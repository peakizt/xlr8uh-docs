Directory structure:
└── vicshann-ghostdbg/
    ├── README.md
    ├── GIT_FETCH.bat
    ├── GhostDbg.sln
    ├── LICENSE
    ├── MAKE_JUNCTIONS.bat
    ├── NOTES.txt
    ├── SET_EVARS.bat
    ├── ZIP_RELEASE.vbs
    ├── DbgTester/
    │   ├── DbgTester.cpp
    │   ├── DbgTester.h
    │   ├── DbgTester.vcxproj
    │   └── DbgTester.vcxproj.filters
    ├── INFO/
    │   ├── RtlDispatchException.txt
    │   ├── SharpOD.txt
    │   └── Vmp3.txt
    ├── InjectLib/
    │   ├── InjectDll.cpp
    │   ├── InjectDll.h
    │   ├── InjectDll.vcxproj
    │   └── InjectDll.vcxproj.filters
    └── XDbgPlugin/
        ├── Resources.rc
        ├── XDbgPlugin.cpp
        ├── XDbgPlugin.h
        ├── XDbgPlugin.vcxproj
        ├── XDbgPlugin.vcxproj.filters
        └── pluginsdk/
            ├── _dbgfunctions.h
            ├── _plugin_types.h
            ├── _plugins.h
            ├── bridgelist.h
            └── bridgemain.h

================================================
File: README.md
================================================

 
<img align="center" hspace="20" src="/GhostBanner.gif">

<p align="center">                 
  <h1 align="center">GhostDbg</h1>
</p> 




================================================
File: GIT_FETCH.bat
================================================
rem 'git_dir' EVAR may be set to specify location of '.git' folder for current console session

set remote_repo="https://github.com/Vicshann/GhostDbg.git"
ECHO remote_repo

set git_local=%~dp0.git

if not defined GITCMMNDIR goto NoBuild

for /f "delims=" %%F in ('dir "%~dp0*.sln" /b /o-n') do set sln_name=%%F
if not defined sln_name goto NoSlnFile
ECHO sln_name

SET  sln_fldr=%sln_name:~0,-4%
ECHO sln_fldr

set git_lfldr=%GITCMMNDIR%\%sln_fldr%
ECHO git_lfldr

rmdir "%git_local%"
if exist "%git_local%" goto GitExist

rmdir "%git_lfldr%"
if exist "%git_lfldr%" (
ECHO "GIT objects is still present in the directory - restoring link"
mklink /J "%git_local%" "%git_lfldr%"
goto Exit
)

mkdir "%git_lfldr%"
mklink /J "%git_local%" "%git_lfldr%"

git init
git fetch %remote_repo%
git pull %remote_repo%

ECHO "Success!"
goto Exit

:NoSlnFile
ECHO "No solution file!"
goto Exit

:GitExist
ECHO "GIT folder already exist and not empty!"
goto Exit

:NoBuild
ECHO "No git object folder EVAR!"

:Exit
pause


================================================
File: GhostDbg.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26228.9
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "InjectDll", "InjectLib\InjectDll.vcxproj", "{5B70EAFD-1442-4542-8DE2-E7E3832E407C}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DbgTester", "DbgTester\DbgTester.vcxproj", "{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}"
	ProjectSection(ProjectDependencies) = postProject
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C} = {5B70EAFD-1442-4542-8DE2-E7E3832E407C}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{5345817A-AD81-40B7-9092-C1B91ACCB779}"
	ProjectSection(SolutionItems) = preProject
		GIT_FETCH.bat = GIT_FETCH.bat
		MAKE_JUNCTIONS.bat = MAKE_JUNCTIONS.bat
		NOTES.txt = NOTES.txt
		Readme.txt = Readme.txt
		INFO\RtlDispatchException.txt = INFO\RtlDispatchException.txt
		SET_EVARS.bat = SET_EVARS.bat
		ZIP_RELEASE.vbs = ZIP_RELEASE.vbs
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "XDbgPlugin", "XDbgPlugin\XDbgPlugin.vcxproj", "{157E494D-21B0-493D-A1F4-A8927CF410BF}"
	ProjectSection(ProjectDependencies) = postProject
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C} = {5B70EAFD-1442-4542-8DE2-E7E3832E407C}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x32 = Debug|x32
		Debug|x64 = Debug|x64
		Release|x32 = Release|x32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C}.Debug|x32.ActiveCfg = Debug|Win32
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C}.Debug|x32.Build.0 = Debug|Win32
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C}.Debug|x64.ActiveCfg = Debug|x64
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C}.Debug|x64.Build.0 = Debug|x64
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C}.Release|x32.ActiveCfg = Release|Win32
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C}.Release|x32.Build.0 = Release|Win32
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C}.Release|x64.ActiveCfg = Release|x64
		{5B70EAFD-1442-4542-8DE2-E7E3832E407C}.Release|x64.Build.0 = Release|x64
		{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}.Debug|x32.ActiveCfg = Debug|Win32
		{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}.Debug|x32.Build.0 = Debug|Win32
		{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}.Debug|x64.ActiveCfg = Debug|x64
		{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}.Debug|x64.Build.0 = Debug|x64
		{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}.Release|x32.ActiveCfg = Release|Win32
		{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}.Release|x32.Build.0 = Release|Win32
		{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}.Release|x64.ActiveCfg = Release|x64
		{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}.Release|x64.Build.0 = Release|x64
		{157E494D-21B0-493D-A1F4-A8927CF410BF}.Debug|x32.ActiveCfg = Debug|Win32
		{157E494D-21B0-493D-A1F4-A8927CF410BF}.Debug|x32.Build.0 = Debug|Win32
		{157E494D-21B0-493D-A1F4-A8927CF410BF}.Debug|x64.ActiveCfg = Debug|x64
		{157E494D-21B0-493D-A1F4-A8927CF410BF}.Debug|x64.Build.0 = Debug|x64
		{157E494D-21B0-493D-A1F4-A8927CF410BF}.Release|x32.ActiveCfg = Release|Win32
		{157E494D-21B0-493D-A1F4-A8927CF410BF}.Release|x32.Build.0 = Release|Win32
		{157E494D-21B0-493D-A1F4-A8927CF410BF}.Release|x64.ActiveCfg = Release|x64
		{157E494D-21B0-493D-A1F4-A8927CF410BF}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A09F2D88-7ED4-420F-81F6-78C43301D906}
	EndGlobalSection
EndGlobal



================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2018 Victor Sheinmann

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: MAKE_JUNCTIONS.bat
================================================
rem DO NOT RUN THIS FROM A NETWORK DRIVE!
rem For a new versions of VisualStudio which place their special files in ".vs" directory
rem Every solution must have an unique name
rem Do not forget to define PRJBUILDDIR and COMMONSRCDIR environment variales
rem Please do not make a copy of the Common folder. Always keep it in one place. 
rem Link each project to it and make a backup with an entire project folder to have a working copy.

if not defined PRJBUILDDIR goto NoBuild
if not defined COMMONSRCDIR goto NoCommon

for /f "delims=" %%F in ('dir "%~dp0*.sln" /b /o-n') do set sln_name=%%F
if not defined sln_name goto NoSlnFile
ECHO sln_name

SET  sln_fldr=%sln_name:~0,-4%
ECHO sln_fldr

set build_dir=%PRJBUILDDIR%\%sln_fldr%
ECHO build_dir

set vs_dir=%PRJBUILDDIR%\.vs
ECHO vs_dir

mkdir %vs_dir%
mkdir %build_dir%

mklink /J ".\.vs" "%vs_dir%"
mklink /J ".\BUILD" "%build_dir%"
mklink /J ".\COMMON" "%COMMONSRCDIR%"

if defined BACKUPSRCDIR (
mklink /J "%BACKUPSRCDIR%\%sln_fldr%" "%~dp0"
)

ECHO "Success!"
goto Exit

:NoSlnFile
ECHO "No solution file!"
goto Exit

:NoCommon
ECHO "No common folder EVAR!"
goto Exit

:NoBuild
ECHO "No build folder EVAR!"

:Exit
pause


================================================
File: NOTES.txt
================================================
//------------------------------------------------------------------------------------
 NtSetInformationObject          // GetHandleInformation?
 NtSetInformationVirtualMemory
 NtSetInformationProcess
 NtSetInformationThread
 NtWaitForAlertByThreadId
 RtlCaptureContext
 NtSetInformationProcess 
 NtQueryObject 
 NtContinue (x86)   / RtlRestoreContext (x64)

 KiRaiseUserExceptionDispatcher


 ETHREAD -> StartAddress ?

 https://www.codeproject.com/Articles/543542/Windows-x-system-service-hooks-and-advanced-debu
 https://www.codeproject.com/Articles/543542/Windows-x64-system-service-hooks-and-advanced-debu

					 
TODO: 
 Unload inject DLL if it was loaded by a debugger and it is going to detach? 
 Intercept Any exception (Optional)
 Start a target as Explorer.exe
 Hardware BP only for an active thread (Last for GetThreadContext?)
 Inject into child processes
 Block constant Thread Suspend/Resume calls by x64Dbg if it is already in DbgEvent handler?
 Kernel exception dispatcher hook(No hook of KiUserExceptionDispatcher and NtContinue) (GhostDrv)
 Make DebugBreak less intrusive (No CreateThread?) (APC?)
 Alternate software BP support?
 Single IPC buffer for all GhostDbg clients (Required for GhostDrv)
 IPC SRW locks
 Enable Config files
 IDA compatibility
 Fix extreme slowness on Windows XP (Sync problem? Fix for GhostDrv)   // https://communities.vmware.com/thread/466749
 GInjer compatibility (Especially WOW64 debugging)
 Wait for attach and ignore events until that (GInjer, requires config)

ISSUES:
 Software breakpoints is very dangerous to set if not all threads are suspended on a Debug Event
 Because of SEH recursion a DBG context protection is not used(Find a way to mark a thread with RefCtr)

//-----------------------------------------------------------------------------------------------------------------
 MSVC compiler will always generate ExceptionDirectory for x64 builds. Need to use CLANG to make InjLib smaller: '/clang:-fno-unwind-tables'
//---------------------------

BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine) --> NTSTATUS RtlWow64GetProcessMachines(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine);

//-----------------------------------------------------------------------------------------------------------------
How DebugActiveProcess works:
  1) Suspends all process` threads
  2) Creates a remote thread at ntdll.dll:DbgUiRemoteBreakin
  3) Suspends all other process` threads again (Including at DbgUiRemoteBreakin)   // Suspend count is 1,2,2,2,...


  ------------------------------------------
  https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread

  Note that while reporting debug events, all threads within the reporting process are frozen. 
  Debuggers are expected to use the SuspendThread and ResumeThread functions to limit the set of threads that can execute within a process. 
  By suspending all threads in a process except for the one reporting a debug event, it is possible to "single step" a single thread. 
  The other threads are not released by a continue operation if they are suspended.

  -----------------------------------------------------------------------
  _chkstk Routine is a helper routine for the C compiler. For x86 compilers, _chkstk Routine is called when the local variables exceed 4K bytes; for x64 compilers it is 8K.

  -------------------------------------
  RtlDispatchException hooking:
  1) Find a call to RtlDispatchException in KiUserExceptionDispatcher
  2) Put a jump to a stub at beginning of RtlDispatchException (Save original instructions)

----------------------------------------------------------------------
BOOL __stdcall RtlIsCurrentThreadAttachExempt()
{
  return NtCurrentTeb()->SameTebFlags & 8 && !(NtCurrentTeb()->SameTebFlags & 0x20);
}
----------------------------------------------------------------------
  __int64 __fastcall Wow64NtCreateThread(_QWORD *a1, unsigned int a2, __int64 a3, __int64 aProcessHandle, __int64 a5, CONTEXT *a6, __int64 a7, char aSuspended)
{
  void *vProcessHandle; // rbp
  struct _OBJECT_ATTRIBUTES *v9; // r15
  unsigned int v10; // er14
  void **v11; // rbx
  __int64 result; // rax
  NTSTATUS vStatus; // edi
  __int16 vMachine; // [rsp+40h] [rbp-538h]
  CONTEXT Dst; // [rsp+50h] [rbp-528h]

  vProcessHandle = (void *)aProcessHandle;
  v9 = (struct _OBJECT_ATTRIBUTES *)a3;
  v10 = a2;
  v11 = (void **)a1;
  if ( !a1 || !a7 || !a6 )return 0xC000000Di64;
  result = RtlWow64GetProcessMachines(aProcessHandle, &vMachine, 0i64);
  if ( (int)result < 0 )return result;    
  if ( vMachine )return 0xC0000022i64;   // ???????????????????????????????                            // Not IMAGE_FILE_MACHINE_UNKNOWN   // IsWow64Process is TRUE    
  memset_0(&Dst, 0, 1232u);
  Dst.Rip = LODWORD(a6->R8);
  Dst.Rcx = LODWORD(a6->Rdi);
  Dst.Rdx = HIDWORD(a6->Rbp);
  Dst.R8 = HIDWORD(a6->R9);
  Dst.ContextFlags = 0x100003;
  vStatus = NtCreateThread(v11, v10, v9, vProcessHandle, (PCLIENT_ID)a5, &Dst, (PINITIAL_TEB)a7, 1u);
  if ( vStatus < 0 )return (unsigned int)vStatus;
  if ( vMachine == 0x14C && (unsigned __int16)RtlWow64GetCurrentMachine() == 0x14C )Wow64pCpuInitializeStartupContext((__int64)vProcessHandle, (__int64)*v11, (__int64)a6);
  if ( !aSuspended )
  {
    vStatus = NtResumeThread(*v11, 0i64);
    if ( vStatus < 0 )
    {
      NtTerminateThread(*v11, 0);
      return (unsigned int)vStatus;
    }
  }
  return 0i64;
}
  ---------------------------------------------------------------------- 



================================================
File: SET_EVARS.bat
================================================

setx /M XDBGNI_TESTFLDR C:\TEST\XDBGNI\ 
setx /M XDBGX64_PATH C:\_TOOLS_\_RCE_\XDBG\GHDBG\x64 
setx /M XDBGX32_PATH C:\_TOOLS_\_RCE_\XDBG\GHDBG\x32

pause

setx /M PRJBUILDDIR C:\_BUILD
setx /M GITCMMNDIR C:\_BUILD\.git
setx /M COMMONSRCDIR C:\_SYNC\COMMONSRC\SimpleCommon

pause


================================================
File: ZIP_RELEASE.vbs
================================================
ArchiveFolder ".\BUILD\foo.zip", ".\BUILD\RELEASE\"

Sub ArchiveFolder (zipFile, sFolder)

    With CreateObject("Scripting.FileSystemObject")
        zipFile = .GetAbsolutePathName(zipFile)
        sFolder = .GetAbsolutePathName(sFolder)

        With .CreateTextFile(zipFile, True)
            .Write Chr(80) & Chr(75) & Chr(5) & Chr(6) & String(18, chr(0))
        End With
    End With

    With CreateObject("Shell.Application")
        .NameSpace(zipFile).CopyHere .NameSpace(sFolder).Items

        Do Until .NameSpace(zipFile).Items.Count = _
                 .NameSpace(sFolder).Items.Count
            WScript.Sleep 1000 
        Loop
    End With

End Sub


================================================
File: DbgTester/DbgTester.cpp
================================================

#include "DbgTester.h"


volatile HINSTANCE hInstance; 
volatile bool BreakWrk = false;

BYTE  DllPath[MAX_PATH];
BYTE  ExePath[MAX_PATH];
BYTE  StartUpDir[MAX_PATH];
//------------------------------------------------------------------------------------------------------------
DWORD WINAPI TstMainThread(LPVOID lpThreadParameter)
{          
 HMODULE hLib = LoadLibraryA((LPSTR)&DllPath);
// HMODULE hLibV = LoadLibraryA("XEDParse.dll");
 while(!BreakWrk)  // Breakpoints test loop
  {
   UINT Len = lstrlenA((LPSTR)&StartUpDir);
   Sleep(500 + (Len & 0x0F));
  }
 return 0;
}
//====================================================================================
void _stdcall SysMain(DWORD UnkArg)
{
 SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOGPFAULTERRORBOX|SEM_NOOPENFILEERRORBOX);	 // Crash silently an error happens
 hInstance = GetModuleHandleA(NULL);
 GetModuleFileNameA(hInstance,(LPSTR)&ExePath,sizeof(ExePath)); 
 lstrcpyA((LPSTR)&StartUpDir, (LPSTR)&ExePath);  
// TrimFilePath((LPSTR)&StartUpDir);     // This causes x64dbg to crash in 'dbghelp.dll!AddressMap::getSectionLength(unsigned long)' while loading DbgTester.pdb
    int slctr = lstrlenA((LPSTR)&StartUpDir);
    while(--slctr >= 0){if((StartUpDir[slctr] == 0x2F)||(StartUpDir[slctr] == 0x5C)){StartUpDir[slctr+1] = 0; break;}}
 lstrcpyA((LPSTR)&DllPath, (LPSTR)&StartUpDir);
 lstrcatA((LPSTR)&DllPath, "injlib.dll");

// CONTEXT ctx;
 HANDLE hThread = CreateThread(NULL,0,&TstMainThread,(PVOID)0x1123344,CREATE_SUSPENDED,NULL);   //   CREATE_SUSPENDED
  ResumeThread(hThread);
// memset(&ctx,0,sizeof(ctx));
// ctx.ContextFlags = CONTEXT_CONTROL|CONTEXT_INTEGER;
// GetThreadContext(hThread, &ctx);

 WaitForSingleObject(hThread,INFINITE);
 CloseHandle(hThread);
 ExitProcess(0);  
}
//---------------------------------------------------------------------------



================================================
File: DbgTester/DbgTester.h
================================================

#pragma once


#define WIN32_LEAN_AND_MEAN             

#include <windows.h>
#include "Utils.h"

//------------------------------------------------------------------------------------------------------------
                       

//------------------------------------------------------------------------------------------------------------



================================================
File: DbgTester/DbgTester.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{9161E0FA-8D9B-4EBE-AAD0-BB0CE1154945}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>TestExe</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>DbgTester</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(XDBGNI_TESTFLDR)</OutDir>
    <IntDir>$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(XDBGNI_TESTFLDR)</OutDir>
    <IntDir>$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(XDBGNI_TESTFLDR)</OutDir>
    <IntDir>$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(XDBGNI_TESTFLDR)</OutDir>
    <IntDir>$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>StdCall</CallingConvention>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <StringPooling>true</StringPooling>
      <MinimalRebuild>false</MinimalRebuild>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalOptions>/permissive %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x32.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <GenerateMapFile>true</GenerateMapFile>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <EntryPointSymbol>SysMain</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <FixedBaseAddress>false</FixedBaseAddress>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <Manifest />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>StdCall</CallingConvention>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <StringPooling>true</StringPooling>
      <MinimalRebuild>false</MinimalRebuild>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <OmitFramePointers>false</OmitFramePointers>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalOptions>/permissive %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x64.lib;runtmchk.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <GenerateMapFile>true</GenerateMapFile>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <EntryPointSymbol>SysMain</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <FixedBaseAddress>false</FixedBaseAddress>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>StdCall</CallingConvention>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalOptions>/permissive %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x32.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <GenerateMapFile>true</GenerateMapFile>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <EntryPointSymbol>SysMain</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <FixedBaseAddress>false</FixedBaseAddress>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalOptions>/nocoffgrpinfo %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <CallingConvention>StdCall</CallingConvention>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalOptions>/permissive %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x64.lib;runtmchk.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <GenerateMapFile>true</GenerateMapFile>
      <MinimumRequiredVersion>5.01</MinimumRequiredVersion>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
      <EntryPointSymbol>SysMain</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <FixedBaseAddress>false</FixedBaseAddress>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalOptions>/nocoffgrpinfo %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\COMMON\Utils.h" />
    <ClInclude Include="DbgTester.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\COMMON\RTL\gcvt.cpp" />
    <ClCompile Include="..\COMMON\Utils.cpp" />
    <ClCompile Include="DbgTester.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: DbgTester/DbgTester.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Common">
      <UniqueIdentifier>{1527f702-8857-49ed-8ad1-74b261e99dd0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DbgTester.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\COMMON\Utils.cpp">
      <Filter>Common</Filter>
    </ClCompile>
    <ClCompile Include="..\COMMON\RTL\gcvt.cpp">
      <Filter>Common</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DbgTester.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\Utils.h">
      <Filter>Common</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


================================================
File: INFO/RtlDispatchException.txt
================================================

// x64
push r15 
push r14
push r13
push r12 
push r11
push r10
push rdi
push rsi  
push rbp 
push rbx   
push rax   <<<< Return val, first on stack
push r9   // In reserve
push r8   // In reserve
push rdx  // In reserve
push rcx  // In reserve
movabs rax,0x0000000000000000                                                                                                                 |
call rax        // With this ret addr stack will be aligned to 16 as required 
test eax, eax   // TRUE to call an original code                                                                                                                                    |
pop rcx
pop rdx
pop r8
pop r9
pop rax
pop rbx 
pop rbp
pop rsi
pop rdi
pop r10
pop r11
pop r12
pop r13
pop r14
pop r15
jnz Code
retn
Code:
Original code

41 57 41 56 41 55 41 54 41 53 41 52 57 56 55 53 50 41 51 41 50 52 51 48 B8 00 00 00 00 00 00 00 00 FF D0 85 C0 59 5A 41 58 41 59 58 5B 5D 5E 5F 41 5A 41 5B 41 5C 41 5D 41 5E 41 5F 75 01 C3
--------------------------------------------------------------------------------------

// x32
push edi                                                                                                   
push esi                                                                                                    
push ebp                                                                                                    
push ebx                                                                                                    
push eax     <<<< Return val, fifth on stack
push edx                                                                                                    
push ecx                                                                                                                                                                                                     
push dword ptr ss:[esp+24]                                                                                  
push dword ptr ss:[esp+24]                                                                                  
call ntdll.775FAC45                                                                                         
test eax,eax                                                                                                
pop eax    // Arg                                                                                                 
pop eax    // Arg                                                                                                  
pop ecx 
pop edx 
pop eax                                                                                                    
pop ebx                                                                                                                                                                                                                                                                                                    
pop ebp                                                                                                    
pop esi                                                                                                 
pop edi                                                                                                    
jne Code                                                                                         
ret 8                                                                                                     
Code:
Original code

57 56 55 52 51 53 50 FF 74 24 24 FF 74 24 24 E8 00 00 00 00 85 C0 58 58 58 5B 59 5A 5D 5E 5F 75 03 C2 08 00





RtlDispatchException
--------------------------------------------------------------------------------------
// Xp
.text:7C92A50E                 mov     edi, edi
.text:7C92A510                 push    ebp
.text:7C92A511                 mov     ebp, esp
.text:7C92A513                 sub     esp, 64h
.text:7C92A516                 push    esi
.text:7C92A517                 push    [ebp+arg_4]
.text:7C92A51A                 mov     esi, [ebp+arg_0]
.text:7C92A51D                 push    esi
.text:7C92A51E                 mov     [ebp+var_1], 0
.text:7C92A522                 call    _RtlCallVectoredExceptionHandlers@8 ; RtlCallVectoredExceptionHandlers(x,x)
.text:7C92A527                 test    al, al
.text:7C92A529                 jnz     loc_7C950002  

.text:7C950002                 mov     [ebp+var_1], 1
.text:7C950006                 jmp     loc_7C92A5E1

.text:7C92A5E1                 mov     al, [ebp+var_1]
.text:7C92A5E4                 pop     esi
.text:7C92A5E5                 leave
.text:7C92A5E6                 retn    8
-------------------------------------------------------------------------------------------------
// Win7 x32
.text:77EDF944                 mov     edi, edi
.text:77EDF946                 push    ebp
.text:77EDF947                 mov     ebp, esp
.text:77EDF949                 sub     esp, 64h
.text:77EDF94C                 push    esi
.text:77EDF94D                 push    [ebp+Context]
.text:77EDF950                 mov     esi, [ebp+ExceptionRecord]
.text:77EDF953                 push    esi
.text:77EDF954                 mov     [ebp+var_1], 0
.text:77EDF958                 call    _RtlCallVectoredExceptionHandlers@8 ; RtlCallVectoredExceptionHandlers(x,x)
.text:77EDF95D                 test    al, al
.text:77EDF95F                 jnz     loc_77F50270

.text:77F50270                 mov     [ebp+var_1], 1
.text:77F50274                 jmp     loc_77EC6049

.text:77EC6049                 push    [ebp+Context]
.text:77EC604C                 push    esi
.text:77EC604D                 call    _RtlCallVectoredContinueHandlers@8 ; RtlCallVectoredContinueHandlers(x,x)
.text:77EC6052                 mov     al, [ebp+var_1]
.text:77EC6055                 pop     esi
.text:77EC6056                 leave
.text:77EC6057                 retn    8
-------------------------------------------------------------------------------------------------
// Win7 x64
.text:0000000078E68E20 FF F3                                   push    rbx
.text:0000000078E68E22 55                                      push    rbp
.text:0000000078E68E23 56                                      push    rsi
.text:0000000078E68E24 57                                      push    rdi
.text:0000000078E68E25 41 54                                   push    r12
.text:0000000078E68E27 41 55                                   push    r13
.text:0000000078E68E29 41 56                                   push    r14
.text:0000000078E68E2B 41 57                                   push    r15
.text:0000000078E68E2D 48 81 EC 98 06 00 00                    sub     rsp, 698h
.text:0000000078E68E34 45 33 C0                                xor     r8d, r8d
.text:0000000078E68E37 48 8B EA                                mov     rbp, rdx
.text:0000000078E68E3A 4C 8B F1                                mov     r14, rcx
.text:0000000078E68E3D E8 4E FE FF FF                          call    RtlpCallVectoredHandlers
.text:0000000078E68E42 84 C0                                   test    al, al
.text:0000000078E68E44 0F 85 86 5E 05 00                       jnz     loc_78EBECD0

.text:0000000078EBECD0 41 B7 01                                mov     r15b, 1
.text:0000000078EBECD3 E9 20 F1 F9 FF                          jmp     loc_78E5DDF8

.text:0000000078E5DDF8 48 8B D5                                mov     rdx, rbp
.text:0000000078E5DDFB 49 8B CE                                mov     rcx, r14
.text:0000000078E5DDFE E8 1D 00 00 00                          call    RtlCallVectoredContinueHandlers
.text:0000000078E5DE03 41 8A C7                                mov     al, r15b
.text:0000000078E5DE06 48 81 C4 98 06 00 00                    add     rsp, 698h
.text:0000000078E5DE0D 41 5F                                   pop     r15
.text:0000000078E5DE0F 41 5E                                   pop     r14
.text:0000000078E5DE11 41 5D                                   pop     r13
.text:0000000078E5DE13 41 5C                                   pop     r12
.text:0000000078E5DE15 5F                                      pop     rdi
.text:0000000078E5DE16 5E                                      pop     rsi
.text:0000000078E5DE17 5D                                      pop     rbp
.text:0000000078E5DE18 5B                                      pop     rbx
.text:0000000078E5DE19 C3                                      retn
-------------------------------------------------------------------------------------------------
// Win10 x64
.text:0000000180013890                 mov     [rsp+18h], rbx
.text:0000000180013895                 push    rbp             ; ^^^^^^^^^ Into CONTEXT!
.text:0000000180013896                 push    rsi
.text:0000000180013897                 push    rdi
.text:0000000180013898                 push    r12
.text:000000018001389A                 push    r13
.text:000000018001389C                 push    r14
.text:000000018001389E                 push    r15
.text:00000001800138A0                 lea     rbp, [rsp-5C0h]
.text:00000001800138A8                 sub     rsp, 6C0h
.text:00000001800138AF                 mov     rax, cs:__security_cookie
.text:00000001800138B6                 xor     rax, rsp
.text:00000001800138B9                 mov     [rbp+5F0h+var_40], rax
.text:00000001800138C0                 mov     rax, gs:60h
.text:00000001800138C9                 xor     r14b, r14b
.text:00000001800138CC                 mov     rbx, rdx
.text:00000001800138CF                 mov     [rsp+6F0h+var_678], rdx
.text:00000001800138D4                 mov     r12, rcx
.text:00000001800138D7                 mov     [rbp+5F0h+var_660], rcx
.text:00000001800138DB                 mov     [rsp+6F0h+var_6B0], r14b
.text:00000001800138E0                 test    dword ptr [rax+0BCh], 800000h
.text:00000001800138EA                 jnz     loc_1800A0B40

.text:00000001800A0B40                 mov     [rsp+6F0h+var_6B0], 1
.text:00000001800A0B45                 call    RtlpLogExceptionDispatch
.text:00000001800A0B4A                 nop
.text:00000001800A0B4B                 jmp     loc_1800138F0

.text:00000001800138F0                 xor     r8d, r8d
.text:00000001800138F3                 mov     rdx, rbx
.text:00000001800138F6                 mov     rcx, r12
.text:00000001800138F9                 call    RtlpCallVectoredHandlers
.text:00000001800138FE                 test    al, al
.text:0000000180013900                 jnz     loc_1800141B8

.text:00000001800141B8                 mov     r14b, 1
.text:00000001800141BB                 jmp     loc_180013C60

.text:0000000180013C60                 mov     r8d, 1
.text:0000000180013C66                 mov     rdx, rbx
.text:0000000180013C69                 mov     rcx, r12
.text:0000000180013C6C                 call    RtlpCallVectoredHandlers
.text:0000000180013C71                 movzx   eax, r14b
.text:0000000180013C75                 mov     rcx, [rbp+5F0h+var_40]
.text:0000000180013C7C                 xor     rcx, rsp        ; StackCookie
.text:0000000180013C7F                 call    __security_check_cookie
.text:0000000180013C84                 mov     rbx, [rsp+6F0h+arg_10]
.text:0000000180013C8C                 add     rsp, 6C0h
.text:0000000180013C93                 pop     r15
.text:0000000180013C95                 pop     r14
.text:0000000180013C97                 pop     r13
.text:0000000180013C99                 pop     r12
.text:0000000180013C9B                 pop     rdi
.text:0000000180013C9C                 pop     rsi
.text:0000000180013C9D                 pop     rbp
.text:0000000180013C9E                 retn
-------------------------------------------------------------------------------------------------
// Win10 x32
.text:4B2DABDD                 mov     edi, edi
.text:4B2DABDF                 push    ebp
.text:4B2DABE0                 mov     ebp, esp
.text:4B2DABE2                 and     esp, 0FFFFFFF8h
.text:4B2DABE5                 sub     esp, 7Ch
.text:4B2DABE8                 mov     eax, ds:___security_cookie
.text:4B2DABED                 xor     eax, esp
.text:4B2DABEF                 mov     [esp+7Ch+var_4], eax
.text:4B2DABF3                 mov     edx, [ebp+Context]
.text:4B2DABF6                 push    ebx
.text:4B2DABF7                 push    esi
.text:4B2DABF8                 mov     esi, [ebp+ExceptionRecord]
.text:4B2DABFB                 xor     ebx, ebx
.text:4B2DABFD                 push    edi
.text:4B2DABFE                 mov     [esp+88h+var_7C], edx
.text:4B2DAC02                 mov     [esp+88h+var_75], bl
.text:4B2DAC06                 mov     ecx, [esi+0Ch]
.text:4B2DAC09                 call    _RtlpIsUserCallTargetBitMapCheckFault@4 ; RtlpIsUserCallTargetBitMapCheckFault(x)
.text:4B2DAC0E                 test    al, al
.text:4B2DAC10                 jnz     loc_4B316849

.text:4B316849                 mov     ecx, [edx+0ACh] ; Address
.text:4B31684F                 call    @RtlpHandleInvalidUserCallTarget@4 ; RtlpHandleInvalidUserCallTarget(x)
.text:4B316854                 call    _RtlpGetUserCallTargetBitMapRet@0 ; RtlpGetUserCallTargetBitMapRet()
.text:4B316859                 mov     edi, [esp+88h+var_7C]
.text:4B31685D                 mov     [edi+0B8h], eax
.text:4B316863                 mov     al, 1
.text:4B316865                 jmp     loc_4B2DAD8A

.text:4B2DAD8A                 mov     ecx, [esp+88h+var_4]
.text:4B2DAD91                 pop     edi
.text:4B2DAD92                 pop     esi
.text:4B2DAD93                 pop     ebx
.text:4B2DAD94                 xor     ecx, esp
.text:4B2DAD96                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text:4B2DAD9B                 mov     esp, ebp
.text:4B2DAD9D                 pop     ebp
.text:4B2DAD9E                 retn    8
-------------------------------------------------------------------------------------------------









================================================
File: INFO/SharpOD.txt
================================================
# Function Description
#### ->Hide PEB (overloaded program is in effect)
    Hide PEB and dispose of the following features
- peb.BeingDebugged & wow64.peb64.BeingDebugged
- peb.NtGlobalFlag & wow64.peb64.NtGlobalFlag
- peb.processHeap.HeapFlags & wow64.peb64.processHeap.HeapFlags
- peb.processHeap.ForceFlags & wow64.peb64.processHeap.ForceFlags
  
#### -> Change Caption (Restart debugger is in effect)
    The function of the powerless spit, IMHO, all the anti-debugging with features are not safe.
    This function is to change the debugger window title, menu name to prevent the primary school's enumeration window and menu detection.

#### -> Hide Process (reloaded program is in effect)
    Hidden process function, only for the process being debugged, in NtQuerySystemInformation broken chain

#### -> Fake ParentProcess (overloaded program is in effect)
    Modify the parent process identifier, the process of debugging The parent process will become explorer.exe. If the pid of explorer.exe is not obtained, the parent process will be changed to 4.

#### -> Drag Attach (Restart debugger is in effect)
    Feel this is the most powerful update, just drag the icon in the upper left corner of the debugger to the target window to attach the process.

#### ->Hook *ZwFunctions (overloaded program is in effect)
    Hook Zw series function
    There are too many things to deal with, the following Nt function

##### NtQuerySystemInformation
- SystemKernelDebuggerInformation
- SystemProcessInformation
- SystemHandleInformation

##### NtClose
- invalid Handle

##### NtQueryInformationProcess
- ProcessBasicInformation
- ProcessDebugPort
- ProcessDebugObjectHandle
- ProcessDebugFlags

##### NtSetInformationThread
- ThreadHideFromDebugger

##### NtDuplicateObject

##### NtQueryObject
- ObjectTypesInformation -> DebugObject

##### NtYieldExecution
- return STATUS_NO_YIELD_PERFORMED

#### -> Remove DebugProvileges (overloaded program is in effect)
    Remove debug permissions for the debug process
    Because the process does not have the SeDebugPrivilege privilege by default, this permission is inherited from the debugger during debugging, so someone can take advantage of this. It is not recommended to open by default

#### -> VMP 3.1(above) (overloaded program is in effect)
    Anti-debugging with VMP3.1 or higher
    VMProtect 3.1 version has a major update. Starting from this version, directly simulate Wow64 to call syscall into the kernel. The 32-bit system also directly calls the privileged instruction systnter to enter the kernel. The query detects ProcessDebugObjectHandle, so there is almost no way to intercept it at the application layer.
    I used a small trick to bypass his detection here.

#### -> Protect Drx (overloaded program is in effect)
    Protect hardware breakpoints
- ZwSetContextThread
- ZwGetContextThread
- KiUserExceptionDispatcher ->
- if Wow64PrepareForException Then -> ntdll64.NtQuery/SetInformationThread
- else //x64mode
- RtlDispatchException
- RtlRestoreContext

#### ->Hook SSDT (Restart debugger is in effect)
    With this feature, all user computers have to go to PatchGuard, which is very cumbersome and will be added when necessary.

#### ->Hook ShadowSSDT (Restart debugger is in effect)
    Ibid.

#### ->Dbg Val1dAccessMask (Restart debugger takes effect)
    This feature is specifically for those who mimic TP anti-debugging to clear your DebugObject->ValidAccessMask, who gives you such a large power to globally clear the debugging object of my machine?
    The phenomenon is that your debugger cannot be dragged into any program.

#### ->bypass ObjectHook (Restart debugger takes effect)
    Bypassing the object hook, this protection is used most on 64-bit systems, and it can filter out the permissions of your open process.
    For example, you can't read and write memory to the target process. Turn this feature on to bypass this protection. But it seems that the PG will be triggered under the WIN10 system.

# [SharpOD x64 v0.6 update]
- Complete rewrite architecture and code, not in conflict with ScyllaHide, PhantOm, and lower level than them.
- Support for all 64-bit systems, not hardcoded with SSDT Index
- Add the top left corner icon to drag additional process features
- Support x32dbg, x64dbg


================================================
File: INFO/Vmp3.txt
================================================
Call IsDebuggerPresent to determine that the return value eax==1 is debugged, and eax==0 is not debugged.

CheckRemoteDebuggerPresent, determine whether the buffer return value is 0 or 1, 1 is debugged, 0 is not debugged.

NtQueryInformationProcess, ProcessInfoClass=0x1E to get the debug handle, to determine whether it is debugged, the debug handle returns 0 and the return value of eax is 0xC0000353

NtSetInformationThread, ThreadInfoClass=0x11, this is not to detect debugging, but to set the debugging information to the debugger, you can directly change 0x11 to 0x3 or other values.

ZwQuerySystemInformation, SystemInfoClass=0x23 (MACRO: SystemKernelDebuggerInformation), the return value is a 2-byte bool value, set to 0.

ZwQuerySystemInformation, SystemInfoClass=0xB (MACRO: SystemModuleInformation), will go through the kernel module, and then judge, the first time is to obtain the buffer length that needs to be stored, the second time is to actually get the information, as long as the buffer is set to 0, Debugging is not detected. As for the location of the buffer, the LocalAlloc application space is used for storage after the first call.

CloseHandle anti-debugging, if it is debugged, then the KiRaiseUserExceptionDispatcher function will be called, go the exception handling process; if it is not debugged, it will not go to the exception process.

Detecting hardware breakpoints is handled by SEH exceptions
First, in the SEH chain, the next software breakpoint for the SEH header of the current module.

Then modify the Dr0, Dr1, Dr2, Dr3, Dr6, Dr7 debug registers to 0.

If it is the GetpRrocessAffinityMask function call when it comes to CALL eax, the anti-debug has passed.

information can be tracked here at VmCall ‘’CALL eax‘’

In addition, after ZwQuerySystemInformation[SystemInformationClass::SystemModuleInformation] gets the list of system modules, the module name and the decrypted strings "sice.sys", "siwvid.sys", "ntice.sys", "iceext.sys", and "syser" .sys" for comparison to complete the test.
The above is the debugger detection bypass of VMP3.0.0-3.2.0


================================================
File: InjectLib/InjectDll.cpp
================================================
/*
  Copyright (c) 2020 Victor Sheinmann, Vicshann@gmail.com

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
  to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
*/

#include "InjectDll.h" 

//#pragma comment(linker,"/MERGE:.rdata=.text")    // .idata can be only there
//#pragma comment(linker,"/MERGE:.data=.text") 
//#pragma comment(linker,"/MERGE:.idata=.text")
//#pragma comment(linker, "/SECTION:.text,EWR")    // .text; .bss; .pdata; .idata; .reloc  // GhostDbg can cut off after BSS (It does imports and relocs and PDATA is unused)
#pragma comment(linker,"/MERGE:.data=.rdata")      // Now: .text; .bss; .rdata; .pdata; .reloc   // rdata will not be writable - fixed manually for a separate DLL release
//#pragma comment(linker,"/MERGE:.text=.rdata")    // Creates .xdata section 
//#pragma comment(linker, "/SECTION:.rdata,WR")    // Any attampt to make it writable will create .xdata section 

#pragma comment(linker,"/ENTRY:DLLMain")
#pragma comment(linker,"/NODEFAULTLIB")
    

// ---------- SETTINGS ------------------
UINT IPCSize = 0x100000;    // 1Mb (Enough when Req-Rsp removed)
//bool HideDllProxy = true;
//bool HideDllProxyDsk = true;
bool SuspWaitAttachLd   = true;        // Suspend and report events before a debugger connected
bool RstDskHiddenProxy  = true;
bool AllowEjectOnDetach = false;
//---------------------------------------
//PHOOK(ProcRtlRestoreContext) HookRtlRestoreContext; 
//PHOOK(ProcKiUserExceptionDispatcher) HookKiUserExceptionDispatcher;
//PHOOK(ProcLdrInitializeThunk) HookLdrInitializeThunk;
//PHOOK(ProcRtlDispatchException) HookRtlDispatchException;
PHOOK(ProcNtUnmapViewOfSection) HookNtUnmapViewOfSection;     
PHOOK(ProcNtMapViewOfSection) HookNtMapViewOfSection;
PHOOK(ProcNtGetContextThread) HookNtGetContextThread;
PHOOK(ProcNtSetContextThread) HookNtSetContextThread;
PHOOK(ProcNtTerminateThread)  HookNtTerminateThread;
PHOOK(ProcNtTerminateProcess) HookNtTerminateProcess;                          
PHOOK(ProcNtContinue) HookNtContinue;

NUNIHK::SHookLdrpInitialize       LdrpInitHook;
NUNIHK::SHookRtlDispatchException ExpDispHook;
DWORD   ModInjFlags = 0;  // If 0 then the module is loaded normally(With loader)   // -1 if the module is hidden or a proxy
//BYTE ProxyEncKey = 0;
//PBYTE ProxyDllCopy = NULL;
//DWORD ProxyDllSize = 0;
NGhDbg::CDbgClient* Dbg = NULL;
HANDLE  hIpcTh      = NULL;
DWORD   MainThId    = 0;
DWORD   LastThID    = -1;
DWORD   LastExcThID = 0;    // Helps to reduce overhead of NtContinue hook

//LPSTR   LibPathName = NULL;     // TODO: Add an option to not use a detectable hooks ("No detectable hooks")

PBYTE   ThisLibBase = NULL;
//SIZE_T  ThisLibSize = 0;

PBYTE   MainExeBase = NULL;
//SIZE_T  MainExeSize = 0;

alignas(16) BYTE ArrDbgClient[sizeof(NGhDbg::CDbgClient)];

wchar_t SysDirPath[MAX_PATH];
wchar_t StartUpDir[MAX_PATH];
wchar_t CfgFilePath[MAX_PATH];
wchar_t WorkFolder[MAX_PATH];
//===========================================================================
/*
 Only a SystemService(sysenter/int2E) type of functions is allowed to be used 
 Can be loaded by: XDbgPlugin, GInjer, A target process somehow
 Injector can load a DLL with LdrLoadDll or as '(HMODULE)Mod->ModuleBase, DLL_REFLECTIVE_LOAD, Mod'
 Ginjer injects from exe`s main thread
*/
// Reflective load:
//     hModule    = Module Base
//     ReasonCall = 15
//     lpReserved = SInjModDesc*  (Can be used to find SBlkDescr*)
//===========================================================================
BOOL APIENTRY DLLMain(HMODULE hModule, DWORD ReasonCall, LPVOID lpReserved)  // ReasonCall and lpReserved is invalid for mfRunUAPC,mfRunRMTH,mfRunThHij
{
#ifdef _HAVE_GINGER
 SModDesc* ModDesc = ModDescFromCurTh();        // NULL if loaded not by GInjer  // NOTE: GInjer uses main thread
 SBlkDesc* BlkDesc = AddrToBlkDesc(ModDesc);
 SLdrDesc* LdrDesc = GetCurLdrDesc(BlkDesc); 
 #else
 void* ModDesc = nullptr;
 #endif
 UINT   RemThFlags = (DWORD)hModule & NInjLdr::RemThModMarker;      // DLLMain has been passed to CreateRemoteThread/APC/ExistingThread (Where is only one argument available)  // Normal HMODULE would be aligned at 0x1000   
 if(RemThFlags || (ReasonCall >= DLL_REFLECTIVE_LOAD))  // NOTE: Variables get read in conditions even if these conditions is skipped   // Either an own thread or APC callback of an existing thread  // ReasonCall may be already outside of stack(Remote Thread)!
  {  
   DWORD InjFlg = (ModDesc && (ReasonCall == DLL_REFLECTIVE_LOAD))?(NInjLdr::mfRunThHij):(((RemThFlags & NInjLdr::RemThModMarker)) << 24);          
   bool NotOwnThread  = (InjFlg & (NInjLdr::mfRunUAPC|NInjLdr::mfRunThHij));
   bool NotReusableTh = ModDesc || NotOwnThread;
   if(InjFlg & NInjLdr::mfRunUAPC)   // Cannot reuse these threads
    {
     //
     // TODO: Prevent multi-entering from different threads when APC or Hijack injection method used
     //
    }
#ifdef _HAVE_GINGER
   if(ModDesc)
    {
     hModule = (HMODULE)NInjLdr::ReflectiveRelocateSelf(hModule, (LdrDesc)?((PVOID)LdrDesc->NtDllBase):(NULL));  // Allocate to a new buffer  // Loaded by GInjer. Current memory block will be deallocated by GInjer. Current thread is App`s main thread or GInjer`s Loader thread                      
#ifdef _DEBUG
     LdrLogInit(ModDesc); 
     LDRLOG("Hello from %p, %08X", hModule, ModDesc->Flags);  // LDRLOG("Hello from %p, %08X: %ls", hModule, ModDesc->Flags, &ModDesc->ModulePath);   // '%ls' will crash if called before the process initioalization (Load before loader)
#endif
    }
 #endif
//     else hModule = (HMODULE)NInjLdr::PEImageInitialize(hModule);      // Relocate in current buffer (Must be large enough)       // Loaded by a Debugger plugin   // What was the reason to do self initialization here????  // It is much harded to debug the pluging when it is self relocates sections
   if(!NotReusableTh)hIpcTh = NtCurrentThread;   // Can be changed later, before Start, if needed   // A reusable injected remote thread  // Assign globals after relocation
   if(ModDesc && !NotOwnThread)MainThId = NtCurrentThreadId();    // Main thread by GInjer
   ReasonCall  = DLL_PROCESS_ATTACH;
   ModInjFlags = InjFlg;   // Injected with
  } 
   else MainThId = NtCurrentThreadId();   // Injected from a Main Thread or loaded normally

 switch(ReasonCall)	    
  {			 
   case DLL_PROCESS_ATTACH:
    {
     wchar_t DllDirPath[MAX_PATH];
     ThisLibBase  = (PBYTE)hModule;
	 MainExeBase  = (PBYTE)NNTDLL::GetModuleBaseLdr(NULL); // GetModuleHandleA(NULL);
//     LibPathName  = (LPSTR)&SysDirPath;
//     ThisLibSize  = GetRealModuleSize(ThisLibBase);
//     MainExeSize  = GetRealModuleSize(MainExeBase);
            
     NNTDLL::GetModuleNameLdr(hModule,DllDirPath,countof(DllDirPath));    //  GetModuleFileNameW((HMODULE)hModule,DllDirPath,countof(DllDirPath));        
//     GetSystemDirectoryW(SysDirPath,countof(SysDirPath));   // Get it from PEB?
     NSTR::StrCnat(SysDirPath, L"\\");
     NSTR::StrCnat(SysDirPath,GetFileName(DllDirPath));
     NNTDLL::GetModuleNameLdr(MainExeBase,StartUpDir,countof(StartUpDir));    //  GetModuleFileNameW((HMODULE)MainExeBase,StartUpDir,countof(StartUpDir));        
        
	 NSTR::StrCopy(WorkFolder, StartUpDir);
     TrimFilePath(WorkFolder);
//     NSTR::StrCnat((LPSTR)&WorkFolder,".LOGS\\");
#ifndef NOLOG
     NSTR::StrCopy(LogFilePath, WorkFolder);
	 NSTR::StrCnat(LogFilePath, GetFileName(StartUpDir));
     NSTR::StrCnat(LogFilePath, ctENCSA(LOGFILE));
#endif
     NSTR::StrCopy(CfgFilePath, WorkFolder);
     NSTR::StrCnat(CfgFilePath, GetFileName(StartUpDir));
     NSTR::StrCnat(CfgFilePath, ctENCSA(CFGFILE));	

//     CreateDirectoryPath(WorkFolder);
     LoadConfiguration();
	 DBGMSG("Starting up... (Time=%016X), Owner='%ls'", SysTimeToTime64(NNTDLL::GetSystemTime()), &StartUpDir);
	 DBGMSG("RemThFlags=%08X, hIpcTh=%p, ModDesc=%p, hModule=%p, lpReserved=%p, ModInjFlags=%08X, MainThId=%u", RemThFlags, hIpcTh, ModDesc, hModule, lpReserved, ModInjFlags, MainThId);
     TrimFilePath(StartUpDir);
     DBGMSG("WorkFolder: %ls", &WorkFolder);
     DBGMSG("StartUpDir: %ls", &StartUpDir);
     DBGMSG("SysDirPath: %ls", &SysDirPath);

/*     {
      NTSTATUS stat = NGhDbg::CDbgClient::CreateIpcThread(&hIpcTh, NULL, TRUE);   // <<<<<<<<< TEST !!!!!!!!!!!!
     }  */
/*     BOOL dres = true;
     if(!ModInjected && HideDllProxy)    // NOTE: NO MORE DLL PROXY NEEDED
      {
       PVOID EntryPT = NULL;
       PVOID NewBase = NULL;
       hIpcTh = CreateThread(NULL,0,&NGhDbg::CDbgClient::IPCQueueThread,NULL,CREATE_SUSPENDED,NULL);   // Some anticheats prevent creation of threads outside of any module
       if(NInjLdr::HideSelfProxyDll(hModule, GetModuleHandleA(ctENCSA("ntdll.dll")), (LPSTR)&SysDirPath, &NewBase, &EntryPT) > 0)   // Are imports from our proxy DLL is already resolved by loader at this point?
        {
         DBGMSG("Calling EP of a real DLL: Base=%p, EP=%p",hModule,EntryPT);
         dres = ((decltype(DLLMain)*)EntryPT)(hModule, ReasonCall, lpReserved);   // Pass DLL_PROCESS_ATTACH notification
         hModule = (HMODULE)NewBase;
         if(HideDllProxyDsk && DllDirPath[0])
          {
           DBGMSG("Hiding from disk...");
           if(RstDskHiddenProxy)
            {
             ProxyEncKey = (GetTickCount() >> 3) | 0x80;
             HANDLE hFile = CreateFileA((LPSTR)&DllDirPath,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
             if(hFile != INVALID_HANDLE_VALUE)
              {
               DWORD Result = 0;
               ProxyDllSize = GetFileSize(hFile,NULL);
               ProxyDllCopy = (PBYTE)VirtualAlloc(NULL,ProxyDllSize+MAX_PATH,MEM_COMMIT,PAGE_EXECUTE_READWRITE);  
               if(!ProxyDllSize || !ProxyDllCopy || !ReadFile(hFile,ProxyDllCopy,ProxyDllSize,&Result,NULL) || !Result){VirtualFree(ProxyDllCopy,0,MEM_RELEASE); ProxyDllCopy=NULL;}
               CloseHandle(hFile);
               ProxyDllSize = Result;
               memcpy(&ProxyDllCopy[ProxyDllSize],&DllDirPath,MAX_PATH);
               for(UINT ctr=0,total=ProxyDllSize+MAX_PATH;ctr < total;ctr++)ProxyDllCopy[ctr] = EncryptByteWithCtr(ProxyDllCopy[ctr], ProxyEncKey, ctr);             
              }
             if(ProxyDllCopy)      
              {
               HookNtTerminateProcess.SetHook("NtTerminateProcess","ntdll.dll");
              }
            }
           DeleteFileA((LPSTR)&DllDirPath);     // It is no longer mapped
           DBGMSG("Done hiding from disk!");
          }
        }
       DBGMSG("Done hiding!");
      } */
     bool res = InitApplication(); 
     if(ModInjFlags & NInjLdr::mfRunRMTH){DBGMSG("Terminating injected thread(this): %u", NtCurrentThreadId()); NtTerminateThread(NtCurrentThread,0);}     // Stack frame may be incorrect
     return res; 
    }
     break;									
   case DLL_THREAD_ATTACH:
     if(Dbg && Dbg->IsActive())Dbg->TryAddCurrThread();  //Dbg->Report_CREATE_THREAD_DEBUG_EVENT(NtCurrentThreadId());     // For a simple testing
     break; 
   case DLL_THREAD_DETACH:
     if(Dbg && Dbg->IsActive())Dbg->Report_EXIT_THREAD_DEBUG_EVENT(NtCurrentTeb(),0);     // For a simple testing
     break;
   case DLL_PROCESS_DETACH: 
     if(Dbg && Dbg->IsActive())Dbg->Report_EXIT_PROCESS_DEBUG_EVENT(NtCurrentTeb(),0);      // For a simple testing
     UnInitApplication();     
	 break;

   default : return false;  
  }
 return true;
}
//====================================================================================
// TODO: Store configs and logs in a debugger`s directory(receive a path?)
void _stdcall LoadConfiguration(void)   // Avoid any specific file access here for now
{ 
#ifdef _DEBUG
   LogMode = lmFile;
   // NSTR::StrCopy(LogFilePath, "C:\\TEST\\_LogMy.txt");
#endif

/* CJSonItem Root;
 CMiniStr  str;
 str.FromFile(CfgFilePath);
 bool BinFmt = (str.Length())?(CJSonItem::IsBinaryEncrypted(str.c_data()) >= 0):(0);
 DBGMSG("Loading config(Bin=%u): %ls", BinFmt, &CfgFilePath);
 if(str.Length())Root.FromString(str);
 CJSonItem* Params = EnsureJsnParam(jsObject, "Parameters", &Root);  
 LogMode       = EnsureJsnParam((int)LogMode,       "LogMode",       Params)->GetValInt();     // lmCons;//
 IPCSize       = EnsureJsnParam(IPCSize,            "IPCSize",       Params)->GetValInt(); 
 SuspWaitAttachLd = EnsureJsnParam(SuspWaitAttachLd,     "SuspWaitAttachLd",    Params)->GetValBol(); 
 //HideDllProxy  = EnsureJsnParam(HideDllProxy,         "HideDllProxy",    Params)->GetValBol(); 
 //HideDllProxyDsk = EnsureJsnParam(HideDllProxyDsk,         "HideDllProxyDsk",    Params)->GetValBol(); 
 AllowEjectOnDetach = EnsureJsnParam(AllowEjectOnDetach,         "AllowEjectOnDetach",    Params)->GetValBol();  
// if(LogMode & lmCons){AllocConsole();}                                      // SetWinConsoleSizes(1000, 500, 1000, 500);

 CJSonItem* DbgParams = EnsureJsnParam(jsObject, "DbgClient", &Root);   
 if(Dbg)
  {
   Dbg->HideDbgState = EnsureJsnParam(Dbg->HideDbgState,        "HideDbgState",   DbgParams)->GetValBol(); 
   Dbg->AllowPrTerm  = EnsureJsnParam(Dbg->AllowPrTerm,         "AllowPrTerm",    DbgParams)->GetValBol(); 
   Dbg->AllowThTerm  = EnsureJsnParam(Dbg->AllowThTerm,         "AllowThTerm",    DbgParams)->GetValBol(); 
   Dbg->OnlyOwnSwBP  = EnsureJsnParam(Dbg->OnlyOwnSwBP,         "OnlyOwnSwBP",    DbgParams)->GetValBol(); 
   Dbg->OnlyOwnHwBP  = EnsureJsnParam(Dbg->OnlyOwnHwBP,         "OnlyOwnHwBP",    DbgParams)->GetValBol(); 
   Dbg->OnlyOwnTF    = EnsureJsnParam(Dbg->OnlyOwnTF,           "OnlyOwnTF",      DbgParams)->GetValBol(); 
   Dbg->SwBpVal      = EnsureJsnParam((UINT)Dbg->SwBpVal,       "SwBpVal",        DbgParams)->GetValBol(); 
  }
 DBGMSG("Saving config(Bin=%u): %ls", BinFmt, &CfgFilePath);
 str.Clear();
 if(BinFmt)Root.ToBinary(str,true);
 Root.ToString(str,true);
 str.ToFile(CfgFilePath);  */
 DBGMSG("Exit");
}
//------------------------------------------------------------------------------------
void _stdcall SaveConfiguration(int BinFmt)
{
/* CJSonItem Root;
 CMiniStr  str;
 str.FromFile(CfgFilePath);
 bool VBinFmt = (str.Length() || (BinFmt < 0))?(CJSonItem::IsBinaryEncrypted(str.c_data()) >= 0):(BinFmt > 0);
 DBGMSG("Loading config(Bin=%u): %ls", VBinFmt, &CfgFilePath);
 if(str.Length())Root.FromString(str);
 CJSonItem* Params = EnsureJsnParam(jsObject, "Parameters", &Root);  
 LogMode       = SetJsnParamValue((int)LogMode,       "LogMode",       Params)->GetValInt();
 IPCSize       = SetJsnParamValue(IPCSize,            "IPCSize",       Params)->GetValInt();  
 SuspWaitAttachLd  = SetJsnParamValue(SuspWaitAttachLd,   "SuspWaitAttachLd",    Params)->GetValBol(); 
 //HideDllProxy       = SetJsnParamValue(HideDllProxy,         "HideDllProxy",    Params)->GetValBol(); 
 //HideDllProxyDsk       = SetJsnParamValue(HideDllProxyDsk,         "HideDllProxyDsk",    Params)->GetValBol(); 
 AllowEjectOnDetach       = SetJsnParamValue(AllowEjectOnDetach,         "AllowEjectOnDetach",    Params)->GetValBol();   
     
 CJSonItem* DbgParams = EnsureJsnParam(jsObject, "DbgClient", &Root);   
 if(Dbg)
  {
   SetJsnParamValue(Dbg->HideDbgState,        "HideDbgState",   DbgParams)->GetValBol(); 
   SetJsnParamValue(Dbg->AllowPrTerm,         "AllowPrTerm",    DbgParams)->GetValBol(); 
   SetJsnParamValue(Dbg->AllowThTerm,         "AllowThTerm",    DbgParams)->GetValBol(); 
   SetJsnParamValue(Dbg->OnlyOwnSwBP,         "OnlyOwnSwBP",    DbgParams)->GetValBol(); 
   SetJsnParamValue(Dbg->OnlyOwnHwBP,         "OnlyOwnHwBP",    DbgParams)->GetValBol(); 
   SetJsnParamValue(Dbg->OnlyOwnTF,           "OnlyOwnTF",      DbgParams)->GetValBol(); 
   SetJsnParamValue((UINT)Dbg->SwBpVal,       "SwBpVal",        DbgParams)->GetValBol(); 
  }
 DBGMSG("Saving config(Bin=%u): %ls", BinFmt, &CfgFilePath);
 str.Clear();
 if(VBinFmt)Root.ToBinary(str,true);
 Root.ToString(str,true);
 str.ToFile(CfgFilePath);   */
}
//------------------------------------------------------------------------------------
bool _stdcall InitApplication(void)
{
 DBGMSG("Enter");
 if(NGhDbg::CDbgClient::IsExistForID(NtCurrentProcessId())){DBGMSG("Already injected!"); return false;}

/*#ifdef _AMD64_
 HookRtlRestoreContext.SetHook("RtlRestoreContext","ntdll.dll");     // NtContinue
#endif
 HookKiUserExceptionDispatcher.SetHook("KiUserExceptionDispatcher","ntdll.dll");    
 HookLdrInitializeThunk.SetHook("LdrInitializeThunk","ntdll.dll");     */

 Dbg = new ((void*)&ArrDbgClient) NGhDbg::CDbgClient(ThisLibBase);   // Just call the constructor on ArrDbgClient
 Dbg->UsrReqCallback = &DbgUsrReqCallback;
////////// LoadConfiguration();
 DBGMSG("IPC created: IPCSize=%u",IPCSize);
 PVOID pNtDll = NPEFMT::GetNtDllBaseFast(); 
 DBGMSG("NtDllBase: %p",pNtDll);
 HookNtMapViewOfSection.SetHook(NPEFMT::GetProcAddr(pNtDll, ctENCSA("NtMapViewOfSection")));         // For DLLs list
 HookNtUnmapViewOfSection.SetHook(NPEFMT::GetProcAddr(pNtDll, ctENCSA("NtUnmapViewOfSection")));     // For DLLs list
 HookNtGetContextThread.SetHook(NPEFMT::GetProcAddr(pNtDll, ctENCSA("NtGetContextThread")));         // For DRx hiding
 HookNtSetContextThread.SetHook(NPEFMT::GetProcAddr(pNtDll, ctENCSA("NtSetContextThread")));         // For DRx hiding
 HookNtTerminateThread.SetHook(NPEFMT::GetProcAddr(pNtDll, ctENCSA("NtTerminateThread")));           // For Thread list update
 HookNtTerminateProcess.SetHook(NPEFMT::GetProcAddr(pNtDll, ctENCSA("NtTerminateProcess")));         // Importand for latest Windows 10 bugs
 HookNtContinue.SetHook(NPEFMT::GetProcAddr(pNtDll, ctENCSA("NtContinue")));                         // For Thread list update   // TODO: Replace with LdrInitializeThunk hook
 ExpDispHook.SetHook(ProcExpDispBefore, ProcExpDispAfter);                          // Debugger core function
 LdrpInitHook.SetHook(ProcLdrpInitialize);                                          // Optional: HookNtContinue can do the job but threads will be reported after initialization
 DBGMSG("Hooks set: hIpcTh=%p, MainThId=%u",hIpcTh, MainThId);  
 Dbg->Start(IPCSize, hIpcTh, NULL, MainThId, (hIpcTh != NtCurrentThread)?NtCurrentThreadId():0);     // Start it from DLL Main to avoid of similair DLL being loaded again    // Exclude current temporary thread (GInjer)
 DBGMSG("IPC started");
 return true;
}                                               
//------------------------------------------------------------------------------------
void _stdcall UnInitApplication(void)
{   
 DBGMSG("Enter");
 if(Dbg)Dbg->~CDbgClient();   //  delete(Dbg);  // Compiler will ALWAYS put an unused call to operator DELETE here if called 'Dbg->~CDbgClient()' in Release build if not specified '/MTd'(Multi-Threaded Debug) but it will define '_DEBUG to 1'!
 DBGMSG("IPC destroyed");
 HookNtContinue.Remove();
 HookNtTerminateThread.Remove();
 HookNtTerminateProcess.Remove();
 HookNtUnmapViewOfSection.Remove();
 HookNtMapViewOfSection.Remove(); 
 HookNtSetContextThread.Remove();
 HookNtGetContextThread.Remove();
 LdrpInitHook.Remove();
 ExpDispHook.Remove();
 DBGMSG("Hooks removed");
}
//------------------------------------------------------------------------------------
int _fastcall DbgUsrReqCallback(NShMem::CMessageIPC::SMsgHdr* Req, PVOID ArgA, UINT ArgB)
{
 if(Req->MsgID == NGhDbg::miDbgGetConfigs)
  {
   NShMem::CArgPack<>* apo = (NShMem::CArgPack<>*)ArgA;   
//   apo->PushArgEx(HideDllProxy, "Hide Proxy DLL (After Restart)", NGhDbg::CDbgClient::MakeCfgItemID(++ArgB,NGhDbg::dtBool));  
//   apo->PushArgEx(HideDllProxyDsk, "Hide Proxy DLL on Disk (After Restart)", NGhDbg::CDbgClient::MakeCfgItemID(++ArgB,GhDbg::dtBool));  
   if(!ModInjFlags)apo->PushArgEx(AllowEjectOnDetach, ctENCSA("Allow Eject On Detach"), NGhDbg::CDbgClient::MakeCfgItemID(++ArgB,NGhDbg::dtBool));    
   if(!ModInjFlags){bool Nons = false; apo->PushArgEx(Nons, ctENCSA("Eject"), NGhDbg::CDbgClient::MakeCfgItemID(++ArgB,NGhDbg::dtBool));}    
   return ArgB;
  }
 if(Req->MsgID == NGhDbg::miDbgSetConfigs)
  {
   UINT CfgIdx = 0;
   UINT Type   = NGhDbg::CDbgClient::ReadCfgItemID(ArgB, &CfgIdx);
   if(ArgA)
    {
     switch(CfgIdx)                            // New Process Injection
      {  
//       case 1:
//         HideDllProxy = *(bool*)ArgA;
//        break;
//       case 2:
//         HideDllProxyDsk = *(bool*)ArgA;
//        break;
       case 1:
         AllowEjectOnDetach = *(bool*)ArgA;
        break;
       case 2:  
         if(!ModInjFlags)
          {
           DBGMSG("Ejecting by user!");
           UnInitApplication();
           DBGMSG("Uninit done. Unmapping...");
           NtTerminateThread(NtCurrentThread, 0);       //// NInjLdr::UnmapAndTerminateSelf(ThisLibBase);  // TODO: Self unmap or deallocate        
          }
        break;
      }
    }
   SaveConfiguration();
   return 0;
  }
 if(Req->MsgID == NGhDbg::miDbgDetachNtfy)
  {
   if(AllowEjectOnDetach && !ModInjFlags)
    {
     DBGMSG("Ejecting on Detach!");
     UnInitApplication();
     DBGMSG("Uninit done. Unmapping...");
     NtTerminateThread(NtCurrentThread, 0);   //// NInjLdr::UnmapAndTerminateSelf(ThisLibBase);    // TODO: Self unmap or deallocate
    }
  }
 return 0;
}
//====================================================================================
//                           Debugger support
//------------------------------------------------------------------------------------
// x32:  [ESP]   = EXCEPTION_RECORD*    // Get it with '_ReturnAddress()'
//       [ESP+4] = CONTEXT*
//
// x64:  CONTEXT           // sizeof(CONTEXT) is 0x04E8  // Size of this block is 0x04F0 (On Win7 and Win10 x64) (Aligned to 16?)
//       EXCEPTION_RECORD
//
/*__declspec(noreturn) void _fastcall ProcKiUserExceptionDispatcher(void)  
{
 PBYTE FramePtr = (PBYTE)_AddressOfReturnAddress();   // No return address on stack    // Must match value of ESP on enter to this function
#ifdef _AMD64_
 PCONTEXT Context = (PCONTEXT)FramePtr;
 PEXCEPTION_RECORD ExceptionRecord = (PEXCEPTION_RECORD)&FramePtr[0x4F0];       // AlignFrwd(sizeof(CONTEXT),16)]  ??????????????????????????
#else
 PCONTEXT Context = (PCONTEXT)((PVOID*)FramePtr)[1];
 PEXCEPTION_RECORD ExceptionRecord = (PEXCEPTION_RECORD)((PVOID*)FramePtr)[0];
#endif 
 //
 HookKiUserExceptionDispatcher.OrigProc();     // Must be tail optimized - Requires optimization to be enabled (O1,O2,Ox)
}
//------------------------------------------------------------------------------------
__declspec(noreturn) VOID NTAPI ProcRtlRestoreContext(PCONTEXT ContextRecord, PEXCEPTION_RECORD ExceptionRecord)
{                    
 if(Dbg && Dbg->IsActive())Dbg->DebugThreadLoad(NtCurrentThreadId(), ContextRecord);
 HookRtlRestoreContext.OrigProc(ContextRecord, ExceptionRecord);   
} 
//------------------------------------------------------------------------------------
void NTAPI ProcLdrInitializeThunk(PVOID ArgA, PVOID ArgB, PVOID ArgC, PVOID ArgD)
{
 if(Dbg && Dbg->IsActive())Dbg->GetThread(NtCurrentThreadId());      
 HookLdrInitializeThunk.OrigProc(ArgA, ArgB, ArgC, ArgD);     // Must be tail optimized - Requires optimization to be enabled (O1,O2,Ox)
}  */
//------------------------------------------------------------------------------------
void _stdcall ProcLdrpInitialize(volatile PCONTEXT Ctx, volatile PVOID NtDllBase)
{
 DBGMSG("RetAddr=%p, Ctx=%p, NtDllBase=%p",_ReturnAddress(),Ctx,NtDllBase); 
 if(Dbg && Dbg->IsActive() && (SuspWaitAttachLd || Dbg->IsDbgAttached())){LastThID = NtCurrentThreadId(); Dbg->TryAddCurrThread();}   // LastThID prevents TryAddCurrThread from ProcNtContinue
}
//------------------------------------------------------------------------------------
/* x64
RSP+00 = RetAddr
RSP+08 = RCX
RSP+10 = RDX
RSP+18 = R8
RSP+20 = R9

      mov     rcx, rsp
      add     rcx, 4F0h       ; EXCEPTION_RECORD ExceptionRecord
      mov     rdx, rsp        ; PCONTEXT ContextRecord
      call    RtlDispatchException     // Reserved space for 4 arguments is in beginning of CONTEXT on x64!
// Can`t hook it as usual. Too many dirty tricks are used with SEH, VEH and stack unwinding 
// It may be called recursievly with RtlRaiseStatus
*/                                                                                    
bool _cdecl ProcExpDispBefore(volatile PVOID ArgA, volatile PVOID ArgB, volatile PVOID ArgC, volatile PVOID ArgD, volatile PVOID RetVal)
{
// DBGMSG("Code=%08X, Addr=%p, FCtx=%08X",((PEXCEPTION_RECORD)ArgA)->ExceptionCode, ((PEXCEPTION_RECORD)ArgA)->ExceptionAddress, ((PCONTEXT)ArgB)->ContextFlags);     
 DWORD ThID = LastExcThID = NtCurrentThreadId();
 if(!Dbg || !Dbg->IsActive() || Dbg->IsDbgThreadID(ThID) || !(SuspWaitAttachLd || Dbg->IsDbgAttached()))return true;
 if(Dbg->HandleException(ThID, (PEXCEPTION_RECORD)ArgA, (PCONTEXT)ArgB)){RetVal = (PVOID)TRUE; /*DBGMSG("Handled!");*/ return false;}    // Handled by a debugger
 if(!Dbg->HideDbgState)return true;

// CONTEXT ForgedCtx;      // No debugger context hiding for now :(                      // Can it be detected that this is a copy of original CONTEXT and have a different address on stack?
// memcpy(&ForgedCtx,ContextRecord,sizeof(CONTEXT));
// Dbg->DebugThreadLoad(ThID, &ForgedCtx);       // Load any previous DRx modifications from internal buffer     
// BOOLEAN res = HookRtlDispatchException.OrigProc(ExceptionRecord, &ForgedCtx);
 return true;
}
//------------------------------------------------------------------------------------
bool _cdecl ProcExpDispAfter(volatile PVOID ArgA, volatile PVOID ArgB, volatile PVOID ArgC, volatile PVOID ArgD, volatile PVOID RetVal)
{
// DBGMSG("Exiting!");      
// Dbg->DebugThreadSave(ThID, &ForgedCtx);  // Save any modifications to DRx in a separate struct    // NOTE: It is rare that a AntiDebug check will use an exception handlers to check DRx?
// Dbg->DebugRstExcContext(ContextRecord, &ForgedCtx);
 return true;
}
//------------------------------------------------------------------------------------
// SEC_FILE             0x0800000     
// SEC_IMAGE            0x1000000    // Use NtQuerySection to verify the section is SEC_IMAGE ?
// SEC_PROTECTED_IMAGE  0x2000000  
//
// Normal Dll map: AllocationType=00800000[MEM_ROTATE], Win32Protect=00000004[PAGE_READWRITE] (PAGE_EXECUTE_WRITECOPY for .NET)   // Win10
//
// WinXPx32: ZwMapViewOfSection(v88, -1, (int)&v89, 0, 0, 0, (int)&v86, 1, 0, 4);
// Win7x64:  ZwMapViewOfSection(v9, -1i64, v13, 0i64, 0i64, 0i64, v12, 1, v10, 4);
//
NTSTATUS NTAPI ProcNtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Win32Protect)    // NOTE: A detectable hook!
{ 
// static const DWORD ProtMsk = /*PAGE_READONLY|*/PAGE_READWRITE|PAGE_WRITECOPY|PAGE_EXECUTE_READ|PAGE_EXECUTE_READWRITE|PAGE_EXECUTE_WRITECOPY;   // (Win32Protect & ProtMsk)  // NOTE: .NET (With Tnemida?) uses PAGE_EXECUTE_WRITECOPY (Maps the same module several times)   // I.E. rpcss.dll is mapped with PAGE_READONLY or just read by someone (Protection may be changed later)
         
 NTSTATUS res = HookNtMapViewOfSection.OrigProc(SectionHandle,ProcessHandle,BaseAddress,ZeroBits,CommitSize,SectionOffset,ViewSize,InheritDisposition,AllocationType,Win32Protect);    // May return STATUS_IMAGE_NOT_AT_BASE or STATUS_IMAGE_MACHINE_TYPE_MISMATCH (.NET)

 if((res >= 0) && BaseAddress && *BaseAddress && ViewSize && *ViewSize && (!SectionOffset || !SectionOffset->QuadPart))     // NOTE: DllLoader does not set SectionOffset for now in any version of Windows
  {  
   bool IsMappedPE = false;
   SIZE_T MemLen = NNTDLL::IsMemAvailable(*BaseAddress, &IsMappedPE);   // Ignore anything but real PE image mappings (Which still may be not properly initialized) 
   if(IsMappedPE && MemLen && NNTDLL::IsCurrentProcess(ProcessHandle))
   {                                                 
     DBGMSG("Module: Status=%08X, SectionHandle=%p, BaseAddress=%p, SectionOffset=%p, ViewSize=%08X, AllocationType=%08X, Win32Protect=%08X",res,SectionHandle,*BaseAddress,SectionOffset,*ViewSize,AllocationType,Win32Protect);     
     if(Dbg && Dbg->IsActive() /*(Win32Protect & ProtMsk)*/ && (SuspWaitAttachLd || Dbg->IsDbgAttached()) && NPEFMT::IsValidPEHeaderBlk(*BaseAddress, MemLen))   // <<< Duplicate mapping causes BPs to be set again and never removed if this module is already loaded(If this is not caused by LdrLoadDll)!  // New .NET uses PAGE_READONLY
      {
       Dbg->Report_LOAD_DLL_DEBUG_INFO(NtCurrentTeb(), *BaseAddress);  // NOTE: This is done before PE configuration by LdrLoadDll  // Events:TLS Callbacks must be disabled or xg4dbg will crash in 'cbLoadDll{ auto modInfo = ModInfoFromAddr(duint(base));}' (because it won`t check for NULL) if this mapping will be unmapped too soon
      }
    }
  } 
   else {DBGMSG("XMapping: Status=%08X, BaseAddress=%p, SectionOffset=%p, ViewSize=%08X, AllocationType=%08X, Win32Protect=%08X",res,*BaseAddress,SectionOffset,*ViewSize,AllocationType,Win32Protect);}
//   else {DBGMSG("Status=%08X, SectionHandle=%p, ViewSize=%08X, AllocationType=%08X, Win32Protect=%08X",res,SectionHandle,ViewSize,AllocationType,Win32Protect);}
 return res;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtUnmapViewOfSection(HANDLE ProcessHandle, PVOID BaseAddress)   // NOTE: A detectable hook!
{
 bool IsMappedPE = false;
 SIZE_T MemLen = NNTDLL::IsMemAvailable(BaseAddress, &IsMappedPE);   // Ignore anything but real PE image mappings (Which still may be not properly initialized)
 if(NNTDLL::IsCurrentProcess(ProcessHandle) && IsMappedPE && NPEFMT::IsValidPEHeaderBlk(BaseAddress, MemLen))
  {
   DBGMSG("BaseAddress=%p",BaseAddress);    
   if(Dbg && Dbg->IsActive() && (SuspWaitAttachLd || Dbg->IsDbgAttached()) && Dbg->IsOtherConnections())Dbg->Report_UNLOAD_DLL_DEBUG_EVENT(NtCurrentTeb(), BaseAddress); 
  }                                            
 return HookNtUnmapViewOfSection.OrigProc(ProcessHandle,BaseAddress);
}
//------------------------------------------------------------------------------------
// Called at start of a thread(After initialization) and at return from APC/Exception
// Protect CONTEXT here? Can be used separately from any kernel callback?  // Is someone using it for current thread`s CONTEXT modification(DRx corruption)?
// On Win10 x64 it is called by RtlRestoreContext for normal exceptions but it is not used on Win7 x64  
// On x32 it is called from LdrInitializeThunk when a new thread created (User mode thread`s entry point) 
// LdrInitializeThunk exits with NtContinue
// Hooking LdrInitializeThunk is hard
//
NTSTATUS NTAPI ProcNtContinue(PCONTEXT ContextRecord, BOOLEAN TestAlert)   // NOTE: A detectable hook!     // NOTE: Too much overhead of exception processing with this(Twice 'GetThread' on breakpoints)
{
 DWORD CurrThID = NtCurrentThreadId();
 if(Dbg && (CurrThID != LastThID) && (CurrThID != LastExcThID) && Dbg->IsActive() && (SuspWaitAttachLd || Dbg->IsDbgAttached())){LastThID=CurrThID; Dbg->TryAddCurrThread();}      // Report this thread if it is not in list yet
 return HookNtContinue.OrigProc(ContextRecord, TestAlert);   // Will not return
}
//------------------------------------------------------------------------------------
// ProcessHandle is NULL then terminates all threads, except a current one 
// RtlExitUserProcess: NtTerminateProcess(NULL), NtTerminateProcess(NtCurrentProcess)
// On Win 10 (2019) some suspended threads won`t be terminated!
//   Some race condition with NtSuspendThread and NtTerminateProcess when called from different threads at almost same time? 
//   And they will be suspended when reporting i.e. DLL_UNLOAD, but GhostDbg thread already dead and can`t unfreeze these threads
// Could be a useful feature of NtSuspendProcess ;)
NTSTATUS NTAPI ProcNtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus)  
{
 DBGMSG("ProcessHandle=%p, ExitStatus=%08X",ProcessHandle,ExitStatus); 
/* if(RstDskHiddenProxy && ProxyDllCopy)   // Restore the Proxy Dll on disk
  {   
   BYTE DllPath[MAX_PATH];
   for(UINT ctr=0,total=ProxyDllSize+MAX_PATH;ctr < total;ctr++)ProxyDllCopy[ctr] = DecryptByteWithCtr(ProxyDllCopy[ctr], ProxyEncKey, ctr);
   memcpy(&DllPath,&ProxyDllCopy[ProxyDllSize],MAX_PATH);
   HANDLE hFile = CreateFileA((LPSTR)&DllPath,GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
   if(hFile != INVALID_HANDLE_VALUE)
    {
     DWORD Result = 0;
     WriteFile(hFile,ProxyDllCopy,ProxyDllSize,&Result,NULL);
     CloseHandle(hFile);
     VirtualFree(ProxyDllCopy,0,MEM_RELEASE); 
     ProxyDllCopy = NULL;
     DBGMSG("ProxyDll Restored: %s", (LPSTR)&DllPath);
    }
  } */
 if(Dbg && Dbg->IsActive() && (!ProcessHandle || (ProcessHandle == NtCurrentProcess)) && (SuspWaitAttachLd || Dbg->IsDbgAttached())) 
  {   
   if(!ProcessHandle)Dbg->Report_EXIT_PROCESS_DEBUG_EVENT(NtCurrentTeb(),0);   // (ProcessHandle==NULL) will terminate all other threads, including GhostDbg
     else UnInitApplication();     // Do not report EXIT_PROCESS_DEBUG_EVENT second time!
  }
 return HookNtTerminateProcess.OrigProc(ProcessHandle, ExitStatus);
} 
//------------------------------------------------------------------------------------
// Exit from a thread`s proc will also end up here  
// ThreadHandle is NULL for a current thread; NtCurrentThread is also works
NTSTATUS NTAPI ProcNtTerminateThread(HANDLE ThreadHandle, NTSTATUS ExitStatus)   // NOTE: A detectable hook!
{
 PTEB teb = NULL;
 DBGMSG("ThreadHandle=%p",ThreadHandle); 
 if(Dbg && Dbg->IsActive() && (SuspWaitAttachLd || Dbg->IsDbgAttached()) && (teb=NNTDLL::GetCurrProcessTEB(ThreadHandle))){ Dbg->Report_EXIT_THREAD_DEBUG_EVENT(teb,ExitStatus); } 
 DBGMSG("Terminating: %p, %u",teb,(teb?(UINT)teb->ClientId.UniqueThread:0)); 
 return HookNtTerminateThread.OrigProc(ThreadHandle, ExitStatus);   // TODO: Just call our own NtTerminateThread 
}
//------------------------------------------------------------------------------------    
NTSTATUS NTAPI ProcNtGetContextThread(HANDLE ThreadHandle, PCONTEXT Context)    // NOTE: A detectable hook!
{  
 ULONG ThID;
 NTSTATUS res = HookNtGetContextThread.OrigProc(ThreadHandle, Context);    // TODO: Just call our own NtGetContextThread(What if it is hooked by someone)?
 if(!res && Dbg && Dbg->IsActive() && Dbg->HideDbgState && (SuspWaitAttachLd || Dbg->IsDbgAttached()) && (ThID=NNTDLL::GetCurrProcessThreadID(ThreadHandle)))Dbg->DebugThreadLoad(ThID, Context);   // Load into CONTEXT a previously saved DRx instead of currently read ones
 return res;
}
//------------------------------------------------------------------------------------    
NTSTATUS NTAPI ProcNtSetContextThread(HANDLE ThreadHandle, PCONTEXT Context)    // NOTE: A detectable hook!   // Do not let DRx to be changed by this
{
 ULONG ThID;
 if(!Dbg || !Dbg->IsActive() || !Dbg->HideDbgState || !(SuspWaitAttachLd || Dbg->IsDbgAttached()) || !(ThID=NNTDLL::GetCurrProcessThreadID(ThreadHandle)))return HookNtSetContextThread.OrigProc(ThreadHandle, Context);   // TODO: Just call our own NtSetContextThread
 CONTEXT FCtx;      // Copy of CONTEXT where CONTEXT_DEBUG_REGISTERS is removed (CONTEXT_DEBUG_REGISTERS must be preserved in original Context in case it may be checked)
 Dbg->DebugThreadSave(ThID, Context);    // Save any magic numbers which may be stored in debug registers to detect a debugger
 memcpy(&FCtx,Context,sizeof(CONTEXT));
 FCtx.ContextFlags &= ~0x00000010;   // CONTEXT_DEBUG_REGISTERS     // TF is allowed to change? 
 return HookNtSetContextThread.OrigProc(ThreadHandle, &FCtx);   // TODO: Just call our own NtSetContextThread(What if it is hooked by someone)?
}
//------------------------------------------------------------------------------------      


#pragma optimize( "", off )

#pragma code_seg()

//====================================================================================
//								 WRAPPER FUNCTIONS
//------------------------------------------------------------------------------------
namespace ProxyExport    // NOTE: THIS WILL BE REMOVED (Use GInjer for injection)
{
// winspool.drv
/*APIWRAPPER(LibPathName, GetDefaultPrinterA)
APIWRAPPER(LibPathName, AbortPrinter)
APIWRAPPER(LibPathName, AddFormA)
APIWRAPPER(LibPathName, AddFormW)
APIWRAPPER(LibPathName, AddJobA)
APIWRAPPER(LibPathName, AddJobW)
APIWRAPPER(LibPathName, AddMonitorA)
APIWRAPPER(LibPathName, AddMonitorW)
APIWRAPPER(LibPathName, AddPortA)
APIWRAPPER(LibPathName, AddPortExA)
APIWRAPPER(LibPathName, AddPortExW)
APIWRAPPER(LibPathName, AddPortW)
APIWRAPPER(LibPathName, AddPrintProcessorA)
APIWRAPPER(LibPathName, AddPrintProcessorW)
APIWRAPPER(LibPathName, AddPrintProvidorA)
APIWRAPPER(LibPathName, AddPrintProvidorW)
APIWRAPPER(LibPathName, AddPrinterA)
APIWRAPPER(LibPathName, AddPrinterConnection2A)
APIWRAPPER(LibPathName, AddPrinterConnection2W)
APIWRAPPER(LibPathName, AddPrinterConnectionA)
APIWRAPPER(LibPathName, AddPrinterConnectionW)
APIWRAPPER(LibPathName, AddPrinterDriverA)
APIWRAPPER(LibPathName, AddPrinterDriverExA)
APIWRAPPER(LibPathName, AddPrinterDriverExW)
APIWRAPPER(LibPathName, AddPrinterDriverW)
APIWRAPPER(LibPathName, AddPrinterW)
APIWRAPPER(LibPathName, AdvancedDocumentPropertiesA)
APIWRAPPER(LibPathName, AdvancedDocumentPropertiesW)
APIWRAPPER(LibPathName, AdvancedSetupDialog)
APIWRAPPER(LibPathName, CheckSignatureInFile)
APIWRAPPER(LibPathName, ClosePrinter)
APIWRAPPER(LibPathName, CloseSpoolFileHandle)
APIWRAPPER(LibPathName, CommitSpoolData)
APIWRAPPER(LibPathName, ConfigurePortA)
APIWRAPPER(LibPathName, ConfigurePortW)
APIWRAPPER(LibPathName, ConnectToPrinterDlg)
APIWRAPPER(LibPathName, ConvertAnsiDevModeToUnicodeDevmode)
APIWRAPPER(LibPathName, ConvertUnicodeDevModeToAnsiDevmode)
APIWRAPPER(LibPathName, CorePrinterDriverInstalledA)
APIWRAPPER(LibPathName, CorePrinterDriverInstalledW)
APIWRAPPER(LibPathName, CreatePrintAsyncNotifyChannel)
APIWRAPPER(LibPathName, CreatePrinterIC)
APIWRAPPER(LibPathName, DeleteFormA)
APIWRAPPER(LibPathName, DeleteFormW)
APIWRAPPER(LibPathName, DeleteMonitorA)
APIWRAPPER(LibPathName, DeleteMonitorW)
APIWRAPPER(LibPathName, DeletePortA)
APIWRAPPER(LibPathName, DeletePortW)
APIWRAPPER(LibPathName, DeletePrintProcessorA)
APIWRAPPER(LibPathName, DeletePrintProcessorW)
APIWRAPPER(LibPathName, DeletePrintProvidorA)
APIWRAPPER(LibPathName, DeletePrintProvidorW)
APIWRAPPER(LibPathName, DeletePrinter)
APIWRAPPER(LibPathName, DeletePrinterConnectionA)
APIWRAPPER(LibPathName, DeletePrinterConnectionW)
APIWRAPPER(LibPathName, DeletePrinterDataA)
APIWRAPPER(LibPathName, DeletePrinterDataExA)
APIWRAPPER(LibPathName, DeletePrinterDataExW)
APIWRAPPER(LibPathName, DeletePrinterDataW)
APIWRAPPER(LibPathName, DeletePrinterDriverA)
APIWRAPPER(LibPathName, DeletePrinterDriverExA)
APIWRAPPER(LibPathName, DeletePrinterDriverExW)
APIWRAPPER(LibPathName, DeletePrinterDriverPackageA)
APIWRAPPER(LibPathName, DeletePrinterDriverPackageW)
APIWRAPPER(LibPathName, DeletePrinterDriverW)
APIWRAPPER(LibPathName, DeletePrinterIC)
APIWRAPPER(LibPathName, DeletePrinterKeyA)
APIWRAPPER(LibPathName, DeletePrinterKeyW)
APIWRAPPER(LibPathName, DevQueryPrint)
APIWRAPPER(LibPathName, DevQueryPrintEx)
APIWRAPPER(LibPathName, DeviceCapabilitiesA)
APIWRAPPER(LibPathName, DeviceCapabilitiesW)
APIWRAPPER(LibPathName, DeviceMode)
APIWRAPPER(LibPathName, DevicePropertySheets)
APIWRAPPER(LibPathName, DocumentEvent)
APIWRAPPER(LibPathName, DocumentPropertiesA)
APIWRAPPER(LibPathName, DocumentPropertiesW)
APIWRAPPER(LibPathName, DocumentPropertySheets)
APIWRAPPER(LibPathName, EndDocPrinter)
APIWRAPPER(LibPathName, EndPagePrinter)
APIWRAPPER(LibPathName, EnumFormsA)
APIWRAPPER(LibPathName, EnumFormsW)
APIWRAPPER(LibPathName, EnumJobsA)
APIWRAPPER(LibPathName, EnumJobsW)
APIWRAPPER(LibPathName, EnumMonitorsA)
APIWRAPPER(LibPathName, EnumMonitorsW)
APIWRAPPER(LibPathName, EnumPortsA)
APIWRAPPER(LibPathName, EnumPortsW)
APIWRAPPER(LibPathName, EnumPrintProcessorDatatypesA)
APIWRAPPER(LibPathName, EnumPrintProcessorDatatypesW)
APIWRAPPER(LibPathName, EnumPrintProcessorsA)
APIWRAPPER(LibPathName, EnumPrintProcessorsW)
APIWRAPPER(LibPathName, EnumPrinterDataA)
APIWRAPPER(LibPathName, EnumPrinterDataExA)
APIWRAPPER(LibPathName, EnumPrinterDataExW)
APIWRAPPER(LibPathName, EnumPrinterDataW)
APIWRAPPER(LibPathName, EnumPrinterDriversA)
APIWRAPPER(LibPathName, EnumPrinterDriversW)
APIWRAPPER(LibPathName, EnumPrinterKeyA)
APIWRAPPER(LibPathName, EnumPrinterKeyW)
APIWRAPPER(LibPathName, EnumPrintersA)
APIWRAPPER(LibPathName, EnumPrintersW)
APIWRAPPER(LibPathName, ExtDeviceMode)
APIWRAPPER(LibPathName, FindClosePrinterChangeNotification)
APIWRAPPER(LibPathName, FindFirstPrinterChangeNotification)
APIWRAPPER(LibPathName, FindNextPrinterChangeNotification)
APIWRAPPER(LibPathName, FlushPrinter)
APIWRAPPER(LibPathName, FreePrinterNotifyInfo)
APIWRAPPER(LibPathName, GetCorePrinterDriversA)
APIWRAPPER(LibPathName, GetCorePrinterDriversW)
APIWRAPPER(LibPathName, GetDefaultPrinterW)
APIWRAPPER(LibPathName, GetFormA)
APIWRAPPER(LibPathName, GetFormW)
APIWRAPPER(LibPathName, GetJobA)
APIWRAPPER(LibPathName, GetJobW)
APIWRAPPER(LibPathName, GetPrintExecutionData)
APIWRAPPER(LibPathName, GetPrintProcessorDirectoryA)
APIWRAPPER(LibPathName, GetPrintProcessorDirectoryW)
APIWRAPPER(LibPathName, GetPrinterA)
APIWRAPPER(LibPathName, GetPrinterDataA)
APIWRAPPER(LibPathName, GetPrinterDataExA)
APIWRAPPER(LibPathName, GetPrinterDataExW)
APIWRAPPER(LibPathName, GetPrinterDataW)
APIWRAPPER(LibPathName, GetPrinterDriver2A)
APIWRAPPER(LibPathName, GetPrinterDriver2W)
APIWRAPPER(LibPathName, GetPrinterDriverA)
APIWRAPPER(LibPathName, GetPrinterDriverDirectoryA)
APIWRAPPER(LibPathName, GetPrinterDriverDirectoryW)
APIWRAPPER(LibPathName, GetPrinterDriverPackagePathA)
APIWRAPPER(LibPathName, GetPrinterDriverPackagePathW)
APIWRAPPER(LibPathName, GetPrinterDriverW)
APIWRAPPER(LibPathName, GetPrinterW)
APIWRAPPER(LibPathName, GetSpoolFileHandle)
APIWRAPPER(LibPathName, InstallPrinterDriverFromPackageA)
APIWRAPPER(LibPathName, InstallPrinterDriverFromPackageW)
APIWRAPPER(LibPathName, IsValidDevmodeA)
APIWRAPPER(LibPathName, IsValidDevmodeW)
APIWRAPPER(LibPathName, OpenPrinter2A)
APIWRAPPER(LibPathName, OpenPrinter2W)
APIWRAPPER(LibPathName, OpenPrinterA)
APIWRAPPER(LibPathName, OpenPrinterW)
APIWRAPPER(LibPathName, PerfClose)
APIWRAPPER(LibPathName, PerfCollect)
APIWRAPPER(LibPathName, PerfOpen)
APIWRAPPER(LibPathName, PlayGdiScriptOnPrinterIC)
APIWRAPPER(LibPathName, PrinterMessageBoxA)
APIWRAPPER(LibPathName, PrinterMessageBoxW)
APIWRAPPER(LibPathName, PrinterProperties)
APIWRAPPER(LibPathName, QueryColorProfile)
APIWRAPPER(LibPathName, QueryRemoteFonts)
APIWRAPPER(LibPathName, QuerySpoolMode)
APIWRAPPER(LibPathName, ReadPrinter)
APIWRAPPER(LibPathName, RegisterForPrintAsyncNotifications)
APIWRAPPER(LibPathName, ReportJobProcessingProgress)
APIWRAPPER(LibPathName, ResetPrinterA)
APIWRAPPER(LibPathName, ResetPrinterW)
APIWRAPPER(LibPathName, ScheduleJob)
APIWRAPPER(LibPathName, SeekPrinter)
APIWRAPPER(LibPathName, SetDefaultPrinterA)
APIWRAPPER(LibPathName, SetDefaultPrinterW)
APIWRAPPER(LibPathName, SetFormA)
APIWRAPPER(LibPathName, SetFormW)
APIWRAPPER(LibPathName, SetJobA)
APIWRAPPER(LibPathName, SetJobW)
APIWRAPPER(LibPathName, SetPortA)
APIWRAPPER(LibPathName, SetPortW)
APIWRAPPER(LibPathName, SetPrinterA)
APIWRAPPER(LibPathName, SetPrinterDataA)
APIWRAPPER(LibPathName, SetPrinterDataExA)
APIWRAPPER(LibPathName, SetPrinterDataExW)
APIWRAPPER(LibPathName, SetPrinterDataW)
APIWRAPPER(LibPathName, SetPrinterW)
APIWRAPPER(LibPathName, SplDriverUnloadComplete)
APIWRAPPER(LibPathName, SpoolerDevQueryPrintW)
APIWRAPPER(LibPathName, SpoolerPrinterEvent)
APIWRAPPER(LibPathName, StartDocDlgA)
APIWRAPPER(LibPathName, StartDocDlgW)
APIWRAPPER(LibPathName, StartDocPrinterA)
APIWRAPPER(LibPathName, StartDocPrinterW)
APIWRAPPER(LibPathName, StartPagePrinter)
APIWRAPPER(LibPathName, SystemFunction035)
APIWRAPPER(LibPathName, UnRegisterForPrintAsyncNotifications)
APIWRAPPER(LibPathName, UploadPrinterDriverPackageA)
APIWRAPPER(LibPathName, UploadPrinterDriverPackageW)
APIWRAPPER(LibPathName, WaitForPrinterChange)
APIWRAPPER(LibPathName, WritePrinter)
APIWRAPPER(LibPathName, XcvDataW) */

// cryptsp.dll
/*APIWRAPPER(LibPathName, CryptAcquireContextA)
APIWRAPPER(LibPathName, CryptAcquireContextW)
APIWRAPPER(LibPathName, CryptContextAddRef)
APIWRAPPER(LibPathName, CryptCreateHash)
APIWRAPPER(LibPathName, CryptDecrypt)
APIWRAPPER(LibPathName, CryptDeriveKey)
APIWRAPPER(LibPathName, CryptDestroyHash)
APIWRAPPER(LibPathName, CryptDestroyKey)
APIWRAPPER(LibPathName, CryptDuplicateHash)
APIWRAPPER(LibPathName, CryptDuplicateKey)
APIWRAPPER(LibPathName, CryptEncrypt)
APIWRAPPER(LibPathName, CryptEnumProviderTypesA)
APIWRAPPER(LibPathName, CryptEnumProviderTypesW)
APIWRAPPER(LibPathName, CryptEnumProvidersA)
APIWRAPPER(LibPathName, CryptEnumProvidersW)
APIWRAPPER(LibPathName, CryptExportKey)
APIWRAPPER(LibPathName, CryptGenKey)
APIWRAPPER(LibPathName, CryptGenRandom)
APIWRAPPER(LibPathName, CryptGetDefaultProviderA)
APIWRAPPER(LibPathName, CryptGetDefaultProviderW)
APIWRAPPER(LibPathName, CryptGetHashParam)
APIWRAPPER(LibPathName, CryptGetKeyParam)
APIWRAPPER(LibPathName, CryptGetProvParam)
APIWRAPPER(LibPathName, CryptGetUserKey)
APIWRAPPER(LibPathName, CryptHashData)
APIWRAPPER(LibPathName, CryptHashSessionKey)
APIWRAPPER(LibPathName, CryptImportKey)
APIWRAPPER(LibPathName, CryptReleaseContext)
APIWRAPPER(LibPathName, CryptSetHashParam)
APIWRAPPER(LibPathName, CryptSetKeyParam)
APIWRAPPER(LibPathName, CryptSetProvParam)
APIWRAPPER(LibPathName, CryptSetProviderA)
APIWRAPPER(LibPathName, CryptSetProviderExA)
APIWRAPPER(LibPathName, CryptSetProviderExW)
APIWRAPPER(LibPathName, CryptSetProviderW)
APIWRAPPER(LibPathName, CryptSignHashA)
APIWRAPPER(LibPathName, CryptSignHashW)
APIWRAPPER(LibPathName, CryptVerifySignatureA)
APIWRAPPER(LibPathName, CryptVerifySignatureW)  */

// version.dll
/*APIWRAPPER(LibPathName, GetFileVersionInfoA)
APIWRAPPER(LibPathName, GetFileVersionInfoByHandle)
APIWRAPPER(LibPathName, GetFileVersionInfoExA)
APIWRAPPER(LibPathName, GetFileVersionInfoExW)
APIWRAPPER(LibPathName, GetFileVersionInfoSizeA)
APIWRAPPER(LibPathName, GetFileVersionInfoSizeExA)
APIWRAPPER(LibPathName, GetFileVersionInfoSizeExW)
APIWRAPPER(LibPathName, GetFileVersionInfoSizeW)
APIWRAPPER(LibPathName, GetFileVersionInfoW)
APIWRAPPER(LibPathName, VerFindFileA)
APIWRAPPER(LibPathName, VerFindFileW)
APIWRAPPER(LibPathName, VerInstallFileA)
APIWRAPPER(LibPathName, VerInstallFileW)
APIWRAPPER(LibPathName, VerLanguageNameA)
APIWRAPPER(LibPathName, VerLanguageNameW)
APIWRAPPER(LibPathName, VerQueryValueA)
APIWRAPPER(LibPathName, VerQueryValueW) */ 

}  
//====================================================================================





================================================
File: InjectLib/InjectDll.h
================================================

#pragma once
/*
  Copyright (c) 2020 Victor Sheinmann, Vicshann@gmail.com

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
  to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
*/

#if __has_include ("..\..\GlobalInjector\GInjer\LoaderCode.h")
#define _HAVE_GINGER
#include "..\..\GlobalInjector\GInjer\LoaderCode.h"
#else
#include "Common.hpp"
#define DLL_REFLECTIVE_LOAD (DLL_THREAD_DETACH + 9)
#endif

//====================================================================================
#define CFGFILE    ".InjLib.jsn"
#define LOGFILE    ".InjLib.log"

//====================================================================================
void _stdcall LoadConfiguration(void);
void _stdcall SaveConfiguration(int BinFmt=-1);
void _stdcall UnInitApplication(void);
bool _stdcall InitApplication(void);
int _fastcall DbgUsrReqCallback(NShMem::CMessageIPC::SMsgHdr* Req, PVOID ArgA, UINT ArgB);
//------------------------------------------------------------------------------------
bool _cdecl ProcExpDispBefore(volatile PVOID ArgA, volatile PVOID ArgB, volatile PVOID ArgC, volatile PVOID ArgD, volatile PVOID RetVal);
bool _cdecl ProcExpDispAfter(volatile PVOID ArgA, volatile PVOID ArgB, volatile PVOID ArgC, volatile PVOID ArgD, volatile PVOID RetVal);
//__declspec(noreturn) VOID NTAPI ProcRtlRestoreContext(PCONTEXT ContextRecord, PEXCEPTION_RECORD ExceptionRecord);
//__declspec(noreturn) void _fastcall ProcKiUserExceptionDispatcher(void);
//__declspec(noreturn) void NTAPI ProcLdrInitializeThunk(PVOID ArgA, PVOID ArgB, PVOID ArgC, PVOID ArgD);
void _stdcall ProcLdrpInitialize(volatile PCONTEXT Ctx, volatile PVOID NtDllBase);
NTSTATUS NTAPI ProcNtContinue(PCONTEXT ContextRecord, BOOLEAN TestAlert);
NTSTATUS NTAPI ProcNtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus);
NTSTATUS NTAPI ProcNtTerminateThread(HANDLE ThreadHandle, NTSTATUS ExitStatus);
NTSTATUS NTAPI ProcNtGetContextThread(HANDLE ThreadHandle, PCONTEXT Context);
NTSTATUS NTAPI ProcNtSetContextThread(HANDLE ThreadHandle, PCONTEXT Context);
NTSTATUS NTAPI ProcNtUnmapViewOfSection(HANDLE ProcessHandle, PVOID BaseAddress);
NTSTATUS NTAPI ProcNtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Win32Protect);
//====================================================================================



================================================
File: InjectLib/InjectDll.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5B70EAFD-1442-4542-8DE2-E7E3832E407C}</ProjectGuid>
    <RootNamespace>ToolDll</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <ProjectName>InjectDll</ProjectName>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(XDBGNI_TESTFLDR)</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <IgnoreImportLibrary Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</IgnoreImportLibrary>
    <IgnoreImportLibrary Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</IgnoreImportLibrary>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(XDBGNI_TESTFLDR)</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <IgnoreImportLibrary Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</IgnoreImportLibrary>
    <IgnoreImportLibrary Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</IgnoreImportLibrary>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetName>injlib</TargetName>
    <TargetExt>.dll</TargetExt>
    <EmbedManifest>false</EmbedManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>injlib</TargetName>
    <OutDir>$(XDBGNI_TESTFLDR)</OutDir>
    <IntDir>$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <TargetExt>.dll</TargetExt>
    <EmbedManifest>false</EmbedManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>injlib</TargetName>
    <TargetExt>.dll</TargetExt>
    <EmbedManifest>false</EmbedManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>injlib</TargetName>
    <OutDir>$(XDBGNI_TESTFLDR)</OutDir>
    <IntDir>$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <TargetExt>.dll</TargetExt>
    <EmbedManifest>false</EmbedManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ModuleTools\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_NODESTR;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>FastCall</CallingConvention>
      <ShowIncludes>false</ShowIncludes>
      <StringPooling>true</StringPooling>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/permissive  /Gs100000000  /d2noftol3 %(AdditionalOptions)</AdditionalOptions>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerboseLib</ShowProgress>
      <OutputFile>$(TargetDir)$(TargetName)$(TargetExt)</OutputFile>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>
      </BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>
      </ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <SetChecksum>true</SetChecksum>
      <SpecifySectionAttributes>.bss,ERW</SpecifySectionAttributes>
      <GenerateMapFile>true</GenerateMapFile>
      <IgnoreAllDefaultLibraries>
      </IgnoreAllDefaultLibraries>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <ForceFileOutput>
      </ForceFileOutput>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x32.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <Optimization>Full</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ModuleTools\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_NODESTR;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>FastCall</CallingConvention>
      <ShowIncludes>false</ShowIncludes>
      <StringPooling>true</StringPooling>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <OmitFramePointers>false</OmitFramePointers>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/permissive  /Gs100000000 %(AdditionalOptions)</AdditionalOptions>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerboseLib</ShowProgress>
      <OutputFile>$(TargetDir)$(TargetName)$(TargetExt)</OutputFile>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>
      </BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>
      </ImportLibrary>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <SetChecksum>true</SetChecksum>
      <SpecifySectionAttributes>.bss,ERW</SpecifySectionAttributes>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x64.lib;runtmchk.lib</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ModuleTools\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_NODESTR;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <CallingConvention>FastCall</CallingConvention>
      <CompileAs>Default</CompileAs>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/permissive  /Gs100000000  /d2noftol3 %(AdditionalOptions)</AdditionalOptions>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerboseLib</ShowProgress>
      <OutputFile>$(TargetDir)$(TargetName)$(TargetExt)</OutputFile>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <BaseAddress>
      </BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>
      </ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x32.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <SetChecksum>true</SetChecksum>
      <SpecifySectionAttributes>.bss,ERW</SpecifySectionAttributes>
      <GenerateMapFile>true</GenerateMapFile>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalOptions>/nocoffgrpinfo %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>mkdir "$(SolutionDir)BUILD\RELEASE\$(SolutionName)\x$(PlatformArchitecture)"
copy /Y "$(OutDir)$(TargetName)$(TargetExt)" "$(SolutionDir)BUILD\RELEASE\$(SolutionName)\x$(PlatformArchitecture)\$(TargetName)$(TargetExt)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ModuleTools\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_NODESTR;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <CallingConvention>FastCall</CallingConvention>
      <CompileAs>Default</CompileAs>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/permissive  /Gs100000000 %(AdditionalOptions)</AdditionalOptions>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerboseLib</ShowProgress>
      <OutputFile>$(TargetDir)$(TargetName)$(TargetExt)</OutputFile>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <BaseAddress>
      </BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>
      </ImportLibrary>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x64.lib;runtmchk.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <SetChecksum>true</SetChecksum>
      <SpecifySectionAttributes>.bss,ERW</SpecifySectionAttributes>
      <GenerateMapFile>true</GenerateMapFile>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalOptions>/nocoffgrpinfo %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>mkdir "$(SolutionDir)BUILD\RELEASE\$(SolutionName)\x$(PlatformArchitecture)"
copy /Y "$(OutDir)$(TargetName)$(TargetExt)" "$(SolutionDir)BUILD\RELEASE\$(SolutionName)\x$(PlatformArchitecture)\$(TargetName)$(TargetExt)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\COMMON\RTL\gcvt.cpp" />
    <ClCompile Include="..\COMMON\Utils.cpp" />
    <ClCompile Include="InjectDll.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\COMMON\Common.hpp" />
    <ClInclude Include="..\COMMON\CompileTime.hpp" />
    <ClInclude Include="..\COMMON\FormatPE.hpp" />
    <ClInclude Include="..\COMMON\GhostDbg.hpp" />
    <ClInclude Include="..\COMMON\HDE.hpp" />
    <ClInclude Include="..\COMMON\InjDllLdr.hpp" />
    <ClInclude Include="..\COMMON\json.h" />
    <ClInclude Include="..\COMMON\MiniString.h" />
    <ClInclude Include="..\COMMON\NtDllEx.hpp" />
    <ClInclude Include="..\COMMON\ShMemIPC.hpp" />
    <ClInclude Include="..\COMMON\ThirdParty\ntdll\ntdll.h" />
    <ClInclude Include="..\COMMON\UniHook.hpp" />
    <ClInclude Include="..\COMMON\Utils.h" />
    <ClInclude Include="InjectDll.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>


================================================
File: InjectLib/InjectDll.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx</Extensions>
    </Filter>
    <Filter Include="Common">
      <UniqueIdentifier>{2e4139ac-ff60-48e7-9ddf-a7c62508e2c2}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="InjectDll.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\COMMON\Utils.cpp">
      <Filter>Common</Filter>
    </ClCompile>
    <ClCompile Include="..\COMMON\RTL\gcvt.cpp">
      <Filter>Common</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="InjectDll.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\ThirdParty\ntdll\ntdll.h">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\json.h">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\MiniString.h">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\ShMemIPC.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\Utils.h">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\InjDllLdr.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\GhostDbg.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\CompileTime.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\UniHook.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\NtDllEx.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\Common.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\FormatPE.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\HDE.hpp">
      <Filter>Common</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


================================================
File: XDbgPlugin/Resources.rc
================================================

#include "windows.h"


#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT
#pragma code_page(1251)
#endif //_WIN32

1 ICON "MainIcon.ico"
5 ICON "LogoIcon.ico" 
MAINICON RCDATA "MainIcon.png"            // ICON
InjLib RCDATA  INJLIBPATH

/////////////////////////////////////////////////////////////////////////////
//
// Version
//
VS_VERSION_INFO VERSIONINFO
 FILEVERSION 2,1,0,0
 PRODUCTVERSION 2,1,0,0
 FILEFLAGSMASK 0x17L
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "Comments", "https://github.com/Vicshann"        // Github page
            VALUE "CompanyName", "Vicshann"
            VALUE "FileDescription", "x64Dbg plugin"
            VALUE "FileVersion", "2, 0, 0, 0"
            VALUE "InternalName", "GhostDbg"
            VALUE "LegalCopyright", "Copyright (c) 2020 Vicshann"
            VALUE "OriginalFilename", "GhostDbg.dll"
            VALUE "ProductName", "GhostDbg"
            VALUE "ProductVersion", "2, 0, 0, 0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////



================================================
File: XDbgPlugin/XDbgPlugin.cpp
================================================
/*
  Copyright (c) 2020 Victor Sheinmann, Vicshann@gmail.com

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
  to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
*/

#include "XDbgPlugin.h" 
#include "_plugins.h"

#pragma comment(linker,"/ENTRY:DLLMain")
#pragma comment(linker,"/NODEFAULTLIB")


typedef NShMem  SHM;     
typedef NGhDbg  XNI;

// ---------- SETTINGS ------------------
bool PLogOnly    = false;       // Just log usage of Debug API  
bool PEnabled    = false;       // Enable the GhostDbg plugin
bool AllowInject = true;        // Allow to load inject DLL into a target process(Attach). Else only processes with already injected GhostDbg DLLs will be visible
bool AllowInjNew = true;        // Allow to load inject DLL into a target process(Create).
bool SuspendProc = true;        // It is safer to keep a target process suspended while IPC and GhostDbg Client initializing but some timeouts may be detected
bool SingleCore  = false;
UINT InjFlags    = NInjLdr::mfInjMap|NInjLdr::mfRunRMTH|NInjLdr::mfNoThreadReport;  // |NInjLdr::mfRawRMTH
UINT WaitForInj  = 5000;
//---------------------------------------
                                 
PHOOK(ProcNtClose) HookNtClose;        
PHOOK(ProcNtOpenThread) HookNtOpenThread;
PHOOK(ProcNtOpenProcess) HookNtOpenProcess;    
PHOOK(ProcNtFlushVirtualMemory) HookNtFlushVirtualMemory;                                            
PHOOK(ProcNtQueryVirtualMemory) HookNtQueryVirtualMemory;
PHOOK(ProcNtProtectVirtualMemory) HookNtProtectVirtualMemory;                    
PHOOK(ProcNtQueryInformationThread) HookNtQueryInformationThread;
PHOOK(ProcNtQueryInformationProcess) HookNtQueryInformationProcess;                                                  
PHOOK(ProcNtGetContextThread) HookNtGetContextThread;
PHOOK(ProcNtSetContextThread) HookNtSetContextThread;
PHOOK(ProcNtReadVirtualMemory) HookNtReadVirtualMemory;
PHOOK(ProcNtWriteVirtualMemory) HookNtWriteVirtualMemory;
PHOOK(ProcNtTerminateProcess) HookNtTerminateProcess;
PHOOK(ProcNtTerminateThread) HookNtTerminateThread;
PHOOK(ProcNtSuspendThread) HookNtSuspendThread;
PHOOK(ProcNtResumeThread) HookNtResumeThread;
PHOOK(ProcNtDuplicateObject) HookNtDuplicateObject;
  
PHOOK(ProcDebugActiveProcess) HookDebugActiveProcess; 
PHOOK(ProcDebugActiveProcessStop) HookDebugActiveProcessStop;
PHOOK(ProcWaitForDebugEvent) HookWaitForDebugEvent;   
PHOOK(ProcContinueDebugEvent) HookContinueDebugEvent; 
PHOOK(ProcDebugBreakProcess) HookDebugBreakProcess;
PHOOK(ProcCreateProcessA) HookCreateProcessA;
PHOOK(ProcCreateProcessW) HookCreateProcessW;
PHOOK(ProcIsWow64Process) HookIsWow64Process;


volatile bool BreakWrk = false;
SHM::CMessageIPC* DbgIPC = NULL;
XNI::CThreadList* ThList = NULL;
PVOID NtDllBase = NULL;
ULONG NtDllSize = 0;
HMODULE hInst = NULL;
HANDLE  hSuspTh = NULL;
HANDLE  hLstProc = NULL;
HANDLE hTempObjDir = NULL;
DWORD  DbgProcID = 0; 
DWORD  LstProcID = 0;   // After termination, to prevent reopen try and wait on unavailable IPC
HWND   hXDbgWnd = NULL;
int PluginHandle = -1;
int DbgCliMenu = -1;
bool DoDisconnAtTerm = false;
bool HooksInstalled  = false;
bool DbgCliFlags[32];   // Because there is no function to request a menu item`s checked state in X64DBG  :(


void (_cdecl* plugin_registercallback)(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
void (_cdecl* plugin_menuentrysetchecked)(int pluginHandle, int hEntry,bool checked);
//void (_cdecl* plugin_menuentrysetname)(int pluginHandle, int hEntry, const char* name);    // Broken!
bool (_cdecl* plugin_menuaddseparator)(int hMenu);
bool (_cdecl* plugin_menuclear)(int hMenu);
int  (_cdecl* plugin_menuadd)(int hMenu, const char* title);
int  (_cdecl* plugin_menuaddentry)(int hMenu, int entry, const char* title);
void (_cdecl* plugin_menuseticon)(int hMenu, const ICONDATA* icon);
void (_cdecl* plugin_logprintf)(const char* format, ...);

wchar_t StartUpDir[MAX_PATH];
wchar_t CfgFilePath[MAX_PATH];
wchar_t WorkFolder[MAX_PATH];

//===========================================================================
BOOL APIENTRY DLLMain(HMODULE hModule, DWORD ReasonCall, LPVOID lpReserved) 
{	 
 switch (ReasonCall)	    
  {			 
   case DLL_PROCESS_ATTACH:
    {    
     hInst = hModule;
     GetModuleFileNameW((HMODULE)hModule,StartUpDir,countof(StartUpDir));        
	 NSTR::StrCopy(WorkFolder, StartUpDir);

#ifndef NOLOG
     NSTR::StrCopy(LogFilePath, WorkFolder);
     NSTR::StrCopy(GetFileExt(LogFilePath), L"log");
#endif
     NSTR::StrCopy(CfgFilePath, WorkFolder);
     NSTR::StrCopy(GetFileExt(CfgFilePath), L"ini");
	
     LoadConfiguration(); 
     CreateUntrustedNtObjDir(&hTempObjDir, L"TempNamedObjects");    // Need for injection into low/untrusted integrity processes   // TODO: Generate this name, same as in ShMemIPC
	 if(LogMode & lmCons){AllocConsole();/*SetWinConsoleSizes(1000, 500, 1000, 500);*/}
	 LOGMSG("Starting up... (Time=%016llX), Owner='%ls'", SysTimeToTime64(NNTDLL::GetSystemTime()), &StartUpDir);	
     TrimFilePath(StartUpDir);
     LOGMSG("WorkFolder: %ls", &WorkFolder);
     LOGMSG("StartUpDir: %ls", &StartUpDir);  
    }
     break;									
   case DLL_THREAD_ATTACH:
     break; 
   case DLL_THREAD_DETACH:
     break;
   case DLL_PROCESS_DETACH: 
     DisablePlugin();
	 break;
   default : return false;  
  }
 return true;
}
//====================================================================================
void _stdcall LoadConfiguration(void)
{   
 LogMode       = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"LogMode",   LogMode,  CfgFilePath);
 PLogOnly      = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"PLogOnly",  PLogOnly, CfgFilePath);
 PEnabled      = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"PEnabled",  PEnabled, CfgFilePath);
 AllowInject   = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"AllowInject",  AllowInject, CfgFilePath); 
 AllowInjNew   = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"AllowInjNew",  AllowInjNew, CfgFilePath);   
 SuspendProc   = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"SuspendProc",  SuspendProc, CfgFilePath);     
 SingleCore    = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"SingleCore",  SingleCore, CfgFilePath);
 InjFlags      = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"InjectFlags",  InjFlags, CfgFilePath); 
 WaitForInj    = INIRefreshValueInt<PWSTR>(CFGSECNAME, L"WaitForInj",  WaitForInj, CfgFilePath); 
    
 LOGMSG("Initializing...");   
 PVOID pNtDll = NPEFMT::GetNtDllBaseFast(); 
 LOGMSG("SystemNtDllBase: %p", pNtDll);   
 NtDllSize = GetRealModuleSize(pNtDll);
 NtDllBase = VirtualAlloc(NULL,NtDllSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE); 
 LOGMSG("CopyNtDllBase=%p, NtDllSize=%08X", NtDllBase, NtDllSize);
 CopyValidModuleMem(pNtDll, NtDllBase, NtDllSize);    // On Win7 x64 some regions of ntdll.dll are in reserved state 
 LOGMSG("Done"); 
}
//------------------------------------------------------------------------------------
void _stdcall SaveConfiguration(void)
{
 INISetValueInt<PWSTR>(CFGSECNAME, L"LogMode", LogMode, CfgFilePath);
 INISetValueInt<PWSTR>(CFGSECNAME, L"PLogOnly", PLogOnly, CfgFilePath);
 INISetValueInt<PWSTR>(CFGSECNAME, L"PEnabled", PEnabled, CfgFilePath);
 INISetValueInt<PWSTR>(CFGSECNAME, L"AllowInject", AllowInject, CfgFilePath);  
 INISetValueInt<PWSTR>(CFGSECNAME, L"AllowInjNew", AllowInjNew, CfgFilePath);
 INISetValueInt<PWSTR>(CFGSECNAME, L"SuspendProc", SuspendProc, CfgFilePath);
 INISetValueInt<PWSTR>(CFGSECNAME, L"SingleCore", SingleCore, CfgFilePath);
 INISetValueInt<PWSTR>(CFGSECNAME, L"InjectFlags", InjFlags, CfgFilePath);
 INISetValueInt<PWSTR>(CFGSECNAME, L"WaitForInj", WaitForInj, CfgFilePath);
}
//------------------------------------------------------------------------------------
void _cdecl MenuHandler(CBTYPE Type, PLUG_CB_MENUENTRY *info)
{
 if(info->hEntry >= MENU_ID_DBGCLIENT)
  {
   UINT CfgIdx = info->hEntry - MENU_ID_DBGCLIENT; 
   DbgCliFlags[CfgIdx] = !DbgCliFlags[CfgIdx];
   SetSingleConfig(CfgIdx, XNI::dtBool, &DbgCliFlags[CfgIdx]);   // Set config
   return;
  }
 switch(info->hEntry) 
  {
   case MENU_ID_ENABLED:
     if(PEnabled)DisablePlugin();
      else EnablePlugin();
     PEnabled = !PEnabled;                            // No way to change the menu item`s text?    // plugin_menuentrysetname(PluginHandle,MENU_ID_ENABLED,(PEnabled)?("DISABLE"):("ENABLE"));   
     SaveConfiguration();
    break;
   case MENU_ID_CHK_CANINJ:
     AllowInject = !AllowInject;
     SaveConfiguration();
    break;
   case MENU_ID_CHK_CANINJNEW:
     AllowInjNew = !AllowInjNew;
     SaveConfiguration();
    break;
   case MENU_ID_SUSPPROCESS:
     SuspendProc = !SuspendProc;
     SaveConfiguration();
    break;  
   case MENU_ID_FORCESINGLECORE:
     SingleCore = !SingleCore;
     SaveConfiguration();
    break;                       
   case MENU_ID_USERAWTHREADS:
     if(InjFlags & NInjLdr::mfRawRMTH)InjFlags &= ~NInjLdr::mfRawRMTH;
       else InjFlags |= NInjLdr::mfRawRMTH;  
     SaveConfiguration();
    break;  
   case MENU_ID_NOTHREADREPORTS:
     if(InjFlags & NInjLdr::mfNoThreadReport)InjFlags &= ~NInjLdr::mfNoThreadReport;
       else InjFlags |= NInjLdr::mfNoThreadReport;  
     SaveConfiguration();
    break;       
   case MENU_ID_ABOUT: 
     {  
      char Hdr[64];                                     // XDBGPLG_BUILD
      char About[128]; 
      MSGBOXPARAMSA mpar;
      wsprintfA(Hdr,"%s v%u.%u",XDBGPLG_NAME,XDBGPLG_VERH,XDBGPLG_VERL);
      wsprintfA(About,"Build: %s\nAuthor: Vicshann\nEmail: vicshann@gmail.com",XDBGPLG_BUILD);
      memset(&mpar,0,sizeof(mpar));
      mpar.cbSize       = sizeof(mpar);
      mpar.hInstance    = hInst;  
      mpar.hwndOwner    = hXDbgWnd;
      mpar.dwStyle      = MB_OK | MB_USERICON;
      mpar.dwLanguageId = MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL);
      mpar.lpszIcon     = MAKEINTRESOURCE(5);        // Why can`t it accept the "LOGOICON" name? 
      mpar.lpszText     = About;
      mpar.lpszCaption  = Hdr;
      MessageBoxIndirectA(&mpar);
     }
    break;
  }
}
//------------------------------------------------------------------------------------
extern "C" __declspec(dllexport) bool _cdecl pluginit(PLUG_INITSTRUCT* initStruct)
{
 DBGMSG("Enter");

#ifdef _M_X64
 HMODULE pXDbgLib = GetModuleHandleA("x64dbg.dll");
#else
 HMODULE pXDbgLib = GetModuleHandleA("x32dbg.dll");
#endif
       
 *(FARPROC*)&plugin_registercallback    = GetProcAddress(pXDbgLib, "_plugin_registercallback");
 *(FARPROC*)&plugin_menuentrysetchecked = GetProcAddress(pXDbgLib, "_plugin_menuentrysetchecked");
// *(FARPROC*)&plugin_menuentrysetname    = GetProcAddress(pXDbgLib, "_plugin_menuentrysetname");
 *(FARPROC*)&plugin_menuaddseparator    = GetProcAddress(pXDbgLib, "_plugin_menuaddseparator");
 *(FARPROC*)&plugin_menuaddentry        = GetProcAddress(pXDbgLib, "_plugin_menuaddentry");
 *(FARPROC*)&plugin_menuseticon         = GetProcAddress(pXDbgLib, "_plugin_menuseticon"); 
 *(FARPROC*)&plugin_menuclear           = GetProcAddress(pXDbgLib, "_plugin_menuclear"); 
 *(FARPROC*)&plugin_menuadd             = GetProcAddress(pXDbgLib, "_plugin_menuadd"); 
 *(FARPROC*)&plugin_logprintf           = GetProcAddress(pXDbgLib, "_plugin_logprintf");   
                                 
 PluginHandle = initStruct->pluginHandle;
 initStruct->pluginVersion = XDBGPLG_VERH;
 lstrcpyA(initStruct->pluginName, XDBGPLG_NAME);
 initStruct->sdkVersion = PLUG_SDKVERSION;
 plugin_registercallback(initStruct->pluginHandle, CB_MENUENTRY, (CBPLUGIN)MenuHandler);
 DBGMSG("Exit");
 return true;
}
//------------------------------------------------------------------------------------
extern "C" __declspec(dllexport) bool _cdecl plugstop()
{
 DBGMSG("Enter");
 DisablePlugin();
 DBGMSG("Exit");
 return true;
}
//------------------------------------------------------------------------------------
extern "C" __declspec(dllexport) void _cdecl plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
 DBGMSG("Enter");
 plugin_logprintf("%s Loaded. Build: %s\n",XDBGPLG_NAME,XDBGPLG_BUILD);
 hXDbgWnd = setupStruct->hwndDlg;
 plugin_menuaddentry(setupStruct->hMenu, MENU_ID_ENABLED, "Enabled");
 plugin_menuaddentry(setupStruct->hMenu, MENU_ID_CHK_CANINJ, "Allow Injection");   // Open Process
 plugin_menuaddentry(setupStruct->hMenu, MENU_ID_CHK_CANINJNEW, "Allow Inject New");  // Create Process
// plugin_menuaddentry(setupStruct->hMenu, MENU_ID_CHK_CANEJ, "Allow Ejection");    // On Detach, if DLL has been injected
 plugin_menuaddentry(setupStruct->hMenu, MENU_ID_SUSPPROCESS, "Suspend Process");
 plugin_menuaddentry(setupStruct->hMenu, MENU_ID_FORCESINGLECORE, "Force Single Core");
 plugin_menuaddentry(setupStruct->hMenu, MENU_ID_USERAWTHREADS, "Use Raw Threads");     
 plugin_menuaddentry(setupStruct->hMenu, MENU_ID_NOTHREADREPORTS, "No Thread Reports"); 

 plugin_menuaddseparator(setupStruct->hMenu);
 DbgCliMenu = plugin_menuadd(setupStruct->hMenu, "Client Config");
 plugin_menuaddseparator(setupStruct->hMenu);
 plugin_menuaddentry(setupStruct->hMenu, MENU_ID_ABOUT, "About");
    
 plugin_menuentrysetchecked(PluginHandle,MENU_ID_ENABLED,PEnabled);
 plugin_menuentrysetchecked(PluginHandle,MENU_ID_CHK_CANINJ,AllowInject);
 plugin_menuentrysetchecked(PluginHandle,MENU_ID_CHK_CANINJNEW,AllowInjNew);
 plugin_menuentrysetchecked(PluginHandle,MENU_ID_SUSPPROCESS,SuspendProc);         
 plugin_menuentrysetchecked(PluginHandle,MENU_ID_FORCESINGLECORE,SingleCore);
 plugin_menuentrysetchecked(PluginHandle,MENU_ID_USERAWTHREADS,InjFlags & NInjLdr::mfRawRMTH);
 plugin_menuentrysetchecked(PluginHandle,MENU_ID_NOTHREADREPORTS,InjFlags & NInjLdr::mfNoThreadReport);

 ICONDATA ico;
 UINT ResSize = 0;
 ico.data = GetResource(hInst, "MAINICON", RT_RCDATA, &ResSize);
 ico.size = ResSize; 
 plugin_menuseticon(setupStruct->hMenu, &ico);
 if(PEnabled)EnablePlugin();
 DBGMSG("Exit");
}
//------------------------------------------------------------------------------------
int _stdcall EnablePlugin(void)
{
 if(HooksInstalled)return 0;
 DBGMSG("Enter");
 BreakWrk       = false;
 HooksInstalled = true;  
                         
 HookNtClose.SetHook("NtClose","ntdll.dll");
 HookNtOpenThread.SetHook("NtOpenThread","ntdll.dll");
 HookNtOpenProcess.SetHook("NtOpenProcess","ntdll.dll");  
 HookNtFlushVirtualMemory.SetHook("NtFlushVirtualMemory","ntdll.dll");
 HookNtQueryVirtualMemory.SetHook("NtQueryVirtualMemory","ntdll.dll"); 
 HookNtProtectVirtualMemory.SetHook("NtProtectVirtualMemory","ntdll.dll");  
 HookNtQueryInformationThread.SetHook("NtQueryInformationThread","ntdll.dll");
 HookNtQueryInformationProcess.SetHook("NtQueryInformationProcess","ntdll.dll");

 HookNtTerminateProcess.SetHook("NtTerminateProcess","ntdll.dll");
 HookNtTerminateThread.SetHook("NtTerminateThread","ntdll.dll");
 HookNtSuspendThread.SetHook("NtSuspendThread","ntdll.dll");
 HookNtResumeThread.SetHook("NtResumeThread","ntdll.dll");
 HookNtSetContextThread.SetHook("NtSetContextThread","ntdll.dll");
 HookNtGetContextThread.SetHook("NtGetContextThread","ntdll.dll");
 HookNtReadVirtualMemory.SetHook("NtReadVirtualMemory","ntdll.dll");
 HookNtWriteVirtualMemory.SetHook("NtWriteVirtualMemory","ntdll.dll");
 HookNtDuplicateObject.SetHook("NtDuplicateObject","ntdll.dll");

 HookDebugActiveProcess.SetHook("DebugActiveProcess","kernel32.dll");
 HookDebugActiveProcessStop.SetHook("DebugActiveProcessStop","kernel32.dll");
 HookContinueDebugEvent.SetHook("ContinueDebugEvent","kernel32.dll");
 HookWaitForDebugEvent.SetHook("WaitForDebugEvent","kernel32.dll");
 HookDebugBreakProcess.SetHook("DebugBreakProcess","kernel32.dll");
 HookCreateProcessA.SetHook("CreateProcessA","kernel32.dll");
 HookCreateProcessW.SetHook("CreateProcessW","kernel32.dll");
 HookIsWow64Process.SetHook("IsWow64Process","kernel32.dll");

 ThList = new XNI::CThreadList;
 DbgIPC = new SHM::CMessageIPC;
 DBGMSG("Exit");
 plugin_logprintf("%s Enabled\n",XDBGPLG_NAME);
 return 0;
}
//------------------------------------------------------------------------------------
int _stdcall DisablePlugin(void)
{
 if(!HooksInstalled)return 0;
 DBGMSG("Enter");
 BreakWrk       = true;
 HooksInstalled = false;
 HookNtClose.Remove();
 HookNtOpenThread.Remove();
 HookNtOpenProcess.Remove();
 HookNtFlushVirtualMemory.Remove();
 HookNtQueryVirtualMemory.Remove();
 HookNtProtectVirtualMemory.Remove();
 HookNtQueryInformationThread.Remove();
 HookNtQueryInformationProcess.Remove(); 
 HookNtTerminateProcess.Remove();
 HookNtTerminateThread.Remove();
 HookNtSuspendThread.Remove();
 HookNtResumeThread.Remove();
 HookNtSetContextThread.Remove();
 HookNtGetContextThread.Remove();
 HookNtReadVirtualMemory.Remove();
 HookNtWriteVirtualMemory.Remove();
 HookNtDuplicateObject.Remove();

 HookDebugActiveProcess.Remove();
 HookDebugActiveProcessStop.Remove();
 HookContinueDebugEvent.Remove();
 HookWaitForDebugEvent.Remove();
 HookDebugBreakProcess.Remove();
 HookCreateProcessA.Remove();
 HookCreateProcessW.Remove();

 SHM::CMessageIPC* TmpIPC = DbgIPC;
 DbgIPC = NULL;
 delete(TmpIPC);     // WaitForDebugEvent is finished before this?
 XNI::CThreadList* TmpLst = ThList;
 ThList = NULL;
 delete(TmpLst);

 DBGMSG("Exit");
 plugin_logprintf("%s Disabled\n",XDBGPLG_NAME);
 return 0;
}
//------------------------------------------------------------------------------------
int _stdcall LoadDbgClienConfig(void)
{
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 DBGMSG("Enter");
 plugin_menuclear(DbgCliMenu);
 if(DbgIPC->ExchangeMsg(XNI::miDbgGetConfigs,XNI::mtUsrReq, &api, &apo) < 0){DBGMSG("miDbgGetConfigs failed!"); return -1;}
 for(;;)
  {
   char Name[128];
   UINT Hint   = sizeof(Name);   // On input it is size of name
   UINT ValLen = 0;
   PBYTE Ptr   = apo.PopBlkEx(&ValLen,Name,&Hint);
   if(!Ptr)break;   // No more configs
   UINT CfgIdx = 0;
   UINT Type   = XNI::CDbgClient::ReadCfgItemID(Hint, &CfgIdx);
   if(Type & XNI::dtBool)
    {     
     plugin_menuaddentry(DbgCliMenu, MENU_ID_DBGCLIENT+CfgIdx, Name);
     plugin_menuentrysetchecked(PluginHandle,MENU_ID_DBGCLIENT+CfgIdx,*(bool*)Ptr);
     DbgCliFlags[CfgIdx] = *(bool*)Ptr;
    }
     else if(Type & XNI::dtNull)plugin_menuaddseparator(DbgCliMenu);
  }
 DBGMSG("Done");
 return 0;
}
//------------------------------------------------------------------------------------
int _stdcall SetSingleConfig(UINT CfgID, UINT CfgType, PVOID CfgAddr)
{
 DBGMSG("CfgID=%u, CfgType=%u",CfgID,CfgType);
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 UINT ValLen = 0;
 if(CfgType & (XNI::dtBool|XNI::dtBYTE))ValLen = 1;
 else if(CfgType & XNI::dtWORD)ValLen  = 2;
 else if(CfgType & XNI::dtDWORD)ValLen = 4;
 else if(CfgType & XNI::dtQWORD)ValLen = 8;
 api.PushBlkEx(ValLen, CfgAddr, NULL, XNI::CDbgClient::MakeCfgItemID(CfgID,CfgType));
 if(DbgIPC->ExchangeMsg(XNI::miDbgSetConfigs,XNI::mtUsrReq, &api, &apo) < 0)return -1;
 return 0;
}
//------------------------------------------------------------------------------------
int _stdcall InjectProcess(HANDLE hProcess, DWORD ProcessID)
{
 CArr<BYTE> DllData;
 wchar_t DllPath[MAX_PATH];
 UINT Flags   = InjFlags|NInjLdr::mfRawMod|NPEFMT::fmCryHdr|NPEFMT::fmCryImp|NPEFMT::fmCryExp|NPEFMT::fmCryRes;    // TODO: Inject method to cfg (Separated)
 UINT ResSize = 0;
 PVOID InjLib = NULL;
 NSTR::StrCopy(DllPath, StartUpDir);
 NSTR::StrCnat(DllPath, L"injlib.dll");        // Store this name in some global definition?
 plugin_logprintf("%s: Trying to inject process %u\n",XDBGPLG_NAME,ProcessID);
 HANDLE hFile = CreateFileW(DllPath,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
 if(hFile != INVALID_HANDLE_VALUE)
  {
   DWORD Result   = 0;
   ResSize = GetFileSize(hFile,NULL);
   DllData.Resize(ResSize);
   if(ResSize)ReadFile(hFile,DllData.Data(),ResSize,&Result,NULL);
   CloseHandle(hFile);
   InjLib = DllData.Data();
   DBGMSG("InjLib loaded from file: %ls",&DllPath);
   plugin_logprintf("InjLib loaded from file: %ls\n",&DllPath);
  }
   else InjLib = GetResource(hInst, "InjLib", RT_RCDATA, &ResSize);
 if(!InjLib || !ResSize){DBGMSG("No InjLib found!"); return -1;}
 bool POpened = (hProcess == NULL);
 DWORD ExtraFlags = 0;
 if(SingleCore)ExtraFlags |= PROCESS_SET_INFORMATION;
 if(POpened)hProcess = NInjLdr::OpenRemoteProcess(ProcessID, Flags, SuspendProc, ExtraFlags);   
 if(!hProcess)return -2; 
 if(SingleCore)ForceProcessSingleCore(hProcess);
 if(SuspendProc)
  {
   if(!POpened)
    {
     DuplicateHandle(NtCurrentProcess, hProcess, NtCurrentProcess, &hLstProc, 0, 0, DUPLICATE_SAME_ACCESS);
     NTSTATUS stat = NtSuspendProcess(hLstProc); 
     DBGMSG("Entire process been suspended: Status=%08X, DupHandle=%p",stat,hLstProc);
    }
     else hLstProc = hProcess;
  } 
 if(!POpened && NNTDLL::IsWinXPOrOlder())Flags &= ~NInjLdr::mfRawRMTH;    // On Windows XP this Csr unfriendly thread will catch a process initialization APC!  // A DebugApi remote thread will also catch this APC and DebugApi threas is also not registered with Csr   // On latest Win10 raw threads can`t be injected in notepad.exe (Access Denied)
 int res = NInjLdr::InjModuleIntoProcessAndExec(hProcess, InjLib, ResSize, Flags|NInjLdr::mfResSyscall, 3, NULL, NULL, NtDllBase, 0x20000);   // mfResSyscall is required to avoid self interception    // Only .text(Data merged), .bss and .rdata   // !!! Something at LdrpInitializeThunk requires stack size not less than 0x20000 or the thread will be silently terminated unless it is watched in 'Process Explorer' or a debugger !!!
 if(POpened && !SuspendProc)CloseHandle(hProcess);     // Close after OpenRemoteProcess
 if(res < 0){DBGMSG("InjModuleIntoProcessAndExec failed with %i",res); if(SuspendProc)NtResumeProcess(hProcess); return -3;}    // Cannot terminate without a specific permission
 for(int ctr=WaitForInj;ctr > 0;ctr-=100)
  {      
   Sleep(100);
   if(SHM::CMessageIPC::IsExistForID(ProcessID))break;
  }
 if(!SHM::CMessageIPC::IsExistForID(ProcessID))return -4;
 plugin_logprintf("%s: Target process injection succeeded\n",XDBGPLG_NAME);
 return 0;
}
//------------------------------------------------------------------------------------
// Main threas is suspended, but some additional threads are not
//
BOOL _stdcall ProcessCreateInjWrk(LPPROCESS_INFORMATION lpProcessInformation)
{        
 BOOL res = FALSE; 
 HANDLE hRealThrd = lpProcessInformation->hThread;
 HANDLE hRealProc = lpProcessInformation->hProcess;
 hSuspTh = NULL;
 plugin_logprintf("%s: Trying to inject new process %u\n",XDBGPLG_NAME,(DWORD)lpProcessInformation->dwProcessId);
 lpProcessInformation->hProcess = XNI::CDbgClient::UintToFakeHandle(lpProcessInformation->dwProcessId);      // All communication with a target process is only through IPC 
 lpProcessInformation->hThread  = XNI::CDbgClient::UintToFakeHandle(0);      // Any first thread in list!
 int ires = InjectProcess(hRealProc, lpProcessInformation->dwProcessId);
 if(ires >= 0)
  {
   if(lpProcessInformation->dwProcessId != DbgIPC->GetID())DbgIPC->Disconnect();      // Has been connected to some other process
   if(DbgIPC->Connect((DWORD)lpProcessInformation->dwProcessId, 0, true) >= 0) 
    {
     ThList->Clear();
     LstProcID = DbgProcID = lpProcessInformation->dwProcessId;     // Required for ProcWaitForDebugEvent
     DBGMSG("hProcess=%08X, hThread=%08X, ProcessId=%u, ThreadId=%u",lpProcessInformation->hProcess,lpProcessInformation->hThread,lpProcessInformation->dwProcessId,lpProcessInformation->dwThreadId);
     SHM::CArgPack<> api;
     SHM::CArgPack<> apo;
     api.PushArg(lpProcessInformation->dwProcessId);
     if(DbgIPC->ExchangeMsg(XNI::miDebugActiveProcess,XNI::mtDbgReq, &api, &apo) >= 0)    // Do an usual attach but to a suspended process (Should have a single worker thread)
      {
       DWORD  MainThID = 0;
       HANDLE hPHandle = NULL;
       HANDLE hTHandle = NULL;
       PTEB  MainThTeb = NULL;
       apo.PopArg(res);
       apo.PopArg(MainThID);
       apo.PopArg(MainThTeb);
       apo.PopArg(hTHandle);
       apo.PopArg(hPHandle);
       lpProcessInformation->hProcess = hPHandle;
       lpProcessInformation->hThread  = hTHandle;
       ThList->AddThreadToList(MainThTeb, MainThID, hTHandle, false);    // NOTE: Watch for CloseHandle for thread handles
       LoadDbgClienConfig();
       if(res)hSuspTh = hRealThrd;
///////////////       plugin_logprintf("Main thread is in suspended state\n");   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      }
    }
     else {DBGMSG("Connect failed: %08X(%u)",lpProcessInformation->dwProcessId,lpProcessInformation->dwProcessId);}
  }
   else {DBGMSG("Failed to inject a new process: %08X(%u): %i",lpProcessInformation->dwProcessId,lpProcessInformation->dwProcessId,ires);}
 if(!res){TerminateProcess(hRealProc,0); CloseHandle(hRealThrd);}
 CloseHandle(hRealProc);
 plugin_logprintf("%s: New process injection succeeded\n",XDBGPLG_NAME);
 return res;
}
//------------------------------------------------------------------------------------


//====================================================================================
//
//                          HOOKED SUPPORT FUNCTIONS
//
//------------------------------------------------------------------------------------
// Opening a Process/Thread is forbidden besause some nasty AntiCheat can track this
//
NTSTATUS NTAPI ProcNtOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId)
{    
 DBGMSG("Opening: DbgProcID=%08X, LstProcID=%08X, ProcessID=%08X",DbgProcID,LstProcID,ClientId->UniqueProcess);
 if(LstProcID == (ULONG)ClientId->UniqueProcess)   // x64Dbg will try multiple times!
 {   
  if(!DbgProcID){DBGMSG("Reopening prevented!"); return STATUS_ACCESS_DENIED;}
  *ProcessHandle = XNI::CDbgClient::UintToFakeHandle((ULONG)ClientId->UniqueProcess); 
  DBGMSG("Reopening emulated!");     // "Reopening allowed!"
  return STATUS_SUCCESS;             // HookNtOpenProcess.OrigProc(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);;
 } 
 bool HaveMapping = SHM::CMessageIPC::IsExistForID((DWORD)ClientId->UniqueProcess);                                
 if(PLogOnly || !ClientId || !ProcessHandle || (!HaveMapping && AllowInject))    // Injection(optional) moved to DebugActiveProcess because opening a process is done after DebugActiveProcess  
  {
   NTSTATUS Res = HookNtOpenProcess.OrigProc(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);
   HANDLE   Hnd = (ProcessHandle)?(*ProcessHandle):(INVALID_HANDLE_VALUE);
   DBGMSG("StatusA=%08X, ProcessHandle=%08X, DesiredAccess=%08X, UniqueProcess=%08X, UniqueThread=%08X",Res,Hnd,DesiredAccess,(ClientId)?(ClientId->UniqueProcess):(0),(ClientId)?(ClientId->UniqueThread):(0));
   return Res;
  }
 if(!HaveMapping)return STATUS_UNSUCCESSFUL;   // Debugger will try to open every process. Do not show processes without already injected DLLs
 if((DWORD)ClientId->UniqueProcess != DbgIPC->GetID())DbgIPC->Disconnect();      // Has been connected to some other process
 if(DbgIPC->Connect((DWORD)ClientId->UniqueProcess, 0, true) < 0){DBGMSG("Connect failed: %08X(%u)",ClientId->UniqueProcess,ClientId->UniqueProcess); return STATUS_UNSUCCESSFUL;}
 LstProcID = DbgProcID = (DWORD)ClientId->UniqueProcess;
 ThList->Clear();
 *ProcessHandle = XNI::CDbgClient::UintToFakeHandle((DWORD)ClientId->UniqueProcess);      // All communication with a target process is only through IPC 
 DBGMSG("FakeProcessHandle=%08X, DesiredAccess=%08X, UniqueProcess=%08X, UniqueThread=%08X",*ProcessHandle,DesiredAccess,ClientId->UniqueProcess,ClientId->UniqueThread);
 return STATUS_SUCCESS;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtOpenThread(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId)
{
 HANDLE hTh = NULL;  
 DBGMSG("Opening: DbgProcID=%08X, ProcessID=%08X, ThreadID=%08X",DbgProcID,ClientId->UniqueProcess,ClientId->UniqueThread);
 bool State = PLogOnly || !DbgProcID || !ClientId || !ThreadHandle;
 if(State || !(hTh = ThList->GetHandleByIndex(ThList->FindThreadIdxInList(NULL, (DWORD)ClientId->UniqueThread, NULL))))   // TODO: Need a way to know main thread`s index(In GhostDbg list) of a new created process. It may be requested before CREATE_PROCESS_DEBUG_EVENT
  {
   if(State && ClientId->UniqueThread && (ThList->FindThreadIdxInList(NULL, (DWORD)ClientId->UniqueThread, NULL) >= 0)){DBGMSG("Opening prevented!"); return STATUS_ACCESS_DENIED;}    // x64Dbg will try multiple times!
   NTSTATUS Res = HookNtOpenThread.OrigProc(ThreadHandle, DesiredAccess, ObjectAttributes, ClientId);
   DBGMSG("Status=%08X, ThreadHandle=%08X, DesiredAccess=%08X, UniqueProcess=%08X, UniqueThread=%08X",Res,((ThreadHandle)?(*ThreadHandle):(INVALID_HANDLE_VALUE)),DesiredAccess,(ClientId)?(ClientId->UniqueProcess):(0),(ClientId)?(ClientId->UniqueThread):(0));
   return Res;
  }
 *ThreadHandle = hTh;
 DBGMSG("FakeThreadHandle=%08X, DesiredAccess=%08X, UniqueProcess=%08X, UniqueThread=%08X",hTh,DesiredAccess,ClientId->UniqueProcess,ClientId->UniqueThread);
 return STATUS_SUCCESS;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options)
{                                                  
 if(PLogOnly || !TargetHandle || !XNI::CDbgClient::IsFakeHandle(SourceHandle))
  {
   NTSTATUS Res = HookNtDuplicateObject.OrigProc(SourceProcessHandle, SourceHandle, TargetProcessHandle, TargetHandle, DesiredAccess, HandleAttributes, Options);
   HANDLE   Hnd = (TargetHandle)?(*TargetHandle):(INVALID_HANDLE_VALUE);
   DBGMSG("Status=%08X, TargetHandle=%08X, SourceHandle=%08X, SourceProcessHandle=%08X, TargetProcessHandle=%08X, DesiredAccess=%08X, HandleAttributes=%08X, Options=%08X",Res,Hnd,SourceHandle,SourceProcessHandle,TargetProcessHandle,DesiredAccess,HandleAttributes,Options);
   return Res;
  } 
 *TargetHandle = SourceHandle;        
 DBGMSG("FakeHandle=%08X(%08X), SourceProcessHandle=%08X, TargetProcessHandle=%08X, DesiredAccess=%08X, HandleAttributes=%08X, Options=%08X",SourceHandle,*TargetHandle,SourceProcessHandle,TargetProcessHandle,DesiredAccess,HandleAttributes,Options);
 return STATUS_SUCCESS;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtClose(HANDLE Handle)
{                                          
 if(PLogOnly || !XNI::CDbgClient::IsFakeHandle(Handle))return HookNtClose.OrigProc(Handle);
 DBGMSG("FakeHandle=%08X",Handle);      // Closing some fake handle
 return STATUS_SUCCESS;
}
//------------------------------------------------------------------------------------
BOOL WINAPI ProcCreateProcessA(LPCSTR lpApplicationName,LPSTR lpCommandLine,LPSECURITY_ATTRIBUTES lpProcessAttributes,LPSECURITY_ATTRIBUTES lpThreadAttributes,BOOL bInheritHandles,DWORD dwCreationFlags,LPVOID lpEnvironment,LPCSTR lpCurrentDirectory,LPSTARTUPINFOA lpStartupInfo,LPPROCESS_INFORMATION lpProcessInformation)
{
 DBGMSG("dwCreationFlags=%08X, lpApplicationName='%s',lpCommandLine='%s'",dwCreationFlags,lpApplicationName?lpApplicationName:"",lpCommandLine?lpCommandLine:"");
 bool ForDebug = AllowInjNew && (dwCreationFlags & (DEBUG_PROCESS|DEBUG_ONLY_THIS_PROCESS));
 if(ForDebug)
  {
   dwCreationFlags &= ~(DEBUG_PROCESS|DEBUG_ONLY_THIS_PROCESS);
   dwCreationFlags |= CREATE_SUSPENDED;     // Instead of DEBUG_PROCESS
  }
 BOOL res = HookCreateProcessA.OrigProc(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
 DBGMSG("ProcessId=%u, ThreadId=%u",lpProcessInformation->dwProcessId,lpProcessInformation->dwThreadId);  
 if(res && ForDebug && lpProcessInformation)res = ProcessCreateInjWrk(lpProcessInformation); 
 return res;
}
//------------------------------------------------------------------------------------
BOOL WINAPI ProcCreateProcessW(LPCWSTR lpApplicationName,LPWSTR lpCommandLine,LPSECURITY_ATTRIBUTES lpProcessAttributes,LPSECURITY_ATTRIBUTES lpThreadAttributes,BOOL bInheritHandles,DWORD dwCreationFlags,LPVOID lpEnvironment,LPCWSTR lpCurrentDirectory,LPSTARTUPINFOW lpStartupInfo,LPPROCESS_INFORMATION lpProcessInformation)
{
 DBGMSG("dwCreationFlags=%08X, lpApplicationName='%ls',lpCommandLine='%ls'",dwCreationFlags,lpApplicationName?lpApplicationName:L"",lpCommandLine?lpCommandLine:L"");
 bool ForDebug = AllowInjNew && (dwCreationFlags & (DEBUG_PROCESS|DEBUG_ONLY_THIS_PROCESS));
 if(ForDebug)
  {
   dwCreationFlags &= ~(DEBUG_PROCESS|DEBUG_ONLY_THIS_PROCESS);
   dwCreationFlags |= CREATE_SUSPENDED;     // Instead of DEBUG_PROCESS
  }
 BOOL res = HookCreateProcessW.OrigProc(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation); 
 DBGMSG("ProcessId=%u, ThreadId=%u",lpProcessInformation->dwProcessId,lpProcessInformation->dwThreadId);  
 if(res && ForDebug && lpProcessInformation)res = ProcessCreateInjWrk(lpProcessInformation);
 return res;
}
//------------------------------------------------------------------------------------
BOOL WINAPI ProcIsWow64Process(HANDLE hProcess, PBOOL Wow64Process)   // In Windows 10 (2019) it passes process` handle to NtQuerySystemInformationEx
{
 PVOID Value  = NULL;
 ULONG RetLen = 0;
 NTSTATUS Status = NtQueryInformationProcess(hProcess, ProcessWow64Information, &Value, sizeof(Value), &RetLen);
 if(Status < 0)RtlSetLastWin32Error(RtlNtStatusToDosError(Status));
   else if(Wow64Process)*Wow64Process = (bool)Value;
 DBGMSG("Status=%08X, hProcess=%p, Value=%u",Status,hProcess,(UINT)Value);
 return (Status >= 0);
}

//====================================================================================
//
//                            HOOKED DEBUG WINAPI
//
//------------------------------------------------------------------------------------
// When a debugger attached, a debuggee must send events for all threads and modules (CREATE_PROCESS_DEBUG_EVENT, CREATE_THREAD_DEBUG_EVENT..., LOAD_DLL_DEBUG_EVENT...)
//
BOOL WINAPI ProcWaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
{                                           
 DBGMSG("lpDebugEvent=%p, dwMilliseconds=%u",lpDebugEvent,dwMilliseconds);
 if(PLogOnly || !DbgProcID)
  {
   DBGMSG("PLogOnly=%u, DbgProcID=%u",PLogOnly,DbgProcID);
   BOOL res = HookWaitForDebugEvent.OrigProc(lpDebugEvent, dwMilliseconds);
   if(res){DBGMSG("dwDebugEventCode=%08X, dwProcessId=%08X, dwThreadId=%08X, BASE: %p",lpDebugEvent->dwDebugEventCode,lpDebugEvent->dwProcessId,lpDebugEvent->dwThreadId,lpDebugEvent->u.LoadDll.lpBaseOfDll);}
   return res;
  }
 while(!BreakWrk && DbgIPC->IsOtherConnections())          // If debugger kills this thread while the buffer is still locked what will happen?
  { 
   SHM::CMessageIPC::SMsgHdr* Cmd = DbgIPC->GetMsg();
   if(!Cmd)continue;       // Timeout and still no message
//   DBGMSG("MsgType=%04X, MsgID=%04X, DataID=%08X, Sequence=%08X, DataSize=%08X",Cmd->MsgType,Cmd->MsgID,Cmd->DataID,Cmd->Sequence,Cmd->DataSize);   // DISABLED: Other threaads will spam IPC with ReadVirtualMemory requests no mattter which tab is opened
   if((Cmd->MsgType != XNI::mtDbgRsp)||(Cmd->MsgID != XNI::miWaitForDebugEvent)||(Cmd->DataSize < sizeof(XNI::DbgEvtEx)))continue;   // Not a Response (All debug events are sent as Response without a Request)
   XNI::DbgEvtEx* Evt = (XNI::DbgEvtEx*)&Cmd->Data;
   DBGMSG("Code=%u, ThreadID=%08X(%u)",Evt->dwDebugEventCode,Evt->dwThreadId,Evt->dwThreadId);
   switch(Evt->dwDebugEventCode)
    {
     case EXCEPTION_DEBUG_EVENT:
      {
       DBGMSG("EXCEPTION_DEBUG_EVENT: dwThreadId=%u, Code=%08X, Addr=%p",Evt->dwThreadId,Evt->u.Exception.ExceptionRecord.ExceptionCode, Evt->u.Exception.ExceptionRecord.ExceptionAddress); 
      }
      break;
     case CREATE_THREAD_DEBUG_EVENT:
      {                              
       DBGMSG("CREATE_THREAD_DEBUG_EVENT: hThread=%08X, dwThreadId=%u",Evt->u.CreateThread.hThread,Evt->dwThreadId);
       ThList->AddThreadToList((TEB*)Evt->u.CreateThread.lpThreadLocalBase, Evt->dwThreadId, Evt->u.CreateThread.hThread, false);    // NOTE: Watch for CloseHandle for thread handles
      }
      break;
     case CREATE_PROCESS_DEBUG_EVENT:
      {                             
       DBGMSG("CREATE_PROCESS_DEBUG_EVENT: hProcess=%08X, hThread=%08X, dwThreadId=%u",Evt->u.CreateProcessInfo.hProcess,Evt->u.CreateProcessInfo.hThread,Evt->dwThreadId);
       ThList->AddThreadToList((TEB*)Evt->u.CreateThread.lpThreadLocalBase, Evt->dwThreadId, Evt->u.CreateProcessInfo.hThread, false);   // This fake handle is an encoded index in client`s thread list
       if(hSuspTh){ResumeThread(hSuspTh); CloseHandle(hSuspTh); hSuspTh = NULL; DBGMSG("Main thread has been resumed");}   // Was created as suspended     // TODO: Optionally left main thread suspended if a new process started?
       if(SuspendProc && hLstProc){NTSTATUS stat = NtResumeProcess(hLstProc); CloseHandle(hLstProc); DBGMSG("Entire process been resumed: Status=%08X, Handle=%p",stat,hLstProc); hLstProc=NULL;}    // GhostDbg initialization is finished
      }
      break;
     case EXIT_THREAD_DEBUG_EVENT:
      {
       DBGMSG("EXIT_THREAD_DEBUG_EVENT: dwThreadId=%u, dwExitCode=%u",Evt->dwThreadId,Evt->u.ExitThread.dwExitCode);
       ThList->RemoveThreadFromList(Evt->dwThreadId);      
      }
      break;
     case EXIT_PROCESS_DEBUG_EVENT:
      {
       DBGMSG("EXIT_PROCESS_DEBUG_EVENT: dwProcessId=%u, dwExitCode=%u",Evt->dwProcessId,Evt->u.ExitProcess.dwExitCode);
       if(DbgProcID == Evt->dwProcessId)DoDisconnAtTerm = true;
      }
      break;
     case LOAD_DLL_DEBUG_EVENT:
      {
       DBGMSG("LOAD_DLL_DEBUG_EVENT: DllBase=%p, dwThreadId=%u",Evt->u.LoadDll.lpBaseOfDll, Evt->dwThreadId);
      }
      break;
     case UNLOAD_DLL_DEBUG_EVENT:
      {
       DBGMSG("UNLOAD_DLL_DEBUG_EVENT: DllBase=%p, dwThreadId=%u",Evt->u.UnloadDll.lpBaseOfDll, Evt->dwThreadId);
      }
      break;
     case OUTPUT_DEBUG_STRING_EVENT:
      {
       // Unused
      }
      break;
     case RIP_EVENT:
      {
       // Unused
      }
      break;

     default: {DBGMSG("Unknown DebugEventCode: %u",Evt->dwDebugEventCode);}
    }
   memcpy(lpDebugEvent,&Cmd->Data,sizeof(DEBUG_EVENT));
   DbgIPC->EndMsg(false);   // Unlock shared buffer   // Only single events can be removed because they read in order of arrival     // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
   DBGMSG("CONTINUE");
   return TRUE;        // Other events will wait untiiiil another call to WaitForDebugEvent
  }
 DBGMSG("FINISH");
 DbgProcID = 0;          // No DebugActiveProcessStop is called when WaitForDebugEvent is failed
 DbgIPC->EndMsg(false);   // Unlock shared buffer if it is still locked    // <<<<<<<<<<<<<<<<<<< FALSE for now!
 DbgIPC->Disconnect();
 plugin_menuclear(DbgCliMenu);
 return FALSE;
}
//------------------------------------------------------------------------------------
BOOL WINAPI ProcDebugActiveProcess(DWORD dwProcessId)     // Thes will make a debuggee to prepare bunch of events for WaitForDebugEvent (CREATE_PROCESS_DEBUG_EVENT,CREATE_THREAD_DEBUG_EVENT,LOAD_DLL_DEBUG_EVENT) 
{
 DBGMSG("dwProcessId=%08X",dwProcessId);
 if(PLogOnly || !DbgIPC)return HookDebugActiveProcess.OrigProc(dwProcessId);
 if(dwProcessId != DbgIPC->GetID())DbgIPC->Disconnect();      // Has been connected to some other process
 if(!SHM::CMessageIPC::IsExistForID(dwProcessId))
  {
   if(AllowInject)
    {
     if(int res = InjectProcess(NULL, dwProcessId); res < 0){DBGMSG("Failed to inject: %i", res); return FALSE;}    
    }
     else return FALSE;
  }
 if(int res = DbgIPC->Connect(dwProcessId, 0, true); res < 0){DBGMSG("Failed to connect: %i", res); return FALSE;}
 LstProcID = DbgProcID = dwProcessId;
 ThList->Clear();
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(dwProcessId);
 if(DbgIPC->ExchangeMsg(XNI::miDebugActiveProcess,XNI::mtDbgReq, &api, &apo) < 0){DBGMSG("Failed to communicate!"); return FALSE;}
 BOOL res = FALSE;
 DWORD  MainThID = 0;
 HANDLE hPHandle = NULL;
 HANDLE hTHandle = NULL;
 PTEB  MainThTeb = NULL;
 apo.PopArg(res);
 apo.PopArg(MainThID);
 apo.PopArg(MainThTeb);
 apo.PopArg(hTHandle);
 apo.PopArg(hPHandle);
 ThList->AddThreadToList(MainThTeb, MainThID, hTHandle, false);    // NOTE: Watch for CloseHandle for thread handles
 LoadDbgClienConfig();
 return res;
}
//------------------------------------------------------------------------------------
BOOL WINAPI ProcDebugActiveProcessStop(DWORD dwProcessId)    // Doesn`t called a first time you do Detach because TitanEngine wants a SystemBreakpoint (FirstBPX - a first BP which is not in its list) 
{
 DBGMSG("dwProcessId=%08X",dwProcessId);
 if(PLogOnly || !DbgIPC || !DbgProcID)return HookDebugActiveProcessStop.OrigProc(dwProcessId);
 if(DbgProcID == dwProcessId)LstProcID = DbgProcID = 0;     // Allow reopening of a target process 
 SHM::CArgPack<> api;
 api.PushArg(dwProcessId);
 int res = DbgIPC->ExchangeMsg(XNI::miDebugActiveProcessStop,XNI::mtDbgReq, &api, NULL);
 DbgIPC->ExchangeMsg(XNI::miDbgDetachNtfy,XNI::mtUsrReq, &api, NULL);
 DbgIPC->Disconnect();
 return (res >= 0);   
}
//------------------------------------------------------------------------------------
BOOL WINAPI ProcContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
{
 DBGMSG("dwProcessId=%08X, dwThreadId=%u, dwContinueStatus=%08X",dwProcessId,dwThreadId,dwContinueStatus);
 if(PLogOnly || !DbgIPC || !DbgProcID)return HookContinueDebugEvent.OrigProc(dwProcessId, dwThreadId, dwContinueStatus); 
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(dwContinueStatus);
 api.PushArg(dwThreadId);
 api.PushArg(dwProcessId);
 if(DoDisconnAtTerm)  // Need to wait here to other threads which read Memory/ThreadInfo in a loop or termination will be slow
  {
   DBGMSG("Waiting for other threads to stop accessing the finished process...");
   Sleep(1000);    // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
   DBGMSG("Continuing target process termination");
  }
 if(DbgIPC->ExchangeMsg(XNI::miContinueDebugEvent,XNI::mtDbgReq, &api, &apo) < 0)return FALSE;
 BOOL res = FALSE;
 apo.PopArg(res);
 if(DoDisconnAtTerm && DbgIPC)
  {
   DoDisconnAtTerm = false;
   DbgProcID = 0;
   DbgIPC->Disconnect();
  }
 return res;
}
//------------------------------------------------------------------------------------
BOOL WINAPI ProcDebugBreakProcess(HANDLE hProcess)     // Does ntdll.RtlpCreateUserThreadEx on remote DbgUserBreakPoint
{
 DBGMSG("hProcess=%p",hProcess);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(hProcess))return HookDebugBreakProcess.OrigProc(hProcess);
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(hProcess);
 if(DbgIPC->ExchangeMsg(XNI::miDebugBreakProcess,XNI::mtDbgReq, &api, &apo) < 0)return FALSE;
 BOOL res = FALSE;
 apo.PopArg(res);
 return res;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus)
{
 DBGMSG("ProcessHandle=%p, ExitStatus=%08X",ProcessHandle,ExitStatus);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ProcessHandle))return HookNtTerminateProcess.OrigProc(ProcessHandle, ExitStatus);
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(ExitStatus);
 api.PushArg(ProcessHandle);
 if(DbgIPC->ExchangeMsg(XNI::miTerminateProcess,XNI::mtDbgReq, &api, &apo) < 0)return FALSE;
 NTSTATUS res = STATUS_UNSUCCESSFUL;
 apo.PopArg(res);
 if(!res)DbgIPC->Disconnect();   // x64Dbg is still owns the process handle and will try to request the process info with it!
 DbgProcID = 0;  // ????????????????????
 return res;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtGetContextThread(HANDLE ThreadHandle, PCONTEXT Context)
{                     
 DBGMSG("ThreadHandle=%p, Context=%p",ThreadHandle,Context);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ThreadHandle) || !ThList->IsThreadInList(0,ThreadHandle))return HookNtGetContextThread.OrigProc(ThreadHandle, Context); 
 NTSTATUS Status;
 SHM::CArgPack<sizeof(CONTEXT)+sizeof(HANDLE)> api;
 SHM::CArgPack<sizeof(CONTEXT)+sizeof(HANDLE)> apo;
 api.PushArg(*Context);   // InOut
 api.PushArg(ThreadHandle);
 if(DbgIPC->ExchangeMsg(XNI::miGetThreadContext,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(*Context);
 DBGMSG("RET: ThHndle=%p, Context=%p, PC=%p, Trace=%u, DbgRegs=%u, DR7=%p, DR0=%p, DR1=%p, DR2=%p, DR3=%p",ThreadHandle,Context,XNI::CDbgClient::GetInstrPtr(Context),bool(Context->EFlags&0x0100),bool(Context->ContextFlags & CONTEXT_DEBUG_REGISTERS), Context->Dr7,Context->Dr0,Context->Dr1,Context->Dr2,Context->Dr3);
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtSetContextThread(HANDLE ThreadHandle, PCONTEXT Context)
{
 DBGMSG("ThreadHandle=%p, Context=%p, PC=%p, Trace=%u, DbgRegs=%u, DR7=%p, DR0=%p, DR1=%p, DR2=%p, DR3=%p",ThreadHandle,Context,XNI::CDbgClient::GetInstrPtr(Context),bool(Context->EFlags&0x0100),bool(Context->ContextFlags & CONTEXT_DEBUG_REGISTERS), Context->Dr7,Context->Dr0,Context->Dr1,Context->Dr2,Context->Dr3);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ThreadHandle) || !ThList->IsThreadInList(0,ThreadHandle))return HookNtSetContextThread.OrigProc(ThreadHandle, Context);
 NTSTATUS Status;
 SHM::CArgPack<sizeof(CONTEXT)+sizeof(HANDLE)> api;
 SHM::CArgPack<> apo;
 api.PushArg(*Context);
 api.PushArg(ThreadHandle);
 if(DbgIPC->ExchangeMsg(XNI::miSetThreadContext,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferLength, PSIZE_T ReturnLength)
{
// DBGMSG("ProcessHandle=%p, BaseAddress=%p, Buffer=%p, BufferLength=%08X, ReturnLength=%p",ProcessHandle,BaseAddress,Buffer,BufferLength,ReturnLength);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ProcessHandle))return HookNtReadVirtualMemory.OrigProc(ProcessHandle, BaseAddress, Buffer, BufferLength, ReturnLength);
 SIZE_T RetLen = 0;
 NTSTATUS Status;
 SHM::CArgPack<> api;
 SHM::CArgPack<3072> apo;
 api.PushArg(BufferLength);
 api.PushArg(BaseAddress);
 api.PushArg(ProcessHandle);
 if(DbgIPC->ExchangeMsg(XNI::miReadVirtualMemory,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(RetLen);
 apo.PopBlk(BufferLength,Buffer);      // Always exchange an entire buffer?
 if(ReturnLength)*ReturnLength = RetLen;
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtWriteVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferLength, PSIZE_T ReturnLength)
{
 DBGMSG("ProcessHandle=%p, BaseAddress=%p, Buffer=%p, BufferLength=%08X, BYTE=%02X, ReturnLength=%p",ProcessHandle,BaseAddress,Buffer,BufferLength,(Buffer)?(*(PBYTE)Buffer):0,ReturnLength);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ProcessHandle))return HookNtWriteVirtualMemory.OrigProc(ProcessHandle, BaseAddress, Buffer, BufferLength, ReturnLength);
 SIZE_T RetLen = 0;
 NTSTATUS Status;
 SHM::CArgPack<3072> api;
 SHM::CArgPack<> apo;
 api.PushBlk(BufferLength, Buffer);
 api.PushArg(BufferLength);
 api.PushArg(BaseAddress);
 api.PushArg(ProcessHandle);
 if(DbgIPC->ExchangeMsg(XNI::miWriteVirtualMemory,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(RetLen);
 if(ReturnLength)*ReturnLength = RetLen;
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG NewProtect, PULONG OldProtect)
{
 DBGMSG("ProcessHandle=%p, BaseAddress=%p, RegionSize=%08X, NewProtect=%08X",ProcessHandle,(BaseAddress)?(*BaseAddress):(NULL),(RegionSize)?(*RegionSize):(0),NewProtect);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ProcessHandle) || !BaseAddress || !RegionSize)return HookNtProtectVirtualMemory.OrigProc(ProcessHandle, BaseAddress, RegionSize, NewProtect, OldProtect);
 NTSTATUS Status;
 ULONG OldProt;
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(NewProtect);
 api.PushArg(*RegionSize);
 api.PushArg(*BaseAddress);
 api.PushArg(ProcessHandle);
 if(DbgIPC->ExchangeMsg(XNI::miProtectVirtualMemory,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(*RegionSize);
 apo.PopArg(*BaseAddress);
 apo.PopArg(OldProt);
 if(OldProtect)*OldProtect = OldProt; 
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtFlushVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus)     // Used by WriteProcessMemory
{                                       
 DBGMSG("ProcessHandle=%p, BaseAddress=%p, RegionSize=%08X",ProcessHandle,(BaseAddress)?(*BaseAddress):(NULL),(RegionSize)?(*RegionSize):(0));
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ProcessHandle) || !BaseAddress || !RegionSize)return HookNtFlushVirtualMemory.OrigProc(ProcessHandle, BaseAddress, RegionSize, IoStatus);
 NTSTATUS Status;
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(*RegionSize);
 api.PushArg(*BaseAddress);
 api.PushArg(ProcessHandle);
 if(DbgIPC->ExchangeMsg(XNI::miFlushVirtualMemory,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(*RegionSize);
 apo.PopArg(*BaseAddress);
 apo.PopArg(*IoStatus);
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtSuspendThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount)
{
 DBGMSG("ThreadHandle=%p",ThreadHandle);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ThreadHandle) || !ThList->IsThreadInList(0,ThreadHandle)){return HookNtResumeThread.OrigProc(ThreadHandle,PreviousSuspendCount);}
 ULONG SuspCtr = 0;
 NTSTATUS Status;
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(ThreadHandle);
 if(DbgIPC->ExchangeMsg(XNI::miSuspendThread,XNI::mtDbgReq, &api, &apo) < 0){return STATUS_UNSUCCESSFUL;}
 apo.PopArg(Status);
 apo.PopArg(SuspCtr);
 if(PreviousSuspendCount)*PreviousSuspendCount = SuspCtr;
 DBGMSG("RET: ThreadHandle=%p, Status=%08X, SuspCtr=%u",ThreadHandle, Status, SuspCtr);
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount)
{
 DBGMSG("ThreadHandle=%p",ThreadHandle);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ThreadHandle) || !ThList->IsThreadInList(0,ThreadHandle))return HookNtResumeThread.OrigProc(ThreadHandle,PreviousSuspendCount);
 ULONG SuspCtr = 0;
 NTSTATUS Status;
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(ThreadHandle);
 if(DbgIPC->ExchangeMsg(XNI::miResumeThread,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(SuspCtr);
 if(PreviousSuspendCount)*PreviousSuspendCount = SuspCtr;
 DBGMSG("RET: ThreadHandle=%p, Status=%08X, SuspCtr=%u",ThreadHandle, Status, SuspCtr);
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtTerminateThread(HANDLE ThreadHandle, NTSTATUS ExitStatus)
{
 DBGMSG("ThreadHandle=%p, ExitStatus=%08X",ThreadHandle,ExitStatus);   
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ThreadHandle) || !ThList->IsThreadInList(0,ThreadHandle))return HookNtTerminateThread.OrigProc(ThreadHandle, ExitStatus);
 NTSTATUS Status;
 SHM::CArgPack<> api;
 SHM::CArgPack<> apo;
 api.PushArg(ExitStatus);
 api.PushArg(ThreadHandle);
 if(DbgIPC->ExchangeMsg(XNI::miTerminateThread,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;   
 apo.PopArg(Status);
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength)   // May be called from anywhere, especially from psapi.dll
{                                            
 DBGMSG("ProcessHandle=%08X, ProcessInformationClass=%u, ProcessInformationLength=%08X",ProcessHandle,ProcessInformationClass,ProcessInformationLength);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ProcessHandle))return HookNtQueryInformationProcess.OrigProc(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);  
 ULONG RetLen = 0;
 NTSTATUS Status;
 SHM::CArgPack<> api;
 SHM::CArgPack<3072> apo;
 api.PushArg(ProcessInformationLength);
 api.PushArg(ProcessInformationClass);
 api.PushArg(ProcessHandle);
 if(DbgIPC->ExchangeMsg(XNI::miQueryInformationProcess,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(RetLen);
 apo.PopBlk(ProcessInformationLength,ProcessInformation);    // Full buffer exchange
 if(ReturnLength)*ReturnLength = RetLen;
 if(Status || !RetLen){DBGMSG("Failed with status: %08X!",Status); return Status;}
 switch(ProcessInformationClass)            
  {
   case ProcessBasicInformation:
   case ProcessWow64Information:
    break;
   case ProcessImageFileName:
   case ProcessImageFileNameWin32:
    {
     UNICODE_STRING* str = (UNICODE_STRING*)ProcessInformation;
     str->Buffer = (PWSTR)&((PBYTE)ProcessInformation)[sizeof(UNICODE_STRING)];      // Change Ptr to our address space
    }
    break;

   default:
       DBGMSG("Untested information class: %u!",ProcessInformationClass);
//       DebugBreak();
  }  
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength)   // Used by GetThreadSelectorEntry
{                                
 DBGMSG("ThreadHandle=%08X, ThreadInformationClass=%u, ThreadInformationLength=%08X",ThreadHandle,ThreadInformationClass,ThreadInformationLength);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ThreadHandle))return HookNtQueryInformationThread.OrigProc(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);  
 ULONG RetLen = 0;
 NTSTATUS Status;
 SHM::CArgPack<> api;
 SHM::CArgPack<3072> apo;
 api.PushArg(ThreadInformationLength);
 api.PushArg(ThreadInformationClass);
 api.PushArg(ThreadHandle);
 if(DbgIPC->ExchangeMsg(XNI::miQueryInformationThread,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(RetLen);
 apo.PopBlk(ThreadInformationLength,ThreadInformation);    // Full buffer exchange
 if(ReturnLength)*ReturnLength = RetLen;
 if(Status || !RetLen){DBGMSG("Failed %u with status: %08X!",ThreadInformationClass,Status); return Status;}
 switch(ThreadInformationClass)            
  {
   case ThreadBasicInformation:
   case ThreadSuspendCount:    // Since Windows 8.1
   case ThreadCycleTime:
   case ThreadTimes:
    break;

   default:
       DBGMSG("Untested information class: %u!",ThreadInformationClass);
//       DebugBreak();
  }                   
 return Status;
}
//------------------------------------------------------------------------------------
NTSTATUS NTAPI ProcNtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength)
{                                        
// DBGMSG("ProcessHandle=%08X, BaseAddress=%p, MemoryInformationClass=%u, MemoryInformation=%p, MemoryInformationLength=%08X, ReturnLength=%p",ProcessHandle,BaseAddress,MemoryInformationClass,MemoryInformation,MemoryInformationLength,ReturnLength);
 if(PLogOnly || !DbgIPC || !XNI::CDbgClient::IsFakeHandle(ProcessHandle))return HookNtQueryVirtualMemory.OrigProc(ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation, MemoryInformationLength, ReturnLength);
 SIZE_T RetLen = 0;
 NTSTATUS Status;
 SHM::CArgPack<> api;
 SHM::CArgPack<3072> apo;
 api.PushArg(MemoryInformationLength);
 api.PushArg(MemoryInformationClass);
 api.PushArg(BaseAddress);
 api.PushArg(ProcessHandle);
 if(DbgIPC->ExchangeMsg(XNI::miQueryVirtualMemory,XNI::mtDbgReq, &api, &apo) < 0)return STATUS_UNSUCCESSFUL;
 apo.PopArg(Status);
 apo.PopArg(RetLen);
 apo.PopBlk(MemoryInformationLength,MemoryInformation);    // Full buffer exchange
 if(ReturnLength)*ReturnLength = RetLen;
 if(Status || !RetLen){DBGMSG("Failed with status: %08X, %p, %u!",Status,BaseAddress,MemoryInformationClass); return Status;}
 switch(MemoryInformationClass)            
  {
   case MemoryBasicInformation:
    break;
   case MemoryMappedFilenameInformation:
    {
     UNICODE_STRING* str = (UNICODE_STRING*)MemoryInformation;
     str->Buffer = (PWSTR)&((PBYTE)MemoryInformation)[sizeof(UNICODE_STRING)];      // Change Ptr to our address space
    }
    break;
          
   default:
       DBGMSG("Untested information class: %u!",MemoryInformationClass);
//       DebugBreak();
  }                   
 return Status;
}
//====================================================================================





================================================
File: XDbgPlugin/XDbgPlugin.h
================================================

#pragma once
/*
  Copyright (c) 2020 Victor Sheinmann, Vicshann@gmail.com

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
  to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
  and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
*/ 

#include "Common.hpp"

//====================================================================================
#define CFGSECNAME L"Parameters"
#define XDBGPLG_VERH		2
#define XDBGPLG_VERL		0
#define XDBGPLG_NAME     "GhostDbg"
#define XDBGPLG_BUILD    __DATE__ " - " __TIME__

#define MENU_ID_ENABLED		    1
#define MENU_ID_ABOUT		    2
#define MENU_ID_CHK_CANINJ      3
#define MENU_ID_CHK_CANINJNEW   4
#define MENU_ID_SUSPPROCESS     5
#define MENU_ID_USERAWTHREADS   6
#define MENU_ID_NOTHREADREPORTS 7
#define MENU_ID_FORCESINGLECORE 8
#define MENU_ID_DBGCLIENT       16

//====================================================================================

//====================================================================================

void _stdcall LoadConfiguration(void);
void _stdcall SaveConfiguration(void);
int  _stdcall EnablePlugin(void);
int  _stdcall DisablePlugin(void);

int  _stdcall LoadDbgClienConfig(void);
int  _stdcall SetSingleConfig(UINT CfgID, UINT CfgType, PVOID CfgAddr);

DWORD WINAPI  IPCQueueThread(LPVOID lpThreadParameter);

//------------------------------------------------------------------------------------
BOOL  WINAPI ProcDebugActiveProcess(DWORD dwProcessId);
BOOL  WINAPI ProcDebugActiveProcessStop(DWORD dwProcessId);
BOOL  WINAPI ProcWaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds);
BOOL  WINAPI ProcContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus);
BOOL  WINAPI ProcDebugBreakProcess(HANDLE Process);
BOOL  WINAPI ProcIsWow64Process(HANDLE hProcess, PBOOL Wow64Process);
BOOL  WINAPI ProcCreateProcessA(LPCSTR lpApplicationName,LPSTR lpCommandLine,LPSECURITY_ATTRIBUTES lpProcessAttributes,LPSECURITY_ATTRIBUTES lpThreadAttributes,BOOL bInheritHandles,DWORD dwCreationFlags,LPVOID lpEnvironment,LPCSTR lpCurrentDirectory,LPSTARTUPINFOA lpStartupInfo,LPPROCESS_INFORMATION lpProcessInformation);
BOOL  WINAPI ProcCreateProcessW(LPCWSTR lpApplicationName,LPWSTR lpCommandLine,LPSECURITY_ATTRIBUTES lpProcessAttributes,LPSECURITY_ATTRIBUTES lpThreadAttributes,BOOL bInheritHandles,DWORD dwCreationFlags,LPVOID lpEnvironment,LPCWSTR lpCurrentDirectory,LPSTARTUPINFOW lpStartupInfo,LPPROCESS_INFORMATION lpProcessInformation);

NTSTATUS NTAPI ProcNtOpenThread(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
NTSTATUS NTAPI ProcNtOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
NTSTATUS NTAPI ProcNtFlushVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, PIO_STATUS_BLOCK IoStatus);
NTSTATUS NTAPI ProcNtProtectVirtualMemory(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG NewProtect, PULONG OldProtect);
NTSTATUS NTAPI ProcNtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI ProcNtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI ProcNtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationLength, PSIZE_T ReturnLength);
NTSTATUS NTAPI ProcNtDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);
NTSTATUS NTAPI ProcNtGetContextThread(HANDLE ThreadHandle, PCONTEXT Context);
NTSTATUS NTAPI ProcNtSetContextThread(HANDLE ThreadHandle, PCONTEXT Context);
NTSTATUS NTAPI ProcNtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferLength, PSIZE_T ReturnLength);
NTSTATUS NTAPI ProcNtWriteVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, SIZE_T BufferLength, PSIZE_T ReturnLength);
NTSTATUS NTAPI ProcNtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus);
NTSTATUS NTAPI ProcNtTerminateThread(HANDLE ThreadHandle, NTSTATUS ExitStatus);
NTSTATUS NTAPI ProcNtSuspendThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount);
NTSTATUS NTAPI ProcNtResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount);
NTSTATUS NTAPI ProcNtClose(HANDLE Handle);
//------------------------------------------------------------------------------------

//====================================================================================



================================================
File: XDbgPlugin/XDbgPlugin.vcxproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{157E494D-21B0-493D-A1F4-A8927CF410BF}</ProjectGuid>
    <RootNamespace>PluginDll</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <ProjectName>XDbgPlugin</ProjectName>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(XDBGX32_PATH)\Plugins\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <IgnoreImportLibrary Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</IgnoreImportLibrary>
    <IgnoreImportLibrary Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</IgnoreImportLibrary>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(XDBGX32_PATH)\Plugins\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <IgnoreImportLibrary Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</IgnoreImportLibrary>
    <IgnoreImportLibrary Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</IgnoreImportLibrary>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetName>$(SolutionName)</TargetName>
    <TargetExt>.dp32</TargetExt>
    <EmbedManifest>false</EmbedManifest>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>$(SolutionName)</TargetName>
    <OutDir>$(XDBGX64_PATH)\Plugins\</OutDir>
    <IntDir>$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <TargetExt>.dp64</TargetExt>
    <EmbedManifest>false</EmbedManifest>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>$(SolutionName)</TargetName>
    <TargetExt>.dp32</TargetExt>
    <EmbedManifest>false</EmbedManifest>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>$(SolutionName)</TargetName>
    <OutDir>$(XDBGX64_PATH)\Plugins\</OutDir>
    <IntDir>$(SolutionDir)BUILD\$(ProjectName)\$(Configuration)$(PlatformArchitecture)\</IntDir>
    <TargetExt>.dp64</TargetExt>
    <EmbedManifest>false</EmbedManifest>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\ntdll\;.\pluginsdk\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>FastCall</CallingConvention>
      <ShowIncludes>false</ShowIncludes>
      <StringPooling>true</StringPooling>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/permissive /d2noftol3 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerboseLib</ShowProgress>
      <OutputFile>$(TargetDir)$(TargetName)$(TargetExt)</OutputFile>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>
      </BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>
      </ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <SetChecksum>true</SetChecksum>
      <SpecifySectionAttributes>.bss,ERW</SpecifySectionAttributes>
      <GenerateMapFile>true</GenerateMapFile>
      <IgnoreAllDefaultLibraries>
      </IgnoreAllDefaultLibraries>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <ForceFileOutput>
      </ForceFileOutput>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x32.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\ntdll\;.\pluginsdk\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>FastCall</CallingConvention>
      <ShowIncludes>false</ShowIncludes>
      <StringPooling>true</StringPooling>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/permissive %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerboseLib</ShowProgress>
      <OutputFile>$(TargetDir)$(TargetName)$(TargetExt)</OutputFile>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>
      </BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>
      </ImportLibrary>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <SetChecksum>true</SetChecksum>
      <SpecifySectionAttributes>.bss,ERW</SpecifySectionAttributes>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x64.lib;runtmchk.lib</AdditionalDependencies>
      <GenerateMapFile>true</GenerateMapFile>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>false</OmitFramePointers>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\ntdll\;.\pluginsdk\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <CallingConvention>FastCall</CallingConvention>
      <CompileAs>CompileAsCpp</CompileAs>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/permissive /d2noftol3 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerboseLib</ShowProgress>
      <OutputFile>$(TargetDir)$(TargetName)$(TargetExt)</OutputFile>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <BaseAddress>
      </BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>
      </ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x32.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <SetChecksum>true</SetChecksum>
      <SpecifySectionAttributes>.bss,ERW</SpecifySectionAttributes>
      <GenerateMapFile>true</GenerateMapFile>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalOptions>/nocoffgrpinfo %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>mkdir "$(SolutionDir)BUILD\RELEASE\$(SolutionName)\x$(PlatformArchitecture)"
copy /Y "$(OutDir)$(TargetName)$(TargetExt)" "$(SolutionDir)BUILD\RELEASE\$(SolutionName)\x$(PlatformArchitecture)\$(TargetName)$(TargetExt)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>false</OmitFramePointers>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <AdditionalIncludeDirectories>$(SolutionDir)COMMON\;$(SolutionDir)COMMON\ThirdParty\ntdll\;.\pluginsdk\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>Default</StructMemberAlignment>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <CallingConvention>FastCall</CallingConvention>
      <CompileAs>CompileAsCpp</CompileAs>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>/permissive %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <ShowProgress>LinkVerboseLib</ShowProgress>
      <OutputFile>$(TargetDir)$(TargetName)$(TargetExt)</OutputFile>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <BaseAddress>
      </BaseAddress>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>
      </ImportLibrary>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <AdditionalDependencies>%(AdditionalDependencies);ntdll_x64.lib;runtmchk.lib</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)COMMON\ThirdParty\;$(SolutionDir)COMMON\ThirdParty\ntdll\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <SetChecksum>true</SetChecksum>
      <SpecifySectionAttributes>.bss,ERW</SpecifySectionAttributes>
      <GenerateMapFile>true</GenerateMapFile>
      <IgnoreSpecificDefaultLibraries>threadsafestatics.lib</IgnoreSpecificDefaultLibraries>
      <AdditionalOptions>/nocoffgrpinfo %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>mkdir "$(SolutionDir)BUILD\RELEASE\$(SolutionName)\x$(PlatformArchitecture)"
copy /Y "$(OutDir)$(TargetName)$(TargetExt)" "$(SolutionDir)BUILD\RELEASE\$(SolutionName)\x$(PlatformArchitecture)\$(TargetName)$(TargetExt)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\COMMON\RTL\gcvt.cpp" />
    <ClCompile Include="..\COMMON\Utils.cpp" />
    <ClCompile Include="XDbgPlugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\COMMON\Common.hpp" />
    <ClInclude Include="..\COMMON\FormatPE.hpp" />
    <ClInclude Include="..\COMMON\HDE.hpp" />
    <ClInclude Include="..\COMMON\InjDllLdr.hpp" />
    <ClInclude Include="..\COMMON\NtDllEx.hpp" />
    <ClInclude Include="..\COMMON\ShMemIPC.hpp" />
    <ClInclude Include="..\COMMON\ThirdParty\ntdll\ntdll.h" />
    <ClInclude Include="..\COMMON\UniHook.hpp" />
    <ClInclude Include="..\COMMON\Utils.h" />
    <ClInclude Include="..\COMMON\GhostDbg.hpp" />
    <ClInclude Include="XDbgPlugin.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resources.rc">
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">INJLIBPATH="$(XDBGNI_TESTFLDR)injlib.dll";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">INJLIBPATH="$(XDBGNI_TESTFLDR)injlib.dll";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">INJLIBPATH="$(XDBGNI_TESTFLDR)injlib.dll";%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">INJLIBPATH="$(XDBGNI_TESTFLDR)injlib.dll";%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>


================================================
File: XDbgPlugin/XDbgPlugin.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx</Extensions>
    </Filter>
    <Filter Include="Common">
      <UniqueIdentifier>{2e4139ac-ff60-48e7-9ddf-a7c62508e2c2}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="XDbgPlugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\COMMON\Utils.cpp">
      <Filter>Common</Filter>
    </ClCompile>
    <ClCompile Include="..\COMMON\RTL\gcvt.cpp">
      <Filter>Common</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="XDbgPlugin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\ThirdParty\ntdll\ntdll.h">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\ShMemIPC.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\Utils.h">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\InjDllLdr.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\GhostDbg.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\UniHook.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\NtDllEx.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\Common.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\FormatPE.hpp">
      <Filter>Common</Filter>
    </ClInclude>
    <ClInclude Include="..\COMMON\HDE.hpp">
      <Filter>Common</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resources.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>


================================================
File: XDbgPlugin/pluginsdk/_dbgfunctions.h
================================================
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
} DBGPROCESSINFO;

typedef bool (*ASSEMBLEATEX)(duint addr, const char* instruction, char* error, bool fillnop);
typedef bool (*SECTIONFROMADDR)(duint addr, char* section);
typedef bool (*MODNAMEFROMADDR)(duint addr, char* modname, bool extension);
typedef duint(*MODBASEFROMADDR)(duint addr);
typedef duint(*MODBASEFROMNAME)(const char* modname);
typedef duint(*MODSIZEFROMADDR)(duint addr);
typedef bool (*ASSEMBLE)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
typedef bool (*PATCHGET)(duint addr);
typedef bool (*PATCHINRANGE)(duint start, duint end);
typedef bool (*MEMPATCH)(duint va, const unsigned char* src, duint size);
typedef void (*PATCHRESTORERANGE)(duint start, duint end);
typedef bool (*PATCHENUM)(DBGPATCHINFO* patchlist, size_t* cbsize);
typedef bool (*PATCHRESTORE)(duint addr);
typedef int (*PATCHFILE)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
typedef int (*MODPATHFROMADDR)(duint addr, char* path, int size);
typedef int (*MODPATHFROMNAME)(const char* modname, char* path, int size);
typedef bool (*DISASMFAST)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
typedef void (*MEMUPDATEMAP)();
typedef void (*GETCALLSTACK)(DBGCALLSTACK* callstack);
typedef void (*SYMBOLDOWNLOADALLSYMBOLS)(const char* szSymbolStore);
typedef bool (*GETJIT)(char* jit, bool x64);
typedef bool (*GETJITAUTO)(bool* jitauto);
typedef bool (*GETDEFJIT)(char* defjit);
typedef bool (*GETPROCESSLIST)(DBGPROCESSINFO** entries, int* count);
typedef bool (*GETPAGERIGHTS)(duint addr, char* rights);
typedef bool (*SETPAGERIGHTS)(duint addr, const char* rights);
typedef bool (*PAGERIGHTSTOSTRING)(DWORD protect, char* rights);
typedef bool (*ISPROCESSELEVATED)();
typedef bool (*GETCMDLINE)(char* cmdline, size_t* cbsize);
typedef bool (*SETCMDLINE)(const char* cmdline);
typedef duint(*FILEOFFSETTOVA)(const char* modname, duint offset);
typedef duint(*VATOFILEOFFSET)(duint va);
typedef duint(*GETADDRFROMLINE)(const char* szSourceFile, int line);
typedef bool (*GETSOURCEFROMADDR)(duint addr, char* szSourceFile, int* line);
typedef bool (*VALFROMSTRING)(const char* string, duint* value);
typedef bool(*PATCHGETEX)(duint addr, DBGPATCHINFO* info);

typedef struct DBGFUNCTIONS_
{
    ASSEMBLEATEX AssembleAtEx;
    SECTIONFROMADDR SectionFromAddr;
    MODNAMEFROMADDR ModNameFromAddr;
    MODBASEFROMADDR ModBaseFromAddr;
    MODBASEFROMNAME ModBaseFromName;
    MODSIZEFROMADDR ModSizeFromAddr;
    ASSEMBLE Assemble;
    PATCHGET PatchGet;
    PATCHINRANGE PatchInRange;
    MEMPATCH MemPatch;
    PATCHRESTORERANGE PatchRestoreRange;
    PATCHENUM PatchEnum;
    PATCHRESTORE PatchRestore;
    PATCHFILE PatchFile;
    MODPATHFROMADDR ModPathFromAddr;
    MODPATHFROMNAME ModPathFromName;
    DISASMFAST DisasmFast;
    MEMUPDATEMAP MemUpdateMap;
    GETCALLSTACK GetCallStack;
    SYMBOLDOWNLOADALLSYMBOLS SymbolDownloadAllSymbols;
    GETJITAUTO GetJitAuto;
    GETJIT GetJit;
    GETDEFJIT GetDefJit;
    GETPROCESSLIST GetProcessList;
    GETPAGERIGHTS GetPageRights;
    SETPAGERIGHTS SetPageRights;
    PAGERIGHTSTOSTRING PageRightsToString;
    ISPROCESSELEVATED IsProcessElevated;
    GETCMDLINE GetCmdline;
    SETCMDLINE SetCmdline;
    FILEOFFSETTOVA FileOffsetToVa;
    VATOFILEOFFSET VaToFileOffset;
    GETADDRFROMLINE GetAddrFromLine;
    GETSOURCEFROMADDR GetSourceFromAddr;
    VALFROMSTRING ValFromString;
    PATCHGETEX PatchGetEx;
} DBGFUNCTIONS;

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H



================================================
File: XDbgPlugin/pluginsdk/_plugin_types.h
================================================
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"

#else

#ifdef __GNUC__
#include "dbghelp\dbghelp.h"
#else
#include <dbghelp.h>
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H



================================================
File: XDbgPlugin/pluginsdk/_plugins.h
================================================
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    IMAGEHLP_MODULE64* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL //PLUG_CB_WINEVENTGLOBAL
} CBTYPE;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int, char**);
typedef void (*CBPLUGINSCRIPT)();

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H



================================================
File: XDbgPlugin/pluginsdk/bridgelist.h
================================================
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type))  //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count()))  //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H


================================================
File: XDbgPlugin/pluginsdk/bridgemain.h
================================================
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <windows.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif

//list structure (and C++ wrapper)
//#include "bridgelist.h"    // Disabled because brings in C runtime (vector)

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions
BRIDGE_IMPEXP const char* BridgeInit();
BRIDGE_IMPEXP const char* BridgeStart();
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);
BRIDGE_IMPEXP void BridgeFree(void* ptr);
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);
BRIDGE_IMPEXP bool BridgeSettingFlush();
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);
BRIDGE_IMPEXP int BridgeGetDbgVersion();

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 256
#define MAX_BREAKPOINT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG") + 1)
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64
#define PAGE_SIZE 0x1000

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 1,
    flaglabel = 2,
    flagcomment = 4,
    flagbookmark = 8,
    flagfunction = 16,
    flagloop = 32
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END
} LOOPTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8
} MEMORY_SIZE;

//Debugger typedefs
typedef MEMORY_SIZE VALUE_SIZE;
typedef struct SYMBOLINFO_ SYMBOLINFO;
typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

typedef void (*CBSYMBOLENUM)(SYMBOLINFO* symbol, void* user);

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
} LOOP;

typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
} ADDRINFO;

struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    bool isImported;
};

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool IR;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    DWORD code;
    const char* name;
} LASTERROR;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
} REGDUMP;

typedef struct
{
    DISASM_ARGTYPE type;
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant;
    duint value;
    duint memvalue;
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, unsigned char* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const unsigned char* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDump(REGDUMP* regdump);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP void DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP void DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);

//Gui defines
#define GUI_PLUGIN_MENU 0
#define GUI_DISASM_MENU 1
#define GUI_DUMP_MENU 2
#define GUI_STACK_MENU 3

#define GUI_DISASSEMBLY 0
#define GUI_DUMP 1
#define GUI_STACK 2

#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums
typedef enum
{
    GUI_DISASSEMBLE_AT,             // param1=(duint)va,            param2=(duint)cip
    GUI_SET_DEBUG_STATE,            // param1=(DBGSTATE)state,      param2=unused
    GUI_ADD_MSG_TO_LOG,             // param1=(const char*)msg,     param2=unused
    GUI_CLEAR_LOG,                  // param1=unused,               param2=unused
    GUI_UPDATE_REGISTER_VIEW,       // param1=unused,               param2=unused
    GUI_UPDATE_DISASSEMBLY_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_BREAKPOINTS_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_WINDOW_TITLE,        // param1=(const char*)file,    param2=unused
    GUI_GET_WINDOW_HANDLE,          // param1=unused,               param2=unused
    GUI_DUMP_AT,                    // param1=(duint)va             param2=unused
    GUI_SCRIPT_ADD,                 // param1=int count,            param2=const char** lines
    GUI_SCRIPT_CLEAR,               // param1=unused,               param2=unused
    GUI_SCRIPT_SETIP,               // param1=int line,             param2=unused
    GUI_SCRIPT_ERROR,               // param1=int line,             param2=const char* message
    GUI_SCRIPT_SETTITLE,            // param1=const char* title,    param2=unused
    GUI_SCRIPT_SETINFOLINE,         // param1=int line,             param2=const char* info
    GUI_SCRIPT_MESSAGE,             // param1=const char* message,  param2=unused
    GUI_SCRIPT_MSGYN,               // param1=const char* message,  param2=unused
    GUI_SYMBOL_LOG_ADD,             // param1(const char*)msg,      param2=unused
    GUI_SYMBOL_LOG_CLEAR,           // param1=unused,               param2=unused
    GUI_SYMBOL_SET_PROGRESS,        // param1=int percent           param2=unused
    GUI_SYMBOL_UPDATE_MODULE_LIST,  // param1=int count,            param2=SYMBOLMODULEINFO* modules
    GUI_REF_ADDCOLUMN,              // param1=int width,            param2=(const char*)title
    GUI_REF_SETROWCOUNT,            // param1=int rows,             param2=unused
    GUI_REF_GETROWCOUNT,            // param1=unused,               param2=unused
    GUI_REF_DELETEALLCOLUMNS,       // param1=unused,               param2=unused
    GUI_REF_SETCELLCONTENT,         // param1=(CELLINFO*)info,      param2=unused
    GUI_REF_GETCELLCONTENT,         // param1=int row,              param2=int col
    GUI_REF_RELOADDATA,             // param1=unused,               param2=unused
    GUI_REF_SETSINGLESELECTION,     // param1=int index,            param2=bool scroll
    GUI_REF_SETPROGRESS,            // param1=int progress,         param2=unused
    GUI_REF_SETCURRENTTASKPROGRESS, // param1=int progress,         param2=const char* taskTitle
    GUI_REF_SETSEARCHSTARTCOL,      // param1=int col               param2=unused
    GUI_STACK_DUMP_AT,              // param1=duint addr,           param2=duint csp
    GUI_UPDATE_DUMP_VIEW,           // param1=unused,               param2=unused
    GUI_UPDATE_THREAD_VIEW,         // param1=unused,               param2=unused
    GUI_ADD_RECENT_FILE,            // param1=(const char*)file,    param2=unused
    GUI_SET_LAST_EXCEPTION,         // param1=unsigned int code,    param2=unused
    GUI_GET_DISASSEMBLY,            // param1=duint addr,           param2=char* text
    GUI_MENU_ADD,                   // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_ENTRY,             // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_SEPARATOR,         // param1=int hMenu,            param2=unused
    GUI_MENU_CLEAR,                 // param1=int hMenu,            param2=unused
    GUI_SELECTION_GET,              // param1=int hWindow,          param2=SELECTIONDATA* selection
    GUI_SELECTION_SET,              // param1=int hWindow,          param2=const SELECTIONDATA* selection
    GUI_GETLINE_WINDOW,             // param1=const char* title,    param2=char* text
    GUI_AUTOCOMPLETE_ADDCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_DELCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_CLEARALL,      // param1=unused,               param2=unused
    GUI_SCRIPT_ENABLEHIGHLIGHTING,  // param1=bool enable,          param2=unused
    GUI_ADD_MSG_TO_STATUSBAR,       // param1=const char* msg,      param2=unused
    GUI_UPDATE_SIDEBAR,             // param1=unused,               param2=unused
    GUI_REPAINT_TABLE_VIEW,         // param1=unused,               param2=unused
    GUI_UPDATE_PATCHES,             // param1=unused,               param2=unused
    GUI_UPDATE_CALLSTACK,           // param1=unused,               param2=unused
    GUI_SYMBOL_REFRESH_CURRENT,     // param1=unused,               param2=unused
    GUI_UPDATE_MEMORY_VIEW,         // param1=unused,               param2=unused
    GUI_REF_INITIALIZE,             // param1=const char* name,     param2=unused
    GUI_LOAD_SOURCE_FILE,           // param1=const char* path,     param2=line
    GUI_MENU_SET_ICON,              // param1=int hMenu,            param2=ICONINFO*
    GUI_MENU_SET_ENTRY_ICON,        // param1=int hEntry,           param2=ICONINFO*
    GUI_SHOW_CPU,                   // param1=unused,               param2=unused
    GUI_ADD_QWIDGET_TAB,            // param1=QWidget*,             param2=unused
    GUI_SHOW_QWIDGET_TAB,           // param1=QWidget*,             param2=unused
    GUI_CLOSE_QWIDGET_TAB,          // param1=QWidget*,             param2=unused
    GUI_EXECUTE_ON_GUI_THREAD,      // param1=GUICALLBACK,          param2=unused
    GUI_UPDATE_TIME_WASTED_COUNTER, // param1=unused,               param2=unused
    GUI_SET_GLOBAL_NOTES,           // param1=const char* text,     param2=unused
    GUI_GET_GLOBAL_NOTES,           // param1=char** text,          param2=unused
    GUI_SET_DEBUGGEE_NOTES,         // param1=const char* text,     param2=unused
    GUI_GET_DEBUGGEE_NOTES,         // param1=char** text,          param2=unused
    GUI_DUMP_AT_N,                  // param1=int index,            param2=duint va
    GUI_DISPLAY_WARNING,            // param1=const char *text,     param2=unused
    GUI_REGISTER_SCRIPT_LANG,       // param1=SCRIPTTYPEINFO* info, param2=unused
    GUI_UNREGISTER_SCRIPT_LANG      // param1=int id,               param2=unused
} GUIMSG;

//GUI Typedefs
typedef void (*GUICALLBACK)();
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

//GUI functions
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP const char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(int hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(int hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiLoadSourceFile(const char* path, int line);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_



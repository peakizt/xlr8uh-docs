Directory structure:
└── secrary-idenlib/
    ├── README.md
    ├── LICENSE
    ├── idenLib.sln
    └── idenLib/
        ├── compression.cpp
        ├── compression.h
        ├── disassamble.cpp
        ├── disassamble.h
        ├── idenLib.cpp
        ├── idenLib.vcxproj
        ├── idenLib.vcxproj.filters
        ├── parseArchive.cpp
        ├── parseArchive.h
        ├── pdb.cpp
        ├── pdb.h
        ├── utils.cpp
        ├── utils.h
        └── dependencies/
            ├── zstd/
            └── zydis/

================================================
File: README.md
================================================
# idenLib - Library Function Identification

When analyzing malware or 3rd party software, it's challenging to identify statically linked libraries and to understand what a function from the library is doing.

[`idenLib.exe`](https://github.com/secrary/idenLib) is a tool for generating library signatures from `.lib`/`.obj`/`.exe` files.

[`idenLib.dp32`/`idenLib.dp64`](https://github.com/secrary/idenLibX) is a [`x32dbg`/`x64dbg`](https://x64dbg.com) plugin to identify library functions.

[`idenLib.py`](https://github.com/secrary/IDA-scripts/tree/master/idenLib) is an [`IDA Pro`](https://www.hex-rays.com/products/ida/index.shtml) plugin to identify library functions.


##### Any feedback is greatly appreciated: [@_qaz_qaz](https://twitter.com/_qaz_qaz)

## How does idenLib.exe generate signatures?

1. Parses input file(`.lib`/`.obj` file) to get a list of function addresses and function names.
2. Gets the last opcode from each instruction

![sig](https://user-images.githubusercontent.com/16405698/52433535-35442500-2b05-11e9-92a2-7ed0dfb319ab.png)

3. Compresses the signature with [zstd](https://github.com/facebook/zstd)

4. Saves the signature under the `SymEx` directory, if the input filename is `zlib.lib`, the output will be `zlib.lib.sig` or `zlib.lib.sig64`,
if `zlib.lib.sig(64)` already exists under the `SymEx` directory from a previous execution or from the previous version of the library, the next execution will append different signatures.
If you execute `idenLib.exe` several times with different version of the `.lib` file, the `.sig`/`sig64` file will include all unique function signatures.

Inside of a signature (it's compressed):
![signature](https://user-images.githubusercontent.com/16405698/52490971-e9a18200-2bbd-11e9-8d29-e85a71826c8f.png)

## Usage:
- Generate library signatures: `idenLib.exe /path/to/file` or `idenLib.exe /path/to/directory`
- Generate `main` function signature: `idenLib.exe /path/to/pe -getmain`

## Generating library signatures

![lib](https://user-images.githubusercontent.com/16405698/52433541-35dcbb80-2b05-11e9-918a-6d39afc5de91.gif)

## [`x32dbg`/`x64dbg`](https://x64dbg.com), [`IDA Pro`](https://www.hex-rays.com/products/ida/index.shtml) plugin usage:

1. Copy `SymEx` directory under `x32dbg`/`x64dbg`/`IDA Pro`'s main directory
2. Apply signatures:

[`x32dbg`/`x64dbg`](https://github.com/secrary/idenLibX):

![xdb](https://user-images.githubusercontent.com/16405698/52433536-35442500-2b05-11e9-990e-8d4889bfe1c6.gif)

[`IDA Pro`](https://github.com/secrary/IDA-scripts/tree/master/idenLib):

![ida_boost_2](https://user-images.githubusercontent.com/16405698/52433540-35dcbb80-2b05-11e9-9dd3-9bb44d678ea5.gif)

## Generating `main` function signature:
If you want to generate a signature for `main` function compiled using `MSVC 14` you need to create a  `hello world` application with the corresponding compiler and use the application as input for `idenLib`

![getmain](https://user-images.githubusercontent.com/16405698/53035354-234f7400-346d-11e9-9d56-b05ff0309ca6.gif)

`main` function signature files are `EntryPointSignatures.sig` and `EntryPointSignatures.sig64`

![IDAProMain](https://user-images.githubusercontent.com/16405698/53022517-3c4b2b80-3453-11e9-9e0a-5d1421f9c8f3.gif)

![x64dbg_main](https://user-images.githubusercontent.com/16405698/53122678-14d98900-354f-11e9-88a3-e6f0f6b7d7bf.gif)

## Notes Regarding to `main` Function Signatures

- `idenLib` uses the `DIA APIs` to browse debug information stored in a PDB file. To run `idenLib` with `-getmain` parameter you will need to ensure that the msdia140.dll (found in `Microsoft Visual Studio\2017\Community\DIA SDK\bin`) is registered as a COM component, by invoking regsvr32.exe on the dll. 


## Applying Signatures

There are two ways to apply signatures, exact match and using [`Jaccard index`](https://en.wikipedia.org/wiki/Jaccard_index)

![x32dbg_jaccard](https://user-images.githubusercontent.com/16405698/53361361-80489f80-392f-11e9-9339-36b719394cbe.png)


## Useful links:
- Detailed information about [`C Run-Time Libraries (CRT)`](https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features)

## Third-party
- Zydis ([MIT License](https://github.com/zyantific/zydis/blob/master/LICENSE))
- Zstandard ([BSD License](https://github.com/facebook/zstd/blob/dev/LICENSE))

- Icon by [freepik](https://www.flaticon.com/authors/freepik)



================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2019 Lasha Khasaia

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: idenLib.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.329
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "idenLib", "idenLib\idenLib.vcxproj", "{877936DA-E788-4B7D-AD77-B6555575A44C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{877936DA-E788-4B7D-AD77-B6555575A44C}.Debug|x64.ActiveCfg = Debug|x64
		{877936DA-E788-4B7D-AD77-B6555575A44C}.Debug|x64.Build.0 = Debug|x64
		{877936DA-E788-4B7D-AD77-B6555575A44C}.Debug|x86.ActiveCfg = Debug|Win32
		{877936DA-E788-4B7D-AD77-B6555575A44C}.Debug|x86.Build.0 = Debug|Win32
		{877936DA-E788-4B7D-AD77-B6555575A44C}.Release|x64.ActiveCfg = Release|x64
		{877936DA-E788-4B7D-AD77-B6555575A44C}.Release|x64.Build.0 = Release|x64
		{877936DA-E788-4B7D-AD77-B6555575A44C}.Release|x86.ActiveCfg = Release|Win32
		{877936DA-E788-4B7D-AD77-B6555575A44C}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {735438F8-8F1B-4ABA-9AC8-59A17DEAB00D}
	EndGlobalSection
EndGlobal



================================================
File: idenLib/compression.cpp
================================================
#include "compression.h"

bool CompressFile(fs::path& sigPathTmp, const fs::path& sigPath)
{
	FILE* hFile = nullptr;
	fopen_s(&hFile, sigPathTmp.string().c_str(), "rb");
	if (!hFile)
	{
		fprintf(stderr, "[idenLib - FAILED] failed to open: %s \n", sigPathTmp.string().c_str());
		return false;
	}

	// file size
	fseek(hFile, 0L, SEEK_END);
	const auto fSize = ftell(hFile);
	rewind(hFile);
	// read file
	const auto fBuff = new BYTE[fSize];
	fread(fBuff, 1, fSize - 1, hFile); // without last new line \n (0xa)
	// zero (0x00) at the end
	fBuff[fSize - 1] = 0;
	// alloc for compressed data
	const auto cBufSize = ZSTD_compressBound(fSize);
	const auto cBuff = new BYTE[cBufSize];
	// compress data
	const auto cSize = ZSTD_compress(cBuff, cBufSize, fBuff, fSize, DEFAULT_COMPRESS_LEVEL);
	if (ZSTD_isError(cSize))
	{
		fprintf(stderr, "[idenLib - FAILED] error compressing: %s \n", ZSTD_getErrorName(cSize));
		delete[] cBuff;
		delete[] fBuff;
		return false;
	}
	fclose(hFile);

	if (exists(sigPath))
	{
		fs::remove(sigPath);
	}
	fopen_s(&hFile, sigPath.string().c_str(), "wb");
	if (!hFile)
	{
		fprintf(stderr, "[idenLib - FAILED] failed to open: %s \n", sigPath.string().c_str());
		delete[] cBuff;
		delete[] fBuff;
		return false;
	}
	fwrite(cBuff, 1, cSize, hFile);

	delete[] cBuff;
	delete[] fBuff;
	fclose(hFile);

	return true;
}

_Success_(return)

bool DecompressFile(fs::path& sigPath, PBYTE& decompressedData)
{
	FILE* hFile = nullptr;
	fopen_s(&hFile, sigPath.string().c_str(), "rb");
	if (!hFile)
	{
		fwprintf(stderr, L"[idenLib - FAILED] failed to open the file: %s\n", sigPath.c_str());
		return false;
	}
	// compressed size
	fseek(hFile, 0L, SEEK_END);
	const auto cSize = ftell(hFile);
	rewind(hFile);
	// read data
	const auto cBuff = new BYTE[cSize];
	if (cBuff == nullptr)
	{
		fclose(hFile);
		return false;
	}
	fread(cBuff, 1, cSize, hFile);
	// decompressed size
	const auto rSize = ZSTD_findDecompressedSize(cBuff, cSize);
	if (rSize == ZSTD_CONTENTSIZE_ERROR)
	{
		fwprintf(stderr, L"[idenLib - FAILED] %s : it was not compressed by zstd.\n", sigPath.c_str());
		delete[] cBuff;
		fclose(hFile);
		return false;
	}
	if (rSize == ZSTD_CONTENTSIZE_UNKNOWN)
	{
		fwprintf(stderr,
		         L"[idenLib - FAILED] %s : original size unknown. Use streaming decompression instead.\n",
		         sigPath.c_str());
		delete[] cBuff;
		fclose(hFile);
		return false;
	}
	decompressedData = new BYTE[rSize]; // +1 for 0x00
	if (decompressedData == nullptr)
	{
		delete[] cBuff;
		fclose(hFile);
		return false;
	}
	auto const dSize = ZSTD_decompress(decompressedData, rSize, cBuff, cSize);

	if (dSize != rSize)
	{
		fprintf(stderr, "[idenLib - FAILED] error decoding %s : %s \n", sigPath.string().c_str(),
		        ZSTD_getErrorName(dSize));
		delete[] cBuff;
		fclose(hFile);
		return false;
	}


	fclose(hFile);
	delete[] cBuff;
	return true;
}



================================================
File: idenLib/compression.h
================================================
#pragma once

#include "utils.h"


namespace fs = std::filesystem;

#define DEFAULT_COMPRESS_LEVEL 3

bool CompressFile(fs::path& sigPathTmp, const fs::path& sigPath);

bool DecompressFile(fs::path& sigPath, PBYTE& decompressedData);



================================================
File: idenLib/disassamble.cpp
================================================
#include "disassamble.h"

_Success_(return)

bool GetOpcodeBuf(__in PBYTE funcVa, __in SIZE_T length, __out PCHAR& opcodesBuf, __in bool countBranches,
                  __out size_t& cBranches)
{
	ZydisDecoder decoder;

	ZydisDecoderInit(&decoder, zydisMode, zydisWidth);

	ZyanUSize offset = 0;
	ZydisDecodedInstruction instruction;

	if (countBranches)
	{
		cBranches = 0;
	}

	auto cSize = length * 2;
	opcodesBuf = static_cast<PCHAR>(malloc(cSize)); // // we need to resize the buffer
	if (opcodesBuf == nullptr)
	{
		return false;
	}
	SIZE_T counter = 0;
	while (		ZYAN_SUCCESS(ZydisDecoderDecodeBuffer(&decoder, funcVa + offset, length - offset,
		&instruction)))
	{
		CHAR opcode[3];
		sprintf_s(opcode, "%02x", instruction.opcode);

		memcpy_s(opcodesBuf + counter, cSize - counter, opcode, sizeof(opcode));
		counter += 2;

		if (countBranches)
		{
			if (instruction.meta.branch_type != ZYDIS_BRANCH_TYPE_NONE)
			{
				cBranches++;
			}
		}

		offset += instruction.length;
	}
	auto tmpPtr = static_cast<PCHAR>(realloc(opcodesBuf, counter + 1)); // +1 for 0x00
	if (tmpPtr == nullptr)
	{
		return false;
	}
	opcodesBuf = tmpPtr;

	return counter != 0;
}



================================================
File: idenLib/disassamble.h
================================================
#pragma once

#include "utils.h"

_Success_(return)
bool GetOpcodeBuf(__in PBYTE funcVa, __in SIZE_T length, __out PCHAR& opcodesBuf, __in bool countBranches,
                  __out size_t& cBranches);



================================================
File: idenLib/idenLib.cpp
================================================
//
// author: Lasha Khasaia
// contact: @_qaz_qaz
//

#include "utils.h"

void ProcessFile(const fs::path& sPath);

int main(int argc, char* argv[])
{
	if (argc < 2)
	{
		printf(
			"idenLib - Library Function Identification\n\
		Usage: \n\
		./idenLib.exe /path/to/sample\n\
		./idenLib.exe /path/to/dir\n\
		./idenLib.exe /path/to/dir filename\n\n\
		./idenLib.exe /path/to/sample -getmain\
		\n");
		return STATUS_UNSUCCESSFUL;
	}

	fs::path sPath{argv[1]};

	if (!exists(sPath))
	{
		fwprintf(stderr, L"[idenLib - FAILED] Invalid path: %s\n", sPath.c_str());
		return STATUS_UNSUCCESSFUL;
	}

	if (!exists(symExPath))
	{
		create_directory(symExPath);
	}


	if (argc == 3) // -getmain
	{
		if (strncmp(argv[2], "-getmain", strlen("-getmain")) == 0)
		{
			if (S_OK != CoInitialize(nullptr))
			{
				printf("CoInitialize failed\n");
				return STATUS_UNSUCCESSFUL;
			}

			if (is_regular_file(sPath) && (sPath.extension().compare(".exe") == 0 || sPath.extension().compare(".dll")
				== 0))
			{
				if (!ProcessMainSignature(sPath)) // argv[3] is name of the entry point (wmain, main, etc)
				{
					fprintf(stderr, "[IdenLib - FAILED] Failed to parse .pdb file\n");
					return STATUS_UNSUCCESSFUL;
				}
				return STATUS_SUCCESS;
			}
		}
	}


	if (is_regular_file(sPath))
	{
		ProcessFile(sPath);
	}
	else
	{
		std::error_code ec{};
		for (auto& p : fs::recursive_directory_iterator(sPath, fs::directory_options::skip_permission_denied, ec))
		{
			if (ec.value() != STATUS_SUCCESS)
			{
				continue;
			}
			const auto& currentPath = p.path();
			if (is_regular_file(currentPath, ec))
			{
				if (ec.value() != STATUS_SUCCESS)
				{
					continue;
				}
				if (argc == 3)
				{
					if (std::wstring::npos != currentPath.filename().string().find(argv[2]))
					{
						ProcessFile(currentPath);
					}
				}
				else
				{
					ProcessFile(currentPath);
				}
			}
		}
	}

	printf("------------- EOF -------------");
	return STATUS_SUCCESS;
}


void ProcessArchiveFile(const fs::path& sPath)
{
	Lib lib{sPath};
	USER_CONTEXT userContext{};

	userContext.Dirty = false;

	if (!lib.GetSignature(&userContext) || !userContext.Dirty)
	{
		printf("[idenLib - INFO] No SIG file for : %s\n", sPath.string().c_str());
		return;
	}

	if (lib.isx64)
	{
		sigExt = L".sig64";
		subFolder = L"x64";
	}
	else
	{
		sigExt = L".sig";
		subFolder = L"x86";
	}

	const auto fileName = sPath.filename();
	auto sigPath{symExPath};
	sigPath += L"\\";
	sigPath += subFolder;
	if (!exists(sigPath))
	{
		create_directories(sigPath);
	}
	sigPath += L"\\";
	sigPath += fileName;
	sigPath += sigExt;

	if (exists(sigPath))
	{
		PBYTE decompressedData{};
		if (!DecompressFile(sigPath, decompressedData) || !decompressedData)
		{
			fwprintf_s(stderr, L"[idenLib - FAILED] failed to decompress the file: %s\n", sigPath.c_str());
			return;
		}
		char seps[] = "\n";
		char* next_token = nullptr;
		char* line = strtok_s(reinterpret_cast<char*>(decompressedData), seps, &next_token);
		while (line != nullptr)
		{
			std::vector<std::string> vec{};
			Split(line, vec);
			if (vec.size() != 2)
			{
				fwprintf(stderr, L"[idenLib - FAILED] SIG file contains a malformed data, SIG path: %s\n",
				         sigPath.c_str());
				return;
			}
			// vec[0] opcode
			// vec[1] name
			if (userContext.funcSignature.find(vec[0]) == userContext.funcSignature.end())
			{
				userContext.funcSignature[vec[0]] = vec[1];
			}

			line = strtok_s(nullptr, seps, &next_token);
		}


		delete[] decompressedData;
	}

	fs::path sigPathTmp = sigPath;
	sigPathTmp += L".tmp";
	if (exists(sigPathTmp))
	{
		fs::remove(sigPathTmp);
	}

	FILE* hFile = nullptr;
	fopen_s(&hFile, sigPathTmp.string().c_str(), "wb");
	if (!hFile)
	{
		fwprintf(stderr, L"[idenLib - FAILED] failed to create sig file: %s\n", sigPath.c_str());
		return;
	}
	for (const auto& n : userContext.funcSignature)
	{
		const auto bothSize = n.first.size() + n.second.size() + 3; // space + \n + 0x00
		const auto opcodesName = new CHAR[bothSize];
		sprintf_s(opcodesName, bothSize, "%s %s\n", n.first.c_str(), n.second.c_str());
		fwrite(opcodesName, bothSize - 1, 1, hFile); // -1 without 0x00
		delete[] opcodesName;
	}
	fclose(hFile);

	if (CompressFile(sigPathTmp, sigPath))
	{
		wprintf(L"[idenLib] Created SIG file: %s based on %s\n", sigPath.c_str(), sPath.c_str());
	}
	else
	{
		fwprintf(stderr, L"[idenLib - FAILED] compression failed\n");
	}
	if (exists(sigPathTmp))
		fs::remove(sigPathTmp);


	if (exists(sigPath) && is_empty(sigPath))
	{
		DeleteFile(sigPath.c_str());
	}
}

void ProcessFile(const fs::path& sPath)
{
	if (sPath.extension().compare(".lib") == 0 || sPath.extension().compare(".obj") == 0)
	{
		ProcessArchiveFile(sPath);
	}


	// parse PE files based on pdb - REMOVED
}



================================================
File: idenLib/idenLib.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{877936DA-E788-4B7D-AD77-B6555575A44C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>idenLib</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(ProjectDir)..\idenLib\dependencies\zydis\msvc;$(ProjectDir)..\idenLib\dependencies\zydis\include;$(ProjectDir)..\idenLib\dependencies\zydis\dependencies\zycore\include;$(ProjectDir)..\idenLib\dependencies\zstd\lib;$(VSInstallDir)\DIA SDK\include;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(ProjectDir)..\idenLib\dependencies\zydis\msvc;$(ProjectDir)..\idenLib\dependencies\zydis\include;$(ProjectDir)..\idenLib\dependencies\zydis\dependencies\zycore\include;$(ProjectDir)..\idenLib\dependencies\zstd\lib;$(VSInstallDir)\DIA SDK\include;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)..\idenLib\dependencies\zydis\msvc;$(ProjectDir)..\idenLib\dependencies\zydis\include;$(ProjectDir)..\idenLib\dependencies\zydis\dependencies\zycore\include;$(ProjectDir)..\idenLib\dependencies\zstd\lib;$(VSInstallDir)\DIA SDK\include;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(ProjectDir)..\idenLib\dependencies\zydis\msvc;$(ProjectDir)..\idenLib\dependencies\zydis\include;$(ProjectDir)..\idenLib\dependencies\zydis\dependencies\zycore\include;$(ProjectDir)..\idenLib\dependencies\zstd\lib;$(VSInstallDir)\DIA SDK\include;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>$(ProjectDir)..\deps\zydis\include;$(ProjectDir)..\deps\zydis\build;$(ProjectDir)..\deps\zydis\dependencies\zycore\include;$(ProjectDir)..\deps\zydis\build\dependencies\zycore;$(ProjectDir)..\deps\zstd\include</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(ProjectDir)..\idenlib\dependencies\zstd\build\VS2010\bin\Win32_Release;$(ProjectDir)..\idenLib\dependencies\zydis\msvc\bin</AdditionalLibraryDirectories>
      <AdditionalDependencies>zydis.lib;zycore.lib;libzstd_static.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>zydis.lib;zycore.lib;libzstd_static.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(ProjectDir)..\idenlib\dependencies\zstd\build\VS2010\bin\x64_Release;$(ProjectDir)..\idenLib\dependencies\zydis\msvc\bin</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(ProjectDir)..\idenlib\dependencies\zstd\build\VS2010\bin\Win32_Release;$(ProjectDir)..\idenLib\dependencies\zydis\msvc\bin</AdditionalLibraryDirectories>
      <AdditionalDependencies>zydis.lib;zycore.lib;libzstd_static.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DebugInformationFormat>None</DebugInformationFormat>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(ProjectDir)..\idenlib\dependencies\zstd\build\VS2010\bin\x64_Release;$(ProjectDir)..\idenLib\dependencies\zydis\msvc\bin</AdditionalLibraryDirectories>
      <AdditionalDependencies>zydis.lib;zycore.lib;libzstd_static.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="compression.cpp" />
    <ClCompile Include="disassamble.cpp" />
    <ClCompile Include="idenLib.cpp" />
    <ClCompile Include="parseArchive.cpp" />
    <ClCompile Include="pdb.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="compression.h" />
    <ClInclude Include="disassamble.h" />
    <ClInclude Include="parseArchive.h" />
    <ClInclude Include="pdb.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: idenLib/idenLib.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="idenLib.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="disassamble.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="parseArchive.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="compression.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pdb.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="disassamble.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="parseArchive.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="compression.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pdb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


================================================
File: idenLib/parseArchive.cpp
================================================
#include "parseArchive.h"

Lib::Lib(const fs::path& libPath)
{
	if (_wfopen_s(&this->hFile, libPath.c_str(), L"rb") || !this->hFile) // Zero if successful;
		return;
	// get file length
	fseek(this->hFile, 0, SEEK_END);
	this->FileLength = ftell(this->hFile);
	rewind(this->hFile);
	// file content
	this->FileContent = static_cast<byte*>(malloc(this->FileLength));
	if (this->FileContent == nullptr)
	{
		return;
	}
	fread(this->FileContent, this->FileLength, 1, this->hFile);
	rewind(this->hFile);
	// Is it right type?
	if ((this->FileContent != nullptr) && memcmp(this->FileContent, IMAGE_ARCHIVE_START, IMAGE_ARCHIVE_START_SIZE) == 0)
	{
		this->isLib = true;
	}
}

void Lib::MemberHeader(__in IMAGE_ARCHIVE_MEMBER_HEADER& archiveMemberHdr)
{
	const LONG seek = EVEN_BYTE_ALIGN(this->MemberSeekBase + this->MemberSize);
	fseek(this->hFile, seek, SEEK_SET);
	fread(&archiveMemberHdr, sizeof(IMAGE_ARCHIVE_MEMBER_HEADER), 1, this->hFile);
	this->MemberSeekBase = seek + sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);
	this->MemberSize = strtol(reinterpret_cast<char*>(archiveMemberHdr.Size), nullptr, 10);
}

DWORD Reverse(const DWORD value)
{
	return (value & 0x000000FF) << 24 | (value & 0x0000FF00) << 8 | (value & 0x00FF0000) >> 8 | (value & 0xFF000000) >>
		24;
}

_Success_(return)

bool Lib::GetSignature(LPVOID pUserContext)
{
	if (!this->isLib) // process .obj file
	{
		// Is it a .obj file?
		const auto fHdr = reinterpret_cast<PIMAGE_FILE_HEADER>(this->FileContent);
		if (fHdr->Machine == Arch86 || fHdr->Machine == Arch64)
		{
			this->isx64 = fHdr->Machine == Arch64;
			// process .obj file
			DisasmObjCode(*fHdr, this->FileContent, pUserContext);
			return true;
		}
		return false;
	}

	// process .lib file
	IMAGE_ARCHIVE_MEMBER_HEADER imArcMemHdr{};
	MemberHeader(imArcMemHdr);
	if (memcmp(imArcMemHdr.Name, IMAGE_ARCHIVE_LINKER_MEMBER, 16) != 0)
	{
		return false;
	}
	// number of public symbols in linker member
	DWORD numberOfPublicSymbols{};
	fread(&numberOfPublicSymbols, sizeof(DWORD), 1, this->hFile);
	numberOfPublicSymbols = Reverse(numberOfPublicSymbols);

	// symbols offsets - skip
	fseek(this->hFile, sizeof(DWORD) * numberOfPublicSymbols, SEEK_CUR);
	// size of the linker member string table - skip
	auto stringTable = IMAGE_ARCHIVE_START_SIZE + sizeof(IMAGE_ARCHIVE_MEMBER_HEADER) +
		(this->MemberSize - ftell(this->hFile));
	fseek(this->hFile, stringTable, SEEK_CUR);

	auto newMember = EVEN_BYTE_ALIGN(this->MemberSeekBase + this->MemberSize);
	fseek(this->hFile, newMember, SEEK_SET);

	IMAGE_ARCHIVE_MEMBER_HEADER imArcMemHdrPos{};
	fread(&imArcMemHdrPos, sizeof(IMAGE_ARCHIVE_MEMBER_HEADER), 1, this->hFile);
	if (memcmp(imArcMemHdrPos.Name, IMAGE_ARCHIVE_LINKER_MEMBER, 16) == 0)
	{
		// second link member - skip
		MemberHeader(imArcMemHdr);
		DWORD cMemberOffsets{};
		fread(&cMemberOffsets, sizeof(DWORD), 1, this->hFile);
		fseek(this->hFile, sizeof(DWORD) * cMemberOffsets, SEEK_CUR);

		// new index table - skip
		fread(&numberOfPublicSymbols, sizeof(DWORD), 1, this->hFile);
		fseek(this->hFile, sizeof(WORD) * numberOfPublicSymbols, SEEK_CUR);
		// string table - skip
		stringTable = MemberSize - (ftell(this->hFile) - (newMember + sizeof(IMAGE_ARCHIVE_MEMBER_HEADER)));
		fseek(this->hFile, stringTable, SEEK_CUR);
	}


	newMember = EVEN_BYTE_ALIGN(this->MemberSeekBase + this->MemberSize);
	fseek(this->hFile, newMember, SEEK_SET);
	fread(&imArcMemHdrPos, sizeof(IMAGE_ARCHIVE_MEMBER_HEADER), 1, this->hFile);
	if (memcmp(imArcMemHdrPos.Name, IMAGE_ARCHIVE_LONGNAMES_MEMBER, 16) == 0)
	{
		MemberHeader(imArcMemHdr);
		// strings - skip
		fseek(this->hFile, this->MemberSize, SEEK_CUR);
	}

	// iterate objects
	do
	{
		IMAGE_ARCHIVE_MEMBER_HEADER archiveMemberHdr{};
		MemberHeader(archiveMemberHdr);

		const auto currentObjectStart = this->FileContent + ftell(this->hFile);
		IMAGE_FILE_HEADER imageFileHdr{};
		fread(&imageFileHdr, sizeof(IMAGE_FILE_HEADER), 1, this->hFile);
		if (imageFileHdr.Machine != Arch86 && imageFileHdr.Machine != Arch64)
		{
			continue;
		}
		this->isx64 = imageFileHdr.Machine == Arch64;
		DisasmObjCode(imageFileHdr, currentObjectStart, pUserContext);
	}
	while (this->MemberSeekBase + this->MemberSize + 1 < this->FileLength);


	return true;
}

Lib::~Lib()
{
	if (FileContent != nullptr)
	{
		free(FileContent);
	}
	if (hFile)
		fclose(hFile);
}

void Lib::DisasmObjCode(__in IMAGE_FILE_HEADER& imageFileHdr, __in byte* currentObjectStart, LPVOID pUserContext)
{
	if (this->isx64)
	{
		zydisMode = ZYDIS_MACHINE_MODE_LONG_64;
		zydisWidth = ZYDIS_ADDRESS_WIDTH_64;
	}
	else
	{
		zydisMode = ZYDIS_MACHINE_MODE_LEGACY_32;
		zydisWidth = ZYDIS_ADDRESS_WIDTH_32;
	}

	const auto userContext = static_cast<PUSER_CONTEXT>(pUserContext);
	auto saveLoc = ftell(this->hFile);

	if (!this->isLib)
	{
		this->MemberSeekBase = 0;
	}

	fseek(this->hFile, this->MemberSeekBase +
	      imageFileHdr.PointerToSymbolTable, SEEK_SET);
	if (imageFileHdr.NumberOfSymbols == 0u)
	{
		return;
	}
	const auto symbols = static_cast<PIMAGE_SYMBOL>(malloc(imageFileHdr.NumberOfSymbols * sizeof(IMAGE_SYMBOL)));
	if (symbols == nullptr)
	{
		return;
	}
	fread(symbols, imageFileHdr.NumberOfSymbols, sizeof(IMAGE_SYMBOL), this->hFile);
	fseek(this->hFile, saveLoc, SEEK_SET);

	const auto startOfSectionHeaders = this->MemberSeekBase + sizeof(IMAGE_FILE_HEADER) + imageFileHdr.
		SizeOfOptionalHeader;
	const DWORD cbSections = imageFileHdr.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
	if (cbSections == 0u)
	{
		return;
	}
	const auto sectionHeaders = static_cast<PIMAGE_SECTION_HEADER>(malloc(cbSections));
	if (sectionHeaders == nullptr)
	{
		return;
	}
	fseek(this->hFile, startOfSectionHeaders, SEEK_SET); // set after optional header
	fread(sectionHeaders, sizeof(IMAGE_SECTION_HEADER), imageFileHdr.NumberOfSections, this->hFile);

	const auto stringTable = reinterpret_cast<char*>(imageFileHdr.PointerToSymbolTable + currentObjectStart +
		imageFileHdr.NumberOfSymbols *
		sizeof(IMAGE_SYMBOL));
	for (size_t i = 1; i <= imageFileHdr.NumberOfSections; i++) // since IMAGE_SYMBOL counts from 1 (not 0)
	{
		const auto imageSectionHeader = sectionHeaders[i - 1];
		const auto cbVirtual = imageSectionHeader.SizeOfRawData;

		if (imageSectionHeader.PointerToRawData != 0 && cbVirtual != 0 && ((
			imageSectionHeader.Characteristics & IMAGE_SCN_CNT_CODE) != 0u))
		{
			// disassemble code
			const auto numberOfSymbols = imageFileHdr.NumberOfSymbols;
			for (size_t j = 0; j < numberOfSymbols; ++j)
			{
				if (size_t(symbols[j].SectionNumber) == i &&
					(symbols[j].StorageClass == IMAGE_SYM_CLASS_EXTERNAL ||
						symbols[j].StorageClass == IMAGE_SYM_CLASS_STATIC ||
						symbols[j].StorageClass == IMAGE_SYM_CLASS_LABEL) && ISFCN(symbols[j].Type)
				) // current section and function
				{
					const auto fnName = symbols[j].N.Name.Short != 0u
						                    ? reinterpret_cast<char*>(symbols[j].N.ShortName)
						                    : (stringTable + symbols[j].N.Name.Long);

					std::string sName{fnName};

					//if (sName.find("ZydisDecoderInit") != std::string::npos) { // test func
					//	printf("%s\n", sName.c_str());
					//}

					const auto code = currentObjectStart + imageSectionHeader.PointerToRawData + symbols[j].Value;
					auto codeSize = imageSectionHeader.SizeOfRawData - symbols[j].Value;
					if (codeSize < MIN_FUNC_SIZE)
					{
						continue;
					}
					if (codeSize > MAX_FUNC_SIZE)
					{
						codeSize = MAX_FUNC_SIZE;
					}

					PCHAR opcodesBuf = nullptr;
					size_t branches{};
					if (GetOpcodeBuf(code, static_cast<SIZE_T>(codeSize), opcodesBuf, true, branches) && opcodesBuf)
					{
						std::string cOpcodes{opcodesBuf};
						cOpcodes += "+";
						cOpcodes += std::to_string(branches); // opcodes+numberOfBranches
						userContext->funcSignature[cOpcodes] = sName;
						userContext->Dirty = true;

						free(opcodesBuf);
					}
				}
			}
		}
	}

	free(symbols);
	free(sectionHeaders);
}



================================================
File: idenLib/parseArchive.h
================================================
#pragma once

#include "utils.h"

namespace fs = std::filesystem;

#define EVEN_BYTE_ALIGN(x)	(((x) & 1) ? (x) + 1 : (x))


class Lib
{
	bool isLib = false;
	SIZE_T MemberSeekBase = IMAGE_ARCHIVE_START_SIZE;
	SIZE_T MemberSize = 0;
	void MemberHeader(__in IMAGE_ARCHIVE_MEMBER_HEADER& archiveMemberHdr);
	void DisasmObjCode(__in IMAGE_FILE_HEADER& imageFileHdr, __in byte* currentObjectStart, LPVOID pUserContext);
public:
	bool isx64 = false;
	byte* FileContent = nullptr;
	FILE* hFile = nullptr;
	SIZE_T FileLength = 0;
	Lib() = delete;
	Lib(const fs::path& libPath);
	_Success_(return)
	bool GetSignature(LPVOID pUserContext);

	~Lib();
};



================================================
File: idenLib/pdb.cpp
================================================
#include "pdb.h"

bool LoadDataFromPdb(const wchar_t* szFilename, IDiaDataSource** ppSource, IDiaSession** ppSession,
                     IDiaSymbol** ppGlobal);
bool GetMainSignature(__in IDiaSymbol* pGlobal, MAIN_SIG_INFO& mainInfo);
void GetMainRva(__in IDiaSymbol* pSymbol, MAIN_SIG_INFO& mainInfo);
void FindCallerSignature(__in IDiaSymbol* pSymbol, MAIN_SIG_INFO& mainInfo);
void GetCallerOpcodes(__in PBYTE funcVa, __in SIZE_T length, MAIN_SIG_INFO& mainInfo);

_Success_(return)

bool ProcessMainSignature(const fs::path& pePath)
{
	auto loadAddress = reinterpret_cast<DWORD_PTR>(LoadLibraryEx(pePath.c_str(), nullptr,
	                                                             LOAD_LIBRARY_AS_IMAGE_RESOURCE));
	if (INVALID_HANDLE_VALUE == reinterpret_cast<HANDLE>(loadAddress))
	{
		printf("Failed to map....");
		return false;
	}
	// if PE is DLL, LOAD_LIBRARY_AS_IMAGE_RESOURCE flag increases baseAddress by 2
	MEMORY_BASIC_INFORMATION info{};
	if (!VirtualQuery(reinterpret_cast<LPCVOID>(loadAddress), &info, sizeof(info)))
	{
		printf("[!] VirtualQuery failed\n");
		return false;
	}
	loadAddress = reinterpret_cast<UINT64>(info.AllocationBase);

	const auto dosHeader = reinterpret_cast<PIMAGE_DOS_HEADER>(loadAddress);
	const auto ntHeader = reinterpret_cast<PIMAGE_NT_HEADERS>(loadAddress + dosHeader->e_lfanew);
	const auto isx64 = ntHeader->FileHeader.Machine == Arch64;

	MAIN_SIG_INFO mainInfo;
	mainInfo.Dirty = false;
	mainInfo.baseAddress = loadAddress;

	if (isx64)
	{
		entryPointSignatures = L"EntryPointSignatures.sig64";
		subFolder = L"x64";
		zydisMode = ZYDIS_MACHINE_MODE_LONG_64;
		zydisWidth = ZYDIS_ADDRESS_WIDTH_64;
		auto ntHeaderCurrent = reinterpret_cast<PIMAGE_NT_HEADERS64>(ntHeader);
		mainInfo.EntryAddress = static_cast<DWORD_PTR>(ntHeaderCurrent->OptionalHeader.AddressOfEntryPoint);
	}
	else
	{
		entryPointSignatures = L"EntryPointSignatures.sig";
		subFolder = L"x86";
		zydisMode = ZYDIS_MACHINE_MODE_LEGACY_32;
		zydisWidth = ZYDIS_ADDRESS_WIDTH_32;
		auto ntHeaderCurrent = reinterpret_cast<PIMAGE_NT_HEADERS32>(ntHeader);
		mainInfo.EntryAddress = static_cast<DWORD_PTR>(ntHeaderCurrent->OptionalHeader.AddressOfEntryPoint);
	}

	IDiaDataSource* g_pDiaDataSource;
	IDiaSession* g_pDiaSession;
	IDiaSymbol* g_pGlobalSymbol;

	if (!LoadDataFromPdb(pePath.c_str(), &g_pDiaDataSource, &g_pDiaSession, &g_pGlobalSymbol))
	{
		printf("LoadDataFromPdb failed\n");
		return false;
	}

	if (!GetMainSignature(g_pGlobalSymbol, mainInfo))
	{
		//fwprintf(stderr, L"[idenLib - FAILED] GetMainSignature failed\n");
		return false;
	}

	if (!mainInfo.Dirty)
	{
		fwprintf(stderr, L"[idenLib - INFO] Can not generate a signature: %s\n", pePath.c_str());
		return true;
	}

	fs::path mainSigPath = symExPath;
	mainSigPath += L"\\";
	mainSigPath += subFolder;
	if (!exists(mainSigPath))
	{
		create_directories(mainSigPath);
	}
	mainSigPath += L"\\";
	mainSigPath += entryPointSignatures;

	std::unordered_map<std::string, std::string> mainSigs;

	if (exists(mainSigPath))
	{
		PBYTE decompressedData{};
		if (!DecompressFile(mainSigPath, decompressedData) || !decompressedData)
		{
			fwprintf_s(stderr, L"[idenLib - FAILED] failed to decompress the file: %s\n", mainSigPath.c_str());
			return false;
		}
		const char seps[] = "\n";
		char* next_token = nullptr;
		char* line = strtok_s(reinterpret_cast<char*>(decompressedData), seps, &next_token);
		while (line != nullptr)
		{
			std::vector<std::string> vec{};
			Split(line, vec);
			if (vec.size() != 2)
			{
				fwprintf(stderr, L"[idenLib - FAILED] SIG file contains a malformed data, SIG path: %s\n",
				         mainSigPath.c_str());
				return false;
			}
			// vec[0] opcode
			// vec[1] name
			mainSigs[vec[0]] = vec[1];

			line = strtok_s(nullptr, seps, &next_token);
		}


		delete[] decompressedData;
	}
	mainSigs[mainInfo.opcodes_index] = mainInfo.EntryName;

	fs::path sigPathTmp = mainSigPath;
	sigPathTmp += L".tmp";
	if (exists(sigPathTmp))
	{
		fs::remove(sigPathTmp);
	}

	FILE* hFile = nullptr;
	fopen_s(&hFile, sigPathTmp.string().c_str(), "wb");
	if (!hFile)
	{
		fwprintf(stderr, L"[idenLib - FAILED] failed to create sig file: %s\n", mainSigPath.c_str());
		return false;
	}
	for (const auto& n : mainSigs)
	{
		const auto bothSize = n.first.size() + n.second.size() + 3; // space + \n + 0x00
		const auto opcodesName = new CHAR[bothSize];
		sprintf_s(opcodesName, bothSize, "%s %s\n", n.first.c_str(), n.second.c_str());
		fwrite(opcodesName, bothSize - 1, 1, hFile); // -1 without 0x00
		delete[] opcodesName;
	}
	fclose(hFile);

	if (CompressFile(sigPathTmp, mainSigPath))
	{
		wprintf(L"[idenLib] Created SIG file: %s based on %s\n", mainSigPath.c_str(), pePath.c_str());
	}
	else
	{
		fwprintf(stderr, L"[idenLib - FAILED] compression failed\n");
	}
	if (exists(sigPathTmp))
		fs::remove(sigPathTmp);


	if (exists(mainSigPath) && is_empty(mainSigPath))
	{
		DeleteFile(mainSigPath.c_str());
	}


	return true;
}

bool LoadDataFromPdb(
	const wchar_t* szFilename,
	IDiaDataSource** ppSource,
	IDiaSession** ppSession,
	IDiaSymbol** ppGlobal)
{
	TCHAR wszExt[MAX_PATH]{};

	// Obtain access to the provider
	auto hr = CoCreateInstance(__uuidof(DiaSource),
	                           nullptr,
	                           CLSCTX_INPROC_SERVER,
	                           __uuidof(IDiaDataSource),
	                           reinterpret_cast<void **>(ppSource));

	if (FAILED(hr))
	{
		fwprintf(stderr, L"[idenLib - Failed] CoCreateInstance failed - HRESULT = %08X\n", hr);

		return false;
	}

	_wsplitpath_s(szFilename, nullptr, 0, nullptr, 0, nullptr, 0, wszExt, MAX_PATH);

	if (_wcsicmp(wszExt, L".pdb") == 0)
	{
		// Open and prepare a program database (.pdb) file as a debug data source

		hr = (*ppSource)->loadDataFromPdb(szFilename);

		if (FAILED(hr))
		{
			fwprintf(stderr, L"[idenLib - FAILED] loadDataFromPdb failed - HRESULT = %08X\n", hr);

			return false;
		}
	}

	else
	{
		// Open and prepare the debug data associated with the .exe/.dll file
		hr = (*ppSource)->loadDataForExe(szFilename, nullptr, nullptr);
		if (hr != S_OK)
		{
			wprintf(L"loadDataForExe failed - HRESULT = %x\n", hr);
			return false;
		}
	}

	// Open a session for querying symbols

	hr = (*ppSource)->openSession(ppSession);

	if (FAILED(hr))
	{
		fwprintf(stderr, L"[idenLib - FAILED] openSession failed - HRESULT = %08X\n", hr);

		return false;
	}

	// Retrieve a reference to the global scope

	hr = (*ppSession)->get_globalScope(ppGlobal);

	if (hr != S_OK)
	{
		fwprintf(stderr, L"[idenLib - FAILED] get_globalScope failed\n");

		return false;
	}

	return true;
}

bool GetMainSignature(__in IDiaSymbol* pGlobal, MAIN_SIG_INFO& mainInfo)
{
	IDiaEnumSymbols* pEnumSymbols;
	IDiaSymbol* pSymbol;
	ULONG celt = 0;


	// find RVA of a main function
	mainInfo.mainVA = 0;
	if (SUCCEEDED(pGlobal->findChildren(SymTagFunction, nullptr, nsNone, &pEnumSymbols)))
	{
		while (!mainInfo.mainVA && SUCCEEDED(pEnumSymbols->Next(1, &pSymbol, &celt)) && (celt == 1))
		{
			GetMainRva(pSymbol, mainInfo);

			pSymbol->Release();
		}

		pEnumSymbols->Release();
	}

	else
	{
		fwprintf(stderr, L"[IdenLib - FAILED] findChildren(SymTagFunction, ...) failed \n");

		return false;
	}

	// find a function which calls main
	if (mainInfo.mainVA == 0u)
	{
		fwprintf(stderr, L"[IdenLib - FAILED] failed to find main RVA\n");
		return false;
	}

	if (SUCCEEDED(pGlobal->findChildren(SymTagFunction, nullptr, nsNone, &pEnumSymbols)))
	{
		while (!mainInfo.Dirty && SUCCEEDED(pEnumSymbols->Next(1, &pSymbol, &celt)) && (celt == 1))
		{
			FindCallerSignature(pSymbol, mainInfo);

			pSymbol->Release();
		}

		pEnumSymbols->Release();
	}


	return mainInfo.Dirty;
}

void FindCallerSignature(__in IDiaSymbol* pSymbol, MAIN_SIG_INFO& mainInfo)
{
	DWORD dwRva{};
	ULONGLONG length{};

	if (!pSymbol)
		return;

	DWORD dwSymTag{};
	if (pSymbol->get_symTag(&dwSymTag) != S_OK)
	{
		return;
	}

	auto isFunc = FALSE;
	pSymbol->get_function(&isFunc);
	if (!isFunc && dwSymTag != SymTagFunction)
		return;

	if (pSymbol->get_length(&length) != S_OK)
	{
		return;
	}

	if (pSymbol->get_relativeVirtualAddress(&dwRva) != S_OK)
	{
		dwRva = 0xFFFFFFFF;
	}

	// 444444...44_123 main
	// opcodes_mainInstrCount mainName
	GetCallerOpcodes(reinterpret_cast<PBYTE>(mainInfo.baseAddress + dwRva), length, mainInfo);
}

void GetCallerOpcodes(__in const PBYTE funcVa, __in SIZE_T length, MAIN_SIG_INFO& mainInfo)
{
	ZydisDecoder decoder;

	ZydisDecoderInit(&decoder, zydisMode, zydisWidth);

	ZyanUSize offset = 0;
	ZydisDecodedInstruction instruction;
	auto detected = false;

	size_t callInstr = 0;
	while (		ZYAN_SUCCESS(ZydisDecoderDecodeBuffer(&decoder, funcVa + offset, length - offset,
		&instruction)))
	{
		if (instruction.mnemonic == ZYDIS_MNEMONIC_CALL)
		{
			auto& callOperand = instruction.operands[0];
			ZyanU64 callVa{};
			auto instr = reinterpret_cast<ZyanU64>(funcVa) + offset;
			if (callOperand.type == ZYDIS_OPERAND_TYPE_IMMEDIATE && callOperand.imm.is_relative &&				ZYAN_SUCCESS(
ZydisCalcAbsoluteAddress(&instruction, &callOperand, instr, &callVa)))
			{
				if (callVa == mainInfo.mainVA)
				{
					detected = true;
					callInstr = offset;
					break;
				}
			}
		}
		offset += instruction.length;
	}

	if (!detected)
	{
		return;
	}

	offset = 0;
	auto cSize = length * 2;
	if (cSize < 3) // CHAR opcode[3];
	{
		return;
	}
	auto opcodesBuf = static_cast<PCHAR>(malloc(cSize)); // // we need to resize the buffer
	if (opcodesBuf == nullptr)
	{
		return;
	}
	SIZE_T counter = 0;
	const auto maxLength = length > MAX_FUNC_SIZE ? MAX_FUNC_SIZE : length;
	while (		ZYAN_SUCCESS(ZydisDecoderDecodeBuffer(&decoder, funcVa + offset, maxLength - offset,
		&instruction)))
	{
		CHAR opcode[3];
		sprintf_s(opcode, "%02x", instruction.opcode);

		memcpy_s(opcodesBuf + counter, cSize - counter, opcode, sizeof(opcode));
		counter += 2;

		offset += instruction.length;
	}
	auto tmpPtr = static_cast<PCHAR>(realloc(opcodesBuf, counter + 1)); // +1 for 0x00
	if (tmpPtr == nullptr)
	{
		return;
	}
	opcodesBuf = tmpPtr;


	mainInfo.Dirty = true;
	// Two ways to index a main function location
	std::string mainOpcodes{opcodesBuf};
	mainOpcodes += "_" + std::to_string(callInstr); // _123 => call "main" offset = func + 123
	signed long distanceFromEntry = reinterpret_cast<DWORD_PTR>(funcVa) + callInstr - (mainInfo.EntryAddress + mainInfo.
		baseAddress);
	mainOpcodes += "!" + std::to_string(distanceFromEntry); // !567 => call "main" offset = EP + 567
	mainInfo.opcodes_index = mainOpcodes;


	free(opcodesBuf);
}

void GetMainRva(__in IDiaSymbol* pSymbol, MAIN_SIG_INFO& mainInfo)
{
	DWORD dwRva{};

	if (!pSymbol)
		return;

	DWORD dwSymTag{};
	if (pSymbol->get_symTag(&dwSymTag) != S_OK)
	{
		return;
	}

	auto isFunc = FALSE;
	pSymbol->get_function(&isFunc);
	if (!isFunc && dwSymTag != SymTagFunction)
		return;

	if (pSymbol->get_relativeVirtualAddress(&dwRva) != S_OK)
	{
		dwRva = 0xFFFFFFFF;
	}

	BSTR bstrName;
	if (pSymbol->get_name(&bstrName) == S_OK)
	{
		const std::wstring name{bstrName};

		// mainCRTStartup(or wmainCRTStartup) 			An application that uses / SUBSYSTEM:CONSOLE; calls main(or wmain)
		// WinMainCRTStartup(or wWinMainCRTStartup) 	An application that uses / SUBSYSTEM:WINDOWS; calls WinMain(or wWinMain), which must be defined to use __stdcall
		// _DllMainCRTStartup 							A DLL; calls DllMain if it exists, which must be defined to use __stdcall

		// main wmain WinMain or wWinMain
		if (name == L"main" || name == L"wmain" || name == L"WinMain" || name == L"wWinMain")
		{
			mainInfo.mainVA = dwRva + mainInfo.baseAddress;
			mainInfo.EntryName = std::string{name.begin(), name.end()};
		}

		SysFreeString(bstrName);
	}
}



================================================
File: idenLib/pdb.h
================================================
#pragma once

#include "utils.h"

_Success_(return)
bool ProcessMainSignature(const fs::path& pePath);

typedef struct _MAIN_SIG_INFO
{
	std::unordered_map<std::string, std::string> MainSignatures;
	bool Dirty;
	std::string EntryName;
	std::string opcodes_index;
	DWORD_PTR baseAddress;
	DWORD_PTR mainVA;
	DWORD_PTR EntryAddress;
} MAIN_SIG_INFO, *P_MAIN_SIG_INFO;



================================================
File: idenLib/utils.cpp
================================================
#include "utils.h"

// http://www.martinbroadhurst.com/how-to-split-a-string-in-c.html
void Split(__in const std::string& str, __out std::vector<std::string>& cont)
{
	std::istringstream iss{str};
	std::copy(std::istream_iterator<std::string>(iss),
	          std::istream_iterator<std::string>(),
	          std::back_inserter(cont));
}



================================================
File: idenLib/utils.h
================================================
#pragma once

#include <Windows.h>
#include <dia2.h>

#include <cstdio>
#include <string>
#include <fstream>
#include <algorithm>
#include <sstream>
#include <iterator>
#include <unordered_map>
#include <vector>
#include <filesystem>


#include "disassamble.h"
#include "parseArchive.h"
#include "compression.h"
#include "pdb.h"

#include "Zydis/Zydis.h"

#define ZSTD_STATIC_LINKING_ONLY
#include "zstd.h"

namespace fs = std::filesystem;

#define NT_SUCCESS(_)				(((NTSTATUS)(_)) >= 0)
#define STATUS_SUCCESS				((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL			((NTSTATUS)0xC0000001L)

#define MIN_FUNC_SIZE 0x20
#define MAX_FUNC_SIZE 0x100

inline auto entryPointSignatures = L"EntryPointSignatures.sig";
inline auto sigExt = L".sig";
inline auto subFolder = L"x86";
inline auto zydisMode = ZYDIS_MACHINE_MODE_LEGACY_32;
inline auto zydisWidth = ZYDIS_ADDRESS_WIDTH_32;

inline fs::path symExPath{"SymEx"};
inline fs::path pdbDirName{"symbols"};

void Split(__in const std::string& str, __out std::vector<std::string>& cont);

typedef struct _USER_CONTEXT
{
	std::unordered_map<std::string, std::string> funcSignature;
	bool Dirty;
} USER_CONTEXT, *PUSER_CONTEXT;

enum
{
	Arch86 = 0x14C,
	Arch64 = 0x8664
};





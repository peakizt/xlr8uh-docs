Directory structure:
└── saneki-eazdevirt/
    ├── README.md
    ├── LICENSE
    ├── Rebracer.xml
    ├── eazdevirt.sln
    ├── dnlib/
    └── src/
        └── eazdevirt/
            ├── MonoOptions.cs
            ├── Program.Devirtualize.cs
            ├── Program.Generate.cs
            ├── Program.GetKey.cs
            ├── Program.Instructions.cs
            ├── Program.Methods.cs
            ├── Program.Position.cs
            ├── Program.Resource.cs
            ├── Program.cs
            ├── app.config
            ├── eazdevirt.csproj
            ├── Core/
            │   ├── AttributeInjector.cs
            │   ├── CryptoStreamBase.cs
            │   ├── Devirtualizer.cs
            │   ├── EazModule.cs
            │   ├── Helpers.cs
            │   ├── IPositionTranslator.cs
            │   ├── MethodStub.cs
            │   ├── MethodStubNotFoundException.cs
            │   ├── OriginalOpcodeUnknownException.cs
            │   ├── PositionTranslator.cs
            │   ├── SerializationVersion.cs
            │   ├── SpecialCode.cs
            │   ├── StackTypeHelper.cs
            │   ├── VirtualMachineType.cs
            │   ├── VirtualOpCode.Helpers.cs
            │   ├── VirtualOpCode.cs
            │   ├── Types/
            │   │   ├── BaseTypeDefProvider.cs
            │   │   ├── CryptoStreamDef.cs
            │   │   └── ITypeDefProvider.cs
            │   ├── V1/
            │   │   └── CryptoStreamV1.cs
            │   └── V2/
            │       └── CryptoStreamV2.cs
            ├── Detection/
            │   ├── IInstructionDetector.cs
            │   ├── InstructionDetectorBase.cs
            │   └── V1/
            │       ├── Detection.Arg.cs
            │       ├── Detection.Bitwise.cs
            │       ├── Detection.Br.cs
            │       ├── Detection.Conv.cs
            │       ├── Detection.Elem.cs
            │       ├── Detection.Ind.cs
            │       ├── Detection.Ldc.cs
            │       ├── Detection.Loc.cs
            │       ├── Detection.Math.cs
            │       ├── Detection.Misc.cs
            │       ├── Detection.Prefix.cs
            │       ├── Detection.Special.cs
            │       ├── Detection.Unsupported.cs
            │       ├── Detection.cs
            │       └── InstructionDetectorV1.cs
            ├── Fixers/
            │   ├── FixerAttribute.cs
            │   ├── IMethodFixer.cs
            │   ├── MethodFixer.cs
            │   └── StindFixer.cs
            ├── Generator/
            │   ├── IAssemblyGenerator.cs
            │   └── VirtualizableAssemblyGenerator.cs
            ├── IO/
            │   ├── Resolver.Serialized.cs
            │   ├── Resolver.cs
            │   ├── ResourceReader.cs
            │   └── VirtualizedMethodBodyReader.cs
            ├── Logging/
            │   └── ConsoleLogger.cs
            ├── Mono/
            │   └── Mono.Options.cs
            ├── Properties/
            │   └── AssemblyInfo.cs
            ├── Reflection/
            │   └── DetectAttribute.cs
            └── Util/
                ├── DotNetUtils.cs
                ├── Extensions.cs
                ├── GenericUtils.cs
                ├── NameResolver.cs
                ├── SigUtil.cs
                └── StackTypesCalculator.cs

================================================
File: README.md
================================================
eazdevirt
=========

eazdevirt is an open source (GPLv3) toolkit for inspecting and devirtualizing
executables that have been protected with [Eazfuscator.NET]'s virtualization
feature.

eazdevirt uses [dnlib] to read and write assemblies, which is included as a
submodule.

Features
========

* Identify all methods (stubs) which have been virtualized
* Devirtualize methods for which all virtual opcodes are understood
* Inject method attributes to make identifying devirtualized methods easier
* Extract the embedded resource file containing virtualization info
* List all virtual opcodes and indicate which are identified

Common Issues / Solutions
=========================

Resolution of Types, Methods, etc.
----------------------------------

Because of how [Eazfuscator.NET]'s virtual machine works, resolving some types
and methods requires that their names and MDTokens be as expected (more
specifically, to match what is found in the embedded resource file). This means
that running [de4dot] against an executable with the default options before
attempting to devirtualize said executable might cause certain types/methods to
not resolve correctly.

However, **eazdevirt** also requires (in most cases) the control flow of the
program to be deobfuscated. Otherwise it might not detect certain virtual
opcodes, and in some cases it might not work at all.

One way around this is the following:

```sh
de4dot --dont-rename --keep-types --preserve-tokens MyAssembly.exe
eazdevirt -d MyAssembly-cleaned.exe
de4dot MyAssembly-cleaned-devirtualized.exe
```

... leaving the result as MyAssembly-cleaned-devirtualized-cleaned.exe

If de4dot is having trouble decrypting strings, try appending `--strtyp none`
after the input filename:

```sh
de4dot --dont-rename --keep-types --preserve-tokens MyAssembly.exe --strtyp none
...
de4dot MyAssembly-cleaned-devirtualized.exe --strtyp none
```

Building
========

Mono
----

To build with Mono:

```sh
git submodule update --init
xbuild eazdevirt.sln
```

MSVS
----

On a Windows machine with MSVS installed, opening the solution file and
building in Visual Studio should be sufficient (after updating the submodule
as shown above).

`msbuild eazdevirt.sln` should also work.

Special Thanks
==============

* [0xd4d], for the amazing [dnlib]
* Exclusive, for providing samples and helping debug along the way

[0xd4d]:https://github.com/0xd4d
[de4dot]:https://github.com/0xd4d/de4dot
[dnlib]:https://github.com/0xd4d/dnlib
[Eazfuscator.NET]:https://www.gapotchenko.com/eazfuscator.net



================================================
File: LICENSE
================================================
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.



================================================
File: Rebracer.xml
================================================
ï»¿<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<!--Rebracer Solution Settings File-->
<!--This file contains Visual Studio settings for eazdevirt.sln.-->
<!--Rebracer uses this file to apply settings for this solution-->
<!--when the solution is opened.-->
<!--Install Rebracer from http://visualstudiogallery.msdn.microsoft.com/410e9b9f-65f3-4495-b68e-15567e543c58 -->
<!--See https://github.com/SLaks/Rebracer for more information-->
<UserSettings>
  <ToolsOptions>
    <ToolsOptionsCategory name="Environment">
      <ToolsOptionsSubCategory name="TaskList">
        <PropertyValue name="CommentTokens" ArrayType="VT_VARIANT" ArrayElementCount="4">
          <PropertyValue name="0">TODO:2</PropertyValue>
          <PropertyValue name="1">HACK:2</PropertyValue>
          <PropertyValue name="2">UNDONE:2</PropertyValue>
          <PropertyValue name="3">UnresolvedMergeConflict:3</PropertyValue>
        </PropertyValue>
        <PropertyValue name="ConfirmTaskDeletion">true</PropertyValue>
        <PropertyValue name="DontShowFilePaths">true</PropertyValue>
        <PropertyValue name="WarnOnAddingHiddenItem">false</PropertyValue>
      </ToolsOptionsSubCategory>
    </ToolsOptionsCategory>
    <ToolsOptionsCategory name="TextEditor">
      <ToolsOptionsSubCategory name="CSharp-Specific">
        <PropertyValue name="AutoComment">1</PropertyValue>
        <PropertyValue name="CodeDefinitionWindow_DocumentationComment_IndentBase">1</PropertyValue>
        <PropertyValue name="CodeDefinitionWindow_DocumentationComment_IndentOffset">2</PropertyValue>
        <PropertyValue name="CodeDefinitionWindow_DocumentationComment_WrapLength">80</PropertyValue>
        <PropertyValue name="Formatting_TriggerOnBlockCompletion">1</PropertyValue>
        <PropertyValue name="Formatting_TriggerOnPaste">1</PropertyValue>
        <PropertyValue name="Formatting_TriggerOnStatementCompletion">1</PropertyValue>
        <PropertyValue name="ImplementInterface_InsertRegionTags">0</PropertyValue>
        <PropertyValue name="Indent_BlockContents">1</PropertyValue>
        <PropertyValue name="Indent_Braces">0</PropertyValue>
        <PropertyValue name="Indent_CaseContents">1</PropertyValue>
        <PropertyValue name="Indent_CaseLabels">1</PropertyValue>
        <PropertyValue name="Indent_FlushLabelsLeft">0</PropertyValue>
        <PropertyValue name="Indent_UnindentLabels">1</PropertyValue>
        <PropertyValue name="NewLines_AnonymousTypeInitializer_EachMember">1</PropertyValue>
        <PropertyValue name="NewLines_Braces_AnonymousMethod">1</PropertyValue>
        <PropertyValue name="NewLines_Braces_AnonymousTypeInitializer">1</PropertyValue>
        <PropertyValue name="NewLines_Braces_ArrayInitializer">0</PropertyValue>
        <PropertyValue name="NewLines_Braces_CollectionInitializer">0</PropertyValue>
        <PropertyValue name="NewLines_Braces_ControlFlow">1</PropertyValue>
        <PropertyValue name="NewLines_Braces_LambdaExpressionBody">1</PropertyValue>
        <PropertyValue name="NewLines_Braces_Method">1</PropertyValue>
        <PropertyValue name="NewLines_Braces_ObjectInitializer">1</PropertyValue>
        <PropertyValue name="NewLines_Braces_Type">1</PropertyValue>
        <PropertyValue name="NewLines_Keywords_Catch">1</PropertyValue>
        <PropertyValue name="NewLines_Keywords_Else">1</PropertyValue>
        <PropertyValue name="NewLines_Keywords_Finally">1</PropertyValue>
        <PropertyValue name="NewLines_ObjectInitializer_EachMember">1</PropertyValue>
        <PropertyValue name="NewLines_QueryExpression_EachClause">1</PropertyValue>
        <PropertyValue name="RemoveUnusedUsings">1</PropertyValue>
        <PropertyValue name="SortUsings">1</PropertyValue>
        <PropertyValue name="SortUsings_PlaceSystemFirst">0</PropertyValue>
        <PropertyValue name="Space_AfterBasesColon">1</PropertyValue>
        <PropertyValue name="Space_AfterCast">0</PropertyValue>
        <PropertyValue name="Space_AfterComma">1</PropertyValue>
        <PropertyValue name="Space_AfterDot">0</PropertyValue>
        <PropertyValue name="Space_AfterLambdaArrow">1</PropertyValue>
        <PropertyValue name="Space_AfterMethodCallName">0</PropertyValue>
        <PropertyValue name="Space_AfterMethodDeclarationName">0</PropertyValue>
        <PropertyValue name="Space_AfterSemicolonsInForStatement">1</PropertyValue>
        <PropertyValue name="Space_AroundBinaryOperator">1</PropertyValue>
        <PropertyValue name="Space_BeforeBasesColon">1</PropertyValue>
        <PropertyValue name="Space_BeforeComma">0</PropertyValue>
        <PropertyValue name="Space_BeforeDot">0</PropertyValue>
        <PropertyValue name="Space_BeforeLambdaArrow">1</PropertyValue>
        <PropertyValue name="Space_BeforeOpenSquare">0</PropertyValue>
        <PropertyValue name="Space_BeforeSemicolonsInForStatement">0</PropertyValue>
        <PropertyValue name="Space_BetweenEmptyMethodCallParentheses">0</PropertyValue>
        <PropertyValue name="Space_BetweenEmptyMethodDeclarationParentheses">0</PropertyValue>
        <PropertyValue name="Space_BetweenEmptySquares">0</PropertyValue>
        <PropertyValue name="Space_InControlFlowConstruct">1</PropertyValue>
        <PropertyValue name="Space_Normalize">0</PropertyValue>
        <PropertyValue name="Space_WithinCastParentheses">0</PropertyValue>
        <PropertyValue name="Space_WithinExpressionParentheses">0</PropertyValue>
        <PropertyValue name="Space_WithinMethodCallParentheses">0</PropertyValue>
        <PropertyValue name="Space_WithinMethodDeclarationParentheses">0</PropertyValue>
        <PropertyValue name="Space_WithinOtherParentheses">0</PropertyValue>
        <PropertyValue name="Space_WithinSquares">0</PropertyValue>
        <PropertyValue name="WarnOnBuildErrors">1</PropertyValue>
        <PropertyValue name="WarnWhenMembersCauseCompilerGeneratedReferences">1</PropertyValue>
        <PropertyValue name="Wrapping_IgnoreSpacesAroundBinaryOperators">0</PropertyValue>
        <PropertyValue name="Wrapping_IgnoreSpacesAroundVariableDeclaration">0</PropertyValue>
        <PropertyValue name="Wrapping_KeepStatementsOnSingleLine">1</PropertyValue>
        <PropertyValue name="Wrapping_PreserveSingleLine">1</PropertyValue>
      </ToolsOptionsSubCategory>
      <ToolsOptionsSubCategory name="JavaScript Specific">
        <PropertyValue name="DownloadRemoteReferences">false</PropertyValue>
        <PropertyValue name="FormatCompletedBlockOnRightCurlyBrace">true</PropertyValue>
        <PropertyValue name="FormatCompletedLineOnEnter">true</PropertyValue>
        <PropertyValue name="FormatCompletedStatementOnSemicolon">true</PropertyValue>
        <PropertyValue name="FormatOnPaste">true</PropertyValue>
        <PropertyValue name="ImplicitReferencesString">Implicit (Windows 8)|$(VSInstallDir)\JavaScript\References\libhelp.js|$(VSInstallDir)\JavaScript\References\sitetypesWindows.js|$(VSInstallDir)\JavaScript\References\domWindows_8.0.js|$(VSInstallDir)\JavaScript\References\underscorefilter.js|$(VSInstallDir)\JavaScript\References\showPlainComments.js;Implicit (Windows 8.1)|$(VSInstallDir)\JavaScript\References\libhelp.js|$(VSInstallDir)\JavaScript\References\sitetypesWindows.js|$(VSInstallDir)\JavaScript\References\domWindows_8.1.js|$(VSInstallDir)\JavaScript\References\underscorefilter.js|$(VSInstallDir)\JavaScript\References\showPlainComments.js;Implicit (Windows Phone 8.1)|$(VSInstallDir)\JavaScript\References\libhelp.js|$(VSInstallDir)\JavaScript\References\sitetypesWindows.js|$(VSInstallDir)\JavaScript\References\domWindowsPhone_8.1.js|$(VSInstallDir)\JavaScript\References\underscorefilter.js|$(VSInstallDir)\JavaScript\References\showPlainComments.js;Implicit (Web)|$(VSInstallDir)\JavaScript\References\libhelp.js|$(VSInstallDir)\JavaScript\References\sitetypesWeb.js|$(VSInstallDir)\JavaScript\References\domWeb.js|$(VSInstallDir)\JavaScript\References\underscorefilter.js|$(VSInstallDir)\JavaScript\References\showPlainComments.js|~/Scripts/_references.js;Dedicated Worker|$(VSInstallDir)\JavaScript\References\libhelp.js|$(VSInstallDir)\JavaScript\References\dedicatedworker.js|$(VSInstallDir)\JavaScript\References\underscorefilter.js|$(VSInstallDir)\JavaScript\References\showPlainComments.js;Generic|$(VSInstallDir)\JavaScript\References\libhelp.js|$(VSInstallDir)\JavaScript\References\underscorefilter.js|$(VSInstallDir)\JavaScript\References\showPlainComments.js;</PropertyValue>
        <PropertyValue name="InsertSpaceAfterCommaDelimiter">true</PropertyValue>
        <PropertyValue name="InsertSpaceAfterFunctionKeywordForAnonymousFunctions">true</PropertyValue>
        <PropertyValue name="InsertSpaceAfterKeywordsInControlFlowStatements">true</PropertyValue>
        <PropertyValue name="InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis">false</PropertyValue>
        <PropertyValue name="InsertSpaceAfterSemicolonInForStatements">true</PropertyValue>
        <PropertyValue name="InsertSpaceBeforeAndAfterBinaryOperators">true</PropertyValue>
        <PropertyValue name="PlaceOpenBraceOnNewLineForControlBlocks">false</PropertyValue>
        <PropertyValue name="PlaceOpenBraceOnNewLineForFunctions">false</PropertyValue>
        <PropertyValue name="ShowErrorsAsWarnings">true</PropertyValue>
        <PropertyValue name="ShowSyntaxErrors">true</PropertyValue>
      </ToolsOptionsSubCategory>
      <ToolsOptionsSubCategory name="C/C++ Specific">
        <PropertyValue name="AddSemicolonForClassTypes">true</PropertyValue>
        <PropertyValue name="AlignParameters">false</PropertyValue>
        <PropertyValue name="AlwaysUseFallbackLocation">false</PropertyValue>
        <PropertyValue name="AutoFormatOnBraceCompletion">true</PropertyValue>
        <PropertyValue name="AutoFormatOnClosingBrace">true</PropertyValue>
        <PropertyValue name="AutoFormatOnPaste">true</PropertyValue>
        <PropertyValue name="AutoFormatOnSemicolon">true</PropertyValue>
        <PropertyValue name="AutoIndentOnTab">false</PropertyValue>
        <PropertyValue name="ColorizeInactiveBlocksDifferently">true</PropertyValue>
        <PropertyValue name="DisableBrowsingUpToDateCheck">true</PropertyValue>
        <PropertyValue name="DisableErrorReporting">false</PropertyValue>
        <PropertyValue name="EnumerateCommentTasks">true</PropertyValue>
        <PropertyValue name="GroupBrackets">true</PropertyValue>
        <PropertyValue name="HighlightMatchingTokens">true</PropertyValue>
        <PropertyValue name="IndentAccessSpecifiers">false</PropertyValue>
        <PropertyValue name="IndentBlockContents">true</PropertyValue>
        <PropertyValue name="IndentBraces">false</PropertyValue>
        <PropertyValue name="IndentCaseBraces">false</PropertyValue>
        <PropertyValue name="IndentCaseContents">true</PropertyValue>
        <PropertyValue name="IndentCaseLabels">false</PropertyValue>
        <PropertyValue name="IndentGotoLabels">1</PropertyValue>
        <PropertyValue name="IndentNamespaceContents">true</PropertyValue>
        <PropertyValue name="NewlineControlBlockBrace">0</PropertyValue>
        <PropertyValue name="NewlineEmptyFunctionCloseBrace">true</PropertyValue>
        <PropertyValue name="NewlineEmptyTypeCloseBrace">true</PropertyValue>
        <PropertyValue name="NewlineFunctionBrace">0</PropertyValue>
        <PropertyValue name="NewlineInitListBrace">0</PropertyValue>
        <PropertyValue name="NewlineKeywordCatch">true</PropertyValue>
        <PropertyValue name="NewlineKeywordElse">true</PropertyValue>
        <PropertyValue name="NewlineKeywordWhile">false</PropertyValue>
        <PropertyValue name="NewlineLambdaBrace">0</PropertyValue>
        <PropertyValue name="NewlineNamespaceBrace">0</PropertyValue>
        <PropertyValue name="NewlineTypeBrace">0</PropertyValue>
        <PropertyValue name="PreserveBlock">1</PropertyValue>
        <PropertyValue name="PreserveParameterIndentation">false</PropertyValue>
        <PropertyValue name="RemoveSpaceBeforeSemicolon">true</PropertyValue>
        <PropertyValue name="SpaceAfterCastParenthesis">false</PropertyValue>
        <PropertyValue name="SpaceAfterComma">true</PropertyValue>
        <PropertyValue name="SpaceAfterSemicolon">true</PropertyValue>
        <PropertyValue name="SpaceAroundAssignmentOperator">2</PropertyValue>
        <PropertyValue name="SpaceAroundBinaryOperator">2</PropertyValue>
        <PropertyValue name="SpaceAroundConditionalOperator">2</PropertyValue>
        <PropertyValue name="SpaceBeforeBracket">false</PropertyValue>
        <PropertyValue name="SpaceBeforeComma">false</PropertyValue>
        <PropertyValue name="SpaceBeforeConstructorColon">true</PropertyValue>
        <PropertyValue name="SpaceBeforeControlBlockParenthesis">true</PropertyValue>
        <PropertyValue name="SpaceBeforeEmptyBracket">false</PropertyValue>
        <PropertyValue name="SpaceBeforeFunctionParenthesis">false</PropertyValue>
        <PropertyValue name="SpaceBeforeInheritanceColon">true</PropertyValue>
        <PropertyValue name="SpaceBeforeInitListBrace">false</PropertyValue>
        <PropertyValue name="SpaceBeforeLambdaParenthesis">false</PropertyValue>
        <PropertyValue name="SpaceBetweenEmptyBraces">false</PropertyValue>
        <PropertyValue name="SpaceBetweenEmptyBrackets">false</PropertyValue>
        <PropertyValue name="SpaceBetweenEmptyFunctionParentheses">false</PropertyValue>
        <PropertyValue name="SpaceBetweenEmptyLambdaBrackets">false</PropertyValue>
        <PropertyValue name="SpaceWithinBrackets">false</PropertyValue>
        <PropertyValue name="SpaceWithinCastParentheses">false</PropertyValue>
        <PropertyValue name="SpaceWithinControlBlockParentheses">false</PropertyValue>
        <PropertyValue name="SpaceWithinExpressionParentheses">false</PropertyValue>
        <PropertyValue name="SpaceWithinFunctionParentheses">false</PropertyValue>
        <PropertyValue name="SpaceWithinInitListBraces">true</PropertyValue>
        <PropertyValue name="SpaceWithinLambdaBrackets">false</PropertyValue>
        <PropertyValue name="TrimSpaceAroundScope">true</PropertyValue>
        <PropertyValue name="TrimSpaceUnaryOperator">true</PropertyValue>
      </ToolsOptionsSubCategory>
      <ToolsOptionsSubCategory name="TypeScript Specific">
        <PropertyValue name="AutomaticallyCompileTypeScriptFilesWhenSavedWhenNoSolution">false</PropertyValue>
        <PropertyValue name="FormatCompletedBlockOnRightCurlyBrace">true</PropertyValue>
        <PropertyValue name="FormatCompletedLineOnEnter">true</PropertyValue>
        <PropertyValue name="FormatCompletedStatementOnSemicolon">true</PropertyValue>
        <PropertyValue name="FormatOnPaste">true</PropertyValue>
        <PropertyValue name="InsertSpaceAfterCommaDelimiter">true</PropertyValue>
        <PropertyValue name="InsertSpaceAfterFunctionKeywordForAnonymousFunctions">true</PropertyValue>
        <PropertyValue name="InsertSpaceAfterKeywordsInControlFlowStatements">true</PropertyValue>
        <PropertyValue name="InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis">false</PropertyValue>
        <PropertyValue name="InsertSpaceAfterSemicolonInForStatements">true</PropertyValue>
        <PropertyValue name="InsertSpaceBeforeAndAfterBinaryOperators">true</PropertyValue>
        <PropertyValue name="PlaceOpenBraceOnNewLineForControlBlocks">false</PropertyValue>
        <PropertyValue name="PlaceOpenBraceOnNewLineForFunctions">false</PropertyValue>
        <PropertyValue name="ShowVirtualProjectsInSolutionExplorerWhenNoSolution">true</PropertyValue>
        <PropertyValue name="ShowVirtualProjectsInSolutionExplorerWhenSolutionOpen">false</PropertyValue>
        <PropertyValue name="UseAMDCodeGenerationForModulesThatAreNotPartOfAProject">false</PropertyValue>
        <PropertyValue name="UseCommonJSCodeGenerationForModulesThatAreNotPartOfAProject">false</PropertyValue>
      </ToolsOptionsSubCategory>
      <ToolsOptionsSubCategory name="HTMLX Specific">
        <PropertyValue name="EnableValidation">true</PropertyValue>
        <PropertyValue name="ErrorsAsWarnings">true</PropertyValue>
        <PropertyValue name="FormatOnPaste">true</PropertyValue>
        <PropertyValue name="InsertAttributeValueQuotes">true</PropertyValue>
        <PropertyValue name="InsertClosingTag">true</PropertyValue>
        <PropertyValue name="XHtmlCodingStyle">true</PropertyValue>
      </ToolsOptionsSubCategory>
    </ToolsOptionsCategory>
  </ToolsOptions>
</UserSettings>


================================================
File: eazdevirt.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.31101.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "eazdevirt", "src\eazdevirt\eazdevirt.csproj", "{6E44FD35-6D3C-46DD-9B3A-2203317E7FEF}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "dnlib", "dnlib\src\dnlib.csproj", "{FDFC1237-143F-4919-8318-4926901F4639}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{F7672BE0-C22D-40E8-BD0C-B99C2D859356}"
	ProjectSection(SolutionItems) = preProject
		Rebracer.xml = Rebracer.xml
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{6E44FD35-6D3C-46DD-9B3A-2203317E7FEF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6E44FD35-6D3C-46DD-9B3A-2203317E7FEF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6E44FD35-6D3C-46DD-9B3A-2203317E7FEF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6E44FD35-6D3C-46DD-9B3A-2203317E7FEF}.Release|Any CPU.Build.0 = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal




================================================
File: src/eazdevirt/MonoOptions.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using Mono.Options;
using eazdevirt.Fixers;

namespace eazdevirt
{
	public class MonoOptions
	{
		public ProgramAction Action = ProgramAction.None;
		public Boolean NoLogo = false;

		/// <summary>
		/// Path to input assembly.
		/// </summary>
		public String AssemblyPath = null;

		/// <summary>
		/// Path to output assembly.
		/// </summary>
		public String OutputPath = null;

		public Boolean Help = false;
		public UInt32 VerboseLevel = 0;

		/// <summary>
		/// Whether or not to not throw when writing.
		/// </summary>
		public Boolean NoThrow = false;

		/// <summary>
		/// Whether or not to inject attributes upon successful devirtualization.
		/// </summary>
		public Boolean InjectAttributes = false;

		/// <summary>
		/// Used for: generate.
		/// </summary>
		public String InstructionSet = null;

		public Boolean OnlyIdentified = false;

		/// <summary>
		/// Integer crypto key.
		/// </summary>
		/// <remarks>
		/// HelpText = "Integer key used for crypto"
		/// Used for: position
		/// </remarks>
		public Nullable<Int32> Key { get; set; }

		//public String Destination = null;
		public Boolean OverwriteExisting = false;
		public Boolean ExtractResource = true;
		public Boolean KeepEncrypted = false;

		/// <summary>
		/// Operand "whitelist". Remove or improve later.
		/// </summary>
		/// <remarks>
		/// HelpText = "Only show instructions with specified virtual operand type"
		/// Used for: instructions.
		/// </remarks>
		public Int32 OperandTypeWhitelist = Int32.MinValue;

		/// <summary>
		/// Whether or not to print information about operand types.
		/// </summary>
		/// <remarks>
		/// Used for: instructions.
		/// HelpText = "Print information about operand types"
		/// </remarks>
		public Boolean Operands = false;

		/// <summary>
		/// Position string to translate.
		/// </summary>
		/// <remarks>
		/// Used for: position
		/// </remarks>
		public String PositionString { get; set; }

		public List<String> Extra = null;
		public OptionSet OptionSet = null;

		public Boolean Verbose
		{
			get { return this.VerboseLevel > 0; }
		}

		public Boolean VeryVerbose
		{
			get { return this.VerboseLevel > 1; }
		}

		/// <summary>
		/// Get the option descriptors text from the OptionSet. If
		/// OptionSet is null, returns null.
		/// </summary>
		public String OptionDescriptors
		{
			get
			{
				if (this.OptionSet == null)
					return null;

				// Generate help string from OptionSet
				StringWriter writer = new StringWriter();
				this.OptionSet.WriteOptionDescriptions(writer);
				return writer.ToString();
			}
		}

		/// <summary>
		/// List of MethodFixer types to use.
		/// </summary>
		public IList<Type> MethodFixers
		{
			get
			{
				if (_methodFixers == null)
					this.FixersString = "all";
				return _methodFixers;
			}
			private set { _methodFixers = value; }
		}
		private IList<Type> _methodFixers = null;

		/// <summary>
		/// Set MethodFixers from a string describing the fixers to use.
		/// </summary>
		public String FixersString
		{
			set
			{
				var fields = value.Split(',') // Regex.Split(value, @"\s+")
					.Select(f => { return f.Trim().ToLower(); })
					.Where(f => f.Length > 0) // Remove empty fields
					.Distinct();

				var types = Assembly.GetExecutingAssembly().GetTypes();
				types = types.Where(t => {
					return (t.GetCustomAttribute(typeof(FixerAttribute))) != null;
				}).ToArray();

				if (fields.Contains("all"))
					this.MethodFixers = types;
				else if (fields.Contains("none"))
					this.MethodFixers = new List<Type>();
				else
				{
					this.MethodFixers = types.Where(t => {
						var attr = (FixerAttribute)t.GetCustomAttribute(typeof(FixerAttribute));
						return fields.Contains(attr.Name.ToLower());
					}).ToArray();
				}
			}
		}
	}

	public enum ProgramAction
	{
		None,
		Devirtualize,
		Generate,
		GetKey,
		Instructions,
		Methods,
		Position,
		Resource
	}
}



================================================
File: src/eazdevirt/Program.Devirtualize.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace eazdevirt
{
	public partial class Program
	{
		/// <summary>
		/// Print out information about whether or not a devirtualization attempt was
		/// successful, and if not why not.
		/// </summary>
		/// <param name="options">MonoOptions set from passed command-line arguments</param>
		/// <param name="module">EazModule</param>
		/// <param name="attempt">Data about the devirtualization attempt</param>
		static void PrintAttemptSuccess(MonoOptions options, EazModule module,
			DevirtualizeAttempt attempt)
		{
			var reader = attempt.Reader;

			if (attempt.Successful)
				Console.WriteLine("--> Devirtualizable");
			else if (attempt.WasInstructionUnknown)
			{
				var matches = module.VirtualInstructions
							.Where((instr) => { return instr.VirtualCode == reader.LastVirtualOpCode; })
							.ToArray();

				if (matches.Length > 0)
				{
					VirtualOpCode v = matches[0];
					Console.WriteLine("--> Not yet devirtualizable (contains unknown virtual instruction)");
					Console.WriteLine("-----> Virtual OpCode = {0} @ [{1}] (0x{2:X8})",
						reader.LastVirtualOpCode, reader.CurrentInstructionOffset, reader.CurrentVirtualOffset);
					Console.WriteLine("-----> Delegate method: {0} (MDToken = 0x{1:X8})",
						v.DelegateMethod.FullName, v.DelegateMethod.MDToken.Raw);
				}
				else
				{
					Console.WriteLine("--> Not yet devirtualizable (contains unexpected virtual instruction @ [{0}] (0x{1:X8}))",
						reader.CurrentInstructionOffset, reader.CurrentVirtualOffset);
				}
			}
			else
				Console.WriteLine("--> Not yet devirtualizable (threw exception)");
		}

		/// <summary>
		/// Print out information about a devirtualization attempt.
		/// </summary>
		/// <param name="options">MonoOptions set from passed command-line arguments</param>
		/// <param name="module">EazModule</param>
		/// <param name="attempt">Data about the devirtualization attempt</param>
		static void PrintAttempt(MonoOptions options, EazModule module,
			DevirtualizeAttempt attempt)
		{
			var reader = attempt.Reader;
			var method = attempt.Method;
			var stub = attempt.VirtualizedMethod;
			var body = attempt.MethodBody;

			IList<Local> locals = attempt.Successful ?
				body.Variables : reader.Locals;
			IList<ExceptionHandler> handlers = attempt.Successful ?
				body.ExceptionHandlers : reader.ExceptionHandlers;
			IList<Instruction> instructions = attempt.Successful ?
				body.Instructions : reader.Instructions;

			// Message prefix
			String prefix;
			switch(options.Action)
			{
				case ProgramAction.Devirtualize:
					prefix = "Devirtualized";
					break;
				case ProgramAction.Methods:
				default:
					prefix = "Found";
					break;
			}

			Console.WriteLine("{0} {1} (MDToken = 0x{2:X8})", prefix, method.FullName, method.MDToken.Raw);

			if (options.Action == ProgramAction.Methods || options.Verbose)
			{
				Console.WriteLine("--> Position string: {0}", stub.PositionString);
				Console.WriteLine("--> Position: {0} (0x{0:X8})", stub.Position);
				Console.WriteLine("--> Resource: {0}", stub.ResourceStringId);
				Console.WriteLine("--> Crypto key: {0}", stub.ResourceCryptoKey);
				Console.WriteLine("--> Actual method size: {0} (0x{0:X8})", reader.CodeSize);

				if (options.Action == ProgramAction.Methods)
					PrintAttemptSuccess(options, module, attempt);
			}

			if (options.Action == ProgramAction.Methods || options.Verbose)
			{
				Console.WriteLine();

				// Print locals
				if (locals.Count > 0)
				{
					Int32 index = 0;
					Console.WriteLine("Locals:");
					Console.WriteLine("-------");
					foreach (var local in locals)
						Console.WriteLine("local[{0}]: {1}", index++, local.Type.FullName);
					Console.WriteLine();
				}

				// Print exception handlers
				if (handlers.Count > 0)
				{
					Int32 index = 0;
					Console.WriteLine("Exception Handlers:");
					Console.WriteLine("-------------------");
					foreach (var handler in handlers)
					{
						if (handler.CatchType != null)
							Console.WriteLine("handler[{0}]: HandlerType = {1}, CatchType = {2}",
								index++, handler.HandlerType, handler.CatchType);
						else
							Console.WriteLine("handler[{0}]: HandlerType = {1}",
								index++, handler.HandlerType);
						Console.WriteLine("--> Try:     [{0}, {1}]", handler.TryStart, handler.TryEnd);
						Console.WriteLine("--> Handler: [{0}, {1}]", handler.HandlerStart, handler.HandlerEnd);
						Console.WriteLine("--> Filter:  {0}", handler.FilterStart);
					}
					Console.WriteLine();
				}

				// Print instructions
				if (instructions != null && instructions.Count > 0)
				{
					Console.WriteLine("Instructions:");
					Console.WriteLine("-------------");
					foreach (var instr in instructions)
						Console.WriteLine(instr);
					Console.WriteLine();
				}

				// Print out exception, if any
				if (!attempt.Successful && !attempt.WasInstructionUnknown)
				{
					Console.Write(attempt.Exception);
					Console.WriteLine();
					Console.WriteLine();
				}
			}

			if (!(options.Action == ProgramAction.Devirtualize && !options.Verbose))
				Console.WriteLine();
		}

		/// <summary>
		/// Perform "devirtualize" verb.
		/// </summary>
		/// <param name="options">Options</param>
		static void DoDevirtualize(MonoOptions options)
		{
			ILogger logger = GetLogger(options);

			EazModule module;
			if (!TryLoadModule(options.AssemblyPath, logger, out module))
				return;

			// Setup devirtualize options
			var opts = DevirtualizeOptions.Nothing;
			if (options.InjectAttributes)
				opts |= DevirtualizeOptions.InjectAttributes;

			Devirtualizer devirtualizer = new Devirtualizer(module, opts, options.MethodFixers, logger);

			var results = devirtualizer.Devirtualize((attempt) => {
				if (attempt.Successful)
					PrintAttempt(options, module, attempt);
			});

			if (results.Empty)
			{
				Console.WriteLine("No virtualized methods found");
				return;
			}
			else if (!options.Verbose)
				Console.WriteLine();

			Console.WriteLine("Devirtualized {0}/{1} methods",
				results.DevirtualizedCount, results.MethodCount);

			// Only save if at least one method devirtualized
			if (results.DevirtualizedCount > 0)
			{
				String outputPath = options.OutputPath ?? GetDevirtualizedModulePath(options.AssemblyPath);
				Console.WriteLine("Saving {0}", outputPath);
				module.Write(outputPath, options.NoThrow);
			}
		}

		static String GetDevirtualizedModulePath(String origPath)
		{
			String ext = Path.GetExtension(origPath);
			String noExt = Path.GetFileNameWithoutExtension(origPath);
			return String.Format("{0}-devirtualized{1}",
				Path.Combine(Path.GetDirectoryName(origPath), noExt), ext);
		}
	}
}



================================================
File: src/eazdevirt/Program.Generate.cs
================================================
ï»¿using System;
using System.Linq;
using eazdevirt.Generator;

namespace eazdevirt
{
	public partial class Program
	{
		/// <summary>
		/// Perform "generate" verb.
		/// </summary>
		/// <param name="options">Options</param>
		static void DoGenerate(MonoOptions options)
		{
			var generator = new VirtualizableAssemblyGenerator();

			String instructionSet = "all";
			if (options.InstructionSet != null && options.InstructionSet.Length > 0)
				instructionSet = options.InstructionSet.ToLower();

			String[] sets;
			if (instructionSet.Contains(','))
				sets = instructionSet.Split(',');
			else sets = new String[] { instructionSet };

			Boolean all = sets.Contains("all");
			if (sets.Contains("calli") || all)
				generator.AddCalliMethod();
			if (sets.Contains("conv") || all)
				generator.AddConvMethod();
			if (sets.Contains("ind") || all)
				generator.AddIndMethod();
			if (sets.Contains("static-field") || all)
				generator.AddStaticFieldMethod();

			if (!generator.HasMethod)
			{
				Console.WriteLine("Unknown set(s): {0}", instructionSet);
				return;
			}

			var assembly = generator.Generate();

			String filepath = options.OutputPath;
			if (filepath == null)
				filepath = "eazdevirt-test.exe";

			Console.WriteLine("Saving test assembly {0}", filepath);

			assembly.Write(filepath);
		}
	}
}



================================================
File: src/eazdevirt/Program.GetKey.cs
================================================
ï»¿using System;

namespace eazdevirt
{
	public partial class Program
	{
		/// <summary>
		/// Perform "get-key" verb.
		/// </summary>
		/// <param name="options">Options</param>
		static void DoGetKey(MonoOptions options)
		{
			EazModule module;
			if (!TryLoadModule(options.AssemblyPath, out module))
				return;

			MethodStub method = module.FindFirstVirtualizedMethod();
			Console.WriteLine("Key: {0}", method.ResourceCryptoKey);
		}
	}
}



================================================
File: src/eazdevirt/Program.Instructions.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;

namespace eazdevirt
{
	public partial class Program
	{
		/// <summary>
		/// Perform "instructions" verb.
		/// </summary>
		/// <param name="options">Options</param>
		static void DoInstructions(MonoOptions options)
		{
			EazModule module;
			if (!TryLoadModule(options.AssemblyPath, out module))
				return;

			MethodStub method = module.FindFirstVirtualizedMethod();
			if (method == null)
			{
				Console.WriteLine("No methods in assembly seem to be virtualized");
				return;
			}

			// The virtual-call-method should belong to the main virtualization type
			TypeDef virtualizationType = method.VirtualCallMethod.DeclaringType;
			var vInstructions = module.VirtualInstructions;

			if (vInstructions.Count > 0)
			{
				// Get # of identified instructions
				Int32 identified = 0;
				foreach (var v in vInstructions)
					if (v.IsIdentified) identified++;

				// Get % of identified instructions as a string
				String percentIdentified;
				if (identified == 0)
					percentIdentified = "0%";
				else if (identified == vInstructions.Count)
					percentIdentified = "100%";
				else
					percentIdentified = Math.Floor(
						(((double)identified) / ((double)vInstructions.Count)) * 100d
					) + "%";

				Console.WriteLine("Virtual instruction types found: {0}", vInstructions.Count);
				Console.WriteLine("{0}/{1} instruction types identified ({2})",
					identified, vInstructions.Count, percentIdentified);

				if (!options.Verbose)
					Console.WriteLine();

				// If only showing identified instructions, remove all non-identified and sort by name
				if (options.OnlyIdentified)
				{
					vInstructions = new List<VirtualOpCode>(vInstructions
						.Where((instruction) => { return instruction.IsIdentified; })
						.OrderBy((instruction) => { return instruction.Name; }));
				}

				// If only showing instructions with specific virtual operand types, filter
				if (options.OperandTypeWhitelist != Int32.MinValue)
				{
					vInstructions = new List<VirtualOpCode>(vInstructions
						.Where((instruction) =>
						{
							return options.OperandTypeWhitelist == instruction.VirtualOperandType;
						}));
				}

				foreach (var v in vInstructions)
				{
					if (!options.Verbose) // Simple output
					{
						if (v.IsIdentified)
							Console.WriteLine("Instruction: {0}, Method: {1}", v.Name, v.DelegateMethod.FullName);
						else
							Console.WriteLine("Instruction: Unknown, Method: {0}", v.DelegateMethod.FullName);
					}
					else // Not-Simple output?
					{
						Console.WriteLine();

						if (v.IsIdentified)
							Console.WriteLine("Instruction: {0}", v.Name);
						else
							Console.WriteLine("Instruction: Unknown");

						if (v.IsIdentified || !options.OnlyIdentified)
						{
							if (v.HasVirtualCode)
							{
								Console.WriteLine("--> Virtual OpCode:  {0} ({0:X8})", v.VirtualCode);
								Console.WriteLine("--> Operand type:    {0}", v.VirtualOperandType);
							}

							{
								Console.WriteLine("--> Delegate method: {0}", v.DelegateMethod.FullName);
							}
						}
					}
				}

				// Print operand information
				if (options.Operands)
				{
					var operandTypeDict = new Dictionary<Int32, Int32>();
					foreach (var vInstr in vInstructions)
					{
						var type = vInstr.VirtualOperandType;
						if (operandTypeDict.ContainsKey(type))
							operandTypeDict[type] = (operandTypeDict[type] + 1);
						else operandTypeDict.Add(type, 1);
					}

					Console.WriteLine();
					Console.WriteLine("Virtual operand type counts:");
					foreach (var kvp in operandTypeDict)
						Console.WriteLine("  Operand {0}: {1} occurrence(s)", kvp.Key, kvp.Value);
				}
			}
			else Console.WriteLine("No virtual instructions found?");
		}
	}
}



================================================
File: src/eazdevirt/Program.Methods.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace eazdevirt
{
	public partial class Program
	{
		/// <summary>
		/// Perform "methods" verb.
		/// </summary>
		/// <param name="options">Options</param>
		static void DoMethods(MonoOptions options)
		{
			ILogger logger = GetLogger(options);

			EazModule module;
			if (!TryLoadModule(options.AssemblyPath, logger, out module))
				return;

			Devirtualizer devirtualizer = new Devirtualizer(module, options.MethodFixers, logger);

			var results = devirtualizer.Devirtualize((attempt) => {
				PrintAttempt(options, module, attempt);
			});

			if (results.Empty)
			{
				Console.WriteLine("No virtualized methods found");
				return;
			}

			Console.WriteLine("{0}/{1} method stubs devirtualizable",
				results.DevirtualizedCount, results.MethodCount);
		}
	}
}



================================================
File: src/eazdevirt/Program.Position.cs
================================================
ï»¿using System;

namespace eazdevirt
{
	public partial class Program
	{
		/// <summary>
		/// Perform "position" verb.
		/// </summary>
		/// <param name="options">Options</param>
		static void DoPosition(MonoOptions options)
		{
			Int64 position = 0;

			if (options.AssemblyPath != null)
			{
				EazModule module;
				if (!TryLoadModule(options.AssemblyPath, out module))
					return;

				IPositionTranslator translator = module.PositionTranslator;

				MethodStub method = module.FindFirstVirtualizedMethod();
				if (method != null)
				{
					try
					{
						position = translator.ToPosition(options.PositionString, method.ResourceCryptoKey);
					}
					catch (FormatException e)
					{
						Console.WriteLine(e.Message);
						return;
					}
				}
				else
				{
					Console.WriteLine("No virtualized methods found in specified assembly");
					return;
				}
			}
			else
			{
				Console.WriteLine("Provide either the crypto key or assembly from which to extract the crypto key");
				return;
			}

			Console.WriteLine("{0} => {1:X8}", options.PositionString, position);
		}
	}
}



================================================
File: src/eazdevirt/Program.Resource.cs
================================================
ï»¿using System;
using System.IO;

namespace eazdevirt
{
	public partial class Program
	{
		/// <summary>
		/// Perform "resource" verb.
		/// </summary>
		/// <param name="options">Options</param>
		static void DoResource(MonoOptions options)
		{
			EazModule module;
			if (!TryLoadModule(options.AssemblyPath, out module))
				return;

			// If no action set, set the default action (extract)
			//if (!options.Extract)
			//	options.Extract = true;

			MethodStub method = module.FindFirstVirtualizedMethod();
			if (method != null)
			{
				if (true /* options.Extract */)
				{
					String outputPath = options.OutputPath;
					if (outputPath == null || outputPath.Equals(""))
						outputPath = method.ResourceStringId;

					FileMode fileMode = FileMode.CreateNew;
					if (options.OverwriteExisting)
						fileMode = FileMode.Create;

					using (Stream resourceStream = module.GetResourceStream(options.KeepEncrypted))
					{
						try
						{
							using (FileStream fileStream = new FileStream(outputPath, fileMode, FileAccess.Write))
							{
								resourceStream.CopyTo(fileStream);
							}
						}
						catch (IOException e)
						{
							Console.Write(e);
						}
					}

					Console.WriteLine("Extracted {0} resource to {1}",
						options.KeepEncrypted ? "encrypted" : "decrypted", outputPath);
				}
			}
		}
	}
}



================================================
File: src/eazdevirt/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using dnlib.DotNet;
using Mono.Options;
using eazdevirt.IO;
using eazdevirt.Logging;

namespace eazdevirt
{
	public partial class Program
	{
		static void PrintHelp(MonoOptions parsed)
		{
			Console.WriteLine(GetDescriptorString());
			Console.WriteLine();

			Console.WriteLine("usage: eazdevirt [-dgikmpr] [options] <assembly>");
			Console.WriteLine();

			String generatedHelp = parsed.OptionDescriptors;
			Console.Write(generatedHelp);
			Console.WriteLine();

			Console.WriteLine("examples:");
			Console.WriteLine("  eazdevirt -d MyAssembly.exe");
			Console.WriteLine("  eazdevirt -r --keep-encrypted MyAssembly.exe");
		}

		static String GetDescriptorString()
		{
			// Get description + version from assembly attribute
			Assembly assembly = Assembly.GetEntryAssembly() ?? Assembly.GetExecutingAssembly();

			// Get description
			var descAttr = (AssemblyDescriptionAttribute)assembly.GetCustomAttribute(typeof(AssemblyDescriptionAttribute));
			String description = descAttr.Description;

			// Get version
			Version version = Assembly.GetExecutingAssembly().GetName().Version;

			return String.Format("eazdevirt {0} - {1}", version.ToString(), description);
		}

		/// <summary>
		/// Parse a MonoOptions from passed arguments.
		/// </summary>
		/// <param name="args">Arguments passed to program</param>
		/// <returns>MonoOptions</returns>
		static MonoOptions Parse(String[] args)
		{
			MonoOptions options = new MonoOptions();
			OptionSet optionSet = new OptionSet()
			{
				// Program action options
				{ "d|devirtualize", "attempt to devirtualize methods in a protected assembly",
					v => options.Action = ProgramAction.Devirtualize },
				{ "g|generate", "generate a test executable to be protected and analysed",
					v => options.Action = ProgramAction.Generate },
				{ "i|instructions", "print virtual opcode information extracted from a protected assembly",
					v => options.Action = ProgramAction.Instructions },
				{ "k|get-key", "extract the integer crypto key from a protected assembly",
					v => options.Action = ProgramAction.GetKey },
				{ "m|methods", "print virtualized method + method stub information extracted from a protected assembly",
					v => options.Action = ProgramAction.Methods },
				{ "p|position", "translate a position string into its Int64 representation given either an integer "
				              + "crypto key or a protected assembly",
					v => options.Action = ProgramAction.Position },
				{ "r|resource", "extract the embedded resource from a protected assembly",
					v => options.Action = ProgramAction.Resource },

				{ "N|no-throw", "don't throw when writing a module", v => options.NoThrow = true },

				// `devirtualize` options
				{ "j|inject", "inject attributes", v => options.InjectAttributes = true },
				{ "F=|fixers=", "fixers to use", v => options.FixersString = v },

				// `generate` options
				{ "I=|instruction-set=", "name of \"instruction sets\" to generate",
					v => options.InstructionSet = v },

				// `instructions` options
				{ "only-identified", "only show identified opcodes",
					v => options.OnlyIdentified = true },
				{ "operands", "print info about operand types",
					v => options.Operands = true },
				{ "operand-type=", "operand type whitelist",
					(Int32 v) => options.OperandTypeWhitelist = v },

				// `position` options
				{ "K=|key=", "integer crypto key used to translate a position string",
					(Int32 v) => options.Key = v },
				{ "P=|position-string=", "position string to translate",
					v => options.PositionString = v },

				// `resource` options
				{ "o=|destination=", "destination file (type of file depends on program action)",
					v => options.OutputPath = v },
				{ "f|force", "overwrite destination file if it exists",
					v => options.OverwriteExisting = true },
				{ "x|extract", v => options.ExtractResource = true },
				{ "D|keep-encrypted", "don't decrypt the resource file when extracting",
					v => options.KeepEncrypted = true },

				// Other options
				{ "L|no-logo", "don't show the ascii logo", v => options.NoLogo = true },
				{ "h|?|help", "show help/usage info and exit", v => options.Help = true },
				{ "v|verbose", "more output", v => options.VerboseLevel++ }
			};

			options.Extra = optionSet.Parse(args);
			options.OptionSet = optionSet;

			if (options.Extra.Count > 0)
				options.AssemblyPath = options.Extra[0];

			return options;
		}

		static Int32 Main(String[] args)
		{
			var options = Parse(args);

			if (!options.NoLogo)
				WriteAsciiLogo();

			if (options.Help || options.Action == ProgramAction.None)
			{
				PrintHelp(options);
				return 0;
			}

			switch (options.Action)
			{
				case ProgramAction.Devirtualize:
					DoDevirtualize(options);
					break;
				case ProgramAction.Generate:
					DoGenerate(options);
					break;
				case ProgramAction.GetKey:
					DoGetKey(options);
					break;
				case ProgramAction.Instructions:
					DoInstructions(options);
					break;
				case ProgramAction.Methods:
					DoMethods(options);
					break;
				case ProgramAction.Position:
					DoPosition(options);
					break;
				case ProgramAction.Resource:
					DoResource(options);
					break;
			}

			return 0;
		}

		static ILogger GetLogger(MonoOptions options)
		{
			LoggerEvent e = LoggerEvent.Info;

			if (options.VerboseLevel == 1)
				e = LoggerEvent.Verbose;
			else if (options.VerboseLevel > 1)
				e = LoggerEvent.VeryVerbose;

			return new ConsoleLogger(e);
		}

		static Boolean TryLoadModule(String path, out EazModule module)
		{
			return TryLoadModule(path, null, out module);
		}

		static Boolean TryLoadModule(String path, ILogger logger, out EazModule module)
		{
			try
			{
				ModuleDefMD moduleDef = ModuleDefMD.Load(path);
				AssemblyResolver asmResolver = new AssemblyResolver();
				ModuleContext modCtx = new ModuleContext(asmResolver);
				// All resolved assemblies will also get this same modCtx
				asmResolver.DefaultModuleContext = modCtx;
				moduleDef.Context = modCtx;

				module = new EazModule(moduleDef, logger);
			}
			catch (IOException e)
			{
				// Console.WriteLine(e.Message);
				Console.Write(e);
				module = null;
				return false;
			}

			return true;
		}

		static void WritePartiallyDevirtualizedMethod(VirtualizedMethodBodyReader reader)
		{
			if (!reader.HasInstructions)
				return;

			Console.WriteLine();
			foreach(var instruction in reader.Instructions)
				Console.WriteLine("{0}", instruction.ToString());
			Console.WriteLine();
		}

		/// <summary>
		/// ASCII logo.
		/// </summary>
		static String Logo
		{
			get
			{
				return
@"
                         .___          .__         __   
  ____ _____  ________ __| _/_______  _|__|_______/  |_ 
_/ __ \\__  \ \___   // __ |/ __ \  \/ /  \_  __ \   __\
\  ___/ / __ \_/    // /_/ \  ___/\   /|  ||  | \/|  |  
 \___  >____  /_____ \____ |\___  >\_/ |__||__|   |__|  
     \/     \/      \/    \/    \/                      
";
			}
		}

		static void WriteAsciiLogo()
		{
			Console.WriteLine(Logo);
			Console.WriteLine();
		}
	}
}



================================================
File: src/eazdevirt/app.config
================================================
<?xml version="1.0" encoding="utf-8"?>
<configuration>
<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5"/></startup></configuration>



================================================
File: src/eazdevirt/eazdevirt.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{6E44FD35-6D3C-46DD-9B3A-2203317E7FEF}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>eazdevirt</RootNamespace>
    <AssemblyName>eazdevirt</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\..\bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\..\bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Core\AttributeInjector.cs" />
    <Compile Include="Core\CryptoStreamBase.cs" />
    <Compile Include="Core\SerializationVersion.cs" />
    <Compile Include="Core\SpecialCode.cs" />
    <Compile Include="Core\IPositionTranslator.cs" />
    <Compile Include="Core\PositionTranslator.cs" />
    <Compile Include="Core\StackTypeHelper.cs" />
    <Compile Include="Core\Types\BaseTypeDefProvider.cs" />
    <Compile Include="Core\Types\CryptoStreamDef.cs" />
    <Compile Include="Core\Types\ITypeDefProvider.cs" />
    <Compile Include="Core\V2\CryptoStreamV2.cs" />
    <Compile Include="Detection\InstructionDetectorBase.cs" />
    <Compile Include="Detection\IInstructionDetector.cs" />
    <Compile Include="Detection\V1\Detection.Arg.cs" />
    <Compile Include="Detection\V1\Detection.Bitwise.cs" />
    <Compile Include="Detection\V1\Detection.Br.cs" />
    <Compile Include="Detection\V1\Detection.Conv.cs" />
    <Compile Include="Detection\V1\Detection.Elem.cs" />
    <Compile Include="Detection\V1\Detection.Ind.cs" />
    <Compile Include="Detection\V1\Detection.Ldc.cs" />
    <Compile Include="Detection\V1\Detection.Math.cs" />
    <Compile Include="Detection\V1\Detection.Misc.cs" />
    <Compile Include="Detection\V1\Detection.Prefix.cs" />
    <Compile Include="Detection\V1\Detection.Special.cs" />
    <Compile Include="Detection\V1\Detection.Unsupported.cs" />
    <Compile Include="Detection\V1\InstructionDetectorV1.cs" />
    <Compile Include="Detection\V1\Detection.cs" />
    <Compile Include="Detection\V1\Detection.Loc.cs" />
    <Compile Include="Core\Devirtualizer.cs" />
    <Compile Include="Core\VirtualOpCode.Helpers.cs" />
    <Compile Include="Core\VirtualMachineType.cs" />
    <Compile Include="Fixers\FixerAttribute.cs" />
    <Compile Include="Fixers\MethodFixer.cs" />
    <Compile Include="Fixers\IMethodFixer.cs" />
    <Compile Include="Fixers\StindFixer.cs" />
    <Compile Include="Generator\IAssemblyGenerator.cs" />
    <Compile Include="Generator\VirtualizableAssemblyGenerator.cs" />
    <Compile Include="IO\Resolver.Serialized.cs" />
    <Compile Include="IO\ResourceReader.cs" />
    <Compile Include="IO\VirtualizedMethodBodyReader.cs" />
    <Compile Include="IO\Resolver.cs" />
    <Compile Include="Logging\ConsoleLogger.cs" />
    <Compile Include="Core\MethodStubNotFoundException.cs" />
    <Compile Include="Core\OriginalOpcodeUnknownException.cs" />
    <Compile Include="MonoOptions.cs" />
    <Compile Include="Mono\Mono.Options.cs" />
    <Compile Include="Program.Devirtualize.cs" />
    <Compile Include="Program.Generate.cs" />
    <Compile Include="Program.GetKey.cs" />
    <Compile Include="Program.Instructions.cs" />
    <Compile Include="Program.Methods.cs" />
    <Compile Include="Program.Position.cs" />
    <Compile Include="Program.Resource.cs" />
    <Compile Include="Reflection\DetectAttribute.cs" />
    <Compile Include="Util\DotNetUtils.cs" />
    <Compile Include="Core\V1\CryptoStreamV1.cs" />
    <Compile Include="Core\EazModule.cs" />
    <Compile Include="Core\VirtualOpCode.cs" />
    <Compile Include="Core\MethodStub.cs" />
    <Compile Include="Core\Helpers.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Util\Extensions.cs" />
    <Compile Include="Util\GenericUtils.cs" />
    <Compile Include="Util\NameResolver.cs" />
    <Compile Include="Util\SigUtil.cs" />
    <Compile Include="Util\StackTypesCalculator.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="app.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\dnlib\src\dnlib.csproj">
      <Project>{fdfc1237-143f-4919-8318-4926901f4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: src/eazdevirt/Core/AttributeInjector.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.IO;
using eazdevirt.Util;

namespace eazdevirt
{
	public class AttributeInjector
	{
		/// <summary>
		/// EazModule.
		/// </summary>
		public EazModule EazModule { get; private set; }

		/// <summary>
		/// Module.
		/// </summary>
		public ModuleDefMD Module
		{
			get { return this.EazModule != null ? this.EazModule.Module : null; }
		}

		private Boolean _initialized = false;
		private TypeDef _devirtualizedAttribute = null;

		/// <summary>
		/// Construct an AttributeInjector for a specific module.
		/// </summary>
		/// <param name="module">Target module</param>
		public AttributeInjector(EazModule module)
		{
			this.EazModule = module;
		}

		void Initialize()
		{
			_devirtualizedAttribute = this.CreateDevirtualizedAttribute();
			this.Module.Types.Add(_devirtualizedAttribute);
			_initialized = true;
		}

		/// <summary>
		/// Create the DevirtualizedAttribute TypeDef, with a "default .ctor" that
		/// calls the base type's .ctor (System.Attribute).
		/// </summary>
		/// <returns>TypeDef</returns>
		TypeDef CreateDevirtualizedAttribute()
		{
			var importer = new Importer(this.Module);
			var attributeRef = this.Module.CorLibTypes.GetTypeRef("System", "Attribute");
			var attributeCtorRef = importer.Import(attributeRef.ResolveTypeDefThrow().FindMethod(".ctor"));

			var devirtualizedAttr = new TypeDefUser(
				"eazdevirt.Injected", "DevirtualizedAttribute", attributeRef);
			//devirtualizedAttr.Attributes = TypeAttributes.Public | TypeAttributes.AutoLayout
			//	| TypeAttributes.Class | TypeAttributes.AnsiClass;

			var emptyCtor = new MethodDefUser(".ctor", MethodSig.CreateInstance(this.Module.CorLibTypes.Void),
				MethodImplAttributes.IL | MethodImplAttributes.Managed,
				MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName |
				MethodAttributes.ReuseSlot | MethodAttributes.HideBySig);

			var instructions = new List<Instruction>();
			instructions.Add(OpCodes.Ldarg_0.ToInstruction());
			instructions.Add(OpCodes.Call.ToInstruction(attributeCtorRef)); // Call the constructor .ctor
			instructions.Add(OpCodes.Ret.ToInstruction());
			emptyCtor.Body = new CilBody(false, instructions, new List<ExceptionHandler>(), new List<Local>());

			devirtualizedAttr.Methods.Add(emptyCtor);

			return devirtualizedAttr;
		}

		/// <summary>
		/// Inject the DevirtualizedAttribute into a method.
		/// </summary>
		/// <param name="method">Method to inject</param>
		public void InjectDevirtualized(MethodDef method)
		{
			if (!_initialized)
				this.Initialize();

			var customAttr = new CustomAttribute(_devirtualizedAttribute.FindMethod(".ctor"));
			method.CustomAttributes.Add(customAttr);
		}
	}
}



================================================
File: src/eazdevirt/Core/CryptoStreamBase.cs
================================================
ï»¿using System;
using System.IO;

namespace eazdevirt
{
	public abstract class CryptoStreamBase : Stream
	{
		/// <summary>
		/// Key used for crypto.
		/// </summary>
		public Int32 Key { get; private set; }

		/// <summary>
		/// Underlying stream.
		/// </summary>
		private Stream _stream;

		public override Boolean CanRead
		{
			get { return _stream.CanRead; }
		}

		public override Boolean CanSeek
		{
			get { return _stream.CanSeek; }
		}

		public override Boolean CanWrite
		{
			get { return _stream.CanWrite; }
		}

		public override Int64 Length
		{
			get { return _stream.Length; }
		}

		public override Int64 Position
		{
			get { return _stream.Position; }
			set { _stream.Position = value; }
		}

		public CryptoStreamBase(Stream baseStream, Int32 key)
		{
			_stream = baseStream;
			this.Key = key;
		}

		public override void Flush()
		{
			_stream.Flush();
		}

		public override void Write(Byte[] buffer, Int32 offset, Int32 count)
		{
			Byte[] array = new Byte[count];
			Buffer.BlockCopy(buffer, offset, array, 0, count);
			Int64 position = this.Position;
			for (Int32 i = 0; i < count; i++)
				array[i] = this.Crypt(array[i], position + (Int64)i);
			_stream.Write(array, offset, count);
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			Int64 position = this.Position;
			Byte[] array = new Byte[count];
			Int32 num = _stream.Read(array, 0, count);
			for (Int32 i = 0; i < num; i++)
				buffer[i + offset] = this.Crypt(array[i], position + (Int64)i);
			return num;
		}

		public override Int64 Seek(Int64 offset, SeekOrigin origin)
		{
			return _stream.Seek(offset, origin);
		}

		public override void SetLength(Int64 value)
		{
			_stream.SetLength(value);
		}

		protected abstract Byte Crypt(Byte b, Int64 position);
	}
}



================================================
File: src/eazdevirt/Core/Devirtualizer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Fixers;
using eazdevirt.IO;

namespace eazdevirt
{
	public class Devirtualizer
	{
		/// <summary>
		/// EazModule.
		/// </summary>
		public EazModule Parent { get; private set; }

		/// <summary>
		/// Module.
		/// </summary>
		public ModuleDefMD Module { get { return this.Parent.Module; } }

		/// <summary>
		/// Logger.
		/// </summary>
		public ILogger Logger { get; private set; }

		/// <summary>
		/// Attribute injector.
		/// </summary>
		public AttributeInjector Injector { get; private set; }

		/// <summary>
		/// Devirtualize options flag.
		/// </summary>
		public DevirtualizeOptions Options { get; set; }

		/// <summary>
		/// Fixers by type.
		/// </summary>
		public IList<Type> Fixers { get; private set; }

		public Devirtualizer(EazModule module)
			: this(module, DevirtualizeOptions.Nothing)
		{
		}

		public Devirtualizer(EazModule module, DevirtualizeOptions options)
			: this(module, options, null)
		{
		}

		public Devirtualizer(EazModule module, ILogger logger)
			: this(module, DevirtualizeOptions.Nothing, logger)
		{
		}

		public Devirtualizer(EazModule module, DevirtualizeOptions options, ILogger logger)
			: this(module, options, null, logger)
		{
		}

		public Devirtualizer(EazModule module, IList<Type> fixers, ILogger logger)
			: this(module, DevirtualizeOptions.Nothing, fixers, logger)
		{
		}

		public Devirtualizer(EazModule module, DevirtualizeOptions options, IList<Type> fixers, ILogger logger)
		{
			this.Parent = module;
			this.Options = options;
			this.Injector = new AttributeInjector(module);
			this.Fixers = (fixers != null ? fixers : new List<Type>());
			this.Logger = (logger != null ? logger : DummyLogger.NoThrowInstance);
		}

		public DevirtualizeResults Devirtualize()
		{
			return this.Devirtualize(this.Options, null);
		}

		public DevirtualizeResults Devirtualize(DevirtualizeOptions options)
		{
			return this.Devirtualize(options, null);
		}

		public DevirtualizeResults Devirtualize(Action<DevirtualizeAttempt> attemptCallback)
		{
			return this.Devirtualize(this.Options, attemptCallback);
		}

		public DevirtualizeResults Devirtualize(DevirtualizeOptions options, Action<DevirtualizeAttempt> attemptCallback)
		{
			var methods = this.Parent.FindMethodStubs();

			if (methods.Length == 0)
				return new DevirtualizeResults();

			var attempts = new List<DevirtualizeAttempt>();

			foreach (var method in methods)
			{
				var reader = new VirtualizedMethodBodyReader(method, this.Logger, this.Parent.Version);
				Exception exception = null, fixerException = null;

				try
				{
					reader.Read(); // Read method
				}
				catch (Exception e)
				{
					exception = e;
				}

				DevirtualizeAttempt attempt;

				if (exception == null)
				{
					var body = new CilBody(
						true,
						reader.Instructions,
						reader.ExceptionHandlers,
						reader.Locals
					);

					method.Method.FreeMethodBody();
					method.Method.Body = body;

					// Perform fixes
					try
					{
						PerformFixes(method.Method);
					}
					catch (Exception e)
					{
						fixerException = e;
					}

					if (fixerException == null)
					{
						// Inject DevirtualizedAttribute if specified
						if (options.HasFlag(DevirtualizeOptions.InjectAttributes))
							this.Injector.InjectDevirtualized(method.Method);

						attempt = new DevirtualizeAttempt(method, reader, body);
					}
					else
						attempt = new DevirtualizeAttempt(method, reader, fixerException);
				}
				else
					attempt = new DevirtualizeAttempt(method, reader, exception);

				// Add attempt to list and fire callback
				attempts.Add(attempt);
				if (attemptCallback != null)
					attemptCallback(attempt);
			}

			return new DevirtualizeResults(attempts);
		}

		void PerformFixes(MethodDef method)
		{
			var fixers = GetFixers(method);
			foreach (var fixer in fixers)
				fixer.Fix();
		}

		IList<IMethodFixer> GetFixers(MethodDef method)
		{
			return this.Fixers.Where(t => t.IsSubclassOf(typeof(MethodFixer)))
				.Select(t => (IMethodFixer)Activator.CreateInstance(t, method))
				.ToList();
		}
	}

	/// <summary>
	/// Describes a devirtualization attempt on a single virtualized method.
	/// </summary>
	public class DevirtualizeAttempt
	{
		/// <summary>
		/// The virtualized method associated with this attempt.
		/// </summary>
		public MethodStub VirtualizedMethod { get; private set; }

		public MethodDef Method { get { return this.VirtualizedMethod.Method; } }

		public Exception Exception { get; private set; }

		public Boolean Successful { get { return this.Exception == null; } }

		public CilBody MethodBody { get; private set; }

		public VirtualizedMethodBodyReader Reader { get; private set; }

		/// <summary>
		/// Whether or not the exception (if any) was due to an unknown instruction type.
		/// </summary>
		public Boolean WasInstructionUnknown
		{
			get
			{
				return this.Exception != null
					&& this.Exception is OriginalOpcodeUnknownException;
			}
		}

		/// <summary>
		/// Constructs a failed devirtualize attempt.
		/// </summary>
		/// <param name="vmethod">Virtualized method</param>
		/// <param name="reader">Method body reader</param>
		/// <param name="exception">Exception that occurred while devirtualizing</param>
		public DevirtualizeAttempt(MethodStub vmethod, VirtualizedMethodBodyReader reader, Exception exception)
		{
			this.VirtualizedMethod = vmethod;
			this.Reader = reader;
			this.Exception = exception;
		}

		/// <summary>
		/// Constructs a successful devirtualize attempt.
		/// </summary>
		/// <param name="vmethod">Virtualized method</param>
		/// <param name="reader">Method body reader</param>
		/// <param name="body">Devirtualized method body</param>
		public DevirtualizeAttempt(MethodStub vmethod, VirtualizedMethodBodyReader reader, CilBody body)
		{
			this.VirtualizedMethod = vmethod;
			this.Reader = reader;
			this.MethodBody = body;
		}
	}

	/// <summary>
	/// Describes the results of a devirtualization attempt.
	/// </summary>
	public class DevirtualizeResults
	{
		/// <summary>
		/// All attempts.
		/// </summary>
		public IList<DevirtualizeAttempt> Attempts { get; private set; }

		/// <summary>
		/// All virtualized methods.
		/// </summary>
		public IList<MethodStub> AllMethods { get; private set; }

		/// <summary>
		/// All virtualized methods which were successfully devirtualized.
		/// </summary>
		public IList<MethodStub> DevirtualizedMethods { get; private set; }

		/// <summary>
		/// Count of all methods.
		/// </summary>
		public Int32 MethodCount { get { return this.AllMethods.Count; } }

		/// <summary>
		/// Count of all successfully devirtualized methods.
		/// </summary>
		public Int32 DevirtualizedCount { get { return this.DevirtualizedMethods.Count; } }

		/// <summary>
		/// Whether or not the results are empty (no methods).
		/// </summary>
		public Boolean Empty { get { return this.MethodCount == 0; } }

		/// <summary>
		/// Construct empty results.
		/// </summary>
		public DevirtualizeResults()
			: this (new List<DevirtualizeAttempt>())
		{
		}

		public DevirtualizeResults(IList<DevirtualizeAttempt> attempts)
		{
			this.Attempts = attempts;
			this.Initialize();
		}

		private void Initialize()
		{
			this.AllMethods = new List<MethodStub>();
			this.DevirtualizedMethods = new List<MethodStub>();

			foreach (var attempt in this.Attempts)
			{
				this.AllMethods.Add(attempt.VirtualizedMethod);

				if (attempt.Successful)
				{
					this.DevirtualizedMethods.Add(attempt.VirtualizedMethod);
				}
			}
		}
	}

	/// <summary>
	/// Devirtualize options.
	/// </summary>
	[Flags]
	public enum DevirtualizeOptions
	{
		/// <summary>
		/// Nothing.
		/// </summary>
		Nothing = 0,

		/// <summary>
		/// Inject attributes into devirtualized methods.
		/// </summary>
		InjectAttributes = 1
	}
}



================================================
File: src/eazdevirt/Core/EazModule.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using eazdevirt.Types;

namespace eazdevirt
{
	/// <summary>
	/// Module that contains methods virtualized by Eazfuscator.NET.
	/// </summary>
	public class EazModule
	{
		public ModuleDefMD Module { get; private set; }

		public VirtualMachineType VType { get; private set; }

		public IList<VirtualOpCode> VirtualInstructions { get; private set; }

		/// <summary>
		/// Dictionary containing all identified instruction types (opcodes).
		/// Maps virtual opcode (int) to virtual instruction containing the actual opcode.
		/// </summary>
		public Dictionary<Int32, VirtualOpCode> IdentifiedOpCodes;

		/// <summary>
		/// Embedded resource string identifier.
		/// </summary>
		public String ResourceStringId { get; private set; }

		/// <summary>
		/// Embedded resource crypto key.
		/// </summary>
		public Int32 ResourceCryptoKey { get; private set; }

		/// <summary>
		/// Position translator.
		/// </summary>
		public IPositionTranslator PositionTranslator { get; private set; }

		/// <summary>
		/// Serialization version to use for readers/resolvers.
		/// </summary>
		public SerializationVersion Version { get; private set; }

		public ILogger Logger { get; private set; }

		/// <summary>
		/// Construct an EazModule from a filepath.
		/// </summary>
		/// <param name="filepath">Filepath of assembly</param>
		public EazModule(String filepath)
			: this(ModuleDefMD.Load(filepath))
		{
		}

		public EazModule(String filepath, ILogger logger)
			: this(ModuleDefMD.Load(filepath), logger)
		{
		}

		/// <summary>
		/// Construct an EazModule from a loaded ModuleDefMD.
		/// </summary>
		/// <param name="module">Loaded module</param>
		public EazModule(ModuleDefMD module)
			: this(module, null)
		{
		}

		public EazModule(ModuleDefMD module, ILogger logger)
		{
			this.Module = module;
			this.Logger = (logger != null ? logger : DummyLogger.NoThrowInstance);
			this.Initialize();
		}

		private void Initialize()
		{
			// Initialize PositionTranslator
			var cryptoStreamDef = this.FindCryptoStreamType();
			if (cryptoStreamDef == null)
				throw new Exception("Unable to find crypto stream TypeDef");
			this.PositionTranslator = new PositionTranslator(cryptoStreamDef);

			// Set version
			if (cryptoStreamDef is CryptoStreamDefV2)
				this.Version = SerializationVersion.V2;
			else
				this.Version = SerializationVersion.V1;

			this.VType = new VirtualMachineType(this);
			this.InitializeIdentifiedOpCodes();
		}

		public void Write(String filepath, Boolean noThrow = false)
		{
			var options = new ModuleWriterOptions(this.Module);
			options.MetaDataOptions.Flags |= MetaDataFlags.PreserveAll;

			if (noThrow)
				options.Logger = DummyLogger.NoThrowInstance;

			this.Module.Write(filepath, options);
		}

		/// <summary>
		/// Get the resource with virtualized method data as a Stream.
		/// </summary>
		/// <param name="cryptoStream">
		/// Whether or not to return a raw stream that doesn't automatically handle crypto
		/// </param>
		/// <returns>Stream</returns>
		public Stream GetResourceStream(Boolean rawStream = false)
		{
			var streamType = this.FindCryptoStreamType();
			if (streamType == null)
				throw new Exception("Unable to find crypto stream type");

			if (this.ResourceStringId == null)
			{
				var vmethod = this.FindFirstVirtualizedMethod();
				if (vmethod != null)
				{
					this.ResourceStringId = vmethod.ResourceStringId;
					this.ResourceCryptoKey = vmethod.ResourceCryptoKey;
				}
				else
					throw new Exception("Unable to find any virtualized methods");
			}

			var resource = this.Module.Resources.FindEmbeddedResource(this.ResourceStringId);
			if (resource == null)
				throw new Exception("Unable to find resource");

			if (!rawStream)
				return streamType.CreateStream(resource.GetResourceStream(), this.ResourceCryptoKey);
			else
				return resource.GetResourceStream();
		}

		/// <summary>
		/// Try and find the type used for crypto streams.
		/// </summary>
		/// <returns>Crypto stream TypeDef, or null if none found</returns>
		public CryptoStreamDef FindCryptoStreamType()
		{
			var typeDef = this.Module.Types.FirstOrDefault(type =>
				type.BaseType != null
				&& type.BaseType.FullName.Equals(typeof(System.IO.Stream).FullName));
			if (typeDef == null)
				return null;

			if (CryptoStreamDefV2.Is(typeDef))
				return new CryptoStreamDefV2(typeDef);
			else if (CryptoStreamDef.Is(typeDef))
				return new CryptoStreamDef(typeDef);
			else return null;
		}

		/// <summary>
		/// Look for virtualized methods and return the first found. Useful because
		/// all virtualized methods seem to use the same manifest resource and crypto
		/// key.
		/// </summary>
		/// <returns>First virtualized method if found, null if none found</returns>
		public MethodStub FindFirstVirtualizedMethod()
		{
			var types = this.Module.GetTypes();
			foreach (var type in types)
			{
				MethodStub[] methods = this.FindMethodStubs(type);
				if (methods.Length > 0)
					return methods[0];
			}

			return null;
		}

		/// <summary>
		/// Look for virtualized methods throughout the module.
		/// </summary>
		/// <returns>Found virtualized methods</returns>
		public MethodStub[] FindMethodStubs()
		{
			List<MethodStub> list = new List<MethodStub>();

			var types = this.Module.GetTypes();
			foreach(var type in types)
			{
				MethodStub[] methods = this.FindMethodStubs(type);
				list.AddRange(methods);
			}

			return list.ToArray();
		}

		/// <summary>
		/// Look for virtualized methods of a specific type.
		/// </summary>
		/// <param name="type">Type to look in</param>
		/// <returns>Found virtualized methods</returns>
		public MethodStub[] FindMethodStubs(TypeDef type)
		{
			List<MethodStub> list = new List<MethodStub>();

			var methods = type.Methods;
			foreach (var method in methods)
			{
				if (this.IsMethodStub(method))
					list.Add(new MethodStub(this, method));
			}

			return list.ToArray();
		}

		/// <summary>
		/// Makes an estimated guess as to whether or not the given method
		/// is a virtualized method.
		/// </summary>
		/// <param name="method">Method to inspect</param>
		/// <returns>true if virtualized, false if not</returns>
		/// <remarks>
		/// Performs two checks:
		/// First, it checks for a `ldstr` instruction that loads a length-10 string.
		/// Second, it checks for a call to a method: (Stream, String, Object[]): ???
		/// </remarks>
		public Boolean IsMethodStub(MethodDef method)
		{
			if (method == null || !method.HasBody || !method.Body.HasInstructions)
				return false;

			Boolean hasMethodCall = false, hasLdstr = false;

			var instrs = method.Body.Instructions;
			foreach(var instr in instrs)
			{
				if(instr.OpCode.Code == dnlib.DotNet.Emit.Code.Ldstr)
				{
					String operand = (String)instr.Operand;
					if (operand != null && operand.Length == 10)
						hasLdstr = true;
				}

				if (instr.OpCode.Code == dnlib.DotNet.Emit.Code.Call)
				{
					MethodDef calledMethod;
					if (instr.Operand is MethodDef && (calledMethod = ((MethodDef)instr.Operand)) != null)
					{
						ParameterList p = calledMethod.Parameters;

						TypeSig[] types = null;
						if(p.Count == 3 || p.Count == 6)
						{
							types = new TypeSig[] { p[0].Type, p[1].Type, p[2].Type };
						}
						else if (p.Count == 4 || p.Count == 7)
						{
							types = new TypeSig[] { p[1].Type, p[2].Type, p[3].Type };
						}

						if (types != null
						&& types[0].FullName.Equals("System.IO.Stream")
						&& types[1].FullName.Equals("System.String")
						&& types[2].FullName.Equals("System.Object[]"))
						{
							hasMethodCall = true;
							break;
						}
					}
				}
			}

			return hasLdstr && hasMethodCall;
		}

		/// <summary>
		/// Find all virtual instructions and attempt to identify them.
		/// </summary>
		private void InitializeIdentifiedOpCodes()
		{
			this.IdentifiedOpCodes = new Dictionary<Int32, VirtualOpCode>();

			this.VirtualInstructions = VirtualOpCode.FindAllInstructions(this, this.VType.Type);
			var identified = this.VirtualInstructions.Where((instruction) => { return instruction.IsIdentified; });

			Boolean warningOccurred = false;

			foreach (var instruction in identified)
			{
				Boolean containsVirtual = this.IdentifiedOpCodes.ContainsKey(instruction.VirtualCode);

				VirtualOpCode existing = this.IdentifiedOpCodes.Where((kvp, index) => {
					return kvp.Value.IdentityEquals(instruction);
				}).FirstOrDefault().Value;
				Boolean containsActual = (existing != null);

				if (containsVirtual)
					this.Logger.Warning(this, "WARNING: Multiple instruction types with the same virtual opcode detected ({0})",
						instruction.VirtualCode);

				if (containsActual && !instruction.ExpectsMultiple)
				{
					String opcodeName;

					if (instruction.HasCILOpCode)
						opcodeName = instruction.OpCode.ToString();
					else opcodeName = instruction.SpecialOpCode.ToString();

					this.Logger.Warning(this, "WARNING: Multiple virtual opcodes map to the same actual opcode ({0}, {1} => {2})",
						existing.VirtualCode, instruction.VirtualCode, opcodeName);
				}

				if (!warningOccurred)
					warningOccurred = (containsVirtual || containsActual);

				this.IdentifiedOpCodes.Add(instruction.VirtualCode, instruction);
			}

			if (warningOccurred)
				Console.WriteLine();
		}

		/// <summary>
		/// Write params to Console for debugging purposes.
		/// </summary>
		/// <param name="method">Method</param>
		public static void WriteMethodDefParams(MethodDef method)
		{
			ParameterList p = method.Parameters;

			Console.Write("(");
			foreach (var param in p) Console.Write(param.Type.FullName + " ");
			Console.WriteLine(")");
		}
	}
}



================================================
File: src/eazdevirt/Core/Helpers.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace eazdevirt
{
	public static class Helpers
	{
		/// <summary>
		/// Get the first method that is Call-ed in a method's body. Does not factor
		/// in branching.
		/// </summary>
		/// <param name="method">Method to look in</param>
		public static MethodDef GetFirstCalledMethod(MethodDef method)
		{
			if (method == null)
				throw new ArgumentNullException();

			if (!method.HasBody || !method.Body.HasInstructions)
				return null;

			foreach (var instr in method.Body.Instructions)
			{
				if (instr.OpCode.Code == dnlib.DotNet.Emit.Code.Call)
				{
					MethodDef calledMethod;
					if (instr.Operand is MethodDef && (calledMethod = ((MethodDef)instr.Operand)) != null)
					{
						return calledMethod;
					}
				}

				// Todo: Calli, Callvirt?
			}

			return null;
		}

		/// <summary>
		/// Try to cast a `call` operand to a MethodDef. If not successful,
		/// returns null.
		/// </summary>
		/// <param name="obj">Operand to cast</param>
		/// <returns>MethodDef if successful, null if not</returns>
		public static MethodDef TryTransformCallOperand(Object operand)
		{
			if (operand is MethodDef)
				return (MethodDef)operand;
			else return null;
		}

		/// <summary>
		/// Look through some sequence of instructions for a pattern of opcodes, and return all instruction
		/// subsequences which match the given pattern.
		/// </summary>
		/// <param name="instructions">Instruction sequence to look through</param>
		/// <param name="pattern">OpCode pattern</param>
		/// <returns>All matching instruction subsequences</returns>
		public static IList<Instruction[]> FindOpCodePatterns(IList<Instruction> instructions, IList<Code> pattern)
		{
			List<Instruction[]> list = new List<Instruction[]>();

			for(Int32 i = 0; i < instructions.Count; i++)
			{
				List<Instruction> current = new List<Instruction>();

				for(Int32 j = i, k = 0; j < instructions.Count && k < pattern.Count; j++, k++)
				{
					if (instructions[j].OpCode.Code != pattern[k])
						break;
					else current.Add(instructions[j]);
				}

				if (current.Count == pattern.Count)
					list.Add(current.ToArray());
			}

			return list;
		}

		/// <summary>
		/// Get the operand value for all Ldc_* instructions.
		/// </summary>
		/// <param name="ldc">Instruction</param>
		/// <returns>Operand value</returns>
		public static Int32 GetLdcOperand(Instruction ldc)
		{
			switch (ldc.OpCode.Code)
			{
				case Code.Ldc_I4:
					return (Int32)ldc.Operand;
				case Code.Ldc_I4_S:
					return (Int32)((SByte)ldc.Operand);
				case Code.Ldc_I4_0:
					return 0;
				case Code.Ldc_I4_1:
					return 1;
				case Code.Ldc_I4_2:
					return 2;
				case Code.Ldc_I4_3:
					return 3;
				case Code.Ldc_I4_4:
					return 4;
				case Code.Ldc_I4_5:
					return 5;
				case Code.Ldc_I4_6:
					return 6;
				case Code.Ldc_I4_7:
					return 7;
				case Code.Ldc_I4_8:
					return 8;
				case Code.Ldc_I4_M1:
					return -1;
			}

			throw new Exception("Cannot get operand value of non-ldc instruction");
		}

		public static MethodDef GetRetMethod(MethodDef method)
		{
			if (method == null)
				throw new ArgumentNullException();

			MethodDef lastCalled = null;
			foreach(var instr in method.Body.Instructions)
			{
				MethodDef called = null;
				if(instr.OpCode.Code == Code.Call
				&& (called = TryTransformCallOperand(instr.Operand)) != null)
				{
					lastCalled = called;
				}
				else if (instr.OpCode.Code == Code.Ret)
					break;
			}

			return lastCalled;
		}
	}
}



================================================
File: src/eazdevirt/Core/IPositionTranslator.cs
================================================
ï»¿using System;

namespace eazdevirt
{
	public interface IPositionTranslator
	{
		/// <summary>
		/// Given the crypto key, convert a position string into a position.
		/// </summary>
		/// <param name="s">Position string</param>
		/// <param name="cryptoKey">Crypto key</param>
		/// <returns>Position</returns>
		Int64 ToPosition(String s, Int32 cryptoKey);
	}
}



================================================
File: src/eazdevirt/Core/MethodStub.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace eazdevirt
{
	/// <summary>
	/// Represents a method stub of a method virtualized by Eazfuscator.NET.
	/// </summary>
	public class MethodStub
	{
		/// <summary>
		/// Parent.
		/// </summary>
		public EazModule Parent { get; private set; }

		/// <summary>
		/// Module.
		/// </summary>
		public ModuleDefMD Module { get { return this.Parent.Module; } }

		/// <summary>
		/// Underlying method.
		/// </summary>
		public MethodDef Method { get; private set; }

		/// <summary>
		/// The method that creates the raw resource stream. The method body
		/// contains a `ldstr` instruction with the resource name.
		/// </summary>
		public MethodDef CreateStreamMethod { get; private set; }

		/// <summary>
		/// The method that does the work.
		/// </summary>
		public MethodDef VirtualCallMethod { get; private set; }

		/// <summary>
		/// Instruction index at which the VirtualCallMethod was found.
		/// </summary>
		public Int32 VirtualCallIndex { get; private set; }

		/// <summary>
		/// The string used to specify the file position to read at.
		/// </summary>
		public String PositionString { get; private set; }

		public Int64 Position { get; private set; }

		/// <summary>
		/// String identifier of the embedded resource which contains encrypted
		/// virtualized method info.
		/// </summary>
		public String ResourceStringId { get; private set; }

		/// <summary>
		/// Crypto key integer used to decrypt the embedded resource.
		/// </summary>
		public Int32 ResourceCryptoKey { get; private set; }

		/// <summary>
		/// Construct a MethodStub from an existing method.
		/// </summary>
		/// <param name="module">Parent module</param>
		/// <param name="method">Stub method</param>
		public MethodStub(EazModule module, MethodDef method)
		{
			this.Parent = module;
			this.Method = method;
			this.Initialize();
		}

		/// <summary>
		/// Try to find all helpful information about the method stub and
		/// virtualized method.
		/// </summary>
		private void Initialize()
		{
			if (!this.Method.HasBody || !this.Method.Body.HasInstructions)
				return;

			var instrs = this.Method.Body.Instructions;
			this.VirtualCallIndex = -1;

			// Get info on virtual call method
			for(int i = 0; i < instrs.Count; i++)
			{
				var instr = instrs[i];

				MethodDef method = null;
				if(instr.OpCode.Code == dnlib.DotNet.Emit.Code.Call
				&& (method = Helpers.TryTransformCallOperand(instr.Operand)) != null
				&& IsVirtualCallMethod(method))
				{
					this.VirtualCallMethod = method;
					this.VirtualCallIndex = i;
					break;
				}
			}

			if (this.VirtualCallMethod == null)
				throw new Exception("Couldn't get VirtualCallMethod");

			// Get the position string
			int expectedLdstrIndex = (this.VirtualCallIndex - 2);
			if(this.VirtualCallMethod.Parameters.Count >= 6)
				expectedLdstrIndex -= 3;
			if (expectedLdstrIndex >= 0
			&& instrs[expectedLdstrIndex].OpCode.Code == dnlib.DotNet.Emit.Code.Ldstr)
			{
				this.PositionString = (String)instrs[expectedLdstrIndex].Operand;
			}
			else throw new Exception("Couldn't get PositionString");

			// Get the create stream method
			for (int i = (this.VirtualCallIndex - 3); i >= 0; i--)
			{
				var instr = instrs[i];
				MethodDef method = null;

				if (instr.OpCode.Code == dnlib.DotNet.Emit.Code.Call
				&& (method = Helpers.TryTransformCallOperand(instr.Operand)) != null
				&& method.ReturnType.FullName.Equals("System.IO.Stream"))
				{
					this.CreateStreamMethod = method;
				}
			}

			if (this.CreateStreamMethod == null)
				throw new Exception("Couldn't get CreateStreamMethod");

			// Get the resource string id
			this.ResourceStringId = FindResourceStringId(this.CreateStreamMethod);

			if (this.ResourceStringId == null)
				throw new Exception("Couldn't get ResourceStringId");

			// Get the crypto key
			this.ResourceCryptoKey = FindResourceCryptoKey(this.VirtualCallMethod);

			// Set position from position string + crypto key
			this.Position = this.Parent.PositionTranslator.ToPosition(this.PositionString, this.ResourceCryptoKey);
		}

		/// <summary>
		/// Find the crypto key for the resource associated with the given method
		/// used in virtualized methods.
		/// </summary>
		/// <param name="method">
		/// Method used in virtualized methods, following the pattern: (Stream, String, Object[]): Object
		/// </param>
		/// <returns>Crypto key</returns>
		public static Int32 FindResourceCryptoKey(MethodDef method)
		{
			MethodDef origMethod = method;

			for (int i = 0; i < 5 && method != null; i++)
			{
				if (method.ReturnType.FullName.Equals("System.Int32"))
					break;

				method = Helpers.GetFirstCalledMethod(method);
			}

			if (method == null)
				throw new Exception("Rabbit-Hole strategy of finding the resource crypto key failed");

			var instructions = method.Body.Instructions;
			var count = method.Body.Instructions.Count;

			if (!method.HasBody || !method.Body.HasInstructions || count < 2
			|| !method.ReturnType.FullName.Equals("System.Int32"))
				throw new Exception(String.Format(
					"Found method, but seems insufficient (token={0:X8})", method.MDToken.Raw
				));

			if (instructions[count - 2].OpCode.Code == dnlib.DotNet.Emit.Code.Ldc_I4
			&& instructions[count - 1].OpCode.Code == dnlib.DotNet.Emit.Code.Ret)
			{
				return (Int32)instructions[count - 2].Operand;
			}

			throw new Exception(String.Format(
				"Found bad method? (token={0:X8})", origMethod.MDToken.Raw
			));
		}

		/// <summary>
		/// Find the resource string Id, given the method that contains it.
		/// </summary>
		/// <param name="method">Method</param>
		/// <returns>Resource string Id if successful, or null if not successful</returns>
		/// <remarks>This extraction is very simple and just gets the operand of the first `ldstr`</remarks>
		public static String FindResourceStringId(MethodDef method)
		{
			if (method == null)
				throw new ArgumentNullException();

			if (!method.HasBody || !method.Body.HasInstructions)
				return null;

			foreach(var instr in method.Body.Instructions)
			{
				if (instr.OpCode.Code == dnlib.DotNet.Emit.Code.Ldstr)
					return (String)instr.Operand;
			}

			return null;
		}

		/// <summary>
		/// Whether or not a method appears to be the stream creation method.
		/// </summary>
		/// <param name="method">Method to check</param>
		/// <returns>true if stream creation method, false if not</returns>
		public static Boolean IsCreateStreamMethod(MethodDef method)
		{
			if (method == null)
				throw new ArgumentNullException();

			return method.Parameters.Count == 0
				&& method.ReturnType.FullName.Equals("System.IO.Stream");
		}

		/// <summary>
		/// Whether or not a method appears to be the virtual call method.
		/// </summary>
		/// <param name="method">Method to check</param>
		/// <returns>true if virtual call method, false if not</returns>
		public static Boolean IsVirtualCallMethod(MethodDef method)
		{
			if (method == null)
				throw new ArgumentNullException();

			ParameterList p = method.Parameters;

			TypeSig[] types = null;
			if (p.Count == 3 || p.Count == 6)
			{
				types = new TypeSig[] { p[0].Type, p[1].Type, p[2].Type };
			}
			else if (p.Count == 4 || p.Count == 7)
			{
				types = new TypeSig[] { p[1].Type, p[2].Type, p[3].Type };
			}

			if (types != null
			&& types[0].FullName.Equals("System.IO.Stream")
			&& types[1].FullName.Equals("System.String")
			&& types[2].FullName.Equals("System.Object[]"))
			{
				return true;
			}

			return false;
		}
	}
}



================================================
File: src/eazdevirt/Core/MethodStubNotFoundException.cs
================================================
ï»¿using System;

namespace eazdevirt
{
	public class MethodStubNotFoundException : Exception
	{
		public MethodStubNotFoundException()
		{
		}
	}
}



================================================
File: src/eazdevirt/Core/OriginalOpcodeUnknownException.cs
================================================
ï»¿using System;

namespace eazdevirt
{
	public class OriginalOpcodeUnknownException : Exception
	{
		public VirtualOpCode VirtualInstruction { get; private set; }

		public OriginalOpcodeUnknownException(VirtualOpCode instruction)
		{
			this.VirtualInstruction = instruction;
		}
	}
}



================================================
File: src/eazdevirt/Core/PositionTranslator.cs
================================================
ï»¿using System;
using System.IO;
using eazdevirt.Types;

namespace eazdevirt
{
	/// <summary>
	/// Translates strings into positions.
	/// </summary>
	public class PositionTranslator : IPositionTranslator
	{
		/// <summary>
		/// Although these values appear "random," they are consistent across
		/// all samples I've observed.
		/// </summary>
		private static UInt32[] DefaultPseudoRandomInts = new UInt32[] {
			52200625u,
			614125u,
			7225u,
			85u,
			1u
		};

		/// <summary>
		/// Random integers used in translation.
		/// </summary>
		private UInt32[] _randomInts;

		/// <summary>
		/// Crypto stream type definition.
		/// </summary>
		private CryptoStreamDef _streamType;

		/// <summary>
		/// Construct a PositionTranslator with the default random integers.
		/// </summary>
		/// <param name="streamType">Crypto stream type definition</param>
		public PositionTranslator(CryptoStreamDef streamType)
			: this(streamType, DefaultPseudoRandomInts)
		{
		}

		/// <summary>
		/// Construct a PositionTranslator.
		/// </summary>
		/// <param name="randomInts">Random integers used in translation</param>
		public PositionTranslator(CryptoStreamDef streamType, UInt32[] randomInts)
		{
			if (randomInts == null)
				throw new ArgumentNullException();

			if (randomInts.Length != 5)
				throw new Exception("Integer array must have a length of 5");

			_randomInts = randomInts;
			_streamType = streamType;
		}

		/// <summary>
		/// Given the crypto key, convert a position string into a position.
		/// </summary>
		/// <param name="str">Position string</param>
		/// <param name="cryptoKey">Crypto key</param>
		/// <returns>Position</returns>
		public virtual Int64 ToPosition(String str, Int32 cryptoKey)
		{
			Byte[] array = this.Convert(str);
			MemoryStream memoryStream = new MemoryStream(array);
			CryptoStreamBase stream = _streamType.CreateStream(memoryStream, cryptoKey);
			BinaryReader binaryReader = new BinaryReader(stream);
			Int64 result = binaryReader.ReadInt64();
			memoryStream.Dispose();
			return result;
		}

		/// <summary>
		/// Convert a position string to the corresponding byte array.
		/// </summary>
		/// <param name="str">Position string</param>
		/// <remarks>Most of this is copied from decompilation</remarks>
		/// <returns>Byte array</returns>
		private Byte[] Convert(String str)
		{
			if (str == null)
				throw new ArgumentNullException();

			if (str.Length != 10)
				throw new FormatException("Position string must be 10 characters in length");

			MemoryStream memoryStream = new MemoryStream(str.Length * 4 / 5);
			byte[] result;

			try
			{
				int num = 0;
				uint num2 = 0u;

				for (int i = 0; i < str.Length; i++)
				{
					char c = str[i];
					if (c == 'z' && num == 0)
					{
						WriteValue(memoryStream, num2, 0);
					}
					else
					{
						if (c < '!' || c > 'u')
						{
							throw new FormatException("Illegal character");
						}
						checked
						{
							num2 += (uint)(unchecked((ulong)_randomInts[num]) * (ulong)unchecked((long)checked(c - '!')));
						}
						num++;
						if (num == 5)
						{
							WriteValue(memoryStream, num2, 0);
							num = 0;
							num2 = 0u;
						}
					}
				}

				if (num == 1)
				{
					throw new Exception();
				}

				if (num > 1)
				{
					for (int j = num; j < 5; j++)
					{
						checked
						{
							num2 += 84u * _randomInts[j];
						}
					}
					WriteValue(memoryStream, num2, 5 - num);
				}

				result = memoryStream.ToArray();
			}
			finally
			{
				((IDisposable)memoryStream).Dispose();
			}

			return result;
		}

		private static void WriteValue(Stream stream, uint val, int int_0)
		{
			stream.WriteByte((byte)(val >> 24));
			if (int_0 == 3)
			{
				return;
			}
			stream.WriteByte((byte)(val >> 16 & 255u));
			if (int_0 == 2)
			{
				return;
			}
			stream.WriteByte((byte)(val >> 8 & 255u));
			if (int_0 == 1)
			{
				return;
			}
			stream.WriteByte((byte)(val & 255u));
		}
	}
}



================================================
File: src/eazdevirt/Core/SerializationVersion.cs
================================================
ï»¿namespace eazdevirt
{
	public enum SerializationVersion
	{
		/// <summary>
		/// The "original" serialization version from when I started
		/// researching Eazfuscator's VM.
		/// </summary>
		V1,

		/// <summary>
		/// Almost the exact same as V1, except removes two calls to
		/// ReadByte, one prior to reading EazCall data and the other
		/// prior to reading virtual method data.
		/// </summary>
		/// <remarks>
		/// Detection of this version is done by checking the CryptoStreamDef
		/// version. If it is V2 (has a special hardcoded integer used
		/// in decryption) then the serialization version should be V2.
		/// </remarks>
		V2
	}
}



================================================
File: src/eazdevirt/Core/SpecialCode.cs
================================================
ï»¿namespace eazdevirt
{
	/// <summary>
	/// All special codes are assigned pretend values.
	/// </summary>
	public enum SpecialCode : uint
	{
		/// <summary>
		/// Special opcode, used when calling a virtualized method from within
		/// another virtualized method.
		/// </summary>
		Eaz_Call = 0x80000000
	}
}



================================================
File: src/eazdevirt/Core/StackTypeHelper.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib;
using dnlib.DotNet;

namespace eazdevirt
{
	public static class StackTypeHelper
	{
		/// <summary>
		/// Takes a TypeDef of a "stack type" (types pushed to Eazfuscator.NET's VM stack) and tries
		/// to determine the underlying type.
		/// </summary>
		/// <param name="typeDef">Stack type</param>
		/// <returns>Underlying type (TypeSig) if determined, false if not</returns>
		public static TypeSig GetUnderlyingType(TypeDef typeDef)
		{
			if (!typeDef.HasMethods)
				return null;

			List<TypeSig> returnTypes = new List<TypeSig>();

			var methods = typeDef.Methods;
			foreach(var method in methods)
			{
				// Checks: If a getter-method (non-static, non-virtual) for a type exists,
				// and a field for that type also exists
				if (!method.IsStatic && !method.IsVirtual
				&& method.ReturnType != typeDef.Module.CorLibTypes.Void
				&& typeDef.Fields.FirstOrDefault(x =>
					{ return x.FieldType.MDToken.Raw == method.ReturnType.MDToken.Raw; }) != null)
					returnTypes.Add(method.ReturnType);
			}

			// Could be improved
			if (returnTypes.Count >= 1)
				return returnTypes[0];

			return null;
		}
	}
}



================================================
File: src/eazdevirt/Core/VirtualMachineType.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using de4dot.blocks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Util;

namespace eazdevirt
{
	/// <summary>
	/// Class that contains data extracted from the "VType" (virtual machine type)
	/// found in Eazfuscator.NET-protected assemblies with virtualized methods.
	/// </summary>
	public class VirtualMachineType
	{
		/// <summary>
		/// Parent.
		/// </summary>
		public EazModule Parent { get; private set; }

		/// <summary>
		/// Module.
		/// </summary>
		public ModuleDefMD Module { get { return this.Parent.Module; } }

		/// <summary>
		/// Main virtualization type.
		/// </summary>
		public TypeDef Type { get; private set; }

		/// <summary>
		/// The field used to store the arguments.
		/// </summary>
		public FieldDef ArgumentsField { get; private set; }

		/// <summary>
		/// The field used to store local variables.
		/// </summary>
		public FieldDef LocalsField { get; private set; }

		/// <summary>
		/// Logger.
		/// </summary>
		public ILogger Logger { get; private set; }

		/// <summary>
		/// A few Type fields are set in .cctor.
		/// </summary>
		public Dictionary<FieldDef, ITypeDefOrRef> TypeFields { get; private set; }

		public VirtualMachineType(EazModule module)
			: this(module, null)
		{
		}

		public VirtualMachineType(EazModule module, ILogger logger)
		{
			if (module == null)
				throw new ArgumentNullException();

			this.Parent = module;
			this.Logger = (logger != null ? logger : DummyLogger.NoThrowInstance);

			this.Initialize();
		}

		/// <summary>
		/// Find the VType and extract info from it.
		/// </summary>
		private void Initialize()
		{
			// Finds the type from the first virtualized method
			var vmethod = this.Parent.FindFirstVirtualizedMethod();
			if (vmethod == null)
				throw new MethodStubNotFoundException();

			this.Type = vmethod.VirtualCallMethod.DeclaringType;

			this.InitializeArgumentsField(); // Set ArgumentsField
			this.InitializeLocalsField();    // Set LocalsField
			this.InitializeTypeFields();     // Set TypeFields
		}

		/// <summary>
		/// Find and set the ArgumentsField.
		/// </summary>
		private void InitializeArgumentsField()
		{
			// Get arguments field
			MethodDef setArgumentsMethod = null;
			var methods = this.Type.Methods;
			foreach (var method in methods)
			{
				if (!method.IsStatic && method.IsPrivate
				&& method.ReturnType.FullName.Equals("System.Object")
				&& method.Parameters.Count == 5
				&& method.Parameters[1].Type.FullName.Equals("System.Object[]")
				&& method.Parameters[2].Type.FullName.Equals("System.Type[]")
				&& method.Parameters[3].Type.FullName.Equals("System.Type[]")
				&& method.Parameters[4].Type.FullName.Equals("System.Object[]"))
				{
					setArgumentsMethod = method;
					break;
				}
			}

			if (setArgumentsMethod == null)
				throw new Exception("Unable to find the method in which the arguments field is set");

			var instructions = setArgumentsMethod.Body.Instructions;
			DotNetUtils.GetInstructions(instructions, 4, Code.Stfld.ToOpCode());

			Int32 stfldCount = 0;
			foreach (var instr in instructions)
			{
				if (instr.OpCode.Code == Code.Stfld)
					stfldCount++;

				if (stfldCount == 4)
				{
					this.ArgumentsField = (FieldDef)instr.Operand;
					break;
				}
			}

			if (this.ArgumentsField == null)
				throw new Exception("Unable to find arguments field");
		}

		private void InitializeLocalsField()
		{
			// Locals field is the same type as arguments field
			var fields = this.Type.Fields;
			foreach(var field in fields)
			{
				if(field.FieldType.FullName.Equals(this.ArgumentsField.FieldType.FullName)
				&& field.MDToken != this.ArgumentsField.MDToken)
				{
					this.LocalsField = field;
					break;
				}
			}

			if (this.LocalsField == null)
				throw new Exception("Unable to find locals field");
		}

		private void InitializeTypeFields()
		{
			this.TypeFields = new Dictionary<FieldDef, ITypeDefOrRef>();
			MethodDef cctor = this.Type.FindMethod(".cctor");
			if (cctor == null)
				throw new Exception("Unable to find virtualization type .cctor");

			if (!cctor.HasBody || !cctor.Body.HasInstructions)
				throw new Exception("Virtualization type .cctor has no instructions");

			var subs = cctor.FindAll(new Code[] { Code.Ldtoken, Code.Call, Code.Stsfld });
			foreach(var sub in subs)
			{
				FieldDef field = sub[2].Operand as FieldDef;
				if (field == null)
					continue;

				ITypeDefOrRef type = sub[0].Operand as ITypeDefOrRef;
				if (type == null)
					continue;

				if (this.TypeFields.ContainsKey(field))
				{
					Console.WriteLine("[InitializeTypeFields] WARNING: Overwriting ITypeDefOrRef for FieldDef");
					this.TypeFields[field] = type;
				}
				else this.TypeFields.Add(field, type);
			}
		}

		/// <summary>
		/// Get the FieldDef which maps to a type of a specific name.
		/// </summary>
		/// <param name="typeName">Name of type</param>
		/// <returns>FieldDef if successful, null if not</returns>
		public FieldDef GetTypeField(String typeName)
		{
			foreach(var kvp in this.TypeFields)
			{
				if (kvp.Value.FullName.Equals(typeName))
					return kvp.Key;
			}

			return null;
		}
	}
}



================================================
File: src/eazdevirt/Core/VirtualOpCode.Helpers.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using de4dot.blocks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Detection.V1.Ext;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt
{
	public partial class VirtualOpCode
	{
		/// <summary>
		/// Try to set indentify-related info to the instruction (original opcode).
		/// </summary>
		/// <param name="ins">Virtual instruction</param>
		protected void TrySetIdentify()
		{
			DetectAttribute attr;
			if (this.TryIdentifyFull(out attr))
			{
				this.DetectAttribute = attr;
				this.IsIdentified = true;
			}
			else
			{
				this.IsIdentified = false;
			}
		}

		/// <summary>
		/// Check if the delegate method's body contains the given pattern.
		/// </summary>
		/// <param name="codePattern">Pattern to check for</param>
		/// <returns>true if match, false if not</returns>
		public Boolean Matches(IList<Code> codePattern)
		{
			this.CheckDelegateMethod();
			return this.DelegateMethod.Matches(codePattern);
		}

		/// <summary>
		/// Check if the delegate's method body entirely matches the given pattern.
		/// </summary>
		/// <param name="codePattern">Pattern to check against</param>
		/// <returns>true if match, false if not</returns>
		public Boolean MatchesEntire(IList<Code> codePattern)
		{
			this.CheckDelegateMethod();
			return this.DelegateMethod.MatchesEntire(codePattern);
		}

		/// <summary>
		/// Check if a called method's body contains the given pattern (can be improved).
		/// </summary>
		/// <param name="codePattern">Pattern to search for in called method</param>
		/// <remarks>
		/// Looks like: [static] ??? method(Value, Value)
		/// </remarks>
		/// <returns>true if match, false if not</returns>
		public Boolean MatchesIndirect(IList<Code> codePattern)
		{
			this.CheckDelegateMethod();

			var called = DotNetUtils.GetCalledMethods(this.Parent.Module, this.DelegateMethod);
			var targetMethod = called.FirstOrDefault((m) => {
				return (!m.IsStatic && m.Parameters.Count == 3
					 && m.Parameters[1].Type.FullName.Equals(m.Parameters[2].Type.FullName))
					 || (m.IsStatic && m.Parameters.Count == 2
					 && m.Parameters[0].Type.FullName.Equals(m.Parameters[1].Type.FullName));
			});

			if (targetMethod != null)
				return (Helpers.FindOpCodePatterns(targetMethod.Body.Instructions, codePattern).Count > 0);
			else return false;
		}

		/// <summary>
		/// Check if a called method's body contains the given pattern, and that the called
		/// method is given a Boolean of a specific value as the third argument.
		/// </summary>
		/// <param name="val">Boolean value to expect</param>
		/// <param name="codePattern">Pattern to search for in called method</param>
		/// <remarks>
		/// Looks like: [static] ??? method(Value, Value, Boolean)
		/// </remarks>
		/// <returns>true if match, false if not</returns>
		public Boolean MatchesIndirectWithBoolean(Boolean val, IList<Code> codePattern)
		{
			this.CheckDelegateMethod();

			var called = DotNetUtils.GetCalledMethods(this.Parent.Module, this.DelegateMethod);
			var targetMethod = called.FirstOrDefault((m) =>
			{
				return m.Parameters.Count == 4
					&& m.Parameters[3].Type.FullName.Equals("System.Boolean");
			});

			if (targetMethod == null)
				return false;

			// Expected value of ldc.i4 operand, loading the bool value
			Int32 expected = val ? 1 : 0;

			var instrs = this.DelegateMethod.Body.Instructions;
			for (Int32 i = 0; i < instrs.Count; i++)
			{
				var instr = this.DelegateMethod.Body.Instructions[i];

				if (instr.OpCode.Code == Code.Call && instr.Operand is MethodDef
				&& ((MethodDef)instr.Operand) == targetMethod
				&& i != 0 && instrs[i - 1].IsLdcI4() && Helpers.GetLdcOperand(instrs[i - 1]) == expected)
				{
					// If we get here, we have the right method
					return (Helpers.FindOpCodePatterns(targetMethod.Body.Instructions, codePattern).Count > 0);
				}
			}

			return false;
		}

		/// <summary>
		/// Check if a called method's body contains the given pattern, and that the called
		/// method is given two Booleans of specific values as the third and fourth arguments.
		/// </summary>
		/// <param name="val1">First Boolean value to expect</param>
		/// <param name="val2">Second Boolean value to expect</param>
		/// <param name="codePattern">Pattern to search for in called method</param>
		/// <remarks>
		/// Looks like: [static] ??? method(Value, Value, Boolean, Boolean)
		/// </remarks>
		/// <returns>true if match, false if not</returns>
		public Boolean MatchesIndirectWithBoolean2(Boolean val1, Boolean val2, IList<Code> codePattern)
		{
			this.CheckDelegateMethod();

			var called = DotNetUtils.GetCalledMethods(this.Parent.Module, this.DelegateMethod);
			var targetMethod = called.FirstOrDefault((m) =>
			{
				return m.Parameters.Count == 5
					&& m.Parameters[3].Type.FullName.Equals("System.Boolean")
					&& m.Parameters[4].Type.FullName.Equals("System.Boolean");
			});

			if (targetMethod == null)
				return false;

			// Expected values of ldc.i4 operands, loading the two bool values
			Int32 expected1 = val1 ? 1 : 0, expected2 = val2 ? 1 : 0;

			var instrs = this.DelegateMethod.Body.Instructions;
			for (Int32 i = 0; i < instrs.Count; i++)
			{
				var instr = instrs[i];

				if (instr.OpCode.Code == Code.Call && instr.Operand is MethodDef
				&& ((MethodDef)instr.Operand).MDToken == targetMethod.MDToken
				&& i > 1 && instrs[i - 1].IsLdcI4() && Helpers.GetLdcOperand(instrs[i - 1]) == expected2
				&& instrs[i - 2].IsLdcI4() && Helpers.GetLdcOperand(instrs[i - 2]) == expected1)
				{
					// If we get here, we have the right method
					return (Helpers.FindOpCodePatterns(targetMethod.Body.Instructions, codePattern).Count > 0);
				}
			}

			return false;
		}

		/// <summary>
		/// Find the first occurrence of an opcode pattern in the delegate method,
		/// returning the matching instruction sequence.
		/// </summary>
		/// <param name="pattern">Pattern to search for</param>
		/// <returns>Matching instruction sequence, or null if none found</returns>
		public IList<Instruction> Find(IList<Code> pattern)
		{
			this.CheckDelegateMethod();
			return this.DelegateMethod.Find(pattern);
		}

		/// <summary>
		/// Get all method references that are called in the delegate method.
		/// </summary>
		/// <returns>All called method references</returns>
		/// <remarks>Partially copied from DotNetUtils.GetCalledMethods()</remarks>
		public IList<IMethod> GetCalledMethods()
		{
			ModuleDef module = this.Parent.Module;
			MethodDef method = this.DelegateMethod;

			List<IMethod> methods = new List<IMethod>();

			if (method != null && method.HasBody)
			{
				foreach (var call in method.Body.Instructions)
				{
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					var methodRef = call.Operand as IMethod;
					if (methodRef == null)
						continue;
					methods.Add(methodRef);
				}
			}

			return methods;
		}

		/// <summary>
		/// Copy a given OpCode pattern, and return a modified pattern where all instances of
		/// the specified "old" code are replaced with a "new" code.
		/// </summary>
		/// <param name="pattern">OpCode pattern</param>
		/// <param name="oldCode">Code to replace</param>
		/// <param name="newCode">Code to replace with</param>
		/// <returns>Copied and modified pattern</returns>
		public IList<Code> ModifyPattern(IList<Code> pattern, Code oldCode, Code newCode)
		{
			Code[] result = new Code[pattern.Count];
			for (Int32 i = 0; i < result.Length; i++)
			{
				if (pattern[i] == oldCode)
					result[i] = newCode;
				else result[i] = pattern[i];
			}
			return result;
		}

		/// <summary>
		/// Enforce non-nullness for the delegate method, throwing an Exception if null.
		/// </summary>
		/// <exception cref="System.Exception">Thrown if DelegateMethod is null</exception>
		protected void CheckDelegateMethod()
		{
			if (this.DelegateMethod == null)
				throw new Exception("Cannot check for delegate method match, delegate method is null");
		}
	}
}



================================================
File: src/eazdevirt/Core/VirtualOpCode.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;
using eazdevirt.Reflection;

namespace eazdevirt
{
	/// <summary>
	/// Contains information about a specific virtual instruction.
	/// </summary>
	public partial class VirtualOpCode
	{
		/// <summary>
		/// Parent module.
		/// </summary>
		public EazModule Parent { get; private set; }

		/// <summary>
		/// Module.
		/// </summary>
		public ModuleDefMD Module { get { return this.Parent.Module; } }

		/// <summary>
		/// The container type that holds all instruction fields.
		/// </summary>
		public TypeDef ContainerType { get; private set; }

		/// <summary>
		/// Instruction field. These are all initialized in the .ctor of the container.
		/// </summary>
		public FieldDef InstructionField { get; private set; }

		/// <summary>
		/// The virtual opcode, set when the instruction field is constructed.
		/// </summary>
		public Int32 VirtualCode { get; private set; }

		/// <summary>
		/// The operand type, set when the instruction field is constructed.
		/// </summary>
		public Int32 VirtualOperandType { get; private set; }

		/// <summary>
		/// The dictionary method used by the main virtualization class, which returns a dictionary
		/// of all virtual instructions (with their respective delegates) mapped by virtual opcode.
		/// </summary>
		public MethodDef DictionaryMethod { get; private set; }

		/// <summary>
		/// The delegate method associated with this virtual instruction in the dictionary method.
		/// </summary>
		public MethodDef DelegateMethod { get; private set; }

		/// <summary>
		/// Whether or not the virtual opcode was successfully extracted from the container .ctor method.
		/// </summary>
		public Boolean HasVirtualCode { get; private set; }

		/// <summary>
		/// Whether or not the virtual instruction was identified with a legitimate CIL opcode.
		/// </summary>
		public Boolean IsIdentified { get; private set; }

		/// <summary>
		/// The Detect attribute of the detector method that identified this virtual instruction.
		/// </summary>
		public DetectAttribute DetectAttribute { get; private set; }

		/// <summary>
		/// Get the OpCode name (if CIL), or SpecialOpCode name (if special).
		/// </summary>
		public String Name
		{
			get { return (this.HasCILOpCode ? this.OpCode.ToString() : this.SpecialOpCode.ToString()); }
		}

		public Boolean ExpectsMultiple
		{
			get
			{
				return (this.DetectAttribute != null ? this.DetectAttribute.ExpectsMultiple : false);
			}
		}

		public Boolean HasCILOpCode
		{
			get { return !this.DetectAttribute.IsSpecial; }
		}

		/// <summary>
		/// Identified CIL opcode, if any.
		/// </summary>
		public Code OpCode
		{
			get
			{
				if (!this.DetectAttribute.IsSpecial)
					return this.DetectAttribute.OpCode;
				else throw new Exception("VirtualOpCode is special (non-CIL), no corresponding CIL opcode");
			}
		}

		/// <summary>
		/// Identified special opcode, if any.
		/// </summary>
		public SpecialCode SpecialOpCode
		{
			get
			{
				if (this.DetectAttribute.IsSpecial)
					return this.DetectAttribute.SpecialOpCode;
				else throw new Exception("VirtualOpCode is not special (non-CIL), no special opcode");
			}
		}

		public VirtualMachineType VType { get { return this.Parent.VType; } }

		/// <summary>
		/// OpCode pattern seen per dictionary add in the dictionary method.
		/// </summary>
		public static readonly Code[] DictionaryAddPattern = new Code[] {
			Code.Ldloc_0,
			Code.Ldarg_0,
			Code.Ldfld,
			Code.Ldfld,
			Code.Callvirt,
			Code.Ldarg_0,
			Code.Ldfld,
			Code.Ldfld,
			Code.Ldarg_0,
			Code.Ldftn,
			Code.Newobj,
			Code.Newobj,
			Code.Callvirt
		};

		protected VirtualOpCode()
		{
		}

		/// <summary>
		/// Check whether or not this virtual opcode identifies the same as another
		/// virtual opcode.
		/// </summary>
		/// <param name="vopcode">Other virtual opcode to compare against</param>
		/// <returns>true if identifies the same, false if not</returns>
		public Boolean IdentityEquals(VirtualOpCode vopcode)
		{
			if (vopcode == null)
				throw new ArgumentNullException();

			return this.IsIdentified && vopcode.IsIdentified &&
				(this.HasCILOpCode == vopcode.HasCILOpCode && (
					(this.HasCILOpCode && this.OpCode == vopcode.OpCode) ||
					(!this.HasCILOpCode && this.SpecialOpCode == vopcode.SpecialOpCode)
			));
		}

		/// <summary>
		/// Find all virtual instructions given the main virtualization type.
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="virtualizationType">Main virtualization type (class)</param>
		/// <returns>All found virtualization instructions</returns>
		public static IList<VirtualOpCode> FindAllInstructions(EazModule module, TypeDef virtualizationType)
		{
			if (module == null || virtualizationType == null)
				throw new ArgumentNullException();

			// Find dictionary method
			MethodDef dictMethod = null;
			var methods = virtualizationType.Methods;
			foreach(var method in methods)
			{
				if(method.IsPrivate && !method.IsStatic
				&& method.Parameters.Count == 1
				&& method.HasReturnType
				&& method.ReturnType.FullName.StartsWith("System.Collections.Generic.Dictionary"))
				{
					dictMethod = method;
					break;
				}
			}

			if (dictMethod == null)
				throw new Exception("Unable to find dictionary method");

			// Each dictionary addition looks like this:
			//IL_000b: ldloc.0  // [0]
			//IL_000c: ldarg.0  // [0]
			//IL_000d: ldfld class Class33 Class805::class33_0 // 0x0400092c // TypeDef of this class (Class33) is important
			//IL_0012: ldfld class Class487 Class33::class487_162 // 0x040000da // FieldDef of this field (class487_162) is important
			//IL_0017: callvirt instance int32 Class487::method_1() // 0x06000ac3
			//IL_001c: ldarg.0  // [0]
			//IL_001d: ldfld class Class33 Class805::class33_0 // 0x0400092c
			//IL_0022: ldfld class Class487 Class33::class487_162 // 0x040000da
			//IL_0027: ldarg.0  // [0]
			//IL_0028: ldftn instance void Class805::method_281(class Class1) // 0x060015ca
			//IL_002e: newobj instance void Class805/Delegate9::.ctor(object, native int) // 0x060015dc
			//IL_0033: newobj instance void Class805/Class808::.ctor(class Class487, class Class805/Delegate9) // 0x060015e5
			//IL_0038: callvirt instance void class [mscorlib]System.Collections.Generic.Dictionary`2<int32, class Class805/Class808>::Add(!0, !1) // 0x0a000b63

			if (!dictMethod.HasBody || !dictMethod.Body.HasInstructions)
				throw new Exception("Dictionary method has no instructions");

			IList<Instruction[]> subsequences = Helpers.FindOpCodePatterns(dictMethod.Body.Instructions, DictionaryAddPattern);

			// Remove this check later..?
			if (subsequences.Count != 203)
				throw new Exception(String.Format(
					"Number of found subsequences (DictionaryAddPattern) {0} != 203 (expected value)", subsequences.Count));

			List<VirtualOpCode> vInstructions = new List<VirtualOpCode>();

			TypeDef containerType = null;

			// Each series of instructions represents a virtualized instruction
			foreach(var instrs in subsequences)
			{
				VirtualOpCode vInstruction = new VirtualOpCode();

				containerType = ((FieldDef)instrs[2].Operand).FieldType.TryGetTypeDef(); // ldfld
				FieldDef instructionField = ((FieldDef)instrs[3].Operand); // ldfld
				MethodDef delegateMethod = ((MethodDef)instrs[9].Operand); // ldftn

				vInstruction.Parent = module;
				vInstruction.DictionaryMethod = dictMethod;
				vInstruction.ContainerType = containerType;
				vInstruction.InstructionField = instructionField;
				vInstruction.DelegateMethod = delegateMethod;

				vInstructions.Add(vInstruction);
			}

			if (containerType == null)
				throw new Exception("Container type cannot be null");

			// Get the container .ctor method
			MethodDef containerCtor = null;
			foreach(var m in containerType.FindMethods(".ctor"))
			{
				containerCtor = m;
				break;
			}

			if (containerCtor == null)
				throw new Exception("Container .ctor method cannot be found");

			// Each field construction looks like this:
			//IL_0000: ldarg.0  // [0]
			//IL_0001: ldc.i4 1550052828
			//IL_0006: ldc.i4.5
			//IL_0007: newobj instance void Class487::.ctor(int32, valuetype Enum2) // 0x06000ac1
			//IL_000c: stfld class Class487 Class33::class487_47 // 0x04000067

			if (!containerCtor.HasBody || !containerCtor.Body.HasInstructions)
				throw new Exception("Container .ctor method has no instructions");

			if (containerCtor.Body.Instructions.Count < (vInstructions.Count * 5))
				throw new Exception("Container .ctor not large enough for all virtual instructions");

			// 5 instructions per sequence, with 3 trailing instructions
			int subsequenceCount = (containerCtor.Body.Instructions.Count - 3) / 5;

			// This makes a bit of an assumption..
			for(int i = 0; i < subsequenceCount; i++)
			{
				// Grab the subsequence
				List<Instruction> subsequence = new List<Instruction>();
				for (int j = 0; j < 5; j++)
					subsequence.Add(containerCtor.Body.Instructions[(i * 5) + j]);

				if (subsequence[0].OpCode.Code != Code.Ldarg_0)
					throw new Exception("Unexpected opcode in container .ctor subsequence");

				Int32 virtualOpCode = Helpers.GetLdcOperand(subsequence[1]);
				Int32 operandType = Helpers.GetLdcOperand(subsequence[2]);
				FieldDef instructionField = (FieldDef)subsequence[4].Operand;

				// Find virtual instruction with matching instruction field MD token to set
				foreach(var vInstr in vInstructions)
				{
					if(vInstr.InstructionField.MDToken == instructionField.MDToken)
					{
						vInstr.HasVirtualCode = true;
						vInstr.VirtualCode = virtualOpCode;
						vInstr.VirtualOperandType = operandType;
						vInstr.TrySetIdentify(); // Try to identify and set original opcode
						break;
					}
				}
			}

			return vInstructions.ToArray();
		}

		/// <summary>
		/// Get the size of this virtual instruction. Requires that the instruction be identified
		/// with a CIL opcode.
		/// </summary>
		/// <param name="operand">Instruction operand</param>
		/// <returns>Size of instruction when serialized</returns>
		/// <exception cref="System.Exception">Thrown if virtual instruction not identified</exception>
		public Int32 GetSize(Object operand)
		{
			if (!this.IsIdentified)
				throw new Exception("Cannot get a virtual instruction's size if not identified");

			if (this.HasCILOpCode)
			{
				// Instruction instruction = this.OpCode.ToOpCode().ToInstruction();
				Instruction instruction = new Instruction(this.OpCode.ToOpCode(), operand);
				return (instruction.GetSize() - instruction.OpCode.Size) + 4;
			}
			else
			{
				switch(this.SpecialOpCode)
				{
					case SpecialCode.Eaz_Call:
						return 8;
				}

				throw new Exception(String.Format(
					"Cannot get size of virtual instruction: {0}",
					this.Name));
			}
		}

		/// <summary>
		/// Assume the CIL operand type based on the virtual operand type.
		/// </summary>
		/// <returns>CIL operand type</returns>
		public OperandType GetOperandType()
		{
			switch(this.VirtualOperandType)
			{
				case 0: return OperandType.InlineBrTarget;
				case 2: return OperandType.InlineI;
				case 3: return OperandType.InlineI8;
				case 4: return OperandType.InlineMethod;
				case 5: return OperandType.InlineNone;
				case 7: return OperandType.InlineR;
				case 10: return OperandType.InlineString;
				case 13: return OperandType.InlineType;
				case 11: return OperandType.InlineSwitch;
				case 14: return OperandType.InlineVar;
				case 16: return OperandType.ShortInlineI;
				case 17: return OperandType.ShortInlineR;
				case 18: return OperandType.ShortInlineVar;
				default: throw new Exception("Unknown virtual operand type");
			}
		}

		/// <summary>
		/// Try and assume the CIL operand type based on the virtual operand type.
		/// </summary>
		/// <param name="operandType">Operand type</param>
		/// <returns>true if successful, false if not</returns>
		public Boolean TryGetOperandType(out OperandType operandType)
		{
			try
			{
				operandType = this.GetOperandType();
				return true;
			}
			catch(Exception)
			{
				operandType = OperandType.NOT_USED_8;
				return false;
			}
		}
	}
}



================================================
File: src/eazdevirt/Core/Types/BaseTypeDefProvider.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace eazdevirt.Types
{
	public abstract class BaseTypeDefProvider : ITypeDefProvider
	{
		/// <summary>
		/// Underlying TypeDef.
		/// </summary>
		public TypeDef TypeDef { get; private set; }

		public BaseTypeDefProvider(TypeDef typeDef)
		{
			this.TypeDef = typeDef;
		}
	}
}



================================================
File: src/eazdevirt/Core/Types/CryptoStreamDef.cs
================================================
ï»¿using System;
using System.IO;
using System.Linq;
using dnlib.DotNet;

namespace eazdevirt.Types
{
	public class CryptoStreamDef : BaseTypeDefProvider
	{
		public MethodDef CryptMethod { get; private set; }

		public CryptoStreamDef(TypeDef cryptoStream)
			: base(cryptoStream)
		{
			this.Initialize();
		}

		private void Initialize()
		{
			// Find/set crypt method
			this.CryptMethod = this.FindCryptMethod();
			if (this.CryptMethod == null)
				throw new Exception("Unable to find crypt method of CryptoStreamDef");
		}

		/// <summary>
		/// Find the crypt method.
		/// </summary>
		/// <returns>Crypt MethodDef, or null if none found</returns>
		protected MethodDef FindCryptMethod()
		{
			return this.TypeDef.Methods.FirstOrDefault(m =>
			{
				return !m.IsStatic
					&& m.ReturnType.FullName.Equals(typeof(Byte).FullName)
					&& m.Parameters.Count == 3
					&& m.Parameters[1].Type.FullName.Equals(typeof(Byte).FullName)
					&& m.Parameters[2].Type.FullName.Equals(typeof(Int64).FullName);
			});
		}

		public virtual CryptoStreamBase CreateStream(Stream baseStream, Int32 key)
		{
			return new V1.CryptoStreamV1(baseStream, key);
		}

		public static Boolean Is(TypeDef typeDef)
		{
			try
			{
				var cryptoStreamDef = new CryptoStreamDef(typeDef);
				return true;
			}
			catch { return false; }
		}
	}

	public class CryptoStreamDefV2 : CryptoStreamDef
	{
		public Int32 Special { get; private set; }

		public CryptoStreamDefV2(TypeDef cryptoStream)
			: base(cryptoStream)
		{
			this.Initialize();
		}

		private void Initialize()
		{
			// Find/set special
			var special = this.FindSpecial();
			if (!special.HasValue)
				throw new Exception("Unable to find special value of crypt method of CryptoStreamDef");
			else this.Special = special.Value;
		}

		protected Int32? FindSpecial()
		{
			var instrs = this.CryptMethod.Body.Instructions;
			foreach (var instr in instrs)
			{
				if (instr.IsLdcI4())
					return (Int32)instr.Operand;
			}

			return null;
		}

		public override CryptoStreamBase CreateStream(Stream baseStream, Int32 key)
		{
			return new V2.CryptoStreamV2(baseStream, key, this.Special);
		}

		public static Boolean Is(TypeDef typeDef)
		{
			try
			{
				var cryptoStreamDef = new CryptoStreamDefV2(typeDef);
				// Check if the crypt method has a ldc.i4 instruction
				return cryptoStreamDef.CryptMethod.Body.Instructions.FirstOrDefault(
					instr => instr.IsLdcI4()) != null;
			}
			catch { return false; }
		}
	}
}



================================================
File: src/eazdevirt/Core/Types/ITypeDefProvider.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace eazdevirt.Types
{
	public interface ITypeDefProvider
	{
		TypeDef TypeDef { get; }
	}
}



================================================
File: src/eazdevirt/Core/V1/CryptoStreamV1.cs
================================================
ï»¿using System;
using System.IO;

namespace eazdevirt.V1
{
	/// <summary>
	/// Crypto stream used to read resources containing information about
	/// virtualized methods. Requires an integer key.
	/// </summary>
	public class CryptoStreamV1 : CryptoStreamBase
	{
		/// <summary>
		/// </summary>
		/// <param name="baseStream">Base stream</param>
		/// <param name="key">Key</param>
		public CryptoStreamV1(Stream baseStream, Int32 key)
			: base(baseStream, key)
		{
		}

		protected override Byte Crypt(Byte b, Int64 position)
		{
			return (Byte)((Byte)((UInt64)this.Key | (UInt64)position) ^ b);
		}
	}
}



================================================
File: src/eazdevirt/Core/V2/CryptoStreamV2.cs
================================================
ï»¿using System;
using System.IO;

namespace eazdevirt.V2
{
	/// <summary>
	/// Updated crypto stream.
	/// </summary>
	/// <remarks>Eazfuscator started using this sometime between versions 5.0.102.18536 and 5.0.106.3450.</remarks>
	public class CryptoStreamV2 : CryptoStreamBase
	{
		/// <summary>
		/// Special integer. Similar to the key integer, except it is "hardcoded"
		/// into the crypt method instead of belonging to the stream instance.
		/// </summary>
		/// <remarks>
		/// Seems to be a constant, but as I have only tested protecting programs on
		/// one machine and with one installation of Eazfuscator, the constant may be
		/// generated via machine info or be specific to this installation.
		/// </remarks>
		public Int32 Special { get; private set; }

		/// <summary>
		/// </summary>
		/// <param name="baseStream">Base stream</param>
		/// <param name="key">Key</param>
		/// <param name="special">Special int, hardcoded in the crypt method</param>
		public CryptoStreamV2(Stream baseStream, Int32 key, Int32 special)
			: base(baseStream, key)
		{
			this.Special = special;
		}

		protected override Byte Crypt(Byte b, Int64 position)
		{
			return (Byte)((Byte)(this.Key ^ this.Special ^ (Int32)((UInt32)position)) ^ b);
		}
	}
}



================================================
File: src/eazdevirt/Detection/IInstructionDetector.cs
================================================
ï»¿using System;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;

namespace eazdevirt.Detection
{
	public interface IInstructionDetector
	{
		Code Identify(VirtualOpCode instruction);
		DetectAttribute IdentifyFull(VirtualOpCode instruction);
		Boolean TryIdentify(VirtualOpCode instruction, out Code code);
	}
}



================================================
File: src/eazdevirt/Detection/InstructionDetectorBase.cs
================================================
ï»¿using System;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;

namespace eazdevirt.Detection
{
	public abstract class InstructionDetectorBase : IInstructionDetector
	{
		/// <summary>
		/// Identify a virtual instruction.
		/// </summary>
		/// <param name="instruction">Virtual instruction</param>
		/// <returns>Detected CIL opcode</returns>
		/// <exception cref="eazdevirt.OriginalOpcodeUnknownException">
		/// Thrown if original CIL opcode is unknown.
		/// </exception>
		public abstract Code Identify(VirtualOpCode instruction);

		/// <summary>
		/// Try to identify a virtual instruction.
		/// </summary>
		/// <param name="instruction">Virtual instruction</param>
		/// <param name="code">Detected CIL opcode if successful</param>
		/// <returns>true if successful, false if not</returns>
		public virtual Boolean TryIdentify(VirtualOpCode instruction, out Code code)
		{
			try
			{
				code = this.Identify(instruction);
				return true;
			}
			catch (OriginalOpcodeUnknownException)
			{
				code = Code.UNKNOWN2;
				return false;
			}
		}

		/// <summary>
		/// Identify a virtual instruction, getting the entire attribute of the detection method.
		/// </summary>
		/// <param name="instruction">Virtual instruction</param>
		/// <returns>DetectAttribute of detection method if successful</returns>
		/// <exception cref="eazdevirt.OriginalOpcodeUnknownException">
		/// Thrown if original CIL opcode is unknown.
		/// </exception>
		public abstract DetectAttribute IdentifyFull(VirtualOpCode instruction);

		/// <summary>
		/// Try to identify a virtual instruction, getting the entire attribute of the detection method.
		/// </summary>
		/// <param name="instruction">Virtual instruction</param>
		/// <param name="attribute">DetectAttribute of detection method if successful</param>
		/// <returns>true if successful, false if not</returns>
		public virtual Boolean TryIdentifyFull(VirtualOpCode instruction, out DetectAttribute attribute)
		{
			try
			{
				attribute = this.IdentifyFull(instruction);
				return true;
			}
			catch (OriginalOpcodeUnknownException)
			{
				attribute = null;
				return false;
			}
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Arg.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		/// <summary>
		/// OpCode pattern seen in the Starg_* delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Starg = new Code[] {
			Code.Ldarg_0, Code.Ldfld, Code.Ldloc_0, Code.Callvirt, Code.Ldelem
		};

		/// <summary>
		/// OpCode pattern seen at the "tail" of the Starg_* delegate methods.
		/// </summary>
		/// <remarks>
		/// Without this tail check, multiple delegate methods were being associated
		/// with both Starg and Starg_S
		/// </remarks>
		private static readonly Code[] Pattern_Tail_Starg = new Code[] {
			Code.Callvirt, Code.Pop, Code.Ret
		};

		[Detect(Code.Starg)]
		public static Boolean Is_Starg(this VirtualOpCode ins)
		{
			var sub = ins.Find(Pattern_Starg);
			return sub != null && sub[3].Operand is MethodDef
				&& ((MethodDef)sub[3].Operand).ReturnType.FullName.Equals("System.UInt16")
				&& ins.Matches(Pattern_Tail_Starg);
		}

		[Detect(Code.Starg_S)]
		public static Boolean Is_Starg_S(this VirtualOpCode ins)
		{
			var sub = ins.Find(Pattern_Starg);
			return sub != null && sub[3].Operand is MethodDef
				&& ((MethodDef)sub[3].Operand).ReturnType.FullName.Equals("System.Byte")
				&& ins.Matches(Pattern_Tail_Starg);
		}

		/// <summary>
		/// OpCode pattern seen in the Ldarg_C delegate methods (Ldarg_0, Ldarg_1, Ldarg_2, Ldarg_3).
		/// </summary>
		private static readonly Code[] Pattern_Ldarg_C = new Code[] {
			Code.Ldarg_0, Code.Ldarg_0, Code.Ldfld, Code.Ldc_I4, Code.Ldelem, // Code.Ldc_I4 changes depending on _C
			Code.Callvirt, Code.Call, Code.Ret
		};

		private static Boolean Is_Ldarg_C(VirtualOpCode ins, Code code)
		{
			// Ldarg_C delegates will reference the arguments field in their Ldfld, which sets them apart from
			// other very similar delegates
			return ins.Matches(ins.ModifyPattern(Pattern_Ldarg_C, Code.Ldc_I4, code))
				&& ((FieldDef)ins.DelegateMethod.Body.Instructions[2].Operand).MDToken == ins.VType.ArgumentsField.MDToken;
		}

		[Detect(Code.Ldarg_0)]
		public static Boolean Is_Ldarg_0(this VirtualOpCode ins)
		{
			return Is_Ldarg_C(ins, Code.Ldc_I4_0);
		}

		[Detect(Code.Ldarg_1)]
		public static Boolean Is_Ldarg_1(this VirtualOpCode ins)
		{
			return Is_Ldarg_C(ins, Code.Ldc_I4_1);
		}

		[Detect(Code.Ldarg_2)]
		public static Boolean Is_Ldarg_2(this VirtualOpCode ins)
		{
			return Is_Ldarg_C(ins, Code.Ldc_I4_2);
		}

		[Detect(Code.Ldarg_3)]
		public static Boolean Is_Ldarg_3(this VirtualOpCode ins)
		{
			return Is_Ldarg_C(ins, Code.Ldc_I4_3);
		}

		/// <summary>
		/// OpCode pattern seen in the Ldarga, Ldarga_S delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Ldarga = new Code[] {
			Code.Ldloc_1, Code.Ldarg_0, Code.Ldfld, Code.Ldloc_0, Code.Callvirt,
			Code.Ldelem, Code.Callvirt, Code.Ldloc_1, Code.Call, Code.Ret
		};

		[Detect(Code.Ldarga)]
		/// <remarks>Unsure</remarks>
		public static Boolean Is_Ldarga(this VirtualOpCode ins)
		{
			var sub = ins.Find(Pattern_Ldarga);
			return sub != null
				&& ((FieldDef)sub[2].Operand).MDToken == ins.VType.ArgumentsField.MDToken
				&& ((MethodDef)sub[4].Operand).ReturnType.FullName.Equals("System.UInt16");
		}

		[Detect(Code.Ldarga_S)]
		/// <remarks>Unsure</remarks>
		public static Boolean Is_Ldarga_S(this VirtualOpCode ins)
		{
			var sub = ins.Find(Pattern_Ldarga);
			return sub != null
				&& ((FieldDef)sub[2].Operand).MDToken == ins.VType.ArgumentsField.MDToken
				&& ((MethodDef)sub[4].Operand).ReturnType.FullName.Equals("System.Byte");
		}

		/// <summary>
		/// OpCode pattern seen in the Ldarg, Ldarg_S delegate methods.
		/// </summary>
		/// <remarks>There are other delegate methods that match this exact pattern.</remarks>
		private static readonly Code[] Pattern_Ldarg = new Code[] {
			Code.Ldarg_1, Code.Castclass, Code.Stloc_0, Code.Ldarg_0, Code.Ldarg_0,
			Code.Ldfld, Code.Ldloc_0, Code.Callvirt, Code.Ldelem, Code.Callvirt,
			Code.Call, Code.Ret
		};

		[Detect(Code.Ldarg)]
		public static Boolean Is_Ldarg(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(Pattern_Ldarg)
				&& ((MethodDef)ins.DelegateMethod.Body.Instructions[7].Operand)
				   .ReturnType.FullName.Equals("System.UInt16")
				&& ((FieldDef)ins.DelegateMethod.Body.Instructions[5].Operand)
				   .MDToken == ins.VType.ArgumentsField.MDToken;
		}

		[Detect(Code.Ldarg_S)]
		public static Boolean Is_Ldarg_S(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(Pattern_Ldarg)
				&& ((MethodDef)ins.DelegateMethod.Body.Instructions[7].Operand)
				   .ReturnType.FullName.Equals("System.Byte")
				&& ((FieldDef)ins.DelegateMethod.Body.Instructions[5].Operand)
				   .MDToken == ins.VType.ArgumentsField.MDToken;
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Bitwise.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		[Detect(Code.And)]
		public static Boolean Is_And(this VirtualOpCode ins)
		{
			return ins.MatchesIndirect(
				new Code[] { Code.Ldloc_S, Code.Ldloc_S, Code.And, Code.Callvirt, Code.Ldloc_0, Code.Ret }
			);
		}

		[Detect(Code.Xor)]
		public static Boolean Is_Xor(this VirtualOpCode ins)
		{
			return ins.MatchesIndirect(
				new Code[] { Code.Ldloc_S, Code.Ldloc_S, Code.Xor, Code.Callvirt, Code.Ldloc_0, Code.Ret }
			);
		}

		[Detect(Code.Shl)]
		public static Boolean Is_Shl(this VirtualOpCode ins)
		{
			return ins.MatchesIndirect(
				new Code[] { Code.Ldloc_S, Code.Ldloc_S, Code.Ldc_I4_S, Code.And, Code.Shl, Code.Stloc_S,
				Code.Newobj, Code.Stloc_0, Code.Ldloc_0, Code.Ldloc_S, Code.Callvirt, Code.Ldloc_0, Code.Ret }
			);
		}

		/// <summary>
		/// OpCode pattern seen in the Shr_* helper method.
		/// </summary>
		private static readonly Code[] Pattern_Shr = new Code[] {
			Code.Ldc_I4_S, Code.And, Code.Shr, Code.Callvirt, Code.Ldloc_0, Code.Ret
		};

		[Detect(Code.Shr)]
		public static Boolean Is_Shr(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean(true, Pattern_Shr);
		}

		[Detect(Code.Shr_Un)]
		public static Boolean Is_Shr_Un(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean(false, Pattern_Shr);
		}

		[Detect(Code.Or)]
		public static Boolean Is_Or(this VirtualOpCode ins)
		{
			return ins.MatchesIndirect(new Code[] {
				Code.Ldloc_S, Code.Ldloc_S, Code.Or, Code.Callvirt, Code.Ldloc_0, Code.Ret
			});
		}

		[Detect(Code.Not)]
		public static Boolean Is_Not(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesIndirect(new Code[] {
				Code.Ldloc_1, Code.Ldloc_S, Code.Not, Code.Callvirt, Code.Ldloc_1, Code.Ret
			});
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Br.cs
================================================
ï»¿using System;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		public static Boolean _Jumps(VirtualOpCode ins)
		{
			return ins.DelegateMethod.Calls().Any((called) =>
			{
				MethodDef method = called as MethodDef;
				if (method == null)
					return false;

				return method.MatchesEntire(new Code[] {
					Code.Ldarg_0, Code.Ldarg_1, Code.Newobj, Code.Stfld, Code.Ret
				}) && ((IMethod)method.Body.Instructions[2].Operand).FullName.Contains("System.Nullable");
			});
		}

		[Detect(Code.Br)]
		public static Boolean Is_Br(this VirtualOpCode ins)
		{
			MethodDef called;
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_1, Code.Castclass, Code.Callvirt, Code.Stloc_0, Code.Ldarg_0,
				Code.Ldloc_0, Code.Call, Code.Ret
			}) && (called = (MethodDef)ins.DelegateMethod.Calls().ToArray()[1]).MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Ldarg_1, Code.Newobj, Code.Stfld, Code.Ret
			}) && ((IMethod)called.Body.Instructions[2].Operand).FullName.Contains("System.Nullable");

		}

		[Detect(Code.Brfalse)]
		public static Boolean Is_Brfalse(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Ldloc_0, Code.Callvirt, Code.Ldnull, Code.Ceq, Code.Stloc_1, Code.Br_S
			});
		}

		[Detect(Code.Brtrue)]
		public static Boolean Is_Brtrue(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Ldloc_0, Code.Callvirt, Code.Ldnull, Code.Ceq, Code.Ldc_I4_0,
				Code.Ceq, Code.Stloc_1, Code.Br_S
			});
			//var sub = ins.DelegateMethod.Find(new Code[] {
			//	Code.Ldloc_0, Code.Castclass, Code.Callvirt, Code.Ldsfld, Code.Call,
			//	Code.Stloc_1, Code.Br_S
			//});
			//return sub != null
			//	&& ((IMethod)sub[4].Operand).FullName.Contains("System.UIntPtr::op_Inequality");
		}

		/// <summary>
		/// OpCode pattern seen in the Beq, Bne_Un helper methods.
		/// </summary>
		private static readonly Code[] Pattern_Br_Equality_49 = new Code[] {
			Code.Ldloc_1, Code.Callvirt, Code.Call, Code.Ldarg_1, Code.Callvirt,
			Code.Call, Code.Ceq, Code.Stloc_0, Code.Ldloc_0, Code.Ret
		};

		/// <summary>
		/// Pattern_Br_Equality_49 updated for 5.0.
		/// </summary>
		private static readonly Code[] Pattern_Br_Equality_50 = new Code[] {
			Code.Ceq, Code.Stloc_0, Code.Br_S, Code.Ldarg_0, Code.Castclass, Code.Stloc_S,
			Code.Ldarg_1, Code.Castclass, Code.Stloc_S, Code.Ldloc_S, Code.Ldloc_S,
			Code.Callvirt, Code.Stloc_0, Code.Ldloc_0, Code.Ret
		};

		/// <summary>
		/// OpCode pattern seen in certain branch delegate methods.
		/// </summary>
		/// <remarks>
		/// Looks like:
		///
		/// StackType type1 = this.Pop();
		/// StackType type2 = this.Pop();
		/// if(Compare(type1, type2))
		///		this.Position = Operand;
		/// </remarks>
		private static readonly Code[] Pattern_Br_True = new Code[] {
			Code.Ldarg_0, Code.Call, Code.Stloc_0, Code.Ldarg_0, Code.Call, Code.Stloc_1,
			Code.Ldloc_1, Code.Ldloc_0, Code.Call, Code.Brfalse_S
		};

		/// <summary>
		/// OpCode pattern seen in certain branch delegate methods.
		/// </summary>
		/// <remarks>
		/// Looks like:
		///
		/// StackType type1 = this.Pop();
		/// StackType type2 = this.Pop();
		/// if(!Compare(type1, type2))
		///		this.Position = Operand;
		/// </remarks>
		private static readonly Code[] Pattern_Br_False = new Code[] {
			Code.Ldarg_0, Code.Call, Code.Stloc_0, Code.Ldarg_0, Code.Call, Code.Stloc_1,
			Code.Ldloc_1, Code.Ldloc_0, Code.Call, Code.Brtrue_S
		};

		private static Boolean _Is_Br_Equality(VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesIndirect(Pattern_Br_Equality_49)
				|| ins.DelegateMethod.MatchesIndirect(Pattern_Br_Equality_50);
		}

		[Detect(Code.Beq)]
		public static Boolean Is_Beq(this VirtualOpCode ins)
		{
			return ins.Matches(Pattern_Br_True) && _Is_Br_Equality(ins) && _Jumps(ins);
		}

		[Detect(Code.Bne_Un)]
		public static Boolean Is_Bne_Un(this VirtualOpCode ins)
		{
			return ins.Matches(Pattern_Br_False) && _Is_Br_Equality(ins) && _Jumps(ins);
		}

		/// <summary>
		/// OpCode pattern seen in the Blt helper method.
		/// </summary>
		private static readonly Code[] Pattern_LessThan = new Code[] {
			Code.Ldarg_0, Code.Castclass, Code.Callvirt, Code.Ldarg_1, Code.Castclass,
			Code.Callvirt, Code.Clt, Code.Stloc_0, Code.Ldloc_0, Code.Ret
		};

		/// <summary>
		/// OpCode pattern seen in the Bgt helper method.
		/// </summary>
		private static readonly Code[] Pattern_GreaterThan = new Code[] {
			Code.Ldloc_S, Code.Ldloc_S, Code.Cgt, Code.Stloc_0, Code.Br_S, Code.Ldc_I4_0,
			Code.Stloc_0, Code.Ldloc_0, Code.Ret
		};

		/// <summary>
		/// OpCode pattern seen in the first Ble_Un helper method.
		/// Called Pattern_Cgt_Un because of the comparison type.
		/// </summary>
		private static readonly Code[] Pattern_Ble_Un = new Code[] {
			Code.Ldloc_S, Code.Ldloc_S, Code.Cgt, Code.Stloc_0, Code.Br_S,
			Code.Ldc_I4_0, Code.Stloc_0, Code.Ldloc_0, Code.Ret
		};

		/// <summary>
		/// OpCode pattern seen in Ble, Ble_Un delegate methods. Probably others.
		/// </summary>
		private static readonly Code[] Pattern_Ble = new Code[] {
			Code.Ldloc_1, Code.Ldloc_0, Code.Call, Code.Ldc_I4_0, Code.Ceq, Code.Stloc_2, Code.Br_S,
			Code.Ldloc_1, Code.Ldloc_0, Code.Call, Code.Ldc_I4_0, Code.Ceq, Code.Stloc_2
		};

		[Detect(Code.Blt)]
		public static Boolean Is_Blt(this VirtualOpCode ins)
		{
			return ins.Matches(Pattern_Br_True) && ins.MatchesIndirect(Pattern_LessThan);
		}

		/// <summary>
		/// OpCode pattern seen in Blt_Un helper method. Probably used in others.
		/// </summary>
		/// <remarks>Seen near the end of the method</remarks>
		private static readonly Code[] Pattern_Blt_Un = new Code[] {
			Code.Ldloc_S, Code.Ldloc_S, Code.Blt_S, Code.Ldloc_S, Code.Call, Code.Brtrue_S,
			Code.Ldloc_S, Code.Call, Code.Br_S
		};

		[Detect(Code.Blt_Un)]
		public static Boolean Is_Blt_Un(this VirtualOpCode ins)
		{
			return ins.Matches(Pattern_Br_True) && ins.MatchesIndirect(Pattern_Blt_Un);
		}

		[Detect(Code.Bgt)]
		public static Boolean Is_Bgt(this VirtualOpCode ins)
		{
			return ins.Matches(Pattern_Br_True) && ins.MatchesIndirect(Pattern_GreaterThan);
		}

		[Detect(Code.Bgt_Un)]
		public static Boolean Is_Bgt_Un(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Call, Code.Brfalse_S, Code.Ldarg_1, Code.Castclass
			}) && ins.MatchesIndirect(new Code[] {
				Code.Ldloc_2, Code.Ldloc_3, Code.Bgt_S, Code.Ldloc_2, Code.Call, Code.Brtrue_S,
				Code.Ldloc_3, Code.Call, Code.Br_S
			});
		}

		[Detect(Code.Ble)]
		public static Boolean Is_Ble(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Call, Code.Ldc_I4_0, Code.Ceq, Code.Stloc_2
			}) && ins.MatchesIndirect(Pattern_Ble_Un);
		}

		[Detect(Code.Ble_Un)]
		public static Boolean Is_Ble_Un(this VirtualOpCode ins)
		{
			var sub = ins.DelegateMethod.Find(Pattern_Ble);
			return sub != null && ((MethodDef)sub[2].Operand).Matches(Pattern_Ble_Un);
		}

		[Detect(Code.Bge)]
		public static Boolean Is_Bge(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Call, Code.Brtrue_S, Code.Ldarg_1, Code.Castclass
			}) && ins.MatchesIndirect(new Code[] {
				Code.Ldarg_0, Code.Castclass, Code.Callvirt, Code.Ldarg_1, Code.Castclass,
				Code.Callvirt, Code.Clt, Code.Stloc_0, Code.Ldloc_0, Code.Ret
			});
		}

		[Detect(Code.Bge_Un)]
		public static Boolean Is_Bge_Un(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Call, Code.Brtrue_S, Code.Ldarg_1, Code.Castclass
			}) && ins.MatchesIndirect(Pattern_Clt_Un);
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Conv.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		/// <summary>
		/// OpCode pattern seen at the end of Conv_* helper methods.
		/// Also seen in Conv_*_Un delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Conv_Helper_Tail = new Code[] {
			Code.Ldarg_0, Code.Newobj, Code.Stloc_3, Code.Ldloc_3, Code.Ldloc_2,
			Code.Callvirt, Code.Ldloc_3, Code.Call, Code.Ret
		};

		private static Code[] Conv_Helper_Pattern(params Code[] opcodes)
		{
			var list = new List<Code>(opcodes);
			list.AddRange(Pattern_Conv_Helper_Tail);
			return list.ToArray();
		}

		private static Boolean _Is_Conv_I(VirtualOpCode ins, Boolean ovf, IList<Code> helperPattern)
		{
			Code[] delegatePattern = (ovf ?
				new Code[] { Code.Ldarg_0, Code.Ldc_I4_1, Code.Call, Code.Ret } :
				new Code[] { Code.Ldarg_0, Code.Ldc_I4_0, Code.Call, Code.Ret });

			return ins.DelegateMethod.MatchesEntire(delegatePattern)
				&& ins.DelegateMethod.MatchesIndirect(helperPattern);
		}

		/// <summary>
		/// OpCode pattern seen in Conv_I, Conv_Ovf_I helper methods.
		/// </summary>
		private static readonly Code[] Pattern_Conv_I = Conv_Helper_Pattern(Code.Conv_I8, Code.Call);

		[Detect(Code.Conv_I)]
		public static Boolean Is_Conv_I(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Pattern_Conv_I);
		}

		[Detect(Code.Conv_Ovf_I)]
		public static Boolean Is_Conv_Ovf_I(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Pattern_Conv_I);
		}

		/// <summary>
		/// OpCode pattern seen in Conv_I1, Conv_Ovf_I1 helper methods.
		/// </summary>
		private static readonly Code[] Pattern_Conv_I1 = Conv_Helper_Pattern(Code.Conv_I1, Code.Stloc_2);

		[Detect(Code.Conv_I1)]
		public static Boolean Is_Conv_I1(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Pattern_Conv_I1);
		}

		[Detect(Code.Conv_Ovf_I1)]
		public static Boolean Is_Conv_Ovf_I1(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Pattern_Conv_I1);
		}

		/// <summary>
		/// OpCode pattern seen in Conv_I2, Conv_Ovf_I2 helper methods.
		/// </summary>
		private static readonly Code[] Pattern_Conv_I2 = Conv_Helper_Pattern(Code.Conv_I2, Code.Stloc_2);

		[Detect(Code.Conv_I2)]
		public static Boolean Is_Conv_I2(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Pattern_Conv_I2);
		}

		[Detect(Code.Conv_Ovf_I2)]
		public static Boolean Is_Conv_Ovf_I2(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Pattern_Conv_I2);
		}

		/// <summary>
		/// OpCode pattern seen in Conv_I8, Conv_Ovf_I8 helper methods.
		/// </summary>
		private static readonly Code[] Pattern_Conv_I8 = Conv_Helper_Pattern(Code.Conv_I8, Code.Stloc_2);

		[Detect(Code.Conv_I8)]
		public static Boolean Is_Conv_I8(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Pattern_Conv_I8);
		}

		[Detect(Code.Conv_Ovf_I8)]
		public static Boolean Is_Conv_Ovf_I8(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Pattern_Conv_I8);
		}

		[Detect(Code.Conv_Ovf_I_Un)]
		public static Boolean Is_Conv_Ovf_I_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_I8, Code.Call));
		}

		[Detect(Code.Conv_Ovf_I1_Un)]
		public static Boolean Is_Conv_Ovf_I1_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_I1, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_I2_Un)]
		public static Boolean Is_Conv_Ovf_I2_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_I2, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_I4_Un)]
		public static Boolean Is_Conv_Ovf_I4_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_I4, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_I8_Un)]
		public static Boolean Is_Conv_Ovf_I8_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_I8, Code.Stloc_2));
		}

		/// <summary>
		/// OpCode pattern seen in Conv_Ovf_U helper method and Conv_Ovf_U_Un delegate method.
		/// </summary>
		private static readonly Code[] Pattern_Conv_Ovf_U = Conv_Helper_Pattern(Code.Conv_U8, Code.Call);

		[Detect(Code.Conv_U)]
		public static Boolean Is_Conv_U(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Pattern_Conv_Ovf_U);
		}

		[Detect(Code.Conv_Ovf_U)]
		public static Boolean Is_Conv_Ovf_U(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Pattern_Conv_Ovf_U);
		}

		[Detect(Code.Conv_Ovf_U_Un)]
		public static Boolean Is_Conv_Ovf_U_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Pattern_Conv_Ovf_U);
		}

		[Detect(Code.Conv_U1)]
		public static Boolean Is_Conv_U1(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Conv_Helper_Pattern(Code.Conv_U1, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_U1)]
		public static Boolean Is_Conv_Ovf_U1(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Conv_Helper_Pattern(Code.Conv_U1, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_U1_Un)]
		public static Boolean Is_Conv_Ovf_U1_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_U1, Code.Stloc_2));
		}

		[Detect(Code.Conv_U2)]
		public static Boolean Is_Conv_U2(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Conv_Helper_Pattern(Code.Conv_U2, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_U2)]
		public static Boolean Is_Conv_Ovf_U2(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Conv_Helper_Pattern(Code.Conv_U2, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_U2_Un)]
		public static Boolean Is_Conv_Ovf_U2_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_U2, Code.Stloc_2));
		}

		[Detect(Code.Conv_U4)]
		public static Boolean Is_Conv_Ovf_U4(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Conv_Helper_Pattern(Code.Conv_U4, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_U4)]
		public static Boolean Is_Conv_U4(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Conv_Helper_Pattern(Code.Conv_U4, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_U4_Un)]
		public static Boolean Is_Conv_Ovf_U4_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_U4, Code.Stloc_2));
		}

		[Detect(Code.Conv_U8)]
		public static Boolean Is_Conv_U8(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, false, Conv_Helper_Pattern(Code.Conv_U8, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_U8)]
		public static Boolean Is_Conv_Ovf_U8(this VirtualOpCode ins)
		{
			return _Is_Conv_I(ins, true, Conv_Helper_Pattern(Code.Conv_U8, Code.Stloc_2));
		}

		[Detect(Code.Conv_Ovf_U8_Un)]
		public static Boolean Is_Conv_Ovf_U8_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_Ovf_U8, Code.Stloc_2));
		}

		[Detect(Code.Conv_R_Un)]
		public static Boolean Is_Conv_R_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(Code.Conv_R_Un, Code.Conv_R8, Code.Stloc_2));
		}

		/// <summary>
		/// OpCode pattern seen at the end of Conv_R4 delegate method.
		/// </summary>
		private static readonly Code[] Pattern_Conv_R4_Helper_Tail = new Code[] {
			Code.Ldarg_0, Code.Newobj, Code.Stloc_3, Code.Ldloc_3, Code.Ldloc_2,
			Code.Conv_R8, Code.Callvirt, Code.Ldloc_3, Code.Call, Code.Ret
		};

		private static Code[] Conv_R4_Helper_Pattern(params Code[] opcodes)
		{
			var list = new List<Code>(opcodes);
			list.AddRange(Pattern_Conv_R4_Helper_Tail);
			return list.ToArray();
		}

		[Detect(Code.Conv_R4)]
		public static Boolean Is_Conv_R4(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_R4_Helper_Pattern(Code.Conv_R4, Code.Stloc_2));
		}

		[Detect(Code.Conv_R8)]
		public static Boolean Is_Conv_R8(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(Conv_Helper_Pattern(
				Code.Conv_R8, Code.Stloc_2, Code.Br_S, Code.Ldloc_0, Code.Castclass,
				Code.Callvirt, Code.Stloc_2
			));
		}

		/// <summary>
		/// OpCode pattern seen in Conv_I4, Conv_Ovf_I4 helper methods.
		/// </summary>
		private static readonly Code[] Pattern_Conv_I4 = new Code[] {
			Code.Ldloc_0, Code.Castclass, Code.Callvirt, Code.Conv_Ovf_I4,
			Code.Stloc_2, Code.Br_S, Code.Ldloc_0, Code.Castclass, Code.Callvirt,
			Code.Conv_I4, Code.Stloc_2
		};

		[Detect(Code.Conv_I4)]
		public static Boolean Is_Conv_I4(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Ldc_I4_0, Code.Call, Code.Ret
			}) && ins.DelegateMethod.MatchesIndirect(Pattern_Conv_I4);
		}

		[Detect(Code.Conv_Ovf_I4)]
		public static Boolean Is_Conv_Ovf_I4(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Ldc_I4_1, Code.Call, Code.Ret
			}) && ins.DelegateMethod.MatchesIndirect(Pattern_Conv_I4);
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Elem.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		/// <summary>
		/// OpCode pattern seen in Ldelem, Ldelem_* helper methods.
		/// </summary>
		private static readonly Code[] Pattern_Ldelem = new Code[] {
			Code.Castclass, Code.Stloc_1, Code.Ldarg_0, Code.Ldloc_1, Code.Ldloc_0, Code.Callvirt
		};

		private static Boolean _Is_Ldelem(VirtualOpCode ins)
		{
			MethodDef method;
			IList<Instruction> pattern;
			var calls = ins.DelegateMethod.Calls().ToArray();
			return calls.Length > 0
				&& (method = calls.Last() as MethodDef) != null
				&& (pattern = method.Find(Pattern_Ldelem)) != null
				&& ((ITypeDefOrRef)pattern[0].Operand).FullName.Contains("System.Array");
		}

		private static Boolean _Is_Ldelem_T(VirtualOpCode ins, String typeName)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Ldtoken, Code.Call, Code.Call, Code.Ret
			}) && ((ITypeDefOrRef)ins.DelegateMethod.Body.Instructions[1].Operand)
				  .FullName.Equals(typeName)
				&& _Is_Ldelem(ins);
		}

		[Detect(Code.Ldelem)]
		public static Boolean Is_Ldelem(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_1, Code.Castclass, Code.Callvirt, Code.Stloc_0, Code.Ldarg_0, Code.Ldloc_0,
				Code.Call, Code.Stloc_1, Code.Ldarg_0, Code.Ldloc_1, Code.Call, Code.Ret
			}) && _Is_Ldelem(ins);
		}

		[Detect(Code.Ldelem_I1)]
		public static Boolean Is_Ldelem_I1(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.SByte");
		}

		[Detect(Code.Ldelem_I2)]
		public static Boolean Is_Ldelem_I2(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.Int16");
		}

		[Detect(Code.Ldelem_I4)]
		public static Boolean Is_Ldelem_I4(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.Int32");
		}

		[Detect(Code.Ldelem_I8)]
		public static Boolean Is_Ldelem_I8(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.Int64");
		}

		[Detect(Code.Ldelem_U1)]
		public static Boolean Is_Ldelem_U1(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.Byte");
		}

		[Detect(Code.Ldelem_U2)]
		public static Boolean Is_Ldelem_U2(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.UInt16");
		}

		[Detect(Code.Ldelem_U4)]
		public static Boolean Is_Ldelem_U4(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.UInt32");
		}

		[Detect(Code.Ldelem_R4)]
		public static Boolean Is_Ldelem_R4(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.Single");
		}

		[Detect(Code.Ldelem_R8)]
		public static Boolean Is_Ldelem_R8(this VirtualOpCode ins)
		{
			return _Is_Ldelem_T(ins, "System.Double");
		}

		[Detect(Code.Ldelem_Ref)]
		public static Boolean Is_Ldelem_Ref(this VirtualOpCode ins)
		{
			// Is exact same as Ldelem_I except for the field reference
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Ldsfld, Code.Call, Code.Ret
			}) && _Is_Ldelem(ins) && !ins.Is_Ldelem_I();
		}

		[Detect(Code.Ldelem_I)]
		public static Boolean Is_Ldelem_I(this VirtualOpCode ins)
		{
			var sub = ins.Find(new Code[] {
				Code.Ldarg_0, Code.Ldsfld, Code.Call, Code.Ret
			});
			return sub != null
				&& ((IField)sub[1].Operand).MDToken == ins.VType.GetTypeField("System.IntPtr").MDToken
				&& _Is_Ldelem(ins);
		}

		[Detect(Code.Ldelema)]
		public static Boolean Is_Ldelema(this VirtualOpCode ins)
		{
			// Note: Another way to detect may be by looking at Newobj TypeDef, as
			// it seems specific to the Ldelema instruction type
			// (has 3 fields: Array, long, Type)
			return ins.Matches(new Code[] {
				Code.Ldarg_0, Code.Newobj, Code.Stloc_0,
				Code.Ldloc_0, Code.Ldloc_S, Code.Callvirt,
				Code.Ldloc_0, Code.Ldloc_2, Code.Callvirt,
				Code.Ldloc_0, Code.Ldloc_3, Code.Callvirt,
				Code.Ldloc_0, Code.Call, Code.Ret
			});
		}

		/// <summary>
		/// OpCode pattern seen in Stelem, Stelem_* helper methods.
		/// </summary>
		private static readonly Code[] Pattern_Stelem = new Code[] {
			Code.Castclass, Code.Stloc_3, Code.Ldarg_0, Code.Ldarg_1, Code.Ldloc_1,
			Code.Ldloc_2, Code.Ldloc_3, Code.Call, Code.Ret
		};

		[Detect(Code.Stelem)]
		public static Boolean Is_Stelem(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_1, Code.Castclass, Code.Callvirt, Code.Stloc_0, Code.Ldarg_0,
				Code.Ldloc_0, Code.Call, Code.Stloc_1, Code.Ldarg_0, Code.Ldloc_1,
				Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(Pattern_Stelem);
		}

		[Detect(Code.Stelem_I)]
		public static Boolean Is_Stelem_I(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_0, Code.Ldsfld, Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(Pattern_Stelem)
			&& ((FieldDef)ins.DelegateMethod.Body.Instructions[1].Operand)
			   .MDToken == ins.VType.GetTypeField("System.IntPtr").MDToken;
		}

		[Detect(Code.Stelem_Ref)]
		public static Boolean Is_Stelem_Ref(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_0, Code.Ldsfld, Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(Pattern_Stelem)
			&& !Is_Stelem_I(ins);
		}

		private static Boolean _Is_Stelem_IC(VirtualOpCode ins, String typeName)
		{
			ITypeDefOrRef type = null;
			var sub = ins.DelegateMethod.Find(
				Code.Ldarg_0, Code.Ldtoken, Code.Call, Code.Ldloc_0, Code.Ldloc_1,
				Code.Ldloc_2, Code.Call, Code.Ret
			);
			return sub != null
				&& (type = sub[1].Operand as ITypeDefOrRef) != null
				&& type.FullName.Equals(typeName);
		}

		[Detect(Code.Stelem_I1)]
		public static Boolean Is_Stelem_I1(this VirtualOpCode ins)
		{
			return _Is_Stelem_IC(ins, "System.SByte");
		}

		[Detect(Code.Stelem_I2)]
		public static Boolean Is_Stelem_I2(this VirtualOpCode ins)
		{
			return _Is_Stelem_IC(ins, "System.Int16");
		}

		[Detect(Code.Stelem_I4)]
		public static Boolean Is_Stelem_I4(this VirtualOpCode ins)
		{
			return _Is_Stelem_IC(ins, "System.Int32");
		}

		[Detect(Code.Stelem_I8)]
		public static Boolean Is_Stelem_I8(this VirtualOpCode ins)
		{
			return _Is_Stelem_IC(ins, "System.Int64");
		}

		private static Boolean _Is_Stelem_RC(VirtualOpCode ins, String typeName)
		{
			ITypeDefOrRef type = null;
			var body = ins.DelegateMethod.Body.Instructions;
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_0, Code.Ldtoken, Code.Call, Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(Pattern_Stelem)
			&& (type = body[1].Operand as ITypeDefOrRef) != null
			&& type.FullName.Equals(typeName);
		}

		[Detect(Code.Stelem_R4)]
		public static Boolean Is_Stelem_R4(this VirtualOpCode ins)
		{
			return _Is_Stelem_RC(ins, "System.Single");
		}

		[Detect(Code.Stelem_R8)]
		public static Boolean Is_Stelem_R8(this VirtualOpCode ins)
		{
			return _Is_Stelem_RC(ins, "System.Double");
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Ind.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		[Detect(Code.Ldind_I)]
		public static Boolean Is_Ldind_I(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_0, Code.Ldsfld, Code.Call, Code.Ret
			) && ((FieldDef)ins.DelegateMethod.Body.Instructions[1].Operand)
				 .MDToken == ins.VType.GetTypeField("System.IntPtr").MDToken
			&& ins.DelegateMethod.MatchesIndirect(
				Code.Call, Code.Callvirt, Code.Ldarg_1, Code.Call, Code.Call, Code.Ret
			);
		}

		[Detect(Code.Ldind_Ref)]
		public static Boolean Is_Ldind_Ref(this VirtualOpCode ins)
		{
			// Same as Ldind_I, but different static field. Just check if NOT Ldind_I.
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_0, Code.Ldsfld, Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(
				Code.Call, Code.Callvirt, Code.Ldarg_1, Code.Call, Code.Call, Code.Ret
			) && !Is_Ldind_I(ins);
		}

		public static Boolean _Is_Ldind_IC(VirtualOpCode ins, String tokenTypeName)
		{
			TypeRef tokenType = null;
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_0, Code.Ldtoken, Code.Call, Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(
				Code.Ldarg_0, Code.Call, Code.Stloc_0, Code.Ldarg_0, Code.Ldarg_0, Code.Ldloc_0,
				Code.Call, Code.Callvirt, Code.Ldarg_1, Code.Call, Code.Call, Code.Ret
			) && (tokenType = ins.DelegateMethod.Body.Instructions[1].Operand as TypeRef) != null
			&& tokenType.FullName.Equals(tokenTypeName);
		}

		[Detect(Code.Ldind_I1)]
		public static Boolean Is_Ldind_I1(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.SByte");
		}

		[Detect(Code.Ldind_I2)]
		public static Boolean Is_Ldind_I2(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.Int16");
		}

		[Detect(Code.Ldind_I4)]
		public static Boolean Is_Ldind_I4(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.Int32");
		}

		[Detect(Code.Ldind_I8)]
		public static Boolean Is_Ldind_I8(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.Int64");
		}

		// Conflict
		[Detect(Code.Ldind_R4)]
		public static Boolean Is_Ldind_R4(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.Single");
		}

		// Conflict
		[Detect(Code.Ldind_R8)]
		public static Boolean Is_Ldind_R8(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.Double");
		}

		[Detect(Code.Ldind_U1)]
		public static Boolean Is_Ldind_U1(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.Byte");
		}

		[Detect(Code.Ldind_U2)]
		public static Boolean Is_Ldind_U2(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.UInt16");
		}

		[Detect(Code.Ldind_U4)]
		public static Boolean Is_Ldind_U4(this VirtualOpCode ins)
		{
			return _Is_Ldind_IC(ins, "System.UInt32");
		}

		/// <remarks>
		/// All Stind_* delegate methods follow this pattern. They have different delegate
		/// methods, but their delegate methods all just call the same method with no params.
		///
		/// One way to attack this: Devirtualize all as Stind_I, then go back through the
		/// method afterwards, following the types on the stack. When a Stind_* instruction
		/// is reached, the value (on top of the stack) is the type being set.
		/// </remarks>
		private static Boolean _Is_Stind(VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(Code.Ldarg_0, Code.Call, Code.Ret)
				&& ins.DelegateMethod.MatchesIndirect(
				Code.Ldarg_0, Code.Call, Code.Stloc_0, Code.Ldarg_0, Code.Call,
				Code.Stloc_1, Code.Ldarg_0, Code.Ldloc_1, Code.Ldloc_0, Code.Call,
				Code.Ret
			);
		}

		[Detect(Code.Stind_I, ExpectsMultiple = true)]
		public static Boolean Is_Stind(VirtualOpCode ins)
		{
			// Consider all Stind_* instructions as Stind_I (for now?)
			return _Is_Stind(ins);
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Ldc.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		/// <summary>
		/// OpCode pattern seen in the Ldc_I4_C delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Ldc_I4_C = new Code[] {
			Code.Ldarg_0, Code.Newobj, Code.Stloc_0, Code.Ldloc_0, Code.Ldc_I4, // Code.Ldc_I4 changes depending on _C
			Code.Callvirt, Code.Ldloc_0, Code.Call, Code.Ret
		};

		private static Boolean Is_Ldc_I4_C(VirtualOpCode ins, Code code)
		{
			return ins.MatchesEntire(ins.ModifyPattern(Pattern_Ldc_I4_C, Code.Ldc_I4, code));
		}

		[Detect(Code.Ldc_I4_0)]
		public static Boolean Is_Ldc_I4_0(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_0);
		}

		[Detect(Code.Ldc_I4_1)]
		public static Boolean Is_Ldc_I4_1(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_1);
		}

		[Detect(Code.Ldc_I4_2)]
		public static Boolean Is_Ldc_I4_2(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_2);
		}

		[Detect(Code.Ldc_I4_3)]
		public static Boolean Is_Ldc_I4_3(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_3);
		}

		[Detect(Code.Ldc_I4_4)]
		public static Boolean Is_Ldc_I4_4(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_4);
		}

		[Detect(Code.Ldc_I4_5)]
		public static Boolean Is_Ldc_I4_5(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_5);
		}

		[Detect(Code.Ldc_I4_6)]
		public static Boolean Is_Ldc_I4_6(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_6);
		}

		[Detect(Code.Ldc_I4_7)]
		public static Boolean Is_Ldc_I4_7(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_7);
		}

		[Detect(Code.Ldc_I4_8)]
		public static Boolean Is_Ldc_I4_8(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_8);
		}

		[Detect(Code.Ldc_I4_M1)]
		public static Boolean Is_Ldc_I4_M1(this VirtualOpCode ins)
		{
			return Is_Ldc_I4_C(ins, Code.Ldc_I4_M1);
		}

		/// <summary>
		/// OpCode pattern seen in the Ldc_I4, Ldc_I4_S, Ldc_I8, Ldc_R4, Ldc_R8 delegate methods.
		/// </summary>
		public static readonly Code[] Pattern_Ldc = new Code[] {
			Code.Ldarg_0, Code.Ldarg_1, Code.Call, Code.Ret
		};

		public static Boolean _Is_Ldc(VirtualOpCode ins, OperandType expectedOperandType)
		{
			OperandType operandType;
			return ins.MatchesEntire(Pattern_Ldc)
				&& ins.TryGetOperandType(out operandType)
				&& operandType == expectedOperandType;
		}

		[Detect(Code.Ldc_I4)]
		public static Boolean Is_Ldc_I4(this VirtualOpCode ins)
		{
			return _Is_Ldc(ins, OperandType.InlineI);
		}

		[Detect(Code.Ldc_I4_S)]
		public static Boolean Is_Ldc_I4_S(this VirtualOpCode ins)
		{
			return _Is_Ldc(ins, OperandType.ShortInlineI);
		}

		[Detect(Code.Ldc_I8)]
		public static Boolean Is_Ldc_I8(this VirtualOpCode ins)
		{
			return _Is_Ldc(ins, OperandType.InlineI8);
		}

		[Detect(Code.Ldc_R4)]
		public static Boolean Is_Ldc_R4(this VirtualOpCode ins)
		{
			return _Is_Ldc(ins, OperandType.ShortInlineR);
		}

		[Detect(Code.Ldc_R8)]
		public static Boolean Is_Ldc_R8(this VirtualOpCode ins)
		{
			return _Is_Ldc(ins, OperandType.InlineR);
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Loc.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		/// <summary>
		/// OpCode pattern seen in the Ldloc_C delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Ldloc_C = new Code[] {
			Code.Ldarg_0, Code.Ldarg_0, Code.Ldfld, Code.Ldc_I4, Code.Ldelem, // Code.Ldc_I4 changes depending on _C
			Code.Callvirt, Code.Call, Code.Ret
		};

		private static Boolean Is_Ldloc_C(VirtualOpCode ins, Code code)
		{
			return ins.MatchesEntire(ins.ModifyPattern(Pattern_Ldloc_C, Code.Ldc_I4, code))
				&& ((FieldDef)ins.DelegateMethod.Body.Instructions[2].Operand).MDToken == ins.VType.LocalsField.MDToken;
		}

		[Detect(Code.Ldloc_0)]
		public static Boolean Is_Ldloc_0(this VirtualOpCode ins)
		{
			return Is_Ldloc_C(ins, Code.Ldc_I4_0);
		}

		[Detect(Code.Ldloc_1)]
		public static Boolean Is_Ldloc_1(this VirtualOpCode ins)
		{
			return Is_Ldloc_C(ins, Code.Ldc_I4_1);
		}

		[Detect(Code.Ldloc_2)]
		public static Boolean Is_Ldloc_2(this VirtualOpCode ins)
		{
			return Is_Ldloc_C(ins, Code.Ldc_I4_2);
		}

		[Detect(Code.Ldloc_3)]
		public static Boolean Is_Ldloc_3(this VirtualOpCode ins)
		{
			return Is_Ldloc_C(ins, Code.Ldc_I4_3);
		}

		/// <summary>
		/// OpCode pattern seen in the Ldloc, Ldloc_S delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Ldloc = new Code[] {
			Code.Ldarg_1, Code.Castclass, Code.Stloc_0, Code.Ldarg_0, Code.Ldarg_0,
			Code.Ldfld, Code.Ldloc_0, Code.Callvirt, Code.Ldelem, Code.Callvirt,
			Code.Call, Code.Ret
		};

		[Detect(Code.Ldloc)]
		public static Boolean Is_Ldloc(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(Pattern_Ldloc)
				&& ((MethodDef)ins.DelegateMethod.Body.Instructions[7].Operand)
				   .ReturnType.FullName.Equals("System.UInt16")
				&& ((FieldDef)ins.DelegateMethod.Body.Instructions[5].Operand)
				   .MDToken == ins.VType.LocalsField.MDToken;
		}

		[Detect(Code.Ldloc_S)]
		public static Boolean Is_Ldloc_S(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(Pattern_Ldloc)
				&& ((MethodDef)ins.DelegateMethod.Body.Instructions[7].Operand)
				   .ReturnType.FullName.Equals("System.Byte")
				&& ((FieldDef)ins.DelegateMethod.Body.Instructions[5].Operand)
				   .MDToken == ins.VType.LocalsField.MDToken;
		}

		/// <summary>
		/// OpCode pattern matching the Ldloca, Ldloca_S delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Ldloca = new Code[] {
			// The Castclass operand will be UInt16 stacktype for Ldloca,
			// and Byte stacktype for Ldloca_S
			Code.Ldarg_1, Code.Castclass, Code.Stloc_0, Code.Ldarg_0, Code.Newobj,
			Code.Stloc_1, Code.Ldloc_1, Code.Ldloc_0, Code.Callvirt, Code.Callvirt,
			Code.Ldloc_1, Code.Call, Code.Ret
		};

		private static Boolean _Is_Ldloca(VirtualOpCode ins, String typeName)
		{
			TypeDef stackType;
			return ins.DelegateMethod.MatchesEntire(Pattern_Ldloca)
				&& (stackType = ins.DelegateMethod.Body.Instructions[1].Operand as TypeDef) != null
				&& StackTypeHelper.GetUnderlyingType(stackType).FullName.Equals(typeName);
		}

		[Detect(Code.Ldloca)]
		public static Boolean Is_Ldloca(this VirtualOpCode ins)
		{
			return _Is_Ldloca(ins, "System.UInt16");
		}

		[Detect(Code.Ldloca_S)]
		public static Boolean Is_Ldloca_S(this VirtualOpCode ins)
		{
			return _Is_Ldloca(ins, "System.Byte");
		}

		/// <summary>
		/// OpCode pattern seen in the Stloc_C delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Stloc_C = new Code[] {
			Code.Ldarg_0, Code.Ldc_I4, Code.Call, Code.Ret // Code.Ldc_I4 changes depending on _C
		};

		/// <summary>
		/// OpCode pattern seen in the Stloc_C helper method.
		/// </summary>
		/// <remarks>Found at the head of the method body</remarks>
		private static readonly Code[] Pattern_Helper_Stloc_C = new Code[] {
			Code.Ldarg_0, Code.Call, Code.Stloc_0, Code.Ldloc_0, Code.Isinst,
		};

		private static Boolean Is_Stloc_C(VirtualOpCode ins, Code code)
		{
			return ins.MatchesEntire(ins.ModifyPattern(Pattern_Stloc_C, Code.Ldc_I4, code))
				&& Helpers.FindOpCodePatterns( // Check called method against Pattern_Helper_Stloc_C
					 ((MethodDef)ins.DelegateMethod.Body.Instructions[2].Operand).Body.Instructions,
					 Pattern_Helper_Stloc_C
				   ).Count > 0;
		}

		[Detect(Code.Stloc_0)]
		public static Boolean Is_Stloc_0(this VirtualOpCode ins)
		{
			return Is_Stloc_C(ins, Code.Ldc_I4_0);
		}

		[Detect(Code.Stloc_1)]
		public static Boolean Is_Stloc_1(this VirtualOpCode ins)
		{
			return Is_Stloc_C(ins, Code.Ldc_I4_1);
		}

		[Detect(Code.Stloc_2)]
		public static Boolean Is_Stloc_2(this VirtualOpCode ins)
		{
			return Is_Stloc_C(ins, Code.Ldc_I4_2);
		}

		[Detect(Code.Stloc_3)]
		public static Boolean Is_Stloc_3(this VirtualOpCode ins)
		{
			return Is_Stloc_C(ins, Code.Ldc_I4_3);
		}

		/// <summary>
		/// OpCode pattern seen in the Stloc, Stloc_S delegate methods.
		/// </summary>
		private static readonly Code[] Pattern_Stloc = new Code[] {
			Code.Ldarg_1, Code.Castclass, Code.Stloc_0, Code.Ldarg_0, Code.Ldloc_0,
			Code.Callvirt, Code.Call, Code.Ret
		};

		private static Boolean _Is_Stloc(VirtualOpCode ins, String indexTypeName)
		{
			return ins.MatchesEntire(Pattern_Stloc)
				&& ((MethodDef)ins.DelegateMethod.Body.Instructions[5].Operand)
				   .ReturnType.FullName.Equals(indexTypeName)
				&& Helpers.FindOpCodePatterns( // Check called method against Pattern_Helper_Stloc_C
					 ((MethodDef)ins.DelegateMethod.Body.Instructions[6].Operand).Body.Instructions,
					 Pattern_Helper_Stloc_C
				   ).Count > 0;
		}

		[Detect(Code.Stloc)]
		public static Boolean Is_Stloc(this VirtualOpCode ins)
		{
			return _Is_Stloc(ins, "System.UInt16");
		}

		[Detect(Code.Stloc_S)]
		public static Boolean Is_Stloc_S(this VirtualOpCode ins)
		{
			return _Is_Stloc(ins, "System.Byte");
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Math.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		/// <summary>
		/// OpCode pattern seen in the Sub_* helper method.
		/// </summary>
		private static readonly Code[] Pattern_Sub = new Code[] {
			Code.Ldloc_0, Code.Ldloc_1, Code.Sub, Code.Stloc_2, Code.Newobj, Code.Stloc_3,
			Code.Ldloc_3, Code.Ldloc_2, Code.Callvirt, Code.Ldloc_3, Code.Ret
		};

		[Detect(Code.Sub)]
		public static Boolean Is_Sub(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(false, false, Pattern_Sub);
		}

		[Detect(Code.Sub_Ovf)]
		public static Boolean Is_Sub_Ovf(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(true, false, Pattern_Sub);
		}

		[Detect(Code.Sub_Ovf_Un)]
		public static Boolean Is_Sub_Ovf_Un(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(true, true, Pattern_Sub);
		}

		/// <summary>
		/// OpCode pattern seen in the Add_* helper method.
		/// </summary>
		private static readonly Code[] Pattern_Add = new Code[] {
			Code.Ldloc_0, Code.Ldloc_1, Code.Add, Code.Stloc_2, Code.Newobj, Code.Stloc_3,
			Code.Ldloc_3, Code.Ldloc_2, Code.Callvirt, Code.Ldloc_3, Code.Ret
		};

		[Detect(Code.Add)]
		public static Boolean Is_Add(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(false, false, Pattern_Add);
		}

		[Detect(Code.Add_Ovf)]
		public static Boolean Is_Add_Ovf(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(true, false, Pattern_Add);
		}

		[Detect(Code.Add_Ovf_Un)]
		public static Boolean Is_Add_Ovf_Un(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(true, true, Pattern_Add);
		}

		/// <summary>
		/// OpCode pattern seen in the Mul_* helper method.
		/// </summary>
		private static readonly Code[] Pattern_Mul = new Code[] {
			Code.Ldloc_0, Code.Ldloc_1, Code.Mul, Code.Stloc_2, Code.Newobj, Code.Stloc_3,
			Code.Ldloc_3, Code.Ldloc_2, Code.Callvirt, Code.Ldloc_3, Code.Ret
		};

		[Detect(Code.Mul)]
		public static Boolean Is_Mul(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(false, false, Pattern_Mul);
		}

		[Detect(Code.Mul_Ovf)]
		public static Boolean Is_Mul_Ovf(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(true, false, Pattern_Mul);
		}

		[Detect(Code.Mul_Ovf_Un)]
		public static Boolean Is_Mul_Ovf_Un(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean2(true, true, Pattern_Mul);
		}

		[Detect(Code.Neg)]
		public static Boolean Is_Neg(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesIndirect(
				Code.Ldloc_0, Code.Ldloc_S, Code.Neg, Code.Callvirt, Code.Ldloc_0, Code.Ret
			);
		}

		/// <summary>
		/// OpCode pattern seen in the Rem_* helper method.
		/// </summary>
		private static readonly Code[] Pattern_Rem = new Code[] {
			Code.Ldloc_S, Code.Ldloc_S, Code.Rem, Code.Callvirt, Code.Ldloc_0, Code.Ret
		};

		[Detect(Code.Rem)]
		public static Boolean Is_Rem(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean(false, Pattern_Rem);
		}

		[Detect(Code.Rem_Un)]
		public static Boolean Is_Rem_Un(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean(true, Pattern_Rem);
		}

		/// <summary>
		/// OpCode pattern seen in the Div_* helper method.
		/// </summary>
		private static readonly Code[] Pattern_Div = new Code[] {
			Code.Ldloc_S, Code.Ldloc_S, Code.Div, Code.Callvirt, Code.Ldloc_0, Code.Ret
		};

		[Detect(Code.Div)]
		public static Boolean Is_Div(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean(false, Pattern_Div);
		}

		[Detect(Code.Div_Un)]
		public static Boolean Is_Div_Un(this VirtualOpCode ins)
		{
			return ins.MatchesIndirectWithBoolean(true, Pattern_Div);
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Misc.cs
================================================
ï»¿using System;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		[Detect(Code.Box)]
		public static Boolean Is_Box(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Ldarg_1, Code.Castclass, Code.Callvirt, Code.Stloc_2, Code.Ldarg_0,
				Code.Ldloc_2, Code.Call, Code.Stloc_0, Code.Ldarg_0, Code.Call
			});
		}

		[Detect(Code.Call)]
		public static Boolean Is_Call(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_1, Code.Castclass, Code.Stloc_0, Code.Ldarg_0, Code.Ldloc_0,
				Code.Callvirt, Code.Call, Code.Stloc_1, Code.Ldarg_0, Code.Ldloc_1,
				Code.Ldc_I4_0, Code.Call, Code.Ret
			});
		}

		[Detect(Code.Callvirt)]
		public static Boolean Is_Callvirt(this VirtualOpCode ins)
		{
			MethodDef method;
			var sub = ins.Find(new Code[] {
				Code.Ldarg_1, Code.Castclass, Code.Stloc_S, Code.Ldarg_0, Code.Ldloc_S,
				Code.Callvirt, Code.Call, Code.Stloc_0, Code.Ldarg_0, Code.Ldfld, Code.Brfalse_S
			});
			return sub != null
				&& (method = sub[6].Operand as MethodDef) != null
				&& method.HasReturnType && method.ReturnType.FullName.Equals("System.Reflection.MethodBase");
		}

		[Detect(Code.Castclass)]
		public static Boolean Is_Castclass(this VirtualOpCode ins)
		{
			var sub = ins.DelegateMethod.Find(
				Code.Call, Code.Brtrue_S, Code.Newobj, Code.Throw, Code.Ldarg_0, Code.Ldloc_2,
				Code.Call, Code.Ret
			);
			return sub != null
				&& ((IMethod)sub[2].Operand).DeclaringType.FullName.Contains("System.InvalidCastException");
		}

		private static Boolean _Is_Ceq_50(VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(
				Code.Ldloc_2, Code.Ldloc_1, Code.Ldloc_0, Code.Call, Code.Brtrue_S,
				Code.Ldc_I4_0, Code.Br_S, Code.Ldc_I4_1
			) && ins.DelegateMethod.MatchesIndirect(
				// Helper changed in 5.0
				Code.Ceq, Code.Stloc_0, Code.Br_S, Code.Ldarg_0, Code.Castclass,
				Code.Stloc_S, Code.Ldarg_1, Code.Castclass, Code.Stloc_S,
				Code.Ldloc_S, Code.Ldloc_S, Code.Callvirt, Code.Stloc_0, Code.Ldloc_0,
				Code.Ret
			);
		}

		private static Boolean _Is_Ceq_49(VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(
				Code.Ldloc_2, Code.Ldloc_1, Code.Ldloc_0, Code.Call, Code.Brtrue_S,
				Code.Ldc_I4_0, Code.Br_S, Code.Ldc_I4_1
			) && ins.DelegateMethod.MatchesIndirect(
				Code.Ldloc_1, Code.Callvirt, Code.Call, Code.Ldarg_1, Code.Callvirt, Code.Call,
				Code.Ceq, Code.Stloc_0, Code.Ldloc_0, Code.Ret
			);
		}

		[Detect(Code.Ceq)]
		public static Boolean Is_Ceq(this VirtualOpCode ins)
		{
			return _Is_Ceq_49(ins) || _Is_Ceq_50(ins);
		}

		/// <summary>
		/// OpCode pattern seen in the Less-Than helper method.
		/// Used in: Clt_Un, Blt, Bge_Un (negated)
		/// </summary>
		private static readonly Code[] Pattern_Clt_Un = new Code[] {
			Code.Ldloc_S, Code.Ldloc_S, Code.Blt_S,
			Code.Ldloc_S, Code.Call, Code.Brtrue_S, // System.Double::IsNaN(float64)
			Code.Ldloc_S, Code.Call, Code.Br_S      // System.Double::IsNaN(float64)
		};

		[Detect(Code.Clt)]
		public static Boolean Is_Clt(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(
				Code.Call, Code.Brtrue_S, Code.Ldc_I4_0, Code.Br_S, Code.Ldc_I4_1,
				Code.Callvirt, Code.Ldloc_2, Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(
				// Helper method used elsewhere?
				Code.Ldarg_0, Code.Castclass, Code.Callvirt, Code.Ldarg_1, Code.Castclass,
				Code.Callvirt, Code.Clt, Code.Stloc_0, Code.Ldloc_0, Code.Ret
			);
		}

		[Detect(Code.Clt_Un)]
		public static Boolean Is_Clt_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(new Code[] {
				Code.Call, Code.Brtrue_S, Code.Ldc_I4_0, Code.Br_S, Code.Ldc_I4_1,
				Code.Callvirt, Code.Ldloc_2, Code.Call, Code.Ret
			}) && ins.DelegateMethod.MatchesIndirect(Pattern_Clt_Un);
		}

		/// <summary>
		/// OpCode pattern seen in the Greater-Than helper method.
		/// Used in: Cgt_Un
		/// </summary>
		/// <remarks>Greater-than for Double, Int32, Int64 but not-equal for other?</remarks>
		private static readonly Code[] Pattern_Cgt_Un = new Code[] {
			Code.Ldarg_0, Code.Castclass, Code.Callvirt, Code.Ldarg_1,
			Code.Castclass, Code.Callvirt, Code.Cgt_Un, Code.Stloc_0
		};

		[Detect(Code.Cgt)]
		/// <remarks>Unsure</remarks>
		public static Boolean Is_Cgt(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(
				Code.Call, Code.Brtrue_S, Code.Ldc_I4_0, Code.Br_S, Code.Ldc_I4_1,
				Code.Callvirt, Code.Ldloc_2, Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(
				Code.Ldloc_S, Code.Ldloc_S, Code.Cgt, Code.Stloc_0, Code.Br_S,
				Code.Ldc_I4_0, Code.Stloc_0, Code.Ldloc_0, Code.Ret
			);
		}

		[Detect(Code.Cgt_Un)]
		public static Boolean Is_Cgt_Un(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(new Code[] {
				Code.Call, Code.Brtrue_S, Code.Ldc_I4_0, Code.Br_S, Code.Ldc_I4_1,
				Code.Callvirt, Code.Ldloc_2, Code.Call, Code.Ret
			}) && ins.DelegateMethod.MatchesIndirect(Pattern_Cgt_Un);
		}

		[Detect(Code.Ckfinite)]
		public static Boolean Is_Ckfinite(this VirtualOpCode ins)
		{
			var sub = ins.Find(new Code[] {
				Code.Ldloc_0, Code.Callvirt, Code.Call, Code.Brtrue_S,
				Code.Ldloc_0, Code.Callvirt, Code.Call, Code.Brfalse_S,
				Code.Ldstr, Code.Newobj, Code.Throw
			});

			return sub != null
				&& ((IMethod)sub[2].Operand).FullName.Contains("System.Double::IsNaN")
				&& ((IMethod)sub[6].Operand).FullName.Contains("System.Double::IsInfinity");
		}

		[Detect(Code.Dup)]
		public static Boolean Is_Dup(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_0, Code.Call, Code.Stloc_0, Code.Ldloc_0, Code.Callvirt,
				Code.Stloc_1, Code.Ldarg_0, Code.Ldloc_0, Code.Call, Code.Ldarg_0,
				Code.Ldloc_1, Code.Call, Code.Ret
			);
		}

		[Detect(Code.Endfinally)]
		public static Boolean Is_Endfinally(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_0, Code.Call, Code.Ret
			) && ins.DelegateMethod.MatchesIndirect(
				Code.Ldarg_0, Code.Ldfld, Code.Callvirt, Code.Ldarg_0, Code.Ldloc_0,
				Code.Callvirt, Code.Call, Code.Ret
			);
		}

		[Detect(Code.Isinst)]
		public static Boolean Is_Isinst(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(
				Code.Call, Code.Brfalse_S, Code.Ldarg_0, Code.Ldloc_2, Code.Call, Code.Ret,
				Code.Ldarg_0, Code.Newobj, Code.Call, Code.Ret
			);
		}

		[Detect(Code.Jmp)]
		public static Boolean Is_Jmp(this VirtualOpCode ins)
		{
			IMethod called;
			var sub = ins.DelegateMethod.Find(
				Code.Callvirt, Code.Call, Code.Stloc_1, Code.Ldarg_0, Code.Ldfld, Code.Stloc_2
			);
			return sub != null
				&& (called = sub[1].Operand as IMethod) != null
				&& called.FullName.Contains("System.Reflection.MethodBase");
		}

		/// <summary>
		/// OpCode pattern seen in the Throw, Rethrow helper methods.
		/// </summary>
		public static readonly Code[] Pattern_Throw = new Code[] {
			Code.Ldarg_0, Code.Isinst, Code.Stloc_0, Code.Ldloc_0,
			Code.Call, Code.Ldarg_0, Code.Call, Code.Ret
		};

		public static Boolean _Is_Throw(VirtualOpCode ins, MethodDef helper)
		{
			var matches = Helpers.FindOpCodePatterns(helper.Body.Instructions, Pattern_Throw);
			return matches.Count == 1 && matches[0].Length == Pattern_Throw.Length;
		}

		[Detect(Code.Throw)]
		public static Boolean Is_Throw(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Call, Code.Stloc_0, Code.Ldloc_0,
				Code.Callvirt, Code.Call, Code.Ret
			}) && _Is_Throw(ins, ((MethodDef)ins.DelegateMethod.Body.Instructions[5].Operand));
		}

		[Detect(Code.Rethrow)]
		public static Boolean Is_Rethrow(this VirtualOpCode ins)
		{
			var sub = ins.Find(new Code[] {
				Code.Newobj, Code.Throw, Code.Ldarg_0, Code.Ldarg_0, Code.Ldfld,
				Code.Callvirt, Code.Callvirt, Code.Stfld, Code.Ldarg_0, Code.Ldfld,
				Code.Call, Code.Ret
			});
			return sub != null && _Is_Throw(ins, ((MethodDef)sub[10].Operand));
		}

		[Detect(Code.Ldfld)]
		public static Boolean Is_Ldfld(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Ldarg_0, Code.Ldloc_1, Code.Ldloc_3, Code.Callvirt, Code.Ldloc_1,
				Code.Callvirt, Code.Call, Code.Call, Code.Ret
			}) && ins.DelegateMethod.Calls().Any((called) =>
			{
				return called.FullName.Contains("System.Reflection.FieldInfo::GetValue");
			});
		}

		[Detect(Code.Ldflda)]
		public static Boolean Is_Ldflda(this VirtualOpCode ins)
		{
			MethodDef method;
			var sub = ins.DelegateMethod.Find(new Code[] {
				Code.Ldloc_1, Code.Ldloc_S, Code.Callvirt, Code.Ldloc_1, Code.Ldloc_2,
				Code.Callvirt, Code.Ldloc_1, Code.Call, Code.Ret
			});
			return sub != null
				&& (method = (sub[2].Operand as MethodDef)) != null
				&& method.Parameters.Count == 2
				&& method.Parameters[1].Type.FullName.Contains("System.Reflection.FieldInfo");
		}

		[Detect(Code.Ldftn)]
		public static Boolean Is_Ldftn(this VirtualOpCode ins)
		{
			MethodDef called = null;
			var sub = ins.DelegateMethod.Find(new Code[] {
				Code.Ldarg_0, Code.Newobj, Code.Stloc_2, Code.Ldloc_2, Code.Ldloc_1,
				Code.Callvirt, Code.Ldloc_2, Code.Call, Code.Ret
			});
			return sub != null
				&& (called = ((MethodDef)sub[5].Operand)) != null
				&& called.Parameters.Count >= 2
				&& called.Parameters[1].Type.FullName.Equals("System.Reflection.MethodBase");
		}

		[Detect(Code.Ldlen)]
		public static Boolean Is_Ldlen(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Call, Code.Callvirt, Code.Castclass, Code.Stloc_0, Code.Ldarg_0,
				Code.Newobj, Code.Stloc_1, Code.Ldloc_1, Code.Ldloc_0, Code.Callvirt, Code.Callvirt,
				Code.Ldloc_1, Code.Call, Code.Ret
			}) && ((IMethod)ins.DelegateMethod.Body.Instructions[10].Operand)
				  .FullName.Contains("System.Array::get_Length");
		}

		[Detect(Code.Ldsfld)]
		public static Boolean Is_Ldsfld(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(new Code[] {
				Code.Ldarg_0, Code.Ldloc_1, Code.Ldnull, Code.Callvirt, Code.Ldloc_1,
				Code.Callvirt, Code.Call, Code.Call, Code.Ret
			}) && ins.DelegateMethod.Calls().Any((called) =>
			{
				return called.FullName.Contains("System.Reflection.FieldInfo::GetValue");
			});
		}

		[Detect(Code.Ldsflda)]
		public static Boolean Is_Ldsflda(this VirtualOpCode ins)
		{
			MethodDef method;
			var sub = ins.DelegateMethod.Find(new Code[] {
				Code.Ldarg_0, Code.Newobj, Code.Stloc_2, Code.Ldloc_2, Code.Ldloc_1,
				Code.Callvirt, Code.Ldloc_2, Code.Call, Code.Ret
			});
			return sub != null
				&& (method = (sub[5].Operand as MethodDef)) != null
				&& method.Parameters.Count == 2
				&& method.Parameters[1].Type.FullName.Contains("System.Reflection.FieldInfo");
		}

		[Detect(Code.Ldobj)]
		public static Boolean Is_Ldobj(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(new Code[] {
				Code.Ldarg_1, Code.Castclass, Code.Callvirt, Code.Stloc_0, Code.Ldarg_0,
				Code.Ldloc_0, Code.Call, Code.Stloc_1, Code.Ldarg_0, Code.Ldloc_1,
				Code.Call, Code.Ret
			}) && ins.DelegateMethod.MatchesIndirect(new Code[] {
				Code.Ldarg_0, Code.Call, Code.Stloc_0, Code.Ldarg_0, Code.Ldarg_0,
				Code.Ldloc_0, Code.Call, Code.Callvirt, Code.Ldarg_1, Code.Call,
				Code.Call, Code.Ret
			}) && ((MethodDef)ins.DelegateMethod.Body.Instructions[2].Operand)
				  .ReturnType.FullName.Equals("System.Int32")
			&& ((MethodDef)ins.DelegateMethod.Body.Instructions[6].Operand)
				  .ReturnType.FullName.Equals("System.Type");
		}

		[Detect(Code.Ldstr)]
		public static Boolean Is_Ldstr(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_1, Code.Castclass, Code.Callvirt, Code.Stloc_0, Code.Ldarg_0,
				Code.Ldloc_0, Code.Call, Code.Stloc_1, Code.Ldarg_0, Code.Newobj,
				Code.Stloc_2, Code.Ldloc_2, Code.Ldloc_1, Code.Callvirt, Code.Ldloc_2,
				Code.Call, Code.Ret
			}) && ((MethodDef)ins.DelegateMethod.Body.Instructions[6].Operand)
				  .ReturnType.FullName.Equals("System.String");
		}

		[Detect(Code.Ldnull)]
		public static Boolean Is_Ldnull(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Newobj, Code.Call, Code.Ret
			});
		}

		[Detect(Code.Ldtoken)]
		public static Boolean Is_Ldtoken(this VirtualOpCode ins)
		{
			// Checks delegate method tail
			// Could also check: System.Reflection.FieldInfo::get_Type/Field/MethodHandle(),
			// there are 1 of each of these calls
			return ins.DelegateMethod.Matches(
				Code.Ldarg_0, Code.Newobj, Code.Stloc_3, Code.Ldloc_3, Code.Ldloc_1,
				Code.Callvirt, Code.Ldloc_3, Code.Call, Code.Ret
			);
		}

		[Detect(Code.Ldvirtftn)]
		public static Boolean Is_Ldvirtftn(this VirtualOpCode ins)
		{
			MethodDef called = null;
			var sub = ins.DelegateMethod.Find(new Code[] {
				Code.Ldarg_0, Code.Newobj, Code.Stloc_S, Code.Ldloc_S, Code.Ldloc_3,
				Code.Callvirt, Code.Ldloc_S, Code.Call, Code.Ret
			});
			return sub != null
				&& (called = ((MethodDef)sub[5].Operand)) != null
				&& called.Parameters.Count >= 2
				&& called.Parameters[1].Type.FullName.Equals("System.Reflection.MethodBase");
		}

		[Detect(Code.Leave)]
		public static Boolean Is_Leave(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_1, Code.Castclass, Code.Callvirt, Code.Stloc_0, Code.Ldarg_0,
				Code.Ldnull, Code.Ldloc_0, Code.Call, Code.Ret
			);
		}

		[Detect(Code.Newarr)]
		public static Boolean Is_Newarr(this VirtualOpCode ins)
		{
			var sub = ins.DelegateMethod.Find(
				Code.Ldloc_S, Code.Ldloc_1, Code.Call, Code.Stloc_S
			);
			return sub != null
				&& ((IMethod)sub[2].Operand).FullName.Contains("System.Array::CreateInstance");
		}

		[Detect(Code.Newobj)]
		public static Boolean Is_Newobj(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Ldarg_0, Code.Ldloc_2, Code.Ldnull, Code.Ldloc_3, Code.Ldc_I4_0,
				Code.Call, Code.Stloc_S, Code.Leave_S
			});
		}

		[Detect(Code.Nop, ExpectsMultiple = true)]
		public static Boolean Is_Nop(this VirtualOpCode ins)
		{
			// Three virtual opcodes match this. One of them makes sense to be Nop,
			// unsure what the other two are (maybe Endfault, Endfilter).
			OperandType operandType;
			return ins.DelegateMethod.MatchesEntire(Code.Ret)
				&& ins.TryGetOperandType(out operandType)
				&& operandType == OperandType.InlineNone;
		}

		[Detect(Code.Pop)]
		public static Boolean Is_Pop(this VirtualOpCode ins)
		{
			MethodDef method = null;
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Call, Code.Pop, Code.Ret
			}) && (method = ins.DelegateMethod.Body.Instructions[1].Operand as MethodDef) != null
			   && method.MatchesEntire(new Code[] {
				   Code.Ldarg_0, Code.Ldfld, Code.Callvirt, Code.Ret
			   });
		}

		[Detect(Code.Ret)]
		public static Boolean Is_Ret(this VirtualOpCode ins)
		{
			return ins.MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Call, Code.Ret
			}) && ((MethodDef)ins.DelegateMethod.Body.Instructions[1].Operand).MatchesEntire(new Code[] {
				Code.Ldarg_0, Code.Ldc_I4_1, Code.Stfld, Code.Ret
			});
		}

		[Detect(Code.Stfld)]
		public static Boolean Is_Stfld(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Ldarg_0, Code.Ldloc_1, Code.Ldloc_0, Code.Ldnull, Code.Call,
				Code.Call, Code.Ret
			}) && ins.DelegateMethod.Calls().Any((called) =>
			{
				return called.FullName.Contains("System.Reflection.FieldInfo::SetValue");
			});
		}

		[Detect(Code.Stsfld)]
		public static Boolean Is_Stsfld(this VirtualOpCode ins)
		{
			return ins.Matches(new Code[] {
				Code.Ldloc_1, Code.Ldnull, Code.Ldloc_3, Code.Callvirt, Code.Callvirt,
				Code.Ret
			}) && ins.DelegateMethod.Calls().Any((called) =>
			{
				return called.FullName.Contains("System.Reflection.FieldInfo::SetValue");
			});
		}

		[Detect(Code.Switch)]
		public static Boolean Is_Switch(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(
				Code.Blt_S, Code.Ret, Code.Ldloc_3, Code.Ldloc_2, Code.Conv_U, Code.Ldelem,
				Code.Callvirt, Code.Stloc_S, Code.Ldarg_0, Code.Ldloc_S, Code.Call, Code.Ret
			);
		}

		[Detect(Code.Unbox)]
		public static Boolean Is_Unbox(this VirtualOpCode ins)
		{
			OperandType operandType;
			return ins.DelegateMethod.MatchesEntire(Code.Ret)
				&& ins.TryGetOperandType(out operandType)
				&& operandType == OperandType.InlineType;
		}

		[Detect(Code.Unbox_Any)]
		public static Boolean Is_Unbox_Any(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.Matches(
				Code.Ldloc_2, Code.Callvirt, Code.Stloc_3, Code.Ldloc_3, Code.Ldloc_1,
				Code.Call, Code.Stloc_S, Code.Ldarg_0, Code.Ldloc_S, Code.Call, Code.Ret
			);
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Prefix.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		[Detect(Code.Constrained)]
		public static Boolean Is_Constrained(this VirtualOpCode ins)
		{
			return ins.DelegateMethod.MatchesEntire(
				Code.Ldarg_1, Code.Castclass, Code.Callvirt, Code.Stloc_0, Code.Ldarg_0,
				Code.Ldarg_0, Code.Ldloc_0, Code.Call, Code.Stfld, Code.Ret
			);
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Special.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		[Detect(SpecialCode.Eaz_Call)]
		public static Boolean Is_Eaz_Call(this VirtualOpCode ins)
		{
			var sub = ins.DelegateMethod.Find(new Code[] {
				Code.Ldc_I4, Code.And, Code.Ldc_I4_0, Code.Ceq, Code.Ldc_I4_0, Code.Ceq
			});
			return sub != null
				&& ((Int32)sub[0].Operand) == -2147483648;
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.Unsupported.cs
================================================
ï»¿using System;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;
using eazdevirt.Util;

namespace eazdevirt.Detection.V1.Ext
{
	public static partial class Extensions
	{
		public static Boolean _Is_Unsupported(VirtualOpCode ins, String name)
		{
			String exceptionString = String.Format("{0} is not supported", name);
			return ins.DelegateMethod.MatchesEntire(new Code[] {
				Code.Ldstr, Code.Newobj, Code.Throw
			}) && ((String)ins.DelegateMethod.Body.Instructions[0].Operand)
			      .StartsWith(exceptionString, StringComparison.OrdinalIgnoreCase);
		}

		[Detect(Code.Arglist)]
		public static Boolean Is_Arglist(this VirtualOpCode ins)
		{
			return _Is_Unsupported(ins, "Arglist");
		}

		[Detect(Code.Cpobj)]
		public static Boolean Is_Cpobj(this VirtualOpCode ins)
		{
			return _Is_Unsupported(ins, "Cpobj");
		}

		[Detect(Code.Mkrefany)]
		public static Boolean Is_Mkrefany(this VirtualOpCode ins)
		{
			return _Is_Unsupported(ins, "Mkrefany");
		}

		[Detect(Code.Refanytype)]
		public static Boolean Is_Refanytype(this VirtualOpCode ins)
		{
			return _Is_Unsupported(ins, "Refanytype");
		}

		[Detect(Code.Refanyval)]
		public static Boolean Is_Refanyval(this VirtualOpCode ins)
		{
			return _Is_Unsupported(ins, "Refanyval");
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/Detection.cs
================================================
ï»¿using System;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;

namespace eazdevirt.Detection.V1.Ext
{
	/// <summary>
	/// Extensions for detecting original instruction type (opcode).
	/// </summary>
	public static partial class Extensions
	{
		/// <summary>
		/// Identify a virtual instruction.
		/// </summary>
		/// <param name="instruction">Virtual instruction</param>
		/// <returns>Detected CIL opcode</returns>
		/// <exception cref="eazdevirt.OriginalOpcodeUnknownException">
		/// Thrown if original CIL opcode is unknown.
		/// </exception>
		public static Code Identify(this VirtualOpCode ins)
		{
			return InstructionDetectorV1.Instance.Identify(ins);
		}

		public static Boolean TryIdentify(this VirtualOpCode ins, out Code code)
		{
			return InstructionDetectorV1.Instance.TryIdentify(ins, out code);
		}

		/// <summary>
		/// Identify a virtual instruction, getting the entire attribute of the detection method.
		/// </summary>
		/// <param name="instruction">Virtual instruction</param>
		/// <returns>DetectAttribute of detection method if successful</returns>
		/// <exception cref="eazdevirt.OriginalOpcodeUnknownException">
		/// Thrown if original CIL opcode is unknown.
		/// </exception>
		public static DetectAttribute IdentifyFull(this VirtualOpCode ins)
		{
			return InstructionDetectorV1.Instance.IdentifyFull(ins);
		}

		public static Boolean TryIdentifyFull(this VirtualOpCode ins, out DetectAttribute attribute)
		{
			return InstructionDetectorV1.Instance.TryIdentifyFull(ins, out attribute);
		}
	}
}



================================================
File: src/eazdevirt/Detection/V1/InstructionDetectorV1.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.DotNet.Emit;
using eazdevirt.Reflection;

namespace eazdevirt.Detection.V1
{
	/// <summary>
	/// Instruction detector for assemblies protected with "V1" virtualization
	/// (v3.4 - v4.9).
	/// </summary>
	public sealed class InstructionDetectorV1 : InstructionDetectorBase
	{
		/// <summary>
		/// Singleton instance.
		/// </summary>
		public static InstructionDetectorV1 Instance { get { return _instance; } }
		private static InstructionDetectorV1 _instance = new InstructionDetectorV1();

		/// <summary>
		/// Delegate for detector methods.
		/// </summary>
		/// <param name="instruction">Virtual instruction</param>
		/// <returns>true if detected, false if not</returns>
		private delegate Boolean Detector(VirtualOpCode instruction);

		/// <summary>
		/// Dictionary mapping CIL opcodes to their respective detector methods.
		/// </summary>
		private Dictionary<Code, Detector> _detectors = new Dictionary<Code, Detector>();

		/// <summary>
		/// Dictionary mapping special opcodes to their respective detector methods.
		/// </summary>
		private Dictionary<SpecialCode, Detector> _specialDetectors = new Dictionary<SpecialCode, Detector>();

		/// <summary>
		/// Construct an InstructionDetectorV1.
		/// </summary>
		private InstructionDetectorV1()
		{
			this.Initialize();
		}

		/// <summary>
		/// Build the detector dictionary via reflection.
		/// </summary>
		private void Initialize()
		{
			var extensions = typeof(eazdevirt.Detection.V1.Ext.Extensions);
			var methods = extensions.GetMethods();
			foreach (var method in methods)
			{
				var attrs = method.GetCustomAttributes<DetectAttribute>();
				foreach (var attr in attrs)
				{
					Detector detector = (Detector)Delegate.CreateDelegate(typeof(Detector), method);
					if (attr != null && detector != null)
					{
						this.AddDetector(attr, detector);
					}
				}
			}
		}

		/// <summary>
		/// Add a detector to the dictionary, printing a warning if one already exists for
		/// a CIL opcode.
		/// </summary>
		/// <param name="attr">Attribute</param>
		/// <param name="callback">Detector delegate</param>
		private void AddDetector(DetectAttribute attr, Detector callback)
		{
			if (attr.IsSpecial)
			{
				if (!_specialDetectors.ContainsKey(attr.SpecialOpCode))
					_specialDetectors.Add(attr.SpecialOpCode, callback);
				else
				{
					Console.WriteLine ("[WARNING] More than one detector method found for special opcode {0}", attr.SpecialOpCode);
					_specialDetectors[attr.SpecialOpCode] = callback;
				}
			}
			else
			{
				if (!_detectors.ContainsKey(attr.OpCode))
					_detectors.Add(attr.OpCode, callback);
				else
				{
					Console.WriteLine ("[WARNING] More than one detector method found for CIL opcode {0}", attr.OpCode);
					_detectors[attr.OpCode] = callback;
				}
			}
		}

		/// <inheritdoc/>
		public override Code Identify(VirtualOpCode instruction)
		{
			foreach (var kvp in _detectors)
			{
				if (kvp.Value(instruction))
					return kvp.Key;
			}

			throw new OriginalOpcodeUnknownException(instruction);
		}

		/// <inheritdoc/>
		public override DetectAttribute IdentifyFull(VirtualOpCode instruction)
		{
			foreach (var kvp in _detectors)
			{
				if (kvp.Value(instruction))
					return (DetectAttribute)kvp.Value.Method.GetCustomAttribute(typeof(DetectAttribute));
			}

			foreach (var kvp in _specialDetectors)
			{
				if (kvp.Value(instruction))
					return (DetectAttribute)kvp.Value.Method.GetCustomAttribute(typeof(DetectAttribute));
			}

			throw new OriginalOpcodeUnknownException(instruction);
		}
	}
}



================================================
File: src/eazdevirt/Fixers/FixerAttribute.cs
================================================
ï»¿using System;

namespace eazdevirt.Fixers
{
	public class FixerAttribute : Attribute
	{
		/// <summary>
		/// Name of the fixer as it is specified by program arguments.
		/// </summary>
		public String Name { get; private set; }

		public FixerAttribute(String name)
		{
			this.Name = name;
		}
	}
}



================================================
File: src/eazdevirt/Fixers/IMethodFixer.cs
================================================
ï»¿using System;

namespace eazdevirt.Fixers
{
	public interface IMethodFixer
	{
		void Fix();
	}
}



================================================
File: src/eazdevirt/Fixers/MethodFixer.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace eazdevirt.Fixers
{
	public abstract class MethodFixer : IMethodFixer
	{
		public MethodDef Method { get; private set; }

		public MethodFixer(MethodDef method)
		{
			this.Method = method;
		}

		public abstract void Fix();
	}
}



================================================
File: src/eazdevirt/Fixers/StindFixer.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using eazdevirt.Util;

namespace eazdevirt.Fixers
{
	/// <summary>
	/// Fixer for stind_* CIL instructions.
	/// </summary>
	[Fixer("stind")]
	public class StindFixer : MethodFixer
	{
		private StackTypesCalculator _calc;

		/// <summary>
		/// Method instructions.
		/// </summary>
		public IList<Instruction> Instructions
		{
			get
			{
				if (this.Method.HasBody && this.Method.Body.HasInstructions)
					return this.Method.Body.Instructions;
				else
					return new List<Instruction>();
			}
		}

		/// <summary>
		/// Whether or not this method has a Stind_* instruction.
		/// </summary>
		Boolean HasStind
		{
			get
			{
				var instructions = this.Instructions;

				foreach (var instr in instructions)
				{
					if (IsStind(instr))
						return true;
				}

				return false;
			}
		}

		public StindFixer(MethodDef method)
			: base(method)
		{
			_calc = new StackTypesCalculator(method);
		}

		/// <summary>
		/// Whether or not an instruction is an Stind instruction.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <returns>true if Stind, false if not</returns>
		Boolean IsStind(Instruction instr)
		{
			switch (instr.OpCode.Code)
			{
				case Code.Stind_I:
				case Code.Stind_I1:
				case Code.Stind_I2:
				case Code.Stind_I4:
				case Code.Stind_I8:
				case Code.Stind_R4:
				case Code.Stind_R8:
				case Code.Stind_Ref:
					return true;
				default:
					return false;
			}
		}

		/// <summary>
		/// Compare two TypeSigs.
		/// </summary>
		/// <param name="type1">TypeSig</param>
		/// <param name="type2">TypeSig</param>
		/// <returns>true if equal, false if not</returns>
		Boolean E(TypeSig type1, TypeSig type2)
		{
			return type1.FullName.Equals(type2.FullName);
		}

		void Fix(Instruction instr)
		{
			var cor = this.Method.Module.CorLibTypes;
			var state = _calc.States(instr).Item1;
			state.Pop(); // Pop value
			var byref = state.Pop(); // Pop ByRef (address)

			// Make sure it's a ByRef
			if (!(byref is ByRefSig))
				throw new Exception(String.Format("Expected ByRefSig: {0}", byref));
			// Get underlying type of ByRef
			var type = byref.Next;

			if (E(type, cor.Boolean) || E(type, cor.Byte) || E(type, cor.SByte))
				instr.OpCode = OpCodes.Stind_I1;
			else if (E(type, cor.Int16) || E(type, cor.UInt16))
				instr.OpCode = OpCodes.Stind_I2;
			else if (E(type, cor.Int32) || E(type, cor.UInt32))
				instr.OpCode = OpCodes.Stind_I4;
			else if (E(type, cor.Int64) || E(type, cor.UInt64))
				instr.OpCode = OpCodes.Stind_I8;
			else if (E(type, cor.Single))
				instr.OpCode = OpCodes.Stind_R4;
			else if (E(type, cor.Double))
				instr.OpCode = OpCodes.Stind_R8;
			else if (E(type, cor.IntPtr) || E(type, cor.UIntPtr))
				instr.OpCode = OpCodes.Stind_I;
			else
				instr.OpCode = OpCodes.Stind_Ref;
		}

		public override void Fix()
		{
			if (!this.HasStind)
				return;

			_calc.Walk();
			foreach (var instr in this.Instructions)
			{
				if (IsStind(instr))
					Fix(instr);
			}
		}
	}
}



================================================
File: src/eazdevirt/Generator/IAssemblyGenerator.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace eazdevirt.Generator
{
	public interface IAssemblyGenerator
	{
		AssemblyDef Generate();
	}
}



================================================
File: src/eazdevirt/Generator/VirtualizableAssemblyGenerator.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace eazdevirt.Generator
{
	/// <summary>
	/// Assembly generator for generating a virtualizable assembly that contains an entry point
	/// (Main method) which calls a virtualizable method with some instructions.
	/// </summary>
	public class VirtualizableAssemblyGenerator : IAssemblyGenerator
	{
		public static readonly String DefaultModuleName = "eazdevirt-test-module.exe";
		public static readonly String DefaultAssemblyName = "MyAssembly";
		public static readonly Version DefaultAssemblyVersion = new Version(1, 2, 3, 4);

		private String _assemblyName;
		private String _moduleName;
		private Version _assemblyVersion;

		public delegate IList<Instruction> MethodGenerator(ModuleDef method, TypeDef mainType);
		private Dictionary<String, MethodGenerator> _methods = new Dictionary<String, MethodGenerator>();

		/// <summary>
		/// Whether or not this generator has any virtualizable methods added.
		/// </summary>
		public Boolean HasMethod
		{
			get { return _methods.Count > 0; }
		}

		public VirtualizableAssemblyGenerator()
			: this(DefaultModuleName, DefaultAssemblyName, DefaultAssemblyVersion)
		{
		}

		/// <summary>
		/// Create a virtualizable assembly generator with some instructions to be
		/// virtualized.
		/// </summary>
		public VirtualizableAssemblyGenerator(String moduleName, String assemblyName, Version assemblyVersion)
		{
			_moduleName = moduleName;
			_assemblyName = assemblyName;
			_assemblyVersion = assemblyVersion;
		}

		public void AddCalliMethod()
		{
			this.AddMethod("CalliMethod", VirtualizableAssemblyGenerator.GetCalliInstructions);
		}

		public void AddConvMethod()
		{
			this.AddMethod("ConvMethod", VirtualizableAssemblyGenerator.GetConvInstructions);
		}

		public void AddIndMethod()
		{
			this.AddMethod("IndMethod", VirtualizableAssemblyGenerator.GetIndInstructions);
		}

		public void AddStaticFieldMethod()
		{
			this.AddMethod("StaticFieldMethod", VirtualizableAssemblyGenerator.GetStaticFieldInstructions);
		}

		/// <summary>
		/// Add a virtualizable method.
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="func">Callback which generates the method body</param>
		public void AddMethod(String name, MethodGenerator func)
		{
			if (_methods.ContainsKey(name))
				_methods[name] = func;
			else _methods.Add(name, func);
		}

		/// <summary>
		/// Creates a custom ObfuscationAttribute that can be added to a method.
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="feature">Obfuscation feature name</param>
		/// <param name="exclude">true if exclude, false if include</param>
		/// <returns>CustomAttribute</returns>
		CustomAttribute CreateAttribute(ModuleDef module, String feature, Boolean exclude)
		{
			TypeSig stringSig = module.CorLibTypes.String;
			TypeSig booleanSig = module.CorLibTypes.Boolean;

			CANamedArgument[] args = new CANamedArgument[] {
				// Feature
				new CANamedArgument(
					false,
					stringSig,
					"Feature",
					new CAArgument(stringSig, feature)),

				// Exclude
				new CANamedArgument(
					false,
					booleanSig,
					"Exclude",
					new CAArgument(booleanSig, exclude))
			};

			TypeRef obfuscationRef = new TypeRefUser(
				module, "System.Reflection", "ObfuscationAttribute", module.CorLibTypes.AssemblyRef);

			MemberRef obfuscationCtor = new MemberRefUser(module, ".ctor",
						MethodSig.CreateInstance(module.CorLibTypes.Void),
						obfuscationRef);

			CustomAttribute attr = new CustomAttribute(
				obfuscationCtor,
				new CAArgument[0],
				args
			);

			return attr;
		}

		/// <summary>
		/// Create an entry point method which calls all virtualizable methods.
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="methods">Methods to call</param>
		/// <returns>Entry point method</returns>
		MethodDef CreateEntryPoint(ModuleDef module, IList<MethodDef> methods)
		{
			MethodDef entryPoint = new MethodDefUser("Main",
				MethodSig.CreateStatic(module.CorLibTypes.Int32, new SZArraySig(module.CorLibTypes.String)));

			entryPoint.Attributes = MethodAttributes.Private | MethodAttributes.Static |
				MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
			entryPoint.ImplAttributes = MethodImplAttributes.IL | MethodImplAttributes.Managed;
			entryPoint.ParamDefs.Add(new ParamDefUser("args", 1));

			entryPoint.Body = new CilBody();
			var instructions = entryPoint.Body.Instructions;

			foreach (var method in methods)
				instructions.Add(OpCodes.Call.ToInstruction(method));

			instructions.Add(OpCodes.Ldc_I4_0.ToInstruction());
			instructions.Add(OpCodes.Ret.ToInstruction());

			// Set itself as entry point
			module.EntryPoint = entryPoint;

			return entryPoint;
		}

		/// <summary>
		/// Create a main type.
		/// </summary>
		/// <param name="module">Module</param>
		/// <returns>Main type</returns>
		TypeDef CreateMainType(ModuleDef module)
		{
			TypeDef mainType = new TypeDefUser(
				this._assemblyName, "Program", module.CorLibTypes.Object.TypeDefOrRef);
			mainType.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout |
				TypeAttributes.Class | TypeAttributes.AnsiClass;

			return mainType;
		}

		/// <summary>
		/// Create a virtualizable method.
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="name">Method name</param>
		/// <param name="instructions">Method body instructions</param>
		/// <returns>MethodDef</returns>
		MethodDef CreateVirtualizableMethod(ModuleDef module, String name, IList<Instruction> instructions)
		{
			MethodDef vmethod = new MethodDefUser(name,
				MethodSig.CreateStatic(module.CorLibTypes.Void));

			vmethod.Attributes = MethodAttributes.Private | MethodAttributes.Static |
				MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
			vmethod.ImplAttributes = MethodImplAttributes.IL | MethodImplAttributes.Managed;

			vmethod.CustomAttributes.Add(CreateAttribute(module, "renaming", true));
			vmethod.CustomAttributes.Add(CreateAttribute(module, "virtualization", false));

			// Add instructions to body
			vmethod.Body = new CilBody();
			foreach (var instr in instructions)
				vmethod.Body.Instructions.Add(instr);

			return vmethod;
		}

		/// <summary>
		/// Generate a test assembly.
		/// </summary>
		/// <returns>Assembly</returns>
		public AssemblyDef Generate()
		{
			var module = new ModuleDefUser(_moduleName);
			module.Kind = ModuleKind.Console;

			var assembly = new AssemblyDefUser(_assemblyName, _assemblyVersion);
			assembly.Modules.Add(module);

			var mainType = this.CreateMainType(module);
			module.Types.Add(mainType);

			var generatedMethods = new List<MethodDef>();
			foreach (var kvp in _methods)
			{
				var name = kvp.Key;
				var instructions = kvp.Value(module, mainType);
				var method = CreateVirtualizableMethod(module, name, instructions);

				mainType.Methods.Add(method);
				generatedMethods.Add(method);
			}

			var entryPoint = this.CreateEntryPoint(module, generatedMethods);
			mainType.Methods.Add(entryPoint);

			return assembly;
		}

		/// <summary>
		/// Get a sensible list of all Conv_* instructions.
		/// </summary>
		/// <returns>Instructions</returns>
		static IList<Instruction> GetConvInstructions(ModuleDef module, TypeDef mainType)
		{
			var all = new List<Instruction>();

			all.Add(OpCodes.Ldc_I4_0.ToInstruction());

			all.Add(OpCodes.Conv_I.ToInstruction());
			all.Add(OpCodes.Conv_I1.ToInstruction());
			all.Add(OpCodes.Conv_I2.ToInstruction());
			all.Add(OpCodes.Conv_I4.ToInstruction());
			all.Add(OpCodes.Conv_I8.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I1.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I1_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I2.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I2_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I4.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I4_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I8.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_I8_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U1.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U1_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U2.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U2_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U4.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U4_Un.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U8.ToInstruction());
			all.Add(OpCodes.Conv_Ovf_U8_Un.ToInstruction());
			all.Add(OpCodes.Conv_R_Un.ToInstruction());
			all.Add(OpCodes.Conv_R4.ToInstruction());
			all.Add(OpCodes.Conv_R8.ToInstruction());
			all.Add(OpCodes.Conv_U.ToInstruction());
			all.Add(OpCodes.Conv_U1.ToInstruction());
			all.Add(OpCodes.Conv_U2.ToInstruction());
			all.Add(OpCodes.Conv_U4.ToInstruction());
			all.Add(OpCodes.Conv_U8.ToInstruction());

			all.Add(OpCodes.Ret.ToInstruction());

			return all;
		}

		/// <summary>
		/// Get a sensible list of all static field instructions.
		/// </summary>
		/// <returns>Instructions</returns>
		static IList<Instruction> GetStaticFieldInstructions(ModuleDef module, TypeDef mainType)
		{
			FieldDef field = new FieldDefUser(
				"StaticInteger",
				new FieldSig(module.CorLibTypes.Int32),
				FieldAttributes.Static | FieldAttributes.Public
			);

			mainType.Fields.Add(field);

			var all = new List<Instruction>();
			all.Add(OpCodes.Ldsfld.ToInstruction(field));
			all.Add(OpCodes.Stsfld.ToInstruction(field));
			all.Add(OpCodes.Ldsflda.ToInstruction(field));

			// Pop causes the virtualizer to optimize in some cases,
			// and remove previous instruction
			// all.Add(OpCodes.Pop.ToInstruction());

			all.Add(OpCodes.Ret.ToInstruction());
			return all;
		}

		/// <summary>
		/// Get a sensible list of all Ldind_*, Stind_* instructions.
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="mainType">Main type</param>
		/// <returns>Instructions</returns>
		static IList<Instruction> GetIndInstructions(ModuleDef module, TypeDef mainType)
		{
			var all = new List<Instruction>();

			// This is a bit lazy
			for (Int32 i = 0; i < 11; i++)
			{
				all.Add(OpCodes.Ldc_I4_0.ToInstruction());
			}

			all.Add(OpCodes.Ldind_I.ToInstruction());
			all.Add(OpCodes.Ldind_I1.ToInstruction());
			all.Add(OpCodes.Ldind_I2.ToInstruction());
			all.Add(OpCodes.Ldind_I4.ToInstruction());
			all.Add(OpCodes.Ldind_I8.ToInstruction());
			all.Add(OpCodes.Ldind_R4.ToInstruction());
			all.Add(OpCodes.Ldind_R8.ToInstruction());
			all.Add(OpCodes.Ldind_Ref.ToInstruction());
			all.Add(OpCodes.Ldind_U1.ToInstruction());
			all.Add(OpCodes.Ldind_U2.ToInstruction());
			all.Add(OpCodes.Ldind_U4.ToInstruction());

			for (Int32 i = 0; i < 8; i++)
			{
				all.Add(OpCodes.Ldc_I4_0.ToInstruction());
				all.Add(OpCodes.Ldc_I4_0.ToInstruction());
			}

			all.Add(OpCodes.Stind_I.ToInstruction());
			all.Add(OpCodes.Stind_I1.ToInstruction());
			all.Add(OpCodes.Stind_I2.ToInstruction());
			all.Add(OpCodes.Stind_I4.ToInstruction());
			all.Add(OpCodes.Stind_I8.ToInstruction());
			all.Add(OpCodes.Stind_R4.ToInstruction());
			all.Add(OpCodes.Stind_R8.ToInstruction());
			all.Add(OpCodes.Stind_Ref.ToInstruction());

			return all;
		}

		/// <summary>
		/// Calli.
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="mainType">Main type</param>
		/// <returns>Instructions</returns>
		static IList<Instruction> GetCalliInstructions(ModuleDef module, TypeDef mainType)
		{
			TypeRef consoleRef = new TypeRefUser(module, "System", "Console", module.CorLibTypes.AssemblyRef);
			MemberRef consoleWrite0 = new MemberRefUser(module, "WriteLine",
						MethodSig.CreateStatic(module.CorLibTypes.Void),
						consoleRef);

			var all = new List<Instruction>();
			all.Add(OpCodes.Ldftn.ToInstruction(consoleWrite0));
			all.Add(OpCodes.Calli.ToInstruction(consoleWrite0.MethodSig));
			all.Add(OpCodes.Ret.ToInstruction());
			return all;
		}
	}
}



================================================
File: src/eazdevirt/IO/Resolver.Serialized.cs
================================================
ï»¿using System;
using System.IO;
using System.Linq;
using System.Reflection;

namespace eazdevirt.IO
{
	public partial class Resolver : ResourceReader
	{
		/// <summary>
		/// A guess as to the first Byte (enum) of InlineOperand.
		/// </summary>
		public enum ValueType
		{
			/// <summary>
			/// The Value field holds a raw MDToken value.
			/// </summary>
			Token = 0,

			/// <summary>
			/// The Value field holds a position.
			/// </summary>
			Position = 1
		}

		/// <summary>
		/// Inline operand types.
		/// </summary>
		public enum InlineOperandType
		{
			Type = 0,
			Field = 1,
			Method = 2,
			UserString = 3,
			UnknownType7 = 4
		}

		/// <summary>
		/// Deserialized inline operand.
		/// </summary>
		/// <remarks>Class54</remarks>
		public class InlineOperand
		{
			/// <summary>
			/// Determines how the Value field is interpreted.
			/// </summary>
			public ValueType ValueType { get; private set; }

			/// <summary>
			/// Either a raw metadata token from the parent module, or a position in
			/// the embedded resource file.
			/// </summary>
			public Int32 Value { get; private set; }

			/// <summary>
			/// Deserialized data associated with this operand.
			/// </summary>
			public InlineOperandData Data { get; private set; }

			/// <summary>
			/// Whether or not this operand contains a token.
			/// </summary>
			public Boolean IsToken { get { return this.ValueType == ValueType.Token; } }

			/// <summary>
			/// Whether or not this operand contains a position.
			/// </summary>
			public Boolean IsPosition { get { return !this.IsToken; } }

			/// <summary>
			/// Get the operand's token, throwing an exception if none.
			/// </summary>
			public Int32 Token
			{
				get
				{
					if (this.IsToken)
						return this.Value;
					else
						throw new Exception("InlineOperand has no token (only position)");
				}
			}

			/// <summary>
			/// Get the operand's position, throwing an exception if none.
			/// </summary>
			public Int32 Position
			{
				get
				{
					if (this.IsPosition)
						return this.Value;
					else
						throw new Exception("InlineOperand has no position (only token)");
				}
			}

			/// <summary>
			/// Whether or not this operand has deserialized data associated with it.
			/// </summary>
			public Boolean HasData { get { return this.Data != null; } }

			protected InlineOperand()
			{
			}

			public InlineOperand(BinaryReader reader)
			{
				this.Deserialize(reader);
			}

			private void Deserialize(BinaryReader reader)
			{
				this.ValueType = (ValueType)reader.ReadByte();

				if (this.ValueType == 0)
					this.Value = reader.ReadInt32();
				else
					this.Data = InlineOperandData.Read(reader);
			}

			public static InlineOperand ReadInternal(BinaryReader reader)
			{
				InlineOperand u = new InlineOperand();
				u.ValueType = ValueType.Position;
				u.Value = reader.ReadInt32();
				return u;
			}

			public static InlineOperand[] ReadArrayInternal(BinaryReader reader)
			{
				Int32 count = reader.ReadInt16();
				InlineOperand[] arr = new InlineOperand[count];

				for (Int32 i = 0; i < arr.Length; i++)
					arr[i] = InlineOperand.ReadInternal(reader);

				return arr;
			}
		}

		/// <summary>
		/// Operand data.
		/// </summary>
		/// <remarks>Class41</remarks>
		public abstract class InlineOperandData
		{
			/// <summary>
			/// Describes the type of operand data.
			/// </summary>
			public abstract InlineOperandType Type { get; }

			protected InlineOperandData() { }

			public InlineOperandData(BinaryReader reader)
			{
				this.Deserialize(reader);
			}

			protected abstract void Deserialize(BinaryReader reader);

			/// <summary>
			/// Read some inline operand data from a BinaryReader.
			/// </summary>
			/// <param name="reader">BinaryReader</param>
			/// <returns>InlineOperandData</returns>
			public static InlineOperandData Read(BinaryReader reader)
			{
				switch ((InlineOperandType)reader.ReadByte())
				{
					case InlineOperandType.Type:
						return new TypeData(reader);
					case InlineOperandType.Field:
						return new FieldData(reader);
					case InlineOperandType.Method:
						return new MethodData(reader);
					case InlineOperandType.UserString:
						return new StringData(reader);
					case InlineOperandType.UnknownType7:
						return new UnknownType7(reader);
					default:
						throw new ArgumentOutOfRangeException();
				}
			}
		}

		/// <summary>
		/// Type-related operand data.
		/// </summary>
		/// <remarks>Class46</remarks>
		public class TypeData : InlineOperandData
		{
			public Int32 SomeIndex { get; private set; } // int_1, index into type_2? (GetGenericArguments())
			public Int32 SomeIndex2 { get; private set; } // int_0, index into type_5? (DeclaringType.GetGenericArguments())
			public Boolean Unknown3 { get; private set; } // bool_0
			public String Name { get; private set; } // string_0
			public Boolean HasGenericTypes { get; private set; } // bool_1
			public InlineOperand[] GenericTypes { get; private set; } // class54_0

			public override InlineOperandType Type
			{
				get { return InlineOperandType.Type; }
			}

			public String TypeNameWithoutNamespace
			{
				get
				{
					if (this.TypeName.Contains("."))
						return this.TypeName.Split('.').Last();
					else
						return String.Empty;
				}
			}

			public String Namespace
			{
				get
				{
					if (this.TypeName.Contains("."))
					{
						return String.Join(".",
							this.TypeName.Split('.').Reverse().Skip(1).Reverse().ToArray());
					}
					else
						return this.TypeName;
				}
			}

			public String TypeName
			{
				get
				{
					if (this.Name.Contains(", "))
						return this.Name.Split(',')[0];
					else return this.Name;
				}
			}

			public String AssemblyFullName
			{
				get
				{
					return this.Name.Substring(
						this.TypeName.Length + 2,
						this.Name.Length - (this.TypeName.Length + 2)
					);
				}
			}

			public String AssemblyName
			{
				get { return AssemblyFullName.Split(',')[0]; }
			}

			public TypeData(BinaryReader reader)
				: base(reader)
			{
			}

			protected override void Deserialize(BinaryReader reader)
			{
				this.SomeIndex = reader.ReadInt32();
				this.SomeIndex2 = reader.ReadInt32();
				this.Unknown3 = reader.ReadBoolean();
				this.Name = reader.ReadString();
				this.HasGenericTypes = reader.ReadBoolean();
				this.GenericTypes = InlineOperand.ReadArrayInternal(reader);
			}
		}

		/// <summary>
		/// Field-related operand data.
		/// </summary>
		/// <remarks>Class42</remarks>
		public class FieldData : InlineOperandData
		{
			public InlineOperand FieldType { get; private set; }
			public String Name { get; private set; }
			public Boolean Flags { get; private set; }

			public override InlineOperandType Type
			{
				get { return InlineOperandType.Field; }
			}

			public BindingFlags BindingFlags
			{
				get
				{
					BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic;
					if (this.Flags)
						bindingFlags |= BindingFlags.Static;
					else
						bindingFlags |= BindingFlags.Instance;
					return bindingFlags;
				}
			}

			public FieldData(BinaryReader reader)
				: base(reader)
			{
			}

			protected override void Deserialize(BinaryReader reader)
			{
				this.FieldType = InlineOperand.ReadInternal(reader);
				this.Name = reader.ReadString();
				this.Flags = reader.ReadBoolean();
			}
		}

		/// <summary>
		/// Method-related operand data.
		/// </summary>
		/// <remarks>Class44</remarks>
		public class MethodData : InlineOperandData
		{
			public InlineOperand DeclaringType { get; private set; } // class54_0
			public Boolean Unknown2 { get; private set; } // bool_0
			public Boolean Flags { get; private set; } // bool_1
			public String Name { get; private set; } // string_0
			public InlineOperand ReturnType { get; private set; } // class54_3
			public InlineOperand[] Parameters { get; private set; } // class54_1
			public InlineOperand[] GenericArguments { get; private set; } // class54_2

			public Boolean HasGenericArguments
			{
				get { return this.GenericArguments.Length > 0; }
			}

			public override InlineOperandType Type
			{
				get { return InlineOperandType.Method; }
			}

			public Boolean IsStatic
			{
				get { return this.Flags; }
			}

			public Boolean IsInstance
			{
				get { return !this.Flags; }
			}

			public BindingFlags BindingFlags
			{
				get
				{
					BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic;
					if (this.Flags)
						bindingFlags |= BindingFlags.Static;
					else
						bindingFlags |= BindingFlags.Instance;
					return bindingFlags;
				}
			}

			public MethodData(BinaryReader reader)
				: base(reader)
			{
			}

			protected override void Deserialize(BinaryReader reader)
			{
				this.DeclaringType = InlineOperand.ReadInternal(reader);
				this.Unknown2 = reader.ReadBoolean();
				this.Flags = reader.ReadBoolean();
				this.Name = reader.ReadString();
				this.ReturnType = InlineOperand.ReadInternal(reader);
				this.Parameters = InlineOperand.ReadArrayInternal(reader);
				this.GenericArguments = InlineOperand.ReadArrayInternal(reader);
			}
		}

		/// <summary>
		/// String-related operand data.
		/// </summary>
		/// <remarks>Class45</remarks>
		public class StringData : InlineOperandData
		{
			/// <summary>
			/// String value.
			/// </summary>
			public String Value { get; private set; }

			public override InlineOperandType Type
			{
				get { return InlineOperandType.UserString; }
			}

			public StringData(BinaryReader reader)
				: base(reader)
			{
			}

			protected override void Deserialize(BinaryReader reader)
			{
				this.Value = reader.ReadString();
			}
		}

		// Class43
		public class UnknownType7 : InlineOperandData
		{
			public Int32 Unknown1 { get; private set; }
			public Int32 Unknown2 { get; private set; }

			public override InlineOperandType Type
			{
				get { return InlineOperandType.UnknownType7; }
			}

			public UnknownType7(BinaryReader reader)
				: base(reader)
			{
			}

			protected override void Deserialize(BinaryReader reader)
			{
				this.Unknown1 = reader.ReadInt32();
				this.Unknown2 = reader.ReadInt32();
			}
		}

		public class EazCallData
		{
			/// <summary>
			/// Whether or not the respective method is a static method.
			/// </summary>
			public Boolean IsStatic { get; private set; }

			public Int32 ReturnType { get; private set; }
			public Int32 DeclaringType { get; private set; }
			public String Name { get; private set; }
			public ParameterData[] Parameters { get; private set; }
			public Int32[] Unknown6 { get; private set; }

			public EazCallData(BinaryReader reader)
			{
				this.Deserialize(reader);
			}

			protected void Deserialize(BinaryReader reader)
			{
				this.IsStatic = reader.ReadBoolean();
				this.ReturnType = reader.ReadInt32(); // Return type
				this.DeclaringType = reader.ReadInt32(); // Declaring type
				this.Name = reader.ReadString();

				this.Parameters = ParameterData.ReadArray(reader);

				this.Unknown6 = new Int32[reader.ReadUInt16()];
				for (Int32 i = 0; i < this.Unknown6.Length; i++)
					this.Unknown6[i] = reader.ReadInt32();
			}
		}

		// Parameter?
		public class ParameterData
		{
			public Int32 Type { get; private set; } // Probably a Type to be resolved
			public Boolean Unknown2 { get; private set; } // Probably in/out

			public ParameterData(BinaryReader reader)
			{
				this.Deserialize(reader);
			}

			protected void Deserialize(BinaryReader reader)
			{
				this.Type = reader.ReadInt32();
				this.Unknown2 = reader.ReadBoolean();
			}

			public static ParameterData[] ReadArray(BinaryReader reader)
			{
				Int32 count = reader.ReadInt16();
				ParameterData[] arr = new ParameterData[count];

				for (Int32 i = 0; i < arr.Length; i++)
					arr[i] = new ParameterData(reader);

				return arr;
			}
		}
	}
}



================================================
File: src/eazdevirt/IO/Resolver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using dnlib.DotNet;
using dnlib.DotNet.MD;
using eazdevirt.Util;

namespace eazdevirt.IO
{
	public partial class Resolver : ResourceReader
	{
		/// <summary>
		/// Logger.
		/// </summary>
		public ILogger Logger { get; private set; }

		/// <summary>
		/// Importer.
		/// </summary>
		public Importer Importer { get; private set; }

		/// <summary>
		/// Serialization version. Determines how certain things are read.
		/// </summary>
		public SerializationVersion Version { get; private set; }

		/// <summary>
		/// Lock used for all public resolve methods.
		/// </summary>
		private Object _lock = new Object();

		public Resolver(EazModule module, ILogger logger,
			SerializationVersion version = SerializationVersion.V1)
			: base(module)
		{
			this.Logger = (logger != null ? logger : DummyLogger.NoThrowInstance);
			this.Importer = new Importer(this.Module, ImporterOptions.TryToUseDefs);
			this.Version = version;
		}

		/// <summary>
		/// Resolve a user string.
		/// </summary>
		/// <param name="position">Position</param>
		/// <returns>String</returns>
		public String ResolveString(Int32 position)
		{
			lock (_lock)
			{
				return this.ResolveString_NoLock(position);
			}
		}

		String ResolveString_NoLock(Int32 position)
		{
			this.Stream.Position = position;

			InlineOperand operand = new InlineOperand(this.Reader);
			if (operand.IsToken)
			{
				return this.Module.ReadUserString((UInt32)operand.Token);
			}
			else
			{
				StringData data = operand.Data as StringData;
				return data.Value;
			}
		}

		/// <summary>
		/// Resolve a method.
		/// </summary>
		/// <param name="position">Position</param>
		/// <returns>IMethod</returns>
		public IMethod ResolveMethod(Int32 position)
		{
			lock(_lock)
			{
				return this.ResolveMethod_NoLock(position);
			}
		}

		/// <summary>
		/// Try to resolve a method without throwing.
		/// </summary>
		/// <param name="position">Position</param>
		/// <returns>IMethod, or null if unable to resolve</returns>
		public IMethod TryResolveMethod(Int32 position)
		{
			try
			{
				return this.ResolveMethod(position);
			}
			catch(Exception)
			{
				return null;
			}
		}

		IMethod ResolveMethod_Helper(ITypeDefOrRef declaringType, MethodData data)
		{
			TypeDef declaringDef = declaringType.ResolveTypeDefThrow();
			MethodSig methodSig = GetMethodSig(data);

			// Has a GenericMVar
			if (data.HasGenericArguments)
			{
				MethodSig detectedSig = null;
				MethodDef method = FindMethodCheckBaseType(declaringType, data, out detectedSig);

				if (method == null || detectedSig == null)
				{
					throw new Exception(String.Format(
						"Unable to find generic method from the declaring/base types: DeclaringType={0}, MethodName={1}, MethodSig={2}",
						declaringType.ReflectionFullName, data.Name, methodSig));
				}

				MethodSpec methodSpec = new MethodSpecUser(method, ToGenericInstMethodSig(data));
				return this.Importer.Import(methodSpec);
			}
			else // No GenericMVars
			{
				MethodDef method = declaringDef.FindMethodCheckBaseType(data.Name, methodSig);
				if (method == null)
				{
					throw new Exception(String.Format(
						"Unable to find method from the declaring/base types: DeclaringType={0}, MethodName={1}, MethodSig={2}",
						declaringType.ReflectionFullName, data.Name, methodSig));
				}

				return this.Importer.Import(method);
			}
		}

		IMethod ResolveMethod_NoLock(TypeDef declaringDef, MethodData data)
		{
			return ResolveMethod_Helper(declaringDef, data);
		}

		/// <summary>
		/// Find a MethodDef from a declaring type and some MethodData. Will generate
		/// a list of possible MethodSigs and check against each of them, returning the
		/// first-found MethodDef that matches the method name and signature.
		/// </summary>
		/// <param name="declaringType">Declaring type</param>
		/// <param name="data">MethodData</param>
		/// <param name="detectedSig">The detected MethodSig</param>
		/// <returns>MethodDef if found, null if none found</returns>
		MethodDef FindMethodCheckBaseType(ITypeDefOrRef declaringType, MethodData data, out MethodSig detectedSig)
		{
			detectedSig = null;

			TypeDef declaringDef = declaringType.ResolveTypeDef();
			if (declaringDef == null)
				return null;

			MethodDef method = null;
			MethodSig methodSig = GetMethodSig(data);
			var possibleSigs = PossibleMethodSigs(declaringType, methodSig, data);
			detectedSig = possibleSigs.FirstOrDefault(sig => {
				return (method = declaringDef.FindMethodCheckBaseType(data.Name, sig)) != null;
			});

			return method;
		}

		/// <summary>
		/// Get a GenericInstMethodSig containing the resolved types of the generic method vars
		/// specified in the given MethodData.
		/// </summary>
		/// <param name="data">MethodData</param>
		/// <returns>GenericInstMethodSig, or null if the given data contains no generic arguments</returns>
		GenericInstMethodSig ToGenericInstMethodSig(MethodData data)
		{
			if (!data.HasGenericArguments)
				return null;

			IList<TypeSig> genericMVars = new List<TypeSig>();
			for (Int32 i = 0; i < data.GenericArguments.Length; i++)
				genericMVars.Add(this.ResolveType_NoLock(data.GenericArguments[i].Position).ToTypeSig());

			return new GenericInstMethodSig(genericMVars);
		}

		IMethod ResolveMethod_NoLock(TypeRef declaringRef, MethodData data)
		{
			return ResolveMethod_Helper(declaringRef, data);
		}

		IMethod ResolveMethod_NoLock(TypeSpec declaringSpec, MethodData data)
		{
			// Find a method that matches the signature (factoring in possible generic vars/mvars)
			MethodSig matchedSig = null;
			MethodDef method = FindMethodCheckBaseType(declaringSpec, data, out matchedSig);

			if (matchedSig == null || method == null)
			{
				throw new Exception(String.Format(
					"Unable to find generic method from the declaring/base types: DeclaringType={0}, MethodName={1}",
					declaringSpec.ReflectionFullName, data.Name));
			}

			MemberRef memberRef = new MemberRefUser(this.Module, method.Name, matchedSig, declaringSpec);
			if (data.HasGenericArguments)
				return this.Importer.Import(new MethodSpecUser(memberRef, ToGenericInstMethodSig(data)));
			else
				return this.Importer.Import(memberRef);
		}

		IMethod ResolveMethod_NoLock(Int32 position)
		{
			this.Stream.Position = position;

			InlineOperand operand = new InlineOperand(this.Reader);
			if(operand.IsToken)
			{
				MDToken token = new MDToken(operand.Token);
				if (token.Table == Table.Method)
					return this.Module.ResolveMethod(token.Rid);
				else if (token.Table == Table.MemberRef)
					return this.Module.ResolveMemberRef(token.Rid);
				else if (token.Table == Table.MethodSpec)
					return this.Module.ResolveMethodSpec(token.Rid);

				throw new Exception("[ResolveMethod_NoLock] Bad MDToken table");
			}
			else
			{
				MethodData data = operand.Data as MethodData;
				ITypeDefOrRef declaring = this.ResolveType_NoLock(data.DeclaringType.Position);

				if (declaring is TypeDef)
				{
					TypeDef declaringDef = declaring as TypeDef;
					return this.ResolveMethod_NoLock(declaringDef, data);
				}
				else if (declaring is TypeRef)
				{
					TypeRef declaringRef = declaring as TypeRef;
					return this.ResolveMethod_NoLock(declaringRef, data);
				}
				else if (declaring is TypeSpec)
				{
					TypeSpec declaringSpec = declaring as TypeSpec;
					return this.ResolveMethod_NoLock(declaringSpec, data);
				}

				throw new Exception("[ResolveMethod_NoLock] Expected declaring type to be a TypeDef, TypeRef or TypeSpec");
			}
		}

		/// <summary>
		/// Resolve a field.
		/// </summary>
		/// <param name="position">Position</param>
		/// <returns>Field</returns>
		public IField ResolveField(Int32 position)
		{
			lock (_lock)
			{
				return this.ResolveField_NoLock(position);
			}
		}

		public IField TryResolveField(Int32 position)
		{
			try
			{
				return this.ResolveField(position);
			}
			catch (Exception)
			{
				return null;
			}
		}

		IField ResolveField_NoLock(Int32 position)
		{
			this.Stream.Position = position;

			InlineOperand operand = new InlineOperand(this.Reader);
			if (operand.IsToken)
			{
				MDToken token = new MDToken(operand.Token);
				return this.Module.ResolveField(token.Rid);
			}
			else
			{
				FieldData data = operand.Data as FieldData;
				ITypeDefOrRef declaringType = this.ResolveType_NoLock(data.FieldType.Position);
				if (declaringType == null)
					throw new Exception("[ResolveField_NoLock] Unable to resolve type as TypeDef or TypeRef");

				NameResolver nameResolver = new NameResolver(this.Module);
				IField field = nameResolver.ResolveField(declaringType, data.Name);
				if (field == null)
				{
					throw new Exception(String.Format(
					"[ResolveField_NoLock] Unable to resolve field: DeclaringType={0}, Field={1}",
					declaringType.ReflectionFullName, data.Name));
				}

				return field;
			}
		}

		/// <summary>
		/// Resolve a type.
		/// </summary>
		/// <param name="position">Position</param>
		/// <returns>Type</returns>
		public ITypeDefOrRef ResolveType(Int32 position)
		{
			lock (_lock)
			{
				return this.ResolveType_NoLock(position);
			}
		}

		public ITypeDefOrRef TryResolveType(Int32 position)
		{
			try
			{
				return this.ResolveType(position);
			}
			catch (Exception)
			{
				return null;
			}
		}

		ITypeDefOrRef ResolveType_NoLock(Int32 position)
		{
			this.Stream.Position = position;

			InlineOperand operand = new InlineOperand(this.Reader);
			if (operand.IsToken)
			{
				MDToken token = new MDToken(operand.Token);

				if (token.Table == Table.TypeDef)
					return this.Module.ResolveTypeDef(token.Rid);
				else if (token.Table == Table.TypeRef)
					return this.Module.ResolveTypeRef(token.Rid);
				else if (token.Table == Table.TypeSpec)
					return this.Module.ResolveTypeSpec(token.Rid);

				throw new Exception("Unable to resolve type: bad MDToken table");
			}
			else
			{
				TypeData data = operand.Data as TypeData;

				// Resolve via name
				TypeName typeName = new TypeName(data.Name);
				NameResolver nameResolver = new NameResolver(this.Module);
				ITypeDefOrRef typeDefOrRef = nameResolver.ResolveTypeDefOrRef(typeName);

				if (typeDefOrRef == null)
				{
					throw new Exception(String.Format(
						"Unable to resolve ITypeDefOrRef from given name: {0}",
						typeName.FullName));
				}

				// Apply generics, if any (resulting in a TypeSpec)
				if (data.GenericTypes.Length > 0)
					typeDefOrRef = ApplyGenerics(typeDefOrRef, data);

				if (typeDefOrRef == null)
				{
					throw new Exception(String.Format(
						"Unable to apply generic types: {0}", typeName.FullName
						));
				}

				// Apply [], *, &
				typeDefOrRef = SigUtil.FromBaseSig(typeDefOrRef.ToTypeSig(), typeName.Modifiers)
					.ToTypeDefOrRef();

				return typeDefOrRef;
			}
		}

		/// <summary>
		/// Resolve a token.
		/// </summary>
		/// <param name="position">Position</param>
		/// <returns>Token</returns>
		public ITokenOperand ResolveToken(Int32 position)
		{
			lock (_lock)
			{
				return this.ResolveToken_NoLock(position);
			}
		}

		public ITokenOperand TryResolveToken(Int32 position)
		{
			try
			{
				return this.ResolveToken(position);
			}
			catch (Exception)
			{
				return null;
			}
		}

		ITokenOperand ResolveToken_NoLock(Int32 position)
		{
			this.Stream.Position = position;

			InlineOperand operand = new InlineOperand(this.Reader);
			if (operand.IsToken)
			{
				throw new NotSupportedException("Currently unable to resolve a token via MDToken");
			}
			else
			{
				if (operand.Data.Type == InlineOperandType.Field)
					return this.ResolveField_NoLock(position);
				if (operand.Data.Type == InlineOperandType.Method)
					return this.ResolveMethod_NoLock(position);
				if (operand.Data.Type == InlineOperandType.Type)
					return this.ResolveType_NoLock(position);

				throw new InvalidOperationException(String.Format(
					"Expected inline operand type of token to be either Type, Field or Method; instead got {0}",
					operand.Data.Type));
			}
		}

		public IMethod ResolveEazCall(Int32 value)
		{
			lock (_lock)
			{
				return this.ResolveEazCall_NoLock(value);
			}
		}

		IMethod ResolveEazCall_NoLock(Int32 value)
		{
			// Currently unsure what these two flags do
			Boolean flag1 = (value & 0x80000000) != 0; // Probably indicates the method has no generic vars
			Boolean flag2 = (value & 0x40000000) != 0;
			Int32 position = value & 0x3FFFFFFF; // Always a stream position

			if (flag1)
			{
				//throw new Exception(String.Format(
				//	"Unsure what to do if EazCall operand flag1 is set (operand = 0x{0:X8})",
				//	value
				//));

				// void DoSomething(Int32, Type[], Type[], Boolean):
				// -> DoSomething(position, null, null, flag2);

				return ResolveEazCall_Helper(position, null, null, flag1);
			}
			else
			{
				this.Stream.Position = position;

				InlineOperand operand = new InlineOperand(this.Reader);
				UnknownType7 data = operand.Data as UnknownType7;

				Int32 num = data.Unknown1;
				// This method is used to get generics info?
				IMethod method = this.ResolveMethod_NoLock(data.Unknown2);
				Type[] genericTypes = null; // Todo
				Type[] declaringGenericTypes = null; // Todo

				Boolean subflag1 = (num & 0x40000000) != 0;
				num &= unchecked((Int32)0xBFFFFFFF);

				// -> DoSomething(num, genericTypes, declaringGenericTypes, subflag1);
				return ResolveEazCall_Helper(num, genericTypes, declaringGenericTypes, subflag1);
			}
		}

		IMethod ResolveEazCall_Helper(
			Int32 value, Type[] genericTypes, Type[] declaringGenericTypes, Boolean flag)
		{
			this.Stream.Position = value;

			if (this.Version == SerializationVersion.V1)
			{
				if (this.Reader.ReadByte() != 0)
					throw new InvalidDataException();
			}

			EazCallData data = new EazCallData(this.Reader);

			var delcaringType = (this.ResolveType_NoLock(data.DeclaringType) as TypeDef);
			if (delcaringType == null)
				throw new Exception("Unable to resolve the declaring type of the Eaz_Call method operand");

			var methodSig = GetMethodSig(data);

			// Todo: Factor in generics?
			var method = delcaringType.FindMethodCheckBaseType(data.Name, methodSig);
			if (method == null)
				throw new Exception("Unable to resolve Eaz_Call operand from declaring type + method name");

			return method;
		}

		/// <summary>
		/// Resolve a type from a deserialized inline operand, which should
		/// have a direct token (position).
		/// </summary>
		/// <param name="operand">Inline operand</param>
		/// <returns>TypeSig</returns>
		TypeSig ResolveType(InlineOperand operand)
		{
			ITypeDefOrRef type = this.ResolveType_NoLock(operand.Position);
			return type.ToTypeSig(true);
		}

		TypeSpec ApplyGenerics(ITypeDefOrRef type, IList<TypeSig> generics)
		{
			ClassOrValueTypeSig typeSig = type.ToTypeSig().ToClassOrValueTypeSig();
			GenericInstSig genericSig = new GenericInstSig(typeSig, generics);
			return new TypeSpecUser(genericSig);
		}

		/// <summary>
		/// Create a TypeSpec from a type and data with generic arguments.
		/// from deserialized data to an existing type.
		/// </summary>
		/// <param name="type">Existing type</param>
		/// <param name="data">Deserialized data with generic types</param>
		/// <returns>GenericInstSig</returns>
		TypeSpec ApplyGenerics(ITypeDefOrRef type, TypeData data)
		{
			List<TypeSig> generics = new List<TypeSig>();
			foreach (var g in data.GenericTypes)
			{
				var gtype = this.ResolveType_NoLock(g.Position);
				generics.Add(gtype.ToTypeSig());
			}

			return ApplyGenerics(type, generics);

			//List<TypeSig> types = new List<TypeSig>();
			//foreach (var g in data.GenericTypes)
			//{
			//	var gtype = this.ResolveType_NoLock(g.Position);
			//	types.Add(gtype.ToTypeSig());
			//}
			//
			//ClassOrValueTypeSig typeSig = type.ToTypeSig().ToClassOrValueTypeSig();
			//// return new GenericInstSig(typeSig, types).ToTypeDefOrRef();
			//
			//GenericInstSig genericSig = new GenericInstSig(typeSig, types);
			//TypeSpec typeSpec = new TypeSpecUser(genericSig);
			//return typeSpec;
		}

		IList<MethodSig> PossibleMethodSigs(ITypeDefOrRef declaringType, MethodSig sig, MethodData data)
		{
			// Setup generic types
			IList<TypeSig> typeGenerics = new List<TypeSig>(), methodGenerics = new List<TypeSig>();

			// Add all declaring spec generic types
			TypeSpec declaringSpec = declaringType as TypeSpec;
			if (declaringSpec != null)
			{
				var genericInstSig = declaringSpec.TryGetGenericInstSig();
				foreach (var garg in genericInstSig.GenericArguments)
					typeGenerics.Add(garg);
			}

			// Add all method generic types
			if (data.HasGenericArguments)
			{
				foreach (var operand in data.GenericArguments)
				{
					var gtype = this.ResolveType_NoLock(operand.Position);
					methodGenerics.Add(gtype.ToTypeSig());
				}
			}

			// Todo: Combinations factoring in the possibility that return type might match
			// a generic type
			TypeSig returnType = ResolveType(data.ReturnType);
			IList<TypeSig> returnTypes = GenericUtils.PossibleTypeSigs(returnType, typeGenerics, methodGenerics);

			TypeSig[] paramTypes = new TypeSig[data.Parameters.Length];
			for (Int32 i = 0; i < paramTypes.Length; i++)
			{
				paramTypes[i] = ResolveType(data.Parameters[i]);
			}

			UInt32 genericTypeCount = (UInt32)data.GenericArguments.Length;

			IList<MethodSig> signatures = new List<MethodSig>();
			var paramCombos = GenericUtils.CreateGenericParameterCombinations(paramTypes, typeGenerics, methodGenerics);

			foreach (var rType in returnTypes)
			{
				foreach (var combo in paramCombos)
				{
					var paramCombo = combo.ToArray();

					MethodSig methodSig;

					if (genericTypeCount == 0)
					{
						if (data.IsStatic)
							methodSig = MethodSig.CreateStatic(rType, paramCombo);
						else
							methodSig = MethodSig.CreateInstance(rType, paramCombo);
					}
					else
					{
						if (data.IsStatic)
							methodSig = MethodSig.CreateStaticGeneric(genericTypeCount, rType, paramCombo);
						else
							methodSig = MethodSig.CreateInstanceGeneric(genericTypeCount, rType, paramCombo);
					}

					signatures.Add(methodSig);
				}
			}

			return signatures;
		}

		/// <summary>
		/// Convert some EazCall data into a method signature.
		/// </summary>
		/// <param name="data">Data</param>
		/// <returns>Signature</returns>
		MethodSig GetMethodSig(EazCallData data)
		{
			var returnType = this.ResolveType_NoLock(data.ReturnType).ToTypeSig(true);
			var paramTypes = data.Parameters.Select((p) => {
				return this.ResolveType_NoLock(p.Type).ToTypeSig(true);
			}).ToArray();

			// Unsure about how EazCallData stores/handles generics

			if (data.IsStatic)
				return MethodSig.CreateStatic(returnType, paramTypes);
			else
			{
				paramTypes = paramTypes.Skip(1).ToArray();
				return MethodSig.CreateInstance(returnType, paramTypes);
			}
		}

		/// <summary>
		/// Convert some method data into a method signature.
		/// </summary>
		/// <param name="data">Data</param>
		/// <returns>Signature</returns>
		MethodSig GetMethodSig(MethodData data)
		{
			TypeSig returnType = ResolveType(data.ReturnType);

			TypeSig[] paramTypes = new TypeSig[data.Parameters.Length];
			for (Int32 i = 0; i < paramTypes.Length; i++)
			{
				paramTypes[i] = ResolveType(data.Parameters[i]);
			}

			UInt32 genericTypeCount = (UInt32)data.GenericArguments.Length;

			MethodSig methodSig;
			if (genericTypeCount == 0)
			{
				if (data.IsStatic)
					methodSig = MethodSig.CreateStatic(returnType, paramTypes);
				else
					methodSig = MethodSig.CreateInstance(returnType, paramTypes);
			}
			else
			{
				if (data.IsStatic)
					methodSig = MethodSig.CreateStaticGeneric(genericTypeCount, returnType, paramTypes);
				else
					methodSig = MethodSig.CreateInstanceGeneric(genericTypeCount, returnType, paramTypes);
			}

			return methodSig;
		}

		/// <summary>
		/// Apply type "modifiers" to some TypeSig given a modifiers stack.
		/// </summary>
		/// <param name="typeSig">TypeSig</param>
		/// <param name="modifiers">Modifiers stack</param>
		/// <returns>TypeSig</returns>
		TypeSig ApplyTypeModifiers(TypeSig typeSig, Stack<String> modifiers)
		{
			// This might not be implemented correctly
			typeSig = this.FixTypeAsArray(typeSig, modifiers);
			typeSig = this.FixTypeAsRefOrPointer(typeSig, modifiers);
			return typeSig;
		}

		/// <summary>
		/// Apply array "modifiers" to a TypeSig.
		/// </summary>
		/// <param name="typeSig">TypeSig</param>
		/// <param name="modifiers">Modifiers stack</param>
		/// <returns>TypeSig</returns>
		TypeSig FixTypeAsArray(TypeSig typeSig, Stack<String> modifiers)
		{
			UInt32 rank = 0;

			while(modifiers.Count > 0 && modifiers.Peek().Equals("[]"))
			{
				modifiers.Pop();
				rank++;
			}

			if (rank == 0)
				return typeSig;
			else if (rank == 1)
				return new SZArraySig(typeSig);
			else // Might want to wrap in N SZArraySigs instead of ArraySig(type, N)?
				return new ArraySig(typeSig, rank);
		}

		/// <summary>
		/// Apply ByRef or Ptr "modifiers" to a TypeSig depending on the given modifiers
		/// stack.
		/// </summary>
		/// <param name="typeSig">TypeSig</param>
		/// <param name="modifiers">Modifiers stack</param>
		/// <returns>TypeSig</returns>
		TypeSig FixTypeAsRefOrPointer(TypeSig typeSig, Stack<String> modifiers)
		{
			while(modifiers.Count > 0
				&& (modifiers.Peek().Equals("*") || modifiers.Peek().Equals("&")))
			{
				if(modifiers.Pop().Equals("*")) // Pointer
				{
					typeSig = new PtrSig(typeSig);
				}
				else // ByRef
				{
					typeSig = new ByRefSig(typeSig);
				}
			}

			return typeSig;
		}
	}
}



================================================
File: src/eazdevirt/IO/ResourceReader.cs
================================================
ï»¿using System;
using System.IO;
using dnlib.DotNet;

namespace eazdevirt.IO
{
	public abstract class ResourceReader
	{
		/// <summary>
		/// Parent module.
		/// </summary>
		public EazModule Parent { get; private set; }

		/// <summary>
		/// Module.
		/// </summary>
		public ModuleDefMD Module { get { return this.Parent.Module; } }

		/// <summary>
		/// Embedded resource stream.
		/// </summary>
		public CryptoStreamBase Stream { get; private set; }

		/// <summary>
		/// Embedded Resource reader.
		/// </summary>
		public BinaryReader Reader { get; private set; }

		public ResourceReader(EazModule module)
		{
			if (module == null)
				throw new ArgumentNullException();

			this.Parent = module;
			this.Initialize();
		}

		private void Initialize()
		{
			this.Stream = (CryptoStreamBase)this.Parent.GetResourceStream();
			this.Reader = new BinaryReader(this.Stream);
		}
	}
}



================================================
File: src/eazdevirt/IO/VirtualizedMethodBodyReader.cs
================================================
ï»¿using System;
using System.IO;
using System.Collections.Generic;
using de4dot.blocks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace eazdevirt.IO
{
	public class VirtualizedMethodBodyReader : ResourceReader
	{
		/// <summary>
		/// Method stub of virtualized method.
		/// </summary>
		public MethodStub Method { get; private set; }

		/// <summary>
		/// Size of the method body in bytes.
		/// </summary>
		public Int32 CodeSize { get; private set; }

		/// <summary>
		/// Get the initial position into the embedded resource to begin reading at.
		/// </summary>
		public Int64 InitialPosition
		{
			get { return this.Parent.PositionTranslator.ToPosition(this.Method.PositionString, this.Method.ResourceCryptoKey); }
		}

		/// <summary>
		/// Instructions that make up the method body. Is null until read.
		/// </summary>
		public IList<Instruction> Instructions { get; private set; }

		/// <summary>
		/// Whether or not the instructions have been read and set.
		/// </summary>
		public Boolean HasInstructions { get { return this.Instructions != null; } }

		/// <summary>
		/// Whether or not all instructions in this virtual method have been successfully read.
		/// Only set after reading the last instruction.
		/// </summary>
		public Boolean FullyRead { get; private set; }

		public VirtualizedMethodInfo Info { get; private set; }

		/// <summary>
		/// Exception handlers. Not set until the method is read.
		/// </summary>
		public IList<ExceptionHandler> ExceptionHandlers { get; private set; }

		/// <summary>
		/// Current IL offset into the method body (byte-wise).
		/// </summary>
		public UInt32 CurrentILOffset { get; private set; }

		/// <summary>
		/// Current virtual offset into the method body (byte-wise).
		/// </summary>
		public UInt32 CurrentVirtualOffset { get; private set; }

		/// <summary>
		/// The last-read virtual opcode.
		/// </summary>
		public Int32 LastVirtualOpCode { get; private set; }

		/// <summary>
		/// Current offset into the method body (instruction-wise).
		/// </summary>
		public UInt32 CurrentInstructionOffset { get; private set; }

		/// <summary>
		/// Resolver.
		/// </summary>
		public Resolver Resolver { get; private set; }

		/// <summary>
		/// Map of IL offsets to virtual offsets.
		/// </summary>
		public Dictionary<UInt32, UInt32> VirtualOffsets { get; private set; }

		/// <summary>
		/// Serialization version. Determines how certain things are read.
		/// </summary>
		public SerializationVersion Version { get; private set; }

		/// <summary>
		/// Logger.
		/// </summary>
		public ILogger Logger { get; private set; }

		/// <summary>
		/// Serialized exception handlers read from the embedded resource. After the method body is
		/// read, these will be translated to dnlib ExceptionHandlers.
		/// </summary>
		private IList<SerializedExceptionHandler> _exceptionHandlers;

		/// <summary>
		/// Construct a method body reader given a method stub.
		/// </summary>
		/// <param name="method">Method stub</param>
		/// <param name="version">Serialization version</param>
		public VirtualizedMethodBodyReader(MethodStub method,
			SerializationVersion version = SerializationVersion.V1)
			: this(method, null, version)
		{
		}

		/// <summary>
		/// Construct a method body reader given a method stub.
		/// </summary>
		/// <param name="method">Method stub</param>
		/// <param name="logger">Logger</param>
		/// <param name="version">Serialization version</param>
		public VirtualizedMethodBodyReader(MethodStub method, ILogger logger,
			SerializationVersion version = SerializationVersion.V1)
			: base((method != null ? method.Parent : null))
		{
			if (method == null)
				throw new ArgumentNullException();

			this.Method = method;
			this.Logger = (logger != null ? logger : DummyLogger.NoThrowInstance);
			this.Version = version;

			this.Initialize();
		}

		/// <summary>
		/// Set the ExceptionHandlers property to a list of dnlib ExceptionHandlers.
		/// </summary>
		protected void FixExceptionHandlers()
		{
			this.ExceptionHandlers = this.GetExceptionHandlers();
		}

		/// <summary>
		/// Convert all SerializedExceptionHandlers to dnlib ExceptionHandlers.
		/// </summary>
		/// <returns>List of ExceptionHandlers</returns>
		IList<ExceptionHandler> GetExceptionHandlers()
		{
			IList<ExceptionHandler> handlers = new List<ExceptionHandler>();
			for (Int32 i = 0; i < _exceptionHandlers.Count; i++)
				handlers.Add(this.GetExceptionHandler(i));
			return handlers;
		}

		/// <summary>
		/// Convert the SerializedExceptionHandler at some index to a dnlib ExceptionHandler
		/// and return it.
		/// </summary>
		/// <param name="index">Index</param>
		/// <returns>ExceptionHandler</returns>
		ExceptionHandler GetExceptionHandler(Int32 index)
		{
			var deserialized = _exceptionHandlers[index];

			ExceptionHandler handler = new ExceptionHandler(deserialized.HandlerType);
			if (deserialized.HasCatchType)
				handler.CatchType = this.Resolver.ResolveType(deserialized.VirtualCatchType);

			handler.TryStart = GetInstruction(this.GetRealOffset(deserialized.VirtualTryStart));

			// VirtualTryEnd actually points to virtual instruction before the actual end
			handler.TryEnd = GetInstruction(this.GetRealOffset(deserialized.VirtualTryEnd));
			if (GetInstructionAfter(handler.TryEnd) != null)
				handler.TryEnd = GetInstructionAfter(handler.TryEnd);

			handler.HandlerStart = GetInstruction(this.GetRealOffset(deserialized.VirtualHandlerStart));

			// VirtualHandlerEnd does the same as VirtualTryEnd
			handler.HandlerEnd = GetInstruction(this.GetRealOffset(deserialized.VirtualHandlerEnd));
			if (GetInstructionAfter(handler.HandlerEnd) != null)
				handler.HandlerEnd = GetInstructionAfter(handler.HandlerEnd);

			handler.FilterStart = GetInstruction(this.GetRealOffset(deserialized.VirtualFilterStart));

			return handler;
		}

		private void Initialize()
		{
			/*
			var moduleDef = this.Module.Module;
			this.Resource = moduleDef.Resources.FindEmbeddedResource(this.Method.ResourceStringId);

			if (this.Resource == null)
				throw new Exception("Unable to find embedded resource");

			// Open stream + reader and seek to initial position
			this.Stream = new EazCryptoStream(this.Resource.GetResourceStream(), this.Method.ResourceCryptoKey);
			DnBinaryReader reader = new DnBinaryReader(this.Stream);
			this.Reader = reader; // BinaryReader
			this.Stream.Position = this.InitialPosition;
			*/

			this.Stream.Position = this.InitialPosition;
			this.Resolver = new Resolver(this.Parent, this.Logger, this.Version);
			this.VirtualOffsets = new Dictionary<UInt32, UInt32>();
			this.ExceptionHandlers = new ExceptionHandler[0];
		}

		public void Read()
		{
			BinaryReader reader = this.Reader;

			if (this.Version == SerializationVersion.V1)
			{
				if (reader.ReadByte() != 0)
					throw new InvalidDataException();
			}

			// Read virtualized method info
			this.Info = new VirtualizedMethodInfo(reader);

			// Read exception handlers
			Int32 count = (Int32)reader.ReadInt16();
			_exceptionHandlers = new SerializedExceptionHandler[count];
			for (Int32 i = 0; i < _exceptionHandlers.Count; i++)
				_exceptionHandlers[i] = new SerializedExceptionHandler(reader);

			//if (count > 0)
			//{
			//	Console.WriteLine("Exception Handlers ({0}):", count);
			//	for (Int32 i = 0; i < _exceptionHandlers.Count; i++)
			//	{
			//		var handler = _exceptionHandlers[i];
			//		Console.WriteLine(" Exception handler {0}:", i);
			//		Console.WriteLine("  Handler Type:  {0}", handler.VirtualHandlerType);
			//
			//		if(handler.HasCatchType)
			//			Console.WriteLine("  Catch Type:    {0}", this.Resolver.ResolveType(handler.VirtualCatchType).FullName);
			//		else
			//			Console.WriteLine("  Catch Type:    {0}", handler.VirtualCatchType);
			//
			//		Console.WriteLine("  Try start:     {0}", handler.VirtualTryStart);
			//		Console.WriteLine("  Try end:       {0}", handler.VirtualTryEnd);
			//		Console.WriteLine("  Handler start: {0}", handler.VirtualHandlerStart);
			//		Console.WriteLine("  Handler end:   {0}", handler.VirtualHandlerEnd);
			//		Console.WriteLine("  Filter start:  {0}", handler.VirtualFilterStart);
			//	}
			//}

			// Set locals and parameters
			this.SetLocalsAndParameters();

			// Read instructions
			this.CodeSize = reader.ReadInt32();
			this.ReadInstructions();
		}

		protected void SetLocalsAndParameters()
		{
			ITypeDefOrRef type;

			foreach(var local in this.Info.Locals)
			{
				type = this.Resolver.ResolveType(local.TypeCode);

				if(type != null)
					this.Locals.Add(new Local(type.ToTypeSig(true)));
				else
					this.Logger.Verbose(this, "[SetLocalsAndParameters] WARNING: Unable to resolve local type");
			}

			for(Int32 i = 0; i < this.Info.Parameters.Length; i++)
			{
				var parameter = this.Info.Parameters[i];
				type = this.Resolver.ResolveType(parameter.TypeCode);

				if(type != null)
					this.Parameters.Add(new Parameter(i, type.ToTypeSig(true)));
				else
					this.Logger.Verbose(this, "[SetLocalsAndParameters] WARNING: Unable to resolve parameter type");
			}
		}

		/// <summary>
		/// Reads all instructions
		/// </summary>
		protected void ReadInstructions()
		{
			this.ReadInstructionsNumBytes(this.CodeSize);
		}

		/// <summary>
		/// Read all the instructions in a byte region.
		/// </summary>
		/// <param name="codeSize">Size of region in bytes</param>
		protected void ReadInstructionsNumBytes(Int32 codeSize)
		{
			// List<Instruction> instructions = new List<Instruction>();
			this.Instructions = new List<Instruction>();

			Int64 finalPosition = this.Stream.Position + codeSize;
			while(this.Stream.Position < finalPosition)
				this.Instructions.Add(this.ReadOneInstruction());

			// After fully read, branch operands can be fixed
			this.FixBranches();

			// Also set real exception handlers
			this.FixExceptionHandlers();

			//this.Instructions = instructions;
			this.FullyRead = true;
		}

		protected Instruction ReadOneInstruction_CIL(VirtualOpCode virtualInstruction)
		{
			OpCode opcode = virtualInstruction.OpCode.ToOpCode();

			Instruction instruction = new Instruction(opcode);
			instruction.Offset = this.CurrentILOffset;
			instruction.OpCode = opcode;
			instruction.Operand = this.ReadOperand(instruction);

			if (instruction.OpCode.Code == Code.Switch)
			{
				var targets = (IList<UInt32>)instruction.Operand;
				this.CurrentILOffset += (UInt32)(instruction.OpCode.Size + 4 + (4 * targets.Count));
				this.CurrentVirtualOffset += (UInt32)(4 + 4 + (4 * targets.Count));
			}
			else
			{
				this.CurrentILOffset += (UInt32)instruction.GetSize();
				this.CurrentVirtualOffset += (UInt32)virtualInstruction.GetSize(instruction.Operand);
			}

			this.CurrentInstructionOffset++;

			return instruction;
		}

		protected Instruction ReadOneInstruction_Special(VirtualOpCode virtualInstruction)
		{
			//this.Logger.Verbose(this, "Special Opcode ({0}, delegate MDToken = 0x{1:X8})",
			//	virtualInstruction.SpecialOpCode.ToString(),
			//	virtualInstruction.DelegateMethod.MDToken.Raw
			//);

			// Have a method for this?
			OpCode opcode = null;
			switch(virtualInstruction.SpecialOpCode)
			{
				case SpecialCode.Eaz_Call:
					opcode = Code.Call.ToOpCode(); // Or Callvirt?
					break;
			}

			if(opcode == null)
			{
				throw new Exception(String.Format(
					"Cannot convert SpecialOpCode to CIL OpCode: {0}",
					virtualInstruction.SpecialOpCode
				));
			}

			Object operand = this.ReadSpecialOperand(virtualInstruction);

			Instruction instruction = new Instruction(opcode);
			instruction.Offset = this.CurrentILOffset;
			instruction.OpCode = opcode;
			instruction.Operand = operand; // this.ReadOperand(instruction);

			this.CurrentILOffset += (UInt32)instruction.GetSize();
			this.CurrentVirtualOffset += (UInt32)virtualInstruction.GetSize(instruction.Operand);

			this.CurrentInstructionOffset++;

			return instruction;
		}

		/// <summary>
		/// Read a virtual instruction as a CIL instruction.
		/// </summary>
		/// <returns>CIL instruction</returns>
		protected Instruction ReadOneInstruction()
		{
			Int32 virtualOpcode = this.Reader.ReadInt32();
			this.LastVirtualOpCode = virtualOpcode;

			VirtualOpCode virtualInstruction;
			if (!this.Parent.IdentifiedOpCodes.TryGetValue(virtualOpcode, out virtualInstruction))
				//throw new Exception(String.Format("Unknown virtual opcode: {0}", virtualOpcode));
				throw new OriginalOpcodeUnknownException(virtualInstruction);

			this.VirtualOffsets.Add(this.CurrentILOffset, this.CurrentVirtualOffset);

			if (virtualInstruction.HasCILOpCode)
				return ReadOneInstruction_CIL(virtualInstruction);
			else
				return ReadOneInstruction_Special(virtualInstruction);
		}

		/// <summary>
		/// Read a virtual operand.
		/// </summary>
		/// <param name="code">CIL opcode</param>
		/// <param name="operandType">Operand type</param>
		/// <returns>Operand object, or null if unsupported operand type</returns>
		//protected Object ReadOperand(Code code, OperandType operandType)
		protected Object ReadOperand(Instruction instr)
		{
			BinaryReader reader = this.Reader;
			ModuleDefMD module = this.Module;

			// Todo: Fix some of these to factor in current offset
			switch(instr.OpCode.OperandType)
			{
				case OperandType.InlineSwitch:
					return this.ReadInlineSwitch(instr);
				case OperandType.ShortInlineBrTarget:
					return this.ReadShortInlineBrTarget(instr);
				case OperandType.ShortInlineI:
					if (instr.OpCode.Code == Code.Ldc_I4_S)
						return this.Reader.ReadSByte();
					else
						return this.Reader.ReadByte();
				case OperandType.InlineBrTarget: // ?
					return this.ReadInlineBrTarget(instr);
				case OperandType.InlineI:
					return this.Reader.ReadInt32();
				case OperandType.InlineI8:
					return this.Reader.ReadInt64();
				case OperandType.InlineR:
					return this.Reader.ReadDouble();
				case OperandType.ShortInlineR:
					return this.Reader.ReadSingle();
				case OperandType.InlineVar:
					return this.ReadInlineVar(instr);
				case OperandType.ShortInlineVar:
					return this.ReadShortInlineVar(instr);

				// Resolving
				case OperandType.InlineMethod:
					return this.ReadInlineMethod(instr);
				case OperandType.InlineType:
					return this.ReadInlineType(instr);
				case OperandType.InlineField:
					//return module.ResolveField(reader.ReadUInt32());
					return this.ReadInlineField(instr);
				case OperandType.InlineSig:
					// Supposed to return a MethodSig...?
					//return module.ResolveStandAloneSig(reader.ReadUInt32());
					return this.ReadInlineSig(instr);
				case OperandType.InlineTok:
					// Todo: GenericParamContext support, see ReadInlineTok of MethodBodyReader
					//return module.ResolveToken(reader.ReadInt32()) as ITokenOperand;
					return this.ReadInlineTok(instr);
				case OperandType.InlineString:
					//return module.ReadUserString(reader.ReadUInt32());
					return this.ReadInlineString(instr);
			}

			return null;
		}

		/// <summary>
		/// Read a virtual operand of a special instruction.
		/// </summary>
		/// <param name="virtualOpCode">Special virtual opcode</param>
		/// <returns>Operand object, or null if unsupported operand type</returns>
		protected Object ReadSpecialOperand(VirtualOpCode virtualOpCode)
		{
			switch (virtualOpCode.SpecialOpCode)
			{
				case SpecialCode.Eaz_Call:
					return this.Resolver.ResolveEazCall(this.Reader.ReadInt32());
			}

			return null;
		}

		/// <summary>
		/// Translates a virtual offset to an IL offset.
		/// </summary>
		/// <param name="virtualOffset">Virtual offset used as virtual branch operand</param>
		/// <returns>Real offset, or UInt32.MaxValue if couldn't translate</returns>
		public UInt32 GetRealOffset(UInt32 virtualOffset)
		{
			foreach(var kvp in this.VirtualOffsets)
			{
				if (kvp.Value == virtualOffset)
					return kvp.Key;
			}

			return UInt32.MaxValue;
		}

		/// <summary>
		/// Fixes all branch instructions so their operands are set to an <see cref="Instruction"/>
		/// instead of a virtual offset.
		/// </summary>
		void FixBranches()
		{
			foreach(var instr in this.Instructions)
			{
				switch(instr.OpCode.OperandType)
				{
					case OperandType.InlineBrTarget:
					case OperandType.ShortInlineBrTarget:
						UInt32 realOffset = this.GetRealOffset((UInt32)instr.Operand);
						instr.Operand = this.GetInstruction(realOffset);
						break;

					case OperandType.InlineSwitch:
						Int32[] virtualOffsets = instr.Operand as Int32[];
						Instruction[] destinations = new Instruction[virtualOffsets.Length];
						for (Int32 i = 0; i < virtualOffsets.Length; i++)
							destinations[i] = this.GetInstruction(this.GetRealOffset((UInt32)virtualOffsets[i]));
						instr.Operand = destinations;
						break;
				}
			}
		}

		/// <summary>
		/// Get the instruction after the specified instruction in the list.
		/// </summary>
		/// <param name="instruction">Specified instruction</param>
		/// <returns>
		/// Instruction afterwards, or null if specified instruction not found
		/// or specified instruction last in the list
		/// </returns>
		protected Instruction GetInstructionAfter(Instruction instruction)
		{
			for (Int32 i = 0; i < this.Instructions.Count; i++)
			{
				if (this.Instructions[i] == instruction
					&& i < (this.Instructions.Count - 1))
					return this.Instructions[i + 1];
			}

			return null;
		}

		/// <summary>
		/// Finds an instruction
		/// </summary>
		/// <param name="offset">Offset of instruction</param>
		/// <returns>The instruction or <c>null</c> if there's no instruction at <paramref name="offset"/>.</returns>
		/// <remarks>Copied from MethodBodyReaderBase</remarks>
		protected Instruction GetInstruction(uint offset)
		{
			// The instructions are sorted and all Offset fields are correct. Do a binary search.
			int lo = 0, hi = this.Instructions.Count - 1;
			while (lo <= hi)
			{
				int i = (lo + hi) / 2;
				var instr = this.Instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}

		protected virtual IVariable ReadInlineVar(Instruction instr)
		{
			if (IsArgOperandInstruction(instr))
				return this.GetArgument(this.Reader.ReadUInt16());
			return this.GetLocal(this.Reader.ReadUInt16());
		}

		protected virtual IVariable ReadShortInlineVar(Instruction instr)
		{
			if (IsArgOperandInstruction(instr))
				return this.GetArgument(this.Reader.ReadByte());
			return this.GetLocal(this.Reader.ReadByte());
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineBrTarget"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		/// <remarks>Copied from MethodBodyReaderBase</remarks>
		protected virtual UInt32 ReadInlineBrTarget(Instruction instr)
		{
			//return instr.Offset + (UInt32)instr.GetSize() + this.Reader.ReadUInt32();
			return (UInt32)this.Reader.ReadUInt32();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineBrTarget"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		/// <remarks>Copied from MethodBodyReaderBase</remarks>
		protected virtual UInt32 ReadShortInlineBrTarget(Instruction instr)
		{
			//return instr.Offset + (UInt32)instr.GetSize() + (UInt32)this.Reader.ReadSByte();
			return (UInt32)this.Reader.ReadSByte();
		}

		protected virtual UInt32[] ReadInlineSwitch(Instruction instr)
		{
			UInt32 destCount = this.Reader.ReadUInt32();
			UInt32[] branchDests = new UInt32[destCount];
			for (UInt32 i = 0; i < destCount; i++)
				branchDests[i] = this.Reader.ReadUInt32();
			return branchDests;
		}

		protected virtual IField ReadInlineField(Instruction instruction)
		{
			return this.Resolver.ResolveField(this.Reader.ReadInt32());
		}

		protected virtual MethodSig ReadInlineSig(Instruction instruction)
		{
			throw new NotSupportedException();
		}

		protected virtual ITokenOperand ReadInlineTok(Instruction instruction)
		{
			return this.Resolver.ResolveToken(this.Reader.ReadInt32());
		}

		protected virtual IMethod ReadInlineMethod(Instruction instruction)
		{
			return this.Resolver.ResolveMethod(this.Reader.ReadInt32());
		}

		protected virtual ITypeDefOrRef ReadInlineType(Instruction instruction)
		{
			return this.Resolver.ResolveType(this.Reader.ReadInt32());
		}

		protected virtual String ReadInlineString(Instruction instruction)
		{
			return this.Resolver.ResolveString(this.Reader.ReadInt32());
		}

		public IList<Parameter> Parameters = new List<Parameter>();

		/// <summary>
		/// Translate the specified SerializedParameter to a dnlib Parameter and return it.
		/// </summary>
		/// <param name="index">Index</param>
		/// <returns>Parameter</returns>
		public Parameter GetArgument(UInt16 index)
		{
			if (index < this.Parameters.Count)
				return this.Parameters[index];
			else return null;
		}

		public IList<Local> Locals = new List<Local>();
		//public LocalList Locals = new LocalList();

		/// <summary>
		/// Translate the specified SerializedLocal to a dnlib Local and return it.
		/// </summary>
		/// <param name="index">Index</param>
		/// <returns>Local</returns>
		public Local GetLocal(UInt16 index)
		{
			if (index < this.Locals.Count)
				return this.Locals[index];
			else return null;
		}

		/// <summary>
		/// Returns <c>true</c> if it's one of the ldarg/starg instructions that have an operand
		/// </summary>
		/// <param name="instr">The instruction to check</param>
		/// <remarks>Copied from dnlib</remarks>
		protected static bool IsArgOperandInstruction(Instruction instr)
		{
			switch (instr.OpCode.Code)
			{
				case Code.Ldarg:
				case Code.Ldarg_S:
				case Code.Ldarga:
				case Code.Ldarga_S:
				case Code.Starg:
				case Code.Starg_S:
					return true;
				default:
					return false;
			}
		}

		/// <summary>
		/// Serialized virtualized method info.
		/// </summary>
		public class VirtualizedMethodInfo
		{
			public Boolean Unknown1 { get; set; }
			public Int32 ReturnTypeCode { get; set; }
			public Int32 Unknown3 { get; set; }
			public String Name { get; set; }
			public SerializedParameter[] Parameters { get; set; }
			public SerializedLocal[] Locals { get; set; }

			public VirtualizedMethodInfo(BinaryReader reader)
			{
				this.Deserialize(reader);
			}

			private void Deserialize(BinaryReader reader)
			{
				this.Unknown1 = reader.ReadBoolean();
				this.ReturnTypeCode = reader.ReadInt32();
				this.Unknown3 = reader.ReadInt32();
				this.Name = reader.ReadString();

				Int32 count = (Int32)reader.ReadInt16();
				this.Parameters = new SerializedParameter[count];
				for (Int32 i = 0; i < count; i++)
					this.Parameters[i] = new SerializedParameter(reader);

				count = (Int32)reader.ReadInt16();
				this.Locals = new SerializedLocal[count];
				for (Int32 i = 0; i < count; i++)
					this.Locals[i] = new SerializedLocal(reader);
			}
		}

		/// <remarks>Unsure</remarks>
		public class SerializedParameter
		{
			/// <summary>
			/// Type code.
			/// </summary>
			public Int32 TypeCode { get; set; }

			/// <summary>
			/// True if In, false if Out.
			/// </summary>
			public Boolean In { get; set; }

			public SerializedParameter(BinaryReader reader)
			{
				this.Deserialize(reader);
			}

			private void Deserialize(BinaryReader reader)
			{
				this.TypeCode = reader.ReadInt32();
				this.In = reader.ReadBoolean();
			}
		}

		/// <remarks>Unsure</remarks>
		public class SerializedLocal
		{
			public Int32 TypeCode { get; set; }

			public SerializedLocal(BinaryReader reader)
			{
				this.Deserialize(reader);
			}

			private void Deserialize(BinaryReader reader)
			{
				this.TypeCode = reader.ReadInt32();
			}
		}

		/// <remarks>Might have to do with generics?</remarks>
		public class SerializedExceptionHandler
		{
			public Int32 VirtualHandlerType { get; set; }
			public Int32 VirtualCatchType { get; set; }
			public UInt32 VirtualTryStart { get; set; }
			public UInt32 VirtualTryLength { get; set; }
			public UInt32 VirtualHandlerStart { get; set; }
			public UInt32 VirtualHandlerLength { get; set; }
			public UInt32 VirtualFilterStart { get; set; }

			/// <summary>
			/// The calculated TryEnd virtual offset.
			/// </summary>
			public UInt32 VirtualTryEnd
			{
				get { return this.VirtualTryStart + this.VirtualTryLength; }
			}

			/// <summary>
			/// The calculated HandlerEnd virtual offset.
			/// </summary>
			public UInt32 VirtualHandlerEnd
			{
				get { return this.VirtualHandlerStart + this.VirtualHandlerLength; }
			}

			/// <summary>
			/// The dnlib HandlerType of this SerializedExceptionHandler.
			/// </summary>
			public ExceptionHandlerType HandlerType
			{
				get
				{
					switch(VirtualHandlerType)
					{
						case 0: return ExceptionHandlerType.Catch;
						case 2: return ExceptionHandlerType.Finally;
						default: throw new NotSupportedException();
					}
				}
			}

			/// <summary>
			/// Whether or not the virtual catch type (position) is non-negative, should
			/// only be true if the HandlerType is Catch.
			/// </summary>
			public Boolean HasCatchType
			{
				get { return this.VirtualCatchType >= 0; }
			}

			public SerializedExceptionHandler(BinaryReader reader)
			{
				this.Deserialize(reader);
			}

			private void Deserialize(BinaryReader reader)
			{
				this.VirtualHandlerType = reader.ReadInt32();
				this.VirtualCatchType = reader.ReadInt32();
				this.VirtualTryStart = reader.ReadUInt32();
				this.VirtualTryLength = reader.ReadUInt32();
				this.VirtualHandlerStart = reader.ReadUInt32();
				this.VirtualHandlerLength = reader.ReadUInt32();
				this.VirtualFilterStart = reader.ReadUInt32();
			}
		}
	}
}



================================================
File: src/eazdevirt/Logging/ConsoleLogger.cs
================================================
ï»¿using System;
using dnlib.DotNet;

namespace eazdevirt.Logging
{
	public class ConsoleLogger : ILogger
	{
		public LoggerEvent Level { get; private set; }

		public ConsoleLogger()
			: this(LoggerEvent.Info)
		{
		}

		public ConsoleLogger(LoggerEvent level)
		{
			this.Level = level;
		}

		public bool IgnoresEvent(LoggerEvent loggerEvent)
		{
			return loggerEvent > this.Level;
		}

		public void Log(object sender, LoggerEvent loggerEvent, string format, params object[] args)
		{
			if (!this.IgnoresEvent(loggerEvent))
			{
				if (sender != null)
					Console.WriteLine(String.Format(
						"[{0}] {1}", sender.GetType().FullName, String.Format(format, args)
					));
				else
					Console.WriteLine(String.Format(format, args));
			}
		}
	}
}



================================================
File: src/eazdevirt/Mono/Mono.Options.cs
================================================
ï»¿//
// Options.cs
//
// Authors:
//  Jonathan Pryor <jpryor@novell.com>
//  Federico Di Gregorio <fog@initd.org>
//  Rolf Bjarne Kvinge <rolf@xamarin.com>
//
// Copyright (C) 2008 Novell (http://www.novell.com)
// Copyright (C) 2009 Federico Di Gregorio.
// Copyright (C) 2012 Xamarin Inc (http://www.xamarin.com)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

// Compile With:
//   gmcs -debug+ -r:System.Core Options.cs -o:NDesk.Options.dll
//   gmcs -debug+ -d:LINQ -r:System.Core Options.cs -o:NDesk.Options.dll
//
// The LINQ version just changes the implementation of
// OptionSet.Parse(IEnumerable<string>), and confers no semantic changes.

//
// A Getopt::Long-inspired option parsing library for C#.
//
// NDesk.Options.OptionSet is built upon a key/value table, where the
// key is a option format string and the value is a delegate that is 
// invoked when the format string is matched.
//
// Option format strings:
//  Regex-like BNF Grammar: 
//    name: .+
//    type: [=:]
//    sep: ( [^{}]+ | '{' .+ '}' )?
//    aliases: ( name type sep ) ( '|' name type sep )*
// 
// Each '|'-delimited name is an alias for the associated action.  If the
// format string ends in a '=', it has a required value.  If the format
// string ends in a ':', it has an optional value.  If neither '=' or ':'
// is present, no value is supported.  `=' or `:' need only be defined on one
// alias, but if they are provided on more than one they must be consistent.
//
// Each alias portion may also end with a "key/value separator", which is used
// to split option values if the option accepts > 1 value.  If not specified,
// it defaults to '=' and ':'.  If specified, it can be any character except
// '{' and '}' OR the *string* between '{' and '}'.  If no separator should be
// used (i.e. the separate values should be distinct arguments), then "{}"
// should be used as the separator.
//
// Options are extracted either from the current option by looking for
// the option name followed by an '=' or ':', or is taken from the
// following option IFF:
//  - The current option does not contain a '=' or a ':'
//  - The current option requires a value (i.e. not a Option type of ':')
//
// The `name' used in the option format string does NOT include any leading
// option indicator, such as '-', '--', or '/'.  All three of these are
// permitted/required on any named option.
//
// Option bundling is permitted so long as:
//   - '-' is used to start the option group
//   - all of the bundled options are a single character
//   - at most one of the bundled options accepts a value, and the value
//     provided starts from the next character to the end of the string.
//
// This allows specifying '-a -b -c' as '-abc', and specifying '-D name=value'
// as '-Dname=value'.
//
// Option processing is disabled by specifying "--".  All options after "--"
// are returned by OptionSet.Parse() unchanged and unprocessed.
//
// Unprocessed options are returned from OptionSet.Parse().
//
// Examples:
//  int verbose = 0;
//  OptionSet p = new OptionSet ()
//    .Add ("v", v => ++verbose)
//    .Add ("name=|value=", v => Console.WriteLine (v));
//  p.Parse (new string[]{"-v", "--v", "/v", "-name=A", "/name", "B", "extra"});
//
// The above would parse the argument string array, and would invoke the
// lambda expression three times, setting `verbose' to 3 when complete.  
// It would also print out "A" and "B" to standard output.
// The returned array would contain the string "extra".
//
// C# 3.0 collection initializers are supported and encouraged:
//  var p = new OptionSet () {
//    { "h|?|help", v => ShowHelp () },
//  };
//
// System.ComponentModel.TypeConverter is also supported, allowing the use of
// custom data types in the callback type; TypeConverter.ConvertFromString()
// is used to convert the value option to an instance of the specified
// type:
//
//  var p = new OptionSet () {
//    { "foo=", (Foo f) => Console.WriteLine (f.ToString ()) },
//  };
//
// Random other tidbits:
//  - Boolean options (those w/o '=' or ':' in the option format string)
//    are explicitly enabled if they are followed with '+', and explicitly
//    disabled if they are followed with '-':
//      string a = null;
//      var p = new OptionSet () {
//        { "a", s => a = s },
//      };
//      p.Parse (new string[]{"-a"});   // sets v != null
//      p.Parse (new string[]{"-a+"});  // sets v != null
//      p.Parse (new string[]{"-a-"});  // sets v == null
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;

#if LINQ
using System.Linq;
#endif

#if TEST
using NDesk.Options;
#endif

#if NDESK_OPTIONS
namespace NDesk.Options
#else
namespace Mono.Options
#endif
{
	static class StringCoda
	{

		public static IEnumerable<string> WrappedLines(string self, params int[] widths)
		{
			IEnumerable<int> w = widths;
			return WrappedLines(self, w);
		}

		public static IEnumerable<string> WrappedLines(string self, IEnumerable<int> widths)
		{
			if (widths == null)
				throw new ArgumentNullException("widths");
			return CreateWrappedLinesIterator(self, widths);
		}

		private static IEnumerable<string> CreateWrappedLinesIterator(string self, IEnumerable<int> widths)
		{
			if (string.IsNullOrEmpty(self))
			{
				yield return string.Empty;
				yield break;
			}
			using (IEnumerator<int> ewidths = widths.GetEnumerator())
			{
				bool? hw = null;
				int width = GetNextWidth(ewidths, int.MaxValue, ref hw);
				int start = 0, end;
				do
				{
					end = GetLineEnd(start, width, self);
					char c = self[end - 1];
					if (char.IsWhiteSpace(c))
						--end;
					bool needContinuation = end != self.Length && !IsEolChar(c);
					string continuation = "";
					if (needContinuation)
					{
						--end;
						continuation = "-";
					}
					string line = self.Substring(start, end - start) + continuation;
					yield return line;
					start = end;
					if (char.IsWhiteSpace(c))
						++start;
					width = GetNextWidth(ewidths, width, ref hw);
				} while (start < self.Length);
			}
		}

		private static int GetNextWidth(IEnumerator<int> ewidths, int curWidth, ref bool? eValid)
		{
			if (!eValid.HasValue || (eValid.HasValue && eValid.Value))
			{
				curWidth = (eValid = ewidths.MoveNext()).Value ? ewidths.Current : curWidth;
				// '.' is any character, - is for a continuation
				const string minWidth = ".-";
				if (curWidth < minWidth.Length)
					throw new ArgumentOutOfRangeException("widths",
							string.Format("Element must be >= {0}, was {1}.", minWidth.Length, curWidth));
				return curWidth;
			}
			// no more elements, use the last element.
			return curWidth;
		}

		private static bool IsEolChar(char c)
		{
			return !char.IsLetterOrDigit(c);
		}

		private static int GetLineEnd(int start, int length, string description)
		{
			int end = System.Math.Min(start + length, description.Length);
			int sep = -1;
			for (int i = start; i < end; ++i)
			{
				if (description[i] == '\n')
					return i + 1;
				if (IsEolChar(description[i]))
					sep = i + 1;
			}
			if (sep == -1 || end == description.Length)
				return end;
			return sep;
		}
	}

	public class OptionValueCollection : IList, IList<string>
	{

		List<string> values = new List<string>();
		OptionContext c;

		internal OptionValueCollection(OptionContext c)
		{
			this.c = c;
		}

		#region ICollection
		void ICollection.CopyTo(Array array, int index) { (values as ICollection).CopyTo(array, index); }
		bool ICollection.IsSynchronized { get { return (values as ICollection).IsSynchronized; } }
		object ICollection.SyncRoot { get { return (values as ICollection).SyncRoot; } }
		#endregion

		#region ICollection<T>
		public void Add(string item) { values.Add(item); }
		public void Clear() { values.Clear(); }
		public bool Contains(string item) { return values.Contains(item); }
		public void CopyTo(string[] array, int arrayIndex) { values.CopyTo(array, arrayIndex); }
		public bool Remove(string item) { return values.Remove(item); }
		public int Count { get { return values.Count; } }
		public bool IsReadOnly { get { return false; } }
		#endregion

		#region IEnumerable
		IEnumerator IEnumerable.GetEnumerator() { return values.GetEnumerator(); }
		#endregion

		#region IEnumerable<T>
		public IEnumerator<string> GetEnumerator() { return values.GetEnumerator(); }
		#endregion

		#region IList
		int IList.Add(object value) { return (values as IList).Add(value); }
		bool IList.Contains(object value) { return (values as IList).Contains(value); }
		int IList.IndexOf(object value) { return (values as IList).IndexOf(value); }
		void IList.Insert(int index, object value) { (values as IList).Insert(index, value); }
		void IList.Remove(object value) { (values as IList).Remove(value); }
		void IList.RemoveAt(int index) { (values as IList).RemoveAt(index); }
		bool IList.IsFixedSize { get { return false; } }
		object IList.this[int index] { get { return this[index]; } set { (values as IList)[index] = value; } }
		#endregion

		#region IList<T>
		public int IndexOf(string item) { return values.IndexOf(item); }
		public void Insert(int index, string item) { values.Insert(index, item); }
		public void RemoveAt(int index) { values.RemoveAt(index); }

		private void AssertValid(int index)
		{
			if (c.Option == null)
				throw new InvalidOperationException("OptionContext.Option is null.");
			if (index >= c.Option.MaxValueCount)
				throw new ArgumentOutOfRangeException("index");
			if (c.Option.OptionValueType == OptionValueType.Required &&
					index >= values.Count)
				throw new OptionException(string.Format(
							c.OptionSet.MessageLocalizer("Missing required value for option '{0}'."), c.OptionName),
						c.OptionName);
		}

		public string this[int index]
		{
			get
			{
				AssertValid(index);
				return index >= values.Count ? null : values[index];
			}
			set
			{
				values[index] = value;
			}
		}
		#endregion

		public List<string> ToList()
		{
			return new List<string>(values);
		}

		public string[] ToArray()
		{
			return values.ToArray();
		}

		public override string ToString()
		{
			return string.Join(", ", values.ToArray());
		}
	}

	public class OptionContext
	{
		private Option option;
		private string name;
		private int index;
		private OptionSet set;
		private OptionValueCollection c;

		public OptionContext(OptionSet set)
		{
			this.set = set;
			this.c = new OptionValueCollection(this);
		}

		public Option Option
		{
			get { return option; }
			set { option = value; }
		}

		public string OptionName
		{
			get { return name; }
			set { name = value; }
		}

		public int OptionIndex
		{
			get { return index; }
			set { index = value; }
		}

		public OptionSet OptionSet
		{
			get { return set; }
		}

		public OptionValueCollection OptionValues
		{
			get { return c; }
		}
	}

	public enum OptionValueType
	{
		None,
		Optional,
		Required,
	}

	public abstract class Option
	{
		string prototype, description;
		string[] names;
		OptionValueType type;
		int count;
		string[] separators;
		bool hidden;

		protected Option(string prototype, string description)
			: this(prototype, description, 1, false)
		{
		}

		protected Option(string prototype, string description, int maxValueCount)
			: this(prototype, description, maxValueCount, false)
		{
		}

		protected Option(string prototype, string description, int maxValueCount, bool hidden)
		{
			if (prototype == null)
				throw new ArgumentNullException("prototype");
			if (prototype.Length == 0)
				throw new ArgumentException("Cannot be the empty string.", "prototype");
			if (maxValueCount < 0)
				throw new ArgumentOutOfRangeException("maxValueCount");

			this.prototype = prototype;
			this.description = description;
			this.count = maxValueCount;
			this.names = (this is OptionSet.Category)
				// append GetHashCode() so that "duplicate" categories have distinct
				// names, e.g. adding multiple "" categories should be valid.
				? new[] { prototype + this.GetHashCode() }
				: prototype.Split('|');

			if (this is OptionSet.Category)
				return;

			this.type = ParsePrototype();
			this.hidden = hidden;

			if (this.count == 0 && type != OptionValueType.None)
				throw new ArgumentException(
						"Cannot provide maxValueCount of 0 for OptionValueType.Required or " +
							"OptionValueType.Optional.",
						"maxValueCount");
			if (this.type == OptionValueType.None && maxValueCount > 1)
				throw new ArgumentException(
						string.Format("Cannot provide maxValueCount of {0} for OptionValueType.None.", maxValueCount),
						"maxValueCount");
			if (Array.IndexOf(names, "<>") >= 0 &&
					((names.Length == 1 && this.type != OptionValueType.None) ||
					 (names.Length > 1 && this.MaxValueCount > 1)))
				throw new ArgumentException(
						"The default option handler '<>' cannot require values.",
						"prototype");
		}

		public string Prototype { get { return prototype; } }
		public string Description { get { return description; } }
		public OptionValueType OptionValueType { get { return type; } }
		public int MaxValueCount { get { return count; } }
		public bool Hidden { get { return hidden; } }

		public string[] GetNames()
		{
			return (string[])names.Clone();
		}

		public string[] GetValueSeparators()
		{
			if (separators == null)
				return new string[0];
			return (string[])separators.Clone();
		}

		protected static T Parse<T>(string value, OptionContext c)
		{
			Type tt = typeof(T);
			bool nullable = tt.IsValueType && tt.IsGenericType &&
				!tt.IsGenericTypeDefinition &&
				tt.GetGenericTypeDefinition() == typeof(Nullable<>);
			Type targetType = nullable ? tt.GetGenericArguments()[0] : typeof(T);
			TypeConverter conv = TypeDescriptor.GetConverter(targetType);
			T t = default(T);
			try
			{
				if (value != null)
					t = (T)conv.ConvertFromString(value);
			}
			catch (Exception e)
			{
				throw new OptionException(
						string.Format(
							c.OptionSet.MessageLocalizer("Could not convert string `{0}' to type {1} for option `{2}'."),
							value, targetType.Name, c.OptionName),
						c.OptionName, e);
			}
			return t;
		}

		internal string[] Names { get { return names; } }
		internal string[] ValueSeparators { get { return separators; } }

		static readonly char[] NameTerminator = new char[] { '=', ':' };

		private OptionValueType ParsePrototype()
		{
			char type = '\0';
			List<string> seps = new List<string>();
			for (int i = 0; i < names.Length; ++i)
			{
				string name = names[i];
				if (name.Length == 0)
					throw new ArgumentException("Empty option names are not supported.", "prototype");

				int end = name.IndexOfAny(NameTerminator);
				if (end == -1)
					continue;
				names[i] = name.Substring(0, end);
				if (type == '\0' || type == name[end])
					type = name[end];
				else
					throw new ArgumentException(
							string.Format("Conflicting option types: '{0}' vs. '{1}'.", type, name[end]),
							"prototype");
				AddSeparators(name, end, seps);
			}

			if (type == '\0')
				return OptionValueType.None;

			if (count <= 1 && seps.Count != 0)
				throw new ArgumentException(
						string.Format("Cannot provide key/value separators for Options taking {0} value(s).", count),
						"prototype");
			if (count > 1)
			{
				if (seps.Count == 0)
					this.separators = new string[] { ":", "=" };
				else if (seps.Count == 1 && seps[0].Length == 0)
					this.separators = null;
				else
					this.separators = seps.ToArray();
			}

			return type == '=' ? OptionValueType.Required : OptionValueType.Optional;
		}

		private static void AddSeparators(string name, int end, ICollection<string> seps)
		{
			int start = -1;
			for (int i = end + 1; i < name.Length; ++i)
			{
				switch (name[i])
				{
					case '{':
						if (start != -1)
							throw new ArgumentException(
									string.Format("Ill-formed name/value separator found in \"{0}\".", name),
									"prototype");
						start = i + 1;
						break;
					case '}':
						if (start == -1)
							throw new ArgumentException(
									string.Format("Ill-formed name/value separator found in \"{0}\".", name),
									"prototype");
						seps.Add(name.Substring(start, i - start));
						start = -1;
						break;
					default:
						if (start == -1)
							seps.Add(name[i].ToString());
						break;
				}
			}
			if (start != -1)
				throw new ArgumentException(
						string.Format("Ill-formed name/value separator found in \"{0}\".", name),
						"prototype");
		}

		public void Invoke(OptionContext c)
		{
			OnParseComplete(c);
			c.OptionName = null;
			c.Option = null;
			c.OptionValues.Clear();
		}

		protected abstract void OnParseComplete(OptionContext c);

		public override string ToString()
		{
			return Prototype;
		}
	}

	public abstract class ArgumentSource
	{

		protected ArgumentSource()
		{
		}

		public abstract string[] GetNames();
		public abstract string Description { get; }
		public abstract bool GetArguments(string value, out IEnumerable<string> replacement);

		public static IEnumerable<string> GetArgumentsFromFile(string file)
		{
			return GetArguments(File.OpenText(file), true);
		}

		public static IEnumerable<string> GetArguments(TextReader reader)
		{
			return GetArguments(reader, false);
		}

		// Cribbed from mcs/driver.cs:LoadArgs(string)
		static IEnumerable<string> GetArguments(TextReader reader, bool close)
		{
			try
			{
				StringBuilder arg = new StringBuilder();

				string line;
				while ((line = reader.ReadLine()) != null)
				{
					int t = line.Length;

					for (int i = 0; i < t; i++)
					{
						char c = line[i];

						if (c == '"' || c == '\'')
						{
							char end = c;

							for (i++; i < t; i++)
							{
								c = line[i];

								if (c == end)
									break;
								arg.Append(c);
							}
						}
						else if (c == ' ')
						{
							if (arg.Length > 0)
							{
								yield return arg.ToString();
								arg.Length = 0;
							}
						}
						else
							arg.Append(c);
					}
					if (arg.Length > 0)
					{
						yield return arg.ToString();
						arg.Length = 0;
					}
				}
			}
			finally
			{
				if (close)
					reader.Close();
			}
		}
	}

	public class ResponseFileSource : ArgumentSource
	{

		public override string[] GetNames()
		{
			return new string[] { "@file" };
		}

		public override string Description
		{
			get { return "Read response file for more options."; }
		}

		public override bool GetArguments(string value, out IEnumerable<string> replacement)
		{
			if (string.IsNullOrEmpty(value) || !value.StartsWith("@"))
			{
				replacement = null;
				return false;
			}
			replacement = ArgumentSource.GetArgumentsFromFile(value.Substring(1));
			return true;
		}
	}

	[Serializable]
	public class OptionException : Exception
	{
		private string option;

		public OptionException()
		{
		}

		public OptionException(string message, string optionName)
			: base(message)
		{
			this.option = optionName;
		}

		public OptionException(string message, string optionName, Exception innerException)
			: base(message, innerException)
		{
			this.option = optionName;
		}

		protected OptionException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			this.option = info.GetString("OptionName");
		}

		public string OptionName
		{
			get { return this.option; }
		}

#pragma warning disable 618 // SecurityPermissionAttribute is obsolete
		[SecurityPermission(SecurityAction.LinkDemand, SerializationFormatter = true)]
#pragma warning restore 618
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			base.GetObjectData(info, context);
			info.AddValue("OptionName", option);
		}
	}

	public delegate void OptionAction<TKey, TValue>(TKey key, TValue value);

	public class OptionSet : KeyedCollection<string, Option>
	{
		public OptionSet()
			: this(delegate(string f) { return f; })
		{
		}

		public OptionSet(Converter<string, string> localizer)
		{
			this.localizer = localizer;
			this.roSources = new ReadOnlyCollection<ArgumentSource>(sources);
		}

		Converter<string, string> localizer;

		public Converter<string, string> MessageLocalizer
		{
			get { return localizer; }
		}

		List<ArgumentSource> sources = new List<ArgumentSource>();
		ReadOnlyCollection<ArgumentSource> roSources;

		public ReadOnlyCollection<ArgumentSource> ArgumentSources
		{
			get { return roSources; }
		}


		protected override string GetKeyForItem(Option item)
		{
			if (item == null)
				throw new ArgumentNullException("option");
			if (item.Names != null && item.Names.Length > 0)
				return item.Names[0];
			// This should never happen, as it's invalid for Option to be
			// constructed w/o any names.
			throw new InvalidOperationException("Option has no names!");
		}

		[Obsolete("Use KeyedCollection.this[string]")]
		protected Option GetOptionForName(string option)
		{
			if (option == null)
				throw new ArgumentNullException("option");
			try
			{
				return base[option];
			}
			catch (KeyNotFoundException)
			{
				return null;
			}
		}

		protected override void InsertItem(int index, Option item)
		{
			base.InsertItem(index, item);
			AddImpl(item);
		}

		protected override void RemoveItem(int index)
		{
			Option p = Items[index];
			base.RemoveItem(index);
			// KeyedCollection.RemoveItem() handles the 0th item
			for (int i = 1; i < p.Names.Length; ++i)
			{
				Dictionary.Remove(p.Names[i]);
			}
		}

		protected override void SetItem(int index, Option item)
		{
			base.SetItem(index, item);
			AddImpl(item);
		}

		private void AddImpl(Option option)
		{
			if (option == null)
				throw new ArgumentNullException("option");
			List<string> added = new List<string>(option.Names.Length);
			try
			{
				// KeyedCollection.InsertItem/SetItem handle the 0th name.
				for (int i = 1; i < option.Names.Length; ++i)
				{
					Dictionary.Add(option.Names[i], option);
					added.Add(option.Names[i]);
				}
			}
			catch (Exception)
			{
				foreach (string name in added)
					Dictionary.Remove(name);
				throw;
			}
		}

		public OptionSet Add(string header)
		{
			if (header == null)
				throw new ArgumentNullException("header");
			Add(new Category(header));
			return this;
		}

		internal sealed class Category : Option
		{

			// Prototype starts with '=' because this is an invalid prototype
			// (see Option.ParsePrototype(), and thus it'll prevent Category
			// instances from being accidentally used as normal options.
			public Category(string description)
				: base("=:Category:= " + description, description)
			{
			}

			protected override void OnParseComplete(OptionContext c)
			{
				throw new NotSupportedException("Category.OnParseComplete should not be invoked.");
			}
		}


		public new OptionSet Add(Option option)
		{
			base.Add(option);
			return this;
		}

		sealed class ActionOption : Option
		{
			Action<OptionValueCollection> action;

			public ActionOption(string prototype, string description, int count, Action<OptionValueCollection> action)
				: this(prototype, description, count, action, false)
			{
			}

			public ActionOption(string prototype, string description, int count, Action<OptionValueCollection> action, bool hidden)
				: base(prototype, description, count, hidden)
			{
				if (action == null)
					throw new ArgumentNullException("action");
				this.action = action;
			}

			protected override void OnParseComplete(OptionContext c)
			{
				action(c.OptionValues);
			}
		}

		public OptionSet Add(string prototype, Action<string> action)
		{
			return Add(prototype, null, action);
		}

		public OptionSet Add(string prototype, string description, Action<string> action)
		{
			return Add(prototype, description, action, false);
		}

		public OptionSet Add(string prototype, string description, Action<string> action, bool hidden)
		{
			if (action == null)
				throw new ArgumentNullException("action");
			Option p = new ActionOption(prototype, description, 1,
					delegate(OptionValueCollection v) { action(v[0]); }, hidden);
			base.Add(p);
			return this;
		}

		public OptionSet Add(string prototype, OptionAction<string, string> action)
		{
			return Add(prototype, null, action);
		}

		public OptionSet Add(string prototype, string description, OptionAction<string, string> action)
		{
			return Add(prototype, description, action, false);
		}

		public OptionSet Add(string prototype, string description, OptionAction<string, string> action, bool hidden)
		{
			if (action == null)
				throw new ArgumentNullException("action");
			Option p = new ActionOption(prototype, description, 2,
					delegate(OptionValueCollection v) { action(v[0], v[1]); }, hidden);
			base.Add(p);
			return this;
		}

		sealed class ActionOption<T> : Option
		{
			Action<T> action;

			public ActionOption(string prototype, string description, Action<T> action)
				: base(prototype, description, 1)
			{
				if (action == null)
					throw new ArgumentNullException("action");
				this.action = action;
			}

			protected override void OnParseComplete(OptionContext c)
			{
				action(Parse<T>(c.OptionValues[0], c));
			}
		}

		sealed class ActionOption<TKey, TValue> : Option
		{
			OptionAction<TKey, TValue> action;

			public ActionOption(string prototype, string description, OptionAction<TKey, TValue> action)
				: base(prototype, description, 2)
			{
				if (action == null)
					throw new ArgumentNullException("action");
				this.action = action;
			}

			protected override void OnParseComplete(OptionContext c)
			{
				action(
						Parse<TKey>(c.OptionValues[0], c),
						Parse<TValue>(c.OptionValues[1], c));
			}
		}

		public OptionSet Add<T>(string prototype, Action<T> action)
		{
			return Add(prototype, null, action);
		}

		public OptionSet Add<T>(string prototype, string description, Action<T> action)
		{
			return Add(new ActionOption<T>(prototype, description, action));
		}

		public OptionSet Add<TKey, TValue>(string prototype, OptionAction<TKey, TValue> action)
		{
			return Add(prototype, null, action);
		}

		public OptionSet Add<TKey, TValue>(string prototype, string description, OptionAction<TKey, TValue> action)
		{
			return Add(new ActionOption<TKey, TValue>(prototype, description, action));
		}

		public OptionSet Add(ArgumentSource source)
		{
			if (source == null)
				throw new ArgumentNullException("source");
			sources.Add(source);
			return this;
		}

		protected virtual OptionContext CreateOptionContext()
		{
			return new OptionContext(this);
		}

		public List<string> Parse(IEnumerable<string> arguments)
		{
			if (arguments == null)
				throw new ArgumentNullException("arguments");
			OptionContext c = CreateOptionContext();
			c.OptionIndex = -1;
			bool process = true;
			List<string> unprocessed = new List<string>();
			Option def = Contains("<>") ? this["<>"] : null;
			ArgumentEnumerator ae = new ArgumentEnumerator(arguments);
			foreach (string argument in ae)
			{
				++c.OptionIndex;
				if (argument == "--")
				{
					process = false;
					continue;
				}
				if (!process)
				{
					Unprocessed(unprocessed, def, c, argument);
					continue;
				}
				if (AddSource(ae, argument))
					continue;
				if (!Parse(argument, c))
					Unprocessed(unprocessed, def, c, argument);
			}
			if (c.Option != null)
				c.Option.Invoke(c);
			return unprocessed;
		}

		class ArgumentEnumerator : IEnumerable<string>
		{
			List<IEnumerator<string>> sources = new List<IEnumerator<string>>();

			public ArgumentEnumerator(IEnumerable<string> arguments)
			{
				sources.Add(arguments.GetEnumerator());
			}

			public void Add(IEnumerable<string> arguments)
			{
				sources.Add(arguments.GetEnumerator());
			}

			public IEnumerator<string> GetEnumerator()
			{
				do
				{
					IEnumerator<string> c = sources[sources.Count - 1];
					if (c.MoveNext())
						yield return c.Current;
					else
					{
						c.Dispose();
						sources.RemoveAt(sources.Count - 1);
					}
				} while (sources.Count > 0);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		bool AddSource(ArgumentEnumerator ae, string argument)
		{
			foreach (ArgumentSource source in sources)
			{
				IEnumerable<string> replacement;
				if (!source.GetArguments(argument, out replacement))
					continue;
				ae.Add(replacement);
				return true;
			}
			return false;
		}

		private static bool Unprocessed(ICollection<string> extra, Option def, OptionContext c, string argument)
		{
			if (def == null)
			{
				extra.Add(argument);
				return false;
			}
			c.OptionValues.Add(argument);
			c.Option = def;
			c.Option.Invoke(c);
			return false;
		}

		private readonly Regex ValueOption = new Regex(
			@"^(?<flag>--|-|/)(?<name>[^:=]+)((?<sep>[:=])(?<value>.*))?$");

		protected bool GetOptionParts(string argument, out string flag, out string name, out string sep, out string value)
		{
			if (argument == null)
				throw new ArgumentNullException("argument");

			flag = name = sep = value = null;
			Match m = ValueOption.Match(argument);
			if (!m.Success)
			{
				return false;
			}
			flag = m.Groups["flag"].Value;
			name = m.Groups["name"].Value;
			if (m.Groups["sep"].Success && m.Groups["value"].Success)
			{
				sep = m.Groups["sep"].Value;
				value = m.Groups["value"].Value;
			}
			return true;
		}

		protected virtual bool Parse(string argument, OptionContext c)
		{
			if (c.Option != null)
			{
				ParseValue(argument, c);
				return true;
			}

			string f, n, s, v;
			if (!GetOptionParts(argument, out f, out n, out s, out v))
				return false;

			Option p;
			if (Contains(n))
			{
				p = this[n];
				c.OptionName = f + n;
				c.Option = p;
				switch (p.OptionValueType)
				{
					case OptionValueType.None:
						c.OptionValues.Add(n);
						c.Option.Invoke(c);
						break;
					case OptionValueType.Optional:
					case OptionValueType.Required:
						ParseValue(v, c);
						break;
				}
				return true;
			}
			// no match; is it a bool option?
			if (ParseBool(argument, n, c))
				return true;
			// is it a bundled option?
			if (ParseBundledValue(f, string.Concat(n + s + v), c))
				return true;

			return false;
		}

		private void ParseValue(string option, OptionContext c)
		{
			if (option != null)
				foreach (string o in c.Option.ValueSeparators != null
						? option.Split(c.Option.ValueSeparators, c.Option.MaxValueCount - c.OptionValues.Count, StringSplitOptions.None)
						: new string[] { option })
				{
					c.OptionValues.Add(o);
				}
			if (c.OptionValues.Count == c.Option.MaxValueCount ||
					c.Option.OptionValueType == OptionValueType.Optional)
				c.Option.Invoke(c);
			else if (c.OptionValues.Count > c.Option.MaxValueCount)
			{
				throw new OptionException(localizer(string.Format(
								"Error: Found {0} option values when expecting {1}.",
								c.OptionValues.Count, c.Option.MaxValueCount)),
						c.OptionName);
			}
		}

		private bool ParseBool(string option, string n, OptionContext c)
		{
			Option p;
			string rn;
			if (n.Length >= 1 && (n[n.Length - 1] == '+' || n[n.Length - 1] == '-') &&
					Contains((rn = n.Substring(0, n.Length - 1))))
			{
				p = this[rn];
				string v = n[n.Length - 1] == '+' ? option : null;
				c.OptionName = option;
				c.Option = p;
				c.OptionValues.Add(v);
				p.Invoke(c);
				return true;
			}
			return false;
		}

		private bool ParseBundledValue(string f, string n, OptionContext c)
		{
			if (f != "-")
				return false;
			for (int i = 0; i < n.Length; ++i)
			{
				Option p;
				string opt = f + n[i].ToString();
				string rn = n[i].ToString();
				if (!Contains(rn))
				{
					if (i == 0)
						return false;
					throw new OptionException(string.Format(localizer(
									"Cannot use unregistered option '{0}' in bundle '{1}'."), rn, f + n), null);
				}
				p = this[rn];
				switch (p.OptionValueType)
				{
					case OptionValueType.None:
						Invoke(c, opt, n, p);
						break;
					case OptionValueType.Optional:
					case OptionValueType.Required:
						{
							string v = n.Substring(i + 1);
							c.Option = p;
							c.OptionName = opt;
							ParseValue(v.Length != 0 ? v : null, c);
							return true;
						}
					default:
						throw new InvalidOperationException("Unknown OptionValueType: " + p.OptionValueType);
				}
			}
			return true;
		}

		private static void Invoke(OptionContext c, string name, string value, Option option)
		{
			c.OptionName = name;
			c.Option = option;
			c.OptionValues.Add(value);
			option.Invoke(c);
		}

		private const int OptionWidth = 29;
		private const int Description_FirstWidth = 80 - OptionWidth;
		private const int Description_RemWidth = 80 - OptionWidth - 2;

		public void WriteOptionDescriptions(TextWriter o)
		{
			foreach (Option p in this)
			{
				int written = 0;

				if (p.Hidden)
					continue;

				Category c = p as Category;
				if (c != null)
				{
					WriteDescription(o, p.Description, "", 80, 80);
					continue;
				}

				if (!WriteOptionPrototype(o, p, ref written))
					continue;

				if (written < OptionWidth)
					o.Write(new string(' ', OptionWidth - written));
				else
				{
					o.WriteLine();
					o.Write(new string(' ', OptionWidth));
				}

				WriteDescription(o, p.Description, new string(' ', OptionWidth + 2),
						Description_FirstWidth, Description_RemWidth);
			}

			foreach (ArgumentSource s in sources)
			{
				string[] names = s.GetNames();
				if (names == null || names.Length == 0)
					continue;

				int written = 0;

				Write(o, ref written, "  ");
				Write(o, ref written, names[0]);
				for (int i = 1; i < names.Length; ++i)
				{
					Write(o, ref written, ", ");
					Write(o, ref written, names[i]);
				}

				if (written < OptionWidth)
					o.Write(new string(' ', OptionWidth - written));
				else
				{
					o.WriteLine();
					o.Write(new string(' ', OptionWidth));
				}

				WriteDescription(o, s.Description, new string(' ', OptionWidth + 2),
						Description_FirstWidth, Description_RemWidth);
			}
		}

		void WriteDescription(TextWriter o, string value, string prefix, int firstWidth, int remWidth)
		{
			bool indent = false;
			foreach (string line in GetLines(localizer(GetDescription(value)), firstWidth, remWidth))
			{
				if (indent)
					o.Write(prefix);
				o.WriteLine(line);
				indent = true;
			}
		}

		bool WriteOptionPrototype(TextWriter o, Option p, ref int written)
		{
			string[] names = p.Names;

			int i = GetNextOptionIndex(names, 0);
			if (i == names.Length)
				return false;

			if (names[i].Length == 1)
			{
				Write(o, ref written, "  -");
				Write(o, ref written, names[0]);
			}
			else
			{
				Write(o, ref written, "      --");
				Write(o, ref written, names[0]);
			}

			for (i = GetNextOptionIndex(names, i + 1);
					i < names.Length; i = GetNextOptionIndex(names, i + 1))
			{
				Write(o, ref written, ", ");
				Write(o, ref written, names[i].Length == 1 ? "-" : "--");
				Write(o, ref written, names[i]);
			}

			if (p.OptionValueType == OptionValueType.Optional ||
					p.OptionValueType == OptionValueType.Required)
			{
				if (p.OptionValueType == OptionValueType.Optional)
				{
					Write(o, ref written, localizer("["));
				}
				Write(o, ref written, localizer("=" + GetArgumentName(0, p.MaxValueCount, p.Description)));
				string sep = p.ValueSeparators != null && p.ValueSeparators.Length > 0
					? p.ValueSeparators[0]
					: " ";
				for (int c = 1; c < p.MaxValueCount; ++c)
				{
					Write(o, ref written, localizer(sep + GetArgumentName(c, p.MaxValueCount, p.Description)));
				}
				if (p.OptionValueType == OptionValueType.Optional)
				{
					Write(o, ref written, localizer("]"));
				}
			}
			return true;
		}

		static int GetNextOptionIndex(string[] names, int i)
		{
			while (i < names.Length && names[i] == "<>")
			{
				++i;
			}
			return i;
		}

		static void Write(TextWriter o, ref int n, string s)
		{
			n += s.Length;
			o.Write(s);
		}

		private static string GetArgumentName(int index, int maxIndex, string description)
		{
			if (description == null)
				return maxIndex == 1 ? "VALUE" : "VALUE" + (index + 1);
			string[] nameStart;
			if (maxIndex == 1)
				nameStart = new string[] { "{0:", "{" };
			else
				nameStart = new string[] { "{" + index + ":" };
			for (int i = 0; i < nameStart.Length; ++i)
			{
				int start, j = 0;
				do
				{
					start = description.IndexOf(nameStart[i], j);
				} while (start >= 0 && j != 0 ? description[j++ - 1] == '{' : false);
				if (start == -1)
					continue;
				int end = description.IndexOf("}", start);
				if (end == -1)
					continue;
				return description.Substring(start + nameStart[i].Length, end - start - nameStart[i].Length);
			}
			return maxIndex == 1 ? "VALUE" : "VALUE" + (index + 1);
		}

		private static string GetDescription(string description)
		{
			if (description == null)
				return string.Empty;
			StringBuilder sb = new StringBuilder(description.Length);
			int start = -1;
			for (int i = 0; i < description.Length; ++i)
			{
				switch (description[i])
				{
					case '{':
						if (i == start)
						{
							sb.Append('{');
							start = -1;
						}
						else if (start < 0)
							start = i + 1;
						break;
					case '}':
						if (start < 0)
						{
							if ((i + 1) == description.Length || description[i + 1] != '}')
								throw new InvalidOperationException("Invalid option description: " + description);
							++i;
							sb.Append("}");
						}
						else
						{
							sb.Append(description.Substring(start, i - start));
							start = -1;
						}
						break;
					case ':':
						if (start < 0)
							goto default;
						start = i + 1;
						break;
					default:
						if (start < 0)
							sb.Append(description[i]);
						break;
				}
			}
			return sb.ToString();
		}

		private static IEnumerable<string> GetLines(string description, int firstWidth, int remWidth)
		{
			return StringCoda.WrappedLines(description, firstWidth, remWidth);
		}
	}
}



================================================
File: src/eazdevirt/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("eazdevirt")]
[assembly: AssemblyDescription("Eazfuscator.NET devirtualization toolkit")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("eazdevirt")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("fa8d6d91-156f-4df4-8511-b4c478723ca0")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("0.0.0.1")]
[assembly: AssemblyFileVersion("0.0.0.1")]



================================================
File: src/eazdevirt/Reflection/DetectAttribute.cs
================================================
ï»¿using System;
using dnlib.DotNet.Emit;

namespace eazdevirt.Reflection
{
	/// <summary>
	/// Attribute to identify an instruction detection method.
	/// </summary>
	public class DetectAttribute : Attribute
	{
		/// <summary>
		/// Associated opcode.
		/// </summary>
		public Code OpCode { get; private set; }

		/// <summary>
		/// Associated special opcode.
		/// </summary>
		public SpecialCode SpecialOpCode { get; private set; }

		/// <summary>
		/// Whether or not the method expects to be matched against
		/// more than one virtual instruction type.
		/// </summary>
		public Boolean ExpectsMultiple = false;

		/// <summary>
		/// Whether or not the associated opcode is a special opcode.
		/// </summary>
		public Boolean IsSpecial { get; private set; }

		/// <summary>
		/// Construct a Detect attribute with a CIL opcode.
		/// </summary>
		/// <param name="code">CIL opcode the method checks for</param>
		public DetectAttribute(Code code)
		{
			this.OpCode = code;
			this.IsSpecial = false;
		}

		/// <summary>
		/// Construct a Detect attribute with a special opcode.
		/// </summary>
		/// <param name="code">Special opcode the method checks for</param>
		public DetectAttribute(SpecialCode code)
		{
			this.SpecialOpCode = code;
			this.IsSpecial = true;
		}
	}
}



================================================
File: src/eazdevirt/Util/DotNetUtils.cs
================================================
ï»¿/*
    Copyright (C) 2011-2014 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace de4dot.blocks
{
	public enum FrameworkType
	{
		Unknown,
		Desktop,
		Silverlight,		// and WindowsPhone, XNA Xbox360
		CompactFramework,
		XNA,
		Zune,
	}

	public class CallCounter
	{
		Dictionary<IMethod, int> calls = new Dictionary<IMethod, int>(MethodEqualityComparer.CompareDeclaringTypes);

		public void Add(IMethod calledMethod)
		{
			int count;
			calls.TryGetValue(calledMethod, out count);
			calls[calledMethod] = count + 1;
		}

		public IMethod Most()
		{
			int numCalls;
			return Most(out numCalls);
		}

		public IMethod Most(out int numCalls)
		{
			IMethod method = null;
			int callCount = 0;
			foreach (var key in calls.Keys)
			{
				if (calls[key] > callCount)
				{
					callCount = calls[key];
					method = key;
				}
			}
			numCalls = callCount;
			return method;
		}
	}

	public static class DotNetUtils
	{
		public static TypeDef GetModuleType(ModuleDef module)
		{
			return module.GlobalType;
		}

		public static MethodDef GetModuleTypeCctor(ModuleDef module)
		{
			return module.GlobalType.FindStaticConstructor();
		}

		public static bool IsEmpty(MethodDef method)
		{
			if (method.Body == null)
				return false;
			foreach (var instr in method.Body.Instructions)
			{
				var code = instr.OpCode.Code;
				if (code != Code.Nop && code != Code.Ret)
					return false;
			}
			return true;
		}

		public static bool IsEmptyObfuscated(MethodDef method)
		{
			if (method.Body == null)
				return false;
			int index = 0;
			var instr = GetInstruction(method.Body.Instructions, ref index);
			if (instr == null || instr.OpCode.Code != Code.Ret)
				return false;

			return true;
		}

		public static FieldDef FindFieldType(TypeDef typeDef, string typeName, bool isStatic)
		{
			if (typeDef == null)
				return null;
			foreach (var field in typeDef.Fields)
			{
				if (field.IsStatic == isStatic && field.FieldSig.GetFieldType().GetFullName() == typeName)
					return field;
			}
			return null;
		}

		public static IEnumerable<MethodDef> FindMethods(IEnumerable<MethodDef> methods, string returnType, string[] argsTypes)
		{
			return FindMethods(methods, returnType, argsTypes, true);
		}

		public static IEnumerable<MethodDef> FindMethods(IEnumerable<MethodDef> methods, string returnType, string[] argsTypes, bool isStatic)
		{
			foreach (var method in methods)
			{
				var sig = method.MethodSig;
				if (sig == null || !method.HasBody || !sig.IsDefault)
					continue;
				if (method.IsStatic != isStatic || sig.Params.Count != argsTypes.Length)
					continue;
				if (sig.GenParamCount > 0)
					continue;
				if (sig.RetType.GetFullName() != returnType)
					continue;
				for (int i = 0; i < argsTypes.Length; i++)
				{
					if (sig.Params[i].GetFullName() != argsTypes[i])
						goto next;
				}
				yield return method;
			next: ;
			}
		}

		public static bool IsDelegate(IType type)
		{
			if (type == null)
				return false;
			var fn = type.FullName;
			return fn == "System.Delegate" || fn == "System.MulticastDelegate";
		}

		public static bool DerivesFromDelegate(TypeDef type)
		{
			return type != null && IsDelegate(type.BaseType);
		}

		public static bool IsMethod(IMethod method, string returnType, string parameters)
		{
			return method != null && method.FullName == returnType + " " + method.DeclaringType.FullName + "::" + method.Name + parameters;
		}

		public static string GetDllName(string dll)
		{
			if (dll.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
				return dll.Substring(0, dll.Length - 4);
			return dll;
		}

		public static bool HasPinvokeMethod(TypeDef type, string methodName)
		{
			return GetPInvokeMethod(type, methodName) != null;
		}

		public static MethodDef GetPInvokeMethod(TypeDef type, string methodName)
		{
			if (type == null)
				return null;
			UTF8String mname = methodName;
			foreach (var method in type.Methods)
			{
				if (method.ImplMap == null)
					continue;
				if (UTF8String.Equals(method.ImplMap.Name, mname))
					return method;
			}
			return null;
		}

		public static MethodDef GetPInvokeMethod(TypeDef type, string dll, string funcName)
		{
			foreach (var method in type.Methods)
			{
				if (IsPinvokeMethod(method, dll, funcName))
					return method;
			}
			return null;
		}

		public static bool IsPinvokeMethod(MethodDef method, string dll, string funcName)
		{
			if (method == null)
				return false;
			if (method.ImplMap == null)
				return false;
			return method.ImplMap.IsPinvokeMethod(dll, funcName);
		}

		public static MethodDef GetMethod(ModuleDefMD module, IMethod method)
		{
			if (method == null)
				return null;
			return GetMethod(module, method, method.DeclaringType);
		}

		public static MethodDef GetMethod2(ModuleDefMD module, IMethod method)
		{
			if (method == null)
				return null;
			if (method is MethodDef)
				return (MethodDef)method;
			var git = method.DeclaringType.TryGetGenericInstSig();
			var dt = git == null ? method.DeclaringType : git.GenericType.TypeDefOrRef;
			return GetMethod(module, method, dt);
		}

		static MethodDef GetMethod(ModuleDefMD module, IMethod method, ITypeDefOrRef declaringType)
		{
			if (method == null)
				return null;
			if (method is MethodDef)
				return (MethodDef)method;
			return GetMethod(GetType(module, declaringType), method);
		}

		public static MethodDef GetMethod(TypeDef type, string returnType, string parameters)
		{
			foreach (var method in type.Methods)
			{
				if (IsMethod(method, returnType, parameters))
					return method;
			}
			return null;
		}

		public static MethodDef GetMethod2(ModuleDef module, IMethod method)
		{
			if (method == null)
				return null;
			return GetMethod(module, method, method.DeclaringType.ScopeType);
		}

		public static TypeDef GetType(ModuleDef module, TypeSig type)
		{
			type = type.RemovePinnedAndModifiers();
			var tdr = type as TypeDefOrRefSig;
			if (tdr == null)
				return null;
			return GetType(module, tdr.TypeDefOrRef);
		}

		public static TypeDef GetType(ModuleDef module, ITypeDefOrRef type)
		{
			var td = type as TypeDef;
			if (td == null)
			{
				var tr = type as TypeRef;
				if (tr != null)
				{
					var trAsm = tr.DefinitionAssembly;
					var modAsm = module.Assembly;
					if (trAsm != null && modAsm != null && trAsm.Name == modAsm.Name)
						td = tr.Resolve();
				}
			}
			return td != null && td.Module == module ? td : null;
		}

		static MethodDef GetMethod(ModuleDef module, IMethod method, ITypeDefOrRef declaringType)
		{
			if (method == null)
				return null;
			if (method is MethodDef)
				return (MethodDef)method;
			return GetMethod(GetType(module, declaringType), method);
		}

		public static MethodDef GetMethod(TypeDef type, IMethod methodRef)
		{
			if (type == null || methodRef == null)
				return null;
			if (methodRef is MethodDef)
				return (MethodDef)methodRef;
			return type.FindMethod(methodRef.Name, methodRef.MethodSig);
		}

		public static IEnumerable<MethodDef> GetNormalMethods(TypeDef type)
		{
			foreach (var method in type.Methods)
			{
				if (method.HasImplMap)
					continue;
				if (method.IsConstructor)
					continue;

				yield return method;
			}
		}

		public static FieldDef GetField(ModuleDef module, IField field)
		{
			if (field == null)
				return null;
			if (field is FieldDef)
				return (FieldDef)field;
			return GetField(GetType(module, field.DeclaringType), field);
		}

		public static FieldDef GetField(TypeDef type, IField fieldRef)
		{
			if (type == null || fieldRef == null)
				return null;
			if (fieldRef is FieldDef)
				return (FieldDef)fieldRef;
			return type.FindField(fieldRef.Name, fieldRef.FieldSig);
		}

		public static FieldDef GetField(TypeDef type, string typeFullName)
		{
			if (type == null)
				return null;
			foreach (var field in type.Fields)
			{
				if (field.FieldSig.GetFieldType().GetFullName() == typeFullName)
					return field;
			}
			return null;
		}

		public static IEnumerable<IMethod> GetMethodCalls(MethodDef method)
		{
			var list = new List<IMethod>();
			if (method.HasBody)
			{
				foreach (var instr in method.Body.Instructions)
				{
					var calledMethod = instr.Operand as IMethod;
					if (calledMethod != null)
						list.Add(calledMethod);
				}
			}
			return list;
		}

		public static bool HasString(MethodDef method, string s)
		{
			if (method == null || method.Body == null)
				return false;
			foreach (var instr in method.Body.Instructions)
			{
				if (instr.OpCode.Code == Code.Ldstr && (string)instr.Operand == s)
					return true;
			}
			return false;
		}

		public static IList<string> GetCodeStrings(MethodDef method)
		{
			var strings = new List<string>();
			if (method != null && method.Body != null)
			{
				foreach (var instr in method.Body.Instructions)
				{
					if (instr.OpCode.Code == Code.Ldstr)
						strings.Add((string)instr.Operand);
				}
			}
			return strings;
		}

		public static Resource GetResource(ModuleDef module, string name)
		{
			return GetResource(module, new List<string> { name });
		}

		public static Resource GetResource(ModuleDef module, IEnumerable<string> strings)
		{
			if (!module.HasResources)
				return null;

			var resources = module.Resources;
			foreach (var tmp in strings)
			{
				var resourceName = RemoveFromNullChar(tmp);
				if (resourceName == null)
					continue;
				UTF8String name = resourceName;
				foreach (var resource in resources)
				{
					if (UTF8String.Equals(resource.Name, name))
						return resource;
				}
			}

			return null;
		}

		static string RemoveFromNullChar(string s)
		{
			int index = s.IndexOf((char)0);
			if (index < 0)
				return s;
			return s.Substring(0, index);
		}

		static Instruction GetInstruction(IList<Instruction> instructions, IDictionary<Instruction, int> instructionToIndex, Instruction instruction)
		{
			if (instruction == null)
				return null;
			return instructions[instructionToIndex[instruction]];
		}

		public static void RestoreBody(MethodDef method, IEnumerable<Instruction> instructions, IEnumerable<ExceptionHandler> exceptionHandlers)
		{
			if (method == null || method.Body == null)
				return;

			var bodyInstrs = method.Body.Instructions;
			bodyInstrs.Clear();
			foreach (var instr in instructions)
				bodyInstrs.Add(instr);

			var bodyExceptionHandlers = method.Body.ExceptionHandlers;
			bodyExceptionHandlers.Clear();
			foreach (var eh in exceptionHandlers)
				bodyExceptionHandlers.Add(eh);
		}

		static void CopyLocalsFromTo(MethodDef fromMethod, MethodDef toMethod)
		{
			var fromBody = fromMethod.Body;
			var toBody = toMethod.Body;

			toBody.Variables.Clear();
			foreach (var local in fromBody.Variables)
				toBody.Variables.Add(new Local(local.Type));
		}

		static void UpdateInstructionOperands(MethodDef fromMethod, MethodDef toMethod)
		{
			var fromBody = fromMethod.Body;
			var toBody = toMethod.Body;

			toBody.InitLocals = fromBody.InitLocals;
			toBody.MaxStack = fromBody.MaxStack;

			var newOperands = new Dictionary<object, object>();
			var fromParams = fromMethod.Parameters;
			var toParams = toMethod.Parameters;
			for (int i = 0; i < fromParams.Count; i++)
				newOperands[fromParams[i]] = toParams[i];
			for (int i = 0; i < fromBody.Variables.Count; i++)
				newOperands[fromBody.Variables[i]] = toBody.Variables[i];

			foreach (var instr in toBody.Instructions)
			{
				if (instr.Operand == null)
					continue;
				object newOperand;
				if (newOperands.TryGetValue(instr.Operand, out newOperand))
					instr.Operand = newOperand;
			}
		}

		public static string GetCustomArgAsString(CustomAttribute cattr, int arg)
		{
			if (cattr == null || arg >= cattr.ConstructorArguments.Count)
				return null;
			var carg = cattr.ConstructorArguments[arg];
			if (carg.Type.GetElementType() != ElementType.String)
				return null;
			return UTF8String.ToSystemStringOrEmpty((UTF8String)carg.Value);
		}

		public static IEnumerable<MethodDef> GetCalledMethods(ModuleDef module, MethodDef method)
		{
			if (method != null && method.HasBody)
			{
				foreach (var call in method.Body.Instructions)
				{
					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)
						continue;
					var methodRef = call.Operand as IMethod;
					if (methodRef == null)
						continue;
					var type = GetType(module, methodRef.DeclaringType);
					var methodDef = GetMethod(type, methodRef);
					if (methodDef != null)
						yield return methodDef;
				}
			}
		}

		public static IList<Instruction> GetInstructions(IList<Instruction> instructions, int i, params OpCode[] opcodes)
		{
			if (i + opcodes.Length > instructions.Count)
				return null;
			if (opcodes.Length == 0)
				return new List<Instruction>();
			if (opcodes[0] != instructions[i].OpCode)
				return null;

			var list = new List<Instruction>(opcodes.Length);
			for (int j = 0; j < opcodes.Length; j++)
			{
				var instr = instructions[i + j];
				if (instr.OpCode != opcodes[j])
					return null;
				list.Add(instr);
			}
			return list;
		}

		public static bool HasReturnValue(IMethod method)
		{
			if (method == null || method.MethodSig == null || method.MethodSig.RetType == null)
				return false;
			return method.MethodSig.RetType.RemovePinnedAndModifiers().ElementType != ElementType.Void;
		}

		public static Parameter GetParameter(IList<Parameter> parameters, int index)
		{
			if (0 <= index && index < parameters.Count)
				return parameters[index];
			return null;
		}

		public static TypeSig GetArg(IList<TypeSig> args, int index)
		{
			if (0 <= index && index < args.Count)
				return args[index];
			return null;
		}

		public static List<TypeSig> GetArgs(IMethod method)
		{
			var sig = method.MethodSig;
			var args = new List<TypeSig>(sig.Params.Count + 1);
			if (sig.ImplicitThis)
				args.Add(method.DeclaringType.ToTypeSig());
			foreach (var arg in sig.Params)
				args.Add(arg);
			return args;
		}

		public static int GetArgsCount(IMethod method)
		{
			var sig = method.MethodSig;
			if (sig == null)
				return 0;
			int count = sig.Params.Count;
			if (sig.ImplicitThis)
				count++;
			return count;
		}

		public static Instruction GetInstruction(IList<Instruction> instructions, ref int index)
		{
			for (int i = 0; i < 10; i++)
			{
				if (index < 0 || index >= instructions.Count)
					return null;
				var instr = instructions[index++];
				if (instr.OpCode.Code == Code.Nop)
					continue;
				if (instr.OpCode.OpCodeType == OpCodeType.Prefix)
					continue;
				if (instr == null || (instr.OpCode.Code != Code.Br && instr.OpCode.Code != Code.Br_S))
					return instr;
				instr = instr.Operand as Instruction;
				if (instr == null)
					return null;
				index = instructions.IndexOf(instr);
			}
			return null;
		}

		public static TypeDefOrRefSig FindOrCreateTypeRef(ModuleDef module, AssemblyRef asmRef, string ns, string name, bool isValueType)
		{
			var typeRef = module.UpdateRowId(new TypeRefUser(module, ns, name, asmRef));
			if (isValueType)
				return new ValueTypeSig(typeRef);
			else
				return new ClassSig(typeRef);
		}

		public static FrameworkType GetFrameworkType(ModuleDefMD module)
		{
			foreach (var modRef in module.GetAssemblyRefs())
			{
				if (modRef.Name != "mscorlib")
					continue;
				if (PublicKeyBase.IsNullOrEmpty2(modRef.PublicKeyOrToken))
					continue;
				switch (BitConverter.ToString(modRef.PublicKeyOrToken.Data).Replace("-", "").ToLowerInvariant())
				{
					case "b77a5c561934e089":
						return FrameworkType.Desktop;
					case "7cec85d7bea7798e":
						return FrameworkType.Silverlight;
					case "969db8053d3322ac":
						return FrameworkType.CompactFramework;
					case "1c9e259686f921e0":
						return FrameworkType.XNA;
					case "e92a8b81eba7ceb7":
						return FrameworkType.Zune;
				}
			}

			return FrameworkType.Unknown;
		}

		public static int GetMethodCalls(MethodDef method, string methodFullName)
		{
			if (method == null || method.Body == null)
				return 0;

			int count = 0;
			foreach (var instr in method.Body.Instructions)
			{
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
					continue;
				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.FullName == methodFullName)
					count++;
			}

			return count;
		}

		public static bool CallsMethod(MethodDef method, string methodFullName)
		{
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions)
			{
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
					continue;
				var calledMethod = instr.Operand as IMethod;
				if (calledMethod == null)
					continue;
				if (calledMethod.FullName == methodFullName)
					return true;
			}

			return false;
		}

		public static bool CallsMethod(MethodDef method, string returnType, string parameters)
		{
			if (method == null || method.Body == null)
				return false;

			foreach (var instr in method.Body.Instructions)
			{
				if (instr.OpCode.Code != Code.Call && instr.OpCode.Code != Code.Callvirt && instr.OpCode.Code != Code.Newobj)
					continue;
				if (IsMethod(instr.Operand as IMethod, returnType, parameters))
					return true;
			}

			return false;
		}

		public static IList<Instruction> GetArgPushes(IList<Instruction> instrs, int index)
		{
			return GetArgPushes(instrs, ref index);
		}

		public static IList<Instruction> GetArgPushes(IList<Instruction> instrs, ref int index)
		{
			if (index < 0 || index >= instrs.Count)
				return null;
			var startInstr = instrs[index];
			int pushes, pops;
			startInstr.CalculateStackUsage(false, out pushes, out pops);

			index--;
			int numArgs = pops;
			var args = new List<Instruction>(numArgs);
			int stackSize = numArgs;
			while (index >= 0 && args.Count != numArgs)
			{
				var instr = instrs[index--];
				instr.CalculateStackUsage(false, out pushes, out pops);
				if (instr.OpCode.Code == Code.Dup)
				{
					args.Add(instr);
					stackSize--;
				}
				else
				{
					if (pushes == 1)
						args.Add(instr);
					else if (pushes > 1)
						throw new NotImplementedException();
					stackSize -= pushes;

					if (pops != 0)
					{
						index++;
						if (GetArgPushes(instrs, ref index) == null)
							return null;
					}
				}

				if (stackSize < 0)
					return null;
			}
			if (args.Count != numArgs)
				return null;
			args.Reverse();
			return args;
		}
	}
}


================================================
File: src/eazdevirt/Util/Extensions.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace eazdevirt.Util
{
	public static class Extensions
	{
		/// <summary>
		/// Check if the method's body contains the given pattern.
		/// </summary>
		/// <param name="method">Method to check</param>
		/// <param name="codePattern">Pattern to check for</param>
		/// <returns>true if match, false if not</returns>
		public static Boolean Matches(this MethodDef method, params Code[] codePattern)
		{
			return Matches(method, new List<Code>(codePattern));
		}

		/// <summary>
		/// Check if the method's body contains the given pattern.
		/// </summary>
		/// <param name="method">Method to check</param>
		/// <param name="codePattern">Pattern to check for</param>
		/// <returns>true if match, false if not</returns>
		public static Boolean Matches(this MethodDef method, IList<Code> codePattern)
		{
			if (method == null || codePattern == null)
				throw new ArgumentNullException();

			if (!method.HasBody || !method.Body.HasInstructions)
				return false;

			return (Helpers.FindOpCodePatterns(method.Body.Instructions, codePattern).Count > 0);
		}

		/// <summary>
		/// Check if the method body entirely matches the given pattern.
		/// </summary>
		/// <param name="method">Method to check</param>
		/// <param name="codePattern">Pattern to check against</param>
		/// <returns>true if match, false if not</returns>
		public static Boolean MatchesEntire(this MethodDef method, params Code[] codePattern)
		{
			return MatchesEntire(method, new List<Code>(codePattern));
		}

		/// <summary>
		/// Check if the method body entirely matches the given pattern.
		/// </summary>
		/// <param name="method">Method to check</param>
		/// <param name="codePattern">Pattern to check against</param>
		/// <returns>true if match, false if not</returns>
		public static Boolean MatchesEntire(this MethodDef method, IList<Code> codePattern)
		{
			if (method == null)
				throw new ArgumentNullException();

			if (!method.HasBody || !method.Body.HasInstructions)
				return false;

			var instructions = Helpers.FindOpCodePatterns(method.Body.Instructions, codePattern);
			return (instructions.Count == 1 && instructions[0].Length == method.Body.Instructions.Count);
		}

		/// <summary>
		/// Check if the method calls another method which matches the given pattern.
		/// </summary>
		/// <param name="method">Method to check</param>
		/// <param name="codePattern">Pattern to check against</param>
		/// <returns>true if method calls another which matches, false if not</returns>
		public static Boolean MatchesIndirect(this MethodDef method, params Code[] codePattern)
		{
			return MatchesIndirect(method, new List<Code>(codePattern));
		}

		/// <summary>
		/// Check if the method calls another method which matches the given pattern.
		/// </summary>
		/// <param name="method">Method to check</param>
		/// <param name="codePattern">Pattern to check against</param>
		/// <returns>true if method calls another which matches, false if not</returns>
		public static Boolean MatchesIndirect(this MethodDef method, IList<Code> codePattern)
		{
			if (method == null)
				throw new ArgumentNullException();

			return method.Calls().FirstOrDefault((called) =>
			{
				MethodDef def = called as MethodDef;
				if (def == null)
					return false;
				else return def.Matches(codePattern);
			}) != null;
		}

		/// <summary>
		/// Search for and return all called methods.
		/// </summary>
		/// <param name="method">Method to search</param>
		/// <returns>Called methods</returns>
		public static IEnumerable<IMethod> Calls(this MethodDef method)
		{
			if (method == null)
				throw new ArgumentNullException();

			return DotNetUtils.GetMethodCalls(method);
		}

		/// <summary>
		/// Find the first occurrence of an opcode pattern, returning the matching instruction sequence.
		/// </summary>
		/// <param name="method">Method to search</param>
		/// <param name="pattern">Pattern to search for</param>
		/// <returns>Matching instruction sequence, or null if none found</returns>
		public static IList<Instruction> Find(this MethodDef method, params Code[] pattern)
		{
			return Find(method, new List<Code>(pattern));
		}

		/// <summary>
		/// Find the first occurrence of an opcode pattern, returning the matching instruction sequence.
		/// </summary>
		/// <param name="method">Method to search</param>
		/// <param name="pattern">Pattern to search for</param>
		/// <returns>Matching instruction sequence, or null if none found</returns>
		public static IList<Instruction> Find(this MethodDef method, IList<Code> pattern)
		{
			if (method == null)
				throw new ArgumentNullException();

			var result = Helpers.FindOpCodePatterns(method.Body.Instructions, pattern);
			if (result.Count == 0)
				return null;
			else return result[0];
		}

		/// <summary>
		/// Find all occurrences of an opcode pattern in a method.
		/// </summary>
		/// <param name="method">Method to search</param>
		/// <param name="pattern">Pattern to search for</param>
		/// <returns>All matching instruction sequences</returns>
		public static IList<Instruction[]> FindAll(this MethodDef method, params Code[] pattern)
		{
			return FindAll(method, new List<Code>(pattern));
		}

		/// <summary>
		/// Find all occurrences of an opcode pattern in a method.
		/// </summary>
		/// <param name="method">Method to search</param>
		/// <param name="pattern">Pattern to search for</param>
		/// <returns>All matching instruction sequences</returns>
		public static IList<Instruction[]> FindAll(this MethodDef method, IList<Code> pattern)
		{
			if (method == null)
				throw new ArgumentNullException();

			var result = Helpers.FindOpCodePatterns(method.Body.Instructions, pattern);
			return result;
		}
	}
}



================================================
File: src/eazdevirt/Util/GenericUtils.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;

namespace eazdevirt.Util
{
	public static class GenericUtils
	{
		public static IList<TypeSig> PossibleTypeSigs(TypeSig returnType,
			IList<TypeSig> typeGenerics, IList<TypeSig> methodGenerics)
		{
			IList<TypeSig> list = new List<TypeSig>();

			// Ignore [], &, * when comparing against generic types
			// Otherwise, String[] Blah<String>(...) won't consider that the
			// return type might be T[].
			Stack<String> modifiers;
			TypeSig returnTypeBase = SigUtil.ToBaseSig(returnType, out modifiers);
			if (returnTypeBase == null)
				throw new Exception(String.Format("Given TypeSig is not a TypeDefOrRefSig: {0}", returnType));

			// Generic instance type
			if (returnTypeBase.IsGenericInstanceType)
			{
				var genericSig = returnTypeBase.ToGenericInstSig();
				var combos = GenericUtils.CreateGenericParameterCombinations(
					genericSig.GenericArguments, typeGenerics, methodGenerics);

				foreach (var combo in combos)
					list.Add(new GenericInstSig(genericSig.GenericType, combo));

				return list;
			}
			else // Non-generic-instance type
			{
				list.Add(returnType);

				for (UInt16 g = 0; g < typeGenerics.Count; g++)
				{
					var gtype = typeGenerics[g];
					if (returnTypeBase.FullName.Equals(gtype.FullName))
						list.Add(SigUtil.FromBaseSig(new GenericVar(g), modifiers));
				}

				for (UInt16 g = 0; g < methodGenerics.Count; g++)
				{
					var gtype = methodGenerics[g];
					if (returnTypeBase.FullName.Equals(gtype.FullName))
						list.Add(SigUtil.FromBaseSig(new GenericMVar(g), modifiers));
				}

				return list;
			}
		}

		/// <summary>
		/// Get all combinations of some collections of lists.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="list">Collection of lists to get all combinations from</param>
		/// <returns>All combinations</returns>
		public static IList<IList<T>> AllCombinations<T>(IEnumerable<IList<T>> list)
		{
			return _AllCombinations<T>(list).ToArray();
		}

		/// <summary>
		/// Get all combinations of some collections of lists.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="list">Collection of lists to get all combinations from</param>
		/// <param name="_selected"></param>
		/// <returns>All combinations</returns>
		/// <remarks>Credits to Fung: https://stackoverflow.com/a/17642220 </remarks>
		static IEnumerable<IList<T>> _AllCombinations<T>(IEnumerable<IList<T>> list, IEnumerable<T> _selected = null)
		{
			if(_selected == null)
				_selected = new T[0];

			if (list.Any())
			{
				var remainingLists = list.Skip(1);
				foreach (var item in list.First().Where(x => !_selected.Contains(x)))
					foreach (var combo in _AllCombinations<T>(remainingLists, _selected.Concat(new T[] { item })))
						yield return combo;
			}
			else
			{
				yield return _selected.ToList();
			}
		}

		/// <summary>
		/// Create a list of all possible combinations of types/generic types that would make
		/// sense as parameters. This is necessary because the serialized method data does not
		/// contain information about which parameters map to which generic types (indices),
		/// neither GenericVars (declaring type) or GenericMVars (method itself).
		///
		/// TODO: Factor in context generics (generics from virtualized method itself and
		/// declaring type?)
		/// </summary>
		/// <param name="parameters">Parameters (with no generic type information)</param>
		/// <param name="typeGenerics">Generic variables of the type</param>
		/// <param name="methodGenerics">Generic variables of the method</param>
		/// <returns>Combinations with at least one item (original parameters)</returns>
		public static IList<IList<TypeSig>> CreateGenericParameterCombinations(IList<TypeSig> parameters,
			IList<TypeSig> typeGenerics, IList<TypeSig> methodGenerics)
		{
			IList<IList<TypeSig>> list = new List<IList<TypeSig>>();
			list.Add(parameters);

			var paramCombos = parameters.Select(p => PossibleTypeSigs(p, typeGenerics, methodGenerics));
			var allCombos = AllCombinations<TypeSig>(paramCombos);

			return allCombos;
		}

		/// <summary>
		/// Create a list of all possible combinations of types/generic types that would make
		/// sense as parameters. This is necessary because the serialized method data does not
		/// contain information about which parameters map to which generic types (indices),
		/// neither GenericVars (declaring type) or GenericMVars (method itself).
		///
		/// TODO: Factor in context generics (generics from virtualized method itself and
		/// declaring type?)
		/// </summary>
		/// <param name="parameters">Parameters (with no generic type information)</param>
		/// <param name="generics">Generics visible to the method</param>
		/// <returns>Combinations with at least one item (original parameters)</returns>
		public static IList<IList<TypeSig>> CreateGenericParameterCombinations_(IList<TypeSig> parameters,
			IList<TypeSig> typeGenerics, IList<TypeSig> methodGenerics)
		{
			IList<IList<TypeSig>> list = new List<IList<TypeSig>>();
			list.Add(parameters);

			for (UInt16 p = 0; p < parameters.Count; p++)
			{
				TypeSig paramtype = parameters[p];
				IList<TypeSig> ptypes = new TypeSig[] { paramtype };

				// Might be something like: DoSomething(IList<!0> someList)
				if (paramtype.IsGenericInstanceType)
					ptypes = PossibleTypeSigs(paramtype, typeGenerics, methodGenerics);

				for (UInt16 g = 0; g < typeGenerics.Count; g++)
				{
					var gtype = typeGenerics[g];

					foreach (var ptype in ptypes)
					{
						// Better comparison?
						//if (ptype.FullName.Equals(gtype.FullName))
						//{
							Int32 length = list.Count;
							for (Int32 i = 0; i < length; i++)
							{
								// Copy param list
								List<TypeSig> newParams = new List<TypeSig>();
								newParams.AddRange(list[i]);

								GenericVar gvar = new GenericVar(g);
								newParams[p] = gvar;

								list.Add(newParams);
							}
						//}
					}
				}

				for (UInt16 g = 0; g < methodGenerics.Count; g++)
				{
					var gtype = methodGenerics[g];

					foreach (var ptype in ptypes)
					{
						//if (ptype.FullName.Equals(gtype.FullName))
						//{
							Int32 length = list.Count;
							for (Int32 i = 0; i < length; i++)
							{
								List<TypeSig> newParams = new List<TypeSig>();
								newParams.AddRange(list[i]);

								GenericMVar gmvar = new GenericMVar(g);
								newParams[p] = gmvar;

								list.Add(newParams);
							}
						//}
					}
				}
			}

			return list;
		}
	}
}



================================================
File: src/eazdevirt/Util/NameResolver.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;

namespace eazdevirt.Util
{
	public class NameResolver
	{
		ModuleDefMD _module;
		public Importer Importer { get; private set; }

		public NameResolver(ModuleDefMD module)
		{
			_module = module;
			this.Importer = new Importer(module, ImporterOptions.TryToUseDefs);
		}

		/// <summary>
		/// Resolve an IField from its name and a declaring TypeSpec.
		/// </summary>
		/// <param name="declaringType">Declaring TypeSpec</param>
		/// <param name="fieldName">Field name</param>
		/// <returns>IField, or null if none found</returns>
		public IField ResolveField(TypeSpec declaringType, String fieldName)
		{
			TypeDef typeDef = declaringType.ResolveTypeDef();
			if (typeDef == null)
				return null;

			FieldDef fieldDef = typeDef.FindField(fieldName);
			if (fieldDef == null)
				return null;

			MemberRef memberRef = new MemberRefUser(_module, fieldDef.Name, fieldDef.FieldSig, declaringType);
			return this.Importer.Import(memberRef);
		}

		/// <summary>
		/// Resolve an IField from its name and the resolved delcaring type.
		/// </summary>
		/// <param name="declaringType">Declaring type</param>
		/// <param name="fieldName">Field name</param>
		/// <returns>IField, or null if none found</returns>
		public IField ResolveField(ITypeDefOrRef declaringType, String fieldName)
		{
			if (declaringType is TypeSpec)
				return ResolveField(declaringType as TypeSpec, fieldName);

			TypeDef typeDef = null;
			if (declaringType is TypeDef)
				typeDef = declaringType as TypeDef;
			else if (declaringType is TypeRef)
				typeDef = (declaringType as TypeRef).ResolveTypeDef();

			if (typeDef != null)
				return this.Importer.Import(typeDef.FindField(fieldName));
			else
				return null;
		}

		/// <summary>
		/// Resolve a TypeDef or TypeRef from its name. If neither a TypeDef or TypeRef are found
		/// in the module, search its references (AssemblyRefs) and if a match is found, add a TypeRef
		/// for it to the module and return that.
		/// </summary>
		/// <param name="fullName">Name of TypeDef or TypeRef as found in the resource</param>
		/// <param name="isReflectionName">Whether or not the name is a reflection name</param>
		/// <returns>TypeDef or TypeRef, or null if none found</returns>
		public ITypeDefOrRef ResolveTypeDefOrRef(TypeName typeName)
		{
			String fullName = typeName.Name;

			// Return TypeDef if found
			TypeDef typeDef = _module.Find(fullName, false);
			if (typeDef != null)
				return typeDef;

			// Return existing TypeRef if found
			var typeRefs = _module.GetTypeRefs();
			foreach(var typeRef in typeRefs)
			{
				if (typeRef.FullName.Equals(fullName))
					return typeRef;
			}

			// Get the AssemblyRef from the type name and make our own TypeRef
			AssemblyRef asmRef = this.FindAssemblyRef(typeName);
			if(!typeName.IsNested)
				return new TypeRefUser(_module, typeName.Namespace, typeName.NameWithoutNamespace, asmRef);
			else
			{
				// Lazy...
				var parentName = typeName.ParentName.Split('.').Last();
				TypeRef resolutionRef = new TypeRefUser(_module, typeName.Namespace, parentName, asmRef);
				return new TypeRefUser(_module, "", typeName.NestedName, resolutionRef);
			}
		}

		/// <summary>
		/// Get the AssemblyRef of the module from the assembly full name, adding
		/// our own AssemblyRef if none found.
		/// </summary>
		/// <param name="fullName">TypeName containing the assembly's full name</param>
		/// <returns>AssemblyRef</returns>
		public AssemblyRef FindAssemblyRef(TypeName typeName)
		{
			return this.FindAssemblyRef(typeName.AssemblyFullName);
		}

		/// <summary>
		/// Get the AssemblyRef of the module from the assembly full name, adding
		/// our own AssemblyRef if none found.
		/// </summary>
		/// <param name="fullName">Assembly full name</param>
		/// <returns>AssemblyRef</returns>
		public AssemblyRef FindAssemblyRef(String fullName)
		{
			// fullName: ", mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			// causes...
			// System.IO.FileLoadException: The given assembly name or codebase was invalid. (Exception from HRESULT: 0x80131047)
			//    at System.Reflection.AssemblyName.nInit(RuntimeAssembly& assembly, Boolean forIntrospection, Boolean raiseResolveEvent)
			//    at System.Reflection.AssemblyName.nInit()
			//    at eazdevirt.Util.NameResolver.FindAssemblyRef(String fullName)
			//    at eazdevirt.Util.NameResolver.FindAssemblyRef(TypeName typeName)
			//    at eazdevirt.Util.NameResolver.ResolveTypeDefOrRef(TypeName typeName)
			//    at eazdevirt.IO.Resolver.ResolveType_NoLock(Int32 position)
			//    at eazdevirt.IO.Resolver.ResolveType(Int32 position)
			//    at eazdevirt.IO.VirtualizedMethodBodyReader.SetLocalsAndParameters()
			//    at eazdevirt.IO.VirtualizedMethodBodyReader.Read()
			//    at eazdevirt.Devirtualizer.Devirtualize(DevirtualizeOptions options, Action`1 attemptCallback)

			// Try to find AssemblyRef via full name
			var assemblyRef = _module.GetAssemblyRefs().FirstOrDefault((ar) =>
			{
				return ar.FullName.Equals(fullName);
			});

			if (assemblyRef != null)
				return assemblyRef;

			// If unable to find, add our own AssemblyRef from the full name
			return new AssemblyRefUser(new System.Reflection.AssemblyName(fullName));
		}
	}

	/// <summary>
	/// Convenience class for interpreting the type names found in the
	/// encrypted virtualization resources file.
	/// </summary>
	public class TypeName
	{
		/// <summary>
		/// Full name as given in constructor.
		/// </summary>
		public String FullName { get; private set; }

		public TypeName(String fullName)
		{
			// Eazfuscator.NET uses '+' to indicate a nested type name follows, while
			// dnlib uses '/'
			this.FullName = fullName.Replace('+', '/');
		}

		/// <summary>
		/// Full assembly name.
		/// </summary>
		public String AssemblyFullName
		{
			get
			{
				return this.FullName.Substring(
					this.Name.Length + 2,
					this.FullName.Length - (this.Name.Length + 2)
				);
			}
		}

		/// <summary>
		/// Assembly name.
		/// </summary>
		public String AssemblyName
		{
			get { return AssemblyFullName.Split(',')[0]; }
		}

		/// <summary>
		/// Type name without namespace.
		/// </summary>
		public String NameWithoutNamespace
		{
			get
			{
				//if (this.Name.Contains('/'))
				//	return this.Name.Split('/').Last();

				if (this.Name.Contains('.'))
					return this.Name.Split('.').Last();
				else
					return String.Empty;
			}
		}

		/// <summary>
		/// Namespace.
		/// </summary>
		public String Namespace
		{
			get
			{
				if (this.Name.Contains('.'))
				{
					return String.Join(".",
						this.Name.Split('.').Reverse().Skip(1).Reverse().ToArray());
				}
				else
					return this.Name;
			}
		}

		/// <summary>
		/// Type name without assembly info.
		/// </summary>
		public String Name
		{
			get
			{
				if (this.FullName.Contains(", "))
				{
					// return this.FullName.Split(',')[0];
					String fixedName, typeName = this.FullName.Split(',')[0];
					this.GetModifiersStack(typeName, out fixedName);
					return fixedName;
				}
				else return this.FullName;
			}
		}

		public Stack<String> Modifiers
		{
			get
			{
				if (this.FullName.Contains(", "))
				{
					String fixedName, typeName = this.FullName.Split(',')[0];
					return this.GetModifiersStack(typeName, out fixedName);
				}
				else
					return null;
			}
		}

		/// <summary>
		/// Whether or not this name indicates the type is nested.
		/// </summary>
		public Boolean IsNested
		{
			get
			{
				return this.Name.Contains('/');
			}
		}

		/// <summary>
		/// The parent type name if nested. If not nested, null.
		/// </summary>
		public String ParentName
		{
			get
			{
				// Return name without last "+TypeName"
				if (this.IsNested)
					return String.Join("/",
						this.Name.Split('/').Reverse().Skip(1).Reverse().ToArray());
				else
					return null;
			}
		}

		/// <summary>
		/// The nested child type name if nested. If not nested, null.
		/// </summary>
		public String NestedName
		{
			get
			{
				if (this.IsNested)
					return this.Name.Split('/').Last();
				else
					return null;
			}
		}

		/// <summary>
		/// Get a modifiers stack from a deserialized type name, and also
		/// provide the fixed name.
		/// </summary>
		/// <param name="rawName">Deserialized name</param>
		/// <param name="fixedName">Fixed name</param>
		/// <returns>Modifiers stack</returns>
		Stack<String> GetModifiersStack(String rawName, out String fixedName)
		{
			var stack = new Stack<String>();

			while (true)
			{
				if (rawName.EndsWith("[]"))
					stack.Push("[]");
				else if (rawName.EndsWith("*"))
					stack.Push("*");
				else if (rawName.EndsWith("&"))
					stack.Push("&");
				else break;

				rawName = rawName.Substring(0, rawName.Length - stack.Peek().Length);
			}

			fixedName = rawName;
			return stack;
		}
	}
}



================================================
File: src/eazdevirt/Util/SigUtil.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace eazdevirt.Util
{
	public static class SigUtil
	{
		/// <summary>
		/// Apply a series of modifiers ("[]", "*", "&") to a base TypeSig.
		/// </summary>
		/// <param name="baseSig">Base TypeSig</param>
		/// <param name="modifiers">Modifier strings</param>
		/// <returns>TypeSig</returns>
		public static TypeSig FromBaseSig(TypeSig baseSig, Stack<String> modifiers)
		{
			String mod;
			while (modifiers.Count > 0)
			{
				mod = modifiers.Pop();
				switch (mod)
				{
					case "[]": baseSig = new SZArraySig(baseSig); break;
					case "*": baseSig = new PtrSig(baseSig); break;
					case "&": baseSig = new ByRefSig(baseSig); break;
					default:
						throw new Exception(String.Format("Unknown modifier: {0}", mod));
				}
			}
			return baseSig;
		}

		/// <summary>
		/// Get the base TypeSig.
		/// </summary>
		/// <param name="typeSig">TypeSig</param>
		/// <param name="modifiers">Modifiers to set</param>
		/// <returns>Base TypeSig</returns>
		public static TypeSig ToBaseSig(TypeSig typeSig, out Stack<String> modifiers)
		{
			modifiers = new Stack<String>();

			// While a non-leaf sig
			while (typeSig.Next != null)
			{
				if (typeSig.IsSZArray)
				{
					modifiers.Push("[]");
					typeSig = typeSig.Next;
				}
				else if (typeSig.IsPointer)
				{
					modifiers.Push("*");
					typeSig = typeSig.Next;
				}
				else if (typeSig.IsByRef)
				{
					modifiers.Push("&");
					typeSig = typeSig.Next;
				}
				//else if (typeSig.IsArray)
				//{
				//}
				else
					return null;
			}

			return typeSig;
		}
	}
}



================================================
File: src/eazdevirt/Util/StackTypesCalculator.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace eazdevirt.Util
{
	/// <summary>
	/// Calculates the stack state (types on the stack) for each instruction
	/// in a method.
	/// </summary>
	public class StackTypesCalculator
	{
		/// <summary>
		/// Method to walk and calculate stack for.
		/// </summary>
		public MethodDef Method { get; private set; }

		/// <summary>
		/// All calculated stack states mapped by instruction.
		/// </summary>
		private Dictionary<Instruction, Tuple<Stack<TypeSig>, Stack<TypeSig>>> _states;

		/// <summary>
		/// Method instructions.
		/// </summary>
		public IList<Instruction> Instructions
		{
			get
			{
				if (this.Method.HasBody && this.Method.Body.HasInstructions)
					return this.Method.Body.Instructions;
				else
					return new List<Instruction>();
			}
		}

		public StackTypesCalculator(MethodDef method)
		{
			this.Method = method;
			InitStates();
		}

		private void InitStates()
		{
			_states = new Dictionary<Instruction, Tuple<Stack<TypeSig>, Stack<TypeSig>>>();
			foreach (var instr in this.Instructions)
				_states.Add(instr, null);
		}

		/// <summary>
		/// Get the stack state of an instruction in the method, or null if none.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <returns>
		/// Stack state when the instruction is executed, or null if none or
		/// instruction not found
		/// </returns>
		public Tuple<Stack<TypeSig>, Stack<TypeSig>> States(Instruction instr)
		{
			Tuple<Stack<TypeSig>, Stack<TypeSig>> state;
			_states.TryGetValue(instr, out state);
			if (state != null)
				return state;
			else
				return null;
		}

		/// <summary>
		/// Check whether or not an instruction maps to a stack state.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <returns>true if it maps to a stack state, false if not</returns>
		Boolean HasStackState(Instruction instr)
		{
			return _states[instr] != null;
		}

		/// <summary>
		/// Clone and set a stack state to an instruction.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <param name="stack">Stack state to clone</param>
		void SetStackState(Instruction instr, Stack<TypeSig> stackBefore, Stack<TypeSig> stackAfter)
		{
			//Console.WriteLine("Setting state: {0}", instr);
			//WriteStack(stackAfter);
			//Console.WriteLine("-----");

			_states[instr] = new Tuple<Stack<TypeSig>, Stack<TypeSig>>(stackBefore, stackAfter);
		}

		void WriteStack(Stack<TypeSig> stack)
		{
			var clone = CloneStack<TypeSig>(stack);
			Console.WriteLine("Stack[{0}]:", clone.Count);
			while (clone.Count > 0)
				Console.WriteLine(clone.Pop());
		}

		/// <summary>
		/// Perform a shallow clone of a Stack and return the result.
		/// </summary>
		/// <typeparam name="T">Stack type</typeparam>
		/// <param name="stack">Stack to clone</param>
		/// <returns>Cloned stack</returns>
		Stack<T> CloneStack<T>(Stack<T> stack)
		{
			T[] array = new T[stack.Count];
			stack.CopyTo(array, 0);
			return new Stack<T>(array.Reverse());
		}

		/// <summary>
		/// Get the type loaded onto the stack by a Ldarg instruction.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <returns>Loaded type</returns>
		TypeSig LdargType(Instruction instr)
		{
			Int32 operand = 0;
			if (instr.Operand is Parameter)
				operand = (instr.Operand as Parameter).Index;

			var parameters = this.Method.Parameters;
			switch (instr.OpCode.Code)
			{
				case Code.Ldarg:
					return parameters[(UInt16)operand].Type;
				case Code.Ldarg_0:
					return parameters[0].Type;
				case Code.Ldarg_1:
					return parameters[1].Type;
				case Code.Ldarg_2:
					return parameters[2].Type;
				case Code.Ldarg_3:
					return parameters[3].Type;
				case Code.Ldarg_S:
					return parameters[(Byte)operand].Type;
				// Unsure about Ldarga/Ldarga_S
				case Code.Ldarga:
					return new ByRefSig(parameters[(UInt16)operand].Type);
				case Code.Ldarga_S:
					return new ByRefSig(parameters[(Byte)operand].Type);
			}

			return null;
		}

		/// <summary>
		/// Get the type loaded onto the stack by a Ldloc instruction.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <returns>Loaded type</returns>
		TypeSig LdlocType(Instruction instr)
		{
			Int32 operand = 0;
			if (instr.Operand is Local)
				operand = (instr.Operand as Local).Index;

			var vars = this.Method.Body.Variables;
			switch (instr.OpCode.Code)
			{
				case Code.Ldloc:
					return vars[(UInt16)operand].Type;
				case Code.Ldloc_0:
					return vars[0].Type;
				case Code.Ldloc_1:
					return vars[1].Type;
				case Code.Ldloc_2:
					return vars[2].Type;
				case Code.Ldloc_3:
					return vars[3].Type;
				case Code.Ldloc_S:
					return vars[(Byte)operand].Type;
				// Unsure about Ldloca/Ldloca_S
				case Code.Ldloca:
					return new ByRefSig(vars[(UInt16)operand].Type);
				case Code.Ldloca_S:
					return new ByRefSig(vars[(Byte)operand].Type);
			}

			return null;
		}

		/// <summary>
		/// Get the type loaded by a math instruction.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <param name="state">Current state</param>
		/// <returns>Loaded type</returns>
		TypeSig MathType(Instruction instr, Stack<TypeSig> state)
		{
			switch (instr.OpCode.Code)
			{
				case Code.Add:
				case Code.Add_Ovf:
				case Code.Add_Ovf_Un:
				case Code.Div:
				case Code.Div_Un:
				case Code.Mul:
				case Code.Mul_Ovf:
				case Code.Mul_Ovf_Un:
				case Code.Sub:
				case Code.Sub_Ovf:
				case Code.Sub_Ovf_Un:
				case Code.Shl:
				case Code.Shr:
				case Code.Shr_Un:
					return state.Peek();
				// Unsure about Rem
				case Code.Rem:
				case Code.Rem_Un:
					return state.Peek();
			}

			return null;
		}

		/// <summary>
		/// Gets the types to push onto the stack from an instruction. Should
		/// be run before popping.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <param name="state">Current stack state</param>
		/// <returns>Types to push</returns>
		IList<TypeSig> PushTypes(Instruction instr, Stack<TypeSig> state)
		{
			var module = this.Method.Module;
			var list = new List<TypeSig>();
			switch (instr.OpCode.StackBehaviourPush)
			{
				case StackBehaviour.Push0:
				default:
					break;
				case StackBehaviour.Push1:
					TypeSig type;
					if ((type = this.LdargType(instr)) != null
					|| (type = this.LdlocType(instr)) != null
					|| (type = this.MathType(instr, state)) != null)
						list.Add(type);
					else if (instr.OpCode.Code == Code.Ldfld || instr.OpCode.Code == Code.Ldsfld)
						list.Add((instr.Operand as IField).FieldSig.Type);
					else throw new Exception(String.Format("Unknown type pushed by Push1 instruction: {0}", instr));
					break;
				case StackBehaviour.Push1_push1:
					// Only Dup has Push1_Push1 behaviour
					if (instr.OpCode.Code == Code.Dup)
					{
						// Assumes value hasn't yet been popped: Will need to make sure that
						// this method is run before popping
						list.Add(state.Peek());
						list.Add(state.Peek());
					}
					break;
				case StackBehaviour.Pushi:
					list.Add(module.CorLibTypes.Int32);
					break;
				case StackBehaviour.Pushi8:
					list.Add(module.CorLibTypes.Int64);
					break;
				case StackBehaviour.Pushr4:
					list.Add(module.CorLibTypes.Single);
					break;
				case StackBehaviour.Pushr8:
					list.Add(module.CorLibTypes.Double);
					break;
				case StackBehaviour.Pushref:
					if (instr.OpCode.Code == Code.Ldstr)
						list.Add(module.CorLibTypes.String);
					else if (instr.OpCode.Code == Code.Ldind_Ref)
						list.Add(state.Peek().Next);
					else if (instr.OpCode.Code == Code.Newobj)
					{
						var method = (instr.Operand as IMethod).ResolveMethodDefThrow();
						if (instr.OpCode.Code == Code.Newobj)
							list.Add(method.DeclaringType.ToTypeSig());
					}
					else list.Add(module.CorLibTypes.Object); // Object by default
					break;
				case StackBehaviour.Varpush:
					if (instr.Operand is IMethod)
					{
						TypeSig returnType = (instr.Operand as IMethod).ResolveMethodDefThrow().ReturnType;
						if (returnType != null && !returnType.FullName.Equals("System.Void"))
							list.Add(returnType);
					}
					break;
			}

			return list;
		}

		/// <summary>
		/// Get the number of pops an instruction performs.
		/// </summary>
		/// <param name="instr">Instruction</param>
		/// <returns>Pop count</returns>
		Int32 PopCount(Instruction instr)
		{
			switch (instr.OpCode.StackBehaviourPop)
			{
				case StackBehaviour.Pop0:
				default: // PopAll ?
					return 0;
				case StackBehaviour.Pop1:
				case StackBehaviour.Popi:
				case StackBehaviour.Popref:
					return 1;
				case StackBehaviour.Pop1_pop1:
				case StackBehaviour.Popi_pop1:
				case StackBehaviour.Popi_popi:
				case StackBehaviour.Popi_popi8:
				case StackBehaviour.Popi_popr4:
				case StackBehaviour.Popi_popr8:
				case StackBehaviour.Popref_pop1:
				case StackBehaviour.Popref_popi:
					return 2;
				case StackBehaviour.Popi_popi_popi:
				case StackBehaviour.Popref_popi_pop1:
				case StackBehaviour.Popref_popi_popi:
				case StackBehaviour.Popref_popi_popi8:
				case StackBehaviour.Popref_popi_popr4:
				case StackBehaviour.Popref_popi_popr8:
				case StackBehaviour.Popref_popi_popref:
					return 3;
				case StackBehaviour.Varpop:
					if (instr.Operand is IMethod)
					{
						MethodDef method = (instr.Operand as IMethod).ResolveMethodDefThrow();

						if (instr.OpCode.Code == Code.Newobj)
							return method.Parameters.Count - 1;
						else
							return method.Parameters.Count;
					}
					else if (instr.OpCode.Code == Code.Ret)
						return 0; // Unsure?
					throw new Exception("Unexpected operand type for instruction with stack behaviour Varpop");
			}
		}

		void WalkHandlers()
		{
			var body = this.Method.Body;

			if (body.HasExceptionHandlers)
			{
				foreach (var handler in body.ExceptionHandlers)
				{
					switch(handler.HandlerType)
					{
						case ExceptionHandlerType.Catch:
						case ExceptionHandlerType.Finally:
							var state = States(handler.FilterStart).Item1; // State before try { ... }
							if (handler.HandlerType == ExceptionHandlerType.Catch)
								state.Push(handler.CatchType.ToTypeSig()); // Push the exception type being caught
							Walk(handler.HandlerStart, state);
							break;
					}
				}
			}
		}

		void Walk(Instruction start, Stack<TypeSig> state)
		{
			Walk(this.Instructions.IndexOf(start), state);
		}

		void Walk(Int32 offset, Stack<TypeSig> state)
		{
			var instructions = this.Instructions;

			for (Int32 i = offset; i < instructions.Count; i++)
			{
				var instr = instructions[i];
				var before = CloneStack<TypeSig>(state);

				if (HasStackState(instr))
					return;

				// Get types to push
				var pushTypes = PushTypes(instr, state);

				// Pop everything
				for (Int32 p = 0; p < PopCount(instr); p++)
					state.Pop();

				// Push everything
				foreach (var type in pushTypes)
					state.Push(type);

				// Set the stack state
				SetStackState(instr, before, state);

				// Determine where to go next via flow control
				switch (instr.OpCode.FlowControl)
				{
					case FlowControl.Branch:
						Walk(instr.Operand as Instruction, state);
						return;
					case FlowControl.Cond_Branch:
						Walk(instr.Operand as Instruction, CloneStack<TypeSig>(state));
						break;
					case FlowControl.Return:
					case FlowControl.Throw:
						return;
					case FlowControl.Call:
					case FlowControl.Next:
					default:
						break;
				}
			}
		}

		public void Walk()
		{
			Walk(0, new Stack<TypeSig>());
			WalkHandlers();
		}
	}
}


Directory structure:
└── wwh1004-extremedumper/
    ├── README.md
    ├── ExtremeDumper.Common.props
    ├── ExtremeDumper.sln
    ├── README.zh-CN.md
    ├── appveyor.yml
    ├── .editorconfig
    ├── ExtremeDumper/
    │   ├── ExtremeDumper.csproj
    │   ├── FodyWeavers.xml
    │   ├── FodyWeavers.xsd
    │   ├── Formatter.cs
    │   ├── GlobalExceptionCatcher.cs
    │   ├── Program.cs
    │   ├── app.manifest
    │   ├── AntiAntiDump/
    │   │   ├── AADCoreInjector.cs
    │   │   ├── AADExtensions.cs
    │   │   └── SharedAADClientManager.cs
    │   ├── Diagnostics/
    │   │   ├── AADModulesProvider.cs
    │   │   ├── DefaultProcessesProvider.cs
    │   │   ├── IModulesProvider.cs
    │   │   ├── IProcessesProvider.cs
    │   │   ├── ManagedModulesProvider.cs
    │   │   ├── ModuleInfo.cs
    │   │   ├── ModulesProviderFactory.cs
    │   │   ├── ProcessInfo.cs
    │   │   ├── ProcessesProviderFactory.cs
    │   │   └── UnmanagedModulesProvider.cs
    │   ├── Dumping/
    │   │   ├── AntiAntiDumper.cs
    │   │   ├── BuiltInAssemblyHelper.cs
    │   │   ├── DumperBase.cs
    │   │   ├── DumperFactory.cs
    │   │   ├── IDumper.cs
    │   │   ├── NormalDumper.cs
    │   │   └── PEImageDumper.cs
    │   ├── Forms/
    │   │   ├── FunctionsForm.Designer.cs
    │   │   ├── FunctionsForm.cs
    │   │   ├── FunctionsForm.resx
    │   │   ├── InjectingForm.Designer.cs
    │   │   ├── InjectingForm.cs
    │   │   ├── InjectingForm.resx
    │   │   ├── ListViewExtesion.cs
    │   │   ├── ListViewItemSorter.cs
    │   │   ├── LoaderHookForm.Designer.cs
    │   │   ├── LoaderHookForm.cs
    │   │   ├── LoaderHookForm.resx
    │   │   ├── ModulesForm.Designer.cs
    │   │   ├── ModulesForm.cs
    │   │   ├── ModulesForm.resx
    │   │   ├── NativeMethods.cs
    │   │   ├── ProcessesForm.Designer.cs
    │   │   ├── ProcessesForm.cs
    │   │   ├── ProcessesForm.resx
    │   │   ├── Resources.Designer.cs
    │   │   ├── Resources.resx
    │   │   ├── TitleComposer.cs
    │   │   └── Utils.cs
    │   ├── Images/
    │   ├── Injecting/
    │   │   └── Injector.cs
    │   ├── Logging/
    │   │   ├── ErrorToFileLogger.cs
    │   │   ├── Logger.InterpolatedStringHandler.cs
    │   │   ├── Logger.cs
    │   │   ├── TypeLoggingAliasAttribute.cs
    │   │   └── Internal/
    │   │       ├── AsyncLogger.Core.cs
    │   │       ├── AsyncLogger.cs
    │   │       ├── DefaultLogger.cs
    │   │       ├── ILogger.cs
    │   │       ├── Logger.InterpolatedStringHandler.cs
    │   │       ├── Logger.cs
    │   │       └── NullLogger.cs
    │   └── System/
    │       ├── Array2.cs
    │       ├── HandleProcessCorruptedStateExceptionsAttribute.cs
    │       ├── InterpolatedStringHandlerAttribute.cs
    │       ├── NRT.cs
    │       └── NRT_Helpers.cs
    ├── ExtremeDumper-x86/
    │   ├── ExtremeDumper-x86.csproj
    │   ├── FodyWeavers.xml
    │   ├── Program.cs
    │   └── app.manifest
    ├── ExtremeDumper.AntiAntiDump/
    │   ├── AADClient.cs
    │   ├── AADClients.cs
    │   ├── AADCommand.cs
    │   ├── AADPipe.cs
    │   ├── AADServer.cs
    │   ├── AppDomainInfo.cs
    │   ├── CommandHandlerManager.cs
    │   ├── ExtremeDumper.AntiAntiDump.csproj
    │   ├── ICommandHandler.cs
    │   ├── Injection.cs
    │   ├── MetadataInfo.cs
    │   ├── ModuleInfo.cs
    │   ├── PEInfo.cs
    │   ├── RuntimeInfo.cs
    │   ├── Serialization.cs
    │   ├── Handlers/
    │   │   ├── EnableMultiDomainHandler.cs
    │   │   ├── GetAppDomainInfoHandler.cs
    │   │   ├── GetMetadataInfoHandler.cs
    │   │   ├── GetModulesHandler.cs
    │   │   ├── GetPEInfoHandler.cs
    │   │   └── GetRuntimeInfoHandler.cs
    │   └── System/
    │       ├── Array2.cs
    │       ├── HandleProcessCorruptedStateExceptionsAttribute.cs
    │       ├── NRT.cs
    │       ├── NRT_Helpers.cs
    │       └── Extensions/
    │           └── ExceptionExtensions.cs
    ├── ExtremeDumper.LoaderHook/
    │   ├── ExtremeDumper.LoaderHook.vcxproj
    │   ├── ExtremeDumper.LoaderHook.vcxproj.filters
    │   ├── debugmacros.h
    │   ├── dllmain.c
    │   ├── hijackversion.c
    │   ├── hijackversion.h
    │   ├── hijackversion_jump_x64.asm
    │   ├── hijackversion_jump_x86.asm
    │   ├── loaderhook.c
    │   ├── loaderhook.def
    │   ├── loaderhook.h
    │   ├── stubx64.asm
    │   ├── stubx86.asm
    │   └── utils.h
    ├── Images/
    └── Libraries/
        ├── Detours/
        └── MetadataLocator/

================================================
File: README.md
================================================
# ExtremeDumper [![Build status](https://ci.appveyor.com/api/projects/status/f6kyx4yv68lwain0?svg=true)](https://ci.appveyor.com/project/wwh1004/extremedumper)
.NET Assembly Dumper

[ä¸­æ–‡README](./README.zh-CN.md)

## Features
* List all processes and highlight .NET processes
* List all modules in a process and highlight .NET modules
* Walk memory pages and dump all valid .NET assemblies
* Dump specified module in modules view
* Inject .NET assembly into any process
* Enhanced anti-dump bypass mode
* .NET assembly loader hook
* Anti title keyword detection
* Portable and only one executable file

## Description
### View Processes
![](./Images/ProcessView.png)

The default page is process view. You can right click here to dump all .NET modules and view modules in selected process. And also you can click "Inject Dll" to inject a .NET assembly into any process. Any process which contains desktop clr or coreclr will be marked as green.

### View Modules
![](./Images/ModuleView.png)

This page show all modules in select process and you can just view .NET modules by click "Only .NET Modules". Any .NET module will be marked as green.

### View Exported Functions
![](./Images/ExportFunctionView.png)

This page show exported functions for given module.

### Inject .NET Assemblies
![](./Images/InjectManagedDll.png)

Currently the injector supports any .NET Framework assembly with any platform target. And you can pass a string argument to injection main method in injector. In the future it will supports .NET Core.

### Bypass Anti-Dump
Before:
![](./Images/AntiAntiDump1.png)
![](./Images/AntiAntiDump3.png)
After:
![](./Images/AntiAntiDump2.png)
![](./Images/AntiAntiDump4.png)

#### Usage
Open context menu in modules view and click 'Enable AntiAntiDump'. After enabling it, you can directly and easily dump all .NET assembly which contains anti-dump protection.

#### Principle
ExtremeDumper will inject core dll into target process and read metadata info from clr internal object. Unlike AntiAntiDump in V2, this one has almost perfect compatibility.

### .NET Assembly Loader Hook
![](./Images/LoaderHook1.png)
![](./Images/LoaderHook2.png)

#### Usage
Click 'Open Loader Hook' in main window and you will see 'Loader Hook' window. Select a program to dump and click 'Run With Hook'. 

#### Advanced Usage
Rename 'ExtremeDumper.LoaderHook.dll' to 'version.dll' and put it in the root of the program. It can be loaded in dll hijack mode.

#### Principle
Loader hook will hook 'clr!AssemblyNative::LoadImage' at startup of the application. When any .NET assembly is loaded by apis like 'Assembly.Load(byte[])', loader hook will save raw byte array to disk.

## Downloads
GitHub: [Latest release](https://github.com/wwh1004/ExtremeDumper/releases/latest/download/ExtremeDumper.zip)

AppVeyor: [Latest build](https://ci.appveyor.com/api/buildjobs/ytfttpe2ev8kyheu/artifacts/bin%2FRelease%2FExtremeDumper.zip)



================================================
File: ExtremeDumper.Common.props
================================================
<Project>
	<PropertyGroup>
		<Title>ExtremeDumper</Title>
		<Version>4.0.0.1</Version>
		<Copyright>Copyright Â© 2018-2022 Wwh</Copyright>
	</PropertyGroup>
	<PropertyGroup>
		<AllowUnsafeBlocks>true</AllowUnsafeBlocks>
		<Nullable>enable</Nullable>
		<LangVersion>10.0</LangVersion>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
	</PropertyGroup>
</Project>



================================================
File: ExtremeDumper.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.32112.339
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ExtremeDumper", "ExtremeDumper\ExtremeDumper.csproj", "{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ExtremeDumper-x86", "ExtremeDumper-x86\ExtremeDumper-x86.csproj", "{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ExtremeDumper.AntiAntiDump", "ExtremeDumper.AntiAntiDump\ExtremeDumper.AntiAntiDump.csproj", "{0F76706D-F95E-43DB-9ECE-4991AA537831}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ExtremeDumper.LoaderHook", "ExtremeDumper.LoaderHook\ExtremeDumper.LoaderHook.vcxproj", "{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}.Debug|x64.ActiveCfg = Debug|Any CPU
		{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}.Debug|x86.ActiveCfg = Debug|Any CPU
		{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}.Release|Any CPU.Build.0 = Release|Any CPU
		{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}.Release|x64.ActiveCfg = Release|Any CPU
		{BA1D5A3E-330E-4D82-BFF5-58B6CF52726C}.Release|x86.ActiveCfg = Release|Any CPU
		{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}.Debug|x64.ActiveCfg = Debug|Any CPU
		{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}.Debug|x86.ActiveCfg = Debug|Any CPU
		{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}.Release|Any CPU.Build.0 = Release|Any CPU
		{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}.Release|x64.ActiveCfg = Release|Any CPU
		{F4ED1869-89DC-4A43-A2D7-0766533EB2BA}.Release|x86.ActiveCfg = Release|Any CPU
		{0F76706D-F95E-43DB-9ECE-4991AA537831}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0F76706D-F95E-43DB-9ECE-4991AA537831}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0F76706D-F95E-43DB-9ECE-4991AA537831}.Debug|x64.ActiveCfg = Debug|Any CPU
		{0F76706D-F95E-43DB-9ECE-4991AA537831}.Debug|x86.ActiveCfg = Debug|Any CPU
		{0F76706D-F95E-43DB-9ECE-4991AA537831}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0F76706D-F95E-43DB-9ECE-4991AA537831}.Release|Any CPU.Build.0 = Release|Any CPU
		{0F76706D-F95E-43DB-9ECE-4991AA537831}.Release|x64.ActiveCfg = Release|Any CPU
		{0F76706D-F95E-43DB-9ECE-4991AA537831}.Release|x86.ActiveCfg = Release|Any CPU
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Debug|Any CPU.ActiveCfg = Debug|x64
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Debug|x64.ActiveCfg = Debug|x64
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Debug|x64.Build.0 = Debug|x64
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Debug|x86.ActiveCfg = Debug|Win32
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Debug|x86.Build.0 = Debug|Win32
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Release|Any CPU.ActiveCfg = Release|x64
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Release|x64.ActiveCfg = Release|x64
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Release|x64.Build.0 = Release|x64
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Release|x86.ActiveCfg = Release|Win32
		{A0553CA6-87FF-4A7F-8452-8FD5C6B6525F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4ED7F5D0-D7EC-491E-86FD-0215F210ADAD}
	EndGlobalSection
EndGlobal



================================================
File: README.zh-CN.md
================================================
# ExtremeDumper [![Build status](https://ci.appveyor.com/api/projects/status/f6kyx4yv68lwain0?svg=true)](https://ci.appveyor.com/project/wwh1004/extremedumper)
.NET程序集Dump工具

## 特性
* 列举所有进程并且高亮.NET进程
* 列举进程中所有模块并且高亮.NET模块
* 通过遍历内存页以Dump进程中全部有效的.NET程序集
* 在模块视图中Dump指定的模块
* 注入.NET程序集到任意进程
* 增强的反反Dump模式
* .NET程序集加载器Hook
* 反标题关键词检测
* 单个可执行文件

## 介绍
### 查看进程
![](./Images/ProcessView.png)

默认页面是进程视图。你可以在此选择进程，右键打开菜单，Dump此进程中所有.NET模块或者查看进程中所有模块。你也可以点击"Inject Dll"以注入.NET程序集到任意进程。所有存在clr模块的进程会被高亮为绿色。

### 查看模块
![](./Images/ModuleView.png)

这个页面会显示选中进程中的所有模块，同时你可以通过点击"Only .NET Modules"选项仅查看.NET模块。所有.NET模块会被高亮为绿色。

### 查看导出函数
![](./Images/ExportFunctionView.png)

这个页面显示了选中模块的导出函数。

### 注入.NET程序集
![](./Images/InjectManagedDll.png)

当前注入器仅支持任意架构下的.NET Framework的程序集。同时你可以在注入器中给Main方法传递字符串参数。计划未来支持.NET Core。

### 反反Dump
开启前:
![](./Images/AntiAntiDump1.png)
![](./Images/AntiAntiDump3.png)
开启后:
![](./Images/AntiAntiDump2.png)
![](./Images/AntiAntiDump4.png)

#### 用法
模块视图中打开右键菜单然后点击"Enable AntiAntiDump"。启用之后你可以很方便地直接Dump任何带有反Dump保护的.NET程序集。

#### 原理
ExtremeDumper会注入核心Dll到目标进程并且从CLR内部对象读取元数据信息。不同于V2版本中的反反Dump，当前版本拥有几乎完美的兼容性。

### .NET程序集加载器Hook
![](./Images/LoaderHook1.png)
![](./Images/LoaderHook2.png)

#### 用法
在主界面点击"Open Loader Hook"按钮，之后会弹出"Loader Hook"窗口。选择一个要Dump的程序，然后点击"Run With Hook"。

#### 高级用法
把"ExtremeDumper.LoaderHook.dll"重命名为"version.dll"，然后把它放在目标程序的根目录下。它将以Dll劫持模式加载。

#### 原理
加载器Hook会在程序启动时挂钩"clr!AssemblyNative::LoadImage"函数。当.NET程序集被"Assembly.Load(byte[])"这些API加载，加载器Hook会将它的原始字节数组保存到磁盘中。

## 下载
GitHub: [Latest release](https://github.com/wwh1004/ExtremeDumper/releases/latest/download/ExtremeDumper.zip)

AppVeyor: [Latest build](https://ci.appveyor.com/api/buildjobs/ytfttpe2ev8kyheu/artifacts/bin%2FRelease%2FExtremeDumper.zip)



================================================
File: appveyor.yml
================================================
version: '{build}'
image: Visual Studio 2022
install:
- cmd: git submodule update --init --recursive
before_build:
- cmd: appveyor-retry nuget restore
build_script:
- cmd: >-
    msbuild "C:\projects\extremedumper\ExtremeDumper.sln" /p:Configuration=Release /p:Platform=x86 /verbosity:normal /logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"

    msbuild "C:\projects\extremedumper\ExtremeDumper.sln" /p:Configuration=Release /p:Platform=x64 /verbosity:normal /logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"

    msbuild "C:\projects\extremedumper\ExtremeDumper.sln" /p:Configuration=Release /p:Platform="Any CPU" /verbosity:normal /logger:"C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"
after_build:
- cmd: 7z a bin\Release\ExtremeDumper.zip .\bin\Release\*.exe
artifacts:
- path: bin\Release\ExtremeDumper.zip
  name: ExtremeDumper
deploy:
- provider: GitHub
  tag: $(APPVEYOR_REPO_TAG_NAME)
  release: ExtremeDumper
  auth_token:
    secure: +8UJ1C312inNq+80I8WST34vPMrCylnmTx+9rmuIh1qnsArA5x2b8yc+kcwkXmQC
  on:
    APPVEYOR_REPO_TAG: true


================================================
File: .editorconfig
================================================
# Remove the line below if you want to inherit .editorconfig settings from higher directories
root = true

[*]
charset = utf-8
end_of_line = crlf
indent_size = 4
indent_style = tab
insert_final_newline = true
tab_width = 4
trim_trailing_whitespace = true

# C# files
[*.cs]

#### .NET Coding Conventions ####

# Organize usings
dotnet_separate_import_directive_groups = false
dotnet_sort_system_directives_first = true

# this. and Me. preferences
dotnet_style_qualification_for_event = false:suggestion
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_property = false:suggestion

# Language keywords vs BCL types preferences
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_predefined_type_for_member_access = true:suggestion

# Parentheses preferences
dotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:suggestion
dotnet_style_parentheses_in_other_binary_operators = always_for_clarity:suggestion
dotnet_style_parentheses_in_other_operators = never_if_unnecessary:suggestion
dotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:suggestion

# Modifier preferences
dotnet_style_require_accessibility_modifiers = for_non_interface_members:silent

# Expression-level preferences
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_collection_initializer = true:suggestion
dotnet_style_explicit_tuple_names = true:suggestion
dotnet_style_namespace_match_folder = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_object_initializer = true:suggestion
dotnet_style_operator_placement_when_wrapping = end_of_line
dotnet_style_prefer_auto_properties = false:suggestion
dotnet_style_prefer_compound_assignment = true:suggestion
dotnet_style_prefer_conditional_expression_over_assignment = true:silent
dotnet_style_prefer_conditional_expression_over_return = true:silent
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
dotnet_style_prefer_inferred_tuple_names = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
dotnet_style_prefer_simplified_boolean_expressions = true:suggestion
dotnet_style_prefer_simplified_interpolation = true:suggestion

# Field preferences
dotnet_style_readonly_field = true:suggestion

# Parameter preferences
dotnet_code_quality_unused_parameters = all:suggestion

# Suppression preferences
dotnet_remove_unnecessary_suppression_exclusions = none

# New line preferences
dotnet_style_allow_multiple_blank_lines_experimental = true:silent
dotnet_style_allow_statement_immediately_after_block_experimental = true:silent

#### C# Coding Conventions ####

# var preferences
csharp_style_var_elsewhere = true:suggestion
csharp_style_var_for_built_in_types = false:silent
csharp_style_var_when_type_is_apparent = true:suggestion

# Expression-bodied members
csharp_style_expression_bodied_accessors = true:suggestion
csharp_style_expression_bodied_constructors = false:suggestion
csharp_style_expression_bodied_indexers = true:suggestion
csharp_style_expression_bodied_lambdas = true:suggestion
csharp_style_expression_bodied_local_functions = false:suggestion
csharp_style_expression_bodied_methods = false:suggestion
csharp_style_expression_bodied_operators = false:suggestion
csharp_style_expression_bodied_properties = true:suggestion

# Pattern matching preferences
csharp_style_pattern_matching_over_as_with_null_check = true:suggestion
csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion
csharp_style_prefer_not_pattern = true:suggestion
csharp_style_prefer_pattern_matching = true:silent
csharp_style_prefer_switch_expression = false:suggestion

# Null-checking preferences
csharp_style_conditional_delegate_call = true:suggestion

# Modifier preferences
csharp_prefer_static_local_function = true:suggestion
csharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:silent

# Code-block preferences
csharp_prefer_braces = false:silent
csharp_prefer_simple_using_statement = true:suggestion
csharp_style_namespace_declarations = file_scoped:suggestion

# Expression-level preferences
csharp_prefer_simple_default_expression = true:suggestion
csharp_style_deconstructed_variable_declaration = true:suggestion
csharp_style_implicit_object_creation_when_type_is_apparent = true:suggestion
csharp_style_inlined_variable_declaration = true:suggestion
csharp_style_pattern_local_over_anonymous_function = true:suggestion
csharp_style_prefer_index_operator = true:suggestion
csharp_style_prefer_null_check_over_type_check = true:suggestion
csharp_style_prefer_range_operator = true:suggestion
csharp_style_throw_expression = true:suggestion
csharp_style_unused_value_assignment_preference = unused_local_variable:silent
csharp_style_unused_value_expression_statement_preference = unused_local_variable:silent

# 'using' directive preferences
csharp_using_directive_placement = outside_namespace:suggestion

# New line preferences
csharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = true:silent
csharp_style_allow_blank_lines_between_consecutive_braces_experimental = true:silent
csharp_style_allow_embedded_statements_on_same_line_experimental = true:silent

#### C# Formatting Rules ####

# New line preferences
csharp_new_line_before_catch = true
csharp_new_line_before_else = true
csharp_new_line_before_finally = true
csharp_new_line_before_members_in_anonymous_types = true
csharp_new_line_before_members_in_object_initializers = true
csharp_new_line_before_open_brace = none
csharp_new_line_between_query_expression_clauses = false

# Indentation preferences
csharp_indent_block_contents = true
csharp_indent_braces = false
csharp_indent_case_contents = true
csharp_indent_case_contents_when_block = false
csharp_indent_labels = one_less_than_current
csharp_indent_switch_labels = false

# Space preferences
csharp_space_after_cast = false
csharp_space_after_colon_in_inheritance_clause = true
csharp_space_after_comma = true
csharp_space_after_dot = false
csharp_space_after_keywords_in_control_flow_statements = true
csharp_space_after_semicolon_in_for_statement = true
csharp_space_around_binary_operators = before_and_after
csharp_space_around_declaration_statements = false
csharp_space_before_colon_in_inheritance_clause = true
csharp_space_before_comma = false
csharp_space_before_dot = false
csharp_space_before_open_square_brackets = false
csharp_space_before_semicolon_in_for_statement = false
csharp_space_between_empty_square_brackets = false
csharp_space_between_method_call_empty_parameter_list_parentheses = false
csharp_space_between_method_call_name_and_opening_parenthesis = false
csharp_space_between_method_call_parameter_list_parentheses = false
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
csharp_space_between_method_declaration_name_and_open_parenthesis = false
csharp_space_between_method_declaration_parameter_list_parentheses = false
csharp_space_between_parentheses = false
csharp_space_between_square_brackets = false

# Wrapping preferences
csharp_preserve_single_line_blocks = true
csharp_preserve_single_line_statements = true

#### Naming styles ####

# Naming rules

dotnet_naming_rule.interface_should_be_begins_with_i.severity = suggestion
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

dotnet_naming_rule.types_should_be_pascal_case.severity = suggestion
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = suggestion
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# Symbol specifications

dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.interface.required_modifiers = 

dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum
dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.types.required_modifiers = 

dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.non_field_members.required_modifiers = 

# Naming styles

dotnet_naming_style.pascal_case.required_prefix = 
dotnet_naming_style.pascal_case.required_suffix = 
dotnet_naming_style.pascal_case.word_separator = 
dotnet_naming_style.pascal_case.capitalization = pascal_case

dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix = 
dotnet_naming_style.begins_with_i.word_separator = 
dotnet_naming_style.begins_with_i.capitalization = pascal_case



================================================
File: ExtremeDumper/ExtremeDumper.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk.WindowsDesktop">
	<PropertyGroup>
		<UseWindowsForms>true</UseWindowsForms>
		<Description>.NET Assemblies Dumper</Description>
		<ApplicationIcon>..\ExtremeDumper\Images\ExtremeDumper.ico</ApplicationIcon>
	</PropertyGroup>
	<PropertyGroup>
		<TargetFramework>net462</TargetFramework>
		<OutputType>Exe</OutputType>
		<OutputPath>..\bin\$(Configuration)</OutputPath>
		<ApplicationManifest>app.manifest</ApplicationManifest>
	</PropertyGroup>
	<ItemGroup>
		<EmbeddedResource Include="..\ExtremeDumper.LoaderHook\bin\Win32\$(Configuration)\ExtremeDumper.LoaderHook.dll" Link="costura32\ExtremeDumper.LoaderHook.dll" />
		<EmbeddedResource Include="..\ExtremeDumper.LoaderHook\bin\x64\$(Configuration)\ExtremeDumper.LoaderHook.dll" Link="costura64\ExtremeDumper.LoaderHook.dll" />
	</ItemGroup>
	<ItemGroup>
		<PackageReference Include="Costura.Fody" Version="4.1.0" />
		<PackageReference Include="dnlib" Version="3.4.0" />
		<PackageReference Include="Microsoft.Diagnostics.Runtime" Version="1.1.142101" />
		<PackageReference Include="NativeSharp-lib" Version="3.0.0.1" />
		<PackageReference Include="Ookii.Dialogs.WinForms" Version="4.0.0" />
	</ItemGroup>
	<ItemGroup>
		<ProjectReference Include="..\ExtremeDumper.AntiAntiDump\ExtremeDumper.AntiAntiDump.csproj" />
	</ItemGroup>
	<ItemGroup>
		<Compile Update="Forms\Resources.Designer.cs">
			<DesignTime>True</DesignTime>
			<AutoGen>True</AutoGen>
			<DependentUpon>Resources.resx</DependentUpon>
		</Compile>
	</ItemGroup>
	<ItemGroup>
		<EmbeddedResource Update="Forms\Resources.resx">
			<Generator>ResXFileCodeGenerator</Generator>
			<LastGenOutput>Resources.Designer.cs</LastGenOutput>
		</EmbeddedResource>
	</ItemGroup>
	<Import Project="..\ExtremeDumper.Common.props" />
</Project>



================================================
File: ExtremeDumper/FodyWeavers.xml
================================================
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
	<Costura IncludeDebugSymbols='false' LoadAtModuleInit='false' />
</Weavers>



================================================
File: ExtremeDumper/FodyWeavers.xsd
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <!-- This file was generated by Fody. Manual changes to this file will be lost when your project is rebuilt. -->
  <xs:element name="Weavers">
    <xs:complexType>
      <xs:all>
        <xs:element name="Costura" minOccurs="0" maxOccurs="1">
          <xs:complexType>
            <xs:all>
              <xs:element minOccurs="0" maxOccurs="1" name="ExcludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with line breaks</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="IncludeAssemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged32Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="Unmanaged64Assemblies" type="xs:string">
                <xs:annotation>
                  <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element minOccurs="0" maxOccurs="1" name="PreloadOrder" type="xs:string">
                <xs:annotation>
                  <xs:documentation>The order of preloaded assemblies, delimited with line breaks.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:all>
            <xs:attribute name="CreateTemporaryAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>This will copy embedded files to disk before loading them into memory. This is helpful for some scenarios that expected an assembly to be loaded from a physical file.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeDebugSymbols" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Controls if .pdbs for reference assemblies are also embedded.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCompression" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Embedded assemblies are compressed by default, and uncompressed when they are loaded. You can turn compression off with this option.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="DisableCleanup" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>As part of Costura, embedded assemblies are no longer included as part of the build. This cleanup can be turned off.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="LoadAtModuleInit" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura by default will load as part of the module initialization. This flag disables that behavior. Make sure you call CosturaUtility.Initialize() somewhere in your code.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IgnoreSatelliteAssemblies" type="xs:boolean">
              <xs:annotation>
                <xs:documentation>Costura will by default use assemblies with a name like 'resources.dll' as a satellite resource and prepend the output path. This flag disables that behavior.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ExcludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to exclude from the default action of "embed all Copy Local references", delimited with |</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="IncludeAssemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of assembly names to include from the default action of "embed all Copy Local references", delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged32Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 32 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="Unmanaged64Assemblies" type="xs:string">
              <xs:annotation>
                <xs:documentation>A list of unmanaged 64 bit assembly names to include, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="PreloadOrder" type="xs:string">
              <xs:annotation>
                <xs:documentation>The order of preloaded assemblies, delimited with |.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:all>
      <xs:attribute name="VerifyAssembly" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'true' to run assembly verification (PEVerify) on the target assembly after all weavers have been executed.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="VerifyIgnoreCodes" type="xs:string">
        <xs:annotation>
          <xs:documentation>A comma-separated list of error codes that can be safely ignored in assembly verification.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="GenerateXsd" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>'false' to turn off automatic generation of the XML Schema file.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
</xs:schema>


================================================
File: ExtremeDumper/Formatter.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ExtremeDumper;

static unsafe class Formatter {
	public static string Format(object? o, int nameMaxLength = 512) {
		if (o is byte[] b)
			return BitConverter.ToString(b).Replace("-", string.Empty);

		if (o is string s)
			return s;

		if (o is null)
			return "<null>";

		if (o is IEnumerable<object> a)
			return string.Join(",", a.Select(t => Format(t, nameMaxLength)));

		return o.ToString();
	}

	public static string FormatHex(sbyte value) {
		return $"0x{value:X2}";
	}

	public static string FormatHex(byte value) {
		return $"0x{value:X2}";
	}

	public static string FormatHex(short value) {
		return $"0x{value:X4}";
	}

	public static string FormatHex(ushort value) {
		return $"0x{value:X4}";
	}

	public static string FormatHex(int value) {
		return $"0x{value:X8}";
	}

	public static string FormatHex(uint value) {
		return $"0x{value:X8}";
	}

	public static string FormatHex(long value) {
		return $"0x{value:X16}";
	}

	public static string FormatHex(ulong value) {
		return $"0x{value:X16}";
	}

	public static string FormatHex(nint value) {
		return sizeof(nint) == 4 ? $"0x{(int)value:X8}" : $"0x{(long)value:X16}";
	}

	public static string FormatHex(nuint value) {
		return sizeof(nuint) == 4 ? $"0x{(uint)value:X8}" : $"0x{(ulong)value:X16}";
	}

	public static string FormatHexAuto(int value) {
		return $"0x{value:X}";
	}

	public static string FormatHexAuto(uint value) {
		return $"0x{value:X}";
	}

	public static string FormatHexAuto(long value) {
		return $"0x{value:X}";
	}

	public static string FormatHexAuto(ulong value) {
		return $"0x{value:X}";
	}

	public static string FormatHexAuto(nint value) {
		return $"0x{(ulong)value:X}";
	}

	public static string FormatHexAuto(nuint value) {
		return $"0x{(ulong)value:X}";
	}
}



================================================
File: ExtremeDumper/GlobalExceptionCatcher.cs
================================================
using System;
using System.Windows.Forms;
using ExtremeDumper.Logging;

namespace ExtremeDumper;

/// <summary>
/// 全局错误捕获
/// </summary>
static class GlobalExceptionCatcher {
	static bool isStarted;

	/// <summary>
	/// 自动捕获所有异常
	/// </summary>
	public static void Catch() {
		if (!isStarted) {
			Application.ThreadException += (sender, e) => Logger.Exception(e.Exception);
			AppDomain.CurrentDomain.UnhandledException += (sender, e) => Logger.Exception(e.ExceptionObject as Exception);
			isStarted = true;
		}
	}
}



================================================
File: ExtremeDumper/Program.cs
================================================
using System;
using System.Windows.Forms;
using ExtremeDumper.Forms;

namespace ExtremeDumper;

public static class Program {
	[STAThread]
	public static void Main() {
		Environment.SetEnvironmentVariable("EXTREMEDUMPER_MAGIC", "C41F3A60");
		CosturaUtility.Initialize();
		Environment.SetEnvironmentVariable("EXTREMEDUMPER_MAGIC", null);
		Console.Title = string.Empty;
		GlobalExceptionCatcher.Catch();
		Application.EnableVisualStyles();
		Application.SetCompatibleTextRenderingDefault(false);
		Application.Run(new ProcessesForm());
	}
}



================================================
File: ExtremeDumper/app.manifest
================================================
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <!-- UAC Manifest Options
             If you want to change the Windows User Account Control level replace the 
             requestedExecutionLevel node with one of the following.

        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />

            Specifying requestedExecutionLevel element will disable file and registry virtualization. 
            Remove this element if your application requires this virtualization for backwards
            compatibility.
        -->
        <requestedExecutionLevel level="asInvoker" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on
           and is designed to work with. Uncomment the appropriate elements
           and Windows will automatically select the most compatible environment. -->

      <!-- Windows Vista -->
      <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->

      <!-- Windows 7 -->
      <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->

      <!-- Windows 8 -->
      <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->

      <!-- Windows 8.1 -->
      <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->

      <!-- Windows 10 -->
      <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->

    </application>
  </compatibility>

  <!-- Indicates that the application is DPI-aware and will not be automatically scaled by Windows at higher
       DPIs. Windows Presentation Foundation (WPF) applications are automatically DPI-aware and do not need 
       to opt in. Windows Forms applications targeting .NET Framework 4.6 that opt into this setting, should 
       also set the 'EnableWindowsFormsHighDpiAutoResizing' setting to 'true' in their app.config. 
       
       Makes the application long-path aware. See https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation -->
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <!--<longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>-->
    </windowsSettings>
  </application>

  <!-- Enable themes for Windows common controls and dialogs (Windows XP and later) -->
  <!--
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="*"
          publicKeyToken="6595b64144ccf1df"
          language="*"
        />
    </dependentAssembly>
  </dependency>
  -->

</assembly>



================================================
File: ExtremeDumper/AntiAntiDump/AADCoreInjector.cs
================================================
using System;
using System.IO;
using dnlib.DotNet;
using ExtremeDumper.Injecting;
using ExtremeDumper.Logging;

namespace ExtremeDumper.AntiAntiDump;

static class AADCoreInjector {
	static string dllPath = string.Empty;
	static string moduleName = string.Empty;

	public static string GetAADCoreModuleNameIfLoaded() {
		if (!string.IsNullOrEmpty(dllPath))
			moduleName = Path.GetFileNameWithoutExtension(dllPath);
		return moduleName;
	}

	public static string GetAADCorePath() {
		if (!string.IsNullOrEmpty(dllPath))
			return dllPath;

		var data = GetAADCore(true, out var name);
		dllPath = Path.Combine(Path.GetTempPath(), name);
		File.WriteAllBytes(dllPath, data);
		Logger.Info($"ExtremeDumper.AntiAntiDump.dll has been released to '{dllPath}'");
		return dllPath;
	}

	static byte[] GetAADCore(bool obfuscate, out string fileName) {
		using var module = ModuleDefMD.Load(typeof(AADServer).Module);
		if (obfuscate) {
			var t = Guid.NewGuid().ToString();
			module.Name = $"{t}.dll";
			module.Assembly.Name = t;
		}
		fileName = $"{module.Assembly.Name}.dll";
		using var stream = new MemoryStream();
		module.Write(stream);
		return stream.ToArray();
	}

	public static AADClient Inject(uint processId, InjectionClrVersion clrVersion) {
		return Inject(processId, clrVersion, Guid.NewGuid().ToString());
	}

	public static AADClient Inject(uint processId, InjectionClrVersion clrVersion, string pipeName) {
		if (processId == 0)
			throw new ArgumentNullException(nameof(processId));
		if (string.IsNullOrEmpty(pipeName))
			throw new ArgumentException($"'{nameof(pipeName)}' cannot be null or empty.", nameof(pipeName));

		bool b = Injector.InjectManaged(processId, GetAADCorePath(), "ExtremeDumper.AntiAntiDump.Injection", "Main", pipeName, clrVersion);
		if (!b)
			throw new InvalidOperationException("Can't inject ExtremeDumper.AntiAntiDump.dll to target process.");
		Logger.Info($"ExtremeDumper.AntiAntiDump.dll has been injected into process {processId} and clr version is {clrVersion}");

		var client = AADClient.Create(pipeName);
		if (client is null)
			throw new InvalidOperationException($"Can't create {nameof(AADClient)}.");
		Logger.Info($"Create {nameof(AADClient)} of process {processId} successfully and clr version is {clrVersion}");

		return client;
	}
}



================================================
File: ExtremeDumper/AntiAntiDump/AADExtensions.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ExtremeDumper.AntiAntiDump;

static class AADExtensions {
	public static IEnumerable<AADClient> EnumerateAADClients(uint processId) {
		return SharedAADClientManager.GetAADClients(processId).SelectMany(t => t);
	}

	public static IEnumerable<ModuleInfo> EnumerateModules(this AADClient client) {
		return client.GetModules(out var modules) ? modules : throw new InvalidOperationException("Can't get modules");
	}

	public static MetadataInfo GetMetadataInfo(this AADClient client, ModuleInfo module) {
		return client.GetMetadataInfo(module, out var peInfo) ? peInfo : throw new InvalidOperationException("Can't get metadata info");
	}

	public static PEInfo GetPEInfo(this AADClient client, ModuleInfo module) {
		return client.GetPEInfo(module, out var peInfo) ? peInfo : throw new InvalidOperationException("Can't get PE info");
	}
}



================================================
File: ExtremeDumper/AntiAntiDump/SharedAADClientManager.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using ExtremeDumper.Diagnostics;
using ExtremeDumper.Injecting;
using ExtremeDumper.Logging;

namespace ExtremeDumper.AntiAntiDump;

static class SharedAADClientManager {
	static readonly Dictionary<uint, List<AADClients>> cache = new();
	static readonly object lockObj = new();

	public static List<AADClients> GetAADClients(uint processId) {
		return GetAADClients(processId, 1000);
	}

	public static List<AADClients> GetAADClients(uint processId, int timeout) {
		lock (lockObj)
			return GetAADClients_NoLock(processId, timeout);
	}

	static List<AADClients> GetAADClients_NoLock(uint processId, int timeout) {
		if (cache.TryGetValue(processId, out var clients)) {
			if (clients.First().First().IsConnected) {
				Debug2.Assert(clients.All(t => t.All(t => t.IsConnected)));
				return clients;
			}
			cache.Remove(processId);
			// process already exited, remove it from cache
		}

		var processInfo = DefaultProcessesProvider.GetProcessInfo(processId);
		if (processInfo is null)
			throw new InvalidOperationException("Can't get process info");
		if (processInfo is not DotNetProcessInfo dotNetProcessInfo)
			throw new InvalidOperationException("Target process is not a valid .NET process");

		clients = new List<AADClients>();
		if (dotNetProcessInfo.HasCLR2)
			clients.Add(SetupAADClients(processId, timeout, InjectionClrVersion.V2));
		if (dotNetProcessInfo.HasCLR4)
			clients.Add(SetupAADClients(processId, timeout, InjectionClrVersion.V4));
		if (dotNetProcessInfo.HasCoreCLR)
			Logger.Warning("Currently AntiAntiDump mode doesn't support CoreCLR");
		cache.Add(processId, clients);
		return clients;
	}

	static AADClients SetupAADClients(uint processId, int timeout, InjectionClrVersion clrVersion) {
		var mainClient = AADCoreInjector.Inject(processId, clrVersion);
		if (!mainClient.Connect(timeout))
			throw new InvalidOperationException("Can't connect to AADServer.");
		var clients = AADClients.AsMultiDomain(mainClient);
		if (!clients.ConnectAll(timeout))
			throw new InvalidOperationException("Can't connect to AADServer in other application domain.");
		return clients;
	}
}



================================================
File: ExtremeDumper/Diagnostics/AADModulesProvider.cs
================================================
using System.Collections.Generic;
using System.Diagnostics;
using ExtremeDumper.AntiAntiDump;

namespace ExtremeDumper.Diagnostics;

sealed class AADModulesProvider : IModulesProvider {
	readonly uint processId;

	public AADModulesProvider(uint processId) {
		this.processId = processId;
	}

	public IEnumerable<ModuleInfo> EnumerateModules() {
		foreach (var client in AADExtensions.EnumerateAADClients(processId)) {
			var runtime = client.Runtime;
			foreach (var module in client.EnumerateModules()) {
				var peInfo = client.GetPEInfo(module);
				if (peInfo.IsInvalid) {
					// may be ngen image and corresponding IL image not loaded TODO: get native image, not IL image
					yield return new DotNetModuleInfo(module.AssemblyName, unchecked((nuint)(-1)), 0, "NGEN", module.DomainName, $"v{runtime.FileVersion}");
					continue;
				}

				var layout = peInfo.LoadedLayout;
				Debug2.Assert(!layout.IsInvalid);
				yield return new DotNetModuleInfo(module.AssemblyName, (nuint)layout.ImageBase, layout.ImageSize, peInfo.FilePath, module.DomainName, $"v{runtime.FileVersion}");
			}
		}
	}
}



================================================
File: ExtremeDumper/Diagnostics/DefaultProcessesProvider.cs
================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using NativeSharp;

namespace ExtremeDumper.Diagnostics;

sealed class DefaultProcessesProvider : IProcessesProvider {
	public IEnumerable<ProcessInfo> EnumerateProcesses() {
		var processIds = NativeProcess.GetAllProcessIds();
		if (processIds is null || processIds.Length == 0)
			yield break;
		foreach (uint processId in processIds) {
			if (processId == 0)
				continue;

			var processInfo = GetProcessInfo(processId);
			if (processInfo is not null)
				yield return processInfo;
		}
	}

	public static ProcessInfo? GetProcessInfo(uint processId) {
		var modulesProvider = ModulesProviderFactory.Create(processId, ModulesProviderType.Unmanaged);
		var mainModule = modulesProvider.EnumerateModules().FirstOrDefault();
		if (mainModule is null)
			return null;
		// insufficient privileges

		var name = mainModule.Name;
		var path = mainModule.FilePath;
		var clrModules = modulesProvider.EnumerateModules().Where(t => t.Name.ToUpperInvariant() is "MSCORWKS.DLL" or "CLR.DLL" or "CORECLR.DLL").ToArray();
		if (clrModules.Length != 0)
			return new DotNetProcessInfo(processId, name, path, Is64BitPE(clrModules[0].FilePath), clrModules);
		else
			return new ProcessInfo(processId, name, path, Is64BitPE(mainModule.FilePath));
	}

	static bool Is64BitPE(string filePath) {
		return Is64BitPE(filePath, out bool is64Bit) && is64Bit;
	}

	static bool Is64BitPE(string filePath, out bool is64Bit) {
		try {
			using var stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
			using var reader = new BinaryReader(stream);
			reader.BaseStream.Position = 0x3C;
			uint peOffset = reader.ReadUInt32();
			reader.BaseStream.Position = peOffset + 0x18;
			ushort magic = reader.ReadUInt16();
			if (magic != 0x010B && magic != 0x020B)
				throw new InvalidDataException();
			is64Bit = magic == 0x020B;
			return true;
		}
		catch {
			is64Bit = false;
			return false;
		}
	}
}



================================================
File: ExtremeDumper/Diagnostics/IModulesProvider.cs
================================================
using System.Collections.Generic;

namespace ExtremeDumper.Diagnostics;

public interface IModulesProvider {
	IEnumerable<ModuleInfo> EnumerateModules();
}



================================================
File: ExtremeDumper/Diagnostics/IProcessesProvider.cs
================================================
using System.Collections.Generic;

namespace ExtremeDumper.Diagnostics;

public interface IProcessesProvider {
	IEnumerable<ProcessInfo> EnumerateProcesses();
}



================================================
File: ExtremeDumper/Diagnostics/ManagedModulesProvider.cs
================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using ExtremeDumper.Dumping;
using ExtremeDumper.Logging;
using Microsoft.Diagnostics.Runtime;
using Microsoft.Diagnostics.Runtime.Utilities;
using NativeSharp;

namespace ExtremeDumper.Diagnostics;

sealed unsafe class ManagedModulesProvider : IModulesProvider {
	readonly uint processId;

	public ManagedModulesProvider(uint processId) {
		this.processId = processId;
	}

	public IEnumerable<ModuleInfo> EnumerateModules() {
		using var process = NativeProcess.Open(processId);
		if (process.IsInvalid)
			throw new InvalidOperationException();
		using var dataTarget = DataTarget.AttachToProcess((int)processId, 1000, AttachFlag.Passive);
		dataTarget.SymbolLocator = DummySymbolLocator.Instance;
		foreach (var runtime in dataTarget.ClrVersions.Select(t => t.CreateRuntime())) {
			var clrVersion = runtime.ClrInfo.Version.ToString();
			foreach (var domain in runtime.AppDomains) {
				var domainName = domain.Name;
				foreach (var module in domain.Modules) {
					if (module.ImageBase == 0)
						continue;
					if (!IsValidPEMagic(module, process))
						continue;
					// .NET 3.5有nlp文件，但是被认为是.NET模块

					GetModuleFileInfo(module, out var name, out var path);
					uint size = GetModuleSize(module, process);
					yield return new DotNetModuleInfo(name, (nuint)module.ImageBase, size, path, domainName, clrVersion);
				}
			}
		}
	}

	static bool IsValidPEMagic(ClrModule module, NativeProcess process) {
		byte[] buffer = new byte[2];
		if (!process.TryReadBytes((void*)module.ImageBase, buffer))
			return false;

		return buffer[0] == 'M' && buffer[1] == 'Z';
	}

	static void GetModuleFileInfo(ClrModule module, out string name, out string path) {
		if (string.IsNullOrEmpty(module.Name)) {
			// In memory and obfuscated
			name = string.Empty;
			path = string.Empty;
		}
		else if (module.Name.Contains(",")) {
			// In memory, module.Name is reflection assembly name.
			name = module.Name.Split(',')[0];
			path = string.Empty;
		}
		else {
			// In disk
			name = Path.GetFileName(module.Name);
			path = module.Name;
		}
	}

	static uint GetModuleSize(ClrModule module, NativeProcess process) {
		uint size = (uint)module.Size;
		if (size != 0)
			return size;

		byte[] peHeader = new byte[0x1000];
		if (!process.TryReadBytes((void*)module.ImageBase, peHeader))
			return 0;

		try {
			return PEImageDumper.GetImageSize(peHeader, dnlib.PE.ImageLayout.Memory);
		}
		catch (Exception ex) {
			Logger.Error($"Can't get image size of module '{module.Name}' at {Formatter.FormatHex((nuint)module.ImageBase)}");
			Logger.Exception(ex);
			return 0;
		}
	}

	sealed class DummySymbolLocator : SymbolLocator {
		public static DummySymbolLocator Instance { get; } = new();
		private DummySymbolLocator() { }
		public override string FindBinary(string fileName, int buildTimeStamp, int imageSize, bool checkProperties = true) { return string.Empty; }
		public override Task<string> FindBinaryAsync(string fileName, int buildTimeStamp, int imageSize, bool checkProperties = true) { return Task.FromResult(string.Empty); }
		public override string FindPdb(string pdbName, Guid pdbIndexGuid, int pdbIndexAge) { return string.Empty; }
		public override Task<string> FindPdbAsync(string pdbName, Guid pdbIndexGuid, int pdbIndexAge) { return Task.FromResult(string.Empty); }
		protected override Task CopyStreamToFileAsync(Stream input, string fullSrcPath, string fullDestPath, long size) { throw new NotImplementedException(); }
	}
}



================================================
File: ExtremeDumper/Diagnostics/ModuleInfo.cs
================================================
namespace ExtremeDumper.Diagnostics;

public class ModuleInfo {
	public string Name { get; }

	public nuint ImageBase { get; }

	public uint ImageSize { get; }

	public string FilePath { get; }

	public ModuleInfo() {
		Name = string.Empty;
		FilePath = string.Empty;
	}

	public ModuleInfo(string name, nuint imageBase, uint imageSize, string filePath) {
		Name = name ?? string.Empty;
		ImageBase = imageBase;
		ImageSize = imageSize;
		FilePath = filePath ?? string.Empty;
	}
}

public sealed class DotNetModuleInfo : ModuleInfo {
	public string DomainName { get; }

	public string CLRVersion { get; }

	public bool InMemory => string.IsNullOrEmpty(FilePath);

	public DotNetModuleInfo() {
		DomainName = string.Empty;
		CLRVersion = string.Empty;
	}

	public DotNetModuleInfo(string name, nuint imageBase, uint imageSize, string filePath, string domainName, string clrVersion) : base(name, imageBase, imageSize, filePath) {
		DomainName = domainName ?? string.Empty;
		CLRVersion = clrVersion ?? string.Empty;
	}
}



================================================
File: ExtremeDumper/Diagnostics/ModulesProviderFactory.cs
================================================
using System;

namespace ExtremeDumper.Diagnostics;

/// <summary>
/// Module infos provider type
/// </summary>
public enum ModulesProviderType {
	Unmanaged,
	Managed,
	ManagedAAD
}

/// <summary>
/// Module infos provider factory
/// </summary>
public static class ModulesProviderFactory {
	/// <summary>
	/// Create
	/// </summary>
	/// <param name="processId"></param>
	/// <param name="type"></param>
	/// <returns></returns>
	/// <exception cref="ArgumentOutOfRangeException"></exception>
	public static IModulesProvider Create(uint processId, ModulesProviderType type) {
		switch (type) {
		case ModulesProviderType.Unmanaged:
			return new UnmanagedModulesProvider(processId);
		case ModulesProviderType.Managed:
			return new ManagedModulesProvider(processId);
		case ModulesProviderType.ManagedAAD:
			return new AADModulesProvider(processId);
		default:
			throw new ArgumentOutOfRangeException(nameof(type));
		}
	}
}



================================================
File: ExtremeDumper/Diagnostics/ProcessInfo.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;

namespace ExtremeDumper.Diagnostics;

public class ProcessInfo {
	public uint Id { get; }

	public string Name { get; }

	public string FilePath { get; }

	public bool Is64Bit { get; }

	public ProcessInfo() {
		Name = string.Empty;
		FilePath = string.Empty;
	}

	public ProcessInfo(uint id, string name, string filePath, bool is64Bit) {
		Id = id;
		Name = name ?? string.Empty;
		FilePath = filePath ?? string.Empty;
		Is64Bit = is64Bit;
	}
}

public sealed class DotNetProcessInfo : ProcessInfo {
	public IReadOnlyList<ModuleInfo> CLRModules { get; }

	public bool HasCLR2 => CLRModules.Any(t => string.Equals(t.Name, "mscorwks.dll", StringComparison.OrdinalIgnoreCase));

	public bool HasCLR4 => CLRModules.Any(t => string.Equals(t.Name, "clr.dll", StringComparison.OrdinalIgnoreCase));

	public bool HasCoreCLR => CLRModules.Any(t => string.Equals(t.Name, "coreclr.dll", StringComparison.OrdinalIgnoreCase));

	public DotNetProcessInfo() {
		CLRModules = Array2.Empty<ModuleInfo>();
	}

	public DotNetProcessInfo(uint id, string name, string filePath, bool is64Bit, IEnumerable<ModuleInfo> clrModules) : base(id, name, filePath, is64Bit) {
		CLRModules = new List<ModuleInfo>(clrModules);
	}
}



================================================
File: ExtremeDumper/Diagnostics/ProcessesProviderFactory.cs
================================================
namespace ExtremeDumper.Diagnostics;

/// <summary>
/// Process infos provider factory
/// </summary>
public static class ProcessesProviderFactory {
	/// <summary>
	/// Create
	/// </summary>
	/// <returns></returns>
	public static IProcessesProvider Create() {
		return new DefaultProcessesProvider();
	}
}



================================================
File: ExtremeDumper/Diagnostics/UnmanagedModulesProvider.cs
================================================
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace ExtremeDumper.Diagnostics;

sealed class UnmanagedModulesProvider : IModulesProvider {
	readonly uint processId;

	public UnmanagedModulesProvider(uint processId) {
		this.processId = processId;
	}

	public IEnumerable<ModuleInfo> EnumerateModules() {
		var snapshotHandle = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, processId);
		if (snapshotHandle == INVALID_HANDLE_VALUE)
			yield break;

		try {
			var moduleEntry = new MODULEENTRY32 { dwSize = (uint)Marshal.SizeOf(typeof(MODULEENTRY32)) };
			if (!Module32First(snapshotHandle, ref moduleEntry))
				yield break;

			do {
				yield return new ModuleInfo(moduleEntry.szModule, moduleEntry.modBaseAddr, moduleEntry.modBaseSize, moduleEntry.szExePath);
			} while (Module32Next(snapshotHandle, ref moduleEntry));
		}
		finally {
			CloseHandle(snapshotHandle);
		}
	}

	#region NativeMethods
	const uint TH32CS_SNAPMODULE = 0x00000008;
	const uint TH32CS_SNAPMODULE32 = 0x00000010;
	static readonly nuint INVALID_HANDLE_VALUE = unchecked((nuint)(-1));

	[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
	struct MODULEENTRY32 {
		public uint dwSize;
		public uint th32ModuleID;
		public uint th32ProcessID;
		public uint GlblcntUsage;
		public uint ProccntUsage;
		public nuint modBaseAddr;
		public uint modBaseSize;
		public nuint hModule;
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
		public string szModule;
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
		public string szExePath;
	}

	[DllImport("kernel32.dll", SetLastError = true)]
	static extern bool CloseHandle(nuint hObject);

	[DllImport("kernel32.dll", SetLastError = true)]
	static extern nuint CreateToolhelp32Snapshot(uint dwFlags, uint th32ProcessID);

	[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, SetLastError = true)]
	static extern bool Module32First(nuint hSnapshot, ref MODULEENTRY32 lpme);

	[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, SetLastError = true)]
	static extern bool Module32Next(nuint hSnapshot, ref MODULEENTRY32 lppe);
	#endregion
}



================================================
File: ExtremeDumper/Dumping/AntiAntiDumper.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Text;
using dnlib.DotNet;
using dnlib.IO;
using dnlib.PE;
using ExtremeDumper.AntiAntiDump;

namespace ExtremeDumper.Dumping;

sealed class AntiAntiDumper : DumperBase {
	#region .NET Structures
#pragma warning disable CS0649
	struct IMAGE_DATA_DIRECTORY {
		public uint VirtualAddress;
		public uint Size;
	}

	struct IMAGE_SECTION_HEADER {
		public unsafe fixed byte Name[8];
		public uint VirtualSize;
		public uint VirtualAddress;
		public uint SizeOfRawData;
		public uint PointerToRawData;
		public uint PointerToRelocations;
		public uint PointerToLinenumbers;
		public ushort NumberOfRelocations;
		public ushort NumberOfLinenumbers;
		public uint Characteristics;
	}

	struct IMAGE_COR20_HEADER {
		public uint cb;
		public ushort MajorRuntimeVersion;
		public ushort MinorRuntimeVersion;
		public IMAGE_DATA_DIRECTORY MetaData;
		public uint Flags;
		public uint EntryPointTokenOrRVA;
		public IMAGE_DATA_DIRECTORY Resources;
		public IMAGE_DATA_DIRECTORY StrongNameSignature;
		public IMAGE_DATA_DIRECTORY CodeManagerTable;
		public IMAGE_DATA_DIRECTORY VTableFixups;
		public IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
		public IMAGE_DATA_DIRECTORY ManagedNativeHeader;
	}

	struct STORAGESIGNATURE {
		public uint lSignature;
		public ushort iMajorVer;
		public ushort iMinorVer;
		public uint iExtraData;
		public uint iVersionString;
		public unsafe fixed byte pVersion[1];
	}

	struct STORAGEHEADER {
		public byte fFlags;
		public byte pad;
		public ushort iStreams;
	}
#pragma warning restore CS0649
	#endregion

	public AntiAntiDumper(uint processId) : base(processId) {
	}

	public override bool DumpModule(nuint moduleHandle, ImageLayout __imageLayout_dont_use, string filePath) {
		var clients = AADExtensions.EnumerateAADClients(process.Id);
		if (!FindModule(clients, moduleHandle, out var client, out var module))
			return false;

		var peInfo = client.GetPEInfo(module);
		var metadataInfo = client.GetMetadataInfo(module);
		var imageLayout = FindMetadataImageLayout(peInfo, metadataInfo.MetadataAddress);
		if (imageLayout is null)
			throw new InvalidOperationException("Can't find the PEImageLayout where the metadata is located");

		moduleHandle = (nuint)imageLayout.ImageBase;
		var data = DumpModule(process.Id, moduleHandle, peInfo.InMemory);
		if (data is null)
			throw new InvalidOperationException("Can't dump module");

		AddressToRVA(metadataInfo, imageLayout);
		if (peInfo.InMemory)
			FileLayoutToMemoryLayout(ref data, metadataInfo, imageLayout);
		FixSectionHeaders(data);
		FixDotNetHeaders(data, metadataInfo, imageLayout);

		File.WriteAllBytes(filePath, data);
		return true;
	}

	static bool FindModule(IEnumerable<AADClient> clients, nuint moduleHandle, [NotNullWhen(true)] out AADClient? client, [NotNullWhen(true)] out ModuleInfo? module) {
		foreach (var client2 in clients) {
			foreach (var module2 in client2.EnumerateModules()) {
				var peInfo = client2.GetPEInfo(module2);
				if (peInfo.FlatLayout.ImageBase == moduleHandle ||
					peInfo.MappedLayout.ImageBase == moduleHandle ||
					peInfo.LoadedLayout.ImageBase == moduleHandle) {
					client = client2;
					module = module2;
					return true;
				}
			}
		}
		client = null;
		module = null;
		return false;
	}

	static PEImageLayout? FindMetadataImageLayout(PEInfo peInfo, ulong metadataAddress) {
		if (Check(peInfo.FlatLayout, metadataAddress))
			return peInfo.FlatLayout;
		if (Check(peInfo.MappedLayout, metadataAddress))
			return peInfo.MappedLayout;
		if (Check(peInfo.LoadedLayout, metadataAddress))
			return peInfo.LoadedLayout;
		return null;

		static bool Check(PEImageLayout imageLayout, ulong metadataAddress) {
			if (imageLayout.IsInvalid)
				return false;
			return imageLayout.ImageBase <= metadataAddress && metadataAddress < imageLayout.ImageBase + imageLayout.ImageSize;
		}
	}

	static byte[]? DumpModule(uint processId, nuint moduleHandle, bool inMemory) {
		var imageLayout = inMemory ? ImageLayout.File : ImageLayout.Memory;
		var imageLayoutOld = imageLayout;
		var data = PEImageDumper.Dump(processId, moduleHandle, ref imageLayout);
		if (data is null)
			return null;
		Debug2.Assert(imageLayoutOld == imageLayout);
		return data;
	}

	static void AddressToRVA(MetadataInfo metadataInfo, PEImageLayout imageLayout) {
		metadataInfo.MetadataAddress -= imageLayout.ImageBase;
		if (!metadataInfo.TableStream.IsInvalid)
			metadataInfo.TableStream.Address -= imageLayout.ImageBase;
		if (!metadataInfo.StringHeap.IsInvalid)
			metadataInfo.StringHeap.Address -= imageLayout.ImageBase;
		if (!metadataInfo.UserStringHeap.IsInvalid)
			metadataInfo.UserStringHeap.Address -= imageLayout.ImageBase;
		if (!metadataInfo.GuidHeap.IsInvalid)
			metadataInfo.GuidHeap.Address -= imageLayout.ImageBase;
		if (!metadataInfo.BlobHeap.IsInvalid)
			metadataInfo.BlobHeap.Address -= imageLayout.ImageBase;
		imageLayout.CorHeaderAddress -= imageLayout.ImageBase;
	}

	static void FileLayoutToMemoryLayout(ref byte[] data, MetadataInfo metadataInfo, PEImageLayout imageLayout) {
		data = PEImageDumper.ConvertImageLayout(data, ImageLayout.File, ImageLayout.Memory);
		using var peHeader = new PEImage(data, ImageLayout.File, false);
		// 用于转换RVA与FOA，必须指定imageLayout参数为ImageLayout.File
		metadataInfo.MetadataAddress = (uint)peHeader.ToRVA((FileOffset)metadataInfo.MetadataAddress);
		if (!metadataInfo.TableStream.IsInvalid)
			metadataInfo.TableStream.Address = (uint)peHeader.ToRVA((FileOffset)metadataInfo.TableStream.Address);
		if (!metadataInfo.StringHeap.IsInvalid)
			metadataInfo.StringHeap.Address = (uint)peHeader.ToRVA((FileOffset)metadataInfo.StringHeap.Address);
		if (!metadataInfo.UserStringHeap.IsInvalid)
			metadataInfo.UserStringHeap.Address = (uint)peHeader.ToRVA((FileOffset)metadataInfo.UserStringHeap.Address);
		if (!metadataInfo.GuidHeap.IsInvalid)
			metadataInfo.GuidHeap.Address = (uint)peHeader.ToRVA((FileOffset)metadataInfo.GuidHeap.Address);
		if (!metadataInfo.BlobHeap.IsInvalid)
			metadataInfo.BlobHeap.Address = (uint)peHeader.ToRVA((FileOffset)metadataInfo.BlobHeap.Address);
		imageLayout.CorHeaderAddress = (uint)peHeader.ToRVA((FileOffset)imageLayout.CorHeaderAddress);
	}

	static unsafe void FixSectionHeaders(byte[] data) {
		using var peHeader = new PEImage(data, ImageLayout.Memory, false);
		fixed (byte* p = data) {
			var pOptionalHeader = p + (uint)peHeader.ImageNTHeaders.OptionalHeader.StartOffset;
			*(uint*)(pOptionalHeader + 0x24) = *(uint*)(pOptionalHeader + 0x20);
			uint alignmentMask = *(uint*)(pOptionalHeader + 0x24) - 1;
			foreach (var sectionHeader in peHeader.ImageSectionHeaders) {
				var pSectionHeader = (IMAGE_SECTION_HEADER*)(p + (uint)sectionHeader.StartOffset);
				pSectionHeader->PointerToRawData = pSectionHeader->VirtualAddress;
				pSectionHeader->SizeOfRawData = (pSectionHeader->VirtualSize + alignmentMask) & ~alignmentMask;
			}
		}
	}

	static unsafe void FixDotNetHeaders(byte[] data, MetadataInfo metadataInfo, PEImageLayout imageLayout) {
		fixed (byte* p = data) {
			var pNETDirectory = (IMAGE_DATA_DIRECTORY*)(p + GetDotNetDirectoryRVA(data));
			pNETDirectory->VirtualAddress = (uint)imageLayout.CorHeaderAddress;
			pNETDirectory->Size = (uint)sizeof(IMAGE_COR20_HEADER);
			// Set Data Directories
			var pCor20Header = (IMAGE_COR20_HEADER*)(p + (uint)imageLayout.CorHeaderAddress);
			pCor20Header->cb = (uint)sizeof(IMAGE_COR20_HEADER);
			pCor20Header->MajorRuntimeVersion = 0x2;
			pCor20Header->MinorRuntimeVersion = 0x5;
			pCor20Header->MetaData.VirtualAddress = (uint)metadataInfo.MetadataAddress;
			pCor20Header->MetaData.Size = GetMetadataSize(metadataInfo);
			// Set .NET Directory
			var pStorageSignature = (STORAGESIGNATURE*)(p + (uint)metadataInfo.MetadataAddress);
			pStorageSignature->lSignature = 0x424A5342;
			pStorageSignature->iMajorVer = 0x1;
			pStorageSignature->iMinorVer = 0x1;
			pStorageSignature->iExtraData = 0x0;
			pStorageSignature->iVersionString = 0xC;
			var versionString = Encoding.ASCII.GetBytes("v4.0.30319");
			for (int i = 0; i < versionString.Length; i++)
				pStorageSignature->pVersion[i] = versionString[i];
			// versionString仅仅占位用，程序集具体运行时版本用dnlib获取
			// Set StorageSignature
			var pStorageHeader = (STORAGEHEADER*)((byte*)pStorageSignature + 0x10 + pStorageSignature->iVersionString);
			pStorageHeader->fFlags = 0x0;
			pStorageHeader->pad = 0x0;
			pStorageHeader->iStreams = 0x5;
			// Set StorageHeader
			var pStreamHeader = (uint*)((byte*)pStorageHeader + sizeof(STORAGEHEADER));
			var tableStream = metadataInfo.TableStream;
			if (!tableStream.IsInvalid) {
				*pStreamHeader = (uint)tableStream.Address;
				*pStreamHeader -= (uint)metadataInfo.MetadataAddress;
				pStreamHeader++;
				*pStreamHeader = tableStream.Length;
				pStreamHeader++;
				*pStreamHeader = tableStream.IsCompressed ? 0x00007E23u : 0x000002D23;
				pStreamHeader++;
			}
			// Set #~ or #-
			var stringHeap = metadataInfo.StringHeap;
			if (!stringHeap.IsInvalid) {
				*pStreamHeader = (uint)stringHeap.Address;
				*pStreamHeader -= (uint)metadataInfo.MetadataAddress;
				pStreamHeader++;
				*pStreamHeader = stringHeap.Length;
				pStreamHeader++;
				*pStreamHeader = 0x72745323;
				pStreamHeader++;
				*pStreamHeader = 0x73676E69;
				pStreamHeader++;
				*pStreamHeader = 0x00000000;
				pStreamHeader++;
			}
			// Set #Strings
			var userStringHeap = metadataInfo.UserStringHeap;
			if (!userStringHeap.IsInvalid) {
				*pStreamHeader = (uint)userStringHeap.Address;
				*pStreamHeader -= (uint)metadataInfo.MetadataAddress;
				pStreamHeader++;
				*pStreamHeader = userStringHeap.Length;
				pStreamHeader++;
				*pStreamHeader = 0x00535523;
				pStreamHeader++;
			}
			// Set #US
			var guidHeap = metadataInfo.GuidHeap;
			if (!guidHeap.IsInvalid) {
				*pStreamHeader = (uint)guidHeap.Address;
				*pStreamHeader -= (uint)metadataInfo.MetadataAddress;
				pStreamHeader++;
				*pStreamHeader = guidHeap.Length;
				pStreamHeader++;
				*pStreamHeader = 0x49554723;
				pStreamHeader++;
				*pStreamHeader = 0x00000044;
				pStreamHeader++;
			}
			// Set #GUID
			var blobHeap = metadataInfo.BlobHeap;
			if (!blobHeap.IsInvalid) {
				*pStreamHeader = (uint)blobHeap.Address;
				*pStreamHeader -= (uint)metadataInfo.MetadataAddress;
				pStreamHeader++;
				*pStreamHeader = blobHeap.Length;
				pStreamHeader++;
				*pStreamHeader = 0x6F6C4223;
				pStreamHeader++;
				*pStreamHeader = 0x00000062;
				pStreamHeader++;
			}
			// Set #GUID
			switch (GetCorLibVersion(data).Major) {
			case 2:
				versionString = Encoding.ASCII.GetBytes("v2.0.50727");
				break;
			case 4:
				versionString = Encoding.ASCII.GetBytes("v4.0.30319");
				break;
			default:
				throw new NotSupportedException();
			}
			for (int i = 0; i < versionString.Length; i++)
				pStorageSignature->pVersion[i] = versionString[i];
			// Re set Version
		}
	}

	static uint GetDotNetDirectoryRVA(byte[] data) {
		using var peHeader = new PEImage(data, false);
		return (uint)peHeader.ImageNTHeaders.OptionalHeader.DataDirectories[14].StartOffset;
	}

	static uint GetMetadataSize(MetadataInfo metadataInfo) {
		if (metadataInfo.TableStream.IsCompressed)
			return metadataInfo.MetadataSize;

		var last = (MetadataStreamInfo)metadataInfo.BlobHeap;
		if (metadataInfo.GuidHeap.Address > last.Address)
			last = metadataInfo.GuidHeap;
		if (metadataInfo.UserStringHeap.Address > last.Address)
			last = metadataInfo.UserStringHeap;
		if (metadataInfo.StringHeap.Address > last.Address)
			last = metadataInfo.StringHeap;
		if (metadataInfo.TableStream.Address > last.Address)
			last = metadataInfo.TableStream;
		uint end = (uint)last.Address + last.Length;
		return end - (uint)metadataInfo.MetadataAddress;
	}

	static Version GetCorLibVersion(byte[] data) {
		using var module = ModuleDefMD.Load(new PEImage(data, ImageLayout.Memory, false));
		return module.CorLibTypes.AssemblyRef.Version;
	}

	public override int DumpProcess(string directoryPath) {
		throw new NotSupportedException();
	}
}



================================================
File: ExtremeDumper/Dumping/BuiltInAssemblyHelper.cs
================================================
using System;
using System.Collections.Generic;
using dnlib.DotNet;

namespace ExtremeDumper.Dumping;

static class BuiltInAssemblyHelper {
	public static HashSet<string> FullNames { get; } = new(StringComparer.OrdinalIgnoreCase) {
		"Accessibility, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Accessibility, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"AddInProcess, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"AddInProcess32, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"AddInUtil, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"ComSvcConfig, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"CustomMarshalers, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"CustomMarshalers, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"DataSvcUtil, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"EdmGen, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"ISymWrapper, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"ISymWrapper, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Activities.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Conversion.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Conversion.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Engine, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Engine, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Framework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Framework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Utilities.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Build.Utilities.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.CSharp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Data.Entity.Build.Tasks, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.JScript, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.JScript, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Transactions.Bridge, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Transactions.Bridge.Dtc, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.VisualBasic, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.VisualBasic, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.VisualBasic.Compatibility, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.VisualBasic.Compatibility.Data, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.VisualC, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.VisualC, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.VisualC.STLCLR, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.VisualC.STLCLR, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Vsa, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"Microsoft.Win32.Primitives, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"MSBuild, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51",
		"PresentationBuildTasks, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationBuildTasks, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationCFFRasterizer, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Aero, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Aero, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Aero2, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.AeroLite, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Classic, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Classic, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Luna, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Luna, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Royale, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationFramework.Royale, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"PresentationUI, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"ReachFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"ReachFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"Sentinel.v3.5Client, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"ServiceModelReg, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"SMSvcHost, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"sysglobl, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Activities, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Activities.Core.Presentation, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Activities.DurableInstancing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Activities.Presentation, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Activities.Statements, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.AddIn, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.AddIn, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.AddIn.Contract, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.AddIn.Contract, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.AppContext, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Collections, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Collections, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Collections, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Collections.Concurrent, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Collections.Concurrent, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Collections.Concurrent, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Collections.NonGeneric, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Collections.Specialized, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel.Annotations, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel.Annotations, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel.Composition, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.ComponentModel.Composition.Registration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.ComponentModel.DataAnnotations, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ComponentModel.DataAnnotations, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ComponentModel.EventBasedAsync, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel.EventBasedAsync, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel.EventBasedAsync, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel.Primitives, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ComponentModel.TypeConverter, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Configuration, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Console, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Common, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Data.Common, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Data.DataSetExtensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.DataSetExtensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Entity, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Entity.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Entity.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.OracleClient, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Services, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Services.Client, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Services.Client, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Services.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.Services.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.SqlXml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Data.SqlXml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Deployment, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Deployment, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Device, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Diagnostics.Contracts, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Contracts, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Debug, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Debug, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Debug, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.FileVersionInfo, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Process, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.StackTrace, Version=4.0.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.StackTrace, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.TextWriterTraceListener, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Tools, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Tools, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.TraceSource, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Tracing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Tracing, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Tracing, Version=4.0.20.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Tracing, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Diagnostics.Tracing, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.DirectoryServices.AccountManagement, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.DirectoryServices.AccountManagement, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.DirectoryServices.Protocols, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Drawing.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Dynamic, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Dynamic.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Dynamic.Runtime, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Dynamic.Runtime, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.EnterpriseServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.EnterpriseServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Globalization, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Globalization, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Globalization, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Globalization.Calendars, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Globalization.Extensions, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Globalization.Extensions, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IdentityModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IdentityModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IdentityModel.Selectors, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IdentityModel.Selectors, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IO, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IO.Compression, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IO.Compression.ZipFile, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.IO.FileSystem, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.FileSystem.DriveInfo, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.FileSystem.Primitives, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.FileSystem.Watcher, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.IsolatedStorage, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.Log, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.Log, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.MemoryMappedFiles, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.Pipes, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.IO.UnmanagedMemoryStream, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq.Expressions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq.Expressions, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq.Expressions, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq.Parallel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq.Parallel, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq.Queryable, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Linq.Queryable, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Management, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Management, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Management.Instrumentation, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Management.Instrumentation, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Messaging, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Http, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Http.Rtc, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Http.WebRequest, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.NameResolution, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.NetworkInformation, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.NetworkInformation, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.NetworkInformation, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Ping, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Primitives, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Primitives, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Primitives, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Requests, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Requests, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Requests, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Security, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Sockets, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.Sockets, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.WebHeaderCollection, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.WebHeaderCollection, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.WebSockets, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Net.WebSockets.Client, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Numerics.Vectors, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ObjectModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ObjectModel, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ObjectModel, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Printing, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Printing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Reflection, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection.Context, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Reflection.Emit, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection.Emit.ILGeneration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection.Emit.Lightweight, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection.Extensions, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection.Primitives, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Reflection.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Resources.Reader, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Resources.ResourceManager, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Resources.ResourceManager, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Resources.Writer, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime, Version=4.0.20.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Caching, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.CompilerServices.VisualC, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.DurableInstancing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Runtime.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Extensions, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Extensions, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Handles, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Handles, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.InteropServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.InteropServices, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.InteropServices, Version=4.0.20.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.InteropServices, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.InteropServices.RuntimeInformation, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.InteropServices.WindowsRuntime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Numerics, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Numerics, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Remoting, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Runtime.Remoting, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Runtime.Serialization, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Runtime.Serialization, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Runtime.Serialization.Formatters, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Formatters.Soap, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Formatters.Soap, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Json, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Json, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Primitives, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Primitives, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Primitives, Version=4.1.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Primitives, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Xml, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.Serialization.Xml, Version=4.1.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Runtime.WindowsRuntime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Runtime.WindowsRuntime.UI.Xaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Security, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Claims, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Cryptography.Algorithms, Version=4.2.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Cryptography.Algorithms, Version=4.3.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Cryptography.Csp, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Cryptography.Encoding, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Cryptography.Primitives, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Cryptography.X509Certificates, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Principal, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.Principal, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.SecureString, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Security.SecureString, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.ServiceModel.Activation, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ServiceModel.Activities, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ServiceModel.Channels, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ServiceModel.Discovery, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ServiceModel.Duplex, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ServiceModel.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ServiceModel.Http, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ServiceModel.Install, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.ServiceModel.NetTcp, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ServiceModel.Primitives, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ServiceModel.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ServiceModel.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ServiceModel.WasHosting, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ServiceModel.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Speech, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Speech, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Text.Encoding, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Text.Encoding, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Text.Encoding, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Text.Encoding.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Text.Encoding.Extensions, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Text.Encoding.Extensions, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Text.RegularExpressions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Text.RegularExpressions, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Text.RegularExpressions, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Overlapped, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Overlapped, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Tasks, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Tasks, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Tasks, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Tasks.Parallel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Tasks.Parallel, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Thread, Version=4.0.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.ThreadPool, Version=4.0.12.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Timer, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Threading.Timer, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Transactions, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Transactions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.ValueTuple, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51",
		"System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Web.Abstractions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.Abstractions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.ApplicationServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.DataVisualization, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.DataVisualization.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.DynamicData, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.DynamicData, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.DynamicData.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.DynamicData.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.Entity, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Web.Entity, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Web.Entity.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Web.Entity.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.Mobile, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Web.RegularExpressions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Web.Routing, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.Routing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Web.Services, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Web.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Windows, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Windows.Controls.Ribbon, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Windows.Forms.DataVisualization, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Windows.Forms.DataVisualization.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Windows.Input.Manipulations, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Windows.Presentation, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Windows.Presentation, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Workflow.Activities, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Workflow.Activities, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Workflow.ComponentModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Workflow.ComponentModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Workflow.Runtime, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Workflow.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.WorkflowServices, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.WorkflowServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"System.Xaml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Xml.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Xml.Linq, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Xml.ReaderWriter, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.ReaderWriter, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.ReaderWriter, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.Serialization, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
		"System.Xml.XDocument, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XDocument, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XDocument, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XmlDocument, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XmlSerializer, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XmlSerializer, Version=4.0.10.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XmlSerializer, Version=4.0.11.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XPath, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XPath.XDocument, Version=4.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"System.Xml.XPath.XDocument, Version=4.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"UIAutomationClient, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"UIAutomationClient, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"UIAutomationClientsideProviders, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"UIAutomationClientsideProviders, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"UIAutomationProvider, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"UIAutomationProvider, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"UIAutomationTypes, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"UIAutomationTypes, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"WindowsBase, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"WindowsFormsIntegration, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"WindowsFormsIntegration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
		"WsatConfig, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
		"XamlBuildTask, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
	};

	public static bool IsBuiltInAssembly(byte[] data) {
		if (data is null)
			return false;

		using var module = ModuleDefMD.Load(data);
		return IsBuiltInAssembly(module.Assembly);
	}

	public static bool IsBuiltInAssembly(IAssembly assembly) {
		if (assembly is null)
			return false;

		string name = assembly.Name;
		if (name.EndsWith(".resources", StringComparison.Ordinal))
			name = name.Substring(0, name.Length - 10);
		string fullName = $"{name}, Version={assembly.Version}, Culture=neutral, PublicKeyToken={assembly.PublicKeyOrToken.Token}";
		// ignore neutral for built assembly. if it is resource assembly, 'Culture' is not 'neutral'.
		return FullNames.Contains(fullName);
	}
}



================================================
File: ExtremeDumper/Dumping/DumperBase.cs
================================================
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Text;
using dnlib.PE;
using NativeSharp;

namespace ExtremeDumper.Dumping;

abstract class DumperBase : IDumper {
	static readonly char[] InvalidFileNameChars = Path.GetInvalidFileNameChars();

	protected readonly NativeProcess process;

	protected DumperBase(uint processId) {
		process = NativeProcess.Open(processId, ProcessAccess.MemoryRead | ProcessAccess.QueryInformation);
	}

	public abstract bool DumpModule(nuint moduleHandle, ImageLayout imageLayout, string filePath);

	public abstract int DumpProcess(string directoryPath);

	protected static string EnsureValidFileName(string fileName) {
		if (string.IsNullOrEmpty(fileName))
			return string.Empty;

		var newFileName = new StringBuilder(fileName.Length);
		foreach (char chr in fileName) {
			if (!InvalidFileNameChars.Contains(chr))
				newFileName.Append(chr);
		}
		return newFileName.ToString();
	}

	protected static bool IsSameFile(string directoryPath, string fileName, byte[] data, ConcurrentDictionary<string, byte[]> originalFileCache) {
		string filePath = Path.Combine(directoryPath, fileName);
		if (!File.Exists(filePath)) {
			originalFileCache[fileName] = data;
			return false;
		}

		if (!originalFileCache.TryGetValue(fileName, out byte[] originalData)) {
			originalData = File.ReadAllBytes(filePath);
			originalFileCache.TryAdd(fileName, originalData);
		}

		if (data.Length != originalData.Length)
			return false;

		for (int i = 0; i < data.Length; i++) {
			if (data[i] != originalData[i])
				return false;
		}

		return true;
	}

	protected static string EnsureNoRepeatFileName(string directoryPath, string fileName) {
		int count = 1;
		string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
		string extension = Path.GetExtension(fileName);
		string filePath;
		while (File.Exists(filePath = Path.Combine(directoryPath, fileName))) {
			count++;
			fileName = $"{fileNameWithoutExtension} ({count}){extension}";
		}
		return fileName;
	}

	public virtual void Dispose() {
		process.Dispose();
	}
}



================================================
File: ExtremeDumper/Dumping/DumperFactory.cs
================================================
using System;

namespace ExtremeDumper.Dumping;

public enum DumperType {
	Normal,
	AntiAntiDump
}

public static class DumperFactory {
	public static IDumper Create(uint processId, DumperType dumperType) {
		switch (dumperType) {
		case DumperType.Normal:
			return new NormalDumper(processId);
		case DumperType.AntiAntiDump:
			return new AntiAntiDumper(processId);
		default:
			throw new ArgumentOutOfRangeException(nameof(dumperType));
		}
	}
}



================================================
File: ExtremeDumper/Dumping/IDumper.cs
================================================
using System;
using dnlib.PE;

namespace ExtremeDumper.Dumping;

/// <summary>
/// 转储器的接口类
/// </summary>
public interface IDumper : IDisposable {
	/// <summary>
	/// 转储指定模块
	/// </summary>
	/// <param name="moduleHandle">模块句柄</param>
	/// <param name="imageLayout">程序集在内存中的格式</param>
	/// <param name="filePath">将转储文件保存到指定路径</param>
	/// <returns></returns>
	bool DumpModule(nuint moduleHandle, ImageLayout imageLayout, string filePath);

	/// <summary>
	/// 转储指定进程，返回转储文件数
	/// </summary>
	/// <param name="directoryPath">转储的文件保存到指定文件夹下</param>
	/// <returns></returns>
	int DumpProcess(string directoryPath);
}



================================================
File: ExtremeDumper/Dumping/NormalDumper.cs
================================================
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Runtime.ExceptionServices;
using System.Threading.Tasks;
using dnlib.DotNet;
using dnlib.PE;
using ExtremeDumper.Logging;
using NativeSharp;

namespace ExtremeDumper.Dumping;

sealed unsafe class NormalDumper : DumperBase {
	public NormalDumper(uint processId) : base(processId) {
	}

	[HandleProcessCorruptedStateExceptions]
	public override bool DumpModule(nuint moduleHandle, ImageLayout imageLayout, string filePath) {
		try {
			var peImage = PEImageDumper.Dump(process, moduleHandle, ref imageLayout);
			if (peImage is null)
				return false;

			peImage = PEImageDumper.ConvertImageLayout(peImage, imageLayout, ImageLayout.File);
			File.WriteAllBytes(filePath, peImage);
			return true;
		}
		catch (Exception ex) {
			Logger.Exception(ex);
			return false;
		}
	}

	public override int DumpProcess(string directoryPath) {
		int count = 0;
		var originalFileCache = new ConcurrentDictionary<string, byte[]>(StringComparer.OrdinalIgnoreCase);
		Parallel.ForEach(process.EnumeratePageInfos(), pageInfo => {
			if (!IsValidPage(pageInfo))
				return;
			var page = new byte[Math.Min((int)pageInfo.Size, 0x40000000)];
			// 0x40000000 bytes = 1 giga bytes
			if (!process.TryReadBytes(pageInfo.Address, page))
				return;

			for (int i = 0; i < page.Length - 0x200; i++) {
				fixed (byte* p = page) {
					if (!MaybePEImage(p + i, page.Length - i))
						continue;
				}

				var imageLayout = i == 0 ? GetProbableImageLayout(page) : ImageLayout.File;
				nuint address = (nuint)pageInfo.Address + (uint)i;
				var peImage = DumpDotNetModule(process, address, imageLayout, out var fileName);
				if (peImage is null && i == 0) {
					// 也许判断有误，尝试一下另一种格式。如果不是页面起始位置，必须是文件布局。
					imageLayout = imageLayout == ImageLayout.File ? ImageLayout.Memory : ImageLayout.File;
					peImage = DumpDotNetModule(process, address, ImageLayout.File, out fileName);
				}

				if (peImage is null)
					continue;

				try {
					if (BuiltInAssemblyHelper.IsBuiltInAssembly(peImage))
						continue;
				}
				catch {
					continue;
				}

				Logger.Info($"Found assembly '{fileName}' at {Formatter.FormatHex(address)} and image layout is {imageLayout}");

				fileName = EnsureValidFileName(fileName);
				if (IsSameFile(directoryPath, fileName, peImage, originalFileCache))
					continue;

				fileName = EnsureNoRepeatFileName(directoryPath, fileName);
				var filePath = Path.Combine(directoryPath, fileName);
				File.WriteAllBytes(filePath, peImage);
				count++;
			}
		});
		GC.Collect();
		return count;
	}

	static bool IsValidPage(PageInfo pageInfo) {
		return pageInfo.Protection != 0 && (pageInfo.Protection & MemoryProtection.NoAccess) == 0 && (ulong)pageInfo.Size <= int.MaxValue;
	}

	[HandleProcessCorruptedStateExceptions]
	static bool MaybePEImage(byte* p, int size) {
		try {
			byte* pEnd = p + size;

			if (*(ushort*)p != 0x5A4D)
				return false;

			ushort ntHeadersOffset = *(ushort*)(p + 0x3C);
			p += ntHeadersOffset;
			if (p > pEnd - 4)
				return false;
			if (*(uint*)p != 0x00004550)
				return false;
			p += 0x04;
			// NT headers Signature

			if (p + 0x10 > pEnd - 2)
				return false;
			if (*(ushort*)(p + 0x10) == 0)
				return false;
			p += 0x14;
			// File header SizeOfOptionalHeader

			if (p > pEnd - 2)
				return false;
			if (*(ushort*)p != 0x010B && *(ushort*)p != 0x020B)
				return false;
			// Optional header Magic

			return true;
		}
		catch {
			return false;
		}
	}

	[HandleProcessCorruptedStateExceptions]
	static ImageLayout GetProbableImageLayout(byte[] firstPage) {
		try {
			uint imageSize = PEImageDumper.GetImageSize(firstPage, ImageLayout.File);
			// 获取文件格式大小
			var imageLayout = imageSize >= (uint)firstPage.Length ? ImageLayout.Memory : ImageLayout.File;
			// 如果文件格式大小大于页面大小，说明在内存中是内存格式的，反之为文件格式
			// 这种判断不准确，如果文件文件大小小于最小页面大小，判断会出错
			return imageLayout;
		}
		catch {
			return ImageLayout.Memory;
		}
	}

	[HandleProcessCorruptedStateExceptions]
	static byte[]? DumpDotNetModule(NativeProcess process, nuint address, ImageLayout imageLayout, out string fileName) {
		fileName = string.Empty;
		try {
			var data = PEImageDumper.Dump(process, address, ref imageLayout);
			if (data is null)
				return null;

			data = PEImageDumper.ConvertImageLayout(data, imageLayout, ImageLayout.File);
			using var peImage = new PEImage(data, true);
			// 确保为有效PE文件
			if (peImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].VirtualAddress == 0)
				return null;
			try {
				using var moduleDef = ModuleDefMD.Load(peImage);
				// 再次验证是否为.NET程序集
				if (moduleDef is null)
					return null;
				if (moduleDef.Assembly is not null ? moduleDef.Assembly.Name.Length == 0 : moduleDef.Name.Length == 0)
					return null;
				if (string.IsNullOrEmpty(fileName))
					fileName = moduleDef.Assembly is not null ? (moduleDef.Assembly.Name + (moduleDef.EntryPoint is null ? ".dll" : ".exe")) : moduleDef.Name;
			}
			catch {
				return null;
			}
			if (string.IsNullOrEmpty(fileName))
				fileName = Formatter.FormatHex(address);
			return data;
		}
		catch {
			return null;
		}
	}
}



================================================
File: ExtremeDumper/Dumping/PEImageDumper.cs
================================================
using System;
using System.Linq;
using dnlib.PE;
using NativeSharp;

namespace ExtremeDumper.Dumping;

static unsafe class PEImageDumper {
	/// <summary>
	/// 直接从内存中复制模块，不执行格式转换操作
	/// </summary>
	/// <param name="processId"></param>
	/// <param name="address"></param>
	/// <param name="imageLayout"></param>
	/// <returns></returns>
	public static byte[]? Dump(uint processId, nuint address, ref ImageLayout imageLayout) {
		if (processId == 0)
			throw new ArgumentNullException(nameof(processId));
		if (address == 0)
			throw new ArgumentNullException(nameof(address));

		using var process = NativeProcess.Open(processId);
		return Dump(process, address, ref imageLayout);
	}

	/// <summary>
	/// 直接从内存中复制模块，不执行格式转换操作
	/// </summary>
	/// <param name="process"></param>
	/// <param name="address"></param>
	/// <param name="imageLayout"></param>
	/// <returns></returns>
	public static byte[]? Dump(NativeProcess process, nuint address, ref ImageLayout imageLayout) {
		var pageInfos = process.EnumeratePageInfos((void*)address, (void*)address).ToArray();
		if (pageInfos.Length == 0)
			return null;

		var firstPageInfo = pageInfos[0];
		if (!IsValidPage(firstPageInfo))
			return null;
		// 判断内存页是否有效

		bool atPageHeader = address == (nuint)firstPageInfo.Address;
		if (!atPageHeader)
			imageLayout = ImageLayout.File;
		// 如果不在内存页头部，只可能是文件布局

		var peHeader = new byte[(int)((byte*)firstPageInfo.Address + (int)firstPageInfo.Size - (byte*)address)];
		process.ReadBytes((void*)address, peHeader);
		uint imageSize = GetImageSize(peHeader, imageLayout);
		// 获取模块在内存中的大小

		var peImage = new byte[imageSize];
		switch (imageLayout) {
		case ImageLayout.File:
			if (!process.TryReadBytes((void*)address, peImage, 0, imageSize))
				return null;
			break;
		case ImageLayout.Memory:
			pageInfos = process.EnumeratePageInfos((void*)address, (byte*)address + imageSize).Where(t => IsValidPage(t)).ToArray();
			if (pageInfos.Length == 0)
				return null;

			foreach (var pageInfo in pageInfos) {
				uint offset = (uint)((ulong)pageInfo.Address - address);
				if (!process.TryReadBytes(pageInfo.Address, peImage, offset, (uint)pageInfo.Size))
					return null;
			}
			break;
		default:
			throw new NotSupportedException();
		}
		// 转储

		return peImage;
	}

	static bool IsValidPage(PageInfo pageInfo) {
		return pageInfo.Protection != 0 && (pageInfo.Protection & MemoryProtection.NoAccess) == 0 && (ulong)pageInfo.Size <= int.MaxValue;
	}

	/// <summary>
	/// 转换模块布局
	/// </summary>
	/// <param name="peImage"></param>
	/// <param name="fromImageLayout"></param>
	/// <param name="toImageLayout"></param>
	/// <returns></returns>
	public static byte[] ConvertImageLayout(byte[] peImage, ImageLayout fromImageLayout, ImageLayout toImageLayout) {
		switch (fromImageLayout) {
		case ImageLayout.File:
		case ImageLayout.Memory:
			break;
		default:
			throw new ArgumentOutOfRangeException(nameof(fromImageLayout));
		}
		switch (toImageLayout) {
		case ImageLayout.File:
		case ImageLayout.Memory:
			break;
		default:
			throw new ArgumentOutOfRangeException(nameof(toImageLayout));
		}
		if (peImage is null)
			throw new ArgumentNullException(nameof(peImage));

		if (fromImageLayout == toImageLayout)
			return peImage;
		var newPEImageData = new byte[GetImageSize(peImage, toImageLayout)];
		using var peHeader = new PEImage(peImage, false);
		Buffer.BlockCopy(peImage, 0, newPEImageData, 0, (int)peHeader.ImageSectionHeaders.Last().EndOffset);
		// 复制PE头
		foreach (var sectionHeader in peHeader.ImageSectionHeaders) {
			switch (toImageLayout) {
			case ImageLayout.File:
				// ImageLayout.Memory -> ImageLayout.File
				Buffer.BlockCopy(peImage, (int)sectionHeader.VirtualAddress, newPEImageData, (int)sectionHeader.PointerToRawData, (int)sectionHeader.SizeOfRawData);
				break;
			case ImageLayout.Memory:
				// ImageLayout.File -> ImageLayout.Memory
				Buffer.BlockCopy(peImage, (int)sectionHeader.PointerToRawData, newPEImageData, (int)sectionHeader.VirtualAddress, (int)sectionHeader.SizeOfRawData);
				break;
			default:
				throw new NotSupportedException();
			}
		}
		return newPEImageData;
	}

	/// <summary>
	/// 获取模块大小
	/// </summary>
	/// <param name="peHeader"></param>
	/// <param name="imageLayout"></param>
	/// <returns></returns>
	public static uint GetImageSize(byte[] peHeader, ImageLayout imageLayout) {
		if (peHeader is null)
			throw new ArgumentNullException(nameof(peHeader));

		using var peImage = new PEImage(peHeader, false);
		return GetImageSize(peImage, imageLayout);
		// PEImage构造器中的imageLayout参数无关紧要，因为只需要解析PEHeader
	}

	/// <summary>
	/// 获取模块大小
	/// </summary>
	/// <param name="peHeader"></param>
	/// <param name="imageLayout"></param>
	/// <returns></returns>
	public static uint GetImageSize(PEImage peHeader, ImageLayout imageLayout) {
		var lastSectionHeader = peHeader.ImageSectionHeaders.Last();
		uint alignment;
		uint imageSize;
		switch (imageLayout) {
		case ImageLayout.File:
			alignment = peHeader.ImageNTHeaders.OptionalHeader.FileAlignment;
			imageSize = lastSectionHeader.PointerToRawData + lastSectionHeader.SizeOfRawData;
			break;
		case ImageLayout.Memory:
			alignment = peHeader.ImageNTHeaders.OptionalHeader.SectionAlignment;
			imageSize = (uint)lastSectionHeader.VirtualAddress + lastSectionHeader.VirtualSize;
			break;
		default:
			throw new NotSupportedException();
		}
		if (imageSize % alignment != 0)
			imageSize = imageSize - (imageSize % alignment) + alignment;
		return imageSize;
	}
}



================================================
File: ExtremeDumper/Forms/FunctionsForm.Designer.cs
================================================
namespace ExtremeDumper.Forms
{
    partial class FunctionsForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.lvwFunctions = new System.Windows.Forms.ListView();
            this.chFunctionName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chFunctionAddress = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chOrdinal = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.mnuFunctionsContext = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.mnuRefreshFunctionList = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuFunctionsContext.SuspendLayout();
            this.SuspendLayout();
            // 
            // lvwFunctions
            // 
            this.lvwFunctions.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.lvwFunctions.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.chFunctionName,
            this.chFunctionAddress,
            this.chOrdinal});
            this.lvwFunctions.ContextMenuStrip = this.mnuFunctionsContext;
            this.lvwFunctions.Dock = System.Windows.Forms.DockStyle.Fill;
            this.lvwFunctions.FullRowSelect = true;
            this.lvwFunctions.HideSelection = false;
            this.lvwFunctions.Location = new System.Drawing.Point(0, 0);
            this.lvwFunctions.Name = "lvwFunctions";
            this.lvwFunctions.Size = new System.Drawing.Size(933, 637);
            this.lvwFunctions.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.lvwFunctions.TabIndex = 0;
            this.lvwFunctions.UseCompatibleStateImageBehavior = false;
            this.lvwFunctions.View = System.Windows.Forms.View.Details;
            this.lvwFunctions.Resize += new System.EventHandler(this.lvwFunctions_Resize);
            // 
            // chFunctionName
            // 
            this.chFunctionName.Text = "Name";
            // 
            // chFunctionAddress
            // 
            this.chFunctionAddress.Text = "Address";
            // 
            // chOrdinal
            // 
            this.chOrdinal.Text = "Ordinal";
            // 
            // mnuFunctionsContext
            // 
            this.mnuFunctionsContext.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mnuRefreshFunctionList,
            this.toolStripSeparator1});
            this.mnuFunctionsContext.Name = "mnuModulesContext";
            this.mnuFunctionsContext.Size = new System.Drawing.Size(121, 32);
            // 
            // mnuRefreshFunctionList
            // 
            this.mnuRefreshFunctionList.Name = "mnuRefreshFunctionList";
            this.mnuRefreshFunctionList.Size = new System.Drawing.Size(120, 22);
            this.mnuRefreshFunctionList.Text = "Refresh";
            this.mnuRefreshFunctionList.Click += new System.EventHandler(this.mnuRefreshFunctionList_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(117, 6);
            // 
            // FunctionsForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 17F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(933, 637);
            this.Controls.Add(this.lvwFunctions);
            this.Font = new System.Drawing.Font("Microsoft YaHei", 9F);
            this.Icon = global::ExtremeDumper.Forms.Resources.Icon;
            this.Name = "FunctionsForm";
            this.mnuFunctionsContext.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.ListView lvwFunctions;
        private System.Windows.Forms.ColumnHeader chFunctionName;
        private System.Windows.Forms.ColumnHeader chFunctionAddress;
        private System.Windows.Forms.ColumnHeader chOrdinal;
        private System.Windows.Forms.ContextMenuStrip mnuFunctionsContext;
        private System.Windows.Forms.ToolStripMenuItem mnuRefreshFunctionList;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
    }
}



================================================
File: ExtremeDumper/Forms/FunctionsForm.cs
================================================
using System;
using System.Windows.Forms;
using NativeSharp;

namespace ExtremeDumper.Forms;

unsafe partial class FunctionsForm : Form {
	readonly NativeProcess process;
	readonly NativeModule module;

	public FunctionsForm(uint processId, nuint moduleHandle) {
		InitializeComponent();
		Utils.ScaleByDpi(this);
		process = NativeProcess.Open(processId);
		if (process.IsInvalid)
			throw new InvalidOperationException();
		module = process.UnsafeGetModule((void*)moduleHandle);
		Text = TitleComposer.Compose(true, "Export Functions", module.Name, null);
		Utils.EnableDoubleBuffer(lvwFunctions);
		lvwFunctions.ListViewItemSorter = new ListViewItemSorter(lvwFunctions, new[] { TypeCode.String, TypeCode.UInt64, TypeCode.Int16 }) { AllowHexLeading = true };
		RefreshFunctionList();
	}

	#region Events
	void lvwFunctions_Resize(object sender, EventArgs e) {
		lvwFunctions.AutoResizeColumns(true);
	}

	void mnuRefreshFunctionList_Click(object sender, EventArgs e) {
		RefreshFunctionList();
	}
	#endregion

	void RefreshFunctionList() {
		lvwFunctions.Items.Clear();
		foreach (var functionInfo in module.EnumerateFunctionInfos()) {
			var listViewItem = new ListViewItem(functionInfo.Name);
			listViewItem.SubItems.Add(Formatter.FormatHex((nuint)functionInfo.Address));
			listViewItem.SubItems.Add(functionInfo.Ordinal.ToString());
			lvwFunctions.Items.Add(listViewItem);
		}
		lvwFunctions.AutoResizeColumns(false);
	}

	protected override void Dispose(bool disposing) {
		if (disposing) {
			components?.Dispose();
			process.Dispose();
		}
		base.Dispose(disposing);
	}
}



================================================
File: ExtremeDumper/Forms/FunctionsForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="&gt;&gt;chFunctionName.Name" xml:space="preserve">
    <value>chFunctionName</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="lvwFunctions.Size" type="System.Drawing.Size, System.Drawing">
    <value>933, 637</value>
  </data>
  <data name="chFunctionAddress.Text" xml:space="preserve">
    <value>Address</value>
  </data>
  <data name="mnuRefreshFunctionList.Size" type="System.Drawing.Size, System.Drawing">
    <value>172, 22</value>
  </data>
  <data name="&gt;&gt;toolStripSeparator1.Name" xml:space="preserve">
    <value>toolStripSeparator1</value>
  </data>
  <data name="mnuForceFalse.Size" type="System.Drawing.Size, System.Drawing">
    <value>172, 22</value>
  </data>
  <data name="&gt;&gt;$this.Name" xml:space="preserve">
    <value>FunctionsForm</value>
  </data>
  <data name="mnuForceReturn.Size" type="System.Drawing.Size, System.Drawing">
    <value>172, 22</value>
  </data>
  <data name="toolStripSeparator1.Size" type="System.Drawing.Size, System.Drawing">
    <value>169, 6</value>
  </data>
  <data name="&gt;&gt;lvwFunctions.Type" xml:space="preserve">
    <value>System.Windows.Forms.ListView, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;mnuRefreshFunctionList.Type" xml:space="preserve">
    <value>System.Windows.Forms.ToolStripMenuItem, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="lvwFunctions.Location" type="System.Drawing.Point, System.Drawing">
    <value>0, 0</value>
  </data>
  <assembly alias="mscorlib" name="mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="lvwFunctions.TabIndex" type="System.Int32, mscorlib">
    <value>0</value>
  </data>
  <data name="&gt;&gt;chOrdinal.Type" xml:space="preserve">
    <value>System.Windows.Forms.ColumnHeader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;chOrdinal.Name" xml:space="preserve">
    <value>chOrdinal</value>
  </data>
  <data name="&gt;&gt;chFunctionAddress.Type" xml:space="preserve">
    <value>System.Windows.Forms.ColumnHeader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="$this.ClientSize" type="System.Drawing.Size, System.Drawing">
    <value>933, 637</value>
  </data>
  <data name="&gt;&gt;mnuFunctionsContext.Name" xml:space="preserve">
    <value>mnuFunctionsContext</value>
  </data>
  <data name="&gt;&gt;mnuRefreshFunctionList.Name" xml:space="preserve">
    <value>mnuRefreshFunctionList</value>
  </data>
  <data name="&gt;&gt;lvwFunctions.ZOrder" xml:space="preserve">
    <value>1</value>
  </data>
  <data name="&gt;&gt;mnuFunctionsContext.Type" xml:space="preserve">
    <value>System.Windows.Forms.ContextMenuStrip, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;$this.Type" xml:space="preserve">
    <value>System.Windows.Forms.Form, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="chFunctionName.Text" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="&gt;&gt;lvwFunctions.Name" xml:space="preserve">
    <value>lvwFunctions</value>
  </data>
  <data name="chOrdinal.Text" xml:space="preserve">
    <value>Ordinal</value>
  </data>
  <data name="mnuFunctionsContext.Size" type="System.Drawing.Size, System.Drawing">
    <value>173, 98</value>
  </data>
  <data name="&gt;&gt;toolStripSeparator1.Type" xml:space="preserve">
    <value>System.Windows.Forms.ToolStripSeparator, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;lvwFunctions.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="lvwFunctions.Dock" type="System.Windows.Forms.DockStyle, System.Windows.Forms">
    <value>Fill</value>
  </data>
  <data name="mnuRefreshFunctionList.Text" xml:space="preserve">
    <value>Refresh</value>
  </data>
  <data name="mnuForceTrue.Size" type="System.Drawing.Size, System.Drawing">
    <value>172, 22</value>
  </data>
  <data name="&gt;&gt;chFunctionAddress.Name" xml:space="preserve">
    <value>chFunctionAddress</value>
  </data>
  <data name="&gt;&gt;chFunctionName.Type" xml:space="preserve">
    <value>System.Windows.Forms.ColumnHeader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="$this.AutoScaleDimensions" type="System.Drawing.SizeF, System.Drawing">
    <value>7, 17</value>
  </data>
  <data name="$this.Font" type="System.Drawing.Font, System.Drawing">
    <value>Microsoft YaHei, 9pt</value>
  </data>
  <data name="lvwFunctions.Locked" type="System.Boolean, mscorlib">
    <value>True</value>
  </data>
  <data name="mnuFunctionsContext.TrayLocation" type="System.Drawing.Point, System.Drawing">
    <value>17, 17</value>
  </data>
  <data name="$this.Locked" type="System.Boolean, mscorlib">
    <value>True</value>
  </data>
</root>


================================================
File: ExtremeDumper/Forms/InjectingForm.Designer.cs
================================================
namespace ExtremeDumper.Forms
{
    partial class InjectingForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.chkWaitReturn = new System.Windows.Forms.CheckBox();
            this.btInject = new System.Windows.Forms.Button();
            this.cmbEntryPoint = new System.Windows.Forms.ComboBox();
            this.btSelectAssembly = new System.Windows.Forms.Button();
            this.tbAssemblyPath = new System.Windows.Forms.TextBox();
            this.tbArgument = new System.Windows.Forms.TextBox();
            this.odlgSelectAssembly = new System.Windows.Forms.OpenFileDialog();
            this.cmbCLRVersion = new System.Windows.Forms.ComboBox();
            this.SuspendLayout();
            // 
            // chkWaitReturn
            // 
            this.chkWaitReturn.AutoSize = true;
            this.chkWaitReturn.Location = new System.Drawing.Point(1116, 45);
            this.chkWaitReturn.Name = "chkWaitReturn";
            this.chkWaitReturn.Size = new System.Drawing.Size(64, 24);
            this.chkWaitReturn.TabIndex = 11;
            this.chkWaitReturn.Text = "Wait";
            this.chkWaitReturn.UseVisualStyleBackColor = true;
            // 
            // btInject
            // 
            this.btInject.Location = new System.Drawing.Point(1186, 45);
            this.btInject.Name = "btInject";
            this.btInject.Size = new System.Drawing.Size(174, 28);
            this.btInject.TabIndex = 9;
            this.btInject.Text = "Inject";
            this.btInject.UseVisualStyleBackColor = true;
            this.btInject.Click += new System.EventHandler(this.btInject_Click);
            // 
            // cmbEntryPoint
            // 
            this.cmbEntryPoint.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbEntryPoint.FormattingEnabled = true;
            this.cmbEntryPoint.Location = new System.Drawing.Point(12, 43);
            this.cmbEntryPoint.Name = "cmbEntryPoint";
            this.cmbEntryPoint.Size = new System.Drawing.Size(766, 28);
            this.cmbEntryPoint.TabIndex = 8;
            this.cmbEntryPoint.SelectedIndexChanged += new System.EventHandler(this.cmbEntryPoint_SelectedIndexChanged);
            // 
            // btSelectAssembly
            // 
            this.btSelectAssembly.Location = new System.Drawing.Point(1186, 12);
            this.btSelectAssembly.Name = "btSelectAssembly";
            this.btSelectAssembly.Size = new System.Drawing.Size(174, 28);
            this.btSelectAssembly.TabIndex = 7;
            this.btSelectAssembly.Text = "Select Assembly...";
            this.btSelectAssembly.UseVisualStyleBackColor = true;
            this.btSelectAssembly.Click += new System.EventHandler(this.btSelectAssembly_Click);
            // 
            // tbAssemblyPath
            // 
            this.tbAssemblyPath.Location = new System.Drawing.Point(12, 13);
            this.tbAssemblyPath.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.tbAssemblyPath.Name = "tbAssemblyPath";
            this.tbAssemblyPath.Size = new System.Drawing.Size(1168, 27);
            this.tbAssemblyPath.TabIndex = 6;
            this.tbAssemblyPath.TextChanged += new System.EventHandler(this.tbAssemblyPath_TextChanged);
            // 
            // tbArgument
            // 
            this.tbArgument.Location = new System.Drawing.Point(884, 43);
            this.tbArgument.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.tbArgument.Name = "tbArgument";
            this.tbArgument.Size = new System.Drawing.Size(226, 27);
            this.tbArgument.TabIndex = 12;
            this.tbArgument.Text = "<Optional Argument>";
            this.tbArgument.TextChanged += new System.EventHandler(this.tbArgument_TextChanged);
            // 
            // cmbCLRVersion
            // 
            this.cmbCLRVersion.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbCLRVersion.FormattingEnabled = true;
            this.cmbCLRVersion.Items.AddRange(new object[] {
            "CLR 2.x",
            "CLR 4.x"});
            this.cmbCLRVersion.Location = new System.Drawing.Point(784, 43);
            this.cmbCLRVersion.Name = "cmbCLRVersion";
            this.cmbCLRVersion.Size = new System.Drawing.Size(94, 28);
            this.cmbCLRVersion.TabIndex = 13;
            // 
            // InjectingForm
            // 
            this.AllowDrop = true;
            this.AutoScaleDimensions = new System.Drawing.SizeF(9F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(1372, 82);
            this.Controls.Add(this.cmbCLRVersion);
            this.Controls.Add(this.tbArgument);
            this.Controls.Add(this.chkWaitReturn);
            this.Controls.Add(this.btInject);
            this.Controls.Add(this.cmbEntryPoint);
            this.Controls.Add(this.btSelectAssembly);
            this.Controls.Add(this.tbAssemblyPath);
            this.Font = new System.Drawing.Font("Microsoft YaHei", 9F);
            this.Icon = global::ExtremeDumper.Forms.Resources.Icon;
            this.Name = "InjectingForm";
            this.DragDrop += new System.Windows.Forms.DragEventHandler(this.InjectingForm_DragDrop);
            this.DragEnter += new System.Windows.Forms.DragEventHandler(this.InjectingForm_DragEnter);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.CheckBox chkWaitReturn;
        private System.Windows.Forms.Button btInject;
        private System.Windows.Forms.ComboBox cmbEntryPoint;
        private System.Windows.Forms.Button btSelectAssembly;
        private System.Windows.Forms.TextBox tbAssemblyPath;
        private System.Windows.Forms.TextBox tbArgument;
        private System.Windows.Forms.OpenFileDialog odlgSelectAssembly;
		private System.Windows.Forms.ComboBox cmbCLRVersion;
	}
}



================================================
File: ExtremeDumper/Forms/InjectingForm.cs
================================================
using System;
using System.IO;
using System.Threading;
using System.Windows.Forms;
using dnlib.DotNet;
using ExtremeDumper.Diagnostics;
using ExtremeDumper.Injecting;
using ExtremeDumper.Logging;

namespace ExtremeDumper.Forms;

partial class InjectingForm : Form {
	readonly ProcessInfo process;
	string assemblyPath = string.Empty;
	ModuleDef? module;
	MethodDef? entryPoint;
	string argument = string.Empty;

	public InjectingForm(ProcessInfo process) {
		this.process = process;
		InitializeComponent();
		Text = TitleComposer.Compose(true, "Injector", process.Name, null, $"ID={process.Id}");
		cmbCLRVersion.SelectedIndex = 0;
	}

	#region Events
	void InjectingForm_DragEnter(object sender, DragEventArgs e) {
		e.Effect = e.Data.GetDataPresent(DataFormats.FileDrop) ? DragDropEffects.Copy : DragDropEffects.None;
	}

	void InjectingForm_DragDrop(object sender, DragEventArgs e) {
		tbAssemblyPath.Text = ((string[])e.Data.GetData(DataFormats.FileDrop))[0];
		LoadAssembly();
	}

	void tbAssemblyPath_TextChanged(object sender, EventArgs e) {
		assemblyPath = tbAssemblyPath.Text;
	}

	void btSelectAssembly_Click(object sender, EventArgs e) {
		if (odlgSelectAssembly.ShowDialog() == DialogResult.OK)
			tbAssemblyPath.Text = odlgSelectAssembly.FileName;
		else
			return;
		LoadAssembly();
	}

	void cmbEntryPoint_SelectedIndexChanged(object sender, EventArgs e) {
		entryPoint = (MethodDef)cmbEntryPoint.SelectedItem;
	}

	void tbArgument_TextChanged(object sender, EventArgs e) {
		argument = tbArgument.Text;
	}

	void btInject_Click(object sender, EventArgs e) {
		if (!File.Exists(assemblyPath))
			return;
		if (entryPoint is null)
			return;

		string typeName = entryPoint.FullName.Substring(entryPoint.FullName.IndexOf(' ') + 1);
		typeName = typeName.Substring(0, typeName.IndexOf(':'));
		var clrVersion = cmbCLRVersion.SelectedItem switch {
			"CLR 2.x" => InjectionClrVersion.V2,
			"CLR 4.x" => InjectionClrVersion.V4,
			_ => throw new NotSupportedException()
		};
		if (chkWaitReturn.Checked) {
			btInject.Enabled = false;
			Text += "Waiting...";
			new Thread(() => {
				if (Injector.InjectManagedAndWait(process.Id, assemblyPath, typeName, entryPoint.Name, argument, clrVersion, out int ret))
					Logger.Info($"Inject successfully and return value is {Formatter.FormatHex(ret)}");
				else
					Logger.Error("Failed to inject");
				Invoke(() => {
					btInject.Enabled = true;
					Text = Text.Substring(0, Text.Length - 6);
				});
			}) { IsBackground = true }.Start();
		}
		else {
			if (Injector.InjectManaged(process.Id, assemblyPath, typeName, entryPoint.Name, argument, clrVersion))
				Logger.Info("Inject successfully");
			else
				Logger.Error("Failed to inject");
		}
	}
	#endregion

	void LoadAssembly() {
		try {
			module = ModuleDefMD.Load(File.ReadAllBytes(assemblyPath));
		}
		catch {
			Logger.Error("Invalid assembly");
			module = null;
			return;
		}
		cmbEntryPoint.Items.Clear();
		foreach (var type in module.GetTypes()) {
			foreach (var method in type.Methods) {
				if (!method.IsStatic)
					continue;
				if (method.IsGetter || method.IsSetter)
					continue;

				var methodSig = (MethodSig)method.Signature;
				if (methodSig.Params.Count != 1 || methodSig.Params[0].FullName != "System.String")
					continue;
				if (methodSig.RetType.FullName != "System.Int32")
					continue;

				cmbEntryPoint.Items.Add(method);
			}
		}
		if (cmbEntryPoint.Items.Count == 1)
			cmbEntryPoint.SelectedIndex = 0;
		cmbCLRVersion.SelectedIndex = module.CorLibTypes.AssemblyRef.Version.Major == 4 ? 1 : 0;
	}

	protected override void Dispose(bool disposing) {
		if (disposing) {
			components?.Dispose();
			module?.Dispose();
		}
		base.Dispose(disposing);
	}
}



================================================
File: ExtremeDumper/Forms/InjectingForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="odlgSelectAssembly.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>


================================================
File: ExtremeDumper/Forms/ListViewExtesion.cs
================================================
using System;
using System.Windows.Forms;
using static ExtremeDumper.Forms.NativeMethods;

namespace ExtremeDumper.Forms;

static class ListViewExtesion {
	public static void AutoResizeColumns(this ListView listView, bool onlyLastColumn) {
		if (listView is null)
			throw new ArgumentNullException(nameof(listView));

		listView.SuspendLayout();
		var scrollBarInfo = SCROLLBARINFO.Default;
		GetScrollBarInfo((nuint)(nint)listView.Handle, OBJID_VSCROLL, ref scrollBarInfo);
		int sumWidths = scrollBarInfo.dxyLineButton;
		if (onlyLastColumn) {
			foreach (ColumnHeader columnHeader in listView.Columns)
				sumWidths += columnHeader.Width;
			listView.Columns[listView.Columns.Count - 1].Width += listView.Width - sumWidths - 4;
		}
		else {
			int[] minWidths = CalculateMinimumWidths(listView);
			listView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.ColumnContent);
			for (int i = 0; i < minWidths.Length; i++) {
				if (listView.Columns[i].Width < minWidths[i])
					listView.Columns[i].Width = minWidths[i];
				sumWidths += listView.Columns[i].Width;
			}
			listView.Columns[minWidths.Length - 1].Width += listView.Width - sumWidths;
		}
		listView.ResumeLayout();
	}

	static int[] CalculateMinimumWidths(ListView listView) {
		int[] minWidths = new int[listView.Columns.Count];
		using var g = listView.CreateGraphics();
		for (int i = 0; i < minWidths.Length; i++)
			minWidths[i] = (int)g.MeasureString(listView.Columns[i].Text, listView.Font).Width + 10;
		return minWidths;
	}

	public static ListViewItem.ListViewSubItem GetFirstSelectedSubItem(this ListView listView, int index) {
		if (listView is null)
			throw new ArgumentNullException(nameof(listView));

		return listView.SelectedItems[0].SubItems[index];
	}
}



================================================
File: ExtremeDumper/Forms/ListViewItemSorter.cs
================================================
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Windows.Forms;

namespace ExtremeDumper.Forms;

sealed class ListViewItemSorter : IComparer, IDisposable {
	delegate bool Parser<T>(string s, NumberStyles style, IFormatProvider? provider, out T result);

	readonly ListView listView;
	readonly IList<TypeCode> columnTypes;
	readonly Dictionary<string, object> parsedValues = new(StringComparer.Ordinal);
	int column;
	int lastColumn;
	bool isDisposed;

	public bool AllowHexLeading { get; set; }

	public ListViewItemSorter(ListView listView, IList<TypeCode> columnTypes) {
		if (listView is null)
			throw new ArgumentNullException(nameof(listView));
		if (columnTypes is null)
			throw new ArgumentNullException(nameof(columnTypes));

		this.listView = listView;
		this.columnTypes = columnTypes;
		listView.ColumnClick += ListView_ColumnClick;
	}

	void ListView_ColumnClick(object sender, ColumnClickEventArgs e) {
		if (listView.Sorting == SortOrder.None)
			return;

		column = e.Column;
		if (column == lastColumn)
			listView.Sorting = listView.Sorting == SortOrder.Ascending ? SortOrder.Descending : SortOrder.Ascending;
		else
			listView.Sorting = SortOrder.Ascending;
		listView.Sort();
		lastColumn = column;
	}

	public int Compare(object x, object y) {
		switch (listView.Sorting) {
		case SortOrder.Ascending:
			return Compare(((ListViewItem)x).SubItems[column].Text, ((ListViewItem)y).SubItems[column].Text);
		case SortOrder.Descending:
			return -Compare(((ListViewItem)x).SubItems[column].Text, ((ListViewItem)y).SubItems[column].Text);
		default:
			throw new InvalidEnumArgumentException("æ— æ•ˆçš„Sorting");
		}
	}

	int Compare(string x, string y) {
		switch (columnTypes[column]) {
		case TypeCode.Boolean:
			throw new NotImplementedException();
		case TypeCode.Char:
			throw new NotImplementedException();
		case TypeCode.SByte:
			throw new NotImplementedException();
		case TypeCode.Byte:
			throw new NotImplementedException();
		case TypeCode.Int16:
			return IntegerComparer<short>(x, y, short.TryParse);
		case TypeCode.UInt16:
			return IntegerComparer<ushort>(x, y, ushort.TryParse);
		case TypeCode.Int32:
			return IntegerComparer<int>(x, y, int.TryParse);
		case TypeCode.UInt32:
			return IntegerComparer<uint>(x, y, uint.TryParse);
		case TypeCode.Int64:
			return IntegerComparer<long>(x, y, long.TryParse);
		case TypeCode.UInt64:
			return IntegerComparer<ulong>(x, y, ulong.TryParse);
		case TypeCode.Single:
			throw new NotImplementedException();
		case TypeCode.Double:
			throw new NotImplementedException();
		case TypeCode.Decimal:
			throw new NotImplementedException();
		case TypeCode.DateTime:
			throw new NotImplementedException();
		case TypeCode.String:
			return string.Compare(x, y, StringComparison.OrdinalIgnoreCase);
		default:
			throw new InvalidEnumArgumentException();
		}
	}

	int IntegerComparer<T>(string x, string y, Parser<T> parser) where T : struct, IComparable<T> {
		var a = ParseInteger(x, parser);
		var b = ParseInteger(y, parser);
		return a.CompareTo(b);
	}

	T ParseInteger<T>(string value, Parser<T> parser) where T : struct {
		if (!parsedValues.TryGetValue(value, out var integer)) {
			bool isHex = false;
			value = value.Trim();
			if (AllowHexLeading)
				value = CleanHexIdentifier(value, out isHex);
			if (!parser(value, isHex ? NumberStyles.HexNumber : NumberStyles.Integer, null, out var t))
				t = default;
			integer = t;
			parsedValues.Add(value, integer);
		}
		return (T)integer;
	}

	static string CleanHexIdentifier(string value, out bool isHex) {
		string t = value.Trim();
		if (t.StartsWith("0X", StringComparison.OrdinalIgnoreCase)) {
			isHex = true;
			return t.Substring(2);
		}
		if (t.EndsWith("H", StringComparison.OrdinalIgnoreCase)) {
			isHex = true;
			return t.Substring(0, t.Length - 1);
		}
		isHex = false;
		return value;
	}

	public void Dispose() {
		if (isDisposed)
			return;

		listView.ColumnClick -= ListView_ColumnClick;
		columnTypes.Clear();
		isDisposed = true;
	}
}



================================================
File: ExtremeDumper/Forms/LoaderHookForm.Designer.cs
================================================
namespace ExtremeDumper.Forms;

partial class LoaderHookForm {
	/// <summary>
	/// Required designer variable.
	/// </summary>
	private System.ComponentModel.IContainer components = null;

	/// <summary>
	/// Clean up any resources being used.
	/// </summary>
	/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
	protected override void Dispose(bool disposing) {
		if (disposing && (components != null)) {
			components.Dispose();
		}
		base.Dispose(disposing);
	}

	#region Windows Form Designer generated code

	/// <summary>
	/// Required method for Designer support - do not modify
	/// the contents of this method with the code editor.
	/// </summary>
	private void InitializeComponent() {
            this.btSelectAssembly = new System.Windows.Forms.Button();
            this.tbAssemblyPath = new System.Windows.Forms.TextBox();
            this.btnRun = new System.Windows.Forms.Button();
            this.odlgSelectAssembly = new System.Windows.Forms.OpenFileDialog();
            this.SuspendLayout();
            // 
            // btSelectAssembly
            // 
            this.btSelectAssembly.Location = new System.Drawing.Point(12, 47);
            this.btSelectAssembly.Name = "btSelectAssembly";
            this.btSelectAssembly.Size = new System.Drawing.Size(172, 27);
            this.btSelectAssembly.TabIndex = 9;
            this.btSelectAssembly.Text = "Select Assembly...";
            this.btSelectAssembly.UseVisualStyleBackColor = true;
            this.btSelectAssembly.Click += new System.EventHandler(this.btSelectAssembly_Click);
            // 
            // tbAssemblyPath
            // 
            this.tbAssemblyPath.Location = new System.Drawing.Point(12, 13);
            this.tbAssemblyPath.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            this.tbAssemblyPath.Name = "tbAssemblyPath";
            this.tbAssemblyPath.Size = new System.Drawing.Size(856, 27);
            this.tbAssemblyPath.TabIndex = 8;
            this.tbAssemblyPath.TextChanged += new System.EventHandler(this.tbAssemblyPath_TextChanged);
            // 
            // btnRun
            // 
            this.btnRun.Location = new System.Drawing.Point(455, 47);
            this.btnRun.Name = "btnRun";
            this.btnRun.Size = new System.Drawing.Size(172, 27);
            this.btnRun.TabIndex = 10;
            this.btnRun.Text = "Run With Hook";
            this.btnRun.UseVisualStyleBackColor = true;
            this.btnRun.Click += new System.EventHandler(this.btnRun_Click);
            // 
            // LoaderHookForm
            // 
            this.AllowDrop = true;
            this.AutoScaleDimensions = new System.Drawing.SizeF(9F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(878, 86);
            this.Controls.Add(this.btnRun);
            this.Controls.Add(this.btSelectAssembly);
            this.Controls.Add(this.tbAssemblyPath);
            this.Font = new System.Drawing.Font("Microsoft YaHei", 9F);
            this.Icon = global::ExtremeDumper.Forms.Resources.Icon;
            this.Name = "LoaderHookForm";
            this.Text = "Loader Hook";
            this.DragDrop += new System.Windows.Forms.DragEventHandler(this.LoaderHookForm_DragDrop);
            this.DragEnter += new System.Windows.Forms.DragEventHandler(this.LoaderHookForm_DragEnter);
            this.ResumeLayout(false);
            this.PerformLayout();

	}

	#endregion

	private System.Windows.Forms.Button btSelectAssembly;
	private System.Windows.Forms.TextBox tbAssemblyPath;
	private System.Windows.Forms.Button btnRun;
	private System.Windows.Forms.OpenFileDialog odlgSelectAssembly;
}



================================================
File: ExtremeDumper/Forms/LoaderHookForm.cs
================================================
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;
using ExtremeDumper.Logging;

namespace ExtremeDumper.Forms;

partial class LoaderHookForm : Form {
	[DllImport("ExtremeDumper.LoaderHook.dll", BestFitMapping = false, CharSet = CharSet.Unicode, SetLastError = true)]
	static extern uint LoaderHookCreateProcess(string applicationName, StringBuilder? commandLine);

	string assemblyPath = string.Empty;

	public LoaderHookForm() {
		InitializeComponent();
	}

	#region Events
	void LoaderHookForm_DragEnter(object sender, DragEventArgs e) {
		e.Effect = e.Data.GetDataPresent(DataFormats.FileDrop) ? DragDropEffects.Copy : DragDropEffects.None;
	}

	void LoaderHookForm_DragDrop(object sender, DragEventArgs e) {
		tbAssemblyPath.Text = ((string[])e.Data.GetData(DataFormats.FileDrop))[0];
	}

	void tbAssemblyPath_TextChanged(object sender, EventArgs e) {
		assemblyPath = tbAssemblyPath.Text;
	}

	void btSelectAssembly_Click(object sender, EventArgs e) {
		if (odlgSelectAssembly.ShowDialog() == DialogResult.OK)
			tbAssemblyPath.Text = odlgSelectAssembly.FileName;
		else
			return;
	}

	void btnRun_Click(object sender, EventArgs e) {
		if (string.IsNullOrEmpty(assemblyPath))
			return;

		uint hr = LoaderHookCreateProcess(assemblyPath, null);
		if (hr == 0)
			Logger.Info("Succeed");
		else
			Logger.Info($"Failed, please try using ExtremeDumper{(IntPtr.Size == 4 ? string.Empty : "-x86")}.exe");
	}
	#endregion
}



================================================
File: ExtremeDumper/Forms/LoaderHookForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="odlgSelectAssembly.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
</root>


================================================
File: ExtremeDumper/Forms/ModulesForm.Designer.cs
================================================
namespace ExtremeDumper.Forms
{
    partial class ModulesForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.lvwModules = new System.Windows.Forms.ListView();
            this.chModuleName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chDomainName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chCLRVersion = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chModuleHandle = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chModuleSize = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chModulePath = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.mnuModulesContext = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.mnuDumpModule = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuRefreshModuleList = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuViewFunctions = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuOnlyDotNetModule = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuGotoLocation = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuEnableAntiAntiDump = new System.Windows.Forms.ToolStripMenuItem();
            this.sfdlgDumped = new System.Windows.Forms.SaveFileDialog();
            this.mnuModulesContext.SuspendLayout();
            this.SuspendLayout();
            // 
            // lvwModules
            // 
            this.lvwModules.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.lvwModules.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.chModuleName,
            this.chDomainName,
            this.chCLRVersion,
            this.chModuleHandle,
            this.chModuleSize,
            this.chModulePath});
            this.lvwModules.ContextMenuStrip = this.mnuModulesContext;
            this.lvwModules.Dock = System.Windows.Forms.DockStyle.Fill;
            this.lvwModules.FullRowSelect = true;
            this.lvwModules.HideSelection = false;
            this.lvwModules.Location = new System.Drawing.Point(0, 0);
            this.lvwModules.Name = "lvwModules";
            this.lvwModules.Size = new System.Drawing.Size(933, 637);
            this.lvwModules.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.lvwModules.TabIndex = 0;
            this.lvwModules.UseCompatibleStateImageBehavior = false;
            this.lvwModules.View = System.Windows.Forms.View.Details;
            this.lvwModules.Resize += new System.EventHandler(this.lvwModules_Resize);
            // 
            // chModuleName
            // 
            this.chModuleName.Text = "Name";
            // 
            // chDomainName
            // 
            this.chDomainName.Text = "Domain Name";
            // 
            // chCLRVersion
            // 
            this.chCLRVersion.Text = "CLR Version";
            // 
            // chModuleHandle
            // 
            this.chModuleHandle.Text = "Address";
            // 
            // chModuleSize
            // 
            this.chModuleSize.Text = "Size";
            // 
            // chModulePath
            // 
            this.chModulePath.Text = "Path";
            // 
            // mnuModulesContext
            // 
            this.mnuModulesContext.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mnuDumpModule,
            this.mnuRefreshModuleList,
            this.mnuViewFunctions,
            this.toolStripSeparator1,
            this.mnuOnlyDotNetModule,
            this.toolStripSeparator2,
            this.mnuGotoLocation,
            this.toolStripSeparator3,
            this.mnuEnableAntiAntiDump});
            this.mnuModulesContext.Name = "mnuModulesContext";
            this.mnuModulesContext.Size = new System.Drawing.Size(214, 176);
            // 
            // mnuDumpModule
            // 
            this.mnuDumpModule.Name = "mnuDumpModule";
            this.mnuDumpModule.Size = new System.Drawing.Size(213, 22);
            this.mnuDumpModule.Text = "Dump Selected Module";
            this.mnuDumpModule.Click += new System.EventHandler(this.mnuDumpModule_Click);
            // 
            // mnuRefreshModuleList
            // 
            this.mnuRefreshModuleList.Name = "mnuRefreshModuleList";
            this.mnuRefreshModuleList.Size = new System.Drawing.Size(213, 22);
            this.mnuRefreshModuleList.Text = "Refresh";
            this.mnuRefreshModuleList.Click += new System.EventHandler(this.mnuRefreshModuleList_Click);
            // 
            // mnuViewFunctions
            // 
            this.mnuViewFunctions.Name = "mnuViewFunctions";
            this.mnuViewFunctions.Size = new System.Drawing.Size(213, 22);
            this.mnuViewFunctions.Text = "View Export Functions";
            this.mnuViewFunctions.Click += new System.EventHandler(this.mnuViewFunctions_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(210, 6);
            // 
            // mnuOnlyDotNetModule
            // 
            this.mnuOnlyDotNetModule.CheckOnClick = true;
            this.mnuOnlyDotNetModule.Name = "mnuOnlyDotNetModule";
            this.mnuOnlyDotNetModule.Size = new System.Drawing.Size(213, 22);
            this.mnuOnlyDotNetModule.Text = "Only .NET Modules";
            this.mnuOnlyDotNetModule.Click += new System.EventHandler(this.mnuOnlyDotNetModule_Click);
            // 
            // toolStripSeparator2
            // 
            this.toolStripSeparator2.Name = "toolStripSeparator2";
            this.toolStripSeparator2.Size = new System.Drawing.Size(210, 6);
            // 
            // mnuGotoLocation
            // 
            this.mnuGotoLocation.Name = "mnuGotoLocation";
            this.mnuGotoLocation.Size = new System.Drawing.Size(213, 22);
            this.mnuGotoLocation.Text = "Goto Location";
            this.mnuGotoLocation.Click += new System.EventHandler(this.mnuGotoLocation_Click);
            // 
            // toolStripSeparator3
            // 
            this.toolStripSeparator3.Name = "toolStripSeparator3";
            this.toolStripSeparator3.Size = new System.Drawing.Size(210, 6);
            // 
            // mnuEnableAntiAntiDump
            // 
            this.mnuEnableAntiAntiDump.Name = "mnuEnableAntiAntiDump";
            this.mnuEnableAntiAntiDump.Size = new System.Drawing.Size(213, 22);
            this.mnuEnableAntiAntiDump.Text = "Enable AntiAntiDump";
            this.mnuEnableAntiAntiDump.Click += new System.EventHandler(this.mnuEnableAntiAntiDump_Click);
            // 
            // ModulesForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 17F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(933, 637);
            this.Controls.Add(this.lvwModules);
            this.Font = new System.Drawing.Font("Microsoft YaHei", 9F);
            this.Icon = global::ExtremeDumper.Forms.Resources.Icon;
            this.Name = "ModulesForm";
            this.mnuModulesContext.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.ListView lvwModules;
        private System.Windows.Forms.ColumnHeader chModuleName;
        private System.Windows.Forms.ColumnHeader chDomainName;
        private System.Windows.Forms.ColumnHeader chCLRVersion;
        private System.Windows.Forms.ColumnHeader chModuleHandle;
        private System.Windows.Forms.ColumnHeader chModuleSize;
        private System.Windows.Forms.ColumnHeader chModulePath;
        private System.Windows.Forms.SaveFileDialog sfdlgDumped;
        private System.Windows.Forms.ContextMenuStrip mnuModulesContext;
        private System.Windows.Forms.ToolStripMenuItem mnuDumpModule;
        private System.Windows.Forms.ToolStripMenuItem mnuRefreshModuleList;
        private System.Windows.Forms.ToolStripMenuItem mnuViewFunctions;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
        private System.Windows.Forms.ToolStripMenuItem mnuOnlyDotNetModule;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
        private System.Windows.Forms.ToolStripMenuItem mnuGotoLocation;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator3;
        private System.Windows.Forms.ToolStripMenuItem mnuEnableAntiAntiDump;
    }
}



================================================
File: ExtremeDumper/Forms/ModulesForm.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using ExtremeDumper.Diagnostics;
using ExtremeDumper.Dumping;
using ExtremeDumper.Logging;
using ImageLayout = dnlib.PE.ImageLayout;

namespace ExtremeDumper.Forms;

partial class ModulesForm : Form {
	static readonly char[] InvalidFileNameChars = Path.GetInvalidFileNameChars();

	readonly ProcessInfo process;
	readonly StrongBox<DumperType> dumperType;
	readonly TitleComposer title;
	readonly List<ModuleInfo> modules = new();

	public ModulesForm(ProcessInfo process, StrongBox<DumperType> dumperType) {
		InitializeComponent();
		Utils.ScaleByDpi(this);
		this.process = process;
		this.dumperType = dumperType;
		title = new TitleComposer {
			Title = "Modules",
			Subtitle = process.Name
		};
		title.Annotations["PID"] = $"PID={process.Id}";
		Text = title.Compose(true);
		Utils.EnableDoubleBuffer(lvwModules);
		lvwModules.ListViewItemSorter = new ListViewItemSorter(lvwModules, new[] { TypeCode.String, TypeCode.String, TypeCode.String, TypeCode.UInt64, TypeCode.Int32, TypeCode.String }) { AllowHexLeading = true };
		RefreshModuleList();
	}

	#region Events
	void lvwModules_Resize(object sender, EventArgs e) {
		lvwModules.AutoResizeColumns(true);
	}

	async void mnuDumpModule_Click(object sender, EventArgs e) {
		if (!TryGetSelectedModule(out var module))
			return;

		try {
			mnuDumpModule.Enabled = false;
			title.Annotations["DUMP"] = "Dumping";
			Text = title.Compose(true);

			string filePath = EnsureValidFileName(module.Name);
			if (filePath.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) || filePath.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
				filePath = PathInsertPostfix(filePath, ".dump");
			else
				filePath += ".dump.dll";
			sfdlgDumped.FileName = filePath;
			sfdlgDumped.InitialDirectory = Path.GetDirectoryName(process.FilePath);
			if (sfdlgDumped.ShowDialog() != DialogResult.OK)
				return;

			var imageLayout = module is DotNetModuleInfo dnModule && dnModule.InMemory ? ImageLayout.File : ImageLayout.Memory;
			bool result = await Task.Run(() => DumpModule(module.ImageBase, imageLayout, sfdlgDumped.FileName));
			if (result)
				Logger.Info($"Dump module successfully. Image was saved to: {sfdlgDumped.FileName}");
			else
				Logger.Error("Fail to dump module.");
		}
		catch (Exception ex) {
			Logger.Error("Exception occurred while dumping module");
			Logger.Exception(ex);
		}
		finally {
			title.Annotations["DUMP"] = null;
			Text = title.Compose(true);
			mnuDumpModule.Enabled = true;
		}
	}

	async void mnuRefreshModuleList_Click(object sender, EventArgs e) {
		try {
			mnuRefreshModuleList.Enabled = false;
			mnuOnlyDotNetModule.Enabled = false;
			title.Annotations["REFRESH"] = "Refreshing";
			Text = title.Compose(true);
			if (mnuEnableAntiAntiDump.Checked)
				await RefreshModuleListAAD();
			else
				RefreshModuleList();
		}
		finally {
			title.Annotations["REFRESH"] = null;
			Text = title.Compose(true);
			mnuRefreshModuleList.Enabled = true;
			mnuOnlyDotNetModule.Enabled = true;
		}
	}

	void mnuViewFunctions_Click(object sender, EventArgs e) {
		if (!TryGetSelectedModule(out var module))
			return;

		new FunctionsForm(process.Id, module.ImageBase).Show();
	}

	void mnuOnlyDotNetModule_Click(object sender, EventArgs e) {
		mnuRefreshModuleList_Click(sender, e);
	}

	void mnuGotoLocation_Click(object sender, EventArgs e) {
		if (!TryGetSelectedModule(out var module))
			return;

		if (module.FilePath != "InMemory")
			Process.Start("explorer.exe", $"/select,{module.FilePath}");
	}

	async void mnuEnableAntiAntiDump_Click(object sender, EventArgs e) {
		if (mnuEnableAntiAntiDump.Checked == true) {
			mnuEnableAntiAntiDump.Checked = false;
			title.Annotations["ENABLE_AAD"] = null;
			mnuRefreshModuleList_Click(sender, e);
			return;
		}

		try {
			mnuEnableAntiAntiDump.Enabled = false;
			title.Annotations["ENABLE_AAD"] = "Enabling AntiAntiDump";
			Text = title.Compose(true);

			await Task.Run(() => AntiAntiDump.AADExtensions.EnumerateAADClients(process.Id));
			mnuEnableAntiAntiDump.Checked = true;
		}
		finally {
			title.Annotations["ENABLE_AAD"] = "AntiAntiDump";
			Text = title.Compose(true);
			mnuEnableAntiAntiDump.Enabled = true;
		}
		mnuRefreshModuleList_Click(sender, e);
	}
	#endregion

	bool TryGetSelectedModule([NotNullWhen(true)] out ModuleInfo? module) {
		module = null;
		if (lvwModules.SelectedIndices.Count == 0)
			return false;

		nuint moduleHandle = (nuint)ulong.Parse(lvwModules.GetFirstSelectedSubItem(chModuleHandle.Index).Text.Substring(2), NumberStyles.HexNumber);
		var domainName = lvwModules.GetFirstSelectedSubItem(chDomainName.Index).Text;
		if (string.IsNullOrEmpty(domainName))
			domainName = null;
		module = modules.Find(t => t.ImageBase == moduleHandle && (t as DotNetModuleInfo)?.DomainName == domainName);
		Debug2.Assert(module is not null);
		return true;
	}

	void RefreshModuleList() {
		Utils.RefreshListView(lvwModules, GetAllModules(), t => CreateListViewItem(t), -1);
	}

	ModuleInfo[] GetAllModules() {
		var modules = GetModules();
		var dnModules = GetDotNetModules().Where(t => !IsAntiAntiDumpModule(t)).ToArray();
		var allModules = dnModules.Concat(modules.Where(x => !dnModules.Any(y => x.ImageBase == y.ImageBase))).ToArray();
		this.modules.Clear();
		this.modules.AddRange(allModules);
		return allModules;
	}

	ModuleInfo[] GetModules() {
		if (mnuOnlyDotNetModule.Checked)
			return Array2.Empty<ModuleInfo>();

		return ModulesProviderFactory.Create(process.Id, ModulesProviderType.Unmanaged).EnumerateModules().ToArray();
	}

	ModuleInfo[] GetDotNetModules() {
		if (process is not DotNetProcessInfo)
			return Array2.Empty<ModuleInfo>();

		try {
			return ModulesProviderFactory.Create(process.Id, ModulesProviderType.Managed).EnumerateModules().ToArray();
		}
		catch (Exception ex) {
			Logger.Error("Fail to get .NET modules");
			Logger.Exception(ex);
			return Array2.Empty<ModuleInfo>();
		}
	}

	async Task RefreshModuleListAAD() {
		await Utils.RefreshListViewAsync(lvwModules, GetModulesAAD(), t => CreateListViewItem(t), -1);
	}

	IEnumerable<ModuleInfo> GetModulesAAD() {
		modules.Clear();
		var dnModules = new List<ModuleInfo>();
		foreach (var module in ModulesProviderFactory.Create(process.Id, ModulesProviderType.ManagedAAD).EnumerateModules()) {
			if (IsAntiAntiDumpModule(module))
				continue;
			dnModules.Add(module);
			yield return module;
		}
		modules.AddRange(dnModules);
		var umModules = GetModules().Where(x => !dnModules.Any(y => x.ImageBase == y.ImageBase)).ToArray();
		foreach (var module in umModules)
			yield return module;
		modules.AddRange(modules);
	}

	static ListViewItem CreateListViewItem(ModuleInfo module) {
		var listViewItem = new ListViewItem(string.IsNullOrEmpty(module.Name) ? "<<EmptyName>>" : module.Name);
		// Name
		if (module is DotNetModuleInfo dnModule) {
			listViewItem.SubItems.Add(dnModule.DomainName);
			// Domain Name
			listViewItem.SubItems.Add(dnModule.CLRVersion);
			// CLR Version
			listViewItem.BackColor = Utils.DotNetColor;
		}
		else {
			listViewItem.SubItems.Add(string.Empty);
			// Domain Name
			listViewItem.SubItems.Add(string.Empty);
			// CLR Version
		}
		listViewItem.SubItems.Add(Formatter.FormatHex(module.ImageBase));
		// Address
		listViewItem.SubItems.Add(Formatter.FormatHex(module.ImageSize));
		// Size
		listViewItem.SubItems.Add(string.IsNullOrEmpty(module.FilePath) ? "InMemory" : module.FilePath);
		// Path
		return listViewItem;
	}

	static string EnsureValidFileName(string fileName) {
		if (string.IsNullOrEmpty(fileName))
			return string.Empty;

		var newFileName = new StringBuilder(fileName.Length);
		foreach (char chr in fileName) {
			if (!InvalidFileNameChars.Contains(chr))
				newFileName.Append(chr);
		}
		return newFileName.ToString();
	}

	bool DumpModule(nuint moduleHandle, ImageLayout imageLayout, string filePath) {
		using var dumper = DumperFactory.Create(process.Id, GetDumperType());
		return dumper.DumpModule(moduleHandle, imageLayout, filePath);
	}

	DumperType GetDumperType() {
		if (mnuEnableAntiAntiDump.Checked)
			return DumperType.AntiAntiDump;
		return dumperType.Value;
	}

	static string PathInsertPostfix(string path, string postfix) {
		return Path.Combine(Path.GetDirectoryName(path), Path.GetFileNameWithoutExtension(path) + postfix + Path.GetExtension(path));
	}

	static bool IsAntiAntiDumpModule(ModuleInfo module) {
		if (string.IsNullOrEmpty(module.Name))
			return false;
		switch (Path.GetFileNameWithoutExtension(module.Name)) {
		case "00000000":
		case "00000001":
		case "00000002":
		case "00000003":
		case "00000004":
		case "00000100":
		case "00000101":
		case "00000102":
		case "00000103":
		case "00000104":
		case "00000200":
		case "00000201":
		case "00000202":
		case "00000203":
		case "00000204":
		case "00000300":
		case "00000301":
		case "00000302":
		case "00000303":
		case "00000304":
			return true;
		default:
			return module.Name == AntiAntiDump.AADCoreInjector.GetAADCoreModuleNameIfLoaded();
		}
	}
}



================================================
File: ExtremeDumper/Forms/ModulesForm.resx
================================================
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="mnuModulesContext.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="sfdlgDumped.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>193, 17</value>
  </metadata>
</root>


================================================
File: ExtremeDumper/Forms/NativeMethods.cs
================================================
using System.Drawing;
using System.Runtime.InteropServices;

namespace ExtremeDumper.Forms;

static class NativeMethods {
	public const int OBJID_VSCROLL = unchecked((int)0xFFFFFFFB);

	[StructLayout(LayoutKind.Sequential)]
	public unsafe struct SCROLLBARINFO {
		public static readonly uint UnmanagedSize = (uint)Marshal.SizeOf(typeof(SCROLLBARINFO));
		public static SCROLLBARINFO Default = new() { cbSize = UnmanagedSize };

		public uint cbSize;
		public Rectangle rcScrollBar;
		public int dxyLineButton;
		public int xyThumbTop;
		public int xyThumbBottom;
		public int reserved;
		public fixed uint rgstate[6];
	}

	[DllImport("user32.dll", SetLastError = true)]
	[return: MarshalAs(UnmanagedType.Bool)]
	public static extern bool GetScrollBarInfo(nuint hwnd, int idObject, ref SCROLLBARINFO psbi);
}



================================================
File: ExtremeDumper/Forms/ProcessesForm.Designer.cs
================================================
namespace ExtremeDumper.Forms
{
    partial class ProcessesForm
    {
        /// <summary>
        /// 必需的设计器变量。
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// 清理所有正在使用的资源。
        /// </summary>
        /// <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows 窗体设计器生成的代码

        /// <summary>
        /// 设计器支持所需的方法 - 不要修改
        /// 使用代码编辑器修改此方法的内容。
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.lvwProcesses = new System.Windows.Forms.ListView();
            this.chProcessName = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chProcessId = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chCLRModule = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.chProcessPath = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.mnuProcessContext = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.mnuDumpProcess = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuRefreshProcessList = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuViewModules = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuOnlyDotNetProcess = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuInjectDll = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator4 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuGotoLocation = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuMain = new System.Windows.Forms.MenuStrip();
            this.mnuOptions = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuDebugPrivilege = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuDumperType = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator5 = new System.Windows.Forms.ToolStripSeparator();
            this.mnuFastDump = new System.Windows.Forms.ToolStripMenuItem();
            this.fbdlgDumped = new Ookii.Dialogs.WinForms.VistaFolderBrowserDialog();
            this.mnuOpenLoaderHook = new System.Windows.Forms.ToolStripMenuItem();
            this.mnuProcessContext.SuspendLayout();
            this.mnuMain.SuspendLayout();
            this.SuspendLayout();
            // 
            // lvwProcesses
            // 
            this.lvwProcesses.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.lvwProcesses.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.chProcessName,
            this.chProcessId,
            this.chCLRModule,
            this.chProcessPath});
            this.lvwProcesses.ContextMenuStrip = this.mnuProcessContext;
            this.lvwProcesses.Dock = System.Windows.Forms.DockStyle.Fill;
            this.lvwProcesses.FullRowSelect = true;
            this.lvwProcesses.HideSelection = false;
            this.lvwProcesses.Location = new System.Drawing.Point(0, 30);
            this.lvwProcesses.Name = "lvwProcesses";
            this.lvwProcesses.Size = new System.Drawing.Size(933, 607);
            this.lvwProcesses.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.lvwProcesses.TabIndex = 0;
            this.lvwProcesses.UseCompatibleStateImageBehavior = false;
            this.lvwProcesses.View = System.Windows.Forms.View.Details;
            this.lvwProcesses.Resize += new System.EventHandler(this.lvwProcesses_Resize);
            // 
            // chProcessName
            // 
            this.chProcessName.Text = "Name";
            // 
            // chProcessId
            // 
            this.chProcessId.Text = "PID";
            // 
            // chCLRModule
            // 
            this.chCLRModule.Text = "CLR";
            // 
            // chProcessPath
            // 
            this.chProcessPath.Text = "Path";
            // 
            // mnuProcessContext
            // 
            this.mnuProcessContext.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.mnuProcessContext.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mnuDumpProcess,
            this.mnuRefreshProcessList,
            this.mnuViewModules,
            this.toolStripSeparator2,
            this.mnuOnlyDotNetProcess,
            this.toolStripSeparator3,
            this.mnuInjectDll,
            this.toolStripSeparator4,
            this.mnuGotoLocation});
            this.mnuProcessContext.Name = "contextMenuStrip1";
            this.mnuProcessContext.Size = new System.Drawing.Size(251, 178);
            // 
            // mnuDumpProcess
            // 
            this.mnuDumpProcess.Name = "mnuDumpProcess";
            this.mnuDumpProcess.Size = new System.Drawing.Size(250, 26);
            this.mnuDumpProcess.Text = "Dump Selected Process";
            this.mnuDumpProcess.Click += new System.EventHandler(this.mnuDumpProcess_Click);
            // 
            // mnuRefreshProcessList
            // 
            this.mnuRefreshProcessList.Name = "mnuRefreshProcessList";
            this.mnuRefreshProcessList.Size = new System.Drawing.Size(250, 26);
            this.mnuRefreshProcessList.Text = "Refresh";
            this.mnuRefreshProcessList.Click += new System.EventHandler(this.mnuRefreshProcessList_Click);
            // 
            // mnuViewModules
            // 
            this.mnuViewModules.Name = "mnuViewModules";
            this.mnuViewModules.Size = new System.Drawing.Size(250, 26);
            this.mnuViewModules.Text = "View Modules";
            this.mnuViewModules.Click += new System.EventHandler(this.mnuViewModules_Click);
            // 
            // toolStripSeparator2
            // 
            this.toolStripSeparator2.Name = "toolStripSeparator2";
            this.toolStripSeparator2.Size = new System.Drawing.Size(247, 6);
            // 
            // mnuOnlyDotNetProcess
            // 
            this.mnuOnlyDotNetProcess.Checked = true;
            this.mnuOnlyDotNetProcess.CheckOnClick = true;
            this.mnuOnlyDotNetProcess.CheckState = System.Windows.Forms.CheckState.Checked;
            this.mnuOnlyDotNetProcess.Name = "mnuOnlyDotNetProcess";
            this.mnuOnlyDotNetProcess.Size = new System.Drawing.Size(250, 26);
            this.mnuOnlyDotNetProcess.Text = "Only .NET Processes";
            this.mnuOnlyDotNetProcess.Click += new System.EventHandler(this.mnuOnlyDotNetProcess_Click);
            // 
            // toolStripSeparator3
            // 
            this.toolStripSeparator3.Name = "toolStripSeparator3";
            this.toolStripSeparator3.Size = new System.Drawing.Size(247, 6);
            // 
            // mnuInjectDll
            // 
            this.mnuInjectDll.Name = "mnuInjectDll";
            this.mnuInjectDll.Size = new System.Drawing.Size(250, 26);
            this.mnuInjectDll.Text = "Inject Dll";
            this.mnuInjectDll.Click += new System.EventHandler(this.mnuInjectDll_Click);
            // 
            // toolStripSeparator4
            // 
            this.toolStripSeparator4.Name = "toolStripSeparator4";
            this.toolStripSeparator4.Size = new System.Drawing.Size(247, 6);
            // 
            // mnuGotoLocation
            // 
            this.mnuGotoLocation.Name = "mnuGotoLocation";
            this.mnuGotoLocation.Size = new System.Drawing.Size(250, 26);
            this.mnuGotoLocation.Text = "Goto Location";
            this.mnuGotoLocation.Click += new System.EventHandler(this.mnuGotoLocation_Click);
            // 
            // mnuMain
            // 
            this.mnuMain.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.mnuMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mnuOptions,
            this.mnuOpenLoaderHook});
            this.mnuMain.Location = new System.Drawing.Point(0, 0);
            this.mnuMain.Name = "mnuMain";
            this.mnuMain.Padding = new System.Windows.Forms.Padding(7, 3, 0, 3);
            this.mnuMain.Size = new System.Drawing.Size(933, 30);
            this.mnuMain.TabIndex = 1;
            // 
            // mnuOptions
            // 
            this.mnuOptions.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.mnuDebugPrivilege,
            this.toolStripSeparator1,
            this.mnuDumperType,
            this.toolStripSeparator5,
            this.mnuFastDump});
            this.mnuOptions.Name = "mnuOptions";
            this.mnuOptions.Size = new System.Drawing.Size(81, 24);
            this.mnuOptions.Text = "Options";
            // 
            // mnuDebugPrivilege
            // 
            this.mnuDebugPrivilege.Name = "mnuDebugPrivilege";
            this.mnuDebugPrivilege.Size = new System.Drawing.Size(260, 26);
            this.mnuDebugPrivilege.Text = "Enable Debug Privilege";
            this.mnuDebugPrivilege.Click += new System.EventHandler(this.mnuDebugPrivilege_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(257, 6);
            // 
            // mnuDumperType
            // 
            this.mnuDumperType.Name = "mnuDumperType";
            this.mnuDumperType.Size = new System.Drawing.Size(260, 26);
            this.mnuDumperType.Text = "DumperType";
            // 
            // toolStripSeparator5
            // 
            this.toolStripSeparator5.Name = "toolStripSeparator5";
            this.toolStripSeparator5.Size = new System.Drawing.Size(257, 6);
            // 
            // mnuFastDump
            // 
            this.mnuFastDump.CheckOnClick = true;
            this.mnuFastDump.Name = "mnuFastDump";
            this.mnuFastDump.Size = new System.Drawing.Size(260, 26);
            this.mnuFastDump.Text = "Fast Dump";
            // 
            // fbdlgDumped
            // 
            this.fbdlgDumped.Description = "Select a directory to save dumps";
            this.fbdlgDumped.UseDescriptionForTitle = true;
            // 
            // mnuOpenLoaderHook
            // 
            this.mnuOpenLoaderHook.Name = "mnuOpenLoaderHook";
            this.mnuOpenLoaderHook.Size = new System.Drawing.Size(162, 24);
            this.mnuOpenLoaderHook.Text = "Open Loader Hook";
            this.mnuOpenLoaderHook.Click += new System.EventHandler(this.mnuOpenLoaderHook_Click);
            // 
            // ProcessesForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(9F, 20F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(933, 637);
            this.Controls.Add(this.lvwProcesses);
            this.Controls.Add(this.mnuMain);
            this.Font = new System.Drawing.Font("Microsoft YaHei", 9F);
            this.Icon = global::ExtremeDumper.Forms.Resources.Icon;
            this.MainMenuStrip = this.mnuMain;
            this.Name = "ProcessesForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.mnuProcessContext.ResumeLayout(false);
            this.mnuMain.ResumeLayout(false);
            this.mnuMain.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.ListView lvwProcesses;
        private System.Windows.Forms.MenuStrip mnuMain;
        private System.Windows.Forms.ToolStripMenuItem mnuOptions;
        private System.Windows.Forms.ToolStripMenuItem mnuDebugPrivilege;
        private System.Windows.Forms.ToolStripMenuItem mnuDumperType;
        private System.Windows.Forms.ColumnHeader chProcessName;
        private System.Windows.Forms.ColumnHeader chProcessId;
        private System.Windows.Forms.ColumnHeader chCLRModule;
        private System.Windows.Forms.ColumnHeader chProcessPath;
        private System.Windows.Forms.ContextMenuStrip mnuProcessContext;
        private System.Windows.Forms.ToolStripMenuItem mnuDumpProcess;
        private System.Windows.Forms.ToolStripMenuItem mnuViewModules;
        private System.Windows.Forms.ToolStripMenuItem mnuOnlyDotNetProcess;
        private System.Windows.Forms.ToolStripMenuItem mnuRefreshProcessList;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
        private Ookii.Dialogs.WinForms.VistaFolderBrowserDialog fbdlgDumped;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator3;
        private System.Windows.Forms.ToolStripMenuItem mnuInjectDll;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator4;
        private System.Windows.Forms.ToolStripMenuItem mnuGotoLocation;
        private System.Windows.Forms.ToolStripSeparator toolStripSeparator5;
        private System.Windows.Forms.ToolStripMenuItem mnuFastDump;
		private System.Windows.Forms.ToolStripMenuItem mnuOpenLoaderHook;
	}
}




================================================
File: ExtremeDumper/Forms/ProcessesForm.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Principal;
using System.Threading.Tasks;
using System.Windows.Forms;
using ExtremeDumper.Diagnostics;
using ExtremeDumper.Dumping;
using ExtremeDumper.Logging;

namespace ExtremeDumper.Forms;

partial class ProcessesForm : Form {
	static readonly bool IsAdministrator = new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator);
	static bool hasSeDebugPrivilege;

	readonly StrongBox<DumperType> dumperType = new();
	readonly List<ProcessInfo> processes = new();
	readonly TitleComposer title;

	public ProcessesForm() {
		InitializeComponent();
		Utils.ScaleByDpi(this);
		title = new TitleComposer {
			Title = Application.ProductName,
			Version = $"v{Application.ProductVersion}"
		};
		title.Annotations["BITNESS"] = Environment.Is64BitProcess ? "x64" : "x86";
		if (IsAdministrator)
			title.Annotations["ADMIN"] = "Administrator";
		Console.Title = Text = title.Compose(true);
		Utils.EnableDoubleBuffer(lvwProcesses);
		lvwProcesses.ListViewItemSorter = new ListViewItemSorter(lvwProcesses, new[] { TypeCode.String, TypeCode.Int32, TypeCode.String });
		for (var dumperType = DumperType.Normal; dumperType <= DumperType.AntiAntiDump; dumperType++) {
			var item = new ToolStripMenuItem(dumperType.ToString());
			var currentDumperType = dumperType;
			item.Click += (_, _) => SwitchDumperType(currentDumperType);
			mnuDumperType.DropDownItems.Add(item);
		}
		SwitchDumperType(DumperType.Normal);
		RefreshProcessList();
	}

	#region Events
	void mnuDebugPrivilege_Click(object sender, EventArgs e) {
		if (hasSeDebugPrivilege)
			return;

		if (!IsAdministrator) {
			Logger.Error("Please run as administator");
			return;
		}
		try {
			Process.EnterDebugMode();
			hasSeDebugPrivilege = true;
			mnuDebugPrivilege.Checked = true;
			mnuDebugPrivilege.Enabled = false;
			title.Annotations["SE_DEBUG"] = "SeDebugPrivilege";
			Text = title.Compose(true);
			Logger.Info("Succeed");
		}
		catch (Exception ex) {
			Logger.Error("Failed");
			Logger.Exception(ex);
		}
	}

	void mnuOpenLoaderHook_Click(object sender, EventArgs e) {
		new LoaderHookForm().Show();
	}

	void lvwProcesses_Resize(object sender, EventArgs e) {
		lvwProcesses.AutoResizeColumns(true);
	}

	async void mnuDumpProcess_Click(object sender, EventArgs e) {
		if (!TryGetSelectedProcess(out var process))
			return;

		try {
			mnuDumpProcess.Enabled = false;
			title.Annotations["DUMP"] = "Dumping";
			Text = title.Compose(true);
			var path = Path.GetDirectoryName(process.FilePath);
			if (!mnuFastDump.Checked) {
				fbdlgDumped.SelectedPath = path + "\\";
				if (fbdlgDumped.ShowDialog() != DialogResult.OK)
					return;
				path = fbdlgDumped.SelectedPath;
			}
			path = Path.Combine(path, "Dumps");
			int count = await Task.Run(() => DumpProcess(process.Id, path));
			Logger.Info($"{count} images have been dumped to: {path}");
		}
		catch (Exception ex) {
			Logger.Error("Exception occurred while dumping process");
			Logger.Exception(ex);
		}
		finally {
			title.Annotations["DUMP"] = null;
			Text = title.Compose(true);
			mnuDumpProcess.Enabled = true;
		}
	}

	void mnuViewModules_Click(object sender, EventArgs e) {
		if (!TryGetSelectedProcess(out var process))
			return;

		if (IntPtr.Size == 8 && process is DotNetProcessInfo && !process.Is64Bit) {
			Logger.Error("Please run x86 version");
			return;
		}

		new ModulesForm(process, dumperType).Show();
	}

	void mnuRefreshProcessList_Click(object sender, EventArgs e) {
		try {
			title.Annotations["REFRESH"] = "Refreshing";
			Text = title.Compose(true);
			RefreshProcessList();
		}
		finally {
			title.Annotations["REFRESH"] = null;
			Text = title.Compose(true);
		}
	}

	void mnuOnlyDotNetProcess_Click(object sender, EventArgs e) {
		mnuRefreshProcessList_Click(sender, e);
	}

	void mnuInjectDll_Click(object sender, EventArgs e) {
		if (!TryGetSelectedProcess(out var process))
			return;

		new InjectingForm(process).Show();
	}

	void mnuGotoLocation_Click(object sender, EventArgs e) {
		if (!TryGetSelectedProcess(out var process))
			return;

		Process.Start("explorer.exe", $"/select,{process.FilePath}");
	}
	#endregion

	bool TryGetSelectedProcess([NotNullWhen(true)] out ProcessInfo? process) {
		process = null;
		if (lvwProcesses.SelectedIndices.Count == 0)
			return false;

		uint processId = uint.Parse(lvwProcesses.GetFirstSelectedSubItem(chProcessId.Index).Text);
		process = processes.Find(t => t.Id == processId);
		Debug2.Assert(process is not null);
		return true;
	}

	void SwitchDumperType(DumperType dumperType) {
		string name = dumperType.ToString();
		foreach (ToolStripMenuItem item in mnuDumperType.DropDownItems)
			item.Checked = item.Text == name;
		this.dumperType.Value = dumperType;
	}

	void RefreshProcessList() {
		Utils.RefreshListView(lvwProcesses, GetProcesses(), t => CreateListViewItem(t), 10);
	}

	IEnumerable<ProcessInfo> GetProcesses() {
		processes.Clear();
		foreach (var process in ProcessesProviderFactory.Create().EnumerateProcesses()) {
			if (mnuOnlyDotNetProcess.Checked && process is not DotNetProcessInfo)
				continue;
			processes.Add(process);
			yield return process;
		}
	}

	static ListViewItem CreateListViewItem(ProcessInfo process) {
		var listViewItem = new ListViewItem(process.Name);
		// Name
		listViewItem.SubItems.Add(process.Id.ToString());
		// Id
		if (process is DotNetProcessInfo dnProcess)
			listViewItem.SubItems.Add(string.Join(", ", dnProcess.CLRModules.Select(t => t.Name)));
		else
			listViewItem.SubItems.Add(string.Empty);
		// CLR
		listViewItem.SubItems.Add(process.FilePath);
		// Path
		if (IntPtr.Size == 8 && !process.Is64Bit)
			listViewItem.Text += " (32 Bit)";
		if (process is DotNetProcessInfo)
			listViewItem.BackColor = Utils.DotNetColor;
		return listViewItem;
	}

	int DumpProcess(uint processId, string directoryPath) {
		if (!Directory.Exists(directoryPath))
			Directory.CreateDirectory(directoryPath);
		using var dumper = DumperFactory.Create(processId, dumperType.Value);
		return dumper.DumpProcess(directoryPath);
	}
}



================================================
File: ExtremeDumper/Forms/ProcessesForm.resx
================================================
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="lvwProcesses.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="mnuProcessContext.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="mnuMain.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>186, 17</value>
  </metadata>
  <metadata name="mnuMain.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="fbdlgDumped.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>294, 17</value>
  </metadata>
  <metadata name="$this.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>


================================================
File: ExtremeDumper/Forms/Resources.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ExtremeDumper.Forms {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ExtremeDumper.Forms.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Icon similar to (Icon).
        /// </summary>
        internal static System.Drawing.Icon Icon {
            get {
                object obj = ResourceManager.GetObject("Icon", resourceCulture);
                return ((System.Drawing.Icon)(obj));
            }
        }
    }
}



================================================
File: ExtremeDumper/Forms/Resources.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="Icon" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\images\extremedumper.ico;System.Drawing.Icon, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>


================================================
File: ExtremeDumper/Forms/TitleComposer.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ExtremeDumper.Forms;

sealed class TitleComposer {
	static readonly char[] uppercaseLetters = "ÅBĊĎĘḞĢΉÎĴĶḼḾŅÕҎQŖŜTỰṼẂẌẎẐ".ToCharArray();
	static readonly char[] lowercaseLetters = "åbċďęḟģήîĵķḽḿņõҏqŗŝtựṽẃẍẏẑ".ToCharArray();

	public string Title { get; set; } = string.Empty;

	public string? Subtitle { get; set; }

	public string? Version { get; set; }

	public IDictionary<string, string?> Annotations { get; } = new Dictionary<string, string?>();

	public string Compose(bool obfuscate) {
		var sb = new StringBuilder(Title);
		if (!string.IsNullOrEmpty(Subtitle)) {
			sb.Append(" - ");
			sb.Append(Subtitle);
		}
		if (!string.IsNullOrEmpty(Version)) {
			sb.Append(" ");
			sb.Append(Version);
		}
		var annotations = Annotations.Values.Where(t => !string.IsNullOrEmpty(t)).ToArray();
		if (annotations.Length != 0) {
			sb.Append(" (");
			sb.Append(string.Join(", ", annotations));
			sb.Append(')');
		}
		var result = sb.ToString();
		if (obfuscate)
			result = Obfuscate(result);
		return result;
	}

	public static string Compose(bool obfuscate, string title, string? subtitle, string? version, params string?[]? annotations) {
		var titleManager = new TitleComposer {
			Title = title,
			Subtitle = subtitle,
			Version = version
		};
		if (annotations is not null) {
			for (int i = 0; i < annotations.Length; i++) {
				if (!string.IsNullOrEmpty(annotations[i]))
					titleManager.Annotations.Add(i.ToString(), annotations[i]);
			}
		}
		return titleManager.Compose(obfuscate);
	}

	static string Obfuscate(string title) {
		var random = new Random();
		var sb = new StringBuilder(title.Length * 2);
		for (int i = 0; i < title.Length - 1; i++) {
			char c = title[i];
			if ('A' <= c && c <= 'Z')
				sb.Append(uppercaseLetters[c - 'A']);
			else if ('a' <= c && c <= 'z')
				sb.Append(lowercaseLetters[c - 'a']);
			else
				sb.Append(c);
		}
		sb.Append(title[title.Length - 1]);
		return sb.ToString();
	}
}



================================================
File: ExtremeDumper/Forms/Utils.cs
================================================
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ExtremeDumper.Forms;

static class Utils {
	public static Color DotNetColor => Color.YellowGreen;

	public static void EnableDoubleBuffer(ListView listView) {
		typeof(ListView).InvokeMember("DoubleBuffered", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.SetProperty, null, listView, new object[] { true });
	}

	public static void RefreshListView<T>(ListView listView, IEnumerable<T> sources, Func<T, ListViewItem> itemCreator, int layoutInterval) {
		listView.SuspendLayout();
		listView.Items.Clear();

		int c = 0;
		foreach (var source in sources) {
			listView.Items.Add(itemCreator(source));
			if (layoutInterval != -1 && c++ % layoutInterval == 0)
				listView.PerformLayout();
		}

		listView.ResumeLayout();
		listView.AutoResizeColumns(false);
	}

	// Only used with very slow sources
	public static async Task RefreshListViewAsync<T>(ListView listView, IEnumerable<T> sources, Func<T, ListViewItem> itemCreator, int layoutInterval) {
		listView.SuspendLayout();
		listView.Items.Clear();

		var buffer = await Task.Run(() => sources.ToArray());
		int c = 0;
		foreach (var source in buffer) {
			listView.Items.Add(itemCreator(source));
			if (layoutInterval != -1 && c++ % layoutInterval == 0)
				listView.PerformLayout();
		}

		listView.ResumeLayout();
		listView.AutoResizeColumns(false);
	}

	public static void ScaleByDpi(Form form) {
		using var g = Graphics.FromHwnd(IntPtr.Zero);
		var size = form.ClientSize;
		size.Width = (int)(size.Width * (g.DpiX / 96));
		size.Height = (int)(size.Height * (g.DpiY / 96));
		form.ClientSize = size;
	}
}




================================================
File: ExtremeDumper/Injecting/Injector.cs
================================================
namespace ExtremeDumper.Injecting;

/// <summary>
/// 注入时使用的CLR版本
/// </summary>
enum InjectionClrVersion {
	///// <summary>
	///// 自动选择，由要注入的程序集本身决定
	///// </summary>
	//Auto,

	/// <summary>
	/// v2.0.50727
	/// </summary>
	V2 = 1,

	/// <summary>
	/// v4.0.30319
	/// </summary>
	V4
}

/// <summary>
/// Assembly and dll injector
/// </summary>
static class Injector {
	/// <summary>
	/// 注入托管DLL
	/// </summary>
	/// <param name="processId"></param>
	/// <param name="assemblyPath">要注入程序集的路径</param>
	/// <param name="typeName">类型名（命名空间+类型名，比如NamespaceA.ClassB）</param>
	/// <param name="methodName">方法名（比如MethodC），该方法必须具有此类签名static int MethodName(string)，比如private static int InjectingMain(string argument)</param>
	/// <param name="argument">参数，可传入 <see langword="null"/></param>
	/// <param name="clrVersion">使用的CLR版本</param>
	/// <returns></returns>
	public static bool InjectManaged(uint processId, string assemblyPath, string typeName, string methodName, string argument, InjectionClrVersion clrVersion) {
		using var process = NativeSharp.NativeProcess.Open(processId);
		if (process.IsInvalid)
			return false;
		return process.InjectManaged(assemblyPath, typeName, methodName, argument, (NativeSharp.InjectionClrVersion)clrVersion);
	}

	/// <summary>
	/// 注入托管DLL，并获取被调用方法的返回值（警告：被调用方法返回后才能获取到返回值，<see cref="InjectManaged(string, string, string, string, out int)"/>方法将一直等待到被调用方法返回。如果仅注入程序集而不需要获取返回值，请使用重载版本<see cref="InjectManaged(string, string, string, string)"/>）
	/// </summary>
	/// <param name="processId"></param>
	/// <param name="assemblyPath">要注入程序集的路径</param>
	/// <param name="typeName">类型名（命名空间+类型名，比如NamespaceA.ClassB）</param>
	/// <param name="methodName">方法名（比如MethodC），该方法必须具有此类签名static int MethodName(string)，比如private static int InjectingMain(string argument)</param>
	/// <param name="argument">参数，可传入 <see langword="null"/></param>
	/// <param name="clrVersion">使用的CLR版本</param>
	/// <param name="returnValue">被调用方法返回的整数值</param>
	/// <returns></returns>
	public static bool InjectManagedAndWait(uint processId, string assemblyPath, string typeName, string methodName, string argument, InjectionClrVersion clrVersion, out int returnValue) {
		returnValue = 0;
		using var process = NativeSharp.NativeProcess.Open(processId);
		if (process.IsInvalid)
			return false;
		return process.InjectManaged(assemblyPath, typeName, methodName, argument, (NativeSharp.InjectionClrVersion)clrVersion, out returnValue);
	}

	/// <summary>
	/// 注入非托管DLL
	/// </summary>
	/// <param name="processId"></param>
	/// <param name="dllPath">要注入DLL的路径</param>
	/// <returns></returns>
	public static bool InjectUnmanaged(uint processId, string dllPath) {
		using var process = NativeSharp.NativeProcess.Open(processId);
		if (process.IsInvalid)
			return false;
		return process.InjectUnmanaged(dllPath);
	}
}



================================================
File: ExtremeDumper/Logging/ErrorToFileLogger.cs
================================================
using System;
using System.IO;
using System.Text;
using Tool.Logging;

namespace ExtremeDumper.Logging;

sealed class ErrorToFileLogger : ILogger {
	readonly ILogger logger;
	readonly FileStream logFile;

	public LogLevel Level {
		get => logger.Level;
		set => logger.Level = value;
	}

	public bool IsAsync {
		get => logger.IsAsync;
		set => logger.IsAsync = value;
	}

	public bool IsIdle => logger.IsIdle;

	public int QueueCount => logger.QueueCount;

	public bool IsLocked => logger.IsLocked;

	public ErrorToFileLogger(ILogger logger, FileStream logFile) {
		this.logger = logger ?? throw new ArgumentNullException(nameof(logger));
		this.logFile = logFile ?? throw new ArgumentNullException(nameof(logFile));
	}

	public void Info() {
		logger.Info();
	}

	public void Info(string? value) {
		logger.Info(value);
	}

	public void Warning(string? value) {
		WriteFile(value);
		logger.Warning(value);
	}

	public void Error(string? value) {
		WriteFile(value);
		logger.Error(value);
	}

	public void Verbose1(string? value) {
		logger.Verbose1(value);
	}

	public void Verbose2(string? value) {
		logger.Verbose2(value);
	}

	public void Verbose3(string? value) {
		logger.Verbose3(value);
	}

	public void Exception(Exception? value) {
		logger.Exception(value);
	}

	public void Log(string? value, LogLevel level, ConsoleColor? color) {
		logger.Log(value, level, color);
	}

	public void Flush() {
		logger.Flush();
		logFile.Flush();
	}

	public ILogger EnterLock() {
		return logger.EnterLock();
	}

	public ILogger ExitLock() {
		return logger.ExitLock();
	}

	void WriteFile(string? value) {
		value += Environment.NewLine;
		byte[] bytes = Encoding.UTF8.GetBytes(value);
		logFile.Write(bytes, 0, bytes.Length);
	}
}



================================================
File: ExtremeDumper/Logging/Logger.InterpolatedStringHandler.cs
================================================
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Text;
using Tool.Logging;

namespace ExtremeDumper.Logging;

partial class Logger {
	[EditorBrowsable(EditorBrowsableState.Never)]
	[InterpolatedStringHandler]
	public struct Verbose1InterpolatedStringHandler {
		private AppendInterpolatedStringHandler _stringBuilderHandler;

		public Verbose1InterpolatedStringHandler(int literalLength, int formattedCount, out bool shouldAppend) {
			if (Level < LogLevel.Verbose1) {
				_stringBuilderHandler = default;
				shouldAppend = false;
			}
			else {
				_stringBuilderHandler = new AppendInterpolatedStringHandler(literalLength, formattedCount, new StringBuilder());
				shouldAppend = true;
			}
		}

		internal string? ToStringAndClear() {
			string? s = _stringBuilderHandler._stringBuilder?.ToString();
			_stringBuilderHandler = default;
			return s;
		}

		public void AppendLiteral(string value) {
			_stringBuilderHandler.AppendLiteral(value);
		}

		public void AppendFormatted<T>(T value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted<T>(T value, string? format) {
			_stringBuilderHandler.AppendFormatted(value, format);
		}

		public void AppendFormatted<T>(T value, int alignment) {
			_stringBuilderHandler.AppendFormatted(value, alignment);
		}

		public void AppendFormatted<T>(T value, int alignment, string? format) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(string? value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted(string? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(object? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[InterpolatedStringHandler]
	public struct Verbose2InterpolatedStringHandler {
		private AppendInterpolatedStringHandler _stringBuilderHandler;

		public Verbose2InterpolatedStringHandler(int literalLength, int formattedCount, out bool shouldAppend) {
			if (Level < LogLevel.Verbose2) {
				_stringBuilderHandler = default;
				shouldAppend = false;
			}
			else {
				_stringBuilderHandler = new AppendInterpolatedStringHandler(literalLength, formattedCount, new StringBuilder());
				shouldAppend = true;
			}
		}

		internal string? ToStringAndClear() {
			string? s = _stringBuilderHandler._stringBuilder?.ToString();
			_stringBuilderHandler = default;
			return s;
		}

		public void AppendLiteral(string value) {
			_stringBuilderHandler.AppendLiteral(value);
		}

		public void AppendFormatted<T>(T value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted<T>(T value, string? format) {
			_stringBuilderHandler.AppendFormatted(value, format);
		}

		public void AppendFormatted<T>(T value, int alignment) {
			_stringBuilderHandler.AppendFormatted(value, alignment);
		}

		public void AppendFormatted<T>(T value, int alignment, string? format) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(string? value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted(string? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(object? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[InterpolatedStringHandler]
	public struct Verbose3InterpolatedStringHandler {
		private AppendInterpolatedStringHandler _stringBuilderHandler;

		public Verbose3InterpolatedStringHandler(int literalLength, int formattedCount, out bool shouldAppend) {
			if (Level < LogLevel.Verbose3) {
				_stringBuilderHandler = default;
				shouldAppend = false;
			}
			else {
				_stringBuilderHandler = new AppendInterpolatedStringHandler(literalLength, formattedCount, new StringBuilder());
				shouldAppend = true;
			}
		}

		internal string? ToStringAndClear() {
			string? s = _stringBuilderHandler._stringBuilder?.ToString();
			_stringBuilderHandler = default;
			return s;
		}

		public void AppendLiteral(string value) {
			_stringBuilderHandler.AppendLiteral(value);
		}

		public void AppendFormatted<T>(T value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted<T>(T value, string? format) {
			_stringBuilderHandler.AppendFormatted(value, format);
		}

		public void AppendFormatted<T>(T value, int alignment) {
			_stringBuilderHandler.AppendFormatted(value, alignment);
		}

		public void AppendFormatted<T>(T value, int alignment, string? format) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(string? value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted(string? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(object? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[InterpolatedStringHandler]
	struct AppendInterpolatedStringHandler {
		internal readonly StringBuilder _stringBuilder;
		private readonly IFormatProvider? _provider;

		public AppendInterpolatedStringHandler(int literalLength, int formattedCount, StringBuilder stringBuilder) {
			_stringBuilder = stringBuilder;
			_provider = null;
		}

		public AppendInterpolatedStringHandler(int literalLength, int formattedCount, StringBuilder stringBuilder, IFormatProvider? provider) {
			_stringBuilder = stringBuilder;
			_provider = provider;
		}

		public void AppendLiteral(string value) {
			_stringBuilder.Append(value);
		}

		public void AppendFormatted<T>(T value) {
			if (value is IFormattable) {
				_stringBuilder.Append(((IFormattable)value).ToString(format: null, _provider));
			}
			else if (value is not null) {
				_stringBuilder.Append(value.ToString());
			}
		}

		public void AppendFormatted<T>(T value, string? format) {
			if (value is IFormattable) {
				_stringBuilder.Append(((IFormattable)value).ToString(format, _provider));
			}
			else if (value is not null) {
				_stringBuilder.Append(value.ToString());
			}
		}

		public void AppendFormatted<T>(T value, int alignment) {
			AppendFormatted(value, alignment, format: null);
		}

		public void AppendFormatted<T>(T value, int alignment, string? format) {
			if (alignment == 0) {
				AppendFormatted(value, format);
			}
			else if (alignment < 0) {
				int start = _stringBuilder.Length;
				AppendFormatted(value, format);
				int paddingRequired = -alignment - (_stringBuilder.Length - start);
				if (paddingRequired > 0) {
					_stringBuilder.Append(' ', paddingRequired);
				}
			}
			else {
				string s;
				if (value is IFormattable) {
					s = ((IFormattable)value).ToString(format, _provider);
				}
				else {
					s = value?.ToString() ?? string.Empty;
				}
				AppendFormatted(s, alignment);
			}
		}

		public void AppendFormatted(string? value) {
			_stringBuilder.Append(value);
		}

		public void AppendFormatted(string? value, int alignment = 0, string? format = null) {
			AppendFormatted<string?>(value, alignment, format);
		}

		public void AppendFormatted(object? value, int alignment = 0, string? format = null) {
			AppendFormatted<object?>(value, alignment, format);
		}
	}
}



================================================
File: ExtremeDumper/Logging/Logger.cs
================================================
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Text;
using Tool.Logging;

namespace ExtremeDumper.Logging;

static partial class Logger {
	enum StackCrawlMark {
		LookForMyCaller = 1
		// CLR内部实现似乎没有处理LookForMyCallersCaller，枚举值LookForMyCallersCaller无效
	}

	delegate MethodBase InternalGetCurrentMethodDelegate(ref StackCrawlMark stackMark);

	static readonly InternalGetCurrentMethodDelegate internalGetCurrentMethod = CreateInternalGetCurrentMethod();
	static readonly Dictionary<Type, string> typeAliases = GetTypeAliases();

	public static readonly bool CallerNameWithType = false; // Release下由于tailcall的优化，调用堆栈可能是错误的（call xxx变成了jmp xxx）

#if DEBUG
	public const bool BreakOnError = true;
#endif

	public static LogLevel Level { get => Tool.Logging.Logger.Level; set => Tool.Logging.Logger.Level = value; }

	public static bool IsAsync { get => Tool.Logging.Logger.IsAsync; set => Tool.Logging.Logger.IsAsync = value; }

	public static int Indent { get; set; }

	public static void Info() {
		Tool.Logging.Logger.Info();
	}

	public static void Info(string? value, [CallerMemberName] string callerName = "") {
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Info("[Info]      | " + prefix + value);
	}

	public static void Warning(string? value, [CallerMemberName] string callerName = "") {
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Warning("[Warning]   | " + prefix + value);
	}

	public static void Error(string? value, [CallerMemberName] string callerName = "") {
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Error("[Error]     | " + prefix + value);
#if DEBUG
		if (BreakOnError) {
			Flush();
			System.Diagnostics.Debug2.Assert(false);
		}
#endif
	}

	public static void Verbose1(string? value, [CallerMemberName] string callerName = "") {
		if (Level < LogLevel.Verbose1)
			return;
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Verbose1("[Verbose1]  | " + prefix + value);
	}

	public static void Verbose1(ref Verbose1InterpolatedStringHandler value, [CallerMemberName] string callerName = "") {
		string? value2 = value.ToStringAndClear();
		if (value2 is null)
			return;
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Verbose1("[Verbose1]  | " + prefix + value2);
	}

	public static void Verbose2(string? value, [CallerMemberName] string callerName = "") {
		if (Level < LogLevel.Verbose2)
			return;
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Verbose2("[Verbose2]  | " + prefix + value);
	}

	public static void Verbose2(ref Verbose2InterpolatedStringHandler value, [CallerMemberName] string callerName = "") {
		string? value2 = value.ToStringAndClear();
		if (value2 is null)
			return;
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Verbose2("[Verbose2]  | " + prefix + value2);
	}

	public static void Verbose3(string? value, [CallerMemberName] string callerName = "") {
		if (Level < LogLevel.Verbose3)
			return;
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Verbose3("[Verbose3]  | " + prefix + value);
	}

	public static void Verbose3(ref Verbose3InterpolatedStringHandler value, [CallerMemberName] string callerName = "") {
		string? value2 = value.ToStringAndClear();
		if (value2 is null)
			return;
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Verbose3("[Verbose3]  | " + prefix + value2);
	}

	public static void Exception(Exception? value, [CallerMemberName] string callerName = "") {
		string prefix;
		if (CallerNameWithType) {
			var stackMark = StackCrawlMark.LookForMyCaller;
			var caller = internalGetCurrentMethod(ref stackMark);
			prefix = GetPrefix(callerName, caller);
		}
		else {
			prefix = GetPrefix(callerName);
		}
		Tool.Logging.Logger.Error("[Exception] | " + prefix + FormatException(value));
#if DEBUG
		if (BreakOnError) {
			Flush();
			System.Diagnostics.Debug2.Assert(false);
		}
#endif
	}

	public static void Flush() {
		Tool.Logging.Logger.Flush();
	}

	static string GetPrefix(string callerName, MethodBase caller) {
		var type = GetUserType(caller.DeclaringType);
		if (type is not null) {
			var typeName = typeAliases.TryGetValue(type, out var typeAlias) ? typeAlias : type.Name;
			callerName = typeName + "." + callerName;
		}
		return GetPrefix(callerName.ToString());
	}

	static Type? GetUserType(Type? type) {
		if (type is null)
			return null;
		return type.Name.StartsWith("<", StringComparison.Ordinal) ? GetUserType(type.DeclaringType) : type;
	}

	static string GetPrefix(string callerName) {
		return $"{new string(' ', Indent * 2)}[{callerName}] ";
	}

	static string FormatException(Exception? exception) {
		var sb = new StringBuilder();
		DumpException(exception, sb);
		return sb.ToString();
	}

	static void DumpException(Exception? exception, StringBuilder sb) {
		exception ??= new ArgumentNullException(nameof(exception), "<No exception object>");
		sb.AppendLine($"Type: {Environment.NewLine}{exception.GetType().FullName}");
		sb.AppendLine($"Message: {Environment.NewLine}{exception.Message}");
		sb.AppendLine($"Source: {Environment.NewLine}{exception.Source}");
		sb.AppendLine($"StackTrace: {Environment.NewLine}{exception.StackTrace}");
		sb.AppendLine($"TargetSite: {Environment.NewLine}{exception.TargetSite}");
		sb.AppendLine("----------------------------------------");
		if (exception.InnerException is not null)
			DumpException(exception.InnerException, sb);
		if (exception is ReflectionTypeLoadException reflectionTypeLoadException) {
			foreach (var loaderException in reflectionTypeLoadException.LoaderExceptions)
				DumpException(loaderException, sb);
		}
	}

	static InternalGetCurrentMethodDelegate CreateInternalGetCurrentMethod() {
		var dynamicMethod = new DynamicMethod("InternalGetCurrentMethod_Proxy", typeof(MethodBase), new[] { typeof(StackCrawlMark).MakeByRefType() }, typeof(Logger), true);
		var generator = dynamicMethod.GetILGenerator();
		var internalGetCurrentMethod = typeof(MethodBase).Module.GetType("System.Reflection.RuntimeMethodInfo").GetMethod("InternalGetCurrentMethod", BindingFlags.NonPublic | BindingFlags.Static);

		generator.Emit(OpCodes.Ldarg_0);
		generator.Emit(OpCodes.Call, internalGetCurrentMethod);
		generator.Emit(OpCodes.Ret);

		return (InternalGetCurrentMethodDelegate)dynamicMethod.CreateDelegate(typeof(InternalGetCurrentMethodDelegate));
	}

	static Dictionary<Type, string> GetTypeAliases() {
		var aliases = new Dictionary<Type, string>();
		foreach (var type in typeof(Logger).Module.GetTypes()) {
			var attribute = type.GetCustomAttribute<TypeLoggingAliasAttribute>();
			if (attribute is not null)
				aliases.Add(type, attribute.Alias);
		}
		return aliases;
	}
}



================================================
File: ExtremeDumper/Logging/TypeLoggingAliasAttribute.cs
================================================
using System;

namespace ExtremeDumper.Logging;

/// <summary>
/// 记录日志时，方法所在类型的别名
/// </summary>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
sealed class TypeLoggingAliasAttribute : Attribute {
	/// <summary>
	/// 别名
	/// </summary>
	public string Alias { get; }

	/// <summary>
	/// 构造器
	/// </summary>
	/// <param name="alias"></param>
	public TypeLoggingAliasAttribute(string alias) {
		Alias = alias ?? string.Empty;
	}
}



================================================
File: ExtremeDumper/Logging/Internal/AsyncLogger.Core.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace Tool.Logging;

partial class AsyncLogger {
	delegate void LogCallback(string value, LogLevel level, ConsoleColor? color);

	sealed class Context {
		public readonly object LockObj = new();

		public ILogger Creator;
		public volatile ILogger Owner;
		public volatile bool IsLocked;
		public readonly LogCallback Callback;

		public Context(ILogger creator, ILogger owner, LogCallback callback) {
			Creator = creator;
			Owner = owner;
			Callback = callback;
		}
	}

	sealed class LoggerCore {
		static readonly object logLock = new();
		static readonly ManualResetEvent asyncIdleEvent = new(true);
		static readonly Queue<LogItem> asyncQueue = new();
		static readonly object asyncLock = new();
		static readonly Thread asyncWorker = new(AsyncLoop) {
			Name = $"{nameof(AsyncLogger)}.{nameof(AsyncLoop)}",
			IsBackground = true
		};

		readonly Context context;
		LogLevel level;
		volatile bool isAsync;

		public Context Context => context;

		public LogLevel Level {
			get => level;
			set => level = value;
		}

		public bool IsAsync {
			get => isAsync;
			set {
				if (value == isAsync)
					return;

				lock (logLock) {
					isAsync = value;
					if (!value)
						Flush();
				}
			}
		}

		public static bool IsIdle => asyncQueue.Count == 0;

		public static int QueueCount => asyncQueue.Count;

		public LoggerCore(Context context) {
			this.context = context ?? throw new ArgumentNullException(nameof(context));
			level = LogLevel.Info;
			isAsync = true;
		}

		public void Info(ILogger logger) {
			Log(string.Empty, LogLevel.Info, null, logger);
		}

		public void Info(string? value, ILogger logger) {
			Log(value, LogLevel.Info, ConsoleColor.Gray, logger);
		}

		public void Warning(string? value, ILogger logger) {
			Log(value, LogLevel.Warning, ConsoleColor.Yellow, logger);
		}

		public void Error(string? value, ILogger logger) {
			Log(value, LogLevel.Error, ConsoleColor.Red, logger);
		}

		public void Verbose1(string? value, ILogger logger) {
			Log(value, LogLevel.Verbose1, ConsoleColor.DarkGray, logger);
		}

		public void Verbose2(string? value, ILogger logger) {
			Log(value, LogLevel.Verbose2, ConsoleColor.DarkGray, logger);
		}

		public void Verbose3(string? value, ILogger logger) {
			Log(value, LogLevel.Verbose3, ConsoleColor.DarkGray, logger);
		}

		public void Exception(Exception? value, ILogger logger) {
			Error(FormatException(value), logger);
		}

		public void Log(string? value, LogLevel level, ConsoleColor? color, ILogger logger) {
			if (context.IsLocked) {
			relock:
				if (context.Owner != logger) {
					lock (context.LockObj) {
						if (context.Owner != logger) {
							Monitor.Wait(context.LockObj);
							goto relock;
						}
					}
				}
			}

			if (level > Level)
				return;

			value ??= string.Empty;
			lock (logLock) {
				if (isAsync) {
					lock (asyncLock) {
						asyncQueue.Enqueue(new(context.Callback, value, level, color));
						if ((asyncWorker.ThreadState & ThreadState.Unstarted) != 0)
							asyncWorker.Start();
						Monitor.Pulse(asyncLock);
					}
				}
				else {
					context.Callback(value, level, color);
				}
			}
		}

		public static void Flush() {
		retry:
			asyncIdleEvent.WaitOne();
			if (!IsIdle) {
				Thread.Sleep(0);
				goto retry;
			}
			// AsyncLoop的执行线程可能停留在'Monitor.Wait(asyncLock)'这一行代码还没来得及相应
		}

		static void AsyncLoop() {
			var sb = new StringBuilder();
			while (true) {
				lock (asyncLock) {
					if (asyncQueue.Count == 0) {
						asyncIdleEvent.Set();
						Monitor.Wait(asyncLock);
					}
					asyncIdleEvent.Reset();
				}
				// 等待输出被触发

				LogItem[] logItems;
				lock (asyncLock) {
					logItems = asyncQueue.ToArray();
					asyncQueue.Clear();
				}
				var currentsByCallback = logItems.GroupBy(t => t.Callback).Select(t => new Queue<LogItem>(t)).ToArray();
				// 获取全部要输出的内容

				foreach (var currents in currentsByCallback) {
					// 按回调方法分组输出
					foreach (var logItem in currents) {
						if (string.IsNullOrEmpty(logItem.Value))
							logItem.Color = null;
						// 空行是什么颜色不重要，统一设置颜色为null
					}
					var callback = currents.Peek().Callback;
					do {
						var current = currents.Dequeue();
						var color = current.Color;
						sb.Length = 0;
						sb.Append(current.Value);
						while (true) {
							if (currents.Count == 0)
								break;

							var next = currents.Peek();
							if (next.Level != current.Level)
								break;

							if (!color.HasValue && next.Color.HasValue)
								color = next.Color;
							// 空行的颜色是null，获取第一个非null的颜色作为合并日志的颜色
							if (next.Color.HasValue && next.Color != color)
								break;
							// 如果下一行的颜色不是null并且与当前颜色不同，跳出优化

							sb.AppendLine();
							sb.Append(currents.Dequeue().Value);
						}
						// 合并日志等级与颜色相同的，减少重绘带来的性能损失
						callback(sb.ToString(), current.Level, color);
					} while (currents.Count > 0);
				}
			}
		}

		sealed class LogItem {
			public LogCallback Callback;
			public string Value;
			public LogLevel Level;
			public ConsoleColor? Color;

			public LogItem(LogCallback callback, string value, LogLevel level, ConsoleColor? color) {
				Callback = callback;
				Value = value;
				Level = level;
				Color = color;
			}
		}
	}
}



================================================
File: ExtremeDumper/Logging/Internal/AsyncLogger.cs
================================================
using System;
using System.Reflection;
using System.Text;
using System.Threading;

namespace Tool.Logging;

/// <summary>
/// Async logger.
/// In derived class, you must override <see cref="LogCore"/>.
/// </summary>
public partial class AsyncLogger : ILogger {
	readonly LoggerCore core;
	bool isFreed;

	/// <inheritdoc />
	public virtual bool IsLocked => core.Context.IsLocked;

	/// <summary>
	/// Constructor
	/// </summary>
	protected AsyncLogger() {
		core = new LoggerCore(new Context(this, this, LogCore));
	}

	AsyncLogger(LoggerCore core) {
		this.core = core;
	}

	/// <summary>
	/// Immediately write the log without buffer. Derived class must override this method!
	/// </summary>
	/// <param name="value"></param>
	/// <param name="level"></param>
	/// <param name="color"></param>
	protected virtual void LogCore(string value, LogLevel level, ConsoleColor? color) {
		throw new NotImplementedException($"In derived class, you must override '{nameof(LogCore)}'");
	}

	/// <inheritdoc />
	public virtual ILogger EnterLock() {
		CheckFreed();
		var context = core.Context;
		if (this != context.Creator)
			throw new InvalidOperationException("Nested lock is not supported");

		relock:
		lock (context.LockObj) {
			if (context.IsLocked) {
				Monitor.Wait(context.LockObj);
				goto relock;
			}

			context.Owner = new AsyncLogger(core);
			context.IsLocked = true;
			return context.Owner;
		}
	}

	/// <inheritdoc />
	public virtual ILogger ExitLock() {
		CheckFreed();
		var context = core.Context;
		if (context.Creator == this)
			throw new InvalidOperationException("No lock can be exited");

		isFreed = true;
		context.Owner = context.Creator;
		context.IsLocked = false;
		lock (context.LockObj)
			Monitor.PulseAll(context.LockObj);
		return context.Owner;
	}

	/// <summary>
	/// Checks current logger is freed
	/// </summary>
	protected void CheckFreed() {
		if (isFreed)
			throw new InvalidOperationException("Current logger is freed");
	}

	/// <summary>
	/// Format exception
	/// </summary>
	/// <param name="exception"></param>
	/// <returns></returns>
	protected static string FormatException(Exception? exception) {
		var sb = new StringBuilder();
		DumpException(exception, sb);
		return sb.ToString();
	}

	static void DumpException(Exception? exception, StringBuilder sb) {
		exception ??= new ArgumentNullException(nameof(exception), "<No exception object>");
		sb.AppendLine($"Type: {Environment.NewLine}{exception.GetType().FullName}");
		sb.AppendLine($"Message: {Environment.NewLine}{exception.Message}");
		sb.AppendLine($"Source: {Environment.NewLine}{exception.Source}");
		sb.AppendLine($"StackTrace: {Environment.NewLine}{exception.StackTrace}");
		sb.AppendLine($"TargetSite: {Environment.NewLine}{exception.TargetSite}");
		sb.AppendLine("----------------------------------------");
		if (exception.InnerException is not null)
			DumpException(exception.InnerException, sb);
		if (exception is ReflectionTypeLoadException reflectionTypeLoadException) {
			foreach (var loaderException in reflectionTypeLoadException.LoaderExceptions)
				DumpException(loaderException, sb);
		}
	}

	#region forwards
	/// <inheritdoc />
	public virtual LogLevel Level {
		get {
			CheckFreed();
			return core.Level;
		}
		set {
			CheckFreed();
			core.Level = value;
		}
	}

	/// <inheritdoc />
	public virtual bool IsAsync {
		get {
			CheckFreed();
			return core.IsAsync;
		}
		set {
			CheckFreed();
			core.IsAsync = value;
		}
	}

	/// <inheritdoc />
	public virtual bool IsIdle {
		get {
			CheckFreed();
			return LoggerCore.IsIdle;
		}
	}

	/// <inheritdoc />
	public virtual int QueueCount {
		get {
			CheckFreed();
			return LoggerCore.QueueCount;
		}
	}

	/// <inheritdoc />
	public virtual void Info() {
		CheckFreed();
		core.Info(this);
	}

	/// <inheritdoc />
	public virtual void Info(string? value) {
		CheckFreed();
		core.Info(value, this);
	}

	/// <inheritdoc />
	public virtual void Warning(string? value) {
		CheckFreed();
		core.Warning(value, this);
	}

	/// <inheritdoc />
	public virtual void Error(string? value) {
		CheckFreed();
		core.Error(value, this);
	}

	/// <inheritdoc />
	public virtual void Verbose1(string? value) {
		CheckFreed();
		core.Verbose1(value, this);
	}

	/// <inheritdoc />
	public virtual void Verbose2(string? value) {
		CheckFreed();
		core.Verbose2(value, this);
	}

	/// <inheritdoc />
	public virtual void Verbose3(string? value) {
		CheckFreed();
		core.Verbose3(value, this);
	}

	/// <inheritdoc />
	public virtual void Exception(Exception? value) {
		CheckFreed();
		core.Exception(value, this);
	}

	/// <inheritdoc />
	public virtual void Log(string? value, LogLevel level, ConsoleColor? color = null) {
		CheckFreed();
		core.Log(value, level, color, this);
	}

	/// <inheritdoc />
	public virtual void Flush() {
		CheckFreed();
		LoggerCore.Flush();
	}
	#endregion
}



================================================
File: ExtremeDumper/Logging/Internal/DefaultLogger.cs
================================================
using System;
using System.IO;
using System.Text;

namespace Tool.Logging;

/// <summary>
/// Default logger implement
/// </summary>
public sealed class DefaultLogger : AsyncLogger {
	static readonly byte[] Newline = Encoding.ASCII.GetBytes(Environment.NewLine);

	readonly bool writeConsole;
	readonly Stream? stream;
	readonly Encoding? encoding;

	/// <summary>
	/// Logger instance which only writes console
	/// </summary>
	public static ILogger ConsoleOnlyInstance { get; } = new DefaultLogger();

	/// <summary>
	/// Constructor
	/// Do NOT make it public! Multi <see cref="AsyncLogger.LogCallback"/> instances will cause <see cref="AsyncLogger.LoggerCore.AsyncLoop"/> slowly!
	/// </summary>
	DefaultLogger() {
		writeConsole = true;
	}

	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="writeConsole"></param>
	/// <param name="stream"></param>
	public DefaultLogger(bool writeConsole, Stream stream) : this(writeConsole, stream, Encoding.UTF8) {
	}

	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="writeConsole"></param>
	/// <param name="stream"></param>
	/// <param name="encoding"></param>
	public DefaultLogger(bool writeConsole, Stream stream, Encoding encoding) {
		this.writeConsole = writeConsole;
		this.stream = stream ?? throw new ArgumentNullException(nameof(stream));
		this.encoding = encoding ?? throw new ArgumentNullException(nameof(encoding));
	}

	/// <inheritdoc />
	protected override void LogCore(string value, LogLevel level, ConsoleColor? color) {
		if (writeConsole) {
			ConsoleColor oldColor = default;
			if (color.HasValue) {
				oldColor = Console.ForegroundColor;
				Console.ForegroundColor = color.Value;
			}
			Console.WriteLine(value ?? string.Empty);
			if (color.HasValue)
				Console.ForegroundColor = oldColor;
		}
		if (stream is not null) {
			if (!string.IsNullOrEmpty(value)) {
				byte[] bytes = encoding!.GetBytes(value);
				stream.Write(bytes, 0, bytes.Length);
			}
			stream.Write(Newline, 0, Newline.Length);
			stream.Flush();
		}
	}
}



================================================
File: ExtremeDumper/Logging/Internal/ILogger.cs
================================================
using System;

namespace Tool.Logging;

/// <summary>
/// Log level
/// </summary>
public enum LogLevel {
	/// <summary>
	/// Error
	/// </summary>
	Error,

	/// <summary>
	/// Warning
	/// </summary>
	Warning,

	/// <summary>
	/// Information
	/// </summary>
	Info,

	/// <summary>
	/// Verbose infoï¼ˆLevel 1ï¼‰
	/// </summary>
	Verbose1,

	/// <summary>
	/// Verbose infoï¼ˆLevel 2ï¼‰
	/// </summary>
	Verbose2,

	/// <summary>
	/// Verbose infoï¼ˆLevel 3ï¼‰
	/// </summary>
	Verbose3
}

/// <summary>
/// Tool logger interface
/// </summary>
public interface ILogger {
	/// <summary>
	/// Indicates current log level, only logs of which log level greater than or equal to current log level will be logged
	/// </summary>
	LogLevel Level { get; set; }

	/// <summary>
	/// Indicates current logger in running in async mode
	/// </summary>
	bool IsAsync { get; set; }

	/// <summary>
	/// Indicates whether log queue is empty and background logger thread is idle (for async mode)
	/// </summary>
	bool IsIdle { get; }

	/// <summary>
	/// Indicates current enqueued log count (for async mode)
	/// </summary>
	int QueueCount { get; }

	/// <summary>
	/// Indicates whether current logger is locked. If locked, only who owners lock can access current logger
	/// </summary>
	bool IsLocked { get; }

	/// <summary>
	/// Logs empty line
	/// </summary>
	void Info();

	/// <summary>
	/// Logs info and wraps
	/// </summary>
	/// <param name="value"></param>
	void Info(string? value);

	/// <summary>
	/// Logs warning and wraps
	/// </summary>
	/// <param name="value"></param>
	void Warning(string? value);

	/// <summary>
	/// Logs error and wraps
	/// </summary>
	/// <param name="value"></param>
	void Error(string? value);

	/// <summary>
	/// Logs level 1 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	void Verbose1(string? value);

	/// <summary>
	/// Logs level 2 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	void Verbose2(string? value);

	/// <summary>
	/// Logs level 3 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	void Verbose3(string? value);

	/// <summary>
	/// Logs exception and wraps
	/// </summary>
	/// <param name="value"></param>
	void Exception(Exception? value);

	/// <summary>
	/// Logs text with specified color and wraps
	/// </summary>
	/// <param name="value"></param>
	/// <param name="level"></param>
	/// <param name="color"></param>
	void Log(string? value, LogLevel level, ConsoleColor? color = null);

	/// <summary>
	/// Immediately flushes buffer and waits to clear buffer (for async mode)
	/// </summary>
	void Flush();

	/// <summary>
	/// Gets current logger with lock, current logger can be accessd only by the returned child logger
	/// </summary>
	/// <returns></returns>
	ILogger EnterLock();

	/// <summary>
	/// Exits lock mode and returns parent logger
	/// </summary>
	/// <returns></returns>
	ILogger ExitLock();
}



================================================
File: ExtremeDumper/Logging/Internal/Logger.InterpolatedStringHandler.cs
================================================
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Text;

namespace Tool.Logging;

partial class Logger {
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
	[EditorBrowsable(EditorBrowsableState.Never)]
	[InterpolatedStringHandler]
	public struct Verbose1InterpolatedStringHandler {
		private AppendInterpolatedStringHandler _stringBuilderHandler;

		public Verbose1InterpolatedStringHandler(int literalLength, int formattedCount, out bool shouldAppend) {
			if (Level < LogLevel.Verbose1) {
				_stringBuilderHandler = default;
				shouldAppend = false;
			}
			else {
				_stringBuilderHandler = new AppendInterpolatedStringHandler(literalLength, formattedCount, new StringBuilder());
				shouldAppend = true;
			}
		}

		internal string? ToStringAndClear() {
			string? s = _stringBuilderHandler._stringBuilder?.ToString();
			_stringBuilderHandler = default;
			return s;
		}

		public void AppendLiteral(string value) {
			_stringBuilderHandler.AppendLiteral(value);
		}

		public void AppendFormatted<T>(T value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted<T>(T value, string? format) {
			_stringBuilderHandler.AppendFormatted(value, format);
		}

		public void AppendFormatted<T>(T value, int alignment) {
			_stringBuilderHandler.AppendFormatted(value, alignment);
		}

		public void AppendFormatted<T>(T value, int alignment, string? format) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(string? value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted(string? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(object? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[InterpolatedStringHandler]
	public struct Verbose2InterpolatedStringHandler {
		private AppendInterpolatedStringHandler _stringBuilderHandler;

		public Verbose2InterpolatedStringHandler(int literalLength, int formattedCount, out bool shouldAppend) {
			if (Level < LogLevel.Verbose2) {
				_stringBuilderHandler = default;
				shouldAppend = false;
			}
			else {
				_stringBuilderHandler = new AppendInterpolatedStringHandler(literalLength, formattedCount, new StringBuilder());
				shouldAppend = true;
			}
		}

		internal string? ToStringAndClear() {
			string? s = _stringBuilderHandler._stringBuilder?.ToString();
			_stringBuilderHandler = default;
			return s;
		}

		public void AppendLiteral(string value) {
			_stringBuilderHandler.AppendLiteral(value);
		}

		public void AppendFormatted<T>(T value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted<T>(T value, string? format) {
			_stringBuilderHandler.AppendFormatted(value, format);
		}

		public void AppendFormatted<T>(T value, int alignment) {
			_stringBuilderHandler.AppendFormatted(value, alignment);
		}

		public void AppendFormatted<T>(T value, int alignment, string? format) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(string? value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted(string? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(object? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[InterpolatedStringHandler]
	public struct Verbose3InterpolatedStringHandler {
		private AppendInterpolatedStringHandler _stringBuilderHandler;

		public Verbose3InterpolatedStringHandler(int literalLength, int formattedCount, out bool shouldAppend) {
			if (Level < LogLevel.Verbose3) {
				_stringBuilderHandler = default;
				shouldAppend = false;
			}
			else {
				_stringBuilderHandler = new AppendInterpolatedStringHandler(literalLength, formattedCount, new StringBuilder());
				shouldAppend = true;
			}
		}

		internal string? ToStringAndClear() {
			string? s = _stringBuilderHandler._stringBuilder?.ToString();
			_stringBuilderHandler = default;
			return s;
		}

		public void AppendLiteral(string value) {
			_stringBuilderHandler.AppendLiteral(value);
		}

		public void AppendFormatted<T>(T value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted<T>(T value, string? format) {
			_stringBuilderHandler.AppendFormatted(value, format);
		}

		public void AppendFormatted<T>(T value, int alignment) {
			_stringBuilderHandler.AppendFormatted(value, alignment);
		}

		public void AppendFormatted<T>(T value, int alignment, string? format) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(string? value) {
			_stringBuilderHandler.AppendFormatted(value);
		}

		public void AppendFormatted(string? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}

		public void AppendFormatted(object? value, int alignment = 0, string? format = null) {
			_stringBuilderHandler.AppendFormatted(value, alignment, format);
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[InterpolatedStringHandler]
	struct AppendInterpolatedStringHandler {
		internal readonly StringBuilder _stringBuilder;
		private readonly IFormatProvider? _provider;

		public AppendInterpolatedStringHandler(int literalLength, int formattedCount, StringBuilder stringBuilder) {
			_stringBuilder = stringBuilder;
			_provider = null;
		}

		public AppendInterpolatedStringHandler(int literalLength, int formattedCount, StringBuilder stringBuilder, IFormatProvider? provider) {
			_stringBuilder = stringBuilder;
			_provider = provider;
		}

		public void AppendLiteral(string value) {
			_stringBuilder.Append(value);
		}

		public void AppendFormatted<T>(T value) {
			if (value is IFormattable) {
				_stringBuilder.Append(((IFormattable)value).ToString(format: null, _provider));
			}
			else if (value is not null) {
				_stringBuilder.Append(value.ToString());
			}
		}

		public void AppendFormatted<T>(T value, string? format) {
			if (value is IFormattable) {
				_stringBuilder.Append(((IFormattable)value).ToString(format, _provider));
			}
			else if (value is not null) {
				_stringBuilder.Append(value.ToString());
			}
		}

		public void AppendFormatted<T>(T value, int alignment) {
			AppendFormatted(value, alignment, format: null);
		}

		public void AppendFormatted<T>(T value, int alignment, string? format) {
			if (alignment == 0) {
				AppendFormatted(value, format);
			}
			else if (alignment < 0) {
				int start = _stringBuilder.Length;
				AppendFormatted(value, format);
				int paddingRequired = -alignment - (_stringBuilder.Length - start);
				if (paddingRequired > 0) {
					_stringBuilder.Append(' ', paddingRequired);
				}
			}
			else {
				string s;
				if (value is IFormattable) {
					s = ((IFormattable)value).ToString(format, _provider);
				}
				else {
					s = value?.ToString() ?? string.Empty;
				}
				AppendFormatted(s, alignment);
			}
		}

		public void AppendFormatted(string? value) {
			_stringBuilder.Append(value);
		}

		public void AppendFormatted(string? value, int alignment = 0, string? format = null) {
			AppendFormatted<string?>(value, alignment, format);
		}

		public void AppendFormatted(object? value, int alignment = 0, string? format = null) {
			AppendFormatted<object?>(value, alignment, format);
		}
	}
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
}



================================================
File: ExtremeDumper/Logging/Internal/Logger.cs
================================================
using System;

namespace Tool.Logging;

/// <summary>
/// Global logger
/// </summary>
public static partial class Logger {
	/// <summary>
	/// Gets current logger implement
	/// </summary>
	/// <returns></returns>
	public static ILogger Impl => ExternImpl ?? DefaultImpl;

	/// <summary>
	/// Gets default logger implement
	/// </summary>
	public static ILogger DefaultImpl => DefaultLogger.ConsoleOnlyInstance;

	/// <summary>
	/// Gets or sets customized logger
	/// </summary>
	public static ILogger? ExternImpl { get; set; }

	/// <summary>
	/// Indicates current log level, only logs of which log level greater than or equal to current log level will be logged
	/// </summary>
	public static LogLevel Level { get => Impl.Level; set => Impl.Level = value; }

	/// <summary>
	/// Indicates current logger in running in async mode
	/// </summary>
	public static bool IsAsync { get => Impl.IsAsync; set => Impl.IsAsync = value; }

	/// <summary>
	/// Indicates whether log queue is empty and background logger thread is idle (for async mode)
	/// </summary>
	public static bool IsIdle => Impl.IsIdle;

	/// <summary>
	/// Indicates current enqueued log count (for async mode)
	/// </summary>
	public static int QueueCount => Impl.QueueCount;

	/// <summary>
	/// Indicates whether current logger is locked. If locked, only who owners lock can access current logger
	/// </summary>
	public static bool IsLocked => Impl.IsLocked;

	/// <summary>
	/// Logs empty line
	/// </summary>
	public static void Info() { Impl.Info(); }

	/// <summary>
	/// Logs info and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Info(string? value) { Impl.Info(value); }

	/// <summary>
	/// Logs warning and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Warning(string? value) { Impl.Warning(value); }

	/// <summary>
	/// Logs error and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Error(string? value) { Impl.Error(value); }

	/// <summary>
	/// Logs level 1 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Verbose1(string? value) { Impl.Verbose1(value); }

	/// <summary>
	/// Logs level 1 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Verbose1(ref Verbose1InterpolatedStringHandler value) { var s = value.ToStringAndClear(); if (s is not null) Impl.Verbose1(s); }

	/// <summary>
	/// Logs level 2 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Verbose2(string? value) { Impl.Verbose2(value); }

	/// <summary>
	/// Logs level 2 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Verbose2(ref Verbose2InterpolatedStringHandler value) { var s = value.ToStringAndClear(); if (s is not null) Impl.Verbose2(s); }

	/// <summary>
	/// Logs level 3 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Verbose3(string? value) { Impl.Verbose3(value); }

	/// <summary>
	/// Logs level 3 verbose info and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Verbose3(ref Verbose3InterpolatedStringHandler value) { var s = value.ToStringAndClear(); if (s is not null) Impl.Verbose3(s); }

	/// <summary>
	/// Logs exception and wraps
	/// </summary>
	/// <param name="value"></param>
	public static void Exception(Exception? value) { Impl.Exception(value); }

	/// <summary>
	/// Logs text with specified color and wraps
	/// </summary>
	/// <param name="value"></param>
	/// <param name="level"></param>
	/// <param name="color"></param>
	public static void Log(string? value, LogLevel level, ConsoleColor? color = null) { Impl.Log(value, level, color); }

	/// <summary>
	/// Immediately flushes buffer and waits to clear buffer (for async mode)
	/// </summary>
	public static void Flush() { Impl.Flush(); }

	/// <summary>
	/// Gets current logger with lock, current logger can be accessd only by the returned sub logger
	/// </summary>
	/// <returns></returns>
	public static ILogger EnterLock() { return Impl.EnterLock(); }

	/// <summary>
	/// Exits lock mode and returns parent logger
	/// </summary>
	/// <returns></returns>
	public static ILogger ExitLock() { return Impl.ExitLock(); }
}



================================================
File: ExtremeDumper/Logging/Internal/NullLogger.cs
================================================
using System;

namespace Tool.Logging;

/// <summary>
/// Null logger implement which won't output any information
/// </summary>
public sealed class NullLogger : ILogger {
	/// <summary>
	/// Null logger instance
	/// </summary>
	public static ILogger Instance { get; } = new NullLogger();
	NullLogger() { }
	LogLevel ILogger.Level { get => LogLevel.Info; set { } }
	bool ILogger.IsAsync { get => false; set { } }
	bool ILogger.IsIdle => true;
	int ILogger.QueueCount => 0;
	bool ILogger.IsLocked => false;
	void ILogger.Info() { }
	void ILogger.Info(string? value) { }
	void ILogger.Warning(string? value) { }
	void ILogger.Error(string? value) { }
	void ILogger.Verbose1(string? value) { }
	void ILogger.Verbose2(string? value) { }
	void ILogger.Verbose3(string? value) { }
	void ILogger.Exception(Exception? value) { }
	void ILogger.Log(string? value, LogLevel level, ConsoleColor? color) { }
	void ILogger.Flush() { }
	ILogger ILogger.EnterLock() { return this; }
	ILogger ILogger.ExitLock() { return this; }
}



================================================
File: ExtremeDumper/System/Array2.cs
================================================
namespace System;

static class Array2 {
	public static T[] Empty<T>() {
		return EmptyArray<T>.Value;
	}

	static class EmptyArray<T> {
#pragma warning disable CA1825
		public static readonly T[] Value = new T[0];
#pragma warning restore CA1825
	}
}



================================================
File: ExtremeDumper/System/HandleProcessCorruptedStateExceptionsAttribute.cs
================================================
#if !NET40_OR_GREATER
namespace System.Runtime.ExceptionServices;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
sealed class HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
#endif



================================================
File: ExtremeDumper/System/InterpolatedStringHandlerAttribute.cs
================================================
#if !NET6_0_OR_GREATER
namespace System.Runtime.CompilerServices;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
sealed class InterpolatedStringHandlerAttribute : Attribute {
	public InterpolatedStringHandlerAttribute() {
	}
}
#endif



================================================
File: ExtremeDumper/System/NRT.cs
================================================
#if NETFRAMEWORK || NETSTANDARD2_0
namespace System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
sealed class NotNullWhenAttribute : Attribute {
	public bool ReturnValue { get; }

	public NotNullWhenAttribute(bool returnValue) {
		ReturnValue = returnValue;
	}
}

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
sealed class DoesNotReturnAttribute : Attribute {
	public DoesNotReturnAttribute() {
	}
}

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
sealed class DoesNotReturnIfAttribute : Attribute {
	public bool ParameterValue { get; }

	public DoesNotReturnIfAttribute(bool parameterValue) {
		ParameterValue = parameterValue;
	}
}
#endif



================================================
File: ExtremeDumper/System/NRT_Helpers.cs
================================================
using System.Diagnostics.CodeAnalysis;

namespace System.Diagnostics;

static class Debug2 {
	[Conditional("DEBUG")]
	public static void Assert([DoesNotReturnIf(false)] bool condition) {
		Debug.Assert(condition);
	}

	[Conditional("DEBUG")]
	public static void Assert([DoesNotReturnIf(false)] bool condition, string? message) {
		Debug.Assert(condition, message);
	}
}



================================================
File: ExtremeDumper-x86/ExtremeDumper-x86.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<UseWindowsForms>true</UseWindowsForms>
		<Description>.NET Assemblies Dumper</Description>
		<ApplicationIcon>..\ExtremeDumper\Images\ExtremeDumper.ico</ApplicationIcon>
	</PropertyGroup>
	<PropertyGroup>
		<TargetFramework>net462</TargetFramework>
		<PlatformTarget>x86</PlatformTarget>
		<OutputType>Exe</OutputType>
		<OutputPath>..\bin\$(Configuration)</OutputPath>
		<ApplicationManifest>app.manifest</ApplicationManifest>
	</PropertyGroup>
	<ItemGroup>
		<PackageReference Include="Costura.Fody" Version="4.1.0" />
	</ItemGroup>
	<Target Name="ClearReferenceCopyLocalPaths" AfterTargets="ResolveAssemblyReferences">
		<ItemGroup>
			<ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" />
		</ItemGroup>
	</Target>
	<Import Project="..\ExtremeDumper.Common.props" />
	<ItemGroup>
		<ProjectReference Include="..\ExtremeDumper\ExtremeDumper.csproj" />
	</ItemGroup>
</Project>



================================================
File: ExtremeDumper-x86/FodyWeavers.xml
================================================
<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
	<Costura IncludeDebugSymbols='false' IncludeAssemblies='ExtremeDumper' />
</Weavers>



================================================
File: ExtremeDumper-x86/Program.cs
================================================
using System;

namespace ExtremeDumper_x86;

static class Program {
	[STAThread]
	static void Main() {
		ExtremeDumper.Program.Main();
	}
}



================================================
File: ExtremeDumper-x86/app.manifest
================================================
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <!-- UAC Manifest Options
             If you want to change the Windows User Account Control level replace the 
             requestedExecutionLevel node with one of the following.

        <requestedExecutionLevel  level="asInvoker" uiAccess="false" />
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
        <requestedExecutionLevel  level="highestAvailable" uiAccess="false" />

            Specifying requestedExecutionLevel element will disable file and registry virtualization. 
            Remove this element if your application requires this virtualization for backwards
            compatibility.
        -->
        <requestedExecutionLevel level="asInvoker" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>

  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- A list of the Windows versions that this application has been tested on
           and is designed to work with. Uncomment the appropriate elements
           and Windows will automatically select the most compatible environment. -->

      <!-- Windows Vista -->
      <!--<supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}" />-->

      <!-- Windows 7 -->
      <!--<supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}" />-->

      <!-- Windows 8 -->
      <!--<supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}" />-->

      <!-- Windows 8.1 -->
      <!--<supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}" />-->

      <!-- Windows 10 -->
      <!--<supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />-->

    </application>
  </compatibility>

  <!-- Indicates that the application is DPI-aware and will not be automatically scaled by Windows at higher
       DPIs. Windows Presentation Foundation (WPF) applications are automatically DPI-aware and do not need 
       to opt in. Windows Forms applications targeting .NET Framework 4.6 that opt into this setting, should 
       also set the 'EnableWindowsFormsHighDpiAutoResizing' setting to 'true' in their app.config. 
       
       Makes the application long-path aware. See https://docs.microsoft.com/windows/win32/fileio/maximum-file-path-limitation -->
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
      <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
    </windowsSettings>
  </application>

  <!-- Enable themes for Windows common controls and dialogs (Windows XP and later) -->
  <!--
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="*"
          publicKeyToken="6595b64144ccf1df"
          language="*"
        />
    </dependentAssembly>
  </dependency>
  -->

</assembly>



================================================
File: ExtremeDumper.AntiAntiDump/AADClient.cs
================================================
using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.IO.Pipes;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// Anti anti dump client
/// </summary>
public sealed class AADClient : AADPipe {
	AADClient[]? multiDomainClients;
	readonly AADClient? mainClient;
	RuntimeInfo? runtimeInfoCache;
	AppDomainInfo? domainInfoCache;

	/// <summary>
	/// Current runtime info
	/// </summary>
	public RuntimeInfo Runtime {
		get {
			if (!GetRuntimeInfo(out var result))
				throw new InvalidOperationException();
			return result;
		}
	}

	/// <summary>
	/// Current application domain info
	/// </summary>
	public AppDomainInfo Domain {
		get {
			if (!GetAppDomainInfo(out var result))
				throw new InvalidOperationException();
			return result;
		}
	}

	AADClient(NamedPipeClientStream stream, AADClient? mainClient) : base(stream) {
		this.mainClient = mainClient;
	}

	/// <summary>
	/// Create a anti anti dump client
	/// </summary>
	/// <param name="pipeName">Name of named pipe stream</param>
	/// <returns></returns>
	public static AADClient? Create(string pipeName) {
		return Create(pipeName, null);
	}

	static AADClient? Create(string pipeName, AADClient? mainClient) {
		if (string.IsNullOrEmpty(pipeName))
			return null;

		try {
			var stream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut);
			return new AADClient(stream, mainClient);
		}
		catch {
			return null;
		}
	}

	/// <summary>
	/// Connects to a waiting server with an infinite time-out value.
	/// </summary>
	/// <returns></returns>
	public bool Connect() {
		return Connect(-1);
	}

	/// <summary>
	/// Connects to a waiting server within the specified time-out period.
	/// </summary>
	/// <param name="timeout">The number of milliseconds to wait for the server to respond before the connection times out.</param>
	/// <returns></returns>
	public bool Connect(int timeout) {
		if (IsConnected)
			return true;
		try {
			var stream = (NamedPipeClientStream)base.stream;
			stream.Connect(timeout);
		}
		catch {
		}
		return IsConnected;
	}

	/// <summary>
	/// Disconnect from server
	/// </summary>
	public void Disconnect() {
		Dispose();
	}

	/// <summary>
	/// Create <see cref="AADServer"/>s in other application domains and get corresponding <see cref="AADClient"/>s
	/// </summary>
	/// <param name="clients"></param>
	/// <returns></returns>
	public bool EnableMultiDomain(out AADClient[] clients) {
		if (mainClient is not null) {
			Debug2.Assert(false, "do NOT call EnableMultiDomain in sub AADClient");
			clients = Array2.Empty<AADClient>();
			return false;
		}

		if (multiDomainClients is not null) {
			foreach (var client in multiDomainClients)
				Debug2.Assert(client.IsConnected);
			clients = multiDomainClients;
			return true;
		}

		clients = Array2.Empty<AADClient>();
		if (!Invoke<Handlers.EnableMultiDomainHandler.PipeNames>(AADCommand.EnableMultiDomain, EmptySerializable.Instance, out var pipeNames))
			return false;
		clients = new AADClient[pipeNames.Values.Length];
		for (int i = 0; i < clients.Length; i++) {
			var client = Create(pipeNames.Values[i], this);
			if (client is null)
				return false;
			clients[i] = client;
		}
		multiDomainClients = clients;
		return true;
	}

	/// <summary>
	/// Get runtime info
	/// </summary>
	/// <param name="runtimeInfo"></param>
	/// <returns></returns>
	bool GetRuntimeInfo([NotNullWhen(true)] out RuntimeInfo? runtimeInfo) {
		if (mainClient is not null)
			return mainClient.GetRuntimeInfo(out runtimeInfo);

		runtimeInfo = null;
		if (runtimeInfoCache is null) {
			if (!Invoke(AADCommand.GetRuntimeInfo, EmptySerializable.Instance, out runtimeInfoCache))
				return false;
		}
		runtimeInfo = runtimeInfoCache;
		return true;
	}

	/// <summary>
	/// Get application domain info
	/// </summary>
	/// <param name="runtimeInfo"></param>
	/// <returns></returns>
	bool GetAppDomainInfo([NotNullWhen(true)] out AppDomainInfo? domainInfo) {
		domainInfo = null;
		if (domainInfoCache is null) {
			if (!Invoke(AADCommand.GetAppDomainInfo, EmptySerializable.Instance, out domainInfoCache))
				return false;
		}
		domainInfo = domainInfoCache;
		return true;
	}

	/// <summary>
	/// Get all modules
	/// </summary>
	/// <param name="modules"></param>
	/// <returns></returns>
	public bool GetModules([NotNullWhen(true)] out ModuleInfos? modules) {
		return Invoke(AADCommand.GetModules, EmptySerializable.Instance, out modules);
	}

	/// <summary>
	/// Get metadata of <paramref name="module"/>
	/// </summary>
	/// <param name="module"></param>
	/// <param name="metadataInfo"></param>
	/// <returns></returns>
	public bool GetMetadataInfo(ModuleInfo module, [NotNullWhen(true)] out MetadataInfo? metadataInfo) {
		return Invoke(AADCommand.GetMetadataInfo, module, out metadataInfo);
	}

	/// <summary>
	/// Get PE info of <paramref name="module"/>
	/// </summary>
	/// <param name="module"></param>
	/// <param name="peInfo"></param>
	/// <returns></returns>
	public bool GetPEInfo(ModuleInfo module, [NotNullWhen(true)] out PEInfo? peInfo) {
		return Invoke(AADCommand.GetPEInfo, module, out peInfo);
	}

	bool Invoke<T>(AADCommand command, ISerializable parameters, [NotNullWhen(true)] out T? result) where T : class, ISerializable {
		result = null;
		if (!IsConnected)
			return false;
		var r = InvokeOne(command, parameters, out var result2);
		Debug2.Assert(r != ExecutionResult.UnknownCommand);
		// internal error, we should fix it
		switch (r) {
		case ExecutionResult.IOError:
		case ExecutionResult.Disconnect:
			Disconnect();
			return false;
		case ExecutionResult.Success:
			result = result2 as T;
			return result is not null;
		default:
			return false;
		}
	}

	/// <summary>
	/// Invoke one specified command with parameters
	/// </summary>
	/// <param name="command"></param>
	/// <param name="parameters"></param>
	/// <param name="result"></param>
	/// <returns></returns>
	/// <remarks>See executor: <seealso cref="AADServer.ExecuteOne"/></remarks>
	ExecutionResult InvokeOne(AADCommand command, ISerializable parameters, out ISerializable? result) {
		result = null;
		try {
			if (!CommandHandlerManager.Handlers.TryGetValue(command, out var handler)) {
				Debug2.Assert(false);
				return ExecutionResult.UnknownCommand;
			}
			// phase 1: get the handler corresponding to the command

			WriteCommand(command);
			Write(parameters);
			// phase 2: write parameters to stream

			ReadCommand(out var resultCommand);
			if (resultCommand == AADCommand.UnhandledException) {
				var exception = new AADServerInvocationException();
				Read(exception);
				throw exception;
			}
			if (resultCommand != AADCommand.Success)
				return ExecutionResult.Failure;
			// phase 3: read execution result

			result = Activator.CreateInstance(handler.ResultType, true) as ISerializable;
			if (result is null)
				throw new InvalidOperationException("Can't create result object");
			// phase 4: create result instance

			Read(result);
			// phase 5: read result from stream

			return ExecutionResult.Success;
		}
		catch (AADServerInvocationException) {
			throw;
		}
		catch (Exception ex) {
			Debug2.Assert(ex is IOException);
			// regard all unhandable exceptions as IO error
			return ExecutionResult.IOError;
		}
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/AADClients.cs
================================================
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// <see cref="AADClient"/> aggregator used for <see cref="AADCommand.EnableMultiDomain"/>
/// </summary>
public sealed class AADClients : IEnumerable<AADClient>, IDisposable {
	readonly List<AADClient> clients = new();

	/// <summary>
	/// Are all client connected
	/// </summary>
	public bool IsConnected {
		get {
			if (clients.Count == 0)
				return false;
			foreach (var client in clients) {
				if (!client.IsConnected)
					return false;
			}
			return true;
		}
	}

	/// <summary>
	/// Current runtime info
	/// </summary>
	public RuntimeInfo Runtime => clients.Count != 0 ? clients[0].Runtime : throw new InvalidOperationException();

	/// <summary>
	/// All application domain infos
	/// </summary>
	public IEnumerable<AppDomainInfo> Domains {
		get {
			foreach (var client in clients)
				yield return client.Domain;
		}
	}

	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="client"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public AADClients(AADClient client) {
		if (client is null)
			throw new ArgumentNullException(nameof(client));

		clients.Add(client);
	}

	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="clients"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public AADClients(IEnumerable<AADClient> clients) {
		if (clients is null)
			throw new ArgumentNullException(nameof(clients));

		this.clients.AddRange(clients);
		Debug2.Assert(this.clients.Count != 0);
	}

	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="mainClient"></param>
	/// <param name="otherClients"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public AADClients(AADClient mainClient, IEnumerable<AADClient> otherClients) {
		if (mainClient is null)
			throw new ArgumentNullException(nameof(mainClient));
		if (otherClients is null)
			throw new ArgumentNullException(nameof(otherClients));

		clients.Add(mainClient);
		clients.AddRange(otherClients);
	}

	/// <summary>
	/// Use <paramref name="mainClient"/> as trampoline to enable multi domain mode
	/// </summary>
	/// <param name="mainClient"></param>
	/// <returns></returns>
	public static AADClients AsMultiDomain(AADClient mainClient) {
		if (mainClient is null)
			throw new ArgumentNullException(nameof(mainClient));

		Debug2.Assert(mainClient.IsConnected);
		if (mainClient.Runtime.Flavor != RuntimeFlavor.Framework)
			return new AADClients(mainClient);
		if (!mainClient.EnableMultiDomain(out var otherClients))
			throw new InvalidOperationException("Can't enable multi application domains mode");
		return new AADClients(mainClient, otherClients);
	}

	/// <summary>
	/// Call <see cref="AADClient.Connect"/> for all <see cref="AADClient"/>s
	/// </summary>
	/// <param name="timeout"></param>
	public bool ConnectAll(int timeout) {
		if (clients.Count == 0)
			return false;
		foreach (var client in clients) {
			if (!client.Connect(timeout))
				return false;
		}
		return true;
	}

	/// <summary>
	/// Call <see cref="AADClient.Disconnect"/> for all <see cref="AADClient"/>s
	/// </summary>
	public void DisconnectAll() {
		Dispose();
	}

	/// <summary>
	/// Get all modules
	/// </summary>
	/// <param name="modules"></param>
	/// <returns></returns>
	public bool GetModules([NotNullWhen(true)] out ModuleInfos? modules) {
		modules = null;
		var buffer = new ModuleInfos();
		foreach (var client in clients) {
			if (!client.GetModules(out var t))
				return false;
			buffer.AddRange(t);
		}
		modules = buffer;
		return true;
	}

	/// <summary>
	/// Get metadata of <paramref name="module"/>
	/// </summary>
	/// <param name="module"></param>
	/// <param name="metadataInfo"></param>
	/// <returns></returns>
	public bool GetMetadataInfo(ModuleInfo module, [NotNullWhen(true)] out MetadataInfo? metadataInfo) {
		metadataInfo = null;
		var client = FindClient(module.DomainId);
		return client is not null && client.GetMetadataInfo(module, out metadataInfo);
	}

	/// <summary>
	/// Get PE info of <paramref name="module"/>
	/// </summary>
	/// <param name="module"></param>
	/// <param name="peInfo"></param>
	/// <returns></returns>
	public bool GetPEInfo(ModuleInfo module, [NotNullWhen(true)] out PEInfo? peInfo) {
		peInfo = null;
		var client = FindClient(module.DomainId);
		return client is not null && client.GetPEInfo(module, out peInfo);
	}

	AADClient? FindClient(uint domainId) {
		if (clients.Count == 0)
			return null;
		foreach (var client in clients) {
			Debug2.Assert(client.IsConnected);
			if (client.Domain.Id == domainId)
				return client;
		}
		Debug2.Assert(false);
		return null;
	}

	/// <inheritdoc/>
	public IEnumerator<AADClient> GetEnumerator() {
		return clients.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator() {
		return ((IEnumerable)clients).GetEnumerator();
	}

	/// <inheritdoc/>
	public void Dispose() {
		foreach (var client in clients)
			client.Dispose();
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/AADCommand.cs
================================================
namespace ExtremeDumper.AntiAntiDump;

enum AADCommand : uint {
	Invalid,

	Disconnect,
	EnableMultiDomain,
	GetAppDomainInfo,
	GetRuntimeInfo,
	GetModules,
	GetMetadataInfo,
	GetPEInfo,
	// Client -> Server

	Success = ushort.MaxValue + 1,
	Failure,
	UnhandledException,
	// Server -> Client
}



================================================
File: ExtremeDumper.AntiAntiDump/AADPipe.cs
================================================
using System;
using System.IO;
using System.IO.Pipes;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// Anti anti dump server/client base class
/// </summary>
public abstract class AADPipe : IDisposable {
	internal enum ExecutionResult {
		Success,
		Failure,
		UnknownCommand,
		UnhandledException,
		IOError,
		Disconnect
	}

	internal readonly PipeStream stream;
	bool isDisposed;

	/// <summary>
	/// Is connected
	/// </summary>
	public bool IsConnected => stream.IsConnected;

	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="stream"></param>
	internal AADPipe(PipeStream stream) {
		this.stream = stream;
	}

	/// <summary>
	/// Read command from stream
	/// </summary>
	/// <param name="command"></param>
	/// <param name="throwing"></param>
	/// <returns></returns>
	/// <exception cref="IOException"></exception>
	internal bool ReadCommand(out AADCommand command, bool throwing = true) {
		command = AADCommand.Invalid;
		var buffer = new byte[4];
		if (!Read(buffer, throwing))
			return false;
		command = (AADCommand)BitConverter.ToUInt32(buffer, 0);
		return true;
	}

	/// <summary>
	/// Write command to stream
	/// </summary>
	/// <param name="command"></param>
	/// <returns></returns>
	/// <exception cref="IOException"></exception>
	internal bool WriteCommand(AADCommand command, bool throwing = true) {
		var buffer = BitConverter.GetBytes((uint)command);
		return Write(buffer, throwing);
	}

	/// <summary>
	/// Read serializable object from stream
	/// </summary>
	/// <param name="obj"></param>
	/// <param name="throwing"></param>
	/// <returns></returns>
	/// <exception cref="IOException"></exception>
	internal bool Read(ISerializable obj, bool throwing = true) {
		bool b;
		try {
			b = obj.Deserialize(stream);
		}
		catch {
			b = false;
		}
		if (!b && throwing)
			throw new IOException("Can't read serializable object from internal pipe stream.");
		return b;
	}

	/// <summary>
	/// Write serializable object to stream
	/// </summary>
	/// <param name="obj"></param>
	/// <param name="throwing"></param>
	/// <returns></returns>
	/// <exception cref="IOException"></exception>
	internal bool Write(ISerializable obj, bool throwing = true) {
		bool b;
		try {
			b = obj.Serialize(stream);
		}
		catch {
			b = false;
		}
		if (!b && throwing)
			throw new IOException("Can't write serializable object to internal pipe stream.");
		return b;
	}

	/// <summary>
	/// Read bytes from stream 
	/// </summary>
	/// <param name="buffer"></param>
	/// <param name="throwing"></param>
	/// <returns></returns>
	/// <exception cref="IOException"></exception>
	internal bool Read(byte[] buffer, bool throwing = true) {
		bool b;
		try {
			b = stream.Read(buffer, 0, buffer.Length) == buffer.Length;
		}
		catch {
			b = false;
		}
		if (!b && throwing)
			throw new IOException("Can't read data from internal pipe stream.");
		return b;
	}

	/// <summary>
	/// Write bytes to stream
	/// </summary>
	/// <param name="buffer"></param>
	/// <param name="throwing"></param>
	/// <returns></returns>
	/// <exception cref="IOException"></exception>
	internal bool Write(byte[] buffer, bool throwing = true) {
		bool b;
		try {
			stream.Write(buffer, 0, buffer.Length);
			b = true;
		}
		catch {
			b = false;
		}
		if (!b && throwing)
			throw new IOException("Can't write data to internal pipe stream.");
		return b;
	}

	/// <inheritdoc/>
	public void Dispose() {
		if (!isDisposed) {
			if (IsConnected)
				WriteCommand(AADCommand.Disconnect, false);
			stream.Dispose();
			isDisposed = true;
		}
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/AADServer.cs
================================================
using System;
using System.Diagnostics;
using System.Extensions;
using System.IO;
using System.IO.Pipes;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// <see cref="AADCommand.UnhandledException"/>
/// </summary>
public sealed class AADServerInvocationException : Exception, ISerializable {
	string message = string.Empty;

	/// <inheritdoc/>
	public override string Message => message;

	/// <inheritdoc/>
	public AADServerInvocationException() {
	}

	/// <inheritdoc/>
	public AADServerInvocationException(string message) {
		this.message = message;
	}

	bool ISerializable.Serialize(Stream destination) {
		return Serializer.WriteString(destination, message);
	}

	bool ISerializable.Deserialize(Stream source) {
		return Serializer.ReadString(source, out message);
	}
}

/// <summary>
/// Anti anti dump server, which provides module info and metadata info to bypass anti dump
/// </summary>
public sealed class AADServer : AADPipe {
	bool isListening;

	AADServer(NamedPipeServerStream stream) : base(stream) {
	}

	/// <summary>
	/// Create a metadata server
	/// </summary>
	/// <param name="pipeName">Name of named pipe stream</param>
	/// <returns></returns>
	public static AADServer? Create(string pipeName) {
		if (string.IsNullOrEmpty(pipeName))
			return null;
		if (File.Exists($@"\\.\pipe\{pipeName}"))
			return null;

		try {
			var stream = new NamedPipeServerStream(pipeName, PipeDirection.InOut, 1);
			return new AADServer(stream);
		}
		catch {
			return null;
		}
	}

	/// <summary>
	/// Waits for a client to connect to this <see cref="AADServer" /> object.
	/// </summary>
	/// <returns></returns>
	bool WaitForConnection() {
		return WaitForConnection(-1);
	}

	/// <summary>
	/// Connects to a waiting server within the specified time-out period.
	/// </summary>
	/// <param name="timeout">The number of milliseconds to wait for the client to connect before the connection times out.</param>
	/// <returns></returns>
	bool WaitForConnection(int timeout) {
		// TODO: timeout
		Debug2.Assert(!IsConnected);
		var stream = (NamedPipeServerStream)base.stream;
		stream.WaitForConnection();
		return IsConnected;
	}

	void Disconnect() {
		try {
			var stream = (NamedPipeServerStream)base.stream;
			stream.Disconnect();
		}
		catch {
		}
	}

	/// <summary>
	/// Start listening
	/// </summary>
	public void Listen() {
		if (isListening)
			throw new InvalidOperationException("Already listening");

		isListening = true;
		try {
			while (true) {
				WaitForConnection();
				Execute();
			}
		}
		finally {
			isListening = false;
		}
	}

	/// <summary>
	/// Execute loop until disconnect
	/// </summary>
	/// <returns><see langword="true"/> if disconnected by command, <see langword="false"/> if client disconnects without sending command</returns>
	/// <remarks>Guarantee no exception thrown</remarks>
	bool Execute() {
		while (true) {
			var r = ExecuteOne();
			Debug2.Assert(r != ExecutionResult.UnknownCommand);
			// internal error, we should fix it
			switch (r) {
			case ExecutionResult.IOError:
			case ExecutionResult.Disconnect:
				Disconnect();
				return r == ExecutionResult.Disconnect;
			}
		}
	}

	/// <summary>
	/// Execute one command and return execution result
	/// </summary>
	/// <returns></returns>
	/// <remarks>See invoker: <seealso cref="AADClient.InvokeOne(AADCommand, ISerializable, out ISerializable?)"/></remarks>
	ExecutionResult ExecuteOne() {
		try {
			ReadCommand(out var command);

			if (command == AADCommand.Disconnect)
				return ExecutionResult.Disconnect;

			if (!CommandHandlerManager.Handlers.TryGetValue(command, out var handler)) {
				Debug2.Assert(false);
				return ExecutionResult.UnknownCommand;
			}
			// phase 1: get the handler corresponding to the command

			if (Activator.CreateInstance(handler.ParametersType, true) is not ISerializable parameters)
				throw new InvalidOperationException("Can't create parameters object");
			// phase 2: create parameters instance

			Read(parameters);
			// phase 3: read parameters from stream

			bool b;
			ISerializable? result;
			try {
				b = handler.Execute(parameters, out result);
			}
			catch (Exception ex) {
				WriteCommand(AADCommand.UnhandledException);
				Write(new AADServerInvocationException(ex.ToFullString()));
				return ExecutionResult.UnhandledException;
			}
			if (!b) {
				WriteCommand(AADCommand.Failure);
				return ExecutionResult.Failure;
			}
			// phase 4: execute command with parameters

			WriteCommand(AADCommand.Success);
			Write(result!);
			// phase 5: write result to stream

			return ExecutionResult.Success;
		}
		catch (Exception ex) {
			Debug2.Assert(ex is IOException);
			// regard all unhandable exceptions as IO error
			return ExecutionResult.IOError;
		}
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/AppDomainInfo.cs
================================================
using System.IO;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// Application domain info
/// </summary>
public sealed class AppDomainInfo : ISerializable {
	/// <summary>
	/// Domain ID
	/// </summary>
	public uint Id;

	/// <summary>
	/// Domain name
	/// </summary>
	public string Name = string.Empty;

	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.Write(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.Read(source, this);
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/CommandHandlerManager.cs
================================================
using System;
using System.Collections.Generic;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// Find all <see cref="AADCommand"/> handler
/// </summary>
static class CommandHandlerManager {
	/// <summary>
	/// All <see cref="AADCommand"/> handlers
	/// </summary>
	public static IDictionary<AADCommand, ICommandHandler> Handlers { get; } = GetHandlers();

	static Dictionary<AADCommand, ICommandHandler> GetHandlers() {
		var handlers = new Dictionary<AADCommand, ICommandHandler>();
		foreach (var type in typeof(ICommandHandler).Module.GetTypes()) {
			if (type.IsAbstract)
				continue;
			foreach (var interfaceType in type.GetInterfaces()) {
				if (interfaceType.IsAssignableFrom(typeof(ICommandHandler))) {
					var handler = (ICommandHandler)Activator.CreateInstance(type, true);
					handlers.Add(handler.Command, handler);
				}
			}
		}
		return handlers;
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/ExtremeDumper.AntiAntiDump.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<TargetFramework>net35</TargetFramework>
	</PropertyGroup>
	<Import Project="..\ExtremeDumper.Common.props" />
	<ItemGroup>
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\Memory.cs" Link="MetadataLocator\Memory.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\MetadataImport.cs" Link="MetadataLocator\MetadataImport.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\MetadataInfo.cs" Link="MetadataLocator\MetadataInfo.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\MetadataInfoImpl.cs" Link="MetadataLocator\MetadataInfoImpl.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\PEInfo.cs" Link="MetadataLocator\PEInfo.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\PEInfoImpl.cs" Link="MetadataLocator\PEInfoImpl.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\ReflectionHelpers.cs" Link="MetadataLocator\ReflectionHelpers.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\RuntimeDefinitions.cs" Link="MetadataLocator\RuntimeDefinitions.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\RuntimeEnvironment.cs" Link="MetadataLocator\RuntimeEnvironment.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\TestAssemblyManager.cs" Link="MetadataLocator\TestAssemblyManager.cs" />
		<Compile Include="..\Libraries\MetadataLocator\MetadataLocator\Utils.cs" Link="MetadataLocator\Utils.cs" />
	</ItemGroup>
</Project>



================================================
File: ExtremeDumper.AntiAntiDump/ICommandHandler.cs
================================================
using System;
using System.Diagnostics.CodeAnalysis;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// <see cref="AADCommand"/> handler interface
/// </summary>
/// <remarks>
/// Phase1 invoke command: Client.Invoke -> ICommandHandler.Invoke -> Server.Execute -> ICommandHandler.Execute -> result(in server)
/// Phase2 receive result: result(in server) -> ICommandHandler.Execute -> Server.Execute -> ICommandHandler.Invoke -> Client.Invoke
/// </remarks>
interface ICommandHandler {
	/// <summary>
	/// Registered command enum
	/// </summary>
	AADCommand Command { get; }

	/// <summary>
	/// Parameters type (server side)
	/// </summary>
	Type ParametersType { get; }

	/// <summary>
	/// Result type (client side)
	/// </summary>
	Type ResultType { get; }

	/// <summary>
	/// Execute command (server side)
	/// </summary>
	/// <param name="parameters"></param>
	/// <param name="result"></param>
	/// <returns></returns>
	bool Execute(ISerializable parameters, [NotNullWhen(true)] out ISerializable? result);
}



================================================
File: ExtremeDumper.AntiAntiDump/Injection.cs
================================================
using System;
using System.Extensions;
using System.Runtime.ExceptionServices;
using System.Threading;

namespace ExtremeDumper.AntiAntiDump;

public static class Injection {
	public const int Success = 0;
	public const int Failure = -1;
	public const int InvalidArgument = -2;
	public const int UnhandledException = -3;

	public static int Main(string arg) {
		RunAADServerAsync(arg);
		return Success;
	}

	public static void RunAADServerAsync(string pipeName) {
		new Thread(() => RunAADServer(pipeName)) { IsBackground = true }.Start();
	}

	[HandleProcessCorruptedStateExceptions]
	public static int RunAADServer(string pipeName) {
		try {
			var server = AADServer.Create(pipeName);
			if (server is null) {
				TryMessageBox("Can't create AADServer instance.");
				return InvalidArgument;
			}

			server.Listen();
			return Success;
		}
		catch (Exception ex) {
			TryMessageBox(ex.ToFullString());
			return UnhandledException;
		}
	}

	static void Server_UnhandledException(object sender, UnhandledExceptionEventArgs e) {
		if (e.ExceptionObject is Exception exception)
			TryMessageBox(exception.ToFullString());
	}

	static bool TryMessageBox(string message) {
		var type = Type.GetType("System.Windows.Forms.MessageBox, System.Windows.Forms, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", false);
		if (type is null)
			return false;

		var method = type.GetMethod("Show", new[] { typeof(string) });
		if (method is null)
			return false;

		method.Invoke(null, new object[] { message });
		return true;
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/MetadataInfo.cs
================================================
using System;
using System.IO;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// Metadata schema
/// </summary>
public sealed class MetadataSchema : ISerializable {
	/// <summary>
	/// Determine if current instance is invalid
	/// </summary>
	public bool IsInvalid => ValidMask == 0;

	/// <summary/>
	public uint Reserved1;

	/// <summary/>
	public byte MajorVersion;

	/// <summary/>
	public byte MinorVersion;

	/// <summary/>
	public byte Flags;

	/// <summary/>
	public byte Log2Rid;

	/// <summary/>
	public ulong ValidMask;

	/// <summary/>
	public ulong SortedMask;

	/// <summary/>
	/// <remarks>Array length always equals to <see cref="MetadataLocator.RuntimeDefinitions.TBL_COUNT"/> if not empty</remarks>
	public uint[] RowCounts = Array2.Empty<uint>();

	/// <summary/>
	public uint ExtraData;

	/// <summary>
	/// Default constructor
	/// </summary>
	public MetadataSchema() {
	}

	/// <summary>
	/// Populate data from <see cref="MetadataLocator.MetadataSchema"/>
	/// </summary>
	/// <param name="schema"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public MetadataSchema(MetadataLocator.MetadataSchema schema) {
		if (schema is null)
			throw new ArgumentNullException(nameof(schema));

		Reserved1 = schema.Reserved1;
		MajorVersion = schema.MajorVersion;
		MinorVersion = schema.MinorVersion;
		Flags = schema.Flags;
		Log2Rid = schema.Log2Rid;
		ValidMask = schema.ValidMask;
		SortedMask = schema.SortedMask;
		RowCounts = schema.RowCounts;
		ExtraData = schema.ExtraData;
	}

	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.Write(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.Read(source, this);
	}
}

/// <summary>
/// Metadata stream info
/// </summary>
public abstract class MetadataStreamInfo : ISerializable {
	/// <summary>
	/// Determine if current instance is invalid
	/// </summary>
	public bool IsInvalid => Address == 0;

	/// <summary>
	/// Address of stream
	/// </summary>
	public ulong Address;

	/// <summary>
	/// Length of stream
	/// </summary>
	public uint Length;

	/// <summary>
	/// Default constructor
	/// </summary>
	protected MetadataStreamInfo() {
	}

	/// <summary>
	/// Populate data from <see cref="MetadataLocator.MetadataStreamInfo"/>
	/// </summary>
	/// <param name="stream"></param>
	/// <exception cref="ArgumentNullException"></exception>
	protected MetadataStreamInfo(MetadataLocator.MetadataStreamInfo stream) {
		if (stream is null)
			throw new ArgumentNullException(nameof(stream));

		Address = stream.Address;
		Length = stream.Length;
	}

	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.Write(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.Read(source, this);
	}
}

/// <summary>
/// Metadata table info (#~, #-)
/// </summary>
public sealed class MetadataTableInfo : MetadataStreamInfo {
	/// <summary>
	/// Is compressed table stream (#~)
	/// </summary>
	public bool IsCompressed;

	/// <summary>
	/// Table count, see <see cref="MetadataLocator.RuntimeDefinitions.TBL_COUNT_V1"/> and  <see cref="MetadataLocator.RuntimeDefinitions.TBL_COUNT_V2"/>
	/// </summary>
	public uint TableCount;

	/// <summary>
	/// Size of each row
	/// </summary>
	/// <remarks>Array length always equals to <see cref="MetadataLocator.RuntimeDefinitions.TBL_COUNT"/> if not empty</remarks>
	public uint[] RowSizes = Array2.Empty<uint>();

	/// <summary>
	/// Default constructor
	/// </summary>
	public MetadataTableInfo() {
	}

	/// <summary>
	/// Populate data from <see cref="MetadataLocator.MetadataTableInfo"/>
	/// </summary>
	/// <param name="table"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public MetadataTableInfo(MetadataLocator.MetadataTableInfo table) : base(table) {
		if (table is null)
			throw new ArgumentNullException(nameof(table));

		IsCompressed = table.IsCompressed;
		TableCount = table.TableCount;
		RowSizes = table.RowSizes;
	}
}

/// <summary>
/// Metadata heap info (#Strings, #US, #GUID, #Blob)
/// </summary>
public sealed class MetadataHeapInfo : MetadataStreamInfo {
	/// <summary>
	/// Default constructor
	/// </summary>
	public MetadataHeapInfo() {
	}

	/// <summary>
	/// Populate data from <see cref="MetadataLocator.MetadataTableInfo"/>
	/// </summary>
	/// <param name="heap"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public MetadataHeapInfo(MetadataLocator.MetadataHeapInfo heap) : base(heap) {
	}
}

/// <summary>
/// Metadata info
/// </summary>
public sealed class MetadataInfo : ISerializable {
	/// <summary>
	/// Determine if current instance is invalid
	/// </summary>
	public bool IsInvalid => MetadataAddress == 0;

	/// <summary>
	/// Address of metadata
	/// </summary>
	public ulong MetadataAddress;

	/// <summary>
	/// Size of metadata
	/// </summary>
	/// <remarks>Currently return 0x1c if table stream is uncompressed (aka #-)</remarks>
	public uint MetadataSize;

	/// <summary>
	/// Metadata schema
	/// </summary>
	public MetadataSchema Schema = new();

	/// <summary>
	/// #~ or #- info
	/// </summary>
	public MetadataTableInfo TableStream = new();

	/// <summary>
	/// #Strings heap info
	/// </summary>
	public MetadataHeapInfo StringHeap = new();

	/// <summary>
	/// #US heap info
	/// </summary>
	public MetadataHeapInfo UserStringHeap = new();

	/// <summary>
	/// #GUID heap info
	/// </summary>
	public MetadataHeapInfo GuidHeap = new();

	/// <summary>
	/// #Blob heap info
	/// </summary>
	public MetadataHeapInfo BlobHeap = new();

	/// <summary>
	/// Default constructor
	/// </summary>
	public MetadataInfo() {
	}

	/// <summary>
	/// Populate data from <see cref="MetadataLocator.MetadataInfo"/>
	/// </summary>
	/// <param name="metadata"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public MetadataInfo(MetadataLocator.MetadataInfo metadata) {
		if (metadata is null)
			throw new ArgumentNullException(nameof(metadata));

		MetadataAddress = metadata.MetadataAddress;
		MetadataSize = metadata.MetadataSize;
		Schema = new MetadataSchema(metadata.Schema);
		TableStream = new MetadataTableInfo(metadata.TableStream);
		StringHeap = new MetadataHeapInfo(metadata.StringHeap);
		UserStringHeap = new MetadataHeapInfo(metadata.UserStringHeap);
		GuidHeap = new MetadataHeapInfo(metadata.GuidHeap);
		BlobHeap = new MetadataHeapInfo(metadata.BlobHeap);
	}

	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.Write(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.Read(source, this);
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/ModuleInfo.cs
================================================
using System.Collections.Generic;
using System.IO;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// Module info
/// </summary>
public sealed class ModuleInfo : ISerializable {
	/// <summary>
	/// Module name
	/// </summary>
	public string Name = string.Empty;

	/// <summary>
	/// Owner assembly name
	/// </summary>
	public string AssemblyName = string.Empty;

	/// <summary>
	/// Owner application domain id
	/// </summary>
	public uint DomainId;

	/// <summary>
	/// Owner application domain name
	/// </summary>
	public string DomainName = string.Empty;

	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.Write(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.Read(source, this);
	}
}

/// <summary>
/// Module info list
/// </summary>
public sealed class ModuleInfos : List<ModuleInfo>, ISerializable {
	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.WriteList(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.ReadList(source, this);
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/PEInfo.cs
================================================
using System;
using System.IO;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// CLR internal image layout
/// </summary>
public sealed class PEImageLayout : ISerializable {
	/// <summary>
	/// Determine if current instance is invalid
	/// </summary>
	public bool IsInvalid => ImageBase == 0;

	/// <summary>
	/// Image base address
	/// </summary>
	public ulong ImageBase;

	/// <summary>
	/// Image size (size of file on disk, as opposed to OptionalHeaders.SizeOfImage)
	/// </summary>
	public uint ImageSize;

	/// <summary>
	/// Address of <see cref="MetadataLocator.RuntimeDefinitions.IMAGE_COR20_HEADER"/>
	/// </summary>
	public ulong CorHeaderAddress;

	/// <summary>
	/// Default constructor
	/// </summary>
	public PEImageLayout() {
	}

	/// <summary>
	/// Populate data from <see cref="MetadataLocator.PEImageLayout"/>
	/// </summary>
	/// <param name="imageLayout"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public PEImageLayout(MetadataLocator.PEImageLayout imageLayout) {
		if (imageLayout is null)
			throw new ArgumentNullException(nameof(imageLayout));

		ImageBase = imageLayout.ImageBase;
		ImageSize = imageLayout.ImageSize;
		CorHeaderAddress = imageLayout.CorHeaderAddress;
	}

	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.Write(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.Read(source, this);
	}
}

/// <summary>
/// .NET PE Info
/// </summary>
public sealed class PEInfo : ISerializable {
	/// <summary>
	/// Determine if current instance is invalid
	/// </summary>
	public bool IsInvalid => LoadedLayout.IsInvalid;

	/// <summary>
	/// Image file path
	/// </summary>
	public string FilePath = string.Empty;

	/// <summary>
	/// If image is loaded in memory
	/// </summary>
	public bool InMemory => string.IsNullOrEmpty(FilePath);

	/// <summary>
	/// Flat image layout, maybe empty (Assembly.Load(byte[]))
	/// </summary>
	public PEImageLayout FlatLayout = new();

	/// <summary>
	/// Mapped image layout, maybe empty (Assembly.LoadFile)
	/// </summary>
	public PEImageLayout MappedLayout = new();

	/// <summary>
	/// Loaded image layout, not empty (Assembly.LoadFile)
	/// </summary>
	public PEImageLayout LoadedLayout = new();

	/// <summary>
	/// Default constructor
	/// </summary>
	public PEInfo() {
	}

	/// <summary>
	/// Populate data from <see cref="MetadataLocator.PEInfo"/>
	/// </summary>
	/// <param name="peInfo"></param>
	/// <exception cref="ArgumentNullException"></exception>
	public PEInfo(MetadataLocator.PEInfo peInfo) {
		if (peInfo is null)
			throw new ArgumentNullException(nameof(peInfo));

		FilePath = peInfo.FilePath;
		FlatLayout = new PEImageLayout(peInfo.FlatLayout);
		MappedLayout = new PEImageLayout(peInfo.MappedLayout);
		LoadedLayout = new PEImageLayout(peInfo.LoadedLayout);
	}

	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.Write(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.Read(source, this);
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/RuntimeInfo.cs
================================================
using System;
using System.IO;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// CLR Runtime flavor
/// </summary>
public enum RuntimeFlavor {
	/// <summary>
	/// .NET Framework 1.0 ~ 4.8
	/// </summary>
	Framework,

	/// <summary>
	/// .NET Core 1.0 ~ 3.1
	/// </summary>
	Core,

	/// <summary>
	/// .NET 5.0 +
	/// </summary>
	Net
}

/// <summary>
/// CLR Runtime info
/// </summary>
public sealed class RuntimeInfo : ISerializable {
	/// <summary>
	/// Runtime flavor
	/// </summary>
	public RuntimeFlavor Flavor {
		get => (RuntimeFlavor)_Flavor;
		set => _Flavor = (int)value;
	}

	/// <summary/>
	public int _Flavor;

	/// <summary>
	/// File name
	/// </summary>
	public string FileName = string.Empty;

	/// <summary>
	/// File version
	/// </summary>
	public Version FileVersion {
		get => new(_FileVersion);
		set => _FileVersion = value.ToString();
	}

	/// <summary/>
	public string _FileVersion = string.Empty;

	bool ISerializable.Serialize(Stream destination) {
		return SimpleSerializer.Write(destination, this);
	}

	bool ISerializable.Deserialize(Stream source) {
		return SimpleSerializer.Read(source, this);
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/Serialization.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace ExtremeDumper.AntiAntiDump;

/// <summary>
/// Represent a serializable object to provider a general interface for <see cref="AADPipe"/> to transfer object
/// </summary>
interface ISerializable {
	/// <summary>
	/// Serialize to <paramref name="destination"/>
	/// </summary>
	/// <param name="destination"></param>
	/// <returns></returns>
	/// <remarks>Guarantee no exception thrown</remarks>
	bool Serialize(Stream destination);

	/// <summary>
	/// Deserialize from <paramref name="source"/>
	/// </summary>
	/// <param name="source"></param>
	/// <returns></returns>
	/// <remarks>Guarantee no exception thrown</remarks>
	bool Deserialize(Stream source);
}

sealed class EmptySerializable : ISerializable {
	public static readonly EmptySerializable Instance = new();

	private EmptySerializable() { }

	public bool Serialize(Stream destination) {
		return true;
	}

	public bool Deserialize(Stream source) {
		return true;
	}
}

/// <summary>
/// Serialize and deserialize basic types
/// </summary>
/// <remarks>
/// <para>Guarantee no exception thrown.</para>
/// <para>Should only called by <see cref="ISerializable"/> implement. Other classes should always call methods in <see cref="ISerializable"/> interface.</para>
/// </remarks>
static class Serializer {
	public static bool WriteBoolean(Stream destination, bool value) {
		byte[] buffer = new byte[] { value ? (byte)1 : (byte)0 };
		return destination.Write(buffer);
	}

	public static bool ReadBoolean(Stream source, out bool value) {
		value = false;
		var buffer = new byte[1];
		if (!source.Read(buffer))
			return false;

		value = buffer[0] != 0;
		return true;
	}

	public static bool WriteByte(Stream destination, byte value) {
		byte[] buffer = new byte[] { value };
		return destination.Write(buffer);
	}

	public static bool ReadByte(Stream source, out byte value) {
		value = 0;
		var buffer = new byte[1];
		if (!source.Read(buffer))
			return false;

		value = buffer[0];
		return true;
	}

	public static bool WriteInt32(Stream destination, int value) {
		byte[] buffer = BitConverter.GetBytes(value);
		return destination.Write(buffer);
	}

	public static bool ReadInt32(Stream source, out int value) {
		value = 0;
		var buffer = new byte[4];
		if (!source.Read(buffer))
			return false;

		value = BitConverter.ToInt32(buffer, 0);
		return true;
	}

	public static bool WriteUInt32(Stream destination, uint value) {
		byte[] buffer = BitConverter.GetBytes(value);
		return destination.Write(buffer);
	}

	public static bool ReadUInt32(Stream source, out uint value) {
		value = 0;
		var buffer = new byte[4];
		if (!source.Read(buffer))
			return false;

		value = BitConverter.ToUInt32(buffer, 0);
		return true;
	}

	public static bool WriteUInt64(Stream destination, ulong value) {
		byte[] buffer = BitConverter.GetBytes(value);
		return destination.Write(buffer);
	}

	public static bool ReadUInt64(Stream source, out ulong value) {
		value = 0;
		var buffer = new byte[8];
		if (!source.Read(buffer))
			return false;

		value = BitConverter.ToUInt64(buffer, 0);
		return true;
	}

	public static bool WriteInt64(Stream destination, long value) {
		byte[] buffer = BitConverter.GetBytes(value);
		return destination.Write(buffer);
	}

	public static bool ReadInt64(Stream source, out long value) {
		value = 0;
		var buffer = new byte[8];
		if (!source.Read(buffer))
			return false;

		value = BitConverter.ToInt64(buffer, 0);
		return true;
	}

	public static bool WriteString(Stream destination, string value) {
		if (value is null)
			return false;

		var buffer = Encoding.UTF8.GetBytes(value);
		return WriteBytes(destination, buffer);
	}

	public static bool ReadString(Stream source, out string value) {
		value = string.Empty;
		if (!ReadBytes(source, out var buffer))
			return false;

		value = Encoding.UTF8.GetString(buffer);
		return true;
	}

	public static bool WriteBytes(Stream destination, byte[] value) {
		if (value is null)
			return false;

		WriteInt32(destination, value.Length);
		return destination.Write(value);
	}

	public static bool ReadBytes(Stream source, out byte[] value) {
		value = Array2.Empty<byte>();
		if (!ReadInt32(source, out int length))
			return false;

		value = new byte[length];
		return source.Read(value);
	}

	public static bool WriteInt32Array(Stream destination, int[] array) {
		if (array is null)
			return false;

		if (!WriteInt32(destination, array.Length))
			return false;
		foreach (int element in array) {
			if (!WriteInt32(destination, element))
				return false;
		}
		return true;
	}

	public static bool ReadInt32Array(Stream source, out int[] array) {
		array = Array2.Empty<int>();
		if (!ReadInt32(source, out int length))
			return false;

		array = new int[length];
		for (int i = 0; i < length; i++) {
			if (!ReadInt32(source, out array[i]))
				return false;
		}
		return true;
	}

	public static bool WriteUInt32Array(Stream destination, uint[] array) {
		if (array is null)
			return false;

		if (!WriteInt32(destination, array.Length))
			return false;
		foreach (uint element in array) {
			if (!WriteUInt32(destination, element))
				return false;
		}
		return true;
	}

	public static bool ReadUInt32Array(Stream source, out uint[] array) {
		array = Array2.Empty<uint>();
		if (!ReadInt32(source, out int length))
			return false;

		array = new uint[length];
		for (int i = 0; i < length; i++) {
			if (!ReadUInt32(source, out array[i]))
				return false;
		}
		return true;
	}

	public static bool WriteInt64Array(Stream destination, long[] array) {
		if (array is null)
			return false;

		if (!WriteInt32(destination, array.Length))
			return false;
		foreach (long element in array) {
			if (!WriteInt64(destination, element))
				return false;
		}
		return true;
	}

	public static bool ReadInt64Array(Stream source, out long[] array) {
		array = Array2.Empty<long>();
		if (!ReadInt32(source, out int length))
			return false;

		array = new long[length];
		for (int i = 0; i < length; i++) {
			if (!ReadInt64(source, out array[i]))
				return false;
		}
		return true;
	}

	public static bool WriteUInt64Array(Stream destination, ulong[] array) {
		if (array is null)
			return false;

		if (!WriteInt32(destination, array.Length))
			return false;
		foreach (ulong element in array) {
			if (!WriteUInt64(destination, element))
				return false;
		}
		return true;
	}

	public static bool ReadUInt64Array(Stream source, out ulong[] array) {
		array = Array2.Empty<ulong>();
		if (!ReadInt32(source, out int length))
			return false;

		array = new ulong[length];
		for (int i = 0; i < length; i++) {
			if (!ReadUInt64(source, out array[i]))
				return false;
		}
		return true;
	}

	public static bool WriteStringArray(Stream destination, string[] array) {
		if (array is null)
			return false;

		if (!WriteInt32(destination, array.Length))
			return false;
		foreach (string element in array) {
			if (!WriteString(destination, element))
				return false;
		}
		return true;
	}

	public static bool ReadStringArray(Stream source, out string[] array) {
		array = Array2.Empty<string>();
		if (!ReadInt32(source, out int length))
			return false;

		array = new string[length];
		for (int i = 0; i < length; i++) {
			if (!ReadString(source, out array[i]))
				return false;
		}
		return true;
	}

	static bool Write(this Stream stream, byte[] data) {
		try {
			stream.Write(data, 0, data.Length);
			return true;
		}
		catch {
			return false;
		}
	}

	static bool Read(this Stream stream, byte[] data) {
		bool b;
		try {
			b = stream.Read(data, 0, data.Length) == data.Length;
		}
		catch {
			b = false;
		}
		return b;
	}
}

/// <summary>
/// A simple <see cref="ISerializable"/> object serializer to quickly implement <see cref="ISerializable"/> interface
/// </summary>
/// <remarks>Should only called by <see cref="ISerializable"/> implement. Other classes should always call methods in <see cref="ISerializable"/> interface.</remarks>
static class SimpleSerializer {
	/// <summary>
	/// Write <see cref="ISerializable"/> instance which has simple internal layout
	/// </summary>
	/// <param name="destination"></param>
	/// <param name="obj"></param>
	/// <returns></returns>
	/// <remarks>Should only called by <see cref="ISerializable.Serialize(Stream)"/> to quick serialize itself</remarks>
	public static bool Write(Stream destination, ISerializable obj) {
		var fields = obj.GetType().GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
		foreach (var field in fields) {
			var value = field.GetValue(obj);
			switch (Type.GetTypeCode(field.FieldType)) {
			case TypeCode.Boolean:
				if (!Serializer.WriteBoolean(destination, (bool)value))
					return false;
				continue;
			case TypeCode.Byte:
				if (!Serializer.WriteByte(destination, (byte)value))
					return false;
				continue;
			case TypeCode.Int32:
				if (!Serializer.WriteInt32(destination, (int)value))
					return false;
				continue;
			case TypeCode.UInt32:
				if (!Serializer.WriteUInt32(destination, (uint)value))
					return false;
				continue;
			case TypeCode.Int64:
				if (!Serializer.WriteInt64(destination, (long)value))
					return false;
				continue;
			case TypeCode.UInt64:
				if (!Serializer.WriteUInt64(destination, (ulong)value))
					return false;
				continue;
			case TypeCode.String:
				if (!Serializer.WriteString(destination, (string)value))
					return false;
				continue;
			}
			if (value is int[] i4s) {
				if (!Serializer.WriteInt32Array(destination, i4s))
					return false;
				continue;
			}
			if (value is uint[] u4s) {
				if (!Serializer.WriteUInt32Array(destination, u4s))
					return false;
				continue;
			}
			if (value is long[] i8s) {
				if (!Serializer.WriteInt64Array(destination, i8s))
					return false;
				continue;
			}
			if (value is ulong[] u8s) {
				if (!Serializer.WriteUInt64Array(destination, u8s))
					return false;
				continue;
			}
			if (value is string[] ss) {
				if (!Serializer.WriteStringArray(destination, ss))
					return false;
				continue;
			}
			if (value is byte[] bin) {
				if (!Serializer.WriteBytes(destination, bin))
					return false;
				continue;
			}
			if (value is ISerializable o) {
				if (!Write(destination, o))
					return false;
				continue;
			}
			Debug2.Assert(false);
			return false;
		}
		return true;
	}

	/// <summary>
	/// Read <see cref="ISerializable"/> instance which has simple internal layout
	/// </summary>
	/// <param name="destination"></param>
	/// <param name="obj"></param>
	/// <returns></returns>
	/// <remarks>Should only called by <see cref="ISerializable.Deserialize(Stream)(Stream)"/> to quick deserialize itself</remarks>
	public static bool Read(Stream source, ISerializable obj) {
		var fields = obj.GetType().GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
		foreach (var field in fields) {
			object? value;
			var fieldType = field.FieldType;
			switch (Type.GetTypeCode(fieldType)) {
			case TypeCode.Boolean:
				if (!Serializer.ReadBoolean(source, out bool b))
					return false;
				value = b;
				goto next;
			case TypeCode.Byte:
				if (!Serializer.ReadByte(source, out byte u1))
					return false;
				value = u1;
				goto next;
			case TypeCode.Int32:
				if (!Serializer.ReadInt32(source, out int i4))
					return false;
				value = i4;
				goto next;
			case TypeCode.UInt32:
				if (!Serializer.ReadUInt32(source, out uint u4))
					return false;
				value = u4;
				goto next;
			case TypeCode.Int64:
				if (!Serializer.ReadInt64(source, out long i8))
					return false;
				value = i8;
				goto next;
			case TypeCode.UInt64:
				if (!Serializer.ReadUInt64(source, out ulong u8))
					return false;
				value = u8;
				goto next;
			case TypeCode.String:
				if (!Serializer.ReadString(source, out var s))
					return false;
				value = s;
				goto next;
			}
			if (fieldType == typeof(byte[])) {
				if (!Serializer.ReadBytes(source, out var bin))
					return false;
				value = bin;
				goto next;
			}
			if (fieldType == typeof(int[])) {
				if (!Serializer.ReadInt32Array(source, out var i4s))
					return false;
				value = i4s;
				goto next;
			}
			if (fieldType == typeof(uint[])) {
				if (!Serializer.ReadUInt32Array(source, out var u4s))
					return false;
				value = u4s;
				goto next;
			}
			if (fieldType == typeof(long[])) {
				if (!Serializer.ReadInt64Array(source, out var i8s))
					return false;
				value = i8s;
				goto next;
			}
			if (fieldType == typeof(ulong[])) {
				if (!Serializer.ReadUInt64Array(source, out var u8s))
					return false;
				value = u8s;
				goto next;
			}
			if (fieldType == typeof(string[])) {
				if (!Serializer.ReadStringArray(source, out var ss))
					return false;
				value = ss;
				goto next;
			}
			if (typeof(ISerializable).IsAssignableFrom(fieldType)) {
				var o = (ISerializable)Activator.CreateInstance(fieldType, true);
				if (!Read(source, o))
					return false;
				value = o;
				goto next;
			}
			Debug2.Assert(false);
			return false;

		next:
			field.SetValue(obj, value);
		}
		return true;
	}

	/// <summary>
	/// Write list of <see cref="ISerializable"/>
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <param name="destination"></param>
	/// <param name="list"></param>
	/// <returns></returns>
	public static bool WriteList<T>(Stream destination, IList<T> list) where T : class, ISerializable {
		if (list is null)
			return false;

		if (!Serializer.WriteInt32(destination, list.Count))
			return false;
		foreach (var element in list) {
			if (element is null)
				return false;
			if (!element.Serialize(destination))
				return false;
		}
		return true;
	}

	/// <summary>
	/// Read list of <see cref="ISerializable"/>
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <param name="source"></param>
	/// <param name="list"></param>
	/// <returns></returns>
	public static bool ReadList<T>(Stream source, IList<T> list) where T : class, ISerializable, new() {
		list.Clear();
		if (!Serializer.ReadInt32(source, out int length))
			return false;

		for (int i = 0; i < length; i++) {
			var element = new T();
			if (!element.Deserialize(source))
				return false;
			list.Add(element);
		}
		return true;
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/Handlers/EnableMultiDomainHandler.cs
================================================
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.InteropServices;

namespace ExtremeDumper.AntiAntiDump.Handlers;

sealed class EnableMultiDomainHandler : ICommandHandler {
	public sealed class PipeNames : ISerializable {
		public string[] Values = Array2.Empty<string>();

		bool ISerializable.Serialize(Stream destination) {
			return SimpleSerializer.Write(destination, this);
		}

		bool ISerializable.Deserialize(Stream source) {
			return SimpleSerializer.Read(source, this);
		}
	}

	sealed class AADServerCreator : MarshalByRefObject {
		public bool Create(string pipeName) {
			Injection.RunAADServerAsync(pipeName);
			return true;
		}
	}

	public AADCommand Command => AADCommand.EnableMultiDomain;

	public Type ParametersType => typeof(EmptySerializable);

	public Type ResultType => typeof(PipeNames);

	public bool Execute(ISerializable parameters, [NotNullWhen(true)] out ISerializable? result) {
		result = null;
		if (!MultiDomainHelper.IsSupported)
			return false;

		var assemblyLocation = typeof(AADServer).Assembly.Location;
		if (string.IsNullOrEmpty(assemblyLocation))
			return false;

		AppDomain.CurrentDomain.AssemblyResolve += AssemblyResolve;
		try {
			var pipeNames = new List<string>();
			foreach (var domain in MultiDomainHelper.EnumerateDomains()) {
				if (domain == AppDomain.CurrentDomain)
					continue;
				var creator = (AADServerCreator)domain.CreateInstanceFromAndUnwrap(assemblyLocation, typeof(AADServerCreator).FullName);
				var name = Guid.NewGuid().ToString();
				if (!creator.Create(name))
					return false;
				// TODO: cleanup
				pipeNames.Add(name);
			}
			result = new PipeNames { Values = pipeNames.ToArray() };
		}
		finally {
			AppDomain.CurrentDomain.AssemblyResolve -= AssemblyResolve;
		}
		return true;

		static System.Reflection.Assembly? AssemblyResolve(object sender, ResolveEventArgs args) {
			return args.Name == typeof(AADServer).Assembly.FullName ? typeof(AADServer).Assembly : null;
		}
	}

	static class MultiDomainHelper {
		/// <summary>
		/// Does current runtime support multi application domains
		/// </summary>
		public static bool IsSupported { get; } = MetadataLocator.RuntimeEnvironment.Flavor == MetadataLocator.RuntimeFlavor.Framework;

		/// <summary>
		/// Enumerate all <see cref="AppDomain"/>s
		/// </summary>
		/// <returns></returns>
		public static IEnumerable<AppDomain> EnumerateDomains() {
			if (!IsSupported) {
				yield return AppDomain.CurrentDomain;
				yield break;
			}

			var host = (ICorRuntimeHost)Activator.CreateInstance(Type.GetTypeFromCLSID(new Guid("CB2F6723-AB3A-11D2-9C40-00C04FA30A3E")));
			host.EnumDomains(out var enumHandle);
			try {
				while (true) {
					host.NextDomain(enumHandle, out var obj);
					if (obj is AppDomain domain)
						yield return domain;
					else
						yield break;
				}
			}
			finally {
				host.CloseEnum(enumHandle);
			}
		}

		[ComImport, Guid("CB2F6722-AB3A-11D2-9C40-00C04FA30A3E"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		interface ICorRuntimeHost {
			void _VtblGap1_11();
			void EnumDomains(out nuint hEnum);
			void NextDomain(nuint hEnum, [MarshalAs(UnmanagedType.IUnknown)] out object pAppDomain);
			void CloseEnum(nuint hEnum);
		}
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/Handlers/GetAppDomainInfoHandler.cs
================================================
using System;
using System.Diagnostics.CodeAnalysis;

namespace ExtremeDumper.AntiAntiDump.Handlers;

sealed class GetAppDomainInfoHandler : ICommandHandler {
	public AADCommand Command => AADCommand.GetAppDomainInfo;

	public Type ParametersType => typeof(EmptySerializable);

	public Type ResultType => typeof(AppDomainInfo);

	public bool Execute(ISerializable parameters, [NotNullWhen(true)] out ISerializable? result) {
		var domain = AppDomain.CurrentDomain;
		result = new AppDomainInfo {
			Id = (uint)domain.Id,
			Name = domain.FriendlyName
		};
		return true;
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/Handlers/GetMetadataInfoHandler.cs
================================================
using System;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace ExtremeDumper.AntiAntiDump.Handlers;

sealed class GetMetadataInfoHandler : ICommandHandler {
	public AADCommand Command => AADCommand.GetMetadataInfo;

	public Type ParametersType => typeof(ModuleInfo);

	public Type ResultType => typeof(MetadataInfo);

	public bool Execute(ISerializable parameters_, [NotNullWhen(true)] out ISerializable? result_) {
		result_ = null;
		if (parameters_ is not ModuleInfo parameters)
			return false;

		var module = FindModule(parameters);
		if (module is null)
			return false;

		var metadataProvider = MetadataLocator.MetadataInfo.Create(module);
		var metadata = new MetadataInfo(metadataProvider);
		result_ = metadata;
		return true;
	}

	Module? FindModule(ModuleInfo moduleInfo) {
		var domain = AppDomain.CurrentDomain;
		if (domain.Id != moduleInfo.DomainId)
			return null;

		foreach (var assembly in domain.GetAssemblies()) {
			var assemblyName = assembly.GetName().Name;
			if (assemblyName != moduleInfo.AssemblyName)
				continue;

			foreach (var module in assembly.GetLoadedModules()) {
				if (module.ScopeName == moduleInfo.Name)
					return module;
			}
		}

		return null;
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/Handlers/GetModulesHandler.cs
================================================
using System;

namespace ExtremeDumper.AntiAntiDump.Handlers;

sealed class GetModulesHandler : ICommandHandler {
	public AADCommand Command => AADCommand.GetModules;

	public Type ParametersType => typeof(EmptySerializable);

	public Type ResultType => typeof(ModuleInfos);

	public bool Execute(ISerializable parameters, out ISerializable result) {
		var moduleInfos = new ModuleInfos();
		var domain = AppDomain.CurrentDomain;
		uint domainId = (uint)domain.Id;
		var domainName = domain.FriendlyName;
		foreach (var assembly in domain.GetAssemblies()) {
			var assemblyName = assembly.GetName().Name;
			foreach (var module in assembly.GetLoadedModules()) {
				var moduleInfo = new ModuleInfo {
					Name = module.ScopeName,
					AssemblyName = assemblyName,
					DomainId = domainId,
					DomainName = domainName
				};
				moduleInfos.Add(moduleInfo);
			}
		}
		result = moduleInfos;
		return true;
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/Handlers/GetPEInfoHandler.cs
================================================
using System;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace ExtremeDumper.AntiAntiDump.Handlers;

sealed class GetPEInfoHandler : ICommandHandler {
	public AADCommand Command => AADCommand.GetPEInfo;

	public Type ParametersType => typeof(ModuleInfo);

	public Type ResultType => typeof(PEInfo);

	public bool Execute(ISerializable parameters_, [NotNullWhen(true)] out ISerializable? result_) {
		result_ = null;
		if (parameters_ is not ModuleInfo parameters)
			return false;

		var module = FindModule(parameters);
		if (module is null)
			return false;

		var peInfoProvider = MetadataLocator.PEInfo.Create(module);
		var peInfo = new PEInfo(peInfoProvider);
		result_ = peInfo;
		return true;
	}

	Module? FindModule(ModuleInfo moduleInfo) {
		var domain = AppDomain.CurrentDomain;
		if (domain.Id != moduleInfo.DomainId)
			return null;

		foreach (var assembly in domain.GetAssemblies()) {
			var assemblyName = assembly.GetName().Name;
			if (assemblyName != moduleInfo.AssemblyName)
				continue;

			foreach (var module in assembly.GetLoadedModules()) {
				if (module.ScopeName == moduleInfo.Name)
					return module;
			}
		}

		return null;
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/Handlers/GetRuntimeInfoHandler.cs
================================================
using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace ExtremeDumper.AntiAntiDump.Handlers;

sealed class GetRuntimeInfoHandler : ICommandHandler {
	public AADCommand Command => AADCommand.GetRuntimeInfo;

	public Type ParametersType => typeof(EmptySerializable);

	public Type ResultType => typeof(RuntimeInfo);

	public bool Execute(ISerializable parameters, [NotNullWhen(true)] out ISerializable? result) {
		var flavor = GetRuntimeFlavor();
		var fileName = GetRuntimeFileName(flavor);
		var fileVersion = GetFileVersion(fileName);
		result = new RuntimeInfo {
			Flavor = flavor,
			FileName = fileName,
			FileVersion = fileVersion
		};
		return true;
	}

	static RuntimeFlavor GetRuntimeFlavor() {
		var assemblyProductAttribute = (AssemblyProductAttribute)typeof(object).Assembly.GetCustomAttributes(typeof(AssemblyProductAttribute), false)[0];
		string product = assemblyProductAttribute.Product;
		if (product.EndsWith("Framework", StringComparison.Ordinal)) return RuntimeFlavor.Framework;
		else if (product.EndsWith("Core", StringComparison.Ordinal)) return RuntimeFlavor.Core;
		else if (product.EndsWith("NET", StringComparison.Ordinal)) return RuntimeFlavor.Net;
		else throw new NotSupportedException();
	}

	static string GetRuntimeFileName(RuntimeFlavor flavor) {
		switch (flavor) {
		case RuntimeFlavor.Framework:
			return Environment.Version.Major == 4 ? "clr.dll" : "mscorwks.dll";
		case RuntimeFlavor.Core:
		case RuntimeFlavor.Net:
			return "coreclr.dll";
		default:
			throw new NotSupportedException();
		}
	}

	static Version GetFileVersion(string fileName) {
		var path = new StringBuilder(MAX_PATH);
		if (!GetModuleFileName(GetModuleHandle(fileName), path, MAX_PATH))
			return new Version();
		var versionInfo = FileVersionInfo.GetVersionInfo(path.ToString());
		return new Version(versionInfo.FileMajorPart, versionInfo.FileMinorPart, versionInfo.FileBuildPart, versionInfo.FilePrivatePart);
	}

	#region NativeMethods
	const ushort MAX_PATH = 260;

	[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, SetLastError = true)]
	static extern nuint GetModuleHandle(string? lpModuleName);

	[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, SetLastError = true)]
	[return: MarshalAs(UnmanagedType.Bool)]
	static extern bool GetModuleFileName(nuint hModule, StringBuilder lpFilename, uint nSize);
	#endregion
}



================================================
File: ExtremeDumper.AntiAntiDump/System/Array2.cs
================================================
namespace System;

static class Array2 {
	public static T[] Empty<T>() {
		return EmptyArray<T>.Value;
	}

	static class EmptyArray<T> {
#pragma warning disable CA1825
		public static readonly T[] Value = new T[0];
#pragma warning restore CA1825
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/System/HandleProcessCorruptedStateExceptionsAttribute.cs
================================================
#if !NET40_OR_GREATER
namespace System.Runtime.ExceptionServices;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
sealed class HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
#endif



================================================
File: ExtremeDumper.AntiAntiDump/System/NRT.cs
================================================
#if NETFRAMEWORK || NETSTANDARD2_0
namespace System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
sealed class NotNullWhenAttribute : Attribute {
	public bool ReturnValue { get; }

	public NotNullWhenAttribute(bool returnValue) {
		ReturnValue = returnValue;
	}
}

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
sealed class DoesNotReturnAttribute : Attribute {
	public DoesNotReturnAttribute() {
	}
}

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
sealed class DoesNotReturnIfAttribute : Attribute {
	public bool ParameterValue { get; }

	public DoesNotReturnIfAttribute(bool parameterValue) {
		ParameterValue = parameterValue;
	}
}
#endif



================================================
File: ExtremeDumper.AntiAntiDump/System/NRT_Helpers.cs
================================================
using System.Diagnostics.CodeAnalysis;

namespace System.Diagnostics;

static class Debug2 {
	[Conditional("DEBUG")]
	public static void Assert([DoesNotReturnIf(false)] bool condition) {
		Debug.Assert(condition);
	}

	[Conditional("DEBUG")]
	public static void Assert([DoesNotReturnIf(false)] bool condition, string? message) {
		Debug.Assert(condition, message);
	}
}



================================================
File: ExtremeDumper.AntiAntiDump/System/Extensions/ExceptionExtensions.cs
================================================
using System.Reflection;
using System.Text;

namespace System.Extensions;

static class ExceptionExtensions {
	public static Exception GetInmostException(this Exception exception) {
		if (exception is null)
			throw new ArgumentNullException(nameof(exception));

		return exception.InnerException is null ? exception : exception.InnerException.GetInmostException();
	}

	public static string ToFullString(this Exception exception) {
		if (exception is null)
			throw new ArgumentNullException(nameof(exception));

		var sb = new StringBuilder();
		DumpException(exception, sb);
		return sb.ToString();
	}

	static void DumpException(Exception exception, StringBuilder sb) {
		exception ??= new ArgumentNullException(nameof(exception), "<No exception object>");
		sb.AppendLine($"Type: {Environment.NewLine}{exception.GetType().FullName}");
		sb.AppendLine($"Message: {Environment.NewLine}{exception.Message}");
		sb.AppendLine($"Source: {Environment.NewLine}{exception.Source}");
		sb.AppendLine($"StackTrace: {Environment.NewLine}{exception.StackTrace}");
		sb.AppendLine($"TargetSite: {Environment.NewLine}{exception.TargetSite}");
		sb.AppendLine("----------------------------------------");
		if (exception.InnerException is not null)
			DumpException(exception.InnerException, sb);
		if (exception is ReflectionTypeLoadException reflectionTypeLoadException) {
			foreach (var loaderException in reflectionTypeLoadException.LoaderExceptions)
				DumpException(loaderException, sb);
		}
	}
}



================================================
File: ExtremeDumper.LoaderHook/ExtremeDumper.LoaderHook.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a0553ca6-87ff-4a7f-8452-8fd5c6b6525f}</ProjectGuid>
    <RootNamespace>ExtremeDumperLoaderHook</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>obj\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;EXTREMEDUMPERLOADERHOOK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ModuleDefinitionFile>LoaderHook.def</ModuleDefinitionFile>
      <AdditionalDependencies>shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;EXTREMEDUMPERLOADERHOOK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ModuleDefinitionFile>LoaderHook.def</ModuleDefinitionFile>
      <AdditionalDependencies>shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;EXTREMEDUMPERLOADERHOOK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ModuleDefinitionFile>LoaderHook.def</ModuleDefinitionFile>
      <AdditionalDependencies>shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;EXTREMEDUMPERLOADERHOOK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ModuleDefinitionFile>LoaderHook.def</ModuleDefinitionFile>
      <AdditionalDependencies>shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Libraries\Detours\src\creatwth.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\detours.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\disasm.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\disolarm.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\disolarm64.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\disolia64.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\disolx64.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\disolx86.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\image.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\modules.cpp" />
    <ClCompile Include="..\Libraries\Detours\src\uimports.cpp">
      <ExcludedFromBuild>true</ExcludedFromBuild>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Libraries\Detours\src\detours.h" />
    <ClInclude Include="..\Libraries\Detours\src\detver.h" />
    <ClInclude Include="hijackversion.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.c" />
    <ClCompile Include="hijackversion.c" />
    <ClCompile Include="loaderhook.c" />
  </ItemGroup>
  <ItemGroup>
    <None Include="loaderhook.def" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="loaderhook.h" />
  </ItemGroup>
  <ItemGroup Condition="'$(Platform)'=='Win32'">
    <MASM Include="hijackversion_jump_x86.asm" />
    <MASM Include="stubx86.asm" />
  </ItemGroup>
  <ItemGroup Condition="'$(Platform)'=='x64'">
    <MASM Include="hijackversion_jump_x64.asm" />
    <MASM Include="stubx64.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>


================================================
File: ExtremeDumper.LoaderHook/ExtremeDumper.LoaderHook.vcxproj.filters
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Detours">
      <UniqueIdentifier>{933964f2-382b-4ebb-aa02-4d2c0c21c19f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Hijack">
      <UniqueIdentifier>{a57b3a7e-0784-4ed5-a81b-84aade94b064}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Libraries\Detours\src\creatwth.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\detours.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\disasm.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\disolarm.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\disolarm64.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\disolia64.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\disolx64.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\disolx86.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\image.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\modules.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="..\Libraries\Detours\src\uimports.cpp">
      <Filter>Detours</Filter>
    </ClCompile>
    <ClCompile Include="hijackversion.c">
      <Filter>Hijack</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Libraries\Detours\src\detours.h">
      <Filter>Detours</Filter>
    </ClInclude>
    <ClInclude Include="..\Libraries\Detours\src\detver.h">
      <Filter>Detours</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hijackversion.h">
      <Filter>Hijack</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="loaderhook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="loaderhook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="loaderhook.def">
      <Filter>Header Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="hijackversion_jump_x64.asm">
      <Filter>Hijack</Filter>
    </MASM>
    <MASM Include="hijackversion_jump_x86.asm">
      <Filter>Hijack</Filter>
    </MASM>
    <MASM Include="stubx64.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="stubx86.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>


================================================
File: ExtremeDumper.LoaderHook/debugmacros.h
================================================
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
//*****************************************************************************
// DebugMacros.h
//
// Wrappers for Debugging purposes.
//
//*****************************************************************************

#pragma once

#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { goto LABEL; } } while (0)

#define IfFailRet(EXPR) \
do { hr = (EXPR); if(FAILED(hr)) { return (hr); } } while (0)

#define IfFailWin32Ret(EXPR) \
do { hr = (EXPR); if(hr != ERROR_SUCCESS) { hr = HRESULT_FROM_WIN32(hr); return hr;} } while (0)

#define IfFailWin32Goto(EXPR, LABEL) \
do { hr = (EXPR); if(hr != ERROR_SUCCESS) { hr = HRESULT_FROM_WIN32(hr); goto LABEL; } } while (0)

#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)

#define IfFailWin32Go(EXPR) IfFailWin32Goto(EXPR, ErrExit)



================================================
File: ExtremeDumper.LoaderHook/dllmain.c
================================================
#define WIN32_LEAN_AND_MEAN
#include "loaderhook.h"
#include "utils.h"
#include "../Libraries/Detours/src/detours.h"
#include <crtdbg.h>
#include <shlwapi.h>
#include <stdio.h>
#include "hijackversion.h"

static LDHK_MONITOR_INFO g_info = { 0 };
static BOOL g_isSelf = FALSE;
static BOOL g_isHijack = FALSE;
static BOOL g_isInitialized = FALSE;

DWORD WINAPI RunMonitorLoop(LPVOID lpThreadParameter) {
	return LoaderHookMonitorLoop((PLDHK_MONITOR_INFO)lpThreadParameter);
}

BOOL ReadMonitorInfo(WCHAR* path, LDHK_MONITOR_INFO* info) {
	if (path == NULL || info == NULL)
		return FALSE;

	FILE* file = NULL;
	if (_wfopen_s(&file, path, L"rb+") != 0 || file == NULL)
		return FALSE;
	if (fread_s(&g_info, sizeof(LDHK_MONITOR_INFO), sizeof(LDHK_MONITOR_INFO), 1, file) != 1)
		return FALSE;
	fclose(file);
	return TRUE;
}

VOID Initialize() {
	if (g_isInitialized)
		return;

	WCHAR variable[20] = { 0 };
	GetEnvironmentVariable(L"EXTREMEDUMPER_MAGIC", variable, 20);
	g_isSelf = wcscmp(variable, L"C41F3A60") == 0;
	if (g_isSelf)
		goto Exit;
	// If current dll is loaded in ExtremeDumper itself, don't initialize

	HINSTANCE hLoaderHook = NULL;
	if (!GetCurrentModuleHandle(&hLoaderHook))
		goto Exit;
	WCHAR configPath[MAX_PATH] = { 0 };
	GetModuleFileName(hLoaderHook, configPath, MAX_PATH);
	PathRemoveFileSpec(configPath);
	PathAppend(configPath, L"LoaderHook.dat");
	// Get config path

	if (!ReadMonitorInfo(configPath, &g_info)) {
		LDHK_MONITOR_INFO info = {
			.Sleep = 1,
			.Flags = LDHK_MONITOR_MSCORWKS | LDHK_MONITOR_CLR | LDHK_MONITOR_CORECLR
		};
		g_info = info;
	}
	// Read config

	WCHAR fileName[MAX_PATH] = { 0 };
	GetModuleFileName(hLoaderHook, fileName, MAX_PATH);
	PathStripPath(fileName);
	g_isHijack = _wcsicmp(fileName, L"version.dll") == 0;
	// Check hijack mode

Exit:
	g_isInitialized = TRUE;
	return;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	Initialize();
	if (g_isSelf || DetourIsHelperProcess())
		return TRUE;

	if (g_isHijack)
		HijackDllMain(hModule, ul_reason_for_call, lpReserved);
	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		AllocConsole();
		FILE* dummy = NULL;
		freopen_s(&dummy, "CONIN$", "r", stdin);
		freopen_s(&dummy, "CONOUT$", "w", stderr);
		freopen_s(&dummy, "CONOUT$", "w", stdout);

		wprintf_s(L"[LDHK] DllMain: Loaded\n");
		DetourRestoreAfterWith();
		CreateThread(NULL, 0, RunMonitorLoop, &g_info, 0, NULL);
		// Create thread to run monitor loop
		wprintf_s(L"[LDHK] DllMain: Monitor created\n");
		break;
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}



================================================
File: ExtremeDumper.LoaderHook/hijackversion.c
================================================

//
// created by AheadLib
// github:https://github.com/strivexjun/AheadLib-x86-x64
//

#include "hijackversion.h"
#include <shlwapi.h>
#include <stdio.h>

#pragma comment( lib, "shlwapi.lib")

#ifndef _WIN64
#pragma comment(linker, "/EXPORT:GetFileVersionInfoA=_AheadLib_GetFileVersionInfoA,@1")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoByHandle=_AheadLib_GetFileVersionInfoByHandle,@2")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoExA=_AheadLib_GetFileVersionInfoExA,@3")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoExW=_AheadLib_GetFileVersionInfoExW,@4")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeA=_AheadLib_GetFileVersionInfoSizeA,@5")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExA=_AheadLib_GetFileVersionInfoSizeExA,@6")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExW=_AheadLib_GetFileVersionInfoSizeExW,@7")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeW=_AheadLib_GetFileVersionInfoSizeW,@8")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoW=_AheadLib_GetFileVersionInfoW,@9")
#pragma comment(linker, "/EXPORT:VerFindFileA=_AheadLib_VerFindFileA,@10")
#pragma comment(linker, "/EXPORT:VerFindFileW=_AheadLib_VerFindFileW,@11")
#pragma comment(linker, "/EXPORT:VerInstallFileA=_AheadLib_VerInstallFileA,@12")
#pragma comment(linker, "/EXPORT:VerInstallFileW=_AheadLib_VerInstallFileW,@13")
#pragma comment(linker, "/EXPORT:VerLanguageNameA=KERNEL32.VerLanguageNameA,@14")
#pragma comment(linker, "/EXPORT:VerLanguageNameW=KERNEL32.VerLanguageNameW,@15")
#pragma comment(linker, "/EXPORT:VerQueryValueA=_AheadLib_VerQueryValueA,@16")
#pragma comment(linker, "/EXPORT:VerQueryValueW=_AheadLib_VerQueryValueW,@17")
#else
#pragma comment(linker, "/EXPORT:GetFileVersionInfoA=AheadLib_GetFileVersionInfoA,@1")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoByHandle=AheadLib_GetFileVersionInfoByHandle,@2")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoExA=AheadLib_GetFileVersionInfoExA,@3")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoExW=AheadLib_GetFileVersionInfoExW,@4")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeA=AheadLib_GetFileVersionInfoSizeA,@5")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExA=AheadLib_GetFileVersionInfoSizeExA,@6")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExW=AheadLib_GetFileVersionInfoSizeExW,@7")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeW=AheadLib_GetFileVersionInfoSizeW,@8")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoW=AheadLib_GetFileVersionInfoW,@9")
#pragma comment(linker, "/EXPORT:VerFindFileA=AheadLib_VerFindFileA,@10")
#pragma comment(linker, "/EXPORT:VerFindFileW=AheadLib_VerFindFileW,@11")
#pragma comment(linker, "/EXPORT:VerInstallFileA=AheadLib_VerInstallFileA,@12")
#pragma comment(linker, "/EXPORT:VerInstallFileW=AheadLib_VerInstallFileW,@13")
#pragma comment(linker, "/EXPORT:VerLanguageNameA=KERNEL32.VerLanguageNameA,@14")
#pragma comment(linker, "/EXPORT:VerLanguageNameW=KERNEL32.VerLanguageNameW,@15")
#pragma comment(linker, "/EXPORT:VerQueryValueA=AheadLib_VerQueryValueA,@16")
#pragma comment(linker, "/EXPORT:VerQueryValueW=AheadLib_VerQueryValueW,@17")
#endif


PVOID pfnAheadLib_GetFileVersionInfoA = NULL;
PVOID pfnAheadLib_GetFileVersionInfoByHandle = NULL;
PVOID pfnAheadLib_GetFileVersionInfoExA = NULL;
PVOID pfnAheadLib_GetFileVersionInfoExW = NULL;
PVOID pfnAheadLib_GetFileVersionInfoSizeA = NULL;
PVOID pfnAheadLib_GetFileVersionInfoSizeExA = NULL;
PVOID pfnAheadLib_GetFileVersionInfoSizeExW = NULL;
PVOID pfnAheadLib_GetFileVersionInfoSizeW = NULL;
PVOID pfnAheadLib_GetFileVersionInfoW = NULL;
PVOID pfnAheadLib_VerFindFileA = NULL;
PVOID pfnAheadLib_VerFindFileW = NULL;
PVOID pfnAheadLib_VerInstallFileA = NULL;
PVOID pfnAheadLib_VerInstallFileW = NULL;
PVOID pfnAheadLib_VerQueryValueA = NULL;
PVOID pfnAheadLib_VerQueryValueW = NULL;


static
HMODULE g_OldModule = NULL;

VOID WINAPI Free()
{
	if (g_OldModule)
	{
		FreeLibrary(g_OldModule);
	}
}


BOOL WINAPI Load()
{
	TCHAR tzPath[MAX_PATH];

	GetSystemDirectory(tzPath, MAX_PATH);

	lstrcat(tzPath, TEXT("\\version.dll"));

	g_OldModule = LoadLibrary(tzPath);

	return (g_OldModule != NULL);
}


FARPROC WINAPI GetAddress(PCSTR pszProcName)
{
	FARPROC fpAddress;

	fpAddress = GetProcAddress(g_OldModule, pszProcName);
	return fpAddress;
}

BOOL WINAPI Init()
{
	pfnAheadLib_GetFileVersionInfoA = GetAddress("GetFileVersionInfoA");
	pfnAheadLib_GetFileVersionInfoByHandle = GetAddress("GetFileVersionInfoByHandle");
	pfnAheadLib_GetFileVersionInfoExA = GetAddress("GetFileVersionInfoExA");
	pfnAheadLib_GetFileVersionInfoExW = GetAddress("GetFileVersionInfoExW");
	pfnAheadLib_GetFileVersionInfoSizeA = GetAddress("GetFileVersionInfoSizeA");
	pfnAheadLib_GetFileVersionInfoSizeExA = GetAddress("GetFileVersionInfoSizeExA");
	pfnAheadLib_GetFileVersionInfoSizeExW = GetAddress("GetFileVersionInfoSizeExW");
	pfnAheadLib_GetFileVersionInfoSizeW = GetAddress("GetFileVersionInfoSizeW");
	pfnAheadLib_GetFileVersionInfoW = GetAddress("GetFileVersionInfoW");
	pfnAheadLib_VerFindFileA = GetAddress("VerFindFileA");
	pfnAheadLib_VerFindFileW = GetAddress("VerFindFileW");
	pfnAheadLib_VerInstallFileA = GetAddress("VerInstallFileA");
	pfnAheadLib_VerInstallFileW = GetAddress("VerInstallFileW");
	pfnAheadLib_VerQueryValueA = GetAddress("VerQueryValueA");
	pfnAheadLib_VerQueryValueW = GetAddress("VerQueryValueW");
	return TRUE;
}	

BOOL APIENTRY HijackDllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		Load();
		Init();
		wprintf_s(L"[LDHK] HijackDllMain: Loaded\n");
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		Free();
	}

	return TRUE;
}



================================================
File: ExtremeDumper.LoaderHook/hijackversion.h
================================================
#pragma once

#include <windows.h>

BOOL APIENTRY HijackDllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved);



================================================
File: ExtremeDumper.LoaderHook/hijackversion_jump_x64.asm
================================================

;
; created by AheadLib
; github:https://github.com/strivexjun/AheadLib-x86-x64
;

.DATA
EXTERN pfnAheadLib_GetFileVersionInfoA:dq;
EXTERN pfnAheadLib_GetFileVersionInfoByHandle:dq;
EXTERN pfnAheadLib_GetFileVersionInfoExA:dq;
EXTERN pfnAheadLib_GetFileVersionInfoExW:dq;
EXTERN pfnAheadLib_GetFileVersionInfoSizeA:dq;
EXTERN pfnAheadLib_GetFileVersionInfoSizeExA:dq;
EXTERN pfnAheadLib_GetFileVersionInfoSizeExW:dq;
EXTERN pfnAheadLib_GetFileVersionInfoSizeW:dq;
EXTERN pfnAheadLib_GetFileVersionInfoW:dq;
EXTERN pfnAheadLib_VerFindFileA:dq;
EXTERN pfnAheadLib_VerFindFileW:dq;
EXTERN pfnAheadLib_VerInstallFileA:dq;
EXTERN pfnAheadLib_VerInstallFileW:dq;
EXTERN pfnAheadLib_VerQueryValueA:dq;
EXTERN pfnAheadLib_VerQueryValueW:dq;

.CODE
AheadLib_GetFileVersionInfoA PROC
	jmp pfnAheadLib_GetFileVersionInfoA
AheadLib_GetFileVersionInfoA ENDP

AheadLib_GetFileVersionInfoByHandle PROC
	jmp pfnAheadLib_GetFileVersionInfoByHandle
AheadLib_GetFileVersionInfoByHandle ENDP

AheadLib_GetFileVersionInfoExA PROC
	jmp pfnAheadLib_GetFileVersionInfoExA
AheadLib_GetFileVersionInfoExA ENDP

AheadLib_GetFileVersionInfoExW PROC
	jmp pfnAheadLib_GetFileVersionInfoExW
AheadLib_GetFileVersionInfoExW ENDP

AheadLib_GetFileVersionInfoSizeA PROC
	jmp pfnAheadLib_GetFileVersionInfoSizeA
AheadLib_GetFileVersionInfoSizeA ENDP

AheadLib_GetFileVersionInfoSizeExA PROC
	jmp pfnAheadLib_GetFileVersionInfoSizeExA
AheadLib_GetFileVersionInfoSizeExA ENDP

AheadLib_GetFileVersionInfoSizeExW PROC
	jmp pfnAheadLib_GetFileVersionInfoSizeExW
AheadLib_GetFileVersionInfoSizeExW ENDP

AheadLib_GetFileVersionInfoSizeW PROC
	jmp pfnAheadLib_GetFileVersionInfoSizeW
AheadLib_GetFileVersionInfoSizeW ENDP

AheadLib_GetFileVersionInfoW PROC
	jmp pfnAheadLib_GetFileVersionInfoW
AheadLib_GetFileVersionInfoW ENDP

AheadLib_VerFindFileA PROC
	jmp pfnAheadLib_VerFindFileA
AheadLib_VerFindFileA ENDP

AheadLib_VerFindFileW PROC
	jmp pfnAheadLib_VerFindFileW
AheadLib_VerFindFileW ENDP

AheadLib_VerInstallFileA PROC
	jmp pfnAheadLib_VerInstallFileA
AheadLib_VerInstallFileA ENDP

AheadLib_VerInstallFileW PROC
	jmp pfnAheadLib_VerInstallFileW
AheadLib_VerInstallFileW ENDP

AheadLib_VerQueryValueA PROC
	jmp pfnAheadLib_VerQueryValueA
AheadLib_VerQueryValueA ENDP

AheadLib_VerQueryValueW PROC
	jmp pfnAheadLib_VerQueryValueW
AheadLib_VerQueryValueW ENDP


END



================================================
File: ExtremeDumper.LoaderHook/hijackversion_jump_x86.asm
================================================

;
; created by AheadLib
; github:https://github.com/strivexjun/AheadLib-x86-x64
;

.MODEL FLAT, C

.DATA
EXTERN pfnAheadLib_GetFileVersionInfoA:DWORD;
EXTERN pfnAheadLib_GetFileVersionInfoByHandle:DWORD;
EXTERN pfnAheadLib_GetFileVersionInfoExA:DWORD;
EXTERN pfnAheadLib_GetFileVersionInfoExW:DWORD;
EXTERN pfnAheadLib_GetFileVersionInfoSizeA:DWORD;
EXTERN pfnAheadLib_GetFileVersionInfoSizeExA:DWORD;
EXTERN pfnAheadLib_GetFileVersionInfoSizeExW:DWORD;
EXTERN pfnAheadLib_GetFileVersionInfoSizeW:DWORD;
EXTERN pfnAheadLib_GetFileVersionInfoW:DWORD;
EXTERN pfnAheadLib_VerFindFileA:DWORD;
EXTERN pfnAheadLib_VerFindFileW:DWORD;
EXTERN pfnAheadLib_VerInstallFileA:DWORD;
EXTERN pfnAheadLib_VerInstallFileW:DWORD;
EXTERN pfnAheadLib_VerQueryValueA:DWORD;
EXTERN pfnAheadLib_VerQueryValueW:DWORD;

.CODE
AheadLib_GetFileVersionInfoA PROC
	jmp pfnAheadLib_GetFileVersionInfoA
AheadLib_GetFileVersionInfoA ENDP

AheadLib_GetFileVersionInfoByHandle PROC
	jmp pfnAheadLib_GetFileVersionInfoByHandle
AheadLib_GetFileVersionInfoByHandle ENDP

AheadLib_GetFileVersionInfoExA PROC
	jmp pfnAheadLib_GetFileVersionInfoExA
AheadLib_GetFileVersionInfoExA ENDP

AheadLib_GetFileVersionInfoExW PROC
	jmp pfnAheadLib_GetFileVersionInfoExW
AheadLib_GetFileVersionInfoExW ENDP

AheadLib_GetFileVersionInfoSizeA PROC
	jmp pfnAheadLib_GetFileVersionInfoSizeA
AheadLib_GetFileVersionInfoSizeA ENDP

AheadLib_GetFileVersionInfoSizeExA PROC
	jmp pfnAheadLib_GetFileVersionInfoSizeExA
AheadLib_GetFileVersionInfoSizeExA ENDP

AheadLib_GetFileVersionInfoSizeExW PROC
	jmp pfnAheadLib_GetFileVersionInfoSizeExW
AheadLib_GetFileVersionInfoSizeExW ENDP

AheadLib_GetFileVersionInfoSizeW PROC
	jmp pfnAheadLib_GetFileVersionInfoSizeW
AheadLib_GetFileVersionInfoSizeW ENDP

AheadLib_GetFileVersionInfoW PROC
	jmp pfnAheadLib_GetFileVersionInfoW
AheadLib_GetFileVersionInfoW ENDP

AheadLib_VerFindFileA PROC
	jmp pfnAheadLib_VerFindFileA
AheadLib_VerFindFileA ENDP

AheadLib_VerFindFileW PROC
	jmp pfnAheadLib_VerFindFileW
AheadLib_VerFindFileW ENDP

AheadLib_VerInstallFileA PROC
	jmp pfnAheadLib_VerInstallFileA
AheadLib_VerInstallFileA ENDP

AheadLib_VerInstallFileW PROC
	jmp pfnAheadLib_VerInstallFileW
AheadLib_VerInstallFileW ENDP

AheadLib_VerQueryValueA PROC
	jmp pfnAheadLib_VerQueryValueA
AheadLib_VerQueryValueA ENDP

AheadLib_VerQueryValueW PROC
	jmp pfnAheadLib_VerQueryValueW
AheadLib_VerQueryValueW ENDP


END



================================================
File: ExtremeDumper.LoaderHook/loaderhook.c
================================================
#include "loaderhook.h"
#include "../Libraries/Detours/src/detours.h"
#include <shlwapi.h>
#include <stdio.h>
#include "utils.h"

PVOID LoadImageOriginal_Mscorwks = NULL;
EXTERN_C VOID LoadImageStub_Mscorwks();

PVOID LoadImageOriginal_CLR = NULL;
EXTERN_C VOID LoadImageStub_CLR();

static INT32 g_index = 0;

BOOL GetNextFilePath(WCHAR* path) {
	GetTempPath(MAX_PATH, path);
	WCHAR buffer1[MAX_PATH] = { 0 };
	GetModuleFileName(NULL, buffer1, MAX_PATH);
	PathStripPath(buffer1);
	PathAppend(path, buffer1);
	wcscat_s(path, MAX_PATH - wcslen(path), L"_Dumps");
	CreateDirectory(path, NULL);
	if (!PathIsDirectory(path))
		return FALSE;
	size_t index = wcslen(path);
	for (; g_index < MAXINT; g_index++) {
		WCHAR buffer2[20] = { 0 };
		_itow_s(g_index, buffer2, 20, 10);
		PathAppend(path, buffer2);
		wcscat_s(path, MAX_PATH - wcslen(path), L".dll");
		if (!PathFileExists(path))
			return TRUE;
		PathRemoveFileSpec(path);
	}
	return FALSE;
}

VOID DumpCallback(PBYTE peImage, UINT32 size) {
	wprintf_s(L"[LDHK] DumpCallback: peImage=%p size=%X\n", peImage, size);
	WCHAR path[MAX_PATH] = { 0 };
	if (!GetNextFilePath(path))
		return;
	FILE* file = NULL;
	if (_wfopen_s(&file, path, L"wb+") != 0 || file == NULL)
		return;
	if (fwrite(peImage, 1, size, file) != size)
		return;
	fflush(file);
	fclose(file);
	wprintf_s(L"[LDHK] DumpCallback: Saved to %s\n", path);
}

PVOID FindBytes(PVOID startAddress, UINT32 size, PVOID pattern, UINT32 patternSize) {
	for (PBYTE p = (PBYTE)startAddress, end = p + (INT32)(size - patternSize); p < end; p++) {
		if (memcmp(p, pattern, patternSize) == 0)
			return p;
	}
	return NULL;
}

PVOID FindECallFunction(HINSTANCE hModule, PCSTR name) {
	if (hModule == NULL || name == NULL)
		goto ErrExit;

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((PBYTE)hModule + dosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER sectionHeaders = (PIMAGE_SECTION_HEADER)((PBYTE)&ntHeaders->OptionalHeader + ntHeaders->FileHeader.SizeOfOptionalHeader);
	PIMAGE_SECTION_HEADER textSectionHeader = sectionHeaders;
	if (strcmp(textSectionHeader->Name, ".text") != 0)
		goto ErrExit;

	PVOID startAddress = (PBYTE)hModule;
	UINT32 size = ntHeaders->OptionalHeader.SizeOfImage;
	PVOID pFuncName = FindBytes(startAddress, size, (PVOID)name, (UINT32)strlen(name) + 1);
	if (pFuncName == NULL)
		goto ErrExit;
	PVOID ppFuncName = FindBytes(startAddress, size, &pFuncName, 4);
	if (ppFuncName == NULL)
		goto ErrExit;
	PVOID funcAddr = ((PVOID*)ppFuncName)[-1];
	if ((PBYTE)funcAddr <= (PBYTE)hModule + textSectionHeader->VirtualAddress || (PBYTE)funcAddr >= (PBYTE)hModule + textSectionHeader->VirtualAddress + size)
		goto ErrExit;
	return funcAddr;

ErrExit:
	return NULL;
}

BOOL InstallHook(PVOID* ppPointer, PVOID pDetour) {
	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());
	DetourAttach(ppPointer, pDetour);
	BOOL b = DetourTransactionCommit() == NO_ERROR;
	wprintf_s(L"[LDHK] InstallHook: %d\n", b);
	return b;
}

_Success_(SUCCEEDED(return))
HRESULT WINAPI LoaderHookCreateProcess(_In_ PCWSTR applicationName, _Inout_opt_ PWSTR commandLine) {
	if (applicationName == NULL)
		return E_INVALIDARG;

	WCHAR szFullExe[MAX_PATH] = { 0 };
	GetFullPathName(applicationName, MAX_PATH, szFullExe, NULL);
	WCHAR currentDirectory[MAX_PATH] = { 0 };
	wcscpy_s(currentDirectory, MAX_PATH, szFullExe);
	PathRemoveFileSpec(currentDirectory);

	//SECURITY_ATTRIBUTES securityAttributes = { 0 };
	//securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	//securityAttributes.bInheritHandle = TRUE;
	STARTUPINFO startupInfo = { 0 };
	startupInfo.cb = sizeof(STARTUPINFO);
	//HANDLE hStdOutputRead = NULL;
	//CreatePipe(&hStdOutputRead, &startupInfo.hStdOutput, &securityAttributes, 0);
	//startupInfo.dwFlags |= STARTF_USESTDHANDLES;
	PROCESS_INFORMATION processInformation = { 0 };

	CHAR dllPath[MAX_PATH];
	HINSTANCE hLoaderHook = NULL;
	GetCurrentModuleHandle(&hLoaderHook);
	GetModuleFileNameA(hLoaderHook, dllPath, MAX_PATH);

	BOOL b = DetourCreateProcessWithDll(applicationName, commandLine, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, currentDirectory, &startupInfo, &processInformation, dllPath, NULL);
	return b ? S_OK : E_FAIL;
}

_Success_(SUCCEEDED(return))
HRESULT WINAPI LoaderHookMonitorLoop(_In_ PLDHK_MONITOR_INFO pInfo) {
	if (pInfo == NULL)
		return E_INVALIDARG;

	BYTE foundModules = 0;
	while (foundModules != (pInfo->Flags & LDHK_MONITOR_MODULE_MASK)) {
		HINSTANCE hModule;
		if ((pInfo->Flags & LDHK_MONITOR_MSCORWKS) && !(foundModules & LDHK_MONITOR_MSCORWKS) && (hModule = GetModuleHandle(L"mscorwks.dll"))) {
			PVOID pLoadImage = NULL;
			if (pInfo->LoadImageRVA_Mscorwks) {
				pLoadImage = (PBYTE)hModule + pInfo->LoadImageRVA_Mscorwks;
				wprintf_s(L"[LDHK] LoaderHookMonitorLoop: Found nLoadImage at %p by config\n", pLoadImage);
			}
			if (!pLoadImage) {
				pLoadImage = FindECallFunction(hModule, "nLoadImage");
				wprintf_s(L"[LDHK] LoaderHookMonitorLoop: Found nLoadImage at %p by ECall\n", pLoadImage);
			}
			if (pLoadImage) {
				LoadImageOriginal_Mscorwks = pLoadImage;
				InstallHook(&LoadImageOriginal_Mscorwks, LoadImageStub_Mscorwks);
			}
			foundModules |= LDHK_MONITOR_MSCORWKS;
			wprintf_s(L"[LDHK] LoaderHookMonitorLoop: LDHK_MONITOR_MSCORWKS at %p\n", pLoadImage);
		}
		if ((pInfo->Flags & LDHK_MONITOR_CLR) && !(foundModules & LDHK_MONITOR_CLR) && (hModule = GetModuleHandle(L"clr.dll"))) {
			PVOID pLoadImage = NULL;
			if (pInfo->LoadImageRVA_CLR) {
				pLoadImage = (PBYTE)hModule + pInfo->LoadImageRVA_CLR;
				wprintf_s(L"[LDHK] LoaderHookMonitorLoop: Found nLoadImage at %p by config\n", pLoadImage);
			}
			if (!pLoadImage) {
				pLoadImage = FindECallFunction(hModule, "nLoadImage");
				wprintf_s(L"[LDHK] LoaderHookMonitorLoop: Found nLoadImage at %p by ECall\n", pLoadImage);
			}
			if (pLoadImage) {
				LoadImageOriginal_CLR = pLoadImage;
				InstallHook(&LoadImageOriginal_CLR, LoadImageStub_CLR);
			}
			foundModules |= LDHK_MONITOR_CLR;
			wprintf_s(L"[LDHK] LoaderHookMonitorLoop: LDHK_MONITOR_CLR at %p\n", pLoadImage);
		}
		Sleep(pInfo->Sleep);
	}

	return S_OK;
}



================================================
File: ExtremeDumper.LoaderHook/loaderhook.def
================================================
EXPORTS
	LoaderHookMonitorLoop
	LoaderHookCreateProcess



================================================
File: ExtremeDumper.LoaderHook/loaderhook.h
================================================
#pragma once

#include <windows.h>

#define LDHK_MONITOR_MSCORWKS    0x01
#define LDHK_MONITOR_CLR         0x02
#define LDHK_MONITOR_CORECLR     0x04
#define LDHK_MONITOR_MODULE_MASK 0x07

typedef struct LDHK_MONITOR_INFO {
	BYTE  Sleep;
	BYTE  Flags;
	DWORD LoadImageRVA_Mscorwks;
	DWORD LoadImageRVA_CLR;
	DWORD LoadImageRVA_CoreCLR;
} LDHK_MONITOR_INFO, * PLDHK_MONITOR_INFO;

EXTERN_C_START

// Run loop to monitor clr modules loading and hook it
_Success_(SUCCEEDED(return))
HRESULT WINAPI LoaderHookMonitorLoop(_In_ PLDHK_MONITOR_INFO pInfo);

// Create process with loader hook
_Success_(SUCCEEDED(return))
HRESULT WINAPI LoaderHookCreateProcess(_In_ PCWSTR applicationName, _Inout_opt_ PWSTR commandLine);

EXTERN_C_END



================================================
File: ExtremeDumper.LoaderHook/stubx64.asm
================================================
; macros (from https://github.com/tandasat/HyperPlatform/blob/master/HyperPlatform/Arch/x64/x64.asm)

; Saves all general purpose registers to the stack
PUSHAQ MACRO
    push    rax
    push    rcx
    push    rdx
    push    rbx
    push    -1      ; dummy for rsp
    push    rbp
    push    rsi
    push    rdi
    push    r8
    push    r9
    push    r10
    push    r11
    push    r12
    push    r13
    push    r14
    push    r15
ENDM

; Loads all general purpose registers from the stack
POPAQ MACRO
    pop     r15
    pop     r14
    pop     r13
    pop     r12
    pop     r11
    pop     r10
    pop     r9
    pop     r8
    pop     rdi
    pop     rsi
    pop     rbp
    add     rsp, 8    ; dummy for rsp
    pop     rbx
    pop     rdx
    pop     rcx
    pop     rax
ENDM


.CODE

EXTERN DumpCallback:PROC


DO_CALLBACK_RCX_U1ARRAY MACRO
	pushfq
	PUSHAQ

	sub rsp, 20h
	mov edx, dword ptr [rcx+8h]
	add rcx, 10h
	call DumpCallback
	add rsp, 20h

	POPAQ
	popfq
ENDM


LoadImageStub_Mscorwks PROC
	DO_CALLBACK_RCX_U1ARRAY
	EXTERN LoadImageOriginal_Mscorwks:QWORD
	jmp [LoadImageOriginal_Mscorwks]
LoadImageStub_Mscorwks ENDP


LoadImageStub_CLR PROC
	DO_CALLBACK_RCX_U1ARRAY
	EXTERN LoadImageOriginal_CLR:QWORD
	jmp [LoadImageOriginal_CLR]
LoadImageStub_CLR ENDP

END



================================================
File: ExtremeDumper.LoaderHook/stubx86.asm
================================================
.MODEL FLAT, C

.CODE

EXTERN DumpCallback:PROC


DO_CALLBACK_ECX_U1ARRAY MACRO
	pushfd
	pushad

	push dword ptr [ecx+4h]
	add ecx, 8h
	push ecx
	call DumpCallback
	add esp, 8h

	popad
	popfd
ENDM


LoadImageStub_Mscorwks PROC
	DO_CALLBACK_ECX_U1ARRAY
	EXTERN LoadImageOriginal_Mscorwks:DWORD
	jmp [LoadImageOriginal_Mscorwks]
LoadImageStub_Mscorwks ENDP


LoadImageStub_CLR PROC
	DO_CALLBACK_ECX_U1ARRAY
	EXTERN LoadImageOriginal_CLR:DWORD
	jmp [LoadImageOriginal_CLR]
LoadImageStub_CLR ENDP

END



================================================
File: ExtremeDumper.LoaderHook/utils.h
================================================
#pragma once

#include <windows.h>

static WCHAR __DONT_USE_CURRENT_MODULE_DUMMY = 0;

#define GetCurrentModuleHandle(phModule) GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT | GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, &__DONT_USE_CURRENT_MODULE_DUMMY, phModule)






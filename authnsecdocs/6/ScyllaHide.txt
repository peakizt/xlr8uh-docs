Directory structure:
└── x64dbg-scyllahide/
    ├── README.md
    ├── LICENSE
    ├── ScyllaHide.sln
    ├── changelog.txt
    ├── release.bat
    ├── .editorconfig
    ├── 3rdparty/
    │   ├── README.txt
    │   ├── distorm/
    │   │   ├── config.h
    │   │   ├── decoder.c
    │   │   ├── decoder.h
    │   │   ├── distorm.c
    │   │   ├── distorm.h
    │   │   ├── distorm.vcxproj
    │   │   ├── distorm.vcxproj.filters
    │   │   ├── instructions.c
    │   │   ├── instructions.h
    │   │   ├── insts.c
    │   │   ├── insts.h
    │   │   ├── mnemonics.c
    │   │   ├── mnemonics.h
    │   │   ├── operands.c
    │   │   ├── operands.h
    │   │   ├── prefix.c
    │   │   ├── prefix.h
    │   │   ├── textdefs.c
    │   │   ├── textdefs.h
    │   │   ├── wstring.c
    │   │   ├── wstring.h
    │   │   └── x86defs.h
    │   ├── ntdll/
    │   │   └── ntdll.h
    │   ├── ollydbg1/
    │   │   └── ollyplugindefinitions.h
    │   ├── ollydbg2/
    │   │   └── plugin.h
    │   ├── titan/
    │   │   └── TitanEngine.h
    │   └── x64dbg/
    │       ├── _dbgfunctions.h
    │       ├── _plugin_types.h
    │       ├── _plugins.h
    │       ├── bridgegraph.h
    │       ├── bridgelist.h
    │       ├── bridgemain.h
    │       └── jansson/
    │           ├── jansson.h
    │           ├── jansson_config.h
    │           └── jansson_x64dbg.h
    ├── ConfigCollection/
    │   └── scylla_hide.ini
    ├── Documentation/
    │   ├── README
    │   ├── ScyllaHideDocumentation.tex
    │   ├── gpl-3.0.tex
    │   └── .gitignore
    ├── HookLibrary/
    │   ├── DllMain.cpp
    │   ├── Export.def
    │   ├── HookHelper.cpp
    │   ├── HookHelper.h
    │   ├── HookLibrary.vcxproj
    │   ├── HookLibrary.vcxproj.filters
    │   ├── HookMain.h
    │   ├── HookedFunctions.cpp
    │   ├── HookedFunctions.h
    │   ├── InstrumentationCallbackX64.asm
    │   ├── InstrumentationCallbackX86.asm
    │   ├── Tls.h
    │   └── hook.props
    ├── InjectorCLI/
    │   ├── ApplyHooking.cpp
    │   ├── ApplyHooking.h
    │   ├── CliMain.cpp
    │   ├── DynamicMapping.cpp
    │   ├── DynamicMapping.h
    │   ├── Icon.rc
    │   ├── InjectorCLI.vcxproj
    │   ├── InjectorCLI.vcxproj.filters
    │   ├── RemoteHook.cpp
    │   ├── RemoteHook.h
    │   └── resource.h
    ├── PluginGeneric/
    │   ├── AttachDialog.cpp
    │   ├── AttachDialog.h
    │   ├── Injector.cpp
    │   ├── Injector.h
    │   ├── OllyExceptionHandler.cpp
    │   ├── OllyExceptionHandler.h
    │   ├── OptionsDialog.cpp
    │   ├── OptionsDialog.h
    │   ├── findere.bmp
    │   ├── finderf.bmp
    │   └── searchwindow.cur
    ├── SCMRevGen/
    │   ├── SCMRevGen.vcxproj
    │   └── make_scmrev.h.bat
    ├── Scylla/
    │   ├── Logger.cpp
    │   ├── Logger.h
    │   ├── NtApiShim.h
    │   ├── OsInfo.cpp
    │   ├── OsInfo.h
    │   ├── Peb.cpp
    │   ├── Peb.h
    │   ├── PebHider.cpp
    │   ├── PebHider.h
    │   ├── Resource.h
    │   ├── Scylla.vcxproj
    │   ├── Scylla.vcxproj.filters
    │   ├── Settings.cpp
    │   ├── Settings.h
    │   ├── User32Loader.cpp
    │   ├── User32Loader.h
    │   ├── Util.cpp
    │   ├── Util.h
    │   ├── Version.cpp
    │   ├── Version.h
    │   ├── VersionPatch.cpp
    │   ├── VersionPatch.h
    │   ├── Win32kSyscalls.h
    │   ├── scylla.debug.props
    │   ├── scylla.props
    │   └── scylla.release.props
    ├── ScyllaHideGenericPlugin/
    │   ├── ScyllaHideGenericPlugin.cpp
    │   ├── ScyllaHideGenericPlugin.h
    │   ├── ScyllaHideGenericPlugin.vcxproj
    │   └── ScyllaHideGenericPlugin.vcxproj.filters
    ├── ScyllaHideIDAProPlugin/
    │   ├── IdaServerClient.cpp
    │   ├── IdaServerClient.h
    │   ├── ScyllaHideIDAProPlugin.cpp
    │   ├── ScyllaHideIDAProPlugin.rc
    │   ├── ScyllaHideIDAProPlugin.vcxproj
    │   ├── ScyllaHideIDAProPlugin.vcxproj.filters
    │   └── resource.h
    ├── ScyllaHideIDAServer/
    │   ├── Icon.rc
    │   ├── IdaServerExchange.h
    │   ├── ScyllaHideIDAServer.vcxproj
    │   ├── ScyllaHideIDAServer.vcxproj.filters
    │   ├── idaserver.cpp
    │   ├── idaserver.h
    │   └── resource.h
    ├── ScyllaHideOlly1Plugin/
    │   ├── ScyllaHideOlly1Plugin.cpp
    │   ├── ScyllaHideOlly1Plugin.rc
    │   ├── ScyllaHideOlly1Plugin.vcxproj
    │   ├── ScyllaHideOlly1Plugin.vcxproj.filters
    │   ├── olly1patches.cpp
    │   ├── olly1patches.h
    │   └── resource.h
    ├── ScyllaHideOlly2Plugin/
    │   ├── ScyllaHideOlly2Plugin.cpp
    │   ├── ScyllaHideOlly2Plugin.rc
    │   ├── ScyllaHideOlly2Plugin.vcxproj
    │   ├── ScyllaHideOlly2Plugin.vcxproj.filters
    │   └── resource.h
    ├── ScyllaHideTEPlugin/
    │   ├── ScyllaHideTEPlugin.cpp
    │   ├── ScyllaHideTEPlugin.vcxproj
    │   └── ScyllaHideTEPlugin.vcxproj.filters
    ├── ScyllaHideX64DBGPlugin/
    │   ├── ScyllaHideX64DBGPlugin.cpp
    │   ├── ScyllaHideX64DBGPlugin.rc
    │   ├── ScyllaHideX64DBGPlugin.vcxproj
    │   ├── ScyllaHideX64DBGPlugin.vcxproj.filters
    │   └── resource.h
    ├── ScyllaTest/
    │   ├── ScyllaTest.vcxproj
    │   ├── ScyllaTest.vcxproj.filters
    │   └── main.cpp
    └── .github/
        └── workflows/
            └── build.yml

================================================
File: README.md
================================================
# ScyllaHide

ScyllaHide is an advanced open-source x64/x86 user mode Anti-Anti-Debug library. It hooks various functions to hide debugging. This tool is intended to stay in user mode (ring 3). If you need kernel mode (ring 0) Anti-Anti-Debug, please see [TitanHide](https://github.com/mrexodia/titanhide). Forked from [NtQuery/ScyllaHide](https://bitbucket.org/NtQuery/scyllahide).

ScyllaHide supports various debuggers through plugins:

- OllyDbg [v1](http://www.ollydbg.de) and [v2](http://www.ollydbg.de/version2.html)
- [x64dbg](https://x64dbg.com)
- [Hex-Rays IDA](https://www.hex-rays.com/products/ida/) v6 (not supported)
- TitanEngine v2 ([original](http://www.reversinglabs.com/open-source/titanengine.html) and [updated](https://github.com/x64dbg/TitanEngine/) versions)

PE x64 debugging is fully supported with plugins for x64dbg and IDA.

Please note that ScyllaHide is not limited to these debuggers. You can use the standalone command line version of ScyllaHide. You can inject ScyllaHide into any process debugged by any debugger.

More information is available in the [documentation](https://github.com/x64dbg/ScyllaHide/releases/download/docs-2019-05-17/ScyllaHide.pdf) (PDF).

## License
ScyllaHide is licensed under the [GNU General Public License v3](https://www.gnu.org/licenses/gpl-3.0.en.html).

## Special thanks to
- What for his [POISON Assembler source code](https://tuts4you.com/download.php?view.2281)
- waliedassar for his [blog posts](http://waleedassar.blogspot.de)
- Peter Ferrie for his [PDFs](http://pferrie.host22.com)
- MaRKuS-DJM for [Olly Advanced](http://www.openrce.org/downloads/details/241/Olly_Advanced)
- Lim Bio Liong for [MS Spy++ style Window Finder](http://www.codeproject.com/Articles/1698/MS-Spy-style-Window-Finder)



================================================
File: LICENSE
================================================
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.



================================================
File: ScyllaHide.sln
================================================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28315.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "InjectorCLI", "InjectorCLI\InjectorCLI.vcxproj", "{92C90AAD-036E-474D-902C-CFD1E7422899}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HookLibrary", "HookLibrary\HookLibrary.vcxproj", "{C36C2313-72A8-4583-B7D8-28E193D5287F}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ScyllaHideTEPlugin", "ScyllaHideTEPlugin\ScyllaHideTEPlugin.vcxproj", "{0520906F-4296-4BEC-BD5F-B370E1F7800A}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ScyllaHideOlly1Plugin", "ScyllaHideOlly1Plugin\ScyllaHideOlly1Plugin.vcxproj", "{79774D44-ED2A-4FD2-9224-40AF0A590410}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ScyllaHideOlly2Plugin", "ScyllaHideOlly2Plugin\ScyllaHideOlly2Plugin.vcxproj", "{9EEA6D78-4E74-47B9-8746-B8754B15525D}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ScyllaHideIDAProPlugin", "ScyllaHideIDAProPlugin\ScyllaHideIDAProPlugin.vcxproj", "{A94B6222-ABEF-41A0-BE48-06801157AAA5}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ScyllaHideIDAServer", "ScyllaHideIDAServer\ScyllaHideIDAServer.vcxproj", "{4506D672-19C3-439B-8E1B-F1BA8BE28844}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ScyllaHideX64DBGPlugin", "ScyllaHideX64DBGPlugin\ScyllaHideX64DBGPlugin.vcxproj", "{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ScyllaHideGenericPlugin", "ScyllaHideGenericPlugin\ScyllaHideGenericPlugin.vcxproj", "{C2B5EC30-CF03-4963-B963-7576E9F1D01E}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "distorm", "3rdparty\distorm\distorm.vcxproj", "{920BBB4D-C715-4CD4-9129-FF2CF941495D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Scylla", "Scylla\Scylla.vcxproj", "{E468DA07-48EA-40EB-A845-FA69C39D3396}"
	ProjectSection(ProjectDependencies) = postProject
		{920BBB4D-C715-4CD4-9129-FF2CF941495D} = {920BBB4D-C715-4CD4-9129-FF2CF941495D}
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762} = {4CEF9C8E-91C8-4148-94B1-AF2A3B597762}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ScyllaTest", "ScyllaTest\ScyllaTest.vcxproj", "{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}"
	ProjectSection(ProjectDependencies) = postProject
		{E468DA07-48EA-40EB-A845-FA69C39D3396} = {E468DA07-48EA-40EB-A845-FA69C39D3396}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SCMRevGen", "SCMRevGen\SCMRevGen.vcxproj", "{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Debug|Win32.ActiveCfg = Debug|Win32
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Debug|Win32.Build.0 = Debug|Win32
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Debug|x64.ActiveCfg = Debug|x64
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Debug|x64.Build.0 = Debug|x64
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Release|Win32.ActiveCfg = Release|Win32
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Release|Win32.Build.0 = Release|Win32
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Release|x64.ActiveCfg = Release|x64
		{92C90AAD-036E-474D-902C-CFD1E7422899}.Release|x64.Build.0 = Release|x64
		{C36C2313-72A8-4583-B7D8-28E193D5287F}.Debug|Win32.ActiveCfg = Debug|Win32
		{C36C2313-72A8-4583-B7D8-28E193D5287F}.Debug|Win32.Build.0 = Debug|Win32
		{C36C2313-72A8-4583-B7D8-28E193D5287F}.Debug|x64.ActiveCfg = Debug|x64
		{C36C2313-72A8-4583-B7D8-28E193D5287F}.Debug|x64.Build.0 = Debug|x64
		{C36C2313-72A8-4583-B7D8-28E193D5287F}.Release|Win32.ActiveCfg = Release|Win32
		{C36C2313-72A8-4583-B7D8-28E193D5287F}.Release|Win32.Build.0 = Release|Win32
		{C36C2313-72A8-4583-B7D8-28E193D5287F}.Release|x64.ActiveCfg = Release|x64
		{C36C2313-72A8-4583-B7D8-28E193D5287F}.Release|x64.Build.0 = Release|x64
		{0520906F-4296-4BEC-BD5F-B370E1F7800A}.Debug|Win32.ActiveCfg = Debug|Win32
		{0520906F-4296-4BEC-BD5F-B370E1F7800A}.Debug|Win32.Build.0 = Debug|Win32
		{0520906F-4296-4BEC-BD5F-B370E1F7800A}.Debug|x64.ActiveCfg = Debug|x64
		{0520906F-4296-4BEC-BD5F-B370E1F7800A}.Debug|x64.Build.0 = Debug|x64
		{0520906F-4296-4BEC-BD5F-B370E1F7800A}.Release|Win32.ActiveCfg = Release|Win32
		{0520906F-4296-4BEC-BD5F-B370E1F7800A}.Release|Win32.Build.0 = Release|Win32
		{0520906F-4296-4BEC-BD5F-B370E1F7800A}.Release|x64.ActiveCfg = Release|x64
		{0520906F-4296-4BEC-BD5F-B370E1F7800A}.Release|x64.Build.0 = Release|x64
		{79774D44-ED2A-4FD2-9224-40AF0A590410}.Debug|Win32.ActiveCfg = Debug|Win32
		{79774D44-ED2A-4FD2-9224-40AF0A590410}.Debug|Win32.Build.0 = Debug|Win32
		{79774D44-ED2A-4FD2-9224-40AF0A590410}.Debug|x64.ActiveCfg = Debug|Win32
		{79774D44-ED2A-4FD2-9224-40AF0A590410}.Release|Win32.ActiveCfg = Release|Win32
		{79774D44-ED2A-4FD2-9224-40AF0A590410}.Release|Win32.Build.0 = Release|Win32
		{79774D44-ED2A-4FD2-9224-40AF0A590410}.Release|x64.ActiveCfg = Release|Win32
		{9EEA6D78-4E74-47B9-8746-B8754B15525D}.Debug|Win32.ActiveCfg = Debug|Win32
		{9EEA6D78-4E74-47B9-8746-B8754B15525D}.Debug|Win32.Build.0 = Debug|Win32
		{9EEA6D78-4E74-47B9-8746-B8754B15525D}.Debug|x64.ActiveCfg = Debug|Win32
		{9EEA6D78-4E74-47B9-8746-B8754B15525D}.Release|Win32.ActiveCfg = Release|Win32
		{9EEA6D78-4E74-47B9-8746-B8754B15525D}.Release|Win32.Build.0 = Release|Win32
		{9EEA6D78-4E74-47B9-8746-B8754B15525D}.Release|x64.ActiveCfg = Release|Win32
		{A94B6222-ABEF-41A0-BE48-06801157AAA5}.Debug|Win32.ActiveCfg = Debug|Win32
		{A94B6222-ABEF-41A0-BE48-06801157AAA5}.Debug|x64.ActiveCfg = Debug|Win32
		{A94B6222-ABEF-41A0-BE48-06801157AAA5}.Release|Win32.ActiveCfg = Release|Win32
		{A94B6222-ABEF-41A0-BE48-06801157AAA5}.Release|x64.ActiveCfg = Release|Win32
		{4506D672-19C3-439B-8E1B-F1BA8BE28844}.Debug|Win32.ActiveCfg = Debug|Win32
		{4506D672-19C3-439B-8E1B-F1BA8BE28844}.Debug|x64.ActiveCfg = Debug|x64
		{4506D672-19C3-439B-8E1B-F1BA8BE28844}.Release|Win32.ActiveCfg = Release|Win32
		{4506D672-19C3-439B-8E1B-F1BA8BE28844}.Release|x64.ActiveCfg = Release|x64
		{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}.Debug|Win32.ActiveCfg = Debug|Win32
		{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}.Debug|Win32.Build.0 = Debug|Win32
		{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}.Debug|x64.ActiveCfg = Debug|x64
		{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}.Debug|x64.Build.0 = Debug|x64
		{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}.Release|Win32.ActiveCfg = Release|Win32
		{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}.Release|Win32.Build.0 = Release|Win32
		{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}.Release|x64.ActiveCfg = Release|x64
		{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}.Release|x64.Build.0 = Release|x64
		{C2B5EC30-CF03-4963-B963-7576E9F1D01E}.Debug|Win32.ActiveCfg = Debug|Win32
		{C2B5EC30-CF03-4963-B963-7576E9F1D01E}.Debug|Win32.Build.0 = Debug|Win32
		{C2B5EC30-CF03-4963-B963-7576E9F1D01E}.Debug|x64.ActiveCfg = Debug|x64
		{C2B5EC30-CF03-4963-B963-7576E9F1D01E}.Debug|x64.Build.0 = Debug|x64
		{C2B5EC30-CF03-4963-B963-7576E9F1D01E}.Release|Win32.ActiveCfg = Release|Win32
		{C2B5EC30-CF03-4963-B963-7576E9F1D01E}.Release|Win32.Build.0 = Release|Win32
		{C2B5EC30-CF03-4963-B963-7576E9F1D01E}.Release|x64.ActiveCfg = Release|x64
		{C2B5EC30-CF03-4963-B963-7576E9F1D01E}.Release|x64.Build.0 = Release|x64
		{920BBB4D-C715-4CD4-9129-FF2CF941495D}.Debug|Win32.ActiveCfg = Debug|Win32
		{920BBB4D-C715-4CD4-9129-FF2CF941495D}.Debug|Win32.Build.0 = Debug|Win32
		{920BBB4D-C715-4CD4-9129-FF2CF941495D}.Debug|x64.ActiveCfg = Debug|x64
		{920BBB4D-C715-4CD4-9129-FF2CF941495D}.Debug|x64.Build.0 = Debug|x64
		{920BBB4D-C715-4CD4-9129-FF2CF941495D}.Release|Win32.ActiveCfg = Release|Win32
		{920BBB4D-C715-4CD4-9129-FF2CF941495D}.Release|Win32.Build.0 = Release|Win32
		{920BBB4D-C715-4CD4-9129-FF2CF941495D}.Release|x64.ActiveCfg = Release|x64
		{920BBB4D-C715-4CD4-9129-FF2CF941495D}.Release|x64.Build.0 = Release|x64
		{E468DA07-48EA-40EB-A845-FA69C39D3396}.Debug|Win32.ActiveCfg = Debug|Win32
		{E468DA07-48EA-40EB-A845-FA69C39D3396}.Debug|Win32.Build.0 = Debug|Win32
		{E468DA07-48EA-40EB-A845-FA69C39D3396}.Debug|x64.ActiveCfg = Debug|x64
		{E468DA07-48EA-40EB-A845-FA69C39D3396}.Debug|x64.Build.0 = Debug|x64
		{E468DA07-48EA-40EB-A845-FA69C39D3396}.Release|Win32.ActiveCfg = Release|Win32
		{E468DA07-48EA-40EB-A845-FA69C39D3396}.Release|Win32.Build.0 = Release|Win32
		{E468DA07-48EA-40EB-A845-FA69C39D3396}.Release|x64.ActiveCfg = Release|x64
		{E468DA07-48EA-40EB-A845-FA69C39D3396}.Release|x64.Build.0 = Release|x64
		{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}.Debug|Win32.ActiveCfg = Debug|Win32
		{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}.Debug|Win32.Build.0 = Debug|Win32
		{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}.Debug|x64.ActiveCfg = Debug|x64
		{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}.Debug|x64.Build.0 = Debug|x64
		{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}.Release|Win32.ActiveCfg = Release|Win32
		{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}.Release|Win32.Build.0 = Release|Win32
		{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}.Release|x64.ActiveCfg = Release|x64
		{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}.Release|x64.Build.0 = Release|x64
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}.Debug|Win32.ActiveCfg = Debug|Win32
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}.Debug|Win32.Build.0 = Debug|Win32
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}.Debug|x64.ActiveCfg = Debug|x64
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}.Debug|x64.Build.0 = Debug|x64
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}.Release|Win32.ActiveCfg = Release|Win32
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}.Release|Win32.Build.0 = Release|Win32
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}.Release|x64.ActiveCfg = Release|x64
		{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C656F8F6-F616-40A9-9343-90FC1032D65C}
	EndGlobalSection
EndGlobal



================================================
File: changelog.txt
================================================
Version 1.x
- All Plugins: Patch PEB64 under Wow64.
- All Plugins: Patch Flags in RTL_USER_PROCESS_PARAMETERS.
- Application for testing ScyllaHide features.

Version 1.3
- IDA Plugin: Removed attaching support due to IDA SDK bugs
- Other Plugins: Improved Anti-Anti-Attach + 64bit support

Version 1.2
- All Plugins: New attach dialog with crosshair/bullseye window finder.
- All Plugins: Tooltips with information (unfinished).
- Olly v1 Plugin: Fix for faulty handle bug
- Olly v1 Plugin: Fix for NT symbol path bug added to "Fix Olly Bugs", thanks to redblkjck 

Version 1.1
- Added "thanks" to About
- Added kill anti-attach (for x86 only)
- Olly v1 Plugin: Advanced CTRL+G
- Olly v1 Plugin: Skip "compressed code" message
- Olly v1 Plugin: Ignore bad PE image (WinUPack)
- Olly v1 Plugin: Skip "Load DLL" message

Version 1.0

- added sprintf %s Olly1 bugfix to "Fix Olly bugs"
- x64dbg 32/64bit plugins https://github.com/x64dbg/x64dbg
- fixed alignment bug 64bit

Version 0.9

- All plugins use separate scylla_hide.ini now. ini is interchangeable between plugins !
  (ini section in ollydbg.ini now deprecated !)
- Load/Save ini profiles in Olly1&2 and IDA plugin
- RunPE malware unpacker
- NtSetInformationProcess Hook in GUI

Version 0.8

- Olly v1 Plugin: option "Skip EP outside of code message"
- Fix for NtSetInformationProcess -> ProcessHandleTracing
- All plugins: Update-Check
- Timing Hooks: GetTickCount, GetTickCount64, GetLocalTime, GetSystemTime, NtQuerySystemTime, NtQueryPerformanceCounter
- "Remove Debug Privileges" added 

Version 0.7

- IDA 64bit plugin
- IDA 32/64bit remote server
- IDA DLL Injection
- IDA option to start x64 server automatically

Version 0.6

- IDA 32bit plugin

Version 0.5

- NtCreateThreadEx hook
- Prevent Thread creation 
  (special hook for some protectors like Execryptor. Only use this if you know what you do)
- Split Hide PEB into 4 options (ini option PEB now deprecated)
- Inject DLL option added (2 methods)
- Replaced Olly2 dialog
- Improved "Break on TLS"

Version 0.4

- Olly v1/v2 Plugins: Apply hooks without restarting
- Olly v1 Plugin: Added "Break on TLS"

Version 0.3

- Fix for Olly plugins caption reset
- Fix STARTUPINFO structure, GetStartupInfoA/W
- Resume/Suspend all Threads in Thread window
- x64 compatibility mode for Olly1
- fix PE-Bugs for Olly1
- fix FPU-Bug for Olly1
- split "Protect DRx" into its options (ini option ProtectDRx now deprecated)
- Fix PEB Patch bug, now Themida works on WinXP

Version 0.2

Warning: Since this version, ScyllaHide is not compatbile with Stealth64! You need to remove the Stealth64 plugin.

- Stealth hooks for 32-bit targets to defeat protectors like Themida
- Olly Plugin: Change olly caption
- Olly v1 Plugin: Remove EP One-Shot Breakpoint for VMProtect

Version 0.1

- Init



================================================
File: release.bat
================================================
@echo off
setlocal enableextensions
setlocal enabledelayedexpansion

@rem build release

cd %~dp0

@rem We still support Windows XP in our release builds, and probably will continue to do so for the foreseeable future.
@rem This is controlled by the following env var. Because we don't expect that regular users will want to target XP in their
@rem private local builds, in the normal case (opening VS) this will not be set and the minimum target version is Windows 7.
@rem If you want to make such a "release build", but without XP support and the toolchain requirements that come with it,
@rem call this with USE_XP_TOOLCHAIN set to FALSE
@rem
@rem 'TRUE' is the default value so that if a commit or PR breaks XP compatibility, it will be caught by Github Actions because it runs this build as a CI step.
@rem
@rem The most important (probably not installed on your machine) requirement to build with XP support enabled is *VS2019* with the latest *14.27* VC++ toolchain.
@rem The installer calls this the "16.7 toolchain", the compiler/CRT files themselves are versioned "14.27".
if "%USE_XP_TOOLCHAIN%"=="" (
	set USE_XP_TOOLCHAIN=TRUE
)

set PROGRAMFILES32=%PROGRAMFILES(x86)%
if not exist "%PROGRAMFILES(x86)%" set PROGRAMFILES32=%PROGRAMFILES%

set VSWHERE=%PROGRAMFILES32%\Microsoft Visual Studio\Installer\vswhere.exe
if not exist "%VSWHERE%" (
	echo VS2017/VS2019 installation directory does not exist, or the vswhere.exe tool is missing.
	exit /b
)

@rem Test if the vswhere tool is actually up to date enough to understand -find syntax (the one on Appveyor isn't)
"%VSWHERE%" -nologo -latest -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe 1>nul 2>&1
if not %ERRORLEVEL%==0 (
	@rem Fetch some version that gets it
	echo Fetching vswhere.exe...
	curl -O -L https://github.com/microsoft/vswhere/releases/download/3.1.1/vswhere.exe 1>nul
	set VSWHERE=vswhere.exe
)
set MSBUILD=
for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -nologo -latest -requires Microsoft.Component.MSBuild -find MSBuild\**\Bin\MSBuild.exe`) do (
	set MSBUILD=%%i
)
set XPTOOLCHAIN_INSTALLED=
for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -nologo -version [16.0^,17^) -requires Microsoft.VisualStudio.Component.VC.14.27.x86.x64`) do (
	set XPTOOLCHAIN_INSTALLED=%%i
)
set VS2019INSTALLDIR=
for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -nologo -version [16.0^,17^) -property installationPath`) do (
	set VS2019INSTALLDIR=%%i
)
set VS2019SETUP=
for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -nologo -version [16.0^,17^) -property properties_setupEngineFilePath`) do (
	set VS2019SETUP=%%i
)
del vswhere.exe 1>nul 2>&1

if "%MSBUILD%"=="" (
	echo Failed to find MSBuild installation directory.
	exit /b
)
@rem Alternatively if github continues to fuck this up, we can curl the latest VS2019 setup from the hardcoded URL https://aka.ms/vs/16/release/vs_enterprise.exe
if "%USE_XP_TOOLCHAIN%"=="TRUE" (
	if "%VS2019INSTALLDIR%"=="" (
		echo XP toolchain build was requested, but VS2019 install dir could not be found. Set USE_XP_TOOLCHAIN to something other than TRUE if you don't actually need it.
		exit /b
	)
	if "%XPTOOLCHAIN_INSTALLED%"=="" (
		if "%VS2019SETUP%"=="" (
			echo XP toolchain build was requested, but VS2019 setup.exe could not be found. Set USE_XP_TOOLCHAIN to something other than TRUE if you don't actually need it.
			exit /b
		)
		echo Sorry buddy, but you need some more VS stuff. Installing it for you now, don't worry. We're gonna take care of this for ya...
		@rem Despite '--quiet', this command is not actually quiet. AT ALL. Redirect stdout spam
		"%VS2019SETUP%" modify --installPath "%VS2019INSTALLDIR%" --add "Microsoft.VisualStudio.Component.VC.14.27.x86.x64" --add "Microsoft.VisualStudio.Component.VC.14.27.MFC" --add "Microsoft.VisualStudio.Component.VC.14.27.ATL" --norestart --force --quiet 1>nul
		if not %ERRORLEVEL%==0 (
			echo Installation failed!
			exit /b
		)
		echo Installation successful.
	)
	@rem Finally, ascend to 14.27 toolchain environment
	call "%VS2019INSTALLDIR%\VC\Auxiliary\Build\vcvarsall.bat" amd64 -vcvars_ver=14.27
)

"%MSBUILD%" /m /property:Configuration=Release,Platform=Win32
if not %ERRORLEVEL%==0 exit /b

"%MSBUILD%" /m /property:Configuration=Release,Platform=x64
if not %ERRORLEVEL%==0 exit /b

rmdir /S /Q Release
xcopy /S /Y ConfigCollection Release\

@rem Release structure
mkdir Release\x64dbg\x32\plugins
mkdir Release\x64dbg\x64\plugins
mkdir Release\Olly1
mkdir Release\Olly2
mkdir Release\TitanEngine
mkdir Release\Generic
mkdir Release\IDA

copy /y /b build\Release\Win32\ScyllaHideGenericPluginx86.dll Release\Generic\
copy /y /b build\Release\x64\ScyllaHideGenericPluginx64.dll Release\Generic\
copy /y /b build\Release\Win32\ScyllaHideOlly1Plugin.dll Release\Olly1\
copy /y /b build\Release\Win32\ScyllaHideOlly2Plugin.dll Release\Olly2\
copy /y /b build\Release\Win32\ScyllaHideTEPluginx86.dll Release\TitanEngine\
copy /y /b build\Release\x64\ScyllaHideTEPluginx64.dll Release\TitanEngine\
copy /y /b build\Release\Win32\ScyllaHideX64DBGPlugin.dp32 Release\x64dbg\x32\plugins\
copy /y /b build\Release\x64\ScyllaHideX64DBGPlugin.dp64 Release\x64dbg\x64\plugins\
copy /y /b build\Release\Win32\ScyllaHideIDAProPlugin.plw Release\IDA\

xcopy /S /Y build\Release\Win32\*.exe Release\
xcopy /S /Y build\Release\x64\*.exe Release\
copy /y /b build\Release\Win32\HookLibraryx86.dll Release\
copy /y /b build\Release\x64\HookLibraryx64.dll Release\

copy /y /b Release\HookLibraryx64.dll Release\x64dbg\x64\plugins\
copy /y /b Release\HookLibraryx86.dll Release\x64dbg\x32\plugins\
copy /y /b Release\scylla_hide.ini Release\x64dbg\x64\plugins\
copy /y /b Release\scylla_hide.ini Release\x64dbg\x32\plugins\

copy /y /b Release\scylla_hide.ini Release\Olly1\
copy /y /b Release\HookLibraryx86.dll Release\Olly1\

copy /y /b Release\scylla_hide.ini Release\Olly2\
copy /y /b Release\HookLibraryx86.dll Release\Olly2\

copy /y /b Release\scylla_hide.ini Release\TitanEngine\
copy /y /b Release\HookLibraryx64.dll Release\TitanEngine\
copy /y /b Release\HookLibraryx86.dll Release\TitanEngine\

copy /y /b Release\scylla_hide.ini Release\Generic\
copy /y /b Release\HookLibraryx64.dll Release\Generic\
copy /y /b Release\HookLibraryx86.dll Release\Generic\

copy /y /b Release\scylla_hide.ini Release\IDA\
copy /y /b Release\HookLibraryx64.dll Release\IDA\
copy /y /b Release\HookLibraryx86.dll Release\IDA\
move Release\ScyllaHideIDAServer* Release\IDA\

exit 0


================================================
File: .editorconfig
================================================
; Top-most EditorConfig file
root = true

; Windows-style newlines
[*]
end_of_line = CRLF

; Tab indentation
[*.{c,cpp,h,hpp}]
indent_style = space
indent_size = 4
trim_trailing_whitespace = true
insert_final_newline = true



================================================
File: 3rdparty/README.txt
================================================
To build the IDA plugin, extract the contents of idasdk695.zip in the directory "idasdk"


================================================
File: 3rdparty/distorm/config.h
================================================
/*
config.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef CONFIG_H
#define CONFIG_H

/* diStorm version number. */
#define __DISTORMV__ 0x030304

#include <string.h> /* memset, memcpy - can be easily self implemented for libc independency. */

#include "distorm.h"


/*
 * 64 bit offsets support:
 * This macro should be defined from compiler command line flags, e.g: -DSUPPORT_64BIT_OFFSET
 * Note: make sure that the caller (library user) defines it too!
 */
#ifndef SUPPORT_64BIT_OFFSET
#define SUPPORT_64BIT_OFFSET
#endif

/*
 * If you compile diStorm as a dynamic library (.dll or .so) file, make sure you uncomment the next line.
 * So the interface functions will be exported, otherwise they are useable only for static library.
 * For example, this macro is being set for compiling diStorm as a .dll for Python with CTypes.
 */
/* #define DISTORM_DYNAMIC */

/*
 * If DISTORM_LIGHT is defined, everything involved in formatting the instructions
 * as text will be excluded from compilation.
 * distorm_decode(..) and distorm_format(..) will not be available.
 * This will decrease the size of the executable and leave you with decomposition functionality only.
 *
 * Note: it should be either set in the preprocessor definitions manually or in command line -D switch.
 */
#ifndef DISTORM_LIGHT
#define DISTORM_LIGHT
#endif
/*
 * diStorm now supports little/big endian CPU's.
 * It should detect the endianness according to predefined macro's of the compiler.
 * If you don't use GCC/MSVC you will have to define it on your own.
 */

/* These macros are used in order to make the code portable. */
#ifdef __GNUC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ static
/* GCC ignores this directive... */
/*#define _FASTCALL_ __attribute__((__fastcall__))*/

/* Set endianity (supposed to be LE though): */
#ifdef __BIG_ENDIAN__
	#define BE_SYSTEM
#endif

/* End of __GCC__ */

#elif __WATCOMC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ __inline

/* End of __WATCOMC__ */

#elif __DMC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_ __inline

/* End of __DMC__ */

#elif __TINYC__

#include <stdint.h>

#define _DLLEXPORT_
#define _FASTCALL_
#define _INLINE_

/* End of __TINYC__ */

#elif _MSC_VER

/* stdint alternative is defined in distorm.h */

#define _DLLEXPORT_ __declspec(dllexport)
#define _FASTCALL_ __fastcall
#define _INLINE_ __inline

/* Set endianity (supposed to be LE though): */
#if !defined(_M_IX86) && !defined(_M_X64)
	#define BE_SYSTEM
#endif

#endif /* #elif _MSC_VER */

/* If the library isn't compiled as a dynamic library don't export any functions. */
#ifndef DISTORM_DYNAMIC
#undef _DLLEXPORT_
#define _DLLEXPORT_
#endif

#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif

/* Define stream read functions for big endian systems. */
#ifdef BE_SYSTEM
/*
 * These functions can read from the stream safely!
 * Swap endianity of input to little endian.
 */
static _INLINE_ int16_t RSHORT(const uint8_t *s)
{
	return s[0] | (s[1] << 8);
}
static _INLINE_ uint16_t RUSHORT(const uint8_t *s)
{
	return s[0] | (s[1] << 8);
}
static _INLINE_ int32_t RLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24);
}
static _INLINE_ uint32_t RULONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24);
}
static _INLINE_ int64_t RLLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24) | ((uint64_t)s[4] << 32) | ((uint64_t)s[5] << 40) | ((uint64_t)s[6] << 48) | ((uint64_t)s[7] << 56);
}
static _INLINE_ uint64_t RULLONG(const uint8_t *s)
{
	return s[0] | (s[1] << 8) | (s[2] << 16) | (s[3] << 24) | ((uint64_t)s[4] << 32) | ((uint64_t)s[5] << 40) | ((uint64_t)s[6] << 48) | ((uint64_t)s[7] << 56);
}
#else
/* Little endian macro's will just make the cast. */
#define RSHORT(x) *(int16_t *)x
#define RUSHORT(x) *(uint16_t *)x
#define RLONG(x) *(int32_t *)x
#define RULONG(x) *(uint32_t *)x
#define RLLONG(x) *(int64_t *)x
#define RULLONG(x) *(uint64_t *)x
#endif

#endif /* CONFIG_H */



================================================
File: 3rdparty/distorm/decoder.c
================================================
/*
decoder.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "decoder.h"
#include "instructions.h"
#include "insts.h"
#include "prefix.h"
#include "x86defs.h"
#include "operands.h"
#include "insts.h"
#include "mnemonics.h"


/* Instruction Prefixes - Opcode - ModR/M - SIB - Displacement - Immediate */

static _DecodeType decode_get_effective_addr_size(_DecodeType dt, _iflags decodedPrefixes)
{
	/*
	 * This table is to map from the current decoding mode to an effective address size:
	 * Decode16 -> Decode32
	 * Decode32 -> Decode16
	 * Decode64 -> Decode32
	 */
	static _DecodeType AddrSizeTable[] = {Decode32Bits, Decode16Bits, Decode32Bits};

	/* Switch to non default mode if prefix exists, only for ADDRESS SIZE. */
	if (decodedPrefixes & INST_PRE_ADDR_SIZE) dt = AddrSizeTable[dt];
	return dt;
}

static _DecodeType decode_get_effective_op_size(_DecodeType dt, _iflags decodedPrefixes, unsigned int rex, _iflags instFlags)
{
	/*
	 * This table is to map from the current decoding mode to an effective operand size:
	 * Decode16 -> Decode32
	 * Decode32 -> Decode16
	 * Decode64 -> Decode16
	 * Not that in 64bits it's a bit more complicated, because of REX and promoted instructions.
	 */
	static _DecodeType OpSizeTable[] = {Decode32Bits, Decode16Bits, Decode16Bits};

	if (decodedPrefixes & INST_PRE_OP_SIZE) return OpSizeTable[dt];

	if (dt == Decode64Bits) {
		/*
		 * REX Prefix toggles data size to 64 bits.
		 * Operand size prefix toggles data size to 16.
		 * Default data size is 32 bits.
		 * Promoted instructions are 64 bits if they don't require a REX perfix.
		 * Non promoted instructions are 64 bits if the REX prefix exists.
		 */
		/* Automatically promoted instructions have only INST_64BITS SET! */
		if (((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS) ||
		/* Other instructions in 64 bits can be promoted only with a REX prefix. */
			((decodedPrefixes & INST_PRE_REX) && (rex & PREFIX_EX_W))) dt = Decode64Bits;
		else dt = Decode32Bits; /* Default. */
	}
	return dt;
}

/* A helper macro to convert from diStorm's CPU flags to EFLAGS. */
#define CONVERT_FLAGS_TO_EFLAGS(dst, src, field) dst->field = ((src->field & D_COMPACT_SAME_FLAGS) | \
	((src->field & D_COMPACT_IF) ? D_IF : 0) | \
	((src->field & D_COMPACT_DF) ? D_DF : 0) | \
	((src->field & D_COMPACT_OF) ? D_OF : 0));

static _DecodeResult decode_inst(_CodeInfo* ci, _PrefixState* ps, _DInst* di)
{
	/* Remember whether the instruction is privileged. */
	uint16_t privilegedFlag = 0;

	/* The ModR/M byte of the current instruction. */
	unsigned int modrm = 0;

	/* The REX/VEX prefix byte value. */
	unsigned int vrex = ps->vrex;

	/*
	 * Backup original input, so we can use it later if a problem occurs
	 * (like not enough data for decoding, invalid opcode, etc).
	 */
	const uint8_t* startCode = ci->code;

	/* Holds the info about the current found instruction. */
	_InstInfo* ii = NULL;
	_InstInfo iip; /* Privileged instruction cache. */
	_InstSharedInfo* isi = NULL;

	/* Used only for special CMP instructions which have pseudo opcodes suffix. */
	unsigned char cmpType = 0;

	/*
	 * Indicates whether it is right to LOCK the instruction by decoding its first operand.
	 * Only then you know if it's ok to output the LOCK prefix's text...
	 * Used for first operand only.
	 */
	int lockable = FALSE;

	/* Calculate (and cache) effective-operand-size and effective-address-size only once. */
	_DecodeType effOpSz, effAdrSz;
	_iflags instFlags;

	ii = inst_lookup(ci, ps);
	if (ii == NULL) goto _Undecodable;
	isi = &InstSharedInfoTable[ii->sharedIndex];
	instFlags = FlagsTable[isi->flagsIndex];
	privilegedFlag = ii->opcodeId & OPCODE_ID_PRIVILEGED;

	if (privilegedFlag) {
		/*
		 * Copy the privileged instruction info so we can remove the privileged bit
		 * from the opcodeId field. This makes sure we're not modifying the tables
		 * in case we lookup this privileged instruction later.
		 */
		iip = *ii;
		iip.opcodeId &= ~OPCODE_ID_PRIVILEGED;
		ii = &iip;
	}

	/*
	 * If both REX and OpSize are available we will have to disable the OpSize, because REX has precedence.
	 * However, only if REX.W is set !
	 * We had to wait with this test, since the operand size may be a mandatory prefix,
	 * and we know it only after prefetching.
	 */
	if ((ps->prefixExtType == PET_REX) &&
		(ps->decodedPrefixes & INST_PRE_OP_SIZE) &&
		(!ps->isOpSizeMandatory) &&
		(vrex & PREFIX_EX_W)) {
		ps->decodedPrefixes &= ~INST_PRE_OP_SIZE;
		prefixes_ignore(ps, PFXIDX_OP_SIZE);
	}

	/*
	 * In this point we know the instruction we are about to decode and its operands (unless, it's an invalid one!),
	 * so it makes it the right time for decoding-type suitability testing.
	 * Which practically means, don't allow 32 bits instructions in 16 bits decoding mode, but do allow
	 * 16 bits instructions in 32 bits decoding mode, of course...

	 * NOTE: Make sure the instruction set for 32 bits has explicitly this specific flag set.
	 * NOTE2: Make sure the instruction set for 64 bits has explicitly this specific flag set.

	 * If this is the case, drop what we've got and restart all over after DB'ing that byte.

	 * Though, don't drop an instruction which is also supported in 16 and 32 bits.
	 */

	/* ! ! ! DISABLED UNTIL FURTHER NOTICE ! ! ! Decode16Bits CAN NOW DECODE 32 BITS INSTRUCTIONS ! ! !*/
	/* if (ii && (dt == Decode16Bits) && (instFlags & INST_32BITS) && (~instFlags & INST_16BITS)) ii = NULL; */

	/* Drop instructions which are invalid in 64 bits. */
	if ((ci->dt == Decode64Bits) && (instFlags & INST_INVALID_64BITS)) goto _Undecodable;

	/* If it's only a 64 bits instruction drop it in other decoding modes. */
	if ((ci->dt != Decode64Bits) && (instFlags & INST_64BITS_FETCH)) goto _Undecodable;

	if (instFlags & INST_MODRM_REQUIRED) {
		/* If the ModRM byte is not part of the opcode, skip the last byte code, so code points now to ModRM. */
		if (~instFlags & INST_MODRM_INCLUDED) {
			ci->code++;
			if (--ci->codeLen < 0) goto _Undecodable;
		}
		modrm = *ci->code;

		/* Some instructions enforce that reg=000, so validate that. (Specifically EXTRQ). */
		if ((instFlags & INST_FORCE_REG0) && (((modrm >> 3) & 7) != 0)) goto _Undecodable;
		/* Some instructions enforce that mod=11, so validate that. */
		if ((instFlags & INST_MODRR_REQUIRED) && (modrm < INST_DIVIDED_MODRM)) goto _Undecodable;
	}

	ci->code++; /* Skip the last byte we just read (either last opcode's byte code or a ModRM). */

	/* Cache the effective operand-size and address-size. */
	effOpSz = decode_get_effective_op_size(ci->dt, ps->decodedPrefixes, vrex, instFlags);
	effAdrSz = decode_get_effective_addr_size(ci->dt, ps->decodedPrefixes);

	memset(di, 0, sizeof(_DInst));
	di->base = R_NONE;

	/*
	 * Try to extract the next operand only if the latter exists.
	 * For example, if there is not first operand, no reason to try to extract second operand...
	 * I decided that a for-break is better for readability in this specific case than goto.
	 * Note: do-while with a constant 0 makes the compiler warning about it.
	 */
	for (;;) {
		if (isi->d != OT_NONE) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->d, ONT_1, modrm, ps, effOpSz, effAdrSz, &lockable)) goto _Undecodable;
		} else break;

		if (isi->s != OT_NONE) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)isi->s, ONT_2, modrm, ps, effOpSz, effAdrSz, NULL)) goto _Undecodable;
		} else break;

		/* Use third operand, only if the flags says this InstInfo requires it. */
		if (instFlags & INST_USE_OP3) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op3, ONT_3, modrm, ps, effOpSz, effAdrSz, NULL)) goto _Undecodable;
		} else break;
		
		/* Support for a fourth operand is added for (i.e:) INSERTQ instruction. */
		if (instFlags & INST_USE_OP4) {
			if (!operands_extract(ci, di, ii, instFlags, (_OpType)((_InstInfoEx*)ii)->op4, ONT_4, modrm, ps, effOpSz, effAdrSz, NULL)) goto _Undecodable;
		}
		break;
	} /* Continue here after all operands were extracted. */

	/* If it were a 3DNow! instruction, we will have to find the instruction itself now that we got its operands extracted. */
	if (instFlags & INST_3DNOW_FETCH) {
		ii = inst_lookup_3dnow(ci);
		if (ii == NULL) goto _Undecodable;
		isi = &InstSharedInfoTable[ii->sharedIndex];
		instFlags = FlagsTable[isi->flagsIndex];
	}

	/* Check whether pseudo opcode is needed, only for CMP instructions: */
	if (instFlags & INST_PSEUDO_OPCODE) {
		if (--ci->codeLen < 0) goto _Undecodable;
		cmpType = *ci->code;
		ci->code++;
		if (instFlags & INST_PRE_VEX) {
			/* AVX Comparison type must be between 0 to 32, otherwise Reserved. */
			if (cmpType >= INST_VCMP_MAX_RANGE) goto _Undecodable;
		} else {
			/* SSE Comparison type must be between 0 to 8, otherwise Reserved. */
			if (cmpType >= INST_CMP_MAX_RANGE) goto _Undecodable;
		}
	}

	/*
	 * There's a limit of 15 bytes on instruction length. The only way to violate
	 * this limit is by putting redundant prefixes before an instruction.
	 * start points to first prefix if any, otherwise it points to instruction first byte.
	 */
	if ((ci->code - ps->start) > INST_MAXIMUM_SIZE) goto _Undecodable; /* Drop instruction. */

	/*
	 * If we reached here the instruction was fully decoded, we located the instruction in the DB and extracted operands.
	 * Use the correct mnemonic according to the DT.
	 * If we are in 32 bits decoding mode it doesn't necessarily mean we will choose mnemonic2, alas,
	 * it means that if there is a mnemonic2, it will be used.
	 */

	/* Start with prefix LOCK. */
	if ((lockable == TRUE) && (instFlags & INST_PRE_LOCK)) {
		ps->usedPrefixes |= INST_PRE_LOCK;
		di->flags |= FLAG_LOCK;
	} else if ((instFlags & INST_PRE_REPNZ) && (ps->decodedPrefixes & INST_PRE_REPNZ)) {
		ps->usedPrefixes |= INST_PRE_REPNZ;
		di->flags |= FLAG_REPNZ;
	} else if ((instFlags & INST_PRE_REP) && (ps->decodedPrefixes & INST_PRE_REP)) {
		ps->usedPrefixes |= INST_PRE_REP;
		di->flags |= FLAG_REP;
	}

	/* If it's JeCXZ the ADDR_SIZE prefix affects them. */
	if ((instFlags & (INST_PRE_ADDR_SIZE | INST_USE_EXMNEMONIC)) == (INST_PRE_ADDR_SIZE | INST_USE_EXMNEMONIC)) {
		ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
		if (effAdrSz == Decode16Bits) di->opcode = ii->opcodeId;
		else if (effAdrSz == Decode32Bits) di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
		/* Ignore REX.W in 64bits, JECXZ is promoted. */
		else /* Decode64Bits */ di->opcode = ((_InstInfoEx*)ii)->opcodeId3;
	}

	/* LOOPxx instructions are also native instruction, but they are special case ones, ADDR_SIZE prefix affects them. */
	else if ((instFlags & (INST_PRE_ADDR_SIZE | INST_NATIVE)) == (INST_PRE_ADDR_SIZE | INST_NATIVE)) {
		di->opcode = ii->opcodeId;

		/* If LOOPxx gets here from 64bits, it must be Decode32Bits because Address Size prefix is set. */
		ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
	}
	/*
	 * Note:
	 * If the instruction is prefixed by operand size we will format it in the non-default decoding mode!
	 * So there might be a situation that an instruction of 32 bit gets formatted in 16 bits decoding mode.
	 * Both ways should end up with a correct and expected formatting of the text.
	*/
	else if (effOpSz == Decode16Bits) { /* Decode16Bits */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode16Bits);

		/*
		 * If it's a special instruction which has two mnemonics, then use the 16 bits one + update usedPrefixes.
		 * Note: use 16 bits mnemonic if that instruction supports 32 bit or 64 bit explicitly.
		 */
		if ((instFlags & INST_USE_EXMNEMONIC) && ((instFlags & (INST_32BITS | INST_64BITS)) == 0)) ps->usedPrefixes |= INST_PRE_OP_SIZE;
		di->opcode = ii->opcodeId;
	} else if (effOpSz == Decode32Bits) { /* Decode32Bits */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode32Bits);

		/* Give a chance for special mnemonic instruction in 32 bits decoding. */
		if (instFlags & INST_USE_EXMNEMONIC) {
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/* Is it a special instruction which has another mnemonic for mod=11 ? */
			if (instFlags & INST_MNEMONIC_MODRM_BASED) {
				if (modrm >= INST_DIVIDED_MODRM) di->opcode = ii->opcodeId;
				else di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
			} else di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
		} else di->opcode = ii->opcodeId;
	} else { /* Decode64Bits, note that some instructions might be decoded in Decode32Bits above. */

		/* Set operand size. */
		FLAG_SET_OPSIZE(di, Decode64Bits);

		if (instFlags & (INST_USE_EXMNEMONIC | INST_USE_EXMNEMONIC2)) {
			/*
			 * We shouldn't be here for MODRM based mnemonics with a MOD=11,
			 * because they must not use REX (otherwise it will get to the wrong instruction which share same opcode).
			 * See XRSTOR and XSAVEOPT.
			 */
			if ((instFlags & INST_MNEMONIC_MODRM_BASED) && (modrm >= INST_DIVIDED_MODRM)) goto _Undecodable;

			/* Use third mnemonic, for 64 bits. */
			if ((instFlags & INST_USE_EXMNEMONIC2) && (vrex & PREFIX_EX_W)) {
				ps->usedPrefixes |= INST_PRE_REX;
				di->opcode = ((_InstInfoEx*)ii)->opcodeId3;
			} else di->opcode = ((_InstInfoEx*)ii)->opcodeId2; /* Use second mnemonic. */
		} else di->opcode = ii->opcodeId;
	}

	/* If it's a native instruction use OpSize Prefix. */
	if ((instFlags & INST_NATIVE) && (ps->decodedPrefixes & INST_PRE_OP_SIZE)) ps->usedPrefixes |= INST_PRE_OP_SIZE;

	/* Check VEX mnemonics: */
	if ((instFlags & INST_PRE_VEX) &&
		(((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXW_BASED) && (vrex & PREFIX_EX_W)) ||
		 ((((_InstInfoEx*)ii)->flagsEx & INST_MNEMONIC_VEXL_BASED) && (vrex & PREFIX_EX_L)))) {
		di->opcode = ((_InstInfoEx*)ii)->opcodeId2;
	}

	/* Or is it a special CMP instruction which needs a pseudo opcode suffix ? */
	if (instFlags & INST_PSEUDO_OPCODE) {
		/*
		 * The opcodeId is the offset to the FIRST pseudo compare mnemonic,
		 * we will have to fix it so it offsets into the corrected mnemonic.
		 * Therefore, we use another table to fix the offset.
		 */
		if (instFlags & INST_PRE_VEX) {
			/* Use the AVX pseudo compare mnemonics table. */
			di->opcode = ii->opcodeId + VCmpMnemonicOffsets[cmpType];
		} else {
			/* Use the SSE pseudo compare mnemonics table. */
			di->opcode = ii->opcodeId + CmpMnemonicOffsets[cmpType];
		}
	}

	/*
	 * Store the address size inside the flags.
	 * This is necessary for the caller to know the size of rSP when using PUSHA for example.
	 */
	FLAG_SET_ADDRSIZE(di, effAdrSz);

	/* Copy DST_WR flag. */
	if (instFlags & INST_DST_WR) di->flags |= FLAG_DST_WR;

	/* Set the unused prefixes mask. */
	di->unusedPrefixesMask = prefixes_set_unused_mask(ps);

	/* Fix privileged. Assumes the privilegedFlag is 0x8000 only. */
	di->flags |= privilegedFlag;

	/* Copy instruction meta. */
	di->meta = isi->meta;
	if (di->segment == 0) di->segment = R_NONE;

	/* Take into account the O_MEM base register for the mask. */
	if (di->base != R_NONE) di->usedRegistersMask |= _REGISTERTORCLASS[di->base];

	/* Copy CPU affected flags. */
	CONVERT_FLAGS_TO_EFLAGS(di, isi, modifiedFlagsMask);
	CONVERT_FLAGS_TO_EFLAGS(di, isi, testedFlagsMask);
	CONVERT_FLAGS_TO_EFLAGS(di, isi, undefinedFlagsMask);

	/* Calculate the size of the instruction we've just decoded. */
	di->size = (uint8_t)((ci->code - startCode) & 0xff);
	return DECRES_SUCCESS;

_Undecodable: /* If the instruction couldn't be decoded for some reason, drop the first byte. */
	memset(di, 0, sizeof(_DInst));
	di->base = R_NONE;

	di->size = 1;
	/* Clean prefixes just in case... */
	ps->usedPrefixes = 0;

	/* Special case for WAIT instruction: If it's dropped, you have to return a valid instruction! */
	if (*startCode == INST_WAIT_INDEX) {
		di->opcode = I_WAIT;
		META_SET_ISC(di, ISC_INTEGER);
		return DECRES_SUCCESS;
	}

	/* Mark that we didn't manage to decode the instruction well, caller will drop it. */
	return DECRES_INPUTERR;
}

/*
 * decode_internal
 *
 * supportOldIntr - Since now we work with new structure instead of the old _DecodedInst, we are still interested in backward compatibility.
 *                  So although, the array is now of type _DInst, we want to read it in jumps of the old array element's size.
 *                  This is in order to save memory allocation for conversion between the new and the old structures.
 *                  It really means we can do the conversion in-place now.
 */
_DecodeResult decode_internal(_CodeInfo* _ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount)
{
	_PrefixState ps;
	unsigned int prefixSize;
	_CodeInfo ci;
	unsigned int features;
	unsigned int mfc;

	_OffsetType codeOffset = _ci->codeOffset;
	const uint8_t* code = _ci->code;
	int codeLen = _ci->codeLen;

	/*
	 * This is used for printing only, it is the real offset of where the whole instruction begins.
	 * We need this variable in addition to codeOffset, because prefixes might change the real offset an instruction begins at.
	 * So we keep track of both.
	 */
	_OffsetType startInstOffset = 0;

	const uint8_t* p;

	/* Current working decoded instruction in results. */
	unsigned int nextPos = 0;
	_DInst *pdi = NULL;

	_OffsetType addrMask = (_OffsetType)-1;

	_DecodeResult decodeResult;

#ifdef DISTORM_LIGHT
	supportOldIntr; /* Unreferenced. */

	/*
	 * Only truncate address if we are using the decompose interface.
	 * Otherwise, we use the textual interface which needs full addresses for formatting bytes output.
	 * So distorm_format will truncate later.
	 */
	if (_ci->features & DF_MAXIMUM_ADDR32) addrMask = 0xffffffff;
	else if (_ci->features & DF_MAXIMUM_ADDR16) addrMask = 0xffff;
#endif

	/* No entries are used yet. */
	*usedInstructionsCount = 0;
	ci.dt = _ci->dt;
	_ci->nextOffset = codeOffset;

	/* Decode instructions as long as we have what to decode/enough room in entries. */
	while (codeLen > 0) {

		/* startInstOffset holds the displayed offset of current instruction. */
		startInstOffset = codeOffset;

		memset(&ps, 0, (size_t)((char*)&ps.pfxIndexer[0] - (char*)&ps));
		memset(ps.pfxIndexer, PFXIDX_NONE, sizeof(int) * PFXIDX_MAX);
		ps.start = code;
		ps.last = code;
		prefixSize = 0;

		if (prefixes_is_valid(*code, ci.dt)) {
			prefixes_decode(code, codeLen, &ps, ci.dt);
			/* Count prefixes, start points to first prefix. */
			prefixSize = (unsigned int)(ps.last - ps.start);
			/*
			 * It might be that we will just notice that we ran out of bytes, or only prefixes
			 * so we will have to drop everything and halt.
			 * Also take into consideration of flow control instruction filter.
			 */
			codeLen -= prefixSize;
			if ((codeLen == 0) || (prefixSize == INST_MAXIMUM_SIZE)) {
				if (~_ci->features & DF_RETURN_FC_ONLY) {
					/* Make sure there is enough room. */
					if (nextPos + (ps.last - code) > maxResultCount) return DECRES_MEMORYERR;

					for (p = code; p < ps.last; p++, startInstOffset++) {
						/* Use next entry. */
#ifndef DISTORM_LIGHT
						if (supportOldIntr) {
							pdi = (_DInst*)((char*)result + nextPos * sizeof(_DecodedInst));
						}
						else
#endif /* DISTORM_LIGHT */
						{
							pdi = &result[nextPos];
						}
						nextPos++;
						memset(pdi, 0, sizeof(_DInst));

						pdi->flags = FLAG_NOT_DECODABLE;
						pdi->imm.byte = *p;
						pdi->size = 1;
						pdi->addr = startInstOffset & addrMask;
					}
					*usedInstructionsCount = nextPos; /* Include them all. */
				}
				if (codeLen == 0) break; /* Bye bye, out of bytes. */
			}
			code += prefixSize;
			codeOffset += prefixSize;

			/* If we got only prefixes continue to next instruction. */
			if (prefixSize == INST_MAXIMUM_SIZE) continue;
		}

		/*
		 * Now we decode the instruction and only then we do further prefixes handling.
		 * This is because the instruction could not be decoded at all, or an instruction requires
		 * a mandatory prefix, or some of the prefixes were useless, etc...

		 * Even if there were a mandatory prefix, we already took into account its size as a normal prefix.
		 * so prefixSize includes that, and the returned size in pdi is simply the size of the real(=without prefixes) instruction.
		 */
		if (ci.dt == Decode64Bits) {
			if (ps.decodedPrefixes & INST_PRE_REX) {
				/* REX prefix must precede first byte of instruction. */
				if (ps.rexPos != (code - 1)) {
					ps.decodedPrefixes &= ~INST_PRE_REX;
					ps.prefixExtType = PET_NONE;
					prefixes_ignore(&ps, PFXIDX_REX);
				}
				/*
				 * We will disable operand size prefix,
				 * if it exists only after decoding the instruction, since it might be a mandatory prefix.
				 * This will be done after calling inst_lookup in decode_inst.
				 */
			}
			/* In 64 bits, segment overrides of CS, DS, ES and SS are ignored. So don't take'em into account. */
			if (ps.decodedPrefixes & INST_PRE_SEGOVRD_MASK32) {
				ps.decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK32;
				prefixes_ignore(&ps, PFXIDX_SEG);
			}
		}

		/* Make sure there is at least one more entry to use, for the upcoming instruction. */
		if (nextPos + 1 > maxResultCount) return DECRES_MEMORYERR;
#ifndef DISTORM_LIGHT
		if (supportOldIntr) {
			pdi = (_DInst*)((char*)result + nextPos * sizeof(_DecodedInst));
		}
		else
#endif /* DISTORM_LIGHT */
		{
			pdi = &result[nextPos];
		}
		nextPos++;

		/*
		 * The reason we copy these two again is because we have to keep track on the input ourselves.
		 * There might be a case when an instruction is invalid, and then it will be counted as one byte only.
		 * But that instruction already read a byte or two from the stream and only then returned the error.
		 * Thus, we end up unsynchronized on the stream.
		 * This way, we are totally safe, because we keep track after the call to decode_inst, using the returned size.
		 */
		ci.code = code;
		ci.codeLen = codeLen;
		/* Nobody uses codeOffset in the decoder itself, so spare it. */

		decodeResult = decode_inst(&ci, &ps, pdi);

		/* See if we need to filter this instruction. */
		if ((_ci->features & DF_RETURN_FC_ONLY) && (META_GET_FC(pdi->meta) == FC_NONE)) decodeResult = DECRES_FILTERED;

		/* Set address to the beginning of the instruction. */
		pdi->addr = startInstOffset & addrMask;
		/* pdi->disp &= addrMask; */

		if ((decodeResult == DECRES_INPUTERR) && (ps.decodedPrefixes & INST_PRE_VEX)) {
			if (ps.prefixExtType == PET_VEX3BYTES) {
				prefixSize -= 2;
				codeLen += 2;
			} else if (ps.prefixExtType == PET_VEX2BYTES) {
				prefixSize -= 1;
				codeLen += 1;
			}
			ps.last = ps.start + prefixSize - 1;
			code = ps.last + 1;
			codeOffset = startInstOffset + prefixSize;
		} else {
			/* Advance to next instruction. */
			codeLen -= pdi->size;
			codeOffset += pdi->size;
			code += pdi->size;

			/* Instruction's size should include prefixes. */
			pdi->size += (uint8_t)prefixSize;
		}

		/* Drop all prefixes and the instruction itself, because the instruction wasn't successfully decoded. */
		if ((decodeResult == DECRES_INPUTERR) && (~_ci->features & DF_RETURN_FC_ONLY)) {
			nextPos--; /* Undo last result. */
			if ((prefixSize + 1) > 0) { /* 1 for the first instruction's byte. */
				if ((nextPos + prefixSize + 1) > maxResultCount) return DECRES_MEMORYERR;

				for (p = ps.start; p < ps.last + 1; p++, startInstOffset++) {
					/* Use next entry. */
#ifndef DISTORM_LIGHT
					if (supportOldIntr) {
						pdi = (_DInst*)((char*)result + nextPos * sizeof(_DecodedInst));
					}
					else
#endif /* DISTORM_LIGHT */
					{
						pdi = &result[nextPos];
					}
					nextPos++;

					memset(pdi, 0, sizeof(_DInst));
					pdi->flags = FLAG_NOT_DECODABLE;
					pdi->imm.byte = *p;
					pdi->size = 1;
					pdi->addr = startInstOffset & addrMask;
				}
			}
		} else if (decodeResult == DECRES_FILTERED) nextPos--; /* Return it to pool, since it was filtered. */

		/* Alright, the caller can read, at least, up to this one. */
		*usedInstructionsCount = nextPos;
		/* Fix next offset. */
		_ci->nextOffset = codeOffset;

		/* Check whether we need to stop on any flow control instruction. */
		features = _ci->features;
		mfc = META_GET_FC(pdi->meta);
		if ((decodeResult == DECRES_SUCCESS) && (features & DF_STOP_ON_FLOW_CONTROL)) {
			if (((features & DF_STOP_ON_CALL) && (mfc == FC_CALL)) ||
				((features & DF_STOP_ON_RET) && (mfc == FC_RET)) ||
				((features & DF_STOP_ON_SYS) && (mfc == FC_SYS)) ||
				((features & DF_STOP_ON_UNC_BRANCH) && (mfc == FC_UNC_BRANCH)) ||
				((features & DF_STOP_ON_CND_BRANCH) && (mfc == FC_CND_BRANCH)) ||
				((features & DF_STOP_ON_INT) && (mfc == FC_INT)) ||
				((features & DF_STOP_ON_CMOV) && (mfc == FC_CMOV)))
				return DECRES_SUCCESS;
		}
	}

	return DECRES_SUCCESS;
}



================================================
File: 3rdparty/distorm/decoder.h
================================================
/*
decoder.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2011  Gil Dabah

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
*/


#ifndef DECODER_H
#define DECODER_H

#include "config.h"

typedef unsigned int _iflags;

_DecodeResult decode_internal(_CodeInfo* ci, int supportOldIntr, _DInst result[], unsigned int maxResultCount, unsigned int* usedInstructionsCount);

#endif /* DECODER_H */



================================================
File: 3rdparty/distorm/distorm.c
================================================
/*
distorm.c

diStorm3 C Library Interface
diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "distorm.h"
#include "config.h"
#include "decoder.h"
#include "x86defs.h"
#include "textdefs.h"
#include "wstring.h"
#include "mnemonics.h"

/* C DLL EXPORTS */
#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ _DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#else
	_DLLEXPORT_ _DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#endif
{
	if (usedInstructionsCount == NULL) {
		return DECRES_SUCCESS;
	}

	/* DECRES_SUCCESS still may indicate we may have something in the result, so zero it first thing. */
	*usedInstructionsCount = 0;

	if ((ci == NULL) ||
		(ci->codeLen < 0) ||
		((ci->dt != Decode16Bits) && (ci->dt != Decode32Bits) && (ci->dt != Decode64Bits)) ||
		(ci->code == NULL) ||
		(result == NULL) ||
		((ci->features & (DF_MAXIMUM_ADDR16 | DF_MAXIMUM_ADDR32)) == (DF_MAXIMUM_ADDR16 | DF_MAXIMUM_ADDR32)))
	{
		return DECRES_INPUTERR;
	}

	/* Assume length=0 is success. */
	if (ci->codeLen == 0) {
		return DECRES_SUCCESS;
	}

	return decode_internal(ci, FALSE, result, maxInstructions, usedInstructionsCount);
}

#ifndef DISTORM_LIGHT

/* Helper function to concatenate an explicit size when it's unknown from the operands. */
static void distorm_format_size(_WString* str, const _DInst* di, int opNum)
{
	int isSizingRequired = 0;
	/*
	 * We only have to output the size explicitly if it's not clear from the operands.
	 * For example:
	 * mov al, [0x1234] -> The size is 8, we know it from the AL register operand.
	 * mov [0x1234], 0x11 -> Now we don't know the size. Pam pam pam
	 *
	 * If given operand number is higher than 2, then output the size anyways.
	 */
	isSizingRequired = ((opNum >= 2) || ((di->ops[0].type != O_REG) && (di->ops[1].type != O_REG)));

	/* Still not sure? Try some special instructions. */
	if (!isSizingRequired) {
		/*
		 * INS/OUTS are exception, because DX is a port specifier and not a real src/dst register.
		 * A few exceptions that always requires sizing:
		 * MOVZX, MOVSX, MOVSXD.
		 * ROL, ROR, RCL, RCR, SHL, SHR, SAL, SAR.
		 * SHLD, SHRD.
		 */
		switch (di->opcode)
		{
			case I_INS:
			case I_OUTS:
			case I_MOVZX:
			case I_MOVSX:
			case I_MOVSXD:
			case I_ROL:
			case I_ROR:
			case I_RCL:
			case I_RCR:
			case I_SHL:
			case I_SHR:
			case I_SAL:
			case I_SAR:
			case I_SHLD:
			case I_SHRD:
				isSizingRequired = 1;
			break;
			default: /* Instruction doesn't require sizing. */ break;
		}
	}

	if (isSizingRequired)
	{
		switch (di->ops[opNum].size)
		{
			case 0: break; /* OT_MEM's unknown size. */
			case 8: strcat_WSN(str, "BYTE "); break;
			case 16: strcat_WSN(str, "WORD "); break;
			case 32: strcat_WSN(str, "DWORD "); break;
			case 64: strcat_WSN(str, "QWORD "); break;
			case 80: strcat_WSN(str, "TBYTE "); break;
			case 128: strcat_WSN(str, "DQWORD "); break;
			case 256: strcat_WSN(str, "YWORD "); break;
			default: /* Big oh uh if it gets here. */ break;
		}
	}
}

static void distorm_format_signed_disp(_WString* str, const _DInst* di, uint64_t addrMask)
{
	int64_t tmpDisp64;

	if (di->dispSize) {
		chrcat_WS(str, ((int64_t)di->disp < 0) ? MINUS_DISP_CHR : PLUS_DISP_CHR);
		if ((int64_t)di->disp < 0) tmpDisp64 = -(int64_t)di->disp;
		else tmpDisp64 = di->disp;
		tmpDisp64 &= addrMask;
		str_code_hqw(str, (uint8_t*)&tmpDisp64);
	}
}

#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result)
#else
	_DLLEXPORT_ void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result)
#endif
{
	_WString* str;
	unsigned int i, isDefault;
	int64_t tmpDisp64;
	uint64_t addrMask = (uint64_t)-1;
	uint8_t segment;
	const _WMnemonic* mnemonic;

	/* Set address mask, when default is for 64bits addresses. */
	if (ci->features & DF_MAXIMUM_ADDR32) addrMask = 0xffffffff;
	else if (ci->features & DF_MAXIMUM_ADDR16) addrMask = 0xffff;

	/* Copy other fields. */
	result->size = di->size;
	result->offset = di->addr;

	if (di->flags == FLAG_NOT_DECODABLE) {
		str = &result->mnemonic;
		result->offset &= addrMask;
		strclear_WS(&result->operands);
		strcpy_WSN(str, "DB ");
		str_code_hb(str, di->imm.byte);
		strclear_WS(&result->instructionHex);
		str_hex_b(&result->instructionHex, di->imm.byte);
		return; /* Skip to next instruction. */
	}

	str = &result->instructionHex;
	strclear_WS(str);
	/* Gotta have full address for (di->addr - ci->codeOffset) to work in all modes. */
	for (i = 0; i < di->size; i++)
		str_hex_b(str, ci->code[(unsigned int)(di->addr - ci->codeOffset + i)]);

	/* Truncate address now. */
	result->offset &= addrMask;

	str = &result->mnemonic;
	switch (FLAG_GET_PREFIX(di->flags))
	{
		case FLAG_LOCK:
			strcpy_WSN(str, "LOCK ");
		break;
		case FLAG_REP:
			/* REP prefix for CMPS and SCAS is really a REPZ. */
			if ((di->opcode == I_CMPS) || (di->opcode == I_SCAS)) strcpy_WSN(str, "REPZ ");
			else strcpy_WSN(str, "REP ");
		break;
		case FLAG_REPNZ:
			strcpy_WSN(str, "REPNZ ");
		break;
		default:
			/* Init mnemonic string, cause next touch is concatenation. */
			strclear_WS(str);
		break;
	}

	mnemonic = (const _WMnemonic*)&_MNEMONICS[di->opcode];
	memcpy((int8_t*)&str->p[str->length], mnemonic->p, mnemonic->length + 1);
	str->length += mnemonic->length;

	/* Format operands: */
	str = &result->operands;
	strclear_WS(str);

	/* Special treatment for String instructions. */
	if ((META_GET_ISC(di->meta) == ISC_INTEGER) &&
		((di->opcode == I_MOVS) ||
		 (di->opcode == I_CMPS) ||
		 (di->opcode == I_STOS) ||
		 (di->opcode == I_LODS) ||
		 (di->opcode == I_SCAS)))
	{
		/*
		 * No operands are needed if the address size is the default one,
		 * and no segment is overridden, so add the suffix letter,
		 * to indicate size of operation and continue to next instruction.
		 */
		if ((FLAG_GET_ADDRSIZE(di->flags) == ci->dt) && (SEGMENT_IS_DEFAULT(di->segment))) {
			str = &result->mnemonic;
			switch (di->ops[0].size)
			{
				case 8: chrcat_WS(str, 'B'); break;
				case 16: chrcat_WS(str, 'W'); break;
				case 32: chrcat_WS(str, 'D'); break;
				case 64: chrcat_WS(str, 'Q'); break;
			}
			return;
		}
	}

	for (i = 0; ((i < OPERANDS_NO) && (di->ops[i].type != O_NONE)); i++) {
		if (i > 0) strcat_WSN(str, ", ");
		switch (di->ops[i].type)
		{
			case O_REG:
				strcat_WS(str, (const _WString*)&_REGISTERS[di->ops[i].index]);
			break;
			case O_IMM:
				/* If the instruction is 'push', show explicit size (except byte imm). */
				if ((di->opcode == I_PUSH) && (di->ops[i].size != 8)) distorm_format_size(str, di, i);
				/* Special fix for negative sign extended immediates. */
				if ((di->flags & FLAG_IMM_SIGNED) && (di->ops[i].size == 8)) {
					if (di->imm.sbyte < 0) {
						chrcat_WS(str, MINUS_DISP_CHR);
						str_code_hb(str, -di->imm.sbyte);
						break;
					}
				}
				if (di->ops[i].size == 64) str_code_hqw(str, (uint8_t*)&di->imm.qword);
				else str_code_hdw(str, di->imm.dword);
			break;
			case O_IMM1:
				str_code_hdw(str, di->imm.ex.i1);
			break;
			case O_IMM2:
				str_code_hdw(str, di->imm.ex.i2);
			break;
			case O_DISP:
				distorm_format_size(str, di, i);
				chrcat_WS(str, OPEN_CHR);
				if ((SEGMENT_GET(di->segment) != R_NONE) && !SEGMENT_IS_DEFAULT(di->segment)) {
					strcat_WS(str, (const _WString*)&_REGISTERS[SEGMENT_GET(di->segment)]);
					chrcat_WS(str, SEG_OFF_CHR);
				}
				tmpDisp64 = di->disp & addrMask;
				str_code_hqw(str, (uint8_t*)&tmpDisp64);
				chrcat_WS(str, CLOSE_CHR);
			break;
			case O_SMEM:
				distorm_format_size(str, di, i);
				chrcat_WS(str, OPEN_CHR);

				/*
				 * This is where we need to take special care for String instructions.
				 * If we got here, it means we need to explicitly show their operands.
				 * The problem with CMPS and MOVS is that they have two(!) memory operands.
				 * So we have to complete it ourselves, since the structure supplies only the segment that can be overridden.
				 * And make the rest of the String operations explicit.
				 */
				segment = SEGMENT_GET(di->segment);
				isDefault = SEGMENT_IS_DEFAULT(di->segment);
				switch (di->opcode)
				{
					case I_MOVS:
						isDefault = FALSE;
						if (i == 0) segment = R_ES;
					break;
					case I_CMPS:
						isDefault = FALSE;
						if (i == 1) segment = R_ES;
					break;
					case I_INS:
					case I_LODS:
					case I_STOS:
					case I_SCAS: isDefault = FALSE; break;
				}
				if (!isDefault && (segment != R_NONE)) {
					strcat_WS(str, (const _WString*)&_REGISTERS[segment]);
					chrcat_WS(str, SEG_OFF_CHR);
				}

				strcat_WS(str, (const _WString*)&_REGISTERS[di->ops[i].index]);

				distorm_format_signed_disp(str, di, addrMask);
				chrcat_WS(str, CLOSE_CHR);
			break;
			case O_MEM:
				distorm_format_size(str, di, i);
				chrcat_WS(str, OPEN_CHR);
				if ((SEGMENT_GET(di->segment) != R_NONE) && !SEGMENT_IS_DEFAULT(di->segment)) {
					strcat_WS(str, (const _WString*)&_REGISTERS[SEGMENT_GET(di->segment)]);
					chrcat_WS(str, SEG_OFF_CHR);
				}
				if (di->base != R_NONE) {
					strcat_WS(str, (const _WString*)&_REGISTERS[di->base]);
					chrcat_WS(str, PLUS_DISP_CHR);
				}
				strcat_WS(str, (const _WString*)&_REGISTERS[di->ops[i].index]);
				if (di->scale != 0) {
					chrcat_WS(str, '*');
					if (di->scale == 2) chrcat_WS(str, '2');
					else if (di->scale == 4) chrcat_WS(str, '4');
					else /* if (di->scale == 8) */ chrcat_WS(str, '8');
				}

				distorm_format_signed_disp(str, di, addrMask);
				chrcat_WS(str, CLOSE_CHR);
			break;
			case O_PC:
#ifdef SUPPORT_64BIT_OFFSET
				str_off64(str, (di->imm.sqword + di->addr + di->size) & addrMask);
#else
				str_code_hdw(str, ((_OffsetType)di->imm.sdword + di->addr + di->size) & (uint32_t)addrMask);
#endif
			break;
			case O_PTR:
				str_code_hdw(str, di->imm.ptr.seg);
				chrcat_WS(str, SEG_OFF_CHR);
				str_code_hdw(str, di->imm.ptr.off);
			break;
		}
	}

	if (di->flags & FLAG_HINT_TAKEN) strcat_WSN(str, " ;TAKEN");
	else if (di->flags & FLAG_HINT_NOT_TAKEN) strcat_WSN(str, " ;NOT TAKEN");
}

#ifdef SUPPORT_64BIT_OFFSET
	_DLLEXPORT_ _DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#else
	_DLLEXPORT_ _DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount)
#endif
{
	_DecodeResult res;
	_DInst di;
	_CodeInfo ci;
	unsigned int instsCount = 0, i;

	*usedInstructionsCount = 0;

	/* I use codeLen as a signed variable in order to ease detection of underflow... and besides - */
	if (codeLen < 0) {
		return DECRES_INPUTERR;
	}

	if ((dt != Decode16Bits) && (dt != Decode32Bits) && (dt != Decode64Bits)) {
		return DECRES_INPUTERR;
	}

	if (code == NULL || result == NULL) {
		return DECRES_INPUTERR;
	}

	/* Assume length=0 is success. */
	if (codeLen == 0) {
		return DECRES_SUCCESS;
	}

	/*
	 * We have to format the result into text. But the interal decoder works with the new structure of _DInst.
	 * Therefore, we will pass the result array(!) from the caller and the interal decoder will fill it in with _DInst's.
	 * Then we will copy each result to a temporary structure, and use it to reformat that specific result.
	 *
	 * This is all done to save memory allocation and to work on the same result array in-place!!!
	 * It's a bit ugly, I have to admit, but worth it.
	 */

	ci.codeOffset = codeOffset;
	ci.code = code;
	ci.codeLen = codeLen;
	ci.dt = dt;
	ci.features = DF_NONE;
	if (dt == Decode16Bits) ci.features = DF_MAXIMUM_ADDR16;
	else if (dt == Decode32Bits) ci.features = DF_MAXIMUM_ADDR32;

	res = decode_internal(&ci, TRUE, (_DInst*)result, maxInstructions, &instsCount);
	for (i = 0; i < instsCount; i++) {
		if ((*usedInstructionsCount + i) >= maxInstructions) return DECRES_MEMORYERR;

		/* Copy the current decomposed result to a temp structure, so we can override the result with text. */
		memcpy(&di, (char*)result + (i * sizeof(_DecodedInst)), sizeof(_DInst));
#ifdef SUPPORT_64BIT_OFFSET
		distorm_format64(&ci, &di, &result[i]);
#else
		distorm_format32(&ci, &di, &result[i]);
#endif
	}

	*usedInstructionsCount = instsCount;
	return res;
}

#endif /* DISTORM_LIGHT */

_DLLEXPORT_ unsigned int distorm_version()
{
	return __DISTORMV__;
}



================================================
File: 3rdparty/distorm/distorm.h
================================================
/* diStorm 3.3.3 */

/*
distorm.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef DISTORM_H
#define DISTORM_H

/*
 * 64 bit offsets support:
 * If the diStorm library you use was compiled with 64 bits offsets,
 * make sure you compile your own code with the following macro set:
 * SUPPORT_64BIT_OFFSET
 * Otherwise comment it out, or you will get a linker error of an unresolved symbol...
 * Turned on by default!
 */

#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))
	/* Define this macro for outer projects by default. */
	#define SUPPORT_64BIT_OFFSET
#endif

/* TINYC has a problem with some 64bits library functions, so ignore 64 bit offsets. */
#ifdef __TINYC__
	#undef SUPPORT_64BIT_OFFSET
#endif

/* If your compiler doesn't support stdint.h, define your own 64 bits type. */
#ifdef SUPPORT_64BIT_OFFSET
	#ifdef _MSC_VER
		#define OFFSET_INTEGER unsigned __int64
	#else
		#include <stdint.h>
		#define OFFSET_INTEGER uint64_t
	#endif
#else
	/* 32 bit offsets are used. */
	#define OFFSET_INTEGER unsigned long
#endif

#ifdef _MSC_VER
/* Since MSVC isn't shipped with stdint.h, we will have our own: */
typedef signed __int64		int64_t;
typedef unsigned __int64	uint64_t;
typedef signed __int32		int32_t;
typedef unsigned __int32	uint32_t;
typedef signed __int16		int16_t;
typedef unsigned __int16	uint16_t;
typedef signed __int8		int8_t;
typedef unsigned __int8		uint8_t;
#endif

/* Support C++ compilers */
#ifdef __cplusplus
 extern "C" {
#endif


/* ***  Helper Macros  *** */

/* Get the ISC of the instruction, used with the definitions below. */
#define META_GET_ISC(meta) (((meta) >> 3) & 0x1f)
#define META_SET_ISC(di, isc) (((di)->meta) |= ((isc) << 3))
/* Get the flow control flags of the instruction, see 'features for decompose' below. */
#define META_GET_FC(meta) ((meta) & 0x7)

/* Get the target address of a branching instruction. O_PC operand type. */
#define INSTRUCTION_GET_TARGET(di) ((_OffsetType)(((di)->addr + (di)->imm.addr + (di)->size)))
/* Get the target address of a RIP-relative memory indirection. */
#define INSTRUCTION_GET_RIP_TARGET(di) ((_OffsetType)(((di)->addr + (di)->disp + (di)->size)))

/*
 * Operand Size or Adderss size are stored inside the flags:
 * 00 - 16 bits
 * 01 - 32 bits
 * 10 - 64 bits
 * 11 - reserved
 *
 * If you call these set-macros more than once, you will have to clean the bits before doing so.
 */
#define FLAG_SET_OPSIZE(di, size) ((di->flags) |= (((size) & 3) << 8))
#define FLAG_SET_ADDRSIZE(di, size) ((di->flags) |= (((size) & 3) << 10))
#define FLAG_GET_OPSIZE(flags) (((flags) >> 8) & 3)
#define FLAG_GET_ADDRSIZE(flags) (((flags) >> 10) & 3)
/* To get the LOCK/REPNZ/REP prefixes. */
#define FLAG_GET_PREFIX(flags) ((flags) & 7)
/* Indicates whether the instruction is privileged. */
#define FLAG_GET_PRIVILEGED(flags) (((flags) & FLAG_PRIVILEGED_INSTRUCTION) != 0)

/*
 * Macros to extract segment registers from 'segment':
 */
#define SEGMENT_DEFAULT 0x80
#define SEGMENT_SET(di, seg) ((di->segment) |= seg)
#define SEGMENT_GET(segment) (((segment) == R_NONE) ? R_NONE : ((segment) & 0x7f))
#define SEGMENT_IS_DEFAULT(segment) (((segment) & SEGMENT_DEFAULT) == SEGMENT_DEFAULT)


/* Decodes modes of the disassembler, 16 bits or 32 bits or 64 bits for AMD64, x86-64. */
typedef enum { Decode16Bits = 0, Decode32Bits = 1, Decode64Bits = 2 } _DecodeType;

typedef OFFSET_INTEGER _OffsetType;

typedef struct {
	_OffsetType codeOffset, nextOffset; /* nextOffset is OUT only. */
	const uint8_t* code;
	int codeLen; /* Using signed integer makes it easier to detect an underflow. */
	_DecodeType dt;
	unsigned int features;
} _CodeInfo;

typedef enum { O_NONE, O_REG, O_IMM, O_IMM1, O_IMM2, O_DISP, O_SMEM, O_MEM, O_PC, O_PTR } _OperandType;

typedef union {
	/* Used by O_IMM: */
	int8_t sbyte;
	uint8_t byte;
	int16_t sword;
	uint16_t word;
	int32_t sdword;
	uint32_t dword;
	int64_t sqword; /* All immediates are SIGN-EXTENDED to 64 bits! */
	uint64_t qword;

	/* Used by O_PC: (Use GET_TARGET_ADDR).*/
	_OffsetType addr; /* It's a relative offset as for now. */

	/* Used by O_PTR: */
	struct {
		uint16_t seg;
		/* Can be 16 or 32 bits, size is in ops[n].size. */
		uint32_t off;
	} ptr;

	/* Used by O_IMM1 (i1) and O_IMM2 (i2). ENTER instruction only. */
	struct {
		uint32_t i1;
		uint32_t i2;
	} ex;
} _Value;

typedef struct {
	/* Type of operand:
		O_NONE: operand is to be ignored.
		O_REG: index holds global register index.
		O_IMM: instruction.imm.
		O_IMM1: instruction.imm.ex.i1.
		O_IMM2: instruction.imm.ex.i2.
		O_DISP: memory dereference with displacement only, instruction.disp.
		O_SMEM: simple memory dereference with optional displacement (a single register memory dereference).
		O_MEM: complex memory dereference (optional fields: s/i/b/disp).
		O_PC: the relative address of a branch instruction (instruction.imm.addr).
		O_PTR: the absolute target address of a far branch instruction (instruction.imm.ptr.seg/off).
	*/
	uint8_t type; /* _OperandType */

	/* Index of:
		O_REG: holds global register index
		O_SMEM: holds the 'base' register. E.G: [ECX], [EBX+0x1234] are both in operand.index.
		O_MEM: holds the 'index' register. E.G: [EAX*4] is in operand.index.
	*/
	uint8_t index;

	/* Size in bits of:
		O_REG: register
		O_IMM: instruction.imm
		O_IMM1: instruction.imm.ex.i1
		O_IMM2: instruction.imm.ex.i2
		O_DISP: instruction.disp
		O_SMEM: size of indirection.
		O_MEM: size of indirection.
		O_PC: size of the relative offset
		O_PTR: size of instruction.imm.ptr.off (16 or 32)
	*/
	uint16_t size;
} _Operand;

#define OPCODE_ID_NONE 0
/* Instruction could not be disassembled. */
#define FLAG_NOT_DECODABLE ((uint16_t)-1)
/* The instruction locks memory access. */
#define FLAG_LOCK (1 << 0)
/* The instruction is prefixed with a REPNZ. */
#define FLAG_REPNZ (1 << 1)
/* The instruction is prefixed with a REP, this can be a REPZ, it depends on the specific instruction. */
#define FLAG_REP (1 << 2)
/* Indicates there is a hint taken for Jcc instructions only. */
#define FLAG_HINT_TAKEN (1 << 3)
/* Indicates there is a hint non-taken for Jcc instructions only. */
#define FLAG_HINT_NOT_TAKEN (1 << 4)
/* The Imm value is signed extended (E.G in 64 bit decoding mode, a 32 bit imm is usually sign extended into 64 bit imm). */
#define FLAG_IMM_SIGNED (1 << 5)
/* The destination operand is writable. */
#define FLAG_DST_WR (1 << 6)
/* The instruction uses RIP-relative indirection. */
#define FLAG_RIP_RELATIVE (1 << 7)

/* See flag FLAG_GET_XXX macros above. */

/* The instruction is privileged and can only be used from Ring0. */
#define FLAG_PRIVILEGED_INSTRUCTION (1 << 15)

/* No register was defined. */
#define R_NONE ((uint8_t)-1)

#define REGS64_BASE 0
#define REGS32_BASE 16
#define REGS16_BASE 32
#define REGS8_BASE 48
#define REGS8_REX_BASE 64
#define SREGS_BASE 68
#define FPUREGS_BASE 75
#define MMXREGS_BASE 83
#define SSEREGS_BASE 91
#define AVXREGS_BASE 107
#define CREGS_BASE 123
#define DREGS_BASE 132

#define OPERANDS_NO (4)

typedef struct {
	/* Used by ops[n].type == O_IMM/O_IMM1&O_IMM2/O_PTR/O_PC. Its size is ops[n].size. */
	_Value imm;
	/* Used by ops[n].type == O_SMEM/O_MEM/O_DISP. Its size is dispSize. */
	uint64_t disp;
	/* Virtual address of first byte of instruction. */
	_OffsetType addr;
	/* General flags of instruction, holds prefixes and more, if FLAG_NOT_DECODABLE, instruction is invalid. */
	uint16_t flags;
	/* Unused prefixes mask, for each bit that is set that prefix is not used (LSB is byte [addr + 0]). */
	uint16_t unusedPrefixesMask;
	/* Mask of registers that were used in the operands, only used for quick look up, in order to know *some* operand uses that register class. */
	uint32_t usedRegistersMask;
	/* ID of opcode in the global opcode table. Use for mnemonic look up. */
	uint16_t opcode;
	/* Up to four operands per instruction, ignored if ops[n].type == O_NONE. */
	_Operand ops[OPERANDS_NO];
	/* Size of the whole instruction in bytes. */
	uint8_t size;
	/* Segment information of memory indirection, default segment, or overriden one, can be -1. Use SEGMENT macros. */
	uint8_t segment;
	/* Used by ops[n].type == O_MEM. Base global register index (might be R_NONE), scale size (2/4/8), ignored for 0 or 1. */
	uint8_t base, scale;
	uint8_t dispSize;
	/* Meta defines the instruction set class, and the flow control flags. Use META macros. */
	uint8_t meta;
	/* The CPU flags that the instruction operates upon. */
	uint16_t modifiedFlagsMask, testedFlagsMask, undefinedFlagsMask;
} _DInst;

#ifndef DISTORM_LIGHT

/* Static size of strings. Do not change this value. Keep Python wrapper in sync. */
#define MAX_TEXT_SIZE (48)
typedef struct {
	unsigned int length;
	unsigned char p[MAX_TEXT_SIZE]; /* p is a null terminated string. */
} _WString;

/*
 * Old decoded instruction structure in text format.
 * Used only for backward compatibility with diStorm64.
 * This structure holds all information the disassembler generates per instruction.
 */
typedef struct {
	_WString mnemonic; /* Mnemonic of decoded instruction, prefixed if required by REP, LOCK etc. */
	_WString operands; /* Operands of the decoded instruction, up to 3 operands, comma-seperated. */
	_WString instructionHex; /* Hex dump - little endian, including prefixes. */
	unsigned int size; /* Size of decoded instruction in bytes. */
	_OffsetType offset; /* Start offset of the decoded instruction. */
} _DecodedInst;

#endif /* DISTORM_LIGHT */

/* Register masks for quick look up, each mask indicates one of a register-class that is being used in some operand. */
#define RM_AX 1     /* AL, AH, AX, EAX, RAX */
#define RM_CX 2     /* CL, CH, CX, ECX, RCX */
#define RM_DX 4     /* DL, DH, DX, EDX, RDX */
#define RM_BX 8     /* BL, BH, BX, EBX, RBX */
#define RM_SP 0x10  /* SPL, SP, ESP, RSP */ 
#define RM_BP 0x20  /* BPL, BP, EBP, RBP */
#define RM_SI 0x40  /* SIL, SI, ESI, RSI */
#define RM_DI 0x80  /* DIL, DI, EDI, RDI */
#define RM_FPU 0x100 /* ST(0) - ST(7) */
#define RM_MMX 0x200 /* MM0 - MM7 */
#define RM_SSE 0x400 /* XMM0 - XMM15 */
#define RM_AVX 0x800 /* YMM0 - YMM15 */
#define RM_CR 0x1000 /* CR0, CR2, CR3, CR4, CR8 */
#define RM_DR 0x2000 /* DR0, DR1, DR2, DR3, DR6, DR7 */
#define RM_R8 0x4000 /* R8B, R8W, R8D, R8 */
#define RM_R9 0x8000 /* R9B, R9W, R9D, R9 */
#define RM_R10 0x10000 /* R10B, R10W, R10D, R10 */
#define RM_R11 0x20000 /* R11B, R11W, R11D, R11 */
#define RM_R12 0x40000 /* R12B, R12W, R12D, R12 */
#define RM_R13 0x80000 /* R13B, R13W, R13D, R13 */
#define RM_R14 0x100000 /* R14B, R14W, R14D, R14 */
#define RM_R15 0x200000 /* R15B, R15W, R15D, R15 */

/* RIP should be checked using the 'flags' field and FLAG_RIP_RELATIVE.
 * Segments should be checked using the segment macros.
 * For now R8 - R15 are not supported and non general purpose registers map into same RM.
 */

/* CPU flags that instructions modify, test or undefine (are EFLAGS compatible!). */
#define D_CF 1		/* Carry */
#define D_PF 4		/* Parity */
#define D_AF 0x10	/* Auxiliary */
#define D_ZF 0x40	/* Zero */
#define D_SF 0x80	/* Sign */
#define D_IF 0x200	/* Interrupt */
#define D_DF 0x400	/* Direction */
#define D_OF 0x800	/* Overflow */

/*
 * Instructions Set classes:
 * if you want a better understanding of the available classes, look at disOps project, file: x86sets.py.
 */
/* Indicates the instruction belongs to the General Integer set. */
#define ISC_INTEGER 1
/* Indicates the instruction belongs to the 387 FPU set. */
#define ISC_FPU 2
/* Indicates the instruction belongs to the P6 set. */
#define ISC_P6 3
/* Indicates the instruction belongs to the MMX set. */
#define ISC_MMX 4
/* Indicates the instruction belongs to the SSE set. */
#define ISC_SSE 5
/* Indicates the instruction belongs to the SSE2 set. */
#define ISC_SSE2 6
/* Indicates the instruction belongs to the SSE3 set. */
#define ISC_SSE3 7
/* Indicates the instruction belongs to the SSSE3 set. */
#define ISC_SSSE3 8
/* Indicates the instruction belongs to the SSE4.1 set. */
#define ISC_SSE4_1 9
/* Indicates the instruction belongs to the SSE4.2 set. */
#define ISC_SSE4_2 10
/* Indicates the instruction belongs to the AMD's SSE4.A set. */
#define ISC_SSE4_A 11
/* Indicates the instruction belongs to the 3DNow! set. */
#define ISC_3DNOW 12
/* Indicates the instruction belongs to the 3DNow! Extensions set. */
#define ISC_3DNOWEXT 13
/* Indicates the instruction belongs to the VMX (Intel) set. */
#define ISC_VMX 14
/* Indicates the instruction belongs to the SVM (AMD) set. */
#define ISC_SVM 15
/* Indicates the instruction belongs to the AVX (Intel) set. */
#define ISC_AVX 16
/* Indicates the instruction belongs to the FMA (Intel) set. */
#define ISC_FMA 17
/* Indicates the instruction belongs to the AES/AVX (Intel) set. */
#define ISC_AES 18
/* Indicates the instruction belongs to the CLMUL (Intel) set. */
#define ISC_CLMUL 19

/* Features for decompose: */
#define DF_NONE 0
/* The decoder will limit addresses to a maximum of 16 bits. */
#define DF_MAXIMUM_ADDR16 1
/* The decoder will limit addresses to a maximum of 32 bits. */
#define DF_MAXIMUM_ADDR32 2
/* The decoder will return only flow control instructions (and filter the others internally). */
#define DF_RETURN_FC_ONLY 4
/* The decoder will stop and return to the caller when the instruction 'CALL' (near and far) was decoded. */
#define DF_STOP_ON_CALL 8
/* The decoder will stop and return to the caller when the instruction 'RET' (near and far) was decoded. */
#define DF_STOP_ON_RET 0x10
/* The decoder will stop and return to the caller when the instruction system-call/ret was decoded. */
#define DF_STOP_ON_SYS 0x20
/* The decoder will stop and return to the caller when any of the branch 'JMP', (near and far) instructions were decoded. */
#define DF_STOP_ON_UNC_BRANCH 0x40
/* The decoder will stop and return to the caller when any of the conditional branch instruction were decoded. */
#define DF_STOP_ON_CND_BRANCH 0x80
/* The decoder will stop and return to the caller when the instruction 'INT' (INT, INT1, INTO, INT 3) was decoded. */
#define DF_STOP_ON_INT 0x100
/* The decoder will stop and return to the caller when any of the 'CMOVxx' instruction was decoded. */
#define DF_STOP_ON_CMOV 0x200
/* The decoder will stop and return to the caller when any flow control instruction was decoded. */
#define DF_STOP_ON_FLOW_CONTROL (DF_STOP_ON_CALL | DF_STOP_ON_RET | DF_STOP_ON_SYS | DF_STOP_ON_UNC_BRANCH | DF_STOP_ON_CND_BRANCH | DF_STOP_ON_INT | DF_STOP_ON_CMOV)

/* Indicates the instruction is not a flow-control instruction. */
#define FC_NONE 0
/* Indicates the instruction is one of: CALL, CALL FAR. */
#define FC_CALL 1
/* Indicates the instruction is one of: RET, IRET, RETF. */
#define FC_RET 2
/* Indicates the instruction is one of: SYSCALL, SYSRET, SYSENTER, SYSEXIT. */
#define FC_SYS 3
/* Indicates the instruction is one of: JMP, JMP FAR. */
#define FC_UNC_BRANCH 4
/*
 * Indicates the instruction is one of:
 * JCXZ, JO, JNO, JB, JAE, JZ, JNZ, JBE, JA, JS, JNS, JP, JNP, JL, JGE, JLE, JG, LOOP, LOOPZ, LOOPNZ.
 */
#define FC_CND_BRANCH 5
/* Indiciates the instruction is one of: INT, INT1, INT 3, INTO, UD2. */
#define FC_INT 6
/* Indicates the instruction is one of: CMOVxx. */
#define FC_CMOV 7

/* Return code of the decoding function. */
typedef enum { DECRES_NONE, DECRES_SUCCESS, DECRES_MEMORYERR, DECRES_INPUTERR, DECRES_FILTERED } _DecodeResult;

/* Define the following interface functions only for outer projects. */
#if !(defined(DISTORM_STATIC) || defined(DISTORM_DYNAMIC))

/* distorm_decode
 * Input:
 *         offset - Origin of the given code (virtual address that is), NOT an offset in code.
 *         code - Pointer to the code buffer to be disassembled.
 *         length - Amount of bytes that should be decoded from the code buffer.
 *         dt - Decoding mode, 16 bits (Decode16Bits), 32 bits (Decode32Bits) or AMD64 (Decode64Bits).
 *         result - Array of type _DecodeInst which will be used by this function in order to return the disassembled instructions.
 *         maxInstructions - The maximum number of entries in the result array that you pass to this function, so it won't exceed its bound.
 *         usedInstructionsCount - Number of the instruction that successfully were disassembled and written to the result array.
 * Output: usedInstructionsCount will hold the number of entries used in the result array
 *         and the result array itself will be filled with the disassembled instructions.
 * Return: DECRES_SUCCESS on success (no more to disassemble), DECRES_INPUTERR on input error (null code buffer, invalid decoding mode, etc...),
 *         DECRES_MEMORYERR when there are not enough entries to use in the result array, BUT YOU STILL have to check for usedInstructionsCount!
 * Side-Effects: Even if the return code is DECRES_MEMORYERR, there might STILL be data in the
 *               array you passed, this function will try to use as much entries as possible!
 * Notes:  1)The minimal size of maxInstructions is 15.
 *         2)You will have to synchronize the offset,code and length by yourself if you pass code fragments and not a complete code block!
 */
 
/* distorm_decompose
 * See more documentation online at the GitHub project's wiki.
 *
 */
#ifdef SUPPORT_64BIT_OFFSET

	_DecodeResult distorm_decompose64(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	#define distorm_decompose distorm_decompose64

#ifndef DISTORM_LIGHT
	/* If distorm-light is defined, we won't export these text-formatting functionality. */
	_DecodeResult distorm_decode64(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	void distorm_format64(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
	#define distorm_decode distorm_decode64
	#define distorm_format distorm_format64
#endif /*DISTORM_LIGHT*/

#else /*SUPPORT_64BIT_OFFSET*/

	_DecodeResult distorm_decompose32(_CodeInfo* ci, _DInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	#define distorm_decompose distorm_decompose32

#ifndef DISTORM_LIGHT
	/* If distorm-light is defined, we won't export these text-formatting functionality. */
	_DecodeResult distorm_decode32(_OffsetType codeOffset, const unsigned char* code, int codeLen, _DecodeType dt, _DecodedInst result[], unsigned int maxInstructions, unsigned int* usedInstructionsCount);
	void distorm_format32(const _CodeInfo* ci, const _DInst* di, _DecodedInst* result);
	#define distorm_decode distorm_decode32
	#define distorm_format distorm_format32
#endif /*DISTORM_LIGHT*/

#endif

/*
 * distorm_version
 * Input:
 *        none
 *
 * Output: unsigned int - version of compiled library.
 */
unsigned int distorm_version();

#endif /* DISTORM_STATIC */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#endif /* DISTORM_H */



================================================
File: 3rdparty/distorm/distorm.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{920bbb4d-c715-4cd4-9129-ff2cf941495d}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>distorm</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>DISTORM_STATIC;SUPPORT_64BIT_OFFSET;DISTORM_LIGHT;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>DISTORM_STATIC;SUPPORT_64BIT_OFFSET;DISTORM_LIGHT;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>DISTORM_STATIC;SUPPORT_64BIT_OFFSET;DISTORM_LIGHT;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>DISTORM_STATIC;SUPPORT_64BIT_OFFSET;DISTORM_LIGHT;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="decoder.c" />
    <ClCompile Include="distorm.c" />
    <ClCompile Include="instructions.c" />
    <ClCompile Include="insts.c" />
    <ClCompile Include="mnemonics.c" />
    <ClCompile Include="operands.c" />
    <ClCompile Include="prefix.c" />
    <ClCompile Include="textdefs.c" />
    <ClCompile Include="wstring.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="config.h" />
    <ClInclude Include="decoder.h" />
    <ClInclude Include="distorm.h" />
    <ClInclude Include="instructions.h" />
    <ClInclude Include="insts.h" />
    <ClInclude Include="mnemonics.h" />
    <ClInclude Include="operands.h" />
    <ClInclude Include="prefix.h" />
    <ClInclude Include="textdefs.h" />
    <ClInclude Include="wstring.h" />
    <ClInclude Include="x86defs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: 3rdparty/distorm/distorm.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="decoder.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="distorm.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="instructions.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="insts.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mnemonics.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="operands.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="prefix.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="textdefs.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wstring.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="config.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="decoder.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="distorm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="instructions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="insts.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mnemonics.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="operands.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="prefix.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="textdefs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="wstring.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x86defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


================================================
File: 3rdparty/distorm/instructions.c
================================================
/*
instructions.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "instructions.h"

#include "insts.h"
#include "prefix.h"
#include "x86defs.h"
#include "mnemonics.h"


/* Helper macros to extract the type or index from an inst-node value. */
#define INST_NODE_INDEX(n) ((n) & 0x1fff)
#define INST_NODE_TYPE(n) ((n) >> 13)

/* Helper macro to read the actual flags that are associated with an inst-info. */
#define INST_INFO_FLAGS(ii) (FlagsTable[InstSharedInfoTable[(ii)->sharedIndex].flagsIndex])

/*
I use the trie data structure as I found it most fitting to a disassembler mechanism.
When you read a byte and have to decide if it's enough or you should read more bytes, 'till you get to the instruction information.
It's really fast because you POP the instruction info in top 3 iterates on the DB, because an instruction can be formed from two bytes + 3 bits reg from the ModR/M byte.
For a simple explanation, check this out:
http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Trie/
Further reading: http://en.wikipedia.org/wiki/Trie

The first GATE (array you read off a trie data structure), as I call them, is statically allocated by the compiler.
The second and third gates if used are being allocated dynamically by the instructions-insertion functionality.

How would such a thing look in memory, say we support 4 instructions with 3 bytes top (means 2 dynamically allocated gates).

->
|-------|                                0,
|0|     -------------------------------> |-------|
|1|RET  |      1,                        |0|AND  |
|2|     -----> |-------|                 |1|XOR  |
|3|INT3 |      |0|PUSH |                 |2|OR   |         0,3,
|-------|      |1|POP  |                 |3|     --------->|-------|
               |2|PUSHF|                 |-------|         |0|ROR  |
               |3|POPF |                                   |1|ROL  |
               |-------|                                   |2|SHR  |
                                                           |3|SHL  |
                                                           |-------|

Of course, this is NOT how Intel instructions set looks!!!
but I just wanted to give a small demonstration.
Now the instructions you get from such a trie DB goes like this:

0, 0 - AND
0, 1 - XOR
0, 2 - OR
0, 3, 0, ROR
0, 3, 1, ROL
0, 3, 2, SHR
0, 3, 3, SHL
1 - RET
2, 0 - PUSH
2, 1 - POP
2, 2 - PUSHF
2, 3 - POPF
3 - INT3

I guess it's clear by now.
So now, if you read 0, you know that you have to enter the second gate(list) with the second byte specifying the index.
But if you read 1, you know that you go to an instruction (in this case, a RET).
That's why there's an Instruction-Node structure, it tells you whether you got to an instruction or another list
so you should keep on reading byte).

In Intel, you could go through 4 gates at top, because there are instructions which are built from 2 bytes and another smaller list
for the REG part, or newest SSE4 instructions which use 4 bytes for opcode.
Therefore, Intel's first gate is 256 long, and other gates are 256 (/72) or 8 long, yes, it costs pretty much a lot of memory
for non-used defined instructions, but I think that it still rocks.
*/

/*
 * A helper function to look up the correct inst-info structure.
 * It does one fetch from the index-table, and then another to get the inst-info.
 * Note that it takes care about basic inst-info or inst-info-ex.
 * The caller should worry about boundary checks and whether it accesses a last-level table.
 */
static _InstInfo* inst_get_info(_InstNode in, int index)
{
	int instIndex = 0;

	in = InstructionsTree[INST_NODE_INDEX(in) + index];
	if (in == INT_NOTEXISTS) return NULL;

	instIndex = INST_NODE_INDEX(in);
	return INST_NODE_TYPE(in) == INT_INFO ? &InstInfos[instIndex] : (_InstInfo*)&InstInfosEx[instIndex];
}

/*
 * This function is responsible to return the instruction information of the first found in code.
 * It returns the _InstInfo of the found instruction, otherwise NULL.
 * code should point to the ModR/M byte upon exit (if used), or after the instruction binary code itself.
 * This function is NOT decoding-type dependant, it is up to the caller to see whether the instruction is valid.
 * Get the instruction info, using a Trie data structure.
 *
 * Sometimes normal prefixes become mandatory prefixes, which means they are now part of the instruction opcode bytes.

 * This is a bit tricky now,
 * if the first byte is a REP (F3) prefix, we will have to give a chance to an SSE instruction.
 * If an instruction doesn't exist, we will make it as a prefix and re-locateinst.
 * A case such that a REP prefix is being changed into an instruction byte and also an SSE instruction will not be found can't happen,
 * simply because there are no collisions between string instruction and SSE instructions (they are escaped).

 * As for S/SSE2/3, check for F2 and 66 as well.

 * In 64 bits, we have to make sure that we will skip the REX prefix, if it exists.
 * There's a specific case, where a 66 is mandatory but it was dropped because REG.W was used,
 * but it doesn't behave as an operand size prefix but as a mandatory, so we will have to take it into account.

 * For example (64 bits decoding mode):
 * 66 98 CBW
 * 48 98 CDQE
 * 66 48 98: db 0x66; CDQE
 * Shows that operand size is dropped.

 * Now, it's a mandatory prefix and NOT an operand size one.
 * 66480f2dc0 db 0x48; CVTPD2PI XMM0, XMM0
 * Although this instruction doesn't require a REX.W, it just shows, that even if it did - it doesn't matter.
 * REX.W is dropped because it's not required, but the decode function disabled the operand size even so.
 */
static _InstInfo* inst_lookup_prefixed(_InstNode in, _PrefixState* ps)
{
	int checkOpSize = FALSE;
	int index = 0;
	_InstInfo* ii = NULL;

	/* Check prefixes of current decoded instruction (None, 0x66, 0xf3, 0xf2). */
	switch (ps->decodedPrefixes & (INST_PRE_OP_SIZE | INST_PRE_REPS))
	{
		case 0:
			/* Non-prefixed, index = 0. */
			index = 0;
		break;
		case INST_PRE_OP_SIZE:
			/* 0x66, index = 1. */
			index = 1;
			/* Mark that we used it as a mandatory prefix. */
			ps->isOpSizeMandatory = TRUE;
			ps->decodedPrefixes &= ~INST_PRE_OP_SIZE;
		break;
		case INST_PRE_REP:
			/* 0xf3, index = 2. */
			index = 2;
			ps->decodedPrefixes &= ~INST_PRE_REP;
		break;
		case INST_PRE_REPNZ:
			/* 0xf2, index = 3. */
			index = 3;
			ps->decodedPrefixes &= ~INST_PRE_REPNZ;
		break;
		default:
			/*
			 * Now we got a problem, since there are a few mandatory prefixes at once.
			 * There is only one case when it's ok, when the operand size prefix is for real (not mandatory).
			 * Otherwise we will have to return NULL, since the instruction is illegal.
			 * Therefore we will start with REPNZ and REP prefixes,
			 * try to get the instruction and only then check for the operand size prefix.
			 */

			/* If both REPNZ and REP are together, it's illegal for sure. */
			if ((ps->decodedPrefixes & INST_PRE_REPS) == INST_PRE_REPS) return NULL;

			/* Now we know it's either REPNZ+OPSIZE or REP+OPSIZE, so examine the instruction. */
			if (ps->decodedPrefixes & INST_PRE_REPNZ) {
				index = 3;
				ps->decodedPrefixes &= ~INST_PRE_REPNZ;
			} else if (ps->decodedPrefixes & INST_PRE_REP) {
				index = 2;
				ps->decodedPrefixes &= ~INST_PRE_REP;
			}
			/* Mark to verify the operand-size prefix of the fetched instruction below. */
			checkOpSize = TRUE;
		break;
	}

	/* Fetch the inst-info from the index. */
	ii = inst_get_info(in, index);

	if (checkOpSize) {
		/* If the instruction doesn't support operand size prefix, then it's illegal. */
		if ((ii == NULL) || (~INST_INFO_FLAGS(ii) & INST_PRE_OP_SIZE)) return NULL;
	}

	/* If there was a prefix, but the instruction wasn't found. Try to fall back to use the normal instruction. */
	if (ii == NULL) ii = inst_get_info(in, 0);
	return ii;
}

/* A helper function to look up special VEX instructions.
 * See if it's a MOD based instruction and fix index if required.
 * Only after a first lookup (that was done by caller), we can tell if we need to fix the index.
 * Because these are coupled instructions
 * (which means that the base instruction hints about the other instruction).
 * Note that caller should check if it's a MOD dependent instruction before getting in here.
 */
static _InstInfo* inst_vex_mod_lookup(_CodeInfo* ci, _InstNode in, _InstInfo* ii, unsigned int index)
{
	/* Advance to read the MOD from ModRM byte. */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	if (*ci->code < INST_DIVIDED_MODRM) {
		/* MOD is not 11, therefore change the index to 8 - 12 range in the prefixed table. */
		index += 4;
		/* Make a second lookup for this special instruction. */
		return inst_get_info(in, index);
	}
	/* Return the original one, in case we didn't find a suited instruction. */
	return ii;
}

static _InstInfo* inst_vex_lookup(_CodeInfo* ci, _PrefixState* ps)
{
	_InstNode in = 0;
	unsigned int pp = 0, start = 0;
	unsigned int index = 4; /* VEX instructions start at index 4 in the Prefixed table. */
	uint8_t vex = *ps->vexPos, vex2 = 0, v = 0;
	int instType = 0, instIndex = 0;

	/* The VEX instruction will #ud if any of 66, f0, f2, f3, REX prefixes precede. */
	_iflags illegal = (INST_PRE_OP_SIZE | INST_PRE_LOCK | INST_PRE_REP | INST_PRE_REPNZ | INST_PRE_REX);
	if ((ps->decodedPrefixes & illegal) != 0) return NULL;

	/* Read the some fields from the VEX prefix we need to extract the instruction. */
	if (ps->prefixExtType == PET_VEX2BYTES) {
		ps->vexV = v = (~vex >> 3) & 0xf;
		pp = vex & 3;
		/* Implied leading 0x0f byte by default for 2 bytes VEX prefix. */
		start = 1;
	} else { /* PET_VEX3BYTES */
		start = vex & 0x1f;
		vex2 = *(ps->vexPos + 1);
		ps->vexV = v = (~vex2 >> 3) & 0xf;
		pp = vex2 & 3;
	}

	/* start can be either 1 (0x0f), 2 (0x0f, 0x038) or 3 (0x0f, 0x3a), otherwise it's illegal. */
	switch (start)
	{
		case 1: in = Table_0F; break;
		case 2: in = Table_0F_38; break;
		case 3: in = Table_0F_3A; break;
		default: return NULL;
	}

	/* pp is actually the implied mandatory prefix, apply it to the index. */
	index += pp; /* (None, 0x66, 0xf3, 0xf2) */

	/* Read a byte from the stream. */
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;

	in = InstructionsTree[INST_NODE_INDEX(in) + *ci->code];
	if (in == INT_NOTEXISTS) return NULL;

	instType = INST_NODE_TYPE(in);
	instIndex = INST_NODE_INDEX(in);

	/*
	 * If we started with 0f38 or 0f3a so it's a prefixed table,
	 * therefore it's surely a VEXed instruction (because of a high index).
	 * However, starting with 0f, could also lead immediately to a prefixed table for some bytes.
	 * it might return NULL, if the index is invalid.
	 */
	if (instType == INT_LIST_PREFIXED) {
		_InstInfo* ii = inst_get_info(in, index);
		/* See if the instruction is dependent on MOD. */
		if ((ii != NULL) && (((_InstInfoEx*)ii)->flagsEx & INST_MODRR_BASED)) {
			ii = inst_vex_mod_lookup(ci, in, ii, index);
		}
		return ii;
	}

	/*
	 * If we reached here, obviously we started with 0f. VEXed instructions must be nodes of a prefixed table.
	 * But since we found an instruction (or divided one), just return NULL.
	 * They cannot lead to a VEXed instruction.
	 */
	if ((instType == INT_INFO) || (instType == INT_INFOEX) || (instType == INT_LIST_DIVIDED)) return NULL;

	/* Now we are left with handling either GROUP or FULL tables, therefore we will read another byte from the stream. */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;

	if (instType == INT_LIST_GROUP) {
		in = InstructionsTree[instIndex + ((*ci->code >> 3) & 7)];
		/* Continue below to check prefixed table. */
	} else if (instType == INT_LIST_FULL) {
		in = InstructionsTree[instIndex + *ci->code];
		/* Continue below to check prefixed table. */
	}

	/* Now that we got to the last table in the trie, check for a prefixed table. */
	if (INST_NODE_TYPE(in) == INT_LIST_PREFIXED) {
		_InstInfo* ii = inst_get_info(in, index);
		/* See if the instruction is dependent on MOD. */
		if ((ii != NULL) && (((_InstInfoEx*)ii)->flagsEx & INST_MODRR_BASED)) {
			ii = inst_vex_mod_lookup(ci, in, ii, index);
		}
		return ii;
	}

	/* No VEXed instruction was found. */
	return NULL;
}

_InstInfo* inst_lookup(_CodeInfo* ci, _PrefixState* ps)
{
	unsigned int tmpIndex0 = 0, tmpIndex1 = 0, tmpIndex2 = 0, rex = ps->vrex;
	int instType = 0;
	_InstNode in = 0;
	_InstInfo* ii = NULL;
	int isWaitIncluded = FALSE;

	/* See whether we have to handle a VEX prefixed instruction. */
	if (ps->decodedPrefixes & INST_PRE_VEX) {
		ii = inst_vex_lookup(ci, ps);
		if (ii != NULL) {
			/* Make sure that VEX.L exists when forced. */
			if ((((_InstInfoEx*)ii)->flagsEx & INST_FORCE_VEXL) && (~ps->vrex & PREFIX_EX_L)) return NULL;
			/* If the instruction doesn't use VEX.vvvv it must be zero. */
			if ((((_InstInfoEx*)ii)->flagsEx & INST_VEX_V_UNUSED) && ps->vexV) return NULL;
		}
		return ii;
	}

	/* Read first byte. */
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex0 = *ci->code;

	/* Check for special 0x9b, WAIT instruction, which can be part of some instructions(x87). */
	if (tmpIndex0 == INST_WAIT_INDEX) {
		/* Only OCST_1dBYTES get a chance to include this byte as part of the opcode. */
		isWaitIncluded = TRUE;

		/* Ignore all prefixes, since they are useless and operate on the WAIT instruction itself. */
		prefixes_ignore_all(ps);

		/* Move to next code byte as a new whole instruction. */
		ci->code += 1;
		ci->codeLen -= 1;
		if (ci->codeLen < 0) return NULL; /* Faster to return NULL, it will be detected as WAIT later anyway. */
		/* Since we got a WAIT prefix, we re-read the first byte. */
		tmpIndex0 = *ci->code;
	}

	/* Walk first byte in InstructionsTree root. */
	in = InstructionsTree[tmpIndex0];
	if (in == INT_NOTEXISTS) return NULL;
	instType = INST_NODE_TYPE(in);

	/* Single byte instruction (OCST_1BYTE). */
	if ((instType < INT_INFOS) && (!isWaitIncluded)) {
		/* Some single byte instructions need extra treatment. */
		switch (tmpIndex0)
		{
			case INST_ARPL_INDEX:
				/*
				 * ARPL/MOVSXD share the same opcode, and both have different operands and mnemonics, of course.
				 * Practically, I couldn't come up with a comfortable way to merge the operands' types of ARPL/MOVSXD.
				 * And since the DB can't be patched dynamically, because the DB has to be multi-threaded compliant,
				 * I have no choice but to check for ARPL/MOVSXD right here - "right about now, the funk soul brother, check it out now, the funk soul brother...", fatboy slim
				 */
				if (ci->dt == Decode64Bits) {
					return &II_MOVSXD;
				} /* else ARPL will be returned because its defined in the DB already. */
			break;

			case INST_NOP_INDEX: /* Nopnopnop */
				/* Check for Pause, since it's prefixed with 0xf3, which is not a real mandatory prefix. */
				if (ps->decodedPrefixes & INST_PRE_REP) {
					/* Flag this prefix as used. */
					ps->usedPrefixes |= INST_PRE_REP;
					return &II_PAUSE;
				}

				/*
				 * Treat NOP/XCHG specially.
				 * If we're not in 64bits restore XCHG to NOP, since in the DB it's XCHG.
				 * Else if we're in 64bits examine REX, if exists, and decide which instruction should go to output.
				 * 48 90 XCHG RAX, RAX is a true NOP (eat REX in this case because it's valid).
				 * 90 XCHG EAX, EAX is a true NOP (and not high dword of RAX = 0 although it should be a 32 bits operation).
				 * Note that if the REX.B is used, then the register is not RAX anymore but R8, which means it's not a NOP.
				 */
				if (rex & PREFIX_EX_W) ps->usedPrefixes |= INST_PRE_REX;
				if ((ci->dt != Decode64Bits) || (~rex & PREFIX_EX_B)) return &II_NOP;
			break;
			
			case INST_LEA_INDEX:
				/* Ignore segment override prefixes for LEA instruction. */
				ps->decodedPrefixes &= ~INST_PRE_SEGOVRD_MASK;
				/* Update unused mask for ignoring segment prefix. */
				prefixes_ignore(ps, PFXIDX_SEG);
			break;
		}

		/* Return the 1 byte instruction we found. */
		return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];
	}

	/* Read second byte, still doesn't mean all of its bits are used (I.E: ModRM). */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex1 = *ci->code;
	
	/* Try single byte instruction + reg bits (OCST_13BYTES). */
	if ((instType == INT_LIST_GROUP) && (!isWaitIncluded)) return inst_get_info(in, (tmpIndex1 >> 3) & 7);

	/* Try single byte instruction + reg byte OR one whole byte (OCST_1dBYTES). */
	if (instType == INT_LIST_DIVIDED) {

		/* Checking for inst by REG bits is higher priority if it's found not to be divided instruction. */
		{
			_InstNode in2 = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex1 >> 3) & 7)];
			/*
			 * Do NOT check for NULL here, since we do a bit of a guess work,
			 * hence we don't override 'in', cause we might still need it.
			 */
			instType = INST_NODE_TYPE(in2);

			if (instType == INT_INFO) ii = &InstInfos[INST_NODE_INDEX(in2)];
			else if (instType == INT_INFOEX) ii = (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in2)];
			if ((ii != NULL) && (INST_INFO_FLAGS(ii) & INST_NOT_DIVIDED)) return ii;
			/* ii is reset below. */
		}

		/* Continue normally because of wait prefix. */
		if (tmpIndex1 < INST_DIVIDED_MODRM) {
			/* An instruction which requires a ModR/M byte. Thus it's 1.3 bytes long instruction. */
			tmpIndex1 = (tmpIndex1 >> 3) & 7; /* Isolate the 3 REG/OPCODE bits. */
		} else { /* Normal 2 bytes instruction. */
			/*
			 * Divided instructions can't be in the range of 0x8-0xc0.
			 * That's because 0-8 are used for 3 bits group.
			 * And 0xc0-0xff are used for not-divided instruction.
			 * So the in between range is omitted, thus saving some more place in the tables.
			 */
			tmpIndex1 -= INST_DIVIDED_MODRM - 8;
		}

		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex1];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS) {
			/* If the instruction doesn't support the wait (marked as opsize) as part of the opcode, it's illegal. */
			ii = instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];
			if ((~INST_INFO_FLAGS(ii) & INST_PRE_OP_SIZE) && (isWaitIncluded)) return NULL;
			return ii;
		}
		/*
		 * If we got here the instruction can support the wait prefix, so see if it was part of the stream.
		 * Examine prefixed table, specially used for 0x9b, since it's optional.
		 * No Wait: index = 0.
		 * Wait Exists, index = 1.
		 */
		return inst_get_info(in, isWaitIncluded);
	}

	/* Don't allow to continue if WAIT is part of the opcode, because there are no instructions that include it. */
	if (isWaitIncluded) return NULL;

	/* Try 2 bytes long instruction (doesn't include ModRM byte). */
	if (instType == INT_LIST_FULL) {
		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex1];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		/* This is where we check if we just read two escape bytes in a row, which means it is a 3DNow! instruction. */
		if ((tmpIndex0 == _3DNOW_ESCAPE_BYTE) && (tmpIndex1 == _3DNOW_ESCAPE_BYTE)) return &II_3DNOW;

		/* 2 bytes instruction (OCST_2BYTES). */
		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		/*
		 * 2 bytes + mandatory prefix.
		 * Mandatory prefixes can be anywhere in the prefixes.
		 * There cannot be more than one mandatory prefix, unless it's a normal operand size prefix.
		 */
		if (instType == INT_LIST_PREFIXED) return inst_lookup_prefixed(in, ps);
	}

	/* Read third byte, still doesn't mean all of its bits are used (I.E: ModRM). */
	ci->code += 1;
	ci->codeLen -= 1;
	if (ci->codeLen < 0) return NULL;
	tmpIndex2 = *ci->code;

	/* Try 2 bytes + reg instruction (OCST_23BYTES). */
	if (instType == INT_LIST_GROUP) {
		in = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex2 >> 3) & 7)];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		/* It has to be a prefixed table then. */
		ii = inst_lookup_prefixed(in, ps);
		/* RDRAND and VMPTRLD share same 2.3 bytes opcode, and alternate on the MOD bits. See insts.h for more info. */
		if ((ii != NULL) && (ii->opcodeId == I_VMPTRLD) && (tmpIndex1 >= INST_DIVIDED_MODRM)) return &II_RDRAND;
		return ii;
	}

	/* Try 2 bytes + divided range (OCST_2dBYTES). */
	if (instType == INT_LIST_DIVIDED) {
		_InstNode in2 = InstructionsTree[INST_NODE_INDEX(in) + ((tmpIndex2 >> 3) & 7)];
		/*
		 * Do NOT check for NULL here, since we do a bit of a guess work,
		 * hence we don't override 'in', cause we might still need it.
		 */
		instType = INST_NODE_TYPE(in2);
		
		if (instType == INT_INFO) ii = &InstInfos[INST_NODE_INDEX(in2)];
		else if (instType == INT_INFOEX) ii = (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in2)];

		/*
		 * OCST_2dBYTES is complex, because there are a few instructions which are not divided in some special cases.
		 * If the instruction wasn't divided (but still it must be a 2.3 because we are in divided category)
		 * or it was an official 2.3 (because its index was less than 0xc0) -
		 * Then it means the instruction should be using the REG bits, otherwise give a chance to range 0xc0-0xff.
		 */
		/* If we found an instruction only by its REG bits, AND it is not divided, then return it. */
		if ((ii != NULL) && (INST_INFO_FLAGS(ii) & INST_NOT_DIVIDED)) return ii;
		/* Otherwise, if the range is above 0xc0, try the special divided range (range 0x8-0xc0 is omitted). */
		if (tmpIndex2 >= INST_DIVIDED_MODRM) return inst_get_info(in, tmpIndex2 - INST_DIVIDED_MODRM + 8);

		/* It might be that we got here without touching ii in the above if statements, then it becomes an invalid instruction prolly. */
		return ii;
	}

	/* Try 3 full bytes (OCST_3BYTES - no ModRM byte). */
	if (instType == INT_LIST_FULL) {
		/* OCST_3BYTES. */
		in = InstructionsTree[INST_NODE_INDEX(in) + tmpIndex2];
		if (in == INT_NOTEXISTS) return NULL;
		instType = INST_NODE_TYPE(in);

		if (instType < INT_INFOS)
			return instType == INT_INFO ? &InstInfos[INST_NODE_INDEX(in)] : (_InstInfo*)&InstInfosEx[INST_NODE_INDEX(in)];

		if (instType == INT_LIST_PREFIXED) return inst_lookup_prefixed(in, ps);
	}

	/* Kahtchinggg, damn. */
	return NULL;
}

/*
* 3DNow! instruction handling:

* This is used when we encounter a 3DNow! instruction.
* We can't really locate a 3DNow! instruction before we see two escaped bytes,
* 0x0f, 0x0f. Then we have to extract operands which are, dest=mmx register, src=mmx register or quadword indirection.
* When we are finished with the extraction of operands we can resume to locate the instruction by reading another byte
* which tells us which 3DNow instruction we really tracked down...
* So in order to tell the extract operands function which operands the 3DNow! instruction require, we need to set up some
* generic instruction info for 3DNow! instructions.

* In the inst_lookup itself, when we read an OCST_3BYTES which the two first bytes are 0x0f and 0x0f.
* we will return this special generic II for the specific operands we are interested in (MM, MM64).
* Then after extracting the operand, we'll call a completion routine for locating the instruction
* which will be called only for 3DNow! instructions, distinguished by a flag, and it will read the last byte of the 3 bytes.
*
* The id of this opcode should not be used, the following function should change it anyway.
*/
_InstInfo* inst_lookup_3dnow(_CodeInfo* ci)
{
	/* Start off from the two escape bytes gates... which is 3DNow! table.*/
	_InstNode in = Table_0F_0F;

	int index;

	/* Make sure we can read a byte off the stream. */
	if (ci->codeLen < 1) return NULL;

	index = *ci->code;

	ci->codeLen -= 1;
	ci->code += 1;
	return inst_get_info(in, index);
}



================================================
File: 3rdparty/distorm/instructions.h
================================================
/*
instructions.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef INSTRUCTIONS_H
#define INSTRUCTIONS_H

#include "config.h"
#include "prefix.h"


/*
 * Operand type possibilities:
 * Note "_FULL" suffix indicates to decode the operand as 16 bits or 32 bits depends on DecodeType -
 * actually, it depends on the decoding mode, unless there's an operand/address size prefix.
 * For example, the code: 33 c0 could be decoded/executed as XOR AX, AX or XOR EAX, EAX.
 */
typedef enum OpType {
	/* No operand is set */
	OT_NONE = 0,

	/* Read a byte(8 bits) immediate */
	OT_IMM8,
	/* Force a read of a word(16 bits) immediate, used by ret only */
	OT_IMM16,
	/* Read a word/dword immediate */
	OT_IMM_FULL,
	/* Read a double-word(32 bits) immediate */
	OT_IMM32,

	/* Read a signed extended byte(8 bits) immediate */
	OT_SEIMM8,

	/*
	 * Special immediates for instructions which have more than one immediate,
	 * which is an exception from standard instruction format.
	 * As to version v1.0: ENTER, INSERTQ, EXTRQ are the only problematic ones.
	 */
	/* 16 bits immediate using the first imm-slot */
	OT_IMM16_1,
	/* 8 bits immediate using the first imm-slot */
	OT_IMM8_1,
	/* 8 bits immediate using the second imm-slot */
	OT_IMM8_2,

	/* Use a 8bit register */
	OT_REG8,
	/* Use a 16bit register */
	OT_REG16,
	/* Use a 16/32/64bit register */
	OT_REG_FULL,
	/* Use a 32bit register */
	OT_REG32,
	/*
	 * If used with REX the reg operand size becomes 64 bits, otherwise 32 bits.
	 * VMX instructions are promoted automatically without a REX prefix.
	 */
	OT_REG32_64,
	/* Used only by MOV CR/DR(n). Promoted with REX onlly. */
	OT_FREG32_64_RM,

	/* Use or read (indirection) a 8bit register or immediate byte */
	OT_RM8,
	/* Some instructions force 16 bits (mov sreg, rm16) */
	OT_RM16,
	/* Use or read a 16/32/64bit register or immediate word/dword/qword */
	OT_RM_FULL,
	/*
	 * 32 or 64 bits (with REX) operand size indirection memory operand.
	 * Some instructions are promoted automatically without a REX prefix.
	 */
	OT_RM32_64,
	/* 16 or 32 bits RM. This is used only with MOVZXD instruction in 64bits. */
	OT_RM16_32,
	/* Same as OT_RMXX but POINTS to 16 bits [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM16,
	/* Same as OT_RMXX but POINTS to 32 bits (single precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM32,
	/* Same as OT_RMXX but POINTS to 64 bits (double precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM64,
	/* Same as OT_RMXX but POINTS to 80 bits (extended precision) [cannot use GENERAL-PURPOSE REG!] */
	OT_FPUM80,

	/*
	 * Special operand type for SSE4 where the ModR/M might
	 * be a 32 bits register or 8 bits memory indirection operand.
	 */
	OT_R32_M8,
	/*
	 * Special ModR/M for PINSRW, which need a 16 bits memory operand or 32 bits register.
	 * In 16 bits decoding mode R32 becomes R16, operand size cannot affect this.
	 */
	OT_R32_M16,
	/*
	 * Special type for SSE4, ModR/M might be a 32 bits or 64 bits (with REX) register or
	 * a 8 bits memory indirection operand.
	 */
	OT_R32_64_M8,
	/*
	 * Special type for SSE4, ModR/M might be a 32 bits or 64 bits (with REX) register or
	 * a 16 bits memory indirection operand.
	 */
	OT_R32_64_M16,
	/*
	 * Special operand type for MOV reg16/32/64/mem16, segReg 8C /r. and SMSW.
	 * It supports all decoding modes, but if used as a memory indirection it's a 16 bit ModR/M indirection.
	 */
	OT_RFULL_M16,

	/* Use a control register */
	OT_CREG,
	/* Use a debug register */
	OT_DREG,
	/* Use a segment register */
	OT_SREG,
	/*
	 * SEG is encoded in the flags of the opcode itself!
	 * This is used for specific "push SS" where SS is a segment where
	 * each "push SS" has an absolutely different opcode byte.
	 * We need this to detect whether an operand size prefix is used.
	 */
	OT_SEG,
	
	/* Use AL */
	OT_ACC8,
	/* Use AX (FSTSW) */
	OT_ACC16,
	/* Use AX/EAX/RAX */
	OT_ACC_FULL,
	/* Use AX/EAX, no REX is possible for RAX, used only with IN/OUT which don't support 64 bit registers */
	OT_ACC_FULL_NOT64,

	/*
	 * Read one word (seg), and a word/dword/qword (depends on operand size) from memory.
	 * JMP FAR [EBX] means EBX point to 16:32 ptr.
	 */
	OT_MEM16_FULL,
	/* Read one word (seg) and a word/dword/qword (depends on operand size), usually SEG:OFF, JMP 1234:1234 */
	OT_PTR16_FULL,
	/* Read one word (limit) and a dword/qword (limit) (depends on operand size), used by SGDT, SIDT, LGDT, LIDT. */
	OT_MEM16_3264,

	/* Read a byte(8 bits) immediate and calculate it relatively to the current offset of the instruction being decoded */
	OT_RELCB,
	/* Read a word/dword immediate and calculate it relatively to the current offset of the instruction being decoded */
	OT_RELC_FULL,

	/* Use general memory indirection, with varying sizes: */
	OT_MEM,
	/* Used when a memory indirection is required, but if the mod field is 11, this operand will be ignored. */
	OT_MEM_OPT,
	OT_MEM32,
	/* Memory dereference for MOVNTI, either 32 or 64 bits (with REX). */
	OT_MEM32_64,
	OT_MEM64,
	OT_MEM128,
	/* Used for cmpxchg8b/16b. */
	OT_MEM64_128,

	/* Read an immediate as an absolute address, size is known by instruction, used by MOV (memory offset) only */
	OT_MOFFS8,
	OT_MOFFS_FULL,
	/* Use an immediate of 1, as for SHR R/M, 1 */
	OT_CONST1,
	/* Use CL, as for SHR R/M, CL */
	OT_REGCL,

	/*
	 * Instruction-Block for one byte long instructions, used by INC/DEC/PUSH/POP/XCHG,
	 * REG is extracted from the value of opcode
	 * Use a 8bit register
	 */
	OT_IB_RB,
	/* Use a 16/32/64bit register */
	OT_IB_R_FULL,

	/* Use [(r)SI] as INDIRECTION, for repeatable instructions */
	OT_REGI_ESI,
	/* Use [(r)DI] as INDIRECTION, for repeatable instructions */
	OT_REGI_EDI,
	/* Use [(r)BX + AL] as INDIRECTIOM, used by XLAT only */
	OT_REGI_EBXAL,
	/* Use [(r)AX] as INDIRECTION, used by AMD's SVM instructions */
	OT_REGI_EAX,
	/* Use DX, as for OUTS DX, BYTE [SI] */
	OT_REGDX,
	/* Use ECX in INVLPGA instruction */
	OT_REGECX,

	/* FPU registers: */
	OT_FPU_SI, /* ST(i) */
	OT_FPU_SSI, /* ST(0), ST(i) */
	OT_FPU_SIS, /* ST(i), ST(0) */

	/* MMX registers: */
	OT_MM,
	/* Extract the MMX register from the RM bits this time (used when the REG bits are used for opcode extension) */
	OT_MM_RM,
	/* ModR/M points to 32 bits MMX variable */
	OT_MM32,
	/* ModR/M points to 32 bits MMX variable */
	OT_MM64,

	/* SSE registers: */
	OT_XMM,
	/* Extract the SSE register from the RM bits this time (used when the REG bits are used for opcode extension) */
	OT_XMM_RM,
	/* ModR/M points to 16 bits SSE variable */
	OT_XMM16,
	/* ModR/M points to 32 bits SSE variable */
	OT_XMM32,
	/* ModR/M points to 64 bits SSE variable */
	OT_XMM64,
	/* ModR/M points to 128 bits SSE variable */
	OT_XMM128,
	/* Implied XMM0 register as operand, used in SSE4. */
	OT_REGXMM0,

	/* AVX operands: */

	/* ModR/M for 32 bits. */
	OT_RM32,
	/* Reg32/Reg64 (prefix width) or Mem8. */
	OT_REG32_64_M8,
	/* Reg32/Reg64 (prefix width) or Mem16. */
	OT_REG32_64_M16,
	/* Reg32/Reg 64 depends on prefix width only. */
	OT_WREG32_64,
	/* RM32/RM64 depends on prefix width only. */
	OT_WRM32_64,
	/* XMM or Mem32/Mem64 depends on perfix width only. */
	OT_WXMM32_64,
	/* XMM is encoded in VEX.VVVV. */
	OT_VXMM,
	/* XMM is encoded in the high nibble of an immediate byte. */
	OT_XMM_IMM,
	/* YMM/XMM is dependent on VEX.L. */
	OT_YXMM,
	/* YMM/XMM (depends on prefix length) is encoded in the high nibble of an immediate byte. */
	OT_YXMM_IMM,
	/* YMM is encoded in reg. */
	OT_YMM,
	/* YMM or Mem256. */
	OT_YMM256,
	/* YMM is encoded in VEX.VVVV. */
	OT_VYMM,
	/* YMM/XMM is dependent on VEX.L, and encoded in VEX.VVVV. */
	OT_VYXMM,
	/* YMM/XMM or Mem64/Mem256 is dependent on VEX.L. */
	OT_YXMM64_256,
	/* YMM/XMM or Mem128/Mem256 is dependent on VEX.L. */
	OT_YXMM128_256,
	/* XMM or Mem64/Mem256 is dependent on VEX.L. */
	OT_LXMM64_128,
	/* Mem128/Mem256 is dependent on VEX.L. */
	OT_LMEM128_256
} _OpType;

/* Flags for instruction: */

/* Empty flags indicator: */
#define INST_FLAGS_NONE (0)
/* The instruction we are going to decode requires ModR/M encoding. */
#define INST_MODRM_REQUIRED (1)
/* Special treatment for instructions which are in the divided-category but still needs the whole byte for ModR/M... */
#define INST_NOT_DIVIDED (1 << 1)
/*
 * Used explicitly in repeatable instructions,
 * which needs a suffix letter in their mnemonic to specify operation-size (depend on operands).
 */
#define INST_16BITS (1 << 2)
/* If the opcode is supported by 80286 and upper models (16/32 bits). */
#define INST_32BITS (1 << 3)
/*
 * Prefix flags (6 types: lock/rep, seg override, addr-size, oper-size, REX, VEX)
 * There are several specific instructions that can follow LOCK prefix,
 * note that they must be using a memory operand form, otherwise they generate an exception.
 */
#define INST_PRE_LOCK (1 << 4)
/* REPNZ prefix for string instructions only - means an instruction can follow it. */
#define INST_PRE_REPNZ (1 << 5)
/* REP prefix for string instructions only - means an instruction can follow it. */
#define INST_PRE_REP (1 << 6)
/* CS override prefix. */
#define INST_PRE_CS (1 << 7)
/* SS override prefix. */
#define INST_PRE_SS (1 << 8)
/* DS override prefix. */
#define INST_PRE_DS (1 << 9)
/* ES override prefix. */
#define INST_PRE_ES (1 << 10)
/* FS override prefix. Funky Segment :) */
#define INST_PRE_FS (1 << 11)
/* GS override prefix. Groovy Segment, of course not, duh ! */
#define INST_PRE_GS (1 << 12)
/* Switch operand size from 32 to 16 and vice versa. */
#define INST_PRE_OP_SIZE (1 << 13)
/* Switch address size from 32 to 16 and vice versa. */
#define INST_PRE_ADDR_SIZE (1 << 14)
/* Native instructions which needs suffix letter to indicate their operation-size (and don't depend on operands). */
#define INST_NATIVE (1 << 15)
/* Use extended mnemonic, means it's an _InstInfoEx structure, which contains another mnemonic for 32 bits specifically. */
#define INST_USE_EXMNEMONIC (1 << 16)
/* Use third operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define INST_USE_OP3 (1 << 17)
/* Use fourth operand, means it's an _InstInfoEx structure, which contains another operand for special instructions. */
#define INST_USE_OP4 (1 << 18)
/* The instruction's mnemonic depends on the mod value of the ModR/M byte (mod=11, mod!=11). */
#define INST_MNEMONIC_MODRM_BASED (1 << 19)
/* The instruction uses a ModR/M byte which the MOD must be 11 (for registers operands only). */
#define INST_MODRR_REQUIRED (1 << 20)
/* The way of 3DNow! instructions are built, we have to handle their locating specially. Suffix imm8 tells which instruction it is. */
#define INST_3DNOW_FETCH (1 << 21)
/* The instruction needs two suffixes, one for the comparison type (imm8) and the second for its operation size indication (second mnemonic). */
#define INST_PSEUDO_OPCODE (1 << 22)
/* Invalid instruction at 64 bits decoding mode. */
#define INST_INVALID_64BITS (1 << 23)
/* Specific instruction can be promoted to 64 bits (without REX, it is promoted automatically). */
#define INST_64BITS (1 << 24)
/* Indicates the instruction must be REX prefixed in order to use 64 bits operands. */
#define INST_PRE_REX (1 << 25)
/* Third mnemonic is set. */
#define INST_USE_EXMNEMONIC2 (1 << 26)
/* Instruction is only valid in 64 bits decoding mode. */
#define INST_64BITS_FETCH (1 << 27)
/* Forces that the ModRM-REG/Opcode field will be 0. (For EXTRQ). */
#define INST_FORCE_REG0 (1 << 28)
/* Indicates that instruction is encoded with a VEX prefix. */
#define INST_PRE_VEX (1 << 29)
/* Indicates that the instruction is encoded with a ModRM byte (REG field specifically). */
#define INST_MODRM_INCLUDED (1 << 30)
/* Indicates that the first (/destination) operand of the instruction is writable. */
#define INST_DST_WR (1 << 31)

#define INST_PRE_REPS (INST_PRE_REPNZ | INST_PRE_REP)
#define INST_PRE_LOKREP_MASK (INST_PRE_LOCK | INST_PRE_REPNZ | INST_PRE_REP)
#define INST_PRE_SEGOVRD_MASK32 (INST_PRE_CS | INST_PRE_SS | INST_PRE_DS | INST_PRE_ES)
#define INST_PRE_SEGOVRD_MASK64 (INST_PRE_FS | INST_PRE_GS)
#define INST_PRE_SEGOVRD_MASK (INST_PRE_SEGOVRD_MASK32 | INST_PRE_SEGOVRD_MASK64)

/* Extended flags for VEX: */
/* Indicates that the instruction might have VEX.L encoded. */
#define INST_VEX_L (1)
/* Indicates that the instruction might have VEX.W encoded. */
#define INST_VEX_W (1 << 1)
/* Indicates that the mnemonic of the instruction is based on the VEX.W bit. */
#define INST_MNEMONIC_VEXW_BASED (1 << 2)
/* Indicates that the mnemonic of the instruction is based on the VEX.L bit. */
#define INST_MNEMONIC_VEXL_BASED (1 << 3)
/* Forces the instruction to be encoded with VEX.L, otherwise it's undefined. */
#define INST_FORCE_VEXL (1 << 4)
/*
 * Indicates that the instruction is based on the MOD field of the ModRM byte.
 * (MOD==11: got the right instruction, else skip +4 in prefixed table for the correct instruction).
 */
#define INST_MODRR_BASED (1 << 5)
/* Indicates that the instruction doesn't use the VVVV field of the VEX prefix, if it does then it's undecodable. */
#define INST_VEX_V_UNUSED (1 << 6)

/* Indication that the instruction is privileged (Ring 0), this should be checked on the opcodeId field. */
#define OPCODE_ID_PRIVILEGED ((uint16_t)0x8000)

/*
 * Indicates which operand is being decoded.
 * Destination (1st), Source (2nd), op3 (3rd), op4 (4th).
 * Used to set the operands' fields in the _DInst structure!
 */
typedef enum {ONT_NONE = -1, ONT_1 = 0, ONT_2 = 1, ONT_3 = 2, ONT_4 = 3} _OperandNumberType;

/* CPU Flags that instructions modify, test or undefine, in compacted form (CF,PF,AF,ZF,SF are 1:1 map to EFLAGS). */
#define D_COMPACT_CF 1		/* Carry */
#define D_COMPACT_PF 4		/* Parity */
#define D_COMPACT_AF 0x10	/* Auxiliary */
#define D_COMPACT_ZF 0x40	/* Zero */
#define D_COMPACT_SF 0x80	/* Sign */
/* The following flags have to be translated to EFLAGS. */
#define D_COMPACT_IF 2		/* Interrupt */
#define D_COMPACT_DF 8		/* Direction */
#define D_COMPACT_OF 0x20	/* Overflow */

/* The mask of flags that are already compatible with EFLAGS. */
#define D_COMPACT_SAME_FLAGS (D_COMPACT_CF | D_COMPACT_PF | D_COMPACT_AF | D_COMPACT_ZF | D_COMPACT_SF)

/*
 * In order to save more space for storing the DB statically,
 * I came up with another level of shared info.
 * Because I saw that most of the information that instructions use repeats itself.
 *
 * Info about the instruction, source/dest types, meta and flags.
 * _InstInfo points to a table of _InstSharedInfo.
 */
typedef struct {
	uint8_t flagsIndex; /* An index into FlagsTables */
	uint8_t s, d; /* OpType. */
	uint8_t meta; /* Hi 5 bits = Instruction set class | Lo 3 bits = flow control flags. */
	/*
	 * The following are CPU flag masks that the instruction changes.
	 * The flags are compacted so 8 bits representation is enough.
	 * They will be expanded in runtime to be compatible to EFLAGS.
	 */
	uint8_t modifiedFlagsMask;
	uint8_t testedFlagsMask;
	uint8_t undefinedFlagsMask;
} _InstSharedInfo;

/*
 * This structure is used for the instructions DB and NOT for the disassembled result code!
 * This is the BASE structure, there are extensions to this structure below.
 */
typedef struct {
	uint16_t sharedIndex; /* An index into the SharedInfoTable. */
	uint16_t opcodeId; /* The opcodeId is really a byte-offset into the mnemonics table. MSB is a privileged indication. */
} _InstInfo;

/*
 * There are merely few instructions which need a second mnemonic for 32 bits.
 * Or a third for 64 bits. Therefore sometimes the second mnemonic is empty but not the third.
 * In all decoding modes the first mnemonic is the default.
 * A flag will indicate it uses another mnemonic.
 *
 * There are a couple of (SSE4) instructions in the whole DB which need both op3 and 3rd mnemonic for 64bits,
 * therefore, I decided to make the extended structure contain all extra info in the same structure.
 * There are a few instructions (SHLD/SHRD/IMUL and SSE too) which use third operand (or a fourth).
 * A flag will indicate it uses a third/fourth operand.
 */
typedef struct {
	/* Base structure (doesn't get accessed directly from code). */
	_InstInfo BASE;

	/* Extended starts here. */
	uint8_t flagsEx; /* 8 bits are enough, in the future we might make it a bigger integer. */
	uint8_t op3, op4; /* OpType. */
	uint16_t opcodeId2, opcodeId3;
} _InstInfoEx;

/* Trie data structure node type: */
typedef enum {
	INT_NOTEXISTS = 0, /* Not exists. */
	INT_INFO = 1, /* It's an instruction info. */
	INT_INFOEX,
	INT_LIST_GROUP,
	INT_LIST_FULL,
	INT_LIST_DIVIDED,
	INT_LIST_PREFIXED
} _InstNodeType;

/* Used to check instType < INT_INFOS, means we got an inst-info. Cause it has to be only one of them. */
#define INT_INFOS (INT_LIST_GROUP)

/* Instruction node is treated as { int index:13;  int type:3; } */
typedef uint16_t _InstNode;

_InstInfo* inst_lookup(_CodeInfo* ci, _PrefixState* ps);
_InstInfo* inst_lookup_3dnow(_CodeInfo* ci);

#endif /* INSTRUCTIONS_H */



================================================
File: 3rdparty/distorm/insts.c
================================================
/*
insts.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "config.h"
#include "insts.h"
#include "instructions.h"


/*
* GENERATED BY disOps at Sun Jul 09 21:22:14 2017
*/

_InstInfo II_MOVSXD =	/*II*/{ 0x1d3, 10027 };
_InstInfo II_NOP =	/*II*/{ 0x53, 581 };
_InstInfo II_PAUSE =	/*II*/{ 0x88, 10035 };
_InstInfo II_WAIT =	/*II*/{ 0x53, 10042 };
_InstInfo II_RDRAND =	/*II*/{ 0x1d4, 10048 };
_InstInfo II_3DNOW =	/*II*/{ 0x1d5, 10056 };

_iflags FlagsTable[101] = {
	0x80000011,
	0x80000000,
	0x800400,
	0x80800400,
	0x800080,
	0x800100,
	0x80800100,
	0x800200,
	0x80800200,
	0x800000,
	0x1,
	0x0,
	0x80800000,
	0x1000000,
	0x81000000,
	0x808000,
	0x800001,
	0x80020001,
	0x1002000,
	0x60,
	0x64,
	0x80000001,
	0x4010000,
	0x1008000,
	0x80000060,
	0x83000064,
	0x3000064,
	0x83000000,
	0x3008000,
	0x200,
	0xc000,
	0x4014000,
	0x8,
	0x81000009,
	0x9,
	0x80000009,
	0x1000808,
	0x81000808,
	0x80020009,
	0x1001008,
	0x81001008,
	0x80000019,
	0x3000009,
	0x83000009,
	0x83000008,
	0xc0000011,
	0x40000001,
	0xc0800011,
	0x40800001,
	0xc0000019,
	0xc1000001,
	0xc0000001,
	0xc0000003,
	0x41000000,
	0x40000000,
	0x40000008,
	0x40000009,
	0x41000001,
	0x43000001,
	0x40000003,
	0x48000000,
	0x200009,
	0x20000009,
	0x60020009,
	0x60000009,
	0x80090009,
	0x200b0009,
	0x20020009,
	0x80100009,
	0x21100009,
	0x87000009,
	0x20009,
	0x20000008,
	0x1000009,
	0x10020009,
	0x160009,
	0x100009,
	0x47000009,
	0x47090009,
	0x40090009,
	0x80002009,
	0xc0000009,
	0x2001,
	0x80002001,
	0x410009,
	0x20420009,
	0x20060009,
	0x120009,
	0x21020009,
	0xc7000019,
	0x20100009,
	0xc0002009,
	0x40002008,
	0xc0000000,
	0xc0002008,
	0x4020009,
	0x40100009,
	0x60120009,
	0x41000009,
	0x83000001,
	0x200001
};

_InstNode Table_0F = 256;
_InstNode Table_0F_0F = 1440;
_InstNode Table_0F_38 = 1896;
_InstNode Table_0F_3A = 2152;

_InstInfo InstInfos[1246] = {
	/*II_00*/{ 0x0, 11 },
	/*II_01*/{ 0x1, 11 },
	/*II_02*/{ 0x2, 11 },
	/*II_03*/{ 0x3, 11 },
	/*II_04*/{ 0x4, 11 },
	/*II_05*/{ 0x5, 11 },
	/*II_06*/{ 0x6, 16 },
	/*II_07*/{ 0x7, 22 },
	/*II_08*/{ 0x8, 27 },
	/*II_09*/{ 0x9, 27 },
	/*II_0A*/{ 0xa, 27 },
	/*II_0B*/{ 0xb, 27 },
	/*II_0C*/{ 0xc, 27 },
	/*II_0D*/{ 0xd, 27 },
	/*II_0E*/{ 0xe, 16 },
	/*II_10*/{ 0xf, 31 },
	/*II_11*/{ 0x10, 31 },
	/*II_12*/{ 0x11, 31 },
	/*II_13*/{ 0x12, 31 },
	/*II_14*/{ 0x13, 31 },
	/*II_15*/{ 0x14, 31 },
	/*II_16*/{ 0x15, 16 },
	/*II_17*/{ 0x16, 22 },
	/*II_18*/{ 0xf, 36 },
	/*II_19*/{ 0x10, 36 },
	/*II_1A*/{ 0x11, 36 },
	/*II_1B*/{ 0x12, 36 },
	/*II_1C*/{ 0x13, 36 },
	/*II_1D*/{ 0x14, 36 },
	/*II_1E*/{ 0x17, 16 },
	/*II_1F*/{ 0x18, 22 },
	/*II_20*/{ 0x19, 41 },
	/*II_21*/{ 0x1a, 41 },
	/*II_22*/{ 0x1b, 41 },
	/*II_23*/{ 0x1c, 41 },
	/*II_24*/{ 0x1d, 41 },
	/*II_25*/{ 0x1e, 41 },
	/*II_27*/{ 0x1f, 46 },
	/*II_28*/{ 0x0, 51 },
	/*II_29*/{ 0x1, 51 },
	/*II_2A*/{ 0x2, 51 },
	/*II_2B*/{ 0x3, 51 },
	/*II_2C*/{ 0x4, 51 },
	/*II_2D*/{ 0x5, 51 },
	/*II_2F*/{ 0x1f, 56 },
	/*II_30*/{ 0x20, 61 },
	/*II_31*/{ 0x21, 61 },
	/*II_32*/{ 0x22, 61 },
	/*II_33*/{ 0x23, 61 },
	/*II_34*/{ 0x24, 61 },
	/*II_35*/{ 0x25, 61 },
	/*II_37*/{ 0x26, 66 },
	/*II_38*/{ 0x27, 71 },
	/*II_39*/{ 0x28, 71 },
	/*II_3A*/{ 0x29, 71 },
	/*II_3B*/{ 0x2a, 71 },
	/*II_3C*/{ 0x2b, 71 },
	/*II_3D*/{ 0x2c, 71 },
	/*II_3F*/{ 0x26, 76 },
	/*II_40*/{ 0x2d, 81 },
	/*II_40*/{ 0x2d, 81 },
	/*II_40*/{ 0x2d, 81 },
	/*II_40*/{ 0x2d, 81 },
	/*II_40*/{ 0x2d, 81 },
	/*II_40*/{ 0x2d, 81 },
	/*II_40*/{ 0x2d, 81 },
	/*II_40*/{ 0x2d, 81 },
	/*II_48*/{ 0x2d, 86 },
	/*II_48*/{ 0x2d, 86 },
	/*II_48*/{ 0x2d, 86 },
	/*II_48*/{ 0x2d, 86 },
	/*II_48*/{ 0x2d, 86 },
	/*II_48*/{ 0x2d, 86 },
	/*II_48*/{ 0x2d, 86 },
	/*II_48*/{ 0x2d, 86 },
	/*II_50*/{ 0x2e, 16 },
	/*II_50*/{ 0x2e, 16 },
	/*II_50*/{ 0x2e, 16 },
	/*II_50*/{ 0x2e, 16 },
	/*II_50*/{ 0x2e, 16 },
	/*II_50*/{ 0x2e, 16 },
	/*II_50*/{ 0x2e, 16 },
	/*II_50*/{ 0x2e, 16 },
	/*II_58*/{ 0x2f, 22 },
	/*II_58*/{ 0x2f, 22 },
	/*II_58*/{ 0x2f, 22 },
	/*II_58*/{ 0x2f, 22 },
	/*II_58*/{ 0x2f, 22 },
	/*II_58*/{ 0x2f, 22 },
	/*II_58*/{ 0x2f, 22 },
	/*II_58*/{ 0x2f, 22 },
	/*II_60*/{ 0x30, 91 },
	/*II_61*/{ 0x30, 98 },
	/*II_62*/{ 0x31, 104 },
	/*II_63*/{ 0x32, 111 },
	/*II_68*/{ 0x33, 16 },
	/*II_6A*/{ 0x35, 16 },
	/*II_6C*/{ 0x36, 32891 },
	/*II_6D*/{ 0x37, 32891 },
	/*II_6E*/{ 0x38, 32896 },
	/*II_6F*/{ 0x39, 32896 },
	/*II_70*/{ 0x3a, 134 },
	/*II_71*/{ 0x3a, 138 },
	/*II_72*/{ 0x3b, 143 },
	/*II_73*/{ 0x3b, 147 },
	/*II_74*/{ 0x3c, 152 },
	/*II_75*/{ 0x3c, 156 },
	/*II_76*/{ 0x3d, 161 },
	/*II_77*/{ 0x3d, 166 },
	/*II_78*/{ 0x3e, 170 },
	/*II_79*/{ 0x3e, 174 },
	/*II_7A*/{ 0x3f, 179 },
	/*II_7B*/{ 0x3f, 183 },
	/*II_7C*/{ 0x40, 188 },
	/*II_7D*/{ 0x40, 192 },
	/*II_7E*/{ 0x41, 197 },
	/*II_7F*/{ 0x41, 202 },
	/*II_84*/{ 0x42, 206 },
	/*II_85*/{ 0x43, 206 },
	/*II_86*/{ 0x44, 212 },
	/*II_87*/{ 0x45, 212 },
	/*II_88*/{ 0x46, 218 },
	/*II_89*/{ 0x47, 218 },
	/*II_8A*/{ 0x48, 218 },
	/*II_8B*/{ 0x49, 218 },
	/*II_8C*/{ 0x4a, 218 },
	/*II_8D*/{ 0x4b, 223 },
	/*II_8E*/{ 0x4c, 218 },
	/*II_90*/{ 0x4d, 212 },
	/*II_91*/{ 0x4d, 212 },
	/*II_92*/{ 0x4d, 212 },
	/*II_93*/{ 0x4d, 212 },
	/*II_94*/{ 0x4d, 212 },
	/*II_95*/{ 0x4d, 212 },
	/*II_96*/{ 0x4d, 212 },
	/*II_97*/{ 0x4d, 212 },
	/*II_9A*/{ 0x4f, 260 },
	/*II_9C*/{ 0x50, 270 },
	/*II_9D*/{ 0x51, 277 },
	/*II_9E*/{ 0x52, 283 },
	/*II_9F*/{ 0x53, 289 },
	/*II_A0*/{ 0x54, 218 },
	/*II_A1*/{ 0x55, 218 },
	/*II_A2*/{ 0x56, 218 },
	/*II_A3*/{ 0x57, 218 },
	/*II_A4*/{ 0x58, 295 },
	/*II_A5*/{ 0x59, 295 },
	/*II_A6*/{ 0x5a, 301 },
	/*II_A7*/{ 0x5b, 301 },
	/*II_A8*/{ 0x5c, 206 },
	/*II_A9*/{ 0x5d, 206 },
	/*II_AA*/{ 0x5e, 307 },
	/*II_AB*/{ 0x5f, 307 },
	/*II_AC*/{ 0x60, 313 },
	/*II_AD*/{ 0x61, 313 },
	/*II_AE*/{ 0x62, 319 },
	/*II_AF*/{ 0x63, 319 },
	/*II_B0*/{ 0x64, 218 },
	/*II_B0*/{ 0x64, 218 },
	/*II_B0*/{ 0x64, 218 },
	/*II_B0*/{ 0x64, 218 },
	/*II_B0*/{ 0x64, 218 },
	/*II_B0*/{ 0x64, 218 },
	/*II_B0*/{ 0x64, 218 },
	/*II_B0*/{ 0x64, 218 },
	/*II_B8*/{ 0x65, 218 },
	/*II_B8*/{ 0x65, 218 },
	/*II_B8*/{ 0x65, 218 },
	/*II_B8*/{ 0x65, 218 },
	/*II_B8*/{ 0x65, 218 },
	/*II_B8*/{ 0x65, 218 },
	/*II_B8*/{ 0x65, 218 },
	/*II_B8*/{ 0x65, 218 },
	/*II_C2*/{ 0x66, 325 },
	/*II_C3*/{ 0x67, 325 },
	/*II_C4*/{ 0x68, 330 },
	/*II_C5*/{ 0x68, 335 },
	/*II_C8*/{ 0x69, 340 },
	/*II_C9*/{ 0x6a, 347 },
	/*II_CA*/{ 0x6b, 354 },
	/*II_CB*/{ 0x6c, 354 },
	/*II_CC*/{ 0x6d, 360 },
	/*II_CD*/{ 0x6e, 367 },
	/*II_CE*/{ 0x6f, 372 },
	/*II_CF*/{ 0x70, 33146 },
	/*II_D4*/{ 0x71, 384 },
	/*II_D5*/{ 0x71, 389 },
	/*II_D6*/{ 0x72, 394 },
	/*II_D7*/{ 0x73, 400 },
	/*II_E0*/{ 0x74, 406 },
	/*II_E1*/{ 0x74, 414 },
	/*II_E2*/{ 0x75, 421 },
	/*II_E4*/{ 0x77, 33215 },
	/*II_E5*/{ 0x78, 33215 },
	/*II_E6*/{ 0x79, 33219 },
	/*II_E7*/{ 0x7a, 33219 },
	/*II_E8*/{ 0x7b, 456 },
	/*II_E9*/{ 0x7c, 462 },
	/*II_EA*/{ 0x7d, 467 },
	/*II_EB*/{ 0x7e, 462 },
	/*II_EC*/{ 0x7f, 33215 },
	/*II_ED*/{ 0x80, 33215 },
	/*II_EE*/{ 0x81, 33219 },
	/*II_EF*/{ 0x82, 33219 },
	/*II_F1*/{ 0x6d, 476 },
	/*II_F4*/{ 0x53, 33250 },
	/*II_F5*/{ 0x83, 487 },
	/*II_F8*/{ 0x83, 492 },
	/*II_F9*/{ 0x83, 497 },
	/*II_FA*/{ 0x84, 33270 },
	/*II_FB*/{ 0x84, 33275 },
	/*II_FC*/{ 0x85, 512 },
	/*II_FD*/{ 0x85, 517 },
	/*II_0F_02*/{ 0x86, 522 },
	/*II_0F_03*/{ 0x86, 527 },
	/*II_0F_05*/{ 0x87, 532 },
	/*II_0F_06*/{ 0x88, 33309 },
	/*II_0F_07*/{ 0x87, 547 },
	/*II_0F_08*/{ 0x88, 33323 },
	/*II_0F_09*/{ 0x88, 33329 },
	/*II_0F_0B*/{ 0x89, 569 },
	/*II_0F_0E*/{ 0x8a, 574 },
	/*II_0F_1F*/{ 0x8b, 581 },
	/*II_0F_20*/{ 0x8c, 32986 },
	/*II_0F_21*/{ 0x8d, 32986 },
	/*II_0F_22*/{ 0x8e, 32986 },
	/*II_0F_23*/{ 0x8f, 32986 },
	/*II_0F_30*/{ 0x88, 33354 },
	/*II_0F_31*/{ 0x88, 33361 },
	/*II_0F_32*/{ 0x88, 33368 },
	/*II_0F_33*/{ 0x88, 33375 },
	/*II_0F_34*/{ 0x87, 614 },
	/*II_0F_35*/{ 0x87, 624 },
	/*II_0F_37*/{ 0x90, 633 },
	/*II_0F_40*/{ 0x91, 641 },
	/*II_0F_41*/{ 0x91, 648 },
	/*II_0F_42*/{ 0x92, 656 },
	/*II_0F_43*/{ 0x92, 663 },
	/*II_0F_44*/{ 0x93, 671 },
	/*II_0F_45*/{ 0x93, 678 },
	/*II_0F_46*/{ 0x94, 686 },
	/*II_0F_47*/{ 0x94, 694 },
	/*II_0F_48*/{ 0x95, 701 },
	/*II_0F_49*/{ 0x95, 708 },
	/*II_0F_4A*/{ 0x96, 716 },
	/*II_0F_4B*/{ 0x96, 723 },
	/*II_0F_4C*/{ 0x97, 731 },
	/*II_0F_4D*/{ 0x97, 738 },
	/*II_0F_4E*/{ 0x98, 746 },
	/*II_0F_4F*/{ 0x98, 754 },
	/*II_0F_80*/{ 0x99, 134 },
	/*II_0F_81*/{ 0x99, 138 },
	/*II_0F_82*/{ 0x9a, 143 },
	/*II_0F_83*/{ 0x9a, 147 },
	/*II_0F_84*/{ 0x9b, 152 },
	/*II_0F_85*/{ 0x9b, 156 },
	/*II_0F_86*/{ 0x9c, 161 },
	/*II_0F_87*/{ 0x9c, 166 },
	/*II_0F_88*/{ 0x9d, 170 },
	/*II_0F_89*/{ 0x9d, 174 },
	/*II_0F_8A*/{ 0x9e, 179 },
	/*II_0F_8B*/{ 0x9e, 183 },
	/*II_0F_8C*/{ 0x9f, 188 },
	/*II_0F_8D*/{ 0x9f, 192 },
	/*II_0F_8E*/{ 0xa0, 197 },
	/*II_0F_8F*/{ 0xa0, 202 },
	/*II_0F_90*/{ 0xa1, 761 },
	/*II_0F_91*/{ 0xa1, 767 },
	/*II_0F_92*/{ 0xa2, 774 },
	/*II_0F_93*/{ 0xa2, 780 },
	/*II_0F_94*/{ 0xa3, 787 },
	/*II_0F_95*/{ 0xa3, 793 },
	/*II_0F_96*/{ 0xa4, 800 },
	/*II_0F_97*/{ 0xa4, 807 },
	/*II_0F_98*/{ 0xa5, 813 },
	/*II_0F_99*/{ 0xa5, 819 },
	/*II_0F_9A*/{ 0xa6, 826 },
	/*II_0F_9B*/{ 0xa6, 832 },
	/*II_0F_9C*/{ 0xa7, 839 },
	/*II_0F_9D*/{ 0xa7, 845 },
	/*II_0F_9E*/{ 0xa8, 852 },
	/*II_0F_9F*/{ 0xa8, 859 },
	/*II_0F_A0*/{ 0xa9, 16 },
	/*II_0F_A1*/{ 0xaa, 22 },
	/*II_0F_A2*/{ 0x88, 865 },
	/*II_0F_A3*/{ 0xab, 872 },
	/*II_0F_A8*/{ 0xad, 16 },
	/*II_0F_A9*/{ 0xae, 22 },
	/*II_0F_AA*/{ 0xaf, 882 },
	/*II_0F_AB*/{ 0xb0, 887 },
	/*II_0F_AF*/{ 0xb1, 117 },
	/*II_0F_B0*/{ 0xb2, 898 },
	/*II_0F_B1*/{ 0xb3, 898 },
	/*II_0F_B2*/{ 0xb4, 907 },
	/*II_0F_B3*/{ 0xb0, 912 },
	/*II_0F_B4*/{ 0xb4, 917 },
	/*II_0F_B5*/{ 0xb4, 922 },
	/*II_0F_B6*/{ 0xb5, 927 },
	/*II_0F_B7*/{ 0xb6, 927 },
	/*II_0F_B9*/{ 0x89, 569 },
	/*II_0F_BB*/{ 0xb0, 934 },
	/*II_0F_BE*/{ 0xb5, 939 },
	/*II_0F_BF*/{ 0xb6, 939 },
	/*II_0F_C0*/{ 0xb2, 946 },
	/*II_0F_C1*/{ 0xb3, 946 },
	/*II_0F_C3*/{ 0xb7, 952 },
	/*II_0F_C8*/{ 0xb8, 960 },
	/*II_0F_C8*/{ 0xb8, 960 },
	/*II_0F_C8*/{ 0xb8, 960 },
	/*II_0F_C8*/{ 0xb8, 960 },
	/*II_0F_C8*/{ 0xb8, 960 },
	/*II_0F_C8*/{ 0xb8, 960 },
	/*II_0F_C8*/{ 0xb8, 960 },
	/*II_0F_C8*/{ 0xb8, 960 },
	/*II_80_00*/{ 0xb9, 11 },
	/*II_80_01*/{ 0xba, 27 },
	/*II_80_02*/{ 0xbb, 31 },
	/*II_80_03*/{ 0xbb, 36 },
	/*II_80_04*/{ 0xbc, 41 },
	/*II_80_05*/{ 0xb9, 51 },
	/*II_80_06*/{ 0xbd, 61 },
	/*II_80_07*/{ 0xbe, 71 },
	/*II_81_00*/{ 0xbf, 11 },
	/*II_81_01*/{ 0xc0, 27 },
	/*II_81_02*/{ 0xc1, 31 },
	/*II_81_03*/{ 0xc1, 36 },
	/*II_81_04*/{ 0xc2, 41 },
	/*II_81_05*/{ 0xbf, 51 },
	/*II_81_06*/{ 0xc3, 61 },
	/*II_81_07*/{ 0xc4, 71 },
	/*II_82_00*/{ 0xc5, 11 },
	/*II_82_01*/{ 0xc6, 27 },
	/*II_82_02*/{ 0xc7, 31 },
	/*II_82_03*/{ 0xc7, 36 },
	/*II_82_04*/{ 0xc8, 41 },
	/*II_82_05*/{ 0xc5, 51 },
	/*II_82_06*/{ 0xc9, 61 },
	/*II_82_07*/{ 0xca, 71 },
	/*II_83_00*/{ 0xcb, 11 },
	/*II_83_01*/{ 0xcc, 27 },
	/*II_83_02*/{ 0xcd, 31 },
	/*II_83_03*/{ 0xcd, 36 },
	/*II_83_04*/{ 0xce, 41 },
	/*II_83_05*/{ 0xcb, 51 },
	/*II_83_06*/{ 0xcf, 61 },
	/*II_83_07*/{ 0xd0, 71 },
	/*II_8F_00*/{ 0xd1, 22 },
	/*II_C0_00*/{ 0xd2, 967 },
	/*II_C0_01*/{ 0xd2, 972 },
	/*II_C0_02*/{ 0xd3, 977 },
	/*II_C0_03*/{ 0xd3, 982 },
	/*II_C0_04*/{ 0xd4, 987 },
	/*II_C0_05*/{ 0xd4, 992 },
	/*II_C0_06*/{ 0xd4, 997 },
	/*II_C0_07*/{ 0xd4, 1002 },
	/*II_C1_00*/{ 0xd5, 967 },
	/*II_C1_01*/{ 0xd5, 972 },
	/*II_C1_02*/{ 0xd6, 977 },
	/*II_C1_03*/{ 0xd6, 982 },
	/*II_C1_04*/{ 0xd7, 987 },
	/*II_C1_05*/{ 0xd7, 992 },
	/*II_C1_06*/{ 0xd7, 997 },
	/*II_C1_07*/{ 0xd7, 1002 },
	/*II_C6_00*/{ 0xd8, 218 },
	/*II_C6_F8*/{ 0xd9, 1007 },
	/*II_C7_00*/{ 0xda, 218 },
	/*II_C7_F8*/{ 0xdb, 1015 },
	/*II_D0_00*/{ 0xdc, 967 },
	/*II_D0_01*/{ 0xdc, 972 },
	/*II_D0_02*/{ 0xdd, 977 },
	/*II_D0_03*/{ 0xdd, 982 },
	/*II_D0_04*/{ 0xde, 987 },
	/*II_D0_05*/{ 0xde, 992 },
	/*II_D0_06*/{ 0xde, 997 },
	/*II_D0_07*/{ 0xde, 1002 },
	/*II_D1_00*/{ 0xdf, 967 },
	/*II_D1_01*/{ 0xdf, 972 },
	/*II_D1_02*/{ 0xe0, 977 },
	/*II_D1_03*/{ 0xe0, 982 },
	/*II_D1_04*/{ 0xe1, 987 },
	/*II_D1_05*/{ 0xe1, 992 },
	/*II_D1_06*/{ 0xe1, 997 },
	/*II_D1_07*/{ 0xe1, 1002 },
	/*II_D2_00*/{ 0xe2, 967 },
	/*II_D2_01*/{ 0xe2, 972 },
	/*II_D2_02*/{ 0xe3, 977 },
	/*II_D2_03*/{ 0xe3, 982 },
	/*II_D2_04*/{ 0xe4, 987 },
	/*II_D2_05*/{ 0xe4, 992 },
	/*II_D2_06*/{ 0xe4, 997 },
	/*II_D2_07*/{ 0xe4, 1002 },
	/*II_D3_00*/{ 0xe5, 967 },
	/*II_D3_01*/{ 0xe5, 972 },
	/*II_D3_02*/{ 0xe6, 977 },
	/*II_D3_03*/{ 0xe6, 982 },
	/*II_D3_04*/{ 0xe7, 987 },
	/*II_D3_05*/{ 0xe7, 992 },
	/*II_D3_06*/{ 0xe7, 997 },
	/*II_D3_07*/{ 0xe7, 1002 },
	/*II_D8_00*/{ 0xe8, 1023 },
	/*II_D8_01*/{ 0xe8, 1029 },
	/*II_D8_02*/{ 0xe8, 1035 },
	/*II_D8_03*/{ 0xe8, 1041 },
	/*II_D8_04*/{ 0xe8, 1048 },
	/*II_D8_05*/{ 0xe8, 1054 },
	/*II_D8_06*/{ 0xe8, 1061 },
	/*II_D8_07*/{ 0xe8, 1067 },
	/*II_D8_C0*/{ 0xe9, 1023 },
	/*II_D8_C0*/{ 0xe9, 1023 },
	/*II_D8_C0*/{ 0xe9, 1023 },
	/*II_D8_C0*/{ 0xe9, 1023 },
	/*II_D8_C0*/{ 0xe9, 1023 },
	/*II_D8_C0*/{ 0xe9, 1023 },
	/*II_D8_C0*/{ 0xe9, 1023 },
	/*II_D8_C0*/{ 0xe9, 1023 },
	/*II_D8_C8*/{ 0xe9, 1029 },
	/*II_D8_C8*/{ 0xe9, 1029 },
	/*II_D8_C8*/{ 0xe9, 1029 },
	/*II_D8_C8*/{ 0xe9, 1029 },
	/*II_D8_C8*/{ 0xe9, 1029 },
	/*II_D8_C8*/{ 0xe9, 1029 },
	/*II_D8_C8*/{ 0xe9, 1029 },
	/*II_D8_C8*/{ 0xe9, 1029 },
	/*II_D8_D0*/{ 0xea, 1035 },
	/*II_D8_D0*/{ 0xea, 1035 },
	/*II_D8_D0*/{ 0xea, 1035 },
	/*II_D8_D0*/{ 0xea, 1035 },
	/*II_D8_D0*/{ 0xea, 1035 },
	/*II_D8_D0*/{ 0xea, 1035 },
	/*II_D8_D0*/{ 0xea, 1035 },
	/*II_D8_D0*/{ 0xea, 1035 },
	/*II_D8_D8*/{ 0xea, 1041 },
	/*II_D8_D9*/{ 0xeb, 1041 },
	/*II_D8_D8*/{ 0xea, 1041 },
	/*II_D8_D8*/{ 0xea, 1041 },
	/*II_D8_D8*/{ 0xea, 1041 },
	/*II_D8_D8*/{ 0xea, 1041 },
	/*II_D8_D8*/{ 0xea, 1041 },
	/*II_D8_D8*/{ 0xea, 1041 },
	/*II_D8_E0*/{ 0xe9, 1048 },
	/*II_D8_E0*/{ 0xe9, 1048 },
	/*II_D8_E0*/{ 0xe9, 1048 },
	/*II_D8_E0*/{ 0xe9, 1048 },
	/*II_D8_E0*/{ 0xe9, 1048 },
	/*II_D8_E0*/{ 0xe9, 1048 },
	/*II_D8_E0*/{ 0xe9, 1048 },
	/*II_D8_E0*/{ 0xe9, 1048 },
	/*II_D8_E8*/{ 0xe9, 1054 },
	/*II_D8_E8*/{ 0xe9, 1054 },
	/*II_D8_E8*/{ 0xe9, 1054 },
	/*II_D8_E8*/{ 0xe9, 1054 },
	/*II_D8_E8*/{ 0xe9, 1054 },
	/*II_D8_E8*/{ 0xe9, 1054 },
	/*II_D8_E8*/{ 0xe9, 1054 },
	/*II_D8_E8*/{ 0xe9, 1054 },
	/*II_D8_F0*/{ 0xe9, 1061 },
	/*II_D8_F0*/{ 0xe9, 1061 },
	/*II_D8_F0*/{ 0xe9, 1061 },
	/*II_D8_F0*/{ 0xe9, 1061 },
	/*II_D8_F0*/{ 0xe9, 1061 },
	/*II_D8_F0*/{ 0xe9, 1061 },
	/*II_D8_F0*/{ 0xe9, 1061 },
	/*II_D8_F0*/{ 0xe9, 1061 },
	/*II_D8_F8*/{ 0xe9, 1067 },
	/*II_D8_F8*/{ 0xe9, 1067 },
	/*II_D8_F8*/{ 0xe9, 1067 },
	/*II_D8_F8*/{ 0xe9, 1067 },
	/*II_D8_F8*/{ 0xe9, 1067 },
	/*II_D8_F8*/{ 0xe9, 1067 },
	/*II_D8_F8*/{ 0xe9, 1067 },
	/*II_D8_F8*/{ 0xe9, 1067 },
	/*II_D9_00*/{ 0xe8, 1074 },
	/*II_D9_02*/{ 0xec, 1079 },
	/*II_D9_03*/{ 0xec, 1084 },
	/*II_D9_04*/{ 0xed, 1090 },
	/*II_D9_05*/{ 0xee, 1098 },
	/*II_D9_C0*/{ 0xea, 1074 },
	/*II_D9_C0*/{ 0xea, 1074 },
	/*II_D9_C0*/{ 0xea, 1074 },
	/*II_D9_C0*/{ 0xea, 1074 },
	/*II_D9_C0*/{ 0xea, 1074 },
	/*II_D9_C0*/{ 0xea, 1074 },
	/*II_D9_C0*/{ 0xea, 1074 },
	/*II_D9_C0*/{ 0xea, 1074 },
	/*II_D9_C8*/{ 0xea, 1105 },
	/*II_D9_C9*/{ 0xeb, 1105 },
	/*II_D9_C8*/{ 0xea, 1105 },
	/*II_D9_C8*/{ 0xea, 1105 },
	/*II_D9_C8*/{ 0xea, 1105 },
	/*II_D9_C8*/{ 0xea, 1105 },
	/*II_D9_C8*/{ 0xea, 1105 },
	/*II_D9_C8*/{ 0xea, 1105 },
	/*II_D9_D0*/{ 0xeb, 1111 },
	/*II_D9_E0*/{ 0xeb, 1117 },
	/*II_D9_E1*/{ 0xeb, 1123 },
	/*II_D9_E4*/{ 0xeb, 1129 },
	/*II_D9_E5*/{ 0xeb, 1135 },
	/*II_D9_E8*/{ 0xeb, 1141 },
	/*II_D9_E9*/{ 0xeb, 1147 },
	/*II_D9_EA*/{ 0xeb, 1155 },
	/*II_D9_EB*/{ 0xeb, 1163 },
	/*II_D9_EC*/{ 0xeb, 1170 },
	/*II_D9_ED*/{ 0xeb, 1178 },
	/*II_D9_EE*/{ 0xeb, 1186 },
	/*II_D9_F0*/{ 0xeb, 1192 },
	/*II_D9_F1*/{ 0xeb, 1199 },
	/*II_D9_F2*/{ 0xeb, 1206 },
	/*II_D9_F3*/{ 0xeb, 1213 },
	/*II_D9_F4*/{ 0xeb, 1221 },
	/*II_D9_F5*/{ 0xeb, 1230 },
	/*II_D9_F6*/{ 0xeb, 1238 },
	/*II_D9_F7*/{ 0xeb, 1247 },
	/*II_D9_F8*/{ 0xeb, 1256 },
	/*II_D9_F9*/{ 0xeb, 1263 },
	/*II_D9_FA*/{ 0xeb, 1272 },
	/*II_D9_FB*/{ 0xeb, 1279 },
	/*II_D9_FC*/{ 0xeb, 1288 },
	/*II_D9_FD*/{ 0xeb, 1297 },
	/*II_D9_FE*/{ 0xeb, 1305 },
	/*II_D9_FF*/{ 0xeb, 1311 },
	/*II_DA_00*/{ 0xe8, 1317 },
	/*II_DA_01*/{ 0xe8, 1324 },
	/*II_DA_02*/{ 0xe8, 1331 },
	/*II_DA_03*/{ 0xe8, 1338 },
	/*II_DA_04*/{ 0xe8, 1346 },
	/*II_DA_05*/{ 0xe8, 1353 },
	/*II_DA_06*/{ 0xe8, 1361 },
	/*II_DA_07*/{ 0xe8, 1368 },
	/*II_DA_C0*/{ 0xef, 1376 },
	/*II_DA_C0*/{ 0xef, 1376 },
	/*II_DA_C0*/{ 0xef, 1376 },
	/*II_DA_C0*/{ 0xef, 1376 },
	/*II_DA_C0*/{ 0xef, 1376 },
	/*II_DA_C0*/{ 0xef, 1376 },
	/*II_DA_C0*/{ 0xef, 1376 },
	/*II_DA_C0*/{ 0xef, 1376 },
	/*II_DA_C8*/{ 0xf0, 1384 },
	/*II_DA_C8*/{ 0xf0, 1384 },
	/*II_DA_C8*/{ 0xf0, 1384 },
	/*II_DA_C8*/{ 0xf0, 1384 },
	/*II_DA_C8*/{ 0xf0, 1384 },
	/*II_DA_C8*/{ 0xf0, 1384 },
	/*II_DA_C8*/{ 0xf0, 1384 },
	/*II_DA_C8*/{ 0xf0, 1384 },
	/*II_DA_D0*/{ 0xf1, 1392 },
	/*II_DA_D0*/{ 0xf1, 1392 },
	/*II_DA_D0*/{ 0xf1, 1392 },
	/*II_DA_D0*/{ 0xf1, 1392 },
	/*II_DA_D0*/{ 0xf1, 1392 },
	/*II_DA_D0*/{ 0xf1, 1392 },
	/*II_DA_D0*/{ 0xf1, 1392 },
	/*II_DA_D0*/{ 0xf1, 1392 },
	/*II_DA_D8*/{ 0xf2, 1401 },
	/*II_DA_D8*/{ 0xf2, 1401 },
	/*II_DA_D8*/{ 0xf2, 1401 },
	/*II_DA_D8*/{ 0xf2, 1401 },
	/*II_DA_D8*/{ 0xf2, 1401 },
	/*II_DA_D8*/{ 0xf2, 1401 },
	/*II_DA_D8*/{ 0xf2, 1401 },
	/*II_DA_D8*/{ 0xf2, 1401 },
	/*II_DA_E9*/{ 0xeb, 1409 },
	/*II_DB_00*/{ 0xe8, 1418 },
	/*II_DB_01*/{ 0xf3, 1424 },
	/*II_DB_02*/{ 0xec, 1432 },
	/*II_DB_03*/{ 0xec, 1438 },
	/*II_DB_05*/{ 0xf4, 1074 },
	/*II_DB_07*/{ 0xf5, 1084 },
	/*II_DB_C0*/{ 0xef, 1445 },
	/*II_DB_C0*/{ 0xef, 1445 },
	/*II_DB_C0*/{ 0xef, 1445 },
	/*II_DB_C0*/{ 0xef, 1445 },
	/*II_DB_C0*/{ 0xef, 1445 },
	/*II_DB_C0*/{ 0xef, 1445 },
	/*II_DB_C0*/{ 0xef, 1445 },
	/*II_DB_C0*/{ 0xef, 1445 },
	/*II_DB_C8*/{ 0xf0, 1454 },
	/*II_DB_C8*/{ 0xf0, 1454 },
	/*II_DB_C8*/{ 0xf0, 1454 },
	/*II_DB_C8*/{ 0xf0, 1454 },
	/*II_DB_C8*/{ 0xf0, 1454 },
	/*II_DB_C8*/{ 0xf0, 1454 },
	/*II_DB_C8*/{ 0xf0, 1454 },
	/*II_DB_C8*/{ 0xf0, 1454 },
	/*II_DB_D0*/{ 0xf1, 1463 },
	/*II_DB_D0*/{ 0xf1, 1463 },
	/*II_DB_D0*/{ 0xf1, 1463 },
	/*II_DB_D0*/{ 0xf1, 1463 },
	/*II_DB_D0*/{ 0xf1, 1463 },
	/*II_DB_D0*/{ 0xf1, 1463 },
	/*II_DB_D0*/{ 0xf1, 1463 },
	/*II_DB_D0*/{ 0xf1, 1463 },
	/*II_DB_D8*/{ 0xf2, 1473 },
	/*II_DB_D8*/{ 0xf2, 1473 },
	/*II_DB_D8*/{ 0xf2, 1473 },
	/*II_DB_D8*/{ 0xf2, 1473 },
	/*II_DB_D8*/{ 0xf2, 1473 },
	/*II_DB_D8*/{ 0xf2, 1473 },
	/*II_DB_D8*/{ 0xf2, 1473 },
	/*II_DB_D8*/{ 0xf2, 1473 },
	/*II_DB_E0*/{ 0xeb, 1482 },
	/*II_DB_E1*/{ 0xeb, 1488 },
	/*II_DB_E4*/{ 0xeb, 1496 },
	/*II_DB_E8*/{ 0xf6, 1504 },
	/*II_DB_E8*/{ 0xf6, 1504 },
	/*II_DB_E8*/{ 0xf6, 1504 },
	/*II_DB_E8*/{ 0xf6, 1504 },
	/*II_DB_E8*/{ 0xf6, 1504 },
	/*II_DB_E8*/{ 0xf6, 1504 },
	/*II_DB_E8*/{ 0xf6, 1504 },
	/*II_DB_E8*/{ 0xf6, 1504 },
	/*II_DB_F0*/{ 0xf7, 1512 },
	/*II_DB_F0*/{ 0xf7, 1512 },
	/*II_DB_F0*/{ 0xf7, 1512 },
	/*II_DB_F0*/{ 0xf7, 1512 },
	/*II_DB_F0*/{ 0xf7, 1512 },
	/*II_DB_F0*/{ 0xf7, 1512 },
	/*II_DB_F0*/{ 0xf7, 1512 },
	/*II_DB_F0*/{ 0xf7, 1512 },
	/*II_DC_00*/{ 0xf8, 1023 },
	/*II_DC_01*/{ 0xf8, 1029 },
	/*II_DC_02*/{ 0xf8, 1035 },
	/*II_DC_03*/{ 0xf8, 1041 },
	/*II_DC_04*/{ 0xf8, 1048 },
	/*II_DC_05*/{ 0xf8, 1054 },
	/*II_DC_06*/{ 0xf8, 1061 },
	/*II_DC_07*/{ 0xf8, 1067 },
	/*II_DC_C0*/{ 0xf9, 1023 },
	/*II_DC_C0*/{ 0xf9, 1023 },
	/*II_DC_C0*/{ 0xf9, 1023 },
	/*II_DC_C0*/{ 0xf9, 1023 },
	/*II_DC_C0*/{ 0xf9, 1023 },
	/*II_DC_C0*/{ 0xf9, 1023 },
	/*II_DC_C0*/{ 0xf9, 1023 },
	/*II_DC_C0*/{ 0xf9, 1023 },
	/*II_DC_C8*/{ 0xf9, 1029 },
	/*II_DC_C8*/{ 0xf9, 1029 },
	/*II_DC_C8*/{ 0xf9, 1029 },
	/*II_DC_C8*/{ 0xf9, 1029 },
	/*II_DC_C8*/{ 0xf9, 1029 },
	/*II_DC_C8*/{ 0xf9, 1029 },
	/*II_DC_C8*/{ 0xf9, 1029 },
	/*II_DC_C8*/{ 0xf9, 1029 },
	/*II_DC_E0*/{ 0xf9, 1054 },
	/*II_DC_E0*/{ 0xf9, 1054 },
	/*II_DC_E0*/{ 0xf9, 1054 },
	/*II_DC_E0*/{ 0xf9, 1054 },
	/*II_DC_E0*/{ 0xf9, 1054 },
	/*II_DC_E0*/{ 0xf9, 1054 },
	/*II_DC_E0*/{ 0xf9, 1054 },
	/*II_DC_E0*/{ 0xf9, 1054 },
	/*II_DC_E8*/{ 0xf9, 1048 },
	/*II_DC_E8*/{ 0xf9, 1048 },
	/*II_DC_E8*/{ 0xf9, 1048 },
	/*II_DC_E8*/{ 0xf9, 1048 },
	/*II_DC_E8*/{ 0xf9, 1048 },
	/*II_DC_E8*/{ 0xf9, 1048 },
	/*II_DC_E8*/{ 0xf9, 1048 },
	/*II_DC_E8*/{ 0xf9, 1048 },
	/*II_DC_F0*/{ 0xf9, 1067 },
	/*II_DC_F0*/{ 0xf9, 1067 },
	/*II_DC_F0*/{ 0xf9, 1067 },
	/*II_DC_F0*/{ 0xf9, 1067 },
	/*II_DC_F0*/{ 0xf9, 1067 },
	/*II_DC_F0*/{ 0xf9, 1067 },
	/*II_DC_F0*/{ 0xf9, 1067 },
	/*II_DC_F0*/{ 0xf9, 1067 },
	/*II_DC_F8*/{ 0xf9, 1061 },
	/*II_DC_F8*/{ 0xf9, 1061 },
	/*II_DC_F8*/{ 0xf9, 1061 },
	/*II_DC_F8*/{ 0xf9, 1061 },
	/*II_DC_F8*/{ 0xf9, 1061 },
	/*II_DC_F8*/{ 0xf9, 1061 },
	/*II_DC_F8*/{ 0xf9, 1061 },
	/*II_DC_F8*/{ 0xf9, 1061 },
	/*II_DD_00*/{ 0xf8, 1074 },
	/*II_DD_01*/{ 0xfa, 1424 },
	/*II_DD_02*/{ 0xfb, 1079 },
	/*II_DD_03*/{ 0xfb, 1084 },
	/*II_DD_04*/{ 0xed, 1519 },
	/*II_DD_C0*/{ 0xea, 1527 },
	/*II_DD_C0*/{ 0xea, 1527 },
	/*II_DD_C0*/{ 0xea, 1527 },
	/*II_DD_C0*/{ 0xea, 1527 },
	/*II_DD_C0*/{ 0xea, 1527 },
	/*II_DD_C0*/{ 0xea, 1527 },
	/*II_DD_C0*/{ 0xea, 1527 },
	/*II_DD_C0*/{ 0xea, 1527 },
	/*II_DD_D0*/{ 0xea, 1079 },
	/*II_DD_D0*/{ 0xea, 1079 },
	/*II_DD_D0*/{ 0xea, 1079 },
	/*II_DD_D0*/{ 0xea, 1079 },
	/*II_DD_D0*/{ 0xea, 1079 },
	/*II_DD_D0*/{ 0xea, 1079 },
	/*II_DD_D0*/{ 0xea, 1079 },
	/*II_DD_D0*/{ 0xea, 1079 },
	/*II_DD_D8*/{ 0xea, 1084 },
	/*II_DD_D8*/{ 0xea, 1084 },
	/*II_DD_D8*/{ 0xea, 1084 },
	/*II_DD_D8*/{ 0xea, 1084 },
	/*II_DD_D8*/{ 0xea, 1084 },
	/*II_DD_D8*/{ 0xea, 1084 },
	/*II_DD_D8*/{ 0xea, 1084 },
	/*II_DD_D8*/{ 0xea, 1084 },
	/*II_DD_E0*/{ 0xf9, 1534 },
	/*II_DD_E1*/{ 0xeb, 1534 },
	/*II_DD_E0*/{ 0xf9, 1534 },
	/*II_DD_E0*/{ 0xf9, 1534 },
	/*II_DD_E0*/{ 0xf9, 1534 },
	/*II_DD_E0*/{ 0xf9, 1534 },
	/*II_DD_E0*/{ 0xf9, 1534 },
	/*II_DD_E0*/{ 0xf9, 1534 },
	/*II_DD_E8*/{ 0xea, 1541 },
	/*II_DD_E9*/{ 0xeb, 1541 },
	/*II_DD_E8*/{ 0xea, 1541 },
	/*II_DD_E8*/{ 0xea, 1541 },
	/*II_DD_E8*/{ 0xea, 1541 },
	/*II_DD_E8*/{ 0xea, 1541 },
	/*II_DD_E8*/{ 0xea, 1541 },
	/*II_DD_E8*/{ 0xea, 1541 },
	/*II_DE_00*/{ 0xee, 1317 },
	/*II_DE_01*/{ 0xee, 1324 },
	/*II_DE_02*/{ 0xee, 1331 },
	/*II_DE_03*/{ 0xee, 1338 },
	/*II_DE_04*/{ 0xee, 1346 },
	/*II_DE_05*/{ 0xee, 1353 },
	/*II_DE_06*/{ 0xee, 1361 },
	/*II_DE_07*/{ 0xee, 1368 },
	/*II_DE_C0*/{ 0xf9, 1549 },
	/*II_DE_C1*/{ 0xeb, 1549 },
	/*II_DE_C0*/{ 0xf9, 1549 },
	/*II_DE_C0*/{ 0xf9, 1549 },
	/*II_DE_C0*/{ 0xf9, 1549 },
	/*II_DE_C0*/{ 0xf9, 1549 },
	/*II_DE_C0*/{ 0xf9, 1549 },
	/*II_DE_C0*/{ 0xf9, 1549 },
	/*II_DE_C8*/{ 0xf9, 1556 },
	/*II_DE_C9*/{ 0xeb, 1556 },
	/*II_DE_C8*/{ 0xf9, 1556 },
	/*II_DE_C8*/{ 0xf9, 1556 },
	/*II_DE_C8*/{ 0xf9, 1556 },
	/*II_DE_C8*/{ 0xf9, 1556 },
	/*II_DE_C8*/{ 0xf9, 1556 },
	/*II_DE_C8*/{ 0xf9, 1556 },
	/*II_DE_D9*/{ 0xeb, 1563 },
	/*II_DE_E0*/{ 0xf9, 1571 },
	/*II_DE_E1*/{ 0xeb, 1571 },
	/*II_DE_E0*/{ 0xf9, 1571 },
	/*II_DE_E0*/{ 0xf9, 1571 },
	/*II_DE_E0*/{ 0xf9, 1571 },
	/*II_DE_E0*/{ 0xf9, 1571 },
	/*II_DE_E0*/{ 0xf9, 1571 },
	/*II_DE_E0*/{ 0xf9, 1571 },
	/*II_DE_E8*/{ 0xf9, 1579 },
	/*II_DE_E9*/{ 0xeb, 1579 },
	/*II_DE_E8*/{ 0xf9, 1579 },
	/*II_DE_E8*/{ 0xf9, 1579 },
	/*II_DE_E8*/{ 0xf9, 1579 },
	/*II_DE_E8*/{ 0xf9, 1579 },
	/*II_DE_E8*/{ 0xf9, 1579 },
	/*II_DE_E8*/{ 0xf9, 1579 },
	/*II_DE_F0*/{ 0xf9, 1586 },
	/*II_DE_F1*/{ 0xeb, 1586 },
	/*II_DE_F0*/{ 0xf9, 1586 },
	/*II_DE_F0*/{ 0xf9, 1586 },
	/*II_DE_F0*/{ 0xf9, 1586 },
	/*II_DE_F0*/{ 0xf9, 1586 },
	/*II_DE_F0*/{ 0xf9, 1586 },
	/*II_DE_F0*/{ 0xf9, 1586 },
	/*II_DE_F8*/{ 0xf9, 1594 },
	/*II_DE_F9*/{ 0xeb, 1594 },
	/*II_DE_F8*/{ 0xf9, 1594 },
	/*II_DE_F8*/{ 0xf9, 1594 },
	/*II_DE_F8*/{ 0xf9, 1594 },
	/*II_DE_F8*/{ 0xf9, 1594 },
	/*II_DE_F8*/{ 0xf9, 1594 },
	/*II_DE_F8*/{ 0xf9, 1594 },
	/*II_DF_00*/{ 0xee, 1418 },
	/*II_DF_01*/{ 0xfc, 1424 },
	/*II_DF_02*/{ 0xfd, 1432 },
	/*II_DF_03*/{ 0xfd, 1438 },
	/*II_DF_04*/{ 0xf4, 1601 },
	/*II_DF_05*/{ 0xf8, 1418 },
	/*II_DF_06*/{ 0xf5, 1607 },
	/*II_DF_07*/{ 0xfb, 1438 },
	/*II_DF_E8*/{ 0xf6, 1614 },
	/*II_DF_E8*/{ 0xf6, 1614 },
	/*II_DF_E8*/{ 0xf6, 1614 },
	/*II_DF_E8*/{ 0xf6, 1614 },
	/*II_DF_E8*/{ 0xf6, 1614 },
	/*II_DF_E8*/{ 0xf6, 1614 },
	/*II_DF_E8*/{ 0xf6, 1614 },
	/*II_DF_E8*/{ 0xf6, 1614 },
	/*II_DF_F0*/{ 0xf6, 1623 },
	/*II_DF_F0*/{ 0xf6, 1623 },
	/*II_DF_F0*/{ 0xf6, 1623 },
	/*II_DF_F0*/{ 0xf6, 1623 },
	/*II_DF_F0*/{ 0xf6, 1623 },
	/*II_DF_F0*/{ 0xf6, 1623 },
	/*II_DF_F0*/{ 0xf6, 1623 },
	/*II_DF_F0*/{ 0xf6, 1623 },
	/*II_F6_00*/{ 0xfe, 206 },
	/*II_F6_02*/{ 0xff, 1631 },
	/*II_F6_03*/{ 0x100, 1636 },
	/*II_F6_04*/{ 0x101, 1641 },
	/*II_F6_05*/{ 0x101, 117 },
	/*II_F6_06*/{ 0x102, 1646 },
	/*II_F6_07*/{ 0x102, 1651 },
	/*II_F7_00*/{ 0x103, 206 },
	/*II_F7_02*/{ 0x104, 1631 },
	/*II_F7_03*/{ 0x105, 1636 },
	/*II_F7_04*/{ 0x106, 1641 },
	/*II_F7_05*/{ 0x106, 117 },
	/*II_F7_06*/{ 0x107, 1646 },
	/*II_F7_07*/{ 0x107, 1651 },
	/*II_FE_00*/{ 0x108, 81 },
	/*II_FE_01*/{ 0x108, 86 },
	/*II_FF_00*/{ 0x109, 81 },
	/*II_FF_01*/{ 0x109, 86 },
	/*II_FF_02*/{ 0x10a, 456 },
	/*II_FF_03*/{ 0x10b, 260 },
	/*II_FF_04*/{ 0x10c, 462 },
	/*II_FF_05*/{ 0x10d, 467 },
	/*II_FF_06*/{ 0x10e, 16 },
	/*II_0F_00_00*/{ 0x10f, 1657 },
	/*II_0F_00_01*/{ 0x110, 1663 },
	/*II_0F_00_02*/{ 0x110, 34436 },
	/*II_0F_00_03*/{ 0x111, 34442 },
	/*II_0F_00_04*/{ 0x112, 1679 },
	/*II_0F_00_05*/{ 0x112, 1685 },
	/*II_0F_01_00*/{ 0x113, 1691 },
	/*II_0F_01_01*/{ 0x113, 1697 },
	/*II_0F_01_02*/{ 0x113, 34471 },
	/*II_0F_01_03*/{ 0x113, 34477 },
	/*II_0F_01_04*/{ 0x114, 1715 },
	/*II_0F_01_06*/{ 0x115, 34489 },
	/*II_0F_01_07*/{ 0x116, 34495 },
	/*II_0F_01_C1*/{ 0x117, 1735 },
	/*II_0F_01_C2*/{ 0x117, 1743 },
	/*II_0F_01_C3*/{ 0x117, 1753 },
	/*II_0F_01_C4*/{ 0x117, 1763 },
	/*II_0F_01_C8*/{ 0x118, 1771 },
	/*II_0F_01_C9*/{ 0x118, 1780 },
	/*II_0F_01_D0*/{ 0x88, 1787 },
	/*II_0F_01_D1*/{ 0x88, 1795 },
	/*II_0F_01_D4*/{ 0x117, 1803 },
	/*II_0F_01_D5*/{ 0x119, 1811 },
	/*II_0F_01_D8*/{ 0x11a, 1817 },
	/*II_0F_01_D9*/{ 0x11b, 1824 },
	/*II_0F_01_DA*/{ 0x11c, 1833 },
	/*II_0F_01_DB*/{ 0x11c, 1841 },
	/*II_0F_01_DC*/{ 0x11b, 1849 },
	/*II_0F_01_DD*/{ 0x11b, 1855 },
	/*II_0F_01_DE*/{ 0x11c, 1861 },
	/*II_0F_01_DF*/{ 0x11d, 1869 },
	/*II_0F_01_F8*/{ 0x11e, 1878 },
	/*II_0F_01_F9*/{ 0x11e, 1886 },
	/*II_0F_0D_00*/{ 0x11f, 1894 },
	/*II_0F_0D_01*/{ 0x11f, 1904 },
	/*II_0F_0F_0C*/{ 0x120, 1915 },
	/*II_0F_0F_0D*/{ 0x121, 1922 },
	/*II_0F_0F_1C*/{ 0x120, 1929 },
	/*II_0F_0F_1D*/{ 0x121, 1936 },
	/*II_0F_0F_8A*/{ 0x120, 1943 },
	/*II_0F_0F_8E*/{ 0x120, 1951 },
	/*II_0F_0F_90*/{ 0x121, 1960 },
	/*II_0F_0F_94*/{ 0x121, 1969 },
	/*II_0F_0F_96*/{ 0x121, 1976 },
	/*II_0F_0F_97*/{ 0x121, 1983 },
	/*II_0F_0F_9A*/{ 0x121, 1992 },
	/*II_0F_0F_9E*/{ 0x121, 1999 },
	/*II_0F_0F_A0*/{ 0x121, 2006 },
	/*II_0F_0F_A4*/{ 0x121, 2015 },
	/*II_0F_0F_A6*/{ 0x121, 2022 },
	/*II_0F_0F_A7*/{ 0x121, 2032 },
	/*II_0F_0F_AA*/{ 0x121, 2042 },
	/*II_0F_0F_AE*/{ 0x121, 2050 },
	/*II_0F_0F_B0*/{ 0x121, 2057 },
	/*II_0F_0F_B4*/{ 0x121, 2066 },
	/*II_0F_0F_B6*/{ 0x121, 2073 },
	/*II_0F_0F_B7*/{ 0x121, 2083 },
	/*II_0F_0F_BB*/{ 0x120, 2092 },
	/*II_0F_0F_BF*/{ 0x121, 2100 },
	/*II_0F_10*/{ 0x122, 2109 },
	/*II_66_0F_10*/{ 0x123, 2117 },
	/*II_F3_0F_10*/{ 0x124, 2125 },
	/*II_F2_0F_10*/{ 0x125, 2132 },
	/*II_0F_11*/{ 0x12a, 2109 },
	/*II_66_0F_11*/{ 0x12b, 2117 },
	/*II_F3_0F_11*/{ 0x12c, 2125 },
	/*II_F2_0F_11*/{ 0x12d, 2132 },
	/*II_66_0F_12*/{ 0x132, 2190 },
	/*II_F3_0F_12*/{ 0x133, 2198 },
	/*II_F2_0F_12*/{ 0x133, 2208 },
	/*II_0F_13*/{ 0x137, 2182 },
	/*II_66_0F_13*/{ 0x138, 2190 },
	/*II_0F_14*/{ 0x13a, 2266 },
	/*II_66_0F_14*/{ 0x13b, 2276 },
	/*II_0F_15*/{ 0x13a, 2308 },
	/*II_66_0F_15*/{ 0x13b, 2318 },
	/*II_66_0F_16*/{ 0x132, 2367 },
	/*II_F3_0F_16*/{ 0x13d, 2375 },
	/*II_0F_17*/{ 0x137, 2359 },
	/*II_66_0F_17*/{ 0x138, 2367 },
	/*II_0F_18_00*/{ 0x13e, 2424 },
	/*II_0F_18_01*/{ 0x13e, 2437 },
	/*II_0F_18_02*/{ 0x13e, 2449 },
	/*II_0F_18_03*/{ 0x13e, 2461 },
	/*II_0F_28*/{ 0x122, 2473 },
	/*II_66_0F_28*/{ 0x123, 2481 },
	/*II_0F_29*/{ 0x12a, 2473 },
	/*II_66_0F_29*/{ 0x12b, 2481 },
	/*II_0F_2A*/{ 0x13f, 2507 },
	/*II_66_0F_2A*/{ 0x140, 2517 },
	/*II_F3_0F_2A*/{ 0x141, 2527 },
	/*II_F2_0F_2A*/{ 0x142, 2537 },
	/*II_0F_2B*/{ 0x143, 2569 },
	/*II_66_0F_2B*/{ 0x144, 2578 },
	/*II_F3_0F_2B*/{ 0x145, 2587 },
	/*II_F2_0F_2B*/{ 0x146, 2596 },
	/*II_0F_2C*/{ 0x148, 2625 },
	/*II_66_0F_2C*/{ 0x149, 2636 },
	/*II_F3_0F_2C*/{ 0x14a, 2647 },
	/*II_F2_0F_2C*/{ 0x14b, 2658 },
	/*II_0F_2D*/{ 0x148, 2693 },
	/*II_66_0F_2D*/{ 0x13b, 2703 },
	/*II_F3_0F_2D*/{ 0x14a, 2713 },
	/*II_F2_0F_2D*/{ 0x14b, 2723 },
	/*II_0F_2E*/{ 0x14d, 2755 },
	/*II_66_0F_2E*/{ 0x14e, 2764 },
	/*II_0F_2F*/{ 0x14d, 2793 },
	/*II_66_0F_2F*/{ 0x14e, 2801 },
	/*II_0F_50*/{ 0x151, 2827 },
	/*II_66_0F_50*/{ 0x152, 2837 },
	/*II_0F_51*/{ 0x13a, 2869 },
	/*II_66_0F_51*/{ 0x13b, 2877 },
	/*II_F3_0F_51*/{ 0x154, 2885 },
	/*II_F2_0F_51*/{ 0x14e, 2893 },
	/*II_0F_52*/{ 0x13a, 2937 },
	/*II_F3_0F_52*/{ 0x154, 2946 },
	/*II_0F_53*/{ 0x13a, 2975 },
	/*II_F3_0F_53*/{ 0x154, 2982 },
	/*II_0F_54*/{ 0x13a, 3005 },
	/*II_66_0F_54*/{ 0x13b, 3012 },
	/*II_0F_55*/{ 0x13a, 3035 },
	/*II_66_0F_55*/{ 0x13b, 3043 },
	/*II_0F_56*/{ 0x13a, 3069 },
	/*II_66_0F_56*/{ 0x13b, 3075 },
	/*II_0F_57*/{ 0x13a, 3095 },
	/*II_66_0F_57*/{ 0x13b, 3102 },
	/*II_0F_58*/{ 0x13a, 3125 },
	/*II_66_0F_58*/{ 0x13b, 3132 },
	/*II_F3_0F_58*/{ 0x154, 3139 },
	/*II_F2_0F_58*/{ 0x14e, 3146 },
	/*II_0F_59*/{ 0x13a, 3185 },
	/*II_66_0F_59*/{ 0x13b, 3192 },
	/*II_F3_0F_59*/{ 0x154, 3199 },
	/*II_F2_0F_59*/{ 0x14e, 3206 },
	/*II_0F_5A*/{ 0x14e, 3245 },
	/*II_66_0F_5A*/{ 0x13b, 3255 },
	/*II_F3_0F_5A*/{ 0x155, 3265 },
	/*II_F2_0F_5A*/{ 0x14e, 3275 },
	/*II_0F_5B*/{ 0x13b, 3329 },
	/*II_66_0F_5B*/{ 0x13b, 3339 },
	/*II_F3_0F_5B*/{ 0x13b, 3349 },
	/*II_0F_5C*/{ 0x13a, 3394 },
	/*II_66_0F_5C*/{ 0x13b, 3401 },
	/*II_F3_0F_5C*/{ 0x154, 3408 },
	/*II_F2_0F_5C*/{ 0x14e, 3415 },
	/*II_0F_5D*/{ 0x13a, 3454 },
	/*II_66_0F_5D*/{ 0x13b, 3461 },
	/*II_F3_0F_5D*/{ 0x154, 3468 },
	/*II_F2_0F_5D*/{ 0x14e, 3475 },
	/*II_0F_5E*/{ 0x13a, 3514 },
	/*II_66_0F_5E*/{ 0x13b, 3521 },
	/*II_F3_0F_5E*/{ 0x154, 3528 },
	/*II_F2_0F_5E*/{ 0x14e, 3535 },
	/*II_0F_5F*/{ 0x13a, 3574 },
	/*II_66_0F_5F*/{ 0x13b, 3581 },
	/*II_F3_0F_5F*/{ 0x154, 3588 },
	/*II_F2_0F_5F*/{ 0x14e, 3595 },
	/*II_0F_60*/{ 0x158, 3634 },
	/*II_66_0F_60*/{ 0x13b, 3634 },
	/*II_0F_61*/{ 0x158, 3657 },
	/*II_66_0F_61*/{ 0x13b, 3657 },
	/*II_0F_62*/{ 0x158, 3680 },
	/*II_66_0F_62*/{ 0x13b, 3680 },
	/*II_0F_63*/{ 0x159, 3703 },
	/*II_66_0F_63*/{ 0x13b, 3703 },
	/*II_0F_64*/{ 0x159, 3724 },
	/*II_66_0F_64*/{ 0x13b, 3724 },
	/*II_0F_65*/{ 0x159, 3743 },
	/*II_66_0F_65*/{ 0x13b, 3743 },
	/*II_0F_66*/{ 0x159, 3762 },
	/*II_66_0F_66*/{ 0x13b, 3762 },
	/*II_0F_67*/{ 0x159, 3781 },
	/*II_66_0F_67*/{ 0x13b, 3781 },
	/*II_0F_68*/{ 0x159, 3802 },
	/*II_66_0F_68*/{ 0x13b, 3802 },
	/*II_0F_69*/{ 0x159, 3825 },
	/*II_66_0F_69*/{ 0x13b, 3825 },
	/*II_0F_6A*/{ 0x159, 3848 },
	/*II_66_0F_6A*/{ 0x13b, 3848 },
	/*II_0F_6B*/{ 0x159, 3871 },
	/*II_66_0F_6B*/{ 0x13b, 3871 },
	/*II_66_0F_6C*/{ 0x13b, 3892 },
	/*II_66_0F_6D*/{ 0x13b, 3917 },
	/*II_0F_6F*/{ 0x15d, 3948 },
	/*II_66_0F_6F*/{ 0x123, 3968 },
	/*II_F3_0F_6F*/{ 0x123, 3976 },
	/*II_0F_74*/{ 0x159, 4065 },
	/*II_66_0F_74*/{ 0x13b, 4065 },
	/*II_0F_75*/{ 0x159, 4084 },
	/*II_66_0F_75*/{ 0x13b, 4084 },
	/*II_0F_76*/{ 0x159, 4103 },
	/*II_66_0F_76*/{ 0x13b, 4103 },
	/*II_0F_77*/{ 0x161, 4122 },
	/*II_0F_78*/{ 0x163, 4150 },
	/*II_0F_79*/{ 0x166, 4174 },
	/*II_66_0F_79*/{ 0x167, 4158 },
	/*II_F2_0F_79*/{ 0x168, 4165 },
	/*II_0F_7A_30*/{ 0x169, 4183 },
	/*II_0F_7A_31*/{ 0x16a, 4193 },
	/*II_66_0F_7C*/{ 0x16b, 4203 },
	/*II_F2_0F_7C*/{ 0x16b, 4211 },
	/*II_66_0F_7D*/{ 0x16b, 4237 },
	/*II_F2_0F_7D*/{ 0x16b, 4245 },
	/*II_F3_0F_7E*/{ 0x125, 3948 },
	/*II_0F_7F*/{ 0x16f, 3948 },
	/*II_66_0F_7F*/{ 0x12b, 3968 },
	/*II_F3_0F_7F*/{ 0x12b, 3976 },
	/*II_F3_0F_B8*/{ 0x173, 4360 },
	/*II_0F_BA_04*/{ 0x174, 872 },
	/*II_0F_BA_05*/{ 0x175, 887 },
	/*II_0F_BA_06*/{ 0x175, 912 },
	/*II_0F_BA_07*/{ 0x175, 934 },
	/*II_0F_BC*/{ 0x176, 4368 },
	/*II_F3_0F_BC*/{ 0x177, 4373 },
	/*II_0F_BD*/{ 0x176, 4380 },
	/*II_F3_0F_BD*/{ 0x178, 4385 },
	/*II_0F_C7_07*/{ 0x188, 6407 },
	/*II_66_0F_D0*/{ 0x16b, 6416 },
	/*II_F2_0F_D0*/{ 0x16b, 6426 },
	/*II_0F_D1*/{ 0x159, 6458 },
	/*II_66_0F_D1*/{ 0x13b, 6458 },
	/*II_0F_D2*/{ 0x159, 6473 },
	/*II_66_0F_D2*/{ 0x13b, 6473 },
	/*II_0F_D3*/{ 0x159, 6488 },
	/*II_66_0F_D3*/{ 0x13b, 6488 },
	/*II_0F_D4*/{ 0x14e, 6503 },
	/*II_66_0F_D4*/{ 0x13b, 6503 },
	/*II_0F_D5*/{ 0x159, 6518 },
	/*II_66_0F_D5*/{ 0x13b, 6518 },
	/*II_66_0F_D6*/{ 0x12d, 3948 },
	/*II_F3_0F_D6*/{ 0x189, 6535 },
	/*II_F2_0F_D6*/{ 0x18a, 6544 },
	/*II_0F_D7*/{ 0x18c, 6553 },
	/*II_66_0F_D7*/{ 0x18d, 6553 },
	/*II_0F_D8*/{ 0x159, 6574 },
	/*II_66_0F_D8*/{ 0x13b, 6574 },
	/*II_0F_D9*/{ 0x159, 6593 },
	/*II_66_0F_D9*/{ 0x13b, 6593 },
	/*II_0F_DA*/{ 0x18f, 6612 },
	/*II_66_0F_DA*/{ 0x13b, 6612 },
	/*II_0F_DB*/{ 0x159, 6629 },
	/*II_66_0F_DB*/{ 0x13b, 6629 },
	/*II_0F_DC*/{ 0x159, 6642 },
	/*II_66_0F_DC*/{ 0x13b, 6642 },
	/*II_0F_DD*/{ 0x159, 6661 },
	/*II_66_0F_DD*/{ 0x13b, 6661 },
	/*II_0F_DE*/{ 0x18f, 6670 },
	/*II_66_0F_DE*/{ 0x13b, 6670 },
	/*II_0F_DF*/{ 0x159, 6687 },
	/*II_66_0F_DF*/{ 0x13b, 6687 },
	/*II_0F_E0*/{ 0x18f, 6702 },
	/*II_66_0F_E0*/{ 0x13b, 6702 },
	/*II_0F_E1*/{ 0x159, 6717 },
	/*II_66_0F_E1*/{ 0x13b, 6717 },
	/*II_0F_E2*/{ 0x159, 6732 },
	/*II_66_0F_E2*/{ 0x13b, 6732 },
	/*II_0F_E3*/{ 0x18f, 6747 },
	/*II_66_0F_E3*/{ 0x13b, 6747 },
	/*II_0F_E4*/{ 0x18f, 6762 },
	/*II_66_0F_E4*/{ 0x13b, 6762 },
	/*II_0F_E5*/{ 0x159, 6781 },
	/*II_66_0F_E5*/{ 0x13b, 6781 },
	/*II_66_0F_E6*/{ 0x13b, 6798 },
	/*II_F3_0F_E6*/{ 0x14e, 6809 },
	/*II_F2_0F_E6*/{ 0x13b, 6819 },
	/*II_0F_E7*/{ 0x190, 6863 },
	/*II_66_0F_E7*/{ 0x144, 6871 },
	/*II_0F_E8*/{ 0x159, 6890 },
	/*II_66_0F_E8*/{ 0x13b, 6890 },
	/*II_0F_E9*/{ 0x159, 6907 },
	/*II_66_0F_E9*/{ 0x13b, 6907 },
	/*II_0F_EA*/{ 0x18f, 6924 },
	/*II_66_0F_EA*/{ 0x13b, 6924 },
	/*II_0F_EB*/{ 0x159, 6941 },
	/*II_66_0F_EB*/{ 0x13b, 6941 },
	/*II_0F_EC*/{ 0x159, 6952 },
	/*II_66_0F_EC*/{ 0x13b, 6952 },
	/*II_0F_ED*/{ 0x159, 6969 },
	/*II_66_0F_ED*/{ 0x13b, 6969 },
	/*II_0F_EE*/{ 0x18f, 6986 },
	/*II_66_0F_EE*/{ 0x13b, 6986 },
	/*II_0F_EF*/{ 0x159, 7003 },
	/*II_66_0F_EF*/{ 0x13b, 7003 },
	/*II_F2_0F_F0*/{ 0x191, 7016 },
	/*II_0F_F1*/{ 0x159, 7031 },
	/*II_66_0F_F1*/{ 0x13b, 7031 },
	/*II_0F_F2*/{ 0x159, 7046 },
	/*II_66_0F_F2*/{ 0x13b, 7046 },
	/*II_0F_F3*/{ 0x159, 7061 },
	/*II_66_0F_F3*/{ 0x13b, 7061 },
	/*II_0F_F4*/{ 0x193, 7076 },
	/*II_66_0F_F4*/{ 0x13b, 7076 },
	/*II_0F_F5*/{ 0x159, 7095 },
	/*II_66_0F_F5*/{ 0x13b, 7095 },
	/*II_0F_F6*/{ 0x18f, 7114 },
	/*II_66_0F_F6*/{ 0x13b, 7114 },
	/*II_0F_F7*/{ 0x194, 7131 },
	/*II_66_0F_F7*/{ 0x195, 7141 },
	/*II_0F_F8*/{ 0x159, 7166 },
	/*II_66_0F_F8*/{ 0x13b, 7166 },
	/*II_0F_F9*/{ 0x159, 7181 },
	/*II_66_0F_F9*/{ 0x13b, 7181 },
	/*II_0F_FA*/{ 0x159, 7196 },
	/*II_66_0F_FA*/{ 0x13b, 7196 },
	/*II_0F_FB*/{ 0x193, 7211 },
	/*II_66_0F_FB*/{ 0x13b, 7211 },
	/*II_0F_FC*/{ 0x159, 7226 },
	/*II_66_0F_FC*/{ 0x13b, 7226 },
	/*II_0F_FD*/{ 0x159, 7241 },
	/*II_66_0F_FD*/{ 0x13b, 7241 },
	/*II_0F_FE*/{ 0x159, 7256 },
	/*II_66_0F_FE*/{ 0x13b, 7256 },
	/*II_D9_06*/{ 0x197, 7271 },
	/*II_9B_D9_06*/{ 0x198, 7280 },
	/*II_D9_07*/{ 0xfd, 7288 },
	/*II_9B_D9_07*/{ 0x199, 7296 },
	/*II_DB_E2*/{ 0xeb, 7303 },
	/*II_9B_DB_E2*/{ 0x19a, 7311 },
	/*II_DB_E3*/{ 0xeb, 7318 },
	/*II_9B_DB_E3*/{ 0x19a, 7326 },
	/*II_DD_06*/{ 0x197, 7333 },
	/*II_9B_DD_06*/{ 0x198, 7341 },
	/*II_DD_07*/{ 0xfd, 7348 },
	/*II_9B_DD_07*/{ 0x199, 7356 },
	/*II_DF_E0*/{ 0x19b, 7348 },
	/*II_9B_DF_E0*/{ 0x19c, 7356 },
	/*II_0F_38_00*/{ 0x19d, 7363 },
	/*II_66_0F_38_00*/{ 0x19e, 7363 },
	/*II_0F_38_01*/{ 0x19d, 7380 },
	/*II_66_0F_38_01*/{ 0x19e, 7380 },
	/*II_0F_38_02*/{ 0x19d, 7397 },
	/*II_66_0F_38_02*/{ 0x19e, 7397 },
	/*II_0F_38_03*/{ 0x19d, 7414 },
	/*II_66_0F_38_03*/{ 0x19e, 7414 },
	/*II_0F_38_04*/{ 0x19d, 7433 },
	/*II_66_0F_38_04*/{ 0x19e, 7433 },
	/*II_0F_38_05*/{ 0x19d, 7456 },
	/*II_66_0F_38_05*/{ 0x19e, 7456 },
	/*II_0F_38_06*/{ 0x19d, 7473 },
	/*II_66_0F_38_06*/{ 0x19e, 7473 },
	/*II_0F_38_07*/{ 0x19d, 7490 },
	/*II_66_0F_38_07*/{ 0x19e, 7490 },
	/*II_0F_38_08*/{ 0x19d, 7509 },
	/*II_66_0F_38_08*/{ 0x19e, 7509 },
	/*II_0F_38_09*/{ 0x19d, 7526 },
	/*II_66_0F_38_09*/{ 0x19e, 7526 },
	/*II_0F_38_0A*/{ 0x19d, 7543 },
	/*II_66_0F_38_0A*/{ 0x19e, 7543 },
	/*II_0F_38_0B*/{ 0x19d, 7560 },
	/*II_66_0F_38_0B*/{ 0x19e, 7560 },
	/*II_66_0F_38_17*/{ 0x1a0, 7651 },
	/*II_0F_38_1C*/{ 0x19d, 7710 },
	/*II_66_0F_38_1C*/{ 0x19e, 7710 },
	/*II_0F_38_1D*/{ 0x19d, 7725 },
	/*II_66_0F_38_1D*/{ 0x19e, 7725 },
	/*II_0F_38_1E*/{ 0x19d, 7740 },
	/*II_66_0F_38_1E*/{ 0x19e, 7740 },
	/*II_66_0F_38_20*/{ 0x1a5, 7755 },
	/*II_66_0F_38_21*/{ 0x1a6, 7776 },
	/*II_66_0F_38_22*/{ 0x1a7, 7797 },
	/*II_66_0F_38_23*/{ 0x1a5, 7818 },
	/*II_66_0F_38_24*/{ 0x1a6, 7839 },
	/*II_66_0F_38_25*/{ 0x1a5, 7860 },
	/*II_66_0F_38_28*/{ 0x1a9, 7881 },
	/*II_66_0F_38_29*/{ 0x1a9, 7898 },
	/*II_66_0F_38_2A*/{ 0x1aa, 7917 },
	/*II_66_0F_38_2B*/{ 0x1a9, 7938 },
	/*II_66_0F_38_30*/{ 0x1a5, 7983 },
	/*II_66_0F_38_31*/{ 0x1a6, 8004 },
	/*II_66_0F_38_32*/{ 0x1a7, 8025 },
	/*II_66_0F_38_33*/{ 0x1a5, 8046 },
	/*II_66_0F_38_34*/{ 0x1a6, 8067 },
	/*II_66_0F_38_35*/{ 0x1a5, 8088 },
	/*II_66_0F_38_37*/{ 0x1a0, 8109 },
	/*II_66_0F_38_38*/{ 0x1a9, 8128 },
	/*II_66_0F_38_39*/{ 0x1a9, 8145 },
	/*II_66_0F_38_3A*/{ 0x1a9, 8162 },
	/*II_66_0F_38_3B*/{ 0x1a9, 8179 },
	/*II_66_0F_38_3C*/{ 0x1a9, 8196 },
	/*II_66_0F_38_3D*/{ 0x1a9, 8213 },
	/*II_66_0F_38_3E*/{ 0x1a9, 8230 },
	/*II_66_0F_38_3F*/{ 0x1a9, 8247 },
	/*II_66_0F_38_40*/{ 0x1a9, 8264 },
	/*II_66_0F_38_41*/{ 0x1a9, 8281 },
	/*II_66_0F_38_80*/{ 0x1ad, 8306 },
	/*II_66_0F_38_81*/{ 0x1ad, 8314 },
	/*II_66_0F_38_82*/{ 0x1ad, 8323 },
	/*II_66_0F_38_DB*/{ 0x1b0, 9172 },
	/*II_66_0F_38_DC*/{ 0x1b0, 9189 },
	/*II_66_0F_38_DD*/{ 0x1b0, 9206 },
	/*II_66_0F_38_DE*/{ 0x1b0, 9231 },
	/*II_66_0F_38_DF*/{ 0x1b0, 9248 },
	/*II_0F_38_F0*/{ 0x1b3, 9273 },
	/*II_F2_0F_38_F0*/{ 0x1b4, 9280 },
	/*II_0F_38_F1*/{ 0x1b5, 9273 },
	/*II_F2_0F_38_F1*/{ 0x1b6, 9280 },
	/*II_0F_71_02*/{ 0x1cd, 6458 },
	/*II_66_0F_71_02*/{ 0x1ce, 6458 },
	/*II_0F_71_04*/{ 0x1cd, 6717 },
	/*II_66_0F_71_04*/{ 0x1ce, 6717 },
	/*II_0F_71_06*/{ 0x1cd, 7031 },
	/*II_66_0F_71_06*/{ 0x1ce, 7031 },
	/*II_0F_72_02*/{ 0x1cd, 6473 },
	/*II_66_0F_72_02*/{ 0x1ce, 6473 },
	/*II_0F_72_04*/{ 0x1cd, 6732 },
	/*II_66_0F_72_04*/{ 0x1ce, 6732 },
	/*II_0F_72_06*/{ 0x1cd, 7046 },
	/*II_66_0F_72_06*/{ 0x1ce, 7046 },
	/*II_0F_73_02*/{ 0x1cd, 6488 },
	/*II_66_0F_73_02*/{ 0x1ce, 6488 },
	/*II_66_0F_73_03*/{ 0x1ce, 9852 },
	/*II_0F_73_06*/{ 0x1cd, 7061 },
	/*II_66_0F_73_06*/{ 0x1ce, 7061 },
	/*II_66_0F_73_07*/{ 0x1ce, 9869 },
	/*II_F3_0F_AE_00*/{ 0x1d0, 9904 },
	/*II_F3_0F_AE_01*/{ 0x1d0, 9934 },
	/*II_0F_AE_02*/{ 0x116, 9944 },
	/*II_F3_0F_AE_02*/{ 0x1d0, 9953 },
	/*II_0F_AE_03*/{ 0x116, 9973 },
	/*II_F3_0F_AE_03*/{ 0x1d0, 9982 },
	/*II_0F_C7_06*/{ 0x1d2, 10002 },
	/*II_66_0F_C7_06*/{ 0x188, 10011 },
	/*II_F3_0F_C7_06*/{ 0x188, 10020 }
};

_InstInfoEx InstInfosEx[381] = {
	/*II_69*/{ { 0x34, 117 }, 0x0, 3, 0, 0, 0 },
	/*II_6B*/{ { 0x34, 117 }, 0x0, 5, 0, 0, 0 },
	/*II_98*/{ { 0x4e, 228 }, 0x0, 0, 0, 233, 239 },
	/*II_99*/{ { 0x4e, 245 }, 0x0, 0, 0, 250, 255 },
	/*II_E3*/{ { 0x76, 427 }, 0x0, 0, 0, 433, 440 },
	/*II_0F_A4*/{ { 0xac, 876 }, 0x0, 1, 0, 0, 0 },
	/*II_0F_A5*/{ { 0xac, 876 }, 0x0, 52, 0, 0, 0 },
	/*II_0F_AC*/{ { 0xac, 892 }, 0x0, 1, 0, 0, 0 },
	/*II_0F_AD*/{ { 0xac, 892 }, 0x0, 52, 0, 0, 0 },
	/*II_V_0F_10*/{ { 0x126, 2139 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_10*/{ { 0x126, 2148 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_10*/{ { 0x127, 2157 }, 0x20, 69, 0, 0, 0 },
	/*II_V_F2_0F_10*/{ { 0x127, 2165 }, 0x20, 69, 0, 0, 0 },
	/*II_VRR_F3_0F_10*/{ { 0x128, 2157 }, 0x60, 0, 0, 0, 0 },
	/*II_VRR_F2_0F_10*/{ { 0x129, 2165 }, 0x60, 0, 0, 0, 0 },
	/*II_V_0F_11*/{ { 0x12e, 2139 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_11*/{ { 0x12e, 2148 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_11*/{ { 0x127, 2157 }, 0x20, 69, 0, 0, 0 },
	/*II_V_F2_0F_11*/{ { 0x127, 2165 }, 0x20, 69, 0, 0, 0 },
	/*II_VRR_F3_0F_11*/{ { 0x12f, 2157 }, 0x60, 0, 0, 0, 0 },
	/*II_VRR_F2_0F_11*/{ { 0x130, 2165 }, 0x60, 0, 0, 0, 0 },
	/*II_0F_12*/{ { 0x131, 2173 }, 0x0, 0, 0, 2182, 0 },
	/*II_V_0F_12*/{ { 0x134, 2217 }, 0x0, 72, 0, 2227, 0 },
	/*II_V_66_0F_12*/{ { 0x135, 2236 }, 0x0, 46, 0, 0, 0 },
	/*II_V_F3_0F_12*/{ { 0x126, 2245 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F2_0F_12*/{ { 0x136, 2256 }, 0x41, 0, 0, 0, 0 },
	/*II_V_0F_13*/{ { 0x139, 2227 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_13*/{ { 0x139, 2236 }, 0x40, 0, 0, 0, 0 },
	/*II_V_0F_14*/{ { 0x13c, 2286 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_14*/{ { 0x13c, 2297 }, 0x1, 90, 0, 0, 0 },
	/*II_V_0F_15*/{ { 0x13c, 2328 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_15*/{ { 0x13c, 2339 }, 0x1, 90, 0, 0, 0 },
	/*II_0F_16*/{ { 0x131, 2350 }, 0x0, 0, 0, 2359, 0 },
	/*II_V_0F_16*/{ { 0x134, 2385 }, 0x0, 72, 0, 2395, 0 },
	/*II_V_66_0F_16*/{ { 0x135, 2404 }, 0x0, 46, 0, 0, 0 },
	/*II_V_F3_0F_16*/{ { 0x126, 2413 }, 0x41, 0, 0, 0, 0 },
	/*II_V_0F_17*/{ { 0x139, 2395 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_17*/{ { 0x139, 2404 }, 0x40, 0, 0, 0, 0 },
	/*II_V_0F_28*/{ { 0x126, 2489 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_28*/{ { 0x126, 2498 }, 0x41, 0, 0, 0, 0 },
	/*II_V_0F_29*/{ { 0x12e, 2489 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_29*/{ { 0x12e, 2498 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_2A*/{ { 0x135, 2547 }, 0x2, 79, 0, 0, 0 },
	/*II_V_F2_0F_2A*/{ { 0x135, 2558 }, 0x2, 79, 0, 0, 0 },
	/*II_V_0F_2B*/{ { 0x147, 2605 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_2B*/{ { 0x147, 2615 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_2C*/{ { 0x14c, 2669 }, 0x42, 0, 0, 0, 0 },
	/*II_V_F2_0F_2C*/{ { 0x14c, 2681 }, 0x42, 0, 0, 0, 0 },
	/*II_V_F3_0F_2D*/{ { 0x14c, 2733 }, 0x42, 0, 0, 0, 0 },
	/*II_V_F2_0F_2D*/{ { 0x14c, 2744 }, 0x42, 0, 0, 0, 0 },
	/*II_V_0F_2E*/{ { 0x14f, 2773 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_2E*/{ { 0x150, 2783 }, 0x40, 0, 0, 0, 0 },
	/*II_V_0F_2F*/{ { 0x14f, 2809 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_2F*/{ { 0x150, 2818 }, 0x40, 0, 0, 0, 0 },
	/*II_V_0F_50*/{ { 0x153, 2847 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_50*/{ { 0x153, 2858 }, 0x41, 0, 0, 0, 0 },
	/*II_V_0F_51*/{ { 0x126, 2901 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_51*/{ { 0x126, 2910 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_51*/{ { 0x135, 2919 }, 0x0, 71, 0, 0, 0 },
	/*II_V_F2_0F_51*/{ { 0x135, 2928 }, 0x0, 72, 0, 0, 0 },
	/*II_V_0F_52*/{ { 0x126, 2955 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_52*/{ { 0x135, 2965 }, 0x0, 71, 0, 0, 0 },
	/*II_V_0F_53*/{ { 0x126, 2989 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_53*/{ { 0x135, 2997 }, 0x0, 71, 0, 0, 0 },
	/*II_V_0F_54*/{ { 0x13c, 3019 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_54*/{ { 0x13c, 3027 }, 0x1, 90, 0, 0, 0 },
	/*II_V_0F_55*/{ { 0x13c, 3051 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_55*/{ { 0x13c, 3060 }, 0x1, 90, 0, 0, 0 },
	/*II_V_0F_56*/{ { 0x13c, 3081 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_56*/{ { 0x13c, 3088 }, 0x1, 90, 0, 0, 0 },
	/*II_V_0F_57*/{ { 0x13c, 3109 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_57*/{ { 0x13c, 3117 }, 0x1, 90, 0, 0, 0 },
	/*II_V_0F_58*/{ { 0x13c, 3153 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_58*/{ { 0x13c, 3161 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F3_0F_58*/{ { 0x135, 3169 }, 0x0, 71, 0, 0, 0 },
	/*II_V_F2_0F_58*/{ { 0x135, 3177 }, 0x0, 72, 0, 0, 0 },
	/*II_V_0F_59*/{ { 0x13c, 3213 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_59*/{ { 0x13c, 3221 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F3_0F_59*/{ { 0x135, 3229 }, 0x0, 71, 0, 0, 0 },
	/*II_V_F2_0F_59*/{ { 0x135, 3237 }, 0x0, 72, 0, 0, 0 },
	/*II_V_0F_5A*/{ { 0x156, 3285 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_5A*/{ { 0x157, 3296 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_5A*/{ { 0x135, 3307 }, 0x0, 71, 0, 0, 0 },
	/*II_V_F2_0F_5A*/{ { 0x135, 3318 }, 0x0, 72, 0, 0, 0 },
	/*II_V_0F_5B*/{ { 0x126, 3360 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_5B*/{ { 0x126, 3371 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_5B*/{ { 0x126, 3382 }, 0x41, 0, 0, 0, 0 },
	/*II_V_0F_5C*/{ { 0x13c, 3422 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_5C*/{ { 0x13c, 3430 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F3_0F_5C*/{ { 0x135, 3438 }, 0x0, 71, 0, 0, 0 },
	/*II_V_F2_0F_5C*/{ { 0x135, 3446 }, 0x0, 72, 0, 0, 0 },
	/*II_V_0F_5D*/{ { 0x13c, 3482 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_5D*/{ { 0x13c, 3490 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F3_0F_5D*/{ { 0x135, 3498 }, 0x0, 71, 0, 0, 0 },
	/*II_V_F2_0F_5D*/{ { 0x135, 3506 }, 0x0, 72, 0, 0, 0 },
	/*II_V_0F_5E*/{ { 0x13c, 3542 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_5E*/{ { 0x13c, 3550 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F3_0F_5E*/{ { 0x135, 3558 }, 0x0, 71, 0, 0, 0 },
	/*II_V_F2_0F_5E*/{ { 0x135, 3566 }, 0x0, 72, 0, 0, 0 },
	/*II_V_0F_5F*/{ { 0x13c, 3602 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_5F*/{ { 0x13c, 3610 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F3_0F_5F*/{ { 0x135, 3618 }, 0x0, 71, 0, 0, 0 },
	/*II_V_F2_0F_5F*/{ { 0x135, 3626 }, 0x0, 72, 0, 0, 0 },
	/*II_V_66_0F_60*/{ { 0x135, 3645 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_61*/{ { 0x135, 3668 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_62*/{ { 0x135, 3691 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_63*/{ { 0x135, 3713 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_64*/{ { 0x135, 3733 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_65*/{ { 0x135, 3752 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_66*/{ { 0x135, 3771 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_67*/{ { 0x135, 3791 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_68*/{ { 0x135, 3813 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_69*/{ { 0x135, 3836 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_6A*/{ { 0x135, 3859 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_6B*/{ { 0x135, 3881 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_6C*/{ { 0x135, 3904 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_6D*/{ { 0x135, 3929 }, 0x0, 73, 0, 0, 0 },
	/*II_0F_6E*/{ { 0x15a, 3942 }, 0x0, 0, 0, 0, 3948 },
	/*II_66_0F_6E*/{ { 0x15b, 3942 }, 0x0, 0, 0, 0, 3948 },
	/*II_V_66_0F_6E*/{ { 0x15c, 3954 }, 0x46, 0, 0, 3961, 0 },
	/*II_V_66_0F_6F*/{ { 0x126, 3984 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_6F*/{ { 0x126, 3993 }, 0x41, 0, 0, 0, 0 },
	/*II_0F_70*/{ { 0x15e, 4002 }, 0x0, 1, 0, 0, 0 },
	/*II_66_0F_70*/{ { 0x15f, 4010 }, 0x0, 1, 0, 0, 0 },
	/*II_F3_0F_70*/{ { 0x15f, 4018 }, 0x0, 1, 0, 0, 0 },
	/*II_F2_0F_70*/{ { 0x15f, 4027 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_70*/{ { 0x160, 4036 }, 0x40, 1, 0, 0, 0 },
	/*II_V_F3_0F_70*/{ { 0x160, 4045 }, 0x40, 1, 0, 0, 0 },
	/*II_V_F2_0F_70*/{ { 0x160, 4055 }, 0x40, 1, 0, 0, 0 },
	/*II_V_66_0F_74*/{ { 0x135, 4074 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_75*/{ { 0x135, 4093 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_76*/{ { 0x135, 4112 }, 0x0, 73, 0, 0, 0 },
	/*II_V_0F_77*/{ { 0x162, 4128 }, 0x49, 0, 0, 4140, 0 },
	/*II_66_0F_78*/{ { 0x164, 4158 }, 0x0, 8, 0, 0, 0 },
	/*II_F2_0F_78*/{ { 0x165, 4165 }, 0x0, 7, 8, 0, 0 },
	/*II_V_66_0F_7C*/{ { 0x13c, 4219 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F2_0F_7C*/{ { 0x13c, 4228 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_7D*/{ { 0x13c, 4253 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F2_0F_7D*/{ { 0x13c, 4262 }, 0x1, 90, 0, 0, 0 },
	/*II_0F_7E*/{ { 0x16c, 3942 }, 0x0, 0, 0, 0, 3948 },
	/*II_66_0F_7E*/{ { 0x16d, 3942 }, 0x0, 0, 0, 0, 3948 },
	/*II_V_66_0F_7E*/{ { 0x16e, 3954 }, 0x46, 0, 0, 3961, 0 },
	/*II_V_F3_0F_7E*/{ { 0x150, 3961 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_7F*/{ { 0x12e, 3984 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_7F*/{ { 0x12e, 3993 }, 0x41, 0, 0, 0, 0 },
	/*II_0F_AE_04*/{ { 0x170, 4271 }, 0x0, 0, 0, 0, 4278 },
	/*II_0F_AE_05*/{ { 0x171, 4287 }, 0x0, 0, 0, 4295, 4303 },
	/*II_0F_AE_06*/{ { 0x171, 4313 }, 0x0, 0, 0, 4321, 4331 },
	/*II_0F_AE_07*/{ { 0x172, 4343 }, 0x0, 0, 0, 4351, 0 },
	/*II_0F_C2*/{ { 0x179, 4392 }, 0x0, 0, 0, 4401, 4410 },
	/*II_66_0F_C2*/{ { 0x17a, 4471 }, 0x0, 0, 0, 4480, 4489 },
	/*II_F3_0F_C2*/{ { 0x17b, 4550 }, 0x0, 0, 0, 4559, 4568 },
	/*II_F2_0F_C2*/{ { 0x17c, 4629 }, 0x0, 0, 0, 4638, 4647 },
	/*II_V_0F_C2*/{ { 0x17d, 4708 }, 0x1, 90, 0, 4718, 4728 },
	/*II_V_66_0F_C2*/{ { 0x17d, 5110 }, 0x1, 90, 0, 5120, 5130 },
	/*II_V_F3_0F_C2*/{ { 0x17e, 5512 }, 0x0, 71, 0, 5522, 5532 },
	/*II_V_F2_0F_C2*/{ { 0x17e, 5914 }, 0x0, 72, 0, 5924, 5934 },
	/*II_0F_C4*/{ { 0x17f, 6316 }, 0x0, 1, 0, 0, 0 },
	/*II_66_0F_C4*/{ { 0x180, 6316 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_C4*/{ { 0x181, 6324 }, 0x0, 25, 1, 0, 0 },
	/*II_0F_C5*/{ { 0x182, 6333 }, 0x0, 1, 0, 0, 0 },
	/*II_66_0F_C5*/{ { 0x183, 6333 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_C5*/{ { 0x184, 6341 }, 0x40, 1, 0, 0, 0 },
	/*II_0F_C6*/{ { 0x185, 6350 }, 0x0, 1, 0, 0, 0 },
	/*II_66_0F_C6*/{ { 0x15f, 6358 }, 0x0, 1, 0, 0, 0 },
	/*II_V_0F_C6*/{ { 0x186, 6366 }, 0x1, 90, 1, 0, 0 },
	/*II_V_66_0F_C6*/{ { 0x186, 6375 }, 0x1, 90, 1, 0, 0 },
	/*II_0F_C7_01*/{ { 0x187, 6384 }, 0x0, 0, 0, 0, 6395 },
	/*II_V_66_0F_D0*/{ { 0x13c, 6436 }, 0x1, 90, 0, 0, 0 },
	/*II_V_F2_0F_D0*/{ { 0x13c, 6447 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_D1*/{ { 0x135, 6465 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_D2*/{ { 0x135, 6480 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_D3*/{ { 0x135, 6495 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_D4*/{ { 0x135, 6510 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_D5*/{ { 0x135, 6526 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_D6*/{ { 0x18b, 3961 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_D7*/{ { 0x18e, 6563 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_D8*/{ { 0x135, 6583 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_D9*/{ { 0x135, 6602 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_DA*/{ { 0x135, 6620 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_DB*/{ { 0x135, 6635 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_DC*/{ { 0x135, 6651 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_DD*/{ { 0x135, 6651 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_DE*/{ { 0x135, 6678 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_DF*/{ { 0x135, 6694 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_E0*/{ { 0x135, 6709 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_E1*/{ { 0x135, 6724 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_E2*/{ { 0x135, 6739 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_E3*/{ { 0x135, 6754 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_E4*/{ { 0x135, 6771 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_E5*/{ { 0x135, 6789 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_E6*/{ { 0x157, 6829 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F3_0F_E6*/{ { 0x156, 6841 }, 0x41, 0, 0, 0, 0 },
	/*II_V_F2_0F_E6*/{ { 0x157, 6852 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_E7*/{ { 0x147, 6880 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_E8*/{ { 0x135, 6898 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_E9*/{ { 0x135, 6915 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_EA*/{ { 0x135, 6932 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_EB*/{ { 0x135, 6946 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_EC*/{ { 0x135, 6960 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_ED*/{ { 0x135, 6977 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_EE*/{ { 0x135, 6994 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_EF*/{ { 0x135, 7009 }, 0x0, 73, 0, 0, 0 },
	/*II_V_F2_0F_F0*/{ { 0x192, 7023 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_F1*/{ { 0x135, 7038 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_F2*/{ { 0x135, 7053 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_F3*/{ { 0x135, 7068 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_F4*/{ { 0x135, 7085 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_F5*/{ { 0x135, 7104 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_F6*/{ { 0x135, 7122 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_F7*/{ { 0x196, 7153 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_F8*/{ { 0x135, 7173 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_F9*/{ { 0x135, 7188 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_FA*/{ { 0x135, 7203 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_FB*/{ { 0x135, 7218 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_FC*/{ { 0x135, 7233 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_FD*/{ { 0x135, 7248 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_FE*/{ { 0x135, 7263 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_00*/{ { 0x135, 7371 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_01*/{ { 0x135, 7388 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_02*/{ { 0x135, 7405 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_03*/{ { 0x135, 7423 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_04*/{ { 0x135, 7444 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_05*/{ { 0x135, 7464 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_06*/{ { 0x135, 7481 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_07*/{ { 0x135, 7499 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_08*/{ { 0x135, 7517 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_09*/{ { 0x135, 7534 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_0A*/{ { 0x135, 7551 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_0B*/{ { 0x135, 7570 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_0C*/{ { 0x13c, 7581 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_38_0D*/{ { 0x13c, 7592 }, 0x1, 90, 0, 0, 0 },
	/*II_V_66_0F_38_0E*/{ { 0x126, 7603 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_38_0F*/{ { 0x126, 7612 }, 0x41, 0, 0, 0, 0 },
	/*II_66_0F_38_10*/{ { 0x19f, 7621 }, 0x0, 74, 0, 0, 0 },
	/*II_66_0F_38_14*/{ { 0x19f, 7631 }, 0x0, 74, 0, 0, 0 },
	/*II_66_0F_38_15*/{ { 0x19f, 7641 }, 0x0, 74, 0, 0, 0 },
	/*II_V_66_0F_38_17*/{ { 0x126, 7658 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_38_18*/{ { 0x1a1, 7666 }, 0x41, 0, 0, 0, 0 },
	/*II_V_66_0F_38_19*/{ { 0x1a2, 7680 }, 0x50, 0, 0, 0, 0 },
	/*II_V_66_0F_38_1A*/{ { 0x1a3, 7694 }, 0x50, 0, 0, 0, 0 },
	/*II_V_66_0F_38_1C*/{ { 0x1a4, 7717 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_1D*/{ { 0x1a4, 7732 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_1E*/{ { 0x1a4, 7747 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_20*/{ { 0x150, 7765 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_21*/{ { 0x14f, 7786 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_22*/{ { 0x1a8, 7807 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_23*/{ { 0x150, 7828 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_24*/{ { 0x14f, 7849 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_25*/{ { 0x150, 7870 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_28*/{ { 0x135, 7889 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_29*/{ { 0x135, 7907 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_2A*/{ { 0x1ab, 7927 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_2B*/{ { 0x135, 7948 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_2C*/{ { 0x13c, 7959 }, 0x1, 92, 0, 0, 0 },
	/*II_V_66_0F_38_2D*/{ { 0x13c, 7971 }, 0x1, 92, 0, 0, 0 },
	/*II_V_66_0F_38_2E*/{ { 0x1ac, 7959 }, 0x1, 83, 0, 0, 0 },
	/*II_V_66_0F_38_2F*/{ { 0x1ac, 7971 }, 0x1, 83, 0, 0, 0 },
	/*II_V_66_0F_38_30*/{ { 0x150, 7993 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_31*/{ { 0x14f, 8014 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_32*/{ { 0x1a8, 8035 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_33*/{ { 0x150, 8056 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_34*/{ { 0x14f, 8077 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_35*/{ { 0x150, 8098 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_37*/{ { 0x135, 8118 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_38*/{ { 0x135, 8136 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_39*/{ { 0x135, 8153 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_3A*/{ { 0x135, 8170 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_3B*/{ { 0x135, 8187 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_3C*/{ { 0x135, 8204 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_3D*/{ { 0x135, 8221 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_3E*/{ { 0x135, 8238 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_3F*/{ { 0x135, 8255 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_40*/{ { 0x135, 8272 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_41*/{ { 0x1a4, 8293 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_96*/{ { 0x1ae, 8332 }, 0x7, 90, 0, 8348, 0 },
	/*II_V_66_0F_38_97*/{ { 0x1ae, 8364 }, 0x7, 90, 0, 8380, 0 },
	/*II_V_66_0F_38_98*/{ { 0x1ae, 8396 }, 0x7, 90, 0, 8409, 0 },
	/*II_V_66_0F_38_99*/{ { 0x1af, 8422 }, 0x6, 80, 0, 8435, 0 },
	/*II_V_66_0F_38_9A*/{ { 0x1ae, 8448 }, 0x7, 90, 0, 8461, 0 },
	/*II_V_66_0F_38_9B*/{ { 0x1af, 8474 }, 0x6, 80, 0, 8487, 0 },
	/*II_V_66_0F_38_9C*/{ { 0x1ae, 8500 }, 0x7, 90, 0, 8514, 0 },
	/*II_V_66_0F_38_9D*/{ { 0x1af, 8528 }, 0x6, 80, 0, 8542, 0 },
	/*II_V_66_0F_38_9E*/{ { 0x1ae, 8556 }, 0x7, 90, 0, 8570, 0 },
	/*II_V_66_0F_38_9F*/{ { 0x1af, 8584 }, 0x6, 80, 0, 8598, 0 },
	/*II_V_66_0F_38_A6*/{ { 0x1ae, 8612 }, 0x7, 90, 0, 8628, 0 },
	/*II_V_66_0F_38_A7*/{ { 0x1ae, 8644 }, 0x7, 90, 0, 8660, 0 },
	/*II_V_66_0F_38_A8*/{ { 0x1ae, 8676 }, 0x7, 90, 0, 8689, 0 },
	/*II_V_66_0F_38_A9*/{ { 0x1af, 8702 }, 0x6, 80, 0, 8715, 0 },
	/*II_V_66_0F_38_AA*/{ { 0x1ae, 8728 }, 0x7, 90, 0, 8741, 0 },
	/*II_V_66_0F_38_AB*/{ { 0x1af, 8754 }, 0x6, 80, 0, 8767, 0 },
	/*II_V_66_0F_38_AC*/{ { 0x1ae, 8780 }, 0x7, 90, 0, 8794, 0 },
	/*II_V_66_0F_38_AD*/{ { 0x1af, 8808 }, 0x6, 80, 0, 8822, 0 },
	/*II_V_66_0F_38_AE*/{ { 0x1ae, 8836 }, 0x7, 90, 0, 8850, 0 },
	/*II_V_66_0F_38_AF*/{ { 0x1af, 8864 }, 0x6, 80, 0, 8878, 0 },
	/*II_V_66_0F_38_B6*/{ { 0x1ae, 8892 }, 0x7, 90, 0, 8908, 0 },
	/*II_V_66_0F_38_B7*/{ { 0x1ae, 8924 }, 0x7, 90, 0, 8940, 0 },
	/*II_V_66_0F_38_B8*/{ { 0x1ae, 8956 }, 0x7, 90, 0, 8969, 0 },
	/*II_V_66_0F_38_B9*/{ { 0x1af, 8982 }, 0x6, 80, 0, 8995, 0 },
	/*II_V_66_0F_38_BA*/{ { 0x1ae, 9008 }, 0x7, 90, 0, 9021, 0 },
	/*II_V_66_0F_38_BB*/{ { 0x1af, 9034 }, 0x6, 80, 0, 9047, 0 },
	/*II_V_66_0F_38_BC*/{ { 0x1ae, 9060 }, 0x7, 90, 0, 9074, 0 },
	/*II_V_66_0F_38_BD*/{ { 0x1af, 9088 }, 0x6, 80, 0, 9102, 0 },
	/*II_V_66_0F_38_BE*/{ { 0x1ae, 9116 }, 0x7, 90, 0, 9130, 0 },
	/*II_V_66_0F_38_BF*/{ { 0x1af, 9144 }, 0x6, 80, 0, 9158, 0 },
	/*II_V_66_0F_38_DB*/{ { 0x1b1, 9180 }, 0x40, 0, 0, 0, 0 },
	/*II_V_66_0F_38_DC*/{ { 0x1b2, 9197 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_DD*/{ { 0x1b2, 9218 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_DE*/{ { 0x1b2, 9239 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_38_DF*/{ { 0x1b2, 9260 }, 0x0, 73, 0, 0, 0 },
	/*II_V_66_0F_3A_04*/{ { 0x1b7, 7581 }, 0x41, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_05*/{ { 0x1b7, 7592 }, 0x41, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_06*/{ { 0x1b8, 9287 }, 0x10, 86, 1, 0, 0 },
	/*II_66_0F_3A_08*/{ { 0x19f, 9299 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_08*/{ { 0x1b7, 9308 }, 0x41, 1, 0, 0, 0 },
	/*II_66_0F_3A_09*/{ { 0x19f, 9318 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_09*/{ { 0x1b7, 9327 }, 0x41, 1, 0, 0, 0 },
	/*II_66_0F_3A_0A*/{ { 0x1b9, 9337 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_0A*/{ { 0x181, 9346 }, 0x0, 71, 1, 0, 0 },
	/*II_66_0F_3A_0B*/{ { 0x1ba, 9356 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_0B*/{ { 0x181, 9365 }, 0x0, 72, 1, 0, 0 },
	/*II_66_0F_3A_0C*/{ { 0x19f, 9375 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_0C*/{ { 0x186, 9384 }, 0x1, 90, 1, 0, 0 },
	/*II_66_0F_3A_0D*/{ { 0x19f, 9394 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_0D*/{ { 0x186, 9403 }, 0x1, 90, 1, 0, 0 },
	/*II_66_0F_3A_0E*/{ { 0x19f, 9413 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_0E*/{ { 0x181, 9422 }, 0x0, 73, 1, 0, 0 },
	/*II_0F_3A_0F*/{ { 0x1bb, 9432 }, 0x0, 1, 0, 0, 0 },
	/*II_66_0F_3A_0F*/{ { 0x1bc, 9432 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_0F*/{ { 0x181, 9441 }, 0x0, 73, 1, 0, 0 },
	/*II_66_0F_3A_14*/{ { 0x1bd, 9451 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_14*/{ { 0x1be, 9459 }, 0x40, 1, 0, 0, 0 },
	/*II_66_0F_3A_15*/{ { 0x1bf, 6333 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_15*/{ { 0x1c0, 6341 }, 0x40, 1, 0, 0, 0 },
	/*II_66_0F_3A_16*/{ { 0x1c1, 9468 }, 0x0, 1, 0, 0, 9476 },
	/*II_V_66_0F_3A_16*/{ { 0x1c2, 9484 }, 0x46, 1, 0, 9493, 0 },
	/*II_66_0F_3A_17*/{ { 0x1c3, 9502 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_17*/{ { 0x1c4, 9513 }, 0x40, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_18*/{ { 0x1b8, 9525 }, 0x10, 73, 1, 0, 0 },
	/*II_V_66_0F_3A_19*/{ { 0x1c5, 9538 }, 0x50, 1, 0, 0, 0 },
	/*II_66_0F_3A_20*/{ { 0x1c6, 9552 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_20*/{ { 0x181, 9560 }, 0x0, 76, 1, 0, 0 },
	/*II_66_0F_3A_21*/{ { 0x1b9, 9569 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_21*/{ { 0x181, 9579 }, 0x0, 71, 1, 0, 0 },
	/*II_66_0F_3A_22*/{ { 0x1c7, 9590 }, 0x0, 1, 0, 0, 9598 },
	/*II_V_66_0F_3A_22*/{ { 0x181, 9606 }, 0x6, 79, 1, 9615, 0 },
	/*II_66_0F_3A_40*/{ { 0x19f, 9624 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_40*/{ { 0x186, 9630 }, 0x1, 90, 1, 0, 0 },
	/*II_66_0F_3A_41*/{ { 0x19f, 9637 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_41*/{ { 0x181, 9643 }, 0x0, 73, 1, 0, 0 },
	/*II_66_0F_3A_42*/{ { 0x19f, 9650 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_42*/{ { 0x181, 9659 }, 0x0, 73, 1, 0, 0 },
	/*II_66_0F_3A_44*/{ { 0x1c8, 9669 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_44*/{ { 0x1c9, 9680 }, 0x0, 73, 1, 0, 0 },
	/*II_V_66_0F_3A_4A*/{ { 0x186, 9692 }, 0x1, 90, 84, 0, 0 },
	/*II_V_66_0F_3A_4B*/{ { 0x186, 9703 }, 0x1, 90, 84, 0, 0 },
	/*II_V_66_0F_3A_4C*/{ { 0x181, 9714 }, 0x0, 73, 82, 0, 0 },
	/*II_66_0F_3A_60*/{ { 0x1ca, 9725 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_60*/{ { 0x160, 9736 }, 0x40, 1, 0, 0, 0 },
	/*II_66_0F_3A_61*/{ { 0x1ca, 9748 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_61*/{ { 0x160, 9759 }, 0x40, 1, 0, 0, 0 },
	/*II_66_0F_3A_62*/{ { 0x1ca, 9771 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_62*/{ { 0x160, 9782 }, 0x40, 1, 0, 0, 0 },
	/*II_66_0F_3A_63*/{ { 0x1ca, 9794 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_63*/{ { 0x160, 9805 }, 0x40, 1, 0, 0, 0 },
	/*II_66_0F_3A_DF*/{ { 0x1cb, 9817 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_3A_DF*/{ { 0x1cc, 9834 }, 0x40, 1, 0, 0, 0 },
	/*II_V_66_0F_71_02*/{ { 0x1cf, 6465 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_71_04*/{ { 0x1cf, 6724 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_71_06*/{ { 0x1cf, 7038 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_72_02*/{ { 0x1cf, 6480 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_72_04*/{ { 0x1cf, 6739 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_72_06*/{ { 0x1cf, 7053 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_73_02*/{ { 0x1cf, 6495 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_73_03*/{ { 0x1cf, 9860 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_73_06*/{ { 0x1cf, 7068 }, 0x0, 1, 0, 0, 0 },
	/*II_V_66_0F_73_07*/{ { 0x1cf, 9877 }, 0x0, 1, 0, 0, 0 },
	/*II_0F_AE_00*/{ { 0x170, 9886 }, 0x0, 0, 0, 0, 9894 },
	/*II_0F_AE_01*/{ { 0x170, 9914 }, 0x0, 0, 0, 0, 9923 },
	/*II_V_0F_AE_02*/{ { 0x1d1, 9963 }, 0x40, 0, 0, 0, 0 },
	/*II_V_0F_AE_03*/{ { 0x1d1, 9992 }, 0x40, 0, 0, 0, 0 }
};

_InstNode InstructionsTree[5688] = {
	/* 0 - _00 */  0x2000,
	/* 1 - _01 */  0x2001,
	/* 2 - _02 */  0x2002,
	/* 3 - _03 */  0x2003,
	/* 4 - _04 */  0x2004,
	/* 5 - _05 */  0x2005,
	/* 6 - _06 */  0x2006,
	/* 7 - _07 */  0x2007,
	/* 8 - _08 */  0x2008,
	/* 9 - _09 */  0x2009,
	/* a - _0A */  0x200a,
	/* b - _0B */  0x200b,
	/* c - _0C */  0x200c,
	/* d - _0D */  0x200d,
	/* e - _0E */  0x200e,
	/* f - _0F */  0x8100,
	/* 10 - _10 */  0x200f,
	/* 11 - _11 */  0x2010,
	/* 12 - _12 */  0x2011,
	/* 13 - _13 */  0x2012,
	/* 14 - _14 */  0x2013,
	/* 15 - _15 */  0x2014,
	/* 16 - _16 */  0x2015,
	/* 17 - _17 */  0x2016,
	/* 18 - _18 */  0x2017,
	/* 19 - _19 */  0x2018,
	/* 1a - _1A */  0x2019,
	/* 1b - _1B */  0x201a,
	/* 1c - _1C */  0x201b,
	/* 1d - _1D */  0x201c,
	/* 1e - _1E */  0x201d,
	/* 1f - _1F */  0x201e,
	/* 20 - _20 */  0x201f,
	/* 21 - _21 */  0x2020,
	/* 22 - _22 */  0x2021,
	/* 23 - _23 */  0x2022,
	/* 24 - _24 */  0x2023,
	/* 25 - _25 */  0x2024,
	/* 26 -  */  0,
	/* 27 - _27 */  0x2025,
	/* 28 - _28 */  0x2026,
	/* 29 - _29 */  0x2027,
	/* 2a - _2A */  0x2028,
	/* 2b - _2B */  0x2029,
	/* 2c - _2C */  0x202a,
	/* 2d - _2D */  0x202b,
	/* 2e -  */  0,
	/* 2f - _2F */  0x202c,
	/* 30 - _30 */  0x202d,
	/* 31 - _31 */  0x202e,
	/* 32 - _32 */  0x202f,
	/* 33 - _33 */  0x2030,
	/* 34 - _34 */  0x2031,
	/* 35 - _35 */  0x2032,
	/* 36 -  */  0,
	/* 37 - _37 */  0x2033,
	/* 38 - _38 */  0x2034,
	/* 39 - _39 */  0x2035,
	/* 3a - _3A */  0x2036,
	/* 3b - _3B */  0x2037,
	/* 3c - _3C */  0x2038,
	/* 3d - _3D */  0x2039,
	/* 3e -  */  0,
	/* 3f - _3F */  0x203a,
	/* 40 - _40 */  0x203b,
	/* 41 - _40 */  0x203c,
	/* 42 - _40 */  0x203d,
	/* 43 - _40 */  0x203e,
	/* 44 - _40 */  0x203f,
	/* 45 - _40 */  0x2040,
	/* 46 - _40 */  0x2041,
	/* 47 - _40 */  0x2042,
	/* 48 - _48 */  0x2043,
	/* 49 - _48 */  0x2044,
	/* 4a - _48 */  0x2045,
	/* 4b - _48 */  0x2046,
	/* 4c - _48 */  0x2047,
	/* 4d - _48 */  0x2048,
	/* 4e - _48 */  0x2049,
	/* 4f - _48 */  0x204a,
	/* 50 - _50 */  0x204b,
	/* 51 - _50 */  0x204c,
	/* 52 - _50 */  0x204d,
	/* 53 - _50 */  0x204e,
	/* 54 - _50 */  0x204f,
	/* 55 - _50 */  0x2050,
	/* 56 - _50 */  0x2051,
	/* 57 - _50 */  0x2052,
	/* 58 - _58 */  0x2053,
	/* 59 - _58 */  0x2054,
	/* 5a - _58 */  0x2055,
	/* 5b - _58 */  0x2056,
	/* 5c - _58 */  0x2057,
	/* 5d - _58 */  0x2058,
	/* 5e - _58 */  0x2059,
	/* 5f - _58 */  0x205a,
	/* 60 - _60 */  0x205b,
	/* 61 - _61 */  0x205c,
	/* 62 - _62 */  0x205d,
	/* 63 - _63 */  0x205e,
	/* 64 -  */  0,
	/* 65 -  */  0,
	/* 66 -  */  0,
	/* 67 -  */  0,
	/* 68 - _68 */  0x205f,
	/* 69 - _69 */  0x4000,
	/* 6a - _6A */  0x2060,
	/* 6b - _6B */  0x4001,
	/* 6c - _6C */  0x2061,
	/* 6d - _6D */  0x2062,
	/* 6e - _6E */  0x2063,
	/* 6f - _6F */  0x2064,
	/* 70 - _70 */  0x2065,
	/* 71 - _71 */  0x2066,
	/* 72 - _72 */  0x2067,
	/* 73 - _73 */  0x2068,
	/* 74 - _74 */  0x2069,
	/* 75 - _75 */  0x206a,
	/* 76 - _76 */  0x206b,
	/* 77 - _77 */  0x206c,
	/* 78 - _78 */  0x206d,
	/* 79 - _79 */  0x206e,
	/* 7a - _7A */  0x206f,
	/* 7b - _7B */  0x2070,
	/* 7c - _7C */  0x2071,
	/* 7d - _7D */  0x2072,
	/* 7e - _7E */  0x2073,
	/* 7f - _7F */  0x2074,
	/* 80 - _80 */  0x6200,
	/* 81 - _81 */  0x6208,
	/* 82 - _82 */  0x6210,
	/* 83 - _83 */  0x6218,
	/* 84 - _84 */  0x2075,
	/* 85 - _85 */  0x2076,
	/* 86 - _86 */  0x2077,
	/* 87 - _87 */  0x2078,
	/* 88 - _88 */  0x2079,
	/* 89 - _89 */  0x207a,
	/* 8a - _8A */  0x207b,
	/* 8b - _8B */  0x207c,
	/* 8c - _8C */  0x207d,
	/* 8d - _8D */  0x207e,
	/* 8e - _8E */  0x207f,
	/* 8f - _8F */  0x6220,
	/* 90 - _90 */  0x2080,
	/* 91 - _91 */  0x2081,
	/* 92 - _92 */  0x2082,
	/* 93 - _93 */  0x2083,
	/* 94 - _94 */  0x2084,
	/* 95 - _95 */  0x2085,
	/* 96 - _96 */  0x2086,
	/* 97 - _97 */  0x2087,
	/* 98 - _98 */  0x4002,
	/* 99 - _99 */  0x4003,
	/* 9a - _9A */  0x2088,
	/* 9b -  */  0,
	/* 9c - _9C */  0x2089,
	/* 9d - _9D */  0x208a,
	/* 9e - _9E */  0x208b,
	/* 9f - _9F */  0x208c,
	/* a0 - _A0 */  0x208d,
	/* a1 - _A1 */  0x208e,
	/* a2 - _A2 */  0x208f,
	/* a3 - _A3 */  0x2090,
	/* a4 - _A4 */  0x2091,
	/* a5 - _A5 */  0x2092,
	/* a6 - _A6 */  0x2093,
	/* a7 - _A7 */  0x2094,
	/* a8 - _A8 */  0x2095,
	/* a9 - _A9 */  0x2096,
	/* aa - _AA */  0x2097,
	/* ab - _AB */  0x2098,
	/* ac - _AC */  0x2099,
	/* ad - _AD */  0x209a,
	/* ae - _AE */  0x209b,
	/* af - _AF */  0x209c,
	/* b0 - _B0 */  0x209d,
	/* b1 - _B0 */  0x209e,
	/* b2 - _B0 */  0x209f,
	/* b3 - _B0 */  0x20a0,
	/* b4 - _B0 */  0x20a1,
	/* b5 - _B0 */  0x20a2,
	/* b6 - _B0 */  0x20a3,
	/* b7 - _B0 */  0x20a4,
	/* b8 - _B8 */  0x20a5,
	/* b9 - _B8 */  0x20a6,
	/* ba - _B8 */  0x20a7,
	/* bb - _B8 */  0x20a8,
	/* bc - _B8 */  0x20a9,
	/* bd - _B8 */  0x20aa,
	/* be - _B8 */  0x20ab,
	/* bf - _B8 */  0x20ac,
	/* c0 - _C0 */  0x6228,
	/* c1 - _C1 */  0x6230,
	/* c2 - _C2 */  0x20ad,
	/* c3 - _C3 */  0x20ae,
	/* c4 - _C4 */  0x20af,
	/* c5 - _C5 */  0x20b0,
	/* c6 - _C6 */  0xa238,
	/* c7 - _C7 */  0xa280,
	/* c8 - _C8 */  0x20b1,
	/* c9 - _C9 */  0x20b2,
	/* ca - _CA */  0x20b3,
	/* cb - _CB */  0x20b4,
	/* cc - _CC */  0x20b5,
	/* cd - _CD */  0x20b6,
	/* ce - _CE */  0x20b7,
	/* cf - _CF */  0x20b8,
	/* d0 - _D0 */  0x62c8,
	/* d1 - _D1 */  0x62d0,
	/* d2 - _D2 */  0x62d8,
	/* d3 - _D3 */  0x62e0,
	/* d4 - _D4 */  0x20b9,
	/* d5 - _D5 */  0x20ba,
	/* d6 - _D6 */  0x20bb,
	/* d7 - _D7 */  0x20bc,
	/* d8 - _D8 */  0xa2e8,
	/* d9 - _D9 */  0xa330,
	/* da - _DA */  0xa378,
	/* db - _DB */  0xa3c0,
	/* dc - _DC */  0xa408,
	/* dd - _DD */  0xa450,
	/* de - _DE */  0xa498,
	/* df - _DF */  0xa4e0,
	/* e0 - _E0 */  0x20bd,
	/* e1 - _E1 */  0x20be,
	/* e2 - _E2 */  0x20bf,
	/* e3 - _E3 */  0x4004,
	/* e4 - _E4 */  0x20c0,
	/* e5 - _E5 */  0x20c1,
	/* e6 - _E6 */  0x20c2,
	/* e7 - _E7 */  0x20c3,
	/* e8 - _E8 */  0x20c4,
	/* e9 - _E9 */  0x20c5,
	/* ea - _EA */  0x20c6,
	/* eb - _EB */  0x20c7,
	/* ec - _EC */  0x20c8,
	/* ed - _ED */  0x20c9,
	/* ee - _EE */  0x20ca,
	/* ef - _EF */  0x20cb,
	/* f0 -  */  0,
	/* f1 - _F1 */  0x20cc,
	/* f2 -  */  0,
	/* f3 -  */  0,
	/* f4 - _F4 */  0x20cd,
	/* f5 - _F5 */  0x20ce,
	/* f6 - _F6 */  0x6528,
	/* f7 - _F7 */  0x6530,
	/* f8 - _F8 */  0x20cf,
	/* f9 - _F9 */  0x20d0,
	/* fa - _FA */  0x20d1,
	/* fb - _FB */  0x20d2,
	/* fc - _FC */  0x20d3,
	/* fd - _FD */  0x20d4,
	/* fe - _FE */  0x6538,
	/* ff - _FF */  0x6540,
	/* 100 - _0F_00 */  0x6548,
	/* 101 - _0F_01 */  0xa550,
	/* 102 - _0F_02 */  0x20d5,
	/* 103 - _0F_03 */  0x20d6,
	/* 104 -  */  0,
	/* 105 - _0F_05 */  0x20d7,
	/* 106 - _0F_06 */  0x20d8,
	/* 107 - _0F_07 */  0x20d9,
	/* 108 - _0F_08 */  0x20da,
	/* 109 - _0F_09 */  0x20db,
	/* 10a -  */  0,
	/* 10b - _0F_0B */  0x20dc,
	/* 10c -  */  0,
	/* 10d - _0F_0D */  0x6598,
	/* 10e - _0F_0E */  0x20dd,
	/* 10f - _0F_0F */  0x85a0,
	/* 110 - _0F_10 */  0xc6a0,
	/* 111 - _0F_11 */  0xc6ac,
	/* 112 - _0F_12 */  0xc6b8,
	/* 113 - _0F_13 */  0xc6c4,
	/* 114 - _0F_14 */  0xc6d0,
	/* 115 - _0F_15 */  0xc6dc,
	/* 116 - _0F_16 */  0xc6e8,
	/* 117 - _0F_17 */  0xc6f4,
	/* 118 - _0F_18 */  0x6700,
	/* 119 -  */  0,
	/* 11a -  */  0,
	/* 11b -  */  0,
	/* 11c -  */  0,
	/* 11d -  */  0,
	/* 11e -  */  0,
	/* 11f - _0F_1F */  0x20de,
	/* 120 - _0F_20 */  0x20df,
	/* 121 - _0F_21 */  0x20e0,
	/* 122 - _0F_22 */  0x20e1,
	/* 123 - _0F_23 */  0x20e2,
	/* 124 -  */  0,
	/* 125 -  */  0,
	/* 126 -  */  0,
	/* 127 -  */  0,
	/* 128 - _0F_28 */  0xc708,
	/* 129 - _0F_29 */  0xc714,
	/* 12a - _0F_2A */  0xc720,
	/* 12b - _0F_2B */  0xc72c,
	/* 12c - _0F_2C */  0xc738,
	/* 12d - _0F_2D */  0xc744,
	/* 12e - _0F_2E */  0xc750,
	/* 12f - _0F_2F */  0xc75c,
	/* 130 - _0F_30 */  0x20e3,
	/* 131 - _0F_31 */  0x20e4,
	/* 132 - _0F_32 */  0x20e5,
	/* 133 - _0F_33 */  0x20e6,
	/* 134 - _0F_34 */  0x20e7,
	/* 135 - _0F_35 */  0x20e8,
	/* 136 -  */  0,
	/* 137 - _0F_37 */  0x20e9,
	/* 138 - _0F_38 */  0x8768,
	/* 139 -  */  0,
	/* 13a - _0F_3A */  0x8868,
	/* 13b -  */  0,
	/* 13c -  */  0,
	/* 13d -  */  0,
	/* 13e -  */  0,
	/* 13f -  */  0,
	/* 140 - _0F_40 */  0x20ea,
	/* 141 - _0F_41 */  0x20eb,
	/* 142 - _0F_42 */  0x20ec,
	/* 143 - _0F_43 */  0x20ed,
	/* 144 - _0F_44 */  0x20ee,
	/* 145 - _0F_45 */  0x20ef,
	/* 146 - _0F_46 */  0x20f0,
	/* 147 - _0F_47 */  0x20f1,
	/* 148 - _0F_48 */  0x20f2,
	/* 149 - _0F_49 */  0x20f3,
	/* 14a - _0F_4A */  0x20f4,
	/* 14b - _0F_4B */  0x20f5,
	/* 14c - _0F_4C */  0x20f6,
	/* 14d - _0F_4D */  0x20f7,
	/* 14e - _0F_4E */  0x20f8,
	/* 14f - _0F_4F */  0x20f9,
	/* 150 - _0F_50 */  0xc968,
	/* 151 - _0F_51 */  0xc974,
	/* 152 - _0F_52 */  0xc980,
	/* 153 - _0F_53 */  0xc98c,
	/* 154 - _0F_54 */  0xc998,
	/* 155 - _0F_55 */  0xc9a4,
	/* 156 - _0F_56 */  0xc9b0,
	/* 157 - _0F_57 */  0xc9bc,
	/* 158 - _0F_58 */  0xc9c8,
	/* 159 - _0F_59 */  0xc9d4,
	/* 15a - _0F_5A */  0xc9e0,
	/* 15b - _0F_5B */  0xc9ec,
	/* 15c - _0F_5C */  0xc9f8,
	/* 15d - _0F_5D */  0xca04,
	/* 15e - _0F_5E */  0xca10,
	/* 15f - _0F_5F */  0xca1c,
	/* 160 - _0F_60 */  0xca28,
	/* 161 - _0F_61 */  0xca34,
	/* 162 - _0F_62 */  0xca40,
	/* 163 - _0F_63 */  0xca4c,
	/* 164 - _0F_64 */  0xca58,
	/* 165 - _0F_65 */  0xca64,
	/* 166 - _0F_66 */  0xca70,
	/* 167 - _0F_67 */  0xca7c,
	/* 168 - _0F_68 */  0xca88,
	/* 169 - _0F_69 */  0xca94,
	/* 16a - _0F_6A */  0xcaa0,
	/* 16b - _0F_6B */  0xcaac,
	/* 16c - _0F_6C */  0xcab8,
	/* 16d - _0F_6D */  0xcac4,
	/* 16e - _0F_6E */  0xcad0,
	/* 16f - _0F_6F */  0xcadc,
	/* 170 - _0F_70 */  0xcae8,
	/* 171 - _0F_71 */  0x6af4,
	/* 172 - _0F_72 */  0x6afc,
	/* 173 - _0F_73 */  0x6b04,
	/* 174 - _0F_74 */  0xcb0c,
	/* 175 - _0F_75 */  0xcb18,
	/* 176 - _0F_76 */  0xcb24,
	/* 177 - _0F_77 */  0xcb30,
	/* 178 - _0F_78 */  0xcb3c,
	/* 179 - _0F_79 */  0xcb48,
	/* 17a - _0F_7A */  0x8b54,
	/* 17b -  */  0,
	/* 17c - _0F_7C */  0xcc54,
	/* 17d - _0F_7D */  0xcc60,
	/* 17e - _0F_7E */  0xcc6c,
	/* 17f - _0F_7F */  0xcc78,
	/* 180 - _0F_80 */  0x20fa,
	/* 181 - _0F_81 */  0x20fb,
	/* 182 - _0F_82 */  0x20fc,
	/* 183 - _0F_83 */  0x20fd,
	/* 184 - _0F_84 */  0x20fe,
	/* 185 - _0F_85 */  0x20ff,
	/* 186 - _0F_86 */  0x2100,
	/* 187 - _0F_87 */  0x2101,
	/* 188 - _0F_88 */  0x2102,
	/* 189 - _0F_89 */  0x2103,
	/* 18a - _0F_8A */  0x2104,
	/* 18b - _0F_8B */  0x2105,
	/* 18c - _0F_8C */  0x2106,
	/* 18d - _0F_8D */  0x2107,
	/* 18e - _0F_8E */  0x2108,
	/* 18f - _0F_8F */  0x2109,
	/* 190 - _0F_90 */  0x210a,
	/* 191 - _0F_91 */  0x210b,
	/* 192 - _0F_92 */  0x210c,
	/* 193 - _0F_93 */  0x210d,
	/* 194 - _0F_94 */  0x210e,
	/* 195 - _0F_95 */  0x210f,
	/* 196 - _0F_96 */  0x2110,
	/* 197 - _0F_97 */  0x2111,
	/* 198 - _0F_98 */  0x2112,
	/* 199 - _0F_99 */  0x2113,
	/* 19a - _0F_9A */  0x2114,
	/* 19b - _0F_9B */  0x2115,
	/* 19c - _0F_9C */  0x2116,
	/* 19d - _0F_9D */  0x2117,
	/* 19e - _0F_9E */  0x2118,
	/* 19f - _0F_9F */  0x2119,
	/* 1a0 - _0F_A0 */  0x211a,
	/* 1a1 - _0F_A1 */  0x211b,
	/* 1a2 - _0F_A2 */  0x211c,
	/* 1a3 - _0F_A3 */  0x211d,
	/* 1a4 - _0F_A4 */  0x4005,
	/* 1a5 - _0F_A5 */  0x4006,
	/* 1a6 -  */  0,
	/* 1a7 -  */  0,
	/* 1a8 - _0F_A8 */  0x211e,
	/* 1a9 - _0F_A9 */  0x211f,
	/* 1aa - _0F_AA */  0x2120,
	/* 1ab - _0F_AB */  0x2121,
	/* 1ac - _0F_AC */  0x4007,
	/* 1ad - _0F_AD */  0x4008,
	/* 1ae - _0F_AE */  0x6c84,
	/* 1af - _0F_AF */  0x2122,
	/* 1b0 - _0F_B0 */  0x2123,
	/* 1b1 - _0F_B1 */  0x2124,
	/* 1b2 - _0F_B2 */  0x2125,
	/* 1b3 - _0F_B3 */  0x2126,
	/* 1b4 - _0F_B4 */  0x2127,
	/* 1b5 - _0F_B5 */  0x2128,
	/* 1b6 - _0F_B6 */  0x2129,
	/* 1b7 - _0F_B7 */  0x212a,
	/* 1b8 - _0F_B8 */  0xcc8c,
	/* 1b9 - _0F_B9 */  0x212b,
	/* 1ba - _0F_BA */  0x6c98,
	/* 1bb - _0F_BB */  0x212c,
	/* 1bc - _0F_BC */  0xcca0,
	/* 1bd - _0F_BD */  0xccac,
	/* 1be - _0F_BE */  0x212d,
	/* 1bf - _0F_BF */  0x212e,
	/* 1c0 - _0F_C0 */  0x212f,
	/* 1c1 - _0F_C1 */  0x2130,
	/* 1c2 - _0F_C2 */  0xccb8,
	/* 1c3 - _0F_C3 */  0x2131,
	/* 1c4 - _0F_C4 */  0xccc4,
	/* 1c5 - _0F_C5 */  0xccd0,
	/* 1c6 - _0F_C6 */  0xccdc,
	/* 1c7 - _0F_C7 */  0x6ce8,
	/* 1c8 - _0F_C8 */  0x2132,
	/* 1c9 - _0F_C8 */  0x2133,
	/* 1ca - _0F_C8 */  0x2134,
	/* 1cb - _0F_C8 */  0x2135,
	/* 1cc - _0F_C8 */  0x2136,
	/* 1cd - _0F_C8 */  0x2137,
	/* 1ce - _0F_C8 */  0x2138,
	/* 1cf - _0F_C8 */  0x2139,
	/* 1d0 - _0F_D0 */  0xccf0,
	/* 1d1 - _0F_D1 */  0xccfc,
	/* 1d2 - _0F_D2 */  0xcd08,
	/* 1d3 - _0F_D3 */  0xcd14,
	/* 1d4 - _0F_D4 */  0xcd20,
	/* 1d5 - _0F_D5 */  0xcd2c,
	/* 1d6 - _0F_D6 */  0xcd38,
	/* 1d7 - _0F_D7 */  0xcd44,
	/* 1d8 - _0F_D8 */  0xcd50,
	/* 1d9 - _0F_D9 */  0xcd5c,
	/* 1da - _0F_DA */  0xcd68,
	/* 1db - _0F_DB */  0xcd74,
	/* 1dc - _0F_DC */  0xcd80,
	/* 1dd - _0F_DD */  0xcd8c,
	/* 1de - _0F_DE */  0xcd98,
	/* 1df - _0F_DF */  0xcda4,
	/* 1e0 - _0F_E0 */  0xcdb0,
	/* 1e1 - _0F_E1 */  0xcdbc,
	/* 1e2 - _0F_E2 */  0xcdc8,
	/* 1e3 - _0F_E3 */  0xcdd4,
	/* 1e4 - _0F_E4 */  0xcde0,
	/* 1e5 - _0F_E5 */  0xcdec,
	/* 1e6 - _0F_E6 */  0xcdf8,
	/* 1e7 - _0F_E7 */  0xce04,
	/* 1e8 - _0F_E8 */  0xce10,
	/* 1e9 - _0F_E9 */  0xce1c,
	/* 1ea - _0F_EA */  0xce28,
	/* 1eb - _0F_EB */  0xce34,
	/* 1ec - _0F_EC */  0xce40,
	/* 1ed - _0F_ED */  0xce4c,
	/* 1ee - _0F_EE */  0xce58,
	/* 1ef - _0F_EF */  0xce64,
	/* 1f0 - _0F_F0 */  0xce70,
	/* 1f1 - _0F_F1 */  0xce7c,
	/* 1f2 - _0F_F2 */  0xce88,
	/* 1f3 - _0F_F3 */  0xce94,
	/* 1f4 - _0F_F4 */  0xcea0,
	/* 1f5 - _0F_F5 */  0xceac,
	/* 1f6 - _0F_F6 */  0xceb8,
	/* 1f7 - _0F_F7 */  0xcec4,
	/* 1f8 - _0F_F8 */  0xced0,
	/* 1f9 - _0F_F9 */  0xcedc,
	/* 1fa - _0F_FA */  0xcee8,
	/* 1fb - _0F_FB */  0xcef4,
	/* 1fc - _0F_FC */  0xcf00,
	/* 1fd - _0F_FD */  0xcf0c,
	/* 1fe - _0F_FE */  0xcf18,
	/* 1ff -  */  0,
	/* 200 - _80_00 */  0x213a,
	/* 201 - _80_01 */  0x213b,
	/* 202 - _80_02 */  0x213c,
	/* 203 - _80_03 */  0x213d,
	/* 204 - _80_04 */  0x213e,
	/* 205 - _80_05 */  0x213f,
	/* 206 - _80_06 */  0x2140,
	/* 207 - _80_07 */  0x2141,
	/* 208 - _81_00 */  0x2142,
	/* 209 - _81_01 */  0x2143,
	/* 20a - _81_02 */  0x2144,
	/* 20b - _81_03 */  0x2145,
	/* 20c - _81_04 */  0x2146,
	/* 20d - _81_05 */  0x2147,
	/* 20e - _81_06 */  0x2148,
	/* 20f - _81_07 */  0x2149,
	/* 210 - _82_00 */  0x214a,
	/* 211 - _82_01 */  0x214b,
	/* 212 - _82_02 */  0x214c,
	/* 213 - _82_03 */  0x214d,
	/* 214 - _82_04 */  0x214e,
	/* 215 - _82_05 */  0x214f,
	/* 216 - _82_06 */  0x2150,
	/* 217 - _82_07 */  0x2151,
	/* 218 - _83_00 */  0x2152,
	/* 219 - _83_01 */  0x2153,
	/* 21a - _83_02 */  0x2154,
	/* 21b - _83_03 */  0x2155,
	/* 21c - _83_04 */  0x2156,
	/* 21d - _83_05 */  0x2157,
	/* 21e - _83_06 */  0x2158,
	/* 21f - _83_07 */  0x2159,
	/* 220 - _8F_00 */  0x215a,
	/* 221 -  */  0,
	/* 222 -  */  0,
	/* 223 -  */  0,
	/* 224 -  */  0,
	/* 225 -  */  0,
	/* 226 -  */  0,
	/* 227 -  */  0,
	/* 228 - _C0_00 */  0x215b,
	/* 229 - _C0_01 */  0x215c,
	/* 22a - _C0_02 */  0x215d,
	/* 22b - _C0_03 */  0x215e,
	/* 22c - _C0_04 */  0x215f,
	/* 22d - _C0_05 */  0x2160,
	/* 22e - _C0_06 */  0x2161,
	/* 22f - _C0_07 */  0x2162,
	/* 230 - _C1_00 */  0x2163,
	/* 231 - _C1_01 */  0x2164,
	/* 232 - _C1_02 */  0x2165,
	/* 233 - _C1_03 */  0x2166,
	/* 234 - _C1_04 */  0x2167,
	/* 235 - _C1_05 */  0x2168,
	/* 236 - _C1_06 */  0x2169,
	/* 237 - _C1_07 */  0x216a,
	/* 238 - _C6_00 */  0x216b,
	/* 239 -  */  0,
	/* 23a -  */  0,
	/* 23b -  */  0,
	/* 23c -  */  0,
	/* 23d -  */  0,
	/* 23e -  */  0,
	/* 23f -  */  0,
	/* 240 -  */  0,
	/* 241 -  */  0,
	/* 242 -  */  0,
	/* 243 -  */  0,
	/* 244 -  */  0,
	/* 245 -  */  0,
	/* 246 -  */  0,
	/* 247 -  */  0,
	/* 248 -  */  0,
	/* 249 -  */  0,
	/* 24a -  */  0,
	/* 24b -  */  0,
	/* 24c -  */  0,
	/* 24d -  */  0,
	/* 24e -  */  0,
	/* 24f -  */  0,
	/* 250 -  */  0,
	/* 251 -  */  0,
	/* 252 -  */  0,
	/* 253 -  */  0,
	/* 254 -  */  0,
	/* 255 -  */  0,
	/* 256 -  */  0,
	/* 257 -  */  0,
	/* 258 -  */  0,
	/* 259 -  */  0,
	/* 25a -  */  0,
	/* 25b -  */  0,
	/* 25c -  */  0,
	/* 25d -  */  0,
	/* 25e -  */  0,
	/* 25f -  */  0,
	/* 260 -  */  0,
	/* 261 -  */  0,
	/* 262 -  */  0,
	/* 263 -  */  0,
	/* 264 -  */  0,
	/* 265 -  */  0,
	/* 266 -  */  0,
	/* 267 -  */  0,
	/* 268 -  */  0,
	/* 269 -  */  0,
	/* 26a -  */  0,
	/* 26b -  */  0,
	/* 26c -  */  0,
	/* 26d -  */  0,
	/* 26e -  */  0,
	/* 26f -  */  0,
	/* 270 -  */  0,
	/* 271 -  */  0,
	/* 272 -  */  0,
	/* 273 -  */  0,
	/* 274 -  */  0,
	/* 275 -  */  0,
	/* 276 -  */  0,
	/* 277 -  */  0,
	/* 278 - _C6_F8 */  0x216c,
	/* 279 -  */  0,
	/* 27a -  */  0,
	/* 27b -  */  0,
	/* 27c -  */  0,
	/* 27d -  */  0,
	/* 27e -  */  0,
	/* 27f -  */  0,
	/* 280 - _C7_00 */  0x216d,
	/* 281 -  */  0,
	/* 282 -  */  0,
	/* 283 -  */  0,
	/* 284 -  */  0,
	/* 285 -  */  0,
	/* 286 -  */  0,
	/* 287 -  */  0,
	/* 288 -  */  0,
	/* 289 -  */  0,
	/* 28a -  */  0,
	/* 28b -  */  0,
	/* 28c -  */  0,
	/* 28d -  */  0,
	/* 28e -  */  0,
	/* 28f -  */  0,
	/* 290 -  */  0,
	/* 291 -  */  0,
	/* 292 -  */  0,
	/* 293 -  */  0,
	/* 294 -  */  0,
	/* 295 -  */  0,
	/* 296 -  */  0,
	/* 297 -  */  0,
	/* 298 -  */  0,
	/* 299 -  */  0,
	/* 29a -  */  0,
	/* 29b -  */  0,
	/* 29c -  */  0,
	/* 29d -  */  0,
	/* 29e -  */  0,
	/* 29f -  */  0,
	/* 2a0 -  */  0,
	/* 2a1 -  */  0,
	/* 2a2 -  */  0,
	/* 2a3 -  */  0,
	/* 2a4 -  */  0,
	/* 2a5 -  */  0,
	/* 2a6 -  */  0,
	/* 2a7 -  */  0,
	/* 2a8 -  */  0,
	/* 2a9 -  */  0,
	/* 2aa -  */  0,
	/* 2ab -  */  0,
	/* 2ac -  */  0,
	/* 2ad -  */  0,
	/* 2ae -  */  0,
	/* 2af -  */  0,
	/* 2b0 -  */  0,
	/* 2b1 -  */  0,
	/* 2b2 -  */  0,
	/* 2b3 -  */  0,
	/* 2b4 -  */  0,
	/* 2b5 -  */  0,
	/* 2b6 -  */  0,
	/* 2b7 -  */  0,
	/* 2b8 -  */  0,
	/* 2b9 -  */  0,
	/* 2ba -  */  0,
	/* 2bb -  */  0,
	/* 2bc -  */  0,
	/* 2bd -  */  0,
	/* 2be -  */  0,
	/* 2bf -  */  0,
	/* 2c0 - _C7_F8 */  0x216e,
	/* 2c1 -  */  0,
	/* 2c2 -  */  0,
	/* 2c3 -  */  0,
	/* 2c4 -  */  0,
	/* 2c5 -  */  0,
	/* 2c6 -  */  0,
	/* 2c7 -  */  0,
	/* 2c8 - _D0_00 */  0x216f,
	/* 2c9 - _D0_01 */  0x2170,
	/* 2ca - _D0_02 */  0x2171,
	/* 2cb - _D0_03 */  0x2172,
	/* 2cc - _D0_04 */  0x2173,
	/* 2cd - _D0_05 */  0x2174,
	/* 2ce - _D0_06 */  0x2175,
	/* 2cf - _D0_07 */  0x2176,
	/* 2d0 - _D1_00 */  0x2177,
	/* 2d1 - _D1_01 */  0x2178,
	/* 2d2 - _D1_02 */  0x2179,
	/* 2d3 - _D1_03 */  0x217a,
	/* 2d4 - _D1_04 */  0x217b,
	/* 2d5 - _D1_05 */  0x217c,
	/* 2d6 - _D1_06 */  0x217d,
	/* 2d7 - _D1_07 */  0x217e,
	/* 2d8 - _D2_00 */  0x217f,
	/* 2d9 - _D2_01 */  0x2180,
	/* 2da - _D2_02 */  0x2181,
	/* 2db - _D2_03 */  0x2182,
	/* 2dc - _D2_04 */  0x2183,
	/* 2dd - _D2_05 */  0x2184,
	/* 2de - _D2_06 */  0x2185,
	/* 2df - _D2_07 */  0x2186,
	/* 2e0 - _D3_00 */  0x2187,
	/* 2e1 - _D3_01 */  0x2188,
	/* 2e2 - _D3_02 */  0x2189,
	/* 2e3 - _D3_03 */  0x218a,
	/* 2e4 - _D3_04 */  0x218b,
	/* 2e5 - _D3_05 */  0x218c,
	/* 2e6 - _D3_06 */  0x218d,
	/* 2e7 - _D3_07 */  0x218e,
	/* 2e8 - _D8_00 */  0x218f,
	/* 2e9 - _D8_01 */  0x2190,
	/* 2ea - _D8_02 */  0x2191,
	/* 2eb - _D8_03 */  0x2192,
	/* 2ec - _D8_04 */  0x2193,
	/* 2ed - _D8_05 */  0x2194,
	/* 2ee - _D8_06 */  0x2195,
	/* 2ef - _D8_07 */  0x2196,
	/* 2f0 - _D8_C0 */  0x2197,
	/* 2f1 - _D8_C0 */  0x2198,
	/* 2f2 - _D8_C0 */  0x2199,
	/* 2f3 - _D8_C0 */  0x219a,
	/* 2f4 - _D8_C0 */  0x219b,
	/* 2f5 - _D8_C0 */  0x219c,
	/* 2f6 - _D8_C0 */  0x219d,
	/* 2f7 - _D8_C0 */  0x219e,
	/* 2f8 - _D8_C8 */  0x219f,
	/* 2f9 - _D8_C8 */  0x21a0,
	/* 2fa - _D8_C8 */  0x21a1,
	/* 2fb - _D8_C8 */  0x21a2,
	/* 2fc - _D8_C8 */  0x21a3,
	/* 2fd - _D8_C8 */  0x21a4,
	/* 2fe - _D8_C8 */  0x21a5,
	/* 2ff - _D8_C8 */  0x21a6,
	/* 300 - _D8_D0 */  0x21a7,
	/* 301 - _D8_D0 */  0x21a8,
	/* 302 - _D8_D0 */  0x21a9,
	/* 303 - _D8_D0 */  0x21aa,
	/* 304 - _D8_D0 */  0x21ab,
	/* 305 - _D8_D0 */  0x21ac,
	/* 306 - _D8_D0 */  0x21ad,
	/* 307 - _D8_D0 */  0x21ae,
	/* 308 - _D8_D8 */  0x21af,
	/* 309 - _D8_D9 */  0x21b0,
	/* 30a - _D8_D8 */  0x21b1,
	/* 30b - _D8_D8 */  0x21b2,
	/* 30c - _D8_D8 */  0x21b3,
	/* 30d - _D8_D8 */  0x21b4,
	/* 30e - _D8_D8 */  0x21b5,
	/* 30f - _D8_D8 */  0x21b6,
	/* 310 - _D8_E0 */  0x21b7,
	/* 311 - _D8_E0 */  0x21b8,
	/* 312 - _D8_E0 */  0x21b9,
	/* 313 - _D8_E0 */  0x21ba,
	/* 314 - _D8_E0 */  0x21bb,
	/* 315 - _D8_E0 */  0x21bc,
	/* 316 - _D8_E0 */  0x21bd,
	/* 317 - _D8_E0 */  0x21be,
	/* 318 - _D8_E8 */  0x21bf,
	/* 319 - _D8_E8 */  0x21c0,
	/* 31a - _D8_E8 */  0x21c1,
	/* 31b - _D8_E8 */  0x21c2,
	/* 31c - _D8_E8 */  0x21c3,
	/* 31d - _D8_E8 */  0x21c4,
	/* 31e - _D8_E8 */  0x21c5,
	/* 31f - _D8_E8 */  0x21c6,
	/* 320 - _D8_F0 */  0x21c7,
	/* 321 - _D8_F0 */  0x21c8,
	/* 322 - _D8_F0 */  0x21c9,
	/* 323 - _D8_F0 */  0x21ca,
	/* 324 - _D8_F0 */  0x21cb,
	/* 325 - _D8_F0 */  0x21cc,
	/* 326 - _D8_F0 */  0x21cd,
	/* 327 - _D8_F0 */  0x21ce,
	/* 328 - _D8_F8 */  0x21cf,
	/* 329 - _D8_F8 */  0x21d0,
	/* 32a - _D8_F8 */  0x21d1,
	/* 32b - _D8_F8 */  0x21d2,
	/* 32c - _D8_F8 */  0x21d3,
	/* 32d - _D8_F8 */  0x21d4,
	/* 32e - _D8_F8 */  0x21d5,
	/* 32f - _D8_F8 */  0x21d6,
	/* 330 - _D9_00 */  0x21d7,
	/* 331 -  */  0,
	/* 332 - _D9_02 */  0x21d8,
	/* 333 - _D9_03 */  0x21d9,
	/* 334 - _D9_04 */  0x21da,
	/* 335 - _D9_05 */  0x21db,
	/* 336 - _D9_06 */  0xcf24,
	/* 337 - _D9_07 */  0xcf30,
	/* 338 - _D9_C0 */  0x21dc,
	/* 339 - _D9_C0 */  0x21dd,
	/* 33a - _D9_C0 */  0x21de,
	/* 33b - _D9_C0 */  0x21df,
	/* 33c - _D9_C0 */  0x21e0,
	/* 33d - _D9_C0 */  0x21e1,
	/* 33e - _D9_C0 */  0x21e2,
	/* 33f - _D9_C0 */  0x21e3,
	/* 340 - _D9_C8 */  0x21e4,
	/* 341 - _D9_C9 */  0x21e5,
	/* 342 - _D9_C8 */  0x21e6,
	/* 343 - _D9_C8 */  0x21e7,
	/* 344 - _D9_C8 */  0x21e8,
	/* 345 - _D9_C8 */  0x21e9,
	/* 346 - _D9_C8 */  0x21ea,
	/* 347 - _D9_C8 */  0x21eb,
	/* 348 - _D9_D0 */  0x21ec,
	/* 349 -  */  0,
	/* 34a -  */  0,
	/* 34b -  */  0,
	/* 34c -  */  0,
	/* 34d -  */  0,
	/* 34e -  */  0,
	/* 34f -  */  0,
	/* 350 -  */  0,
	/* 351 -  */  0,
	/* 352 -  */  0,
	/* 353 -  */  0,
	/* 354 -  */  0,
	/* 355 -  */  0,
	/* 356 -  */  0,
	/* 357 -  */  0,
	/* 358 - _D9_E0 */  0x21ed,
	/* 359 - _D9_E1 */  0x21ee,
	/* 35a -  */  0,
	/* 35b -  */  0,
	/* 35c - _D9_E4 */  0x21ef,
	/* 35d - _D9_E5 */  0x21f0,
	/* 35e -  */  0,
	/* 35f -  */  0,
	/* 360 - _D9_E8 */  0x21f1,
	/* 361 - _D9_E9 */  0x21f2,
	/* 362 - _D9_EA */  0x21f3,
	/* 363 - _D9_EB */  0x21f4,
	/* 364 - _D9_EC */  0x21f5,
	/* 365 - _D9_ED */  0x21f6,
	/* 366 - _D9_EE */  0x21f7,
	/* 367 -  */  0,
	/* 368 - _D9_F0 */  0x21f8,
	/* 369 - _D9_F1 */  0x21f9,
	/* 36a - _D9_F2 */  0x21fa,
	/* 36b - _D9_F3 */  0x21fb,
	/* 36c - _D9_F4 */  0x21fc,
	/* 36d - _D9_F5 */  0x21fd,
	/* 36e - _D9_F6 */  0x21fe,
	/* 36f - _D9_F7 */  0x21ff,
	/* 370 - _D9_F8 */  0x2200,
	/* 371 - _D9_F9 */  0x2201,
	/* 372 - _D9_FA */  0x2202,
	/* 373 - _D9_FB */  0x2203,
	/* 374 - _D9_FC */  0x2204,
	/* 375 - _D9_FD */  0x2205,
	/* 376 - _D9_FE */  0x2206,
	/* 377 - _D9_FF */  0x2207,
	/* 378 - _DA_00 */  0x2208,
	/* 379 - _DA_01 */  0x2209,
	/* 37a - _DA_02 */  0x220a,
	/* 37b - _DA_03 */  0x220b,
	/* 37c - _DA_04 */  0x220c,
	/* 37d - _DA_05 */  0x220d,
	/* 37e - _DA_06 */  0x220e,
	/* 37f - _DA_07 */  0x220f,
	/* 380 - _DA_C0 */  0x2210,
	/* 381 - _DA_C0 */  0x2211,
	/* 382 - _DA_C0 */  0x2212,
	/* 383 - _DA_C0 */  0x2213,
	/* 384 - _DA_C0 */  0x2214,
	/* 385 - _DA_C0 */  0x2215,
	/* 386 - _DA_C0 */  0x2216,
	/* 387 - _DA_C0 */  0x2217,
	/* 388 - _DA_C8 */  0x2218,
	/* 389 - _DA_C8 */  0x2219,
	/* 38a - _DA_C8 */  0x221a,
	/* 38b - _DA_C8 */  0x221b,
	/* 38c - _DA_C8 */  0x221c,
	/* 38d - _DA_C8 */  0x221d,
	/* 38e - _DA_C8 */  0x221e,
	/* 38f - _DA_C8 */  0x221f,
	/* 390 - _DA_D0 */  0x2220,
	/* 391 - _DA_D0 */  0x2221,
	/* 392 - _DA_D0 */  0x2222,
	/* 393 - _DA_D0 */  0x2223,
	/* 394 - _DA_D0 */  0x2224,
	/* 395 - _DA_D0 */  0x2225,
	/* 396 - _DA_D0 */  0x2226,
	/* 397 - _DA_D0 */  0x2227,
	/* 398 - _DA_D8 */  0x2228,
	/* 399 - _DA_D8 */  0x2229,
	/* 39a - _DA_D8 */  0x222a,
	/* 39b - _DA_D8 */  0x222b,
	/* 39c - _DA_D8 */  0x222c,
	/* 39d - _DA_D8 */  0x222d,
	/* 39e - _DA_D8 */  0x222e,
	/* 39f - _DA_D8 */  0x222f,
	/* 3a0 -  */  0,
	/* 3a1 -  */  0,
	/* 3a2 -  */  0,
	/* 3a3 -  */  0,
	/* 3a4 -  */  0,
	/* 3a5 -  */  0,
	/* 3a6 -  */  0,
	/* 3a7 -  */  0,
	/* 3a8 -  */  0,
	/* 3a9 - _DA_E9 */  0x2230,
	/* 3aa -  */  0,
	/* 3ab -  */  0,
	/* 3ac -  */  0,
	/* 3ad -  */  0,
	/* 3ae -  */  0,
	/* 3af -  */  0,
	/* 3b0 -  */  0,
	/* 3b1 -  */  0,
	/* 3b2 -  */  0,
	/* 3b3 -  */  0,
	/* 3b4 -  */  0,
	/* 3b5 -  */  0,
	/* 3b6 -  */  0,
	/* 3b7 -  */  0,
	/* 3b8 -  */  0,
	/* 3b9 -  */  0,
	/* 3ba -  */  0,
	/* 3bb -  */  0,
	/* 3bc -  */  0,
	/* 3bd -  */  0,
	/* 3be -  */  0,
	/* 3bf -  */  0,
	/* 3c0 - _DB_00 */  0x2231,
	/* 3c1 - _DB_01 */  0x2232,
	/* 3c2 - _DB_02 */  0x2233,
	/* 3c3 - _DB_03 */  0x2234,
	/* 3c4 -  */  0,
	/* 3c5 - _DB_05 */  0x2235,
	/* 3c6 -  */  0,
	/* 3c7 - _DB_07 */  0x2236,
	/* 3c8 - _DB_C0 */  0x2237,
	/* 3c9 - _DB_C0 */  0x2238,
	/* 3ca - _DB_C0 */  0x2239,
	/* 3cb - _DB_C0 */  0x223a,
	/* 3cc - _DB_C0 */  0x223b,
	/* 3cd - _DB_C0 */  0x223c,
	/* 3ce - _DB_C0 */  0x223d,
	/* 3cf - _DB_C0 */  0x223e,
	/* 3d0 - _DB_C8 */  0x223f,
	/* 3d1 - _DB_C8 */  0x2240,
	/* 3d2 - _DB_C8 */  0x2241,
	/* 3d3 - _DB_C8 */  0x2242,
	/* 3d4 - _DB_C8 */  0x2243,
	/* 3d5 - _DB_C8 */  0x2244,
	/* 3d6 - _DB_C8 */  0x2245,
	/* 3d7 - _DB_C8 */  0x2246,
	/* 3d8 - _DB_D0 */  0x2247,
	/* 3d9 - _DB_D0 */  0x2248,
	/* 3da - _DB_D0 */  0x2249,
	/* 3db - _DB_D0 */  0x224a,
	/* 3dc - _DB_D0 */  0x224b,
	/* 3dd - _DB_D0 */  0x224c,
	/* 3de - _DB_D0 */  0x224d,
	/* 3df - _DB_D0 */  0x224e,
	/* 3e0 - _DB_D8 */  0x224f,
	/* 3e1 - _DB_D8 */  0x2250,
	/* 3e2 - _DB_D8 */  0x2251,
	/* 3e3 - _DB_D8 */  0x2252,
	/* 3e4 - _DB_D8 */  0x2253,
	/* 3e5 - _DB_D8 */  0x2254,
	/* 3e6 - _DB_D8 */  0x2255,
	/* 3e7 - _DB_D8 */  0x2256,
	/* 3e8 - _DB_E0 */  0x2257,
	/* 3e9 - _DB_E1 */  0x2258,
	/* 3ea - _DB_E2 */  0xcf3c,
	/* 3eb - _DB_E3 */  0xcf48,
	/* 3ec - _DB_E4 */  0x2259,
	/* 3ed -  */  0,
	/* 3ee -  */  0,
	/* 3ef -  */  0,
	/* 3f0 - _DB_E8 */  0x225a,
	/* 3f1 - _DB_E8 */  0x225b,
	/* 3f2 - _DB_E8 */  0x225c,
	/* 3f3 - _DB_E8 */  0x225d,
	/* 3f4 - _DB_E8 */  0x225e,
	/* 3f5 - _DB_E8 */  0x225f,
	/* 3f6 - _DB_E8 */  0x2260,
	/* 3f7 - _DB_E8 */  0x2261,
	/* 3f8 - _DB_F0 */  0x2262,
	/* 3f9 - _DB_F0 */  0x2263,
	/* 3fa - _DB_F0 */  0x2264,
	/* 3fb - _DB_F0 */  0x2265,
	/* 3fc - _DB_F0 */  0x2266,
	/* 3fd - _DB_F0 */  0x2267,
	/* 3fe - _DB_F0 */  0x2268,
	/* 3ff - _DB_F0 */  0x2269,
	/* 400 -  */  0,
	/* 401 -  */  0,
	/* 402 -  */  0,
	/* 403 -  */  0,
	/* 404 -  */  0,
	/* 405 -  */  0,
	/* 406 -  */  0,
	/* 407 -  */  0,
	/* 408 - _DC_00 */  0x226a,
	/* 409 - _DC_01 */  0x226b,
	/* 40a - _DC_02 */  0x226c,
	/* 40b - _DC_03 */  0x226d,
	/* 40c - _DC_04 */  0x226e,
	/* 40d - _DC_05 */  0x226f,
	/* 40e - _DC_06 */  0x2270,
	/* 40f - _DC_07 */  0x2271,
	/* 410 - _DC_C0 */  0x2272,
	/* 411 - _DC_C0 */  0x2273,
	/* 412 - _DC_C0 */  0x2274,
	/* 413 - _DC_C0 */  0x2275,
	/* 414 - _DC_C0 */  0x2276,
	/* 415 - _DC_C0 */  0x2277,
	/* 416 - _DC_C0 */  0x2278,
	/* 417 - _DC_C0 */  0x2279,
	/* 418 - _DC_C8 */  0x227a,
	/* 419 - _DC_C8 */  0x227b,
	/* 41a - _DC_C8 */  0x227c,
	/* 41b - _DC_C8 */  0x227d,
	/* 41c - _DC_C8 */  0x227e,
	/* 41d - _DC_C8 */  0x227f,
	/* 41e - _DC_C8 */  0x2280,
	/* 41f - _DC_C8 */  0x2281,
	/* 420 -  */  0,
	/* 421 -  */  0,
	/* 422 -  */  0,
	/* 423 -  */  0,
	/* 424 -  */  0,
	/* 425 -  */  0,
	/* 426 -  */  0,
	/* 427 -  */  0,
	/* 428 -  */  0,
	/* 429 -  */  0,
	/* 42a -  */  0,
	/* 42b -  */  0,
	/* 42c -  */  0,
	/* 42d -  */  0,
	/* 42e -  */  0,
	/* 42f -  */  0,
	/* 430 - _DC_E0 */  0x2282,
	/* 431 - _DC_E0 */  0x2283,
	/* 432 - _DC_E0 */  0x2284,
	/* 433 - _DC_E0 */  0x2285,
	/* 434 - _DC_E0 */  0x2286,
	/* 435 - _DC_E0 */  0x2287,
	/* 436 - _DC_E0 */  0x2288,
	/* 437 - _DC_E0 */  0x2289,
	/* 438 - _DC_E8 */  0x228a,
	/* 439 - _DC_E8 */  0x228b,
	/* 43a - _DC_E8 */  0x228c,
	/* 43b - _DC_E8 */  0x228d,
	/* 43c - _DC_E8 */  0x228e,
	/* 43d - _DC_E8 */  0x228f,
	/* 43e - _DC_E8 */  0x2290,
	/* 43f - _DC_E8 */  0x2291,
	/* 440 - _DC_F0 */  0x2292,
	/* 441 - _DC_F0 */  0x2293,
	/* 442 - _DC_F0 */  0x2294,
	/* 443 - _DC_F0 */  0x2295,
	/* 444 - _DC_F0 */  0x2296,
	/* 445 - _DC_F0 */  0x2297,
	/* 446 - _DC_F0 */  0x2298,
	/* 447 - _DC_F0 */  0x2299,
	/* 448 - _DC_F8 */  0x229a,
	/* 449 - _DC_F8 */  0x229b,
	/* 44a - _DC_F8 */  0x229c,
	/* 44b - _DC_F8 */  0x229d,
	/* 44c - _DC_F8 */  0x229e,
	/* 44d - _DC_F8 */  0x229f,
	/* 44e - _DC_F8 */  0x22a0,
	/* 44f - _DC_F8 */  0x22a1,
	/* 450 - _DD_00 */  0x22a2,
	/* 451 - _DD_01 */  0x22a3,
	/* 452 - _DD_02 */  0x22a4,
	/* 453 - _DD_03 */  0x22a5,
	/* 454 - _DD_04 */  0x22a6,
	/* 455 -  */  0,
	/* 456 - _DD_06 */  0xcf54,
	/* 457 - _DD_07 */  0xcf60,
	/* 458 - _DD_C0 */  0x22a7,
	/* 459 - _DD_C0 */  0x22a8,
	/* 45a - _DD_C0 */  0x22a9,
	/* 45b - _DD_C0 */  0x22aa,
	/* 45c - _DD_C0 */  0x22ab,
	/* 45d - _DD_C0 */  0x22ac,
	/* 45e - _DD_C0 */  0x22ad,
	/* 45f - _DD_C0 */  0x22ae,
	/* 460 -  */  0,
	/* 461 -  */  0,
	/* 462 -  */  0,
	/* 463 -  */  0,
	/* 464 -  */  0,
	/* 465 -  */  0,
	/* 466 -  */  0,
	/* 467 -  */  0,
	/* 468 - _DD_D0 */  0x22af,
	/* 469 - _DD_D0 */  0x22b0,
	/* 46a - _DD_D0 */  0x22b1,
	/* 46b - _DD_D0 */  0x22b2,
	/* 46c - _DD_D0 */  0x22b3,
	/* 46d - _DD_D0 */  0x22b4,
	/* 46e - _DD_D0 */  0x22b5,
	/* 46f - _DD_D0 */  0x22b6,
	/* 470 - _DD_D8 */  0x22b7,
	/* 471 - _DD_D8 */  0x22b8,
	/* 472 - _DD_D8 */  0x22b9,
	/* 473 - _DD_D8 */  0x22ba,
	/* 474 - _DD_D8 */  0x22bb,
	/* 475 - _DD_D8 */  0x22bc,
	/* 476 - _DD_D8 */  0x22bd,
	/* 477 - _DD_D8 */  0x22be,
	/* 478 - _DD_E0 */  0x22bf,
	/* 479 - _DD_E1 */  0x22c0,
	/* 47a - _DD_E0 */  0x22c1,
	/* 47b - _DD_E0 */  0x22c2,
	/* 47c - _DD_E0 */  0x22c3,
	/* 47d - _DD_E0 */  0x22c4,
	/* 47e - _DD_E0 */  0x22c5,
	/* 47f - _DD_E0 */  0x22c6,
	/* 480 - _DD_E8 */  0x22c7,
	/* 481 - _DD_E9 */  0x22c8,
	/* 482 - _DD_E8 */  0x22c9,
	/* 483 - _DD_E8 */  0x22ca,
	/* 484 - _DD_E8 */  0x22cb,
	/* 485 - _DD_E8 */  0x22cc,
	/* 486 - _DD_E8 */  0x22cd,
	/* 487 - _DD_E8 */  0x22ce,
	/* 488 -  */  0,
	/* 489 -  */  0,
	/* 48a -  */  0,
	/* 48b -  */  0,
	/* 48c -  */  0,
	/* 48d -  */  0,
	/* 48e -  */  0,
	/* 48f -  */  0,
	/* 490 -  */  0,
	/* 491 -  */  0,
	/* 492 -  */  0,
	/* 493 -  */  0,
	/* 494 -  */  0,
	/* 495 -  */  0,
	/* 496 -  */  0,
	/* 497 -  */  0,
	/* 498 - _DE_00 */  0x22cf,
	/* 499 - _DE_01 */  0x22d0,
	/* 49a - _DE_02 */  0x22d1,
	/* 49b - _DE_03 */  0x22d2,
	/* 49c - _DE_04 */  0x22d3,
	/* 49d - _DE_05 */  0x22d4,
	/* 49e - _DE_06 */  0x22d5,
	/* 49f - _DE_07 */  0x22d6,
	/* 4a0 - _DE_C0 */  0x22d7,
	/* 4a1 - _DE_C1 */  0x22d8,
	/* 4a2 - _DE_C0 */  0x22d9,
	/* 4a3 - _DE_C0 */  0x22da,
	/* 4a4 - _DE_C0 */  0x22db,
	/* 4a5 - _DE_C0 */  0x22dc,
	/* 4a6 - _DE_C0 */  0x22dd,
	/* 4a7 - _DE_C0 */  0x22de,
	/* 4a8 - _DE_C8 */  0x22df,
	/* 4a9 - _DE_C9 */  0x22e0,
	/* 4aa - _DE_C8 */  0x22e1,
	/* 4ab - _DE_C8 */  0x22e2,
	/* 4ac - _DE_C8 */  0x22e3,
	/* 4ad - _DE_C8 */  0x22e4,
	/* 4ae - _DE_C8 */  0x22e5,
	/* 4af - _DE_C8 */  0x22e6,
	/* 4b0 -  */  0,
	/* 4b1 -  */  0,
	/* 4b2 -  */  0,
	/* 4b3 -  */  0,
	/* 4b4 -  */  0,
	/* 4b5 -  */  0,
	/* 4b6 -  */  0,
	/* 4b7 -  */  0,
	/* 4b8 -  */  0,
	/* 4b9 - _DE_D9 */  0x22e7,
	/* 4ba -  */  0,
	/* 4bb -  */  0,
	/* 4bc -  */  0,
	/* 4bd -  */  0,
	/* 4be -  */  0,
	/* 4bf -  */  0,
	/* 4c0 - _DE_E0 */  0x22e8,
	/* 4c1 - _DE_E1 */  0x22e9,
	/* 4c2 - _DE_E0 */  0x22ea,
	/* 4c3 - _DE_E0 */  0x22eb,
	/* 4c4 - _DE_E0 */  0x22ec,
	/* 4c5 - _DE_E0 */  0x22ed,
	/* 4c6 - _DE_E0 */  0x22ee,
	/* 4c7 - _DE_E0 */  0x22ef,
	/* 4c8 - _DE_E8 */  0x22f0,
	/* 4c9 - _DE_E9 */  0x22f1,
	/* 4ca - _DE_E8 */  0x22f2,
	/* 4cb - _DE_E8 */  0x22f3,
	/* 4cc - _DE_E8 */  0x22f4,
	/* 4cd - _DE_E8 */  0x22f5,
	/* 4ce - _DE_E8 */  0x22f6,
	/* 4cf - _DE_E8 */  0x22f7,
	/* 4d0 - _DE_F0 */  0x22f8,
	/* 4d1 - _DE_F1 */  0x22f9,
	/* 4d2 - _DE_F0 */  0x22fa,
	/* 4d3 - _DE_F0 */  0x22fb,
	/* 4d4 - _DE_F0 */  0x22fc,
	/* 4d5 - _DE_F0 */  0x22fd,
	/* 4d6 - _DE_F0 */  0x22fe,
	/* 4d7 - _DE_F0 */  0x22ff,
	/* 4d8 - _DE_F8 */  0x2300,
	/* 4d9 - _DE_F9 */  0x2301,
	/* 4da - _DE_F8 */  0x2302,
	/* 4db - _DE_F8 */  0x2303,
	/* 4dc - _DE_F8 */  0x2304,
	/* 4dd - _DE_F8 */  0x2305,
	/* 4de - _DE_F8 */  0x2306,
	/* 4df - _DE_F8 */  0x2307,
	/* 4e0 - _DF_00 */  0x2308,
	/* 4e1 - _DF_01 */  0x2309,
	/* 4e2 - _DF_02 */  0x230a,
	/* 4e3 - _DF_03 */  0x230b,
	/* 4e4 - _DF_04 */  0x230c,
	/* 4e5 - _DF_05 */  0x230d,
	/* 4e6 - _DF_06 */  0x230e,
	/* 4e7 - _DF_07 */  0x230f,
	/* 4e8 -  */  0,
	/* 4e9 -  */  0,
	/* 4ea -  */  0,
	/* 4eb -  */  0,
	/* 4ec -  */  0,
	/* 4ed -  */  0,
	/* 4ee -  */  0,
	/* 4ef -  */  0,
	/* 4f0 -  */  0,
	/* 4f1 -  */  0,
	/* 4f2 -  */  0,
	/* 4f3 -  */  0,
	/* 4f4 -  */  0,
	/* 4f5 -  */  0,
	/* 4f6 -  */  0,
	/* 4f7 -  */  0,
	/* 4f8 -  */  0,
	/* 4f9 -  */  0,
	/* 4fa -  */  0,
	/* 4fb -  */  0,
	/* 4fc -  */  0,
	/* 4fd -  */  0,
	/* 4fe -  */  0,
	/* 4ff -  */  0,
	/* 500 -  */  0,
	/* 501 -  */  0,
	/* 502 -  */  0,
	/* 503 -  */  0,
	/* 504 -  */  0,
	/* 505 -  */  0,
	/* 506 -  */  0,
	/* 507 -  */  0,
	/* 508 - _DF_E0 */  0xcf6c,
	/* 509 -  */  0,
	/* 50a -  */  0,
	/* 50b -  */  0,
	/* 50c -  */  0,
	/* 50d -  */  0,
	/* 50e -  */  0,
	/* 50f -  */  0,
	/* 510 - _DF_E8 */  0x2310,
	/* 511 - _DF_E8 */  0x2311,
	/* 512 - _DF_E8 */  0x2312,
	/* 513 - _DF_E8 */  0x2313,
	/* 514 - _DF_E8 */  0x2314,
	/* 515 - _DF_E8 */  0x2315,
	/* 516 - _DF_E8 */  0x2316,
	/* 517 - _DF_E8 */  0x2317,
	/* 518 - _DF_F0 */  0x2318,
	/* 519 - _DF_F0 */  0x2319,
	/* 51a - _DF_F0 */  0x231a,
	/* 51b - _DF_F0 */  0x231b,
	/* 51c - _DF_F0 */  0x231c,
	/* 51d - _DF_F0 */  0x231d,
	/* 51e - _DF_F0 */  0x231e,
	/* 51f - _DF_F0 */  0x231f,
	/* 520 -  */  0,
	/* 521 -  */  0,
	/* 522 -  */  0,
	/* 523 -  */  0,
	/* 524 -  */  0,
	/* 525 -  */  0,
	/* 526 -  */  0,
	/* 527 -  */  0,
	/* 528 - _F6_00 */  0x2320,
	/* 529 -  */  0,
	/* 52a - _F6_02 */  0x2321,
	/* 52b - _F6_03 */  0x2322,
	/* 52c - _F6_04 */  0x2323,
	/* 52d - _F6_05 */  0x2324,
	/* 52e - _F6_06 */  0x2325,
	/* 52f - _F6_07 */  0x2326,
	/* 530 - _F7_00 */  0x2327,
	/* 531 -  */  0,
	/* 532 - _F7_02 */  0x2328,
	/* 533 - _F7_03 */  0x2329,
	/* 534 - _F7_04 */  0x232a,
	/* 535 - _F7_05 */  0x232b,
	/* 536 - _F7_06 */  0x232c,
	/* 537 - _F7_07 */  0x232d,
	/* 538 - _FE_00 */  0x232e,
	/* 539 - _FE_01 */  0x232f,
	/* 53a -  */  0,
	/* 53b -  */  0,
	/* 53c -  */  0,
	/* 53d -  */  0,
	/* 53e -  */  0,
	/* 53f -  */  0,
	/* 540 - _FF_00 */  0x2330,
	/* 541 - _FF_01 */  0x2331,
	/* 542 - _FF_02 */  0x2332,
	/* 543 - _FF_03 */  0x2333,
	/* 544 - _FF_04 */  0x2334,
	/* 545 - _FF_05 */  0x2335,
	/* 546 - _FF_06 */  0x2336,
	/* 547 -  */  0,
	/* 548 - _0F_00_00 */  0x2337,
	/* 549 - _0F_00_01 */  0x2338,
	/* 54a - _0F_00_02 */  0x2339,
	/* 54b - _0F_00_03 */  0x233a,
	/* 54c - _0F_00_04 */  0x233b,
	/* 54d - _0F_00_05 */  0x233c,
	/* 54e -  */  0,
	/* 54f -  */  0,
	/* 550 - _0F_01_00 */  0x233d,
	/* 551 - _0F_01_01 */  0x233e,
	/* 552 - _0F_01_02 */  0x233f,
	/* 553 - _0F_01_03 */  0x2340,
	/* 554 - _0F_01_04 */  0x2341,
	/* 555 -  */  0,
	/* 556 - _0F_01_06 */  0x2342,
	/* 557 - _0F_01_07 */  0x2343,
	/* 558 -  */  0,
	/* 559 - _0F_01_C1 */  0x2344,
	/* 55a - _0F_01_C2 */  0x2345,
	/* 55b - _0F_01_C3 */  0x2346,
	/* 55c - _0F_01_C4 */  0x2347,
	/* 55d -  */  0,
	/* 55e -  */  0,
	/* 55f -  */  0,
	/* 560 - _0F_01_C8 */  0x2348,
	/* 561 - _0F_01_C9 */  0x2349,
	/* 562 -  */  0,
	/* 563 -  */  0,
	/* 564 -  */  0,
	/* 565 -  */  0,
	/* 566 -  */  0,
	/* 567 -  */  0,
	/* 568 - _0F_01_D0 */  0x234a,
	/* 569 - _0F_01_D1 */  0x234b,
	/* 56a -  */  0,
	/* 56b -  */  0,
	/* 56c - _0F_01_D4 */  0x234c,
	/* 56d - _0F_01_D5 */  0x234d,
	/* 56e -  */  0,
	/* 56f -  */  0,
	/* 570 - _0F_01_D8 */  0x234e,
	/* 571 - _0F_01_D9 */  0x234f,
	/* 572 - _0F_01_DA */  0x2350,
	/* 573 - _0F_01_DB */  0x2351,
	/* 574 - _0F_01_DC */  0x2352,
	/* 575 - _0F_01_DD */  0x2353,
	/* 576 - _0F_01_DE */  0x2354,
	/* 577 - _0F_01_DF */  0x2355,
	/* 578 -  */  0,
	/* 579 -  */  0,
	/* 57a -  */  0,
	/* 57b -  */  0,
	/* 57c -  */  0,
	/* 57d -  */  0,
	/* 57e -  */  0,
	/* 57f -  */  0,
	/* 580 -  */  0,
	/* 581 -  */  0,
	/* 582 -  */  0,
	/* 583 -  */  0,
	/* 584 -  */  0,
	/* 585 -  */  0,
	/* 586 -  */  0,
	/* 587 -  */  0,
	/* 588 -  */  0,
	/* 589 -  */  0,
	/* 58a -  */  0,
	/* 58b -  */  0,
	/* 58c -  */  0,
	/* 58d -  */  0,
	/* 58e -  */  0,
	/* 58f -  */  0,
	/* 590 - _0F_01_F8 */  0x2356,
	/* 591 - _0F_01_F9 */  0x2357,
	/* 592 -  */  0,
	/* 593 -  */  0,
	/* 594 -  */  0,
	/* 595 -  */  0,
	/* 596 -  */  0,
	/* 597 -  */  0,
	/* 598 - _0F_0D_00 */  0x2358,
	/* 599 - _0F_0D_01 */  0x2359,
	/* 59a -  */  0,
	/* 59b -  */  0,
	/* 59c -  */  0,
	/* 59d -  */  0,
	/* 59e -  */  0,
	/* 59f -  */  0,
	/* 5a0 -  */  0,
	/* 5a1 -  */  0,
	/* 5a2 -  */  0,
	/* 5a3 -  */  0,
	/* 5a4 -  */  0,
	/* 5a5 -  */  0,
	/* 5a6 -  */  0,
	/* 5a7 -  */  0,
	/* 5a8 -  */  0,
	/* 5a9 -  */  0,
	/* 5aa -  */  0,
	/* 5ab -  */  0,
	/* 5ac - _0F_0F_0C */  0x235a,
	/* 5ad - _0F_0F_0D */  0x235b,
	/* 5ae -  */  0,
	/* 5af -  */  0,
	/* 5b0 -  */  0,
	/* 5b1 -  */  0,
	/* 5b2 -  */  0,
	/* 5b3 -  */  0,
	/* 5b4 -  */  0,
	/* 5b5 -  */  0,
	/* 5b6 -  */  0,
	/* 5b7 -  */  0,
	/* 5b8 -  */  0,
	/* 5b9 -  */  0,
	/* 5ba -  */  0,
	/* 5bb -  */  0,
	/* 5bc - _0F_0F_1C */  0x235c,
	/* 5bd - _0F_0F_1D */  0x235d,
	/* 5be -  */  0,
	/* 5bf -  */  0,
	/* 5c0 -  */  0,
	/* 5c1 -  */  0,
	/* 5c2 -  */  0,
	/* 5c3 -  */  0,
	/* 5c4 -  */  0,
	/* 5c5 -  */  0,
	/* 5c6 -  */  0,
	/* 5c7 -  */  0,
	/* 5c8 -  */  0,
	/* 5c9 -  */  0,
	/* 5ca -  */  0,
	/* 5cb -  */  0,
	/* 5cc -  */  0,
	/* 5cd -  */  0,
	/* 5ce -  */  0,
	/* 5cf -  */  0,
	/* 5d0 -  */  0,
	/* 5d1 -  */  0,
	/* 5d2 -  */  0,
	/* 5d3 -  */  0,
	/* 5d4 -  */  0,
	/* 5d5 -  */  0,
	/* 5d6 -  */  0,
	/* 5d7 -  */  0,
	/* 5d8 -  */  0,
	/* 5d9 -  */  0,
	/* 5da -  */  0,
	/* 5db -  */  0,
	/* 5dc -  */  0,
	/* 5dd -  */  0,
	/* 5de -  */  0,
	/* 5df -  */  0,
	/* 5e0 -  */  0,
	/* 5e1 -  */  0,
	/* 5e2 -  */  0,
	/* 5e3 -  */  0,
	/* 5e4 -  */  0,
	/* 5e5 -  */  0,
	/* 5e6 -  */  0,
	/* 5e7 -  */  0,
	/* 5e8 -  */  0,
	/* 5e9 -  */  0,
	/* 5ea -  */  0,
	/* 5eb -  */  0,
	/* 5ec -  */  0,
	/* 5ed -  */  0,
	/* 5ee -  */  0,
	/* 5ef -  */  0,
	/* 5f0 -  */  0,
	/* 5f1 -  */  0,
	/* 5f2 -  */  0,
	/* 5f3 -  */  0,
	/* 5f4 -  */  0,
	/* 5f5 -  */  0,
	/* 5f6 -  */  0,
	/* 5f7 -  */  0,
	/* 5f8 -  */  0,
	/* 5f9 -  */  0,
	/* 5fa -  */  0,
	/* 5fb -  */  0,
	/* 5fc -  */  0,
	/* 5fd -  */  0,
	/* 5fe -  */  0,
	/* 5ff -  */  0,
	/* 600 -  */  0,
	/* 601 -  */  0,
	/* 602 -  */  0,
	/* 603 -  */  0,
	/* 604 -  */  0,
	/* 605 -  */  0,
	/* 606 -  */  0,
	/* 607 -  */  0,
	/* 608 -  */  0,
	/* 609 -  */  0,
	/* 60a -  */  0,
	/* 60b -  */  0,
	/* 60c -  */  0,
	/* 60d -  */  0,
	/* 60e -  */  0,
	/* 60f -  */  0,
	/* 610 -  */  0,
	/* 611 -  */  0,
	/* 612 -  */  0,
	/* 613 -  */  0,
	/* 614 -  */  0,
	/* 615 -  */  0,
	/* 616 -  */  0,
	/* 617 -  */  0,
	/* 618 -  */  0,
	/* 619 -  */  0,
	/* 61a -  */  0,
	/* 61b -  */  0,
	/* 61c -  */  0,
	/* 61d -  */  0,
	/* 61e -  */  0,
	/* 61f -  */  0,
	/* 620 -  */  0,
	/* 621 -  */  0,
	/* 622 -  */  0,
	/* 623 -  */  0,
	/* 624 -  */  0,
	/* 625 -  */  0,
	/* 626 -  */  0,
	/* 627 -  */  0,
	/* 628 -  */  0,
	/* 629 -  */  0,
	/* 62a - _0F_0F_8A */  0x235e,
	/* 62b -  */  0,
	/* 62c -  */  0,
	/* 62d -  */  0,
	/* 62e - _0F_0F_8E */  0x235f,
	/* 62f -  */  0,
	/* 630 - _0F_0F_90 */  0x2360,
	/* 631 -  */  0,
	/* 632 -  */  0,
	/* 633 -  */  0,
	/* 634 - _0F_0F_94 */  0x2361,
	/* 635 -  */  0,
	/* 636 - _0F_0F_96 */  0x2362,
	/* 637 - _0F_0F_97 */  0x2363,
	/* 638 -  */  0,
	/* 639 -  */  0,
	/* 63a - _0F_0F_9A */  0x2364,
	/* 63b -  */  0,
	/* 63c -  */  0,
	/* 63d -  */  0,
	/* 63e - _0F_0F_9E */  0x2365,
	/* 63f -  */  0,
	/* 640 - _0F_0F_A0 */  0x2366,
	/* 641 -  */  0,
	/* 642 -  */  0,
	/* 643 -  */  0,
	/* 644 - _0F_0F_A4 */  0x2367,
	/* 645 -  */  0,
	/* 646 - _0F_0F_A6 */  0x2368,
	/* 647 - _0F_0F_A7 */  0x2369,
	/* 648 -  */  0,
	/* 649 -  */  0,
	/* 64a - _0F_0F_AA */  0x236a,
	/* 64b -  */  0,
	/* 64c -  */  0,
	/* 64d -  */  0,
	/* 64e - _0F_0F_AE */  0x236b,
	/* 64f -  */  0,
	/* 650 - _0F_0F_B0 */  0x236c,
	/* 651 -  */  0,
	/* 652 -  */  0,
	/* 653 -  */  0,
	/* 654 - _0F_0F_B4 */  0x236d,
	/* 655 -  */  0,
	/* 656 - _0F_0F_B6 */  0x236e,
	/* 657 - _0F_0F_B7 */  0x236f,
	/* 658 -  */  0,
	/* 659 -  */  0,
	/* 65a -  */  0,
	/* 65b - _0F_0F_BB */  0x2370,
	/* 65c -  */  0,
	/* 65d -  */  0,
	/* 65e -  */  0,
	/* 65f - _0F_0F_BF */  0x2371,
	/* 660 -  */  0,
	/* 661 -  */  0,
	/* 662 -  */  0,
	/* 663 -  */  0,
	/* 664 -  */  0,
	/* 665 -  */  0,
	/* 666 -  */  0,
	/* 667 -  */  0,
	/* 668 -  */  0,
	/* 669 -  */  0,
	/* 66a -  */  0,
	/* 66b -  */  0,
	/* 66c -  */  0,
	/* 66d -  */  0,
	/* 66e -  */  0,
	/* 66f -  */  0,
	/* 670 -  */  0,
	/* 671 -  */  0,
	/* 672 -  */  0,
	/* 673 -  */  0,
	/* 674 -  */  0,
	/* 675 -  */  0,
	/* 676 -  */  0,
	/* 677 -  */  0,
	/* 678 -  */  0,
	/* 679 -  */  0,
	/* 67a -  */  0,
	/* 67b -  */  0,
	/* 67c -  */  0,
	/* 67d -  */  0,
	/* 67e -  */  0,
	/* 67f -  */  0,
	/* 680 -  */  0,
	/* 681 -  */  0,
	/* 682 -  */  0,
	/* 683 -  */  0,
	/* 684 -  */  0,
	/* 685 -  */  0,
	/* 686 -  */  0,
	/* 687 -  */  0,
	/* 688 -  */  0,
	/* 689 -  */  0,
	/* 68a -  */  0,
	/* 68b -  */  0,
	/* 68c -  */  0,
	/* 68d -  */  0,
	/* 68e -  */  0,
	/* 68f -  */  0,
	/* 690 -  */  0,
	/* 691 -  */  0,
	/* 692 -  */  0,
	/* 693 -  */  0,
	/* 694 -  */  0,
	/* 695 -  */  0,
	/* 696 -  */  0,
	/* 697 -  */  0,
	/* 698 -  */  0,
	/* 699 -  */  0,
	/* 69a -  */  0,
	/* 69b -  */  0,
	/* 69c -  */  0,
	/* 69d -  */  0,
	/* 69e -  */  0,
	/* 69f -  */  0,
	/* 6a0 - _0F_10 */  0x2372,
	/* 6a1 - _66_0F_10 */  0x2373,
	/* 6a2 - _F3_0F_10 */  0x2374,
	/* 6a3 - _F2_0F_10 */  0x2375,
	/* 6a4 - _V_0F_10 */  0x4009,
	/* 6a5 - _V_66_0F_10 */  0x400a,
	/* 6a6 - _V_F3_0F_10 */  0x400b,
	/* 6a7 - _V_F2_0F_10 */  0x400c,
	/* 6a8 -  */  0,
	/* 6a9 -  */  0,
	/* 6aa - _VRR_F3_0F_10 */  0x400d,
	/* 6ab - _VRR_F2_0F_10 */  0x400e,
	/* 6ac - _0F_11 */  0x2376,
	/* 6ad - _66_0F_11 */  0x2377,
	/* 6ae - _F3_0F_11 */  0x2378,
	/* 6af - _F2_0F_11 */  0x2379,
	/* 6b0 - _V_0F_11 */  0x400f,
	/* 6b1 - _V_66_0F_11 */  0x4010,
	/* 6b2 - _V_F3_0F_11 */  0x4011,
	/* 6b3 - _V_F2_0F_11 */  0x4012,
	/* 6b4 -  */  0,
	/* 6b5 -  */  0,
	/* 6b6 - _VRR_F3_0F_11 */  0x4013,
	/* 6b7 - _VRR_F2_0F_11 */  0x4014,
	/* 6b8 - _0F_12 */  0x4015,
	/* 6b9 - _66_0F_12 */  0x237a,
	/* 6ba - _F3_0F_12 */  0x237b,
	/* 6bb - _F2_0F_12 */  0x237c,
	/* 6bc - _V_0F_12 */  0x4016,
	/* 6bd - _V_66_0F_12 */  0x4017,
	/* 6be - _V_F3_0F_12 */  0x4018,
	/* 6bf - _V_F2_0F_12 */  0x4019,
	/* 6c0 -  */  0,
	/* 6c1 -  */  0,
	/* 6c2 -  */  0,
	/* 6c3 -  */  0,
	/* 6c4 - _0F_13 */  0x237d,
	/* 6c5 - _66_0F_13 */  0x237e,
	/* 6c6 -  */  0,
	/* 6c7 -  */  0,
	/* 6c8 - _V_0F_13 */  0x401a,
	/* 6c9 - _V_66_0F_13 */  0x401b,
	/* 6ca -  */  0,
	/* 6cb -  */  0,
	/* 6cc -  */  0,
	/* 6cd -  */  0,
	/* 6ce -  */  0,
	/* 6cf -  */  0,
	/* 6d0 - _0F_14 */  0x237f,
	/* 6d1 - _66_0F_14 */  0x2380,
	/* 6d2 -  */  0,
	/* 6d3 -  */  0,
	/* 6d4 - _V_0F_14 */  0x401c,
	/* 6d5 - _V_66_0F_14 */  0x401d,
	/* 6d6 -  */  0,
	/* 6d7 -  */  0,
	/* 6d8 -  */  0,
	/* 6d9 -  */  0,
	/* 6da -  */  0,
	/* 6db -  */  0,
	/* 6dc - _0F_15 */  0x2381,
	/* 6dd - _66_0F_15 */  0x2382,
	/* 6de -  */  0,
	/* 6df -  */  0,
	/* 6e0 - _V_0F_15 */  0x401e,
	/* 6e1 - _V_66_0F_15 */  0x401f,
	/* 6e2 -  */  0,
	/* 6e3 -  */  0,
	/* 6e4 -  */  0,
	/* 6e5 -  */  0,
	/* 6e6 -  */  0,
	/* 6e7 -  */  0,
	/* 6e8 - _0F_16 */  0x4020,
	/* 6e9 - _66_0F_16 */  0x2383,
	/* 6ea - _F3_0F_16 */  0x2384,
	/* 6eb -  */  0,
	/* 6ec - _V_0F_16 */  0x4021,
	/* 6ed - _V_66_0F_16 */  0x4022,
	/* 6ee - _V_F3_0F_16 */  0x4023,
	/* 6ef -  */  0,
	/* 6f0 -  */  0,
	/* 6f1 -  */  0,
	/* 6f2 -  */  0,
	/* 6f3 -  */  0,
	/* 6f4 - _0F_17 */  0x2385,
	/* 6f5 - _66_0F_17 */  0x2386,
	/* 6f6 -  */  0,
	/* 6f7 -  */  0,
	/* 6f8 - _V_0F_17 */  0x4024,
	/* 6f9 - _V_66_0F_17 */  0x4025,
	/* 6fa -  */  0,
	/* 6fb -  */  0,
	/* 6fc -  */  0,
	/* 6fd -  */  0,
	/* 6fe -  */  0,
	/* 6ff -  */  0,
	/* 700 - _0F_18_00 */  0x2387,
	/* 701 - _0F_18_01 */  0x2388,
	/* 702 - _0F_18_02 */  0x2389,
	/* 703 - _0F_18_03 */  0x238a,
	/* 704 -  */  0,
	/* 705 -  */  0,
	/* 706 -  */  0,
	/* 707 -  */  0,
	/* 708 - _0F_28 */  0x238b,
	/* 709 - _66_0F_28 */  0x238c,
	/* 70a -  */  0,
	/* 70b -  */  0,
	/* 70c - _V_0F_28 */  0x4026,
	/* 70d - _V_66_0F_28 */  0x4027,
	/* 70e -  */  0,
	/* 70f -  */  0,
	/* 710 -  */  0,
	/* 711 -  */  0,
	/* 712 -  */  0,
	/* 713 -  */  0,
	/* 714 - _0F_29 */  0x238d,
	/* 715 - _66_0F_29 */  0x238e,
	/* 716 -  */  0,
	/* 717 -  */  0,
	/* 718 - _V_0F_29 */  0x4028,
	/* 719 - _V_66_0F_29 */  0x4029,
	/* 71a -  */  0,
	/* 71b -  */  0,
	/* 71c -  */  0,
	/* 71d -  */  0,
	/* 71e -  */  0,
	/* 71f -  */  0,
	/* 720 - _0F_2A */  0x238f,
	/* 721 - _66_0F_2A */  0x2390,
	/* 722 - _F3_0F_2A */  0x2391,
	/* 723 - _F2_0F_2A */  0x2392,
	/* 724 -  */  0,
	/* 725 -  */  0,
	/* 726 - _V_F3_0F_2A */  0x402a,
	/* 727 - _V_F2_0F_2A */  0x402b,
	/* 728 -  */  0,
	/* 729 -  */  0,
	/* 72a -  */  0,
	/* 72b -  */  0,
	/* 72c - _0F_2B */  0x2393,
	/* 72d - _66_0F_2B */  0x2394,
	/* 72e - _F3_0F_2B */  0x2395,
	/* 72f - _F2_0F_2B */  0x2396,
	/* 730 - _V_0F_2B */  0x402c,
	/* 731 - _V_66_0F_2B */  0x402d,
	/* 732 -  */  0,
	/* 733 -  */  0,
	/* 734 -  */  0,
	/* 735 -  */  0,
	/* 736 -  */  0,
	/* 737 -  */  0,
	/* 738 - _0F_2C */  0x2397,
	/* 739 - _66_0F_2C */  0x2398,
	/* 73a - _F3_0F_2C */  0x2399,
	/* 73b - _F2_0F_2C */  0x239a,
	/* 73c -  */  0,
	/* 73d -  */  0,
	/* 73e - _V_F3_0F_2C */  0x402e,
	/* 73f - _V_F2_0F_2C */  0x402f,
	/* 740 -  */  0,
	/* 741 -  */  0,
	/* 742 -  */  0,
	/* 743 -  */  0,
	/* 744 - _0F_2D */  0x239b,
	/* 745 - _66_0F_2D */  0x239c,
	/* 746 - _F3_0F_2D */  0x239d,
	/* 747 - _F2_0F_2D */  0x239e,
	/* 748 -  */  0,
	/* 749 -  */  0,
	/* 74a - _V_F3_0F_2D */  0x4030,
	/* 74b - _V_F2_0F_2D */  0x4031,
	/* 74c -  */  0,
	/* 74d -  */  0,
	/* 74e -  */  0,
	/* 74f -  */  0,
	/* 750 - _0F_2E */  0x239f,
	/* 751 - _66_0F_2E */  0x23a0,
	/* 752 -  */  0,
	/* 753 -  */  0,
	/* 754 - _V_0F_2E */  0x4032,
	/* 755 - _V_66_0F_2E */  0x4033,
	/* 756 -  */  0,
	/* 757 -  */  0,
	/* 758 -  */  0,
	/* 759 -  */  0,
	/* 75a -  */  0,
	/* 75b -  */  0,
	/* 75c - _0F_2F */  0x23a1,
	/* 75d - _66_0F_2F */  0x23a2,
	/* 75e -  */  0,
	/* 75f -  */  0,
	/* 760 - _V_0F_2F */  0x4034,
	/* 761 - _V_66_0F_2F */  0x4035,
	/* 762 -  */  0,
	/* 763 -  */  0,
	/* 764 -  */  0,
	/* 765 -  */  0,
	/* 766 -  */  0,
	/* 767 -  */  0,
	/* 768 - _0F_38_00 */  0xcf78,
	/* 769 - _0F_38_01 */  0xcf84,
	/* 76a - _0F_38_02 */  0xcf90,
	/* 76b - _0F_38_03 */  0xcf9c,
	/* 76c - _0F_38_04 */  0xcfa8,
	/* 76d - _0F_38_05 */  0xcfb4,
	/* 76e - _0F_38_06 */  0xcfc0,
	/* 76f - _0F_38_07 */  0xcfcc,
	/* 770 - _0F_38_08 */  0xcfd8,
	/* 771 - _0F_38_09 */  0xcfe4,
	/* 772 - _0F_38_0A */  0xcff0,
	/* 773 - _0F_38_0B */  0xcffc,
	/* 774 - _0F_38_0C */  0xd008,
	/* 775 - _0F_38_0D */  0xd014,
	/* 776 - _0F_38_0E */  0xd020,
	/* 777 - _0F_38_0F */  0xd02c,
	/* 778 - _0F_38_10 */  0xd038,
	/* 779 -  */  0,
	/* 77a -  */  0,
	/* 77b -  */  0,
	/* 77c - _0F_38_14 */  0xd044,
	/* 77d - _0F_38_15 */  0xd050,
	/* 77e -  */  0,
	/* 77f - _0F_38_17 */  0xd05c,
	/* 780 - _0F_38_18 */  0xd068,
	/* 781 - _0F_38_19 */  0xd074,
	/* 782 - _0F_38_1A */  0xd080,
	/* 783 -  */  0,
	/* 784 - _0F_38_1C */  0xd08c,
	/* 785 - _0F_38_1D */  0xd098,
	/* 786 - _0F_38_1E */  0xd0a4,
	/* 787 -  */  0,
	/* 788 - _0F_38_20 */  0xd0b0,
	/* 789 - _0F_38_21 */  0xd0bc,
	/* 78a - _0F_38_22 */  0xd0c8,
	/* 78b - _0F_38_23 */  0xd0d4,
	/* 78c - _0F_38_24 */  0xd0e0,
	/* 78d - _0F_38_25 */  0xd0ec,
	/* 78e -  */  0,
	/* 78f -  */  0,
	/* 790 - _0F_38_28 */  0xd0f8,
	/* 791 - _0F_38_29 */  0xd104,
	/* 792 - _0F_38_2A */  0xd110,
	/* 793 - _0F_38_2B */  0xd11c,
	/* 794 - _0F_38_2C */  0xd128,
	/* 795 - _0F_38_2D */  0xd134,
	/* 796 - _0F_38_2E */  0xd140,
	/* 797 - _0F_38_2F */  0xd14c,
	/* 798 - _0F_38_30 */  0xd158,
	/* 799 - _0F_38_31 */  0xd164,
	/* 79a - _0F_38_32 */  0xd170,
	/* 79b - _0F_38_33 */  0xd17c,
	/* 79c - _0F_38_34 */  0xd188,
	/* 79d - _0F_38_35 */  0xd194,
	/* 79e -  */  0,
	/* 79f - _0F_38_37 */  0xd1a0,
	/* 7a0 - _0F_38_38 */  0xd1ac,
	/* 7a1 - _0F_38_39 */  0xd1b8,
	/* 7a2 - _0F_38_3A */  0xd1c4,
	/* 7a3 - _0F_38_3B */  0xd1d0,
	/* 7a4 - _0F_38_3C */  0xd1dc,
	/* 7a5 - _0F_38_3D */  0xd1e8,
	/* 7a6 - _0F_38_3E */  0xd1f4,
	/* 7a7 - _0F_38_3F */  0xd200,
	/* 7a8 - _0F_38_40 */  0xd20c,
	/* 7a9 - _0F_38_41 */  0xd218,
	/* 7aa -  */  0,
	/* 7ab -  */  0,
	/* 7ac -  */  0,
	/* 7ad -  */  0,
	/* 7ae -  */  0,
	/* 7af -  */  0,
	/* 7b0 -  */  0,
	/* 7b1 -  */  0,
	/* 7b2 -  */  0,
	/* 7b3 -  */  0,
	/* 7b4 -  */  0,
	/* 7b5 -  */  0,
	/* 7b6 -  */  0,
	/* 7b7 -  */  0,
	/* 7b8 -  */  0,
	/* 7b9 -  */  0,
	/* 7ba -  */  0,
	/* 7bb -  */  0,
	/* 7bc -  */  0,
	/* 7bd -  */  0,
	/* 7be -  */  0,
	/* 7bf -  */  0,
	/* 7c0 -  */  0,
	/* 7c1 -  */  0,
	/* 7c2 -  */  0,
	/* 7c3 -  */  0,
	/* 7c4 -  */  0,
	/* 7c5 -  */  0,
	/* 7c6 -  */  0,
	/* 7c7 -  */  0,
	/* 7c8 -  */  0,
	/* 7c9 -  */  0,
	/* 7ca -  */  0,
	/* 7cb -  */  0,
	/* 7cc -  */  0,
	/* 7cd -  */  0,
	/* 7ce -  */  0,
	/* 7cf -  */  0,
	/* 7d0 -  */  0,
	/* 7d1 -  */  0,
	/* 7d2 -  */  0,
	/* 7d3 -  */  0,
	/* 7d4 -  */  0,
	/* 7d5 -  */  0,
	/* 7d6 -  */  0,
	/* 7d7 -  */  0,
	/* 7d8 -  */  0,
	/* 7d9 -  */  0,
	/* 7da -  */  0,
	/* 7db -  */  0,
	/* 7dc -  */  0,
	/* 7dd -  */  0,
	/* 7de -  */  0,
	/* 7df -  */  0,
	/* 7e0 -  */  0,
	/* 7e1 -  */  0,
	/* 7e2 -  */  0,
	/* 7e3 -  */  0,
	/* 7e4 -  */  0,
	/* 7e5 -  */  0,
	/* 7e6 -  */  0,
	/* 7e7 -  */  0,
	/* 7e8 - _0F_38_80 */  0xd224,
	/* 7e9 - _0F_38_81 */  0xd230,
	/* 7ea - _0F_38_82 */  0xd23c,
	/* 7eb -  */  0,
	/* 7ec -  */  0,
	/* 7ed -  */  0,
	/* 7ee -  */  0,
	/* 7ef -  */  0,
	/* 7f0 -  */  0,
	/* 7f1 -  */  0,
	/* 7f2 -  */  0,
	/* 7f3 -  */  0,
	/* 7f4 -  */  0,
	/* 7f5 -  */  0,
	/* 7f6 -  */  0,
	/* 7f7 -  */  0,
	/* 7f8 -  */  0,
	/* 7f9 -  */  0,
	/* 7fa -  */  0,
	/* 7fb -  */  0,
	/* 7fc -  */  0,
	/* 7fd -  */  0,
	/* 7fe - _0F_38_96 */  0xd248,
	/* 7ff - _0F_38_97 */  0xd254,
	/* 800 - _0F_38_98 */  0xd260,
	/* 801 - _0F_38_99 */  0xd26c,
	/* 802 - _0F_38_9A */  0xd278,
	/* 803 - _0F_38_9B */  0xd284,
	/* 804 - _0F_38_9C */  0xd290,
	/* 805 - _0F_38_9D */  0xd29c,
	/* 806 - _0F_38_9E */  0xd2a8,
	/* 807 - _0F_38_9F */  0xd2b4,
	/* 808 -  */  0,
	/* 809 -  */  0,
	/* 80a -  */  0,
	/* 80b -  */  0,
	/* 80c -  */  0,
	/* 80d -  */  0,
	/* 80e - _0F_38_A6 */  0xd2c0,
	/* 80f - _0F_38_A7 */  0xd2cc,
	/* 810 - _0F_38_A8 */  0xd2d8,
	/* 811 - _0F_38_A9 */  0xd2e4,
	/* 812 - _0F_38_AA */  0xd2f0,
	/* 813 - _0F_38_AB */  0xd2fc,
	/* 814 - _0F_38_AC */  0xd308,
	/* 815 - _0F_38_AD */  0xd314,
	/* 816 - _0F_38_AE */  0xd320,
	/* 817 - _0F_38_AF */  0xd32c,
	/* 818 -  */  0,
	/* 819 -  */  0,
	/* 81a -  */  0,
	/* 81b -  */  0,
	/* 81c -  */  0,
	/* 81d -  */  0,
	/* 81e - _0F_38_B6 */  0xd338,
	/* 81f - _0F_38_B7 */  0xd344,
	/* 820 - _0F_38_B8 */  0xd350,
	/* 821 - _0F_38_B9 */  0xd35c,
	/* 822 - _0F_38_BA */  0xd368,
	/* 823 - _0F_38_BB */  0xd374,
	/* 824 - _0F_38_BC */  0xd380,
	/* 825 - _0F_38_BD */  0xd38c,
	/* 826 - _0F_38_BE */  0xd398,
	/* 827 - _0F_38_BF */  0xd3a4,
	/* 828 -  */  0,
	/* 829 -  */  0,
	/* 82a -  */  0,
	/* 82b -  */  0,
	/* 82c -  */  0,
	/* 82d -  */  0,
	/* 82e -  */  0,
	/* 82f -  */  0,
	/* 830 -  */  0,
	/* 831 -  */  0,
	/* 832 -  */  0,
	/* 833 -  */  0,
	/* 834 -  */  0,
	/* 835 -  */  0,
	/* 836 -  */  0,
	/* 837 -  */  0,
	/* 838 -  */  0,
	/* 839 -  */  0,
	/* 83a -  */  0,
	/* 83b -  */  0,
	/* 83c -  */  0,
	/* 83d -  */  0,
	/* 83e -  */  0,
	/* 83f -  */  0,
	/* 840 -  */  0,
	/* 841 -  */  0,
	/* 842 -  */  0,
	/* 843 - _0F_38_DB */  0xd3b0,
	/* 844 - _0F_38_DC */  0xd3bc,
	/* 845 - _0F_38_DD */  0xd3c8,
	/* 846 - _0F_38_DE */  0xd3d4,
	/* 847 - _0F_38_DF */  0xd3e0,
	/* 848 -  */  0,
	/* 849 -  */  0,
	/* 84a -  */  0,
	/* 84b -  */  0,
	/* 84c -  */  0,
	/* 84d -  */  0,
	/* 84e -  */  0,
	/* 84f -  */  0,
	/* 850 -  */  0,
	/* 851 -  */  0,
	/* 852 -  */  0,
	/* 853 -  */  0,
	/* 854 -  */  0,
	/* 855 -  */  0,
	/* 856 -  */  0,
	/* 857 -  */  0,
	/* 858 - _0F_38_F0 */  0xd3ec,
	/* 859 - _0F_38_F1 */  0xd3f8,
	/* 85a -  */  0,
	/* 85b -  */  0,
	/* 85c -  */  0,
	/* 85d -  */  0,
	/* 85e -  */  0,
	/* 85f -  */  0,
	/* 860 -  */  0,
	/* 861 -  */  0,
	/* 862 -  */  0,
	/* 863 -  */  0,
	/* 864 -  */  0,
	/* 865 -  */  0,
	/* 866 -  */  0,
	/* 867 -  */  0,
	/* 868 -  */  0,
	/* 869 -  */  0,
	/* 86a -  */  0,
	/* 86b -  */  0,
	/* 86c - _0F_3A_04 */  0xd404,
	/* 86d - _0F_3A_05 */  0xd410,
	/* 86e - _0F_3A_06 */  0xd41c,
	/* 86f -  */  0,
	/* 870 - _0F_3A_08 */  0xd428,
	/* 871 - _0F_3A_09 */  0xd434,
	/* 872 - _0F_3A_0A */  0xd440,
	/* 873 - _0F_3A_0B */  0xd44c,
	/* 874 - _0F_3A_0C */  0xd458,
	/* 875 - _0F_3A_0D */  0xd464,
	/* 876 - _0F_3A_0E */  0xd470,
	/* 877 - _0F_3A_0F */  0xd47c,
	/* 878 -  */  0,
	/* 879 -  */  0,
	/* 87a -  */  0,
	/* 87b -  */  0,
	/* 87c - _0F_3A_14 */  0xd488,
	/* 87d - _0F_3A_15 */  0xd494,
	/* 87e - _0F_3A_16 */  0xd4a0,
	/* 87f - _0F_3A_17 */  0xd4ac,
	/* 880 - _0F_3A_18 */  0xd4b8,
	/* 881 - _0F_3A_19 */  0xd4c4,
	/* 882 -  */  0,
	/* 883 -  */  0,
	/* 884 -  */  0,
	/* 885 -  */  0,
	/* 886 -  */  0,
	/* 887 -  */  0,
	/* 888 - _0F_3A_20 */  0xd4d0,
	/* 889 - _0F_3A_21 */  0xd4dc,
	/* 88a - _0F_3A_22 */  0xd4e8,
	/* 88b -  */  0,
	/* 88c -  */  0,
	/* 88d -  */  0,
	/* 88e -  */  0,
	/* 88f -  */  0,
	/* 890 -  */  0,
	/* 891 -  */  0,
	/* 892 -  */  0,
	/* 893 -  */  0,
	/* 894 -  */  0,
	/* 895 -  */  0,
	/* 896 -  */  0,
	/* 897 -  */  0,
	/* 898 -  */  0,
	/* 899 -  */  0,
	/* 89a -  */  0,
	/* 89b -  */  0,
	/* 89c -  */  0,
	/* 89d -  */  0,
	/* 89e -  */  0,
	/* 89f -  */  0,
	/* 8a0 -  */  0,
	/* 8a1 -  */  0,
	/* 8a2 -  */  0,
	/* 8a3 -  */  0,
	/* 8a4 -  */  0,
	/* 8a5 -  */  0,
	/* 8a6 -  */  0,
	/* 8a7 -  */  0,
	/* 8a8 - _0F_3A_40 */  0xd4f4,
	/* 8a9 - _0F_3A_41 */  0xd500,
	/* 8aa - _0F_3A_42 */  0xd50c,
	/* 8ab -  */  0,
	/* 8ac - _0F_3A_44 */  0xd518,
	/* 8ad -  */  0,
	/* 8ae -  */  0,
	/* 8af -  */  0,
	/* 8b0 -  */  0,
	/* 8b1 -  */  0,
	/* 8b2 - _0F_3A_4A */  0xd524,
	/* 8b3 - _0F_3A_4B */  0xd530,
	/* 8b4 - _0F_3A_4C */  0xd53c,
	/* 8b5 -  */  0,
	/* 8b6 -  */  0,
	/* 8b7 -  */  0,
	/* 8b8 -  */  0,
	/* 8b9 -  */  0,
	/* 8ba -  */  0,
	/* 8bb -  */  0,
	/* 8bc -  */  0,
	/* 8bd -  */  0,
	/* 8be -  */  0,
	/* 8bf -  */  0,
	/* 8c0 -  */  0,
	/* 8c1 -  */  0,
	/* 8c2 -  */  0,
	/* 8c3 -  */  0,
	/* 8c4 -  */  0,
	/* 8c5 -  */  0,
	/* 8c6 -  */  0,
	/* 8c7 -  */  0,
	/* 8c8 - _0F_3A_60 */  0xd548,
	/* 8c9 - _0F_3A_61 */  0xd554,
	/* 8ca - _0F_3A_62 */  0xd560,
	/* 8cb - _0F_3A_63 */  0xd56c,
	/* 8cc -  */  0,
	/* 8cd -  */  0,
	/* 8ce -  */  0,
	/* 8cf -  */  0,
	/* 8d0 -  */  0,
	/* 8d1 -  */  0,
	/* 8d2 -  */  0,
	/* 8d3 -  */  0,
	/* 8d4 -  */  0,
	/* 8d5 -  */  0,
	/* 8d6 -  */  0,
	/* 8d7 -  */  0,
	/* 8d8 -  */  0,
	/* 8d9 -  */  0,
	/* 8da -  */  0,
	/* 8db -  */  0,
	/* 8dc -  */  0,
	/* 8dd -  */  0,
	/* 8de -  */  0,
	/* 8df -  */  0,
	/* 8e0 -  */  0,
	/* 8e1 -  */  0,
	/* 8e2 -  */  0,
	/* 8e3 -  */  0,
	/* 8e4 -  */  0,
	/* 8e5 -  */  0,
	/* 8e6 -  */  0,
	/* 8e7 -  */  0,
	/* 8e8 -  */  0,
	/* 8e9 -  */  0,
	/* 8ea -  */  0,
	/* 8eb -  */  0,
	/* 8ec -  */  0,
	/* 8ed -  */  0,
	/* 8ee -  */  0,
	/* 8ef -  */  0,
	/* 8f0 -  */  0,
	/* 8f1 -  */  0,
	/* 8f2 -  */  0,
	/* 8f3 -  */  0,
	/* 8f4 -  */  0,
	/* 8f5 -  */  0,
	/* 8f6 -  */  0,
	/* 8f7 -  */  0,
	/* 8f8 -  */  0,
	/* 8f9 -  */  0,
	/* 8fa -  */  0,
	/* 8fb -  */  0,
	/* 8fc -  */  0,
	/* 8fd -  */  0,
	/* 8fe -  */  0,
	/* 8ff -  */  0,
	/* 900 -  */  0,
	/* 901 -  */  0,
	/* 902 -  */  0,
	/* 903 -  */  0,
	/* 904 -  */  0,
	/* 905 -  */  0,
	/* 906 -  */  0,
	/* 907 -  */  0,
	/* 908 -  */  0,
	/* 909 -  */  0,
	/* 90a -  */  0,
	/* 90b -  */  0,
	/* 90c -  */  0,
	/* 90d -  */  0,
	/* 90e -  */  0,
	/* 90f -  */  0,
	/* 910 -  */  0,
	/* 911 -  */  0,
	/* 912 -  */  0,
	/* 913 -  */  0,
	/* 914 -  */  0,
	/* 915 -  */  0,
	/* 916 -  */  0,
	/* 917 -  */  0,
	/* 918 -  */  0,
	/* 919 -  */  0,
	/* 91a -  */  0,
	/* 91b -  */  0,
	/* 91c -  */  0,
	/* 91d -  */  0,
	/* 91e -  */  0,
	/* 91f -  */  0,
	/* 920 -  */  0,
	/* 921 -  */  0,
	/* 922 -  */  0,
	/* 923 -  */  0,
	/* 924 -  */  0,
	/* 925 -  */  0,
	/* 926 -  */  0,
	/* 927 -  */  0,
	/* 928 -  */  0,
	/* 929 -  */  0,
	/* 92a -  */  0,
	/* 92b -  */  0,
	/* 92c -  */  0,
	/* 92d -  */  0,
	/* 92e -  */  0,
	/* 92f -  */  0,
	/* 930 -  */  0,
	/* 931 -  */  0,
	/* 932 -  */  0,
	/* 933 -  */  0,
	/* 934 -  */  0,
	/* 935 -  */  0,
	/* 936 -  */  0,
	/* 937 -  */  0,
	/* 938 -  */  0,
	/* 939 -  */  0,
	/* 93a -  */  0,
	/* 93b -  */  0,
	/* 93c -  */  0,
	/* 93d -  */  0,
	/* 93e -  */  0,
	/* 93f -  */  0,
	/* 940 -  */  0,
	/* 941 -  */  0,
	/* 942 -  */  0,
	/* 943 -  */  0,
	/* 944 -  */  0,
	/* 945 -  */  0,
	/* 946 -  */  0,
	/* 947 - _0F_3A_DF */  0xd578,
	/* 948 -  */  0,
	/* 949 -  */  0,
	/* 94a -  */  0,
	/* 94b -  */  0,
	/* 94c -  */  0,
	/* 94d -  */  0,
	/* 94e -  */  0,
	/* 94f -  */  0,
	/* 950 -  */  0,
	/* 951 -  */  0,
	/* 952 -  */  0,
	/* 953 -  */  0,
	/* 954 -  */  0,
	/* 955 -  */  0,
	/* 956 -  */  0,
	/* 957 -  */  0,
	/* 958 -  */  0,
	/* 959 -  */  0,
	/* 95a -  */  0,
	/* 95b -  */  0,
	/* 95c -  */  0,
	/* 95d -  */  0,
	/* 95e -  */  0,
	/* 95f -  */  0,
	/* 960 -  */  0,
	/* 961 -  */  0,
	/* 962 -  */  0,
	/* 963 -  */  0,
	/* 964 -  */  0,
	/* 965 -  */  0,
	/* 966 -  */  0,
	/* 967 -  */  0,
	/* 968 - _0F_50 */  0x23a3,
	/* 969 - _66_0F_50 */  0x23a4,
	/* 96a -  */  0,
	/* 96b -  */  0,
	/* 96c - _V_0F_50 */  0x4036,
	/* 96d - _V_66_0F_50 */  0x4037,
	/* 96e -  */  0,
	/* 96f -  */  0,
	/* 970 -  */  0,
	/* 971 -  */  0,
	/* 972 -  */  0,
	/* 973 -  */  0,
	/* 974 - _0F_51 */  0x23a5,
	/* 975 - _66_0F_51 */  0x23a6,
	/* 976 - _F3_0F_51 */  0x23a7,
	/* 977 - _F2_0F_51 */  0x23a8,
	/* 978 - _V_0F_51 */  0x4038,
	/* 979 - _V_66_0F_51 */  0x4039,
	/* 97a - _V_F3_0F_51 */  0x403a,
	/* 97b - _V_F2_0F_51 */  0x403b,
	/* 97c -  */  0,
	/* 97d -  */  0,
	/* 97e -  */  0,
	/* 97f -  */  0,
	/* 980 - _0F_52 */  0x23a9,
	/* 981 -  */  0,
	/* 982 - _F3_0F_52 */  0x23aa,
	/* 983 -  */  0,
	/* 984 - _V_0F_52 */  0x403c,
	/* 985 -  */  0,
	/* 986 - _V_F3_0F_52 */  0x403d,
	/* 987 -  */  0,
	/* 988 -  */  0,
	/* 989 -  */  0,
	/* 98a -  */  0,
	/* 98b -  */  0,
	/* 98c - _0F_53 */  0x23ab,
	/* 98d -  */  0,
	/* 98e - _F3_0F_53 */  0x23ac,
	/* 98f -  */  0,
	/* 990 - _V_0F_53 */  0x403e,
	/* 991 -  */  0,
	/* 992 - _V_F3_0F_53 */  0x403f,
	/* 993 -  */  0,
	/* 994 -  */  0,
	/* 995 -  */  0,
	/* 996 -  */  0,
	/* 997 -  */  0,
	/* 998 - _0F_54 */  0x23ad,
	/* 999 - _66_0F_54 */  0x23ae,
	/* 99a -  */  0,
	/* 99b -  */  0,
	/* 99c - _V_0F_54 */  0x4040,
	/* 99d - _V_66_0F_54 */  0x4041,
	/* 99e -  */  0,
	/* 99f -  */  0,
	/* 9a0 -  */  0,
	/* 9a1 -  */  0,
	/* 9a2 -  */  0,
	/* 9a3 -  */  0,
	/* 9a4 - _0F_55 */  0x23af,
	/* 9a5 - _66_0F_55 */  0x23b0,
	/* 9a6 -  */  0,
	/* 9a7 -  */  0,
	/* 9a8 - _V_0F_55 */  0x4042,
	/* 9a9 - _V_66_0F_55 */  0x4043,
	/* 9aa -  */  0,
	/* 9ab -  */  0,
	/* 9ac -  */  0,
	/* 9ad -  */  0,
	/* 9ae -  */  0,
	/* 9af -  */  0,
	/* 9b0 - _0F_56 */  0x23b1,
	/* 9b1 - _66_0F_56 */  0x23b2,
	/* 9b2 -  */  0,
	/* 9b3 -  */  0,
	/* 9b4 - _V_0F_56 */  0x4044,
	/* 9b5 - _V_66_0F_56 */  0x4045,
	/* 9b6 -  */  0,
	/* 9b7 -  */  0,
	/* 9b8 -  */  0,
	/* 9b9 -  */  0,
	/* 9ba -  */  0,
	/* 9bb -  */  0,
	/* 9bc - _0F_57 */  0x23b3,
	/* 9bd - _66_0F_57 */  0x23b4,
	/* 9be -  */  0,
	/* 9bf -  */  0,
	/* 9c0 - _V_0F_57 */  0x4046,
	/* 9c1 - _V_66_0F_57 */  0x4047,
	/* 9c2 -  */  0,
	/* 9c3 -  */  0,
	/* 9c4 -  */  0,
	/* 9c5 -  */  0,
	/* 9c6 -  */  0,
	/* 9c7 -  */  0,
	/* 9c8 - _0F_58 */  0x23b5,
	/* 9c9 - _66_0F_58 */  0x23b6,
	/* 9ca - _F3_0F_58 */  0x23b7,
	/* 9cb - _F2_0F_58 */  0x23b8,
	/* 9cc - _V_0F_58 */  0x4048,
	/* 9cd - _V_66_0F_58 */  0x4049,
	/* 9ce - _V_F3_0F_58 */  0x404a,
	/* 9cf - _V_F2_0F_58 */  0x404b,
	/* 9d0 -  */  0,
	/* 9d1 -  */  0,
	/* 9d2 -  */  0,
	/* 9d3 -  */  0,
	/* 9d4 - _0F_59 */  0x23b9,
	/* 9d5 - _66_0F_59 */  0x23ba,
	/* 9d6 - _F3_0F_59 */  0x23bb,
	/* 9d7 - _F2_0F_59 */  0x23bc,
	/* 9d8 - _V_0F_59 */  0x404c,
	/* 9d9 - _V_66_0F_59 */  0x404d,
	/* 9da - _V_F3_0F_59 */  0x404e,
	/* 9db - _V_F2_0F_59 */  0x404f,
	/* 9dc -  */  0,
	/* 9dd -  */  0,
	/* 9de -  */  0,
	/* 9df -  */  0,
	/* 9e0 - _0F_5A */  0x23bd,
	/* 9e1 - _66_0F_5A */  0x23be,
	/* 9e2 - _F3_0F_5A */  0x23bf,
	/* 9e3 - _F2_0F_5A */  0x23c0,
	/* 9e4 - _V_0F_5A */  0x4050,
	/* 9e5 - _V_66_0F_5A */  0x4051,
	/* 9e6 - _V_F3_0F_5A */  0x4052,
	/* 9e7 - _V_F2_0F_5A */  0x4053,
	/* 9e8 -  */  0,
	/* 9e9 -  */  0,
	/* 9ea -  */  0,
	/* 9eb -  */  0,
	/* 9ec - _0F_5B */  0x23c1,
	/* 9ed - _66_0F_5B */  0x23c2,
	/* 9ee - _F3_0F_5B */  0x23c3,
	/* 9ef -  */  0,
	/* 9f0 - _V_0F_5B */  0x4054,
	/* 9f1 - _V_66_0F_5B */  0x4055,
	/* 9f2 - _V_F3_0F_5B */  0x4056,
	/* 9f3 -  */  0,
	/* 9f4 -  */  0,
	/* 9f5 -  */  0,
	/* 9f6 -  */  0,
	/* 9f7 -  */  0,
	/* 9f8 - _0F_5C */  0x23c4,
	/* 9f9 - _66_0F_5C */  0x23c5,
	/* 9fa - _F3_0F_5C */  0x23c6,
	/* 9fb - _F2_0F_5C */  0x23c7,
	/* 9fc - _V_0F_5C */  0x4057,
	/* 9fd - _V_66_0F_5C */  0x4058,
	/* 9fe - _V_F3_0F_5C */  0x4059,
	/* 9ff - _V_F2_0F_5C */  0x405a,
	/* a00 -  */  0,
	/* a01 -  */  0,
	/* a02 -  */  0,
	/* a03 -  */  0,
	/* a04 - _0F_5D */  0x23c8,
	/* a05 - _66_0F_5D */  0x23c9,
	/* a06 - _F3_0F_5D */  0x23ca,
	/* a07 - _F2_0F_5D */  0x23cb,
	/* a08 - _V_0F_5D */  0x405b,
	/* a09 - _V_66_0F_5D */  0x405c,
	/* a0a - _V_F3_0F_5D */  0x405d,
	/* a0b - _V_F2_0F_5D */  0x405e,
	/* a0c -  */  0,
	/* a0d -  */  0,
	/* a0e -  */  0,
	/* a0f -  */  0,
	/* a10 - _0F_5E */  0x23cc,
	/* a11 - _66_0F_5E */  0x23cd,
	/* a12 - _F3_0F_5E */  0x23ce,
	/* a13 - _F2_0F_5E */  0x23cf,
	/* a14 - _V_0F_5E */  0x405f,
	/* a15 - _V_66_0F_5E */  0x4060,
	/* a16 - _V_F3_0F_5E */  0x4061,
	/* a17 - _V_F2_0F_5E */  0x4062,
	/* a18 -  */  0,
	/* a19 -  */  0,
	/* a1a -  */  0,
	/* a1b -  */  0,
	/* a1c - _0F_5F */  0x23d0,
	/* a1d - _66_0F_5F */  0x23d1,
	/* a1e - _F3_0F_5F */  0x23d2,
	/* a1f - _F2_0F_5F */  0x23d3,
	/* a20 - _V_0F_5F */  0x4063,
	/* a21 - _V_66_0F_5F */  0x4064,
	/* a22 - _V_F3_0F_5F */  0x4065,
	/* a23 - _V_F2_0F_5F */  0x4066,
	/* a24 -  */  0,
	/* a25 -  */  0,
	/* a26 -  */  0,
	/* a27 -  */  0,
	/* a28 - _0F_60 */  0x23d4,
	/* a29 - _66_0F_60 */  0x23d5,
	/* a2a -  */  0,
	/* a2b -  */  0,
	/* a2c -  */  0,
	/* a2d - _V_66_0F_60 */  0x4067,
	/* a2e -  */  0,
	/* a2f -  */  0,
	/* a30 -  */  0,
	/* a31 -  */  0,
	/* a32 -  */  0,
	/* a33 -  */  0,
	/* a34 - _0F_61 */  0x23d6,
	/* a35 - _66_0F_61 */  0x23d7,
	/* a36 -  */  0,
	/* a37 -  */  0,
	/* a38 -  */  0,
	/* a39 - _V_66_0F_61 */  0x4068,
	/* a3a -  */  0,
	/* a3b -  */  0,
	/* a3c -  */  0,
	/* a3d -  */  0,
	/* a3e -  */  0,
	/* a3f -  */  0,
	/* a40 - _0F_62 */  0x23d8,
	/* a41 - _66_0F_62 */  0x23d9,
	/* a42 -  */  0,
	/* a43 -  */  0,
	/* a44 -  */  0,
	/* a45 - _V_66_0F_62 */  0x4069,
	/* a46 -  */  0,
	/* a47 -  */  0,
	/* a48 -  */  0,
	/* a49 -  */  0,
	/* a4a -  */  0,
	/* a4b -  */  0,
	/* a4c - _0F_63 */  0x23da,
	/* a4d - _66_0F_63 */  0x23db,
	/* a4e -  */  0,
	/* a4f -  */  0,
	/* a50 -  */  0,
	/* a51 - _V_66_0F_63 */  0x406a,
	/* a52 -  */  0,
	/* a53 -  */  0,
	/* a54 -  */  0,
	/* a55 -  */  0,
	/* a56 -  */  0,
	/* a57 -  */  0,
	/* a58 - _0F_64 */  0x23dc,
	/* a59 - _66_0F_64 */  0x23dd,
	/* a5a -  */  0,
	/* a5b -  */  0,
	/* a5c -  */  0,
	/* a5d - _V_66_0F_64 */  0x406b,
	/* a5e -  */  0,
	/* a5f -  */  0,
	/* a60 -  */  0,
	/* a61 -  */  0,
	/* a62 -  */  0,
	/* a63 -  */  0,
	/* a64 - _0F_65 */  0x23de,
	/* a65 - _66_0F_65 */  0x23df,
	/* a66 -  */  0,
	/* a67 -  */  0,
	/* a68 -  */  0,
	/* a69 - _V_66_0F_65 */  0x406c,
	/* a6a -  */  0,
	/* a6b -  */  0,
	/* a6c -  */  0,
	/* a6d -  */  0,
	/* a6e -  */  0,
	/* a6f -  */  0,
	/* a70 - _0F_66 */  0x23e0,
	/* a71 - _66_0F_66 */  0x23e1,
	/* a72 -  */  0,
	/* a73 -  */  0,
	/* a74 -  */  0,
	/* a75 - _V_66_0F_66 */  0x406d,
	/* a76 -  */  0,
	/* a77 -  */  0,
	/* a78 -  */  0,
	/* a79 -  */  0,
	/* a7a -  */  0,
	/* a7b -  */  0,
	/* a7c - _0F_67 */  0x23e2,
	/* a7d - _66_0F_67 */  0x23e3,
	/* a7e -  */  0,
	/* a7f -  */  0,
	/* a80 -  */  0,
	/* a81 - _V_66_0F_67 */  0x406e,
	/* a82 -  */  0,
	/* a83 -  */  0,
	/* a84 -  */  0,
	/* a85 -  */  0,
	/* a86 -  */  0,
	/* a87 -  */  0,
	/* a88 - _0F_68 */  0x23e4,
	/* a89 - _66_0F_68 */  0x23e5,
	/* a8a -  */  0,
	/* a8b -  */  0,
	/* a8c -  */  0,
	/* a8d - _V_66_0F_68 */  0x406f,
	/* a8e -  */  0,
	/* a8f -  */  0,
	/* a90 -  */  0,
	/* a91 -  */  0,
	/* a92 -  */  0,
	/* a93 -  */  0,
	/* a94 - _0F_69 */  0x23e6,
	/* a95 - _66_0F_69 */  0x23e7,
	/* a96 -  */  0,
	/* a97 -  */  0,
	/* a98 -  */  0,
	/* a99 - _V_66_0F_69 */  0x4070,
	/* a9a -  */  0,
	/* a9b -  */  0,
	/* a9c -  */  0,
	/* a9d -  */  0,
	/* a9e -  */  0,
	/* a9f -  */  0,
	/* aa0 - _0F_6A */  0x23e8,
	/* aa1 - _66_0F_6A */  0x23e9,
	/* aa2 -  */  0,
	/* aa3 -  */  0,
	/* aa4 -  */  0,
	/* aa5 - _V_66_0F_6A */  0x4071,
	/* aa6 -  */  0,
	/* aa7 -  */  0,
	/* aa8 -  */  0,
	/* aa9 -  */  0,
	/* aaa -  */  0,
	/* aab -  */  0,
	/* aac - _0F_6B */  0x23ea,
	/* aad - _66_0F_6B */  0x23eb,
	/* aae -  */  0,
	/* aaf -  */  0,
	/* ab0 -  */  0,
	/* ab1 - _V_66_0F_6B */  0x4072,
	/* ab2 -  */  0,
	/* ab3 -  */  0,
	/* ab4 -  */  0,
	/* ab5 -  */  0,
	/* ab6 -  */  0,
	/* ab7 -  */  0,
	/* ab8 -  */  0,
	/* ab9 - _66_0F_6C */  0x23ec,
	/* aba -  */  0,
	/* abb -  */  0,
	/* abc -  */  0,
	/* abd - _V_66_0F_6C */  0x4073,
	/* abe -  */  0,
	/* abf -  */  0,
	/* ac0 -  */  0,
	/* ac1 -  */  0,
	/* ac2 -  */  0,
	/* ac3 -  */  0,
	/* ac4 -  */  0,
	/* ac5 - _66_0F_6D */  0x23ed,
	/* ac6 -  */  0,
	/* ac7 -  */  0,
	/* ac8 -  */  0,
	/* ac9 - _V_66_0F_6D */  0x4074,
	/* aca -  */  0,
	/* acb -  */  0,
	/* acc -  */  0,
	/* acd -  */  0,
	/* ace -  */  0,
	/* acf -  */  0,
	/* ad0 - _0F_6E */  0x4075,
	/* ad1 - _66_0F_6E */  0x4076,
	/* ad2 -  */  0,
	/* ad3 -  */  0,
	/* ad4 -  */  0,
	/* ad5 - _V_66_0F_6E */  0x4077,
	/* ad6 -  */  0,
	/* ad7 -  */  0,
	/* ad8 -  */  0,
	/* ad9 -  */  0,
	/* ada -  */  0,
	/* adb -  */  0,
	/* adc - _0F_6F */  0x23ee,
	/* add - _66_0F_6F */  0x23ef,
	/* ade - _F3_0F_6F */  0x23f0,
	/* adf -  */  0,
	/* ae0 -  */  0,
	/* ae1 - _V_66_0F_6F */  0x4078,
	/* ae2 - _V_F3_0F_6F */  0x4079,
	/* ae3 -  */  0,
	/* ae4 -  */  0,
	/* ae5 -  */  0,
	/* ae6 -  */  0,
	/* ae7 -  */  0,
	/* ae8 - _0F_70 */  0x407a,
	/* ae9 - _66_0F_70 */  0x407b,
	/* aea - _F3_0F_70 */  0x407c,
	/* aeb - _F2_0F_70 */  0x407d,
	/* aec -  */  0,
	/* aed - _V_66_0F_70 */  0x407e,
	/* aee - _V_F3_0F_70 */  0x407f,
	/* aef - _V_F2_0F_70 */  0x4080,
	/* af0 -  */  0,
	/* af1 -  */  0,
	/* af2 -  */  0,
	/* af3 -  */  0,
	/* af4 -  */  0,
	/* af5 -  */  0,
	/* af6 - _0F_71_02 */  0xd584,
	/* af7 -  */  0,
	/* af8 - _0F_71_04 */  0xd590,
	/* af9 -  */  0,
	/* afa - _0F_71_06 */  0xd59c,
	/* afb -  */  0,
	/* afc -  */  0,
	/* afd -  */  0,
	/* afe - _0F_72_02 */  0xd5a8,
	/* aff -  */  0,
	/* b00 - _0F_72_04 */  0xd5b4,
	/* b01 -  */  0,
	/* b02 - _0F_72_06 */  0xd5c0,
	/* b03 -  */  0,
	/* b04 -  */  0,
	/* b05 -  */  0,
	/* b06 - _0F_73_02 */  0xd5cc,
	/* b07 - _0F_73_03 */  0xd5d8,
	/* b08 -  */  0,
	/* b09 -  */  0,
	/* b0a - _0F_73_06 */  0xd5e4,
	/* b0b - _0F_73_07 */  0xd5f0,
	/* b0c - _0F_74 */  0x23f1,
	/* b0d - _66_0F_74 */  0x23f2,
	/* b0e -  */  0,
	/* b0f -  */  0,
	/* b10 -  */  0,
	/* b11 - _V_66_0F_74 */  0x4081,
	/* b12 -  */  0,
	/* b13 -  */  0,
	/* b14 -  */  0,
	/* b15 -  */  0,
	/* b16 -  */  0,
	/* b17 -  */  0,
	/* b18 - _0F_75 */  0x23f3,
	/* b19 - _66_0F_75 */  0x23f4,
	/* b1a -  */  0,
	/* b1b -  */  0,
	/* b1c -  */  0,
	/* b1d - _V_66_0F_75 */  0x4082,
	/* b1e -  */  0,
	/* b1f -  */  0,
	/* b20 -  */  0,
	/* b21 -  */  0,
	/* b22 -  */  0,
	/* b23 -  */  0,
	/* b24 - _0F_76 */  0x23f5,
	/* b25 - _66_0F_76 */  0x23f6,
	/* b26 -  */  0,
	/* b27 -  */  0,
	/* b28 -  */  0,
	/* b29 - _V_66_0F_76 */  0x4083,
	/* b2a -  */  0,
	/* b2b -  */  0,
	/* b2c -  */  0,
	/* b2d -  */  0,
	/* b2e -  */  0,
	/* b2f -  */  0,
	/* b30 - _0F_77 */  0x23f7,
	/* b31 -  */  0,
	/* b32 -  */  0,
	/* b33 -  */  0,
	/* b34 - _V_0F_77 */  0x4084,
	/* b35 -  */  0,
	/* b36 -  */  0,
	/* b37 -  */  0,
	/* b38 -  */  0,
	/* b39 -  */  0,
	/* b3a -  */  0,
	/* b3b -  */  0,
	/* b3c - _0F_78 */  0x23f8,
	/* b3d - _66_0F_78 */  0x4085,
	/* b3e -  */  0,
	/* b3f - _F2_0F_78 */  0x4086,
	/* b40 -  */  0,
	/* b41 -  */  0,
	/* b42 -  */  0,
	/* b43 -  */  0,
	/* b44 -  */  0,
	/* b45 -  */  0,
	/* b46 -  */  0,
	/* b47 -  */  0,
	/* b48 - _0F_79 */  0x23f9,
	/* b49 - _66_0F_79 */  0x23fa,
	/* b4a -  */  0,
	/* b4b - _F2_0F_79 */  0x23fb,
	/* b4c -  */  0,
	/* b4d -  */  0,
	/* b4e -  */  0,
	/* b4f -  */  0,
	/* b50 -  */  0,
	/* b51 -  */  0,
	/* b52 -  */  0,
	/* b53 -  */  0,
	/* b54 -  */  0,
	/* b55 -  */  0,
	/* b56 -  */  0,
	/* b57 -  */  0,
	/* b58 -  */  0,
	/* b59 -  */  0,
	/* b5a -  */  0,
	/* b5b -  */  0,
	/* b5c -  */  0,
	/* b5d -  */  0,
	/* b5e -  */  0,
	/* b5f -  */  0,
	/* b60 -  */  0,
	/* b61 -  */  0,
	/* b62 -  */  0,
	/* b63 -  */  0,
	/* b64 -  */  0,
	/* b65 -  */  0,
	/* b66 -  */  0,
	/* b67 -  */  0,
	/* b68 -  */  0,
	/* b69 -  */  0,
	/* b6a -  */  0,
	/* b6b -  */  0,
	/* b6c -  */  0,
	/* b6d -  */  0,
	/* b6e -  */  0,
	/* b6f -  */  0,
	/* b70 -  */  0,
	/* b71 -  */  0,
	/* b72 -  */  0,
	/* b73 -  */  0,
	/* b74 -  */  0,
	/* b75 -  */  0,
	/* b76 -  */  0,
	/* b77 -  */  0,
	/* b78 -  */  0,
	/* b79 -  */  0,
	/* b7a -  */  0,
	/* b7b -  */  0,
	/* b7c -  */  0,
	/* b7d -  */  0,
	/* b7e -  */  0,
	/* b7f -  */  0,
	/* b80 -  */  0,
	/* b81 -  */  0,
	/* b82 -  */  0,
	/* b83 -  */  0,
	/* b84 - _0F_7A_30 */  0x23fc,
	/* b85 - _0F_7A_31 */  0x23fd,
	/* b86 -  */  0,
	/* b87 -  */  0,
	/* b88 -  */  0,
	/* b89 -  */  0,
	/* b8a -  */  0,
	/* b8b -  */  0,
	/* b8c -  */  0,
	/* b8d -  */  0,
	/* b8e -  */  0,
	/* b8f -  */  0,
	/* b90 -  */  0,
	/* b91 -  */  0,
	/* b92 -  */  0,
	/* b93 -  */  0,
	/* b94 -  */  0,
	/* b95 -  */  0,
	/* b96 -  */  0,
	/* b97 -  */  0,
	/* b98 -  */  0,
	/* b99 -  */  0,
	/* b9a -  */  0,
	/* b9b -  */  0,
	/* b9c -  */  0,
	/* b9d -  */  0,
	/* b9e -  */  0,
	/* b9f -  */  0,
	/* ba0 -  */  0,
	/* ba1 -  */  0,
	/* ba2 -  */  0,
	/* ba3 -  */  0,
	/* ba4 -  */  0,
	/* ba5 -  */  0,
	/* ba6 -  */  0,
	/* ba7 -  */  0,
	/* ba8 -  */  0,
	/* ba9 -  */  0,
	/* baa -  */  0,
	/* bab -  */  0,
	/* bac -  */  0,
	/* bad -  */  0,
	/* bae -  */  0,
	/* baf -  */  0,
	/* bb0 -  */  0,
	/* bb1 -  */  0,
	/* bb2 -  */  0,
	/* bb3 -  */  0,
	/* bb4 -  */  0,
	/* bb5 -  */  0,
	/* bb6 -  */  0,
	/* bb7 -  */  0,
	/* bb8 -  */  0,
	/* bb9 -  */  0,
	/* bba -  */  0,
	/* bbb -  */  0,
	/* bbc -  */  0,
	/* bbd -  */  0,
	/* bbe -  */  0,
	/* bbf -  */  0,
	/* bc0 -  */  0,
	/* bc1 -  */  0,
	/* bc2 -  */  0,
	/* bc3 -  */  0,
	/* bc4 -  */  0,
	/* bc5 -  */  0,
	/* bc6 -  */  0,
	/* bc7 -  */  0,
	/* bc8 -  */  0,
	/* bc9 -  */  0,
	/* bca -  */  0,
	/* bcb -  */  0,
	/* bcc -  */  0,
	/* bcd -  */  0,
	/* bce -  */  0,
	/* bcf -  */  0,
	/* bd0 -  */  0,
	/* bd1 -  */  0,
	/* bd2 -  */  0,
	/* bd3 -  */  0,
	/* bd4 -  */  0,
	/* bd5 -  */  0,
	/* bd6 -  */  0,
	/* bd7 -  */  0,
	/* bd8 -  */  0,
	/* bd9 -  */  0,
	/* bda -  */  0,
	/* bdb -  */  0,
	/* bdc -  */  0,
	/* bdd -  */  0,
	/* bde -  */  0,
	/* bdf -  */  0,
	/* be0 -  */  0,
	/* be1 -  */  0,
	/* be2 -  */  0,
	/* be3 -  */  0,
	/* be4 -  */  0,
	/* be5 -  */  0,
	/* be6 -  */  0,
	/* be7 -  */  0,
	/* be8 -  */  0,
	/* be9 -  */  0,
	/* bea -  */  0,
	/* beb -  */  0,
	/* bec -  */  0,
	/* bed -  */  0,
	/* bee -  */  0,
	/* bef -  */  0,
	/* bf0 -  */  0,
	/* bf1 -  */  0,
	/* bf2 -  */  0,
	/* bf3 -  */  0,
	/* bf4 -  */  0,
	/* bf5 -  */  0,
	/* bf6 -  */  0,
	/* bf7 -  */  0,
	/* bf8 -  */  0,
	/* bf9 -  */  0,
	/* bfa -  */  0,
	/* bfb -  */  0,
	/* bfc -  */  0,
	/* bfd -  */  0,
	/* bfe -  */  0,
	/* bff -  */  0,
	/* c00 -  */  0,
	/* c01 -  */  0,
	/* c02 -  */  0,
	/* c03 -  */  0,
	/* c04 -  */  0,
	/* c05 -  */  0,
	/* c06 -  */  0,
	/* c07 -  */  0,
	/* c08 -  */  0,
	/* c09 -  */  0,
	/* c0a -  */  0,
	/* c0b -  */  0,
	/* c0c -  */  0,
	/* c0d -  */  0,
	/* c0e -  */  0,
	/* c0f -  */  0,
	/* c10 -  */  0,
	/* c11 -  */  0,
	/* c12 -  */  0,
	/* c13 -  */  0,
	/* c14 -  */  0,
	/* c15 -  */  0,
	/* c16 -  */  0,
	/* c17 -  */  0,
	/* c18 -  */  0,
	/* c19 -  */  0,
	/* c1a -  */  0,
	/* c1b -  */  0,
	/* c1c -  */  0,
	/* c1d -  */  0,
	/* c1e -  */  0,
	/* c1f -  */  0,
	/* c20 -  */  0,
	/* c21 -  */  0,
	/* c22 -  */  0,
	/* c23 -  */  0,
	/* c24 -  */  0,
	/* c25 -  */  0,
	/* c26 -  */  0,
	/* c27 -  */  0,
	/* c28 -  */  0,
	/* c29 -  */  0,
	/* c2a -  */  0,
	/* c2b -  */  0,
	/* c2c -  */  0,
	/* c2d -  */  0,
	/* c2e -  */  0,
	/* c2f -  */  0,
	/* c30 -  */  0,
	/* c31 -  */  0,
	/* c32 -  */  0,
	/* c33 -  */  0,
	/* c34 -  */  0,
	/* c35 -  */  0,
	/* c36 -  */  0,
	/* c37 -  */  0,
	/* c38 -  */  0,
	/* c39 -  */  0,
	/* c3a -  */  0,
	/* c3b -  */  0,
	/* c3c -  */  0,
	/* c3d -  */  0,
	/* c3e -  */  0,
	/* c3f -  */  0,
	/* c40 -  */  0,
	/* c41 -  */  0,
	/* c42 -  */  0,
	/* c43 -  */  0,
	/* c44 -  */  0,
	/* c45 -  */  0,
	/* c46 -  */  0,
	/* c47 -  */  0,
	/* c48 -  */  0,
	/* c49 -  */  0,
	/* c4a -  */  0,
	/* c4b -  */  0,
	/* c4c -  */  0,
	/* c4d -  */  0,
	/* c4e -  */  0,
	/* c4f -  */  0,
	/* c50 -  */  0,
	/* c51 -  */  0,
	/* c52 -  */  0,
	/* c53 -  */  0,
	/* c54 -  */  0,
	/* c55 - _66_0F_7C */  0x23fe,
	/* c56 -  */  0,
	/* c57 - _F2_0F_7C */  0x23ff,
	/* c58 -  */  0,
	/* c59 - _V_66_0F_7C */  0x4087,
	/* c5a -  */  0,
	/* c5b - _V_F2_0F_7C */  0x4088,
	/* c5c -  */  0,
	/* c5d -  */  0,
	/* c5e -  */  0,
	/* c5f -  */  0,
	/* c60 -  */  0,
	/* c61 - _66_0F_7D */  0x2400,
	/* c62 -  */  0,
	/* c63 - _F2_0F_7D */  0x2401,
	/* c64 -  */  0,
	/* c65 - _V_66_0F_7D */  0x4089,
	/* c66 -  */  0,
	/* c67 - _V_F2_0F_7D */  0x408a,
	/* c68 -  */  0,
	/* c69 -  */  0,
	/* c6a -  */  0,
	/* c6b -  */  0,
	/* c6c - _0F_7E */  0x408b,
	/* c6d - _66_0F_7E */  0x408c,
	/* c6e - _F3_0F_7E */  0x2402,
	/* c6f -  */  0,
	/* c70 -  */  0,
	/* c71 - _V_66_0F_7E */  0x408d,
	/* c72 - _V_F3_0F_7E */  0x408e,
	/* c73 -  */  0,
	/* c74 -  */  0,
	/* c75 -  */  0,
	/* c76 -  */  0,
	/* c77 -  */  0,
	/* c78 - _0F_7F */  0x2403,
	/* c79 - _66_0F_7F */  0x2404,
	/* c7a - _F3_0F_7F */  0x2405,
	/* c7b -  */  0,
	/* c7c -  */  0,
	/* c7d - _V_66_0F_7F */  0x408f,
	/* c7e - _V_F3_0F_7F */  0x4090,
	/* c7f -  */  0,
	/* c80 -  */  0,
	/* c81 -  */  0,
	/* c82 -  */  0,
	/* c83 -  */  0,
	/* c84 - _0F_AE_00 */  0xd5fc,
	/* c85 - _0F_AE_01 */  0xd608,
	/* c86 - _0F_AE_02 */  0xd614,
	/* c87 - _0F_AE_03 */  0xd620,
	/* c88 - _0F_AE_04 */  0x4091,
	/* c89 - _0F_AE_05 */  0x4092,
	/* c8a - _0F_AE_06 */  0x4093,
	/* c8b - _0F_AE_07 */  0x4094,
	/* c8c -  */  0,
	/* c8d -  */  0,
	/* c8e - _F3_0F_B8 */  0x2406,
	/* c8f -  */  0,
	/* c90 -  */  0,
	/* c91 -  */  0,
	/* c92 -  */  0,
	/* c93 -  */  0,
	/* c94 -  */  0,
	/* c95 -  */  0,
	/* c96 -  */  0,
	/* c97 -  */  0,
	/* c98 -  */  0,
	/* c99 -  */  0,
	/* c9a -  */  0,
	/* c9b -  */  0,
	/* c9c - _0F_BA_04 */  0x2407,
	/* c9d - _0F_BA_05 */  0x2408,
	/* c9e - _0F_BA_06 */  0x2409,
	/* c9f - _0F_BA_07 */  0x240a,
	/* ca0 - _0F_BC */  0x240b,
	/* ca1 -  */  0,
	/* ca2 - _F3_0F_BC */  0x240c,
	/* ca3 -  */  0,
	/* ca4 -  */  0,
	/* ca5 -  */  0,
	/* ca6 -  */  0,
	/* ca7 -  */  0,
	/* ca8 -  */  0,
	/* ca9 -  */  0,
	/* caa -  */  0,
	/* cab -  */  0,
	/* cac - _0F_BD */  0x240d,
	/* cad -  */  0,
	/* cae - _F3_0F_BD */  0x240e,
	/* caf -  */  0,
	/* cb0 -  */  0,
	/* cb1 -  */  0,
	/* cb2 -  */  0,
	/* cb3 -  */  0,
	/* cb4 -  */  0,
	/* cb5 -  */  0,
	/* cb6 -  */  0,
	/* cb7 -  */  0,
	/* cb8 - _0F_C2 */  0x4095,
	/* cb9 - _66_0F_C2 */  0x4096,
	/* cba - _F3_0F_C2 */  0x4097,
	/* cbb - _F2_0F_C2 */  0x4098,
	/* cbc - _V_0F_C2 */  0x4099,
	/* cbd - _V_66_0F_C2 */  0x409a,
	/* cbe - _V_F3_0F_C2 */  0x409b,
	/* cbf - _V_F2_0F_C2 */  0x409c,
	/* cc0 -  */  0,
	/* cc1 -  */  0,
	/* cc2 -  */  0,
	/* cc3 -  */  0,
	/* cc4 - _0F_C4 */  0x409d,
	/* cc5 - _66_0F_C4 */  0x409e,
	/* cc6 -  */  0,
	/* cc7 -  */  0,
	/* cc8 -  */  0,
	/* cc9 - _V_66_0F_C4 */  0x409f,
	/* cca -  */  0,
	/* ccb -  */  0,
	/* ccc -  */  0,
	/* ccd -  */  0,
	/* cce -  */  0,
	/* ccf -  */  0,
	/* cd0 - _0F_C5 */  0x40a0,
	/* cd1 - _66_0F_C5 */  0x40a1,
	/* cd2 -  */  0,
	/* cd3 -  */  0,
	/* cd4 -  */  0,
	/* cd5 - _V_66_0F_C5 */  0x40a2,
	/* cd6 -  */  0,
	/* cd7 -  */  0,
	/* cd8 -  */  0,
	/* cd9 -  */  0,
	/* cda -  */  0,
	/* cdb -  */  0,
	/* cdc - _0F_C6 */  0x40a3,
	/* cdd - _66_0F_C6 */  0x40a4,
	/* cde -  */  0,
	/* cdf -  */  0,
	/* ce0 - _V_0F_C6 */  0x40a5,
	/* ce1 - _V_66_0F_C6 */  0x40a6,
	/* ce2 -  */  0,
	/* ce3 -  */  0,
	/* ce4 -  */  0,
	/* ce5 -  */  0,
	/* ce6 -  */  0,
	/* ce7 -  */  0,
	/* ce8 -  */  0,
	/* ce9 - _0F_C7_01 */  0x40a7,
	/* cea -  */  0,
	/* ceb -  */  0,
	/* cec -  */  0,
	/* ced -  */  0,
	/* cee - _0F_C7_06 */  0xd62c,
	/* cef - _0F_C7_07 */  0x240f,
	/* cf0 -  */  0,
	/* cf1 - _66_0F_D0 */  0x2410,
	/* cf2 -  */  0,
	/* cf3 - _F2_0F_D0 */  0x2411,
	/* cf4 -  */  0,
	/* cf5 - _V_66_0F_D0 */  0x40a8,
	/* cf6 -  */  0,
	/* cf7 - _V_F2_0F_D0 */  0x40a9,
	/* cf8 -  */  0,
	/* cf9 -  */  0,
	/* cfa -  */  0,
	/* cfb -  */  0,
	/* cfc - _0F_D1 */  0x2412,
	/* cfd - _66_0F_D1 */  0x2413,
	/* cfe -  */  0,
	/* cff -  */  0,
	/* d00 -  */  0,
	/* d01 - _V_66_0F_D1 */  0x40aa,
	/* d02 -  */  0,
	/* d03 -  */  0,
	/* d04 -  */  0,
	/* d05 -  */  0,
	/* d06 -  */  0,
	/* d07 -  */  0,
	/* d08 - _0F_D2 */  0x2414,
	/* d09 - _66_0F_D2 */  0x2415,
	/* d0a -  */  0,
	/* d0b -  */  0,
	/* d0c -  */  0,
	/* d0d - _V_66_0F_D2 */  0x40ab,
	/* d0e -  */  0,
	/* d0f -  */  0,
	/* d10 -  */  0,
	/* d11 -  */  0,
	/* d12 -  */  0,
	/* d13 -  */  0,
	/* d14 - _0F_D3 */  0x2416,
	/* d15 - _66_0F_D3 */  0x2417,
	/* d16 -  */  0,
	/* d17 -  */  0,
	/* d18 -  */  0,
	/* d19 - _V_66_0F_D3 */  0x40ac,
	/* d1a -  */  0,
	/* d1b -  */  0,
	/* d1c -  */  0,
	/* d1d -  */  0,
	/* d1e -  */  0,
	/* d1f -  */  0,
	/* d20 - _0F_D4 */  0x2418,
	/* d21 - _66_0F_D4 */  0x2419,
	/* d22 -  */  0,
	/* d23 -  */  0,
	/* d24 -  */  0,
	/* d25 - _V_66_0F_D4 */  0x40ad,
	/* d26 -  */  0,
	/* d27 -  */  0,
	/* d28 -  */  0,
	/* d29 -  */  0,
	/* d2a -  */  0,
	/* d2b -  */  0,
	/* d2c - _0F_D5 */  0x241a,
	/* d2d - _66_0F_D5 */  0x241b,
	/* d2e -  */  0,
	/* d2f -  */  0,
	/* d30 -  */  0,
	/* d31 - _V_66_0F_D5 */  0x40ae,
	/* d32 -  */  0,
	/* d33 -  */  0,
	/* d34 -  */  0,
	/* d35 -  */  0,
	/* d36 -  */  0,
	/* d37 -  */  0,
	/* d38 -  */  0,
	/* d39 - _66_0F_D6 */  0x241c,
	/* d3a - _F3_0F_D6 */  0x241d,
	/* d3b - _F2_0F_D6 */  0x241e,
	/* d3c -  */  0,
	/* d3d - _V_66_0F_D6 */  0x40af,
	/* d3e -  */  0,
	/* d3f -  */  0,
	/* d40 -  */  0,
	/* d41 -  */  0,
	/* d42 -  */  0,
	/* d43 -  */  0,
	/* d44 - _0F_D7 */  0x241f,
	/* d45 - _66_0F_D7 */  0x2420,
	/* d46 -  */  0,
	/* d47 -  */  0,
	/* d48 -  */  0,
	/* d49 - _V_66_0F_D7 */  0x40b0,
	/* d4a -  */  0,
	/* d4b -  */  0,
	/* d4c -  */  0,
	/* d4d -  */  0,
	/* d4e -  */  0,
	/* d4f -  */  0,
	/* d50 - _0F_D8 */  0x2421,
	/* d51 - _66_0F_D8 */  0x2422,
	/* d52 -  */  0,
	/* d53 -  */  0,
	/* d54 -  */  0,
	/* d55 - _V_66_0F_D8 */  0x40b1,
	/* d56 -  */  0,
	/* d57 -  */  0,
	/* d58 -  */  0,
	/* d59 -  */  0,
	/* d5a -  */  0,
	/* d5b -  */  0,
	/* d5c - _0F_D9 */  0x2423,
	/* d5d - _66_0F_D9 */  0x2424,
	/* d5e -  */  0,
	/* d5f -  */  0,
	/* d60 -  */  0,
	/* d61 - _V_66_0F_D9 */  0x40b2,
	/* d62 -  */  0,
	/* d63 -  */  0,
	/* d64 -  */  0,
	/* d65 -  */  0,
	/* d66 -  */  0,
	/* d67 -  */  0,
	/* d68 - _0F_DA */  0x2425,
	/* d69 - _66_0F_DA */  0x2426,
	/* d6a -  */  0,
	/* d6b -  */  0,
	/* d6c -  */  0,
	/* d6d - _V_66_0F_DA */  0x40b3,
	/* d6e -  */  0,
	/* d6f -  */  0,
	/* d70 -  */  0,
	/* d71 -  */  0,
	/* d72 -  */  0,
	/* d73 -  */  0,
	/* d74 - _0F_DB */  0x2427,
	/* d75 - _66_0F_DB */  0x2428,
	/* d76 -  */  0,
	/* d77 -  */  0,
	/* d78 -  */  0,
	/* d79 - _V_66_0F_DB */  0x40b4,
	/* d7a -  */  0,
	/* d7b -  */  0,
	/* d7c -  */  0,
	/* d7d -  */  0,
	/* d7e -  */  0,
	/* d7f -  */  0,
	/* d80 - _0F_DC */  0x2429,
	/* d81 - _66_0F_DC */  0x242a,
	/* d82 -  */  0,
	/* d83 -  */  0,
	/* d84 -  */  0,
	/* d85 - _V_66_0F_DC */  0x40b5,
	/* d86 -  */  0,
	/* d87 -  */  0,
	/* d88 -  */  0,
	/* d89 -  */  0,
	/* d8a -  */  0,
	/* d8b -  */  0,
	/* d8c - _0F_DD */  0x242b,
	/* d8d - _66_0F_DD */  0x242c,
	/* d8e -  */  0,
	/* d8f -  */  0,
	/* d90 -  */  0,
	/* d91 - _V_66_0F_DD */  0x40b6,
	/* d92 -  */  0,
	/* d93 -  */  0,
	/* d94 -  */  0,
	/* d95 -  */  0,
	/* d96 -  */  0,
	/* d97 -  */  0,
	/* d98 - _0F_DE */  0x242d,
	/* d99 - _66_0F_DE */  0x242e,
	/* d9a -  */  0,
	/* d9b -  */  0,
	/* d9c -  */  0,
	/* d9d - _V_66_0F_DE */  0x40b7,
	/* d9e -  */  0,
	/* d9f -  */  0,
	/* da0 -  */  0,
	/* da1 -  */  0,
	/* da2 -  */  0,
	/* da3 -  */  0,
	/* da4 - _0F_DF */  0x242f,
	/* da5 - _66_0F_DF */  0x2430,
	/* da6 -  */  0,
	/* da7 -  */  0,
	/* da8 -  */  0,
	/* da9 - _V_66_0F_DF */  0x40b8,
	/* daa -  */  0,
	/* dab -  */  0,
	/* dac -  */  0,
	/* dad -  */  0,
	/* dae -  */  0,
	/* daf -  */  0,
	/* db0 - _0F_E0 */  0x2431,
	/* db1 - _66_0F_E0 */  0x2432,
	/* db2 -  */  0,
	/* db3 -  */  0,
	/* db4 -  */  0,
	/* db5 - _V_66_0F_E0 */  0x40b9,
	/* db6 -  */  0,
	/* db7 -  */  0,
	/* db8 -  */  0,
	/* db9 -  */  0,
	/* dba -  */  0,
	/* dbb -  */  0,
	/* dbc - _0F_E1 */  0x2433,
	/* dbd - _66_0F_E1 */  0x2434,
	/* dbe -  */  0,
	/* dbf -  */  0,
	/* dc0 -  */  0,
	/* dc1 - _V_66_0F_E1 */  0x40ba,
	/* dc2 -  */  0,
	/* dc3 -  */  0,
	/* dc4 -  */  0,
	/* dc5 -  */  0,
	/* dc6 -  */  0,
	/* dc7 -  */  0,
	/* dc8 - _0F_E2 */  0x2435,
	/* dc9 - _66_0F_E2 */  0x2436,
	/* dca -  */  0,
	/* dcb -  */  0,
	/* dcc -  */  0,
	/* dcd - _V_66_0F_E2 */  0x40bb,
	/* dce -  */  0,
	/* dcf -  */  0,
	/* dd0 -  */  0,
	/* dd1 -  */  0,
	/* dd2 -  */  0,
	/* dd3 -  */  0,
	/* dd4 - _0F_E3 */  0x2437,
	/* dd5 - _66_0F_E3 */  0x2438,
	/* dd6 -  */  0,
	/* dd7 -  */  0,
	/* dd8 -  */  0,
	/* dd9 - _V_66_0F_E3 */  0x40bc,
	/* dda -  */  0,
	/* ddb -  */  0,
	/* ddc -  */  0,
	/* ddd -  */  0,
	/* dde -  */  0,
	/* ddf -  */  0,
	/* de0 - _0F_E4 */  0x2439,
	/* de1 - _66_0F_E4 */  0x243a,
	/* de2 -  */  0,
	/* de3 -  */  0,
	/* de4 -  */  0,
	/* de5 - _V_66_0F_E4 */  0x40bd,
	/* de6 -  */  0,
	/* de7 -  */  0,
	/* de8 -  */  0,
	/* de9 -  */  0,
	/* dea -  */  0,
	/* deb -  */  0,
	/* dec - _0F_E5 */  0x243b,
	/* ded - _66_0F_E5 */  0x243c,
	/* dee -  */  0,
	/* def -  */  0,
	/* df0 -  */  0,
	/* df1 - _V_66_0F_E5 */  0x40be,
	/* df2 -  */  0,
	/* df3 -  */  0,
	/* df4 -  */  0,
	/* df5 -  */  0,
	/* df6 -  */  0,
	/* df7 -  */  0,
	/* df8 -  */  0,
	/* df9 - _66_0F_E6 */  0x243d,
	/* dfa - _F3_0F_E6 */  0x243e,
	/* dfb - _F2_0F_E6 */  0x243f,
	/* dfc -  */  0,
	/* dfd - _V_66_0F_E6 */  0x40bf,
	/* dfe - _V_F3_0F_E6 */  0x40c0,
	/* dff - _V_F2_0F_E6 */  0x40c1,
	/* e00 -  */  0,
	/* e01 -  */  0,
	/* e02 -  */  0,
	/* e03 -  */  0,
	/* e04 - _0F_E7 */  0x2440,
	/* e05 - _66_0F_E7 */  0x2441,
	/* e06 -  */  0,
	/* e07 -  */  0,
	/* e08 -  */  0,
	/* e09 - _V_66_0F_E7 */  0x40c2,
	/* e0a -  */  0,
	/* e0b -  */  0,
	/* e0c -  */  0,
	/* e0d -  */  0,
	/* e0e -  */  0,
	/* e0f -  */  0,
	/* e10 - _0F_E8 */  0x2442,
	/* e11 - _66_0F_E8 */  0x2443,
	/* e12 -  */  0,
	/* e13 -  */  0,
	/* e14 -  */  0,
	/* e15 - _V_66_0F_E8 */  0x40c3,
	/* e16 -  */  0,
	/* e17 -  */  0,
	/* e18 -  */  0,
	/* e19 -  */  0,
	/* e1a -  */  0,
	/* e1b -  */  0,
	/* e1c - _0F_E9 */  0x2444,
	/* e1d - _66_0F_E9 */  0x2445,
	/* e1e -  */  0,
	/* e1f -  */  0,
	/* e20 -  */  0,
	/* e21 - _V_66_0F_E9 */  0x40c4,
	/* e22 -  */  0,
	/* e23 -  */  0,
	/* e24 -  */  0,
	/* e25 -  */  0,
	/* e26 -  */  0,
	/* e27 -  */  0,
	/* e28 - _0F_EA */  0x2446,
	/* e29 - _66_0F_EA */  0x2447,
	/* e2a -  */  0,
	/* e2b -  */  0,
	/* e2c -  */  0,
	/* e2d - _V_66_0F_EA */  0x40c5,
	/* e2e -  */  0,
	/* e2f -  */  0,
	/* e30 -  */  0,
	/* e31 -  */  0,
	/* e32 -  */  0,
	/* e33 -  */  0,
	/* e34 - _0F_EB */  0x2448,
	/* e35 - _66_0F_EB */  0x2449,
	/* e36 -  */  0,
	/* e37 -  */  0,
	/* e38 -  */  0,
	/* e39 - _V_66_0F_EB */  0x40c6,
	/* e3a -  */  0,
	/* e3b -  */  0,
	/* e3c -  */  0,
	/* e3d -  */  0,
	/* e3e -  */  0,
	/* e3f -  */  0,
	/* e40 - _0F_EC */  0x244a,
	/* e41 - _66_0F_EC */  0x244b,
	/* e42 -  */  0,
	/* e43 -  */  0,
	/* e44 -  */  0,
	/* e45 - _V_66_0F_EC */  0x40c7,
	/* e46 -  */  0,
	/* e47 -  */  0,
	/* e48 -  */  0,
	/* e49 -  */  0,
	/* e4a -  */  0,
	/* e4b -  */  0,
	/* e4c - _0F_ED */  0x244c,
	/* e4d - _66_0F_ED */  0x244d,
	/* e4e -  */  0,
	/* e4f -  */  0,
	/* e50 -  */  0,
	/* e51 - _V_66_0F_ED */  0x40c8,
	/* e52 -  */  0,
	/* e53 -  */  0,
	/* e54 -  */  0,
	/* e55 -  */  0,
	/* e56 -  */  0,
	/* e57 -  */  0,
	/* e58 - _0F_EE */  0x244e,
	/* e59 - _66_0F_EE */  0x244f,
	/* e5a -  */  0,
	/* e5b -  */  0,
	/* e5c -  */  0,
	/* e5d - _V_66_0F_EE */  0x40c9,
	/* e5e -  */  0,
	/* e5f -  */  0,
	/* e60 -  */  0,
	/* e61 -  */  0,
	/* e62 -  */  0,
	/* e63 -  */  0,
	/* e64 - _0F_EF */  0x2450,
	/* e65 - _66_0F_EF */  0x2451,
	/* e66 -  */  0,
	/* e67 -  */  0,
	/* e68 -  */  0,
	/* e69 - _V_66_0F_EF */  0x40ca,
	/* e6a -  */  0,
	/* e6b -  */  0,
	/* e6c -  */  0,
	/* e6d -  */  0,
	/* e6e -  */  0,
	/* e6f -  */  0,
	/* e70 -  */  0,
	/* e71 -  */  0,
	/* e72 -  */  0,
	/* e73 - _F2_0F_F0 */  0x2452,
	/* e74 -  */  0,
	/* e75 -  */  0,
	/* e76 -  */  0,
	/* e77 - _V_F2_0F_F0 */  0x40cb,
	/* e78 -  */  0,
	/* e79 -  */  0,
	/* e7a -  */  0,
	/* e7b -  */  0,
	/* e7c - _0F_F1 */  0x2453,
	/* e7d - _66_0F_F1 */  0x2454,
	/* e7e -  */  0,
	/* e7f -  */  0,
	/* e80 -  */  0,
	/* e81 - _V_66_0F_F1 */  0x40cc,
	/* e82 -  */  0,
	/* e83 -  */  0,
	/* e84 -  */  0,
	/* e85 -  */  0,
	/* e86 -  */  0,
	/* e87 -  */  0,
	/* e88 - _0F_F2 */  0x2455,
	/* e89 - _66_0F_F2 */  0x2456,
	/* e8a -  */  0,
	/* e8b -  */  0,
	/* e8c -  */  0,
	/* e8d - _V_66_0F_F2 */  0x40cd,
	/* e8e -  */  0,
	/* e8f -  */  0,
	/* e90 -  */  0,
	/* e91 -  */  0,
	/* e92 -  */  0,
	/* e93 -  */  0,
	/* e94 - _0F_F3 */  0x2457,
	/* e95 - _66_0F_F3 */  0x2458,
	/* e96 -  */  0,
	/* e97 -  */  0,
	/* e98 -  */  0,
	/* e99 - _V_66_0F_F3 */  0x40ce,
	/* e9a -  */  0,
	/* e9b -  */  0,
	/* e9c -  */  0,
	/* e9d -  */  0,
	/* e9e -  */  0,
	/* e9f -  */  0,
	/* ea0 - _0F_F4 */  0x2459,
	/* ea1 - _66_0F_F4 */  0x245a,
	/* ea2 -  */  0,
	/* ea3 -  */  0,
	/* ea4 -  */  0,
	/* ea5 - _V_66_0F_F4 */  0x40cf,
	/* ea6 -  */  0,
	/* ea7 -  */  0,
	/* ea8 -  */  0,
	/* ea9 -  */  0,
	/* eaa -  */  0,
	/* eab -  */  0,
	/* eac - _0F_F5 */  0x245b,
	/* ead - _66_0F_F5 */  0x245c,
	/* eae -  */  0,
	/* eaf -  */  0,
	/* eb0 -  */  0,
	/* eb1 - _V_66_0F_F5 */  0x40d0,
	/* eb2 -  */  0,
	/* eb3 -  */  0,
	/* eb4 -  */  0,
	/* eb5 -  */  0,
	/* eb6 -  */  0,
	/* eb7 -  */  0,
	/* eb8 - _0F_F6 */  0x245d,
	/* eb9 - _66_0F_F6 */  0x245e,
	/* eba -  */  0,
	/* ebb -  */  0,
	/* ebc -  */  0,
	/* ebd - _V_66_0F_F6 */  0x40d1,
	/* ebe -  */  0,
	/* ebf -  */  0,
	/* ec0 -  */  0,
	/* ec1 -  */  0,
	/* ec2 -  */  0,
	/* ec3 -  */  0,
	/* ec4 - _0F_F7 */  0x245f,
	/* ec5 - _66_0F_F7 */  0x2460,
	/* ec6 -  */  0,
	/* ec7 -  */  0,
	/* ec8 -  */  0,
	/* ec9 - _V_66_0F_F7 */  0x40d2,
	/* eca -  */  0,
	/* ecb -  */  0,
	/* ecc -  */  0,
	/* ecd -  */  0,
	/* ece -  */  0,
	/* ecf -  */  0,
	/* ed0 - _0F_F8 */  0x2461,
	/* ed1 - _66_0F_F8 */  0x2462,
	/* ed2 -  */  0,
	/* ed3 -  */  0,
	/* ed4 -  */  0,
	/* ed5 - _V_66_0F_F8 */  0x40d3,
	/* ed6 -  */  0,
	/* ed7 -  */  0,
	/* ed8 -  */  0,
	/* ed9 -  */  0,
	/* eda -  */  0,
	/* edb -  */  0,
	/* edc - _0F_F9 */  0x2463,
	/* edd - _66_0F_F9 */  0x2464,
	/* ede -  */  0,
	/* edf -  */  0,
	/* ee0 -  */  0,
	/* ee1 - _V_66_0F_F9 */  0x40d4,
	/* ee2 -  */  0,
	/* ee3 -  */  0,
	/* ee4 -  */  0,
	/* ee5 -  */  0,
	/* ee6 -  */  0,
	/* ee7 -  */  0,
	/* ee8 - _0F_FA */  0x2465,
	/* ee9 - _66_0F_FA */  0x2466,
	/* eea -  */  0,
	/* eeb -  */  0,
	/* eec -  */  0,
	/* eed - _V_66_0F_FA */  0x40d5,
	/* eee -  */  0,
	/* eef -  */  0,
	/* ef0 -  */  0,
	/* ef1 -  */  0,
	/* ef2 -  */  0,
	/* ef3 -  */  0,
	/* ef4 - _0F_FB */  0x2467,
	/* ef5 - _66_0F_FB */  0x2468,
	/* ef6 -  */  0,
	/* ef7 -  */  0,
	/* ef8 -  */  0,
	/* ef9 - _V_66_0F_FB */  0x40d6,
	/* efa -  */  0,
	/* efb -  */  0,
	/* efc -  */  0,
	/* efd -  */  0,
	/* efe -  */  0,
	/* eff -  */  0,
	/* f00 - _0F_FC */  0x2469,
	/* f01 - _66_0F_FC */  0x246a,
	/* f02 -  */  0,
	/* f03 -  */  0,
	/* f04 -  */  0,
	/* f05 - _V_66_0F_FC */  0x40d7,
	/* f06 -  */  0,
	/* f07 -  */  0,
	/* f08 -  */  0,
	/* f09 -  */  0,
	/* f0a -  */  0,
	/* f0b -  */  0,
	/* f0c - _0F_FD */  0x246b,
	/* f0d - _66_0F_FD */  0x246c,
	/* f0e -  */  0,
	/* f0f -  */  0,
	/* f10 -  */  0,
	/* f11 - _V_66_0F_FD */  0x40d8,
	/* f12 -  */  0,
	/* f13 -  */  0,
	/* f14 -  */  0,
	/* f15 -  */  0,
	/* f16 -  */  0,
	/* f17 -  */  0,
	/* f18 - _0F_FE */  0x246d,
	/* f19 - _66_0F_FE */  0x246e,
	/* f1a -  */  0,
	/* f1b -  */  0,
	/* f1c -  */  0,
	/* f1d - _V_66_0F_FE */  0x40d9,
	/* f1e -  */  0,
	/* f1f -  */  0,
	/* f20 -  */  0,
	/* f21 -  */  0,
	/* f22 -  */  0,
	/* f23 -  */  0,
	/* f24 - _D9_06 */  0x246f,
	/* f25 - _9B_D9_06 */  0x2470,
	/* f26 -  */  0,
	/* f27 -  */  0,
	/* f28 -  */  0,
	/* f29 -  */  0,
	/* f2a -  */  0,
	/* f2b -  */  0,
	/* f2c -  */  0,
	/* f2d -  */  0,
	/* f2e -  */  0,
	/* f2f -  */  0,
	/* f30 - _D9_07 */  0x2471,
	/* f31 - _9B_D9_07 */  0x2472,
	/* f32 -  */  0,
	/* f33 -  */  0,
	/* f34 -  */  0,
	/* f35 -  */  0,
	/* f36 -  */  0,
	/* f37 -  */  0,
	/* f38 -  */  0,
	/* f39 -  */  0,
	/* f3a -  */  0,
	/* f3b -  */  0,
	/* f3c - _DB_E2 */  0x2473,
	/* f3d - _9B_DB_E2 */  0x2474,
	/* f3e -  */  0,
	/* f3f -  */  0,
	/* f40 -  */  0,
	/* f41 -  */  0,
	/* f42 -  */  0,
	/* f43 -  */  0,
	/* f44 -  */  0,
	/* f45 -  */  0,
	/* f46 -  */  0,
	/* f47 -  */  0,
	/* f48 - _DB_E3 */  0x2475,
	/* f49 - _9B_DB_E3 */  0x2476,
	/* f4a -  */  0,
	/* f4b -  */  0,
	/* f4c -  */  0,
	/* f4d -  */  0,
	/* f4e -  */  0,
	/* f4f -  */  0,
	/* f50 -  */  0,
	/* f51 -  */  0,
	/* f52 -  */  0,
	/* f53 -  */  0,
	/* f54 - _DD_06 */  0x2477,
	/* f55 - _9B_DD_06 */  0x2478,
	/* f56 -  */  0,
	/* f57 -  */  0,
	/* f58 -  */  0,
	/* f59 -  */  0,
	/* f5a -  */  0,
	/* f5b -  */  0,
	/* f5c -  */  0,
	/* f5d -  */  0,
	/* f5e -  */  0,
	/* f5f -  */  0,
	/* f60 - _DD_07 */  0x2479,
	/* f61 - _9B_DD_07 */  0x247a,
	/* f62 -  */  0,
	/* f63 -  */  0,
	/* f64 -  */  0,
	/* f65 -  */  0,
	/* f66 -  */  0,
	/* f67 -  */  0,
	/* f68 -  */  0,
	/* f69 -  */  0,
	/* f6a -  */  0,
	/* f6b -  */  0,
	/* f6c - _DF_E0 */  0x247b,
	/* f6d - _9B_DF_E0 */  0x247c,
	/* f6e -  */  0,
	/* f6f -  */  0,
	/* f70 -  */  0,
	/* f71 -  */  0,
	/* f72 -  */  0,
	/* f73 -  */  0,
	/* f74 -  */  0,
	/* f75 -  */  0,
	/* f76 -  */  0,
	/* f77 -  */  0,
	/* f78 - _0F_38_00 */  0x247d,
	/* f79 - _66_0F_38_00 */  0x247e,
	/* f7a -  */  0,
	/* f7b -  */  0,
	/* f7c -  */  0,
	/* f7d - _V_66_0F_38_00 */  0x40da,
	/* f7e -  */  0,
	/* f7f -  */  0,
	/* f80 -  */  0,
	/* f81 -  */  0,
	/* f82 -  */  0,
	/* f83 -  */  0,
	/* f84 - _0F_38_01 */  0x247f,
	/* f85 - _66_0F_38_01 */  0x2480,
	/* f86 -  */  0,
	/* f87 -  */  0,
	/* f88 -  */  0,
	/* f89 - _V_66_0F_38_01 */  0x40db,
	/* f8a -  */  0,
	/* f8b -  */  0,
	/* f8c -  */  0,
	/* f8d -  */  0,
	/* f8e -  */  0,
	/* f8f -  */  0,
	/* f90 - _0F_38_02 */  0x2481,
	/* f91 - _66_0F_38_02 */  0x2482,
	/* f92 -  */  0,
	/* f93 -  */  0,
	/* f94 -  */  0,
	/* f95 - _V_66_0F_38_02 */  0x40dc,
	/* f96 -  */  0,
	/* f97 -  */  0,
	/* f98 -  */  0,
	/* f99 -  */  0,
	/* f9a -  */  0,
	/* f9b -  */  0,
	/* f9c - _0F_38_03 */  0x2483,
	/* f9d - _66_0F_38_03 */  0x2484,
	/* f9e -  */  0,
	/* f9f -  */  0,
	/* fa0 -  */  0,
	/* fa1 - _V_66_0F_38_03 */  0x40dd,
	/* fa2 -  */  0,
	/* fa3 -  */  0,
	/* fa4 -  */  0,
	/* fa5 -  */  0,
	/* fa6 -  */  0,
	/* fa7 -  */  0,
	/* fa8 - _0F_38_04 */  0x2485,
	/* fa9 - _66_0F_38_04 */  0x2486,
	/* faa -  */  0,
	/* fab -  */  0,
	/* fac -  */  0,
	/* fad - _V_66_0F_38_04 */  0x40de,
	/* fae -  */  0,
	/* faf -  */  0,
	/* fb0 -  */  0,
	/* fb1 -  */  0,
	/* fb2 -  */  0,
	/* fb3 -  */  0,
	/* fb4 - _0F_38_05 */  0x2487,
	/* fb5 - _66_0F_38_05 */  0x2488,
	/* fb6 -  */  0,
	/* fb7 -  */  0,
	/* fb8 -  */  0,
	/* fb9 - _V_66_0F_38_05 */  0x40df,
	/* fba -  */  0,
	/* fbb -  */  0,
	/* fbc -  */  0,
	/* fbd -  */  0,
	/* fbe -  */  0,
	/* fbf -  */  0,
	/* fc0 - _0F_38_06 */  0x2489,
	/* fc1 - _66_0F_38_06 */  0x248a,
	/* fc2 -  */  0,
	/* fc3 -  */  0,
	/* fc4 -  */  0,
	/* fc5 - _V_66_0F_38_06 */  0x40e0,
	/* fc6 -  */  0,
	/* fc7 -  */  0,
	/* fc8 -  */  0,
	/* fc9 -  */  0,
	/* fca -  */  0,
	/* fcb -  */  0,
	/* fcc - _0F_38_07 */  0x248b,
	/* fcd - _66_0F_38_07 */  0x248c,
	/* fce -  */  0,
	/* fcf -  */  0,
	/* fd0 -  */  0,
	/* fd1 - _V_66_0F_38_07 */  0x40e1,
	/* fd2 -  */  0,
	/* fd3 -  */  0,
	/* fd4 -  */  0,
	/* fd5 -  */  0,
	/* fd6 -  */  0,
	/* fd7 -  */  0,
	/* fd8 - _0F_38_08 */  0x248d,
	/* fd9 - _66_0F_38_08 */  0x248e,
	/* fda -  */  0,
	/* fdb -  */  0,
	/* fdc -  */  0,
	/* fdd - _V_66_0F_38_08 */  0x40e2,
	/* fde -  */  0,
	/* fdf -  */  0,
	/* fe0 -  */  0,
	/* fe1 -  */  0,
	/* fe2 -  */  0,
	/* fe3 -  */  0,
	/* fe4 - _0F_38_09 */  0x248f,
	/* fe5 - _66_0F_38_09 */  0x2490,
	/* fe6 -  */  0,
	/* fe7 -  */  0,
	/* fe8 -  */  0,
	/* fe9 - _V_66_0F_38_09 */  0x40e3,
	/* fea -  */  0,
	/* feb -  */  0,
	/* fec -  */  0,
	/* fed -  */  0,
	/* fee -  */  0,
	/* fef -  */  0,
	/* ff0 - _0F_38_0A */  0x2491,
	/* ff1 - _66_0F_38_0A */  0x2492,
	/* ff2 -  */  0,
	/* ff3 -  */  0,
	/* ff4 -  */  0,
	/* ff5 - _V_66_0F_38_0A */  0x40e4,
	/* ff6 -  */  0,
	/* ff7 -  */  0,
	/* ff8 -  */  0,
	/* ff9 -  */  0,
	/* ffa -  */  0,
	/* ffb -  */  0,
	/* ffc - _0F_38_0B */  0x2493,
	/* ffd - _66_0F_38_0B */  0x2494,
	/* ffe -  */  0,
	/* fff -  */  0,
	/* 1000 -  */  0,
	/* 1001 - _V_66_0F_38_0B */  0x40e5,
	/* 1002 -  */  0,
	/* 1003 -  */  0,
	/* 1004 -  */  0,
	/* 1005 -  */  0,
	/* 1006 -  */  0,
	/* 1007 -  */  0,
	/* 1008 -  */  0,
	/* 1009 -  */  0,
	/* 100a -  */  0,
	/* 100b -  */  0,
	/* 100c -  */  0,
	/* 100d - _V_66_0F_38_0C */  0x40e6,
	/* 100e -  */  0,
	/* 100f -  */  0,
	/* 1010 -  */  0,
	/* 1011 -  */  0,
	/* 1012 -  */  0,
	/* 1013 -  */  0,
	/* 1014 -  */  0,
	/* 1015 -  */  0,
	/* 1016 -  */  0,
	/* 1017 -  */  0,
	/* 1018 -  */  0,
	/* 1019 - _V_66_0F_38_0D */  0x40e7,
	/* 101a -  */  0,
	/* 101b -  */  0,
	/* 101c -  */  0,
	/* 101d -  */  0,
	/* 101e -  */  0,
	/* 101f -  */  0,
	/* 1020 -  */  0,
	/* 1021 -  */  0,
	/* 1022 -  */  0,
	/* 1023 -  */  0,
	/* 1024 -  */  0,
	/* 1025 - _V_66_0F_38_0E */  0x40e8,
	/* 1026 -  */  0,
	/* 1027 -  */  0,
	/* 1028 -  */  0,
	/* 1029 -  */  0,
	/* 102a -  */  0,
	/* 102b -  */  0,
	/* 102c -  */  0,
	/* 102d -  */  0,
	/* 102e -  */  0,
	/* 102f -  */  0,
	/* 1030 -  */  0,
	/* 1031 - _V_66_0F_38_0F */  0x40e9,
	/* 1032 -  */  0,
	/* 1033 -  */  0,
	/* 1034 -  */  0,
	/* 1035 -  */  0,
	/* 1036 -  */  0,
	/* 1037 -  */  0,
	/* 1038 -  */  0,
	/* 1039 - _66_0F_38_10 */  0x40ea,
	/* 103a -  */  0,
	/* 103b -  */  0,
	/* 103c -  */  0,
	/* 103d -  */  0,
	/* 103e -  */  0,
	/* 103f -  */  0,
	/* 1040 -  */  0,
	/* 1041 -  */  0,
	/* 1042 -  */  0,
	/* 1043 -  */  0,
	/* 1044 -  */  0,
	/* 1045 - _66_0F_38_14 */  0x40eb,
	/* 1046 -  */  0,
	/* 1047 -  */  0,
	/* 1048 -  */  0,
	/* 1049 -  */  0,
	/* 104a -  */  0,
	/* 104b -  */  0,
	/* 104c -  */  0,
	/* 104d -  */  0,
	/* 104e -  */  0,
	/* 104f -  */  0,
	/* 1050 -  */  0,
	/* 1051 - _66_0F_38_15 */  0x40ec,
	/* 1052 -  */  0,
	/* 1053 -  */  0,
	/* 1054 -  */  0,
	/* 1055 -  */  0,
	/* 1056 -  */  0,
	/* 1057 -  */  0,
	/* 1058 -  */  0,
	/* 1059 -  */  0,
	/* 105a -  */  0,
	/* 105b -  */  0,
	/* 105c -  */  0,
	/* 105d - _66_0F_38_17 */  0x2495,
	/* 105e -  */  0,
	/* 105f -  */  0,
	/* 1060 -  */  0,
	/* 1061 - _V_66_0F_38_17 */  0x40ed,
	/* 1062 -  */  0,
	/* 1063 -  */  0,
	/* 1064 -  */  0,
	/* 1065 -  */  0,
	/* 1066 -  */  0,
	/* 1067 -  */  0,
	/* 1068 -  */  0,
	/* 1069 -  */  0,
	/* 106a -  */  0,
	/* 106b -  */  0,
	/* 106c -  */  0,
	/* 106d - _V_66_0F_38_18 */  0x40ee,
	/* 106e -  */  0,
	/* 106f -  */  0,
	/* 1070 -  */  0,
	/* 1071 -  */  0,
	/* 1072 -  */  0,
	/* 1073 -  */  0,
	/* 1074 -  */  0,
	/* 1075 -  */  0,
	/* 1076 -  */  0,
	/* 1077 -  */  0,
	/* 1078 -  */  0,
	/* 1079 - _V_66_0F_38_19 */  0x40ef,
	/* 107a -  */  0,
	/* 107b -  */  0,
	/* 107c -  */  0,
	/* 107d -  */  0,
	/* 107e -  */  0,
	/* 107f -  */  0,
	/* 1080 -  */  0,
	/* 1081 -  */  0,
	/* 1082 -  */  0,
	/* 1083 -  */  0,
	/* 1084 -  */  0,
	/* 1085 - _V_66_0F_38_1A */  0x40f0,
	/* 1086 -  */  0,
	/* 1087 -  */  0,
	/* 1088 -  */  0,
	/* 1089 -  */  0,
	/* 108a -  */  0,
	/* 108b -  */  0,
	/* 108c - _0F_38_1C */  0x2496,
	/* 108d - _66_0F_38_1C */  0x2497,
	/* 108e -  */  0,
	/* 108f -  */  0,
	/* 1090 -  */  0,
	/* 1091 - _V_66_0F_38_1C */  0x40f1,
	/* 1092 -  */  0,
	/* 1093 -  */  0,
	/* 1094 -  */  0,
	/* 1095 -  */  0,
	/* 1096 -  */  0,
	/* 1097 -  */  0,
	/* 1098 - _0F_38_1D */  0x2498,
	/* 1099 - _66_0F_38_1D */  0x2499,
	/* 109a -  */  0,
	/* 109b -  */  0,
	/* 109c -  */  0,
	/* 109d - _V_66_0F_38_1D */  0x40f2,
	/* 109e -  */  0,
	/* 109f -  */  0,
	/* 10a0 -  */  0,
	/* 10a1 -  */  0,
	/* 10a2 -  */  0,
	/* 10a3 -  */  0,
	/* 10a4 - _0F_38_1E */  0x249a,
	/* 10a5 - _66_0F_38_1E */  0x249b,
	/* 10a6 -  */  0,
	/* 10a7 -  */  0,
	/* 10a8 -  */  0,
	/* 10a9 - _V_66_0F_38_1E */  0x40f3,
	/* 10aa -  */  0,
	/* 10ab -  */  0,
	/* 10ac -  */  0,
	/* 10ad -  */  0,
	/* 10ae -  */  0,
	/* 10af -  */  0,
	/* 10b0 -  */  0,
	/* 10b1 - _66_0F_38_20 */  0x249c,
	/* 10b2 -  */  0,
	/* 10b3 -  */  0,
	/* 10b4 -  */  0,
	/* 10b5 - _V_66_0F_38_20 */  0x40f4,
	/* 10b6 -  */  0,
	/* 10b7 -  */  0,
	/* 10b8 -  */  0,
	/* 10b9 -  */  0,
	/* 10ba -  */  0,
	/* 10bb -  */  0,
	/* 10bc -  */  0,
	/* 10bd - _66_0F_38_21 */  0x249d,
	/* 10be -  */  0,
	/* 10bf -  */  0,
	/* 10c0 -  */  0,
	/* 10c1 - _V_66_0F_38_21 */  0x40f5,
	/* 10c2 -  */  0,
	/* 10c3 -  */  0,
	/* 10c4 -  */  0,
	/* 10c5 -  */  0,
	/* 10c6 -  */  0,
	/* 10c7 -  */  0,
	/* 10c8 -  */  0,
	/* 10c9 - _66_0F_38_22 */  0x249e,
	/* 10ca -  */  0,
	/* 10cb -  */  0,
	/* 10cc -  */  0,
	/* 10cd - _V_66_0F_38_22 */  0x40f6,
	/* 10ce -  */  0,
	/* 10cf -  */  0,
	/* 10d0 -  */  0,
	/* 10d1 -  */  0,
	/* 10d2 -  */  0,
	/* 10d3 -  */  0,
	/* 10d4 -  */  0,
	/* 10d5 - _66_0F_38_23 */  0x249f,
	/* 10d6 -  */  0,
	/* 10d7 -  */  0,
	/* 10d8 -  */  0,
	/* 10d9 - _V_66_0F_38_23 */  0x40f7,
	/* 10da -  */  0,
	/* 10db -  */  0,
	/* 10dc -  */  0,
	/* 10dd -  */  0,
	/* 10de -  */  0,
	/* 10df -  */  0,
	/* 10e0 -  */  0,
	/* 10e1 - _66_0F_38_24 */  0x24a0,
	/* 10e2 -  */  0,
	/* 10e3 -  */  0,
	/* 10e4 -  */  0,
	/* 10e5 - _V_66_0F_38_24 */  0x40f8,
	/* 10e6 -  */  0,
	/* 10e7 -  */  0,
	/* 10e8 -  */  0,
	/* 10e9 -  */  0,
	/* 10ea -  */  0,
	/* 10eb -  */  0,
	/* 10ec -  */  0,
	/* 10ed - _66_0F_38_25 */  0x24a1,
	/* 10ee -  */  0,
	/* 10ef -  */  0,
	/* 10f0 -  */  0,
	/* 10f1 - _V_66_0F_38_25 */  0x40f9,
	/* 10f2 -  */  0,
	/* 10f3 -  */  0,
	/* 10f4 -  */  0,
	/* 10f5 -  */  0,
	/* 10f6 -  */  0,
	/* 10f7 -  */  0,
	/* 10f8 -  */  0,
	/* 10f9 - _66_0F_38_28 */  0x24a2,
	/* 10fa -  */  0,
	/* 10fb -  */  0,
	/* 10fc -  */  0,
	/* 10fd - _V_66_0F_38_28 */  0x40fa,
	/* 10fe -  */  0,
	/* 10ff -  */  0,
	/* 1100 -  */  0,
	/* 1101 -  */  0,
	/* 1102 -  */  0,
	/* 1103 -  */  0,
	/* 1104 -  */  0,
	/* 1105 - _66_0F_38_29 */  0x24a3,
	/* 1106 -  */  0,
	/* 1107 -  */  0,
	/* 1108 -  */  0,
	/* 1109 - _V_66_0F_38_29 */  0x40fb,
	/* 110a -  */  0,
	/* 110b -  */  0,
	/* 110c -  */  0,
	/* 110d -  */  0,
	/* 110e -  */  0,
	/* 110f -  */  0,
	/* 1110 -  */  0,
	/* 1111 - _66_0F_38_2A */  0x24a4,
	/* 1112 -  */  0,
	/* 1113 -  */  0,
	/* 1114 -  */  0,
	/* 1115 - _V_66_0F_38_2A */  0x40fc,
	/* 1116 -  */  0,
	/* 1117 -  */  0,
	/* 1118 -  */  0,
	/* 1119 -  */  0,
	/* 111a -  */  0,
	/* 111b -  */  0,
	/* 111c -  */  0,
	/* 111d - _66_0F_38_2B */  0x24a5,
	/* 111e -  */  0,
	/* 111f -  */  0,
	/* 1120 -  */  0,
	/* 1121 - _V_66_0F_38_2B */  0x40fd,
	/* 1122 -  */  0,
	/* 1123 -  */  0,
	/* 1124 -  */  0,
	/* 1125 -  */  0,
	/* 1126 -  */  0,
	/* 1127 -  */  0,
	/* 1128 -  */  0,
	/* 1129 -  */  0,
	/* 112a -  */  0,
	/* 112b -  */  0,
	/* 112c -  */  0,
	/* 112d - _V_66_0F_38_2C */  0x40fe,
	/* 112e -  */  0,
	/* 112f -  */  0,
	/* 1130 -  */  0,
	/* 1131 -  */  0,
	/* 1132 -  */  0,
	/* 1133 -  */  0,
	/* 1134 -  */  0,
	/* 1135 -  */  0,
	/* 1136 -  */  0,
	/* 1137 -  */  0,
	/* 1138 -  */  0,
	/* 1139 - _V_66_0F_38_2D */  0x40ff,
	/* 113a -  */  0,
	/* 113b -  */  0,
	/* 113c -  */  0,
	/* 113d -  */  0,
	/* 113e -  */  0,
	/* 113f -  */  0,
	/* 1140 -  */  0,
	/* 1141 -  */  0,
	/* 1142 -  */  0,
	/* 1143 -  */  0,
	/* 1144 -  */  0,
	/* 1145 - _V_66_0F_38_2E */  0x4100,
	/* 1146 -  */  0,
	/* 1147 -  */  0,
	/* 1148 -  */  0,
	/* 1149 -  */  0,
	/* 114a -  */  0,
	/* 114b -  */  0,
	/* 114c -  */  0,
	/* 114d -  */  0,
	/* 114e -  */  0,
	/* 114f -  */  0,
	/* 1150 -  */  0,
	/* 1151 - _V_66_0F_38_2F */  0x4101,
	/* 1152 -  */  0,
	/* 1153 -  */  0,
	/* 1154 -  */  0,
	/* 1155 -  */  0,
	/* 1156 -  */  0,
	/* 1157 -  */  0,
	/* 1158 -  */  0,
	/* 1159 - _66_0F_38_30 */  0x24a6,
	/* 115a -  */  0,
	/* 115b -  */  0,
	/* 115c -  */  0,
	/* 115d - _V_66_0F_38_30 */  0x4102,
	/* 115e -  */  0,
	/* 115f -  */  0,
	/* 1160 -  */  0,
	/* 1161 -  */  0,
	/* 1162 -  */  0,
	/* 1163 -  */  0,
	/* 1164 -  */  0,
	/* 1165 - _66_0F_38_31 */  0x24a7,
	/* 1166 -  */  0,
	/* 1167 -  */  0,
	/* 1168 -  */  0,
	/* 1169 - _V_66_0F_38_31 */  0x4103,
	/* 116a -  */  0,
	/* 116b -  */  0,
	/* 116c -  */  0,
	/* 116d -  */  0,
	/* 116e -  */  0,
	/* 116f -  */  0,
	/* 1170 -  */  0,
	/* 1171 - _66_0F_38_32 */  0x24a8,
	/* 1172 -  */  0,
	/* 1173 -  */  0,
	/* 1174 -  */  0,
	/* 1175 - _V_66_0F_38_32 */  0x4104,
	/* 1176 -  */  0,
	/* 1177 -  */  0,
	/* 1178 -  */  0,
	/* 1179 -  */  0,
	/* 117a -  */  0,
	/* 117b -  */  0,
	/* 117c -  */  0,
	/* 117d - _66_0F_38_33 */  0x24a9,
	/* 117e -  */  0,
	/* 117f -  */  0,
	/* 1180 -  */  0,
	/* 1181 - _V_66_0F_38_33 */  0x4105,
	/* 1182 -  */  0,
	/* 1183 -  */  0,
	/* 1184 -  */  0,
	/* 1185 -  */  0,
	/* 1186 -  */  0,
	/* 1187 -  */  0,
	/* 1188 -  */  0,
	/* 1189 - _66_0F_38_34 */  0x24aa,
	/* 118a -  */  0,
	/* 118b -  */  0,
	/* 118c -  */  0,
	/* 118d - _V_66_0F_38_34 */  0x4106,
	/* 118e -  */  0,
	/* 118f -  */  0,
	/* 1190 -  */  0,
	/* 1191 -  */  0,
	/* 1192 -  */  0,
	/* 1193 -  */  0,
	/* 1194 -  */  0,
	/* 1195 - _66_0F_38_35 */  0x24ab,
	/* 1196 -  */  0,
	/* 1197 -  */  0,
	/* 1198 -  */  0,
	/* 1199 - _V_66_0F_38_35 */  0x4107,
	/* 119a -  */  0,
	/* 119b -  */  0,
	/* 119c -  */  0,
	/* 119d -  */  0,
	/* 119e -  */  0,
	/* 119f -  */  0,
	/* 11a0 -  */  0,
	/* 11a1 - _66_0F_38_37 */  0x24ac,
	/* 11a2 -  */  0,
	/* 11a3 -  */  0,
	/* 11a4 -  */  0,
	/* 11a5 - _V_66_0F_38_37 */  0x4108,
	/* 11a6 -  */  0,
	/* 11a7 -  */  0,
	/* 11a8 -  */  0,
	/* 11a9 -  */  0,
	/* 11aa -  */  0,
	/* 11ab -  */  0,
	/* 11ac -  */  0,
	/* 11ad - _66_0F_38_38 */  0x24ad,
	/* 11ae -  */  0,
	/* 11af -  */  0,
	/* 11b0 -  */  0,
	/* 11b1 - _V_66_0F_38_38 */  0x4109,
	/* 11b2 -  */  0,
	/* 11b3 -  */  0,
	/* 11b4 -  */  0,
	/* 11b5 -  */  0,
	/* 11b6 -  */  0,
	/* 11b7 -  */  0,
	/* 11b8 -  */  0,
	/* 11b9 - _66_0F_38_39 */  0x24ae,
	/* 11ba -  */  0,
	/* 11bb -  */  0,
	/* 11bc -  */  0,
	/* 11bd - _V_66_0F_38_39 */  0x410a,
	/* 11be -  */  0,
	/* 11bf -  */  0,
	/* 11c0 -  */  0,
	/* 11c1 -  */  0,
	/* 11c2 -  */  0,
	/* 11c3 -  */  0,
	/* 11c4 -  */  0,
	/* 11c5 - _66_0F_38_3A */  0x24af,
	/* 11c6 -  */  0,
	/* 11c7 -  */  0,
	/* 11c8 -  */  0,
	/* 11c9 - _V_66_0F_38_3A */  0x410b,
	/* 11ca -  */  0,
	/* 11cb -  */  0,
	/* 11cc -  */  0,
	/* 11cd -  */  0,
	/* 11ce -  */  0,
	/* 11cf -  */  0,
	/* 11d0 -  */  0,
	/* 11d1 - _66_0F_38_3B */  0x24b0,
	/* 11d2 -  */  0,
	/* 11d3 -  */  0,
	/* 11d4 -  */  0,
	/* 11d5 - _V_66_0F_38_3B */  0x410c,
	/* 11d6 -  */  0,
	/* 11d7 -  */  0,
	/* 11d8 -  */  0,
	/* 11d9 -  */  0,
	/* 11da -  */  0,
	/* 11db -  */  0,
	/* 11dc -  */  0,
	/* 11dd - _66_0F_38_3C */  0x24b1,
	/* 11de -  */  0,
	/* 11df -  */  0,
	/* 11e0 -  */  0,
	/* 11e1 - _V_66_0F_38_3C */  0x410d,
	/* 11e2 -  */  0,
	/* 11e3 -  */  0,
	/* 11e4 -  */  0,
	/* 11e5 -  */  0,
	/* 11e6 -  */  0,
	/* 11e7 -  */  0,
	/* 11e8 -  */  0,
	/* 11e9 - _66_0F_38_3D */  0x24b2,
	/* 11ea -  */  0,
	/* 11eb -  */  0,
	/* 11ec -  */  0,
	/* 11ed - _V_66_0F_38_3D */  0x410e,
	/* 11ee -  */  0,
	/* 11ef -  */  0,
	/* 11f0 -  */  0,
	/* 11f1 -  */  0,
	/* 11f2 -  */  0,
	/* 11f3 -  */  0,
	/* 11f4 -  */  0,
	/* 11f5 - _66_0F_38_3E */  0x24b3,
	/* 11f6 -  */  0,
	/* 11f7 -  */  0,
	/* 11f8 -  */  0,
	/* 11f9 - _V_66_0F_38_3E */  0x410f,
	/* 11fa -  */  0,
	/* 11fb -  */  0,
	/* 11fc -  */  0,
	/* 11fd -  */  0,
	/* 11fe -  */  0,
	/* 11ff -  */  0,
	/* 1200 -  */  0,
	/* 1201 - _66_0F_38_3F */  0x24b4,
	/* 1202 -  */  0,
	/* 1203 -  */  0,
	/* 1204 -  */  0,
	/* 1205 - _V_66_0F_38_3F */  0x4110,
	/* 1206 -  */  0,
	/* 1207 -  */  0,
	/* 1208 -  */  0,
	/* 1209 -  */  0,
	/* 120a -  */  0,
	/* 120b -  */  0,
	/* 120c -  */  0,
	/* 120d - _66_0F_38_40 */  0x24b5,
	/* 120e -  */  0,
	/* 120f -  */  0,
	/* 1210 -  */  0,
	/* 1211 - _V_66_0F_38_40 */  0x4111,
	/* 1212 -  */  0,
	/* 1213 -  */  0,
	/* 1214 -  */  0,
	/* 1215 -  */  0,
	/* 1216 -  */  0,
	/* 1217 -  */  0,
	/* 1218 -  */  0,
	/* 1219 - _66_0F_38_41 */  0x24b6,
	/* 121a -  */  0,
	/* 121b -  */  0,
	/* 121c -  */  0,
	/* 121d - _V_66_0F_38_41 */  0x4112,
	/* 121e -  */  0,
	/* 121f -  */  0,
	/* 1220 -  */  0,
	/* 1221 -  */  0,
	/* 1222 -  */  0,
	/* 1223 -  */  0,
	/* 1224 -  */  0,
	/* 1225 - _66_0F_38_80 */  0x24b7,
	/* 1226 -  */  0,
	/* 1227 -  */  0,
	/* 1228 -  */  0,
	/* 1229 -  */  0,
	/* 122a -  */  0,
	/* 122b -  */  0,
	/* 122c -  */  0,
	/* 122d -  */  0,
	/* 122e -  */  0,
	/* 122f -  */  0,
	/* 1230 -  */  0,
	/* 1231 - _66_0F_38_81 */  0x24b8,
	/* 1232 -  */  0,
	/* 1233 -  */  0,
	/* 1234 -  */  0,
	/* 1235 -  */  0,
	/* 1236 -  */  0,
	/* 1237 -  */  0,
	/* 1238 -  */  0,
	/* 1239 -  */  0,
	/* 123a -  */  0,
	/* 123b -  */  0,
	/* 123c -  */  0,
	/* 123d - _66_0F_38_82 */  0x24b9,
	/* 123e -  */  0,
	/* 123f -  */  0,
	/* 1240 -  */  0,
	/* 1241 -  */  0,
	/* 1242 -  */  0,
	/* 1243 -  */  0,
	/* 1244 -  */  0,
	/* 1245 -  */  0,
	/* 1246 -  */  0,
	/* 1247 -  */  0,
	/* 1248 -  */  0,
	/* 1249 -  */  0,
	/* 124a -  */  0,
	/* 124b -  */  0,
	/* 124c -  */  0,
	/* 124d - _V_66_0F_38_96 */  0x4113,
	/* 124e -  */  0,
	/* 124f -  */  0,
	/* 1250 -  */  0,
	/* 1251 -  */  0,
	/* 1252 -  */  0,
	/* 1253 -  */  0,
	/* 1254 -  */  0,
	/* 1255 -  */  0,
	/* 1256 -  */  0,
	/* 1257 -  */  0,
	/* 1258 -  */  0,
	/* 1259 - _V_66_0F_38_97 */  0x4114,
	/* 125a -  */  0,
	/* 125b -  */  0,
	/* 125c -  */  0,
	/* 125d -  */  0,
	/* 125e -  */  0,
	/* 125f -  */  0,
	/* 1260 -  */  0,
	/* 1261 -  */  0,
	/* 1262 -  */  0,
	/* 1263 -  */  0,
	/* 1264 -  */  0,
	/* 1265 - _V_66_0F_38_98 */  0x4115,
	/* 1266 -  */  0,
	/* 1267 -  */  0,
	/* 1268 -  */  0,
	/* 1269 -  */  0,
	/* 126a -  */  0,
	/* 126b -  */  0,
	/* 126c -  */  0,
	/* 126d -  */  0,
	/* 126e -  */  0,
	/* 126f -  */  0,
	/* 1270 -  */  0,
	/* 1271 - _V_66_0F_38_99 */  0x4116,
	/* 1272 -  */  0,
	/* 1273 -  */  0,
	/* 1274 -  */  0,
	/* 1275 -  */  0,
	/* 1276 -  */  0,
	/* 1277 -  */  0,
	/* 1278 -  */  0,
	/* 1279 -  */  0,
	/* 127a -  */  0,
	/* 127b -  */  0,
	/* 127c -  */  0,
	/* 127d - _V_66_0F_38_9A */  0x4117,
	/* 127e -  */  0,
	/* 127f -  */  0,
	/* 1280 -  */  0,
	/* 1281 -  */  0,
	/* 1282 -  */  0,
	/* 1283 -  */  0,
	/* 1284 -  */  0,
	/* 1285 -  */  0,
	/* 1286 -  */  0,
	/* 1287 -  */  0,
	/* 1288 -  */  0,
	/* 1289 - _V_66_0F_38_9B */  0x4118,
	/* 128a -  */  0,
	/* 128b -  */  0,
	/* 128c -  */  0,
	/* 128d -  */  0,
	/* 128e -  */  0,
	/* 128f -  */  0,
	/* 1290 -  */  0,
	/* 1291 -  */  0,
	/* 1292 -  */  0,
	/* 1293 -  */  0,
	/* 1294 -  */  0,
	/* 1295 - _V_66_0F_38_9C */  0x4119,
	/* 1296 -  */  0,
	/* 1297 -  */  0,
	/* 1298 -  */  0,
	/* 1299 -  */  0,
	/* 129a -  */  0,
	/* 129b -  */  0,
	/* 129c -  */  0,
	/* 129d -  */  0,
	/* 129e -  */  0,
	/* 129f -  */  0,
	/* 12a0 -  */  0,
	/* 12a1 - _V_66_0F_38_9D */  0x411a,
	/* 12a2 -  */  0,
	/* 12a3 -  */  0,
	/* 12a4 -  */  0,
	/* 12a5 -  */  0,
	/* 12a6 -  */  0,
	/* 12a7 -  */  0,
	/* 12a8 -  */  0,
	/* 12a9 -  */  0,
	/* 12aa -  */  0,
	/* 12ab -  */  0,
	/* 12ac -  */  0,
	/* 12ad - _V_66_0F_38_9E */  0x411b,
	/* 12ae -  */  0,
	/* 12af -  */  0,
	/* 12b0 -  */  0,
	/* 12b1 -  */  0,
	/* 12b2 -  */  0,
	/* 12b3 -  */  0,
	/* 12b4 -  */  0,
	/* 12b5 -  */  0,
	/* 12b6 -  */  0,
	/* 12b7 -  */  0,
	/* 12b8 -  */  0,
	/* 12b9 - _V_66_0F_38_9F */  0x411c,
	/* 12ba -  */  0,
	/* 12bb -  */  0,
	/* 12bc -  */  0,
	/* 12bd -  */  0,
	/* 12be -  */  0,
	/* 12bf -  */  0,
	/* 12c0 -  */  0,
	/* 12c1 -  */  0,
	/* 12c2 -  */  0,
	/* 12c3 -  */  0,
	/* 12c4 -  */  0,
	/* 12c5 - _V_66_0F_38_A6 */  0x411d,
	/* 12c6 -  */  0,
	/* 12c7 -  */  0,
	/* 12c8 -  */  0,
	/* 12c9 -  */  0,
	/* 12ca -  */  0,
	/* 12cb -  */  0,
	/* 12cc -  */  0,
	/* 12cd -  */  0,
	/* 12ce -  */  0,
	/* 12cf -  */  0,
	/* 12d0 -  */  0,
	/* 12d1 - _V_66_0F_38_A7 */  0x411e,
	/* 12d2 -  */  0,
	/* 12d3 -  */  0,
	/* 12d4 -  */  0,
	/* 12d5 -  */  0,
	/* 12d6 -  */  0,
	/* 12d7 -  */  0,
	/* 12d8 -  */  0,
	/* 12d9 -  */  0,
	/* 12da -  */  0,
	/* 12db -  */  0,
	/* 12dc -  */  0,
	/* 12dd - _V_66_0F_38_A8 */  0x411f,
	/* 12de -  */  0,
	/* 12df -  */  0,
	/* 12e0 -  */  0,
	/* 12e1 -  */  0,
	/* 12e2 -  */  0,
	/* 12e3 -  */  0,
	/* 12e4 -  */  0,
	/* 12e5 -  */  0,
	/* 12e6 -  */  0,
	/* 12e7 -  */  0,
	/* 12e8 -  */  0,
	/* 12e9 - _V_66_0F_38_A9 */  0x4120,
	/* 12ea -  */  0,
	/* 12eb -  */  0,
	/* 12ec -  */  0,
	/* 12ed -  */  0,
	/* 12ee -  */  0,
	/* 12ef -  */  0,
	/* 12f0 -  */  0,
	/* 12f1 -  */  0,
	/* 12f2 -  */  0,
	/* 12f3 -  */  0,
	/* 12f4 -  */  0,
	/* 12f5 - _V_66_0F_38_AA */  0x4121,
	/* 12f6 -  */  0,
	/* 12f7 -  */  0,
	/* 12f8 -  */  0,
	/* 12f9 -  */  0,
	/* 12fa -  */  0,
	/* 12fb -  */  0,
	/* 12fc -  */  0,
	/* 12fd -  */  0,
	/* 12fe -  */  0,
	/* 12ff -  */  0,
	/* 1300 -  */  0,
	/* 1301 - _V_66_0F_38_AB */  0x4122,
	/* 1302 -  */  0,
	/* 1303 -  */  0,
	/* 1304 -  */  0,
	/* 1305 -  */  0,
	/* 1306 -  */  0,
	/* 1307 -  */  0,
	/* 1308 -  */  0,
	/* 1309 -  */  0,
	/* 130a -  */  0,
	/* 130b -  */  0,
	/* 130c -  */  0,
	/* 130d - _V_66_0F_38_AC */  0x4123,
	/* 130e -  */  0,
	/* 130f -  */  0,
	/* 1310 -  */  0,
	/* 1311 -  */  0,
	/* 1312 -  */  0,
	/* 1313 -  */  0,
	/* 1314 -  */  0,
	/* 1315 -  */  0,
	/* 1316 -  */  0,
	/* 1317 -  */  0,
	/* 1318 -  */  0,
	/* 1319 - _V_66_0F_38_AD */  0x4124,
	/* 131a -  */  0,
	/* 131b -  */  0,
	/* 131c -  */  0,
	/* 131d -  */  0,
	/* 131e -  */  0,
	/* 131f -  */  0,
	/* 1320 -  */  0,
	/* 1321 -  */  0,
	/* 1322 -  */  0,
	/* 1323 -  */  0,
	/* 1324 -  */  0,
	/* 1325 - _V_66_0F_38_AE */  0x4125,
	/* 1326 -  */  0,
	/* 1327 -  */  0,
	/* 1328 -  */  0,
	/* 1329 -  */  0,
	/* 132a -  */  0,
	/* 132b -  */  0,
	/* 132c -  */  0,
	/* 132d -  */  0,
	/* 132e -  */  0,
	/* 132f -  */  0,
	/* 1330 -  */  0,
	/* 1331 - _V_66_0F_38_AF */  0x4126,
	/* 1332 -  */  0,
	/* 1333 -  */  0,
	/* 1334 -  */  0,
	/* 1335 -  */  0,
	/* 1336 -  */  0,
	/* 1337 -  */  0,
	/* 1338 -  */  0,
	/* 1339 -  */  0,
	/* 133a -  */  0,
	/* 133b -  */  0,
	/* 133c -  */  0,
	/* 133d - _V_66_0F_38_B6 */  0x4127,
	/* 133e -  */  0,
	/* 133f -  */  0,
	/* 1340 -  */  0,
	/* 1341 -  */  0,
	/* 1342 -  */  0,
	/* 1343 -  */  0,
	/* 1344 -  */  0,
	/* 1345 -  */  0,
	/* 1346 -  */  0,
	/* 1347 -  */  0,
	/* 1348 -  */  0,
	/* 1349 - _V_66_0F_38_B7 */  0x4128,
	/* 134a -  */  0,
	/* 134b -  */  0,
	/* 134c -  */  0,
	/* 134d -  */  0,
	/* 134e -  */  0,
	/* 134f -  */  0,
	/* 1350 -  */  0,
	/* 1351 -  */  0,
	/* 1352 -  */  0,
	/* 1353 -  */  0,
	/* 1354 -  */  0,
	/* 1355 - _V_66_0F_38_B8 */  0x4129,
	/* 1356 -  */  0,
	/* 1357 -  */  0,
	/* 1358 -  */  0,
	/* 1359 -  */  0,
	/* 135a -  */  0,
	/* 135b -  */  0,
	/* 135c -  */  0,
	/* 135d -  */  0,
	/* 135e -  */  0,
	/* 135f -  */  0,
	/* 1360 -  */  0,
	/* 1361 - _V_66_0F_38_B9 */  0x412a,
	/* 1362 -  */  0,
	/* 1363 -  */  0,
	/* 1364 -  */  0,
	/* 1365 -  */  0,
	/* 1366 -  */  0,
	/* 1367 -  */  0,
	/* 1368 -  */  0,
	/* 1369 -  */  0,
	/* 136a -  */  0,
	/* 136b -  */  0,
	/* 136c -  */  0,
	/* 136d - _V_66_0F_38_BA */  0x412b,
	/* 136e -  */  0,
	/* 136f -  */  0,
	/* 1370 -  */  0,
	/* 1371 -  */  0,
	/* 1372 -  */  0,
	/* 1373 -  */  0,
	/* 1374 -  */  0,
	/* 1375 -  */  0,
	/* 1376 -  */  0,
	/* 1377 -  */  0,
	/* 1378 -  */  0,
	/* 1379 - _V_66_0F_38_BB */  0x412c,
	/* 137a -  */  0,
	/* 137b -  */  0,
	/* 137c -  */  0,
	/* 137d -  */  0,
	/* 137e -  */  0,
	/* 137f -  */  0,
	/* 1380 -  */  0,
	/* 1381 -  */  0,
	/* 1382 -  */  0,
	/* 1383 -  */  0,
	/* 1384 -  */  0,
	/* 1385 - _V_66_0F_38_BC */  0x412d,
	/* 1386 -  */  0,
	/* 1387 -  */  0,
	/* 1388 -  */  0,
	/* 1389 -  */  0,
	/* 138a -  */  0,
	/* 138b -  */  0,
	/* 138c -  */  0,
	/* 138d -  */  0,
	/* 138e -  */  0,
	/* 138f -  */  0,
	/* 1390 -  */  0,
	/* 1391 - _V_66_0F_38_BD */  0x412e,
	/* 1392 -  */  0,
	/* 1393 -  */  0,
	/* 1394 -  */  0,
	/* 1395 -  */  0,
	/* 1396 -  */  0,
	/* 1397 -  */  0,
	/* 1398 -  */  0,
	/* 1399 -  */  0,
	/* 139a -  */  0,
	/* 139b -  */  0,
	/* 139c -  */  0,
	/* 139d - _V_66_0F_38_BE */  0x412f,
	/* 139e -  */  0,
	/* 139f -  */  0,
	/* 13a0 -  */  0,
	/* 13a1 -  */  0,
	/* 13a2 -  */  0,
	/* 13a3 -  */  0,
	/* 13a4 -  */  0,
	/* 13a5 -  */  0,
	/* 13a6 -  */  0,
	/* 13a7 -  */  0,
	/* 13a8 -  */  0,
	/* 13a9 - _V_66_0F_38_BF */  0x4130,
	/* 13aa -  */  0,
	/* 13ab -  */  0,
	/* 13ac -  */  0,
	/* 13ad -  */  0,
	/* 13ae -  */  0,
	/* 13af -  */  0,
	/* 13b0 -  */  0,
	/* 13b1 - _66_0F_38_DB */  0x24ba,
	/* 13b2 -  */  0,
	/* 13b3 -  */  0,
	/* 13b4 -  */  0,
	/* 13b5 - _V_66_0F_38_DB */  0x4131,
	/* 13b6 -  */  0,
	/* 13b7 -  */  0,
	/* 13b8 -  */  0,
	/* 13b9 -  */  0,
	/* 13ba -  */  0,
	/* 13bb -  */  0,
	/* 13bc -  */  0,
	/* 13bd - _66_0F_38_DC */  0x24bb,
	/* 13be -  */  0,
	/* 13bf -  */  0,
	/* 13c0 -  */  0,
	/* 13c1 - _V_66_0F_38_DC */  0x4132,
	/* 13c2 -  */  0,
	/* 13c3 -  */  0,
	/* 13c4 -  */  0,
	/* 13c5 -  */  0,
	/* 13c6 -  */  0,
	/* 13c7 -  */  0,
	/* 13c8 -  */  0,
	/* 13c9 - _66_0F_38_DD */  0x24bc,
	/* 13ca -  */  0,
	/* 13cb -  */  0,
	/* 13cc -  */  0,
	/* 13cd - _V_66_0F_38_DD */  0x4133,
	/* 13ce -  */  0,
	/* 13cf -  */  0,
	/* 13d0 -  */  0,
	/* 13d1 -  */  0,
	/* 13d2 -  */  0,
	/* 13d3 -  */  0,
	/* 13d4 -  */  0,
	/* 13d5 - _66_0F_38_DE */  0x24bd,
	/* 13d6 -  */  0,
	/* 13d7 -  */  0,
	/* 13d8 -  */  0,
	/* 13d9 - _V_66_0F_38_DE */  0x4134,
	/* 13da -  */  0,
	/* 13db -  */  0,
	/* 13dc -  */  0,
	/* 13dd -  */  0,
	/* 13de -  */  0,
	/* 13df -  */  0,
	/* 13e0 -  */  0,
	/* 13e1 - _66_0F_38_DF */  0x24be,
	/* 13e2 -  */  0,
	/* 13e3 -  */  0,
	/* 13e4 -  */  0,
	/* 13e5 - _V_66_0F_38_DF */  0x4135,
	/* 13e6 -  */  0,
	/* 13e7 -  */  0,
	/* 13e8 -  */  0,
	/* 13e9 -  */  0,
	/* 13ea -  */  0,
	/* 13eb -  */  0,
	/* 13ec - _0F_38_F0 */  0x24bf,
	/* 13ed -  */  0,
	/* 13ee -  */  0,
	/* 13ef - _F2_0F_38_F0 */  0x24c0,
	/* 13f0 -  */  0,
	/* 13f1 -  */  0,
	/* 13f2 -  */  0,
	/* 13f3 -  */  0,
	/* 13f4 -  */  0,
	/* 13f5 -  */  0,
	/* 13f6 -  */  0,
	/* 13f7 -  */  0,
	/* 13f8 - _0F_38_F1 */  0x24c1,
	/* 13f9 -  */  0,
	/* 13fa -  */  0,
	/* 13fb - _F2_0F_38_F1 */  0x24c2,
	/* 13fc -  */  0,
	/* 13fd -  */  0,
	/* 13fe -  */  0,
	/* 13ff -  */  0,
	/* 1400 -  */  0,
	/* 1401 -  */  0,
	/* 1402 -  */  0,
	/* 1403 -  */  0,
	/* 1404 -  */  0,
	/* 1405 -  */  0,
	/* 1406 -  */  0,
	/* 1407 -  */  0,
	/* 1408 -  */  0,
	/* 1409 - _V_66_0F_3A_04 */  0x4136,
	/* 140a -  */  0,
	/* 140b -  */  0,
	/* 140c -  */  0,
	/* 140d -  */  0,
	/* 140e -  */  0,
	/* 140f -  */  0,
	/* 1410 -  */  0,
	/* 1411 -  */  0,
	/* 1412 -  */  0,
	/* 1413 -  */  0,
	/* 1414 -  */  0,
	/* 1415 - _V_66_0F_3A_05 */  0x4137,
	/* 1416 -  */  0,
	/* 1417 -  */  0,
	/* 1418 -  */  0,
	/* 1419 -  */  0,
	/* 141a -  */  0,
	/* 141b -  */  0,
	/* 141c -  */  0,
	/* 141d -  */  0,
	/* 141e -  */  0,
	/* 141f -  */  0,
	/* 1420 -  */  0,
	/* 1421 - _V_66_0F_3A_06 */  0x4138,
	/* 1422 -  */  0,
	/* 1423 -  */  0,
	/* 1424 -  */  0,
	/* 1425 -  */  0,
	/* 1426 -  */  0,
	/* 1427 -  */  0,
	/* 1428 -  */  0,
	/* 1429 - _66_0F_3A_08 */  0x4139,
	/* 142a -  */  0,
	/* 142b -  */  0,
	/* 142c -  */  0,
	/* 142d - _V_66_0F_3A_08 */  0x413a,
	/* 142e -  */  0,
	/* 142f -  */  0,
	/* 1430 -  */  0,
	/* 1431 -  */  0,
	/* 1432 -  */  0,
	/* 1433 -  */  0,
	/* 1434 -  */  0,
	/* 1435 - _66_0F_3A_09 */  0x413b,
	/* 1436 -  */  0,
	/* 1437 -  */  0,
	/* 1438 -  */  0,
	/* 1439 - _V_66_0F_3A_09 */  0x413c,
	/* 143a -  */  0,
	/* 143b -  */  0,
	/* 143c -  */  0,
	/* 143d -  */  0,
	/* 143e -  */  0,
	/* 143f -  */  0,
	/* 1440 -  */  0,
	/* 1441 - _66_0F_3A_0A */  0x413d,
	/* 1442 -  */  0,
	/* 1443 -  */  0,
	/* 1444 -  */  0,
	/* 1445 - _V_66_0F_3A_0A */  0x413e,
	/* 1446 -  */  0,
	/* 1447 -  */  0,
	/* 1448 -  */  0,
	/* 1449 -  */  0,
	/* 144a -  */  0,
	/* 144b -  */  0,
	/* 144c -  */  0,
	/* 144d - _66_0F_3A_0B */  0x413f,
	/* 144e -  */  0,
	/* 144f -  */  0,
	/* 1450 -  */  0,
	/* 1451 - _V_66_0F_3A_0B */  0x4140,
	/* 1452 -  */  0,
	/* 1453 -  */  0,
	/* 1454 -  */  0,
	/* 1455 -  */  0,
	/* 1456 -  */  0,
	/* 1457 -  */  0,
	/* 1458 -  */  0,
	/* 1459 - _66_0F_3A_0C */  0x4141,
	/* 145a -  */  0,
	/* 145b -  */  0,
	/* 145c -  */  0,
	/* 145d - _V_66_0F_3A_0C */  0x4142,
	/* 145e -  */  0,
	/* 145f -  */  0,
	/* 1460 -  */  0,
	/* 1461 -  */  0,
	/* 1462 -  */  0,
	/* 1463 -  */  0,
	/* 1464 -  */  0,
	/* 1465 - _66_0F_3A_0D */  0x4143,
	/* 1466 -  */  0,
	/* 1467 -  */  0,
	/* 1468 -  */  0,
	/* 1469 - _V_66_0F_3A_0D */  0x4144,
	/* 146a -  */  0,
	/* 146b -  */  0,
	/* 146c -  */  0,
	/* 146d -  */  0,
	/* 146e -  */  0,
	/* 146f -  */  0,
	/* 1470 -  */  0,
	/* 1471 - _66_0F_3A_0E */  0x4145,
	/* 1472 -  */  0,
	/* 1473 -  */  0,
	/* 1474 -  */  0,
	/* 1475 - _V_66_0F_3A_0E */  0x4146,
	/* 1476 -  */  0,
	/* 1477 -  */  0,
	/* 1478 -  */  0,
	/* 1479 -  */  0,
	/* 147a -  */  0,
	/* 147b -  */  0,
	/* 147c - _0F_3A_0F */  0x4147,
	/* 147d - _66_0F_3A_0F */  0x4148,
	/* 147e -  */  0,
	/* 147f -  */  0,
	/* 1480 -  */  0,
	/* 1481 - _V_66_0F_3A_0F */  0x4149,
	/* 1482 -  */  0,
	/* 1483 -  */  0,
	/* 1484 -  */  0,
	/* 1485 -  */  0,
	/* 1486 -  */  0,
	/* 1487 -  */  0,
	/* 1488 -  */  0,
	/* 1489 - _66_0F_3A_14 */  0x414a,
	/* 148a -  */  0,
	/* 148b -  */  0,
	/* 148c -  */  0,
	/* 148d - _V_66_0F_3A_14 */  0x414b,
	/* 148e -  */  0,
	/* 148f -  */  0,
	/* 1490 -  */  0,
	/* 1491 -  */  0,
	/* 1492 -  */  0,
	/* 1493 -  */  0,
	/* 1494 -  */  0,
	/* 1495 - _66_0F_3A_15 */  0x414c,
	/* 1496 -  */  0,
	/* 1497 -  */  0,
	/* 1498 -  */  0,
	/* 1499 - _V_66_0F_3A_15 */  0x414d,
	/* 149a -  */  0,
	/* 149b -  */  0,
	/* 149c -  */  0,
	/* 149d -  */  0,
	/* 149e -  */  0,
	/* 149f -  */  0,
	/* 14a0 -  */  0,
	/* 14a1 - _66_0F_3A_16 */  0x414e,
	/* 14a2 -  */  0,
	/* 14a3 -  */  0,
	/* 14a4 -  */  0,
	/* 14a5 - _V_66_0F_3A_16 */  0x414f,
	/* 14a6 -  */  0,
	/* 14a7 -  */  0,
	/* 14a8 -  */  0,
	/* 14a9 -  */  0,
	/* 14aa -  */  0,
	/* 14ab -  */  0,
	/* 14ac -  */  0,
	/* 14ad - _66_0F_3A_17 */  0x4150,
	/* 14ae -  */  0,
	/* 14af -  */  0,
	/* 14b0 -  */  0,
	/* 14b1 - _V_66_0F_3A_17 */  0x4151,
	/* 14b2 -  */  0,
	/* 14b3 -  */  0,
	/* 14b4 -  */  0,
	/* 14b5 -  */  0,
	/* 14b6 -  */  0,
	/* 14b7 -  */  0,
	/* 14b8 -  */  0,
	/* 14b9 -  */  0,
	/* 14ba -  */  0,
	/* 14bb -  */  0,
	/* 14bc -  */  0,
	/* 14bd - _V_66_0F_3A_18 */  0x4152,
	/* 14be -  */  0,
	/* 14bf -  */  0,
	/* 14c0 -  */  0,
	/* 14c1 -  */  0,
	/* 14c2 -  */  0,
	/* 14c3 -  */  0,
	/* 14c4 -  */  0,
	/* 14c5 -  */  0,
	/* 14c6 -  */  0,
	/* 14c7 -  */  0,
	/* 14c8 -  */  0,
	/* 14c9 - _V_66_0F_3A_19 */  0x4153,
	/* 14ca -  */  0,
	/* 14cb -  */  0,
	/* 14cc -  */  0,
	/* 14cd -  */  0,
	/* 14ce -  */  0,
	/* 14cf -  */  0,
	/* 14d0 -  */  0,
	/* 14d1 - _66_0F_3A_20 */  0x4154,
	/* 14d2 -  */  0,
	/* 14d3 -  */  0,
	/* 14d4 -  */  0,
	/* 14d5 - _V_66_0F_3A_20 */  0x4155,
	/* 14d6 -  */  0,
	/* 14d7 -  */  0,
	/* 14d8 -  */  0,
	/* 14d9 -  */  0,
	/* 14da -  */  0,
	/* 14db -  */  0,
	/* 14dc -  */  0,
	/* 14dd - _66_0F_3A_21 */  0x4156,
	/* 14de -  */  0,
	/* 14df -  */  0,
	/* 14e0 -  */  0,
	/* 14e1 - _V_66_0F_3A_21 */  0x4157,
	/* 14e2 -  */  0,
	/* 14e3 -  */  0,
	/* 14e4 -  */  0,
	/* 14e5 -  */  0,
	/* 14e6 -  */  0,
	/* 14e7 -  */  0,
	/* 14e8 -  */  0,
	/* 14e9 - _66_0F_3A_22 */  0x4158,
	/* 14ea -  */  0,
	/* 14eb -  */  0,
	/* 14ec -  */  0,
	/* 14ed - _V_66_0F_3A_22 */  0x4159,
	/* 14ee -  */  0,
	/* 14ef -  */  0,
	/* 14f0 -  */  0,
	/* 14f1 -  */  0,
	/* 14f2 -  */  0,
	/* 14f3 -  */  0,
	/* 14f4 -  */  0,
	/* 14f5 - _66_0F_3A_40 */  0x415a,
	/* 14f6 -  */  0,
	/* 14f7 -  */  0,
	/* 14f8 -  */  0,
	/* 14f9 - _V_66_0F_3A_40 */  0x415b,
	/* 14fa -  */  0,
	/* 14fb -  */  0,
	/* 14fc -  */  0,
	/* 14fd -  */  0,
	/* 14fe -  */  0,
	/* 14ff -  */  0,
	/* 1500 -  */  0,
	/* 1501 - _66_0F_3A_41 */  0x415c,
	/* 1502 -  */  0,
	/* 1503 -  */  0,
	/* 1504 -  */  0,
	/* 1505 - _V_66_0F_3A_41 */  0x415d,
	/* 1506 -  */  0,
	/* 1507 -  */  0,
	/* 1508 -  */  0,
	/* 1509 -  */  0,
	/* 150a -  */  0,
	/* 150b -  */  0,
	/* 150c -  */  0,
	/* 150d - _66_0F_3A_42 */  0x415e,
	/* 150e -  */  0,
	/* 150f -  */  0,
	/* 1510 -  */  0,
	/* 1511 - _V_66_0F_3A_42 */  0x415f,
	/* 1512 -  */  0,
	/* 1513 -  */  0,
	/* 1514 -  */  0,
	/* 1515 -  */  0,
	/* 1516 -  */  0,
	/* 1517 -  */  0,
	/* 1518 -  */  0,
	/* 1519 - _66_0F_3A_44 */  0x4160,
	/* 151a -  */  0,
	/* 151b -  */  0,
	/* 151c -  */  0,
	/* 151d - _V_66_0F_3A_44 */  0x4161,
	/* 151e -  */  0,
	/* 151f -  */  0,
	/* 1520 -  */  0,
	/* 1521 -  */  0,
	/* 1522 -  */  0,
	/* 1523 -  */  0,
	/* 1524 -  */  0,
	/* 1525 -  */  0,
	/* 1526 -  */  0,
	/* 1527 -  */  0,
	/* 1528 -  */  0,
	/* 1529 - _V_66_0F_3A_4A */  0x4162,
	/* 152a -  */  0,
	/* 152b -  */  0,
	/* 152c -  */  0,
	/* 152d -  */  0,
	/* 152e -  */  0,
	/* 152f -  */  0,
	/* 1530 -  */  0,
	/* 1531 -  */  0,
	/* 1532 -  */  0,
	/* 1533 -  */  0,
	/* 1534 -  */  0,
	/* 1535 - _V_66_0F_3A_4B */  0x4163,
	/* 1536 -  */  0,
	/* 1537 -  */  0,
	/* 1538 -  */  0,
	/* 1539 -  */  0,
	/* 153a -  */  0,
	/* 153b -  */  0,
	/* 153c -  */  0,
	/* 153d -  */  0,
	/* 153e -  */  0,
	/* 153f -  */  0,
	/* 1540 -  */  0,
	/* 1541 - _V_66_0F_3A_4C */  0x4164,
	/* 1542 -  */  0,
	/* 1543 -  */  0,
	/* 1544 -  */  0,
	/* 1545 -  */  0,
	/* 1546 -  */  0,
	/* 1547 -  */  0,
	/* 1548 -  */  0,
	/* 1549 - _66_0F_3A_60 */  0x4165,
	/* 154a -  */  0,
	/* 154b -  */  0,
	/* 154c -  */  0,
	/* 154d - _V_66_0F_3A_60 */  0x4166,
	/* 154e -  */  0,
	/* 154f -  */  0,
	/* 1550 -  */  0,
	/* 1551 -  */  0,
	/* 1552 -  */  0,
	/* 1553 -  */  0,
	/* 1554 -  */  0,
	/* 1555 - _66_0F_3A_61 */  0x4167,
	/* 1556 -  */  0,
	/* 1557 -  */  0,
	/* 1558 -  */  0,
	/* 1559 - _V_66_0F_3A_61 */  0x4168,
	/* 155a -  */  0,
	/* 155b -  */  0,
	/* 155c -  */  0,
	/* 155d -  */  0,
	/* 155e -  */  0,
	/* 155f -  */  0,
	/* 1560 -  */  0,
	/* 1561 - _66_0F_3A_62 */  0x4169,
	/* 1562 -  */  0,
	/* 1563 -  */  0,
	/* 1564 -  */  0,
	/* 1565 - _V_66_0F_3A_62 */  0x416a,
	/* 1566 -  */  0,
	/* 1567 -  */  0,
	/* 1568 -  */  0,
	/* 1569 -  */  0,
	/* 156a -  */  0,
	/* 156b -  */  0,
	/* 156c -  */  0,
	/* 156d - _66_0F_3A_63 */  0x416b,
	/* 156e -  */  0,
	/* 156f -  */  0,
	/* 1570 -  */  0,
	/* 1571 - _V_66_0F_3A_63 */  0x416c,
	/* 1572 -  */  0,
	/* 1573 -  */  0,
	/* 1574 -  */  0,
	/* 1575 -  */  0,
	/* 1576 -  */  0,
	/* 1577 -  */  0,
	/* 1578 -  */  0,
	/* 1579 - _66_0F_3A_DF */  0x416d,
	/* 157a -  */  0,
	/* 157b -  */  0,
	/* 157c -  */  0,
	/* 157d - _V_66_0F_3A_DF */  0x416e,
	/* 157e -  */  0,
	/* 157f -  */  0,
	/* 1580 -  */  0,
	/* 1581 -  */  0,
	/* 1582 -  */  0,
	/* 1583 -  */  0,
	/* 1584 - _0F_71_02 */  0x24c3,
	/* 1585 - _66_0F_71_02 */  0x24c4,
	/* 1586 -  */  0,
	/* 1587 -  */  0,
	/* 1588 -  */  0,
	/* 1589 - _V_66_0F_71_02 */  0x416f,
	/* 158a -  */  0,
	/* 158b -  */  0,
	/* 158c -  */  0,
	/* 158d -  */  0,
	/* 158e -  */  0,
	/* 158f -  */  0,
	/* 1590 - _0F_71_04 */  0x24c5,
	/* 1591 - _66_0F_71_04 */  0x24c6,
	/* 1592 -  */  0,
	/* 1593 -  */  0,
	/* 1594 -  */  0,
	/* 1595 - _V_66_0F_71_04 */  0x4170,
	/* 1596 -  */  0,
	/* 1597 -  */  0,
	/* 1598 -  */  0,
	/* 1599 -  */  0,
	/* 159a -  */  0,
	/* 159b -  */  0,
	/* 159c - _0F_71_06 */  0x24c7,
	/* 159d - _66_0F_71_06 */  0x24c8,
	/* 159e -  */  0,
	/* 159f -  */  0,
	/* 15a0 -  */  0,
	/* 15a1 - _V_66_0F_71_06 */  0x4171,
	/* 15a2 -  */  0,
	/* 15a3 -  */  0,
	/* 15a4 -  */  0,
	/* 15a5 -  */  0,
	/* 15a6 -  */  0,
	/* 15a7 -  */  0,
	/* 15a8 - _0F_72_02 */  0x24c9,
	/* 15a9 - _66_0F_72_02 */  0x24ca,
	/* 15aa -  */  0,
	/* 15ab -  */  0,
	/* 15ac -  */  0,
	/* 15ad - _V_66_0F_72_02 */  0x4172,
	/* 15ae -  */  0,
	/* 15af -  */  0,
	/* 15b0 -  */  0,
	/* 15b1 -  */  0,
	/* 15b2 -  */  0,
	/* 15b3 -  */  0,
	/* 15b4 - _0F_72_04 */  0x24cb,
	/* 15b5 - _66_0F_72_04 */  0x24cc,
	/* 15b6 -  */  0,
	/* 15b7 -  */  0,
	/* 15b8 -  */  0,
	/* 15b9 - _V_66_0F_72_04 */  0x4173,
	/* 15ba -  */  0,
	/* 15bb -  */  0,
	/* 15bc -  */  0,
	/* 15bd -  */  0,
	/* 15be -  */  0,
	/* 15bf -  */  0,
	/* 15c0 - _0F_72_06 */  0x24cd,
	/* 15c1 - _66_0F_72_06 */  0x24ce,
	/* 15c2 -  */  0,
	/* 15c3 -  */  0,
	/* 15c4 -  */  0,
	/* 15c5 - _V_66_0F_72_06 */  0x4174,
	/* 15c6 -  */  0,
	/* 15c7 -  */  0,
	/* 15c8 -  */  0,
	/* 15c9 -  */  0,
	/* 15ca -  */  0,
	/* 15cb -  */  0,
	/* 15cc - _0F_73_02 */  0x24cf,
	/* 15cd - _66_0F_73_02 */  0x24d0,
	/* 15ce -  */  0,
	/* 15cf -  */  0,
	/* 15d0 -  */  0,
	/* 15d1 - _V_66_0F_73_02 */  0x4175,
	/* 15d2 -  */  0,
	/* 15d3 -  */  0,
	/* 15d4 -  */  0,
	/* 15d5 -  */  0,
	/* 15d6 -  */  0,
	/* 15d7 -  */  0,
	/* 15d8 -  */  0,
	/* 15d9 - _66_0F_73_03 */  0x24d1,
	/* 15da -  */  0,
	/* 15db -  */  0,
	/* 15dc -  */  0,
	/* 15dd - _V_66_0F_73_03 */  0x4176,
	/* 15de -  */  0,
	/* 15df -  */  0,
	/* 15e0 -  */  0,
	/* 15e1 -  */  0,
	/* 15e2 -  */  0,
	/* 15e3 -  */  0,
	/* 15e4 - _0F_73_06 */  0x24d2,
	/* 15e5 - _66_0F_73_06 */  0x24d3,
	/* 15e6 -  */  0,
	/* 15e7 -  */  0,
	/* 15e8 -  */  0,
	/* 15e9 - _V_66_0F_73_06 */  0x4177,
	/* 15ea -  */  0,
	/* 15eb -  */  0,
	/* 15ec -  */  0,
	/* 15ed -  */  0,
	/* 15ee -  */  0,
	/* 15ef -  */  0,
	/* 15f0 -  */  0,
	/* 15f1 - _66_0F_73_07 */  0x24d4,
	/* 15f2 -  */  0,
	/* 15f3 -  */  0,
	/* 15f4 -  */  0,
	/* 15f5 - _V_66_0F_73_07 */  0x4178,
	/* 15f6 -  */  0,
	/* 15f7 -  */  0,
	/* 15f8 -  */  0,
	/* 15f9 -  */  0,
	/* 15fa -  */  0,
	/* 15fb -  */  0,
	/* 15fc - _0F_AE_00 */  0x4179,
	/* 15fd -  */  0,
	/* 15fe - _F3_0F_AE_00 */  0x24d5,
	/* 15ff -  */  0,
	/* 1600 -  */  0,
	/* 1601 -  */  0,
	/* 1602 -  */  0,
	/* 1603 -  */  0,
	/* 1604 -  */  0,
	/* 1605 -  */  0,
	/* 1606 -  */  0,
	/* 1607 -  */  0,
	/* 1608 - _0F_AE_01 */  0x417a,
	/* 1609 -  */  0,
	/* 160a - _F3_0F_AE_01 */  0x24d6,
	/* 160b -  */  0,
	/* 160c -  */  0,
	/* 160d -  */  0,
	/* 160e -  */  0,
	/* 160f -  */  0,
	/* 1610 -  */  0,
	/* 1611 -  */  0,
	/* 1612 -  */  0,
	/* 1613 -  */  0,
	/* 1614 - _0F_AE_02 */  0x24d7,
	/* 1615 -  */  0,
	/* 1616 - _F3_0F_AE_02 */  0x24d8,
	/* 1617 -  */  0,
	/* 1618 - _V_0F_AE_02 */  0x417b,
	/* 1619 -  */  0,
	/* 161a -  */  0,
	/* 161b -  */  0,
	/* 161c -  */  0,
	/* 161d -  */  0,
	/* 161e -  */  0,
	/* 161f -  */  0,
	/* 1620 - _0F_AE_03 */  0x24d9,
	/* 1621 -  */  0,
	/* 1622 - _F3_0F_AE_03 */  0x24da,
	/* 1623 -  */  0,
	/* 1624 - _V_0F_AE_03 */  0x417c,
	/* 1625 -  */  0,
	/* 1626 -  */  0,
	/* 1627 -  */  0,
	/* 1628 -  */  0,
	/* 1629 -  */  0,
	/* 162a -  */  0,
	/* 162b -  */  0,
	/* 162c - _0F_C7_06 */  0x24db,
	/* 162d - _66_0F_C7_06 */  0x24dc,
	/* 162e - _F3_0F_C7_06 */  0x24dd,
	/* 162f -  */  0,
	/* 1630 -  */  0,
	/* 1631 -  */  0,
	/* 1632 -  */  0,
	/* 1633 -  */  0,
	/* 1634 -  */  0,
	/* 1635 -  */  0,
	/* 1636 -  */  0,
	/* 1637 -  */  0
};

_InstSharedInfo InstSharedInfoTable[470] = {
	{ 0, 9, 15, 8, 245, 0, 0 },
	{ 0, 11, 17, 8, 245, 0, 0 },
	{ 0, 15, 9, 8, 245, 0, 0 },
	{ 0, 17, 11, 8, 245, 0, 0 },
	{ 1, 1, 33, 8, 245, 0, 0 },
	{ 1, 3, 35, 8, 245, 0, 0 },
	{ 2, 0, 32, 8, 0, 0, 0 },
	{ 3, 0, 32, 8, 0, 0, 0 },
	{ 0, 9, 15, 8, 196, 16, 0 },
	{ 0, 11, 17, 8, 196, 16, 0 },
	{ 0, 15, 9, 8, 196, 16, 0 },
	{ 0, 17, 11, 8, 196, 16, 0 },
	{ 1, 1, 33, 8, 196, 16, 0 },
	{ 1, 3, 35, 8, 196, 16, 0 },
	{ 4, 0, 32, 8, 0, 0, 0 },
	{ 0, 9, 15, 8, 245, 1, 0 },
	{ 0, 11, 17, 8, 245, 1, 0 },
	{ 0, 15, 9, 8, 245, 1, 0 },
	{ 0, 17, 11, 8, 245, 1, 0 },
	{ 1, 1, 33, 8, 245, 1, 0 },
	{ 1, 3, 35, 8, 245, 1, 0 },
	{ 5, 0, 32, 8, 0, 0, 0 },
	{ 6, 0, 32, 8, 0, 0, 0 },
	{ 7, 0, 32, 8, 0, 0, 0 },
	{ 8, 0, 32, 8, 0, 0, 0 },
	{ 0, 9, 15, 8, 229, 0, 16 },
	{ 0, 11, 17, 8, 229, 0, 16 },
	{ 0, 15, 9, 8, 229, 0, 16 },
	{ 0, 17, 11, 8, 229, 0, 16 },
	{ 1, 1, 33, 8, 229, 0, 16 },
	{ 1, 3, 35, 8, 229, 0, 16 },
	{ 9, 0, 0, 8, 213, 17, 32 },
	{ 0, 9, 15, 8, 196, 0, 16 },
	{ 0, 11, 17, 8, 196, 0, 16 },
	{ 0, 15, 9, 8, 196, 0, 16 },
	{ 0, 17, 11, 8, 196, 0, 16 },
	{ 1, 1, 33, 8, 196, 0, 16 },
	{ 1, 3, 35, 8, 196, 0, 16 },
	{ 9, 0, 0, 8, 17, 16, 228 },
	{ 10, 9, 15, 8, 245, 0, 0 },
	{ 10, 11, 17, 8, 245, 0, 0 },
	{ 10, 15, 9, 8, 245, 0, 0 },
	{ 10, 17, 11, 8, 245, 0, 0 },
	{ 11, 1, 33, 8, 245, 0, 0 },
	{ 11, 3, 35, 8, 245, 0, 0 },
	{ 12, 0, 54, 8, 244, 0, 0 },
	{ 13, 0, 54, 8, 0, 0, 0 },
	{ 14, 0, 54, 8, 0, 0, 0 },
	{ 15, 0, 0, 8, 0, 0, 0 },
	{ 16, 42, 11, 8, 0, 0, 0 },
	{ 10, 10, 16, 8, 64, 0, 0 },
	{ 13, 0, 3, 8, 0, 0, 0 },
	{ 17, 17, 11, 8, 33, 0, 212 },
	{ 18, 0, 5, 8, 0, 0, 0 },
	{ 19, 59, 56, 8, 0, 8, 0 },
	{ 20, 59, 56, 8, 0, 8, 0 },
	{ 19, 55, 59, 8, 0, 8, 0 },
	{ 20, 55, 59, 8, 0, 8, 0 },
	{ 13, 0, 40, 13, 0, 32, 0 },
	{ 13, 0, 40, 13, 0, 1, 0 },
	{ 13, 0, 40, 13, 0, 64, 0 },
	{ 13, 0, 40, 13, 0, 65, 0 },
	{ 13, 0, 40, 13, 0, 128, 0 },
	{ 13, 0, 40, 13, 0, 4, 0 },
	{ 13, 0, 40, 13, 0, 160, 0 },
	{ 13, 0, 40, 13, 0, 224, 0 },
	{ 10, 9, 15, 8, 196, 0, 16 },
	{ 10, 11, 17, 8, 196, 0, 16 },
	{ 0, 9, 15, 8, 0, 0, 0 },
	{ 0, 11, 17, 8, 0, 0, 0 },
	{ 21, 9, 15, 8, 0, 0, 0 },
	{ 21, 11, 17, 8, 0, 0, 0 },
	{ 21, 15, 9, 8, 0, 0, 0 },
	{ 21, 17, 11, 8, 0, 0, 0 },
	{ 21, 31, 28, 8, 0, 0, 0 },
	{ 21, 42, 11, 8, 0, 0, 0 },
	{ 21, 28, 31, 8, 0, 0, 0 },
	{ 1, 35, 54, 8, 0, 0, 0 },
	{ 22, 0, 0, 8, 0, 0, 0 },
	{ 9, 0, 38, 9, 0, 0, 0 },
	{ 23, 0, 0, 8, 0, 0, 0 },
	{ 23, 0, 0, 8, 255, 0, 0 },
	{ 11, 0, 0, 8, 213, 0, 0 },
	{ 11, 0, 0, 8, 0, 0, 0 },
	{ 1, 49, 33, 8, 0, 0, 0 },
	{ 1, 50, 35, 8, 0, 0, 0 },
	{ 1, 33, 49, 8, 0, 0, 0 },
	{ 1, 35, 50, 8, 0, 0, 0 },
	{ 24, 55, 56, 8, 0, 8, 0 },
	{ 25, 55, 56, 8, 0, 8, 0 },
	{ 19, 56, 55, 8, 245, 8, 0 },
	{ 26, 56, 55, 8, 245, 8, 0 },
	{ 11, 1, 33, 8, 196, 0, 16 },
	{ 11, 3, 35, 8, 196, 0, 16 },
	{ 19, 33, 56, 8, 0, 8, 0 },
	{ 26, 35, 56, 8, 0, 8, 0 },
	{ 19, 55, 33, 8, 0, 8, 0 },
	{ 26, 55, 35, 8, 0, 8, 0 },
	{ 19, 33, 56, 8, 245, 8, 0 },
	{ 26, 35, 56, 8, 245, 8, 0 },
	{ 1, 1, 53, 8, 0, 0, 0 },
	{ 27, 3, 54, 8, 0, 0, 0 },
	{ 13, 0, 2, 10, 0, 0, 0 },
	{ 13, 0, 0, 10, 0, 0, 0 },
	{ 16, 37, 11, 8, 0, 0, 0 },
	{ 13, 8, 6, 8, 0, 0, 0 },
	{ 13, 0, 0, 8, 0, 0, 0 },
	{ 28, 0, 2, 10, 0, 0, 0 },
	{ 28, 0, 0, 10, 0, 0, 0 },
	{ 11, 0, 0, 14, 0, 0, 0 },
	{ 11, 0, 1, 14, 0, 0, 0 },
	{ 9, 0, 0, 14, 0, 0, 0 },
	{ 28, 0, 0, 10, 255, 0, 0 },
	{ 9, 0, 1, 8, 196, 0, 49 },
	{ 9, 0, 0, 8, 0, 0, 0 },
	{ 29, 0, 57, 8, 0, 0, 0 },
	{ 30, 0, 40, 13, 0, 64, 0 },
	{ 30, 0, 40, 13, 0, 0, 0 },
	{ 31, 0, 40, 13, 0, 0, 0 },
	{ 1, 1, 33, 8, 0, 0, 0 },
	{ 1, 1, 36, 8, 0, 0, 0 },
	{ 11, 33, 1, 8, 0, 0, 0 },
	{ 11, 36, 1, 8, 0, 0, 0 },
	{ 13, 0, 41, 9, 0, 0, 0 },
	{ 13, 0, 41, 12, 0, 0, 0 },
	{ 9, 0, 38, 12, 0, 0, 0 },
	{ 13, 0, 40, 12, 0, 0, 0 },
	{ 1, 59, 33, 8, 0, 0, 0 },
	{ 1, 59, 36, 8, 0, 0, 0 },
	{ 11, 33, 59, 8, 0, 0, 0 },
	{ 11, 36, 59, 8, 0, 0, 0 },
	{ 11, 0, 0, 8, 1, 0, 0 },
	{ 11, 0, 0, 8, 2, 0, 0 },
	{ 11, 0, 0, 8, 8, 0, 0 },
	{ 10, 16, 11, 8, 64, 0, 0 },
	{ 32, 0, 0, 27, 0, 0, 0 },
	{ 32, 0, 0, 8, 0, 0, 0 },
	{ 32, 0, 0, 14, 0, 0, 0 },
	{ 11, 0, 0, 96, 0, 0, 0 },
	{ 10, 0, 17, 8, 0, 0, 0 },
	{ 33, 29, 14, 8, 0, 0, 0 },
	{ 33, 30, 14, 8, 0, 0, 0 },
	{ 33, 14, 29, 8, 0, 0, 0 },
	{ 33, 14, 30, 8, 0, 0, 0 },
	{ 34, 0, 0, 8, 0, 0, 0 },
	{ 35, 17, 11, 31, 0, 32, 0 },
	{ 35, 17, 11, 31, 0, 1, 0 },
	{ 35, 17, 11, 31, 0, 64, 0 },
	{ 35, 17, 11, 31, 0, 65, 0 },
	{ 35, 17, 11, 31, 0, 128, 0 },
	{ 35, 17, 11, 31, 0, 4, 0 },
	{ 35, 17, 11, 31, 0, 160, 0 },
	{ 35, 17, 11, 31, 0, 224, 0 },
	{ 32, 0, 41, 13, 0, 32, 0 },
	{ 32, 0, 41, 13, 0, 1, 0 },
	{ 32, 0, 41, 13, 0, 64, 0 },
	{ 32, 0, 41, 13, 0, 65, 0 },
	{ 32, 0, 41, 13, 0, 128, 0 },
	{ 32, 0, 41, 13, 0, 4, 0 },
	{ 32, 0, 41, 13, 0, 160, 0 },
	{ 32, 0, 41, 13, 0, 224, 0 },
	{ 35, 0, 15, 8, 0, 32, 0 },
	{ 35, 0, 15, 8, 0, 1, 0 },
	{ 35, 0, 15, 8, 0, 64, 0 },
	{ 35, 0, 15, 8, 0, 65, 0 },
	{ 35, 0, 15, 8, 0, 128, 0 },
	{ 35, 0, 15, 8, 0, 4, 0 },
	{ 35, 0, 15, 8, 0, 160, 0 },
	{ 35, 0, 15, 8, 0, 224, 0 },
	{ 36, 0, 32, 8, 0, 0, 0 },
	{ 37, 0, 32, 8, 0, 0, 0 },
	{ 35, 11, 17, 8, 1, 0, 244 },
	{ 38, 11, 17, 8, 197, 0, 48 },
	{ 39, 0, 32, 8, 0, 0, 0 },
	{ 40, 0, 32, 8, 0, 0, 0 },
	{ 32, 0, 0, 8, 255, 0, 0 },
	{ 41, 11, 17, 8, 1, 0, 244 },
	{ 35, 17, 11, 8, 33, 0, 212 },
	{ 41, 9, 15, 8, 245, 0, 0 },
	{ 41, 11, 17, 8, 245, 0, 0 },
	{ 42, 37, 11, 8, 0, 0, 0 },
	{ 35, 15, 11, 8, 0, 0, 0 },
	{ 43, 16, 11, 8, 0, 0, 0 },
	{ 43, 13, 45, 48, 0, 0, 0 },
	{ 44, 0, 54, 8, 0, 0, 0 },
	{ 45, 1, 15, 8, 245, 0, 0 },
	{ 45, 1, 15, 8, 196, 16, 0 },
	{ 45, 1, 15, 8, 245, 1, 0 },
	{ 45, 1, 15, 8, 229, 0, 16 },
	{ 45, 1, 15, 8, 196, 0, 16 },
	{ 46, 1, 15, 8, 245, 0, 0 },
	{ 45, 3, 17, 8, 245, 0, 0 },
	{ 45, 3, 17, 8, 196, 16, 0 },
	{ 45, 3, 17, 8, 245, 1, 0 },
	{ 45, 3, 17, 8, 229, 0, 16 },
	{ 45, 3, 17, 8, 196, 0, 16 },
	{ 46, 3, 17, 8, 245, 0, 0 },
	{ 47, 1, 15, 8, 245, 0, 0 },
	{ 47, 1, 15, 8, 196, 16, 0 },
	{ 47, 1, 15, 8, 245, 1, 0 },
	{ 47, 1, 15, 8, 229, 0, 16 },
	{ 47, 1, 15, 8, 196, 0, 16 },
	{ 48, 1, 15, 8, 245, 0, 0 },
	{ 45, 5, 17, 8, 245, 0, 0 },
	{ 49, 5, 17, 8, 196, 16, 0 },
	{ 45, 5, 17, 8, 245, 1, 0 },
	{ 49, 5, 17, 8, 229, 0, 16 },
	{ 49, 5, 17, 8, 196, 0, 16 },
	{ 46, 5, 17, 8, 245, 0, 0 },
	{ 50, 0, 17, 8, 0, 0, 0 },
	{ 51, 1, 15, 8, 1, 0, 32 },
	{ 51, 1, 15, 8, 1, 1, 32 },
	{ 51, 1, 15, 8, 197, 0, 48 },
	{ 51, 1, 17, 8, 1, 0, 32 },
	{ 51, 1, 17, 8, 1, 1, 32 },
	{ 51, 1, 17, 8, 197, 0, 48 },
	{ 52, 1, 15, 8, 0, 0, 0 },
	{ 53, 0, 1, 24, 0, 0, 0 },
	{ 52, 3, 17, 8, 0, 0, 0 },
	{ 53, 0, 41, 24, 0, 0, 0 },
	{ 51, 51, 15, 8, 33, 0, 0 },
	{ 51, 51, 15, 8, 33, 1, 0 },
	{ 51, 51, 15, 8, 229, 0, 16 },
	{ 51, 51, 17, 8, 33, 0, 0 },
	{ 51, 51, 17, 8, 33, 1, 0 },
	{ 51, 51, 17, 8, 229, 0, 16 },
	{ 51, 52, 15, 8, 1, 0, 32 },
	{ 51, 52, 15, 8, 1, 1, 32 },
	{ 51, 52, 15, 8, 197, 0, 48 },
	{ 51, 52, 17, 8, 1, 0, 32 },
	{ 51, 52, 17, 8, 1, 1, 32 },
	{ 51, 52, 17, 8, 197, 0, 48 },
	{ 46, 0, 21, 16, 0, 0, 0 },
	{ 54, 0, 62, 16, 0, 0, 0 },
	{ 54, 0, 61, 16, 0, 0, 0 },
	{ 54, 0, 0, 16, 0, 0, 0 },
	{ 51, 0, 21, 16, 0, 0, 0 },
	{ 46, 0, 42, 16, 0, 0, 0 },
	{ 46, 0, 20, 16, 0, 0, 0 },
	{ 55, 0, 62, 24, 0, 1, 0 },
	{ 55, 0, 62, 24, 0, 64, 0 },
	{ 55, 0, 62, 24, 0, 65, 0 },
	{ 55, 0, 62, 24, 0, 4, 0 },
	{ 56, 0, 21, 56, 0, 0, 0 },
	{ 46, 0, 23, 16, 0, 0, 0 },
	{ 51, 0, 23, 16, 0, 0, 0 },
	{ 55, 0, 62, 16, 69, 0, 0 },
	{ 55, 0, 62, 24, 69, 0, 0 },
	{ 46, 0, 22, 16, 0, 0, 0 },
	{ 54, 0, 63, 16, 0, 0, 0 },
	{ 56, 0, 22, 56, 0, 0, 0 },
	{ 51, 0, 22, 16, 0, 0, 0 },
	{ 56, 0, 20, 56, 0, 0, 0 },
	{ 51, 0, 20, 16, 0, 0, 0 },
	{ 46, 1, 15, 8, 196, 0, 16 },
	{ 45, 0, 15, 8, 0, 0, 0 },
	{ 45, 0, 15, 8, 245, 0, 0 },
	{ 51, 0, 15, 8, 33, 0, 212 },
	{ 51, 0, 15, 8, 0, 0, 245 },
	{ 46, 3, 17, 8, 196, 0, 16 },
	{ 45, 0, 17, 8, 0, 0, 0 },
	{ 45, 0, 17, 8, 245, 0, 0 },
	{ 51, 0, 17, 8, 33, 0, 212 },
	{ 51, 0, 17, 8, 0, 0, 245 },
	{ 45, 0, 15, 8, 244, 0, 0 },
	{ 45, 0, 17, 8, 244, 0, 0 },
	{ 57, 0, 17, 9, 0, 0, 0 },
	{ 58, 0, 37, 9, 0, 0, 0 },
	{ 57, 0, 17, 12, 0, 0, 0 },
	{ 58, 0, 37, 12, 0, 0, 0 },
	{ 57, 0, 17, 8, 0, 0, 0 },
	{ 46, 0, 17, 8, 0, 0, 0 },
	{ 46, 0, 16, 8, 0, 0, 0 },
	{ 56, 0, 16, 8, 0, 0, 0 },
	{ 46, 0, 16, 8, 64, 0, 0 },
	{ 57, 0, 39, 8, 0, 0, 0 },
	{ 52, 0, 28, 8, 0, 0, 0 },
	{ 59, 0, 16, 8, 0, 0, 0 },
	{ 56, 0, 42, 8, 0, 0, 0 },
	{ 55, 0, 0, 112, 0, 0, 0 },
	{ 55, 0, 0, 8, 0, 0, 0 },
	{ 13, 0, 0, 24, 0, 0, 0 },
	{ 56, 0, 58, 120, 0, 0, 0 },
	{ 55, 0, 0, 120, 0, 0, 0 },
	{ 55, 0, 58, 120, 0, 0, 0 },
	{ 55, 60, 58, 120, 0, 0, 0 },
	{ 60, 0, 0, 8, 0, 0, 0 },
	{ 56, 0, 42, 96, 0, 0, 0 },
	{ 61, 67, 64, 104, 0, 0, 0 },
	{ 61, 67, 64, 96, 0, 0, 0 },
	{ 35, 73, 68, 40, 0, 0, 0 },
	{ 35, 73, 68, 48, 0, 0, 0 },
	{ 35, 71, 68, 40, 0, 0, 0 },
	{ 35, 72, 68, 48, 0, 0, 0 },
	{ 62, 90, 83, 128, 0, 0, 0 },
	{ 63, 81, 68, 128, 0, 0, 0 },
	{ 64, 44, 68, 128, 0, 0, 0 },
	{ 64, 46, 68, 128, 0, 0, 0 },
	{ 35, 68, 73, 40, 0, 0, 0 },
	{ 35, 68, 73, 48, 0, 0, 0 },
	{ 35, 68, 71, 40, 0, 0, 0 },
	{ 35, 68, 72, 48, 0, 0, 0 },
	{ 62, 83, 90, 128, 0, 0, 0 },
	{ 64, 68, 44, 128, 0, 0, 0 },
	{ 64, 68, 46, 128, 0, 0, 0 },
	{ 65, 72, 68, 40, 0, 0, 0 },
	{ 35, 46, 68, 48, 0, 0, 0 },
	{ 35, 72, 68, 56, 0, 0, 0 },
	{ 66, 81, 68, 128, 0, 0, 0 },
	{ 67, 81, 68, 128, 0, 0, 0 },
	{ 62, 89, 83, 128, 0, 0, 0 },
	{ 35, 68, 46, 40, 0, 0, 0 },
	{ 35, 68, 46, 48, 0, 0, 0 },
	{ 62, 68, 46, 128, 0, 0, 0 },
	{ 34, 73, 68, 40, 0, 0, 0 },
	{ 34, 73, 68, 48, 0, 0, 0 },
	{ 67, 88, 83, 128, 0, 0, 0 },
	{ 35, 73, 68, 56, 0, 0, 0 },
	{ 56, 0, 42, 40, 0, 0, 0 },
	{ 34, 67, 68, 40, 0, 0, 0 },
	{ 34, 67, 68, 48, 0, 0, 0 },
	{ 42, 18, 68, 40, 0, 0, 0 },
	{ 42, 18, 68, 48, 0, 0, 0 },
	{ 35, 68, 47, 40, 0, 0, 0 },
	{ 35, 68, 47, 48, 0, 0, 0 },
	{ 35, 68, 44, 88, 0, 0, 0 },
	{ 35, 68, 46, 88, 0, 0, 0 },
	{ 62, 83, 92, 128, 0, 0, 0 },
	{ 34, 72, 64, 40, 0, 0, 0 },
	{ 34, 73, 64, 48, 0, 0, 0 },
	{ 42, 71, 13, 40, 0, 0, 0 },
	{ 42, 72, 13, 48, 0, 0, 0 },
	{ 62, 80, 78, 128, 0, 0, 0 },
	{ 34, 71, 68, 40, 69, 0, 0 },
	{ 34, 72, 68, 48, 0, 0, 0 },
	{ 62, 71, 68, 128, 0, 0, 0 },
	{ 62, 72, 68, 128, 0, 0, 0 },
	{ 68, 69, 12, 40, 0, 0, 0 },
	{ 68, 69, 12, 48, 0, 0, 0 },
	{ 69, 83, 13, 128, 0, 0, 0 },
	{ 34, 71, 68, 40, 0, 0, 0 },
	{ 34, 71, 68, 48, 0, 0, 0 },
	{ 62, 91, 83, 128, 0, 0, 0 },
	{ 62, 90, 68, 128, 0, 0, 0 },
	{ 34, 66, 64, 32, 0, 0, 0 },
	{ 34, 67, 64, 32, 0, 0, 0 },
	{ 70, 18, 64, 32, 0, 0, 0 },
	{ 70, 18, 68, 48, 0, 0, 0 },
	{ 62, 79, 68, 128, 0, 0, 0 },
	{ 35, 67, 64, 32, 0, 0, 0 },
	{ 71, 67, 64, 40, 0, 0, 0 },
	{ 71, 73, 68, 48, 0, 0, 0 },
	{ 67, 73, 68, 128, 0, 0, 0 },
	{ 32, 0, 0, 32, 0, 0, 0 },
	{ 72, 0, 0, 128, 0, 0, 0 },
	{ 73, 13, 18, 112, 0, 0, 0 },
	{ 74, 7, 69, 88, 0, 0, 0 },
	{ 75, 69, 68, 88, 0, 0, 0 },
	{ 73, 18, 13, 112, 0, 0, 0 },
	{ 34, 69, 68, 88, 0, 0, 0 },
	{ 76, 69, 68, 88, 0, 0, 0 },
	{ 32, 72, 68, 112, 0, 0, 0 },
	{ 32, 68, 72, 112, 0, 0, 0 },
	{ 34, 73, 68, 56, 0, 0, 0 },
	{ 70, 64, 18, 32, 0, 0, 0 },
	{ 70, 68, 18, 48, 0, 0, 0 },
	{ 62, 68, 79, 128, 0, 0, 0 },
	{ 35, 64, 67, 32, 0, 0, 0 },
	{ 77, 0, 42, 8, 0, 0, 0 },
	{ 78, 0, 43, 8, 0, 0, 0 },
	{ 79, 0, 43, 8, 0, 0, 0 },
	{ 80, 17, 11, 80, 64, 0, 0 },
	{ 81, 1, 17, 8, 1, 0, 244 },
	{ 49, 1, 17, 8, 1, 0, 244 },
	{ 34, 17, 11, 8, 64, 0, 245 },
	{ 82, 17, 11, 112, 0, 0, 0 },
	{ 83, 17, 11, 8, 65, 0, 180 },
	{ 84, 73, 68, 40, 0, 0, 0 },
	{ 84, 73, 68, 48, 0, 0, 0 },
	{ 84, 71, 68, 40, 0, 0, 0 },
	{ 84, 72, 68, 48, 0, 0, 0 },
	{ 85, 88, 83, 128, 0, 0, 0 },
	{ 85, 81, 68, 128, 0, 0, 0 },
	{ 71, 25, 64, 40, 0, 0, 0 },
	{ 71, 25, 68, 48, 0, 0, 0 },
	{ 86, 81, 68, 128, 0, 0, 0 },
	{ 87, 65, 12, 40, 0, 0, 0 },
	{ 71, 69, 12, 48, 0, 0, 0 },
	{ 88, 68, 13, 128, 0, 0, 0 },
	{ 71, 73, 68, 40, 0, 0, 0 },
	{ 86, 88, 83, 128, 0, 0, 0 },
	{ 89, 0, 48, 8, 64, 0, 0 },
	{ 56, 0, 46, 112, 0, 0, 0 },
	{ 68, 65, 68, 48, 0, 0, 0 },
	{ 68, 69, 64, 48, 0, 0, 0 },
	{ 62, 68, 72, 128, 0, 0, 0 },
	{ 76, 65, 12, 40, 0, 0, 0 },
	{ 76, 69, 12, 48, 0, 0, 0 },
	{ 69, 68, 13, 128, 0, 0, 0 },
	{ 34, 67, 64, 40, 0, 0, 0 },
	{ 35, 64, 46, 40, 0, 0, 0 },
	{ 34, 42, 68, 56, 0, 0, 0 },
	{ 62, 92, 83, 128, 0, 0, 0 },
	{ 34, 67, 64, 48, 0, 0, 0 },
	{ 76, 65, 64, 40, 0, 0, 0 },
	{ 76, 69, 68, 48, 0, 0, 0 },
	{ 90, 69, 68, 128, 0, 0, 0 },
	{ 51, 0, 42, 16, 0, 0, 0 },
	{ 91, 0, 42, 16, 0, 0, 0 },
	{ 91, 0, 20, 16, 0, 0, 0 },
	{ 92, 0, 0, 16, 0, 0, 0 },
	{ 93, 0, 34, 16, 0, 0, 0 },
	{ 94, 0, 34, 16, 0, 0, 0 },
	{ 34, 67, 64, 64, 0, 0, 0 },
	{ 34, 73, 68, 64, 0, 0, 0 },
	{ 71, 73, 68, 72, 0, 0, 0 },
	{ 34, 73, 68, 80, 0, 0, 0 },
	{ 62, 44, 83, 128, 0, 0, 0 },
	{ 62, 46, 85, 128, 0, 0, 0 },
	{ 62, 47, 85, 128, 0, 0, 0 },
	{ 62, 73, 68, 128, 0, 0, 0 },
	{ 34, 72, 68, 72, 0, 0, 0 },
	{ 34, 71, 68, 72, 0, 0, 0 },
	{ 34, 70, 68, 72, 0, 0, 0 },
	{ 62, 70, 68, 128, 0, 0, 0 },
	{ 34, 73, 68, 72, 0, 0, 0 },
	{ 35, 47, 68, 72, 0, 0, 0 },
	{ 62, 47, 68, 128, 0, 0, 0 },
	{ 67, 88, 92, 128, 0, 0, 0 },
	{ 73, 47, 13, 112, 0, 0, 0 },
	{ 67, 88, 83, 136, 0, 0, 0 },
	{ 67, 81, 68, 136, 0, 0, 0 },
	{ 34, 73, 68, 152, 0, 0, 0 },
	{ 62, 73, 68, 152, 0, 0, 0 },
	{ 67, 81, 68, 152, 0, 0, 0 },
	{ 35, 17, 11, 8, 0, 0, 0 },
	{ 35, 15, 13, 80, 0, 0, 0 },
	{ 35, 11, 17, 8, 0, 0, 0 },
	{ 35, 17, 13, 80, 0, 0, 0 },
	{ 67, 90, 83, 128, 0, 0, 0 },
	{ 86, 87, 85, 128, 0, 0, 0 },
	{ 71, 71, 68, 72, 0, 0, 0 },
	{ 71, 72, 68, 72, 0, 0, 0 },
	{ 71, 67, 64, 64, 0, 0, 0 },
	{ 71, 73, 68, 64, 0, 0, 0 },
	{ 71, 68, 26, 72, 0, 0, 0 },
	{ 88, 68, 76, 128, 0, 0, 0 },
	{ 71, 68, 27, 72, 0, 0, 0 },
	{ 88, 68, 77, 128, 0, 0, 0 },
	{ 95, 68, 18, 72, 0, 0, 0 },
	{ 67, 68, 79, 128, 0, 0, 0 },
	{ 71, 68, 18, 72, 0, 0, 0 },
	{ 67, 68, 75, 128, 0, 0, 0 },
	{ 67, 85, 73, 128, 0, 0, 0 },
	{ 71, 24, 68, 72, 0, 0, 0 },
	{ 95, 18, 68, 72, 0, 0, 0 },
	{ 71, 73, 68, 144, 0, 0, 0 },
	{ 86, 81, 68, 144, 0, 0, 0 },
	{ 71, 73, 68, 80, 0, 0, 0 },
	{ 71, 73, 68, 152, 0, 0, 0 },
	{ 67, 73, 68, 152, 0, 0, 0 },
	{ 96, 1, 65, 32, 0, 0, 0 },
	{ 56, 1, 69, 48, 0, 0, 0 },
	{ 97, 69, 81, 128, 0, 0, 0 },
	{ 98, 0, 13, 112, 0, 0, 0 },
	{ 64, 0, 44, 128, 0, 0, 0 },
	{ 56, 0, 42, 112, 0, 0, 0 },
	{ 99, 75, 13, 8, 0, 0, 0 },
	{ 98, 0, 17, 8, 0, 0, 0 },
	{ 100, 67, 64, 96, 0, 0, 0 }
};

uint16_t CmpMnemonicOffsets[8] = {
	0, 9, 18, 27, 39, 49, 59, 69
};
uint16_t VCmpMnemonicOffsets[32] = {
	0, 10, 20, 30, 43, 54, 65, 76, 87, 100, 111, 122, 135, 149, 159, 169, 181, 194, 207, 220, 235, 249, 263, 277, 290, 303, 317, 331, 347, 361, 374, 387
};



================================================
File: 3rdparty/distorm/insts.h
================================================
/*
insts.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef INSTS_H
#define INSTS_H

#include "instructions.h"


/* Flags Table */
extern _iflags FlagsTable[];

/* Root Trie DB */
extern _InstSharedInfo InstSharedInfoTable[];
extern _InstInfo InstInfos[];
extern _InstInfoEx InstInfosEx[];
extern _InstNode InstructionsTree[];

/* 3DNow! Trie DB */
extern _InstNode Table_0F_0F;
/* AVX related: */
extern _InstNode Table_0F, Table_0F_38, Table_0F_3A;

/*
 * The inst_lookup will return on of these two instructions according to the specified decoding mode.
 * ARPL or MOVSXD on 64 bits is one byte instruction at index 0x63.
 */
extern _InstInfo II_MOVSXD;

/*
 * The NOP instruction can be prefixed by REX in 64bits, therefore we have to decide in runtime whether it's an XCHG or NOP instruction.
 * If 0x90 is prefixed by a usable REX it will become XCHG, otherwise it will become a NOP.
 * Also note that if it's prefixed by 0xf3, it becomes a Pause.
 */
extern _InstInfo II_NOP;
extern _InstInfo II_PAUSE;

/*
 * RDRAND and VMPTRLD share same 2.3 bytes opcode, and then alternates on the MOD bits,
 * RDRAND is OT_FULL_REG while VMPTRLD is OT_MEM, and there's no such mixed type.
 * So a hack into the inst_lookup was added for this decision, the DB isn't flexible enough. :(
 */
extern _InstInfo II_RDRAND;

/*
 * Used for letting the extract operand know the type of operands without knowing the
 * instruction itself yet, because of the way those instructions work.
 * See function instructions.c!inst_lookup_3dnow.
 */
extern _InstInfo II_3DNOW;

/* Helper tables for pseudo compare mnemonics. */
extern uint16_t CmpMnemonicOffsets[8]; /* SSE */
extern uint16_t VCmpMnemonicOffsets[32]; /* AVX */

#endif /* INSTS_H */



================================================
File: 3rdparty/distorm/mnemonics.c
================================================
/*
mnemonics.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "mnemonics.h"

#ifndef DISTORM_LIGHT

const unsigned char _MNEMONICS[] =
"\x09" "UNDEFINED\0" "\x03" "ADD\0" "\x04" "PUSH\0" "\x03" "POP\0" "\x02" "OR\0" \
"\x03" "ADC\0" "\x03" "SBB\0" "\x03" "AND\0" "\x03" "DAA\0" "\x03" "SUB\0" \
"\x03" "DAS\0" "\x03" "XOR\0" "\x03" "AAA\0" "\x03" "CMP\0" "\x03" "AAS\0" \
"\x03" "INC\0" "\x03" "DEC\0" "\x05" "PUSHA\0" "\x04" "POPA\0" "\x05" "BOUND\0" \
"\x04" "ARPL\0" "\x04" "IMUL\0" "\x03" "INS\0" "\x04" "OUTS\0" "\x02" "JO\0" \
"\x03" "JNO\0" "\x02" "JB\0" "\x03" "JAE\0" "\x02" "JZ\0" "\x03" "JNZ\0" "\x03" "JBE\0" \
"\x02" "JA\0" "\x02" "JS\0" "\x03" "JNS\0" "\x02" "JP\0" "\x03" "JNP\0" "\x02" "JL\0" \
"\x03" "JGE\0" "\x03" "JLE\0" "\x02" "JG\0" "\x04" "TEST\0" "\x04" "XCHG\0" \
"\x03" "MOV\0" "\x03" "LEA\0" "\x03" "CBW\0" "\x04" "CWDE\0" "\x04" "CDQE\0" \
"\x03" "CWD\0" "\x03" "CDQ\0" "\x03" "CQO\0" "\x08" "CALL FAR\0" "\x05" "PUSHF\0" \
"\x04" "POPF\0" "\x04" "SAHF\0" "\x04" "LAHF\0" "\x04" "MOVS\0" "\x04" "CMPS\0" \
"\x04" "STOS\0" "\x04" "LODS\0" "\x04" "SCAS\0" "\x03" "RET\0" "\x03" "LES\0" \
"\x03" "LDS\0" "\x05" "ENTER\0" "\x05" "LEAVE\0" "\x04" "RETF\0" "\x05" "INT 3\0" \
"\x03" "INT\0" "\x04" "INTO\0" "\x04" "IRET\0" "\x03" "AAM\0" "\x03" "AAD\0" \
"\x04" "SALC\0" "\x04" "XLAT\0" "\x06" "LOOPNZ\0" "\x05" "LOOPZ\0" "\x04" "LOOP\0" \
"\x04" "JCXZ\0" "\x05" "JECXZ\0" "\x05" "JRCXZ\0" "\x02" "IN\0" "\x03" "OUT\0" \
"\x04" "CALL\0" "\x03" "JMP\0" "\x07" "JMP FAR\0" "\x04" "INT1\0" "\x03" "HLT\0" \
"\x03" "CMC\0" "\x03" "CLC\0" "\x03" "STC\0" "\x03" "CLI\0" "\x03" "STI\0" \
"\x03" "CLD\0" "\x03" "STD\0" "\x03" "LAR\0" "\x03" "LSL\0" "\x07" "SYSCALL\0" \
"\x04" "CLTS\0" "\x06" "SYSRET\0" "\x04" "INVD\0" "\x06" "WBINVD\0" "\x03" "UD2\0" \
"\x05" "FEMMS\0" "\x03" "NOP\0" "\x05" "WRMSR\0" "\x05" "RDTSC\0" "\x05" "RDMSR\0" \
"\x05" "RDPMC\0" "\x08" "SYSENTER\0" "\x07" "SYSEXIT\0" "\x06" "GETSEC\0" "\x05" "CMOVO\0" \
"\x06" "CMOVNO\0" "\x05" "CMOVB\0" "\x06" "CMOVAE\0" "\x05" "CMOVZ\0" "\x06" "CMOVNZ\0" \
"\x06" "CMOVBE\0" "\x05" "CMOVA\0" "\x05" "CMOVS\0" "\x06" "CMOVNS\0" "\x05" "CMOVP\0" \
"\x06" "CMOVNP\0" "\x05" "CMOVL\0" "\x06" "CMOVGE\0" "\x06" "CMOVLE\0" "\x05" "CMOVG\0" \
"\x04" "SETO\0" "\x05" "SETNO\0" "\x04" "SETB\0" "\x05" "SETAE\0" "\x04" "SETZ\0" \
"\x05" "SETNZ\0" "\x05" "SETBE\0" "\x04" "SETA\0" "\x04" "SETS\0" "\x05" "SETNS\0" \
"\x04" "SETP\0" "\x05" "SETNP\0" "\x04" "SETL\0" "\x05" "SETGE\0" "\x05" "SETLE\0" \
"\x04" "SETG\0" "\x05" "CPUID\0" "\x02" "BT\0" "\x04" "SHLD\0" "\x03" "RSM\0" \
"\x03" "BTS\0" "\x04" "SHRD\0" "\x07" "CMPXCHG\0" "\x03" "LSS\0" "\x03" "BTR\0" \
"\x03" "LFS\0" "\x03" "LGS\0" "\x05" "MOVZX\0" "\x03" "BTC\0" "\x05" "MOVSX\0" \
"\x04" "XADD\0" "\x06" "MOVNTI\0" "\x05" "BSWAP\0" "\x03" "ROL\0" "\x03" "ROR\0" \
"\x03" "RCL\0" "\x03" "RCR\0" "\x03" "SHL\0" "\x03" "SHR\0" "\x03" "SAL\0" \
"\x03" "SAR\0" "\x06" "XABORT\0" "\x06" "XBEGIN\0" "\x04" "FADD\0" "\x04" "FMUL\0" \
"\x04" "FCOM\0" "\x05" "FCOMP\0" "\x04" "FSUB\0" "\x05" "FSUBR\0" "\x04" "FDIV\0" \
"\x05" "FDIVR\0" "\x03" "FLD\0" "\x03" "FST\0" "\x04" "FSTP\0" "\x06" "FLDENV\0" \
"\x05" "FLDCW\0" "\x04" "FXCH\0" "\x04" "FNOP\0" "\x04" "FCHS\0" "\x04" "FABS\0" \
"\x04" "FTST\0" "\x04" "FXAM\0" "\x04" "FLD1\0" "\x06" "FLDL2T\0" "\x06" "FLDL2E\0" \
"\x05" "FLDPI\0" "\x06" "FLDLG2\0" "\x06" "FLDLN2\0" "\x04" "FLDZ\0" "\x05" "F2XM1\0" \
"\x05" "FYL2X\0" "\x05" "FPTAN\0" "\x06" "FPATAN\0" "\x07" "FXTRACT\0" "\x06" "FPREM1\0" \
"\x07" "FDECSTP\0" "\x07" "FINCSTP\0" "\x05" "FPREM\0" "\x07" "FYL2XP1\0" "\x05" "FSQRT\0" \
"\x07" "FSINCOS\0" "\x07" "FRNDINT\0" "\x06" "FSCALE\0" "\x04" "FSIN\0" "\x04" "FCOS\0" \
"\x05" "FIADD\0" "\x05" "FIMUL\0" "\x05" "FICOM\0" "\x06" "FICOMP\0" "\x05" "FISUB\0" \
"\x06" "FISUBR\0" "\x05" "FIDIV\0" "\x06" "FIDIVR\0" "\x06" "FCMOVB\0" "\x06" "FCMOVE\0" \
"\x07" "FCMOVBE\0" "\x06" "FCMOVU\0" "\x07" "FUCOMPP\0" "\x04" "FILD\0" "\x06" "FISTTP\0" \
"\x04" "FIST\0" "\x05" "FISTP\0" "\x07" "FCMOVNB\0" "\x07" "FCMOVNE\0" "\x08" "FCMOVNBE\0" \
"\x07" "FCMOVNU\0" "\x04" "FENI\0" "\x06" "FEDISI\0" "\x06" "FSETPM\0" "\x06" "FUCOMI\0" \
"\x05" "FCOMI\0" "\x06" "FRSTOR\0" "\x05" "FFREE\0" "\x05" "FUCOM\0" "\x06" "FUCOMP\0" \
"\x05" "FADDP\0" "\x05" "FMULP\0" "\x06" "FCOMPP\0" "\x06" "FSUBRP\0" "\x05" "FSUBP\0" \
"\x06" "FDIVRP\0" "\x05" "FDIVP\0" "\x04" "FBLD\0" "\x05" "FBSTP\0" "\x07" "FUCOMIP\0" \
"\x06" "FCOMIP\0" "\x03" "NOT\0" "\x03" "NEG\0" "\x03" "MUL\0" "\x03" "DIV\0" \
"\x04" "IDIV\0" "\x04" "SLDT\0" "\x03" "STR\0" "\x04" "LLDT\0" "\x03" "LTR\0" \
"\x04" "VERR\0" "\x04" "VERW\0" "\x04" "SGDT\0" "\x04" "SIDT\0" "\x04" "LGDT\0" \
"\x04" "LIDT\0" "\x04" "SMSW\0" "\x04" "LMSW\0" "\x06" "INVLPG\0" "\x06" "VMCALL\0" \
"\x08" "VMLAUNCH\0" "\x08" "VMRESUME\0" "\x06" "VMXOFF\0" "\x07" "MONITOR\0" \
"\x05" "MWAIT\0" "\x06" "XGETBV\0" "\x06" "XSETBV\0" "\x06" "VMFUNC\0" "\x04" "XEND\0" \
"\x05" "VMRUN\0" "\x07" "VMMCALL\0" "\x06" "VMLOAD\0" "\x06" "VMSAVE\0" "\x04" "STGI\0" \
"\x04" "CLGI\0" "\x06" "SKINIT\0" "\x07" "INVLPGA\0" "\x06" "SWAPGS\0" "\x06" "RDTSCP\0" \
"\x08" "PREFETCH\0" "\x09" "PREFETCHW\0" "\x05" "PI2FW\0" "\x05" "PI2FD\0" \
"\x05" "PF2IW\0" "\x05" "PF2ID\0" "\x06" "PFNACC\0" "\x07" "PFPNACC\0" "\x07" "PFCMPGE\0" \
"\x05" "PFMIN\0" "\x05" "PFRCP\0" "\x07" "PFRSQRT\0" "\x05" "PFSUB\0" "\x05" "PFADD\0" \
"\x07" "PFCMPGT\0" "\x05" "PFMAX\0" "\x08" "PFRCPIT1\0" "\x08" "PFRSQIT1\0" \
"\x06" "PFSUBR\0" "\x05" "PFACC\0" "\x07" "PFCMPEQ\0" "\x05" "PFMUL\0" "\x08" "PFRCPIT2\0" \
"\x07" "PMULHRW\0" "\x06" "PSWAPD\0" "\x07" "PAVGUSB\0" "\x06" "MOVUPS\0" "\x06" "MOVUPD\0" \
"\x05" "MOVSS\0" "\x05" "MOVSD\0" "\x07" "VMOVUPS\0" "\x07" "VMOVUPD\0" "\x06" "VMOVSS\0" \
"\x06" "VMOVSD\0" "\x07" "MOVHLPS\0" "\x06" "MOVLPS\0" "\x06" "MOVLPD\0" "\x08" "MOVSLDUP\0" \
"\x07" "MOVDDUP\0" "\x08" "VMOVHLPS\0" "\x07" "VMOVLPS\0" "\x07" "VMOVLPD\0" \
"\x09" "VMOVSLDUP\0" "\x08" "VMOVDDUP\0" "\x08" "UNPCKLPS\0" "\x08" "UNPCKLPD\0" \
"\x09" "VUNPCKLPS\0" "\x09" "VUNPCKLPD\0" "\x08" "UNPCKHPS\0" "\x08" "UNPCKHPD\0" \
"\x09" "VUNPCKHPS\0" "\x09" "VUNPCKHPD\0" "\x07" "MOVLHPS\0" "\x06" "MOVHPS\0" \
"\x06" "MOVHPD\0" "\x08" "MOVSHDUP\0" "\x08" "VMOVLHPS\0" "\x07" "VMOVHPS\0" \
"\x07" "VMOVHPD\0" "\x09" "VMOVSHDUP\0" "\x0b" "PREFETCHNTA\0" "\x0a" "PREFETCHT0\0" \
"\x0a" "PREFETCHT1\0" "\x0a" "PREFETCHT2\0" "\x06" "MOVAPS\0" "\x06" "MOVAPD\0" \
"\x07" "VMOVAPS\0" "\x07" "VMOVAPD\0" "\x08" "CVTPI2PS\0" "\x08" "CVTPI2PD\0" \
"\x08" "CVTSI2SS\0" "\x08" "CVTSI2SD\0" "\x09" "VCVTSI2SS\0" "\x09" "VCVTSI2SD\0" \
"\x07" "MOVNTPS\0" "\x07" "MOVNTPD\0" "\x07" "MOVNTSS\0" "\x07" "MOVNTSD\0" \
"\x08" "VMOVNTPS\0" "\x08" "VMOVNTPD\0" "\x09" "CVTTPS2PI\0" "\x09" "CVTTPD2PI\0" \
"\x09" "CVTTSS2SI\0" "\x09" "CVTTSD2SI\0" "\x0a" "VCVTTSS2SI\0" "\x0a" "VCVTTSD2SI\0" \
"\x08" "CVTPS2PI\0" "\x08" "CVTPD2PI\0" "\x08" "CVTSS2SI\0" "\x08" "CVTSD2SI\0" \
"\x09" "VCVTSS2SI\0" "\x09" "VCVTSD2SI\0" "\x07" "UCOMISS\0" "\x07" "UCOMISD\0" \
"\x08" "VUCOMISS\0" "\x08" "VUCOMISD\0" "\x06" "COMISS\0" "\x06" "COMISD\0" \
"\x07" "VCOMISS\0" "\x07" "VCOMISD\0" "\x08" "MOVMSKPS\0" "\x08" "MOVMSKPD\0" \
"\x09" "VMOVMSKPS\0" "\x09" "VMOVMSKPD\0" "\x06" "SQRTPS\0" "\x06" "SQRTPD\0" \
"\x06" "SQRTSS\0" "\x06" "SQRTSD\0" "\x07" "VSQRTPS\0" "\x07" "VSQRTPD\0" "\x07" "VSQRTSS\0" \
"\x07" "VSQRTSD\0" "\x07" "RSQRTPS\0" "\x07" "RSQRTSS\0" "\x08" "VRSQRTPS\0" \
"\x08" "VRSQRTSS\0" "\x05" "RCPPS\0" "\x05" "RCPSS\0" "\x06" "VRCPPS\0" "\x06" "VRCPSS\0" \
"\x05" "ANDPS\0" "\x05" "ANDPD\0" "\x06" "VANDPS\0" "\x06" "VANDPD\0" "\x06" "ANDNPS\0" \
"\x06" "ANDNPD\0" "\x07" "VANDNPS\0" "\x07" "VANDNPD\0" "\x04" "ORPS\0" "\x04" "ORPD\0" \
"\x05" "VORPS\0" "\x05" "VORPD\0" "\x05" "XORPS\0" "\x05" "XORPD\0" "\x06" "VXORPS\0" \
"\x06" "VXORPD\0" "\x05" "ADDPS\0" "\x05" "ADDPD\0" "\x05" "ADDSS\0" "\x05" "ADDSD\0" \
"\x06" "VADDPS\0" "\x06" "VADDPD\0" "\x06" "VADDSS\0" "\x06" "VADDSD\0" "\x05" "MULPS\0" \
"\x05" "MULPD\0" "\x05" "MULSS\0" "\x05" "MULSD\0" "\x06" "VMULPS\0" "\x06" "VMULPD\0" \
"\x06" "VMULSS\0" "\x06" "VMULSD\0" "\x08" "CVTPS2PD\0" "\x08" "CVTPD2PS\0" \
"\x08" "CVTSS2SD\0" "\x08" "CVTSD2SS\0" "\x09" "VCVTPS2PD\0" "\x09" "VCVTPD2PS\0" \
"\x09" "VCVTSS2SD\0" "\x09" "VCVTSD2SS\0" "\x08" "CVTDQ2PS\0" "\x08" "CVTPS2DQ\0" \
"\x09" "CVTTPS2DQ\0" "\x09" "VCVTDQ2PS\0" "\x09" "VCVTPS2DQ\0" "\x0a" "VCVTTPS2DQ\0" \
"\x05" "SUBPS\0" "\x05" "SUBPD\0" "\x05" "SUBSS\0" "\x05" "SUBSD\0" "\x06" "VSUBPS\0" \
"\x06" "VSUBPD\0" "\x06" "VSUBSS\0" "\x06" "VSUBSD\0" "\x05" "MINPS\0" "\x05" "MINPD\0" \
"\x05" "MINSS\0" "\x05" "MINSD\0" "\x06" "VMINPS\0" "\x06" "VMINPD\0" "\x06" "VMINSS\0" \
"\x06" "VMINSD\0" "\x05" "DIVPS\0" "\x05" "DIVPD\0" "\x05" "DIVSS\0" "\x05" "DIVSD\0" \
"\x06" "VDIVPS\0" "\x06" "VDIVPD\0" "\x06" "VDIVSS\0" "\x06" "VDIVSD\0" "\x05" "MAXPS\0" \
"\x05" "MAXPD\0" "\x05" "MAXSS\0" "\x05" "MAXSD\0" "\x06" "VMAXPS\0" "\x06" "VMAXPD\0" \
"\x06" "VMAXSS\0" "\x06" "VMAXSD\0" "\x09" "PUNPCKLBW\0" "\x0a" "VPUNPCKLBW\0" \
"\x09" "PUNPCKLWD\0" "\x0a" "VPUNPCKLWD\0" "\x09" "PUNPCKLDQ\0" "\x0a" "VPUNPCKLDQ\0" \
"\x08" "PACKSSWB\0" "\x09" "VPACKSSWB\0" "\x07" "PCMPGTB\0" "\x08" "VPCMPGTB\0" \
"\x07" "PCMPGTW\0" "\x08" "VPCMPGTW\0" "\x07" "PCMPGTD\0" "\x08" "VPCMPGTD\0" \
"\x08" "PACKUSWB\0" "\x09" "VPACKUSWB\0" "\x09" "PUNPCKHBW\0" "\x0a" "VPUNPCKHBW\0" \
"\x09" "PUNPCKHWD\0" "\x0a" "VPUNPCKHWD\0" "\x09" "PUNPCKHDQ\0" "\x0a" "VPUNPCKHDQ\0" \
"\x08" "PACKSSDW\0" "\x09" "VPACKSSDW\0" "\x0a" "PUNPCKLQDQ\0" "\x0b" "VPUNPCKLQDQ\0" \
"\x0a" "PUNPCKHQDQ\0" "\x0b" "VPUNPCKHQDQ\0" "\x04" "MOVD\0" "\x04" "MOVQ\0" \
"\x05" "VMOVD\0" "\x05" "VMOVQ\0" "\x06" "MOVDQA\0" "\x06" "MOVDQU\0" "\x07" "VMOVDQA\0" \
"\x07" "VMOVDQU\0" "\x06" "PSHUFW\0" "\x06" "PSHUFD\0" "\x07" "PSHUFHW\0" "\x07" "PSHUFLW\0" \
"\x07" "VPSHUFD\0" "\x08" "VPSHUFHW\0" "\x08" "VPSHUFLW\0" "\x07" "PCMPEQB\0" \
"\x08" "VPCMPEQB\0" "\x07" "PCMPEQW\0" "\x08" "VPCMPEQW\0" "\x07" "PCMPEQD\0" \
"\x08" "VPCMPEQD\0" "\x04" "EMMS\0" "\x0a" "VZEROUPPER\0" "\x08" "VZEROALL\0" \
"\x06" "VMREAD\0" "\x05" "EXTRQ\0" "\x07" "INSERTQ\0" "\x07" "VMWRITE\0" "\x08" "CVTPH2PS\0" \
"\x08" "CVTPS2PH\0" "\x06" "HADDPD\0" "\x06" "HADDPS\0" "\x07" "VHADDPD\0" \
"\x07" "VHADDPS\0" "\x06" "HSUBPD\0" "\x06" "HSUBPS\0" "\x07" "VHSUBPD\0" "\x07" "VHSUBPS\0" \
"\x05" "XSAVE\0" "\x07" "XSAVE64\0" "\x06" "LFENCE\0" "\x06" "XRSTOR\0" "\x08" "XRSTOR64\0" \
"\x06" "MFENCE\0" "\x08" "XSAVEOPT\0" "\x0a" "XSAVEOPT64\0" "\x06" "SFENCE\0" \
"\x07" "CLFLUSH\0" "\x06" "POPCNT\0" "\x03" "BSF\0" "\x05" "TZCNT\0" "\x03" "BSR\0" \
"\x05" "LZCNT\0" "\x07" "CMPEQPS\0" "\x07" "CMPLTPS\0" "\x07" "CMPLEPS\0" "\x0a" "CMPUNORDPS\0" \
"\x08" "CMPNEQPS\0" "\x08" "CMPNLTPS\0" "\x08" "CMPNLEPS\0" "\x08" "CMPORDPS\0" \
"\x07" "CMPEQPD\0" "\x07" "CMPLTPD\0" "\x07" "CMPLEPD\0" "\x0a" "CMPUNORDPD\0" \
"\x08" "CMPNEQPD\0" "\x08" "CMPNLTPD\0" "\x08" "CMPNLEPD\0" "\x08" "CMPORDPD\0" \
"\x07" "CMPEQSS\0" "\x07" "CMPLTSS\0" "\x07" "CMPLESS\0" "\x0a" "CMPUNORDSS\0" \
"\x08" "CMPNEQSS\0" "\x08" "CMPNLTSS\0" "\x08" "CMPNLESS\0" "\x08" "CMPORDSS\0" \
"\x07" "CMPEQSD\0" "\x07" "CMPLTSD\0" "\x07" "CMPLESD\0" "\x0a" "CMPUNORDSD\0" \
"\x08" "CMPNEQSD\0" "\x08" "CMPNLTSD\0" "\x08" "CMPNLESD\0" "\x08" "CMPORDSD\0" \
"\x08" "VCMPEQPS\0" "\x08" "VCMPLTPS\0" "\x08" "VCMPLEPS\0" "\x0b" "VCMPUNORDPS\0" \
"\x09" "VCMPNEQPS\0" "\x09" "VCMPNLTPS\0" "\x09" "VCMPNLEPS\0" "\x09" "VCMPORDPS\0" \
"\x0b" "VCMPEQ_UQPS\0" "\x09" "VCMPNGEPS\0" "\x09" "VCMPNGTPS\0" "\x0b" "VCMPFALSEPS\0" \
"\x0c" "VCMPNEQ_OQPS\0" "\x08" "VCMPGEPS\0" "\x08" "VCMPGTPS\0" "\x0a" "VCMPTRUEPS\0" \
"\x0b" "VCMPEQ_OSPS\0" "\x0b" "VCMPLT_OQPS\0" "\x0b" "VCMPLE_OQPS\0" "\x0d" "VCMPUNORD_SPS\0" \
"\x0c" "VCMPNEQ_USPS\0" "\x0c" "VCMPNLT_UQPS\0" "\x0c" "VCMPNLE_UQPS\0" "\x0b" "VCMPORD_SPS\0" \
"\x0b" "VCMPEQ_USPS\0" "\x0c" "VCMPNGE_UQPS\0" "\x0c" "VCMPNGT_UQPS\0" "\x0e" "VCMPFALSE_OSPS\0" \
"\x0c" "VCMPNEQ_OSPS\0" "\x0b" "VCMPGE_OQPS\0" "\x0b" "VCMPGT_OQPS\0" "\x0d" "VCMPTRUE_USPS\0" \
"\x08" "VCMPEQPD\0" "\x08" "VCMPLTPD\0" "\x08" "VCMPLEPD\0" "\x0b" "VCMPUNORDPD\0" \
"\x09" "VCMPNEQPD\0" "\x09" "VCMPNLTPD\0" "\x09" "VCMPNLEPD\0" "\x09" "VCMPORDPD\0" \
"\x0b" "VCMPEQ_UQPD\0" "\x09" "VCMPNGEPD\0" "\x09" "VCMPNGTPD\0" "\x0b" "VCMPFALSEPD\0" \
"\x0c" "VCMPNEQ_OQPD\0" "\x08" "VCMPGEPD\0" "\x08" "VCMPGTPD\0" "\x0a" "VCMPTRUEPD\0" \
"\x0b" "VCMPEQ_OSPD\0" "\x0b" "VCMPLT_OQPD\0" "\x0b" "VCMPLE_OQPD\0" "\x0d" "VCMPUNORD_SPD\0" \
"\x0c" "VCMPNEQ_USPD\0" "\x0c" "VCMPNLT_UQPD\0" "\x0c" "VCMPNLE_UQPD\0" "\x0b" "VCMPORD_SPD\0" \
"\x0b" "VCMPEQ_USPD\0" "\x0c" "VCMPNGE_UQPD\0" "\x0c" "VCMPNGT_UQPD\0" "\x0e" "VCMPFALSE_OSPD\0" \
"\x0c" "VCMPNEQ_OSPD\0" "\x0b" "VCMPGE_OQPD\0" "\x0b" "VCMPGT_OQPD\0" "\x0d" "VCMPTRUE_USPD\0" \
"\x08" "VCMPEQSS\0" "\x08" "VCMPLTSS\0" "\x08" "VCMPLESS\0" "\x0b" "VCMPUNORDSS\0" \
"\x09" "VCMPNEQSS\0" "\x09" "VCMPNLTSS\0" "\x09" "VCMPNLESS\0" "\x09" "VCMPORDSS\0" \
"\x0b" "VCMPEQ_UQSS\0" "\x09" "VCMPNGESS\0" "\x09" "VCMPNGTSS\0" "\x0b" "VCMPFALSESS\0" \
"\x0c" "VCMPNEQ_OQSS\0" "\x08" "VCMPGESS\0" "\x08" "VCMPGTSS\0" "\x0a" "VCMPTRUESS\0" \
"\x0b" "VCMPEQ_OSSS\0" "\x0b" "VCMPLT_OQSS\0" "\x0b" "VCMPLE_OQSS\0" "\x0d" "VCMPUNORD_SSS\0" \
"\x0c" "VCMPNEQ_USSS\0" "\x0c" "VCMPNLT_UQSS\0" "\x0c" "VCMPNLE_UQSS\0" "\x0b" "VCMPORD_SSS\0" \
"\x0b" "VCMPEQ_USSS\0" "\x0c" "VCMPNGE_UQSS\0" "\x0c" "VCMPNGT_UQSS\0" "\x0e" "VCMPFALSE_OSSS\0" \
"\x0c" "VCMPNEQ_OSSS\0" "\x0b" "VCMPGE_OQSS\0" "\x0b" "VCMPGT_OQSS\0" "\x0d" "VCMPTRUE_USSS\0" \
"\x08" "VCMPEQSD\0" "\x08" "VCMPLTSD\0" "\x08" "VCMPLESD\0" "\x0b" "VCMPUNORDSD\0" \
"\x09" "VCMPNEQSD\0" "\x09" "VCMPNLTSD\0" "\x09" "VCMPNLESD\0" "\x09" "VCMPORDSD\0" \
"\x0b" "VCMPEQ_UQSD\0" "\x09" "VCMPNGESD\0" "\x09" "VCMPNGTSD\0" "\x0b" "VCMPFALSESD\0" \
"\x0c" "VCMPNEQ_OQSD\0" "\x08" "VCMPGESD\0" "\x08" "VCMPGTSD\0" "\x0a" "VCMPTRUESD\0" \
"\x0b" "VCMPEQ_OSSD\0" "\x0b" "VCMPLT_OQSD\0" "\x0b" "VCMPLE_OQSD\0" "\x0d" "VCMPUNORD_SSD\0" \
"\x0c" "VCMPNEQ_USSD\0" "\x0c" "VCMPNLT_UQSD\0" "\x0c" "VCMPNLE_UQSD\0" "\x0b" "VCMPORD_SSD\0" \
"\x0b" "VCMPEQ_USSD\0" "\x0c" "VCMPNGE_UQSD\0" "\x0c" "VCMPNGT_UQSD\0" "\x0e" "VCMPFALSE_OSSD\0" \
"\x0c" "VCMPNEQ_OSSD\0" "\x0b" "VCMPGE_OQSD\0" "\x0b" "VCMPGT_OQSD\0" "\x0d" "VCMPTRUE_USSD\0" \
"\x06" "PINSRW\0" "\x07" "VPINSRW\0" "\x06" "PEXTRW\0" "\x07" "VPEXTRW\0" "\x06" "SHUFPS\0" \
"\x06" "SHUFPD\0" "\x07" "VSHUFPS\0" "\x07" "VSHUFPD\0" "\x09" "CMPXCHG8B\0" \
"\x0a" "CMPXCHG16B\0" "\x07" "VMPTRST\0" "\x08" "ADDSUBPD\0" "\x08" "ADDSUBPS\0" \
"\x09" "VADDSUBPD\0" "\x09" "VADDSUBPS\0" "\x05" "PSRLW\0" "\x06" "VPSRLW\0" \
"\x05" "PSRLD\0" "\x06" "VPSRLD\0" "\x05" "PSRLQ\0" "\x06" "VPSRLQ\0" "\x05" "PADDQ\0" \
"\x06" "VPADDQ\0" "\x06" "PMULLW\0" "\x07" "VPMULLW\0" "\x07" "MOVQ2DQ\0" "\x07" "MOVDQ2Q\0" \
"\x08" "PMOVMSKB\0" "\x09" "VPMOVMSKB\0" "\x07" "PSUBUSB\0" "\x08" "VPSUBUSB\0" \
"\x07" "PSUBUSW\0" "\x08" "VPSUBUSW\0" "\x06" "PMINUB\0" "\x07" "VPMINUB\0" \
"\x04" "PAND\0" "\x05" "VPAND\0" "\x07" "PADDUSB\0" "\x08" "VPADDUSW\0" "\x07" "PADDUSW\0" \
"\x06" "PMAXUB\0" "\x07" "VPMAXUB\0" "\x05" "PANDN\0" "\x06" "VPANDN\0" "\x05" "PAVGB\0" \
"\x06" "VPAVGB\0" "\x05" "PSRAW\0" "\x06" "VPSRAW\0" "\x05" "PSRAD\0" "\x06" "VPSRAD\0" \
"\x05" "PAVGW\0" "\x06" "VPAVGW\0" "\x07" "PMULHUW\0" "\x08" "VPMULHUW\0" "\x06" "PMULHW\0" \
"\x07" "VPMULHW\0" "\x09" "CVTTPD2DQ\0" "\x08" "CVTDQ2PD\0" "\x08" "CVTPD2DQ\0" \
"\x0a" "VCVTTPD2DQ\0" "\x09" "VCVTDQ2PD\0" "\x09" "VCVTPD2DQ\0" "\x06" "MOVNTQ\0" \
"\x07" "MOVNTDQ\0" "\x08" "VMOVNTDQ\0" "\x06" "PSUBSB\0" "\x07" "VPSUBSB\0" \
"\x06" "PSUBSW\0" "\x07" "VPSUBSW\0" "\x06" "PMINSW\0" "\x07" "VPMINSW\0" "\x03" "POR\0" \
"\x04" "VPOR\0" "\x06" "PADDSB\0" "\x07" "VPADDSB\0" "\x06" "PADDSW\0" "\x07" "VPADDSW\0" \
"\x06" "PMAXSW\0" "\x07" "VPMAXSW\0" "\x04" "PXOR\0" "\x05" "VPXOR\0" "\x05" "LDDQU\0" \
"\x06" "VLDDQU\0" "\x05" "PSLLW\0" "\x06" "VPSLLW\0" "\x05" "PSLLD\0" "\x06" "VPSLLD\0" \
"\x05" "PSLLQ\0" "\x06" "VPSLLQ\0" "\x07" "PMULUDQ\0" "\x08" "VPMULUDQ\0" "\x07" "PMADDWD\0" \
"\x08" "VPMADDWD\0" "\x06" "PSADBW\0" "\x07" "VPSADBW\0" "\x08" "MASKMOVQ\0" \
"\x0a" "MASKMOVDQU\0" "\x0b" "VMASKMOVDQU\0" "\x05" "PSUBB\0" "\x06" "VPSUBB\0" \
"\x05" "PSUBW\0" "\x06" "VPSUBW\0" "\x05" "PSUBD\0" "\x06" "VPSUBD\0" "\x05" "PSUBQ\0" \
"\x06" "VPSUBQ\0" "\x05" "PADDB\0" "\x06" "VPADDB\0" "\x05" "PADDW\0" "\x06" "VPADDW\0" \
"\x05" "PADDD\0" "\x06" "VPADDD\0" "\x07" "FNSTENV\0" "\x06" "FSTENV\0" "\x06" "FNSTCW\0" \
"\x05" "FSTCW\0" "\x06" "FNCLEX\0" "\x05" "FCLEX\0" "\x06" "FNINIT\0" "\x05" "FINIT\0" \
"\x06" "FNSAVE\0" "\x05" "FSAVE\0" "\x06" "FNSTSW\0" "\x05" "FSTSW\0" "\x06" "PSHUFB\0" \
"\x07" "VPSHUFB\0" "\x06" "PHADDW\0" "\x07" "VPHADDW\0" "\x06" "PHADDD\0" "\x07" "VPHADDD\0" \
"\x07" "PHADDSW\0" "\x08" "VPHADDSW\0" "\x09" "PMADDUBSW\0" "\x0a" "VPMADDUBSW\0" \
"\x06" "PHSUBW\0" "\x07" "VPHSUBW\0" "\x06" "PHSUBD\0" "\x07" "VPHSUBD\0" "\x07" "PHSUBSW\0" \
"\x08" "VPHSUBSW\0" "\x06" "PSIGNB\0" "\x07" "VPSIGNB\0" "\x06" "PSIGNW\0" \
"\x07" "VPSIGNW\0" "\x06" "PSIGND\0" "\x07" "VPSIGND\0" "\x08" "PMULHRSW\0" \
"\x09" "VPMULHRSW\0" "\x09" "VPERMILPS\0" "\x09" "VPERMILPD\0" "\x07" "VTESTPS\0" \
"\x07" "VTESTPD\0" "\x08" "PBLENDVB\0" "\x08" "BLENDVPS\0" "\x08" "BLENDVPD\0" \
"\x05" "PTEST\0" "\x06" "VPTEST\0" "\x0c" "VBROADCASTSS\0" "\x0c" "VBROADCASTSD\0" \
"\x0e" "VBROADCASTF128\0" "\x05" "PABSB\0" "\x06" "VPABSB\0" "\x05" "PABSW\0" \
"\x06" "VPABSW\0" "\x05" "PABSD\0" "\x06" "VPABSD\0" "\x08" "PMOVSXBW\0" "\x09" "VPMOVSXBW\0" \
"\x08" "PMOVSXBD\0" "\x09" "VPMOVSXBD\0" "\x08" "PMOVSXBQ\0" "\x09" "VPMOVSXBQ\0" \
"\x08" "PMOVSXWD\0" "\x09" "VPMOVSXWD\0" "\x08" "PMOVSXWQ\0" "\x09" "VPMOVSXWQ\0" \
"\x08" "PMOVSXDQ\0" "\x09" "VPMOVSXDQ\0" "\x06" "PMULDQ\0" "\x07" "VPMULDQ\0" \
"\x07" "PCMPEQQ\0" "\x08" "VPCMPEQQ\0" "\x08" "MOVNTDQA\0" "\x09" "VMOVNTDQA\0" \
"\x08" "PACKUSDW\0" "\x09" "VPACKUSDW\0" "\x0a" "VMASKMOVPS\0" "\x0a" "VMASKMOVPD\0" \
"\x08" "PMOVZXBW\0" "\x09" "VPMOVZXBW\0" "\x08" "PMOVZXBD\0" "\x09" "VPMOVZXBD\0" \
"\x08" "PMOVZXBQ\0" "\x09" "VPMOVZXBQ\0" "\x08" "PMOVZXWD\0" "\x09" "VPMOVZXWD\0" \
"\x08" "PMOVZXWQ\0" "\x09" "VPMOVZXWQ\0" "\x08" "PMOVZXDQ\0" "\x09" "VPMOVZXDQ\0" \
"\x07" "PCMPGTQ\0" "\x08" "VPCMPGTQ\0" "\x06" "PMINSB\0" "\x07" "VPMINSB\0" \
"\x06" "PMINSD\0" "\x07" "VPMINSD\0" "\x06" "PMINUW\0" "\x07" "VPMINUW\0" "\x06" "PMINUD\0" \
"\x07" "VPMINUD\0" "\x06" "PMAXSB\0" "\x07" "VPMAXSB\0" "\x06" "PMAXSD\0" "\x07" "VPMAXSD\0" \
"\x06" "PMAXUW\0" "\x07" "VPMAXUW\0" "\x06" "PMAXUD\0" "\x07" "VPMAXUD\0" "\x06" "PMULLD\0" \
"\x07" "VPMULLD\0" "\x0a" "PHMINPOSUW\0" "\x0b" "VPHMINPOSUW\0" "\x06" "INVEPT\0" \
"\x07" "INVVPID\0" "\x07" "INVPCID\0" "\x0e" "VFMADDSUB132PS\0" "\x0e" "VFMADDSUB132PD\0" \
"\x0e" "VFMSUBADD132PS\0" "\x0e" "VFMSUBADD132PD\0" "\x0b" "VFMADD132PS\0" \
"\x0b" "VFMADD132PD\0" "\x0b" "VFMADD132SS\0" "\x0b" "VFMADD132SD\0" "\x0b" "VFMSUB132PS\0" \
"\x0b" "VFMSUB132PD\0" "\x0b" "VFMSUB132SS\0" "\x0b" "VFMSUB132SD\0" "\x0c" "VFNMADD132PS\0" \
"\x0c" "VFNMADD132PD\0" "\x0c" "VFNMADD132SS\0" "\x0c" "VFNMADD132SD\0" "\x0c" "VFNMSUB132PS\0" \
"\x0c" "VFNMSUB132PD\0" "\x0c" "VFNMSUB132SS\0" "\x0c" "VFNMSUB132SD\0" "\x0e" "VFMADDSUB213PS\0" \
"\x0e" "VFMADDSUB213PD\0" "\x0e" "VFMSUBADD213PS\0" "\x0e" "VFMSUBADD213PD\0" \
"\x0b" "VFMADD213PS\0" "\x0b" "VFMADD213PD\0" "\x0b" "VFMADD213SS\0" "\x0b" "VFMADD213SD\0" \
"\x0b" "VFMSUB213PS\0" "\x0b" "VFMSUB213PD\0" "\x0b" "VFMSUB213SS\0" "\x0b" "VFMSUB213SD\0" \
"\x0c" "VFNMADD213PS\0" "\x0c" "VFNMADD213PD\0" "\x0c" "VFNMADD213SS\0" "\x0c" "VFNMADD213SD\0" \
"\x0c" "VFNMSUB213PS\0" "\x0c" "VFNMSUB213PD\0" "\x0c" "VFNMSUB213SS\0" "\x0c" "VFNMSUB213SD\0" \
"\x0e" "VFMADDSUB231PS\0" "\x0e" "VFMADDSUB231PD\0" "\x0e" "VFMSUBADD231PS\0" \
"\x0e" "VFMSUBADD231PD\0" "\x0b" "VFMADD231PS\0" "\x0b" "VFMADD231PD\0" "\x0b" "VFMADD231SS\0" \
"\x0b" "VFMADD231SD\0" "\x0b" "VFMSUB231PS\0" "\x0b" "VFMSUB231PD\0" "\x0b" "VFMSUB231SS\0" \
"\x0b" "VFMSUB231SD\0" "\x0c" "VFNMADD231PS\0" "\x0c" "VFNMADD231PD\0" "\x0c" "VFNMADD231SS\0" \
"\x0c" "VFNMADD231SD\0" "\x0c" "VFNMSUB231PS\0" "\x0c" "VFNMSUB231PD\0" "\x0c" "VFNMSUB231SS\0" \
"\x0c" "VFNMSUB231SD\0" "\x06" "AESIMC\0" "\x07" "VAESIMC\0" "\x06" "AESENC\0" \
"\x07" "VAESENC\0" "\x0a" "AESENCLAST\0" "\x0b" "VAESENCLAST\0" "\x06" "AESDEC\0" \
"\x07" "VAESDEC\0" "\x0a" "AESDECLAST\0" "\x0b" "VAESDECLAST\0" "\x05" "MOVBE\0" \
"\x05" "CRC32\0" "\x0a" "VPERM2F128\0" "\x07" "ROUNDPS\0" "\x08" "VROUNDPS\0" \
"\x07" "ROUNDPD\0" "\x08" "VROUNDPD\0" "\x07" "ROUNDSS\0" "\x08" "VROUNDSS\0" \
"\x07" "ROUNDSD\0" "\x08" "VROUNDSD\0" "\x07" "BLENDPS\0" "\x08" "VBLENDPS\0" \
"\x07" "BLENDPD\0" "\x08" "VBLENDPD\0" "\x07" "PBLENDW\0" "\x08" "VPBLENDW\0" \
"\x07" "PALIGNR\0" "\x08" "VPALIGNR\0" "\x06" "PEXTRB\0" "\x07" "VPEXTRB\0" \
"\x06" "PEXTRD\0" "\x06" "PEXTRQ\0" "\x07" "VPEXTRD\0" "\x07" "VPEXTRQ\0" "\x09" "EXTRACTPS\0" \
"\x0a" "VEXTRACTPS\0" "\x0b" "VINSERTF128\0" "\x0c" "VEXTRACTF128\0" "\x06" "PINSRB\0" \
"\x07" "VPINSRB\0" "\x08" "INSERTPS\0" "\x09" "VINSERTPS\0" "\x06" "PINSRD\0" \
"\x06" "PINSRQ\0" "\x07" "VPINSRD\0" "\x07" "VPINSRQ\0" "\x04" "DPPS\0" "\x05" "VDPPS\0" \
"\x04" "DPPD\0" "\x05" "VDPPD\0" "\x07" "MPSADBW\0" "\x08" "VMPSADBW\0" "\x09" "PCLMULQDQ\0" \
"\x0a" "VPCLMULQDQ\0" "\x09" "VBLENDVPS\0" "\x09" "VBLENDVPD\0" "\x09" "VPBLENDVB\0" \
"\x09" "PCMPESTRM\0" "\x0a" "VPCMPESTRM\0" "\x09" "PCMPESTRI\0" "\x0a" "VPCMPESTRI\0" \
"\x09" "PCMPISTRM\0" "\x0a" "VPCMPISTRM\0" "\x09" "PCMPISTRI\0" "\x0a" "VPCMPISTRI\0" \
"\x0f" "AESKEYGENASSIST\0" "\x10" "VAESKEYGENASSIST\0" "\x06" "PSRLDQ\0" "\x07" "VPSRLDQ\0" \
"\x06" "PSLLDQ\0" "\x07" "VPSLLDQ\0" "\x06" "FXSAVE\0" "\x08" "FXSAVE64\0" \
"\x08" "RDFSBASE\0" "\x07" "FXRSTOR\0" "\x09" "FXRSTOR64\0" "\x08" "RDGSBASE\0" \
"\x07" "LDMXCSR\0" "\x08" "WRFSBASE\0" "\x08" "VLDMXCSR\0" "\x07" "STMXCSR\0" \
"\x08" "WRGSBASE\0" "\x08" "VSTMXCSR\0" "\x07" "VMPTRLD\0" "\x07" "VMCLEAR\0" \
"\x05" "VMXON\0" "\x06" "MOVSXD\0" "\x05" "PAUSE\0" "\x04" "WAIT\0" "\x06" "RDRAND\0" \
"\x06" "_3DNOW\0";

const _WRegister _REGISTERS[] = {
	{ 3, "RAX" }, { 3, "RCX" }, { 3, "RDX" }, { 3, "RBX" }, { 3, "RSP" }, { 3, "RBP" }, { 3, "RSI" }, { 3, "RDI" }, { 2, "R8" }, { 2, "R9" }, { 3, "R10" }, { 3, "R11" }, { 3, "R12" }, { 3, "R13" }, { 3, "R14" }, { 3, "R15" },
	{ 3, "EAX" }, { 3, "ECX" }, { 3, "EDX" }, { 3, "EBX" }, { 3, "ESP" }, { 3, "EBP" }, { 3, "ESI" }, { 3, "EDI" }, { 3, "R8D" }, { 3, "R9D" }, { 4, "R10D" }, { 4, "R11D" }, { 4, "R12D" }, { 4, "R13D" }, { 4, "R14D" }, { 4, "R15D" },
	{ 2, "AX" }, { 2, "CX" }, { 2, "DX" }, { 2, "BX" }, { 2, "SP" }, { 2, "BP" }, { 2, "SI" }, { 2, "DI" }, { 3, "R8W" }, { 3, "R9W" }, { 4, "R10W" }, { 4, "R11W" }, { 4, "R12W" }, { 4, "R13W" }, { 4, "R14W" }, { 4, "R15W" },
	{ 2, "AL" }, { 2, "CL" }, { 2, "DL" }, { 2, "BL" }, { 2, "AH" }, { 2, "CH" }, { 2, "DH" }, { 2, "BH" }, { 3, "R8B" }, { 3, "R9B" }, { 4, "R10B" }, { 4, "R11B" }, { 4, "R12B" }, { 4, "R13B" }, { 4, "R14B" }, { 4, "R15B" },
	{ 3, "SPL" }, { 3, "BPL" }, { 3, "SIL" }, { 3, "DIL" },
	{ 2, "ES" }, { 2, "CS" }, { 2, "SS" }, { 2, "DS" }, { 2, "FS" }, { 2, "GS" },
	{ 3, "RIP" },
	{ 3, "ST0" }, { 3, "ST1" }, { 3, "ST2" }, { 3, "ST3" }, { 3, "ST4" }, { 3, "ST5" }, { 3, "ST6" }, { 3, "ST7" },
	{ 3, "MM0" }, { 3, "MM1" }, { 3, "MM2" }, { 3, "MM3" }, { 3, "MM4" }, { 3, "MM5" }, { 3, "MM6" }, { 3, "MM7" },
	{ 4, "XMM0" }, { 4, "XMM1" }, { 4, "XMM2" }, { 4, "XMM3" }, { 4, "XMM4" }, { 4, "XMM5" }, { 4, "XMM6" }, { 4, "XMM7" }, { 4, "XMM8" }, { 4, "XMM9" }, { 5, "XMM10" }, { 5, "XMM11" }, { 5, "XMM12" }, { 5, "XMM13" }, { 5, "XMM14" }, { 5, "XMM15" },
	{ 4, "YMM0" }, { 4, "YMM1" }, { 4, "YMM2" }, { 4, "YMM3" }, { 4, "YMM4" }, { 4, "YMM5" }, { 4, "YMM6" }, { 4, "YMM7" }, { 4, "YMM8" }, { 4, "YMM9" }, { 5, "YMM10" }, { 5, "YMM11" }, { 5, "YMM12" }, { 5, "YMM13" }, { 5, "YMM14" }, { 5, "YMM15" },
	{ 3, "CR0" }, { 0, "" }, { 3, "CR2" }, { 3, "CR3" }, { 3, "CR4" }, { 0, "" }, { 0, "" }, { 0, "" }, { 3, "CR8" },
	{ 3, "DR0" }, { 3, "DR1" }, { 3, "DR2" }, { 3, "DR3" }, { 0, "" }, { 0, "" }, { 3, "DR6" }, { 3, "DR7" }
};

#endif /* DISTORM_LIGHT */



================================================
File: 3rdparty/distorm/mnemonics.h
================================================
/*
mnemonics.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef MNEMONICS_H
#define MNEMONICS_H

#ifdef __cplusplus
 extern "C" {
#endif

#ifndef DISTORM_LIGHT

typedef struct WMnemonic {
	unsigned char length;
	unsigned char p[1]; /* p is a null terminated string, which contains 'length' characters. */
} _WMnemonic;

typedef struct WRegister {
	unsigned int length;
	unsigned char p[6]; /* p is a null terminated string. */
} _WRegister;

extern const unsigned char _MNEMONICS[];
extern const _WRegister _REGISTERS[];

#endif /* DISTORM_LIGHT */

#ifdef __cplusplus
} /* End Of Extern */
#endif

#define GET_REGISTER_NAME(r) (unsigned char*)_REGISTERS[(r)].p
#define GET_MNEMONIC_NAME(m) ((_WMnemonic*)&_MNEMONICS[(m)])->p

 typedef enum {
	 I_UNDEFINED = 0, I_AAA = 66, I_AAD = 389, I_AAM = 384, I_AAS = 76, I_ADC = 31, I_ADD = 11, I_ADDPD = 3132,
	 I_ADDPS = 3125, I_ADDSD = 3146, I_ADDSS = 3139, I_ADDSUBPD = 6416, I_ADDSUBPS = 6426,
	 I_AESDEC = 9231, I_AESDECLAST = 9248, I_AESENC = 9189, I_AESENCLAST = 9206,
	 I_AESIMC = 9172, I_AESKEYGENASSIST = 9817, I_AND = 41, I_ANDNPD = 3043, I_ANDNPS = 3035,
	 I_ANDPD = 3012, I_ANDPS = 3005, I_ARPL = 111, I_BLENDPD = 9394, I_BLENDPS = 9375,
	 I_BLENDVPD = 7641, I_BLENDVPS = 7631, I_BOUND = 104, I_BSF = 4368, I_BSR = 4380,
	 I_BSWAP = 960, I_BT = 872, I_BTC = 934, I_BTR = 912, I_BTS = 887, I_CALL = 456,
	 I_CALL_FAR = 260, I_CBW = 228, I_CDQ = 250, I_CDQE = 239, I_CLC = 492, I_CLD = 512,
	 I_CLFLUSH = 4351, I_CLGI = 1855, I_CLI = 502, I_CLTS = 541, I_CMC = 487, I_CMOVA = 694,
	 I_CMOVAE = 663, I_CMOVB = 656, I_CMOVBE = 686, I_CMOVG = 754, I_CMOVGE = 738,
	 I_CMOVL = 731, I_CMOVLE = 746, I_CMOVNO = 648, I_CMOVNP = 723, I_CMOVNS = 708,
	 I_CMOVNZ = 678, I_CMOVO = 641, I_CMOVP = 716, I_CMOVS = 701, I_CMOVZ = 671,
	 I_CMP = 71, I_CMPEQPD = 4471, I_CMPEQPS = 4392, I_CMPEQSD = 4629, I_CMPEQSS = 4550,
	 I_CMPLEPD = 4489, I_CMPLEPS = 4410, I_CMPLESD = 4647, I_CMPLESS = 4568, I_CMPLTPD = 4480,
	 I_CMPLTPS = 4401, I_CMPLTSD = 4638, I_CMPLTSS = 4559, I_CMPNEQPD = 4510, I_CMPNEQPS = 4431,
	 I_CMPNEQSD = 4668, I_CMPNEQSS = 4589, I_CMPNLEPD = 4530, I_CMPNLEPS = 4451,
	 I_CMPNLESD = 4688, I_CMPNLESS = 4609, I_CMPNLTPD = 4520, I_CMPNLTPS = 4441,
	 I_CMPNLTSD = 4678, I_CMPNLTSS = 4599, I_CMPORDPD = 4540, I_CMPORDPS = 4461,
	 I_CMPORDSD = 4698, I_CMPORDSS = 4619, I_CMPS = 301, I_CMPUNORDPD = 4498, I_CMPUNORDPS = 4419,
	 I_CMPUNORDSD = 4656, I_CMPUNORDSS = 4577, I_CMPXCHG = 898, I_CMPXCHG16B = 6395,
	 I_CMPXCHG8B = 6384, I_COMISD = 2801, I_COMISS = 2793, I_CPUID = 865, I_CQO = 255,
	 I_CRC32 = 9280, I_CVTDQ2PD = 6809, I_CVTDQ2PS = 3329, I_CVTPD2DQ = 6819, I_CVTPD2PI = 2703,
	 I_CVTPD2PS = 3255, I_CVTPH2PS = 4183, I_CVTPI2PD = 2517, I_CVTPI2PS = 2507,
	 I_CVTPS2DQ = 3339, I_CVTPS2PD = 3245, I_CVTPS2PH = 4193, I_CVTPS2PI = 2693,
	 I_CVTSD2SI = 2723, I_CVTSD2SS = 3275, I_CVTSI2SD = 2537, I_CVTSI2SS = 2527,
	 I_CVTSS2SD = 3265, I_CVTSS2SI = 2713, I_CVTTPD2DQ = 6798, I_CVTTPD2PI = 2636,
	 I_CVTTPS2DQ = 3349, I_CVTTPS2PI = 2625, I_CVTTSD2SI = 2658, I_CVTTSS2SI = 2647,
	 I_CWD = 245, I_CWDE = 233, I_DAA = 46, I_DAS = 56, I_DEC = 86, I_DIV = 1646,
	 I_DIVPD = 3521, I_DIVPS = 3514, I_DIVSD = 3535, I_DIVSS = 3528, I_DPPD = 9637,
	 I_DPPS = 9624, I_EMMS = 4122, I_ENTER = 340, I_EXTRACTPS = 9502, I_EXTRQ = 4158,
	 I_F2XM1 = 1192, I_FABS = 1123, I_FADD = 1023, I_FADDP = 1549, I_FBLD = 1601,
	 I_FBSTP = 1607, I_FCHS = 1117, I_FCLEX = 7311, I_FCMOVB = 1376, I_FCMOVBE = 1392,
	 I_FCMOVE = 1384, I_FCMOVNB = 1445, I_FCMOVNBE = 1463, I_FCMOVNE = 1454, I_FCMOVNU = 1473,
	 I_FCMOVU = 1401, I_FCOM = 1035, I_FCOMI = 1512, I_FCOMIP = 1623, I_FCOMP = 1041,
	 I_FCOMPP = 1563, I_FCOS = 1311, I_FDECSTP = 1238, I_FDIV = 1061, I_FDIVP = 1594,
	 I_FDIVR = 1067, I_FDIVRP = 1586, I_FEDISI = 1488, I_FEMMS = 574, I_FENI = 1482,
	 I_FFREE = 1527, I_FIADD = 1317, I_FICOM = 1331, I_FICOMP = 1338, I_FIDIV = 1361,
	 I_FIDIVR = 1368, I_FILD = 1418, I_FIMUL = 1324, I_FINCSTP = 1247, I_FINIT = 7326,
	 I_FIST = 1432, I_FISTP = 1438, I_FISTTP = 1424, I_FISUB = 1346, I_FISUBR = 1353,
	 I_FLD = 1074, I_FLD1 = 1141, I_FLDCW = 1098, I_FLDENV = 1090, I_FLDL2E = 1155,
	 I_FLDL2T = 1147, I_FLDLG2 = 1170, I_FLDLN2 = 1178, I_FLDPI = 1163, I_FLDZ = 1186,
	 I_FMUL = 1029, I_FMULP = 1556, I_FNCLEX = 7303, I_FNINIT = 7318, I_FNOP = 1111,
	 I_FNSAVE = 7333, I_FNSTCW = 7288, I_FNSTENV = 7271, I_FNSTSW = 7348, I_FPATAN = 1213,
	 I_FPREM = 1256, I_FPREM1 = 1230, I_FPTAN = 1206, I_FRNDINT = 1288, I_FRSTOR = 1519,
	 I_FSAVE = 7341, I_FSCALE = 1297, I_FSETPM = 1496, I_FSIN = 1305, I_FSINCOS = 1279,
	 I_FSQRT = 1272, I_FST = 1079, I_FSTCW = 7296, I_FSTENV = 7280, I_FSTP = 1084,
	 I_FSTSW = 7356, I_FSUB = 1048, I_FSUBP = 1579, I_FSUBR = 1054, I_FSUBRP = 1571,
	 I_FTST = 1129, I_FUCOM = 1534, I_FUCOMI = 1504, I_FUCOMIP = 1614, I_FUCOMP = 1541,
	 I_FUCOMPP = 1409, I_FXAM = 1135, I_FXCH = 1105, I_FXRSTOR = 9914, I_FXRSTOR64 = 9923,
	 I_FXSAVE = 9886, I_FXSAVE64 = 9894, I_FXTRACT = 1221, I_FYL2X = 1199, I_FYL2XP1 = 1263,
	 I_GETSEC = 633, I_HADDPD = 4203, I_HADDPS = 4211, I_HLT = 482, I_HSUBPD = 4237,
	 I_HSUBPS = 4245, I_IDIV = 1651, I_IMUL = 117, I_IN = 447, I_INC = 81, I_INS = 123,
	 I_INSERTPS = 9569, I_INSERTQ = 4165, I_INT = 367, I_INT_3 = 360, I_INT1 = 476,
	 I_INTO = 372, I_INVD = 555, I_INVEPT = 8306, I_INVLPG = 1727, I_INVLPGA = 1869,
	 I_INVPCID = 8323, I_INVVPID = 8314, I_IRET = 378, I_JA = 166, I_JAE = 147,
	 I_JB = 143, I_JBE = 161, I_JCXZ = 427, I_JECXZ = 433, I_JG = 202, I_JGE = 192,
	 I_JL = 188, I_JLE = 197, I_JMP = 462, I_JMP_FAR = 467, I_JNO = 138, I_JNP = 183,
	 I_JNS = 174, I_JNZ = 156, I_JO = 134, I_JP = 179, I_JRCXZ = 440, I_JS = 170,
	 I_JZ = 152, I_LAHF = 289, I_LAR = 522, I_LDDQU = 7016, I_LDMXCSR = 9944, I_LDS = 335,
	 I_LEA = 223, I_LEAVE = 347, I_LES = 330, I_LFENCE = 4287, I_LFS = 917, I_LGDT = 1703,
	 I_LGS = 922, I_LIDT = 1709, I_LLDT = 1668, I_LMSW = 1721, I_LODS = 313, I_LOOP = 421,
	 I_LOOPNZ = 406, I_LOOPZ = 414, I_LSL = 527, I_LSS = 907, I_LTR = 1674, I_LZCNT = 4385,
	 I_MASKMOVDQU = 7141, I_MASKMOVQ = 7131, I_MAXPD = 3581, I_MAXPS = 3574, I_MAXSD = 3595,
	 I_MAXSS = 3588, I_MFENCE = 4313, I_MINPD = 3461, I_MINPS = 3454, I_MINSD = 3475,
	 I_MINSS = 3468, I_MONITOR = 1771, I_MOV = 218, I_MOVAPD = 2481, I_MOVAPS = 2473,
	 I_MOVBE = 9273, I_MOVD = 3942, I_MOVDDUP = 2208, I_MOVDQ2Q = 6544, I_MOVDQA = 3968,
	 I_MOVDQU = 3976, I_MOVHLPS = 2173, I_MOVHPD = 2367, I_MOVHPS = 2359, I_MOVLHPS = 2350,
	 I_MOVLPD = 2190, I_MOVLPS = 2182, I_MOVMSKPD = 2837, I_MOVMSKPS = 2827, I_MOVNTDQ = 6871,
	 I_MOVNTDQA = 7917, I_MOVNTI = 952, I_MOVNTPD = 2578, I_MOVNTPS = 2569, I_MOVNTQ = 6863,
	 I_MOVNTSD = 2596, I_MOVNTSS = 2587, I_MOVQ = 3948, I_MOVQ2DQ = 6535, I_MOVS = 295,
	 I_MOVSD = 2132, I_MOVSHDUP = 2375, I_MOVSLDUP = 2198, I_MOVSS = 2125, I_MOVSX = 939,
	 I_MOVSXD = 10027, I_MOVUPD = 2117, I_MOVUPS = 2109, I_MOVZX = 927, I_MPSADBW = 9650,
	 I_MUL = 1641, I_MULPD = 3192, I_MULPS = 3185, I_MULSD = 3206, I_MULSS = 3199,
	 I_MWAIT = 1780, I_NEG = 1636, I_NOP = 581, I_NOT = 1631, I_OR = 27, I_ORPD = 3075,
	 I_ORPS = 3069, I_OUT = 451, I_OUTS = 128, I_PABSB = 7710, I_PABSD = 7740, I_PABSW = 7725,
	 I_PACKSSDW = 3871, I_PACKSSWB = 3703, I_PACKUSDW = 7938, I_PACKUSWB = 3781,
	 I_PADDB = 7226, I_PADDD = 7256, I_PADDQ = 6503, I_PADDSB = 6952, I_PADDSW = 6969,
	 I_PADDUSB = 6642, I_PADDUSW = 6661, I_PADDW = 7241, I_PALIGNR = 9432, I_PAND = 6629,
	 I_PANDN = 6687, I_PAUSE = 10035, I_PAVGB = 6702, I_PAVGUSB = 2100, I_PAVGW = 6747,
	 I_PBLENDVB = 7621, I_PBLENDW = 9413, I_PCLMULQDQ = 9669, I_PCMPEQB = 4065,
	 I_PCMPEQD = 4103, I_PCMPEQQ = 7898, I_PCMPEQW = 4084, I_PCMPESTRI = 9748,
	 I_PCMPESTRM = 9725, I_PCMPGTB = 3724, I_PCMPGTD = 3762, I_PCMPGTQ = 8109,
	 I_PCMPGTW = 3743, I_PCMPISTRI = 9794, I_PCMPISTRM = 9771, I_PEXTRB = 9451,
	 I_PEXTRD = 9468, I_PEXTRQ = 9476, I_PEXTRW = 6333, I_PF2ID = 1936, I_PF2IW = 1929,
	 I_PFACC = 2050, I_PFADD = 1999, I_PFCMPEQ = 2057, I_PFCMPGE = 1960, I_PFCMPGT = 2006,
	 I_PFMAX = 2015, I_PFMIN = 1969, I_PFMUL = 2066, I_PFNACC = 1943, I_PFPNACC = 1951,
	 I_PFRCP = 1976, I_PFRCPIT1 = 2022, I_PFRCPIT2 = 2073, I_PFRSQIT1 = 2032, I_PFRSQRT = 1983,
	 I_PFSUB = 1992, I_PFSUBR = 2042, I_PHADDD = 7397, I_PHADDSW = 7414, I_PHADDW = 7380,
	 I_PHMINPOSUW = 8281, I_PHSUBD = 7473, I_PHSUBSW = 7490, I_PHSUBW = 7456, I_PI2FD = 1922,
	 I_PI2FW = 1915, I_PINSRB = 9552, I_PINSRD = 9590, I_PINSRQ = 9598, I_PINSRW = 6316,
	 I_PMADDUBSW = 7433, I_PMADDWD = 7095, I_PMAXSB = 8196, I_PMAXSD = 8213, I_PMAXSW = 6986,
	 I_PMAXUB = 6670, I_PMAXUD = 8247, I_PMAXUW = 8230, I_PMINSB = 8128, I_PMINSD = 8145,
	 I_PMINSW = 6924, I_PMINUB = 6612, I_PMINUD = 8179, I_PMINUW = 8162, I_PMOVMSKB = 6553,
	 I_PMOVSXBD = 7776, I_PMOVSXBQ = 7797, I_PMOVSXBW = 7755, I_PMOVSXDQ = 7860,
	 I_PMOVSXWD = 7818, I_PMOVSXWQ = 7839, I_PMOVZXBD = 8004, I_PMOVZXBQ = 8025,
	 I_PMOVZXBW = 7983, I_PMOVZXDQ = 8088, I_PMOVZXWD = 8046, I_PMOVZXWQ = 8067,
	 I_PMULDQ = 7881, I_PMULHRSW = 7560, I_PMULHRW = 2083, I_PMULHUW = 6762, I_PMULHW = 6781,
	 I_PMULLD = 8264, I_PMULLW = 6518, I_PMULUDQ = 7076, I_POP = 22, I_POPA = 98,
	 I_POPCNT = 4360, I_POPF = 277, I_POR = 6941, I_PREFETCH = 1894, I_PREFETCHNTA = 2424,
	 I_PREFETCHT0 = 2437, I_PREFETCHT1 = 2449, I_PREFETCHT2 = 2461, I_PREFETCHW = 1904,
	 I_PSADBW = 7114, I_PSHUFB = 7363, I_PSHUFD = 4010, I_PSHUFHW = 4018, I_PSHUFLW = 4027,
	 I_PSHUFW = 4002, I_PSIGNB = 7509, I_PSIGND = 7543, I_PSIGNW = 7526, I_PSLLD = 7046,
	 I_PSLLDQ = 9869, I_PSLLQ = 7061, I_PSLLW = 7031, I_PSRAD = 6732, I_PSRAW = 6717,
	 I_PSRLD = 6473, I_PSRLDQ = 9852, I_PSRLQ = 6488, I_PSRLW = 6458, I_PSUBB = 7166,
	 I_PSUBD = 7196, I_PSUBQ = 7211, I_PSUBSB = 6890, I_PSUBSW = 6907, I_PSUBUSB = 6574,
	 I_PSUBUSW = 6593, I_PSUBW = 7181, I_PSWAPD = 2092, I_PTEST = 7651, I_PUNPCKHBW = 3802,
	 I_PUNPCKHDQ = 3848, I_PUNPCKHQDQ = 3917, I_PUNPCKHWD = 3825, I_PUNPCKLBW = 3634,
	 I_PUNPCKLDQ = 3680, I_PUNPCKLQDQ = 3892, I_PUNPCKLWD = 3657, I_PUSH = 16,
	 I_PUSHA = 91, I_PUSHF = 270, I_PXOR = 7003, I_RCL = 977, I_RCPPS = 2975, I_RCPSS = 2982,
	 I_RCR = 982, I_RDFSBASE = 9904, I_RDGSBASE = 9934, I_RDMSR = 600, I_RDPMC = 607,
	 I_RDRAND = 10048, I_RDTSC = 593, I_RDTSCP = 1886, I_RET = 325, I_RETF = 354,
	 I_ROL = 967, I_ROR = 972, I_ROUNDPD = 9318, I_ROUNDPS = 9299, I_ROUNDSD = 9356,
	 I_ROUNDSS = 9337, I_RSM = 882, I_RSQRTPS = 2937, I_RSQRTSS = 2946, I_SAHF = 283,
	 I_SAL = 997, I_SALC = 394, I_SAR = 1002, I_SBB = 36, I_SCAS = 319, I_SETA = 807,
	 I_SETAE = 780, I_SETB = 774, I_SETBE = 800, I_SETG = 859, I_SETGE = 845, I_SETL = 839,
	 I_SETLE = 852, I_SETNO = 767, I_SETNP = 832, I_SETNS = 819, I_SETNZ = 793,
	 I_SETO = 761, I_SETP = 826, I_SETS = 813, I_SETZ = 787, I_SFENCE = 4343, I_SGDT = 1691,
	 I_SHL = 987, I_SHLD = 876, I_SHR = 992, I_SHRD = 892, I_SHUFPD = 6358, I_SHUFPS = 6350,
	 I_SIDT = 1697, I_SKINIT = 1861, I_SLDT = 1657, I_SMSW = 1715, I_SQRTPD = 2877,
	 I_SQRTPS = 2869, I_SQRTSD = 2893, I_SQRTSS = 2885, I_STC = 497, I_STD = 517,
	 I_STGI = 1849, I_STI = 507, I_STMXCSR = 9973, I_STOS = 307, I_STR = 1663, I_SUB = 51,
	 I_SUBPD = 3401, I_SUBPS = 3394, I_SUBSD = 3415, I_SUBSS = 3408, I_SWAPGS = 1878,
	 I_SYSCALL = 532, I_SYSENTER = 614, I_SYSEXIT = 624, I_SYSRET = 547, I_TEST = 206,
	 I_TZCNT = 4373, I_UCOMISD = 2764, I_UCOMISS = 2755, I_UD2 = 569, I_UNPCKHPD = 2318,
	 I_UNPCKHPS = 2308, I_UNPCKLPD = 2276, I_UNPCKLPS = 2266, I_VADDPD = 3161,
	 I_VADDPS = 3153, I_VADDSD = 3177, I_VADDSS = 3169, I_VADDSUBPD = 6436, I_VADDSUBPS = 6447,
	 I_VAESDEC = 9239, I_VAESDECLAST = 9260, I_VAESENC = 9197, I_VAESENCLAST = 9218,
	 I_VAESIMC = 9180, I_VAESKEYGENASSIST = 9834, I_VANDNPD = 3060, I_VANDNPS = 3051,
	 I_VANDPD = 3027, I_VANDPS = 3019, I_VBLENDPD = 9403, I_VBLENDPS = 9384, I_VBLENDVPD = 9703,
	 I_VBLENDVPS = 9692, I_VBROADCASTF128 = 7694, I_VBROADCASTSD = 7680, I_VBROADCASTSS = 7666,
	 I_VCMPEQPD = 5110, I_VCMPEQPS = 4708, I_VCMPEQSD = 5914, I_VCMPEQSS = 5512,
	 I_VCMPEQ_OSPD = 5291, I_VCMPEQ_OSPS = 4889, I_VCMPEQ_OSSD = 6095, I_VCMPEQ_OSSS = 5693,
	 I_VCMPEQ_UQPD = 5197, I_VCMPEQ_UQPS = 4795, I_VCMPEQ_UQSD = 6001, I_VCMPEQ_UQSS = 5599,
	 I_VCMPEQ_USPD = 5400, I_VCMPEQ_USPS = 4998, I_VCMPEQ_USSD = 6204, I_VCMPEQ_USSS = 5802,
	 I_VCMPFALSEPD = 5232, I_VCMPFALSEPS = 4830, I_VCMPFALSESD = 6036, I_VCMPFALSESS = 5634,
	 I_VCMPFALSE_OSPD = 5441, I_VCMPFALSE_OSPS = 5039, I_VCMPFALSE_OSSD = 6245,
	 I_VCMPFALSE_OSSS = 5843, I_VCMPGEPD = 5259, I_VCMPGEPS = 4857, I_VCMPGESD = 6063,
	 I_VCMPGESS = 5661, I_VCMPGE_OQPD = 5471, I_VCMPGE_OQPS = 5069, I_VCMPGE_OQSD = 6275,
	 I_VCMPGE_OQSS = 5873, I_VCMPGTPD = 5269, I_VCMPGTPS = 4867, I_VCMPGTSD = 6073,
	 I_VCMPGTSS = 5671, I_VCMPGT_OQPD = 5484, I_VCMPGT_OQPS = 5082, I_VCMPGT_OQSD = 6288,
	 I_VCMPGT_OQSS = 5886, I_VCMPLEPD = 5130, I_VCMPLEPS = 4728, I_VCMPLESD = 5934,
	 I_VCMPLESS = 5532, I_VCMPLE_OQPD = 5317, I_VCMPLE_OQPS = 4915, I_VCMPLE_OQSD = 6121,
	 I_VCMPLE_OQSS = 5719, I_VCMPLTPD = 5120, I_VCMPLTPS = 4718, I_VCMPLTSD = 5924,
	 I_VCMPLTSS = 5522, I_VCMPLT_OQPD = 5304, I_VCMPLT_OQPS = 4902, I_VCMPLT_OQSD = 6108,
	 I_VCMPLT_OQSS = 5706, I_VCMPNEQPD = 5153, I_VCMPNEQPS = 4751, I_VCMPNEQSD = 5957,
	 I_VCMPNEQSS = 5555, I_VCMPNEQ_OQPD = 5245, I_VCMPNEQ_OQPS = 4843, I_VCMPNEQ_OQSD = 6049,
	 I_VCMPNEQ_OQSS = 5647, I_VCMPNEQ_OSPD = 5457, I_VCMPNEQ_OSPS = 5055, I_VCMPNEQ_OSSD = 6261,
	 I_VCMPNEQ_OSSS = 5859, I_VCMPNEQ_USPD = 5345, I_VCMPNEQ_USPS = 4943, I_VCMPNEQ_USSD = 6149,
	 I_VCMPNEQ_USSS = 5747, I_VCMPNGEPD = 5210, I_VCMPNGEPS = 4808, I_VCMPNGESD = 6014,
	 I_VCMPNGESS = 5612, I_VCMPNGE_UQPD = 5413, I_VCMPNGE_UQPS = 5011, I_VCMPNGE_UQSD = 6217,
	 I_VCMPNGE_UQSS = 5815, I_VCMPNGTPD = 5221, I_VCMPNGTPS = 4819, I_VCMPNGTSD = 6025,
	 I_VCMPNGTSS = 5623, I_VCMPNGT_UQPD = 5427, I_VCMPNGT_UQPS = 5025, I_VCMPNGT_UQSD = 6231,
	 I_VCMPNGT_UQSS = 5829, I_VCMPNLEPD = 5175, I_VCMPNLEPS = 4773, I_VCMPNLESD = 5979,
	 I_VCMPNLESS = 5577, I_VCMPNLE_UQPD = 5373, I_VCMPNLE_UQPS = 4971, I_VCMPNLE_UQSD = 6177,
	 I_VCMPNLE_UQSS = 5775, I_VCMPNLTPD = 5164, I_VCMPNLTPS = 4762, I_VCMPNLTSD = 5968,
	 I_VCMPNLTSS = 5566, I_VCMPNLT_UQPD = 5359, I_VCMPNLT_UQPS = 4957, I_VCMPNLT_UQSD = 6163,
	 I_VCMPNLT_UQSS = 5761, I_VCMPORDPD = 5186, I_VCMPORDPS = 4784, I_VCMPORDSD = 5990,
	 I_VCMPORDSS = 5588, I_VCMPORD_SPD = 5387, I_VCMPORD_SPS = 4985, I_VCMPORD_SSD = 6191,
	 I_VCMPORD_SSS = 5789, I_VCMPTRUEPD = 5279, I_VCMPTRUEPS = 4877, I_VCMPTRUESD = 6083,
	 I_VCMPTRUESS = 5681, I_VCMPTRUE_USPD = 5497, I_VCMPTRUE_USPS = 5095, I_VCMPTRUE_USSD = 6301,
	 I_VCMPTRUE_USSS = 5899, I_VCMPUNORDPD = 5140, I_VCMPUNORDPS = 4738, I_VCMPUNORDSD = 5944,
	 I_VCMPUNORDSS = 5542, I_VCMPUNORD_SPD = 5330, I_VCMPUNORD_SPS = 4928, I_VCMPUNORD_SSD = 6134,
	 I_VCMPUNORD_SSS = 5732, I_VCOMISD = 2818, I_VCOMISS = 2809, I_VCVTDQ2PD = 6841,
	 I_VCVTDQ2PS = 3360, I_VCVTPD2DQ = 6852, I_VCVTPD2PS = 3296, I_VCVTPS2DQ = 3371,
	 I_VCVTPS2PD = 3285, I_VCVTSD2SI = 2744, I_VCVTSD2SS = 3318, I_VCVTSI2SD = 2558,
	 I_VCVTSI2SS = 2547, I_VCVTSS2SD = 3307, I_VCVTSS2SI = 2733, I_VCVTTPD2DQ = 6829,
	 I_VCVTTPS2DQ = 3382, I_VCVTTSD2SI = 2681, I_VCVTTSS2SI = 2669, I_VDIVPD = 3550,
	 I_VDIVPS = 3542, I_VDIVSD = 3566, I_VDIVSS = 3558, I_VDPPD = 9643, I_VDPPS = 9630,
	 I_VERR = 1679, I_VERW = 1685, I_VEXTRACTF128 = 9538, I_VEXTRACTPS = 9513,
	 I_VFMADD132PD = 8409, I_VFMADD132PS = 8396, I_VFMADD132SD = 8435, I_VFMADD132SS = 8422,
	 I_VFMADD213PD = 8689, I_VFMADD213PS = 8676, I_VFMADD213SD = 8715, I_VFMADD213SS = 8702,
	 I_VFMADD231PD = 8969, I_VFMADD231PS = 8956, I_VFMADD231SD = 8995, I_VFMADD231SS = 8982,
	 I_VFMADDSUB132PD = 8348, I_VFMADDSUB132PS = 8332, I_VFMADDSUB213PD = 8628,
	 I_VFMADDSUB213PS = 8612, I_VFMADDSUB231PD = 8908, I_VFMADDSUB231PS = 8892,
	 I_VFMSUB132PD = 8461, I_VFMSUB132PS = 8448, I_VFMSUB132SD = 8487, I_VFMSUB132SS = 8474,
	 I_VFMSUB213PD = 8741, I_VFMSUB213PS = 8728, I_VFMSUB213SD = 8767, I_VFMSUB213SS = 8754,
	 I_VFMSUB231PD = 9021, I_VFMSUB231PS = 9008, I_VFMSUB231SD = 9047, I_VFMSUB231SS = 9034,
	 I_VFMSUBADD132PD = 8380, I_VFMSUBADD132PS = 8364, I_VFMSUBADD213PD = 8660,
	 I_VFMSUBADD213PS = 8644, I_VFMSUBADD231PD = 8940, I_VFMSUBADD231PS = 8924,
	 I_VFNMADD132PD = 8514, I_VFNMADD132PS = 8500, I_VFNMADD132SD = 8542, I_VFNMADD132SS = 8528,
	 I_VFNMADD213PD = 8794, I_VFNMADD213PS = 8780, I_VFNMADD213SD = 8822, I_VFNMADD213SS = 8808,
	 I_VFNMADD231PD = 9074, I_VFNMADD231PS = 9060, I_VFNMADD231SD = 9102, I_VFNMADD231SS = 9088,
	 I_VFNMSUB132PD = 8570, I_VFNMSUB132PS = 8556, I_VFNMSUB132SD = 8598, I_VFNMSUB132SS = 8584,
	 I_VFNMSUB213PD = 8850, I_VFNMSUB213PS = 8836, I_VFNMSUB213SD = 8878, I_VFNMSUB213SS = 8864,
	 I_VFNMSUB231PD = 9130, I_VFNMSUB231PS = 9116, I_VFNMSUB231SD = 9158, I_VFNMSUB231SS = 9144,
	 I_VHADDPD = 4219, I_VHADDPS = 4228, I_VHSUBPD = 4253, I_VHSUBPS = 4262, I_VINSERTF128 = 9525,
	 I_VINSERTPS = 9579, I_VLDDQU = 7023, I_VLDMXCSR = 9963, I_VMASKMOVDQU = 7153,
	 I_VMASKMOVPD = 7971, I_VMASKMOVPS = 7959, I_VMAXPD = 3610, I_VMAXPS = 3602,
	 I_VMAXSD = 3626, I_VMAXSS = 3618, I_VMCALL = 1735, I_VMCLEAR = 10011, I_VMFUNC = 1803,
	 I_VMINPD = 3490, I_VMINPS = 3482, I_VMINSD = 3506, I_VMINSS = 3498, I_VMLAUNCH = 1743,
	 I_VMLOAD = 1833, I_VMMCALL = 1824, I_VMOVAPD = 2498, I_VMOVAPS = 2489, I_VMOVD = 3954,
	 I_VMOVDDUP = 2256, I_VMOVDQA = 3984, I_VMOVDQU = 3993, I_VMOVHLPS = 2217,
	 I_VMOVHPD = 2404, I_VMOVHPS = 2395, I_VMOVLHPS = 2385, I_VMOVLPD = 2236, I_VMOVLPS = 2227,
	 I_VMOVMSKPD = 2858, I_VMOVMSKPS = 2847, I_VMOVNTDQ = 6880, I_VMOVNTDQA = 7927,
	 I_VMOVNTPD = 2615, I_VMOVNTPS = 2605, I_VMOVQ = 3961, I_VMOVSD = 2165, I_VMOVSHDUP = 2413,
	 I_VMOVSLDUP = 2245, I_VMOVSS = 2157, I_VMOVUPD = 2148, I_VMOVUPS = 2139, I_VMPSADBW = 9659,
	 I_VMPTRLD = 10002, I_VMPTRST = 6407, I_VMREAD = 4150, I_VMRESUME = 1753, I_VMRUN = 1817,
	 I_VMSAVE = 1841, I_VMULPD = 3221, I_VMULPS = 3213, I_VMULSD = 3237, I_VMULSS = 3229,
	 I_VMWRITE = 4174, I_VMXOFF = 1763, I_VMXON = 10020, I_VORPD = 3088, I_VORPS = 3081,
	 I_VPABSB = 7717, I_VPABSD = 7747, I_VPABSW = 7732, I_VPACKSSDW = 3881, I_VPACKSSWB = 3713,
	 I_VPACKUSDW = 7948, I_VPACKUSWB = 3791, I_VPADDB = 7233, I_VPADDD = 7263,
	 I_VPADDQ = 6510, I_VPADDSB = 6960, I_VPADDSW = 6977, I_VPADDUSW = 6651, I_VPADDW = 7248,
	 I_VPALIGNR = 9441, I_VPAND = 6635, I_VPANDN = 6694, I_VPAVGB = 6709, I_VPAVGW = 6754,
	 I_VPBLENDVB = 9714, I_VPBLENDW = 9422, I_VPCLMULQDQ = 9680, I_VPCMPEQB = 4074,
	 I_VPCMPEQD = 4112, I_VPCMPEQQ = 7907, I_VPCMPEQW = 4093, I_VPCMPESTRI = 9759,
	 I_VPCMPESTRM = 9736, I_VPCMPGTB = 3733, I_VPCMPGTD = 3771, I_VPCMPGTQ = 8118,
	 I_VPCMPGTW = 3752, I_VPCMPISTRI = 9805, I_VPCMPISTRM = 9782, I_VPERM2F128 = 9287,
	 I_VPERMILPD = 7592, I_VPERMILPS = 7581, I_VPEXTRB = 9459, I_VPEXTRD = 9484,
	 I_VPEXTRQ = 9493, I_VPEXTRW = 6341, I_VPHADDD = 7405, I_VPHADDSW = 7423, I_VPHADDW = 7388,
	 I_VPHMINPOSUW = 8293, I_VPHSUBD = 7481, I_VPHSUBSW = 7499, I_VPHSUBW = 7464,
	 I_VPINSRB = 9560, I_VPINSRD = 9606, I_VPINSRQ = 9615, I_VPINSRW = 6324, I_VPMADDUBSW = 7444,
	 I_VPMADDWD = 7104, I_VPMAXSB = 8204, I_VPMAXSD = 8221, I_VPMAXSW = 6994, I_VPMAXUB = 6678,
	 I_VPMAXUD = 8255, I_VPMAXUW = 8238, I_VPMINSB = 8136, I_VPMINSD = 8153, I_VPMINSW = 6932,
	 I_VPMINUB = 6620, I_VPMINUD = 8187, I_VPMINUW = 8170, I_VPMOVMSKB = 6563,
	 I_VPMOVSXBD = 7786, I_VPMOVSXBQ = 7807, I_VPMOVSXBW = 7765, I_VPMOVSXDQ = 7870,
	 I_VPMOVSXWD = 7828, I_VPMOVSXWQ = 7849, I_VPMOVZXBD = 8014, I_VPMOVZXBQ = 8035,
	 I_VPMOVZXBW = 7993, I_VPMOVZXDQ = 8098, I_VPMOVZXWD = 8056, I_VPMOVZXWQ = 8077,
	 I_VPMULDQ = 7889, I_VPMULHRSW = 7570, I_VPMULHUW = 6771, I_VPMULHW = 6789,
	 I_VPMULLD = 8272, I_VPMULLW = 6526, I_VPMULUDQ = 7085, I_VPOR = 6946, I_VPSADBW = 7122,
	 I_VPSHUFB = 7371, I_VPSHUFD = 4036, I_VPSHUFHW = 4045, I_VPSHUFLW = 4055,
	 I_VPSIGNB = 7517, I_VPSIGND = 7551, I_VPSIGNW = 7534, I_VPSLLD = 7053, I_VPSLLDQ = 9877,
	 I_VPSLLQ = 7068, I_VPSLLW = 7038, I_VPSRAD = 6739, I_VPSRAW = 6724, I_VPSRLD = 6480,
	 I_VPSRLDQ = 9860, I_VPSRLQ = 6495, I_VPSRLW = 6465, I_VPSUBB = 7173, I_VPSUBD = 7203,
	 I_VPSUBQ = 7218, I_VPSUBSB = 6898, I_VPSUBSW = 6915, I_VPSUBUSB = 6583, I_VPSUBUSW = 6602,
	 I_VPSUBW = 7188, I_VPTEST = 7658, I_VPUNPCKHBW = 3813, I_VPUNPCKHDQ = 3859,
	 I_VPUNPCKHQDQ = 3929, I_VPUNPCKHWD = 3836, I_VPUNPCKLBW = 3645, I_VPUNPCKLDQ = 3691,
	 I_VPUNPCKLQDQ = 3904, I_VPUNPCKLWD = 3668, I_VPXOR = 7009, I_VRCPPS = 2989,
	 I_VRCPSS = 2997, I_VROUNDPD = 9327, I_VROUNDPS = 9308, I_VROUNDSD = 9365,
	 I_VROUNDSS = 9346, I_VRSQRTPS = 2955, I_VRSQRTSS = 2965, I_VSHUFPD = 6375,
	 I_VSHUFPS = 6366, I_VSQRTPD = 2910, I_VSQRTPS = 2901, I_VSQRTSD = 2928, I_VSQRTSS = 2919,
	 I_VSTMXCSR = 9992, I_VSUBPD = 3430, I_VSUBPS = 3422, I_VSUBSD = 3446, I_VSUBSS = 3438,
	 I_VTESTPD = 7612, I_VTESTPS = 7603, I_VUCOMISD = 2783, I_VUCOMISS = 2773,
	 I_VUNPCKHPD = 2339, I_VUNPCKHPS = 2328, I_VUNPCKLPD = 2297, I_VUNPCKLPS = 2286,
	 I_VXORPD = 3117, I_VXORPS = 3109, I_VZEROALL = 4140, I_VZEROUPPER = 4128,
	 I_WAIT = 10042, I_WBINVD = 561, I_WRFSBASE = 9953, I_WRGSBASE = 9982, I_WRMSR = 586,
	 I_XABORT = 1007, I_XADD = 946, I_XBEGIN = 1015, I_XCHG = 212, I_XEND = 1811,
	 I_XGETBV = 1787, I_XLAT = 400, I_XOR = 61, I_XORPD = 3102, I_XORPS = 3095,
	 I_XRSTOR = 4295, I_XRSTOR64 = 4303, I_XSAVE = 4271, I_XSAVE64 = 4278, I_XSAVEOPT = 4321,
	 I_XSAVEOPT64 = 4331, I_XSETBV = 1795, I__3DNOW = 10056
 } _InstructionType;

typedef enum {
	R_RAX, R_RCX, R_RDX, R_RBX, R_RSP, R_RBP, R_RSI, R_RDI, R_R8, R_R9, R_R10, R_R11, R_R12, R_R13, R_R14, R_R15,
	R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI, R_R8D, R_R9D, R_R10D, R_R11D, R_R12D, R_R13D, R_R14D, R_R15D,
	R_AX, R_CX, R_DX, R_BX, R_SP, R_BP, R_SI, R_DI, R_R8W, R_R9W, R_R10W, R_R11W, R_R12W, R_R13W, R_R14W, R_R15W,
	R_AL, R_CL, R_DL, R_BL, R_AH, R_CH, R_DH, R_BH, R_R8B, R_R9B, R_R10B, R_R11B, R_R12B, R_R13B, R_R14B, R_R15B,
	R_SPL, R_BPL, R_SIL, R_DIL,
	R_ES, R_CS, R_SS, R_DS, R_FS, R_GS,
	R_RIP,
	R_ST0, R_ST1, R_ST2, R_ST3, R_ST4, R_ST5, R_ST6, R_ST7,
	R_MM0, R_MM1, R_MM2, R_MM3, R_MM4, R_MM5, R_MM6, R_MM7,
	R_XMM0, R_XMM1, R_XMM2, R_XMM3, R_XMM4, R_XMM5, R_XMM6, R_XMM7, R_XMM8, R_XMM9, R_XMM10, R_XMM11, R_XMM12, R_XMM13, R_XMM14, R_XMM15,
	R_YMM0, R_YMM1, R_YMM2, R_YMM3, R_YMM4, R_YMM5, R_YMM6, R_YMM7, R_YMM8, R_YMM9, R_YMM10, R_YMM11, R_YMM12, R_YMM13, R_YMM14, R_YMM15,
	R_CR0, R_UNUSED0, R_CR2, R_CR3, R_CR4, R_UNUSED1, R_UNUSED2, R_UNUSED3, R_CR8,
	R_DR0, R_DR1, R_DR2, R_DR3, R_UNUSED4, R_UNUSED5, R_DR6, R_DR7
} _RegisterType;

#endif /* MNEMONICS_H */



================================================
File: 3rdparty/distorm/operands.c
================================================
/*
operands.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "config.h"
#include "operands.h"
#include "x86defs.h"
#include "insts.h"
#include "mnemonics.h"


/* Maps a register to its register-class mask. */
uint32_t _REGISTERTORCLASS[] = /* Based on _RegisterType enumeration! */
{RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_SP, RM_BP, RM_SI, RM_DI, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_AX, RM_CX, RM_DX, RM_BX, RM_AX, RM_CX, RM_DX, RM_BX, RM_R8, RM_R9, RM_R10, RM_R11, RM_R12, RM_R13, RM_R14, RM_R15,
 RM_SP, RM_BP, RM_SI, RM_DI,
 0, 0, 0, 0, 0, 0,
 0,
 RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU, RM_FPU,
 RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX, RM_MMX,
 RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE, RM_SSE,
 RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX, RM_AVX,
 RM_CR, 0, RM_CR, RM_CR, RM_CR, 0, 0, 0, RM_CR,
 RM_DR, RM_DR, RM_DR, RM_DR, 0, 0, RM_DR, RM_DR
};

typedef enum {OPERAND_SIZE_NONE = 0, OPERAND_SIZE8, OPERAND_SIZE16, OPERAND_SIZE32, OPERAND_SIZE64, OPERAND_SIZE80, OPERAND_SIZE128, OPERAND_SIZE256} _OperandSizeType;
static uint16_t _OPSIZETOINT[] = {0, 8, 16, 32, 64, 80, 128, 256};

/* A helper function to fix the 8 bits register if REX is used (to support SIL, DIL, etc). */
static unsigned int _FASTCALL_ operands_fix_8bit_rex_base(unsigned int reg)
{
	if ((reg >= 4) && (reg < 8)) return reg + REGS8_REX_BASE - 4;
	return reg + REGS8_BASE;
}

/* A helper function to set operand's type and size. */
static void _FASTCALL_ operands_set_ts(_Operand* op, _OperandType type, uint16_t size)
{
	op->type = type;
	op->size = size;
}

/* A helper function to set operand's type, size and index. */
static void _FASTCALL_ operands_set_tsi(_Operand* op, _OperandType type, uint16_t size, unsigned int index)
{
	op->type = type;
	op->index = (uint8_t)index;
	op->size = size;
}

/* A helper function to read an unsigned integer from the stream safely. */
static int _FASTCALL_ read_stream_safe_uint(_CodeInfo* ci, void* result, unsigned int size)
{
	ci->codeLen -= size;
	if (ci->codeLen < 0) return FALSE;
	switch (size)
	{
		case 1: *(uint8_t*)result = *(uint8_t*)ci->code; break;
		case 2: *(uint16_t*)result = RUSHORT(ci->code); break;
		case 4: *(uint32_t*)result = RULONG(ci->code); break;
		case 8: *(uint64_t*)result = RULLONG(ci->code); break;
	}
	ci->code += size;
	return TRUE;
}

/* A helper function to read a signed integer from the stream safely. */
static int _FASTCALL_ read_stream_safe_sint(_CodeInfo* ci, int64_t* result, unsigned int size)
{
	ci->codeLen -= size;
	if (ci->codeLen < 0) return FALSE;
	switch (size)
	{
		case 1: *result = *(int8_t*)ci->code; break;
		case 2: *result = RSHORT(ci->code); break;
		case 4: *result = RLONG(ci->code); break;
		case 8: *result = RLLONG(ci->code); break;
	}
	ci->code += size;
	return TRUE;
}

/*
 * SIB decoding is the most confusing part when decoding IA-32 instructions.
 * This explanation should clear up some stuff.
 *
 * ! When base == 5, use EBP as the base register !
 * if (rm == 4) {
 *	if mod == 01, decode SIB byte and ALSO read a 8 bits displacement.
 *	if mod == 10, decode SIB byte and ALSO read a 32 bits displacement.
 *	if mod == 11 <-- EXCEPTION, this is a general-purpose register and mustn't lead to SIB decoding!
 *	; So far so good, now the confusing part comes in with mod == 0 and base=5, but no worry.
 *	if (mod == 00) {
 *	 decode SIB byte WITHOUT any displacement.
 *	 EXCEPTION!!! when base == 5, read a 32 bits displacement, but this time DO NOT use (EBP) BASE at all!
 *	}
 *
 *	NOTE: base could specify None (no base register) if base==5 and mod==0, but then you also need DISP32.
 * }
 */
static void operands_extract_sib(_DInst* di, _OperandNumberType opNum,
                                 _PrefixState* ps, _DecodeType effAdrSz,
                                 unsigned int sib, unsigned int mod)
{
	unsigned int scale = 0, index = 0, base = 0;
	unsigned int vrex = ps->vrex;
	uint8_t* pIndex = NULL;

	_Operand* op = &di->ops[opNum];

	/*
	 * SIB bits:
	 * |7---6-5----3-2---0|
	 * |SCALE| INDEX| BASE|
	 * |------------------|
	 */
	scale = (sib >> 6) & 3;
	index = (sib >> 3) & 7;
	base = sib & 7;

	/*
	 * The following fields: base/index/scale/disp8/32 are ALL optional by specific rules!
	 * The idea here is to keep the indirection as a simple-memory type.
	 * Because the base is optional, and we might be left with only one index.
	 * So even if there's a base but no index, or vice versa, we end up with one index register.
	 */

	/* In 64 bits the REX prefix might affect the index of the SIB byte. */
	if (vrex & PREFIX_EX_X) {
		ps->usedPrefixes |= INST_PRE_REX;
		index += EX_GPR_BASE;
	}

	if (index == 4) { /* No index is used. Use SMEM. */
		op->type = O_SMEM;
		pIndex = &op->index;
	} else {
		op->type = O_MEM;
		pIndex = &di->base;
		/* No base, unless it is updated below. E.G: [EAX*4] has no base reg. */
	}

	if (base != 5) {
		if (vrex & PREFIX_EX_B) ps->usedPrefixes |= INST_PRE_REX;
		*pIndex = effAdrSz == Decode64Bits ? REGS64_BASE : REGS32_BASE;
		*pIndex += (uint8_t)(base + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0));
	} else if (mod != 0) {
		/*
		 * if base == 5 then you have to decode according to MOD.
		 * mod(00) - disp32.
		 * mod(01) - disp8 + rBP
		 * mod(10) - disp32 + rBP
		 * mod(11) - not possible, it's a general-purpose register.
		 */

		if (vrex & PREFIX_EX_B) ps->usedPrefixes |= INST_PRE_REX;
		if (effAdrSz == Decode64Bits) *pIndex = REGS64_BASE + 5 + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0);
		else *pIndex = REGS32_BASE + 5 + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0);
	} else if (index == 4) {
		 /* 32bits displacement only. */
		op->type = O_DISP;
		return;
	}

	if (index != 4) { /* In 64 bits decoding mode, if index == R12, it's valid! */
		if (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + index);
		else op->index = (uint8_t)(REGS32_BASE + index);
		di->scale = scale != 0 ? (1 << scale) : 0;
	}
}

/*
 * This seems to be the hardest part in decoding the operands.
 * If you take a look carefully at Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte,
 * you will understand it's easy to decode the operands.

 * First we check the DT, so we can decide according to which Table in the documentation we are supposed to decode.
 * Then we follow the specific table whether it's 16 bits or 32/64 bits.

 * Don't forget that Operand Size AND Address Size prefixes may change the decoding!

 * Some instructions force the use of RM16 or other specific types, so take it into account.
 */
static int operands_extract_modrm(_CodeInfo* ci,
                                  _DInst* di, _OpType type,
                                  _OperandNumberType opNum, _PrefixState* ps,
                                  _DecodeType effOpSz, _DecodeType effAdrSz,
                                  int* lockableInstruction, unsigned int mod, unsigned int rm,
                                  _iflags instFlags)
{
	unsigned int vrex = ps->vrex, sib = 0, base = 0;
	_Operand* op = &di->ops[opNum];
	uint16_t size = 0;

	if (mod == 3) {
		/*
		 * General-purpose register is handled the same way in 16/32/64 bits decoding modes.
		 * NOTE!! that we have to override the size of the register, since it was set earlier as Memory and not Register!
		 */
		op->type = O_REG;
		/* Start with original size which was set earlier, some registers have same size of memory and depend on it. */
		size = op->size;
		switch(type)
		{
			case OT_RFULL_M16:
			case OT_RM_FULL:
				switch (effOpSz)
				{
					case Decode16Bits:
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						if (vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							rm += EX_GPR_BASE;
						}
						size = 16;
						rm += REGS16_BASE;
					break;
					case Decode32Bits:
						ps->usedPrefixes |= INST_PRE_OP_SIZE;
						if (vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							rm += EX_GPR_BASE;
						}
						size = 32;
						rm += REGS32_BASE;
					break;
					case Decode64Bits:
						/* A fix for SMSW RAX which use the REX prefix. */
						if (type == OT_RFULL_M16) ps->usedPrefixes |= INST_PRE_REX;
						/* CALL NEAR/PUSH/POP defaults to 64 bits. --> INST_64BITS, REX isn't required, thus ignored anyways. */
						if (instFlags & INST_PRE_REX) ps->usedPrefixes |= INST_PRE_REX;
						/* Include REX if used for REX.B. */
						if (vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							rm += EX_GPR_BASE;
						}
						size = 64;
						rm += REGS64_BASE;
					break;
				}
			break;
			case OT_R32_64_M8:
			/* FALL THROUGH, decode 32 or 64 bits register. */
			case OT_R32_64_M16:
			/* FALL THROUGH, decode 32 or 64 bits register. */
			case OT_RM32_64: /* Take care specifically in MOVNTI/MOVD/CVT's instructions, making it _REG64 with REX or if they are promoted. */
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				/* Is it a promoted instruction? (only INST_64BITS is set and REX isn't required.) */
				if ((ci->dt == Decode64Bits) && ((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS)) {
					size = 64;
					rm += REGS64_BASE;
					break;
				}
				/* Give a chance to REX.W. Because if it was a promoted instruction we don't care about REX.W anyways. */
				if (vrex & PREFIX_EX_W) {
					ps->usedPrefixes |= INST_PRE_REX;
					size = 64;
					rm += REGS64_BASE;
				} else {
					size = 32;
					rm += REGS32_BASE;
				}
			break;
			case OT_RM16_32: /* Used only with MOVZXD instruction to support 16 bits operand. */
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				/* Is it 16 bits operand size? */
				if (ps->decodedPrefixes & INST_PRE_OP_SIZE) {
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					size = 16;
					rm += REGS16_BASE;
				} else {
					size = 32;
					rm += REGS32_BASE;
				}
			break;
			case OT_RM16:
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				rm += REGS16_BASE;
			break;
			case OT_RM8:
				if (ps->prefixExtType == PET_REX) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm = operands_fix_8bit_rex_base(rm + ((vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0));
				} else rm += REGS8_BASE;
			break;
			case OT_MM32:
			case OT_MM64:
				/* MMX doesn't support extended registers. */
				size = 64;
				rm += MMXREGS_BASE;
			break;

			case OT_XMM16:
			case OT_XMM32:
			case OT_XMM64:
			case OT_XMM128:
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				size = 128;
				rm += SSEREGS_BASE;
			break;

			case OT_RM32:
			case OT_R32_M8:
			case OT_R32_M16:
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}
				size = 32;
				rm += REGS32_BASE;
			break;

			case OT_YMM256:
				if (vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				rm += AVXREGS_BASE;
			break;
			case OT_YXMM64_256:
			case OT_YXMM128_256:
				if (vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				if (vrex & PREFIX_EX_L) {
					size = 256;
					rm += AVXREGS_BASE;
				} else {
					size = 128;
					rm += SSEREGS_BASE;
				}
			break;
			case OT_WXMM32_64:
			case OT_LXMM64_128:
				if (vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				size = 128;
				rm += SSEREGS_BASE;
			break;

			case OT_WRM32_64:
			case OT_REG32_64_M8:
			case OT_REG32_64_M16:
				if (vrex & PREFIX_EX_B) rm += EX_GPR_BASE;
				if (vrex & PREFIX_EX_W) {
					size = 64;
					rm += REGS64_BASE;
				} else {
					size = 32;
					rm += REGS32_BASE;
				}
			break;

			default: return FALSE;
		}
		op->size = size;
		op->index = (uint8_t)rm;
		return TRUE;
	}

	/* Memory indirection decoding ahead:) */

	ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
	if (lockableInstruction && (ps->decodedPrefixes & INST_PRE_LOCK)) *lockableInstruction = TRUE;

	if (effAdrSz == Decode16Bits) {
		/* Decoding according to Table 2-1. (16 bits) */
		if ((mod == 0) && (rm == 6)) {
			/* 6 is a special case - only 16 bits displacement. */
			op->type = O_DISP;
			di->dispSize = 16;
			if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int16_t))) return FALSE;
		} else {
			/*
			 * Create the O_MEM for 16 bits indirection that requires 2 registers, E.G: [BS+SI].
			 * or create O_SMEM for a single register indirection, E.G: [BP].
			 */
			static uint8_t MODS[] = {R_BX, R_BX, R_BP, R_BP, R_SI, R_DI, R_BP, R_BX};
			static uint8_t MODS2[] = {R_SI, R_DI, R_SI, R_DI};
			if (rm < 4) {
				op->type = O_MEM;
				di->base = MODS[rm];
				op->index = MODS2[rm];
			} else {
				op->type = O_SMEM;
				op->index = MODS[rm];
			}

			if (mod == 1) { /* 8 bits displacement + indirection */
				di->dispSize = 8;
				if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int8_t))) return FALSE;
			} else if (mod == 2) { /* 16 bits displacement + indirection */
				di->dispSize = 16;
				if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int16_t))) return FALSE;
			}
		}

		if ((rm == 2) || (rm == 3) || ((rm == 6) && (mod != 0))) {
			/* BP's default segment is SS, so ignore it. */
			prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);
		} else {
			/* Ignore default DS segment. */
			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
		}
	} else { /* Decode32Bits or Decode64Bits! */
		/* Remember that from a 32/64 bits ModR/M byte a SIB byte could follow! */
		if ((mod == 0) && (rm == 5)) {

			/* 5 is a special case - only 32 bits displacement, or RIP relative. */
			di->dispSize = 32;
			if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int32_t))) return FALSE;

			if (ci->dt == Decode64Bits) {
				/* In 64 bits decoding mode depsite of the address size, a RIP-relative address it is. */
				op->type = O_SMEM;
				op->index = R_RIP;
				di->flags |= FLAG_RIP_RELATIVE;
			} else {
				/* Absolute address: */
				op->type = O_DISP;
			}
		} else {
			if (rm == 4) {
				/* 4 is a special case - SIB byte + disp8/32 follows! */
				/* Read SIB byte. */
				if (!read_stream_safe_uint(ci, &sib, sizeof(int8_t))) return FALSE;
				operands_extract_sib(di, opNum, ps, effAdrSz, sib, mod);
			} else {
				op->type = O_SMEM;
				if (vrex & PREFIX_EX_B) {
					ps->usedPrefixes |= INST_PRE_REX;
					rm += EX_GPR_BASE;
				}

				if (effAdrSz == Decode64Bits) op->index = (uint8_t)(REGS64_BASE + rm);
				else op->index = (uint8_t)(REGS32_BASE + rm);
			}

			if (mod == 1) {
				di->dispSize = 8;
				if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int8_t))) return FALSE;
			} else if ((mod == 2) || ((sib & 7) == 5)) { /* If there is no BASE, read DISP32! */
				di->dispSize = 32;
				if (!read_stream_safe_sint(ci, (int64_t*)&di->disp, sizeof(int32_t))) return FALSE;
			}
		}

		/* Get the base register. */
		base = op->index;
		if (di->base != R_NONE) base = di->base;
		else if (di->scale >= 2) base = 0; /* If it's only an index but got scale, it's still DS. */
		/* Default for EBP/ESP is SS segment. 64 bits mode ignores DS anyway. */
		if ((base == R_EBP) || (base == R_ESP)) prefixes_use_segment(INST_PRE_SS, ps, ci->dt, di);
		else prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);
	}

	return TRUE;
}


/*
 * This function is reponsible to textually format a required operand according to its type.
 * It is vital to understand that there are other operands than what the ModR/M byte specifies.

 * Only by decoding the operands of an instruction which got a LOCK prefix, we could tell whether it may use the LOCK prefix.
 * According to Intel, LOCK prefix must precede some specific instructions AND in their memory destination operand form (which means first operand).
 * LOCK INC EAX, would generate an exception, but LOCK INC [EAX] is alright.
 * Also LOCK ADD BX, [BP] would generate an exception.

 * Return code:
 * TRUE - continue parsing the instruction and its operands, everything went right 'till now.
 * FALSE - not enough bytes, or invalid operands.
 */

int operands_extract(_CodeInfo* ci, _DInst* di, _InstInfo* ii,
                     _iflags instFlags, _OpType type, _OperandNumberType opNum,
                     unsigned int modrm, _PrefixState* ps, _DecodeType effOpSz,
                     _DecodeType effAdrSz, int* lockableInstruction)
{
	int ret = 0;
	unsigned int mod = 0, reg = 0, rm = 0, vexV = ps->vexV;
	unsigned int vrex = ps->vrex, typeHandled = TRUE;
	_Operand* op = &di->ops[opNum];

	/* Used to indicate the size of the MEMORY INDIRECTION only. */
	_OperandSizeType opSize = OPERAND_SIZE_NONE;

	/*
	 * ModRM bits:
	 * |7-6-5--------3-2-0|
	 * |MOD|REG/OPCODE|RM |
	 * |------------------|
	 */
	mod = (modrm >> 6) & 3; /* Mode(register-indirection, disp8+reg+indirection, disp16+reg+indirection, general-purpose register) */
	reg = (modrm >> 3) & 7; /* Register(could be part of the opcode itself or general-purpose register) */
	rm = modrm & 7; /* Specifies which general-purpose register or disp+reg to use. */

	/* -- Memory Indirection Operands (that cannot be a general purpose register) -- */
	switch (type)
	{
		case OT_MEM64_128: /* Used only by CMPXCHG8/16B. */
			/* Make a specific check when the type is OT_MEM64_128 since the lockable CMPXCHG8B uses this one... */
			if (lockableInstruction && (ps->decodedPrefixes & INST_PRE_LOCK)) *lockableInstruction = TRUE;
			if (effOpSz == Decode64Bits) {
				ps->usedPrefixes |= INST_PRE_REX;
				opSize = OPERAND_SIZE128;
			} else opSize = OPERAND_SIZE64;
		break;
		case OT_MEM32: opSize = OPERAND_SIZE32; break;
		case OT_MEM32_64:
			/* Used by MOVNTI. Default size is 32bits, 64bits with REX. */
			if (effOpSz == Decode64Bits) {
				ps->usedPrefixes |= INST_PRE_REX;
				opSize = OPERAND_SIZE64;
			} else opSize = OPERAND_SIZE32;
		break;
		case OT_MEM64: opSize = OPERAND_SIZE64; break;
		case OT_MEM128: opSize = OPERAND_SIZE128; break;
		case OT_MEM16_FULL: /* The size indicates about the second item of the pair. */
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					opSize = OPERAND_SIZE16;
				break;
				case Decode32Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					opSize = OPERAND_SIZE32;
				break;
				case Decode64Bits:
					/* Mark usage of REX only if it was required. */
					if ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX)) ps->usedPrefixes |= INST_PRE_REX;
					opSize = OPERAND_SIZE64;
				break;
			}
		break;
		case OT_MEM16_3264: /* The size indicates about the second item of the pair. */
			if (ci->dt == Decode64Bits) opSize = OPERAND_SIZE64;
			else opSize = OPERAND_SIZE32;
		break;
		case OT_MEM_OPT:
			/* Since the MEM is optional, only when mod != 3, then return true as if the operand was alright. */
			if (mod == 0x3) return TRUE;
		break;
		case OT_FPUM16: opSize = OPERAND_SIZE16; break;
		case OT_FPUM32: opSize = OPERAND_SIZE32; break;
		case OT_FPUM64: opSize = OPERAND_SIZE64; break;
		case OT_FPUM80: opSize = OPERAND_SIZE80; break;
		case OT_LMEM128_256:
			if (vrex & PREFIX_EX_L) opSize = OPERAND_SIZE256;
			else opSize = OPERAND_SIZE128;
		break;
		case OT_MEM: /* Size is unknown, but still handled. */ break;
		default: typeHandled = FALSE; break;
	}
	if (typeHandled) {
		/* All of the above types can't use a general-purpose register (a MOD of 3)!. */
		if (mod == 0x3) {
			if (lockableInstruction) *lockableInstruction = FALSE;
			return FALSE;
		}
		op->size = _OPSIZETOINT[opSize];
		ret = operands_extract_modrm(ci, di, type, opNum, ps, effOpSz, effAdrSz, lockableInstruction, mod, rm, instFlags);
		if ((op->type == O_REG) || (op->type == O_SMEM) || (op->type == O_MEM)) {
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		}
		return ret;
	}

	/* -- Memory Indirection Operands (that can be a register) -- */
	typeHandled = TRUE;
	switch (type)
	{
		case OT_RM_FULL:
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/* PUSH/JMP/CALL are automatically promoted to 64 bits! */
			if (effOpSz == Decode32Bits) {
				opSize = OPERAND_SIZE32;
				break;
			} else if (effOpSz == Decode64Bits) {
				/* Mark usage of REX only if it was required. */
				if ((instFlags & INST_64BITS) == 0) ps->usedPrefixes |= INST_PRE_REX;
				opSize = OPERAND_SIZE64;
				break;
			}
			/* FALL THROUGH BECAUSE dt==Decoded16Bits @-<----*/
		case OT_RM16:
			/* If we got here not from OT_RM16, then the prefix was used. */
			if (type != OT_RM16) ps->usedPrefixes |= INST_PRE_OP_SIZE;
			opSize = OPERAND_SIZE16;
		break;
		case OT_RM32_64:
			/* The default size is 32, which can be 64 with a REX only. */
			if (effOpSz == Decode64Bits) {
				opSize = OPERAND_SIZE64;
				/* Mark REX prefix as used if non-promoted instruction. */
				if ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX)) {
					ps->usedPrefixes |= INST_PRE_REX;
				}
			} else opSize = OPERAND_SIZE32;
		break;
		case OT_RM16_32:
			/* Ignore REX, it's either 32 or 16 bits RM. */
			if (ps->decodedPrefixes & INST_PRE_OP_SIZE) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				/* Assume: We are in 64bits when we have this operand used. */
				opSize = OPERAND_SIZE16;
			} else opSize = OPERAND_SIZE32;
		break;
		case OT_WXMM32_64:
		case OT_WRM32_64:
			if (vrex & PREFIX_EX_W) opSize = OPERAND_SIZE64;
			else opSize = OPERAND_SIZE32;
		break;
		case OT_YXMM64_256:
			if (vrex & PREFIX_EX_L) opSize = OPERAND_SIZE256;
			else opSize = OPERAND_SIZE64;
		break;
		case OT_YXMM128_256:
			if (vrex & PREFIX_EX_L) opSize = OPERAND_SIZE256;
			else opSize = OPERAND_SIZE128;
		break;
		case OT_LXMM64_128:
			if (vrex & PREFIX_EX_L) opSize = OPERAND_SIZE128;
			else opSize = OPERAND_SIZE64;
		break;
		case OT_RFULL_M16:
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			opSize = OPERAND_SIZE16;
		break;

		case OT_RM8:
		case OT_R32_M8:
		case OT_R32_64_M8:
		case OT_REG32_64_M8:
			opSize = OPERAND_SIZE8;
		break;

		case OT_XMM16:
		case OT_R32_M16:
		case OT_R32_64_M16:
		case OT_REG32_64_M16:
			opSize = OPERAND_SIZE16;
		break;

		case OT_RM32:
		case OT_MM32:
		case OT_XMM32:
			opSize = OPERAND_SIZE32;
		break;

		case OT_MM64:
		case OT_XMM64:
			opSize = OPERAND_SIZE64;
		break;

		case OT_XMM128: opSize = OPERAND_SIZE128; break;
		case OT_YMM256: opSize = OPERAND_SIZE256; break;
		default: typeHandled = FALSE; break;
	}
	if (typeHandled) {
		/* Fill size of memory dereference for operand. */
		op->size = _OPSIZETOINT[opSize];
		ret = operands_extract_modrm(ci, di, type, opNum, ps, effOpSz, effAdrSz, lockableInstruction, mod, rm, instFlags);
		if ((op->type == O_REG) || (op->type == O_SMEM) || (op->type == O_MEM)) {
			di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
		}
		return ret;
	}

	/* Simple operand type (no ModRM byte). */
	switch (type)
	{
		case OT_IMM8:
			operands_set_ts(op, O_IMM, 8);
			if (!read_stream_safe_uint(ci, &di->imm.byte, sizeof(int8_t))) return FALSE;
		break;
		case OT_IMM_FULL: /* 16, 32 or 64, depends on prefixes. */
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				/* FALL THROUGH */
		case OT_IMM16: /* Force 16 bits imm. */
			operands_set_ts(op, O_IMM, 16);
			if (!read_stream_safe_uint(ci, &di->imm.word, sizeof(int16_t))) return FALSE;
		break;
			/*
			 * Extension: MOV imm64, requires REX.
			 * Make sure it needs the REX.
			 * REX must be present because op size function takes it into consideration.
			 */
			} else if ((effOpSz == Decode64Bits) &&
				        ((instFlags & (INST_64BITS | INST_PRE_REX)) == (INST_64BITS | INST_PRE_REX))) {
				ps->usedPrefixes |= INST_PRE_REX;

				operands_set_ts(op, O_IMM, 64);
				if (!read_stream_safe_uint(ci, &di->imm.qword, sizeof(int64_t))) return FALSE;
				break;
			} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/* FALL THROUGH BECAUSE dt==Decoded32Bits @-<----*/
		case OT_IMM32:
			op->type = O_IMM;
			if (ci->dt == Decode64Bits) {
				/*
				 * Imm32 is sign extended to 64 bits!
				 * Originally the op size was 64, but later was changed to reflect real size of imm.
				 */
				op->size = 32;
				/* Use this as an indicator that it should be signed extended. */
				di->flags |= FLAG_IMM_SIGNED;
				if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int32_t))) return FALSE;
			} else {
				op->size = 32;
				if (!read_stream_safe_uint(ci, &di->imm.dword, sizeof(int32_t))) return FALSE;
			}
		break;
		case OT_SEIMM8: /* Sign extended immediate. */
			/*
			 * PUSH SEIMM8 can be prefixed by operand size:
			 * Input stream: 66, 6a, 55
			 * 64bits DT: push small 55
			 * 32bits DT: push small 55
			 * 16bits DT: push large 55
			 * small/large indicates the size of the eSP pointer advancement.
			 * Check the instFlags (ii->flags) if it can be operand-size-prefixed and if the prefix exists.
			 */
			op->type = O_IMM;
			if ((instFlags & INST_PRE_OP_SIZE) && (ps->decodedPrefixes & INST_PRE_OP_SIZE)) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				switch (ci->dt)
				{
					case Decode16Bits: op->size = 32; break;
					case Decode32Bits:
					case Decode64Bits:
						op->size = 16;
					break;
				}
			} else op->size = 8;
			di->flags |= FLAG_IMM_SIGNED;
			if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int8_t))) return FALSE;
		break;
		case OT_IMM16_1:
			operands_set_ts(op, O_IMM1, 16);
			if (!read_stream_safe_uint(ci, &di->imm.ex.i1, sizeof(int16_t))) return FALSE;
		break;
		case OT_IMM8_1:
			operands_set_ts(op, O_IMM1, 8);
			if (!read_stream_safe_uint(ci, &di->imm.ex.i1, sizeof(int8_t))) return FALSE;
		break;
		case OT_IMM8_2:
			operands_set_ts(op, O_IMM2, 8);
			if (!read_stream_safe_uint(ci, &di->imm.ex.i2, sizeof(int8_t))) return FALSE;
		break;
		case OT_REG8:
			operands_set_ts(op, O_REG, 8);
			if (ps->prefixExtType) {
				/*
				 * If REX prefix is valid then we will have to use low bytes.
				 * This is a PASSIVE behavior changer of REX prefix, it affects operands even if its value is 0x40 !
				 */
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg + ((vrex & PREFIX_EX_R) ? EX_GPR_BASE : 0));
			} else op->index = (uint8_t)(REGS8_BASE + reg);
		break;
		case OT_REG16:
			operands_set_tsi(op, O_REG, 16, REGS16_BASE + reg);
		break;
		case OT_REG_FULL:
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (vrex & PREFIX_EX_R) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					}
					operands_set_tsi(op, O_REG, 16, REGS16_BASE + reg);
				break;
				case Decode32Bits:
					if (vrex & PREFIX_EX_R) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
					operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
				break;
				case Decode64Bits: /* rex must be presented. */
					ps->usedPrefixes |= INST_PRE_REX;
					operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg + ((vrex & PREFIX_EX_R) ? EX_GPR_BASE : 0));
				break;
			}
		break;
		case OT_REG32:
			if (vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}
			operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
		break;
		case OT_REG32_64: /* Handle CVT's, MOVxX and MOVNTI instructions which could be extended to 64 bits registers with REX. */
			if (vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}

			/* Is it a promoted instruction? (only INST_64BITS is set and REX isn't required.) */
			if ((ci->dt == Decode64Bits) && ((instFlags & (INST_64BITS | INST_PRE_REX)) == INST_64BITS)) {
				operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg);
				break;
			}
			/* Give a chance to REX.W. Because if it was a promoted instruction we don't care about REX.W anyways. */
			if (vrex & PREFIX_EX_W) {
				ps->usedPrefixes |= INST_PRE_REX;
				operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg);
			} else operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
		break;
		case OT_FREG32_64_RM: /* Force decoding mode. Used for MOV CR(n)/DR(n) which defaults to 64 bits operand size in 64 bits. */
			if (vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				rm += EX_GPR_BASE;
			}

			if (ci->dt == Decode64Bits) operands_set_tsi(op, O_REG, 64, REGS64_BASE + rm);
			else operands_set_tsi(op, O_REG, 32, REGS32_BASE + rm);
		break;
		case OT_MM: /* MMX register */
			operands_set_tsi(op, O_REG, 64, MMXREGS_BASE + reg);
		break;
		case OT_MM_RM: /* MMX register, this time from the RM field */
			operands_set_tsi(op, O_REG, 64, MMXREGS_BASE + rm);
		break;
		case OT_REGXMM0: /* Implicit XMM0 operand. */
			reg = 0;
			vrex = 0;
		/* FALL THROUGH */
		case OT_XMM: /* SSE register */
			if (vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			}
			operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + reg);
		break;
		case OT_XMM_RM: /* SSE register, this time from the RM field */
			if (vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				rm += EX_GPR_BASE;
			}
			operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + rm);
		break;
		case OT_CREG:
			/*
			 * Don't parse if the reg exceeds the bounds of the array.
			 * Most of the CR's are not implemented, so if there's no matching string, the operand is invalid.
			 */
			if (vrex & PREFIX_EX_R) {
				ps->usedPrefixes |= INST_PRE_REX;
				reg += EX_GPR_BASE;
			} else if ((ci->dt == Decode32Bits) && (ps->decodedPrefixes & INST_PRE_LOCK)) {
				/*
				 * NOTE: In 32 bits decoding mode,
				 * if the lock prefix is set before MOV CR(n) it will become the 4th bit of the REG field like REX.R in 64 bits.
				 */
				reg += EX_GPR_BASE;
				ps->usedPrefixes |= INST_PRE_LOCK;
			}
			/* Ignore some registers which do not exist. */
			if ((reg >= CREGS_MAX) || (reg == 1) || ((reg >= 5) && (reg <= 7))) return FALSE;

			op->type = O_REG;
			if (ci->dt == Decode64Bits) op->size = 64;
			else op->size = 32;
			op->index = (uint8_t)(CREGS_BASE + reg);
		break;
		case OT_DREG:
			/*
			 * In 64 bits there are 16 debug registers.
			 * but accessing any of dr8-15 which aren't implemented will cause an #ud.
			 */
			if ((reg == 4) || (reg == 5) || (vrex & PREFIX_EX_R)) return FALSE;

			op->type = O_REG;
			if (ci->dt == Decode64Bits) op->size = 64;
			else op->size = 32;
			op->index = (uint8_t)(DREGS_BASE + reg);
		break;
		case OT_SREG: /* Works with REG16 only! */
			/* If lockableInstruction pointer is non-null we know it's the first operand. */
			if (lockableInstruction && (reg == 1)) return FALSE; /* Can't MOV CS, <REG>. */
			/*Don't parse if the reg exceeds the bounds of the array. */
			if (reg <= SEG_REGS_MAX - 1) operands_set_tsi(op, O_REG, 16, SREGS_BASE + reg);
			else return FALSE;
		break;
		case OT_SEG:
			op->type = O_REG;
			/* Size of reg is always 16, it's up to caller to zero extend it to operand size. */
			op->size = 16;
			ps->usedPrefixes |= INST_PRE_OP_SIZE;
			/*
			 * Extract the SEG from ii->flags this time!!!
			 * Check whether an operand size prefix is used.
			 */
			switch (instFlags & INST_PRE_SEGOVRD_MASK)
			{
				case INST_PRE_ES: op->index = R_ES; break;
				case INST_PRE_CS: op->index = R_CS; break;
				case INST_PRE_SS: op->index = R_SS; break;
				case INST_PRE_DS: op->index = R_DS; break;
				case INST_PRE_FS: op->index = R_FS; break;
				case INST_PRE_GS: op->index = R_GS; break;
			}
		break;
		case OT_ACC8:
			operands_set_tsi(op, O_REG, 8, R_AL);
		break;
		case OT_ACC16:
			operands_set_tsi(op, O_REG, 16, R_AX);
		break;
		case OT_ACC_FULL_NOT64: /* No REX.W support for IN/OUT. */
			vrex &= ~PREFIX_EX_W;
		case OT_ACC_FULL:
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				operands_set_tsi(op, O_REG, 16, R_AX);
			} else if (effOpSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				operands_set_tsi(op, O_REG, 32, R_EAX);
			} else { /* Decode64Bits */
				/* Only non-promoted instructions need REX in order to decode in 64 bits. */
				/* MEM-OFFSET MOV's are NOT automatically promoted to 64 bits. */
				if (~instFlags & INST_64BITS) {
					ps->usedPrefixes |= INST_PRE_REX;
				}
				operands_set_tsi(op, O_REG, 64, R_RAX);
			}
		break;
		case OT_PTR16_FULL:
			/* ptr16:full - full is size of operand size to read, therefore Operand Size Prefix affects this. So we need to handle it. */
			if (effOpSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				ci->codeLen -= sizeof(int16_t)*2;
				if (ci->codeLen < 0) return FALSE;

				operands_set_ts(op, O_PTR, 16);
				di->imm.ptr.off = RUSHORT(ci->code); /* Read offset first. */
				di->imm.ptr.seg = RUSHORT((ci->code + sizeof(int16_t))); /* And read segment. */

				ci->code += sizeof(int16_t)*2;
			} else { /* Decode32Bits, for Decode64Bits this instruction is invalid. */
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				ci->codeLen -= sizeof(int32_t) + sizeof(int16_t);
				if (ci->codeLen < 0) return FALSE;

				operands_set_ts(op, O_PTR, 32);
				di->imm.ptr.off = RULONG(ci->code); /* Read 32bits offset this time. */
				di->imm.ptr.seg = RUSHORT((ci->code + sizeof(int32_t))); /* And read segment, 16 bits. */
				
				ci->code += sizeof(int32_t) + sizeof(int16_t);
			}
		break;
		case OT_RELCB:
		case OT_RELC_FULL:

			if (type == OT_RELCB) {
				operands_set_ts(op, O_PC, 8);
				if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int8_t))) return FALSE;
			} else { /* OT_RELC_FULL */

				/* Yep, operand size prefix affects relc also.  */
				ps->usedPrefixes |= INST_PRE_OP_SIZE;
				if (effOpSz == Decode16Bits) {
					operands_set_ts(op, O_PC, 16);
					if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int16_t))) return FALSE;
				} else { /* Decode32Bits or Decode64Bits = for now they are the same */
					operands_set_ts(op, O_PC, 32);
					if (!read_stream_safe_sint(ci, &di->imm.sqword, sizeof(int32_t))) return FALSE;
				}
			}

			/* Support for hint, see if there's a segment override. */
			if ((ii->opcodeId >= I_JO) && (ii->opcodeId <= I_JG)) {
				if (ps->decodedPrefixes & INST_PRE_CS) {
					ps->usedPrefixes |= INST_PRE_CS;
					di->flags |= FLAG_HINT_NOT_TAKEN;
				} else if (ps->decodedPrefixes & INST_PRE_DS) {
					ps->usedPrefixes |= INST_PRE_DS;
					di->flags |= FLAG_HINT_TAKEN;
				}
			}
		break;
		case OT_MOFFS8:
			op->size = 8;
			/* FALL THROUGH, size won't be changed. */
		case OT_MOFFS_FULL:
			op->type = O_DISP;
			if (op->size == 0) {
				/* Calculate size of operand (same as ACC size). */
				switch (effOpSz)
				{
					case Decode16Bits: op->size = 16; break;
					case Decode32Bits: op->size = 32; break;
					case Decode64Bits: op->size = 64; break;
				}
			}

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			/*
			 * Just a pointer to a BYTE, WORD, DWORD, QWORD. Works only with ACC8/16/32/64 respectively. 
			 * MOV [0x1234], AL ; MOV AX, [0x1234] ; MOV EAX, [0x1234], note that R/E/AX will be chosen by OT_ACC_FULL.
			 */
			if (effAdrSz == Decode16Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

				di->dispSize = 16;
				if (!read_stream_safe_uint(ci, &di->disp, sizeof(int16_t))) return FALSE;
			} else if (effAdrSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

				di->dispSize = 32;
				if (!read_stream_safe_uint(ci, &di->disp, sizeof(int32_t))) return FALSE;
			} else { /* Decode64Bits */
				di->dispSize = 64;
				if (!read_stream_safe_uint(ci, &di->disp, sizeof(int64_t))) return FALSE;
			}
		break;
		case OT_CONST1:
			operands_set_ts(op, O_IMM, 8);
			di->imm.byte = 1;
		break;
		case OT_REGCL:
			operands_set_tsi(op, O_REG, 8, R_CL);
		break;

		case OT_FPU_SI:
			/* Low 3 bits specify the REG, similar to the MODR/M byte reg. */
			operands_set_tsi(op, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
		break;
		case OT_FPU_SSI:
			operands_set_tsi(op, O_REG, 32, R_ST0);
			operands_set_tsi(op + 1, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
		break;
		case OT_FPU_SIS:
			operands_set_tsi(op, O_REG, 32, FPUREGS_BASE + (*(ci->code-1) & 7));
			operands_set_tsi(op + 1, O_REG, 32, R_ST0);
		break;

		/*
		 * Special treatment for Instructions-Block:
		 * INC/DEC (only 16/32 bits) /PUSH/POP/XCHG instructions, which get their REG from their own binary code.

		 * Notice these instructions are 1 or 2 byte long,
		 * code points after the byte which represents the instruction itself,
		 * thus, even if the instructions are 2 bytes long it will read its last byte which contains the REG info.
		 */
		case OT_IB_RB:
			/* Low 3 bits specify the REG, similar to the MODR/M byte reg. */
			operands_set_ts(op, O_REG, 8);
			reg = *(ci->code-1) & 7;
			if (vrex & PREFIX_EX_B) {
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg + EX_GPR_BASE);
			} else if (ps->prefixExtType == PET_REX) {
				ps->usedPrefixes |= INST_PRE_REX;
				op->index = (uint8_t)operands_fix_8bit_rex_base(reg);
			} else op->index = (uint8_t)(REGS8_BASE + reg);
		break;
		case OT_IB_R_FULL:
			reg = *(ci->code-1) & 7;
			switch (effOpSz)
			{
				case Decode16Bits:
					ps->usedPrefixes |= INST_PRE_OP_SIZE;
					if (vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					}
					operands_set_tsi(op, O_REG, 16, REGS16_BASE + reg);
				break;
				case Decode32Bits:
					if (vrex & PREFIX_EX_B) {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += EX_GPR_BASE;
					} else ps->usedPrefixes |= INST_PRE_OP_SIZE;
					operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
				break;
				case Decode64Bits:
					/*
					 * Automatically promoted instruction can drop REX prefix if not required.
					 * PUSH/POP defaults to 64 bits. --> INST_64BITS
					 * MOV imm64 / BSWAP requires REX.W to be 64 bits --> INST_64BITS | INST_PRE_REX
					 */
					if ((instFlags & INST_64BITS) && ((instFlags & INST_PRE_REX) == 0)) {
						if (vrex & PREFIX_EX_B) {
							ps->usedPrefixes |= INST_PRE_REX;
							reg += EX_GPR_BASE;
						}
					} else {
						ps->usedPrefixes |= INST_PRE_REX;
						reg += (vrex & PREFIX_EX_B) ? EX_GPR_BASE : 0;
					}
					operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg);
				break;
			}
		break;

		/*
		 * Special treatment for repeatable instructions.

		 * We want the following output:
		 * If there's only the REP/NZ prefix, we won't output anything (All operands are implicit).
		 * If there's an operand size prefix, we will change the suffix letter of the mnemonic, which specifies the size of operand to the required one.
		 * If there's a segment override prefix, we will output the segment and the used index register (EDI/ESI).
		 * If there's an address size prefix, we will output the (segment if needed and) the used and inverted index register (DI/SI).

		 * Example:
		 * :: Decoding in 16 bits mode! ::
		 * AD ~ LODSW
		 * 66 AD ~ LODSD
		 * F3 AC ~ REP LODSB
		 * F3 66 AD ~ REP LODSD
		 * F3 3E AC ~ REP LODS BYTE DS:[SI]
		 * F3 67 AD ~ REP LODS WORD [ESI]

		 * The basic form of a repeatable instruction has its operands hidden and has a suffix letter
		 * which implies on the size of operation being done.
		 * Therefore, we cannot change the mnemonic here when we encounter another prefix and its not the decoder's responsibility to do so.
		 * That's why the caller is responsible to add the suffix letter if no other prefixes are used.
		 * And all we are doing here is formatting the operand correctly.
		 */
		case OT_REGI_ESI:
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			op->type = O_SMEM;

			/* This might be a 16, 32 or 64 bits instruction, depends on the decoding mode. */
			if (instFlags & INST_16BITS) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;

				if (effOpSz == Decode16Bits) op->size = 16;
				else if ((effOpSz == Decode64Bits) && (instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
					op->size = 64;
				} else op->size = 32;
			} else op->size = 8;

			/*
			 * Clear segment in case OT_REGI_EDI was parsed earlier,
			 * DS can be overridden and therefore has precedence.
			 */
			di->segment = 0;
			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			if (effAdrSz == Decode16Bits) op->index = R_SI;
			else if (effAdrSz == Decode32Bits) op->index = R_ESI;
			else op->index = R_RSI;
		break;
		case OT_REGI_EDI:
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			op->type = O_SMEM;

			/* This might be a 16 or 32 bits instruction, depends on the decoding mode. */
			if (instFlags & INST_16BITS) {
				ps->usedPrefixes |= INST_PRE_OP_SIZE;

				if (effOpSz == Decode16Bits) op->size = 16;
				else if ((effOpSz == Decode64Bits) && (instFlags & INST_64BITS)) {
					ps->usedPrefixes |= INST_PRE_REX;
					op->size = 64;
				} else op->size = 32;
			} else op->size = 8;

			/* Note: The [rDI] operand can't be prefixed by a segment override, therefore we don't set usedPrefixes. */
			if ((opNum == ONT_1) && (ci->dt != Decode64Bits)) di->segment = R_ES | SEGMENT_DEFAULT; /* No ES in 64 bits mode. */

			if (effAdrSz == Decode16Bits) op->index = R_DI;
			else if (effAdrSz == Decode32Bits) op->index = R_EDI;
			else op->index = R_RDI;
		break;

		/* Used for In/Out instructions varying forms. */
		case OT_REGDX:
			/* Simple single IN/OUT instruction. */
			operands_set_tsi(op, O_REG, 16, R_DX);
		break;

		/* Used for INVLPGA instruction. */
		case OT_REGECX:
			operands_set_tsi(op, O_REG, 32, R_ECX);
		break;
		case OT_REGI_EBXAL:
			/* XLAT BYTE [rBX + AL] */
			ps->usedPrefixes |= INST_PRE_ADDR_SIZE;

			prefixes_use_segment(INST_PRE_DS, ps, ci->dt, di);

			/* Size of deref is always 8 for xlat. */
			operands_set_tsi(op, O_MEM, 8, R_AL);

			if (effAdrSz == Decode16Bits) di->base = R_BX;
			else if (effAdrSz == Decode32Bits) di->base = R_EBX;
			else {
				ps->usedPrefixes |= INST_PRE_REX;
				di->base = R_RBX;
			}
		break;
		case OT_REGI_EAX:
			/*
			 * Implicit rAX as memory indirection operand. Used by AMD's SVM instructions.
			 * Since this is a memory indirection, the default address size in 64bits decoding mode is 64.
			 */

			if (effAdrSz == Decode64Bits) operands_set_tsi(op, O_SMEM, 64, R_RAX);
			else if (effAdrSz == Decode32Bits) {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				operands_set_tsi(op, O_SMEM, 32, R_EAX);
			} else {
				ps->usedPrefixes |= INST_PRE_ADDR_SIZE;
				operands_set_tsi(op, O_SMEM, 16, R_AX);
			}
		break;
		case OT_VXMM:
			operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + vexV);
		break;
		case OT_XMM_IMM:
			ci->codeLen -= sizeof(int8_t);
			if (ci->codeLen < 0) return FALSE;

			if (ci->dt == Decode32Bits) reg = (*ci->code >> 4) & 0x7;
			else reg = (*ci->code >> 4) & 0xf;
			operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + reg);

			ci->code += sizeof(int8_t);
		break;
		case OT_YXMM:
			if (vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + reg);
			else operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + reg);
		break;
		case OT_YXMM_IMM:
			ci->codeLen -= sizeof(int8_t);
			if (ci->codeLen < 0) return FALSE;

			if (ci->dt == Decode32Bits) reg = (*ci->code >> 4) & 0x7;
			else reg = (*ci->code >> 4) & 0xf;

			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + reg);
			else operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + reg);

			ci->code += sizeof(int8_t);
		break;
		case OT_YMM:
			if (vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + reg);
		break;
		case OT_VYMM:
			operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + vexV);
		break;
		case OT_VYXMM:
			if (ps->vrex & PREFIX_EX_L) operands_set_tsi(op, O_REG, 256, AVXREGS_BASE + vexV);
			else operands_set_tsi(op, O_REG, 128, SSEREGS_BASE + vexV); 
		break;
		case OT_WREG32_64:
			if (vrex & PREFIX_EX_R) reg += EX_GPR_BASE;
			if (ps->vrex & PREFIX_EX_W) operands_set_tsi(op, O_REG, 64, REGS64_BASE + reg);
			else operands_set_tsi(op, O_REG, 32, REGS32_BASE + reg);
		break;
		default: return FALSE;
	}

	if ((op->type == O_REG) || (op->type == O_SMEM) || (op->type == O_MEM)) {
		di->usedRegistersMask |= _REGISTERTORCLASS[op->index];
	}

	return TRUE;
}



================================================
File: 3rdparty/distorm/operands.h
================================================
/*
operands.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef OPERANDS_H
#define OPERANDS_H

#include "config.h"
#include "decoder.h"
#include "prefix.h"
#include "instructions.h"


extern uint32_t _REGISTERTORCLASS[];

int operands_extract(_CodeInfo* ci, _DInst* di, _InstInfo* ii,
                     _iflags instFlags, _OpType type, _OperandNumberType opNum,
                     unsigned int modrm, _PrefixState* ps, _DecodeType effOpSz,
                     _DecodeType effAdrSz, int* lockableInstruction);

#endif /* OPERANDS_H */



================================================
File: 3rdparty/distorm/prefix.c
================================================
/*
prefix.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "prefix.h"

#include "x86defs.h"
#include "instructions.h"
#include "mnemonics.h"


/*
 * The main purpose of this module is to keep track of all kind of prefixes a single instruction may have.
 * The problem is that a single instruction may have up to six different prefix-types.
 * That's why I have to detect such cases and drop those excess prefixes.
 */

int prefixes_is_valid(unsigned int ch, _DecodeType dt)
{
	switch (ch) {
		/* for i in xrange(0x40, 0x50): print "case 0x%2x:" % i */
		case 0x40: /* REX: */
		case 0x41:
		case 0x42:
		case 0x43:
		case 0x44:
		case 0x45:
		case 0x46:
		case 0x47:
		case 0x48:
		case 0x49:
		case 0x4a:
		case 0x4b:
		case 0x4c:
		case 0x4d:
		case 0x4e:
		case 0x4f: return (dt == Decode64Bits);
		case PREFIX_LOCK: return TRUE;
		case PREFIX_REPNZ: return TRUE;
		case PREFIX_REP: return TRUE;
		case PREFIX_CS: return TRUE;
		case PREFIX_SS: return TRUE;
		case PREFIX_DS: return TRUE;
		case PREFIX_ES: return TRUE;
		case PREFIX_FS: return TRUE;
		case PREFIX_GS: return TRUE;
		case PREFIX_OP_SIZE: return TRUE;
		case PREFIX_ADDR_SIZE: return TRUE;
		/* The VEXs might be false positives, the decode_perfixes will determine for sure. */
		case PREFIX_VEX2b: /* VEX is supported for all modes, because 16 bits Pmode is included. */
		case PREFIX_VEX3b: return TRUE;
	}
	return FALSE;
}

/* Ignore a specific prefix type. */
void prefixes_ignore(_PrefixState* ps, _PrefixIndexer pi)
{
	/*
	 * If that type of prefix appeared already, set the bit of that *former* prefix.
	 * Anyway, set the new index of that prefix type to the current index, so next time we know its position.
	 */
	if (ps->pfxIndexer[pi] != PFXIDX_NONE) ps->unusedPrefixesMask |= (1 << ps->pfxIndexer[pi]);
}

/* Ignore all prefix. */
void prefixes_ignore_all(_PrefixState* ps)
{
	int i;
	for (i = 0; i < PFXIDX_MAX; i++)
		prefixes_ignore(ps, i);
}

/* Calculates which prefixes weren't used and accordingly sets the bits in the unusedPrefixesMask. */
uint16_t prefixes_set_unused_mask(_PrefixState* ps)
{
	/*
	 * The decodedPrefixes represents the prefixes that were *read* from the binary stream for the instruction.
	 * The usedPrefixes represents the prefixes that were actually used by the instruction in the *decode* phase.
	 * Xoring between the two will result in a 'diff' which returns the prefixes that were read
	 * from the stream *and* that were never used in the actual decoding.
	 *
	 * Only one prefix per type can be set in decodedPrefixes from the stream.
	 * Therefore it's enough to check each type once and set the flag accordingly.
	 * That's why we had to book-keep each prefix type and its position.
	 * So now we know which bits we need to set exactly in the mask.
	 */
	_iflags unusedPrefixesDiff = ps->decodedPrefixes ^ ps->usedPrefixes;

	/* Examine unused prefixes by type: */
	/*
	 * About REX: it might be set in the diff although it was never in the stream itself.
	 * This is because the vrex is shared between VEX and REX and some places flag it as REX usage, while
	 * we were really decoding an AVX instruction.
	 * It's not a big problem, because the prefixes_ignore func will ignore it anyway,
	 * since it wasn't seen earlier. But it's important to know this.
	 */
	if (unusedPrefixesDiff & INST_PRE_REX) prefixes_ignore(ps, PFXIDX_REX);
	if (unusedPrefixesDiff & INST_PRE_SEGOVRD_MASK) prefixes_ignore(ps, PFXIDX_SEG);
	if (unusedPrefixesDiff & INST_PRE_LOKREP_MASK) prefixes_ignore(ps, PFXIDX_LOREP);
	if (unusedPrefixesDiff & INST_PRE_OP_SIZE) prefixes_ignore(ps, PFXIDX_OP_SIZE);
	if (unusedPrefixesDiff & INST_PRE_ADDR_SIZE) prefixes_ignore(ps, PFXIDX_ADRS);
	/* If a VEX instruction was found, its prefix is considered as used, therefore no point for checking for it. */

	return ps->unusedPrefixesMask;
}

/*
 * Mark a prefix as unused, and bookkeep where we last saw this same type,
 * because in the future we might want to disable it too.
 */
_INLINE_ void prefixes_track_unused(_PrefixState* ps, int index, _PrefixIndexer pi)
{
	prefixes_ignore(ps, pi);
	/* Book-keep the current index for this type. */
	ps->pfxIndexer[pi] = index;
}

/*
 * Read as many prefixes as possible, up to 15 bytes, and halt when we encounter non-prefix byte.
 * This algorithm tries to imitate a real processor, where the same prefix can appear a few times, etc.
 * The tiny complexity is that we want to know when a prefix was superfluous and mark any copy of it as unused.
 * Note that the last prefix of its type will be considered as used, and all the others (of same type) before it as unused.
 */
void prefixes_decode(const uint8_t* code, int codeLen, _PrefixState* ps, _DecodeType dt)
{
	int index, done;
	uint8_t vex;

	/*
	 * First thing to do, scan for prefixes, there are six types of prefixes.
	 * There may be up to six prefixes before a single instruction, not the same type, no special order,
	 * except REX/VEX must precede immediately the first opcode byte.
	 * BTW - This is the reason why I didn't make the REP prefixes part of the instructions (STOS/SCAS/etc).
	 *
	 * Another thing, the instruction maximum size is 15 bytes, thus if we read more than 15 bytes, we will halt.
	 *
	 * We attach all prefixes to the next instruction, there might be two or more occurrences from the same prefix.
	 * Also, since VEX can be allowed only once we will test it separately.
	 */
	for (index = 0, done = FALSE;
		 (codeLen > 0) && (code - ps->start < INST_MAXIMUM_SIZE);
		 code++, codeLen--, index++) {
		/*
		NOTE: AMD treat lock/rep as two different groups... But I am based on Intel.

			- Lock and Repeat:
				- 0xF0 — LOCK
				- 0xF2 — REPNE/REPNZ
				- 0xF3 - REP/REPE/REPZ
			- Segment Override:
				- 0x2E - CS
				- 0x36 - SS
				- 0x3E - DS
				- 0x26 - ES
				- 0x64 - FS
				- 0x65 - GS
			- Operand-Size Override: 0x66, switching default size.
			- Address-Size Override: 0x67, switching default size.

		64 Bits:
			- REX: 0x40 - 0x4f, extends register access.
			- 2 Bytes VEX: 0xc4
			- 3 Bytes VEX: 0xc5
		32 Bits:
			- 2 Bytes VEX: 0xc4 11xx-xxxx
			- 3 Bytes VEX: 0xc5 11xx-xxxx
		*/

		/* Examine what type of prefix we got. */
		switch (*code)
		{
			/* REX type, 64 bits decoding mode only: */
			case 0x40:
			case 0x41:
			case 0x42:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x46:
			case 0x47:
			case 0x48:
			case 0x49:
			case 0x4a:
			case 0x4b:
			case 0x4c:
			case 0x4d:
			case 0x4e:
			case 0x4f:
				if (dt == Decode64Bits) {
					ps->decodedPrefixes |= INST_PRE_REX;
					ps->vrex = *code & 0xf; /* Keep only BXRW. */
					ps->rexPos = code;
					ps->prefixExtType = PET_REX;
					prefixes_track_unused(ps, index, PFXIDX_REX);
				} else done = TRUE; /* If we are not in 64 bits mode, it's an instruction, then halt. */
			break;

			/* LOCK and REPx type: */
			case PREFIX_LOCK:
				ps->decodedPrefixes |= INST_PRE_LOCK;
				prefixes_track_unused(ps, index, PFXIDX_LOREP);
			break;
			case PREFIX_REPNZ:
				ps->decodedPrefixes |= INST_PRE_REPNZ;
				prefixes_track_unused(ps, index, PFXIDX_LOREP);
			break;
			case PREFIX_REP:
				ps->decodedPrefixes |= INST_PRE_REP;
				prefixes_track_unused(ps, index, PFXIDX_LOREP);
			break;

			/* Seg Overide type: */
			case PREFIX_CS:
				ps->decodedPrefixes |= INST_PRE_CS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_SS:
				ps->decodedPrefixes |= INST_PRE_SS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_DS:
				ps->decodedPrefixes |= INST_PRE_DS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_ES:
				ps->decodedPrefixes |= INST_PRE_ES;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_FS:
				ps->decodedPrefixes |= INST_PRE_FS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;
			case PREFIX_GS:
				ps->decodedPrefixes |= INST_PRE_GS;
				prefixes_track_unused(ps, index, PFXIDX_SEG);
			break;

			/* Op Size type: */
			case PREFIX_OP_SIZE:
				ps->decodedPrefixes |= INST_PRE_OP_SIZE;
				prefixes_track_unused(ps, index, PFXIDX_OP_SIZE);
			break;

			/* Addr Size type: */
			case PREFIX_ADDR_SIZE:
				ps->decodedPrefixes |= INST_PRE_ADDR_SIZE;
				prefixes_track_unused(ps, index, PFXIDX_ADRS);
			break;

			/* Non-prefix byte now, so break 2. */
			default: done = TRUE; break;
		}
		if (done) break;
	}

	/* 2 Bytes VEX: */
	if ((codeLen >= 2) &&
		(*code == PREFIX_VEX2b) &&
		((code - ps->start) <= INST_MAXIMUM_SIZE - 2)) {
		/*
		 * In 32 bits the second byte has to be in the special range of Mod=11.
		 * Otherwise it might be a normal LDS instruction.
		 */
		if ((dt == Decode64Bits) || (*(code + 1) >= INST_DIVIDED_MODRM)) {
			ps->vexPos = code + 1;
			ps->decodedPrefixes |= INST_PRE_VEX;
			ps->prefixExtType = PET_VEX2BYTES;

			/*
			 * VEX 1 byte bits:
			 * |7-6--3-2-10|
			 * |R|vvvv|L|pp|
			 * |-----------|
			 */

			/* -- Convert from VEX prefix to VREX flags -- */
			vex = *ps->vexPos;
			if (~vex & 0x80 && dt == Decode64Bits) ps->vrex |= PREFIX_EX_R; /* Convert VEX.R. */
			if (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */

			code += 2;
		}
	}

	/* 3 Bytes VEX: */
	if ((codeLen >= 3) &&
		(*code == PREFIX_VEX3b) &&
		((code - ps->start) <= INST_MAXIMUM_SIZE - 3) &&
		(~ps->decodedPrefixes & INST_PRE_VEX)) {
		/*
		 * In 32 bits the second byte has to be in the special range of Mod=11.
		 * Otherwise it might be a normal LES instruction.
		 * And we don't care now about the 3rd byte.
		 */
		if ((dt == Decode64Bits) || (*(code + 1) >= INST_DIVIDED_MODRM)) {
			ps->vexPos = code + 1;
			ps->decodedPrefixes |= INST_PRE_VEX;
			ps->prefixExtType = PET_VEX3BYTES;

			/*
			 * VEX first and second bytes:
			 * |7-6-5-4----0|  |7-6--3-2-10|
			 * |R|X|B|m-mmmm|  |W|vvvv|L|pp|
			 * |------------|  |-----------|
			 */

			/* -- Convert from VEX prefix to VREX flags -- */
			vex = *ps->vexPos;
			ps->vrex |= ((~vex >> 5) & 0x7); /* Shift and invert VEX.R/X/B to their place */
			vex = *(ps->vexPos + 1);
			if (vex & 4) ps->vrex |= PREFIX_EX_L; /* Convert VEX.L. */
			if (vex & 0x80) ps->vrex |= PREFIX_EX_W; /* Convert VEX.W. */

			/* Clear some flags if the mode isn't 64 bits. */
			if (dt != Decode64Bits) ps->vrex &= ~(PREFIX_EX_B | PREFIX_EX_X | PREFIX_EX_R | PREFIX_EX_W);

			code += 3;
		}
	}

	/*
	 * Save last byte scanned address, so the decoder could keep on scanning from this point and on and on and on.
	 * In addition the decoder is able to know that the last byte could lead to MMX/SSE instructions (preceding REX if exists).
	 */
	ps->last = code; /* ps->last points to an opcode byte. */
}

/*
 * For every memory-indirection operand we want to set its corresponding default segment.
 * If the segment is being overrided, we need to see whether we use it or not.
 * We will use it only if it's not the default one already.
 */
void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di)
{
	_iflags flags = 0;
	if (dt == Decode64Bits) flags = ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK64;
	else flags = ps->decodedPrefixes & INST_PRE_SEGOVRD_MASK;

	if ((flags == 0) || (flags == defaultSeg)) {
		flags = defaultSeg;
		di->segment |= SEGMENT_DEFAULT;
	} else if (flags != defaultSeg) {
		/* Use it only if it's non-default segment. */
		ps->usedPrefixes |= flags;
	}

	/* ASSERT: R_XX must be below 128. */
	switch (flags)
	{
		case INST_PRE_ES: di->segment |= R_ES; break;
		case INST_PRE_CS: di->segment |= R_CS; break;
		case INST_PRE_SS: di->segment |= R_SS; break;
		case INST_PRE_DS: di->segment |= R_DS; break;
		case INST_PRE_FS: di->segment |= R_FS; break;
		case INST_PRE_GS: di->segment |= R_GS; break;
	}

	/* If it's one of the CS,SS,DS,ES and the mode is 64 bits, set segment it to none, since it's ignored. */
	if ((dt == Decode64Bits) && (flags & INST_PRE_SEGOVRD_MASK32)) di->segment = R_NONE;
}



================================================
File: 3rdparty/distorm/prefix.h
================================================
/*
prefix.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef PREFIX_H
#define PREFIX_H

#include "config.h"
#include "decoder.h"


/* Specifies the type of the extension prefix, such as: REX, 2 bytes VEX, 3 bytes VEX. */
typedef enum {PET_NONE = 0, PET_REX, PET_VEX2BYTES, PET_VEX3BYTES} _PrefixExtType;

/* Specifies an index into a table of prefixes by their type. */
typedef enum {PFXIDX_NONE = -1, PFXIDX_REX, PFXIDX_LOREP, PFXIDX_SEG, PFXIDX_OP_SIZE, PFXIDX_ADRS, PFXIDX_MAX} _PrefixIndexer;

/*
* This holds the prefixes state for the current instruction we decode.
* decodedPrefixes includes all specific prefixes that the instruction got.
* start is a pointer to the first prefix to take into account.
* last is a pointer to the last byte we scanned.
* Other pointers are used to keep track of prefixes positions and help us know if they appeared already and where.
*/
typedef struct {
	_iflags decodedPrefixes, usedPrefixes;
	const uint8_t *start, *last, *vexPos, *rexPos;
	_PrefixExtType prefixExtType;
	uint16_t unusedPrefixesMask;
	/* Indicates whether the operand size prefix (0x66) was used as a mandatory prefix. */
	int isOpSizeMandatory;
	/* If VEX prefix is used, store the VEX.vvvv field. */
	unsigned int vexV;
	/* The fields B/X/R/W/L of REX and VEX are stored together in this byte. */
	unsigned int vrex;

	/* !! Make sure pfxIndexer is LAST! Otherwise memset won't work well with it. !! */

	/* Holds the offset to the prefix byte by its type. */
	int pfxIndexer[PFXIDX_MAX];
} _PrefixState;

/*
* Intel supports 6 types of prefixes, whereas AMD supports 5 types (lock is seperated from rep/nz).
* REX is the fifth prefix type, this time I'm based on AMD64.
* VEX is the 6th, though it can't be repeated.
*/
#define MAX_PREFIXES (5)

int prefixes_is_valid(unsigned int ch, _DecodeType dt);
void prefixes_ignore(_PrefixState* ps, _PrefixIndexer pi);
void prefixes_ignore_all(_PrefixState* ps);
uint16_t prefixes_set_unused_mask(_PrefixState* ps);
void prefixes_decode(const uint8_t* code, int codeLen, _PrefixState* ps, _DecodeType dt);
void prefixes_use_segment(_iflags defaultSeg, _PrefixState* ps, _DecodeType dt, _DInst* di);

#endif /* PREFIX_H */



================================================
File: 3rdparty/distorm/textdefs.c
================================================
/*
textdefs.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "textdefs.h"

#ifndef DISTORM_LIGHT

static uint8_t Nibble2ChrTable[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
#define NIBBLE_TO_CHR Nibble2ChrTable[t]

void _FASTCALL_ str_hex_b(_WString* s, unsigned int x)
{
	/*
	 * def prebuilt():
	 * 	s = ""
	 * 	for i in xrange(256):
	 * 		if ((i % 0x10) == 0):
	 * 			s += "\r\n"
	 * 		s += "\"%02x\", " % (i)
	 * 	return s
	 */
	static int8_t TextBTable[256][3] = {
		"00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f",
		"10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f",
		"20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f",
		"30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f",
		"40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f",
		"50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f",
		"60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f",
		"70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f",
		"80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f",
		"90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f",
		"a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af",
		"b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf",
		"c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf",
		"d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df",
		"e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef",
		"f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"
	};

	/*
	 * Fixed length of 3 including null terminate character.
	 */
	memcpy(&s->p[s->length], TextBTable[x & 255], 3);
	s->length += 2;
}

void _FASTCALL_ str_code_hb(_WString* s, unsigned int x)
{
	static int8_t TextHBTable[256][5] = {
	/*
	 * def prebuilt():
	 * 	s = ""
	 * 	for i in xrange(256):
	 * 		if ((i % 0x10) == 0):
	 * 			s += "\r\n"
	 * 		s += "\"0x%x\", " % (i)
	 * 	return s
	 */
		"0x0", "0x1", "0x2", "0x3", "0x4", "0x5", "0x6", "0x7", "0x8", "0x9", "0xa", "0xb", "0xc", "0xd", "0xe", "0xf",
		"0x10", "0x11", "0x12", "0x13", "0x14", "0x15", "0x16", "0x17", "0x18", "0x19", "0x1a", "0x1b", "0x1c", "0x1d", "0x1e", "0x1f",
		"0x20", "0x21", "0x22", "0x23", "0x24", "0x25", "0x26", "0x27", "0x28", "0x29", "0x2a", "0x2b", "0x2c", "0x2d", "0x2e", "0x2f",
		"0x30", "0x31", "0x32", "0x33", "0x34", "0x35", "0x36", "0x37", "0x38", "0x39", "0x3a", "0x3b", "0x3c", "0x3d", "0x3e", "0x3f",
		"0x40", "0x41", "0x42", "0x43", "0x44", "0x45", "0x46", "0x47", "0x48", "0x49", "0x4a", "0x4b", "0x4c", "0x4d", "0x4e", "0x4f",
		"0x50", "0x51", "0x52", "0x53", "0x54", "0x55", "0x56", "0x57", "0x58", "0x59", "0x5a", "0x5b", "0x5c", "0x5d", "0x5e", "0x5f",
		"0x60", "0x61", "0x62", "0x63", "0x64", "0x65", "0x66", "0x67", "0x68", "0x69", "0x6a", "0x6b", "0x6c", "0x6d", "0x6e", "0x6f",
		"0x70", "0x71", "0x72", "0x73", "0x74", "0x75", "0x76", "0x77", "0x78", "0x79", "0x7a", "0x7b", "0x7c", "0x7d", "0x7e", "0x7f",
		"0x80", "0x81", "0x82", "0x83", "0x84", "0x85", "0x86", "0x87", "0x88", "0x89", "0x8a", "0x8b", "0x8c", "0x8d", "0x8e", "0x8f",
		"0x90", "0x91", "0x92", "0x93", "0x94", "0x95", "0x96", "0x97", "0x98", "0x99", "0x9a", "0x9b", "0x9c", "0x9d", "0x9e", "0x9f",
		"0xa0", "0xa1", "0xa2", "0xa3", "0xa4", "0xa5", "0xa6", "0xa7", "0xa8", "0xa9", "0xaa", "0xab", "0xac", "0xad", "0xae", "0xaf",
		"0xb0", "0xb1", "0xb2", "0xb3", "0xb4", "0xb5", "0xb6", "0xb7", "0xb8", "0xb9", "0xba", "0xbb", "0xbc", "0xbd", "0xbe", "0xbf",
		"0xc0", "0xc1", "0xc2", "0xc3", "0xc4", "0xc5", "0xc6", "0xc7", "0xc8", "0xc9", "0xca", "0xcb", "0xcc", "0xcd", "0xce", "0xcf",
		"0xd0", "0xd1", "0xd2", "0xd3", "0xd4", "0xd5", "0xd6", "0xd7", "0xd8", "0xd9", "0xda", "0xdb", "0xdc", "0xdd", "0xde", "0xdf",
		"0xe0", "0xe1", "0xe2", "0xe3", "0xe4", "0xe5", "0xe6", "0xe7", "0xe8", "0xe9", "0xea", "0xeb", "0xec", "0xed", "0xee", "0xef",
		"0xf0", "0xf1", "0xf2", "0xf3", "0xf4", "0xf5", "0xf6", "0xf7", "0xf8", "0xf9", "0xfa", "0xfb", "0xfc", "0xfd", "0xfe", "0xff"
	};

	if (x < 0x10) {	/* < 0x10 has a fixed length of 4 including null terminate. */
		memcpy(&s->p[s->length], TextHBTable[x & 255], 4);
		s->length += 3;
	} else { /* >= 0x10 has a fixed length of 5 including null terminate. */
		memcpy(&s->p[s->length], TextHBTable[x & 255], 5);
		s->length += 4;
	}
}

void _FASTCALL_ str_code_hdw(_WString* s, uint32_t x)
{
	int8_t* buf;
	int i = 0, shift = 0;
	unsigned int t = 0;

	buf = (int8_t*)&s->p[s->length];

	buf[0] = '0';
	buf[1] = 'x';
	buf += 2;

	for (shift = 28; shift != 0; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}
	t = x & 0xf;
	buf[i++] = NIBBLE_TO_CHR;

	s->length += i + 2;
	buf[i] = '\0';
}

void _FASTCALL_ str_code_hqw(_WString* s, uint8_t src[8])
{
	int8_t* buf;
	int i = 0, shift = 0;
	uint32_t x = RULONG(&src[sizeof(int32_t)]);
	int t;

	buf = (int8_t*)&s->p[s->length];
	buf[0] = '0';
	buf[1] = 'x';
	buf += 2;

	for (shift = 28; shift != -4; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}

	x = RULONG(src);
	for (shift = 28; shift != 0; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}
	t = x & 0xf;
	buf[i++] = NIBBLE_TO_CHR;

	s->length += i + 2;
	buf[i] = '\0';
}

#ifdef SUPPORT_64BIT_OFFSET
void _FASTCALL_ str_off64(_WString* s, OFFSET_INTEGER x)
{
	int8_t* buf;
	int i = 0, shift = 0;
	OFFSET_INTEGER t = 0;

	buf = (int8_t*)&s->p[s->length];

	buf[0] = '0';
	buf[1] = 'x';
	buf += 2;

	for (shift = 60; shift != 0; shift -= 4) {
		t = (x >> shift) & 0xf;
		if (i | t) buf[i++] = NIBBLE_TO_CHR;
	}
	t = x & 0xf;
	buf[i++] = NIBBLE_TO_CHR;

	s->length += i + 2;
	buf[i] = '\0';
}
#endif /* SUPPORT_64BIT_OFFSET */

#endif /* DISTORM_LIGHT */



================================================
File: 3rdparty/distorm/textdefs.h
================================================
/*
textdefs.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef TEXTDEFS_H
#define TEXTDEFS_H

#include "config.h"
#include "wstring.h"

#ifndef DISTORM_LIGHT

#define PLUS_DISP_CHR '+'
#define MINUS_DISP_CHR '-'
#define OPEN_CHR '['
#define CLOSE_CHR ']'
#define SP_CHR ' '
#define SEG_OFF_CHR ':'

/*
Naming Convention:

* get - returns a pointer to a string.
* str - concatenates to string.

* hex - means the function is used for hex dump (number is padded to required size) - Little Endian output.
* code - means the function is used for disassembled instruction - Big Endian output.
* off - means the function is used for 64bit offset - Big Endian output.

* h - '0x' in front of the string.

* b - byte
* dw - double word (can be used for word also)
* qw - quad word

* all numbers are in HEX.
*/

void _FASTCALL_ str_hex_b(_WString* s, unsigned int x);
void _FASTCALL_ str_code_hb(_WString* s, unsigned int x);
void _FASTCALL_ str_code_hdw(_WString* s, uint32_t x);
void _FASTCALL_ str_code_hqw(_WString* s, uint8_t src[8]);

#ifdef SUPPORT_64BIT_OFFSET
void _FASTCALL_ str_off64(_WString* s, OFFSET_INTEGER x);
#endif

#endif /* DISTORM_LIGHT */

#endif /* TEXTDEFS_H */



================================================
File: 3rdparty/distorm/wstring.c
================================================
/*
wstring.c

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#include "wstring.h"

#ifndef DISTORM_LIGHT

void strclear_WS(_WString* s)
{
	s->p[0] = '\0';
	s->length = 0;
}

void chrcat_WS(_WString* s, uint8_t ch)
{
	s->p[s->length] = ch;
	s->p[s->length + 1] = '\0';
	s->length += 1;
}

void strcpylen_WS(_WString* s, const int8_t* buf, unsigned int len)
{
	s->length = len;
	memcpy((int8_t*)s->p, buf, len + 1);
}

void strcatlen_WS(_WString* s, const int8_t* buf, unsigned int len)
{
	memcpy((int8_t*)&s->p[s->length], buf, len + 1);
	s->length += len;
}

void strcat_WS(_WString* s, const _WString* s2)
{
	memcpy((int8_t*)&s->p[s->length], s2->p, s2->length + 1);
	s->length += s2->length;
}

#endif /* DISTORM_LIGHT */



================================================
File: 3rdparty/distorm/wstring.h
================================================
/*
wstring.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef WSTRING_H
#define WSTRING_H

#include "config.h"

#ifndef DISTORM_LIGHT

void strclear_WS(_WString* s);
void chrcat_WS(_WString* s, uint8_t ch);
void strcpylen_WS(_WString* s, const int8_t* buf, unsigned int len);
void strcatlen_WS(_WString* s, const int8_t* buf, unsigned int len);
void strcat_WS(_WString* s, const _WString* s2);

/*
* Warning, this macro should be used only when the compiler knows the size of string in advance!
* This macro is used in order to spare the call to strlen when the strings are known already.
* Note: sizeof includes NULL terminated character.
*/
#define strcat_WSN(s, t) strcatlen_WS((s), ((const int8_t*)t), sizeof((t))-1)
#define strcpy_WSN(s, t) strcpylen_WS((s), ((const int8_t*)t), sizeof((t))-1)

#endif /* DISTORM_LIGHT */

#endif /* WSTRING_H */



================================================
File: 3rdparty/distorm/x86defs.h
================================================
/*
x86defs.h

diStorm3 - Powerful disassembler for X86/AMD64
http://ragestorm.net/distorm/
distorm at gmail dot com
Copyright (C) 2003-2016 Gil Dabah
This library is licensed under the BSD license. See the file COPYING.
*/


#ifndef X86DEFS_H
#define X86DEFS_H


#define SEG_REGS_MAX (6)
#define CREGS_MAX (9)
#define DREGS_MAX (8)

/* Maximum instruction size, including prefixes */
#define INST_MAXIMUM_SIZE (15)

/* Maximum range of imm8 (comparison type) of special SSE CMP instructions. */
#define INST_CMP_MAX_RANGE (8)

/* Maximum range of imm8 (comparison type) of special AVX VCMP instructions. */
#define INST_VCMP_MAX_RANGE (32)

/* Wait instruction byte code. */
#define INST_WAIT_INDEX (0x9b)

/* Lea instruction byte code. */
#define INST_LEA_INDEX (0x8d)

/* NOP/XCHG instruction byte code. */
#define INST_NOP_INDEX (0x90)

/* ARPL/MOVSXD instruction byte code. */
#define INST_ARPL_INDEX (0x63)

/*
 * Minimal MODR/M value of divided instructions.
 * It's 0xc0, two MSBs set, which indicates a general purpose register is used too.
 */
#define INST_DIVIDED_MODRM (0xc0)

/* This is the escape byte value used for 3DNow! instructions. */
#define _3DNOW_ESCAPE_BYTE (0x0f)

#define PREFIX_LOCK (0xf0)
#define PREFIX_REPNZ (0xf2)
#define PREFIX_REP (0xf3)
#define PREFIX_CS (0x2e)
#define PREFIX_SS (0x36)
#define PREFIX_DS (0x3e)
#define PREFIX_ES (0x26)
#define PREFIX_FS (0x64)
#define PREFIX_GS (0x65)
#define PREFIX_OP_SIZE (0x66)
#define PREFIX_ADDR_SIZE (0x67)
#define PREFIX_VEX2b (0xc5)
#define PREFIX_VEX3b (0xc4)

/* REX prefix value range, 64 bits mode decoding only. */
#define PREFIX_REX_LOW (0x40)
#define PREFIX_REX_HI (0x4f)
/* In order to use the extended GPR's we have to add 8 to the Modr/M info values. */
#define EX_GPR_BASE (8)

/* Mask for REX and VEX features: */
/* Base */
#define PREFIX_EX_B (1)
/* Index */
#define PREFIX_EX_X (2)
/* Register */
#define PREFIX_EX_R (4)
/* Operand Width */
#define PREFIX_EX_W (8)
/* Vector Lengh */
#define PREFIX_EX_L (0x10)

#endif /* X86DEFS_H */



================================================
File: 3rdparty/ntdll/ntdll.h
================================================
#ifndef _NTDLL_H
#define _NTDLL_H

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef WIN32_NO_STATUS
#define WIN32_NO_STATUS
#endif
#include <Windows.h>
#undef WIN32_NO_STATUS
#include <ntstatus.h>
#include <intrin.h>

#define NT_SUCCESS(Status)			((NTSTATUS)(Status) >= 0)
#define NT_ERROR(Status)			((((ULONG)(Status)) >> 30) == 3)

#define FASTCALL __fastcall

#ifndef _Reserved_
#define _Reserved_
#endif

#if (defined(_MSC_VER) && (_MSC_VER >= 1800)) || defined(__clang__)
#if (!defined(__RESHARPER__)) && (!defined(__INTELLISENSE__))
#undef FIELD_OFFSET
#undef UFIELD_OFFSET
#define FIELD_OFFSET(type, field)	((LONG)(LONG_PTR)__builtin_offsetof(type, field))
#define UFIELD_OFFSET(type, field)	((ULONG)(LONG_PTR)__builtin_offsetof(type, field))
#endif
#endif

#define PAGE_SIZE					0x1000

#define ALIGN_DOWN(length, type) \
	((ULONG_PTR)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
	(ALIGN_DOWN(((ULONG_PTR)(length) + sizeof(type) - 1), type))

#define MIN(a,b)	(((a) < (b)) ? (a) : (b))
#define MAX(a,b)	(((a) > (b)) ? (a) : (b))

#if !defined (_countof)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif

typedef _Return_type_success_(return >= 0) LONG NTSTATUS, *PNTSTATUS;
typedef LONG KPRIORITY, *PKPRIORITY;
typedef ULONG LOGICAL, *PLOGICAL;

typedef enum _NT_PRODUCT_TYPE
{
	NtProductWinNt = 1,
	NtProductLanManNt,
	NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

typedef enum _SUITE_TYPE
{
	SmallBusiness,
	Enterprise,
	BackOffice,
	CommunicationServer,
	TerminalServer,
	SmallBusinessRestricted,
	EmbeddedNT,
	DataCenter,
	SingleUserTS,
	Personal,
	Blade,
	EmbeddedRestricted,
	SecurityAppliance,
	StorageServer,
	ComputeServer,
	WHServer,
	PhoneNT,
	MaxSuiteType
} SUITE_TYPE;

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

enum KPROCESSOR_MODE
{
	KernelMode,
	UserMode
};

typedef enum _KTHREAD_STATE
{
	Initialized,
	Ready,
	Running,
	Standby,
	Terminated,
	Waiting,
	Transition,
	DeferredReady,
	GateWaitObsolete,
	WaitingForProcessInSwap,
	MaximumThreadState
} KTHREAD_STATE, *PKTHREAD_STATE;

typedef enum _KWAIT_REASON
{
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	WrKeyedEvent,
	WrTerminated,
	WrProcessInSwap,
	WrCpuRateControl,
	WrCalloutStack,
	WrKernel,
	WrResource,
	WrPushLock,
	WrMutex,
	WrQuantumEnd,
	WrDispatchInt,
	WrPreempted,
	WrYieldExecution,
	WrFastMutex,
	WrGuardedMutex,
	WrRundown,
	WrAlertByThreadId,
	WrDeferredPreempt,
	WrPhysicalFault,
	MaximumWaitReason
} KWAIT_REASON;

typedef enum _EVENT_TYPE
{
	NotificationEvent,
	SynchronizationEvent
} EVENT_TYPE;

typedef enum _TIMER_TYPE
{
	NotificationTimer,
	SynchronizationTimer
} TIMER_TYPE;

typedef enum _WAIT_TYPE
{
	WaitAll,
	WaitAny,
	WaitNotification,
	WaitDequeue
} WAIT_TYPE;

typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT;

#define HARDERROR_OVERRIDE_ERRORMODE		0x10000000

typedef enum _HARDERROR_RESPONSE_OPTION
{
	OptionAbortRetryIgnore,
	OptionOk,
	OptionOkCancel,
	OptionRetryCancel,
	OptionYesNo,
	OptionYesNoCancel,
	OptionShutdownSystem,
	OptionOkNoWait,
	OptionCancelTryContinue
} HARDERROR_RESPONSE_OPTION, *PHARDERROR_RESPONSE_OPTION;

typedef enum _HARDERROR_RESPONSE
{
	ResponseReturnToCaller,
	ResponseNotHandled,
	ResponseAbort,
	ResponseCancel,
	ResponseIgnore,
	ResponseNo,
	ResponseOk,
	ResponseRetry,
	ResponseYes,
	ResponseTryAgain,
	ResponseContinue
} HARDERROR_RESPONSE, *PHARDERROR_RESPONSE;

typedef struct _UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

#define DECLARE_UNICODE_STRING_SIZE(_var, _size) \
WCHAR _var ## _buffer[_size]; \
__pragma(warning(push)) \
__pragma(warning(disable:4221)) __pragma(warning(disable:4204)) \
UNICODE_STRING _var = { 0, (_size) * sizeof(WCHAR) , _var ## _buffer } \
__pragma(warning(pop))

#define DECLARE_STATIC_UNICODE_STRING_SIZE(_var, _size) \
WCHAR _var ## _buffer[_size]; \
__pragma(warning(push)) \
__pragma(warning(disable:4221)) __pragma(warning(disable:4204)) \
static UNICODE_STRING _var = { 0, (_size) * sizeof(WCHAR) , _var ## _buffer } \
__pragma(warning(pop))

#if defined(__clang__)
#define RTL_CONSTANT_STRING(s) \
__pragma(clang diagnostic push) \
__pragma(clang diagnostic ignored "-Wwritable-strings") \
{ sizeof(s) - sizeof((s)[0]), sizeof(s), s } \
__pragma(clang diagnostic pop)
#else
#define RTL_CONSTANT_STRING(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), (PWSTR)s }
#define RTL_CONSTANT_ANSI_STRING(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), (PSTR)s }
#endif

FORCEINLINE
VOID
RtlInitEmptyUnicodeString(
	_Out_ PUNICODE_STRING UnicodeString,
	_In_ PWCHAR Buffer,
	_In_ USHORT BufferSize)
{
	UnicodeString->Length = 0;
	UnicodeString->MaximumLength = BufferSize;
	UnicodeString->Buffer = Buffer;
}

typedef struct _STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PCHAR Buffer;
} STRING, *PSTRING, ANSI_STRING, *PANSI_STRING, OEM_STRING, *POEM_STRING;
typedef const STRING *PCSTRING, *PCANSI_STRING, *PCOEM_STRING;

typedef struct _SYSTEM_SESSION_PROCESS_INFORMATION
{
	ULONG SessionId;
	ULONG SizeOfBuf;
	PVOID Buffer;
} SYSTEM_SESSION_PROCESS_INFORMATION, *PSYSTEM_SESSION_PROCESS_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
	BOOLEAN KernelDebuggerEnabled;
	BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
{
	BOOLEAN DebuggerAllowed;
	BOOLEAN DebuggerEnabled;
	BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

typedef struct _LDT_INFORMATION
{
	ULONG Start;
	ULONG Length;
	LDT_ENTRY LdtEntries[1];
} PROCESS_LDT_INFORMATION, *PPROCESS_LDT_INFORMATION;

typedef struct _KERNEL_USER_TIMES
{
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER ExitTime;
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
} KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize; // Since Vista
	ULONG HardFaultCount; // Since Windows 7
	ULONG NumberOfThreadsHighWatermark; // Since Windows 7
	ULONGLONG CycleTime; // Since Windows 7
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey; // Since Vista (requires SystemExtendedProcessInformation)
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1]; // SystemProcessInformation
	// SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; // SystemExtendedProcessinformation
	// SYSTEM_EXTENDED_THREAD_INFORMATION + SYSTEM_PROCESS_INFORMATION_EXTENSION // SystemFullProcessInformation
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _PROCESS_SESSION_INFORMATION
{
	ULONG SessionId;
} PROCESS_SESSION_INFORMATION, *PPROCESS_SESSION_INFORMATION;

// File attribute values
#define FILE_ATTRIBUTE_READONLY					0x00000001
#define FILE_ATTRIBUTE_HIDDEN					0x00000002
#define FILE_ATTRIBUTE_SYSTEM					0x00000004

#define FILE_ATTRIBUTE_DIRECTORY				0x00000010
#define FILE_ATTRIBUTE_ARCHIVE					0x00000020
#define FILE_ATTRIBUTE_DEVICE					0x00000040
#define FILE_ATTRIBUTE_NORMAL					0x00000080

#define FILE_ATTRIBUTE_TEMPORARY				0x00000100
#define FILE_ATTRIBUTE_SPARSE_FILE				0x00000200
#define FILE_ATTRIBUTE_REPARSE_POINT			0x00000400
#define FILE_ATTRIBUTE_COMPRESSED				0x00000800

#define FILE_ATTRIBUTE_OFFLINE					0x00001000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED		0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED				0x00004000

#define FILE_ATTRIBUTE_INTEGRITY_STREAM			0x00008000
#define FILE_ATTRIBUTE_VIRTUAL					0x00010000
#define FILE_ATTRIBUTE_NO_SCRUB_DATA			0x00020000

#define FILE_ATTRIBUTE_EA						0x00040000
#define FILE_ATTRIBUTE_PINNED					0x00080000
#define FILE_ATTRIBUTE_UNPINNED					0x00100000
#define FILE_ATTRIBUTE_RECALL_ON_OPEN			0x00040000
#define FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS	0x00400000

#if NTDDI_VERSION < NTDDI_WIN8
#define FILE_ATTRIBUTE_VALID_FLAGS				0x00007fb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS			0x000031a7
#elif NTDDI_VERSION < NTDDI_WIN10_RS2
#define FILE_ATTRIBUTE_VALID_FLAGS				0x0002ffb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS			0x000231a7
#else
#define FILE_ATTRIBUTE_VALID_FLAGS				0x005affb7
#define FILE_ATTRIBUTE_VALID_SET_FLAGS			0x001a31a7
#endif

// File create disposition values
#define FILE_SUPERSEDE							0x00000000
#define FILE_OPEN								0x00000001
#define FILE_CREATE								0x00000002
#define FILE_OPEN_IF							0x00000003
#define FILE_OVERWRITE							0x00000004
#define FILE_OVERWRITE_IF						0x00000005
#define FILE_MAXIMUM_DISPOSITION				0x00000005

// File create/open option flags
#define FILE_DIRECTORY_FILE						0x00000001
#define FILE_WRITE_THROUGH						0x00000002
#define FILE_SEQUENTIAL_ONLY					0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING			0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT				0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT			0x00000020
#define FILE_NON_DIRECTORY_FILE					0x00000040
#define FILE_CREATE_TREE_CONNECTION				0x00000080

#define FILE_COMPLETE_IF_OPLOCKED				0x00000100
#define FILE_NO_EA_KNOWLEDGE					0x00000200
#define FILE_OPEN_FOR_RECOVERY					0x00000400
#define FILE_RANDOM_ACCESS						0x00000800

#define FILE_DELETE_ON_CLOSE					0x00001000
#define FILE_OPEN_BY_FILE_ID					0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT				0x00004000
#define FILE_NO_COMPRESSION						0x00008000

#if NTDDI_VERSION >= NTDDI_WIN7
#define FILE_OPEN_REQUIRING_OPLOCK				0x00010000
#define FILE_DISALLOW_EXCLUSIVE					0x00020000
#endif
#if NTDDI_VERSION >= NTDDI_WIN8
#define FILE_SESSION_AWARE						0x00040000
#endif

#define FILE_RESERVE_OPFILTER					0x00100000
#define FILE_OPEN_REPARSE_POINT					0x00200000
#define FILE_OPEN_NO_RECALL						0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY			0x00800000

#define FILE_VALID_OPTION_FLAGS					0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS			0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS		0x00000032
#define FILE_VALID_SET_FLAGS					0x00000036

// Named pipe type flags
#define FILE_PIPE_BYTE_STREAM_TYPE				0x00000000
#define FILE_PIPE_MESSAGE_TYPE					0x00000001
#define FILE_PIPE_ACCEPT_REMOTE_CLIENTS			0x00000000
#define FILE_PIPE_REJECT_REMOTE_CLIENTS			0x00000002
#define FILE_PIPE_TYPE_VALID_MASK				0x00000003

// Named pipe completion mode flags
#define FILE_PIPE_QUEUE_OPERATION				0x00000000
#define FILE_PIPE_COMPLETE_OPERATION			0x00000001

// Named pipe read mode flags
#define FILE_PIPE_BYTE_STREAM_MODE				0x00000000
#define FILE_PIPE_MESSAGE_MODE					0x00000001

// NamedPipeConfiguration flags
#define FILE_PIPE_INBOUND						0x00000000
#define FILE_PIPE_OUTBOUND						0x00000001
#define FILE_PIPE_FULL_DUPLEX					0x00000002

// NamedPipeState flags
#define FILE_PIPE_DISCONNECTED_STATE			0x00000001
#define FILE_PIPE_LISTENING_STATE				0x00000002
#define FILE_PIPE_CONNECTED_STATE				0x00000003
#define FILE_PIPE_CLOSING_STATE					0x00000004

// NamedPipeEnd flags
#define FILE_PIPE_CLIENT_END					0x00000000
#define FILE_PIPE_SERVER_END					0x00000001

typedef struct _FILE_BASIC_INFORMATION {
	LARGE_INTEGER CreationTime;
	LARGE_INTEGER LastAccessTime;
	LARGE_INTEGER LastWriteTime;
	LARGE_INTEGER ChangeTime;
	ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION {
	LARGE_INTEGER AllocationSize;
	LARGE_INTEGER EndOfFile;
	ULONG NumberOfLinks;
	BOOLEAN DeletePending;
	BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION
{
	LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

// Privileges
#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_CREATE_SYMBOLIC_LINK_PRIVILEGE

typedef struct _THREAD_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PVOID TebBaseAddress;
	CLIENT_ID ClientId;
	ULONG_PTR AffinityMask;
	KPRIORITY Priority;
	LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

typedef struct _MEMORY_REGION_INFORMATION
{
	PVOID AllocationBase;
	ULONG AllocationProtect;
	union
	{
		ULONG RegionType;
		struct
		{
			ULONG Private : 1;
			ULONG MappedDataFile : 1;
			ULONG MappedImage : 1;
			ULONG MappedPageFile : 1;
			ULONG MappedPhysical : 1;
			ULONG DirectMapped : 1;
			ULONG SoftwareEnclave : 1; //REDSTONE3
			ULONG PageSize64K : 1;
			ULONG Reserved : 24;
		} s;
	} u;
	SIZE_T RegionSize;
	SIZE_T CommitSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _MEMORY_IMAGE_INFORMATION
{
	PVOID ImageBase;
	SIZE_T SizeOfImage;
	union
	{
		ULONG ImageFlags;
		struct
		{
			ULONG ImagePartialMap : 1;
			ULONG ImageNotExecutable : 1;
			ULONG ImageSigningLevel : 1; // REDSTONE3
			ULONG Reserved : 30;
		} s1;
	} u1;
} MEMORY_IMAGE_INFORMATION, *PMEMORY_IMAGE_INFORMATION;

typedef struct _SECTION_BASIC_INFORMATION
{
	PVOID BaseAddress;
	ULONG AllocationAttributes;
	LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION
{
	PVOID TransferAddress; // Entry point
	ULONG ZeroBits;
	SIZE_T MaximumStackSize;
	SIZE_T CommittedStackSize;
	ULONG SubSystemType;
	union
	{
		struct
		{
			USHORT SubSystemMinorVersion;
			USHORT SubSystemMajorVersion;
		} s1;
		ULONG SubSystemVersion;
	} u1;
	union
	{
		struct
		{
			USHORT MajorOperatingSystemVersion;
			USHORT MinorOperatingSystemVersion;
		} s2;
		ULONG OperatingSystemVersion;
	} u2;
	USHORT ImageCharacteristics;
	USHORT DllCharacteristics;
	USHORT Machine;
	BOOLEAN ImageContainsCode;
	union
	{
		UCHAR ImageFlags;
		struct
		{
			UCHAR ComPlusNativeReady : 1;
			UCHAR ComPlusILOnly : 1;
			UCHAR ImageDynamicallyRelocated : 1;
			UCHAR ImageMappedFlat : 1;
			UCHAR BaseBelow4gb : 1;
			UCHAR ComPlusPrefer32bit : 1;
			UCHAR Reserved : 2;
		} s3;
	} u3;
	ULONG LoaderFlags;
	ULONG ImageFileSize;
	ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION
{
	SECTION_IMAGE_INFORMATION SectionInformation;
	union
	{
		ULONG ExtendedFlags;
		struct
		{
			ULONG ImageExportSuppressionEnabled : 1;
			ULONG Reserved : 31;
		} s;
	} u;
} SECTION_INTERNAL_IMAGE_INFORMATION, *PSECTION_INTERNAL_IMAGE_INFORMATION;

typedef struct _IMAGE_INFO
{
	union
	{
		ULONG Properties;
		struct
		{
			ULONG ImageAddressingMode	: 8;  // Code addressing mode
			ULONG SystemModeImage		: 1;  // System mode image
			ULONG ImageMappedToAllPids	: 1;  // Image mapped into all processes
			ULONG ExtendedInfoPresent	: 1;  // IMAGE_INFO_EX available
			ULONG MachineTypeMismatch	: 1;  // Architecture type mismatch
			ULONG ImageSignatureLevel	: 4;  // Signature level
			ULONG ImageSignatureType	: 3;  // Signature type
			ULONG ImagePartialMap		: 1;  // Nonzero if entire image is not mapped
			ULONG Reserved				: 12;
		} s1;
	} u1;
	PVOID	ImageBase;
	ULONG	ImageSelector;
	SIZE_T	ImageSize;
	ULONG	ImageSectionNumber;
} IMAGE_INFO, *PIMAGE_INFO;

typedef struct _PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION
{
	ULONG Version; // Set to 0 for x64, 1 for native x86, and use as PVOID Callback on WOW64
	ULONG Reserved;
	PVOID Callback;
} PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION, *PPROCESS_INSTRUMENTATION_CALLBACK_INFORMATION;

typedef struct _THREAD_LAST_SYSCALL_INFORMATION
{
	PVOID FirstArgument;
	USHORT SystemCallNumber;
#if NTDDI_VERSION >= NTDDI_WINBLUE
	ULONG64 WaitTime; // may be omitted
#endif
} THREAD_LAST_SYSCALL_INFORMATION, *PTHREAD_LAST_SYSCALL_INFORMATION;

typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;
	PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT			0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN							0x00000002

#define LDR_GET_PROCEDURE_ADDRESS_EX_DONT_RECORD_FORWARDER	0x00000001

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS			0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY					0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID			0
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED		1
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED	2

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS			0x00000001

typedef struct _LDR_RESOURCE_INFO
{
	ULONG_PTR Type;
	ULONG_PTR Name;
	ULONG_PTR Language;
} LDR_RESOURCE_INFO, *PLDR_RESOURCE_INFO;

typedef struct _LDR_ENUM_RESOURCE_INFO
{
	ULONG_PTR Type;
	ULONG_PTR Name;
	ULONG_PTR Language;
	PVOID Data;
	SIZE_T Size;
	ULONG_PTR Reserved;
} LDR_ENUM_RESOURCE_INFO, *PLDR_ENUM_RESOURCE_INFO;

#define LDR_FIND_RESOURCE_LANGUAGE_CAN_FALLBACK				0x00000000
#define LDR_FIND_RESOURCE_LANGUAGE_EXACT					0x00000004
#define LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION			0x00000008

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX
{
	USHORT NextOffset;
	RTL_PROCESS_MODULE_INFORMATION BaseInfo;
	ULONG ImageChecksum;
	ULONG TimeDateStamp;
	PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION
{
	ULONG Length;
	ULONG CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

#define CODEINTEGRITY_OPTION_ENABLED						0x1
#define CODEINTEGRITY_OPTION_TESTSIGN						0x2
#define CODEINTEGRITY_OPTION_UMCI_ENABLED					0x4
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED			0x8
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED	0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD						0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD			0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED				0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD					0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED				0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED				0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED	0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED	0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED				0x2000

#if NTDDI_VERSION >= NTDDI_VISTA
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION
{
	GUID BootIdentifier;
	FIRMWARE_TYPE FirmwareType;
	ULONGLONG BootFlags;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;
#endif

typedef struct _SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
{
	ULONG Options;
	ULONG HVCIOptions;
	ULONGLONG Version;
	GUID PolicyGuid;
} SYSTEM_CODEINTEGRITYPOLICY_INFORMATION, *PSYSTEM_CODEINTEGRITYPOLICY_INFORMATION;

typedef struct _SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
{
	HANDLE ImageFile;
} SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION, *PSYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION;

typedef struct _SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION
{
	union
	{
		ULONG Flags;
		struct
		{
			ULONG Locked : 1;
			ULONG Unlockable : 1;
			ULONG UnlockApplied : 1;
			ULONG Reserved : 29;
		} s1;
	} u1;
} SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION, *PSYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION;

typedef
NTSTATUS
NTAPI
RTL_QUERY_REGISTRY_ROUTINE(
	_In_z_ PWSTR ValueName,
	_In_ ULONG ValueType,
	_In_opt_ PVOID ValueData,
	_In_ ULONG ValueLength,
	_In_opt_ PVOID Context,
	_In_opt_ PVOID EntryContext
	);
typedef RTL_QUERY_REGISTRY_ROUTINE *PRTL_QUERY_REGISTRY_ROUTINE;

typedef struct _RTL_QUERY_REGISTRY_TABLE
{
	PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
	ULONG Flags;
	PWSTR Name;
	PVOID EntryContext;
	ULONG DefaultType;
	PVOID DefaultData;
	ULONG DefaultLength;
} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;

// RtlQueryRegistryValues flags
#define RTL_QUERY_REGISTRY_SUBKEY			0x00000001
#define RTL_QUERY_REGISTRY_TOPKEY			0x00000002
#define RTL_QUERY_REGISTRY_REQUIRED			0x00000004
#define RTL_QUERY_REGISTRY_NOVALUE			0x00000008
#define RTL_QUERY_REGISTRY_NOEXPAND			0x00000010
#define RTL_QUERY_REGISTRY_DIRECT			0x00000020
#define RTL_QUERY_REGISTRY_DELETE			0x00000040
#define RTL_QUERY_REGISTRY_NOSTRING			0x00000080
#define RTL_QUERY_REGISTRY_TYPECHECK		0x00000100

#define RTL_QUERY_REGISTRY_TYPECHECK_SHIFT	24
#define RTL_QUERY_REGISTRY_TYPECHECK_MASK	(0xff << RTL_QUERY_REGISTRY_TYPECHECK_SHIFT)

// RtlWriteRegistryValue RelativeTo values
#define RTL_REGISTRY_ABSOLUTE				0			// Path is a full path
#define RTL_REGISTRY_SERVICES				1			// \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL				2			// \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT				3			// \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP				4			// \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER					5			// \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM				6
#define RTL_REGISTRY_HANDLE					0x40000000	// Low order bits are registry handle
#define RTL_REGISTRY_OPTIONAL				0x80000000	// Indicates the key node is optional

typedef struct _PROCESS_HANDLE_INFORMATION
{
	ULONG HandleCount;
	ULONG HandleCountHighWatermark;
} PROCESS_HANDLE_INFORMATION, *PPROCESS_HANDLE_INFORMATION;

#if NTDDI_VERSION >= NTDDI_VISTA
typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION
{
	PROCESS_MITIGATION_POLICY Policy;
	union
	{
		PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
		PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
		PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY SystemCallDisablePolicy;
		PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
		PROCESS_MITIGATION_DYNAMIC_CODE_POLICY DynamicCodePolicy;
		PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY ControlFlowGuardPolicy;
		PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY SignaturePolicy;
		PROCESS_MITIGATION_FONT_DISABLE_POLICY FontDisablePolicy;
		PROCESS_MITIGATION_IMAGE_LOAD_POLICY ImageLoadPolicy;
		PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY SystemCallFilterPolicy;
		PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY PayloadRestrictionPolicy;
		PROCESS_MITIGATION_CHILD_PROCESS_POLICY ChildProcessPolicy;
	};
} PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;
#endif

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
{
	PVOID Object;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG_PTR NumberOfHandles;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef struct _OBJECT_BASIC_INFORMATION
{
	ULONG Attributes;
	ACCESS_MASK GrantedAccess;
	ULONG HandleCount;
	ULONG PointerCount;
	ULONG PagedPoolCharge;
	ULONG NonPagedPoolCharge;
	ULONG Reserved[ 3 ];
	ULONG NameInfoSize;
	ULONG TypeInfoSize;
	ULONG SecurityDescriptorSize;
	LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION
{
	UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	UCHAR TypeIndex; // Since Windows 8.1
	CHAR ReservedByte;
	ULONG PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPES_INFORMATION
{
	ULONG NumberOfTypes;
	OBJECT_TYPE_INFORMATION TypeInformation[1];
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
{
	BOOLEAN Inherit;
	BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

typedef struct _DBGKM_EXCEPTION
{
	EXCEPTION_RECORD ExceptionRecord;
	ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;

typedef struct _DBGKM_CREATE_THREAD
{
	ULONG SubSystemKey;
	PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS
{
	ULONG SubSystemKey;
	HANDLE FileHandle;
	PVOID BaseOfImage;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD
{
	NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS
{
	NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL
{
	HANDLE FileHandle;
	PVOID BaseOfDll;
	ULONG DebugInfoFileOffset;
	ULONG DebugInfoSize;
	PVOID NamePointer;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL
{
	PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef enum _DBG_STATE
{
	DbgIdle,
	DbgReplyPending,
	DbgCreateThreadStateChange,
	DbgCreateProcessStateChange,
	DbgExitThreadStateChange,
	DbgExitProcessStateChange,
	DbgExceptionStateChange,
	DbgBreakpointStateChange,
	DbgSingleStepStateChange,
	DbgLoadDllStateChange,
	DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

typedef struct _DBGUI_CREATE_THREAD
{
	HANDLE HandleToThread;
	DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS
{
	HANDLE HandleToProcess;
	HANDLE HandleToThread;
	DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE
{
	DBG_STATE NewState;
	CLIENT_ID AppClientId;
	union
	{
		DBGKM_EXCEPTION Exception;
		DBGUI_CREATE_THREAD CreateThread;
		DBGUI_CREATE_PROCESS CreateProcessInfo;
		DBGKM_EXIT_THREAD ExitThread;
		DBGKM_EXIT_PROCESS ExitProcess;
		DBGKM_LOAD_DLL LoadDll;
		DBGKM_UNLOAD_DLL UnloadDll;
	} StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

typedef struct _DBGSS_THREAD_DATA
{
	struct _DBGSS_THREAD_DATA *Next;
	HANDLE ThreadHandle;
	HANDLE ProcessHandle;
	ULONG ProcessId;
	ULONG ThreadId;
	BOOLEAN HandleMarked;
} DBGSS_THREAD_DATA, *PDBGSS_THREAD_DATA;

#define DbgSsSetThreadData(d) \
	NtCurrentTeb()->DbgSsReserved[0] = d

#define DbgSsGetThreadData() \
	((PDBGSS_THREAD_DATA)NtCurrentTeb()->DbgSsReserved[0])

typedef USHORT RTL_ATOM, *PRTL_ATOM;
typedef long SECURITY_STATUS;

typedef struct _RTL_SPLAY_LINKS
{
	struct _RTL_SPLAY_LINKS *Parent;
	struct _RTL_SPLAY_LINKS *LeftChild;
	struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS, *PRTL_SPLAY_LINKS;

#define RtlInitializeSplayLinks(Links) \
{ \
	PRTL_SPLAY_LINKS _SplayLinks; \
	_SplayLinks = (PRTL_SPLAY_LINKS)(Links); \
	_SplayLinks->Parent = _SplayLinks; \
	_SplayLinks->LeftChild = NULL; \
	_SplayLinks->RightChild = NULL; \
}

typedef struct _PREFIX_TABLE_ENTRY
{
	SHORT NodeTypeCode;
	SHORT NameLength;
	struct _PREFIX_TABLE_ENTRY *NextPrefixTree;
	RTL_SPLAY_LINKS Links;
	PANSI_STRING Prefix;
} PREFIX_TABLE_ENTRY, *PPREFIX_TABLE_ENTRY;

typedef struct _PREFIX_TABLE
{
	SHORT NodeTypeCode;
	SHORT NameLength;
	PPREFIX_TABLE_ENTRY NextPrefixTree;
} PREFIX_TABLE, *PPREFIX_TABLE;

typedef struct _RTL_BITMAP
{
	ULONG SizeOfBitMap;
	PULONG Buffer;
} RTL_BITMAP, *PRTL_BITMAP;

typedef struct _RTL_BITMAP_RUN
{
	ULONG StartingIndex;
	ULONG NumberOfBits;
} RTL_BITMAP_RUN, *PRTL_BITMAP_RUN;

typedef enum
{
	RtlBsdItemVersionNumber = 0x00,
	RtlBsdItemProductType,
	RtlBsdItemAabEnabled,
	RtlBsdItemAabTimeout,
	RtlBsdItemBootGood,
	RtlBsdItemBootShutdown,
	RtlBsdItemMax
} RTL_BSD_ITEM_TYPE, *PRTL_BSD_ITEM_TYPE;

#define DUPLICATE_CLOSE_SOURCE		0x00000001
#define DUPLICATE_SAME_ACCESS		0x00000002
#define DUPLICATE_SAME_ATTRIBUTES	0x00000004

#define RTL_WALK_MAX_STACK_DEPTH	128

// These cannot be ORed together
#define RTL_WALK_KERNEL_MODE_STACK	0x00000000 // Kernel mode callers only
#define RTL_WALK_USER_MODE_STACK	0x00000001
#define RTL_WALK_TRACE_HANDLES		0x00000300

typedef struct _RTL_PROCESS_VERIFIER_OPTIONS
{
	ULONG SizeStruct;
	ULONG Option;
	UCHAR OptionData[1];
} RTL_PROCESS_VERIFIER_OPTIONS, *PRTL_PROCESS_VERIFIER_OPTIONS;

typedef struct _RTL_DEBUG_INFORMATION
{
	HANDLE SectionHandleClient;
	PVOID ViewBaseClient;
	PVOID ViewBaseTarget;
	ULONG_PTR ViewBaseDelta;
	HANDLE EventPairClient;
	HANDLE EventPairTarget;
	HANDLE TargetProcessId;
	HANDLE TargetThreadHandle;
	ULONG Flags;
	SIZE_T OffsetFree;
	SIZE_T CommitSize;
	SIZE_T ViewSize;
	union
	{
		PRTL_PROCESS_MODULES Modules;
		PRTL_PROCESS_MODULE_INFORMATION_EX ModulesEx;
	};
	struct _RTL_PROCESS_BACKTRACES *BackTraces;
	struct _RTL_PROCESS_HEAPS *Heaps;
	struct _RTL_PROCESS_LOCKS *Locks;
	PVOID SpecificHeap;
	HANDLE TargetProcessHandle;
	PRTL_PROCESS_VERIFIER_OPTIONS VerifierOptions;
	PVOID ProcessHeap;
	HANDLE CriticalSectionHandle;
	HANDLE CriticalSectionOwnerThread;
	PVOID Reserved[4];
} RTL_DEBUG_INFORMATION, *PRTL_DEBUG_INFORMATION;

typedef
VOID
(*PPS_APC_ROUTINE)(
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
	);

typedef struct _RTLP_CURDIR_REF *PRTLP_CURDIR_REF;

typedef struct _RTL_RELATIVE_NAME_U
{
	UNICODE_STRING RelativeName;
	HANDLE ContainingDirectory;
	PRTLP_CURDIR_REF CurDirRef;
} RTL_RELATIVE_NAME_U, *PRTL_RELATIVE_NAME_U;

typedef enum _RTL_PATH_TYPE
{
	RtlPathTypeUnknown,
	RtlPathTypeUncAbsolute,
	RtlPathTypeDriveAbsolute,
	RtlPathTypeDriveRelative,
	RtlPathTypeRooted,
	RtlPathTypeRelative,
	RtlPathTypeLocalDevice,
	RtlPathTypeRootLocalDevice,
} RTL_PATH_TYPE;

#define DOS_MAX_COMPONENT_LENGTH	255
#define DOS_MAX_PATH_LENGTH			(DOS_MAX_COMPONENT_LENGTH + 5)
#define NT_MAX_PATH_LENGTH			( (sizeof("\\??\\UNC\\") - sizeof(CHAR) ) + DOS_MAX_PATH_LENGTH + 1)

typedef struct _CURDIR
{
	UNICODE_STRING DosPath;
	HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR
{
	USHORT Flags;
	USHORT Length;
	ULONG TimeStamp;
	UNICODE_STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

typedef struct _LDR_SERVICE_TAG_RECORD
{
	struct _LDR_SERVICE_TAG_RECORD *Next;
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, *PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
	PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, *PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE
{
	LdrModulesMerged = -5,
	LdrModulesInitError = -4,
	LdrModulesSnapError = -3,
	LdrModulesUnloaded = -2,
	LdrModulesUnloading = -1,
	LdrModulesPlaceHolder = 0,
	LdrModulesMapping = 1,
	LdrModulesMapped = 2,
	LdrModulesWaitingForDependencies = 3,
	LdrModulesSnapping = 4,
	LdrModulesSnapped = 5,
	LdrModulesCondensed = 6,
	LdrModulesReadyToInit = 7,
	LdrModulesInitializing = 8,
	LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
	LIST_ENTRY Modules;
	PLDR_SERVICE_TAG_RECORD ServiceTagList;
	ULONG LoadCount;
	ULONG LoadWhileUnloadingCount;
	ULONG LowestLink;
	union
	{
		LDRP_CSLIST Dependencies;
		SINGLE_LIST_ENTRY RemovalLink;
	};
	LDRP_CSLIST IncomingDependencies;
	LDR_DDAG_STATE State;
	SINGLE_LIST_ENTRY CondenseLink;
	ULONG PreorderNumber;
} LDR_DDAG_NODE, *PLDR_DDAG_NODE;

typedef struct _LDR_DEPENDENCY_RECORD
{
	SINGLE_LIST_ENTRY DependencyLink;
	PLDR_DDAG_NODE DependencyNode;
	SINGLE_LIST_ENTRY IncomingDependencyLink;
	PLDR_DDAG_NODE IncomingDependencyNode;
} LDR_DEPENDENCY_RECORD, *PLDR_DEPENDENCY_RECORD;

typedef enum _LDR_DLL_LOAD_REASON
{
	LoadReasonStaticDependency,
	LoadReasonStaticForwarderDependency,
	LoadReasonDynamicForwarderDependency,
	LoadReasonDelayloadDependency,
	LoadReasonDynamicLoad,
	LoadReasonAsImageLoad,
	LoadReasonAsDataLoad,
	LoadReasonEnclavePrimary, // REDSTONE3
	LoadReasonEnclaveDependency,
	LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, *PLDR_DLL_LOAD_REASON;

#define LDRP_PACKAGED_BINARY			0x00000001
#define LDRP_IMAGE_DLL					0x00000004
#define LDRP_LOAD_IN_PROGRESS			0x00001000
#define LDRP_ENTRY_PROCESSED			0x00004000
#define LDRP_DONT_CALL_FOR_THREADS		0x00040000
#define LDRP_PROCESS_ATTACH_CALLED		0x00080000
#define LDRP_PROCESS_ATTACH_FAILED		0x00100000
#define LDRP_IMAGE_NOT_AT_BASE			0x00200000 // Vista and below
#define LDRP_COR_IMAGE					0x00400000
#define LDRP_DONT_RELOCATE				0x00800000
#define LDRP_REDIRECTED					0x10000000
#define LDRP_COMPAT_DATABASE_PROCESSED	0x80000000

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, DdagNode)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN7 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, BaseNameHashValue)
#define LDR_DATA_TABLE_ENTRY_SIZE_WIN8 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY, ImplicitPathOptions)

#define RTL_BALANCED_NODE_RESERVED_PARENT_MASK 3

typedef struct _RTL_BALANCED_NODE
{
	union
	{
		struct _RTL_BALANCED_NODE *Children[2];
		struct
		{
			struct _RTL_BALANCED_NODE *Left;
			struct _RTL_BALANCED_NODE *Right;
		} s;
	};
	union
	{
		UCHAR Red : 1;
		UCHAR Balance : 2;
		ULONG_PTR ParentValue;
	} u;
} RTL_BALANCED_NODE, *PRTL_BALANCED_NODE;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;
		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		} s;
	} u;
	USHORT ObsoleteLoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
	struct _ACTIVATION_CONTEXT *EntryPointActivationContext;
	PVOID Lock;
	PLDR_DDAG_NODE DdagNode;
	LIST_ENTRY NodeModuleLink;
	struct _LDRP_LOAD_CONTEXT *LoadContext;
	PVOID ParentDllBase;
	PVOID SwitchBackContext;
	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;
	ULONG_PTR OriginalBase;
	LARGE_INTEGER LoadTime;
	ULONG BaseNameHashValue;
	LDR_DLL_LOAD_REASON LoadReason;
	ULONG ImplicitPathOptions;
	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
	UCHAR SigningLevel; // Since Windows 10 RS2
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _INITIAL_TEB
{
	struct
	{
		PVOID OldStackBase;
		PVOID OldStackLimit;
	} OldInitialTeb;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID StackAllocationBase;
} INITIAL_TEB, *PINITIAL_TEB;

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		NTSTATUS Status;
		PVOID Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef
VOID
(NTAPI*
PIO_APC_ROUTINE)(
	_In_ PVOID ApcContext,
	_In_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG Reserved
	);

typedef struct _FILE_IO_COMPLETION_INFORMATION
{
	PVOID KeyContext;
	PVOID ApcContext;
	IO_STATUS_BLOCK IoStatusBlock;
} FILE_IO_COMPLETION_INFORMATION, *PFILE_IO_COMPLETION_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION
{
	HANDLE Port;
	PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

#ifdef __cplusplus
typedef enum _PRIORITY_CLASS : UCHAR
{
	Undefined,
	Idle,
	Normal,
	High,
	Realtime,
	BelowNormal,
	AboveNormal
} PRIORITY_CLASS;
#else
typedef UCHAR PRIORITY_CLASS;
#endif

typedef struct _PROCESS_PRIORITY_CLASS
{
	BOOLEAN Foreground;
	PRIORITY_CLASS PriorityClass;
} PROCESS_PRIORITY_CLASS, *PPROCESS_PRIORITY_CLASS;

typedef struct _PS_ATTRIBUTE {
	ULONG_PTR Attribute;				// PROC_THREAD_ATTRIBUTE_XXX | PROC_THREAD_ATTRIBUTE_XXX modifiers, see ProcThreadAttributeValue macro and Windows Internals 6 (372)
	SIZE_T Size;						// Size of Value or *ValuePtr
	union {
		ULONG_PTR Value;				// Reserve 8 bytes for data (such as a Handle or a data pointer)
		PVOID ValuePtr;					// data pointer
	};
	PSIZE_T ReturnLength;				// Either 0 or specifies size of data returned to caller via "ValuePtr"
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST {
	SIZE_T TotalLength;					// sizeof(PS_ATTRIBUTE_LIST) + <attribute count> * sizeof(PS_ATTRIBUTE)
	PS_ATTRIBUTE Attributes[1];			// Depends on how many attribute entries should be supplied to NtCreateUserProcess
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef struct _PS_MEMORY_RESERVE {
	PVOID ReserveAddress;
	SIZE_T ReserveSize;
} PS_MEMORY_RESERVE, *PPS_MEMORY_RESERVE;

#define PS_ATTRIBUTE_NUMBER_MASK	0x0000ffff
#define PS_ATTRIBUTE_THREAD			0x00010000 // Attribute may be used with thread creation
#define PS_ATTRIBUTE_INPUT			0x00020000 // Attribute is input only
#define PS_ATTRIBUTE_ADDITIVE		0x00040000 // Attribute may be "accumulated", e.g. bitmasks, counters, etc.

typedef enum _PS_ATTRIBUTE_NUM
{
	PsAttributeParentProcess,					// in HANDLE
	PsAttributeDebugPort,						// in HANDLE
	PsAttributeToken,							// in HANDLE
	PsAttributeClientId,						// out PCLIENT_ID
	PsAttributeTebAddress,						// out PTEB
	PsAttributeImageName,						// in PWSTR
	PsAttributeImageInfo,						// out PSECTION_IMAGE_INFORMATION
	PsAttributeMemoryReserve,					// in PPS_MEMORY_RESERVE
	PsAttributePriorityClass,					// in UCHAR
	PsAttributeErrorMode,						// in ULONG
	PsAttributeStdHandleInfo,					// in PPS_STD_HANDLE_INFO
	PsAttributeHandleList,						// in PHANDLE
	PsAttributeGroupAffinity,					// in PGROUP_AFFINITY
	PsAttributePreferredNode,					// in PUSHORT
	PsAttributeIdealProcessor,					// in PPROCESSOR_NUMBER
	PsAttributeUmsThread,						// see MSDN UpdateProceThreadAttributeList (CreateProcessW) - in PUMS_CREATE_THREAD_ATTRIBUTES
	PsAttributeMitigationOptions,				// in UCHAR
	PsAttributeProtectionLevel,					// in ULONG
	PsAttributeSecureProcess,					// since THRESHOLD (Virtual Secure Mode, Device Guard)
	PsAttributeJobList,
	PsAttributeChildProcessPolicy,				// since THRESHOLD2
	PsAttributeAllApplicationPackagesPolicy,	// since REDSTONE
	PsAttributeWin32kFilter,
	PsAttributeSafeOpenPromptOriginClaim,
	PsAttributeBnoIsolation,
	PsAttributeDesktopAppPolicy,
	PsAttributeChpe,							// since REDSTONE3
	PsAttributeMax
} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Additive) \
	(((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
	((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
	((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
	((Additive) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
	PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE) // 0x60000
#define PS_ATTRIBUTE_DEBUG_PORT \
	PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE) // 0x60001
#define PS_ATTRIBUTE_TOKEN \
	PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE) // 0x60002
#define PS_ATTRIBUTE_CLIENT_ID \
	PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE) // 0x10003
#define PS_ATTRIBUTE_TEB_ADDRESS \
	PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE) // 0x10004
#define PS_ATTRIBUTE_IMAGE_NAME \
	PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE) // 0x20005
#define PS_ATTRIBUTE_IMAGE_INFO \
	PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE) // 0x6
#define PS_ATTRIBUTE_MEMORY_RESERVE \
	PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE) // 0x20007
#define PS_ATTRIBUTE_PRIORITY_CLASS \
	PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE) // 0x20008
#define PS_ATTRIBUTE_ERROR_MODE \
	PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE) // 0x20009
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
	PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE) // 0x2000A
#define PS_ATTRIBUTE_HANDLE_LIST \
	PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE) // 0x2000B
#define PS_ATTRIBUTE_GROUP_AFFINITY \
	PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE) // 0x2000C
#define PS_ATTRIBUTE_PREFERRED_NODE \
	PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE) // 0x2000D
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
	PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE) // 0x2000E
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
	PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, TRUE) // 0x60010
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
	PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, FALSE) // 0x20011
#define PS_ATTRIBUTE_SECURE_PROCESS \
	PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE) // 0x20012
#define PS_ATTRIBUTE_JOB_LIST \
	PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE) // 0x20013
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
	PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE) // 0x20014
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
	PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE) // 0x20015
#define PS_ATTRIBUTE_WIN32K_FILTER \
	PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE) // 0x20016
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
	PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE) // 0x20017
#define PS_ATTRIBUTE_BNO_ISOLATION \
	PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE) // 0x20018
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
	PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE) // 0x20019

typedef enum _PS_STD_HANDLE_STATE {
	PsNeverDuplicate,
	PsRequestDuplicate, // Duplicate standard handles specified by PseudoHandleMask, and only if StdHandleSubsystemType matches the image subsystem
	PsAlwaysDuplicate, // Always duplicate standard handles
	PsMaxStdHandleStates
} PS_STD_HANDLE_STATE;

#define HANDLE_DETACHED_PROCESS		((HANDLE)-1)
#define HANDLE_CREATE_NEW_CONSOLE	((HANDLE)-2)
#define HANDLE_CREATE_NO_WINDOW		((HANDLE)-3)

#define PS_STD_INPUT_HANDLE			0x1
#define PS_STD_OUTPUT_HANDLE		0x2
#define PS_STD_ERROR_HANDLE			0x4

typedef struct _PS_STD_HANDLE_INFO
{
	union
	{
		ULONG Flags;
		struct
		{
			ULONG StdHandleState : 2; // PS_STD_HANDLE_STATE
			ULONG PseudoHandleMask : 3; // PS_STD_*
		} s;
	};
	ULONG StdHandleSubsystemType;
} PS_STD_HANDLE_INFO, *PPS_STD_HANDLE_INFO;

typedef struct _PS_BNO_ISOLATION_PARAMETERS
{
	UNICODE_STRING IsolationPrefix;
	ULONG HandleCount;
	PVOID *Handles;
	BOOLEAN IsolationEnabled;
} PS_BNO_ISOLATION_PARAMETERS, *PPS_BNO_ISOLATION_PARAMETERS;

typedef enum _PS_MITIGATION_OPTION
{
	PS_MITIGATION_OPTION_NX,
	PS_MITIGATION_OPTION_SEHOP,
	PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
	PS_MITIGATION_OPTION_HEAP_TERMINATE,
	PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
	PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
	PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
	PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
	PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
	PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
	PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
	PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
	PS_MITIGATION_OPTION_FONT_DISABLE,
	PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
	PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
	PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
	PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
	PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
	PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
	PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
	PS_MITIGATION_OPTION_ROP_STACKPIVOT, // since REDSTONE3
	PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
	PS_MITIGATION_OPTION_ROP_SIMEXEC,
	PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
	PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
	PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
	PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
	PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION
} PS_MITIGATION_OPTION;

typedef enum _PS_CREATE_STATE
{
	PsCreateInitialState,
	PsCreateFailOnFileOpen,
	PsCreateFailOnSectionCreate,
	PsCreateFailExeFormat,
	PsCreateFailMachineMismatch,
	PsCreateFailExeName, // Debugger specified
	PsCreateSuccess,
	PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO
{
	SIZE_T Size;
	PS_CREATE_STATE State;
	union
	{
		// PsCreateInitialState
		struct
		{
			union
			{
				ULONG InitFlags;
				struct
				{
					UCHAR WriteOutputOnExit : 1;
					UCHAR DetectManifest : 1;
					UCHAR IFEOSkipDebugger : 1;
					UCHAR IFEODoNotPropagateKeyState : 1;
					UCHAR SpareBits1 : 4;
					UCHAR SpareBits2 : 8;
					USHORT ProhibitedImageCharacteristics : 16;
				} s1;
			} u1;
			ACCESS_MASK AdditionalFileAccess;
		} InitState;

		// PsCreateFailOnSectionCreate
		struct
		{
			HANDLE FileHandle;
		} FailSection;

		// PsCreateFailExeFormat
		struct
		{
			USHORT DllCharacteristics;
		} ExeFormat;

		// PsCreateFailExeName
		struct
		{
			HANDLE IFEOKey;
		} ExeName;

		// PsCreateSuccess
		struct
		{
			union
			{
				ULONG OutputFlags;
				struct
				{
					UCHAR ProtectedProcess : 1;
					UCHAR AddressSpaceOverride : 1;
					UCHAR DevOverrideEnabled : 1; // From Image File Execution Options
					UCHAR ManifestDetected : 1;
					UCHAR ProtectedProcessLight : 1;
					UCHAR SpareBits1 : 3;
					UCHAR SpareBits2 : 8;
					USHORT SpareBits3 : 16;
				} s2;
			} u2;
			HANDLE FileHandle;
			HANDLE SectionHandle;
			ULONGLONG UserProcessParametersNative;
			ULONG UserProcessParametersWow64;
			ULONG CurrentParameterFlags;
			ULONGLONG PebAddressNative;
			ULONG PebAddressWow64;
			ULONGLONG ManifestAddress;
			ULONG ManifestSize;
		} SuccessState;
	};
} PS_CREATE_INFO, *PPS_CREATE_INFO;

#define PROCESS_CREATE_FLAGS_BREAKAWAY				0x00000001
#define PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT		0x00000002
#define PROCESS_CREATE_FLAGS_INHERIT_HANDLES		0x00000004
#define PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE 0x00000008
#define PROCESS_CREATE_FLAGS_LARGE_PAGES			0x00000010

// Only usable with NtCreateUserProcess (Vista+):
#define PROCESS_CREATE_FLAGS_LARGE_PAGE_SYSTEM_DLL	0x00000020
#define PROCESS_CREATE_FLAGS_PROTECTED_PROCESS		0x00000040 // Only allowed if the calling process is itself protected
#define PROCESS_CREATE_FLAGS_CREATE_SESSION			0x00000080
#define PROCESS_CREATE_FLAGS_INHERIT_FROM_PARENT	0x00000100
#define PROCESS_CREATE_FLAGS_SUSPENDED				0x00000200
#define PROCESS_CREATE_FLAGS_EXTENDED_UNKNOWN		0x00000400

typedef enum _MEMORY_RESERVE_TYPE
{
	MemoryReserveUserApc,
	MemoryReserveIoCompletion,
	MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

typedef struct _PROCESS_HANDLE_TRACING_ENABLE
{
	ULONG Flags;
} PROCESS_HANDLE_TRACING_ENABLE, *PPROCESS_HANDLE_TRACING_ENABLE;

#define PROCESS_HANDLE_TRACING_MAX_SLOTS 0x20000

typedef struct _PROCESS_HANDLE_TRACING_ENABLE_EX
{
	ULONG Flags;
	ULONG TotalSlots;
} PROCESS_HANDLE_TRACING_ENABLE_EX, *PPROCESS_HANDLE_TRACING_ENABLE_EX;

// Source: http://processhacker.sourceforge.net
typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation, // q: PROCESS_BASIC_INFORMATION, PROCESS_EXTENDED_BASIC_INFORMATION
	ProcessQuotaLimits, // qs: QUOTA_LIMITS, QUOTA_LIMITS_EX
	ProcessIoCounters, // q: IO_COUNTERS
	ProcessVmCounters, // q: VM_COUNTERS, VM_COUNTERS_EX, VM_COUNTERS_EX2
	ProcessTimes, // q: KERNEL_USER_TIMES
	ProcessBasePriority, // s: KPRIORITY
	ProcessRaisePriority, // s: ULONG
	ProcessDebugPort, // q: HANDLE
	ProcessExceptionPort, // s: HANDLE
	ProcessAccessToken, // s: PROCESS_ACCESS_TOKEN
	ProcessLdtInformation, // qs: PROCESS_LDT_INFORMATION // 10
	ProcessLdtSize, // s: PROCESS_LDT_SIZE
	ProcessDefaultHardErrorMode, // qs: ULONG
	ProcessIoPortHandlers, // (kernel-mode only)
	ProcessPooledUsageAndLimits, // q: POOLED_USAGE_AND_LIMITS
	ProcessWorkingSetWatch, // q: PROCESS_WS_WATCH_INFORMATION[]; s: void
	ProcessUserModeIOPL,
	ProcessEnableAlignmentFaultFixup, // s: BOOLEAN
	ProcessPriorityClass, // qs: PROCESS_PRIORITY_CLASS
	ProcessWx86Information,
	ProcessHandleCount, // q: ULONG, PROCESS_HANDLE_INFORMATION // 20
	ProcessAffinityMask, // s: KAFFINITY
	ProcessPriorityBoost, // qs: ULONG
	ProcessDeviceMap, // qs: PROCESS_DEVICEMAP_INFORMATION, PROCESS_DEVICEMAP_INFORMATION_EX
	ProcessSessionInformation, // q: PROCESS_SESSION_INFORMATION
	ProcessForegroundInformation, // s: PROCESS_FOREGROUND_BACKGROUND
	ProcessWow64Information, // q: ULONG_PTR
	ProcessImageFileName, // q: UNICODE_STRING
	ProcessLUIDDeviceMapsEnabled, // q: ULONG
	ProcessBreakOnTermination, // qs: ULONG
	ProcessDebugObjectHandle, // q: HANDLE // 30
	ProcessDebugFlags, // qs: ULONG
	ProcessHandleTracing, // q: PROCESS_HANDLE_TRACING_QUERY; s: size 0 disables, otherwise enables
	ProcessIoPriority, // qs: IO_PRIORITY_HINT
	ProcessExecuteFlags, // qs: ULONG
	ProcessResourceManagement,
	ProcessCookie, // q: ULONG
	ProcessImageInformation, // q: SECTION_IMAGE_INFORMATION
	ProcessCycleTime, // q: PROCESS_CYCLE_TIME_INFORMATION // since VISTA
	ProcessPagePriority, // q: ULONG
	ProcessInstrumentationCallback, // 40
	ProcessThreadStackAllocation, // s: PROCESS_STACK_ALLOCATION_INFORMATION, PROCESS_STACK_ALLOCATION_INFORMATION_EX
	ProcessWorkingSetWatchEx, // q: PROCESS_WS_WATCH_INFORMATION_EX[]
	ProcessImageFileNameWin32, // q: UNICODE_STRING
	ProcessImageFileMapping, // q: HANDLE (input)
	ProcessAffinityUpdateMode, // qs: PROCESS_AFFINITY_UPDATE_MODE
	ProcessMemoryAllocationMode, // qs: PROCESS_MEMORY_ALLOCATION_MODE
	ProcessGroupInformation, // q: USHORT[]
	ProcessTokenVirtualizationEnabled, // s: ULONG
	ProcessConsoleHostProcess, // q: ULONG_PTR
	ProcessWindowInformation, // q: PROCESS_WINDOW_INFORMATION // 50
	ProcessHandleInformation, // q: PROCESS_HANDLE_SNAPSHOT_INFORMATION // since WIN8
	ProcessMitigationPolicy, // s: PROCESS_MITIGATION_POLICY_INFORMATION
	ProcessDynamicFunctionTableInformation,
	ProcessHandleCheckingMode,
	ProcessKeepAliveCount, // q: PROCESS_KEEPALIVE_COUNT_INFORMATION
	ProcessRevokeFileHandles, // s: PROCESS_REVOKE_FILE_HANDLES_INFORMATION
	ProcessWorkingSetControl, // s: PROCESS_WORKING_SET_CONTROL
	ProcessHandleTable, // since WINBLUE
	ProcessCheckStackExtentsMode,
	ProcessCommandLineInformation, // q: UNICODE_STRING // 60
	ProcessProtectionInformation, // q: PS_PROTECTION
	ProcessMemoryExhaustion, // PROCESS_MEMORY_EXHAUSTION_INFO // since THRESHOLD
	ProcessFaultInformation, // PROCESS_FAULT_INFORMATION
	ProcessTelemetryIdInformation, // PROCESS_TELEMETRY_ID_INFORMATION
	ProcessCommitReleaseInformation, // PROCESS_COMMIT_RELEASE_INFORMATION
	ProcessDefaultCpuSetsInformation,
	ProcessAllowedCpuSetsInformation,
	ProcessSubsystemProcess,
	ProcessJobMemoryInformation, // PROCESS_JOB_MEMORY_INFO
	ProcessInPrivate, // since THRESHOLD2 // 70
	ProcessRaiseUMExceptionOnInvalidHandleClose,
	ProcessIumChallengeResponse,
	ProcessChildProcessInformation, // PROCESS_CHILD_PROCESS_INFORMATION
	ProcessHighGraphicsPriorityInformation,
	ProcessSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
	ProcessEnergyValues, // PROCESS_ENERGY_VALUES, PROCESS_EXTENDED_ENERGY_VALUES
	ProcessActivityThrottleState, // PROCESS_ACTIVITY_THROTTLE_STATE
	ProcessActivityThrottlePolicy, // PROCESS_ACTIVITY_THROTTLE_POLICY
	ProcessWin32kSyscallFilterInformation,
	ProcessDisableSystemAllowedCpuSets,
	ProcessWakeInformation, // PROCESS_WAKE_INFORMATION
	ProcessEnergyTrackingState, // PROCESS_ENERGY_TRACKING_STATE
	ProcessManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
	ProcessCaptureTrustletLiveDump,
	ProcessTelemetryCoverage,
	ProcessEnclaveInformation,
	ProcessEnableReadWriteVmLogging, // PROCESS_READWRITEVM_LOGGING_INFORMATION
	ProcessUptimeInformation, // PROCESS_UPTIME_INFORMATION
	ProcessImageSection,
	MaxProcessInfoClass
} PROCESSINFOCLASS;

// Source: http://processhacker.sourceforge.net
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
	SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
	SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
	SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
	SystemPathInformation, // not implemented
	SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
	SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
	SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
	SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
	SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
	SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
	SystemModuleInformation, // q: RTL_PROCESS_MODULES
	SystemLocksInformation, // q: RTL_PROCESS_LOCKS
	SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
	SystemPagedPoolInformation, // not implemented
	SystemNonPagedPoolInformation, // not implemented
	SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
	SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
	SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
	SystemVdmInstemulInformation, // q
	SystemVdmBopInformation, // not implemented // 20
	SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
	SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
	SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION
	SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
	SystemFullMemoryInformation, // not implemented
	SystemLoadGdiDriverInformation, // s (kernel-mode only)
	SystemUnloadGdiDriverInformation, // s (kernel-mode only)
	SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
	SystemSummaryMemoryInformation, // not implemented
	SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
	SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
	SystemObsolete0, // not implemented
	SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
	SystemCrashDumpStateInformation, // s (requires SeDebugPrivilege)
	SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
	SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
	SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
	SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
	SystemPrioritySeperation, // s (requires SeTcbPrivilege)
	SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
	SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
	SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION
	SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
	SystemCurrentTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION
	SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
	SystemTimeSlipNotification, // s (requires SeSystemtimePrivilege)
	SystemSessionCreate, // not implemented
	SystemSessionDetach, // not implemented
	SystemSessionInformation, // not implemented (SYSTEM_SESSION_INFORMATION)
	SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
	SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
	SystemVerifierThunkExtend, // s (kernel-mode only)
	SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
	SystemLoadGdiDriverInSystemSpace, // s (kernel-mode only) (same as SystemLoadGdiDriverInformation)
	SystemNumaProcessorMap, // q
	SystemPrefetcherInformation, // q: PREFETCHER_INFORMATION; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
	SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
	SystemRecommendedSharedDataAlignment, // q
	SystemComPlusPackage, // q; s
	SystemNumaAvailableMemory, // 60
	SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION
	SystemEmulationBasicInformation, // q
	SystemEmulationProcessorInformation,
	SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
	SystemLostDelayedWriteInformation, // q: ULONG
	SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
	SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
	SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
	SystemHotpatchInformation, // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
	SystemObjectSecurityMode, // q: ULONG // 70
	SystemWatchdogTimerHandler, // s (kernel-mode only)
	SystemWatchdogTimerInformation, // q (kernel-mode only); s (kernel-mode only)
	SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION
	SystemWow64SharedInformationObsolete, // not implemented
	SystemRegisterFirmwareTableInformationHandler, // s (kernel-mode only)
	SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
	SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
	SystemVerifierTriageInformation, // not implemented
	SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
	SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
	SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
	SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
	SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[]
	SystemVerifierCancellationInformation, // not implemented // name:wow64:whNT32QuerySystemVerifierCancellationInformation
	SystemProcessorPowerInformationEx, // not implemented
	SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
	SystemSpecialPoolInformation, // q; s (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
	SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
	SystemErrorPortInformation, // s (requires SeTcbPrivilege)
	SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
	SystemHypervisorInformation, // q; s (kernel-mode only)
	SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
	SystemTimeZoneInformation, // s (requires SeTimeZonePrivilege)
	SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
	SystemCoverageInformation, // q; s // name:wow64:whNT32QuerySystemCoverageInformation; ExpCovQueryInformation
	SystemPrefetchPatchInformation, // not implemented
	SystemVerifierFaultsInformation, // s (requires SeDebugPrivilege)
	SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
	SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
	SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION // 100
	SystemNumaProximityNodeInformation, // q
	SystemDynamicTimeZoneInformation, // q; s (requires SeTimeZonePrivilege)
	SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
	SystemProcessorMicrocodeUpdateInformation, // s
	SystemProcessorBrandString, // q // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
	SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
	SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // since WIN7 // KeQueryLogicalProcessorRelationship
	SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[]
	SystemStoreInformation, // q; s // SmQueryStoreInformation
	SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
	SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
	SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
	SystemCpuQuotaInformation, // q; s // PsQueryCpuQuotaInformation
	SystemNativeBasicInformation, // not implemented
	SystemSpare1, // not implemented
	SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
	SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
	SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
	SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
	SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
	SystemNodeDistanceInformation, // q
	SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
	SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
	SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
	SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
	SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
	SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
	SystemBadPageInformation,
	SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
	SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
	SystemEntropyInterruptTimingCallback,
	SystemConsoleInformation, // q: SYSTEM_CONSOLE_INFORMATION
	SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION
	SystemThrottleNotificationInformation,
	SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
	SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
	SystemDeviceDataEnumerationInformation,
	SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
	SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
	SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
	SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // since WINBLUE
	SystemSpare0,
	SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
	SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
	SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
	SystemEntropyInterruptTimingRawInformation,
	SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
	SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
	SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
	SystemBootMetadataInformation, // 150
	SystemSoftRebootInformation,
	SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
	SystemOfflineDumpConfigInformation,
	SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
	SystemRegistryReconciliationInformation,
	SystemEdidInformation,
	SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
	SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
	SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
	SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION // 160
	SystemVmGenerationCountInformation,
	SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
	SystemKernelDebuggerFlags,
	SystemCodeIntegrityPolicyInformation, // q: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
	SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
	SystemHardwareSecurityTestInterfaceResultsInformation,
	SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
	SystemAllowedCpuSetsInformation,
	SystemVsmProtectionInformation, // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
	SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
	SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
	SystemCodeIntegrityPolicyFullInformation,
	SystemAffinitizedInterruptProcessorInformation,
	SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
	SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
	SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
	SystemWin32WerStartCallout,
	SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
	SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
	SystemInterruptSteeringInformation, // 180
	SystemSupportedProcessorArchitectures,
	SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
	SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
	SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
	SystemControlFlowTransition,
	SystemKernelDebuggingAllowed,
	SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
	SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
	SystemCodeIntegrityPoliciesFullInformation,
	SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
	SystemIntegrityQuotaInformation,
	SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
	SystemProcessorIdleMaskInformation, // since REDSTONE3
	SystemSecureDumpEncryptionInformation,
	SystemWriteConstraintInformation, // SYSTEM_WRITE_CONSTRAINT_INFORMATION
	SystemKernelVaShadowInformation, // SYSTEM_KERNEL_VA_SHADOW_INFORMATION
	SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
	SystemFirmwareBootPerformanceInformation,
	SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
	SystemFirmwarePartitionInformation, // 200
	SystemSpeculationControlInformation, // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
	SystemDmaGuardPolicyInformation, // SYSTEM_DMA_GUARD_POLICY_INFORMATION
	SystemEnclaveLaunchControlInformation, // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
	SystemWorkloadAllowedCpuSetsInformation, // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
	SystemCodeIntegrityUnlockModeInformation,
	SystemLeapSecondInformation, // SYSTEM_LEAP_SECOND_INFORMATION
	SystemFlags2Information,
	MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

typedef enum _OBJECT_INFORMATION_CLASS
{
	ObjectBasicInformation, // OBJECT_BASIC_INFORMATION
	ObjectNameInformation, // OBJECT_NAME_INFORMATION
	ObjectTypeInformation, // OBJECT_TYPE_INFORMATION
	ObjectTypesInformation, // OBJECT_TYPES_INFORMATION
	ObjectHandleFlagInformation, // OBJECT_HANDLE_FLAG_INFORMATION
	ObjectSessionInformation,
	ObjectSessionObjectInformation,
	MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

// Source: http://processhacker.sourceforge.net
typedef enum _THREADINFOCLASS
{
	ThreadBasicInformation, // q: THREAD_BASIC_INFORMATION
	ThreadTimes, // q: KERNEL_USER_TIMES
	ThreadPriority, // s: KPRIORITY
	ThreadBasePriority, // s: LONG
	ThreadAffinityMask, // s: KAFFINITY
	ThreadImpersonationToken, // s: HANDLE
	ThreadDescriptorTableEntry, // q: DESCRIPTOR_TABLE_ENTRY (or WOW64_DESCRIPTOR_TABLE_ENTRY)
	ThreadEnableAlignmentFaultFixup, // s: BOOLEAN
	ThreadEventPair,
	ThreadQuerySetWin32StartAddress, // q: PVOID
	ThreadZeroTlsCell, // 10
	ThreadPerformanceCount, // q: LARGE_INTEGER
	ThreadAmILastThread, // q: ULONG
	ThreadIdealProcessor, // s: ULONG
	ThreadPriorityBoost, // qs: ULONG
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending, // q: ULONG
	ThreadHideFromDebugger, // s: void
	ThreadBreakOnTermination, // qs: ULONG
	ThreadSwitchLegacyState,
	ThreadIsTerminated, // q: ULONG // 20
	ThreadLastSystemCall, // q: THREAD_LAST_SYSCALL_INFORMATION
	ThreadIoPriority, // qs: IO_PRIORITY_HINT
	ThreadCycleTime, // q: THREAD_CYCLE_TIME_INFORMATION
	ThreadPagePriority, // q: ULONG
	ThreadActualBasePriority,
	ThreadTebInformation, // q: THREAD_TEB_INFORMATION (requires THREAD_GET_CONTEXT + THREAD_SET_CONTEXT)
	ThreadCSwitchMon,
	ThreadCSwitchPmu,
	ThreadWow64Context, // q: WOW64_CONTEXT
	ThreadGroupInformation, // q: GROUP_AFFINITY // 30
	ThreadUmsInformation, // q: THREAD_UMS_INFORMATION
	ThreadCounterProfiling,
	ThreadIdealProcessorEx, // q: PROCESSOR_NUMBER
	ThreadCpuAccountingInformation, // since WIN8
	ThreadSuspendCount, // since WINBLUE
	ThreadHeterogeneousCpuPolicy, // q: KHETERO_CPU_POLICY // since THRESHOLD
	ThreadContainerId, // q: GUID
	ThreadNameInformation, // qs: THREAD_NAME_INFORMATION
	ThreadSelectedCpuSets,
	ThreadSystemThreadInformation, // q: SYSTEM_THREAD_INFORMATION // 40
	ThreadActualGroupAffinity, // since THRESHOLD2
	ThreadDynamicCodePolicyInfo,
	ThreadExplicitCaseSensitivity,
	ThreadWorkOnBehalfTicket,
	ThreadSubsystemInformation, // q: SUBSYSTEM_INFORMATION_TYPE // since REDSTONE2
	ThreadDbgkWerReportActive,
	ThreadAttachContainer,
	ThreadManageWritesToExecutableMemory, // MANAGE_WRITES_TO_EXECUTABLE_MEMORY // since REDSTONE3
	ThreadPowerThrottlingState, // THREAD_POWER_THROTTLING_STATE
	MaxThreadInfoClass
} THREADINFOCLASS;

typedef enum _FSINFOCLASS
{
	FileFsVolumeInformation			= 1,	// FILE_FS_VOLUME_INFORMATION
	FileFsLabelInformation			= 2,	// FILE_FS_LABEL_INFORMATION
	FileFsSizeInformation			= 3,	// FILE_FS_SIZE_INFORMATION
	FileFsDeviceInformation			= 4,	// FILE_FS_DEVICE_INFORMATION
	FileFsAttributeInformation		= 5,	// FILE_FS_ATTRIBUTE_INFORMATION
	FileFsControlInformation		= 6,	// FILE_FS_CONTROL_INFORMATION
	FileFsFullSizeInformation		= 7,	// FILE_FS_FULL_SIZE_INFORMATION
	FileFsObjectIdInformation		= 8,	// FILE_FS_OBJECTID_INFORMATION
	FileFsDriverPathInformation		= 9,	// FILE_FS_DRIVER_PATH_INFORMATION
	FileFsVolumeFlagsInformation	= 10,	// FILE_FS_VOLUME_FLAGS_INFORMATION
	FileFsSectorSizeInformation		= 11,	// FILE_FS_SECTOR_SIZE_INFORMATION // since WIN8
	FileFsDataCopyInformation		= 12,	// FILE_FS_DATA_COPY_INFORMATION
	FileFsMetadataSizeInformation	= 13,	// FILE_FS_METADATA_SIZE_INFORMATION // since THRESHOLD
	FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation, // MEMORY_BASIC_INFORMATION
	MemoryWorkingSetInformation, // MEMORY_WORKING_SET_INFORMATION
	MemoryMappedFilenameInformation, // UNICODE_STRING
	MemoryRegionInformation, // MEMORY_REGION_INFORMATION
	MemoryWorkingSetExInformation, // MEMORY_WORKING_SET_EX_INFORMATION
	MemorySharedCommitInformation, // MEMORY_SHARED_COMMIT_INFORMATION
	MemoryImageInformation, // MEMORY_IMAGE_INFORMATION
	MemoryRegionInformationEx,
	MemoryPrivilegedBasicInformation
} MEMORY_INFORMATION_CLASS;

typedef enum _SECTION_INFORMATION_CLASS
{
	SectionBasicInformation, // q; SECTION_BASIC_INFORMATION
	SectionImageInformation, // q; SECTION_IMAGE_INFORMATION
	SectionRelocationInformation, // name:wow64:whNtQuerySection_SectionRelocationInformation
	SectionOriginalBaseInformation, // PVOID BaseAddress
	SectionInternalImageInformation, // SECTION_INTERNAL_IMAGE_INFORMATION // since REDSTONE2
	MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

// Boot condition flags (NtInitializeRegistry)
#define REG_INIT_BOOT_SM				0x0000
#define REG_INIT_BOOT_SETUP				0x0001
#define REG_INIT_BOOT_ACCEPTED_BASE		0x0002
#define REG_INIT_BOOT_ACCEPTED_MAX		(REG_INIT_BOOT_ACCEPTED_BASE + 999)

#define REG_MAX_KEY_VALUE_NAME_LENGTH	32767
#define REG_MAX_KEY_NAME_LENGTH			512

typedef enum _KEY_INFORMATION_CLASS
{
	KeyBasicInformation, // KEY_BASIC_INFORMATION
	KeyNodeInformation, // KEY_NODE_INFORMATION
	KeyFullInformation, // KEY_FULL_INFORMATION
	KeyNameInformation, // KEY_NAME_INFORMATION
	KeyCachedInformation, // KEY_CACHED_INFORMATION
	KeyFlagsInformation, // KEY_FLAGS_INFORMATION
	KeyVirtualizationInformation, // KEY_VIRTUALIZATION_INFORMATION
	KeyHandleTagsInformation, // KEY_HANDLE_TAGS_INFORMATION
	KeyTrustInformation, // KEY_TRUST_INFORMATION
	KeyLayerInformation, // KEY_LAYER_INFORMATION
	MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef struct _KEY_BASIC_INFORMATION
{
	LARGE_INTEGER LastWriteTime;
	ULONG TitleIndex;
	ULONG NameLength;
	WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION
{
	LARGE_INTEGER LastWriteTime;
	ULONG TitleIndex;
	ULONG ClassOffset;
	ULONG ClassLength;
	ULONG NameLength;
	WCHAR Name[1];
	// ...
	// WCHAR Class[1];
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION
{
	LARGE_INTEGER LastWriteTime;
	ULONG TitleIndex;
	ULONG ClassOffset;
	ULONG ClassLength;
	ULONG SubKeys;
	ULONG MaxNameLen;
	ULONG MaxClassLen;
	ULONG Values;
	ULONG MaxValueNameLen;
	ULONG MaxValueDataLen;
	WCHAR Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_NAME_INFORMATION
{
	ULONG NameLength;
	WCHAR Name[1];
} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

typedef struct _KEY_CACHED_INFORMATION
{
	LARGE_INTEGER LastWriteTime;
	ULONG TitleIndex;
	ULONG SubKeys;
	ULONG MaxNameLen;
	ULONG Values;
	ULONG MaxValueNameLen;
	ULONG MaxValueDataLen;
	ULONG NameLength;
	WCHAR Name[1];
} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;

typedef struct _KEY_FLAGS_INFORMATION
{
	ULONG UserFlags;
} KEY_FLAGS_INFORMATION, *PKEY_FLAGS_INFORMATION;

typedef struct _KEY_VIRTUALIZATION_INFORMATION
{
	ULONG VirtualizationCandidate : 1; // Tells whether the key is part of the virtualization namespace scope (only HKLM\Software for now).
	ULONG VirtualizationEnabled : 1; // Tells whether virtualization is enabled on this key. Can be 1 only if above flag is 1.
	ULONG VirtualTarget : 1; // Tells if the key is a virtual key. Can be 1 only if above 2 are 0. Valid only on the virtual store key handles.
	ULONG VirtualStore : 1; // Tells if the key is a part of the virtual store path. Valid only on the virtual store key handles.
	ULONG VirtualSource : 1; // Tells if the key has ever been virtualized, can be 1 only if VirtualizationCandidate is 1.
	ULONG Reserved : 27;
} KEY_VIRTUALIZATION_INFORMATION, *PKEY_VIRTUALIZATION_INFORMATION;

// private
typedef struct _KEY_TRUST_INFORMATION
{
	ULONG TrustedKey : 1;
	ULONG Reserved : 31;
} KEY_TRUST_INFORMATION, *PKEY_TRUST_INFORMATION;

// private
typedef struct _KEY_LAYER_INFORMATION
{
	ULONG IsTombstone;
	ULONG IsSupersedeLocal;
	ULONG IsSupersedeTree;
	ULONG ClassIsInherited;
	ULONG Reserved;
} KEY_LAYER_INFORMATION, *PKEY_LAYER_INFORMATION;

typedef enum _KEY_SET_INFORMATION_CLASS
{
	KeyWriteTimeInformation, // KEY_WRITE_TIME_INFORMATION
	KeyWow64FlagsInformation, // KEY_WOW64_FLAGS_INFORMATION
	KeyControlFlagsInformation, // KEY_CONTROL_FLAGS_INFORMATION
	KeySetVirtualizationInformation, // KEY_SET_VIRTUALIZATION_INFORMATION
	KeySetDebugInformation,
	KeySetHandleTagsInformation, // KEY_HANDLE_TAGS_INFORMATION
	KeySetLayerInformation, // KEY_SET_LAYER_INFORMATION
	MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_WRITE_TIME_INFORMATION
{
	LARGE_INTEGER LastWriteTime;
} KEY_WRITE_TIME_INFORMATION, *PKEY_WRITE_TIME_INFORMATION;

typedef struct _KEY_WOW64_FLAGS_INFORMATION
{
	ULONG UserFlags;
} KEY_WOW64_FLAGS_INFORMATION, *PKEY_WOW64_FLAGS_INFORMATION;

typedef struct _KEY_HANDLE_TAGS_INFORMATION
{
	ULONG HandleTags;
} KEY_HANDLE_TAGS_INFORMATION, *PKEY_HANDLE_TAGS_INFORMATION;

typedef struct _KEY_SET_LAYER_INFORMATION
{
	ULONG IsTombstone : 1;
	ULONG IsSupersedeLocal : 1;
	ULONG IsSupersedeTree : 1;
	ULONG ClassIsInherited : 1;
	ULONG Reserved : 28;
} KEY_SET_LAYER_INFORMATION, *PKEY_SET_LAYER_INFORMATION;

typedef struct _KEY_CONTROL_FLAGS_INFORMATION
{
	ULONG ControlFlags;
} KEY_CONTROL_FLAGS_INFORMATION, *PKEY_CONTROL_FLAGS_INFORMATION;

typedef struct _KEY_SET_VIRTUALIZATION_INFORMATION
{
	ULONG VirtualTarget : 1;
	ULONG VirtualStore : 1;
	ULONG VirtualSource : 1; // true if key has been virtualized at least once
	ULONG Reserved : 29;
} KEY_SET_VIRTUALIZATION_INFORMATION, *PKEY_SET_VIRTUALIZATION_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS
{
	KeyValueBasicInformation, // KEY_VALUE_BASIC_INFORMATION
	KeyValueFullInformation, // KEY_VALUE_FULL_INFORMATION
	KeyValuePartialInformation, // KEY_VALUE_PARTIAL_INFORMATION
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64, // KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
	KeyValueLayerInformation, // KEY_VALUE_LAYER_INFORMATION
	MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION
{
	ULONG TitleIndex;
	ULONG Type;
	ULONG NameLength;
	WCHAR Name[1];
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION
{
	ULONG TitleIndex;
	ULONG Type;
	ULONG DataOffset;
	ULONG DataLength;
	ULONG NameLength;
	WCHAR Name[1];
	// ...
	// UCHAR Data[1];
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION
{
	ULONG TitleIndex;
	ULONG Type;
	ULONG DataLength;
	UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
{
	ULONG Type;
	ULONG DataLength;
	UCHAR Data[1];
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

// private
typedef struct _KEY_VALUE_LAYER_INFORMATION
{
	ULONG IsTombstone;
	ULONG Reserved;
} KEY_VALUE_LAYER_INFORMATION, *PKEY_VALUE_LAYER_INFORMATION;

typedef struct _KEY_VALUE_ENTRY
{
	PUNICODE_STRING ValueName;
	ULONG DataLength;
	ULONG DataOffset;
	ULONG Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

typedef enum _REG_ACTION
{
	KeyAdded,
	KeyRemoved,
	KeyModified
} REG_ACTION;

typedef struct _REG_NOTIFY_INFORMATION
{
	ULONG NextEntryOffset;
	REG_ACTION Action;
	ULONG KeyLength;
	WCHAR Key[1];
} REG_NOTIFY_INFORMATION, *PREG_NOTIFY_INFORMATION;

typedef struct _KEY_PID_ARRAY
{
	HANDLE PID;
	UNICODE_STRING KeyName;
} KEY_PID_ARRAY, *PKEY_PID_ARRAY;

typedef struct _KEY_OPEN_SUBKEYS_INFORMATION
{
	ULONG Count;
	KEY_PID_ARRAY KeyArray[1];
} KEY_OPEN_SUBKEYS_INFORMATION, *PKEY_OPEN_SUBKEYS_INFORMATION;

typedef enum _SYSDBG_COMMAND
{
	SysDbgQueryModuleInformation,
	SysDbgQueryTraceInformation,
	SysDbgSetTracepoint,
	SysDbgSetSpecialCall,
	SysDbgClearSpecialCalls,
	SysDbgQuerySpecialCalls,
	SysDbgBreakPoint,
	SysDbgQueryVersion,
	SysDbgReadVirtual,
	SysDbgWriteVirtual,
	SysDbgReadPhysical,
	SysDbgWritePhysical,
	SysDbgReadControlSpace,
	SysDbgWriteControlSpace,
	SysDbgReadIoSpace,
	SysDbgWriteIoSpace,
	SysDbgReadMsr,
	SysDbgWriteMsr,
	SysDbgReadBusData,
	SysDbgWriteBusData,
	SysDbgCheckLowMemory,
	SysDbgEnableKernelDebugger,
	SysDbgDisableKernelDebugger,
	SysDbgGetAutoKdEnable,
	SysDbgSetAutoKdEnable,
	SysDbgGetPrintBufferSize,
	SysDbgSetPrintBufferSize,
	SysDbgGetKdUmExceptionEnable,
	SysDbgSetKdUmExceptionEnable,
	SysDbgGetTriageDump,
	SysDbgGetKdBlockEnable,
	SysDbgSetKdBlockEnable,
	SysDbgRegisterForUmBreakInfo,
	SysDbgGetUmBreakPid,
	SysDbgClearUmBreakPid,
	SysDbgGetUmAttachPid,
	SysDbgClearUmAttachPid,
	SysDbgGetLiveKernelDump
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef enum _DEBUGOBJECTINFOCLASS
{
	DebugObjectFlags = 1,
	MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;

// Source: http://processhacker.sourceforge.net
typedef enum _FILE_INFORMATION_CLASS
{
	FileDirectoryInformation = 1, // FILE_DIRECTORY_INFORMATION
	FileFullDirectoryInformation, // FILE_FULL_DIR_INFORMATION
	FileBothDirectoryInformation, // FILE_BOTH_DIR_INFORMATION
	FileBasicInformation, // FILE_BASIC_INFORMATION
	FileStandardInformation, // FILE_STANDARD_INFORMATION
	FileInternalInformation, // FILE_INTERNAL_INFORMATION
	FileEaInformation, // FILE_EA_INFORMATION
	FileAccessInformation, // FILE_ACCESS_INFORMATION
	FileNameInformation, // FILE_NAME_INFORMATION
	FileRenameInformation, // FILE_RENAME_INFORMATION // 10
	FileLinkInformation, // FILE_LINK_INFORMATION
	FileNamesInformation, // FILE_NAMES_INFORMATION
	FileDispositionInformation, // FILE_DISPOSITION_INFORMATION
	FilePositionInformation, // FILE_POSITION_INFORMATION
	FileFullEaInformation, // FILE_FULL_EA_INFORMATION
	FileModeInformation, // FILE_MODE_INFORMATION
	FileAlignmentInformation, // FILE_ALIGNMENT_INFORMATION
	FileAllInformation, // FILE_ALL_INFORMATION
	FileAllocationInformation, // FILE_ALLOCATION_INFORMATION
	FileEndOfFileInformation, // FILE_END_OF_FILE_INFORMATION // 20
	FileAlternateNameInformation, // FILE_NAME_INFORMATION
	FileStreamInformation, // FILE_STREAM_INFORMATION
	FilePipeInformation, // FILE_PIPE_INFORMATION
	FilePipeLocalInformation, // FILE_PIPE_LOCAL_INFORMATION
	FilePipeRemoteInformation, // FILE_PIPE_REMOTE_INFORMATION
	FileMailslotQueryInformation, // FILE_MAILSLOT_QUERY_INFORMATION
	FileMailslotSetInformation, // FILE_MAILSLOT_SET_INFORMATION
	FileCompressionInformation, // FILE_COMPRESSION_INFORMATION
	FileObjectIdInformation, // FILE_OBJECTID_INFORMATION
	FileCompletionInformation, // FILE_COMPLETION_INFORMATION // 30
	FileMoveClusterInformation, // FILE_MOVE_CLUSTER_INFORMATION
	FileQuotaInformation, // FILE_QUOTA_INFORMATION
	FileReparsePointInformation, // FILE_REPARSE_POINT_INFORMATION
	FileNetworkOpenInformation, // FILE_NETWORK_OPEN_INFORMATION
	FileAttributeTagInformation, // FILE_ATTRIBUTE_TAG_INFORMATION
	FileTrackingInformation, // FILE_TRACKING_INFORMATION
	FileIdBothDirectoryInformation, // FILE_ID_BOTH_DIR_INFORMATION
	FileIdFullDirectoryInformation, // FILE_ID_FULL_DIR_INFORMATION
	FileValidDataLengthInformation, // FILE_VALID_DATA_LENGTH_INFORMATION
	FileShortNameInformation, // FILE_NAME_INFORMATION // 40
	FileIoCompletionNotificationInformation, // FILE_IO_COMPLETION_NOTIFICATION_INFORMATION // since VISTA
	FileIoStatusBlockRangeInformation, // FILE_IOSTATUSBLOCK_RANGE_INFORMATION
	FileIoPriorityHintInformation, // FILE_IO_PRIORITY_HINT_INFORMATION
	FileSfioReserveInformation, // FILE_SFIO_RESERVE_INFORMATION
	FileSfioVolumeInformation, // FILE_SFIO_VOLUME_INFORMATION
	FileHardLinkInformation, // FILE_LINKS_INFORMATION
	FileProcessIdsUsingFileInformation, // FILE_PROCESS_IDS_USING_FILE_INFORMATION
	FileNormalizedNameInformation, // FILE_NAME_INFORMATION
	FileNetworkPhysicalNameInformation, // FILE_NETWORK_PHYSICAL_NAME_INFORMATION
	FileIdGlobalTxDirectoryInformation, // FILE_ID_GLOBAL_TX_DIR_INFORMATION // since WIN7 // 50
	FileIsRemoteDeviceInformation, // FILE_IS_REMOTE_DEVICE_INFORMATION
	FileUnusedInformation,
	FileNumaNodeInformation, // FILE_NUMA_NODE_INFORMATION
	FileStandardLinkInformation, // FILE_STANDARD_LINK_INFORMATION
	FileRemoteProtocolInformation, // FILE_REMOTE_PROTOCOL_INFORMATION
	FileRenameInformationBypassAccessCheck, // (kernel-mode only); FILE_RENAME_INFORMATION // since WIN8
	FileLinkInformationBypassAccessCheck, // (kernel-mode only); FILE_LINK_INFORMATION
	FileVolumeNameInformation, // FILE_VOLUME_NAME_INFORMATION
	FileIdInformation, // FILE_ID_INFORMATION
	FileIdExtdDirectoryInformation, // FILE_ID_EXTD_DIR_INFORMATION
	FileReplaceCompletionInformation, // FILE_COMPLETION_INFORMATION // since WINBLUE
	FileHardLinkFullIdInformation, // FILE_LINK_ENTRY_FULL_ID_INFORMATION
	FileIdExtdBothDirectoryInformation, // FILE_ID_EXTD_BOTH_DIR_INFORMATION // since THRESHOLD
	FileDispositionInformationEx, // FILE_DISPOSITION_INFO_EX // since REDSTONE
	FileRenameInformationEx,
	FileRenameInformationExBypassAccessCheck,
	FileDesiredStorageClassInformation, // FILE_DESIRED_STORAGE_CLASS_INFORMATION // since REDSTONE2
	FileStatInformation, // FILE_STAT_INFORMATION
	FileMemoryPartitionInformation, // FILE_MEMORY_PARTITION_INFORMATION // since REDSTONE3
	FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef struct _SYSTEM_BASIC_INFORMATION
{
	ULONG Reserved;
	ULONG TimerResolution;
	ULONG PageSize;
	ULONG NumberOfPhysicalPages;
	ULONG LowestPhysicalPageNumber;
	ULONG HighestPhysicalPageNumber;
	ULONG AllocationGranularity;
	ULONG_PTR MinimumUserModeAddress;
	ULONG_PTR MaximumUserModeAddress;
	ULONG_PTR ActiveProcessorsAffinityMask;
	CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESSOR_INFORMATION
{
	USHORT ProcessorArchitecture;
	USHORT ProcessorLevel;
	USHORT ProcessorRevision;
	USHORT MaximumProcessors;
	ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

typedef struct _FILE_PIPE_PEEK_BUFFER
{
	ULONG NamedPipeState;
	ULONG ReadDataAvailable;
	ULONG NumberOfMessages;
	ULONG MessageLength;
	CHAR Data[1];
} FILE_PIPE_PEEK_BUFFER, *PFILE_PIPE_PEEK_BUFFER;

typedef struct _NAMED_PIPE_CREATE_PARAMETERS
{
	ULONG NamedPipeType;
	ULONG ReadMode;
	ULONG CompletionMode;
	ULONG MaximumInstances;
	ULONG InboundQuota;
	ULONG OutboundQuota;
	LARGE_INTEGER DefaultTimeout;
	BOOLEAN TimeoutSpecified;
} NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS;

typedef struct _FILE_NETWORK_OPEN_INFORMATION
{
	LARGE_INTEGER CreationTime;
	LARGE_INTEGER LastAccessTime;
	LARGE_INTEGER LastWriteTime;
	LARGE_INTEGER ChangeTime;
	LARGE_INTEGER AllocationSize;
	LARGE_INTEGER EndOfFile;
	ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION
{
	LARGE_INTEGER BootTime;
	LARGE_INTEGER CurrentTime;
	LARGE_INTEGER TimeZoneBias;
	ULONG TimeZoneId;
	ULONG Reserved;
	ULONGLONG BootTimeBias;
	ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef struct _TIME_FIELDS
{
	SHORT Year;			// range [1601...]
	SHORT Month;		// range [1..12]
	SHORT Day;			// range [1..31]
	SHORT Hour;			// range [0..23]
	SHORT Minute;		// range [0..59]
	SHORT Second;		// range [0..59]
	SHORT Milliseconds;	// range [0..999]
	SHORT Weekday;		// range [0..6] == [Sunday..Saturday]
} TIME_FIELDS, *PTIME_FIELDS;

typedef struct _SYSTEM_CONSOLE_INFORMATION
{
	ULONG DriverLoaded : 1;
	ULONG Spare : 31;
} SYSTEM_CONSOLE_INFORMATION, *PSYSTEM_CONSOLE_INFORMATION;

typedef struct _COMPRESSED_DATA_INFO
{
	USHORT CompressionFormatAndEngine; // COMPRESSION_FORMAT_* and COMPRESSION_ENGINE_*

	UCHAR CompressionUnitShift;
	UCHAR ChunkShift;
	UCHAR ClusterShift;
	UCHAR Reserved;

	USHORT NumberOfChunks;

	ULONG CompressedChunkSizes[1];
} COMPRESSED_DATA_INFO, *PCOMPRESSED_DATA_INFO;

typedef struct _KSYSTEM_TIME
{
	ULONG LowPart;
	LONG High1Time;
	LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;

typedef struct _PROCESS_ACCESS_TOKEN
{
	HANDLE Token; // Needs TOKEN_ASSIGN_PRIMARY access
	HANDLE Thread; // Handle to initial/only thread; needs THREAD_QUERY_INFORMATION access
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

#ifdef __cplusplus
typedef enum _PS_PROTECTED_TYPE : UCHAR
{
	PsProtectedTypeNone,
	PsProtectedTypeProtectedLight,
	PsProtectedTypeProtected,
	PsProtectedTypeMax
} PS_PROTECTED_TYPE;
#else
typedef UCHAR PS_PROTECTED_TYPE;
#endif

#ifdef __cplusplus
typedef enum _PS_PROTECTED_SIGNER : UCHAR
{
	PsProtectedSignerNone,
	PsProtectedSignerAuthenticode,
	PsProtectedSignerCodeGen,
	PsProtectedSignerAntimalware,
	PsProtectedSignerLsa,
	PsProtectedSignerWindows,
	PsProtectedSignerWinTcb,
	PsProtectedSignerWinSystem,
	PsProtectedSignerApp,
	PsProtectedSignerMax
} PS_PROTECTED_SIGNER;
#else
typedef UCHAR PS_PROTECTED_SIGNER;
#endif

typedef struct _PS_PROTECTION
{
	union
	{
		struct
		{
			PS_PROTECTED_TYPE Type : 3;
			BOOLEAN Audit : 1;
			PS_PROTECTED_SIGNER Signer : 4;
		} s;
		UCHAR Level;
	};
} PS_PROTECTION, *PPS_PROTECTION;

#define RTL_CREATE_ENVIRONMENT_TRANSLATE			0x1 // Translate from multi-byte to Unicode
#define RTL_CREATE_ENVIRONMENT_TRANSLATE_FROM_OEM	0x2 // Translate from OEM to Unicode (Translate flag must also be set)
#define RTL_CREATE_ENVIRONMENT_EMPTY				0x4 // Create empty environment block

typedef struct _RTL_BUFFER {
	PUCHAR Buffer;
	PUCHAR StaticBuffer;
	SIZE_T Size;
	SIZE_T StaticSize;
	SIZE_T ReservedForAllocatedSize; // for future doubling
	PVOID ReservedForIMalloc; // for future pluggable growth
} RTL_BUFFER, *PRTL_BUFFER;

typedef struct _RTL_UNICODE_STRING_BUFFER {
	UNICODE_STRING String;
	RTL_BUFFER ByteBuffer;
	UCHAR MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	ULONG MaximumLength;
	ULONG Length;

	ULONG Flags;
	ULONG DebugFlags;

	HANDLE ConsoleHandle;
	ULONG ConsoleFlags;
	HANDLE StandardInput;
	HANDLE StandardOutput;
	HANDLE StandardError;

	CURDIR CurrentDirectory;
	UNICODE_STRING DllPath;
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
	PWCHAR Environment;

	ULONG StartingX;
	ULONG StartingY;
	ULONG CountX;
	ULONG CountY;
	ULONG CountCharsX;
	ULONG CountCharsY;
	ULONG FillAttribute;

	ULONG WindowFlags;
	ULONG ShowWindowFlags;
	UNICODE_STRING WindowTitle;
	UNICODE_STRING DesktopInfo;
	UNICODE_STRING ShellInfo;
	UNICODE_STRING RuntimeData;
	RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

	ULONG_PTR EnvironmentSize;
	ULONG_PTR EnvironmentVersion;
	PVOID PackageDependencyData;
	ULONG ProcessGroupId;
	ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

#define RTL_USER_PROCESS_PARAMETERS_NORMALIZED				0x01
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_USER			0x02
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_KERNEL			0x04
#define RTL_USER_PROCESS_PARAMETERS_PROFILE_SERVER			0x08
#define RTL_USER_PROCESS_PARAMETERS_RESERVE_1MB				0x20
#define RTL_USER_PROCESS_PARAMETERS_RESERVE_16MB			0x40
#define RTL_USER_PROCESS_PARAMETERS_CASE_SENSITIVE			0x80
#define RTL_USER_PROCESS_PARAMETERS_DISABLE_HEAP_DECOMMIT	0x100
#define RTL_USER_PROCESS_PARAMETERS_DLL_REDIRECTION_LOCAL	0x1000
#define RTL_USER_PROCESS_PARAMETERS_APP_MANIFEST_PRESENT	0x2000
#define RTL_USER_PROCESS_PARAMETERS_IMAGE_KEY_MISSING	 	0x4000
#define RTL_USER_PROCESS_PARAMETERS_NX_OPTIN				0x20000

typedef struct _RTL_USER_PROCESS_INFORMATION
{
	ULONG Length;
	HANDLE Process;
	HANDLE Thread;
	CLIENT_ID ClientId;
	SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

// Handle tag bits for PEB stdio file handles
#define PEB_STDIO_HANDLE_NATIVE		0
#define PEB_STDIO_HANDLE_SUBSYS		1
#define PEB_STDIO_HANDLE_PM			2
#define PEB_STDIO_HANDLE_RESERVED	3

#define GDI_HANDLE_BUFFER_SIZE32	34
#define GDI_HANDLE_BUFFER_SIZE64	60

#ifndef _WIN64
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define TLS_EXPANSION_SLOTS 1024

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _ACTIVATION_CONTEXT_STACK
{
	struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* ActiveFrame;
	LIST_ENTRY FrameListCache;
	ULONG Flags;
	ULONG NextCookieSequenceNumber;
	ULONG StackId;
} ACTIVATION_CONTEXT_STACK, *PACTIVATION_CONTEXT_STACK;

typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN IsLongPathAwareProcess : 1;
		} s1;
	} u1;

	HANDLE Mutant;

	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ProcessPreviouslyThrottled : 1;
			ULONG ProcessCurrentlyThrottled : 1;
			ULONG ReservedBits0 : 25;
		} s2;
	} u2;
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	} u3;
	ULONG SystemReserved[1];
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];

	PVOID ReadOnlySharedMemoryBase;
	PVOID SharedData; // HotpatchInformation
	PVOID *ReadOnlyStaticServerData;

	PVOID AnsiCodePageData; // PCPTABLEINFO
	PVOID OemCodePageData; // PCPTABLEINFO
	PVOID UnicodeCaseTableData; // PNLSTABLEINFO

	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;

	LARGE_INTEGER CriticalSectionTimeout;
	SIZE_T HeapSegmentReserve;
	SIZE_T HeapSegmentCommit;
	SIZE_T HeapDeCommitTotalFreeThreshold;
	SIZE_T HeapDeCommitFreeBlockThreshold;

	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID *ProcessHeaps; // PHEAP

	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	PRTL_CRITICAL_SECTION LoaderLock;

	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	ULONG_PTR ActiveProcessAffinityMask;
	GDI_HANDLE_BUFFER GdiHandleBuffer;
	PVOID PostProcessInitRoutine;

	PVOID TlsExpansionBitmap;
	ULONG TlsExpansionBitmapBits[32];

	ULONG SessionId;

	ULARGE_INTEGER AppCompatFlags;
	ULARGE_INTEGER AppCompatFlagsUser;
	PVOID pShimData;
	PVOID AppCompatInfo; // APPCOMPAT_EXE_DATA

	UNICODE_STRING CSDVersion;

	PVOID ActivationContextData; // ACTIVATION_CONTEXT_DATA
	PVOID ProcessAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP
	PVOID SystemDefaultActivationContextData; // ACTIVATION_CONTEXT_DATA
	PVOID SystemAssemblyStorageMap; // ASSEMBLY_STORAGE_MAP

	SIZE_T MinimumStackCommit;

	PVOID *FlsCallback;
	LIST_ENTRY FlsListHead;
	PVOID FlsBitmap;
	ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
	ULONG FlsHighIndex;

	PVOID WerRegistrationData;
	PVOID WerShipAssertPtr;
	PVOID pUnused; // pContextData
	PVOID pImageHeaderHash;
	union
	{
		ULONG TracingFlags;
		struct
		{
			ULONG HeapTracingEnabled : 1;
			ULONG CritSecTracingEnabled : 1;
			ULONG LibLoaderTracingEnabled : 1;
			ULONG SpareTracingBits : 29;
		} s3;
	} u4;
	ULONGLONG CsrServerReadOnlySharedMemoryBase;
	PVOID TppWorkerpListLock;
	LIST_ENTRY TppWorkerpList;
	PVOID WaitOnAddressHashTable[128];
	PVOID TelemetryCoverageHeader; // REDSTONE3
	ULONG CloudFileFlags;
} PEB, *PPEB;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH
{
	ULONG Offset;
	ULONG_PTR HDC;
	ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
	ULONG Flags;
	PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME
{
	ULONG Flags;
	struct _TEB_ACTIVE_FRAME *Previous;
	PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

typedef struct _TEB
{
	NT_TIB NtTib;

	PVOID EnvironmentPointer;
	CLIENT_ID ClientId;
	PVOID ActiveRpcHandle;
	PVOID ThreadLocalStoragePointer;
	PPEB ProcessEnvironmentBlock;

	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	PVOID CsrClientThread;
	PVOID Win32ThreadInfo;
	ULONG User32Reserved[26];
	ULONG UserReserved[5];
	PVOID WOW32Reserved;
	LCID CurrentLocale;
	ULONG FpSoftwareStatusRegister;
	PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _WIN64
	PVOID SystemReserved1[30];
#else
	PVOID SystemReserved1[26];
#endif
	CHAR PlaceholderCompatibilityMode;
	CHAR PlaceholderReserved[11];
	ULONG ProxiedProcessId;
	ACTIVATION_CONTEXT_STACK ActivationStack;

	UCHAR WorkingOnBehalfTicket[8];
	NTSTATUS ExceptionCode;

	PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
	ULONG_PTR InstrumentationCallbackSp;
	ULONG_PTR InstrumentationCallbackPreviousPc;
	ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _WIN64
	ULONG TxFsContext;
#endif
	BOOLEAN InstrumentationCallbackDisabled;
#ifndef _WIN64
	UCHAR SpareBytes[23];
	ULONG TxFsContext;
#endif
	GDI_TEB_BATCH GdiTebBatch;
	CLIENT_ID RealClientId;
	HANDLE GdiCachedProcessHandle;
	ULONG GdiClientPID;
	ULONG GdiClientTID;
	PVOID GdiThreadLocalInfo;
	ULONG_PTR Win32ClientInfo[62];
	PVOID glDispatchTable[233];
	ULONG_PTR glReserved1[29];
	PVOID glReserved2;
	PVOID glSectionInfo;
	PVOID glSection;
	PVOID glTable;
	PVOID glCurrentRC;
	PVOID glContext;

	NTSTATUS LastStatusValue;
	UNICODE_STRING StaticUnicodeString;
	WCHAR StaticUnicodeBuffer[261];

	PVOID DeallocationStack;
	PVOID TlsSlots[64];
	LIST_ENTRY TlsLinks;

	PVOID Vdm;
	PVOID ReservedForNtRpc;
	PVOID DbgSsReserved[2];

	ULONG HardErrorMode;
#ifdef _WIN64
	PVOID Instrumentation[11];
#else
	PVOID Instrumentation[9];
#endif
	GUID ActivityId;

	PVOID SubProcessTag;
	PVOID PerflibData;
	PVOID EtwTraceData;
	PVOID WinSockData;
	ULONG GdiBatchCount;

	union
	{
		PROCESSOR_NUMBER CurrentIdealProcessor;
		ULONG IdealProcessorValue;
		struct
		{
			UCHAR ReservedPad0;
			UCHAR ReservedPad1;
			UCHAR ReservedPad2;
			UCHAR IdealProcessor;
		} s1;
	} u1;

	ULONG GuaranteedStackBytes;
	PVOID ReservedForPerf;
	PVOID ReservedForOle;
	ULONG WaitingOnLoaderLock;
	PVOID SavedPriorityState;
	ULONG_PTR ReservedForCodeCoverage;
	PVOID ThreadPoolData;
	PVOID *TlsExpansionSlots;
#ifdef _WIN64
	PVOID DeallocationBStore;
	PVOID BStoreLimit;
#endif
	ULONG MuiGeneration;
	ULONG IsImpersonating;
	PVOID NlsCache;
	PVOID pShimData;
	USHORT HeapVirtualAffinity;
	USHORT LowFragHeapDataSlot;
	HANDLE CurrentTransactionHandle;
	PTEB_ACTIVE_FRAME ActiveFrame;
	PVOID FlsData;

	PVOID PreferredLanguages;
	PVOID UserPrefLanguages;
	PVOID MergedPrefLanguages;
	ULONG MuiImpersonation;

	union
	{
		USHORT CrossTebFlags;
		USHORT SpareCrossTebBits : 16;
	} u2;
	union
	{
		USHORT SameTebFlags;
		struct
		{
			USHORT SafeThunkCall : 1;
			USHORT InDebugPrint : 1;
			USHORT HasFiberData : 1;
			USHORT SkipThreadAttach : 1;
			USHORT WerInShipAssertCode : 1;
			USHORT RanProcessInit : 1;
			USHORT ClonedThread : 1;
			USHORT SuppressDebugMsg : 1;
			USHORT DisableUserStackWalk : 1;
			USHORT RtlExceptionAttached : 1;
			USHORT InitialThread : 1;
			USHORT SessionAware : 1;
			USHORT LoadOwner : 1;
			USHORT LoaderWorker : 1;
			USHORT SkipLoaderInit : 1;
			USHORT SpareSameTebBits : 1;
		} s2;
	} u3;

	PVOID TxnScopeEnterCallback;
	PVOID TxnScopeExitCallback;
	PVOID TxnScopeContext;
	ULONG LockCount;
	LONG WowTebOffset;
	PVOID ResourceRetValue;
	PVOID ReservedForWdf;
	ULONGLONG ReservedForCrt;
	GUID EffectiveContainerId;
} TEB, *PTEB;

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE
{
	StandardDesign,
	NEC98x86,
	EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

#define PROCESSOR_FEATURE_MAX		64

#define MAX_WOW64_SHARED_ENTRIES	16

#define NX_SUPPORT_POLICY_ALWAYSOFF	0
#define NX_SUPPORT_POLICY_ALWAYSON	1
#define NX_SUPPORT_POLICY_OPTIN		2
#define NX_SUPPORT_POLICY_OPTOUT	3

#pragma pack(push, 4)
typedef struct _KUSER_SHARED_DATA
{
	ULONG TickCountLowDeprecated;
	ULONG TickCountMultiplier;

	volatile KSYSTEM_TIME InterruptTime;
	volatile KSYSTEM_TIME SystemTime;
	volatile KSYSTEM_TIME TimeZoneBias;

	USHORT ImageNumberLow;
	USHORT ImageNumberHigh;

	WCHAR NtSystemRoot[260];

	ULONG MaxStackTraceDepth;

	ULONG CryptoExponent;

	ULONG TimeZoneId;
	ULONG LargePageMinimum;
	ULONG AitSamplingValue;
	ULONG AppCompatFlag;
	ULONGLONG RNGSeedVersion;
	ULONG GlobalValidationRunlevel;
	LONG TimeZoneBiasStamp;

	ULONG NtBuildNumber;
	NT_PRODUCT_TYPE NtProductType;
	BOOLEAN ProductTypeIsValid;
	UCHAR Reserved0[1];
	USHORT NativeProcessorArchitecture;

	ULONG NtMajorVersion;
	ULONG NtMinorVersion;

	BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];

	ULONG Reserved1;
	ULONG Reserved3;

	volatile ULONG TimeSlip;

	ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
	ULONG BootId;

	LARGE_INTEGER SystemExpirationDate;

	ULONG SuiteMask;

	BOOLEAN KdDebuggerEnabled;
	union
	{
		UCHAR MitigationPolicies;
		struct
		{
			UCHAR NXSupportPolicy : 2;
			UCHAR SEHValidationPolicy : 2;
			UCHAR CurDirDevicesSkippedForDlls : 2;
			UCHAR Reserved : 2;
		} s1;
	} u1;
	UCHAR Reserved6[2];

	volatile ULONG ActiveConsoleId;

	volatile ULONG DismountCount;

	ULONG ComPlusPackage;

	ULONG LastSystemRITEventTickCount;

	ULONG NumberOfPhysicalPages;

	BOOLEAN SafeBootMode;
	UCHAR VirtualizationFlags;
	UCHAR Reserved12[2];

	union
	{
		ULONG SharedDataFlags;
		struct
		{
			ULONG DbgErrorPortPresent : 1;
			ULONG DbgElevationEnabled : 1;
			ULONG DbgVirtEnabled : 1;
			ULONG DbgInstallerDetectEnabled : 1;
			ULONG DbgLkgEnabled : 1;
			ULONG DbgDynProcessorEnabled : 1;
			ULONG DbgConsoleBrokerEnabled : 1;
			ULONG DbgSecureBootEnabled : 1;
			ULONG DbgMultiSessionSku : 1;
			ULONG DbgMultiUsersInSessionSku : 1;
			ULONG DbgStateSeparationEnabled : 1;
			ULONG SpareBits : 21;
		} s2;
	} u2;
	ULONG DataFlagsPad[1];

	ULONGLONG TestRetInstruction;
	LONGLONG QpcFrequency;
	ULONG SystemCall;
	ULONG SystemCallPad0;
	ULONGLONG SystemCallPad[2];

	union
	{
		volatile KSYSTEM_TIME TickCount;
		volatile ULONG64 TickCountQuad;
		ULONG ReservedTickCountOverlay[3];
	};
	ULONG TickCountPad[1];

	ULONG Cookie;
	ULONG CookiePad[1];

	LONGLONG ConsoleSessionForegroundProcessId;
	ULONGLONG TimeUpdateLock;
	ULONGLONG BaselineSystemTimeQpc;
	ULONGLONG BaselineInterruptTimeQpc;
	ULONGLONG QpcSystemTimeIncrement;
	ULONGLONG QpcInterruptTimeIncrement;
	UCHAR QpcSystemTimeIncrementShift;
	UCHAR QpcInterruptTimeIncrementShift;

	USHORT UnparkedProcessorCount;
	ULONG EnclaveFeatureMask[4];

	ULONG TelemetryCoverageRound;

	USHORT UserModeGlobalLogger[16];
	ULONG ImageFileExecutionOptions;

	ULONG LangGenerationCount;
	ULONGLONG Reserved4;
	volatile ULONG64 InterruptTimeBias;
	volatile ULONG64 QpcBias;

	ULONG ActiveProcessorCount;
	volatile UCHAR ActiveGroupCount;
	UCHAR Reserved9;
	union
	{
		USHORT QpcData;
		struct
		{
			UCHAR QpcBypassEnabled : 1;
			UCHAR QpcShift : 1;
		} s3;
	} u3;

	LARGE_INTEGER TimeZoneBiasEffectiveStart;
	LARGE_INTEGER TimeZoneBiasEffectiveEnd;
	XSTATE_CONFIGURATION XState;
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#pragma pack(pop)

#ifdef __cplusplus
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountMultiplier) == 0x4, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, InterruptTime) == 0x8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SystemTime) == 0x14, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneBias) == 0x20, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberLow) == 0x2c, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ImageNumberHigh) == 0x2e, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NtSystemRoot) == 0x30, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, MaxStackTraceDepth) == 0x238, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, CryptoExponent) == 0x23c, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TimeZoneId) == 0x240, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, LargePageMinimum) == 0x244, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NtProductType) == 0x264, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ProductTypeIsValid) == 0x268, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NtMajorVersion) == 0x26c, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NtMinorVersion) == 0x270, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ProcessorFeatures) == 0x274, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved1) == 0x2b4, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, Reserved3) == 0x2b8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TimeSlip) == 0x2bc, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, AlternativeArchitecture) == 0x2c0, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SystemExpirationDate) == 0x2c8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SuiteMask) == 0x2d0, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, KdDebuggerEnabled) == 0x2d4, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ActiveConsoleId) == 0x2d8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, DismountCount) == 0x2dc, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, ComPlusPackage) == 0x2e0, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, LastSystemRITEventTickCount) == 0x2e4, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, NumberOfPhysicalPages) == 0x2e8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SafeBootMode) == 0x2ec, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TestRetInstruction) == 0x2f8, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, SystemCallPad) == 0x310, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TickCount) == 0x320, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, TickCountQuad) == 0x320, "Offset check");
static_assert(FIELD_OFFSET(KUSER_SHARED_DATA, XState) == 0x3d8, "Offset check");
#endif

#if !defined(_KERNEL_MODE) && !defined(KERNELMODE)
	#define USER_SHARED_DATA			0x7FFE0000
	#define SharedUserData				((KUSER_SHARED_DATA * const)USER_SHARED_DATA)
#else
	#if defined(_M_IX86)
		#define KI_USER_SHARED_DATA		0xFFDF0000
	#elif defined (_M_AMD64)
		#define KI_USER_SHARED_DATA		0xFFFFF78000000000Ui64
	#elif defined (_M_ARM)
		#define KI_USER_SHARED_DATA		0xFFFF9000
	#elif defined(M_ARM64)
		#define KI_USER_SHARED_DATA		0xFFFFF78000000000Ui64
	#endif
	#define SharedUserData				((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)
#endif

typedef struct _PROCESS_BASIC_INFORMATION
{
	NTSTATUS ExitStatus;
	PPEB PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
{
	SIZE_T Size; // Set to sizeof structure on input
	PROCESS_BASIC_INFORMATION BasicInfo;
	union
	{
		ULONG Flags;
		struct
		{
			ULONG IsProtectedProcess : 1;
			ULONG IsWow64Process : 1;
			ULONG IsProcessDeleting : 1;
			ULONG IsCrossSessionCreate : 1;
			ULONG IsFrozen : 1;
			ULONG IsBackground : 1;
			ULONG IsStronglyNamed : 1;
			ULONG IsSecureProcess : 1;
			ULONG IsSubsystemProcess : 1;
			ULONG SpareBits : 23;
		} s;
	} u;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _VM_COUNTERS
{
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
} VM_COUNTERS, *PVM_COUNTERS;

typedef struct _VM_COUNTERS_EX
{
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivateUsage;
} VM_COUNTERS_EX, *PVM_COUNTERS_EX;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION
{
	SYSTEM_THREAD_INFORMATION ThreadInfo;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID Win32StartAddress;
	PTEB TebBase; // Since Vista
	ULONG_PTR Reserved2;
	ULONG_PTR Reserved3;
	ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

#define PTR_ADD_OFFSET(Pointer, Offset) ((PVOID)((ULONG_PTR)(Pointer) + (ULONG_PTR)(Offset)))
#define PTR_SUB_OFFSET(Pointer, Offset) ((PVOID)((ULONG_PTR)(Pointer) - (ULONG_PTR)(Offset)))
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~((Align) - 1))
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))

#define InitializeObjectAttributes( p, n, a, r, s ) {	\
	(p)->Length = sizeof( OBJECT_ATTRIBUTES );			\
	(p)->RootDirectory = r;								\
	(p)->Attributes = a;								\
	(p)->ObjectName = n;								\
	(p)->SecurityDescriptor = s;						\
	(p)->SecurityQualityOfService = NULL;				\
	}

#if defined(__cplusplus)
#define RTL_CONST_CAST(type) const_cast<type>
#else
#define RTL_CONST_CAST(type) (type)
#endif

#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) \
	{ sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL }

#define OBJ_INHERIT									0x00000002L
#define OBJ_PERMANENT								0x00000010L
#define OBJ_EXCLUSIVE								0x00000020L
#define OBJ_CASE_INSENSITIVE						0x00000040L
#define OBJ_OPENIF									0x00000080L
#define OBJ_OPENLINK								0x00000100L
#define OBJ_KERNEL_HANDLE							0x00000200L
#define OBJ_FORCE_ACCESS_CHECK						0x00000400L
#define OBJ_IGNORE_IMPERSONATED_DEVICEMAP			0x00000800
#define OBJ_DONT_REPARSE							0x00001000
#define OBJ_VALID_ATTRIBUTES						0x00001FF2

#if NTDDI_VERSION >= NTDDI_VISTA
#define THREAD_ALL_ACCESS							(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
													0xFFFF)
#else
#define THREAD_ALL_ACCESS							(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
													0x3FF)
#endif

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED		0x00000001
#define THREAD_CREATE_FLAGS_SUPPRESS_DLLMAINS		0x00000002
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER		0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR	0x00000010 // ?
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET	0x00000020 // ?
#define THREAD_CREATE_FLAGS_INITIAL_THREAD			0x00000080

#define DEBUG_READ_EVENT							0x0001
#define DEBUG_PROCESS_ASSIGN						0x0002
#define DEBUG_SET_INFORMATION						0x0004
#define DEBUG_QUERY_INFORMATION						0x0008

#define DEBUG_ALL_ACCESS							(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
													DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION | \
													DEBUG_QUERY_INFORMATION)

#define DEBUG_KILL_ON_CLOSE							0x1

#ifndef IO_COMPLETION_QUERY_STATE
#define IO_COMPLETION_QUERY_STATE					0x0001
#endif
#ifndef IO_COMPLETION_MODIFY_STATE
#define IO_COMPLETION_MODIFY_STATE					0x0002
#endif
#ifndef IO_COMPLETION_ALL_ACCESS
#define IO_COMPLETION_ALL_ACCESS					(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
													IO_COMPLETION_QUERY_STATE | IO_COMPLETION_MODIFY_STATE)
#endif

#ifndef SEMAPHORE_ALL_ACCESS
#define SEMAPHORE_QUERY_STATE						0x0001
#define SEMAPHORE_MODIFY_STATE						0x0002

#define SEMAPHORE_ALL_ACCESS						(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
													SEMAPHORE_QUERY_STATE | SEMAPHORE_MODIFY_STATE)
#endif

#ifndef MUTANT_ALL_ACCESS
#define MUTANT_QUERY_STATE							0x0001

#define MUTANT_ALL_ACCESS							(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
						 							MUTANT_QUERY_STATE)
#endif

#ifndef EVENT_ALL_ACCESS
#define EVENT_QUERY_STATE							0x0001
#define EVENT_MODIFY_STATE							0x0002

#define EVENT_ALL_ACCESS							(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
													EVENT_QUERY_STATE | EVENT_MODIFY_STATE)
#endif

#define KEYEDEVENT_WAIT								0x0001
#define KEYEDEVENT_WAKE								0x0002
#define KEYEDEVENT_ALL_ACCESS						(STANDARD_RIGHTS_REQUIRED | \
													KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

#define DIRECTORY_QUERY								0x0001
#define DIRECTORY_TRAVERSE							0x0002
#define DIRECTORY_CREATE_OBJECT						0x0004
#define DIRECTORY_CREATE_SUBDIRECTORY				0x0008

#define DIRECTORY_ALL_ACCESS						(STANDARD_RIGHTS_REQUIRED | \
													DIRECTORY_QUERY | DIRECTORY_TRAVERSE | \
													DIRECTORY_CREATE_OBJECT | DIRECTORY_CREATE_SUBDIRECTORY)

#define SYMBOLIC_LINK_QUERY							0x0001

#define SYMBOLIC_LINK_ALL_ACCESS					(STANDARD_RIGHTS_REQUIRED | \
													SYMBOLIC_LINK_QUERY)

#ifndef TOKEN_ALL_ACCESS
#define TOKEN_ASSIGN_PRIMARY						0x0001
#define TOKEN_DUPLICATE								0x0002
#define TOKEN_IMPERSONATE							0x0004
#define TOKEN_QUERY									0x0008
#define TOKEN_QUERY_SOURCE							0x0010
#define TOKEN_ADJUST_PRIVILEGES						0x0020
#define TOKEN_ADJUST_GROUPS							0x0040
#define TOKEN_ADJUST_DEFAULT						0x0080
#define TOKEN_ADJUST_SESSIONID						0x0100

#define TOKEN_ALL_ACCESS_P							(STANDARD_RIGHTS_REQUIRED | \
													TOKEN_ASSIGN_PRIMARY | \
													TOKEN_DUPLICATE | \
													TOKEN_IMPERSONATE | \
													TOKEN_QUERY | \
													TOKEN_QUERY_SOURCE | \
													TOKEN_ADJUST_PRIVILEGES | \
													TOKEN_ADJUST_GROUPS | \
													TOKEN_ADJUST_DEFAULT)

#define TOKEN_ALL_ACCESS 							(TOKEN_ALL_ACCESS_P | \
													TOKEN_ADJUST_SESSIONID)
#endif

#define WORKER_FACTORY_RELEASE_WORKER				0x0001
#define WORKER_FACTORY_WAIT							0x0002
#define WORKER_FACTORY_SET_INFORMATION				0x0004
#define WORKER_FACTORY_QUERY_INFORMATION			0x0008
#define WORKER_FACTORY_READY_WORKER					0x0010
#define WORKER_FACTORY_SHUTDOWN						0x0020

#define WORKER_FACTORY_ALL_ACCESS 					(STANDARD_RIGHTS_REQUIRED | \
													WORKER_FACTORY_RELEASE_WORKER | \
													WORKER_FACTORY_WAIT | \
													WORKER_FACTORY_SET_INFORMATION | \
													WORKER_FACTORY_QUERY_INFORMATION | \
													WORKER_FACTORY_READY_WORKER | \
													WORKER_FACTORY_SHUTDOWN)

typedef struct _WORKER_FACTORY_DEFERRED_WORK
{
	struct _PORT_MESSAGE* AlpcSendMessage;
	HANDLE AlpcSendMessagePort;
	ULONG AlpcSendMessageFlags;
	ULONG Flags;
} WORKER_FACTORY_DEFERRED_WORK, *PWORKER_FACTORY_DEFERRED_WORK;

#define NtCurrentProcess		((HANDLE)(LONG_PTR)-1)
#define NtCurrentThread			((HANDLE)(LONG_PTR)-2)
#define NtCurrentPeb()			(NtCurrentTeb()->ProcessEnvironmentBlock)
#define NtCurrentProcessId()	(NtCurrentTeb()->ClientId.UniqueProcess)
#define NtCurrentThreadId()		(NtCurrentTeb()->ClientId.UniqueThread)
#define RtlProcessHeap()		(NtCurrentPeb()->ProcessHeap)

typedef struct _RTL_HEAP_ENTRY
{
	SIZE_T Size;
	USHORT Flags;
	USHORT AllocatorBackTraceIndex;
	union
	{
		struct
		{
			SIZE_T Settable;
			ULONG Tag;
		} s1;
		struct
		{
			SIZE_T CommittedSize;
			PVOID FirstBlock;
		} s2;
	} u;
} RTL_HEAP_ENTRY, *PRTL_HEAP_ENTRY;

#define RTL_HEAP_BUSY				(USHORT)0x0001
#define RTL_HEAP_SEGMENT			(USHORT)0x0002
#define RTL_HEAP_SETTABLE_VALUE		(USHORT)0x0010
#define RTL_HEAP_SETTABLE_FLAG1		(USHORT)0x0020
#define RTL_HEAP_SETTABLE_FLAG2		(USHORT)0x0040
#define RTL_HEAP_SETTABLE_FLAG3		(USHORT)0x0080
#define RTL_HEAP_SETTABLE_FLAGS		(USHORT)0x00e0
#define RTL_HEAP_UNCOMMITTED_RANGE	(USHORT)0x0100
#define RTL_HEAP_PROTECTED_ENTRY	(USHORT)0x0200

typedef struct _RTL_HEAP_TAG
{
	ULONG NumberOfAllocations;
	ULONG NumberOfFrees;
	SIZE_T BytesAllocated;
	USHORT TagIndex;
	USHORT CreatorBackTraceIndex;
	WCHAR TagName[24];
} RTL_HEAP_TAG, *PRTL_HEAP_TAG;

typedef struct _RTL_HEAP_INFORMATION
{
	PVOID BaseAddress;
	ULONG Flags;
	USHORT EntryOverhead;
	USHORT CreatorBackTraceIndex;
	SIZE_T BytesAllocated;
	SIZE_T BytesCommitted;
	ULONG NumberOfTags;
	ULONG NumberOfEntries;
	ULONG NumberOfPseudoTags;
	ULONG PseudoTagGranularity;
	ULONG Reserved[5];
	PRTL_HEAP_TAG Tags;
	PRTL_HEAP_ENTRY Entries;
} RTL_HEAP_INFORMATION, *PRTL_HEAP_INFORMATION;

typedef struct _RTL_PROCESS_HEAPS
{
	ULONG NumberOfHeaps;
	RTL_HEAP_INFORMATION Heaps[1];
} RTL_PROCESS_HEAPS, *PRTL_PROCESS_HEAPS;

typedef
NTSTATUS
(NTAPI*
PRTL_HEAP_COMMIT_ROUTINE)(
	_In_ PVOID Base,
	_Inout_ PVOID *CommitAddress,
	_Inout_ PSIZE_T CommitSize
	);

typedef struct _RTL_HEAP_PARAMETERS
{
	ULONG Length;
	SIZE_T SegmentReserve;
	SIZE_T SegmentCommit;
	SIZE_T DeCommitFreeBlockThreshold;
	SIZE_T DeCommitTotalFreeThreshold;
	SIZE_T MaximumAllocationSize;
	SIZE_T VirtualMemoryThreshold;
	SIZE_T InitialCommit;
	SIZE_T InitialReserve;
	PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
	SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

#define HEAP_SETTABLE_USER_VALUE 0x00000100
#define HEAP_SETTABLE_USER_FLAG1 0x00000200
#define HEAP_SETTABLE_USER_FLAG2 0x00000400
#define HEAP_SETTABLE_USER_FLAG3 0x00000800
#define HEAP_SETTABLE_USER_FLAGS 0x00000e00

#define HEAP_CLASS_0 0x00000000 // Process heap
#define HEAP_CLASS_1 0x00001000 // Private heap
#define HEAP_CLASS_2 0x00002000 // Kernel heap
#define HEAP_CLASS_3 0x00003000 // GDI heap
#define HEAP_CLASS_4 0x00004000 // User heap
#define HEAP_CLASS_5 0x00005000 // Console heap
#define HEAP_CLASS_6 0x00006000 // User desktop heap
#define HEAP_CLASS_7 0x00007000 // CSR shared heap
#define HEAP_CLASS_8 0x00008000 // CSR port heap
#define HEAP_CLASS_MASK 0x0000f000

typedef struct _RTL_HEAP_TAG_INFO
{
	ULONG NumberOfAllocations;
	ULONG NumberOfFrees;
	SIZE_T BytesAllocated;
} RTL_HEAP_TAG_INFO, *PRTL_HEAP_TAG_INFO;

#define RTL_HEAP_MAKE_TAG HEAP_MAKE_TAG_FLAGS

typedef struct _RTL_HEAP_WALK_ENTRY
{
	PVOID DataAddress;
	SIZE_T DataSize;
	UCHAR OverheadBytes;
	UCHAR SegmentIndex;
	USHORT Flags;
	union
	{
		struct
		{
			SIZE_T Settable;
			USHORT TagIndex;
			USHORT AllocatorBackTraceIndex;
			ULONG Reserved[2];
		} Block;
		struct
		{
			ULONG CommittedSize;
			ULONG UnCommittedSize;
			PVOID FirstEntry;
			PVOID LastEntry;
		} Segment;
	};
} RTL_HEAP_WALK_ENTRY, *PRTL_HEAP_WALK_ENTRY;

// HEAP_INFORMATION_CLASS. winnt.h is incomplete
#define HeapCompatibilityInformation 0x0 // q; s: ULONG
#define HeapEnableTerminationOnCorruption 0x1 // q; s: NULL
#define HeapExtendedInformation 0x2 // q; s: HEAP_EXTENDED_INFORMATION
#define HeapOptimizeResources 0x3 // q; s: HEAP_OPTIMIZE_RESOURCES_INFORMATION
#define HeapTaggingInformation 0x4
#define HeapStackDatabase 0x5
#define HeapDetailedFailureInformation 0x80000001
#define HeapSetDebuggingInformation 0x80000002 // q; s: HEAP_DEBUGGING_INFORMATION

typedef struct _PROCESS_HEAP_INFORMATION
{
	ULONG_PTR ReserveSize;
	ULONG_PTR CommitSize;
	ULONG NumberOfHeaps;
	ULONG_PTR FirstHeapInformationOffset;
} PROCESS_HEAP_INFORMATION, *PPROCESS_HEAP_INFORMATION;

typedef struct _HEAP_INFORMATION
{
	ULONG_PTR Address;
	ULONG Mode;
	ULONG_PTR ReserveSize;
	ULONG_PTR CommitSize;
	ULONG_PTR FirstRegionInformationOffset;
	ULONG_PTR NextHeapInformationOffset;
} HEAP_INFORMATION, *PHEAP_INFORMATION;

typedef struct _HEAP_EXTENDED_INFORMATION
{
	HANDLE Process;
	ULONG_PTR Heap;
	ULONG Level;
	PVOID CallbackRoutine;
	PVOID CallbackContext;
	PROCESS_HEAP_INFORMATION ProcessHeapInformation;
	HEAP_INFORMATION HeapInformation;
} HEAP_EXTENDED_INFORMATION, *PHEAP_EXTENDED_INFORMATION;

typedef
NTSTATUS
(NTAPI*
PRTL_HEAP_LEAK_ENUMERATION_ROUTINE)(
	_In_ LONG Reserved,
	_In_ PVOID HeapHandle,
	_In_ PVOID BaseAddress,
	_In_ SIZE_T BlockSize,
	_In_ ULONG StackTraceDepth,
	_In_ PVOID *StackTrace
	);

typedef struct _HEAP_DEBUGGING_INFORMATION
{
	PVOID InterceptorFunction;
	USHORT InterceptorValue;
	ULONG ExtendedOptions;
	ULONG StackTraceDepth;
	SIZE_T MinTotalBlockSize;
	SIZE_T MaxTotalBlockSize;
	PRTL_HEAP_LEAK_ENUMERATION_ROUTINE HeapLeakEnumerationRoutine;
} HEAP_DEBUGGING_INFORMATION, *PHEAP_DEBUGGING_INFORMATION;

typedef
NTSTATUS
(NTAPI*
PRTL_ENUM_HEAPS_ROUTINE)(
	_In_ PVOID HeapHandle,
	_In_ PVOID Parameter
	);

typedef
NTSTATUS
(NTAPI*
PUSER_THREAD_START_ROUTINE)(
	_In_ PVOID ThreadParameter
	);

#define LDR_FORMAT_MESSAGE_FROM_SYSTEM_MESSAGE_TABLE	11

#define RTL_ERRORMODE_NOGPFAULTERRORBOX					0x0020
#define RTL_ERRORMODE_NOOPENFILEERRORBOX				0x0040

#define RTL_ACQUIRE_PRIVILEGE_REVERT					0x00000001
#define RTL_ACQUIRE_PRIVILEGE_PROCESS					0x00000002

typedef
VOID
(NTAPI*
PLDR_IMPORT_MODULE_CALLBACK)(
	_In_ PVOID Parameter,
	_In_ PSTR ModuleName
	);

typedef struct _LDR_IMPORT_CALLBACK_INFO
{
	PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine;
	PVOID ImportCallbackParameter;
} LDR_IMPORT_CALLBACK_INFO, *PLDR_IMPORT_CALLBACK_INFO;

typedef struct _LDR_SECTION_INFO
{
	HANDLE SectionHandle;
	ACCESS_MASK DesiredAccess;
	POBJECT_ATTRIBUTES ObjectAttributes;
	ULONG SectionPageProtection;
	ULONG AllocationAttributes;
} LDR_SECTION_INFO, *PLDR_SECTION_INFO;

typedef struct _LDR_VERIFY_IMAGE_INFO
{
	ULONG Size;
	ULONG Flags;
	LDR_IMPORT_CALLBACK_INFO CallbackInfo;
	LDR_SECTION_INFO SectionInfo;
	USHORT ImageCharacteristics;
} LDR_VERIFY_IMAGE_INFO, *PLDR_VERIFY_IMAGE_INFO;

typedef enum _SEMAPHORE_INFORMATION_CLASS
{
	SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION
{
	LONG CurrentCount;
	LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

typedef enum _TIMER_INFORMATION_CLASS
{
	TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION
{
	LARGE_INTEGER RemainingTime;
	BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef
VOID
(NTAPI*
PTIMER_APC_ROUTINE)(
	_In_ PVOID TimerContext,
	_In_ ULONG TimerLowValue,
	_In_ LONG TimerHighValue
	);

typedef enum _TIMER_SET_INFORMATION_CLASS
{
	TimerSetCoalescableTimer,
	MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

typedef struct _TIMER_SET_COALESCABLE_TIMER_INFO
{
	_In_ LARGE_INTEGER DueTime;
	_In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine;
	_In_opt_ PVOID TimerContext;
	_In_opt_ struct _COUNTED_REASON_CONTEXT *WakeContext;
	_In_opt_ ULONG Period;
	_In_ ULONG TolerableDelay;
	_Out_opt_ PBOOLEAN PreviousState;
} TIMER_SET_COALESCABLE_TIMER_INFO, *PTIMER_SET_COALESCABLE_TIMER_INFO;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE
{
	ULONG64 Version;
	UNICODE_STRING Name;
} TOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
{
	PVOID pValue;
	ULONG ValueLength;
} TOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

typedef struct _TOKEN_SECURITY_ATTRIBUTE_V1
{
	UNICODE_STRING Name;
	USHORT ValueType;
	USHORT Reserved;
	ULONG Flags;
	ULONG ValueCount;
	union
	{
		PLONG64 pInt64;
		PULONG64 pUint64;
		PUNICODE_STRING pString;
		PTOKEN_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
		PTOKEN_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
	} Values;
} TOKEN_SECURITY_ATTRIBUTE_V1, *PTOKEN_SECURITY_ATTRIBUTE_V1;

#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1	1
#define TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION		TOKEN_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1

typedef struct _TOKEN_SECURITY_ATTRIBUTES_INFORMATION
{
	USHORT Version;
	USHORT Reserved;
	ULONG AttributeCount;
	union
	{
		PTOKEN_SECURITY_ATTRIBUTE_V1 pAttributeV1;
	} Attribute;
} TOKEN_SECURITY_ATTRIBUTES_INFORMATION, *PTOKEN_SECURITY_ATTRIBUTES_INFORMATION;

typedef enum _FILTER_BOOT_OPTION_OPERATION
{
	FilterBootOptionOperationOpenSystemStore,
	FilterBootOptionOperationSetElement,
	FilterBootOptionOperationDeleteElement,
	FilterBootOptionOperationMax
} FILTER_BOOT_OPTION_OPERATION;

typedef enum _IO_SESSION_EVENT
{
	IoSessionEventIgnore,
	IoSessionEventCreated,
	IoSessionEventTerminated,
	IoSessionEventConnected,
	IoSessionEventDisconnected,
	IoSessionEventLogon,
	IoSessionEventLogoff,
	IoSessionEventMax
} IO_SESSION_EVENT;

typedef enum _IO_SESSION_STATE
{
	IoSessionStateCreated,
	IoSessionStateInitialized,
	IoSessionStateConnected,
	IoSessionStateDisconnected,
	IoSessionStateDisconnectedLoggedOn,
	IoSessionStateLoggedOn,
	IoSessionStateLoggedOff,
	IoSessionStateTerminated,
	IoSessionStateMax
} IO_SESSION_STATE;

typedef struct _PORT_MESSAGE PORT_MESSAGE, *PPORT_MESSAGE;
typedef struct _TP_ALPC TP_ALPC, *PTP_ALPC;

typedef
VOID
(NTAPI*
PTP_ALPC_CALLBACK)(
	_Inout_ PTP_CALLBACK_INSTANCE Instance,
	_Inout_opt_ PVOID Context,
	_In_ PTP_ALPC Alpc
	);

typedef
VOID
(NTAPI*
PTP_ALPC_CALLBACK_EX)(
	_Inout_ PTP_CALLBACK_INSTANCE Instance,
	_Inout_opt_ PVOID Context,
	_In_ PTP_ALPC Alpc,
	_In_ PVOID ApcContext
	);

typedef
VOID
(NTAPI*
PTP_IO_CALLBACK)(
	_Inout_ PTP_CALLBACK_INSTANCE Instance,
	_Inout_opt_ PVOID Context,
	_In_ PVOID ApcContext,
	_In_ PIO_STATUS_BLOCK IoSB,
	_In_ PTP_IO Io
	);

typedef enum _IO_COMPLETION_INFORMATION_CLASS
{
	IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION
{
	LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

typedef enum _WORKERFACTORYINFOCLASS
{
	WorkerFactoryTimeout,
	WorkerFactoryRetryTimeout,
	WorkerFactoryIdleTimeout,
	WorkerFactoryBindingCount,
	WorkerFactoryThreadMinimum,
	WorkerFactoryThreadMaximum,
	WorkerFactoryPaused,
	WorkerFactoryBasicInformation,
	WorkerFactoryAdjustThreadGoal,
	WorkerFactoryCallbackType,
	WorkerFactoryStackInformation, // 10
	WorkerFactoryThreadBasePriority,
	WorkerFactoryTimeoutWaiters, // since THRESHOLD
	WorkerFactoryFlags,
	WorkerFactoryThreadSoftMaximum,
	MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION
{
	LARGE_INTEGER Timeout;
	LARGE_INTEGER RetryTimeout;
	LARGE_INTEGER IdleTimeout;
	BOOLEAN Paused;
	BOOLEAN TimerSet;
	BOOLEAN QueuedToExWorker;
	BOOLEAN MayCreate;
	BOOLEAN CreateInProgress;
	BOOLEAN InsertedIntoQueue;
	BOOLEAN Shutdown;
	ULONG BindingCount;
	ULONG ThreadMinimum;
	ULONG ThreadMaximum;
	ULONG PendingWorkerCount;
	ULONG WaitingWorkerCount;
	ULONG TotalWorkerCount;
	ULONG ReleaseCount;
	LONGLONG InfiniteWaitGoal;
	PVOID StartRoutine;
	PVOID StartParameter;
	HANDLE ProcessId;
	SIZE_T StackReserve;
	SIZE_T StackCommit;
	NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

typedef struct _BOOT_ENTRY
{
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG Attributes;
	ULONG FriendlyNameOffset;
	ULONG BootFilePathOffset;
	ULONG OsOptionsLength;
	UCHAR OsOptions[1];
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_ENTRY_LIST
{
	ULONG NextEntryOffset;
	BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

typedef struct _BOOT_OPTIONS
{
	ULONG Version;
	ULONG Length;
	ULONG Timeout;
	ULONG CurrentBootEntryId;
	ULONG NextBootEntryId;
	WCHAR HeadlessRedirection[1];
} BOOT_OPTIONS, *PBOOT_OPTIONS;

typedef struct _FILE_PATH
{
	ULONG Version;
	ULONG Length;
	ULONG Type;
	UCHAR FilePath[1];
} FILE_PATH, *PFILE_PATH;

typedef struct _EFI_DRIVER_ENTRY
{
	ULONG Version;
	ULONG Length;
	ULONG Id;
	ULONG FriendlyNameOffset;
	ULONG DriverFilePathOffset;
} EFI_DRIVER_ENTRY, *PEFI_DRIVER_ENTRY;

typedef struct _EFI_DRIVER_ENTRY_LIST
{
	ULONG NextEntryOffset;
	EFI_DRIVER_ENTRY DriverEntry;
} EFI_DRIVER_ENTRY_LIST, *PEFI_DRIVER_ENTRY_LIST;

typedef
NTSTATUS
(NTAPI
*t_NtClose)(
	_In_ HANDLE Handle
	);

typedef
NTSTATUS
(NTAPI
*t_NtDuplicateObject)(
	_In_ HANDLE SourceProcessHandle,
	_In_ HANDLE SourceHandle,
	_In_opt_ HANDLE TargetProcessHandle,
	_Out_opt_ PHANDLE TargetHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_In_ ULONG Options
	);

typedef
NTSTATUS
(NTAPI
*t_NtContinue)(
	_In_ PCONTEXT ContextRecord,
	_In_ BOOLEAN TestAlert
	);

typedef
NTSTATUS
(NTAPI
*t_NtCreateThread)(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_Out_ PCLIENT_ID ClientId,
	_In_ PCONTEXT ThreadContext,
	_In_ PINITIAL_TEB InitialTeb,
	_In_ BOOLEAN CreateSuspended
	);

typedef
NTSTATUS
(NTAPI
*t_NtCreateThreadEx)(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_In_ PUSER_THREAD_START_ROUTINE StartRoutine,
	_In_opt_ PVOID Argument,
	_In_ ULONG CreateFlags,
	_In_opt_ ULONG_PTR ZeroBits,
	_In_opt_ SIZE_T StackSize,
	_In_opt_ SIZE_T MaximumStackSize,
	_In_opt_ PPS_ATTRIBUTE_LIST AttributeList
	);

typedef
NTSTATUS
(NTAPI
*t_NtGetContextThread)(
	_In_ HANDLE ThreadHandle,
	_Inout_ PCONTEXT ThreadContext
	);

typedef
NTSTATUS
(NTAPI
*t_NtOpenProcess)(
	_Out_ PHANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PCLIENT_ID ClientId
	);

typedef
NTSTATUS
(NTAPI
*t_NtProtectVirtualMemory)(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG NewProtect,
	_Out_ PULONG OldProtect
	);

typedef
NTSTATUS
(NTAPI
*t_NtQueryDebugFilterState)(
	_In_ ULONG ComponentId,
	_In_ ULONG Level
	);

typedef
NTSTATUS
(NTAPI
*t_NtQueryInformationProcess)(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_Out_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtQueryInformationThread)(
	_In_ HANDLE ThreadHandle,
	_In_ THREADINFOCLASS ThreadInformationClass,
	_Out_ PVOID ThreadInformation,
	_In_ ULONG ThreadInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtQueryObject)(
	_In_ HANDLE Handle,
	_In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
	_Out_opt_ PVOID ObjectInformation,
	_In_ ULONG ObjectInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtQueryPerformanceCounter)(
	_Out_ PLARGE_INTEGER PerformanceCounter,
	_Out_opt_ PLARGE_INTEGER PerformanceFrequency
	);

typedef
NTSTATUS
(NTAPI
*t_NtQuerySystemInformation)(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Out_opt_ PVOID SystemInformation,
	_In_ ULONG SystemInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtQuerySystemTime)(
	_Out_ PLARGE_INTEGER SystemTime
	);

typedef
NTSTATUS
(NTAPI
*t_NtQueryVirtualMemory)(
	_In_ HANDLE ProcessHandle,
	_In_ PVOID BaseAddress,
	_In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
	_Out_ PVOID MemoryInformation,
	_In_ SIZE_T MemoryInformationLength,
	_Out_opt_ PSIZE_T ReturnLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtResumeProcess)(
	_In_ HANDLE ProcessHandle
	);

typedef
NTSTATUS
(NTAPI
*t_NtResumeThread)(
	_In_ HANDLE ThreadHandle,
	_Out_opt_ PULONG PreviousSuspendCount
	);

typedef
NTSTATUS
(NTAPI
*t_NtSetContextThread)(
	_In_ HANDLE ThreadHandle,
	_In_ PCONTEXT ThreadContext
	);

typedef
NTSTATUS
(NTAPI
*t_NtSetDebugFilterState)(
	_In_ ULONG ComponentId,
	_In_ ULONG Level,
	_In_ BOOLEAN State
	);

typedef
NTSTATUS
(NTAPI
*t_NtSetInformationProcess)(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_In_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtSetInformationThread)(
	_In_ HANDLE ThreadHandle,
	_In_ THREADINFOCLASS ThreadInformationClass,
	_In_ PVOID ThreadInformation,
	_In_ ULONG ThreadInformationLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtSetSystemInformation)(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_In_opt_ PVOID SystemInformation,
	_In_ ULONG SystemInformationLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtSetSystemTime)(
	_In_opt_ PLARGE_INTEGER SystemTime,
	_Out_opt_ PLARGE_INTEGER PreviousTime
	);

typedef
NTSTATUS
(NTAPI
*t_NtSuspendProcess)(
	_In_ HANDLE ProcessHandle
	);

typedef
NTSTATUS
(NTAPI
*t_NtSuspendThread)(
	_In_ HANDLE ThreadHandle,
	_Out_opt_ PULONG PreviousSuspendCount
	);

typedef
NTSTATUS
(NTAPI
*t_NtSystemDebugControl)(
	_In_ SYSDBG_COMMAND Command,
	_Inout_opt_ PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_opt_ PVOID OutputBuffer,
	_In_ ULONG OutputBufferLength,
	_Out_opt_ PULONG ReturnLength
	);

typedef
NTSTATUS
(NTAPI
*t_NtTerminateProcess)(
	_In_opt_ HANDLE ProcessHandle,
	_In_ NTSTATUS ExitStatus
	);

typedef
NTSTATUS
(NTAPI
*t_NtYieldExecution)(
	);

typedef
VOID
(NTAPI
*t_KiUserExceptionDispatcher)(
	_In_ PEXCEPTION_RECORD ExceptionRecord,
	_In_ PCONTEXT ContextFrame
	);

#ifdef _WIN64
typedef
VOID
(NTAPI
*t_RtlRestoreContext)(
	_In_ PCONTEXT ContextRecord,
	_In_opt_ PEXCEPTION_RECORD ExceptionRecord
	);
#endif

typedef
NTSTATUS
(NTAPI
*t_NtReadVirtualMemory)(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_Out_ PVOID Buffer,
	_In_ SIZE_T BufferSize,
	_Out_opt_ PSIZE_T NumberOfBytesRead
	);

typedef
NTSTATUS
(NTAPI
*t_NtWriteVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID BaseAddress,
	CONST VOID *Buffer,
	SIZE_T BufferSize,
	PSIZE_T NumberOfBytesWritten
	);

typedef
NTSTATUS
(NTAPI
*t_NtOpenFile)(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions
    );

typedef
NTSTATUS
(NTAPI
*t_NtCreateSection)(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle
    );

typedef
NTSTATUS
(NTAPI
*t_NtMapViewOfSection)(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID* BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect
    );

// win32k system calls
// BlockInput
typedef
NTSTATUS
(NTAPI
*t_NtUserBlockInput)(
	_In_ BOOL BlockIt
	);

#define NtUserFindWindowEx_FW_BOTH 0
#define NtUserFindWindowEx_FW_16BIT 1
#define NtUserFindWindowEx_FW_32BIT 2

// FindWindow
typedef
HWND
(NTAPI
*t_NtUserFindWindowEx)(
	_In_ HWND hWndParent,
	_In_opt_ HWND hWndChildAfter,
	_In_ PUNICODE_STRING lpszClass,
	_In_opt_ PUNICODE_STRING lpszWindow,
	_In_ DWORD dwType
	);

// EnumWindows
typedef
NTSTATUS
(NTAPI
*t_NtUserBuildHwndList)(
	_In_ HDESK hDesktop,
	_In_opt_ HWND hwndParent,
	_In_ BOOLEAN bChildren,
	_In_opt_ ULONG dwThreadId,
	_In_opt_ ULONG lParam,
	_Out_ HWND* pWnd,
	_Inout_ PULONG pBufSize
	);

// EnumWindows (Windows 8+)
typedef
NTSTATUS
(NTAPI
*t_NtUserBuildHwndList_Eight)(
	_In_ HDESK hDesktop,
	_In_opt_ HWND hwndParent,
	_In_ BOOLEAN bChildren,
	_In_ BOOLEAN bUnknownFlag,
	_In_opt_ ULONG dwThreadId,
	_In_opt_ ULONG lParam,
	_Out_ HWND* pWnd,
	_Inout_ PULONG pBufSize
	);

typedef enum _WINDOWINFOCLASS
{
	WindowProcess			= 0,	// HANDLE
	WindowRealWindowOwner	= 1,
	WindowThread			= 2,	// HANDLE
	WindowIsHung			= 5		// BOOL
} WINDOWINFOCLASS;

// GetWindowThreadProcessId
typedef
HANDLE
(NTAPI
*t_NtUserQueryWindow)(
	_In_ HWND hwnd,
	_In_ WINDOWINFOCLASS WindowInfo
	);

typedef enum _THREAD_STATE_ROUTINE
{
	THREADSTATE_GETTHREADINFO,
	THREADSTATE_ACTIVEWINDOW
} THREAD_STATE_ROUTINE;

// GetActiveWindow
typedef
ULONG_PTR
(NTAPI
*t_NtUserGetThreadState)(
	THREAD_STATE_ROUTINE Routine
	);

typedef
HWND
(NTAPI
*t_NtUserGetForegroundWindow)(
	);

typedef
int
(NTAPI
*t_NtUserGetClassName)(
	_In_ HWND hWnd,
	_In_ BOOL Real,
	_Out_ PUNICODE_STRING ClassName
	);

typedef
int
(NTAPI
*t_NtUserInternalGetWindowText)(
	_In_ HWND hwnd,
	_Out_ LPWSTR lpString,
	_In_ int nMaxCount
	);

FORCEINLINE
VOID
InitializeListHead(
	_Out_ PLIST_ENTRY ListHead
	)
{
	ListHead->Flink = ListHead->Blink = ListHead;
}

FORCEINLINE
BOOLEAN
IsListEmpty(
	_In_ PLIST_ENTRY ListHead
	)
{
	return ListHead->Flink == ListHead;
}

FORCEINLINE
BOOLEAN
RemoveEntryList(
	_In_ PLIST_ENTRY Entry
	)
{
	PLIST_ENTRY Flink = Entry->Flink;
	PLIST_ENTRY Blink = Entry->Blink;
	Blink->Flink = Flink;
	Flink->Blink = Blink;

	return Flink == Blink;
}

FORCEINLINE
PLIST_ENTRY
RemoveHeadList(
	_Inout_ PLIST_ENTRY ListHead
	)
{
	PLIST_ENTRY Entry = ListHead->Flink;
	PLIST_ENTRY Flink = Entry->Flink;
	ListHead->Flink = Flink;
	Flink->Blink = ListHead;

	return Entry;
}

FORCEINLINE
PLIST_ENTRY
RemoveTailList(
	_Inout_ PLIST_ENTRY ListHead
	)
{
	PLIST_ENTRY Entry = ListHead->Blink;
	PLIST_ENTRY Blink = Entry->Blink;
	ListHead->Blink = Blink;
	Blink->Flink = ListHead;

	return Entry;
}

FORCEINLINE
VOID
InsertTailList(
	_Inout_ PLIST_ENTRY ListHead,
	_Inout_ PLIST_ENTRY Entry
	)
{
	PLIST_ENTRY Blink = ListHead->Blink;
	Entry->Flink = ListHead;
	Entry->Blink = Blink;
	Blink->Flink = Entry;
	ListHead->Blink = Entry;
}

FORCEINLINE
VOID
InsertHeadList(
	_Inout_ PLIST_ENTRY ListHead,
	_Inout_ PLIST_ENTRY Entry
	)
{
	PLIST_ENTRY Flink = ListHead->Flink;
	Entry->Flink = Flink;
	Entry->Blink = ListHead;
	Flink->Blink = Entry;
	ListHead->Flink = Entry;
}

FORCEINLINE
VOID
AppendTailList(
	_Inout_ PLIST_ENTRY ListHead,
	_Inout_ PLIST_ENTRY ListToAppend
	)
{
	PLIST_ENTRY ListEnd = ListHead->Blink;

	ListHead->Blink->Flink = ListToAppend;
	ListHead->Blink = ListToAppend->Blink;
	ListToAppend->Blink->Flink = ListHead;
	ListToAppend->Blink = ListEnd;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
PopEntryList(
	_Inout_ PSINGLE_LIST_ENTRY ListHead
	)
{
	PSINGLE_LIST_ENTRY FirstEntry = ListHead->Next;

	if (FirstEntry)
		ListHead->Next = FirstEntry->Next;

	return FirstEntry;
}

FORCEINLINE
VOID
PushEntryList(
	_Inout_ PSINGLE_LIST_ENTRY ListHead,
	_Inout_ PSINGLE_LIST_ENTRY Entry
	)
{
	Entry->Next = ListHead->Next;
	ListHead->Next = Entry;
}

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcess(
	_Out_ PHANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ParentProcess,
	_In_ BOOLEAN InheritObjectTable,
	_In_opt_ HANDLE SectionHandle,
	_In_opt_ HANDLE DebugPort,
	_In_opt_ HANDLE TokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateProcessEx(
	_Out_ PHANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ParentProcess,
	_In_ ULONG Flags,
	_In_opt_ HANDLE SectionHandle,
	_In_opt_ HANDLE DebugPort,
	_In_opt_ HANDLE TokenHandle,
	_In_ ULONG JobMemberLevel
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateUserProcess(
	_Out_ PHANDLE ProcessHandle,
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK ProcessDesiredAccess,
	_In_ ACCESS_MASK ThreadDesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
	_In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
	_In_ ULONG ProcessFlags,
	_In_ ULONG ThreadFlags,
	_In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
	_Inout_ PPS_CREATE_INFO CreateInfo,
	_In_ PPS_ATTRIBUTE_LIST AttributeList
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_In_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_Out_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryObject(
	_In_ HANDLE Handle,
	_In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
	_Out_opt_ PVOID ObjectInformation,
	_In_ ULONG ObjectInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_Out_writes_bytes_to_opt_(SystemInformationLength, *ReturnLength) PVOID SystemInformation,
	_In_ ULONG SystemInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
	_In_ ULONG SystemInformationLength,
	_Out_opt_ PULONG ReturnLength
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
	_In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
	_In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
	_In_ ULONG SystemInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationThread(
	_In_ HANDLE ThreadHandle,
	_In_ THREADINFOCLASS ThreadInformationClass,
	_In_ PVOID ThreadInformation,
	_In_ ULONG ThreadInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
	_In_ HANDLE ThreadHandle,
	_In_ THREADINFOCLASS ThreadInformationClass,
	_Out_ PVOID ThreadInformation,
	_In_ ULONG ThreadInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress
	);

#if NTDDI_VERSION >= NTDDI_WIN8

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnmapViewOfSectionEx(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_In_ ULONG Flags
	);

#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtExtendSection(
	_In_ HANDLE SectionHandle,
	_Inout_ PLARGE_INTEGER NewSectionSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSuspendThread(
	_In_ HANDLE ThreadHandle,
	_Out_opt_ PULONG PreviousSuspendCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResumeThread(
	_In_ HANDLE ThreadHandle,
	_Out_opt_ PULONG PreviousSuspendCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSuspendProcess(
	_In_ HANDLE ProcessHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResumeProcess(
	_In_ HANDLE ProcessHandle
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
ULONG
NTAPI
NtGetCurrentProcessorNumber(
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSignalAndWaitForSingleObject(
	_In_ HANDLE SignalHandle,
	_In_ HANDLE WaitHandle,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
	_In_ HANDLE Handle,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects(
	_In_ ULONG Count,
	_In_reads_(Count) HANDLE Handles[],
	_In_ WAIT_TYPE WaitType,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects32(
	_In_ ULONG Count,
	_In_reads_(Count) HANDLE Handles[],
	_In_ WAIT_TYPE WaitType,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
	_In_ HANDLE Handle,
	_In_ SECURITY_INFORMATION SecurityInformation,
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
	_In_ HANDLE Handle,
	_In_ SECURITY_INFORMATION SecurityInformation,
	_Out_writes_bytes_to_(Length,*LengthNeeded) PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_ ULONG Length,
	_Out_ PULONG LengthNeeded
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThread(
	_In_ HANDLE ThreadHandle,
	_In_ PPS_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx(
	_In_ HANDLE ThreadHandle,
	_In_opt_ HANDLE UserApcReserveHandle,
	_In_ PPS_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG NewProtect,
	_Out_ PULONG OldProtect
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushInstructionCache(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_In_ SIZE_T Length
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushWriteBuffer(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFsControlFile(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG FsControlCode,
	_In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
	_In_ ULONG OutputBufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockFile(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ PLARGE_INTEGER ByteOffset,
	_In_ PLARGE_INTEGER Length,
	_In_ ULONG Key,
	_In_ BOOLEAN FailImmediately,
	_In_ BOOLEAN ExclusiveLock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ PLARGE_INTEGER ByteOffset,
	_In_ PLARGE_INTEGER Length,
	_In_ ULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_Out_ PIO_STATUS_BLOCK IoStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_In_ PVOID BaseAddress,
	_In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
	_Out_ PVOID MemoryInformation,
	_In_ SIZE_T MemoryInformationLength,
	_Out_opt_ PSIZE_T ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG MapType
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG MapType
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSystemDebugControl(
	_In_ SYSDBG_COMMAND Command,
	_Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
	_In_ ULONG OutputBufferLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtYieldExecution(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClose(
	_In_ HANDLE Handle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryAttributesFile(
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PFILE_BASIC_INFORMATION FileInformation
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryFullAttributesFile(
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_writes_bytes_(Length) PVOID FileInformation,
	_In_ ULONG Length,
	_In_ FILE_INFORMATION_CLASS FileInformationClass
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_reads_bytes_(Length) PVOID FileInformation,
	_In_ ULONG Length,
	_In_ FILE_INFORMATION_CLASS FileInformationClass
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_reads_bytes_(Length) PVOID Buffer,
	_In_ ULONG Length
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetVolumeInformationFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_reads_bytes_(Length) PVOID FsInformation,
	_In_ ULONG Length,
	_In_ FS_INFORMATION_CLASS FsInformationClass
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateFile(
	_Out_ PHANDLE FileHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_opt_ PLARGE_INTEGER AllocationSize,
	_In_ ULONG FileAttributes,
	_In_ ULONG ShareAccess,
	_In_ ULONG CreateDisposition,
	_In_ ULONG CreateOptions,
	_In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
	_In_ ULONG EaLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateNamedPipeFile(
	_Out_ PHANDLE FileHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG ShareAccess,
	_In_ ULONG CreateDisposition,
	_In_ ULONG CreateOptions,
	_In_ ULONG NamedPipeType,
	_In_ ULONG ReadMode,
	_In_ ULONG CompletionMode,
	_In_ ULONG MaximumInstances,
	_In_ ULONG InboundQuota,
	_In_ ULONG OutboundQuota,
	_In_opt_ PLARGE_INTEGER DefaultTimeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateMailslotFile(
	_Out_ PHANDLE FileHandle,
	_In_ ULONG DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG CreateOptions,
	_In_ ULONG MailslotQuota,
	_In_ ULONG MaximumMessageSize,
	_In_ PLARGE_INTEGER ReadTimeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFileEx(
	_In_ HANDLE FileHandle,
	_In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelSynchronousIoFile(
	_In_ HANDLE ThreadHandle,
	_In_opt_ PIO_STATUS_BLOCK IoRequestToCancel,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
	_Out_ PHANDLE LinkHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ PUNICODE_STRING LinkTarget
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSymbolicLinkObject(
	_Out_ PHANDLE LinkHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
	_In_ HANDLE LinkHandle,
	_Inout_ PUNICODE_STRING LinkTarget,
	_Out_opt_ PULONG ReturnedLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetContextThread(
	_In_ HANDLE ThreadHandle,
	_Inout_ PCONTEXT ThreadContext
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetContextThread(
	_In_ HANDLE ThreadHandle,
	_In_ PCONTEXT ThreadContext
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess(
	_Out_ PHANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PCLIENT_ID ClientId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateProcess(
	_In_opt_ HANDLE ProcessHandle,
	_In_ NTSTATUS ExitStatus
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNextProcess(
	_In_ HANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_In_ ULONG Flags,
	_Out_ PHANDLE NewProcessHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNextThread(
	_In_ HANDLE ProcessHandle,
	_In_ HANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_In_ ULONG Flags,
	_Out_ PHANDLE NewThreadHandle
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDebugObject(
	_Out_ PHANDLE DebugObjectHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDebugActiveProcess(
	_In_ HANDLE ProcessHandle,
	_In_ HANDLE DebugObjectHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtContinue(
	_In_ PCONTEXT ContextRecord,
	_In_ BOOLEAN TestAlert
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseException(
	_In_ PEXCEPTION_RECORD ExceptionRecord,
	_In_ PCONTEXT ContextRecord,
	_In_ BOOLEAN FirstChance
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThread(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_Out_ PCLIENT_ID ClientId,
	_In_ PCONTEXT ThreadContext,
	_In_ PINITIAL_TEB InitialTeb,
	_In_ BOOLEAN CreateSuspended
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateThreadEx(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_In_ PUSER_THREAD_START_ROUTINE StartRoutine,
	_In_opt_ PVOID Argument,
	_In_ ULONG CreateFlags,
	_In_opt_ SIZE_T ZeroBits,
	_In_opt_ SIZE_T StackSize,
	_In_opt_ SIZE_T MaximumStackSize,
	_In_opt_ PPS_ATTRIBUTE_LIST AttributeList
	);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateReserveObject(
	_Out_ PHANDLE MemoryReserveHandle,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ MEMORY_RESERVE_TYPE Type
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterThreadTerminatePort(
	_In_ HANDLE PortHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRaiseHardError(
	_In_ NTSTATUS ErrorStatus,
	_In_ ULONG NumberOfParameters,
	_In_ ULONG UnicodeStringParameterMask,
	_In_reads_(NumberOfParameters) PULONG_PTR Parameters,
	_In_ HARDERROR_RESPONSE_OPTION ResponseOption,
	_Out_ PHARDERROR_RESPONSE Response
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
	_In_ ULONG_PTR ZeroBits,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG AllocationType,
	_In_ ULONG Protect
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG FreeType
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_Out_writes_bytes_(BufferSize) PVOID Buffer,
	_In_ SIZE_T BufferSize,
	_Out_opt_ PSIZE_T NumberOfBytesRead
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_In_reads_bytes_(BufferSize) CONST VOID *Buffer,
	_In_ SIZE_T BufferSize,
	_Out_opt_ PSIZE_T NumberOfBytesWritten
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPages(
	_In_ HANDLE ProcessHandle,
	_Inout_ PULONG_PTR NumberOfPages,
	_Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPages(
	_In_ PVOID VirtualAddress,
	_In_ ULONG_PTR NumberOfPages,
	_In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter(
	_In_reads_(NumberOfPages) PVOID *VirtualAddresses,
	_In_ ULONG_PTR NumberOfPages,
	_In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreeUserPhysicalPages(
	_In_ HANDLE ProcessHandle,
	_Inout_ PULONG_PTR NumberOfPages,
	_In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySection(
	_In_ HANDLE SectionHandle,
	_In_ SECTION_INFORMATION_CLASS SectionInformationClass,
	_Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
	_In_ SIZE_T SectionInformationLength,
	_Out_opt_ PSIZE_T ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAreMappedFilesTheSame(
	_In_ PVOID File1MappedAsAnImage,
	_In_ PVOID File2MappedAsFile
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSection(
	_Out_ PHANDLE SectionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PLARGE_INTEGER MaximumSize,
	_In_ ULONG SectionPageProtection,
	_In_ ULONG AllocationAttributes,
	_In_opt_ HANDLE FileHandle
	);

#if NTDDI_VERSION >= NTDDI_WIN10_RS5

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSectionEx(
	_Out_ PHANDLE SectionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PLARGE_INTEGER MaximumSize,
	_In_ ULONG SectionPageProtection,
	_In_ ULONG AllocationAttributes,
	_In_opt_ HANDLE FileHandle,
	_Inout_updates_opt_(ExtendedParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
	_In_ ULONG ExtendedParameterCount
	);

#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSection(
	_Out_ PHANDLE SectionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapViewOfSection(
	_In_ HANDLE SectionHandle,
	_In_ HANDLE ProcessHandle,
	_Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,
	_In_ ULONG_PTR ZeroBits,
	_In_ SIZE_T CommitSize,
	_Inout_opt_ PLARGE_INTEGER SectionOffset,
	_Inout_ PSIZE_T ViewSize,
	_In_ SECTION_INHERIT InheritDisposition,
	_In_ ULONG AllocationType,
	_In_ ULONG Win32Protect
	);

#if NTDDI_VERSION >= NTDDI_WIN10_RS4

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMapViewOfSectionEx(
	_In_ HANDLE SectionHandle,
	_In_ HANDLE ProcessHandle,
	_Inout_opt_ PVOID* BaseAddress,
	_In_ PLARGE_INTEGER ViewOffset,
	_Inout_ PSIZE_T ViewSize,
	_In_ ULONG AllocationType,
	_In_ ULONG Win32Protect,
	_Inout_updates_opt_(ParameterCount) PMEM_EXTENDED_PARAMETER ExtendedParameters,
	_In_ ULONG ParameterCount
	);

#endif

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSession(
	_Out_ PHANDLE SessionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_ FILE_NOTIFY_INFORMATION Buffer,
	_In_ ULONG Length,
	_In_ ULONG CompletionFilter,
	_In_ BOOLEAN WatchTree
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenFile(
	_Out_ PHANDLE FileHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG ShareAccess,
	_In_ ULONG OpenOptions
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_writes_bytes_(Length) PVOID FileInformation,
	_In_ ULONG Length,
	_In_ FILE_INFORMATION_CLASS FileInformationClass,
	_In_ BOOLEAN ReturnSingleEntry,
	_In_opt_ PUNICODE_STRING FileName,
	_In_ BOOLEAN RestartScan
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryEaFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_writes_bytes_(Length) PVOID Buffer,
	_In_ ULONG Length,
	_In_ BOOLEAN ReturnSingleEntry,
	_In_reads_bytes_opt_(EaListLength) PVOID EaList,
	_In_ ULONG EaListLength,
	_In_opt_ PULONG EaIndex,
	_In_ BOOLEAN RestartScan
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEaFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_reads_bytes_(Length) PVOID Buffer,
	_In_ ULONG Length
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadDriver(
	_In_ PUNICODE_STRING DriverServiceName
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadDriver(
	_In_ PUNICODE_STRING DriverServiceName
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_writes_bytes_(Length) PVOID Buffer,
	_In_ ULONG Length,
	_In_opt_ PLARGE_INTEGER ByteOffset,
	_In_opt_ PULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFileScatter(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ PFILE_SEGMENT_ELEMENT SegmentArray,
	_In_ ULONG Length,
	_In_opt_ PLARGE_INTEGER ByteOffset,
	_In_opt_ PULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFileGather(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ PFILE_SEGMENT_ELEMENT SegmentArray,
	_In_ ULONG Length,
	_In_opt_ PLARGE_INTEGER ByteOffset,
	_In_opt_ PULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteFile(
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFile(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_reads_bytes_(Length) PVOID Buffer,
	_In_ ULONG Length,
	_In_opt_ PLARGE_INTEGER ByteOffset,
	_In_opt_ PULONG Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
	_In_ HANDLE FileHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG IoControlCode,
	_In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
	_In_ ULONG InputBufferLength,
	_Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
	_In_ ULONG OutputBufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationObject(
	_In_ HANDLE Handle,
	_In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
	_In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
	_In_ ULONG ObjectInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateObject(
	_In_ HANDLE SourceProcessHandle,
	_In_ HANDLE SourceHandle,
	_In_opt_ HANDLE TargetProcessHandle,
	_Out_opt_ PHANDLE TargetHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_In_ ULONG Options
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
	_In_ HANDLE Object
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtMakeTemporaryObject(
	_In_ HANDLE Handle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
	_Out_ PHANDLE DirectoryHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
	_Out_ PHANDLE DirectoryHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
	_In_ HANDLE DirectoryHandle,
	_Out_writes_bytes_opt_(Length) PVOID Buffer,
	_In_ ULONG Length,
	_In_ BOOLEAN ReturnSingleEntry,
	_In_ BOOLEAN RestartScan,
	_Inout_ PULONG Context,
	_Out_opt_ PULONG ReturnLength
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreatePrivateNamespace(
	_Out_ PHANDLE NamespaceHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ PVOID BoundaryDescriptor
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenPrivateNamespace(
	_Out_ PHANDLE NamespaceHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ PVOID BoundaryDescriptor
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeletePrivateNamespace(
	_In_ HANDLE NamespaceHandle
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThread(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PCLIENT_ID ClientId
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTerminateThread(
	_In_opt_ HANDLE ThreadHandle,
	_In_ NTSTATUS ExitStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemTime(
	_Out_ PLARGE_INTEGER SystemTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemTime(
	_In_opt_ PLARGE_INTEGER SystemTime,
	_Out_opt_ PLARGE_INTEGER PreviousTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryTimerResolution(
	_Out_ PULONG MaximumTime,
	_Out_ PULONG MinimumTime,
	_Out_ PULONG CurrentTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimerResolution(
	_In_ ULONG DesiredTime,
	_In_ BOOLEAN SetResolution,
	_Out_ PULONG ActualTime
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryPerformanceCounter(
	_Out_ PLARGE_INTEGER PerformanceCounter,
	_Out_opt_ PLARGE_INTEGER PerformanceFrequency
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateLocallyUniqueId(
	_Out_ PLUID Luid
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetUuidSeed(
	_In_ PCHAR Seed
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAllocateUuids(
	_Out_ PULARGE_INTEGER Time,
	_Out_ PULONG Range,
	_Out_ PULONG Sequence,
	_Out_ PCHAR Seed
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEvent(
	_Out_ PHANDLE EventHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ EVENT_TYPE EventType,
	_In_ BOOLEAN InitialState
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEvent(
	_Out_ PHANDLE EventHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEvent(
	_In_ HANDLE EventHandle,
	_Out_opt_ PLONG PreviousState
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtResetEvent(
	_In_ HANDLE EventHandle,
	_Out_opt_ PLONG PreviousState
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtClearEvent(
	_In_ HANDLE EventHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_ PVOID Buffer,
	_In_ ULONG Length,
	_In_ BOOLEAN ReturnSingleEntry,
	_In_opt_ PVOID SidList,
	_In_ ULONG SidListLength,
	_In_opt_ PSID StartSid,
	_In_ BOOLEAN RestartScan
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
	_In_ HANDLE FileHandle,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_Out_writes_bytes_(Length) PVOID FsInformation,
	_In_ ULONG Length,
	_In_ FS_INFORMATION_CLASS FsInformationClass
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKey(
	_Out_ PHANDLE KeyHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Reserved_ ULONG TitleIndex,
	_In_opt_ PUNICODE_STRING Class,
	_In_ ULONG CreateOptions,
	_Out_opt_ PULONG Disposition
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKeyTransacted(
	_Out_ PHANDLE KeyHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Reserved_ ULONG TitleIndex,
	_In_opt_ PUNICODE_STRING Class,
	_In_ ULONG CreateOptions,
	_In_ HANDLE TransactionHandle,
	_Out_opt_ PULONG Disposition
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKey(
	_Out_ PHANDLE KeyHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyTransacted(
	_Out_ PHANDLE KeyHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE TransactionHandle
	);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyEx(
	_Out_ PHANDLE KeyHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ ULONG OpenOptions
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyTransactedEx(
	_Out_ PHANDLE KeyHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ ULONG OpenOptions,
	_In_ HANDLE TransactionHandle
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteKey(
	_In_ HANDLE KeyHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameKey(
	_In_ HANDLE KeyHandle,
	_In_ PUNICODE_STRING NewName
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
	_In_ HANDLE KeyHandle,
	_In_ PUNICODE_STRING ValueName
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryKey(
	_In_ HANDLE KeyHandle,
	_In_ KEY_INFORMATION_CLASS KeyInformationClass,
	_Out_writes_bytes_to_opt_(Length, *ResultLength) PVOID KeyInformation,
	_In_ ULONG Length,
	_Out_ PULONG ResultLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationKey(
	_In_ HANDLE KeyHandle,
	_In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
	_In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
	_In_ ULONG KeySetInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryValueKey(
	_In_ HANDLE KeyHandle,
	_In_ PUNICODE_STRING ValueName,
	_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	_Out_writes_bytes_to_opt_(Length, *ResultLength) PVOID KeyValueInformation,
	_In_ ULONG Length,
	_Out_ PULONG ResultLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetValueKey(
	_In_ HANDLE KeyHandle,
	_In_ PUNICODE_STRING ValueName,
	_In_opt_ ULONG TitleIndex,
	_In_ ULONG Type,
	_In_reads_bytes_opt_(DataSize) PVOID Data,
	_In_ ULONG DataSize
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
	_In_ HANDLE KeyHandle,
	_Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
	_In_ ULONG EntryCount,
	_Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
	_Inout_ PULONG BufferLength,
	_Out_opt_ PULONG RequiredBufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateKey(
	_In_ HANDLE KeyHandle,
	_In_ ULONG Index,
	_In_ KEY_INFORMATION_CLASS KeyInformationClass,
	_Out_writes_bytes_to_opt_(Length, *ResultLength) PVOID KeyInformation,
	_In_ ULONG Length,
	_Out_ PULONG ResultLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
	_In_ HANDLE KeyHandle,
	_In_ ULONG Index,
	_In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	_Out_writes_bytes_to_opt_(Length, *ResultLength) PVOID KeyValueInformation,
	_In_ ULONG Length,
	_Out_ PULONG ResultLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFlushKey(
	_In_ HANDLE KeyHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompactKeys(
	_In_ ULONG Count,
	_In_ PHANDLE KeyArray
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompressKey(
	_In_ HANDLE Key
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ POBJECT_ATTRIBUTES SourceFile
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKey2(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ POBJECT_ATTRIBUTES SourceFile,
	_In_ ULONG Flags
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ POBJECT_ATTRIBUTES SourceFile,
	_In_ ULONG Flags,
	_In_opt_ HANDLE TrustClassKey,
	_In_opt_ HANDLE Event,
	_In_opt_ ACCESS_MASK DesiredAccess,
	_Out_opt_ PHANDLE RootHandle,
	_Out_opt_ PIO_STATUS_BLOCK IoStatus
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReplaceKey(
	_In_ POBJECT_ATTRIBUTES NewFile,
	_In_ HANDLE TargetHandle,
	_In_ POBJECT_ATTRIBUTES OldFile
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveKey(
	_In_ HANDLE KeyHandle,
	_In_ HANDLE FileHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveKeyEx(
	_In_ HANDLE KeyHandle,
	_In_ HANDLE FileHandle,
	_In_ ULONG Format
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSaveMergedKeys(
	_In_ HANDLE HighPrecedenceKeyHandle,
	_In_ HANDLE LowPrecedenceKeyHandle,
	_In_ HANDLE FileHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRestoreKey(
	_In_ HANDLE KeyHandle,
	_In_opt_ HANDLE FileHandle,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKey(
	_In_ POBJECT_ATTRIBUTES TargetKey
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKey2(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ ULONG Flags
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnloadKeyEx(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_opt_ HANDLE Event
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeKey(
	_In_ HANDLE KeyHandle,
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG CompletionFilter,
	_In_ BOOLEAN WatchTree,
	_Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
	_In_ ULONG BufferSize,
	_In_ BOOLEAN Asynchronous
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeMultipleKeys(
	_In_ HANDLE MasterKeyHandle,
	_In_opt_ ULONG Count,
	_In_reads_opt_(Count) OBJECT_ATTRIBUTES SubordinateObjects[],
	_In_opt_ HANDLE Event,
	_In_opt_ PIO_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG CompletionFilter,
	_In_ BOOLEAN WatchTree,
	_Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
	_In_ ULONG BufferSize,
	_In_ BOOLEAN Asynchronous
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryOpenSubKeys(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_Out_ PULONG HandleCount
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryOpenSubKeysEx(
	_In_ POBJECT_ATTRIBUTES TargetKey,
	_In_ ULONG BufferLength,
	_Out_writes_bytes_(BufferLength) PVOID Buffer,
	_Out_ PULONG RequiredSize
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtInitializeRegistry(
	_In_ USHORT BootCondition
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockRegistryKey(
	_In_ HANDLE KeyHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockProductActivationKeys(
	_Inout_opt_ ULONG *pPrivateVer,
	_Out_opt_ ULONG *pSafeMode
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeRegistry(
	_In_ ULONG TimeOutInSeconds
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawRegistry(
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDelayExecution(
	_In_ BOOLEAN Alertable,
	_In_ PLARGE_INTEGER DelayInterval
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCallbackReturn(
	_In_reads_bytes_opt_(OutputLength) PVOID OutputBuffer,
	_In_ ULONG OutputLength,
	_In_ NTSTATUS Status
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
VOID
NTAPI
NtFlushProcessWriteBuffers(
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDebugFilterState(
	_In_ ULONG ComponentId,
	_In_ ULONG Level
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDebugFilterState(
	_In_ ULONG ComponentId,
	_In_ ULONG Level,
	_In_ BOOLEAN State
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveProcessDebug(
	_In_ HANDLE ProcessHandle,
	_In_ HANDLE DebugObjectHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForDebugEvent(
	_In_ HANDLE DebugObjectHandle,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout,
	_Out_ PDBGUI_WAIT_STATE_CHANGE WaitStateChange
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDebugContinue(
	_In_ HANDLE DebugObjectHandle,
	_In_ PCLIENT_ID ClientId,
	_In_ NTSTATUS ContinueStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationDebugObject(
	_In_ HANDLE DebugObjectHandle,
	_In_ DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
	_In_ PVOID DebugInformation,
	_In_ ULONG DebugInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
	_In_ HANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_Out_ PHANDLE TokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
	_In_ HANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ ULONG HandleAttributes,
	_Out_ PHANDLE TokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
	_In_ HANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ BOOLEAN OpenAsSelf,
	_Out_ PHANDLE TokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
	_In_ HANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ BOOLEAN OpenAsSelf,
	_In_ ULONG HandleAttributes,
	_Out_ PHANDLE TokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateToken(
	_Out_ PHANDLE TokenHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ TOKEN_TYPE TokenType,
	_In_ PLUID AuthenticationId,
	_In_ PLARGE_INTEGER ExpirationTime,
	_In_ PTOKEN_USER User,
	_In_ PTOKEN_GROUPS Groups,
	_In_ PTOKEN_PRIVILEGES Privileges,
	_In_opt_ PTOKEN_OWNER Owner,
	_In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
	_In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
	_In_ PTOKEN_SOURCE TokenSource
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDuplicateToken(
	_In_ HANDLE ExistingTokenHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ BOOLEAN EffectiveOnly,
	_In_ TOKEN_TYPE TokenType,
	_Out_ PHANDLE NewTokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
	_In_ HANDLE TokenHandle,
	_In_ BOOLEAN DisableAllPrivileges,
	_In_opt_ PTOKEN_PRIVILEGES NewState,
	_In_ ULONG BufferLength,
	_Out_opt_ PTOKEN_PRIVILEGES PreviousState,
	_Out_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
	_In_ HANDLE TokenHandle,
	_In_ BOOLEAN ResetToDefault,
	_In_opt_ PTOKEN_GROUPS NewState,
	_In_opt_ ULONG BufferLength,
	_Out_ PTOKEN_GROUPS PreviousState,
	_Out_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFilterToken(
	_In_ HANDLE ExistingTokenHandle,
	_In_ ULONG Flags,
	_In_opt_ PTOKEN_GROUPS SidsToDisable,
	_In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
	_In_opt_ PTOKEN_GROUPS RestrictedSids,
	_Out_ PHANDLE NewTokenHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationToken(
	_In_ HANDLE TokenHandle,
	_In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
	_In_ PVOID TokenInformation,
	_In_ ULONG TokenInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCompareTokens(
	_In_ HANDLE FirstTokenHandle,
	_In_ HANDLE SecondTokenHandle,
	_Out_ PBOOLEAN Equal
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
	_In_ HANDLE ClientToken,
	_Inout_ PPRIVILEGE_SET RequiredPrivileges,
	_Out_ PBOOLEAN Result
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
	_In_ HANDLE ThreadHandle
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySecurityAttributesToken(
	_In_ HANDLE TokenHandle,
	_In_reads_opt_(NumberOfAttributes) PUNICODE_STRING Attributes,
	_In_ ULONG NumberOfAttributes,
	_Out_ PTOKEN_SECURITY_ATTRIBUTES_INFORMATION Buffer,
	_In_ ULONG Length,
	_Out_ PULONG ReturnLength
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheck(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_ HANDLE ClientToken,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ PGENERIC_MAPPING GenericMapping,
	_Out_ PPRIVILEGE_SET PrivilegeSet,
	_Inout_ PULONG PrivilegeSetLength,
	_Out_ PACCESS_MASK GrantedAccess,
	_Out_ PNTSTATUS AccessStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByType(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_opt_ PSID PrincipalSelfSid,
	_In_ HANDLE ClientToken,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_TYPE_LIST ObjectTypeList,
	_In_ ULONG ObjectTypeListLength,
	_In_ PGENERIC_MAPPING GenericMapping,
	_Out_ PPRIVILEGE_SET PrivilegeSet,
	_Inout_ PULONG PrivilegeSetLength,
	_Out_ PACCESS_MASK GrantedAccess,
	_Out_ PNTSTATUS AccessStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultList(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_opt_ PSID PrincipalSelfSid,
	_In_ HANDLE ClientToken,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_TYPE_LIST ObjectTypeList,
	_In_ ULONG ObjectTypeListLength,
	_In_ PGENERIC_MAPPING GenericMapping,
	_Out_ PPRIVILEGE_SET PrivilegeSet,
	_Inout_ PULONG PrivilegeSetLength,
	_Out_ PACCESS_MASK GrantedAccess,
	_Out_ PNTSTATUS AccessStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateIoCompletion(
	_Out_ PHANDLE IoCompletionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ ULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenIoCompletion(
	_Out_ PHANDLE IoCompletionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryIoCompletion(
	_In_ HANDLE IoCompletionHandle,
	_In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
	_Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
	_In_ ULONG IoCompletionInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIoCompletion(
	_In_ HANDLE IoCompletionHandle,
	_In_opt_ PVOID KeyContext,
	_In_opt_ PVOID ApcContext,
	_In_ NTSTATUS IoStatus,
	_In_ ULONG_PTR IoStatusInformation
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetIoCompletionEx(
	_In_ HANDLE IoCompletionHandle,
	_In_ HANDLE IoCompletionPacketHandle,
	_In_opt_ PVOID KeyContext,
	_In_opt_ PVOID ApcContext,
	_In_ NTSTATUS IoStatus,
	_In_ ULONG_PTR IoStatusInformation
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveIoCompletion(
	_In_ HANDLE IoCompletionHandle,
	_Out_ PVOID *KeyContext,
	_Out_ PVOID *ApcContext,
	_Out_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_opt_ PLARGE_INTEGER Timeout
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtRemoveIoCompletionEx(
	_In_ HANDLE IoCompletionHandle,
	_Out_writes_to_(Count, *NumEntriesRemoved) PFILE_IO_COMPLETION_INFORMATION IoCompletionInformation,
	_In_ ULONG Count,
	_Out_ PULONG NumEntriesRemoved,
	_In_opt_ PLARGE_INTEGER Timeout,
	_In_ BOOLEAN Alertable
	);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtNotifyChangeSession(
	_In_ HANDLE SessionHandle,
	_In_ ULONG ChangeSequenceNumber,
	_In_ PLARGE_INTEGER ChangeTimeStamp,
	_In_ IO_SESSION_EVENT Event,
	_In_ IO_SESSION_STATE NewState,
	_In_ IO_SESSION_STATE PreviousState,
	_In_reads_bytes_opt_(PayloadSize) PVOID Payload,
	_In_ ULONG PayloadSize
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateMutant(
	_Out_ PHANDLE MutantHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ BOOLEAN InitialOwner
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenMutant(
	_Out_ PHANDLE MutantHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseMutant(
	_In_ HANDLE MutantHandle,
	_Out_opt_ PLONG PreviousCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertThread(
	_In_ HANDLE ThreadHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAlertResumeThread(
	_In_ HANDLE ThreadHandle,
	_Out_opt_ PULONG PreviousSuspendCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTestAlert(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtImpersonateThread(
	_In_ HANDLE ServerThreadHandle,
	_In_ HANDLE ClientThreadHandle,
	_In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
	_Out_ PHANDLE SemaphoreHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ LONG InitialCount,
	_In_ LONG MaximumCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
	_Out_ PHANDLE SemaphoreHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
	_In_ HANDLE SemaphoreHandle,
	_In_ LONG ReleaseCount,
	_Out_opt_ PLONG PreviousCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
	_In_ HANDLE SemaphoreHandle,
	_In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
	_Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
	_In_ ULONG SemaphoreInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTimer(
	_Out_ PHANDLE TimerHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ TIMER_TYPE TimerType
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTimer(
	_Out_ PHANDLE TimerHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimer(
	_In_ HANDLE TimerHandle,
	_In_ PLARGE_INTEGER DueTime,
	_In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
	_In_opt_ PVOID TimerContext,
	_In_ BOOLEAN ResumeTimer,
	_In_opt_ LONG Period,
	_Out_opt_ PBOOLEAN PreviousState
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetTimerEx(
	_In_ HANDLE TimerHandle,
	_In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
	_Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
	_In_ ULONG TimerSetInformationLength
	);
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelTimer(
	_In_ HANDLE TimerHandle,
	_Out_opt_ PBOOLEAN CurrentState
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryTimer(
	_In_ HANDLE TimerHandle,
	_In_ TIMER_INFORMATION_CLASS TimerInformationClass,
	_Out_ PVOID TimerInformation,
	_In_ ULONG TimerInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateKeyedEvent(
	_Out_ PHANDLE KeyedEventHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ ULONG Flags
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenKeyedEvent(
	_Out_ PHANDLE KeyedEventHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseKeyedEvent(
	_In_ HANDLE KeyedEventHandle,
	_In_ PVOID KeyValue,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForKeyedEvent(
	_In_ HANDLE KeyedEventHandle,
	_In_ PVOID KeyValue,
	_In_ BOOLEAN Alertable,
	_In_opt_ PLARGE_INTEGER Timeout
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSCALLAPI
NTSTATUS
NTAPI
NtUmsThreadYield(
	_In_ PVOID SchedulerParam
	);
#endif

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
	_Out_ PHANDLE TmHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PUNICODE_STRING LogFileName,
	_In_opt_ ULONG CreateOptions,
	_In_opt_ ULONG CommitStrength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
	_Out_ PHANDLE TmHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ PUNICODE_STRING LogFileName,
	_In_opt_ LPGUID TmIdentity,
	_In_opt_ ULONG OpenOptions
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRenameTransactionManager(
	_In_ PUNICODE_STRING LogFileName,
	_In_ LPGUID ExistingTransactionManagerGuid
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollforwardTransactionManager(
	_In_ HANDLE TransactionManagerHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverTransactionManager(
	_In_ HANDLE TransactionManagerHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransactionManager(
	_In_ HANDLE TransactionManagerHandle,
	_In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
	_Out_writes_bytes_(TransactionManagerInformationLength) PVOID TransactionManagerInformation,
	_In_ ULONG TransactionManagerInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransactionManager(
	_In_ HANDLE TmHandle,
	_In_ TRANSACTIONMANAGER_INFORMATION_CLASS TransactionManagerInformationClass,
	_In_ PVOID TransactionManagerInformation,
	_In_ ULONG TransactionManagerInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateTransactionObject(
	_In_opt_ HANDLE RootObjectHandle,
	_In_ KTMOBJECT_TYPE QueryType,
	_Inout_updates_bytes_(ObjectCursorLength) PKTMOBJECT_CURSOR ObjectCursor,
	_In_ ULONG ObjectCursorLength,
	_Out_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateTransaction(
	_Out_ PHANDLE TransactionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ LPGUID Uow,
	_In_opt_ HANDLE TmHandle,
	_In_opt_ ULONG CreateOptions,
	_In_opt_ ULONG IsolationLevel,
	_In_opt_ ULONG IsolationFlags,
	_In_opt_ PLARGE_INTEGER Timeout,
	_In_opt_ PUNICODE_STRING Description
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenTransaction(
	_Out_ PHANDLE TransactionHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ LPGUID Uow,
	_In_opt_ HANDLE TmHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationTransaction(
	_In_ HANDLE TransactionHandle,
	_In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
	_Out_writes_bytes_(TransactionInformationLength) PVOID TransactionInformation,
	_In_ ULONG TransactionInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationTransaction(
	_In_ HANDLE TransactionHandle,
	_In_ TRANSACTION_INFORMATION_CLASS TransactionInformationClass,
	_In_ PVOID TransactionInformation,
	_In_ ULONG TransactionInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitTransaction(
	_In_ HANDLE TransactionHandle,
	_In_ BOOLEAN Wait
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
	_In_ HANDLE TransactionHandle,
	_In_ BOOLEAN Wait
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
	_Out_ PHANDLE EnlistmentHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ HANDLE ResourceManagerHandle,
	_In_ HANDLE TransactionHandle,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ ULONG CreateOptions,
	_In_ NOTIFICATION_MASK NotificationMask,
	_In_opt_ PVOID EnlistmentKey
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
	_Out_ PHANDLE EnlistmentHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ HANDLE ResourceManagerHandle,
	_In_ LPGUID EnlistmentGuid,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationEnlistment(
	_In_ HANDLE EnlistmentHandle,
	_In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
	_Out_writes_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
	_In_ ULONG EnlistmentInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationEnlistment(
	_In_opt_ HANDLE EnlistmentHandle,
	_In_ ENLISTMENT_INFORMATION_CLASS EnlistmentInformationClass,
	_In_reads_bytes_(EnlistmentInformationLength) PVOID EnlistmentInformation,
	_In_ ULONG EnlistmentInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverEnlistment(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PVOID EnlistmentKey
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareEnlistment(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareEnlistment(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitEnlistment(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackEnlistment(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrePrepareComplete(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPrepareComplete(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCommitComplete(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadOnlyEnlistment(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRollbackComplete(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSinglePhaseReject(
	_In_ HANDLE EnlistmentHandle,
	_In_opt_ PLARGE_INTEGER TmVirtualClock
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
	_Out_ PHANDLE ResourceManagerHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ HANDLE TmHandle,
	_In_opt_ LPGUID ResourceManagerGuid,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_opt_ ULONG CreateOptions,
	_In_opt_ PUNICODE_STRING Description
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
	_Out_ PHANDLE ResourceManagerHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ HANDLE TmHandle,
	_In_ LPGUID ResourceManagerGuid,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRecoverResourceManager(
	_In_ HANDLE ResourceManagerHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtGetNotificationResourceManager(
	_In_ HANDLE ResourceManagerHandle,
	_Out_ PTRANSACTION_NOTIFICATION TransactionNotification,
	_In_ ULONG NotificationLength,
	_In_ PLARGE_INTEGER Timeout,
	_Out_opt_ PULONG ReturnLength,
	_In_ ULONG Asynchronous,
	_In_opt_ ULONG_PTR AsynchronousContext
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationResourceManager(
	_In_ HANDLE ResourceManagerHandle,
	_In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
	_Out_writes_bytes_(ResourceManagerInformationLength) PVOID ResourceManagerInformation,
	_In_ ULONG ResourceManagerInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationResourceManager(
	_In_ HANDLE ResourceManagerHandle,
	_In_ RESOURCEMANAGER_INFORMATION_CLASS ResourceManagerInformationClass,
	_In_ PVOID ResourceManagerInformation,
	_In_ ULONG ResourceManagerInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtRegisterProtocolAddressInformation(
	_In_ HANDLE ResourceManager,
	_In_ PCRM_PROTOCOL_ID ProtocolId,
	_In_ ULONG ProtocolInformationSize,
	_In_ PVOID ProtocolInformation,
	_In_opt_ ULONG CreateOptions
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationComplete(
	_In_ HANDLE ResourceManagerHandle,
	_In_ ULONG RequestCookie,
	_In_ ULONG BufferLength,
	_In_ PVOID Buffer
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtPropagationFailed(
	_In_ HANDLE ResourceManagerHandle,
	_In_ ULONG RequestCookie,
	_In_ NTSTATUS PropStatus
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
	_In_ PLARGE_INTEGER FreezeTimeout,
	_In_ PLARGE_INTEGER ThawTimeout
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtThawTransactions(
	);
#endif

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateWorkerFactory(
	_Out_ PHANDLE WorkerFactoryHandleReturn,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE CompletionPortHandle,
	_In_ HANDLE WorkerProcessHandle,
	_In_ PUSER_THREAD_START_ROUTINE StartRoutine,
	_In_opt_ PVOID StartParameter,
	_In_opt_ ULONG MaxThreadCount,
	_In_opt_ SIZE_T StackReserve,
	_In_opt_ SIZE_T StackCommit
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationWorkerFactory(
	_In_ HANDLE WorkerFactoryHandle,
	_In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
	_Out_ PVOID WorkerFactoryInformation,
	_In_ ULONG WorkerFactoryInformationLength,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationWorkerFactory(
	_In_ HANDLE WorkerFactoryHandle,
	_In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
	_In_ PVOID WorkerFactoryInformation,
	_In_ ULONG WorkerFactoryInformationLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownWorkerFactory(
	_In_ HANDLE WorkerFactoryHandle,
	_Inout_ volatile LONG *PendingWorkerCount
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReleaseWorkerFactoryWorker(
	_In_ HANDLE WorkerFactoryHandle
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWorkerFactoryWorkerReady(
	_In_ HANDLE WorkerFactoryHandle
	);

#if NTDDI_VERSION >= NTDDI_WIN8 || defined(_WIN64)
// Windows 8+ declaration, can be used on Vista/7 x64
NTSYSCALLAPI
NTSTATUS
NTAPI
NtWaitForWorkViaWorkerFactory(
	_In_ HANDLE WorkerFactoryHandle,
	_Out_writes_to_(Count, *PacketsReturned) PFILE_IO_COMPLETION_INFORMATION MiniPackets,
	_In_ ULONG Count,
	_Out_ PULONG PacketsReturned,
	_In_ PWORKER_FACTORY_DEFERRED_WORK DeferredWork
	);
#else
// Windows Vista/7 x86
NTSYSCALLAPI
NTSTATUS
NTAPI
ZwWaitForWorkViaWorkerFactory(
	_In_ HANDLE WorkerFactoryHandle,
	_Out_ PFILE_IO_COMPLETION_INFORMATION MiniPacket
	);

FORCEINLINE
NTSTATUS
NtWaitForWorkViaWorkerFactory(
	_In_ HANDLE WorkerFactoryHandle,
	_Out_ PFILE_IO_COMPLETION_INFORMATION MiniPackets,
	_Reserved_ ULONG Count,
	_Reserved_ PULONG PacketsReturned,
	_Reserved_ PWORKER_FACTORY_DEFERRED_WORK DeferredWork
	)
{
	UNREFERENCED_PARAMETER(Count);
	UNREFERENCED_PARAMETER(PacketsReturned);
	UNREFERENCED_PARAMETER(DeferredWork);

	return ZwWaitForWorkViaWorkerFactory(WorkerFactoryHandle,
										MiniPackets);
}
#endif
#endif

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemEnvironmentValue(
	_In_ PUNICODE_STRING VariableName,
	_Out_writes_bytes_(ValueLength) PWSTR VariableValue,
	_In_ USHORT ValueLength,
	_Out_opt_ PUSHORT ReturnLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemEnvironmentValue(
	_In_ PUNICODE_STRING VariableName,
	_In_ PUNICODE_STRING VariableValue
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQuerySystemEnvironmentValueEx(
	_In_ PUNICODE_STRING VariableName,
	_In_ LPGUID VendorGuid,
	_Out_writes_bytes_opt_(*ValueLength) PVOID Value,
	_Inout_ PULONG ValueLength,
	_Out_opt_ PULONG Attributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetSystemEnvironmentValueEx(
	_In_ PUNICODE_STRING VariableName,
	_In_ LPGUID VendorGuid,
	_In_reads_bytes_opt_(ValueLength) PVOID Value,
	_In_ ULONG ValueLength,
	_In_ ULONG Attributes
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateSystemEnvironmentValuesEx(
	_In_ ULONG InformationClass,
	_Out_ PVOID Buffer,
	_Inout_ PULONG BufferLength
	);

#if NTDDI_VERSION >= NTDDI_VISTA

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddBootEntry(
	_In_ PBOOT_ENTRY BootEntry,
	_Out_opt_ PULONG Id
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteBootEntry(
	_In_ ULONG Id
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtModifyBootEntry(
	_In_ PBOOT_ENTRY BootEntry
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateBootEntries(
	_Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
	_Inout_ PULONG BufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryBootEntryOrder(
	_Out_writes_opt_(*Count) PULONG Ids,
	_Inout_ PULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetBootEntryOrder(
	_In_reads_(Count) PULONG Ids,
	_In_ ULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryBootOptions(
	_Out_writes_bytes_opt_(*BootOptionsLength) PBOOT_OPTIONS BootOptions,
	_Inout_ PULONG BootOptionsLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetBootOptions(
	_In_ PBOOT_OPTIONS BootOptions,
	_In_ ULONG FieldsToChange
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtTranslateFilePath(
	_In_ PFILE_PATH InputFilePath,
	_In_ ULONG OutputType,
	_Out_writes_bytes_opt_(*OutputFilePathLength) PFILE_PATH OutputFilePath,
	_Inout_opt_ PULONG OutputFilePathLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtAddDriverEntry(
	_In_ PEFI_DRIVER_ENTRY DriverEntry,
	_Out_opt_ PULONG Id
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeleteDriverEntry(
	_In_ ULONG Id
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtModifyDriverEntry(
	_In_ PEFI_DRIVER_ENTRY DriverEntry
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnumerateDriverEntries(
	_Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
	_Inout_ PULONG BufferLength
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDriverEntryOrder(
	_Out_writes_opt_(*Count) PULONG Ids,
	_Inout_ PULONG Count
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetDriverEntryOrder(
	_In_reads_(Count) PULONG Ids,
	_In_ ULONG Count
	);

#endif

#if NTDDI_VERSION >= NTDDI_WIN7

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSerializeBoot(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtEnableLastKnownGood(
	);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDisableLastKnownGood(
	);

#endif

NTSYSAPI
ULONG
__cdecl
DbgPrint(
	_In_z_ _Printf_format_string_ PCSTR Format,
	...
	);

NTSYSAPI
ULONG
__cdecl
DbgPrintEx(
	_In_ ULONG ComponentId,
	_In_ ULONG Level,
	_In_z_ _Printf_format_string_ PCSTR Format,
	...
	);

NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
	);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConnectToDbg(
	);

NTSYSAPI
HANDLE
NTAPI
DbgUiGetThreadDebugObject(
	);

NTSYSAPI
VOID
NTAPI
DbgUiSetThreadDebugObject(
	_In_ HANDLE DebugObject
	);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiWaitStateChange(
	_Out_ PDBGUI_WAIT_STATE_CHANGE StateChange,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiContinue(
	_In_ PCLIENT_ID AppClientId,
	_In_ NTSTATUS ContinueStatus
	);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiStopDebugging(
	_In_ HANDLE Process
	);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
	_In_ HANDLE Process
	);

NTSYSAPI
VOID
NTAPI
DbgUiRemoteBreakin(
	_In_ PVOID Context
	);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiIssueRemoteBreakin(
	_In_ HANDLE Process
	);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConvertStateChangeStructure(
	_In_ PDBGUI_WAIT_STATE_CHANGE StateChange,
	_Out_ DEBUG_EVENT *DebugEvent
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
	_In_opt_ PCWSTR DllPath,
	_In_opt_ PULONG DllCharacteristics,
	_In_ PUNICODE_STRING DllName,
	_Out_ PVOID *DllHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
	_In_opt_ PCWSTR DllPath,
	_In_opt_ PULONG DllCharacteristics,
	_In_ PUNICODE_STRING DllName,
	_Out_ PVOID *DllHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleEx(
	_In_ ULONG Flags,
	_In_opt_ PCWSTR DllPath,
	_In_opt_ PULONG DllCharacteristics,
	_In_ PUNICODE_STRING DllName,
	_Out_opt_ PVOID *DllHandle
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
	_In_ PVOID Base,
	_Out_ PVOID *DllHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByName(
	_In_opt_ PUNICODE_STRING BaseDllName,
	_In_opt_ PUNICODE_STRING FullDllName,
	_Out_ PVOID *DllHandle
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
	_In_ PVOID DllHandle,
	_In_opt_ CONST PANSI_STRING ProcedureName,
	_In_opt_ ULONG ProcedureNumber,
	_Out_ PVOID *ProcedureAddress
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressEx(
	_In_ PVOID DllHandle,
	_In_opt_ PANSI_STRING ProcedureName,
	_In_opt_ ULONG ProcedureNumber,
	_Out_ PVOID *ProcedureAddress,
	_In_ ULONG Flags
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrLockLoaderLock(
	_In_ ULONG Flags,
	_Out_opt_ ULONG *Disposition,
	_Out_ PVOID *Cookie
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnlockLoaderLock(
	_In_ ULONG Flags,
	_Inout_ PVOID Cookie
	);

NTSYSAPI
PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
	_In_ ULONG_PTR VA,
	_In_ ULONG SizeOfBlock,
	_In_ PUSHORT NextOffset,
	_In_ LONG_PTR Diff
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnloadDll(
	_In_ PVOID DllHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll(
	_In_ PVOID DllHandle
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
LdrOpenImageFileOptionsKey(
	_In_ PUNICODE_STRING SubKey,
	_In_ BOOLEAN Wow64,
	_Out_ PHANDLE NewKeyHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileKeyOption(
	_In_ HANDLE KeyHandle,
	_In_ PCWSTR ValueName,
	_In_ ULONG Type,
	_Out_ PVOID Buffer,
	_In_ ULONG BufferSize,
	_Out_opt_ PULONG ReturnedLength
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksum(
	_In_ HANDLE ImageFileHandle,
	_In_opt_ PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine,
	_In_ PVOID ImportCallbackParameter,
	_Out_opt_ PUSHORT ImageCharacteristics
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
LdrVerifyImageMatchesChecksumEx(
	_In_ HANDLE ImageFileHandle,
	_Inout_ PLDR_VERIFY_IMAGE_INFO VerifyInfo
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
LdrAccessResource(
	_In_ PVOID DllHandle,
	_In_ CONST PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry,
	_Out_opt_ PVOID *Address,
	_Out_ PULONG Size
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceDirectory_U(
	_In_ PVOID DllHandle,
	_In_ CONST LDR_RESOURCE_INFO* ResourceIdPath,
	_In_ ULONG ResourceIdPathLength,
	_Out_ PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResource_U(
	_In_ PVOID DllHandle,
	_In_ CONST LDR_RESOURCE_INFO* ResourceIdPath,
	_In_ ULONG ResourceIdPathLength,
	_Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
	);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceEx_U(
	_In_opt_ ULONG Flags,
	_In_ PVOID DllHandle,
	_In_ CONST LDR_RESOURCE_INFO* ResourceIdPath,
	_In_ ULONG ResourceIdPathLength,
	_Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
	);

NTSYSAPI
VOID
NTAPI
RtlAssert(
	_In_ PVOID VoidFailedAssertion,
	_In_ PVOID VoidFileName,
	_In_ ULONG LineNumber,
	_In_opt_ PSTR MutableMessage
	);

NTSYSAPI
DECLSPEC_NORETURN
VOID
NTAPI
RtlRaiseStatus(
	_In_ NTSTATUS Status
	);

NTSYSAPI
VOID
NTAPI
RtlRaiseException(
	_In_ PEXCEPTION_RECORD ExceptionRecord
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlConnectToSm(
	_In_ PUNICODE_STRING ApiPortName,
	_In_ HANDLE ApiPortHandle,
	_In_ DWORD ProcessImageType,
	_Out_ PHANDLE SmssConnection
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSendMsgToSm(
	_In_ HANDLE ApiPortHandle,
	_In_ PPORT_MESSAGE MessageData
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlRegisterThreadWithCsrss(
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
	_Inout_ PRTL_CRITICAL_SECTION CriticalSection
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
	_Inout_ PRTL_CRITICAL_SECTION CriticalSection
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLocked(
	_In_ PRTL_CRITICAL_SECTION CriticalSection
	);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread(
	_In_ PRTL_CRITICAL_SECTION CriticalSection
	);

NTSYSAPI
ULONG
NTAPI
RtlGetCriticalSectionRecursionCount(
	_In_ PRTL_CRITICAL_SECTION CriticalSection
	);
#endif

NTSYSAPI
LOGICAL
NTAPI
RtlTryEnterCriticalSection(
	_Inout_ PRTL_CRITICAL_SECTION CriticalSection
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
	_Out_ PRTL_CRITICAL_SECTION CriticalSection
	);

NTSYSAPI
VOID
NTAPI
RtlEnableEarlyCriticalSectionEventCreation(
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
	_Out_ PRTL_CRITICAL_SECTION CriticalSection,
	_In_ ULONG SpinCount
	);

NTSYSAPI
ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
	_Inout_ PRTL_CRITICAL_SECTION CriticalSection,
	_In_ ULONG SpinCount
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
	_Inout_ PRTL_CRITICAL_SECTION CriticalSection
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
BOOL
NTAPI
RtlQueryPerformanceFrequency(
	_Out_ PLARGE_INTEGER Frequency
	);
#else
FORCEINLINE
BOOL
NTAPI
RtlQueryPerformanceFrequency(
	_Out_ PLARGE_INTEGER Frequency
	)
{
	LARGE_INTEGER _;
	return NT_SUCCESS(NtQueryPerformanceCounter(&_,
												Frequency));
}
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
BOOL
NTAPI
RtlQueryPerformanceCounter(
	_Out_ PLARGE_INTEGER PerformanceCount
	);
#else
FORCEINLINE
BOOL
NTAPI
RtlQueryPerformanceCounter(
	_Out_ PLARGE_INTEGER PerformanceCount
	)
{
	return NT_SUCCESS(NtQueryPerformanceCounter(PerformanceCount,
												NULL));
}
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
	_In_ USHORT CompressionFormatAndEngine,
	_Out_ PULONG CompressBufferWorkSpaceSize,
	_Out_ PULONG CompressFragmentWorkSpaceSize
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
	_In_ USHORT CompressionFormatAndEngine,
	_In_ PUCHAR UncompressedBuffer,
	_In_ ULONG UncompressedBufferSize,
	_Out_ PUCHAR CompressedBuffer,
	_In_ ULONG CompressedBufferSize,
	_In_ ULONG UncompressedChunkSize,
	_Out_ PULONG FinalCompressedSize,
	_In_ PVOID WorkSpace
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
	_In_ USHORT CompressionFormat,
	_Out_ PUCHAR UncompressedBuffer,
	_In_ ULONG UncompressedBufferSize,
	_In_ PUCHAR CompressedBuffer,
	_In_ ULONG CompressedBufferSize,
	_Out_ PULONG FinalUncompressedSize
	);

NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
	_In_ ULONG Flags,
	_In_opt_ PVOID HeapBase,
	_In_opt_ SIZE_T ReserveSize,
	_In_opt_ SIZE_T CommitSize,
	_In_opt_ PVOID Lock,
	_In_opt_ PRTL_HEAP_PARAMETERS Parameters
	);

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
	_Inout_ PVOID HeapHandle
	);

NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
	_In_ PVOID HeapHandle,
	_In_opt_ ULONG Flags,
	_In_ SIZE_T Size
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
	_In_ PVOID HeapHandle,
	_In_opt_ ULONG Flags,
	_Inout_opt_ PVOID BaseAddress
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlWalkHeap(
	_In_ PVOID HeapHandle,
	_Inout_ PRTL_HEAP_WALK_ENTRY Entry
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryHeapInformation(
	_In_ PVOID HeapHandle,
	_In_ HEAP_INFORMATION_CLASS HeapInformationClass,
	_Out_opt_ PVOID HeapInformation,
	_In_opt_ SIZE_T HeapInformationLength,
	_Out_opt_ PSIZE_T ReturnLength
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetHeapInformation(
	_In_ PVOID HeapHandle,
	_In_ HEAP_INFORMATION_CLASS HeapInformationClass,
	_In_opt_ PVOID HeapInformation,
	_In_opt_ SIZE_T HeapInformationLength
	);

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags,
	_In_ PVOID BaseAddress
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags
	);

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
	_In_ PVOID HeapHandle,
	_In_ BOOLEAN MakeReadOnly
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlLockHeap(
	_In_ PVOID HeapHandle
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlUnlockHeap(
	_In_ PVOID HeapHandle
	);

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags,
	_Inout_opt_ PVOID BaseAddress,
	_In_ SIZE_T Size
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlGetUserInfoHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags,
	_In_ PVOID BaseAddress,
	_Out_opt_ PVOID *UserValue,
	_Out_opt_ PULONG UserFlags
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlSetUserValueHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags,
	_In_ PVOID BaseAddress,
	_In_ PVOID UserValue
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlSetUserFlagsHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags,
	_In_ PVOID BaseAddress,
	_In_ ULONG UserFlagsReset,
	_In_ ULONG UserFlagsSet
	);

NTSYSAPI
ULONG
NTAPI
RtlCreateTagHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags,
	_In_opt_ PWSTR TagPrefix,
	_In_ PWSTR TagNames
	);

NTSYSAPI
PWSTR
NTAPI
RtlQueryTagHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags,
	_In_ USHORT TagIndex,
	_In_ BOOLEAN ResetCounters,
	_Out_opt_ PRTL_HEAP_TAG_INFO TagInfo
	);

NTSYSAPI
SIZE_T
NTAPI
RtlCompactHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateHeap(
	_In_ PVOID HeapHandle,
	_In_ ULONG Flags,
	_In_ PVOID BaseAddress
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateProcessHeaps(
	);

NTSYSAPI
ULONG
NTAPI
RtlGetProcessHeaps(
	_In_ ULONG NumberOfHeaps,
	_Out_ PVOID *ProcessHeaps
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlEnumProcessHeaps(
	_In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
	_In_ PVOID Parameter
	);

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
	_In_ PLARGE_INTEGER Time,
	_Out_ PTIME_FIELDS TimeFields
	);

NTSYSAPI
ULONG
NTAPI
RtlUniform(
	_Inout_ PULONG Seed
	);

NTSYSAPI
ULONG
NTAPI
RtlRandom(
	_Inout_ PULONG Seed
	);

NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
	_Inout_ PULONG Seed
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlFindMessage(
	_In_ PVOID DllHandle,
	_In_ ULONG MessageTableId,
	_In_ ULONG MessageLanguageId,
	_In_ ULONG MessageId,
	_Out_ PMESSAGE_RESOURCE_ENTRY *MessageEntry
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatMessage(
	_In_ PCWSTR MessageFormat,
	_In_ ULONG MaximumWidth,
	_In_ BOOLEAN IgnoreInserts,
	_In_ BOOLEAN ArgumentsAreAnsi,
	_In_ BOOLEAN ArgumentsAreAnArray,
	_In_ va_list *Arguments,
	_Out_ PWSTR Buffer,
	_In_ ULONG Length,
	_Out_opt_ PULONG ReturnLength
	);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
	_In_ NTSTATUS Status
	);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
	_In_ NTSTATUS Status
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
	);

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
	);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
	_In_ NTSTATUS Status
	);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
	_In_ LONG Win32Error
	);

NTSYSAPI
VOID
NTAPI
RtlRestoreLastWin32Error(
	_In_ LONG Win32Error
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
ULONG
NTAPI
RtlGetThreadErrorMode(
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetThreadErrorMode(
	_In_ ULONG NewMode,
	_Out_opt_ PULONG OldMode
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
	_Out_ PUNICODE_STRING DestinationString,
	_In_ PCUNICODE_STRING SourceString,
	_In_ BOOLEAN AllocateDestinationString
	);

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
	_Out_ PUNICODE_STRING DestinationString,
	_In_opt_ PCWSTR SourceString
	);

NTSYSAPI
VOID
NTAPI
RtlInitAnsiString(
	_Out_ PANSI_STRING DestinationString,
	_In_opt_ PCSTR SourceString
	);

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
	_Out_ PUNICODE_STRING DestinationString,
	_In_ PCUNICODE_STRING SourceString
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
	_In_ PUNICODE_STRING Destination,
	_In_opt_ PCWSTR Source
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
	_Inout_ PUNICODE_STRING DestinationString,
	_In_ PCANSI_STRING SourceString,
	_In_ BOOLEAN AllocateDestinationString
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
	_Inout_ PANSI_STRING DestinationString,
	_In_ PCUNICODE_STRING SourceString,
	_In_ BOOLEAN AllocateDestinationString
	);

NTSYSAPI
CHAR
NTAPI
RtlUpperChar(
	_In_ CHAR Character
	);

_Must_inspect_result_
NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixString(
	_In_ PCSTRING String1,
	_In_ PCSTRING String2,
	_In_ BOOLEAN CaseInSensitive
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendStringToString(
	_In_ PSTRING Destination,
	_In_ PCSTRING Source
	);

NTSYSAPI
VOID
NTAPI
RtlUpperString(
	_In_ PSTRING DestinationString,
	_In_ PCSTRING SourceString
	);

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
	_Inout_ PANSI_STRING AnsiString
	);

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
	_In_ PUNICODE_STRING UnicodeString
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger(
	_In_ PCUNICODE_STRING String,
	_In_opt_ ULONG Base,
	_Out_ PULONG Value
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDefaultNpAcl(
	_Out_ PACL *Dacl
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateRegistryKey(
	_In_ ULONG RelativeTo,
	_In_ PWSTR Path
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
	_In_ ULONG RelativeTo,
	_In_ PCWSTR Path,
	_Inout_ PRTL_QUERY_REGISTRY_TABLE QueryTable,
	_In_opt_ PVOID Context,
	_In_opt_ PVOID Environment
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlWriteRegistryValue(
	_In_ ULONG RelativeTo,
	_In_ PCWSTR Path,
	_In_ PCWSTR ValueName,
	_In_ ULONG ValueType,
	_In_opt_ PVOID ValueData,
	_In_ ULONG ValueLength
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
	_In_ BOOLEAN CloneCurrentEnvironment,
	_Out_ PVOID *Environment
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironmentEx(
	_In_ PVOID SourceEnv,
	_Out_ PVOID *Environment,
	_In_ ULONG Flags
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
	_In_ PVOID Environment
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
	_In_ PVOID Environment,
	_Out_opt_ PVOID *PreviousEnvironment
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVar(
	_In_opt_ PWSTR *Environment,
	_In_ PWSTR Name,
	_In_ SIZE_T NameLength,
	_In_ PWSTR Value,
	_In_ SIZE_T ValueLength
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
	_In_opt_ PVOID *Environment,
	_In_ PUNICODE_STRING Name,
	_In_ PUNICODE_STRING Value
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable(
	_In_opt_ PVOID Environment,
	_In_ PWSTR Name,
	_In_ SIZE_T NameLength,
	_Out_ PWSTR Value,
	_In_ SIZE_T ValueLength,
	_Out_ PSIZE_T ReturnLength
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U(
	_In_opt_ PVOID Environment,
	_In_ PUNICODE_STRING Name,
	_Out_ PUNICODE_STRING Value
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings(
	_In_opt_ PVOID Environment,
	_In_ PWSTR Src,
	_In_ SIZE_T SrcLength,
	_Out_ PWSTR Dst,
	_In_ SIZE_T DstLength,
	_Out_opt_ PSIZE_T ReturnLength
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
	_In_opt_ PVOID Environment,
	_In_ PUNICODE_STRING Source,
	_Out_ PUNICODE_STRING Destination,
	_Out_opt_ PULONG ReturnedLength
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentStrings(
	_In_ PWCHAR NewEnvironment,
	_In_ SIZE_T NewEnvironmentSize
	);
#endif

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
HANDLE
NTAPI
RtlGetCurrentTransaction(
	);

NTSYSAPI
LOGICAL
NTAPI
RtlSetCurrentTransaction(
	_In_ HANDLE TransactionHandle
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
	_Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
	_In_ PUNICODE_STRING ImagePathName,
	_In_opt_ PUNICODE_STRING DllPath,
	_In_opt_ PUNICODE_STRING CurrentDirectory,
	_In_opt_ PUNICODE_STRING CommandLine,
	_In_opt_ PVOID Environment,
	_In_opt_ PUNICODE_STRING WindowTitle,
	_In_opt_ PUNICODE_STRING DesktopInfo,
	_In_opt_ PUNICODE_STRING ShellInfo,
	_In_opt_ PUNICODE_STRING RuntimeData
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParametersEx(
	_Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
	_In_ PUNICODE_STRING ImagePathName,
	_In_opt_ PUNICODE_STRING DllPath,
	_In_opt_ PUNICODE_STRING CurrentDirectory,
	_In_opt_ PUNICODE_STRING CommandLine,
	_In_opt_ PVOID Environment,
	_In_opt_ PUNICODE_STRING WindowTitle,
	_In_opt_ PUNICODE_STRING DesktopInfo,
	_In_opt_ PUNICODE_STRING ShellInfo,
	_In_opt_ PUNICODE_STRING RuntimeData,
	_In_ ULONG Flags // Pass RTL_USER_PROCESS_PARAMETERS_NORMALIZED to keep parameters normalized
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
	_In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
	);

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlNormalizeProcessParams(
	_Inout_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
	);

NTSYSAPI
PRTL_USER_PROCESS_PARAMETERS
NTAPI
RtlDeNormalizeProcessParams(
	_Inout_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
	_In_ PUNICODE_STRING NtImagePathName,
	_In_ ULONG AttributesDeprecated,
	_In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
	_In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
	_In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
	_In_opt_ HANDLE ParentProcess,
	_In_ BOOLEAN InheritHandles,
	_In_opt_ HANDLE DebugPort,
	_In_opt_ HANDLE TokenHandle, // used to be ExceptionPort
	_Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformation
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
	_In_ HANDLE Process,
	_In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
	_In_ BOOLEAN CreateSuspended,
	_In_opt_ ULONG ZeroBits,
	_In_opt_ SIZE_T MaximumStackSize,
	_In_opt_ SIZE_T CommittedStackSize,
	_In_ PUSER_THREAD_START_ROUTINE StartAddress,
	_In_opt_ PVOID Parameter,
	_Out_opt_ PHANDLE Thread,
	_Out_opt_ PCLIENT_ID ClientId
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlExitUserThread(
	_In_ NTSTATUS ExitStatus
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDosApplyFileIsolationRedirection_Ustr(
	_In_ ULONG Flags,
	_In_ PUNICODE_STRING OriginalName,
	_In_ PUNICODE_STRING Extension,
	_Inout_ PUNICODE_STRING StaticString,
	_Inout_ PUNICODE_STRING DynamicString,
	_Inout_ PUNICODE_STRING *NewName,
	_In_ PULONG NewFlags,
	_In_ PSIZE_T FileNameSize,
	_In_ PSIZE_T RequiredLength
	);

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
	_In_ PVOID ImageBase
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
	_In_opt_ ULONG Flags,
	_In_ PVOID Base,
	_In_ ULONG64 Size,
	_Out_ PIMAGE_NT_HEADERS *OutHeaders
	);
#endif

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
	_In_ PVOID ImageBase,
	_In_ BOOLEAN MappedAsImage,
	_In_ USHORT DirectoryEntry,
	_Out_ PULONG Size
	);

NTSYSAPI
PVOID
NTAPI
RtlPcToFileHeader(
	_In_ PVOID PcValue,
	_Out_ PVOID *BaseOfImage
	);

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable(
	_In_ PIMAGE_NT_HEADERS NtHeaders,
	_In_ PVOID BaseOfImage,
	_In_ ULONG VirtualAddress
	);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
	_In_ PIMAGE_NT_HEADERS NtHeaders,
	_In_ PVOID Base,
	_In_ ULONG Rva
	);

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
	_In_ PIMAGE_NT_HEADERS NtHeaders,
	_In_ PVOID Base,
	_In_ ULONG Rva,
	_Inout_opt_ PIMAGE_SECTION_HEADER *LastRvaSection
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessHeapInformation(
	_Inout_ PRTL_DEBUG_INFORMATION Buffer
	);

NTSYSAPI
PRTL_DEBUG_INFORMATION
NTAPI
RtlCreateQueryDebugBuffer(
	_In_opt_ ULONG MaximumCommit,
	_In_ BOOLEAN UseEventPair
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryProcessDebugInformation(
	_In_ HANDLE UniqueProcessId,
	_In_ ULONG Flags,
	_Inout_ PRTL_DEBUG_INFORMATION Buffer
	);

#ifdef _WIN64
NTSYSAPI
VOID
WINAPI
RtlRestoreContext(
	_In_ PCONTEXT ContextRecord,
	_In_opt_ PEXCEPTION_RECORD ExceptionRecord
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
	_In_ ULONG Privilege,
	_In_ BOOLEAN Enable,
	_In_ BOOLEAN Client,
	_Out_ PBOOLEAN WasEnabled
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
RtlAcquirePrivilege(
	_In_ PULONG Privilege,
	_In_ ULONG NumPriv,
	_In_ ULONG Flags,
	_Out_ PVOID *ReturnedState
	);

NTSYSAPI
VOID
NTAPI
RtlReleasePrivilege(
	_In_ PVOID StatePointer
	);
#endif

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
	_In_ PCWSTR DosFileName,
	_Out_ PUNICODE_STRING NtFileName,
	_Out_opt_ PWSTR *FilePart,
	_Reserved_ PVOID Reserved
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToRelativeNtPathName_U(
	_In_ PCWSTR DosFileName,
	_Out_ PUNICODE_STRING NtFileName,
	_Out_opt_ PWSTR *FilePart,
	_Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDosPathNameToRelativeNtPathName_U_WithStatus(
	_In_ PWSTR DosFileName,
	_Out_ PUNICODE_STRING NtFileName,
	_Out_opt_ PWSTR *FilePart,
	_Out_opt_ PRTL_RELATIVE_NAME_U RelativeName
	);
#endif

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_U(
	_In_ PCWSTR Path
	);

NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_U(
	_In_ PWSTR DosFileName
	);

NTSYSAPI
ULONG
NTAPI
RtlGetFullPathName_U(
	_In_ PWSTR FileName,
	_In_ ULONG BufferLength,
	_Out_writes_bytes_(BufferLength) PWSTR Buffer,
	_Out_opt_ PWSTR *FilePart
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
RtlGetFullPathName_UEx(
	_In_ PWSTR FileName,
	_In_ ULONG BufferLength,
	_Out_writes_bytes_(BufferLength) PWSTR Buffer,
	_Out_opt_ PWSTR *FilePart,
	_Out_opt_ ULONG *BytesRequired
	);
#endif

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
NTSTATUS
NTAPI
RtlGetFullPathName_UstrEx(
	_In_ PUNICODE_STRING FileName,
	_Inout_ PUNICODE_STRING StaticString,
	_Out_opt_ PUNICODE_STRING DynamicString,
	_Out_opt_ PUNICODE_STRING *StringUsed,
	_Out_opt_ SIZE_T *FilePartPrefixCch,
	_Out_opt_ PBOOLEAN NameInvalid,
	_Out_ RTL_PATH_TYPE *InputPathType,
	_Out_opt_ SIZE_T *BytesRequired
	);
#endif

NTSYSAPI
ULONG
NTAPI
RtlGetCurrentDirectory_U(
	_In_ ULONG BufferLength,
	_Out_writes_bytes_(BufferLength) PWSTR Buffer
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentDirectory_U(
	_In_ PUNICODE_STRING PathName
	);

#if NTDDI_VERSION >= NTDDI_WS03
NTSYSAPI
VOID
NTAPI
RtlReleaseRelativeName(
	_In_ PRTL_RELATIVE_NAME_U RelativeName
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
RtlNtPathNameToDosPathName(
	_In_ ULONG Flags,
	_Inout_ PRTL_UNICODE_STRING_BUFFER Path,
	_Out_opt_ PULONG Disposition,
	_Inout_opt_ PWSTR* FilePart
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
VOID
NTAPI
RtlInitializeSRWLock(
	_Out_ PRTL_SRWLOCK SRWLock
	);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockExclusive(
	_Inout_ PRTL_SRWLOCK SRWLock
	);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockShared(
	_Inout_ PRTL_SRWLOCK SRWLock
	);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockExclusive(
	_Inout_ PRTL_SRWLOCK SRWLock
	);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockShared(
	_Inout_ PRTL_SRWLOCK SRWLock
	);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockExclusive(
	_Inout_ PRTL_SRWLOCK SRWLock
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockShared(
	_Inout_ PRTL_SRWLOCK SRWLock
	);

NTSYSAPI
VOID
NTAPI
RtlAcquireReleaseSRWLockExclusive(
	_Inout_ PRTL_SRWLOCK SRWLock
	);
#endif

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain(
	_Out_ PVOID *Callers,
	_In_ ULONG Count,
	_In_ ULONG Flags
	);

NTSYSAPI
PPREFIX_TABLE_ENTRY
NTAPI
PfxFindPrefix(
	_In_ PPREFIX_TABLE PrefixTable,
	_In_ PANSI_STRING FullName
	);

NTSYSAPI
VOID
NTAPI
PfxInitialize(
	_Out_ PPREFIX_TABLE PrefixTable
	);

NTSYSAPI
BOOLEAN
NTAPI
PfxInsertPrefix(
	_In_ PPREFIX_TABLE PrefixTable,
	_In_ PANSI_STRING Prefix,
	_Out_ PPREFIX_TABLE_ENTRY PrefixTableEntry
	);

NTSYSAPI
VOID
NTAPI
PfxRemovePrefix(
	_In_ PPREFIX_TABLE PrefixTable,
	_In_ PPREFIX_TABLE_ENTRY PrefixTableEntry
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
	_In_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
	_Out_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
	_Inout_ PULONG BufferLength
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
	_Inout_ PACL Acl,
	_In_ ULONG AceRevision,
	_In_ ACCESS_MASK AccessMask,
	_In_ PSID Sid
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
	_Inout_ PACL Acl,
	_In_ ULONG AceRevision,
	_In_ ULONG AceFlags,
	_In_ ACCESS_MASK AccessMask,
	_In_ PSID Sid
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
	_Inout_ PACL Acl,
	_In_ ULONG AceRevision,
	_In_ ULONG StartingAceIndex,
	_In_ PVOID AceList,
	_In_ ULONG AceListLength
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAtomToAtomTable(
	_In_ PVOID AtomTableHandle,
	_In_ PWSTR AtomName,
	_Inout_opt_ PRTL_ATOM Atom
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
	PUNICODE_STRING Destination,
	PCUNICODE_STRING Source
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAllAccessesGranted(
	_In_ ACCESS_MASK GrantedAccess,
	_In_ ACCESS_MASK DesiredAccess
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreAnyAccessesGranted(
	_In_ ACCESS_MASK GrantedAccess,
	_In_ ACCESS_MASK DesiredAccess
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsClear(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG StartingIndex,
	_In_ ULONG Length
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlAreBitsSet(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG StartingIndex,
	_In_ ULONG Length
	);

NTSYSAPI
VOID
NTAPI
RtlCaptureContext(
	_Out_ PCONTEXT ContextRecord
	);

NTSYSAPI
_Success_(return != 0)
USHORT
NTAPI
RtlCaptureStackBackTrace(
	_In_ ULONG FramesToSkip,
	_In_ ULONG FramesToCapture,
	_Out_writes_to_(FramesToCapture, return) PVOID *BackTrace,
	_Out_opt_ PULONG BackTraceHash
	);

NTSYSAPI
VOID
NTAPI
RtlClearAllBits(
	_In_ PRTL_BITMAP BitMapHeader
	);

NTSYSAPI
VOID
NTAPI
RtlClearBits(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG StartingIndex,
	_In_ ULONG NumberToClear
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSystemVolumeInformationFolder(
	_In_ PCUNICODE_STRING VolumeRootPath
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
LONG
NTAPI
RtlCompareAltitudes(
	_In_ PCUNICODE_STRING Altitude1,
	_In_ PCUNICODE_STRING Altitude2
	);
#endif

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
	_In_ PCUNICODE_STRING String1,
	_In_ PCUNICODE_STRING String2,
	_In_ BOOLEAN CaseInSensitive
	);

NTSYSAPI
ULONG32
NTAPI
RtlComputeCrc32(
	_In_ ULONG32 PartialCrc,
	_In_ PVOID Buffer,
	_In_ ULONG Length
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
	_Inout_ PUNICODE_STRING UnicodeString,
	_In_ PSID Sid,
	_In_ BOOLEAN AllocateDestinationString
	);

NTSYSAPI
VOID
NTAPI
RtlCopyLuid(
	_Out_ PLUID DestinationLuid,
	_In_ PLUID SourceLuid
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
	_In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
	_In_ UCHAR SubAuthorityCount,
	_In_ ULONG SubAuthority0,
	_In_ ULONG SubAuthority1,
	_In_ ULONG SubAuthority2,
	_In_ ULONG SubAuthority3,
	_In_ ULONG SubAuthority4,
	_In_ ULONG SubAuthority5,
	_In_ ULONG SubAuthority6,
	_In_ ULONG SubAuthority7,
	_Outptr_ PSID *Sid
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
	_In_ ULONG DestinationSidLength,
	_Out_ PSID DestinationSid,
	_In_ PSID SourceSid
	);

NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
	_Inout_ PSID Sid
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
	_Out_ PACL Acl,
	_In_ ULONG AclLength,
	_In_ ULONG AclRevision
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAtomTable(
	_In_ ULONG NumberOfBuckets,
	_Out_ PVOID *AtomTableHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressFragment(
	_In_ USHORT CompressionFormat,
	_Out_ PUCHAR UncompressedFragment,
	_In_ ULONG UncompressedFragmentSize,
	_In_ PUCHAR CompressedBuffer,
	_In_ ULONG CompressedBufferSize,
	_In_ ULONG FragmentOffset,
	_Out_ PULONG FinalUncompressedSize,
	_In_ PVOID WorkSpace
	);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlDelete(
	_In_ PRTL_SPLAY_LINKS Links
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
	_Inout_ PACL Acl,
	_In_ ULONG AceIndex
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAtomFromAtomTable(
	_In_ PVOID AtomTableHandle,
	_In_ RTL_ATOM Atom
	);

NTSYSAPI
VOID
NTAPI
RtlDeleteNoSplay(
	_In_ PRTL_SPLAY_LINKS Links,
	_Inout_ PRTL_SPLAY_LINKS *Root
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
	_Out_ PUNICODE_STRING DestinationString,
	_In_ PCUNICODE_STRING SourceString,
	_In_ BOOLEAN AllocateDestinationString
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
	_In_ ULONG Flags,
	_In_ UNICODE_STRING *StringIn,
	_Out_ UNICODE_STRING *StringOut
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlEmptyAtomTable(
	_In_ PVOID AtomTableHandle,
	_In_ BOOLEAN IncludePinnedAtoms
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
	_In_ PSID Sid1,
	_In_ PSID Sid2
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualString(
	_In_ PANSI_STRING String1,
	_In_ PANSI_STRING String2,
	_In_ BOOLEAN CaseInSensitive
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
	_In_ PCUNICODE_STRING String1,
	_In_ PCUNICODE_STRING String2,
	_In_ BOOLEAN CaseInSensitive
	);

NTSYSAPI
ULONG
NTAPI
RtlFindClearBits(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG NumberToFind,
	_In_ ULONG HintIndex
	);

NTSYSAPI
ULONG
NTAPI
RtlFindClearBitsAndSet(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG NumberToFind,
	_In_ ULONG HintIndex
	);

NTSYSAPI
ULONG
NTAPI
RtlFindClearRuns(
	_In_ PRTL_BITMAP BitMapHeader,
	_Out_ PRTL_BITMAP_RUN RunArray,
	_In_ ULONG SizeOfRunArray,
	_In_ BOOLEAN LocateLongestRuns
	);

NTSYSAPI
ULONG
NTAPI
RtlFindLastBackwardRunClear(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG FromIndex,
	_In_ PULONG StartingRunIndex
	);

NTSYSAPI
CCHAR
NTAPI
RtlFindLeastSignificantBit(
	_In_ ULONGLONG Set
	);

NTSYSAPI
ULONG
NTAPI
RtlFindLongestRunClear(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ PULONG StartingIndex
	);

NTSYSAPI
CCHAR
NTAPI
RtlFindMostSignificantBit(
	_In_ ULONGLONG Set
	);

NTSYSAPI
ULONG
NTAPI
RtlFindNextForwardRunClear(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG FromIndex,
	_In_ PULONG StartingRunIndex
	);

NTSYSAPI
ULONG
NTAPI
RtlFindSetBits(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG NumberToFind,
	_In_ ULONG HintIndex
	);

NTSYSAPI
ULONG
NTAPI
RtlFindSetBitsAndClear(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG NumberToFind,
	_In_ ULONG HintIndex
	);

NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
	_Out_ PVOID *CallersAddress,
	_Out_ PVOID *CallersCaller
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_Out_ PBOOLEAN DaclPresent,
	_Out_ PACL *Dacl,
	_Out_ PBOOLEAN DaclDefaulted
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_Out_ PSID *Group,
	_Out_ PBOOLEAN GroupDefaulted
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_Out_ PSID *Owner,
	_Out_ PBOOLEAN OwnerDefaulted
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_Out_ PBOOLEAN SaclPresent,
	_Out_ PACL *Sacl,
	_Out_ PBOOLEAN SaclDefaulted
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSetBootStatusData(
	_In_ HANDLE Handle,
	_In_ BOOLEAN Get,
	_In_ RTL_BSD_ITEM_TYPE DataItem,
	_In_ PVOID DataBuffer,
	_In_ ULONG DataBufferLength,
	_Out_opt_ PULONG ByteRead
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateBootStatusDataFile(
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
	_Out_ PRTL_OSVERSIONINFOW lpVersionInformation
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
	_In_ PUNICODE_STRING GuidString,
	_Out_ GUID* Guid
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
	_In_ UNICODE_STRING *String,
	_In_ BOOLEAN CaseInSensitive,
	_In_ ULONG HashAlgorithm,
	_Out_ PULONG HashValue
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
	_Out_ PSID Sid,
	_In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
	_In_ UCHAR SubAuthorityCount
	);

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
	_In_ ULONG SubAuthorityCount
	);

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor
	);

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
	_In_ PSID Sid
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlLockBootStatusData(
	_Out_ PHANDLE BootStatusDataHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlLookupAtomInAtomTable(
	_In_ PVOID AtomTableHandle,
	_In_ PWSTR AtomName,
	_Out_opt_ PRTL_ATOM Atom
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlMapSecurityErrorToNtStatus(
	_In_ SECURITY_STATUS Error
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeN(
	_Out_ PWCH UnicodeString,
	_In_ ULONG MaxBytesInUnicodeString,
	_Out_opt_ PULONG BytesInUnicodeString,
	_In_ PCSTR MultiByteString,
	_In_ ULONG BytesInMultiByteString
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlMultiByteToUnicodeSize(
	_Out_ PULONG BytesInUnicodeString,
	_In_ PCSTR MultiByteString,
	_In_ ULONG BytesInMultiByteString
	);

NTSYSAPI
ULONG
NTAPI
RtlNumberOfClearBits(
	_In_ PRTL_BITMAP BitMapHeader
	);

NTSYSAPI
ULONG
NTAPI
RtlNumberOfSetBits(
	_In_ PRTL_BITMAP BitMapHeader
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryAtomInAtomTable(
	_In_ PVOID AtomTableHandle,
	_In_ RTL_ATOM Atom,
	_Out_opt_ PULONG AtomUsage,
	_Out_opt_ PULONG AtomFlags,
	_Inout_opt_ PWSTR AtomName,
	_Inout_opt_ PULONG AtomNameLength
	);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealPredecessor(
	_In_ PRTL_SPLAY_LINKS Links
	);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlRealSuccessor(
	_In_ PRTL_SPLAY_LINKS Links
	);

NTSYSAPI
VOID
NTAPI
RtlRunDecodeUnicodeString(
	_In_ UCHAR Seed,
	_Inout_ PUNICODE_STRING String
	);

NTSYSAPI
VOID
NTAPI
RtlRunEncodeUnicodeString(
	_In_opt_ PUCHAR Seed,
	_Inout_ PUNICODE_STRING String
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD(
	_In_ PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
	_Out_ PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
	_Inout_ PULONG AbsoluteSecurityDescriptorSize,
	_Out_ PACL Dacl,
	_Inout_ PULONG DaclSize,
	_Out_ PACL Sacl,
	_Inout_ PULONG SaclSize,
	_Out_opt_ PSID Owner,
	_Inout_ PULONG OwnerSize,
	_Out_opt_ PSID PrimaryGroup,
	_Inout_ PULONG PrimaryGroupSize
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSelfRelativeToAbsoluteSD2(
	_Inout_ PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
	_Inout_ PULONG pBufferSize
	);

NTSYSAPI
VOID
NTAPI
RtlSetAllBits(
	_In_ PRTL_BITMAP BitMapHeader
	);

NTSYSAPI
VOID
NTAPI
RtlSetBits(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG StartingIndex,
	_In_ ULONG NumberToSet
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
	_Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_ BOOLEAN DaclPresent,
	_In_opt_ PACL Dacl,
	_In_ BOOLEAN DaclDefaulted
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetGroupSecurityDescriptor(
	_Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_opt_ PSID Group,
	_In_opt_ BOOLEAN GroupDefaulted
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
	_Inout_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_opt_ PSID Owner,
	_In_ BOOLEAN OwnerDefaulted
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetSaclSecurityDescriptor(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_ BOOLEAN SaclPresent,
	_In_opt_ PACL Sacl,
	_In_opt_ BOOLEAN SaclDefaulted
	);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSplay(
	_Inout_ PRTL_SPLAY_LINKS Links
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
	_In_ REFGUID Guid,
	_Out_ PUNICODE_STRING GuidString
	);

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
	_In_ PSID Sid
	);

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
	_In_ PSID Sid,
	_In_ ULONG SubAuthority
	);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreePredecessor(
	_In_ PRTL_SPLAY_LINKS Links
	);

NTSYSAPI
PRTL_SPLAY_LINKS
NTAPI
RtlSubtreeSuccessor(
	_In_ PRTL_SPLAY_LINKS Links
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
BOOLEAN
NTAPI
RtlTestBit(
	_In_ PRTL_BITMAP BitMapHeader,
	_In_ ULONG BitNumber
	);
#endif

NTSYSAPI
VOID
NTAPI
RtlUnlockBootStatusData(
	_In_ HANDLE BootStatusDataHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
	_Out_ PSECURITY_DESCRIPTOR SecurityDescriptor,
	_In_ ULONG Revision
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptorInput,
	_In_ ULONG SecurityDescriptorLength,
	_In_ SECURITY_INFORMATION RequiredInformation
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSecurityDescriptor(
	_In_ PSECURITY_DESCRIPTOR SecurityDescriptor
	);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
	_In_ PSID Sid
	);

NTSYSAPI
NTSTATUS
NTAPI
RtlVerifyVersionInfo(
	_In_ RTL_OSVERSIONINFOEXW VersionInfo,
	_In_ ULONG TypeMask,
	_In_ ULONGLONG ConditionMask
	);

NTSYSAPI
ULONGLONG
NTAPI
VerSetConditionMask(
	_In_ ULONGLONG ConditionMask,
	_In_ ULONG TypeMask,
	_In_ UCHAR Condition
	);

#if NTDDI_VERSION >= NTDDI_VISTA
NTSYSAPI
NTSTATUS
NTAPI
TpAllocPool(
	_Out_ PTP_POOL *PoolReturn,
	_Reserved_ PVOID Reserved
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
TpDisablePoolCallbackChecks(
	_Inout_ PTP_POOL Pool
	);
#endif

NTSYSAPI
VOID
NTAPI
TpReleasePool(
	_Inout_ PTP_POOL Pool
	);

NTSYSAPI
VOID
NTAPI
TpSetPoolMaxThreads(
	_Inout_ PTP_POOL Pool,
	_In_ LONG MaxThreads
	);

NTSYSAPI
NTSTATUS
NTAPI
TpSetPoolMinThreads(
	_Inout_ PTP_POOL Pool,
	_In_ LONG MinThreads
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
TpQueryPoolStackInformation(
	_In_ PTP_POOL Pool,
	_Out_ PTP_POOL_STACK_INFORMATION PoolStackInformation
	);

NTSYSAPI
NTSTATUS
NTAPI
TpSetPoolStackInformation(
	_Inout_ PTP_POOL Pool,
	_In_ PTP_POOL_STACK_INFORMATION PoolStackInformation
	);
#endif

NTSYSAPI
NTSTATUS
NTAPI
TpAllocCleanupGroup(
	_Out_ PTP_CLEANUP_GROUP *CleanupGroupReturn
	);

NTSYSAPI
VOID
NTAPI
TpReleaseCleanupGroup(
	_Inout_ PTP_CLEANUP_GROUP CleanupGroup
	);

NTSYSAPI
VOID
NTAPI
TpReleaseCleanupGroupMembers(
	_Inout_ PTP_CLEANUP_GROUP CleanupGroup,
	_In_ LOGICAL CancelPendingCallbacks,
	_Inout_opt_ PVOID CleanupParameter
	);

NTSYSAPI
NTSTATUS
NTAPI
TpSimpleTryPost(
	_In_ PTP_SIMPLE_CALLBACK Callback,
	_Inout_opt_ PVOID Context,
	_In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
	);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocWork(
	_Out_ PTP_WORK *WorkReturn,
	_In_ PTP_WORK_CALLBACK Callback,
	_Inout_opt_ PVOID Context,
	_In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
	);

NTSYSAPI
VOID
NTAPI
TpReleaseWork(
	_Inout_ PTP_WORK Work
	);

NTSYSAPI
VOID
NTAPI
TpPostWork(
	_Inout_ PTP_WORK Work
	);

NTSYSAPI
VOID
NTAPI
TpWaitForWork(
	_Inout_ PTP_WORK Work,
	_In_ LOGICAL CancelPendingCallbacks
	);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocTimer(
	_Out_ PTP_TIMER *Timer,
	_In_ PTP_TIMER_CALLBACK Callback,
	_Inout_opt_ PVOID Context,
	_In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
	);

NTSYSAPI
VOID
NTAPI
TpReleaseTimer(
	_Inout_ PTP_TIMER Timer
	);

NTSYSAPI
VOID
NTAPI
TpSetTimer(
	_Inout_ PTP_TIMER Timer,
	_In_opt_ PLARGE_INTEGER DueTime,
	_In_ LONG Period,
	_In_opt_ LONG WindowLength
	);

NTSYSAPI
LOGICAL
NTAPI
TpIsTimerSet(
	_In_ PTP_TIMER Timer
	);

NTSYSAPI
VOID
NTAPI
TpWaitForTimer(
	_Inout_ PTP_TIMER Timer,
	_In_ LOGICAL CancelPendingCallbacks
	);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocWait(
	_Out_ PTP_WAIT *WaitReturn,
	_In_ PTP_WAIT_CALLBACK Callback,
	_Inout_opt_ PVOID Context,
	_In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
	);

NTSYSAPI
VOID
NTAPI
TpReleaseWait(
	_Inout_ PTP_WAIT Wait
	);

NTSYSAPI
VOID
NTAPI
TpSetWait(
	_Inout_ PTP_WAIT Wait,
	_In_opt_ HANDLE Handle,
	_In_opt_ PLARGE_INTEGER Timeout
	);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocIoCompletion(
	_Out_ PTP_IO *IoReturn,
	_In_ HANDLE File,
	_In_ PTP_IO_CALLBACK Callback,
	_Inout_opt_ PVOID Context,
	_In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
	);

NTSYSAPI
VOID
NTAPI
TpWaitForIoCompletion(
	_Inout_ PTP_IO Io,
	_In_ LOGICAL CancelPendingCallbacks
	);

NTSYSAPI
NTSTATUS
NTAPI
TpAllocAlpcCompletion(
	_Out_ PTP_ALPC *AlpcReturn,
	_In_ HANDLE AlpcPort,
	_In_ PTP_ALPC_CALLBACK Callback,
	_Inout_opt_ PVOID Context,
	_In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
	);

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
TpAllocAlpcCompletionEx(
	_Out_ PTP_ALPC *AlpcReturn,
	_In_ HANDLE AlpcPort,
	_In_ PTP_ALPC_CALLBACK_EX Callback,
	_Inout_opt_ PVOID Context,
	_In_opt_ PTP_CALLBACK_ENVIRON CallbackEnviron
	);
#endif

NTSYSAPI
VOID
NTAPI
TpReleaseAlpcCompletion(
	_Inout_ PTP_ALPC Alpc
	);

NTSYSAPI
VOID
NTAPI
TpWaitForAlpcCompletion(
	_Inout_ PTP_ALPC Alpc
	);
#endif

#if NTDDI_VERSION >= NTDDI_WIN7
NTSYSAPI
NTSTATUS
NTAPI
TpAlpcRegisterCompletionList(
	_Inout_ PTP_ALPC Alpc
	);

NTSYSAPI
NTSTATUS
NTAPI
TpAlpcUnregisterCompletionList(
	_Inout_ PTP_ALPC Alpc
	);
#endif

#ifdef __cplusplus
}
#endif

#endif // _NTDLL_H



================================================
File: 3rdparty/ollydbg1/ollyplugindefinitions.h
================================================
#pragma once
#include <Windows.h>

#pragma pack(1)                      // Force byte alignment of structures

#define SHORTLEN       8               // Maximal length of short name
#define TEXTLEN        256             // Maximal length of text string

#define TY_STOPAN      0x00000080      // Stop animation if TY_ONESHOT
#define TY_SET         0x00000100      // Code INT3 is in memory
#define TY_ACTIVE      0x00000200      // Permanent breakpoint
#define TY_DISABLED    0x00000400      // Permanent disabled breakpoint
#define TY_ONESHOT     0x00000800      // Temporary stop
#define TY_TEMP        0x00001000      // Temporary breakpoint
#define TY_KEEPCODE    0x00002000      // Set and keep command code
#define TY_KEEPCOND    0x00004000      // Keep condition unchanged (0: remove)
#define TY_NOUPDATE    0x00008000      // Don't redraw breakpoint window
#define TY_RTRACE      0x00010000      // Pseudotype of run trace breakpoint

//olly definitions
struct t_module;
extern "C" void _Addtolist(long addr,int highlight,char *format,...);
extern "C" void _Message(unsigned long addr,char *format,...);
extern "C" void _Error(char *format,...);
extern "C" void _Deletebreakpoints(unsigned long addr0,unsigned long addr1,int silent);
extern "C" int _Setbreakpoint(unsigned long addr,unsigned long type,unsigned char cmd);
extern "C" int _Plugingetvalue(int type);
extern "C" void _Tempbreakpoint(unsigned long addr,int mode);
extern "C" int _Gettext(char *title,char *text, char letter,int type,int fontindex);
extern "C" int _Attachtoactiveprocess(int newprocessid);
extern "C" void _Infoline(char *format,...);
extern "C" t_module* _Findmodule(unsigned long addr);
extern "C" unsigned long _Writememory(void *buf,unsigned long addr,unsigned long size,int mode);

#define NBAR 17 // Max allowed number of segments in bar
#define PLUGIN_VERSION 110
#define PM_MAIN 0 // Main window        (NULL)
#define PM_THREADS 13 // Threads window     (t_thread*)
#define VAL_HINST              1       // Current program instance
#define VAL_HWMAIN             2       // Handle of the main window
#define VAL_HWCLIENT           3       // Handle of the MDI client window
#define VAL_NCOLORS            4       // Number of common colors
#define VAL_COLORS             5       // RGB values of common colors
#define VAL_BRUSHES            6       // Handles of common color brushes
#define VAL_PENS               7       // Handles of common color pens
#define VAL_NFONTS             8       // Number of common fonts
#define VAL_FONTS              9       // Handles of common fonts
#define VAL_FONTNAMES          10      // Internal font names
#define VAL_FONTWIDTHS         11      // Average widths of common fonts
#define VAL_FONTHEIGHTS        12      // Average heigths of common fonts
#define VAL_NFIXFONTS          13      // Actual number of fixed-pitch fonts
#define VAL_DEFFONT            14      // Index of default font
#define VAL_NSCHEMES           15      // Number of color schemes
#define VAL_SCHEMES            16      // Color schemes
#define VAL_DEFSCHEME          17      // Index of default colour scheme
#define VAL_DEFHSCROLL         18      // Default horizontal scroll
#define VAL_RESTOREWINDOWPOS   19      // Restore window positions from .ini
#define VAL_HPROCESS           20      // Handle of Debuggee
#define VAL_PROCESSID          21      // Process ID of Debuggee
#define VAL_HMAINTHREAD        22      // Handle of main thread
#define VAL_MAINTHREADID       23      // Thread ID of main thread
#define VAL_MAINBASE           24      // Base of main module in the process
#define VAL_PROCESSNAME        25      // Name of the active process
#define VAL_EXEFILENAME        26      // Name of the main debugged file
#define VAL_CURRENTDIR         27      // Current directory for debugged process
#define VAL_SYSTEMDIR          28      // Windows system directory
#define VAL_DECODEANYIP        29      // Decode registers dependless on EIP
#define VAL_PASCALSTRINGS      30      // Decode Pascal-style string constants
#define VAL_ONLYASCII          31      // Only printable ASCII chars in dump
#define VAL_DIACRITICALS       32      // Allow diacritical symbols in strings
#define VAL_GLOBALSEARCH       33      // Search from the beginning of block
#define VAL_ALIGNEDSEARCH      34      // Search aligned to item's size
#define VAL_IGNORECASE         35      // Ignore case in string search
#define VAL_SEARCHMARGIN       36      // Floating search allows error margin
#define VAL_KEEPSELSIZE        37      // Keep size of hex edit selection
#define VAL_MMXDISPLAY         38      // MMX display mode in dialog
#define VAL_WINDOWFONT         39      // Use calling window's font in dialog
#define VAL_TABSTOPS           40      // Distance between tab stops
#define VAL_MODULES            41      // Table of modules (.EXE and .DLL)
#define VAL_MEMORY             42      // Table of allocated memory blocks
#define VAL_THREADS            43      // Table of active threads
#define VAL_BREAKPOINTS        44      // Table of active breakpoints
#define VAL_REFERENCES         45      // Table with found references
#define VAL_SOURCELIST         46      // Table of source files
#define VAL_WATCHES            47      // Table of watches
#define VAL_CPUFEATURES        50      // CPU feature bits
#define VAL_TRACEFILE          51      // Handle of run trace log file
#define VAL_ALIGNDIALOGS       52      // Whether to align dialogs
#define VAL_CPUDASM            53      // Dump descriptor of CPU Disassembler
#define VAL_CPUDDUMP           54      // Dump descriptor of CPU Dump
#define VAL_CPUDSTACK          55      // Dump descriptor of CPU Stack
#define VAL_APIHELP            56      // Name of selected API help file
#define VAL_HARDBP             57      // Whether hardware breakpoints enabled
#define VAL_PATCHES            58      // Table of patches
#define VAL_HINTS              59      // Sorted data with analysis hints

#define NREGSTACK      32              // Length of stack trace buffer
#define NVERS          32              // Max allowed length of file version

#define MM_RESTORE     0x01            // Restore or remove INT3 breakpoints
#define MM_SILENT      0x02            // Don't display error message
#define MM_DELANAL     0x04            // Delete analysis from the memory

typedef unsigned long  ulong;
typedef unsigned char  uchar;
typedef unsigned short ushort;

typedef struct t_reg {                 // Excerpt from context
    int            modified;             // Some regs modified, update context
    int            modifiedbyuser;       // Among modified, some modified by user
    int            singlestep;           // Type of single step, SS_xxx
    ulong          r[8];                 // EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
    ulong          ip;                   // Instruction pointer (EIP)
    ulong          flags;                // Flags
    int            top;                  // Index of top-of-stack
    long double    f[8];                 // Float registers, f[top] - top of stack
    char           tag[8];               // Float tags (0x3 - empty register)
    ulong          fst;                  // FPU status word
    ulong          fcw;                  // FPU control word
    ulong          s[6];                 // Segment registers ES,CS,SS,DS,FS,GS
    ulong          base[6];              // Segment bases
    ulong          limit[6];             // Segment limits
    char           big[6];               // Default size (0-16, 1-32 bit)
    ulong          dr6;                  // Debug register DR6
    ulong          threadid;             // ID of thread that owns registers
    ulong          lasterror;            // Last thread error or 0xFFFFFFFF
    int            ssevalid;             // Whether SSE registers valid
    int            ssemodified;          // Whether SSE registers modified
    char           ssereg[8][16];        // SSE registers
    ulong          mxcsr;                // SSE control and status register
    int            selected;             // Reports selected register to plugin
    ulong          drlin[4];             // Debug registers DR0..DR3
    ulong          dr7;                  // Debug register DR7
} t_reg;

typedef struct t_thread {              // Information about active threads
    ulong          threadid;             // Thread identifier
    ulong          dummy;                // Always 1
    ulong          type;                 // Service information, TY_xxx
    HANDLE         thread;               // Thread handle
    ulong          datablock;            // Per-thread data block
    ulong          entry;                // Thread entry point
    ulong          stacktop;             // Working variable of Listmemory()
    ulong          stackbottom;          // Working variable of Listmemory()
    CONTEXT        context;              // Actual context of the thread
    t_reg          reg;                  // Actual contents of registers
    int            regvalid;             // Whether reg is valid
    t_reg          oldreg;               // Previous contents of registers
    int            oldregvalid;          // Whether oldreg is valid
    int            suspendcount;         // Suspension count (may be negative)
    long           usertime;             // Time in user mode, 1/10th ms, or -1
    long           systime;              // Time in system mode, 1/10th ms, or -1
    ulong          reserved[16];         // Reserved for future compatibility
} t_thread;

typedef struct t_bar {
    int            nbar;                 // Number of active columns
    int            font;                 // Font used for bar segments
    int            dx[NBAR];             // Actual widths of columns, pixels
    int            defdx[NBAR];          // Default widths of columns, chars
    char           *name[NBAR];          // Column names (may be NULL)
    uchar          mode[NBAR];           // Combination of BAR_xxx bits
    int            captured;             // One of CAPT_xxx, set to CAPT_FREE
    int            active;               // Info about how mouse is captured
    int            prevx;                // Previous mouse coordinate
} t_bar;

typedef struct t_sortheader {          // Header of sorted data field
    ulong          addr;                 // Base address of the entry
    ulong          size;                 // Size address of the entry
    ulong          type;                 // Entry type, TY_xxx
} t_sortheader;

typedef int  SORTFUNC(const t_sortheader *,const t_sortheader *,const int);
typedef int  DRAWFUNC(char *,char *,int *,t_sortheader *,int);
typedef void DESTFUNC(t_sortheader *);

typedef struct t_sorted {              // Descriptor of sorted table
    char           name[MAX_PATH];       // Name of table, as appears in error
    int            n;                    // Actual number of entries
    int            nmax;                 // Maximal number of entries
    int            selected;             // Index of selected entry or -1
    ulong          seladdr;              // Base address of selected entry
    int            itemsize;             // Size of single entry
    ulong          version;              // Unique version of table
    void           *data;                // Entries, sorted by address
    SORTFUNC       *sortfunc;            // Function which sorts data or NULL
    DESTFUNC       *destfunc;            // Destructor function or NULL
    int            sort;                 // Sorting criterium (column)
    int            sorted;               // Whether indexes are sorted
    int            *index;               // Indexes, sorted by criterium
    int            suppresserr;          // Suppress multiple overflow errors
} t_sorted;

typedef struct t_table {               // Window with sorted data and bar
    HWND           hw;                   // Handle of window or NULL
    t_sorted       data;                 // Sorted data
    t_bar          bar;                  // Description of bar
    int            showbar;              // Bar: 1-displayed, 0-hidden, -1-absent
    short          hscroll;              // Horiz. scroll: 1-displayed, 0-hidden
    short          colsel;               // Column in TABLE_COLSEL window
    int            mode;                 // Combination of bits TABLE_xxx
    int            font;                 // Font used by window
    short          scheme;               // Colour scheme used by window
    short          hilite;               // Syntax highlighting used by window
    int            offset;               // First displayed row
    int            xshift;               // Shift in X direction, pixels
    DRAWFUNC       *drawfunc;            // Function which decodes table fields
} t_table;

typedef struct t_operand {             // Full decription of command's operand
    char           optype;               // DEC_xxx (mem) or DECR_xxx (reg,const)
    char           opsize;               // Size of operand
    char           regscale[8];          // Scales of registers
    char           seg;                  // Segment register
    ulong          opconst;              // Constant
} t_operand;

typedef struct t_disasm {              // Results of disassembling
    ulong          ip;                   // Instrucion pointer
    char           dump[TEXTLEN];        // Hexadecimal dump of the command
    char           result[TEXTLEN];      // Disassembled command
    char           comment[TEXTLEN];     // Brief comment
    char           opinfo[3][TEXTLEN];   // Comments to command's operands
    int            cmdtype;              // One of C_xxx
    int            memtype;              // Type of addressed variable in memory
    int            nprefix;              // Number of prefixes
    int            indexed;              // Address contains register(s)
    ulong          jmpconst;             // Constant jump address
    ulong          jmptable;             // Possible address of switch table
    ulong          adrconst;             // Constant part of address
    ulong          immconst;             // Immediate constant
    int            zeroconst;            // Whether contains zero constant
    int            fixupoffset;          // Possible offset of 32-bit fixups
    int            fixupsize;            // Possible total size of fixups or 0
    ulong          jmpaddr;              // Destination of jump/call/return
    int            condition;            // 0xFF:unconditional, 0:false, 1:true
    int            error;                // Error while disassembling command
    int            warnings;             // Combination of DAW_xxx
    int            optype[3];            // Type of operand (extended set DEC_xxx)
    int            opsize[3];            // Size of operand, bytes
    int            opgood[3];            // Whether address and data valid
    ulong          opaddr[3];            // Address if memory, index if register
    ulong          opdata[3];            // Actual value (only integer operands)
    t_operand      op[3];                // Full description of operand
    ulong          regdata[8];           // Registers after command is executed
    int            regstatus[8];         // Status of registers, one of RST_xxx
    ulong          addrdata;             // Traced memory address
    int            addrstatus;           // Status of addrdata, one of RST_xxx
    ulong          regstack[NREGSTACK];  // Stack tracing buffer
    int            rststatus[NREGSTACK]; // Status of stack items
    int            nregstack;            // Number of items in stack trace buffer
    ulong          reserved[29];         // Reserved for plugin compatibility
} t_disasm;

typedef ulong SPECFUNC(char *,ulong,ulong,ulong,t_disasm *,int);

typedef struct t_dump {                // Current status of dump window
    t_table        table;                // Treat dump window as custom table
    int            dimmed;               // Draw in lowcolor if nonzero
    ulong          threadid;             // Use decoding and registers if not 0
    int            dumptype;             // Current dump type, DU_xxx+count+size
    SPECFUNC       *specdump;            // Decoder of DU_SPEC dump types
    int            menutype;             // Standard menues, MT_xxx
    int            itemwidth;            // Length of displayed item, characters
    int            showstackframes;      // Show stack frames in address dump
    int            showstacklocals;      // Show names of locals in stack
    int            commentmode;          // 0: comment, 1: source, 2: profile
    char           filename[MAX_PATH];   // Name of displayed or backup file
    ulong          base;                 // Start of memory block or file
    ulong          size;                 // Size of memory block or file
    ulong          addr;                 // Address of first displayed byte
    ulong          lastaddr;             // Address of last displayed byte + 1
    ulong          sel0;                 // Address of first selected byte
    ulong          sel1;                 // Last selected byte (not included!)
    ulong          startsel;             // Start of last selection
    int            captured;             // Mouse is captured by dump
    ulong          reladdr;              // Addresses relative to this
    char           relname[SHORTLEN];    // Symbol for relative zero address base
    uchar          *filecopy;            // Copy of the file or NULL
    uchar          *backup;              // Old backup of memory/file or NULL
    int            runtraceoffset;       // Offset back in run trace
    ulong          reserved[8];          // Reserved for the future extentions
} t_dump;

typedef struct t_stringtable {         // Pointers to string resources
    ulong          name;                 // Name of block of strings
    ulong          language;             // Language identifier
    ulong          addr;                 // Address of block in memory
    ulong          size;                 // Size of block in memory
} t_stringtable;

typedef struct t_fixup {
    ulong          base;                 // Address of fixup
    ulong          size;                 // Size of fixup (usually 2 or 4 bytes)
} t_fixup;

typedef struct t_symvar {              // Symbolic variable from debug data
    int            next;                 // Index of next variable in chain or -1
    ushort         kind;                 // Kind of variable
    union {
        ulong        type;                 // Type of variable
        ulong        regs;
    };              // Registers in optvar
    union {
        ulong        addr;                 // Address or description of registers
        long         offset;
    };            // Offset for EBP-relative data
    ulong          size;                 // Size of variable or optvar data
    int            optvar;               // Index of optvar chain or -1
    ulong          nameaddr;             // NM_DEBUG address of var's name
} t_symvar;

typedef struct t_jdest {               // Element of jump data
    char           type;                 // Type of jump, one of JT_xxx
    ulong          from;                 // Jump source
    ulong          to;                   // Jump destination
} t_jdest;

typedef struct t_module {              // Executable module descriptor
    ulong          base;                 // Base address of module
    ulong          size;                 // Size occupied by module
    ulong          type;                 // Service information, TY_xxx
    ulong          codebase;             // Base address of module code block
    ulong          codesize;             // Size of module code block
    ulong          resbase;              // Base address of resources
    ulong          ressize;              // Size of resources
    t_stringtable  *stringtable;         // Pointers to string resources or NULL
    int            nstringtable;         // Actual number of used stringtable
    int            maxstringtable;       // Actual number of allocated stringtable
    ulong          entry;                // Address of <ModuleEntryPoint> or NULL
    ulong          database;             // Base address of module data block
    ulong          idatatable;           // Base address of import data table
    ulong          idatabase;            // Base address of import data block
    ulong          edatatable;           // Base address of export data table
    ulong          edatasize;            // Size of export data table
    ulong          reloctable;           // Base address of relocation table
    ulong          relocsize;            // Size of relocation table
    char           name[SHORTLEN];       // Short name of the module
    char           path[MAX_PATH];       // Full name of the module
    int            nsect;                // Number of sections in the module
    IMAGE_SECTION_HEADER *sect;          // Copy of section headers from file
    ulong          headersize;           // Total size of headers in executable
    ulong          fixupbase;            // Base of image in executable file
    int            nfixup;               // Number of fixups in executable
    t_fixup        *fixup;               // Extracted fixups or NULL
    char           *codedec;             // Decoded code features or NULL
    ulong          codecrc;              // Code CRC for actual decoding
    char           *hittrace;            // Hit tracing data or NULL
    char           *hittracecopy;        // Copy of INT3-substituted code
    char           *datadec;             // Decoded data features or NULL
    t_table        namelist;             // List of module names
    t_symvar       *symvar;              // Descriptions of symbolic variables
    int            nsymvar;              // Actual number of elements in symvar
    int            maxsymvar;            // Maximal number of elements in symvar
    char           *globaltypes;         // Global types from debug info
    ulong          mainentry;            // Address of WinMain() etc. in dbg data
    ulong          realsfxentry;         // Entry of packed code or NULL
    int            updatenamelist;       // Request to update namelist
    ulong          origcodesize;         // Original size of module code block
    ulong          sfxbase;              // Base of memory block with SFX
    ulong          sfxsize;              // Size of memory block with SFX
    int            issystemdll;          // Whether system DLL
    int            processed;            // 0: not processed, 1: good, -1: bad
    int            dbghelpsym;           // 1: symbols loaded by dbghelp.dll
    char           version[NVERS];       // Version of executable file
    t_jdest        *jddata;              // Recognized jumps within the module
    int            njddata;              // Number of recognized jumps
    ulong          reserved[15];         // Reserved for plugin compatibility
} t_module;

typedef struct t_bpoint {              // Description of INT3 breakpoint
	ulong          addr;                 // Address of breakpoint
	ulong          dummy;                // Always 1
	ulong          type;                 // Type of breakpoint, TY_xxx
	char           cmd;                  // Old value of command
	ulong          passcount;            // Actual pass count
} t_bpoint;

// Dumpbackup() actions.
#define BKUP_CREATE    1               // Create or update backup copy
#define BKUP_VIEWDATA  2               // View original data
#define BKUP_VIEWCOPY  3               // View backup copy
#define BKUP_LOADCOPY  4               // Read backup copy from file
#define BKUP_SAVEDATA  5               // Save original data to file
#define BKUP_SAVECOPY  6               // Save backup copy to file
#define BKUP_DELETE    7               // Delete backup copy

extern "C" void*   cdecl _Getsortedbyselection(t_sorted *sd,int index);
extern "C" void    cdecl _Dumpbackup(t_dump *pd,int action);


// Types of names used in name functions. Note that higher-priority types have
// smaller identifiers!
#define NM_NONAME      0x00            // Undefined name
#define NM_ANYNAME     0xFF            // Name of any type
// Names saved in the data file of module they appear.
#define NM_PLUGCMD     0x30            // Plugin commands to execute at break
#define NM_LABEL       0x31            // User-defined label
#define NM_EXPORT      0x32            // Exported (global) name
#define NM_IMPORT      0x33            // Imported name
#define NM_LIBRARY     0x34            // Name from library or object file
#define NM_CONST       0x35            // User-defined constant
#define NM_COMMENT     0x36            // User-defined comment
#define NM_LIBCOMM     0x37            // Comment from library or object file
#define NM_BREAK       0x38            // Condition related with breakpoint
#define NM_ARG         0x39            // Arguments decoded by analyzer
#define NM_ANALYSE     0x3A            // Comment added by analyzer
#define NM_BREAKEXPR   0x3B            // Expression related with breakpoint
#define NM_BREAKEXPL   0x3C            // Explanation related with breakpoint
#define NM_ASSUME      0x3D            // Assume function with known arguments
#define NM_STRUCT      0x3E            // Code structure decoded by analyzer
#define NM_CASE        0x3F            // Case description decoded by analyzer
// Names saved in the data file of main module.
#define NM_INSPECT     0x40            // Several last inspect expressions
#define NM_WATCH       0x41            // Watch expressions
#define NM_ASM         0x42            // Several last assembled strings
#define NM_FINDASM     0x43            // Several last find assembler strings
#define NM_LASTWATCH   0x48            // Several last watch expressions
#define NM_SOURCE      0x49            // Several last source search strings
#define NM_REFTXT      0x4A            // Several last ref text search strings
#define NM_GOTO        0x4B            // Several last expressions to follow
#define NM_GOTODUMP    0x4C            // Several expressions to follow in Dump
#define NM_TRPAUSE     0x4D            // Several expressions to pause trace
// Pseudonames.
#define NM_IMCALL      0xFE            // Intermodular call

#define NMHISTORY      0x40            // Converts NM_xxx to type of init list
extern "C" int     cdecl _Insertname(ulong addr,int type,char *name);


typedef enum t_status {                // Thread/process status
	STAT_NONE=0,                         // Thread/process is empty
	STAT_STOPPED,                        // Thread/process suspended
	STAT_EVENT,                          // Processing debug event, process paused
	STAT_RUNNING,                        // Thread/process running
	STAT_FINISHED,                       // Process finished
	STAT_CLOSING                         // Process is requested to terminate
} t_status;

extern "C" t_status cdecl _Getstatus(void);



================================================
File: 3rdparty/ollydbg2/plugin.h
================================================
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                        OLLYDBG 2 PLUGIN HEADER FILE                        //
//                                                                            //
//                                Version 2.01                                //
//                                                                            //
//               Written by Oleh Yuschuk (ollydbg@t-online.de)                //
//                                                                            //
//                          Internet: www.ollydbg.de                          //
//                                                                            //
// This code is distributed "as is", without warranty of any kind, expressed  //
// or implied, including, but not limited to warranty of fitness for any      //
// particular purpose. In no event will Oleh Yuschuk be liable to you for any //
// special, incidental, indirect, consequential or any other damages caused   //
// by the use, misuse, or the inability to use of this code, including any    //
// lost profits or lost savings, even if Oleh Yuschuk has been advised of the //
// possibility of such damages.                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef __ODBG_PLUGIN_H
#define __ODBG_PLUGIN_H

#define PLUGIN_VERSION 0x02010001      // Version 2.01.0001 of plugin interface


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// IMPORTANT INFORMATION /////////////////////////////

// 1. Plugins are UNICODE libraries!
// 2. Export all callback functions by name, NOT by ordinal!
// 3. Force byte alignment of OllyDbg structures!
// 4. Set default char type to unsigned!
// 5. Most API functions are NOT thread-safe!
// 6. Read documentation!

#if !defined(_UNICODE) && !defined(UNICODE)
#error This version must be compiled with UNICODE on
#endif


////////////////////////////////////////////////////////////////////////////////
////////////// PREFERRED SETTINGS AND FIXES FOR BORLAND COMPILERS //////////////

#ifdef __BORLANDC__
#pragma option -a1                   // Byte alignment
#pragma option -K                    // Force unsigned characters!
// Redefinition of MAKELONG removes nasty warning under Borland Builder 4.0:
// boolean OR in one row with arithmetical shift.
#undef  MAKELONG
#define MAKELONG(lo,hi) ((LONG)(((WORD)(lo))|(((DWORD)((WORD)(hi)))<<16)))
#endif


////////////////////////////////////////////////////////////////////////////////
///////////// PREFERRED SETTINGS AND FIXES FOR MICROSOFT COMPILERS /////////////

// If you like Microsoft compiler, this will force byte alignment and verify
// that character is set to unsigned.
#ifdef _MSC_VER
#pragma pack(1)                      // Force byte alignment of structures
#ifndef _CHAR_UNSIGNED               // Verify that character is unsigned
#error Please set default char type to unsigned (option /J)
#endif
#endif


////////////////////////////////////////////////////////////////////////////////
//////////////////// PREFERRED SETTINGS AND FIXES FOR MINGW ////////////////////

#ifdef __MINGW32__
#pragma pack(1)                      // Force byte alignment of structures
#ifndef __CHAR_UNSIGNED__            // Verify that character is unsigned
#error Please set default char type to unsigned (option -funsigned-char)
#endif
#endif


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// GLOBAL DEFINITIONS //////////////////////////////

#ifndef _export
#define _export      __declspec(dllexport)
#endif

#ifndef _import
#define _import      __declspec(dllimport)
#endif

#ifndef _USERENTRY
#define _USERENTRY   __cdecl
#endif

#define MAKEWP(lo,hi)  ((WPARAM)MAKELONG(lo,hi))
#define MAKELP(lo,hi)  ((LPARAM)MAKELONG(lo,hi))

#define LOINT(l)       ((signed short)((WORD)(l)))
#define HIINT(l)       ((signed short)(((DWORD)(l)>>16) & 0xFFFF))

#ifndef MAXPATH
#define MAXPATH      MAX_PATH
#endif

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type,field) ((LONG)&(((type *)0)->field))
#endif

#ifndef arraysize
#define arraysize(x) (sizeof(x)/sizeof(x[0]))
#endif

#define TEXTLEN        256             // Max length of text string incl. '\0'
#define DATALEN        4096            // Max length of data record (max 65535)
#define ARGLEN         1024            // Max length of argument string
#define MAXMULTIPATH   8192            // Max length of multiple selection
#define SHORTNAME      32              // Max length of short or module name

typedef unsigned char  uchar;          // Unsigned character (byte)
typedef unsigned short ushort;         // Unsigned short
typedef unsigned int   uint;           // Unsigned integer
typedef unsigned long  ulong;          // Unsigned long

// Exports used by plugins are declared as stdapi if they use fixed number of
// arguments, and varapi if variable or if code is written in Assembler
// language (I use C calling conventions). OllyDbg variables are declared as
// oddata.

#ifdef __cplusplus
#define extc         extern "C" _export
#define stdapi(type) extern "C"               type __cdecl
#define varapi(type) extern "C"               type __cdecl
#define oddata(type) extern "C" const _import type
#define pentry(type) extern "C" _export       type __cdecl
#else
#define extc         extern     _export
#define stdapi(type) extern                   type __cdecl
#define varapi(type) extern                   type __cdecl
#define oddata(type) extern     const _import type
#define pentry(type) extern     _export       type __cdecl
#endif


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// FORWARD REFERENCES //////////////////////////////

struct t_table;                        // Forward reference
struct t_module;                       // Forward reference
struct t_dump;                         // Forward reference


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// SERVICE FUNCTIONS ///////////////////////////////

// Flags returned by functions Istext.../Israre...
#define PLAINASCII     0x01            // Plain ASCII character
#define DIACRITICAL    0x02            // Diacritical character
#define RAREASCII      0x10            // Rare ASCII character

// Flags used by Memalloc() and Virtalloc(). Note that Virtalloc() alwyas
// initializes memory to zero.
#define REPORT         0x0000          // Report memory allocation errors
#define SILENT         0x0001          // Don't report allocation errors
#define ZEROINIT       0x0002          // Initialize memory to 0

#define CONT_BROADCAST 0x0000          // Continue sending msg to MDI windows
#define STOP_BROADCAST 0x1234          // Stop sending message to MDI windows

// Symbol decoding mode, used by Decodethreadname(), Decodeaddress() and
// Decoderelativeoffset().
// Bits that determine when to decode and comment name at all.
#define DM_VALID       0x00000001      // Only decode if memory exists
#define DM_INMOD       0x00000002      // Only decode if in module
#define DM_SAMEMOD     0x00000004      // Only decode if in same module
#define DM_SYMBOL      0x00000008      // Only decode if direct symbolic name
#define DM_NONTRIVIAL  0x00000010      // Only decode if nontrivial form
// Bits that control name format.
#define DM_BINARY      0x00000100      // Don't use symbolic form
#define DM_DIFBIN      0x00000200      // No symbolic form if different module
#define DM_WIDEFORM    0x00000400      // Extended form (8 digits by hex)
#define DM_CAPITAL     0x00000800      // First letter in uppercase if possible
#define DM_OFFSET      0x00001000      // Add 'OFFSET' if data
#define DM_JUMPIMP     0x00002000      // Check if points to JMP to import
#define DM_DYNAMIC     0x00004000      // Check if points to JMP to DLL
#define DM_ORDINAL     0x00008000      // Add ordinal to thread's name
// Bits that control whether address is preceded with module name.
#define DM_NOMODNAME   0x00000000      // Never add module name
#define DM_DIFFMODNAME 0x00010000      // Add name only if different module
#define DM_MODNAME     0x00020000      // Always add module name
// Bits that control comments.
#define DM_STRING      0x00100000      // Check if pointer to ASCII or UNICODE
#define DM_STRPTR      0x00200000      // Check if points to pointer to text
#define DM_FOLLOW      0x00400000      // Check if follows to different symbol
#define DM_ENTRY       0x00800000      // Check if unnamed entry to subroutine
#define DM_EFORCE      0x01000000      // Check if named entry, too
#define DM_DIFFMOD     0x02000000      // Check if points to different module
#define DM_RELOFFS     0x04000000      // Check if points inside subroutine
#define DM_ANALYSED    0x08000000      // Check if points to decoded data

// Standard commenting mode. Note: DM_DIFFMOD and DM_RELOFFS are not included.
#define DM_COMMENT     (DM_STRING|DM_STRPTR|DM_FOLLOW|DM_ENTRY|DM_ANALYSED)

// Address decoding mode, used by Labeladdress().
#define ADDR_SYMMASK   0x00000003      // Mask to extract sym presentation mode
#define   ADDR_HEXSYM  0x00000000      // Hex, followed by symbolic name
#define   ADDR_SYMHEX  0x00000001      // Symbolic name, followed by hex
#define   ADDR_SINGLE  0x00000002      // Symbolic name, or hex if none
#define   ADDR_HEXONLY 0x00000003      // Only hexadecimal address
#define ADDR_MODNAME   0x00000004      // Add module name to symbol
#define ADDR_FORCEMOD  0x00000008      // (ADDR_SINGLE) Always add module name
#define ADDR_GRAYHEX   0x00000010      // Gray hex
#define ADDR_HILSYM    0x00000020      // Highlight symbolic name
#define ADDR_NODEFMEP  0x00000100      // Do not show <ModuleEntryPoint>
#define ADDR_BREAK     0x00000200      // Mark as unconditional breakpoint
#define ADDR_CONDBRK   0x00000400      // Mark as conditional breakpoint
#define ADDR_DISBRK    0x00000800      // Mark as disabled breakpoint
#define ADDR_EIP       0x00001000      // Mark as actual EIP
#define ADDR_CHECKEIP  0x00002000      // Mark as EIP if EIP of CPU thread
#define ADDR_SHOWNULL  0x00004000      // Display address 0

// Mode bits and return value of Browsefilename().
#define BRO_MODEMASK   0xF0000000      // Mask to extract browsing mode
#define   BRO_FILE     0x00000000      // Get file name
#define   BRO_EXE      0x10000000      // Get name of executable
#define   BRO_TEXT     0x20000000      // Get name of text log
#define   BRO_GROUP    0x30000000      // Get one or several obj or lib files
#define   BRO_MULTI    0x40000000      // Get one or several files
#define BRO_SAVE       0x08000000      // Get name in save mode
#define BRO_SINGLE     0x00800000      // Single file selected
#define BRO_MULTIPLE   0x00400000      // Multiple files selected
#define BRO_APPEND     0x00080000      // Append to existing file
#define BRO_ACTUAL     0x00040000      // Add actual contents
#define BRO_TABS       0x00020000      // Separate columns with tabs
#define BRO_GROUPMASK  0x000000FF      // Mask to extract groups
#define   BRO_GROUP1   0x00000001      // Belongs to group 1
#define   BRO_GROUP2   0x00000002      // Belongs to group 2
#define   BRO_GROUP3   0x00000004      // Belongs to group 3
#define   BRO_GROUP4   0x00000008      // Belongs to group 4

// String decoding modes.
#define DS_DIR         0               // Direct quote
#define DS_ASM         1               // Assembler style
#define DS_C           2               // C style

varapi (void)    Error(wchar_t *format,...);
varapi (void)    Conderror(int *cond,wchar_t *title,wchar_t *format,...);
varapi (int)     Condyesno(int *cond,wchar_t *title,wchar_t *format,...);
stdapi (int)     Stringfromini(wchar_t *section,wchar_t *key,wchar_t *s,
                               int length);
stdapi (int)     Filefromini(wchar_t *key,wchar_t *name,wchar_t *defname);
varapi (int)     Getfromini(wchar_t *file,wchar_t *section,wchar_t *key,
                            wchar_t *format,...);
varapi (int)     Writetoini(wchar_t *file,wchar_t *section,wchar_t *key,
                            wchar_t *format,...);
stdapi (int)     Filetoini(wchar_t *key,wchar_t *name);
stdapi (void)    Deleteinisection(wchar_t *file,wchar_t *section);
stdapi (int)     Getfromsettings(wchar_t *key,int defvalue);
stdapi (void)    Addtosettings(wchar_t *key,int value);
stdapi (void)    Replacegraphs(int mode,wchar_t *s,uchar *mask,
                               int select,int n);
stdapi (int)     Unicodetoascii(const wchar_t *w,int nw,char *s,int ns);
stdapi (int)     Asciitounicode(const char *s,int ns,wchar_t *w,int nw);
stdapi (int)     Unicodetoutf(const wchar_t *w,int nw,char *t,int nt);
stdapi (int)     Utftounicode(const char *t,int nt,wchar_t *w,int nw);
stdapi (HGLOBAL) Unicodebuffertoascii(HGLOBAL hunicode);
stdapi (int)     Iszero(void *data,int n);
stdapi (int)     Guidtotext(uchar *guid,wchar_t *s);
varapi (int)     Swprintf(wchar_t *s,wchar_t *format,...);
stdapi (void *)  Memalloc(ulong size,int flags);
stdapi (void)    Memfree(void *data);
stdapi (void *)  Mempurge(void *data,int count,ulong itemsize,int *newcount);
stdapi (void *)  Memdouble(void *data,int *pcount,ulong itemsize,
                           int *failed,int flags);
stdapi (void *)  Virtalloc(ulong size,int flags);
stdapi (void)    Virtfree(void *data);
stdapi (int)     Broadcast(UINT msg,WPARAM wp,LPARAM lp);
stdapi (int)     Browsefilename(wchar_t *title,wchar_t *name,wchar_t *args,
                                wchar_t *currdir,wchar_t *defext,HWND hwnd,int mode);
stdapi (int)     Browsedirectory(HWND hw,wchar_t *comment,wchar_t *dir);
stdapi (void)    Relativizepath(wchar_t *path);
stdapi (void)    Absolutizepath(wchar_t *path);
stdapi (int)     Confirmoverwrite(wchar_t *path);
stdapi (int)     Labeladdress(wchar_t *text,ulong addr,ulong reladdr,int relreg,
                              int index,uchar *mask,int *select,ulong mode);
stdapi (int)     Simpleaddress(wchar_t *text,ulong addr,
                               uchar *mask,int *select);
stdapi (void)    Heapsort(void *data,const int count,const int size,
                          int (_USERENTRY *compare)(const void *,const void *));
stdapi (void)    Heapsortex(void *data,const int count,const int size,
                            int (_USERENTRY *compareex)(const void *,const void *,ulong),
                            ulong lp);
stdapi (uchar *) Readfile(wchar_t *path,ulong fixsize,ulong *psize);
stdapi (int)     Devicenametodosname(wchar_t *devname,wchar_t *dosname);
stdapi (int)     Filenamefromhandle(HANDLE hfile,wchar_t *path);
stdapi (void)    Quicktimerstart(int timer);
stdapi (void)    Quicktimerstop(int timer);
stdapi (void)    Quicktimerflush(int timer);


////////////////////////////////////////////////////////////////////////////////
////////////////// FAST SERVICE ROUTINES WRITTEN IN ASSEMBLER //////////////////

varapi (int)     StrcopyA(char *dest,int n,const char *src);
varapi (int)     StrcopyW(wchar_t *dest,int n,const wchar_t *src);
varapi (int)     StrlenA(const char *src,int n);
varapi (int)     StrlenW(const wchar_t *src,int n);
varapi (int)     HexprintA(char *s,ulong u);
varapi (int)     HexprintW(wchar_t *s,ulong u);
varapi (int)     Hexprint4A(char *s,ulong u);
varapi (int)     Hexprint4W(wchar_t *s,ulong u);
varapi (int)     Hexprint8A(char *s,ulong u);
varapi (int)     Hexprint8W(wchar_t *s,ulong u);
varapi (int)     SignedhexA(char *s,ulong u);
varapi (int)     SignedhexW(wchar_t *s,ulong u);
varapi (void)    Swapmem(void *base,int size,int i1,int i2);
varapi (int)     HexdumpA(char *s,uchar *code,int n);
varapi (int)     HexdumpW(wchar_t *s,uchar *code,int n);
varapi (int)     Bitcount(ulong u);

varapi (char *)  SetcaseA(char *s);
varapi (wchar_t *) SetcaseW(wchar_t *s);
varapi (int)     StrcopycaseA(char *dest,int n,const char *src);
varapi (int)     StrcopycaseW(wchar_t *dest,int n,const wchar_t *src);
varapi (int)     StrnstrA(char *data,int ndata,
                          char *pat,int npat,int ignorecase);
varapi (int)     StrnstrW(wchar_t *data,int ndata,
                          wchar_t *pat,int npat,int ignorecase);
varapi (int)     StrcmpW(const wchar_t *s1,const wchar_t *s2);
varapi (ulong)   Div64by32(ulong low,ulong hi,ulong div);
varapi (ulong)   CRCcalc(uchar *datacopy,ulong datasize);
varapi (int)     Getcpuidfeatures(void);
varapi (void)    Maskfpu(void);
varapi (void)    Clearfpu(void);


////////////////////////////////////////////////////////////////////////////////
////////////////////// DATA COMPRESSION AND DECOMPRESSION //////////////////////

stdapi (ulong)   Compress(uchar *bufin,ulong nbufin,
                          uchar *bufout,ulong nbufout);
stdapi (ulong)   Getoriginaldatasize(uchar *bufin,ulong nbufin);
stdapi (ulong)   Decompress(uchar *bufin,ulong nbufin,
                            uchar *bufout,ulong nbufout);


////////////////////////////////////////////////////////////////////////////////
/////////////////////// TAGGED DATA FILES AND RESOURCES ////////////////////////

#define MI_SIGNATURE   0x00646F4DL     // Signature of tagged file
#define MI_VERSION     0x7265560AL     // File version
#define MI_FILENAME    0x6C69460AL     // Record with full name of executable
#define MI_FILEINFO    0x7263460AL     // Length, date, CRC (t_fileinfo)
#define MI_DATA        0x7461440AL     // Name or data (t_nameinfo)
#define MI_CALLBRA     0x7262430AL     // Call brackets
#define MI_LOOPBRA     0x72624C0AL     // Loop brackets
#define MI_PROCDATA    0x6372500AL     // Procedure data (set of t_procdata)
#define MI_INT3BREAK   0x336E490AL     // INT3 breakpoint (t_bpoint)
#define MI_MEMBREAK    0x6D70420AL     // Memory breakpoint (t_bpmem)
#define MI_HWBREAK     0x6870420AL     // Hardware breakpoint (t_bphard)
#define MI_ANALYSIS    0x616E410AL     // Record with analysis data
#define MI_SWITCH      0x6977530AL     // Switch (addr+dt_switch)
#define MI_CASE        0x7361430AL     // Case (addr+dt_case)
#define MI_MNEMO       0x656E4D0AL     // Decoding of mnemonics (addr+dt_mnemo)
#define MI_JMPDATA     0x74644A0AL     // Jump data
#define MI_NETSTREAM   0x74734E0AL     // .NET streams (t_netstream)
#define MI_METADATA    0x74644D0AL     // .NET MetaData tables (t_metadata)
#define MI_BINSAV      0x7673420AL     // Last entered binary search patterns
#define MI_MODDATA     0x61624D0AL     // Module base, size and path
#define MI_PREDICT     0x6472500AL     // Predicted command execution results
#define MI_LASTSAV     0x61734C0AL     // Last entered strings (t_nameinfo)
#define MI_SAVEAREA    0x7661530AL     // Save area (t_savearea)
#define MI_RTCOND      0x6374520AL     // Run trace pause condition
#define MI_RTPROT      0x7074520AL     // Run trace protocol condition
#define MI_WATCH       0x6374570AL     // Watch in watch window
#define MI_LOADDLL     0x64644C0AL     // Packed loaddll.exe
#define MI_PATCH       0x7461500AL     // Patch data (compressed t_patch)
#define MI_PLUGIN      0x676C500AL     // Plugin prefix descriptor
#define MI_END         0x646E450AL     // End of tagged file

#ifdef FILE                            // Requires <stdio.h>

typedef struct t_fileinfo              // Length, date, CRC (MI_FILEINFO)
{
    ulong          size;                 // Length of executable file
    FILETIME       filetime;             // Time of last modification
    ulong          crc;                  // CRC of executable file
    int            issfx;                // Whether self-extractable
    ulong          sfxentry;             // Offset of original entry after SFX
} t_fileinfo;

typedef struct t_tagfile               // Descriptor of tagged file (reading)
{
    FILE           *f;                   // File descriptor
    ulong          filesize;             // File size
    ulong          offset;               // Actual offset
    ulong          tag;                  // Tag of next accessed record
    ulong          recsize;              // Size of next accessed record
} t_tagfile;

stdapi (FILE *)  Createtaggedfile(wchar_t *name,char *signature,ulong version);
stdapi (int)     Savetaggedrecord(FILE *f,ulong tag,ulong size,void *data);
stdapi (int)     Savepackedrecord(FILE *f,ulong tag,ulong size,void *data);
stdapi (void)    Finalizetaggedfile(FILE *f);
stdapi (int)     Opentaggedfile(t_tagfile *tf,wchar_t *name,char *signature);
stdapi (int)     Gettaggedrecordsize(t_tagfile *tf,ulong *tag,ulong *size);
stdapi (ulong)   Gettaggedfiledata(t_tagfile *tf,void *buf,ulong bufsize);
stdapi (void)    Closetaggedfile(t_tagfile *tf);

#endif

typedef struct t_nameinfo              // Header of name/data record (MI_NAME)
{
    ulong          offs;                 // Offset in module
    uchar          type;                 // Name/data type, one of NM_xxx/DT_xxx
} t_nameinfo;

typedef struct t_uddsave               // .udd file descriptor used by plugins
{
    void           *file;                // .udd file
    ulong          uddprefix;            // .udd tag prefix
} t_uddsave;

stdapi (int)     Pluginsaverecord(t_uddsave *psave,ulong tag,
                                  ulong size,void *data);
stdapi (int)     Pluginpackedrecord(t_uddsave *psave,ulong tag,
                                    ulong size,void *data);
stdapi (void)    Pluginmodulechanged(ulong addr);
stdapi (int)     Plugingetuniquedatatype(void);
stdapi (int)     Plugintempbreakpoint(ulong addr,ulong type,int forceint3);
stdapi (void)    Pluginshowoptions(struct t_control *options);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LEXICAL SCANNER ////////////////////////////////

#define SMODE_UPCASE   0x00000001      // Convert keywords to uppercase
#define SMODE_NOEOL    0x00000010      // Don't report SCAN_EOL, just skip it
#define SMODE_NOSPEC   0x00000020      // Don't translate specsymbols
#define SMODE_EXTKEY   0x00000040      // Allow &# and .!?%~ inside keywords
#define SMODE_NOUSKEY  0x00000080      // Underscore (_) is not part of keyword
#define SMODE_NODEC    0x00000100      // nn. is not decimal, but nn and '.'
#define SMODE_NOFLOAT  0x00000200      // nn.mm is not float, but nn, '.', mm
#define SMODE_RADIX10  0x00000400      // Default base is 10, not 16
#define SMODE_ANGLES   0x00000800      // Use angular brackets (<>) for text
#define SMODE_MASK     0x00001000      // Allow masked nibbles in SCAN_INT

#define SCAN_EOF       0               // End of data
#define SCAN_EOL       1               // End of line
#define SCAN_KEY       2               // Keyword in text
#define SCAN_TEXT      3               // Text string (without quotes) in text
#define SCAN_INT       4               // Integer in ival or uval
#define SCAN_FLOAT     5               // Floating-point number in fval
#define SCAN_OP        6               // Operator or punctuator in ival
#define SCAN_INVALID   7               // Invalid character in ival
#define SCAN_SYNTAX    8               // Syntactical error in errmsg
#define SCAN_USER      10              // Base for user-defined types

typedef struct t_scan                  // Scan descriptor
{
    // Fill these fields before the first scan. Set line to 1 for 1-based numbers.
    ulong          mode;                 // Scanning mode, set of SMODE_xxx
    wchar_t        *src;                 // Pointer to UNICODE source data
    ulong          length;               // Length of source data, characters
    ulong          caret;                // Next processed symbol, characters
    int            line;                 // Number of encountered EOLs
    // Call to Scan() fills some of these fields with scan data.
    union
    {
        int          ival;                 // Scanned item as integer number
        ulong        uval;                 // Scanned item as unsigned number
    };
    ulong          mask;                 // Binary mask for uval, SCAN_INT only
    long double    fval;                 // Scanned item as floating number
    wchar_t        text[TEXTLEN];        // Scanned item as a text string
    int            ntext;                // Length of text, characters
    wchar_t        errmsg[TEXTLEN];      // Error message
    int            type;                 // Type of last scanned item, SCAN_xxx
} t_scan;

stdapi (int)     Skipspaces(t_scan *ps);
stdapi (void)    Scan(t_scan *ps);
stdapi (int)     Optostring(wchar_t *s,int op);


////////////////////////////////////////////////////////////////////////////////
///////////////////////// SHORTCUTS, MENUS AND TOOLBAR /////////////////////////

// Input modes of menu functions.
#define MENU_VERIFY    0               // Check if menu item applies
#define MENU_EXECUTE   1               // Execute menu item
// Values returned by menu functions on MENU_VERIFY.
#define MENU_ABSENT    0               // Item doesn't appear in menu
#define MENU_NORMAL    1               // Ordinary menu item
#define MENU_CHECKED   2               // Checked menu item
#define MENU_CHKPARENT 3               // Checked menu item + checked parent
#define MENU_GRAYED    4               // Inactive menu item
#define MENU_SHORTCUT  5               // Shortcut only, not in menu
// Values returned by menu functions on MENU_EXECUTE.
#define MENU_NOREDRAW  0               // Do not redraw owning window
#define MENU_REDRAW    1               // Redraw owning window

// Shortcut descriptions.
#define KK_KEYMASK     0x0000FFFF      // Mask to extract key
#define KK_CHAR        0x00010000      // Process as WM_CHAR
#define KK_SHIFT       0x00020000      // Shortcut includes Shift key
#define KK_CTRL        0x00040000      // Shortcut includes Ctrl key
#define KK_ALT         0x00080000      // Shortcut includes Alt key
#define KK_WIN         0x00100000      // Shortcut includes WIN key
#define KK_NOSH        0x00200000      // Shortcut ignores Shift in main menu
#define KK_UNUSED      0x7FC00000      // Unused shortcut data bits
#define KK_DIRECT      0x80000000      // Direct shortcut in menu

// Global shortcuts. They may be re-used by plugins.
#define K_NONE         0               // No shortcut
// Global shortcuts: File functions.
#define K_OPENNEW      100             // Open new executable to debug
#define K_SETARGS      101             // Set command line args for next run
#define K_ATTACH       102             // Attach to the running process
#define K_DETACH       103             // Detach from the debugged process
#define K_EXIT         104             // Close OllyDbg
// Global shortcuts: View functions.
#define K_LOGWINDOW    110             // Open Log window
#define K_MODULES      111             // Open Executable modules window
#define K_MEMORY       112             // Open Memory map window
#define K_WINDOWS      113             // Open list of windows
#define K_THREADS      114             // Open Threads window
#define K_CPU          115             // Open CPU window
#define K_WATCHES      116             // Open Watches window
#define K_SEARCHES     117             // Open Search results window
#define K_RTRACE       118             // Open Run trace window
#define K_PATCHES      119             // Open Patches window
#define K_BPOINTS      120             // Open INT3 breakpoints window
#define K_BPMEM        121             // Open Memory breakpoints window
#define K_BPHARD       122             // Open Hardware breakpoints window
#define K_SOURCES      123             // Open list of source files
#define K_FILE         124             // Open file
// Global shortcuts: Debug functions.
#define K_RUN          130             // Run debugged application
#define K_RUNTHREAD    131             // Run only actual thread
#define K_PAUSE        132             // Pause debugged application
#define K_STEPIN       133             // Step into
#define K_STEPOVER     134             // Step over
#define K_TILLRET      135             // Execute till return
#define K_TILLUSER     136             // Execute till user code
#define K_CALLDLL      137             // Call DLL export
#define K_RESTART      138             // Restart last debugged executable
#define K_CLOSE        139             // Close debuggee
#define K_AFFINITY     140             // Set affinity
// Global shortcuts: Trace functions.
#define K_OPENTRACE    150             // Open Run trace
#define K_CLOSETRACE   151             // Close Run trace
#define K_ANIMIN       152             // Animate into
#define K_ANIMOVER     153             // Animate over
#define K_TRACEIN      154             // Trace into
#define K_TRACEOVER    155             // Trace over
#define K_RUNHIT       156             // Run hit trace
#define K_STOPHIT      157             // Stop hit trace
#define K_RTCOND       158             // Set run trace break condition
#define K_RTLOG        159             // Set run trace log condition
// Global shortcuts: Options.
#define K_OPTIONS      170             // Open Options dialog
#define K_PLUGOPTIONS  171             // Open Plugin options dialog
#define K_SHORTCUTS    172             // Open Shortcut editor
// Global shortcuts: Windows functions.
#define K_TOPMOST      180             // Toggle topmost status of main window
#define K_CASCADE      181             // Cascade MDI windows
#define K_TILEHOR      182             // Tile MDI windows horizontally
#define K_TILEVER      183             // Tile MDI windows vertically
#define K_ICONS        184             // Arrange icons
#define K_CLOSEMDI     185             // Close all MDI windows
#define K_RESTORE      186             // Maximize or restore active MDI window
#define K_PREVMDI      187             // Go to previous MDI window
#define K_NEXTMDI      188             // Go to next MDI window
// Global shortcuts: Help functions.
#define K_ABOUT        190             // Open About dialog
// Generic table shortcuts.
#define K_PREVFRAME    200             // Go to previous frame in table
#define K_NEXTFRAME    201             // Go to next frame in table
#define K_UPDATE       202             // Update table
#define K_COPY         203             // Copy to clipboard
#define K_COPYALL      204             // Copy whole table to clipboard
#define K_CUT          205             // Cut to clipboard
#define K_PASTE        206             // Paste
#define K_TOPMOSTMDI   207             // Make MDI window topmost
#define K_AUTOUPDATE   208             // Periodically update contents of window
#define K_SHOWBAR      209             // Show/hide bar
#define K_HSCROLL      210             // Show/hide horizontal scroll
#define K_DEFCOLUMNS   211             // Resize all columns to default width
// Shortcuts used by different windows.
#define K_SEARCHAGAIN  220             // Repeat last search
#define K_SEARCHREV    221             // Repeat search in inverse direction
// Dump: Data backup.
#define K_BACKUP       240             // Create or update backup
#define K_SHOWBKUP     241             // Toggle backup display
// Dump: Edit.
#define K_UNDO         250             // Undo selection
#define K_COPYADDR     251             // Copy address
#define K_COPYHEX      252             // Copy data in hexadecimal format
#define K_PASTEHEX     253             // Paste data in hexadecimal format
#define K_EDITITEM     254             // Edit first selected item
#define K_EDIT         255             // Edit selection
#define K_FILLZERO     256             // Fill selection with zeros
#define K_FILLNOP      257             // Fill selection with NOPs
#define K_FILLFF       258             // Fill selection with FF code
#define K_SELECTALL    259             // Select all
#define K_SELECTPROC   260             // Select procedure or structure
#define K_COPYTOEXE    261             // Copy selection to executable file
#define K_ZERODUMP     262             // Zero whole dump
#define K_LABEL        263             // Add custom label
#define K_ASSEMBLE     264             // Assemble
#define K_COMMENT      265             // Add custom comment
#define K_SAVEFILE     266             // Save file
// Dump: Breakpoints.
#define K_BREAK        280             // Toggle simple INT3 breakpoint
#define K_CONDBREAK    281             // Set or edit cond INT3 breakpoint
#define K_LOGBREAK     282             // Set or edit logging INT3 breakpoint
#define K_RUNTOSEL     283             // Run to selection
#define K_ENABLEBRK    284             // Enable or disable INT3 breakpoint
#define K_MEMBREAK     285             // Set or edit memory breakpoint
#define K_MEMLOGBREAK  286             // Set or edit memory log breakpoint
#define K_MEMENABLE    287             // Enable or disable memory breakpoint
#define K_MEMDEL       288             // Delete memory breakpoint
#define K_HWBREAK      289             // Set or edit hardware breakpoint
#define K_HWLOGBREAK   290             // Set or edit hardware log breakpoint
#define K_HWENABLE     291             // Enable or disable hardware breakpoint
#define K_HWDEL        292             // Delete hardware breakpoint
// Dump: Jumps to location.
#define K_NEWORIGIN    300             // Set new origin
#define K_FOLLOWDASM   301             // Follow address in Disassembler
#define K_ORIGIN       302             // Go to origin
#define K_GOTO         303             // Go to expression
#define K_JMPTOSEL     304             // Follow jump or call to selection
#define K_SWITCHCASE   305             // Go to switch case
#define K_PREVHIST     306             // Go to previous history location
#define K_NEXTHIST     307             // Go to next history location
#define K_PREVTRACE    308             // Go to previous run trace record
#define K_NEXTTRACE    309             // Go to next run trace record
#define K_PREVPROC     310             // Go to previous procedure
#define K_NEXTPROC     311             // Go to next procedure
#define K_PREVREF      312             // Go to previous found item
#define K_NEXTREF      313             // Go to next found item
#define K_FOLLOWEXE    314             // Follow selection in executable file
// Dump: Structures.
#define K_DECODESTR    330             // Decode as structure
#define K_DECODESPTR   331             // Decode as pointer to structure
// Dump: Search.
#define K_NAMES        380             // Show list of names
#define K_FINDCMD      381             // Find command
#define K_FINDCMDSEQ   382             // Find sequence of commands
#define K_FINDCONST    383             // Find constant
#define K_FINDBIN      384             // Find binary string
#define K_FINDMOD      385             // Find modification
#define K_ALLCALLS     386             // Search for all intermodular calls
#define K_ALLCMDS      387             // Search for all commands
#define K_ALLCMDSEQ    388             // Search for all command sequences
#define K_ALLCONST     389             // Search for all constants
#define K_ALLMODS      390             // Search for all modifications
#define K_ALLSTRS      391             // Search for all referenced strings
#define K_ALLGUIDS     392             // Search for all referenced GUIDs
#define K_ALLCOMMENTS  393             // Search for all user-defined comments
#define K_ALLSWITCHES  394             // Search for all switches
#define K_ALLFLOATS    395             // Search for all floating constants
#define K_LASTRTREC    396             // Find last record in run trace
// Dump: References.
#define K_REFERENCES   410             // Find all references
// Dump: Addressing.
#define K_ABSADDR      420             // Show absolute addresses
#define K_RELADDR      421             // Show offsets from current selection
#define K_BASEADDR     422             // Show offsets relative to module base
// Dump: Comments.
#define K_COMMSRC      430             // Toggle between comments and source
#define K_SHOWPROF     431             // Show or hide run trace profile
// Dump: Analysis.
#define K_ANALYSE      440             // Analyse module
#define K_REMANAL      441             // Remove analysis from selection
#define K_REMANMOD     442             // Remove analysis from the module
// Dump: Help.
#define K_HELPCMD      450             // Help on command
#define K_HELPAPI      451             // Help on Windows API function
// Dump: Data presentation.
#define K_DUMPHA16     460             // Dump as 16 hex bytes and ASCII text
#define K_DUMPHA8      461             // Dump as 8 hex bytes and ASCII text
#define K_DUMPHU16     462             // Dump as 16 hex bytes and UNICODE text
#define K_DUMPHU8      463             // Dump as 8 hex bytes and UNICODE text
#define K_DUMPA64      464             // Dump as 64 ASCII characters
#define K_DUMPA32      465             // Dump as 32 ASCII characters
#define K_DUMPU64      466             // Dump as 64 UNICODE characters
#define K_DUMPU32      467             // Dump as 32 UNICODE characters
#define K_DUMPU16      468             // Dump as 16 UNICODE characters
#define K_DUMPISHORT   469             // Dump as 16-bit signed numbers
#define K_DUMPUSHORT   470             // Dump as 16-bit unsigned numbers
#define K_DUMPXSHORT   471             // Dump as 16-bit hexadecimal numbers
#define K_DUMPILONG    472             // Dump as 32-bit signed numbers
#define K_DUMPULONG    473             // Dump as 32-bit unsigned numbers
#define K_DUMPXLONG    474             // Dump as 32-bit hexadecimal numbers
#define K_DUMPADR      475             // Dump as address with comments
#define K_DUMPADRA     476             // Dump as address with ASCII & comments
#define K_DUMPADRU     477             // Dump as address with UNICODE & comms
#define K_DUMPF32      478             // Dump as 32-bit floats
#define K_DUMPF64      479             // Dump as 64-bit floats
#define K_DUMPF80      480             // Dump as 80-bit floats
#define K_DUMPDA       481             // Dump as disassembly
#define K_DUMPSTRUCT   482             // Dump as known structure
// Stack-specific shortcuts.
#define K_LOCKSTK      490             // Toggle stack lock
#define K_PUSH         491             // Push doubleword
#define K_POP          492             // Pop doubleword
#define K_STACKINDASM  493             // Follow stack doubleword in CPU
#define K_GOTOESP      494             // Go to ESP
#define K_GOTOEBP      495             // Go to EBP
#define K_ESPADDR      496             // Show offsets relative to ESP
#define K_EBPADDR      497             // Show offsets relative to EBP
// Shortcuts of Register pane.
#define K_INCREMENT    500             // Increment register
#define K_DECREMENT    501             // Decrement register
#define K_ZERO         502             // Zero selected register
#define K_SET1         503             // Set register to 1
#define K_MODIFY       504             // Modify contents of register
#define K_UNDOREG      505
#define K_PUSHFPU      506             // Push FPU stack
#define K_POPFPU       507             // Pop FPU stack
#define K_REGINDASM    508             // Follow register in CPU Disassembler
#define K_REGINDUMP    509             // Follow register in CPU Dump
#define K_REGINSTACK   510             // Follow register in CPU Stack
#define K_VIEWFPU      511             // View FPU registers
#define K_VIEWMMX      512             // View MMX registers
#define K_VIEW3DNOW    513             // View 3DNow! registers
#define K_HELPREG      514             // Help on register
// Shortcuts of Information pane.
#define K_EDITOP       520             // Edit contents of operand in info pane
#define K_INFOINDASM   521             // Follow information in CPU Disassembler
#define K_INFOINDUMP   522             // Follow information in CPU Dump
#define K_INFOINSTACK  523             // Follow information in CPU Stack
#define K_LISTJUMPS    524             // List jumps and calls to command
#define K_LISTCASES    525             // List switch cases
#define K_INFOSRC      526             // Follow address in Source code
// Log window.
#define K_LOGINDASM    530             // Follow log address in CPU Disassembler
#define K_LOGINDUMP    531             // Follow log address in CPU Dump
#define K_LOGINSTACK   532             // Follow log address in CPU Stack
#define K_LOGCLEAR     533             // Clear log
#define K_LOGTOFILE    534             // Start logging to file
#define K_STOPLOG      535             // Stop logging to file
// Executable modules.
#define K_MODINDASM    540             // Follow module entry point in CPU
#define K_MODDATA      541             // View module data section in CPU Dump
#define K_MODEXE       542             // Open executable in standalone Dump
#define K_MODNAMES     543             // Show names declared in the module
#define K_GLOBNAMES    544             // Show global list of names
#define K_MODCALLS     545             // Find intermodular calls in module
#define K_MODANALYSE   546             // Analyse selected module
#define K_SAVEUDD      547             // Save module data to .udd file
#define K_LOADUDD      548             // Load module data from .udd file
// Memory map.
#define K_MEMBACKUP    550             // Create backup of memory block
#define K_MEMINDASM    551             // Open memory block in CPU Disassembler
#define K_MEMINDUMP    552             // Open memory block in CPU Dump
#define K_DUMP         553             // Dump memory block in separate window
#define K_SEARCHMEM    554             // Search memory block for binary string
#define K_MEMBPACCESS  555             // Toggle break on access
// List of windows.
#define K_WININDASM    560             // Follow WinProc in CPU Disassembler
#define K_CLSINDASM    561             // Follow ClassProc in CPU Disassembler
// Threads.
#define K_THRINCPU     570             // Open thread in CPU window
#define K_THRTIB       571             // Dump Thread Information Block
#define K_REGISTERS    572             // Open Registers window
#define K_THRSUSPEND   573             // Suspend selected thread
#define K_THRRESUME    574             // Resume selected thread
#define K_THRKILL      575             // Kill selected thread
// Watches.
#define K_ADDWATCH     580             // Add watch
#define K_EDITWATCH    581             // Edit existing watch
#define K_DELWATCH     582             // Delete watch
#define K_WATCHUP      583             // Move watch up
#define K_WATCHDN      584             // Move watch down
#define K_EDITCONT     585             // Edit contents of register or memory
#define K_WATCHINDASM  586             // Follow watch value in CPU Disassembler
#define K_WATCHINDUMP  587             // Follow watch value in CPU Dump
#define K_WATCHINSTACK 588             // Follow watch value in CPU Stack
// Search results.
#define K_SEARCHINDASM 600             // Follow address of found item in CPU
#define K_PREVSEARCH   601             // Follow previous found item in Disasm
#define K_NEXTSEARCH   602             // Follow next found item in Disasm
#define K_FINDTEXT     603             // Find text substring in search results
#define K_BREAKALL     604             // Set breakpoint on all found commands
#define K_CONDBPALL    605             // Set conditional bp on all commands
#define K_LOGBPALL     606             // Set logging bp on all commands
#define K_DELBPALL     607             // Remove breakpoints from all commands
#define K_BREAKCALLS   608             // Set break on calls to function
#define K_CONDBPCALLS  609             // Set cond break on calls to function
#define K_LOGBPCALLS   610             // Set logging break on calls to function
#define K_DELBPCALLS   611             // Remove breakpoints from calls
// Run trace.
#define K_RTPREV       620             // Show previous run trace in Disasm
#define K_RTNEXT       621             // Show next run trace in Disasm
#define K_TRACEINDASM  622             // Follow traced command in CPU
#define K_CLRTRACE     623             // Clear run trace
#define K_REGMODE      624             // Toggle register display mode
#define K_MARKTRACE    625             // Mark address in run trace
#define K_FINDTRADDR   626             // Enter address to mark in run trace
#define K_PREVMARK     627             // Find previous marked address
#define K_NEXTMARK     628             // Find next marked address
#define K_CLEARMARK    629             // Clear address marks in run trace
#define K_PROFILE      630             // Profile selected module
#define K_GLOBPROFILE  631             // Profile whole memory
#define K_SAVETRACE    632             // Save run trace data to the file
#define K_STOPSAVETR   633             // Close run trace log file
// Profile.
#define K_PROFINDASM   640             // Follow profiled command in CPU
#define K_PREVPROF     641             // Follow previous profile item in Disasm
#define K_NEXTPROF     642             // Follow next profile item in Disasm
#define K_PROFMARK     643             // Mark profile address in run trace
// Patches.
#define K_PATCHINDASM  650             // Follow patch in CPU Disassembler
#define K_PREVPATCH    651             // Go to previous patch
#define K_NEXTPATCH    652             // Go to next patch
#define K_APPLYPATCH   653             // Apply patch
#define K_RESTOREPT    654             // Restore original code
#define K_DELPATCH     655             // Delete patch record
// Breakpoint lists.
#define K_DELETEBP     660             // Delete breakpoint
#define K_ENABLEBP     661             // Enable or disable breakpoint
#define K_BPINDASM     662             // Follow breakpoint in CPU Disassembler
#define K_BPINDUMP     663             // Follow breakpoint in CPU Dump
#define K_DISABLEALLBP 664             // Disable all breakpoints
#define K_ENABLEALLBP  665             // Enable all breakpoints
// Source.
#define K_SOURCEINDASM 670             // Follow source line in CPU Disassembler
// List of source files.
#define K_VIEWSRC      680             // View source file
// Names.
#define K_FOLLOWIMP    690             // Follow import in CPU Disassembler
#define K_NAMEINDASM   691             // Follow label in CPU Disassembler
#define K_NAMEINDUMP   692             // Follow label in CPU Dump
#define K_NAMEREFS     693             // Find references to name
#define K_NAMEHELPAPI  694             // Help on selected API function
// Special non-changeable shortcuts.
#define K_0            1008            // Digit 0
#define K_1            1009            // Digit 1
#define K_2            1010            // Digit 2
#define K_3            1011            // Digit 3
#define K_4            1012            // Digit 4
#define K_5            1013            // Digit 5
#define K_6            1014            // Digit 6
#define K_7            1015            // Digit 7
#define K_8            1016            // Digit 8
#define K_9            1017            // Digit 9
#define K_A            1018            // Hex digit A
#define K_B            1019            // Hex digit B
#define K_C            1020            // Hex digit C
#define K_D            1021            // Hex digit D
#define K_E            1022            // Hex digit E
#define K_F            1023            // Hex digit F

// Native OllyDbg tables that support embedded plugin menus:
#define PWM_ATTACH     L"ATTACH"       // List of processes in Attach window
#define PWM_BPHARD     L"BPHARD"       // Hardware breakpoints
#define PWM_BPMEM      L"BPMEM"        // Memory breakpoints
#define PWM_BPOINT     L"BPOINT"       // INT3 breakpoints
#define PWM_DISASM     L"DISASM"       // CPU Disassembler pane
#define PWM_DUMP       L"DUMP"         // All dumps except CPU disasm & stack
#define PWM_INFO       L"INFO"         // CPU Info pane
#define PWM_LOG        L"LOG"          // Log window
#define PWM_MAIN       L"MAIN"         // Main OllyDbg menu
#define PWM_MEMORY     L"MEMORY"       // Memory window
#define PWM_MODULES    L"MODULES"      // Modules window
#define PWM_NAMELIST   L"NAMELIST"     // List of names (labels)
#define PWM_PATCHES    L"PATCHES"      // List of patches
#define PWM_PROFILE    L"PROFILE"      // Profile window
#define PWM_REGISTERS  L"REGISTERS"    // Registers, including CPU
#define PWM_SEARCH     L"SEARCH"       // Search tabs
#define PWM_SOURCE     L"SOURCE"       // Source code window
#define PWM_SRCLIST    L"SRCLIST"      // List of source files
#define PWM_STACK      L"STACK"        // CPU Stack pane
#define PWM_THREADS    L"THREADS"      // Threads window
#define PWM_TRACE      L"TRACE"        // Run trace window
#define PWM_WATCH      L"WATCH"        // Watches
#define PWM_WINDOWS    L"WINDOWS"      // List of windows

typedef int  MENUFUNC(struct t_table *,wchar_t *,ulong,int);

typedef struct t_menu                  // Menu descriptor
{
    wchar_t        *name;                // Menu command
    wchar_t        *help;                // Explanation of command
    int            shortcutid;           // Shortcut identifier, K_xxx
    MENUFUNC       *menufunc;            // Function that executes menu command
    struct t_menu  *submenu;             // Pointer to descriptor of popup menu
    union
    {
        ulong        index;                // Argument passed to menu function
        HMENU        hsubmenu;             // Handle of pulldown menu
    };
} t_menu;

stdapi (int)     Callmenufunction(struct t_table *pt,t_menu *pm,
                                  MENUFUNC *menufunc,ulong index);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// MAIN OLLYDBG WINDOW //////////////////////////////

typedef enum t_status                  // Thread/process status
{
    STAT_IDLE,                           // No process to debug
    STAT_LOADING,                        // Loading new process
    STAT_ATTACHING,                      // Attaching to the running process
    STAT_RUNNING,                        // All threads are running
    STAT_RUNTHR,                         // Single thread is running
    STAT_STEPIN,                         // Stepping into, single thread
    STAT_STEPOVER,                       // Stepping over, single thread
    STAT_ANIMIN,                         // Animating into, single thread
    STAT_ANIMOVER,                       // Animating over, single thread
    STAT_TRACEIN,                        // Tracing into, single thread
    STAT_TRACEOVER,                      // Tracing over, single thread
    STAT_SFXRUN,                         // SFX using run trace, single thread
    STAT_SFXHIT,                         // SFX using hit trace, single thread
    STAT_SFXKNOWN,                       // SFX to known entry, single thread
    STAT_TILLRET,                        // Stepping until return, single thread
    STAT_OVERRET,                        // Stepping over return, single thread
    STAT_TILLUSER,                       // Stepping till user code, single thread
    STAT_PAUSING,                        // Process is requested to pause
    STAT_PAUSED,                         // Process paused on debugging event
    STAT_FINISHED,                       // Process is terminated but in memory
    STAT_CLOSING                         // Process is requested to close/detach
} t_status;

varapi (void)    Info(wchar_t *format,...);
varapi (void)    Message(ulong addr,wchar_t *format,...);
varapi (void)    Tempinfo(wchar_t *format,...);
varapi (void)    Flash(wchar_t *format,...);
varapi (void)    Progress(int promille,wchar_t *format,...);
stdapi (void)    Moveprogress(int promille);
stdapi (void)    Setstatus(t_status newstatus);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// DATA FUNCTIONS ////////////////////////////////

// Name and data types. Do not change order, it's important! Always keep values
// of demangled names 1 higher than originals, and NM_ALIAS higher than
// NM_EXPORT - name search routines rely on these facts!
#define NM_NONAME      0x00            // Means that name is absent
#define DT_NONE        0x00            // Ditto
#define NM_LABEL       0x21            // User-defined label
#define NM_EXPORT      0x22            // Exported name
#define NM_DEEXP       (NM_EXPORT+1)   // Demangled exported name
#define DT_EORD        (NM_EXPORT+2)   // Exported ordinal (ulong)
#define NM_ALIAS       (NM_EXPORT+3)   // Alias of NM_EXPORT
#define NM_IMPORT      0x26            // Imported name (module.function)
#define NM_DEIMP       (NM_IMPORT+1)   // Demangled imported name
#define DT_IORD        (NM_IMPORT+2)   // Imported ordinal (struct dt_iord)
#define NM_DEBUG       0x29            // Name from debug data
#define NM_DEDEBUG     (NM_DEBUG+1)    // Demangled name from debug data
#define NM_ANLABEL     0x2B            // Name added by Analyser
#define NM_COMMENT     0x30            // User-defined comment
#define NM_ANALYSE     0x31            // Comment added by Analyser
#define NM_MARK        0x32            // Important parameter
#define NM_CALLED      0x33            // Name of called function
#define DT_ARG         0x34            // Name and type of argument or data
#define DT_NARG        0x35            // Guessed number of arguments at CALL
#define NM_RETTYPE     0x36            // Type of data returned in EAX
#define NM_MODCOMM     0x37            // Automatical module comments
#define NM_TRICK       0x38            // Parentheses of tricky sequences
#define DT_SWITCH      0x40            // Switch descriptor (struct dt_switch)
#define DT_CASE        0x41            // Case descriptor (struct dt_case)
#define DT_MNEMO       0x42            // Alternative mnemonics data (dt_mnemo)
#define NM_DLLPARMS    0x44            // Parameters of Call DLL dialog
#define DT_DLLDATA     0x45            // Parameters of Call DLL dialog

#define DT_DBGPROC     0x4A            // t_function from debug, don't save!

#define NM_INT3BASE    0x51            // Base for INT3 breakpoint names
#define   NM_INT3COND  (NM_INT3BASE+0) // INT3 breakpoint condition
#define   NM_INT3EXPR  (NM_INT3BASE+1) // Expression to log at INT3 breakpoint
#define   NM_INT3TYPE  (NM_INT3BASE+2) // Type used to decode expression
#define NM_MEMBASE     0x54            // Base for memory breakpoint names
#define   NM_MEMCOND   (NM_MEMBASE+0)  // Memory breakpoint condition
#define   NM_MEMEXPR   (NM_MEMBASE+1)  // Expression to log at memory break
#define   NM_MEMTYPE   (NM_MEMBASE+2)  // Type used to decode expression
#define NM_HARDBASE    0x57            // Base for hardware breakpoint names
#define   NM_HARDCOND  (NM_HARDBASE+0) // Hardware breakpoint condition
#define   NM_HARDEXPR  (NM_HARDBASE+1) // Expression to log at hardware break
#define   NM_HARDTYPE  (NM_HARDBASE+2) // Type used to decode expression

#define NM_LABELSAV    0x60            // NSTRINGS last user-defined labels
#define NM_ASMSAV      0x61            // NSTRINGS last assembled commands
#define NM_ASRCHSAV    0x62            // NSTRINGS last assemby searches
#define NM_COMMSAV     0x63            // NSTRINGS last user-defined comments
#define NM_WATCHSAV    0x64            // NSTRINGS last watch expressions
#define NM_GOTOSAV     0x65            // NSTRINGS last GOTO expressions
#define DT_BINSAV      0x66            // NSTRINGS last binary search patterns
#define NM_CONSTSAV    0x67            // NSTRINGS last constants to search
#define NM_STRSAV      0x68            // NSTRINGS last strings to search
#define NM_ARGSAV      0x69            // NSTRINGS last arguments (ARGLEN!)
#define NM_CURRSAV     0x6A            // NSTRINGS last current dirs (MAXPATH!)

#define NM_SEQSAV      0x6F            // NSTRINGS last sequences (DATALEN!)

#define NM_RTCOND1     0x70            // First run trace pause condition
#define NM_RTCOND2     0x71            // Second run trace pause condition
#define NM_RTCOND3     0x72            // Third run trace pause condition
#define NM_RTCOND4     0x73            // Fourth run trace pause condition
#define NM_RTCMD1      0x74            // First run trace match command
#define NM_RTCMD2      0x75            // Second run trace match command
#define NM_RANGE0      0x76            // Low range limit
#define NM_RANGE1      0x77            // High range limit

#define DT_ANYDATA     0xFF            // Special marker, not a real data

#define NMOFS_COND     0               // Offset to breakpoint condition
#define NMOFS_EXPR     1               // Offset to breakpoint log expression
#define NMOFS_TYPE     2               // Offset to expression decoding type

typedef struct dt_iord                 // Descriptor of DT_IORD data
{
    ulong          ord;                  // Ordinal
    wchar_t        modname[SHORTNAME];   // Short name of the module
} dt_iord;

#define NSWEXIT        256             // Max no. of switch exits, incl. default
#define NSWCASE        128             // Max no. of cases in exit

// Types of switches and switch exits.
#define CASE_CASCADED  0x00000001      // Cascaded IF
#define CASE_HUGE      0x00000002      // Huge switch, some cases are lost
#define CASE_DEFAULT   0x00000004      // Has default (is default for dt_case)
#define CASE_TYPEMASK  0x00000070      // Mask to extract case type
#define   CASE_ASCII   0x00000010      // Intreprete cases as ASCII characters
#define   CASE_MSG     0x00000020      // Interprete cases as WM_xxx
#define   CASE_EXCPTN  0x00000040      // Interprete cases as exception codes
#define CASE_SIGNED    0x00000080      // Interprete cases as signed

typedef struct dt_switch               // Switch descriptor DT_SWITCH
{
    ulong          casemin;              // Minimal case
    ulong          casemax;              // Maximal case
    ulong          type;                 // Switch type, set of CASE_xxx
    int            nexit;                // Number of exits including default
    ulong          exitaddr[NSWEXIT];    // List of exits (point to dt_case)
} dt_switch;

typedef struct dt_case                 // Switch exit descriptor DT_CASE
{
    ulong          swbase;               // Address of a switch descriptor
    ulong          type;                 // Switch type, set of CASE_xxx
    int            ncase;                // Number of cases (1..64, 0: default)
    ulong          value[NSWCASE];       // List of cases for exit
} dt_case;

// Flags indicating alternative forms of assembler mnemonics.
#define MF_JZ          0x01            // JZ, JNZ instead of JE, JNE
#define MF_JC          0x02            // JC, JNC instead of JAE, JB

typedef struct dt_mnemo                // Mnemonics decoding DT_MNEMO
{
    uchar          flags;                // Set of MF_xxx
} dt_mnemo;

stdapi (int)     Insertdata(ulong addr,int type,void *data,ulong datasize);
stdapi (ulong)   Finddata(ulong addr,int type,void *data,ulong datasize);
stdapi (void *)  Finddataptr(ulong addr,int type,ulong *datasize);
stdapi (void)    Startnextdata(ulong addr0,ulong addr1,int type);
stdapi (ulong)   Findnextdata(ulong *addr,void *data,ulong datasize);
stdapi (void)    Startnextdatalist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     Findnextdatalist(ulong *addr,int *type,
                                  void *data,ulong datasize);
stdapi (int)     Isdataavailable(ulong addr,int type1,int type2,int type3);
stdapi (int)     Isdatainrange(ulong addr0,ulong addr1,
                               int type1,int type2,int type3);
stdapi (void)    Deletedatarange(ulong addr0,ulong addr1,
                                 int type1,int type2,int type3);
stdapi (void)    Deletedatarangelist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     Quickinsertdata(ulong addr,int type,
                                 void *data,ulong datasize);
stdapi (void)    Mergequickdata(void);
stdapi (int)     DemanglenameW(wchar_t *name,wchar_t *undecorated,int recurs);
stdapi (int)     InsertnameW(ulong addr,int type,wchar_t *s);
stdapi (int)     QuickinsertnameW(ulong addr,int type,wchar_t *s);
stdapi (int)     FindnameW(ulong addr,int type,wchar_t *name,int nname);
stdapi (int)     FindnextnameW(ulong *addr,wchar_t *name,int nname);
stdapi (void)    Startnextnamelist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     FindnextnamelistW(ulong *addr,int *type,
                                   wchar_t *name,int nname);
stdapi (int)     Findlabel(ulong addr,wchar_t *name,int firsttype);
stdapi (int)     FindaddressW(wchar_t *name,struct t_module *pmod,
                              ulong *addr,wchar_t *errtxt);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// SIMPLE DATA FUNCTIONS ////////////////////////////

typedef struct t_simple                // Simple data container
{
    uchar          *heap;                // Data heap
    ulong          itemsize;             // Size of data element, bytes
    int            maxitem;              // Size of allocated data heap, items
    int            nitem;                // Actual number of data items
    int            sorted;               // Whether data is sorted
} t_simple;

stdapi (void)    Destroysimpledata(t_simple *pdat);
stdapi (int)     Createsimpledata(t_simple *pdat,ulong itemsize);
stdapi (int)     Addsimpledata(t_simple *pdat,void *data);
stdapi (void)    Sortsimpledata(t_simple *pdat);
stdapi (void *)  Findsimpledata(t_simple *pdat,ulong addr);
stdapi (int)     Getsimpledataindexbyaddr(t_simple *pdat,ulong addr);
stdapi (void *)  Getsimpledatabyindex(t_simple *pdat,int index);
stdapi (void)    Deletesimpledatarange(t_simple *pdat,ulong addr0,ulong addr1);

// Bits that describe the state of predicted data, similar to PST_xxx.
#define PRED_SHORTSP   0x8000          // Offset of ESP is 1 byte, .udd only
#define PRED_SHORTBP   0x4000          // Offset of EBP is 1 byte, .udd only
#define PRED_ESPRET    0x0400          // Offset of ESP backtraced from return
#define PRED_ESPOK     0x0200          // Offset of ESP valid
#define PRED_EBPOK     0x0100          // Offset of EBP valid
#define PRED_REL       0x0080          // Result constant fixuped or relative
#define PRED_RESMASK   0x003F          // Mask to extract description of result
#define   PRED_VALID   0x0020          // Result constant valid
#define   PRED_ADDR    0x0010          // Result is address
#define   PRED_ORIG    0x0008          // Result is based on original register
#define   PRED_OMASK   0x0007          // Mask to extract original register

#define PRED_ESPKNOWN  (PRED_ESPRET|PRED_ESPOK)

typedef struct sd_pred                 // Descriptor of predicted data
{
    ulong          addr;                 // Address of predicted command
    ushort         mode;                 // Combination of PRED_xxx
    long           espconst;             // Offset of ESP to original ESP
    long           ebpconst;             // Offset of EBP to original ESP
    ulong          resconst;             // Constant in result of execution
} sd_pred;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SORTED DATA //////////////////////////////////

#define SDM_INDEXED    0x00000001      // Indexed sorted data
#define SDM_EXTADDR    0x00000002      // Address is extended by TY_AEXTMASK
#define SDM_NOSIZE     0x00000004      // Header without size and type
#define SDM_NOEXTEND   0x00000008      // Don't reallocate memory, fail instead

// Address extension.
#define TY_AEXTMASK    0x000000FF      // Mask to extract address extension
// General item types.
#define TY_NEW         0x00000100      // Item is new
#define TY_CONFIRMED   0x00000200      // Item still exists
#define TY_EXTADDR     0x00000400      // Address extension active
#define TY_SELECTED    0x00000800      // Reserved for multiple selection
// Module-related item types (used in t_module and t_premod).
#define MOD_MAIN       0x00010000      // Main module
#define MOD_SFX        0x00020000      // Self-extractable file
#define   MOD_SFXDONE  0x00040000      // SFX file extracted
#define MOD_RUNDLL     0x00080000      // DLL loaded by LOADDLL.EXE
#define MOD_SYSTEMDLL  0x00100000      // System DLL
#define MOD_SUPERSYS   0x00200000      // System DLL that uses special commands
#define MOD_DBGDATA    0x00400000      // Debugging data is available
#define MOD_ANALYSED   0x00800000      // Module is already analysed
#define MOD_NODATA     0x01000000      // Module data is not yet available
#define MOD_HIDDEN     0x02000000      // Module is loaded in stealth mode
#define MOD_NETAPP     0x04000000      // .NET application
#define MOD_RESOLVED   0x40000000      // All static imports are resolved
// Memory-related item types (used in t_memory), see also t_memory.special.
#define MEM_ANYMEM     0x0FFFF000      // Mask for memory attributes
#define   MEM_CODE     0x00001000      // Contains image of code section
#define   MEM_DATA     0x00002000      // Contains image of data section
#define   MEM_SFX      0x00004000      // Contains self-extractor
#define   MEM_IMPDATA  0x00008000      // Contains import data
#define   MEM_EXPDATA  0x00010000      // Contains export data
#define   MEM_RSRC     0x00020000      // Contains resources
#define   MEM_RELOC    0x00040000      // Contains relocation data
#define   MEM_STACK    0x00080000      // Contains stack of some thread
#define   MEM_STKGUARD 0x00100000      // Guarding page of the stack
#define   MEM_THREAD   0x00200000      // Contains data block of some thread
#define   MEM_HEADER   0x00400000      // Contains COFF header
#define   MEM_DEFHEAP  0x00800000      // Contains default heap
#define   MEM_HEAP     0x01000000      // Contains non-default heap
#define   MEM_NATIVE   0x02000000      // Contains JIT-compiled native code
#define   MEM_GAP      0x08000000      // Free or reserved space
#define MEM_SECTION    0x10000000      // Section of the executable file
#define MEM_GUARDED    0x40000000      // NT only: guarded memory block
#define MEM_TEMPGUARD  0x80000000      // NT only: temporarily guarded block
// Thread-related item types (used in t_thread).
#define THR_MAIN       0x00010000      // Main thread
#define THR_NETDBG     0x00020000      // .NET debug helper thread
#define THR_ORGHANDLE  0x00100000      // Original thread's handle, don't close
// Window-related item types (used in t_window).
#define WN_UNICODE     0x00010000      // UNICODE window
// Procedure-related item types (used in t_procdata).
#define PD_CALLBACK    0x00001000      // Used as a callback
#define PD_RETSIZE     0x00010000      // Return size valid
#define PD_TAMPERRET   0x00020000      // Tampers with the return address
#define PD_NORETURN    0x00040000      // Calls function without return
#define PD_PURE        0x00080000      // Doesn't modify memory & make calls
#define PD_ESPALIGN    0x00100000      // Aligns ESP on entry
#define PD_ARGMASK     0x07E00000      // Mask indicating valid narg
#define   PD_FIXARG    0x00200000      // narg is fixed number of arguments
#define   PD_FORMATA   0x00400000      // narg-1 is ASCII printf format
#define   PD_FORMATW   0x00800000      // narg-1 is UNICODE printf format
#define   PD_SCANA     0x01000000      // narg-1 is ASCII scanf format
#define   PD_SCANW     0x02000000      // narg-1 is UNICODE scanf format
#define   PD_COUNT     0x04000000      // narg-1 is count of following args
#define PD_GUESSED     0x08000000      // narg and type are guessed, not known
#define PD_NGUESS      0x10000000      // nguess valid
#define PD_VARGUESS    0x20000000      // nguess variable, set to minimum!=0
#define PD_NPUSH       0x40000000      // npush valid
#define PD_VARPUSH     0x80000000      // npush valid, set to maximum
// Argument prediction-related types (used in t_predict).
#define PR_PUSHBP      0x00010000      // PUSH EBP or ENTER executed
#define PR_MOVBPSP     0x00020000      // MOV EBP,ESP or ENTER executed
#define PR_SETSEH      0x00040000      // Structured exception handler set
#define PR_RETISJMP    0x00100000      // Return is (mis)used as a jump
#define PR_DIFFRET     0x00200000      // Return changed, destination unknown
#define PR_JMPTORET    0x00400000      // Jump to original return address
#define PR_TAMPERRET   0x00800000      // Retaddr on stack accessed or modified
#define PR_BADESP      0x01000000      // ESP of actual generation is invalid
#define PR_RET         0x02000000      // Return from subroutine
#define PR_STEPINTO    0x10000000      // Step into CALL command
// Breakpoint-related types (used in t_bpoint, t_bpmem and t_bphard).
#define BP_BASE        0x0000F000      // Mask to extract basic breakpoint type
#define   BP_MANUAL    0x00001000      // Permanent breakpoint
#define   BP_ONESHOT   0x00002000      // Stop and reset this bit
#define   BP_TEMP      0x00004000      // Reset this bit and continue
#define   BP_TRACE     0x00008000      // Used for hit trace
#define BP_SET         0x00010000      // Code INT3 is in memory, cmd is valid
#define BP_DISABLED    0x00020000      // Permanent breakpoint is disabled
#define BP_COND        0x00040000      // Conditional breakpoint
#define BP_PERIODICAL  0x00080000      // Periodical (pauses each passcount)
#define BP_ACCESSMASK  0x00E00000      // Access conditions (memory+hard)
#define   BP_READ      0x00200000      // Break on read memory access
#define   BP_WRITE     0x00400000      // Break on write memory access
#define   BP_EXEC      0x00800000      // Break on code execution
#define BP_BREAKMASK   0x03000000      // When to pause execution
#define   BP_NOBREAK   0x00000000      // No pause
#define   BP_CONDBREAK 0x01000000      // Pause if condition is true
#define   BP_BREAK     0x03000000      // Pause always
#define BP_LOGMASK     0x0C000000      // When to log value of expression
#define   BP_NOLOG     0x00000000      // Don't log expression
#define   BP_CONDLOG   0x04000000      // Log expression if condition is true
#define   BP_LOG       0x0C000000      // Log expression always
#define BP_ARGMASK     0x30000000      // When to log arguments of a function
#define   BP_NOARG     0x00000000      // Don't log arguments
#define   BP_CONDARG   0x10000000      // Log arguments if condition is true
#define   BP_ARG       0x30000000      // Log arguments always
#define BP_RETMASK     0xC0000000      // When to log return value of a function
#define   BP_NORET     0x00000000      // Don't log return value
#define   BP_CONDRET   0x40000000      // Log return value if condition is true
#define   BP_RET       0xC0000000      // Log return value always
#define BP_MANMASK (BP_PERIODICAL|BP_BREAKMASK|BP_LOGMASK|BP_ARGMASK|BP_RETMASK)
#define BP_CONFIRM     TY_CONFIRMED    // Internal OllyDbg use
// Search-related types (used in t_search).
#define SE_ORIGIN      0x00010000      // Search origin
#define SE_STRING      0x00020000      // Data contains string address
#define SE_FLOAT       0x00040000      // Data contains floating constant
#define SE_GUID        0x00080000      // Data contains GUID
#define SE_CONST       0x01000000      // Constant, not referencing command
// Source-related types (used in t_source).
#define SRC_ABSENT     0x00010000      // Source file is absent
// Namelist-related types (used in t_namelist).
#define NL_EORD        0x00010000      // Associated export ordinal available
#define NL_IORD        0x00020000      // Associated import ordinal available

typedef struct t_sorthdr               // Header of sorted data item
{
    ulong          addr;                 // Base address of the entry
    ulong          size;                 // Size of the entry
    ulong          type;                 // Type and address extension, TY_xxx
} t_sorthdr;

typedef struct t_sorthdr_nosize        // Header of SDM_NOSIZE item
{
    ulong          addr;                 // Base address of the entry
} t_sorthdr_nosize;

typedef int  SORTFUNC(const t_sorthdr *,const t_sorthdr *,const int);
typedef void DESTFUNC(t_sorthdr *);

#define AUTOARRANGE    ((SORTFUNC *)1) // Autoarrangeable sorted data

#define NBLOCK         2048            // Max number of data blocks
#define BLOCKSIZE      1048576         // Size of single data block, bytes

typedef struct t_sorted                // Descriptor of sorted data
{
    int            n;                    // Actual number of entries
    int            nmax;                 // Maximal number of entries
    ulong          itemsize;             // Size of single entry
    int            mode;                 // Storage mode, set of SDM_xxx
    void           *data;                // Sorted data, NULL if SDM_INDEXED
    void           **block;              // NBLOCK sorted data blocks, or NULL
    int            nblock;               // Number of allocated blocks
    ulong          version;              // Changes on each modification
    void           **dataptr;            // Pointers to data, sorted by address
    int            selected;             // Index of selected entry
    ulong          seladdr;              // Base address of selected entry
    ulong          selsubaddr;           // Subaddress of selected entry
    SORTFUNC       *sortfunc;            // Function which sorts data or NULL
    DESTFUNC       *destfunc;            // Destructor function or NULL
    int            sort;                 // Sorting criterium (column)
    int            sorted;               // Whether indexes are sorted
    int            *sortindex;           // Indexes, sorted by criterium
} t_sorted;

stdapi (void)    Destroysorteddata(t_sorted *sd);
stdapi (int)     Createsorteddata(t_sorted *sd,ulong itemsize,int nexp,
                                  SORTFUNC *sortfunc,DESTFUNC *destfunc,int mode);
stdapi (void)    Deletesorteddata(t_sorted *sd,ulong addr,ulong subaddr);
stdapi (int)     Deletesorteddatarange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (void *)  Addsorteddata(t_sorted *sd,void *item);
stdapi (int)     Replacesorteddatarange(t_sorted *sd,void *data,int n,
                                        ulong addr0,ulong addr1);
stdapi (void)    Renumeratesorteddata(t_sorted *sd);
stdapi (int)     Confirmsorteddata(t_sorted *sd,int confirm);
stdapi (int)     Deletenonconfirmedsorteddata(t_sorted *sd);
stdapi (void)    Unmarknewsorteddata(t_sorted *sd);
stdapi (void *)  Findsorteddata(t_sorted *sd,ulong addr,ulong subaddr);
stdapi (void *)  Findsorteddatarange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (int)     Findsortedindexrange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (void *)  Getsortedbyindex(t_sorted *sd,int index);
stdapi (int)     Sortsorteddata(t_sorted *sd,int sort);
stdapi (void *)  Getsortedbyselection(t_sorted *sd,int index);
stdapi (int)     Issortedinit(t_sorted *sd);


////////////////////////////////////////////////////////////////////////////////
///////////////////////// SORTED DATA WINDOWS (TABLES) /////////////////////////

#define NBAR           17              // Max allowed number of segments in bar

#define BAR_FLAT       0x00000000      // Flat segment
#define BAR_BUTTON     0x00000001      // Segment sends WM_USER_BAR
#define BAR_SORT       0x00000002      // Segment re-sorts sorted data
#define BAR_DISABLED   0x00000004      // Bar segment disabled
#define BAR_NORESIZE   0x00000008      // Bar column cannot be resized
#define BAR_SHIFTSEL   0x00000010      // Selection shifted 1/2 char to left
#define BAR_WIDEFONT   0x00000020      // Twice as wide characters
#define BAR_SEP        0x00000040      // Treat '|' as separator
#define BAR_ARROWS     0x00000080      // Arrows if segment is shifted
#define BAR_PRESSED    0x00000100      // Bar segment pressed, used internally
#define BAR_SPMASK     0x0000F000      // Mask to extract speech type
#define   BAR_SPSTD    0x00000000      // Standard speech with all conversions
#define   BAR_SPASM    0x00001000      // Disassembler-oriented speech
#define   BAR_SPEXPR   0x00002000      // Expression-oriented speech
#define   BAR_SPEXACT  0x00003000      // Pass to speech engine as is
#define   BAR_SPELL    0x00004000      // Text, spell symbol by symbol
#define   BAR_SPHEX    0x00005000      // Hexadecimal, spell symbol by symbol
#define   BAR_SPNONE   0x0000F000      // Column is excluded from speech

typedef struct t_bar                   // Descriptor of columns in table window
{
    // These variables must be filled before table window is created.
    int            nbar;                 // Number of columns
    int            visible;              // Bar visible
    wchar_t        *name[NBAR];          // Column names (may be NULL)
    wchar_t        *expl[NBAR];          // Explanations of columns
    int            mode[NBAR];           // Combination of bits BAR_xxx
    int            defdx[NBAR];          // Default widths of columns, chars
    // These variables are initialized by window creation function.
    int            dx[NBAR];             // Actual widths of columns, pixels
    int            captured;             // One of CAPT_xxx
    int            active;               // Info about where mouse was captured
    int            scrollvx;             // X scrolling speed
    int            scrollvy;             // Y scrolling speed
    int            prevx;                // Previous X mouse coordinate
    int            prevy;                // Previous Y mouse coordinate
} t_bar;

#define TABLE_USERDEF  0x00000001      // User-drawn table
#define TABLE_STDSCR   0x00000002      // User-drawn but standard scrolling
#define TABLE_SIMPLE   0x00000004      // Non-sorted, address is line number
#define TABLE_DIR      0x00000008      // Bottom-to-top table
#define TABLE_COLSEL   0x00000010      // Column-wide selection
#define TABLE_BYTE     0x00000020      // Allows for bytewise scrolling
#define TABLE_FASTSEL  0x00000040      // Update when selection changes
#define TABLE_RIGHTSEL 0x00000080      // Right click can select items
#define TABLE_RFOCUS   0x00000100      // Right click sets focus
#define TABLE_NOHSCR   0x00000200      // Table contains no horizontal scroll
#define TABLE_NOVSCR   0x00000400      // Table contains no vertical scroll
#define TABLE_NOBAR    0x00000800      // Bar is always hidden
#define TABLE_STATUS   0x00001000      // Table contains status bar
#define TABLE_MMOVX    0x00002000      // Table is moveable by mouse in X
#define TABLE_MMOVY    0x00004000      // Table is moveable by mouse in Y
#define TABLE_WANTCHAR 0x00008000      // Table processes characters
#define TABLE_SAVEAPP  0x00010000      // Save appearance to .ini
#define TABLE_SAVEPOS  0x00020000      // Save position to .ini
#define TABLE_SAVECOL  0x00040000      // Save width of columns to .ini
#define TABLE_SAVESORT 0x00080000      // Save sort criterium to .ini
#define TABLE_SAVECUST 0x00100000      // Save table-specific data to .ini
#define TABLE_GRAYTEXT 0x00200000      // Text in table is grayed
#define TABLE_NOGRAY   0x00400000      // Text in pane is never grayed
#define TABLE_UPDFOCUS 0x00800000      // Update frame pane on focus change
#define TABLE_AUTOUPD  0x01000000      // Table allows periodical autoupdate
#define TABLE_SYNTAX   0x02000000      // Table allows syntax highlighting
#define TABLE_PROPWID  0x04000000      // Column width means proportional width
#define TABLE_INFRAME  0x10000000      // Table belongs to the frame window
#define TABLE_BORDER   0x20000000      // Table has sunken border
#define TABLE_KEEPOFFS 0x80000000      // Keep xshift, offset, colsel

#define TABLE_MOUSEMV  (TABLE_MMOVX|TABLE_MMOVY)
#define TABLE_SAVEALL (TABLE_SAVEAPP|TABLE_SAVEPOS|TABLE_SAVECOL|TABLE_SAVESORT)

#define DRAW_COLOR     0x0000001F      // Mask to extract colour/bkgnd index
// Direct colour/background pairs.
#define   DRAW_NORMAL  0x00000000      // Normal text
#define   DRAW_HILITE  0x00000001      // Highlighted text
#define   DRAW_GRAY    0x00000002      // Grayed text
#define   DRAW_EIP     0x00000003      // Actual EIP
#define   DRAW_BREAK   0x00000004      // Unconditional breakpoint
#define   DRAW_COND    0x00000005      // Conditional breakpoint
#define   DRAW_BDIS    0x00000006      // Disabled breakpoint
#define   DRAW_IPBREAK 0x00000007      // Breakpoint at actual EIP
#define   DRAW_AUX     0x00000008      // Auxiliary colours
#define   DRAW_SELUL   0x00000009      // Selection and underlining
// Indirect pairs used to highlight commands.
#define   DRAW_PLAIN   0x0000000C      // Plain commands
#define   DRAW_JUMP    0x0000000D      // Unconditional jump commands
#define   DRAW_CJMP    0x0000000E      // Conditional jump commands
#define   DRAW_PUSHPOP 0x0000000F      // PUSH/POP commands
#define   DRAW_CALL    0x00000010      // CALL commands
#define   DRAW_RET     0x00000011      // RET commands
#define   DRAW_FPU     0x00000012      // FPU, MMX, 3DNow! and SSE commands
#define   DRAW_SUSPECT 0x00000013      // Bad, system and privileged commands
#define   DRAW_FILL    0x00000014      // Filling commands
#define   DRAW_MOD     0x00000015      // Modified commands
// Indirect pairs used to highlight operands.
#define   DRAW_IREG    0x00000018      // General purpose registers
#define   DRAW_FREG    0x00000019      // FPU, MMX and SSE registers
#define   DRAW_SYSREG  0x0000001A      // Segment and system registers
#define   DRAW_STKMEM  0x0000001B      // Memory accessed over ESP or EBP
#define   DRAW_MEM     0x0000001C      // Any other memory
#define   DRAW_MCONST  0x0000001D      // Constant pointing to memory
#define   DRAW_CONST   0x0000001E      // Any other constant
#define DRAW_APP       0x00000060      // Mask to extract appearance
#define   DRAW_TEXT    0x00000000      // Plain text
#define   DRAW_ULTEXT  0x00000020      // Underlined text
#define   DRAW_GRAPH   0x00000060      // Graphics (text consists of G_xxx)
#define DRAW_SELECT    0x00000080      // Use selection background
#define DRAW_MASK      0x00000100      // Mask in use
#define DRAW_VARWIDTH  0x00000200      // Variable width possible
#define DRAW_EXTSEL    0x00000800      // Extend mask till end of column
#define DRAW_TOP       0x00001000      // Draw upper half of the two-line text
#define DRAW_BOTTOM    0x00002000      // Draw lower half of the two-line text
#define DRAW_INACTIVE  0x00004000      // Gray everything except hilited text
#define DRAW_RAWDATA   0x00008000      // Don't convert glyphs and multibytes
#define DRAW_NEW       0x00010000      // Use highlighted foreground

typedef struct t_drawheader            // Draw descriptor for TABLE_USERDEF
{
    int            line;                 // Line in window
    int            n;                    // Total number of visible lines
    ulong          nextaddr;             // First address on next line, or 0
    // Following elements can be freely used by drawing routine. They do not
    // change between calls within one table.
    ulong          addr;                 // Custom data
    uchar          s[TEXTLEN];           // Custom data
} t_drawheader;

// Constants used for scrolling and selection.
#define MOVETOP        0x8000          // Move selection to top of table
#define MOVEBOTTOM     0x7FFF          // Move selection to bottom of table

#define DF_CACHESIZE   (-4)            // Request for draw cache size
#define DF_FILLCACHE   (-3)            // Request to fill draw cache
#define DF_FREECACHE   (-2)            // Request to free cached resources
#define DF_NEWROW      (-1)            // Request to start new row in window

// Reasons why t_table.tableselfunc() was called.
#define TSC_KEY        1               // Keyboard key pressed
#define TSC_MOUSE      2               // Selection changed by mouse
#define TSC_CALL       3               // Call to selection move function

typedef long TABFUNC(struct t_table *,HWND,UINT,WPARAM,LPARAM);
typedef int  UPDATEFUNC(struct t_table *);
typedef int  DRAWFUNC(wchar_t *,uchar *,int *,struct t_table *,
                      t_sorthdr *,int,void *);
typedef void TABSELFUNC(struct t_table *,int,int);

typedef struct t_table                 // Window with sorted data and bar
{
    // These variables must be filled before table window is created.
    wchar_t        name[SHORTNAME];      // Name used to save/restore position
    int            mode;                 // Combination of bits TABLE_xxx
    t_sorted       sorted;               // Sorted data
    int            subtype;              // User-defined subtype
    t_bar          bar;                  // Description of bar
    int            bottomspace;          // Height of free space on the bottom
    int            minwidth;             // Minimal width of the table, pixels
    TABFUNC        *tabfunc;             // Custom message function or NULL
    UPDATEFUNC     *updatefunc;          // Data update function or NULL
    DRAWFUNC       *drawfunc;            // Drawing function
    TABSELFUNC     *tableselfunc;        // Callback indicating selection change
    t_menu         *menu;                // Menu descriptor
    // Table functions neither initialize nor use these variables.
    ulong          custommode;           // User-defined custom data
    void           *customdata;          // Pointer to more custom data
    // These variables are initialized and/or used by table functions.
    HWND           hparent;              // Handle of MDI container or NULL
    HWND           hstatus;              // Handle of status bar or NULL
    HWND           hw;                   // Handle of child table or NULL
    HWND           htooltip;             // Handle of tooltip window or NULL
    int            font;                 // Index of font used by window
    int            scheme;               // Colour scheme used by window
    int            hilite;               // Highlighting scheme used by window
    int            hscroll;              // Whether horizontal scroll visible
    int            xshift;               // Shift in X direction, pixels
    int            offset;               // First displayed row
    int            colsel;               // Column in TABLE_COLSEL window
    ulong          version;              // Version of sorted on last update
    ulong          timerdraw;            // Timer redraw is active (period, ms)
    RECT           rcprev;               // Temporary storage for old position
    int            rtback;               // Back step in run trace, 0 - actual
} t_table;

#define GWL_USR_TABLE  0               // Offset to pointer to t_table

// Custom messages.
#define WM_USER_CREATE (WM_USER+100)   // Table window is created
#define WM_USER_HSCR   (WM_USER+101)   // Update horizontal scroll
#define WM_USER_VSCR   (WM_USER+102)   // Update vertical scroll
#define WM_USER_MOUSE  (WM_USER+103)   // Mouse moves, set custom cursor
#define WM_USER_VINC   (WM_USER+104)   // Scroll contents of window by lines
#define WM_USER_VPOS   (WM_USER+105)   // Scroll contents of window by position
#define WM_USER_VBYTE  (WM_USER+106)   // Scroll contents of window by bytes
#define WM_USER_SETS   (WM_USER+107)   // Start selection in window
#define WM_USER_CNTS   (WM_USER+108)   // Continue selection in window
#define WM_USER_MMOV   (WM_USER+109)   // Move window's contents by mouse
#define WM_USER_MOVS   (WM_USER+110)   // Keyboard scrolling and selection
#define WM_USER_KEY    (WM_USER+111)   // Key pressed
#define WM_USER_BAR    (WM_USER+112)   // Message from bar segment as button
#define WM_USER_DBLCLK (WM_USER+113)   // Doubleclick in column
#define WM_USER_SELXY  (WM_USER+114)   // Get coordinates of selection
#define WM_USER_FOCUS  (WM_USER+115)   // Set focus to child of frame window
#define WM_USER_UPD    (WM_USER+116)   // Autoupdate contents of the window
#define WM_USER_MTAB   (WM_USER+117)   // Middle click on tab in tab parent
// Custom broadcasts and notifications.
#define WM_USER_CHGALL (WM_USER+132)   // Update all windows
#define WM_USER_CHGCPU (WM_USER+133)   // CPU thread has changed
#define WM_USER_CHGMEM (WM_USER+134)   // List of memory blocks has changed
#define WM_USER_BKUP   (WM_USER+135)   // Global backup is changed
#define WM_USER_FILE   (WM_USER+136)   // Query for file dump
#define WM_USER_NAMES  (WM_USER+137)   // Query for namelist window
#define WM_USER_SAVE   (WM_USER+138)   // Query for unsaved data
#define WM_USER_CLEAN  (WM_USER+139)   // End of process, close related windows
#define WM_USER_HERE   (WM_USER+140)   // Query for windows to restore
#define WM_USER_CLOSE  (WM_USER+141)   // Internal substitute for WM_CLOSE

#define KEY_ALT        0x04            // Alt key pressed
#define KEY_CTRL       0x02            // Ctrl key pressed
#define KEY_SHIFT      0x01            // Shift key pressed

// Control alignment modes for Createtablechild().
#define ALIGN_MASK     0xC000          // Mask to extract control alignment
#define   ALIGN_LEFT   0x0000          // Control doesn't move
#define   ALIGN_RIGHT  0x4000          // Control moves with right border
#define   ALIGN_WIDTH  0x8000          // Control resizes with right border
#define ALIGN_IDMASK   0x0FFF          // Mask to extract control ID

stdapi (void)    Processwmmousewheel(HWND hw,WPARAM wp);
stdapi (int)     Getcharacterwidth(t_table *pt,int column);
stdapi (void)    Defaultbar(t_table *pt);
stdapi (int)     Linecount(t_table *pt);
stdapi (int)     Gettabletext(t_table *pt,int row,int column,
                              wchar_t *text,uchar *tmask,int *tselect);
stdapi (int)     Gettableselectionxy(t_table *pt,int column,POINT *coord);
stdapi (int)     Maketableareavisible(t_table *pt,int column,
                                      int x0,int y0,int x1,int y1);
stdapi (int)     Movetableselection(t_table *pt,int n);
stdapi (int)     Settableselection(t_table *pt,int selected);
stdapi (int)     Removetableselection(t_table *pt);
stdapi (void)    Updatetable(t_table *pt,int force);
stdapi (void)    Delayedtableredraw(t_table *pt);
stdapi (void)    Setautoupdate(t_table *pt,int autoupdate);
stdapi (HGLOBAL) Copytableselection(t_table *pt,int column);
stdapi (HGLOBAL) Copywholetable(t_table *pt,int compatible);
stdapi (HWND)    Createottablewindow(HWND hparent,t_table *pt,RECT *rpos);
stdapi (HWND)    Createtablewindow(t_table *pt,int nrow,int ncolumn,
                                   HINSTANCE hi,wchar_t *icon,wchar_t *title);
stdapi (HWND)    Activatetablewindow(t_table *pt);
stdapi (HWND)    Createtablechild(t_table *pt,wchar_t *classname,wchar_t *name,
                                  wchar_t *help,ulong style,int x,int y,int dx,int dy,
                                  int idalign);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// FRAME AND TAB WINDOWS /////////////////////////////

#define BLK_NONE       0               // Mouse outside the dividing line
#define BLK_HDIV       1               // Divide horizontally
#define BLK_VDIV       2               // Divide vertically
#define BLK_TABLE      3               // Leaf that describes table window

typedef struct t_block                 // Block descriptor
{
    int            index;                // Index of pos record in the .ini file
    int            type;                 // One of BLK_xxx
    int            percent;              // Percent of block in left/top subblock
    int            offset;               // Offset of dividing line, pixels
    struct t_block *blk1;                // Top/left subblock, NULL if leaf
    int            minp1;                // Min size of 1st subblock, pixels
    int            maxc1;                // Max size of 1st subblock, chars, or 0
    struct t_block *blk2;                // Bottom/right subblock, NULL if leaf
    int            minp2;                // Min size of 2nd subblock, pixels
    int            maxc2;                // Max size of 2nd subblock, chars, or 0
    t_table        *table;               // Descriptor of table window
    wchar_t        tabname[SHORTNAME];   // Tab (tab window only)
    wchar_t        title[TEXTLEN];       // Title (tab window) or speech name
    wchar_t        status[TEXTLEN];      // Status (tab window only)
} t_block;

typedef struct t_frame                 // Descriptor of frame or tab window
{
    // These variables must be filled before frame window is created.
    wchar_t        name[SHORTNAME];      // Name used to save/restore position
    int            herebit;              // Must be 0 for plugins
    int            mode;                 // Combination of bits TABLE_xxx
    t_block        *block;               // Pointer to block tree
    t_menu         *menu;                // Menu descriptor (tab window only)
    int            scheme;               // Colour scheme used by window
    // These variables are initialized by frame creation function.
    HWND           hw;                   // Handle of MDI container or NULL
    HWND           htab;                 // Handle of tab control
    WNDPROC        htabwndproc;          // Original WndProc of tab control
    int            capturedtab;          // Tab captured on middle mouse click
    HWND           hstatus;              // Handle of status bar or NULL
    t_block        *active;              // Active table (has focus) or NULL
    t_block        *captured;            // Block that captured mouse or NULL
    int            captureoffset;        // Offset on mouse capture
    int            capturex;             // Mouse screen X coordinate on capture
    int            capturey;             // Mouse screen Y coordinate on capture
    wchar_t        title[TEXTLEN];       // Frame or tab window title
} t_frame;

stdapi (HWND)    Createframewindow(t_frame *pf,wchar_t *icon,wchar_t *title);
stdapi (void)    Updateframe(t_frame *pf,int redrawnow);
stdapi (t_table *) Getactiveframe(t_frame *pf);

stdapi (int)     Updatetabs(t_frame *pf);
stdapi (HWND)    Createtabwindow(t_frame *pf,wchar_t *icon,wchar_t *title);
stdapi (t_table *) Getactivetab(t_frame *pf);
stdapi (int)     Gettabcount(t_frame *pf,int *index);
stdapi (int)     Setactivetab(t_frame *pf,int index);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// FONTS AND GRAPHICS //////////////////////////////

#define FIXEDFONT      0               // Indices of fixed fonts used in tables
#define TERMINAL6      1               // Note: fonts may be changed by user!
#define FIXEDSYS       2
#define COURIERFONT    3
#define LUCIDACONS     4
#define FONT5          5
#define FONT6          6
#define FONT7          7

#define NFIXFONTS      8               // Total number of fixed fonts

#define BLACKWHITE     0               // Colour schemes used by OllyDbg
#define BLUEGOLD       1               // Note: colours may be changed by user!
#define SKYWIND        2
#define NIGHTSTARS     3
#define SCHEME4        4
#define SCHEME5        5
#define SCHEME6        6
#define SCHEME7        7

#define NSCHEMES       8               // Number of predefined colour schemes
#define NDRAW          32              // Number of fg/bg pairs in scheme

#define NOHILITE       0               // Highlighting schemes used by OllyDbg
#define XMASHILITE     1               // Note: colours may be changed by user!
#define JUMPHILITE     2
#define MEMHILITE      3
#define HILITE4        4
#define HILITE5        5
#define HILITE6        6
#define HILITE7        7

#define NHILITE        8               // Number of predefined hilite schemes

#define BLACK          0               // Indexes of colours used by OllyDbg
#define BLUE           1
#define GREEN          2
#define CYAN           3
#define RED            4
#define MAGENTA        5
#define BROWN          6
#define LIGHTGRAY      7
#define DARKGRAY       8
#define LIGHTBLUE      9
#define LIGHTGREEN     10
#define LIGHTCYAN      11
#define LIGHTRED       12
#define LIGHTMAGENTA   13
#define YELLOW         14
#define WHITE          15
#define MINT           16
#define SKYBLUE        17
#define IVORY          18
#define GRAY           19

#define NFIXCOLORS     20              // Number of colors fixed in OllyDbg
#define NCOLORS        (NFIXCOLORS+16) // Number of available colours

// Symbolic names for graphical characters. Any other graphical symbol is
// interpreted as a space. Use only symbols in range [0x01..0x3F], high bits
// are reserved for the future!
#define G_SPACE        0x01            // Space
#define G_SEP          0x02            // Thin separating line
#define G_POINT        0x03            // Point
#define G_BIGPOINT     0x04            // Big point
#define G_JMPDEST      0x05            // Jump destination
#define G_CALLDEST     0x06            // Call destination
#define G_QUESTION     0x07            // Question mark
#define G_JMPUP        0x10            // Jump upstairs
#define G_JMPOUT       0x11            // Jump to same location or outside
#define G_JMPDN        0x12            // Jump downstairs
#define G_SWUP         0x13            // Switch upstairs
#define G_SWBOTH       0x14            // Switch in both directions
#define G_SWDOWN       0x15            // Switch down
#define G_BEGIN        0x18            // Begin of procedure or scope
#define G_BODY         0x19            // Body of procedure or scope
#define G_ENTRY        0x1A            // Loop entry point
#define G_LEAF         0x1B            // Intermediate leaf on a tree
#define G_END          0x1C            // End of procedure or scope
#define G_SINGLE       0x1D            // Single-line scope
#define G_ENDBEG       0x1E            // End and begin of stack scope
#define G_PATHUP       0x21            // Jump path start upstairs
#define G_PATH         0x22            // Jump path through
#define G_PATHDN       0x23            // Jump path start downstairs
#define G_PATHUPDN     0x24            // Two-sided jump path start
#define G_THROUGHUP    0x25            // Jump entry upstairs
#define G_THROUGHDN    0x26            // Jump entry downstairs
#define G_PATHUPEND    0x27            // End of path upstairs
#define G_PATHDNEND    0x28            // End of path downstairs
#define G_PATHBIEND    0x29            // Two-sided end of path
#define G_THRUUPEND    0x2A            // Intermediate end upstairs
#define G_THRUDNEND    0x2B            // Intermediate end downstairs
#define G_ARRLEFT      0x2C            // Left arrow
// Graphical elements used to draw frames in the command help.
#define G_HL           0x30            // Horizontal line
#define G_LT           0x31            // Left top corner
#define G_CT           0x32            // Central top element
#define G_RT           0x33            // Right top corner
#define G_LM           0x34            // Left middle element
#define G_CM           0x35            // Central cross
#define G_RM           0x36            // Right middle element
#define G_LB           0x37            // Left bottom corner
#define G_CB           0x38            // Central bottom element
#define G_RB           0x39            // Right bottom corner
#define G_VL           0x3A            // Vertical line
#define G_LA           0x3B            // Horizontal line with left arrow
#define G_RA           0x3C            // Horizontal line with right arrow
#define G_DA           0x3D            // Vertical line with down arrow

typedef struct t_font                  // Font descriptor
{
    LOGFONT        logfont;              // System font description
    int            stockindex;           // Index for system stock fonts
    int            hadjtop;              // Height adjustment on top, pixels
    int            hadjbot;              // Height adjustment on bottom, pixels
    wchar_t        name[TEXTLEN];        // Internal font name
    HFONT          hfont;                // Font handle
    int            isstock;              // Don't destroy hfont, taken from stock
    int            isfullunicode;        // Whether UNICODE is fully supported
    int            width;                // Average font width
    int            height;               // Font height
} t_font;

typedef struct t_scheme                // Descriptor of colour scheme
{
    wchar_t        name[TEXTLEN];        // Internal scheme name
    COLORREF       textcolor[NDRAW];     // Foreground colours (in DRAW_COLOR)
    COLORREF       bkcolor[NDRAW];       // Background colours (in DRAW_COLOR)
    int            hiliteoperands;       // Used only by highlighting schemes
    int            hilitemodified;       // Used only by highlighting schemes
    HBRUSH         bkbrush;              // Ordinary background brush
    HBRUSH         selbkbrush;           // Selected background brush
    HBRUSH         auxbrush;             // Auxiliary brush
    HPEN           graphpen;             // Pen for normal graphical elements
    HPEN           lopen;                // Pen for grayed graphical elements
    HPEN           hipen;                // Pen for hilited graphical elements
    HPEN           auxpen;               // Pen for auxiliary graphical elements
    HPEN           ulpen;                // Pen to underline text
} t_scheme;

stdapi (int)     Getmonitorrect(int x,int y,RECT *rc);
stdapi (void)    Sunkenframe(HDC dc,RECT *rc,int flags);
stdapi (int)     Findstockobject(ulong gdihandle,wchar_t *name,int nname);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MEMORY FUNCTIONS ///////////////////////////////

// Mode bits used in calls to Readmemory(), Readmemoryex() and Writememory().
#define MM_REPORT      0x0000          // Display error message if unreadable
#define MM_SILENT      0x0001          // Don't display error message
#define MM_NORESTORE   0x0002          // Don't remove/set INT3 breakpoints
#define MM_PARTIAL     0x0004          // Allow less data than requested
#define MM_WRITETHRU   0x0008          // Write immediately to memory
#define MM_REMOVEINT3  0x0010          // Writememory(): remove INT3 breaks
#define MM_ADJUSTINT3  0x0020          // Writememory(): adjust INT3 breaks
#define MM_FAILGUARD   0x0040          // Fail if memory is guarded
// Mode bits used in calls to Readmemoryex().
#define MM_BPMASK      BP_ACCESSMASK   // Mask to extract memory breakpoints
#define   MM_BPREAD    BP_READ         // Fail if memory break on read is set
#define   MM_BPWRITE   BP_WRITE        // Fail if memory break on write is set
#define   MM_BPEXEC    BP_EXEC         // Fail if memory break on exec is set

// Special types of memory block.
#define MSP_NONE       0               // Not a special memory block
#define MSP_PEB        1               // Contains Process Environment Block
#define MSP_SHDATA     2               // Contains KUSER_SHARED_DATA
#define MSP_PROCPAR    3               // Contains Process Parameters
#define MSP_ENV        4               // Contains environment

typedef struct t_memory                // Descriptor of memory block
{
    ulong          base;                 // Base address of memory block
    ulong          size;                 // Size of memory block
    ulong          type;                 // Service information, TY_xxx+MEM_xxx
    int            special;              // Extension of type, one of MSP_xxx
    ulong          owner;                // Address of owner of the memory
    ulong          initaccess;           // Initial read/write access
    ulong          access;               // Actual status and read/write access
    ulong          threadid;             // Block belongs to this thread or 0
    wchar_t        sectname[SHORTNAME];  // Null-terminated section name
    uchar          *copy;                // Copy used in CPU window or NULL
    uchar          *decode;              // Decoding information or NULL
} t_memory;

stdapi (void)    Flushmemorycache(void);
stdapi (ulong)   Readmemory(void *buf,ulong addr,ulong size,int mode);
stdapi (ulong)   Readmemoryex(void *buf,ulong addr,ulong size,int mode,
                              ulong threadid);
stdapi (ulong)   Writememory(const void *buf,ulong addr,ulong size,int mode);
stdapi (t_memory *) Findmemory(ulong addr);
stdapi (uchar *) Finddecode(ulong addr,ulong *psize);
stdapi (int)     Guardmemory(ulong base,ulong size,int guard);
stdapi (int)     Listmemory(void);
stdapi (HGLOBAL) Copymemoryhex(ulong addr,ulong size);
stdapi (int)     Pastememoryhex(ulong addr,ulong size,
                                int ensurebackup,int removeanalysis);
stdapi (int)     Editmemory(HWND hparent,ulong addr,ulong size,
                            int ensurebackup,int removeanalysis,int x,int y,int font);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// JUMP DATA ///////////////////////////////////

// Types of recognized jumps and calls.
#define JT_TYPE        0x000F          // Mask to extract data type
#define   JT_UNDEF     0x0000          // End of jump table
#define   JT_JUMP      0x0001          // Unconditional jump
#define   JT_COND      0x0002          // Conditional jump
#define   JT_SWITCH    0x0003          // Jump via switch table
#define   JT_RET       0x0004          // RET misused as jump
#define   JT_CALL      0x0005          // Call
#define   JT_SWCALL    0x0006          // Call via switch table
#define   JT_NETJUMP   0x0008          // Unconditional jump in CIL code
#define   JT_NETCOND   0x0009          // Conditional jump in CIL code
#define   JT_NETSW     0x000A          // Switch jump in CIL code
// Used as flag to Addjump, absent in the jump table.
#define JT_NOSORT      0x8000          // Do not sort data implicitly

// Note that these macros work both with t_jmp and t_jmpcall.
#define Isjump(jmp)    (((jmp)->type>=JT_JUMP && (jmp)->type<=JT_RET) ||       \
                       ((jmp)->type>=JT_NETJUMP && (jmp)->type<=JT_NETSW))
#define Iscall(jmp)    ((jmp)->type==JT_CALL || (jmp)->type==JT_SWCALL)

typedef struct t_jmp                   // Descriptor of recognized jump or call
{
    ulong          from;                 // Address of jump/call command
    ulong          dest;                 // Adress of jump/call destination
    uchar          type;                 // Jump/call type, one of JT_xxx
} t_jmp;

typedef struct t_exe                   // Description of executable module
{
    ulong          base;                 // Module base
    ulong          size;                 // Module size
    int            adjusted;             // Whether base is already adjusted
    wchar_t        path[MAXPATH];        // Full module path
} t_exe;

typedef struct t_jmpdata               // Jump table
{
    ulong          modbase;              // Base of module owning jump table
    ulong          modsize;              // Size of module owning jump table
    t_jmp          *jmpdata;             // Jump data, sorted by source
    int            *jmpindex;            // Indices to jmpdata, sorted by dest
    int            maxjmp;               // Total number of elements in arrays
    int            njmp;                 // Number of used elements in arrays
    int            nsorted;              // Number of sorted elements in arrays
    int            dontsort;             // Do not sort data implicitly
    t_exe          *exe;                 // Pointed modules, unsorted
    int            maxexe;               // Allocated number of elements in exe
    int            nexe;                 // Number of used elements in exe
} t_jmpdata;

typedef struct t_jmpcall               // Descriptor of found jump or call
{
    ulong          addr;                 // Source or destination address
    union
    {
        int          type;                 // Jump/call type, one of JT_xxx
        ulong        swcase;               // First switch case
    };
} t_jmpcall;

stdapi (int)     Addjump(t_jmpdata *pdat,ulong from,ulong dest,int type);
stdapi (void)    Sortjumpdata(t_jmpdata *pdat);
stdapi (t_jmp *) Findjumpfrom(ulong from);
stdapi (int)     Findlocaljumpsto(ulong dest,ulong *buf,int nbuf);
stdapi (int)     Findlocaljumpscallsto(ulong dest,t_jmpcall *jmpcall,
                                       int njmpcall);
stdapi (int)     Arelocaljumpscallstorange(ulong addr0,ulong addr1);
stdapi (int)     Findglobalcallsto(ulong dest,ulong *buf,int nbuf);
stdapi (int)     Findglobaljumpscallsto(ulong dest,t_jmpcall *jmpcall,
                                        int njmpcall);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// SETS OF RANGES ////////////////////////////////

typedef struct t_range
{
    ulong        rmin;                   // Low range limit
    ulong        rmax;                   // High range limit (INCLUDED!)
} t_range;

stdapi (int)     Initset(t_range *set,ulong nmax);
stdapi (int)     Fullrange(t_range *set);
stdapi (int)     Emptyrange(t_range *set);
stdapi (ulong)   Getsetcount(const t_range *set);
stdapi (int)     Getrangecount(const t_range *set);
stdapi (int)     Isinset(const t_range *set,ulong value);
stdapi (int)     Getrangebymember(const t_range *set,ulong value,
                                  ulong *rmin,ulong *rmax);
stdapi (int)     Getrangebyindex(const t_range *set,int index,
                                 ulong *rmin,ulong *rmax);
stdapi (int)     Addrange(t_range *set,ulong rmin,ulong rmax);
stdapi (int)     Removerange(t_range *set,ulong rmin,ulong rmax);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// NESTED DATA //////////////////////////////////

// General item types related to nested data.
#define ND_LEVELMASK   0x000000FF      // Mask to extract nesting level
#define ND_OPENTOP     0x00000100      // Range is open on the top
#define ND_OPENBOTTOM  0x00000200      // Range is open on the bottom
#define ND_NESTHILITE  0x00000400      // Highlighted bracket
#define ND_NESTGRAY    0x00000800      // Grayed bracket
// Types specific to loop data t_loopnest:
#define ND_MOREVARS    0x00010000      // List of loop variables overflowed

#define MAXNEST        32              // Limit of displayed nesting levels

typedef struct t_nesthdr               // Header of nested data range
{
    ulong          addr0;                // First address occupied by range
    ulong          addr1;                // Last occupied address (included!)
    ulong          type;                 // Level and user-defined type, TY_xxx
    ulong          aprev;                // First address of previous range
} t_nesthdr;

typedef void NDDEST(t_nesthdr *);

typedef struct t_nested                // Descriptor of nested data
{
    int            n;                    // Actual number of elements
    int            nmax;                 // Maximal number of elements
    ulong          itemsize;             // Size of single element
    void           *data;                // Ordered nested data
    ulong          version;              // Changes on each modification
    NDDEST         *destfunc;            // Destructor function or NULL
} t_nested;

stdapi (void)    Destroynesteddata(t_nested *nd);
stdapi (int)     Createnesteddata(t_nested *nd,ulong itemsize,int nexp,
                                  NDDEST *destfunc);
stdapi (void *)  Addnesteddata(t_nested *nd,void *item);
stdapi (void)    Deletenestedrange(t_nested *nd,ulong addr0,ulong addr1);
stdapi (int)     Getnestingpattern(t_nested *nd,ulong addr,wchar_t *pat,
                                   int npat,uchar *mask,int showentry,int *isend);
stdapi (int)     Getnestingdepth(t_nested *nd,ulong addr);
stdapi (void *)  Findnesteddata(t_nested *nd,ulong addr,int level);

stdapi (void *)  Nesteddatatoudd(t_nested *nd,ulong base,ulong *datasize);
stdapi (int)     Uddtonesteddata(t_nested *nd,void *data,ulong base,ulong size);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// MODULES ////////////////////////////////////

#define SHT_MERGENEXT  0x00000001      // Merge section with the next

#define NCALLMOD       24              // Max number of saved called modules

// .NET stream identifiers. Don't change the order and the values of the
// first three items (NS_STRINGS, NS_GUID and NS_BLOB)!
#define NS_STRINGS     0               // Stream with ASCII strings
#define NS_GUID        1               // Stream with GUIDs
#define NS_BLOB        2               // Data referenced by MetaData
#define NS_US          3               // Stream with UNICODE strings
#define NS_META        4               // Stream with MetaData tables

#define NETSTREAM      5               // Number of default .NET streams

// Indices of .NET MetaData tables.
#define MDT_MODULE     0               // Module table
#define MDT_TYPEREF    1               // TypeRef table
#define MDT_TYPEDEF    2               // TypeDef table
#define MDT_FIELDPTR   3               // FieldPtr table
#define MDT_FIELD      4               // Field table
#define MDT_METHODPTR  5               // MethodPtr table
#define MDT_METHOD     6               // MethodDef table
#define MDT_PARAMPTR   7               // ParamPtr table
#define MDT_PARAM      8               // Param table
#define MDT_INTERFACE  9               // InterfaceImpl table
#define MDT_MEMBERREF  10              // MemberRef table
#define MDT_CONSTANT   11              // Constant table
#define MDT_CUSTATTR   12              // CustomAttribute table
#define MDT_MARSHAL    13              // FieldMarshal table
#define MDT_DECLSEC    14              // DeclSecurity table
#define MDT_CLASSLAY   15              // ClassLayout table
#define MDT_FIELDLAY   16              // FieldLayout table
#define MDT_SIGNATURE  17              // StandAloneSig table
#define MDT_EVENTMAP   18              // EventMap table
#define MDT_EVENTPTR   19              // EventPtr table
#define MDT_EVENT      20              // Event table
#define MDT_PROPMAP    21              // PropertyMap table
#define MDT_PROPPTR    22              // PropertyPtr table
#define MDT_PROPERTY   23              // Property table
#define MDT_METHSEM    24              // MethodSemantics table
#define MDT_METHIMPL   25              // MethodImpl table
#define MDT_MODREF     26              // ModuleRef table
#define MDT_TYPESPEC   27              // TypeSpec table
#define MDT_IMPLMAP    28              // ImplMap table
#define MDT_RVA        29              // FieldRVA table
#define MDT_ENCLOG     30              // ENCLog table
#define MDT_ENCMAP     31              // ENCMap table
#define MDT_ASSEMBLY   32              // Assembly table
#define MDT_ASMPROC    33              // AssemblyProcessor table
#define MDT_ASMOS      34              // AssemblyOS table
#define MDT_ASMREF     35              // AssemblyRef table
#define MDT_REFPROC    36              // AssemblyRefProcessor table
#define MDT_REFOS      37              // AssemblyRefOS table
#define MDT_FILE       38              // File table
#define MDT_EXPORT     39              // ExportedType table
#define MDT_RESOURCE   40              // ManifestResource table
#define MDT_NESTED     41              // NestedClass table
#define MDT_GENPARM    42              // GenericParam table
#define MDT_METHSPEC   43              // MethodSpec table
#define MDT_CONSTR     44              // GenericParamConstraint table
#define MDT_UNUSED     63              // Used only in midx[]

#define MDTCOUNT       64              // Number of .NET MetaData tables

typedef struct t_secthdr               // Extract from IMAGE_SECTION_HEADER
{
    wchar_t        sectname[12];         // Null-terminated section name
    ulong          base;                 // Address of section in memory
    ulong          size;                 // Size of section loaded into memory
    ulong          type;                 // Set of SHT_xxx
    ulong          fileoffset;           // Offset of section in file
    ulong          rawsize;              // Size of section in file
    ulong          characteristics;      // Set of IMAGE_SCN_xxx
} t_secthdr;

typedef struct t_premod                // Preliminary module descriptor
{
    ulong          base;                 // Base address of the module
    ulong          size;                 // Size of module or 1
    ulong          type;                 // Service information, TY_xxx+MOD_xxx
    ulong          entry;                // Address of <ModuleEntryPoint> or 0
    wchar_t        path[MAXPATH];        // Full name of the module
} t_premod;

typedef struct t_netstream             // Location of default .NET stream
{
    ulong          base;                 // Base address in memory
    ulong          size;                 // Stream size, bytes
} t_netstream;

typedef struct t_metadata              // Descriptor of .NET MetaData table
{
    ulong          base;                 // Location in memory or NULL if absent
    ulong          rowcount;             // Number of rows or 0 if absent
    ulong          rowsize;              // Size of single row, bytes, or 0
    ushort         nameoffs;             // Offset of name field
    ushort         namesize;             // Size of name or 0 if absent
} t_metadata;

typedef struct t_module                // Descriptor of executable module
{
    ulong          base;                 // Base address of module
    ulong          size;                 // Size of memory occupied by module
    ulong          type;                 // Service information, TY_xxx+MOD_xxx
    wchar_t        modname[SHORTNAME];   // Short name of the module
    wchar_t        path[MAXPATH];        // Full name of the module
    wchar_t        version[TEXTLEN];     // Version of executable file
    ulong          fixupbase;            // Base of image in executable file
    ulong          codebase;             // Base address of module code block
    ulong          codesize;             // Size of module code block
    ulong          entry;                // Address of <ModuleEntryPoint> or 0
    ulong          sfxentry;             // Address of SFX-packed entry or 0
    ulong          winmain;              // Address of WinMain or 0
    ulong          database;             // Base address of module data block
    ulong          edatabase;            // Base address of export data table
    ulong          edatasize;            // Size of export data table
    ulong          idatatable;           // Base address of import data table
    ulong          iatbase;              // Base of Import Address Table
    ulong          iatsize;              // Size of IAT
    ulong          relocbase;            // Base address of relocation table
    ulong          relocsize;            // Size of relocation table
    ulong          resbase;              // Base address of resources
    ulong          ressize;              // Size of resources
    ulong          tlsbase;              // Base address of TLS directory table
    ulong          tlssize;              // Size of TLS directory table
    ulong          tlscallback;          // Address of first TLS callback or 0
    ulong          netentry;             // .NET entry (MOD_NETAPP only)
    ulong          clibase;              // .NET CLI header base (MOD_NETAPP)
    ulong          clisize;              // .NET CLI header base (MOD_NETAPP)
    t_netstream    netstr[NETSTREAM];    // Locations of default .NET streams
    t_metadata     metadata[MDTCOUNT];   // Descriptors of .NET MetaData tables
    ulong          sfxbase;              // Base of memory block with SFX
    ulong          sfxsize;              // Size of memory block with SFX
    ulong          rawhdrsize;           // Size of PE header in file
    ulong          memhdrsize;           // Size of PE header in memory
    int            nsect;                // Number of sections in the module
    t_secthdr      *sect;                // Extract from section headers
    int            nfixup;               // Number of 32-bit fixups
    ulong          *fixup;               // Array of 32-bit fixups
    t_jmpdata      jumps;                // Jumps and calls from this module
    t_nested       loopnest;             // Loop brackets
    t_nested       argnest;              // Call argument brackets
    t_simple       predict;              // Predicted ESP, EBP & results (sd_pred)
    t_sorted       strings;              // Resource strings (t_string)
    int            saveudd;              // UDD-relevant data is changed
    int            ncallmod;             // No. of called modules (max. NCALLMOD)
    wchar_t        callmod[NCALLMOD][SHORTNAME]; // List of called modules
} t_module;

// Keep t_aqueue identical with the header of t_module!
typedef struct t_aqueue                // Descriptor of module to be analysed
{
    ulong          base;                 // Base address of module
    ulong          size;                 // Size of memory occupied by module
    ulong          type;                 // Service information, TY_xxx+MOD_xxx
} t_aqueue;

stdapi (t_module *) Findmodule(ulong addr);
stdapi (t_module *) Findmodulebyname(wchar_t *shortname);
stdapi (t_module *) Findmainmodule(void);
stdapi (int)     Issystem(ulong addr);
stdapi (ulong *) Findfixup(t_module *pmod,ulong addr);
stdapi (ulong)   Findfileoffset(t_module *pmod,ulong addr);
stdapi (int)     Decoderange(wchar_t *s,ulong addr,ulong size);
stdapi (int)     Getexeversion(wchar_t *path,wchar_t *version);
stdapi (int)     Getexportfrommemory(ulong addr,wchar_t *s);


////////////////////////////////////////////////////////////////////////////////
////////////////////////// LIST OF DEBUGGEE'S WINDOWS //////////////////////////

typedef struct t_window                // Description of window
{
    ulong          hwnd;                 // Window's handle
    ulong          dummy;                // Must be 1
    ulong          type;                 // Type of window, TY_xxx+WN_xxx
    ulong          parenthw;             // Handle of parent or 0
    ulong          winproc;              // Address of WinProc or 0
    ulong          threadid;             // ID of the owning thread
    ulong          exstyle;              // Extended style
    ulong          style;                // Style
    ulong          id;                   // Identifier
    ulong          classproc;            // Address of default (class) WinProc
    RECT           windowrect;           // Window position, screen coordinates
    RECT           clientrect;           // Client position, screen coordinates
    int            child;                // Index of next child
    int            sibling;              // Index of next sibling
    int            byparent;             // Index when sorted by parent
    int            level;                // Level in genealogy (0: topmost)
    wchar_t        title[TEXTLEN];       // Window's title or text
    wchar_t        classname[TEXTLEN];   // Class name
    wchar_t        tree[MAXNEST];        // Tree display
} t_window;


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// NAMELIST WINDOWS ///////////////////////////////

// Types of action in WM_USER_NAMES broadcasts (parameter wp).
#define NA_FIND        0               // Check if namelist is already open
#define NA_UPDATE      1               // Update namelist
#define NA_CLOSE       2               // Close namelist
#define NA_CLOSEALL    3               // Close all namelists

typedef struct t_namecast              // Structure passed on broadcast
{
    ulong          base;                 // Module base, 0 - list of all names
    t_table        *table;               // Filled when broadcast stops
} t_namecast;

typedef struct t_namelist              // Element of namelist sorted data
{
    ulong          addr;                 // Base address of the entry
    ulong          size;                 // Size of the entry, always 1
    ulong          type;                 // Type & addr extension, TY_xxx+NL_xxx
} t_namelist;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// RESOURCES ///////////////////////////////////

typedef struct t_string                // Descriptor of resource string
{
    ulong          id;                   // Identifier associated with the string
    ulong          dummy;                // Always 1
    ulong          addr;                 // Address of string in memory
    ulong          count;                // String size, UNICODE characters!
    int            language;             // Language, one of LANG_xxx
} t_string;

stdapi (int)     Getmodulestring(t_module *pm,ulong id,wchar_t *s);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// UDD FILES ///////////////////////////////////

#define SAVEMAGIC      0xFEDCBA98      // Indicator of savearea validity

// Attention, for the sake of the compatibility between the different OllyDbg
// versions, never, ever change existing elements, only add new!
typedef struct t_savearea
{
    ulong          magic;                // Validity marker, must be SAVEMAGIC
    wchar_t        dumpstr[SHORTNAME];   // Last structure decoding in dump
} t_savearea;


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// THREADS AND REGISTERS /////////////////////////////

#define NREG           8               // Number of registers (of any type)
#define NSEG           6               // Number of valid segment registers
#define NHARD          4               // Number of hardware breakpoints

// Event ignoring list.
#define IGNO_INT3      0x00000001      // Ignore INT3 breakpoint
#define IGNO_ACCESS    0x00000002      // Ignore memory access violation
#define IGNO_HW        0x00000004      // Ignore hardware breakpoint

// Register displaying mode.
#define RDM_MODE       0x0000000F      // Mask to extract display mode
#define   RDM_FPU      0x00000000      // Decode FPU registers as floats
#define   RDM_MMX      0x00000001      // Decode FPU registers as MMX
#define   RDM_3DN      0x00000002      // Decode FPU registers as 3DNow!
#define   RDM_DBG      0x00000003      // Decode debug registers instead of FPU
#define RDM_SSEMODE    0x000000F0      // Mask to extract SSE decoding mode
#define   RDM_SSEI32   0x00000000      // Decode SSE as 4x32-bit hex numbers
#define   RDM_SSEF32   0x00000010      // Decode SSE as 4x32-bit floats
#define   RDM_SSEF64   0x00000020      // Decode SSE as 2x64-bit floats

// Status of registers.
#define RV_MODIFIED    0x00000001      // Update CONTEXT before run
#define RV_USERMOD     0x00000002      // Registers modified by user
#define RV_SSEVALID    0x00000004      // Whether SSE registers are valid
#define RV_SSEMOD      0x00000008      // Update SSE registers before run
#define RV_ERRVALID    0x00000010      // Whether last thread error is valid
#define RV_ERRMOD      0x00000020      // Update last thread error before run
#define RV_MEMVALID    0x00000040      // Whether memory fields are valid
#define RV_DBGMOD      0x00000080      // Update debugging registers before run

// CPU flags.
#define FLAG_C         0x00000001      // Carry flag
#define FLAG_P         0x00000004      // Parity flag
#define FLAG_A         0x00000010      // Auxiliary carry flag
#define FLAG_Z         0x00000040      // Zero flag
#define FLAG_S         0x00000080      // Sign flag
#define FLAG_T         0x00000100      // Single-step trap flag
#define FLAG_D         0x00000400      // Direction flag
#define FLAG_O         0x00000800      // Overflow flag

// Attention, number of memory fields is limited by the run trace!
#define NMEMFIELD      2               // Number of memory fields in t_reg

typedef struct t_memfield              // Descriptor of memory field
{
    ulong          addr;                 // Address of data in memory
    ulong          size;                 // Data size (0 - no data)
    uchar          data[16];             // Data
} t_memfield;

// Thread registers.
typedef struct t_reg                   // Excerpt from context
{
    ulong          status;               // Status of registers, set of RV_xxx
    ulong          threadid;             // ID of thread that owns registers
    ulong          ip;                   // Instruction pointer (EIP)
    ulong          r[NREG];              // EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
    ulong          flags;                // Flags
    ulong          s[NSEG];              // Segment registers ES,CS,SS,DS,FS,GS
    ulong          base[NSEG];           // Segment bases
    ulong          limit[NSEG];          // Segment limits
    uchar          big[NSEG];            // Default size (0-16, 1-32 bit)
    uchar          dummy[2];             // Reserved, used for data alignment
    int            top;                  // Index of top-of-stack
    long double    f[NREG];              // Float registers, f[top] - top of stack
    uchar          tag[NREG];            // Float tags (0x3 - empty register)
    ulong          fst;                  // FPU status word
    ulong          fcw;                  // FPU control word
    ulong          ferrseg;              // Selector of last detected FPU error
    ulong          feroffs;              // Offset of last detected FPU error
    ulong          dr[NREG];             // Debug registers
    ulong          lasterror;            // Last thread error or 0xFFFFFFFF
    uchar          ssereg[NREG][16];     // SSE registers
    ulong          mxcsr;                // SSE control and status register
    t_memfield     mem[NMEMFIELD];       // Known memory fields from run trace
} t_reg;

typedef struct t_thread                // Information about active threads
{
    ulong          threadid;             // Thread identifier
    ulong          dummy;                // Always 1
    ulong          type;                 // Service information, TY_xxx+THR_xxx
    int            ordinal;              // Thread's ordinal number (1-based)
    wchar_t        name[SHORTNAME];      // Short name of the thread
    HANDLE         thread;               // Thread handle, for OllyDbg only!
    ulong          tib;                  // Thread Information Block
    ulong          entry;                // Thread entry point
    CONTEXT        context;              // Actual context of the thread
    t_reg          reg;                  // Actual contents of registers
    int            regvalid;             // Whether reg and context are valid
    t_reg          oldreg;               // Previous contents of registers
    int            oldregvalid;          // Whether oldreg is valid
    int            suspendrun;           // Suspended for run (0 or 1)
    int            suspendcount;         // Temporarily suspended (0..inf)
    int            suspenduser;          // Suspended by user (0 or 1)
    int            trapset;              // Single-step trap set by OllyDbg
    int            trapincontext;        // Trap is catched in exception context
    ulong          rtprotocoladdr;       // Address of destination to protocol
    int            ignoreonce;           // Ignore list, IGNO_xxx
    int            drvalid;              // Contents of dr is valid
    ulong          dr[NREG];             // Expected state of DR0..3,7
    int            hwmasked;             // Temporarily masked hardware breaks
    int            hwreported;           // Reported breakpoint expressions
    // Thread-related information gathered by Updatethreaddata().
    HWND           hw;                   // One of windows owned by thread
    ulong          usertime;             // Time in user mode, 100u units or -1
    ulong          systime;              // Time in system mode, 100u units or -1
    // Thread-related information gathered by Listmemory().
    ulong          stacktop;             // Top of thread's stack
    ulong          stackbottom;          // Bottom of thread's stack
} t_thread;

stdapi (t_thread *) Findthread(ulong threadid);
stdapi (t_thread *) Findthreadbyordinal(int ordinal);
stdapi (t_reg *) Threadregisters(ulong threadid);
stdapi (int)     Decodethreadname(wchar_t *s,ulong threadid,int mode);
stdapi (void)    Registermodifiedbyuser(t_thread *pthr);


////////////////////////////////////////////////////////////////////////////////
////////////////////////// ASSEMBLER AND DISASSEMBLER //////////////////////////

#define MAXCMDSIZE     16              // Maximal length of valid 80x86 command
#define MAXSEQSIZE     256             // Maximal length of command sequence
#define INT3           0xCC            // Code of 1-byte INT3 breakpoint
#define NOP            0x90            // Code of 1-byte NOP command
#define NOPERAND       4               // Maximal allowed number of operands
#define NEGLIMIT       (-16384)        // Limit to decode offsets as negative
#define DECLIMIT       65536           // Limit to decode integers as decimal

// Registers.
#define REG_UNDEF      (-1)            // Codes of general purpose registers
#define REG_EAX        0
#define REG_ECX        1
#define REG_EDX        2
#define REG_EBX        3
#define REG_ESP        4
#define REG_EBP        5
#define REG_ESI        6
#define REG_EDI        7

#define REG_BYTE       0x80            // Flag used in switch analysis

#define REG_AL         0               // Symbolic indices of 8-bit registers
#define REG_CL         1
#define REG_DL         2
#define REG_BL         3
#define REG_AH         4
#define REG_CH         5
#define REG_DH         6
#define REG_BH         7

#define SEG_UNDEF      (-1)            // Codes of segment/selector registers
#define SEG_ES         0
#define SEG_CS         1
#define SEG_SS         2
#define SEG_DS         3
#define SEG_FS         4
#define SEG_GS         5

// Pseudoregisters, used in search for assembler commands.
#define REG_R8         NREG            // 8-bit pseudoregister R8
#define REG_R16        NREG            // 16-bit pseudoregister R16
#define REG_R32        NREG            // 32-bit pseudoregister R32
#define REG_ANY        NREG            // Pseudoregister FPUREG, MMXREG etc.
#define SEG_ANY        NREG            // Segment pseudoregister SEG
#define REG_RA         (NREG+1)        // 32-bit semi-defined pseudoregister RA
#define REG_RB         (NREG+2)        // 32-bit semi-defined pseudoregister RB

#define NPSEUDO        (NREG+3)        // Total count of resisters & pseudoregs

#define IS_REAL(r)     ((r)<REG_R32)   // Checks for real register
#define IS_PSEUDO(r)   ((r)>=REG_R32)  // Checks for pseudoregister (undefined)
#define IS_SEMI(r)     ((r)>=REG_RA)   // Checks for semi-defined register

#define D_NONE         0x00000000      // No special features
// General type of command, only one is allowed.
#define D_CMDTYPE      0x0000001F      // Mask to extract type of command
#define   D_CMD        0x00000000      // Ordinary (none of listed below)
#define   D_MOV        0x00000001      // Move to or from integer register
#define   D_MOVC       0x00000002      // Conditional move to integer register
#define   D_SETC       0x00000003      // Conditional set integer register
#define   D_TEST       0x00000004      // Used to test data (CMP, TEST, AND...)
#define   D_STRING     0x00000005      // String command with REPxxx prefix
#define   D_JMP        0x00000006      // Unconditional near jump
#define   D_JMPFAR     0x00000007      // Unconditional far jump
#define   D_JMC        0x00000008      // Conditional jump on flags
#define   D_JMCX       0x00000009      // Conditional jump on (E)CX (and flags)
#define   D_PUSH       0x0000000A      // PUSH exactly 1 (d)word of data
#define   D_POP        0x0000000B      // POP exactly 1 (d)word of data
#define   D_CALL       0x0000000C      // Plain near call
#define   D_CALLFAR    0x0000000D      // Far call
#define   D_INT        0x0000000E      // Interrupt
#define   D_RET        0x0000000F      // Plain near return from call
#define   D_RETFAR     0x00000010      // Far return or IRET
#define   D_FPU        0x00000011      // FPU command
#define   D_MMX        0x00000012      // MMX instruction, incl. SSE extensions
#define   D_3DNOW      0x00000013      // 3DNow! instruction
#define   D_SSE        0x00000014      // SSE, SSE2, SSE3 etc. instruction
#define   D_IO         0x00000015      // Accesses I/O ports
#define   D_SYS        0x00000016      // Legal but useful in system code only
#define   D_PRIVILEGED 0x00000017      // Privileged (non-Ring3) command
#define   D_DATA       0x0000001C      // Data recognized by Analyser
#define   D_PSEUDO     0x0000001D      // Pseudocommand, for search models only
#define   D_PREFIX     0x0000001E      // Standalone prefix
#define   D_BAD        0x0000001F      // Bad or unrecognized command
// Additional parts of the command.
#define D_SIZE01       0x00000020      // Bit 0x01 in last cmd is data size
#define D_POSTBYTE     0x00000040      // Command continues in postbyte
// For string commands, either long or short form can be selected.
#define D_LONGFORM     0x00000080      // Long form of string command
// Decoding of some commands depends on data or address size.
#define D_SIZEMASK     0x00000F00      // Mask for data/address size dependence
#define   D_DATA16     0x00000100      // Requires 16-bit data size
#define   D_DATA32     0x00000200      // Requires 32-bit data size
#define   D_ADDR16     0x00000400      // Requires 16-bit address size
#define   D_ADDR32     0x00000800      // Requires 32-bit address size
// Prefixes that command may, must or must not possess.
#define D_MUSTMASK     0x0000F000      // Mask for fixed set of prefixes
#define   D_NOMUST     0x00000000      // No obligatory prefixes (default)
#define   D_MUST66     0x00001000      // (SSE) Requires 66, no F2 or F3
#define   D_MUSTF2     0x00002000      // (SSE) Requires F2, no 66 or F3
#define   D_MUSTF3     0x00003000      // (SSE) Requires F3, no 66 or F2
#define   D_MUSTNONE   0x00004000      // (MMX,SSE) Requires no 66, F2 or F3
#define   D_NEEDF2     0x00005000      // (SSE) Requires F2, no F3
#define   D_NEEDF3     0x00006000      // (SSE) Requires F3, no F2
#define   D_NOREP      0x00007000      // Must not include F2 or F3
#define   D_MUSTREP    0x00008000      // Must include F3 (REP)
#define   D_MUSTREPE   0x00009000      // Must include F3 (REPE)
#define   D_MUSTREPNE  0x0000A000      // Must include F2 (REPNE)
#define D_LOCKABLE     0x00010000      // Allows for F0 (LOCK, memory only)
#define D_BHINT        0x00020000      // Allows for branch hints (2E, 3E)
// Decoding of some commands with ModRM-SIB depends whether register or memory.
#define D_MEMORY       0x00040000      // Mod field must indicate memory
#define D_REGISTER     0x00080000      // Mod field must indicate register
// Side effects caused by command.
#define D_FLAGMASK     0x00700000      // Mask to extract modified flags
#define   D_NOFLAGS    0x00000000      // Flags S,Z,P,O,C remain unchanged
#define   D_ALLFLAGS   0x00100000      // Modifies flags S,Z,P,O,C
#define   D_FLAGZ      0x00200000      // Modifies flag Z only
#define   D_FLAGC      0x00300000      // Modifies flag C only
#define   D_FLAGSCO    0x00400000      // Modifies flag C and O only
#define   D_FLAGD      0x00500000      // Modifies flag D only
#define   D_FLAGSZPC   0x00600000      // Modifies flags Z, P and C only (FPU)
#define   D_NOCFLAG    0x00700000      // S,Z,P,O modified, C unaffected
#define D_FPUMASK      0x01800000      // Mask for effects on FPU stack
#define   D_FPUSAME    0x00000000      // Doesn't rotate FPU stack (default)
#define   D_FPUPOP     0x00800000      // Pops FPU stack
#define   D_FPUPOP2    0x01000000      // Pops FPU stack twice
#define   D_FPUPUSH    0x01800000      // Pushes FPU stack
#define D_CHGESP       0x02000000      // Command indirectly modifies ESP
// Command features.
#define D_HLADIR       0x04000000      // Nonstandard order of operands in HLA
#define D_WILDCARD     0x08000000      // Mnemonics contains W/D wildcard ('*')
#define D_COND         0x10000000      // Conditional (action depends on flags)
#define D_USESCARRY    0x20000000      // Uses Carry flag
#define D_USEMASK      0xC0000000      // Mask to detect unusual commands
#define   D_RARE       0x40000000      // Rare or obsolete in Win32 apps
#define   D_SUSPICIOUS 0x80000000      // Suspicious command
#define   D_UNDOC      0xC0000000      // Undocumented command

// Extension of D_xxx.
#define DX_ZEROMASK    0x00000003      // How to decode FLAGS.Z flag
#define   DX_JE        0x00000001      // JE, JNE instead of JZ, JNZ
#define   DX_JZ        0x00000002      // JZ, JNZ instead of JE, JNE
#define DX_CARRYMASK   0x0000000C      // How to decode FLAGS.C flag
#define   DX_JB        0x00000004      // JAE, JB instead of JC, JNC
#define   DX_JC        0x00000008      // JC, JNC instead of JAE, JB
#define DX_WONKYTRAP   0x00000100      // Don't single-step this command

// Type of operand, only one is allowed.
#define B_ARGMASK      0x000000FF      // Mask to extract type of argument
#define   B_NONE       0x00000000      // Operand absent
#define   B_AL         0x00000001      // Register AL
#define   B_AH         0x00000002      // Register AH
#define   B_AX         0x00000003      // Register AX
#define   B_CL         0x00000004      // Register CL
#define   B_CX         0x00000005      // Register CX
#define   B_DX         0x00000006      // Register DX
#define   B_DXPORT     0x00000007      // Register DX as I/O port address
#define   B_EAX        0x00000008      // Register EAX
#define   B_EBX        0x00000009      // Register EBX
#define   B_ECX        0x0000000A      // Register ECX
#define   B_EDX        0x0000000B      // Register EDX
#define   B_ACC        0x0000000C      // Accumulator (AL/AX/EAX)
#define   B_STRCNT     0x0000000D      // Register CX or ECX as REPxx counter
#define   B_DXEDX      0x0000000E      // Register DX or EDX in DIV/MUL
#define   B_BPEBP      0x0000000F      // Register BP or EBP in ENTER/LEAVE
#define   B_REG        0x00000010      // 8/16/32-bit register in Reg
#define   B_REG16      0x00000011      // 16-bit register in Reg
#define   B_REG32      0x00000012      // 32-bit register in Reg
#define   B_REGCMD     0x00000013      // 16/32-bit register in last cmd byte
#define   B_REGCMD8    0x00000014      // 8-bit register in last cmd byte
#define   B_ANYREG     0x00000015      // Reg field is unused, any allowed
#define   B_INT        0x00000016      // 8/16/32-bit register/memory in ModRM
#define   B_INT8       0x00000017      // 8-bit register/memory in ModRM
#define   B_INT16      0x00000018      // 16-bit register/memory in ModRM
#define   B_INT32      0x00000019      // 32-bit register/memory in ModRM
#define   B_INT1632    0x0000001A      // 16/32-bit register/memory in ModRM
#define   B_INT64      0x0000001B      // 64-bit integer in ModRM, memory only
#define   B_INT128     0x0000001C      // 128-bit integer in ModRM, memory only
#define   B_IMMINT     0x0000001D      // 8/16/32-bit int at immediate addr
#define   B_INTPAIR    0x0000001E      // Two signed 16/32 in ModRM, memory only
#define   B_SEGOFFS    0x0000001F      // 16:16/16:32 absolute address in memory
#define   B_STRDEST    0x00000020      // 8/16/32-bit string dest, [ES:(E)DI]
#define   B_STRDEST8   0x00000021      // 8-bit string destination, [ES:(E)DI]
#define   B_STRSRC     0x00000022      // 8/16/32-bit string source, [(E)SI]
#define   B_STRSRC8    0x00000023      // 8-bit string source, [(E)SI]
#define   B_XLATMEM    0x00000024      // 8-bit memory in XLAT, [(E)BX+AL]
#define   B_EAXMEM     0x00000025      // Reference to memory addressed by [EAX]
#define   B_LONGDATA   0x00000026      // Long data in ModRM, mem only
#define   B_ANYMEM     0x00000027      // Reference to memory, data unimportant
#define   B_STKTOP     0x00000028      // 16/32-bit int top of stack
#define   B_STKTOPFAR  0x00000029      // Top of stack (16:16/16:32 far addr)
#define   B_STKTOPEFL  0x0000002A      // 16/32-bit flags on top of stack
#define   B_STKTOPA    0x0000002B      // 16/32-bit top of stack all registers
#define   B_PUSH       0x0000002C      // 16/32-bit int push to stack
#define   B_PUSHRET    0x0000002D      // 16/32-bit push of return address
#define   B_PUSHRETF   0x0000002E      // 16:16/16:32-bit push of far retaddr
#define   B_PUSHA      0x0000002F      // 16/32-bit push all registers
#define   B_EBPMEM     0x00000030      // 16/32-bit int at [EBP]
#define   B_SEG        0x00000031      // Segment register in Reg
#define   B_SEGNOCS    0x00000032      // Segment register in Reg, but not CS
#define   B_SEGCS      0x00000033      // Segment register CS
#define   B_SEGDS      0x00000034      // Segment register DS
#define   B_SEGES      0x00000035      // Segment register ES
#define   B_SEGFS      0x00000036      // Segment register FS
#define   B_SEGGS      0x00000037      // Segment register GS
#define   B_SEGSS      0x00000038      // Segment register SS
#define   B_ST         0x00000039      // 80-bit FPU register in last cmd byte
#define   B_ST0        0x0000003A      // 80-bit FPU register ST0
#define   B_ST1        0x0000003B      // 80-bit FPU register ST1
#define   B_FLOAT32    0x0000003C      // 32-bit float in ModRM, memory only
#define   B_FLOAT64    0x0000003D      // 64-bit float in ModRM, memory only
#define   B_FLOAT80    0x0000003E      // 80-bit float in ModRM, memory only
#define   B_BCD        0x0000003F      // 80-bit BCD in ModRM, memory only
#define   B_MREG8x8    0x00000040      // MMX register as 8 8-bit integers
#define   B_MMX8x8     0x00000041      // MMX reg/memory as 8 8-bit integers
#define   B_MMX8x8DI   0x00000042      // MMX 8 8-bit integers at [DS:(E)DI]
#define   B_MREG16x4   0x00000043      // MMX register as 4 16-bit integers
#define   B_MMX16x4    0x00000044      // MMX reg/memory as 4 16-bit integers
#define   B_MREG32x2   0x00000045      // MMX register as 2 32-bit integers
#define   B_MMX32x2    0x00000046      // MMX reg/memory as 2 32-bit integers
#define   B_MREG64     0x00000047      // MMX register as 1 64-bit integer
#define   B_MMX64      0x00000048      // MMX reg/memory as 1 64-bit integer
#define   B_3DREG      0x00000049      // 3DNow! register as 2 32-bit floats
#define   B_3DNOW      0x0000004A      // 3DNow! reg/memory as 2 32-bit floats
#define   B_XMM0I32x4  0x0000004B      // XMM0 as 4 32-bit integers
#define   B_XMM0I64x2  0x0000004C      // XMM0 as 2 64-bit integers
#define   B_XMM0I8x16  0x0000004D      // XMM0 as 16 8-bit integers
#define   B_SREGF32x4  0x0000004E      // SSE register as 4 32-bit floats
#define   B_SREGF32L   0x0000004F      // Low 32-bit float in SSE register
#define   B_SREGF32x2L 0x00000050      // Low 2 32-bit floats in SSE register
#define   B_SSEF32x4   0x00000051      // SSE reg/memory as 4 32-bit floats
#define   B_SSEF32L    0x00000052      // Low 32-bit float in SSE reg/memory
#define   B_SSEF32x2L  0x00000053      // Low 2 32-bit floats in SSE reg/memory
#define   B_SREGF64x2  0x00000054      // SSE register as 2 64-bit floats
#define   B_SREGF64L   0x00000055      // Low 64-bit float in SSE register
#define   B_SSEF64x2   0x00000056      // SSE reg/memory as 2 64-bit floats
#define   B_SSEF64L    0x00000057      // Low 64-bit float in SSE reg/memory
#define   B_SREGI8x16  0x00000058      // SSE register as 16 8-bit sigints
#define   B_SSEI8x16   0x00000059      // SSE reg/memory as 16 8-bit sigints
#define   B_SSEI8x16DI 0x0000005A      // SSE 16 8-bit sigints at [DS:(E)DI]
#define   B_SSEI8x8L   0x0000005B      // Low 8 8-bit ints in SSE reg/memory
#define   B_SSEI8x4L   0x0000005C      // Low 4 8-bit ints in SSE reg/memory
#define   B_SSEI8x2L   0x0000005D      // Low 2 8-bit ints in SSE reg/memory
#define   B_SREGI16x8  0x0000005E      // SSE register as 8 16-bit sigints
#define   B_SSEI16x8   0x0000005F      // SSE reg/memory as 8 16-bit sigints
#define   B_SSEI16x4L  0x00000060      // Low 4 16-bit ints in SSE reg/memory
#define   B_SSEI16x2L  0x00000061      // Low 2 16-bit ints in SSE reg/memory
#define   B_SREGI32x4  0x00000062      // SSE register as 4 32-bit sigints
#define   B_SREGI32L   0x00000063      // Low 32-bit sigint in SSE register
#define   B_SREGI32x2L 0x00000064      // Low 2 32-bit sigints in SSE register
#define   B_SSEI32x4   0x00000065      // SSE reg/memory as 4 32-bit sigints
#define   B_SSEI32x2L  0x00000066      // Low 2 32-bit sigints in SSE reg/memory
#define   B_SREGI64x2  0x00000067      // SSE register as 2 64-bit sigints
#define   B_SSEI64x2   0x00000068      // SSE reg/memory as 2 64-bit sigints
#define   B_SREGI64L   0x00000069      // Low 64-bit sigint in SSE register
#define   B_EFL        0x0000006A      // Flags register EFL
#define   B_FLAGS8     0x0000006B      // Flags (low byte)
#define   B_OFFSET     0x0000006C      // 16/32 const offset from next command
#define   B_BYTEOFFS   0x0000006D      // 8-bit sxt const offset from next cmd
#define   B_FARCONST   0x0000006E      // 16:16/16:32 absolute address constant
#define   B_DESCR      0x0000006F      // 16:32 descriptor in ModRM
#define   B_1          0x00000070      // Immediate constant 1
#define   B_CONST8     0x00000071      // Immediate 8-bit constant
#define   B_CONST8_2   0x00000072      // Immediate 8-bit const, second in cmd
#define   B_CONST16    0x00000073      // Immediate 16-bit constant
#define   B_CONST      0x00000074      // Immediate 8/16/32-bit constant
#define   B_CONSTL     0x00000075      // Immediate 16/32-bit constant
#define   B_SXTCONST   0x00000076      // Immediate 8-bit sign-extended to size
#define   B_CR         0x00000077      // Control register in Reg
#define   B_CR0        0x00000078      // Control register CR0
#define   B_DR         0x00000079      // Debug register in Reg
// Type modifiers, used for interpretation of contents, only one is allowed.
#define B_MODMASK      0x000F0000      // Mask to extract type modifier
#define   B_NONSPEC    0x00000000      // Non-specific operand
#define   B_UNSIGNED   0x00010000      // Decode as unsigned decimal
#define   B_SIGNED     0x00020000      // Decode as signed decimal
#define   B_BINARY     0x00030000      // Decode as binary (full hex) data
#define   B_BITCNT     0x00040000      // Bit count
#define   B_SHIFTCNT   0x00050000      // Shift count
#define   B_COUNT      0x00060000      // General-purpose count
#define   B_NOADDR     0x00070000      // Not an address
#define   B_JMPCALL    0x00080000      // Near jump/call/return destination
#define   B_JMPCALLFAR 0x00090000      // Far jump/call/return destination
#define   B_STACKINC   0x000A0000      // Unsigned stack increment/decrement
#define   B_PORT       0x000B0000      // I/O port
// Validity markers.
#define B_MEMORY       0x00100000      // Memory only, reg version different
#define B_REGISTER     0x00200000      // Register only, mem version different
#define B_MEMONLY      0x00400000      // Warn if operand in register
#define B_REGONLY      0x00800000      // Warn if operand in memory
#define B_32BITONLY    0x01000000      // Warn if 16-bit operand
#define B_NOESP        0x02000000      // ESP is not allowed
// Miscellaneous options.
#define B_SHOWSIZE     0x08000000      // Always show argument size in disasm
#define B_CHG          0x10000000      // Changed, old contents is not used
#define B_UPD          0x20000000      // Modified using old contents
#define B_PSEUDO       0x40000000      // Pseoudooperand, not in assembler cmd
#define B_NOSEG        0x80000000      // Don't add offset of selector

// Analysis data. Note that DEC_PBODY==DEC_PROC|DEC_PEND; this allows for
// automatical merging of overlapping procedures. Also note that DEC_NET is
// followed, if necessary, by a sequence of DEC_NEXTDATA and not DEC_NEXTCODE!
#define DEC_TYPEMASK   0x1F            // Type of analyzed byte
#define   DEC_UNKNOWN  0x00            // Not analyzed, treat as command
#define   DEC_NEXTCODE 0x01            // Next byte of command
#define   DEC_NEXTDATA 0x02            // Next byte of data
#define   DEC_FILLDATA 0x03            // Not recognized, treat as byte data
#define   DEC_INT      0x04            // First byte of integer
#define   DEC_SWITCH   0x05            // First byte of switch item or count
#define   DEC_DATA     0x06            // First byte of integer data
#define   DEC_DB       0x07            // First byte of byte string
#define   DEC_DUMP     0x08            // First byte of byte string with dump
#define   DEC_ASCII    0x09            // First byte of ASCII string
#define   DEC_ASCCNT   0x0A            // Next chunk of ASCII string
#define   DEC_UNICODE  0x0B            // First byte of UNICODE string
#define   DEC_UNICNT   0x0C            // Next chunk of UNICODE string
#define   DEC_FLOAT    0x0D            // First byte of floating number
#define   DEC_GUID     0x10            // First byte of GUID
#define   DEC_NETCMD   0x18            // First byte of .NET (CIL) command
#define   DEC_JMPNET   0x19            // First byte of .NET at jump destination
#define   DEC_CALLNET  0x1A            // First byte of .NET at call destination
#define   DEC_COMMAND  0x1C            // First byte of ordinary command
#define   DEC_JMPDEST  0x1D            // First byte of cmd at jump destination
#define   DEC_CALLDEST 0x1E            // First byte of cmd at call destination
#define   DEC_FILLING  0x1F            // Command used to fill gaps
#define DEC_PROCMASK   0x60            // Procedure analysis
#define   DEC_NOPROC   0x00            // Outside the procedure
#define   DEC_PROC     0x20            // Start of procedure
#define   DEC_PEND     0x40            // End of procedure
#define   DEC_PBODY    0x60            // Body of procedure
#define DEC_TRACED     0x80            // Hit when traced

// Full type of predicted data.
#define PST_GENMASK    0xFFFFFC00      // Mask for ESP generation
#define   PST_GENINC   0x00000400      // Increment of ESP generation
#define PST_UNCERT     0x00000200      // Uncertain, probably modified by call
#define PST_NONSTACK   0x00000100      // Not a stack, internal use only
#define PST_REL        0x00000080      // Fixup/reladdr counter of constant
#define PST_BASE       0x0000007F      // Mask for basical description
#define   PST_SPEC     0x00000040      // Special contents, type in PST_GENMASK
#define   PST_VALID    0x00000020      // Contents valid
#define   PST_ADDR     0x00000010      // Contents is in memory
#define   PST_ORIG     0x00000008      // Based on reg contents at entry point
#define   PST_OMASK    0x00000007      // Mask to extract original register

// Types of special contents when PST_SPEC is set.
#define PSS_SPECMASK   PST_GENMASK     // Mask for type of special contents
#define   PSS_SEHPTR   0x00000400      // Pointer to SEH chain

#define NSTACK         12              // Number of predicted stack entries
#define NSTKMOD        24              // Max no. of predicted stack mod addr
#define NMEM           2               // Number of predicted memory locations

typedef struct t_modrm                 // ModRM decoding
{
    ulong          size;                 // Total size with SIB and disp, bytes
    struct t_modrm *psib;                // Pointer to SIB table or NULL
    ulong          dispsize;             // Size of displacement or 0 if none
    ulong          features;             // Operand features, set of OP_xxx
    int            reg;                  // Register index or REG_UNDEF
    int            defseg;               // Default selector (SEG_xxx)
    uchar          scale[NREG];          // Scales of registers in memory address
    ulong          aregs;                // List of registers used in address
    int            basereg;              // Register used as base or REG_UNDEF
    wchar_t        ardec[SHORTNAME];     // Register part of address, INTEL fmt
    wchar_t        aratt[SHORTNAME];     // Register part of address, AT&T fmt
} t_modrm;

typedef struct t_predict               // Prediction of execution
{
    ulong          addr;                 // Predicted EIP or NULL if uncertain
    ulong          one;                  // Must be 1
    ulong          type;                 // Type, TY_xxx/PR_xxx
    ushort         flagsmeaning;         // Set of DX_ZEROMASK|DX_CARRYMASK
    ulong          rstate[NREG];         // State of register, set of PST_xxx
    ulong          rconst[NREG];         // Constant related to register
    ulong          jmpstate;             // State of EIP after jump or return
    ulong          jmpconst;             // Constant related to jump or return
    ulong          espatpushbp;          // Offset of ESP at PUSH EBP
    int            nstack;               // Number of valid stack entries
    struct
    {
        long         soffset;              // Offset of data on stack (signed!)
        ulong        sstate;               // State of stack data, set of PST_xxx
        ulong        sconst;               // Constant related to stack data
    } stack[NSTACK];
    int            nstkmod;              // Number of valid stkmod addresses
    ulong          stkmod[NSTKMOD];      // Addresses of stack modifications
    int            nmem;                 // Number of valid memory entries
    struct
    {
        ulong        maddr;                // Address of doubleword variable
        ulong        mstate;               // State of memory, set of PST_xxx
        ulong        mconst;               // Constant related to memory data
    } mem[NMEM];
    ulong          resstate;             // State of result of command execution
    ulong          resconst;             // Constant related to result
} t_predict;

typedef struct t_callpredict           // Simplified prediction
{
    ulong          addr;                 // Predicted EIP or NULL if uncertain
    ulong          one;                  // Must be 1
    ulong          type;                 // Type of prediction, TY_xxx/PR_xxx
    ulong          eaxstate;             // State of EAX, set of PST_xxx
    ulong          eaxconst;             // Constant related to EAX
    int            nstkmod;              // Number of valid stkmod addresses
    ulong          stkmod[NSTKMOD];      // Addresses of stack modifications
    ulong          resstate;             // State of result of command execution
    ulong          resconst;             // Constant related to result
} t_callpredict;

// Location of operand, only one bit is allowed.
#define OP_SOMEREG     0x000000FF      // Mask for any kind of register
#define   OP_REGISTER  0x00000001      // Operand is a general-purpose register
#define   OP_SEGREG    0x00000002      // Operand is a segment register
#define   OP_FPUREG    0x00000004      // Operand is a FPU register
#define   OP_MMXREG    0x00000008      // Operand is a MMX register
#define   OP_3DNOWREG  0x00000010      // Operand is a 3DNow! register
#define   OP_SSEREG    0x00000020      // Operand is a SSE register
#define   OP_CREG      0x00000040      // Operand is a control register
#define   OP_DREG      0x00000080      // Operand is a debug register
#define OP_MEMORY      0x00000100      // Operand is in memory
#define OP_CONST       0x00000200      // Operand is an immediate constant
#define OP_PORT        0x00000400      // Operand is an I/O port
// Additional operand properties.
#define OP_INVALID     0x00001000      // Invalid operand, like reg in mem-only
#define OP_PSEUDO      0x00002000      // Pseudooperand (not in mnenonics)
#define OP_MOD         0x00004000      // Command may change/update operand
#define OP_MODREG      0x00008000      // Memory, but modifies reg (POP,MOVSD)
#define OP_REL         0x00010000      // Relative or fixuped const or address
#define OP_IMPORT      0x00020000      // Value imported from different module
#define OP_SELECTOR    0x00040000      // Includes immediate selector
// Additional properties of memory address.
#define OP_INDEXED     0x00080000      // Memory address contains registers
#define OP_OPCONST     0x00100000      // Memory address contains constant
#define OP_ADDR16      0x00200000      // 16-bit memory address
#define OP_ADDR32      0x00400000      // Explicit 32-bit memory address
// Value of operand.
#define OP_OFFSOK      0x00800000      // Offset to selector valid
#define OP_ADDROK      0x01000000      // Address valid
#define OP_VALUEOK     0x02000000      // Value (max. 16 bytes) valid
#define OP_PREDADDR    0x04000000      // Address predicted, not actual
#define OP_PREDVAL     0x08000000      // Value predicted, not actual
#define OP_RTLOGMEM    0x10000000      // Memory contents got from run trace
#define   OP_ACTVALID  0x20000000      // Actual value is valid
// Pseudooperands, used in assembler search models only.
#define OP_ANYMEM      0x40000000      // Any memory location
#define OP_ANY         0x80000000      // Any operand

typedef struct t_operand               // Description of disassembled operand
{
    // Description of operand.
    ulong          features;             // Operand features, set of OP_xxx
    ulong          arg;                  // Operand type, set of B_xxx
    int            optype;               // DEC_INT, DEC_FLOAT or DEC_UNKNOWN
    int            opsize;               // Total size of data, bytes
    int            granularity;          // Size of element (opsize exc. MMX/SSE)
    int            reg;                  // REG_xxx (also ESP in POP) or REG_UNDEF
    ulong          uses;                 // List of used regs (not in address!)
    ulong          modifies;             // List of modified regs (not in addr!)
    // Description of memory address.
    int            seg;                  // Selector (SEG_xxx)
    uchar          scale[NREG];          // Scales of registers in memory address
    ulong          aregs;                // List of registers used in address
    ulong          opconst;              // Constant or const part of address
    // Value of operand.
    ulong          offset;               // Offset to selector (usually addr)
    ulong          selector;             // Immediate selector in far jump/call
    ulong          addr;                 // Address of operand in memory
    union
    {
        ulong        u;                    // Value of operand (integer form)
        signed long  s;                    // Value of operand (signed form)
        uchar        value[16];
    };         // Value of operand (general form)
    uchar          actual[16];           // Actual memory (if OP_ACTVALID)
    // Textual decoding.
    wchar_t        text[TEXTLEN];        // Operand, decoded to text
    wchar_t        comment[TEXTLEN];     // Commented address and contents
} t_operand;

// Prefix list.
#define PF_SEGMASK     0x0000003F      // Mask for segment override prefixes
#define   PF_ES        0x00000001      // 0x26, ES segment override
#define   PF_CS        0x00000002      // 0x2E, CS segment override
#define   PF_SS        0x00000004      // 0x36, SS segment override
#define   PF_DS        0x00000008      // 0x3E, DS segment override
#define   PF_FS        0x00000010      // 0x64, FS segment override
#define   PF_GS        0x00000020      // 0x65, GS segment override
#define PF_DSIZE       0x00000040      // 0x66, data size override
#define PF_ASIZE       0x00000080      // 0x67, address size override
#define PF_LOCK        0x00000100      // 0xF0, bus lock
#define PF_REPMASK     0x00000600      // Mask for repeat prefixes
#define   PF_REPNE     0x00000200      // 0xF2, REPNE prefix
#define   PF_REP       0x00000400      // 0xF3, REP/REPE prefix
#define PF_BYTE        0x00000800      // Size bit in command, used in cmdexec
#define PF_MUSTMASK    D_MUSTMASK      // Necessary prefixes, used in t_asmmod
#define PF_66          PF_DSIZE        // Alternative names for SSE prefixes
#define PF_F2          PF_REPNE
#define PF_F3          PF_REP
#define PF_HINT        (PF_CS|PF_DS)   // Alternative names for branch hints
#define   PF_NOTTAKEN  PF_CS
#define   PF_TAKEN     PF_DS

// Disassembling errors.
#define DAE_NOERR      0x00000000      // No error
#define DAE_BADCMD     0x00000001      // Unrecognized command
#define DAE_CROSS      0x00000002      // Command crosses end of memory block
#define DAE_MEMORY     0x00000004      // Register where only memory allowed
#define DAE_REGISTER   0x00000008      // Memory where only register allowed
#define DAE_LOCK       0x00000010      // LOCK prefix is not allowed
#define DAE_BADSEG     0x00000020      // Invalid segment register
#define DAE_SAMEPREF   0x00000040      // Two prefixes from the same group
#define DAE_MANYPREF   0x00000080      // More than 4 prefixes
#define DAE_BADCR      0x00000100      // Invalid CR register
#define DAE_INTERN     0x00000200      // Internal error

// Disassembling warnings.
#define DAW_DATASIZE   0x00000001      // Superfluous data size prefix
#define DAW_ADDRSIZE   0x00000002      // Superfluous address size prefix
#define DAW_SEGPREFIX  0x00000004      // Superfluous segment override prefix
#define DAW_REPPREFIX  0x00000008      // Superfluous REPxx prefix
#define DAW_DEFSEG     0x00000010      // Segment prefix coincides with default
#define DAW_JMP16      0x00000020      // 16-bit jump, call or return
#define DAW_FARADDR    0x00000040      // Far jump or call
#define DAW_SEGMOD     0x00000080      // Modifies segment register
#define DAW_PRIV       0x00000100      // Privileged command
#define DAW_IO         0x00000200      // I/O command
#define DAW_SHIFT      0x00000400      // Shift out of range 1..31
#define DAW_LOCK       0x00000800      // Command with valid LOCK prefix
#define DAW_STACK      0x00001000      // Unaligned stack operation
#define DAW_NOESP      0x00002000      // Suspicious use of stack pointer
#define DAW_RARE       0x00004000      // Rare, seldom used command
#define DAW_NONCLASS   0x00008000      // Non-standard or non-documented code
#define DAW_INTERRUPT  0x00010000      // Interrupt command

// Conditions of conditional commands.
#define DAF_NOCOND     0x00000000      // Unconditional command
#define DAF_TRUE       0x00000001      // Condition is true
#define DAF_FALSE      0x00000002      // Condition is false
#define DAF_ANYCOND    0x00000003      // Condition is not predictable

typedef struct t_disasm                // Disassembled command
{
    // In the case that DA_HILITE flag is set, fill these members before calling
    // Disasm(). Parameter hilitereg has priority over hiliteindex.
    ulong          hilitereg;            // One of OP_SOMEREG if reg highlighting
    int            hiregindex;           // Index of register to highlight
    int            hiliteindex;          // Index of highlighting scheme (0: none)
    // Starting from this point, no need to initialize the members of t_disasm.
    ulong          ip;                   // Address of first command byte
    ulong          size;                 // Full length of command, bytes
    ulong          cmdtype;              // Type of command, D_xxx
    ulong          exttype;              // More features, set of DX_xxx
    ulong          prefixes;             // List of prefixes, set of PF_xxx
    ulong          nprefix;              // Number of prefixes, including SSE2
    ulong          memfixup;             // Offset of first 4-byte fixup or -1
    ulong          immfixup;             // Offset of second 4-byte fixup or -1
    int            errors;               // Set of DAE_xxx
    int            warnings;             // Set of DAW_xxx
    // Note that used registers are those which contents is necessary to create
    // result. Modified registers are those which value is changed. For example,
    // command MOV EAX,[EBX+ECX] uses EBX and ECX and modifies EAX. Command
    // ADD ESI,EDI uses ESI and EDI and modifies ESI.
    ulong          uses;                 // List of used registers
    ulong          modifies;             // List of modified registers
    // Useful shortcuts.
    int            condition;            // Condition, one of DAF_xxx
    ulong          jmpaddr;              // Jump/call destination or 0
    ulong          memconst;             // Constant in memory address or 0
    ulong          stackinc;             // Data size in ENTER/RETN/RETF
    // Operands.
    t_operand      op[NOPERAND];         // Operands
    // Textual decoding.
    wchar_t        dump[TEXTLEN];        // Hex dump of the command
    wchar_t        result[TEXTLEN];      // Fully decoded command as text
    uchar          mask[TEXTLEN];        // Mask to highlight result
    int            maskvalid;            // Mask corresponds to result
    wchar_t        comment[TEXTLEN];     // Comment that applies to whole command
} t_disasm;

typedef struct t_opinfo                // Operand in t_cmdinfo
{
    ulong          features;             // Operand features, set of OP_xxx
    ulong          arg;                  // Operand type, set of B_xxx
    int            opsize;               // Total size of data, bytes
    int            reg;                  // REG_xxx (also ESP in POP) or REG_UNDEF
    int            seg;                  // Selector (SEG_xxx)
    uchar          scale[NREG];          // Scales of registers in memory address
    ulong          opconst;              // Constant or const part of address
} t_opinfo;

typedef struct t_cmdinfo               // Information on command
{
    ulong          ip;                   // Address of first command byte
    ulong          size;                 // Full length of command, bytes
    ulong          cmdtype;              // Type of command, D_xxx
    ulong          prefixes;             // List of prefixes, set of PF_xxx
    ulong          nprefix;              // Number of prefixes, including SSE2
    ulong          memfixup;             // Offset of first 4-byte fixup or -1
    ulong          immfixup;             // Offset of second 4-byte fixup or -1
    int            errors;               // Set of DAE_xxx
    ulong          jmpaddr;              // Jump/call destination or 0
    ulong          stackinc;             // Data size in ENTER/RETN/RETF
    t_opinfo       op[NOPERAND];         // Operands
} t_cmdinfo;

// ATTENTION, when making any changes to this structure, apply them to the
// file Cmdemul.asm, too!
typedef struct t_emu                   // Parameters passed to emulation routine
{
    ulong          operand[NOPERAND];    // I/O: Operands
    ulong          opsize;               // IN:  Size of operands
    ulong          memaddr;              // OUT: Save address, or 0 if none
    ulong          memsize;              // OUT: Save size (1, 2 or 4 bytes)
    ulong          memdata;              // OUT: Data to save
} t_emu;

typedef void TRACEFUNC(ulong *,ulong *,t_predict *,t_disasm *);
typedef void __cdecl EMUFUNC(t_emu *,t_reg *);

typedef struct t_bincmd                // Description of 80x86 command
{
    wchar_t        *name;                // Symbolic name for this command
    ulong          cmdtype;              // Command's features, set of D_xxx
    ulong          exttype;              // More features, set of DX_xxx
    ulong          length;               // Length of main code (before ModRM/SIB)
    ulong          mask;                 // Mask for first 4 bytes of the command
    ulong          code;                 // Compare masked bytes with this
    ulong          postbyte;             // Postbyte
    ulong          arg[NOPERAND];        // Types of arguments, set of B_xxx
    TRACEFUNC      *trace;               // Result prediction function
    EMUFUNC        *emu;                 // Command emulation function
} t_bincmd;

#define AMF_SAMEORDER  0x01            // Same order of index registers in addr
#define AMF_ANYSEG     0x02            // Command has undefined segment prefix
#define AMF_POSTBYTE   0x04            // Includes postbyte
#define AMF_IMPRECISE  0x08            // Command is imprecise (search only)
#define AMF_ANYSIZE    0x10            // Any operand size is acceptable
#define AMF_NOSMALL    0x20            // 16-bit address is not allowed
#define AMF_UNDOC      0x40            // Undocumented command
#define AMF_NEWCMD     0x80            // Marks new command in multiline

#define AMP_REGISTER   0x01            // Operand is a register
#define AMP_MEMORY     0x02            // Operand is a memory location
#define AMP_CONST      0x04            // Operand is a constant
#define AMP_IMPRECISE  0x08            // Constant is imprecise
#define AMP_ANYMEM     0x10            // Any memory operand is acceptable
#define AMP_ANYOP      0x20            // Any operand is acceptable

typedef struct t_modop                 // Operand in assembler model
{
    uchar          features;             // Operand features, set of AMP_xxx
    uchar          reg;                  // (Pseudo)register operand
    uchar          scale[NPSEUDO];       // Scales of (pseudo)registers in address
    ulong          opconst;              // Constant or const part of address
} t_modop;

// Assembler command model.
typedef struct t_asmmod                // Description of assembled command
{
    uchar          code[MAXCMDSIZE];     // Binary code
    uchar          mask[MAXCMDSIZE];     // Mask for binary code (0: bit ignored)
    ulong          prefixes;             // List of prefixes, set of PF_xxx
    uchar          ncode;                // Length of code w/o prefixes, bytes
    uchar          features;             // Code features, set of AMF_xxx
    uchar          postbyte;             // Postbyte (if AMF_POSTBYTE set)
    uchar          noperand;             // Number of operands (no pseudooperands)
    t_modop        op[NOPERAND];         // Description of operands
} t_asmmod;

typedef struct t_asmlist               // Descriptor of the sequence of models
{
    t_asmmod       *pasm;                // Pointer to the start of the sequence
    int            length;               // Length of the sequence, models
    wchar_t        comment[TEXTLEN];     // Comment to the sequence
} t_asmlist;

#define DA_TEXT        0x00000001      // Decode command to text and comment
#define   DA_HILITE    0x00000002      // Use syntax highlighting (set t_disasm)
#define DA_OPCOMM      0x00000004      // Comment operands
#define DA_DUMP        0x00000008      // Dump command to hexadecimal text
#define DA_MEMORY      0x00000010      // OK to read memory and use labels
#define   DA_NOIMPORT  0x00000020      // When reading memory, hold the imports
#define   DA_RTLOGMEM  0x00000040      // Use memory saved by run trace
#define   DA_NOSTACKP  0x00000080      // Hide "Stack" prefix in comments
#define DA_STEPINTO    0x00000100      // Enter CALL when predicting registers
#define DA_SHOWARG     0x00000200      // Use predict if address ESP/EBP-based
#define DA_NOPSEUDO    0x00000400      // Skip pseudooperands
#define DA_FORHELP     0x00000800      // Decode operands for command help

#define USEDECODE      ((uchar *)1)    // Request to get decoding automatically

stdapi (int)     Byteregtodwordreg(int bytereg);
stdapi (int)     Printfloat4(wchar_t *s,float f);
stdapi (int)     Printfloat8(wchar_t *s,double d);
stdapi (int)     Printfloat10(wchar_t *s,long double ext);
stdapi (int)     Printmmx(wchar_t *s,uchar *data);
stdapi (int)     Commentcharacter(wchar_t *s,int c,int mode);
stdapi (int)     Nameoffloat(wchar_t *s,uchar *data,ulong size);
stdapi (ulong)   Disasm(uchar *cmd,ulong cmdsize,ulong ip,uchar *dec,
                        t_disasm *da,int mode,t_reg *reg,
                        t_predict *predict);
stdapi (ulong)   Cmdinfo(uchar *cmd,ulong cmdsize,ulong cmdip,
                         t_cmdinfo *ci,int cmdmode,t_reg *cmdreg);
stdapi (ulong)   Disassembleforward(uchar *copy,ulong base,ulong size,
                                    ulong ip,ulong n,uchar *decode);
stdapi (ulong)   Disassembleback(uchar *copy,ulong base,ulong size,
                                 ulong ip,ulong n,uchar *decode);
stdapi (int)     Checkcondition(int code,ulong flags);
stdapi (ulong)   Setcondition(int code,ulong flags);

#define AM_ALLOWBAD    0x00000001      // Allow bad or undocumented commands
#define AM_IMPRECISE   0x00000002      // Generate imprecise (search) forms
#define   AM_MULTI     0x00000004      // Multiple commands are allowed

#define AM_SEARCH      AM_IMPRECISE

stdapi (int)     Assembleallforms(wchar_t *src,ulong ip,t_asmmod *model,
                                  int maxmodel,int mode,wchar_t *errtxt);
stdapi (ulong)   Assemble(wchar_t *src,ulong ip,uchar *buf,ulong nbuf,int mode,
                          wchar_t *errtxt);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// .NET DISASSEMBLER ///////////////////////////////

// CIL command types.
#define N_CMDTYPE      0x0000001F      // Mask to extract type of command
#define   N_CMD        0x00000000      // Ordinary (none of listed below)
#define   N_JMP        0x00000001      // Unconditional jump
#define   N_JMC        0x00000002      // Conditional jump
#define   N_CALL       0x00000003      // Call
#define   N_RET        0x00000004      // Return (also from exception)
#define   N_SWITCH     0x00000005      // Switch, followed by N cases
#define   N_PREFIX     0x00000006      // Prefix, not a standalone command
#define   N_DATA       0x0000001E      // Command is decoded as data
#define   N_BAD        0x0000001F      // Bad command
#define N_POPMASK      0x00000F00      // Mask to extract number of pops
#define   N_POP0       0x00000000      // Pops no arguments (default)
#define   N_POP1       0x00000100      // Pops 1 argument from stack
#define   N_POP2       0x00000200      // Pops 2 arguments from stack
#define   N_POP3       0x00000300      // Pops 3 arguments from stack
#define   N_POPX       0x00000F00      // Pops variable arguments from stack
#define N_PUSHMASK     0x0000F000
#define   N_PUSH0      0x00000000      // Pushes no data (default)
#define   N_PUSH1      0x00001000      // Pushes 1 argument into stack
#define   N_PUSH2      0x00002000      // Pushes 2 arguments into stack
#define   N_PUSHX      0x0000F000      // Pushes 0 or 1 argument into stack

// CIL explicit operand types.
#define A_ARGMASK      0x000000FF      // Mask to extract type of argument
#define   A_NONE       0x00000000      // No operand
#define   A_OFFSET     0x00000001      // 32-bit offset from next command
#define   A_BYTEOFFS   0x00000002      // 8-bit offset from next command
#define   A_METHOD     0x00000003      // 32-bit method descriptor
#define   A_SIGNATURE  0x00000004      // 32-bit signature of call types
#define   A_TYPE       0x00000005      // 32-bit type descriptor
#define   A_FIELD      0x00000006      // 32-bit field descriptor
#define   A_STRING     0x00000007      // 32-bit string descriptor
#define   A_TOKEN      0x00000008      // 32-bit token descriptor
#define   A_INDEX1     0x00000009      // 8-bit immediate index constant
#define   A_INDEX2     0x0000000A      // 16-bit immediate index constant
#define   A_SWCOUNT    0x0000000B      // 32-bit immediate switch count
#define   A_INT1S      0x0000000C      // 8-bit immediate signed integer const
#define   A_INT4       0x0000000D      // 32-bit immediate integer constant
#define   A_INT8       0x0000000E      // 64-bit immediate integer constant
#define   A_FLOAT4     0x0000000F      // 32-bit immediate float constant
#define   A_FLOAT8     0x00000010      // 64-bit immediate float constant
#define   A_NOLIST     0x00000011      // 8-bit list following no. prefix
#define   A_ALIGN      0x00000012      // 8-bit alignment following unaligned.

typedef struct t_netasm                // Disassembled .NET CIL command
{
    ulong          ip;                   // Address of first command byte
    ulong          size;                 // Full length of command, bytes
    ulong          cmdtype;              // Type of command, N_xxx
    ulong          cmdsize;              // Size of command, bytes
    ulong          opsize;               // Size of operand, bytes, or 0 if none
    ulong          nswitch;              // Size of following switch table, dwords
    ulong          jmpaddr;              // Single jump/call destination or 0
    ulong          descriptor;           // Descriptor (xx)xxxxxx or 0
    ulong          dataaddr;             // Address of pointed object/data or 0
    int            errors;               // Set of DAE_xxx
    // Description of operand.
    ulong          optype;               // Operand type, set of A_xxx
    wchar_t        optext[TEXTLEN];      // Operand, decoded to text
    // Textual decoding.
    wchar_t        dump[TEXTLEN];        // Hex dump of the command
    wchar_t        result[TEXTLEN];      // Fully decoded command as text
    wchar_t        comment[TEXTLEN];     // Comment that applies to whole command
} t_netasm;

stdapi (ulong)   Ndisasm(uchar *cmd,ulong size,ulong ip,t_netasm *da,
                         int mode,t_module *pmod);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// ANALYSIS ///////////////////////////////////

#define MAXARG         256             // Maximal sane number of arguments

#define NGUESS         7               // Max number of args in type analysis

#define AA_MANUAL      0               // No automatical analysis
#define AA_MAINONLY    1               // Automatically analyse main module
#define AA_NONSYS      2               // Automatically analyse non-sys modules
#define AA_ALL         3               // Automatically analyse all modules

#define AO_ISFORMATA   0x01            // Argument is probable ASCII format
#define AO_SIGFORMATA  0x02            // Non-trivial ASCII format
#define AO_ISFORMATW   0x04            // Argument is probable UNICODE format
#define AO_SIGFORMATW  0x08            // Non-trivial UNICODE format
#define AO_NOTFORMAT   0x10            // Argument is not a format
#define AO_ISCOUNT     0x20            // Argument is count of remaining args
#define AO_NOTCOUNT    0x40            // Argument is not a count

typedef struct t_procdata              // Description of procedure
{
    ulong          addr;                 // Address of entry point
    ulong          size;                 // Size of simple procedure or 1
    ulong          type;                 // Type of procedure, TY_xxx/PD_xxx
    ulong          retsize;              // Size of return (if PD_RETSIZE)
    ulong          localsize;            // Size of reserved locals, 0 - unknown
    ulong          savedebp;             // Offset of cmd after PUSH EBP, 0 - none
    ulong          features;             // Type of known code, RAW_xxx
    char           generic[12];          // Generic name (without _INTERN_)
    int            narg;                 // No. of stack DWORDs (PD_NARG/VARARG)
    int            nguess;               // Number of guessed args (if PD_NGUESS)
    int            npush;                // Number of pushed args (if PD_NPUSH)
    int            usedarg;              // Min. number of accessed arguments
    uchar          preserved;            // Preserved registers
    uchar          argopt[NGUESS];       // Guessed argument options, AO_xxx
} t_procdata;

typedef struct t_argnest               // Header of call arguments bracket
{
    ulong          addr0;                // First address occupied by range
    ulong          addr1;                // Last occupied address (included!)
    ulong          type;                 // Level and user-defined type, TY_xxx
    ulong          aprev;                // First address of previous range
} t_argnest;

#define NLOOPVAR       4               // Max number of loop variables

typedef struct t_loopnest              // Header of loop bracket
{
    ulong          addr0;                // First address occupied by range
    ulong          addr1;                // Last occupied address (included!)
    ulong          type;                 // Level and user-defined type, TY_xxx
    ulong          aprev;                // First address of previous range
    ulong          eoffs;                // Offset of entry point from addr0
    struct                               // Loop registers and variables
    {
        uchar        type;                 // Combination of PRED_xxx
        long         espoffset;            // For locals, offset to original ESP
        long         increment;            // Increment after loop
    } loopvar[NLOOPVAR];
} t_loopnest;

stdapi (ulong)   Getpackednetint(uchar *code,ulong size,ulong *value);
stdapi (void)    Removeanalysis(ulong base,ulong size,int keephittrace);
stdapi (int)     Maybecommand(ulong addr,int requireanalysis);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// STACK WALK //////////////////////////////////

#define SF_FMUNREL     0x00000001      // Predicted frame is unreliable
#define SF_BPUNREL     0x00000002      // Predicted EBP is unreliable
#define SF_VIRTUAL     0x00000004      // DBGHELP: EBP is undefined

typedef struct t_sframe                // Stack frame descriptor
{
    // Input parameters, fill before call to Findretaddrdata().
    ulong          eip;                  // Address of command that owns frame
    ulong          esp;                  // ESP at EIP
    ulong          ebp;                  // EBP at EIP, or 0 if unknown
    // Parameters used by DBGHELP.DLL, initialize only before the first call.
    int            firstcall;            // First call to Findretaddrdata()
    HANDLE         thread;               // Thread handle
    CONTEXT        context;              // Copy of CONTEXT, fill on first call
    int            contextvalid;         // Whether context contains valid data
    // Output parameters.
    ulong          status;               // Set of SF_xxx
    ulong          oldeip;               // Address of CALL or 0 if unknown
    ulong          oldesp;               // ESP at CALL or 0 if unknown
    ulong          oldebp;               // EBP at CALL or 0 if unknown
    ulong          retpos;               // Address of return in stack
    ulong          procaddr;             // Entry of current function or 0
    // Parameters used by DBGHELP.DLL, don't initialize!
#ifdef STACKFRAME64                  // Requires <dbghelp.h>
    STACKFRAME64 sf;                   // Stack frame for StackWalk64()
#else
    uchar        dummy[264];           // Replaces STACKFRAME64
#endif
} t_sframe;

stdapi (ulong)   Isretaddr(ulong retaddr,ulong *procaddr);
stdapi (int)     Findretaddrdata(t_sframe *pf,ulong base,ulong size);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// KNOWN FUNCTIONS ////////////////////////////////

#define NARG           24              // Max number of arguments in a function

#define ADEC_VALID     0x00000001      // Value valid
#define ADEC_PREDICTED 0x00000002      // Value predicted
#define ADEC_CHGNAME   0x00000004      // Allow name change of substituted arg
#define ADEC_MARK      0x00000008      // (out) Important parameter

// Type of argument in the description of function or structure. Note that
// ARG_STRUCT is allowed only in conjunction with ARG_POINTER.
#define ARG_POINTER    0x01            // Argument is a pointer
#define ARG_BASE       0x06            // Mask to extract base type of argument
#define   ARG_TYPE     0x00            // Argument is a type
#define   ARG_STRUCT   0x02            // Argument is a structure
#define   ARG_DIRECT   0x04            // Argument is a direct string
#define ARG_OUT        0x08            // Pointer to data undefined at call
#define ARG_MARK       0x10            // Important parameter
#define ARG_ELLIPSYS   0x20            // Followed by ellipsys
#define ARG_VALID      0x40            // Must always be set to avoid argx=0

#define ARG_TYPEMASK   (ARG_POINTER|ARG_BASE)    // Mask to extract full type

#define ARG_PTYPE      (ARG_POINTER|ARG_TYPE)    // Pointer to type
#define ARG_PSTRUCT    (ARG_POINTER|ARG_STRUCT)  // Pointer to structure

// Bits used to define type of function.
#define FN_C           0x00000001      // Does not remove arguments from stack
#define FN_PASCAL      0x00000002      // Removes arguments from stack on return
#define FN_NORETURN    0x00000004      // Does not return, like ExitProcess()
#define FN_VARARG      0x00000008      // Variable number of arguments
#define FN_EAX         0x00000100      // EAX on return is same as on entry
#define FN_ECX         0x00000200      // ECX on return is same as on entry
#define FN_EDX         0x00000400      // EDX on return is same as on entry
#define FN_EBX         0x00000800      // EBX on return is same as on entry
#define FN_ESP         0x00001000      // ESP on return is same as on entry
#define FN_EBP         0x00002000      // EBP on return is same as on entry
#define FN_ESI         0x00004000      // ESI on return is same as on entry
#define FN_EDI         0x00008000      // EDI on return is same as on entry
#define FN_USES_EAX    0x00010000      // EAX is used as register parameter
#define FN_USES_ECX    0x00020000      // ECX is used as register parameter
#define FN_USES_EDX    0x00040000      // EDX is used as register parameter
#define FN_USES_EBX    0x00080000      // EBX is used as register parameter
#define FN_USES_ESP    0x00100000      // ESP is used as register parameter
#define FN_USES_EBP    0x00200000      // EBP is used as register parameter
#define FN_USES_ESI    0x00400000      // ESI is used as register parameter
#define FN_USES_EDI    0x00800000      // EDI on return is same as on entry

#define FN_FUNCTION    0
#define FN_STDFUNC     (FN_PASCAL|FN_EBX|FN_EBP|FN_ESI|FN_EDI)
#define FN_STDC        (FN_C|FN_EBX|FN_EBP|FN_ESI|FN_EDI)

typedef struct t_argdec                // Descriptor of function argument
{
    ulong          mode;                 // Value descriptor, set of ADEC_xxx
    ulong          value;                // Value on the stack
    ulong          pushaddr;             // Address of command that pushed data
    wchar_t        prtype[SHORTNAME];    // Type of argument with ARG_xxx prefix
    wchar_t        name[TEXTLEN];        // Decoded name of argument
    wchar_t        text[TEXTLEN];        // Decoded value (if valid or predicted)
} t_argdec;

typedef struct t_strdec                // Decoded structure item
{
    ulong          size;                 // Item size, bytes
    ulong          addr;                 // Address of the first byte
    ulong          value;                // Item value (only if size<=4!)
    uchar          valuevalid;           // Whether value is valid
    uchar          dec;                  // One of DEC_TYPEMASK subfields
    uchar          decsize;              // Size of decoding element
    uchar          reserved;             // Reserved for the future
    wchar_t        prtype[SHORTNAME];    // Type of item with ARG_xxx prefix
    wchar_t        name[TEXTLEN];        // Name of item
    wchar_t        text[TEXTLEN];        // Decoded value
} t_strdec;

typedef struct t_rawdata               // Header of raw data block
{
    ulong          size;                 // Data size, bytes
    ulong          hasmask;              // Data is followed by mask
    ulong          features;             // Data features
} t_rawdata;                           // Data & mask immediately follow header

typedef struct t_argloc                // Information about stack args & locals
{
    ulong          fntype;               // Calling convention, set of FN_xxx
    int            retfeatures;          // Return features, set of ARG_xxx
    int            retsize;              // Size of returned value
    wchar_t        rettype[SHORTNAME];   // Type of the returned value
    int            argvalid;             // Whether arg[] below is valid
    struct                               // List of arguments
    {
        int          features;             // Argument features, set of ARG_xxx
        int          size;                 // Size of argument on the stack
        wchar_t      name[TEXTLEN];        // Name of the argument
        wchar_t      type[SHORTNAME];      // Type of the argument
    } arg[NARG];
} t_argloc;

stdapi (int)     Getconstantbyname(wchar_t *name,ulong *value);
stdapi (int)     Getconstantbyvalue(wchar_t *groupname,
                                    ulong value,wchar_t *name);
stdapi (int)     Decodetype(ulong data,wchar_t *type,wchar_t *text,int ntext);
stdapi (int)     Fillcombowithgroup(HWND hw,wchar_t *groupname,
                                    int sortbyname,ulong select);
stdapi (int)     Fillcombowithstruct(HWND hw,wchar_t *prefix,wchar_t *select);
stdapi (t_rawdata *) Getrawdata(wchar_t *name);
stdapi (int)     Substitutehkeyprefix(wchar_t *key);
stdapi (int)     Decodeknownbyname(wchar_t *name,t_procdata *pd,
                                   t_argdec adec[NARG],wchar_t *rettype,int nexp);
stdapi (int)     Decodeknownbyaddr(ulong addr,t_procdata *pd,
                                   t_argdec adec[NARG],wchar_t *rettype,wchar_t *name,
                                   int nexp,int follow);
stdapi (int)     Isnoreturn(ulong addr);
stdapi (int)     Decodeargument(t_module *pmod,wchar_t *prtype,void *data,
                                int ndata,wchar_t *text,int ntext,int *nontriv);
stdapi (int)     Getstructureitemcount(wchar_t *name,ulong *size);
stdapi (int)     Findstructureitembyoffset(wchar_t *name,ulong offset);
stdapi (int)     Decodestructure(wchar_t *name,ulong addr,int item0,
                                 t_strdec *str,int nstr);
stdapi (ulong)   Getstructureitemvalue(uchar *code,ulong ncode,
                                       wchar_t *name,wchar_t *itemname,void *value,ulong nvalue);


////////////////////////////////////////////////////////////////////////////////
////////////////////// EXPRESSIONS, WATCHES AND INSPECTORS /////////////////////

#define NEXPR          16              // Max. no. of expressions in EMOD_MULTI

// Mode of expression evaluation.
#define EMOD_CHKEXTRA  0x00000001      // Report extra characters on line
#define EMOD_NOVALUE   0x00000002      // Don't convert data to text
#define EMOD_NOMEMORY  0x00000004      // Don't read debuggee's memory
#define EMOD_MULTI     0x00000008      // Allow multiple expressions

#define EXPR_TYPEMASK  0x0F            // Mask to extract type of expression
#define   EXPR_INVALID 0x00            // Invalid or undefined expression
#define   EXPR_BYTE    0x01            // 8-bit integer byte
#define   EXPR_WORD    0x02            // 16-bit integer word
#define   EXPR_DWORD   0x03            // 32-bit integer doubleword
#define   EXPR_FLOAT4  0x04            // 32-bit floating-point number
#define   EXPR_FLOAT8  0x05            // 64-bit floating-point number
#define   EXPR_FLOAT10 0x06            // 80-bit floating-point number
#define   EXPR_SEG     0x07            // Segment
#define   EXPR_ASCII   0x08            // Pointer to ASCII string
#define   EXPR_UNICODE 0x09            // Pointer to UNICODE string
#define   EXPR_TEXT    0x0A            // Immediate UNICODE string
#define EXPR_REG       0x10            // Origin is register
#define EXPR_SIGNED    0x20            // Signed integer

#define EXPR_SIGDWORD  (EXPR_DWORD|EXPR_SIGNED)

typedef struct t_result                // Result of expression's evaluation
{
    int            lvaltype;             // Type of expression, EXPR_xxx
    ulong          lvaladdr;             // Address of lvalue or NULL
    int            datatype;             // Type of data, EXPR_xxx
    int            repcount;             // Repeat count (0..32, 0 means default)
    union
    {
        uchar        data[10];             // Value as set of bytes
        ulong        u;                    // Value as address or unsigned integer
        long         l;                    // Value as signed integer
        long double  f;
    };                 // Value as 80-bit float
    wchar_t        value[TEXTLEN];       // Value decoded to string
} t_result;

typedef struct t_watch                 // Watch descriptor
{
    ulong          addr;                 // 0-based watch index
    ulong          size;                 // Reserved, always 1
    ulong          type;                 // Service information, TY_xxx
    wchar_t        expr[TEXTLEN];        // Watch expression
} t_watch;

stdapi (int)     Cexpression(wchar_t *expression,uchar *cexpr,int nexpr,
                             int *explen,wchar_t *err,ulong mode);
stdapi (int)     Exprcount(uchar *cexpr);
stdapi (int)     Eexpression(t_result *result,wchar_t *expl,uchar *cexpr,
                             int index,uchar *data,ulong base,ulong size,ulong threadid,
                             ulong a,ulong b,ulong mode);
stdapi (int)     Expression(t_result *result,wchar_t *expression,uchar *data,
                            ulong base,ulong size,ulong threadid,ulong a,ulong b,
                            ulong mode);
stdapi (int)     Fastexpression(t_result *result,ulong addr,int type,
                                ulong threadid);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// DIALOGS AND OPTIONS //////////////////////////////

// Mode bits in calls to dialog functions.
#define DIA_SIZEMASK   0x0000001F      // Mask to extract default data size
#define   DIA_BYTE     0x00000001      // Byte data size
#define   DIA_WORD     0x00000002      // Word data size
#define   DIA_DWORD    0x00000004      // Doubleword data size (default)
#define   DIA_QWORD    0x00000008      // Quadword data size
#define   DIA_TBYTE    0x0000000A      // 10-byte data size
#define   DIA_DQWORD   0x00000010      // 16-byte data size
#define DIA_HEXONLY    0x00000020      // Hexadecimal format only
#define DIA_EXTENDED   0x00000040      // Extended format
#define DIA_DATAVALID  0x00000080      // Input data valid (edit mode)
#define DIA_DEFMASK    0x00000F00      // Mask to extract default data type
#define   DIA_DEFHEX   0x00000100      // On startup, cursor in hex control
#define   DIA_DEFSIG   0x00000200      // On startup, cursor in signed control
#define   DIA_DEFUNSIG 0x00000300      // On startup, cursor in unsigned control
#define   DIA_DEFASC   0x00000400      // On startup, cursor in ASCII control
#define   DIA_DEFUNI   0x00000500      // On startup, cursor in UNICODE control
#define   DIA_DEFCODE  0x00000600      // Default is code breakpoint
#define   DIA_DEFFLOAT 0x00000700      // Default selection is float
#define DIA_ISSEARCH   0x00001000      // Is a search dialog
#define DIA_ASKCASE    0x00002000      // Ask if case-insensitive
#define DIA_SEARCHDIR  0x00004000      // Includes direction search buttons
#define DIA_HISTORY    0x00008000      // Supports history
#define DIA_SELMASK    0x000F0000      // Mask to extract selection offset
#define   DIA_SEL0     0x00000000      // Select least significant item
#define   DIA_SEL4     0x00040000      // Select item with offset 4
#define   DIA_SEL8     0x00080000      // Select item with offset 8
#define   DIA_SEL12    0x000C0000      // Select item with offset 12
#define   DIA_SEL14    0x000E0000      // Select item with offset 14
#define DIA_JMPMODE    0x00300000      // Mask for jump/call/switch display
#define   DIA_JMPFROM  0x00000000      // Jumps/calls from specified location
#define   DIA_JMPTO    0x00100000      // Jumps/calls to specified location
#define   DIA_SWITCH   0x00200000      // Switches
#define DIA_JMPGLOB    0x00400000      // Show global jumps and calls
#define DIA_JMPLOC     0x00000000      // Show local jumps and calls
#define DIA_UTF8       0x00800000      // Support for UTF8
#define DIA_ABSXYPOS   0x10000000      // Use X-Y dialog coordinates as is
#define DIA_RESTOREPOS 0x20000000      // Restore X-Y dialog coordinates

// Types of controls that can be used in dialogs.
#define CA_END         0               // End of control list with dialog size
#define CA_COMMENT     1               // Dummy entry in control list
#define CA_TEXT        2               // Simple left-aligned text
#define CA_TEXTC       4               // Simple centered text
#define CA_TEXTR       5               // Simple right-aligned text
#define CA_WARN        6               // Multiline text, highlighted if differ
#define CA_WTEXT       7               // Text with white bg in sunken frame
#define CA_TITLE       8               // Fat centered text
#define CA_FRAME       9               // Etched frame
#define CA_SUNK        10              // Sunken frame
#define CA_GROUP       11              // Group box (named frame)
#define CA_EDIT        12              // Standard edit control
#define CA_NOEDIT      13              // Read-only edit control
#define CA_EDITHEX     14              // Standard edit control, hex uppercase
#define CA_MULTI       15              // Multiline edit control (DATALEN)
#define CA_NOMULTI     16              // Multiline read-only edit (DATALEN)
#define CA_BTN         17              // Standard pushbutton
#define CA_DEFBTN      18              // Standard default pushbutton
#define CA_COMBO       19              // Combo box control, specified font
#define CA_COMBOFIX    20              // Combo box control, fixed width font
#define CA_CEDIT       21              // Combo edit control, specified font
#define CA_CEDITFIX    22              // Combo edit control, fixed width font
#define CA_CESAV0      32              // Combo edit 0 with autosave & UNICODE
#define CA_CESAV1      33              // Combo edit 1 with autosave & UNICODE
#define CA_CESAV2      34              // Combo edit 2 with autosave & UNICODE
#define CA_CESAV3      35              // Combo edit 3 with autosave & UNICODE
#define CA_CESAV4      36              // Combo edit 4 with autosave & UNICODE
#define CA_CESAV5      37              // Combo edit 5 with autosave & UNICODE
#define CA_CESAV6      38              // Combo edit 6 with autosave & UNICODE
#define CA_CESAV7      39              // Combo edit 7 with autosave & UNICODE
#define CA_LIST        48              // Simple list box
#define CA_LISTFIX     49              // Simple list box, fixed font
#define CA_CHECK       62              // Auto check box, left-aligned
#define CA_CHECKR      63              // Auto check box, right-aligned
#define CA_BIT0        64              // Auto check box, bit 0
#define CA_BIT1        65              // Auto check box, bit 1
#define CA_BIT2        66              // Auto check box, bit 2
#define CA_BIT3        67              // Auto check box, bit 3
#define CA_BIT4        68              // Auto check box, bit 4
#define CA_BIT5        69              // Auto check box, bit 5
#define CA_BIT6        70              // Auto check box, bit 6
#define CA_BIT7        71              // Auto check box, bit 7
#define CA_BIT8        72              // Auto check box, bit 8
#define CA_BIT9        73              // Auto check box, bit 9
#define CA_BIT10       74              // Auto check box, bit 10
#define CA_BIT11       75              // Auto check box, bit 11
#define CA_BIT12       76              // Auto check box, bit 12
#define CA_BIT13       77              // Auto check box, bit 13
#define CA_BIT14       78              // Auto check box, bit 14
#define CA_BIT15       79              // Auto check box, bit 15
#define CA_BIT16       80              // Auto check box, bit 16
#define CA_BIT17       81              // Auto check box, bit 17
#define CA_BIT18       82              // Auto check box, bit 18
#define CA_BIT19       83              // Auto check box, bit 19
#define CA_BIT20       84              // Auto check box, bit 20
#define CA_BIT21       85              // Auto check box, bit 21
#define CA_BIT22       86              // Auto check box, bit 22
#define CA_BIT23       87              // Auto check box, bit 23
#define CA_BIT24       88              // Auto check box, bit 24
#define CA_BIT25       89              // Auto check box, bit 25
#define CA_BIT26       90              // Auto check box, bit 26
#define CA_BIT27       91              // Auto check box, bit 27
#define CA_BIT28       92              // Auto check box, bit 28
#define CA_BIT29       93              // Auto check box, bit 29
#define CA_BIT30       94              // Auto check box, bit 30
#define CA_BIT31       95              // Auto check box, bit 31
#define CA_RADIO0      96              // Radio button, value 0
#define CA_RADIO1      97              // Radio button, value 1
#define CA_RADIO2      98              // Radio button, value 2
#define CA_RADIO3      99              // Radio button, value 3
#define CA_RADIO4      100             // Radio button, value 4
#define CA_RADIO5      101             // Radio button, value 5
#define CA_RADIO6      102             // Radio button, value 6
#define CA_RADIO7      103             // Radio button, value 7
#define CA_RADIO8      104             // Radio button, value 8
#define CA_RADIO9      105             // Radio button, value 9
#define CA_RADIO10     106             // Radio button, value 10
#define CA_RADIO11     107             // Radio button, value 11
#define CA_RADIO12     108             // Radio button, value 12
#define CA_RADIO13     109             // Radio button, value 13
#define CA_RADIO14     110             // Radio button, value 14
#define CA_RADIO15     111             // Radio button, value 15
#define CA_CUSTOM      124             // Custom control
#define CA_CUSTSF      125             // Custom control with sunken frame
// Controls with special functions that work only in Options dialog.
#define CA_FILE        129             // Edit file (autosave, MAXPATH chars)
#define CA_BROWSE      130             // Browse file name pushbutton
#define CA_BRDIR       131             // Browse directory pushbutton
#define CA_LANGS       132             // Combobox with list of languages
#define CA_FONTS       133             // Combobox with list of fonts
#define CA_FHTOP       134             // Combobox that adjusts top font height
#define CA_FHBOT       135             // Combobox that adjusts bottom font hgt
#define CA_SCHEMES     136             // Combobox with list of schemes
#define CA_HILITE      137             // Combobox with list of hilites
#define CA_HILITE1     138             // Combobox with nontrivial hilites

// Modes of font usage in dialog windows, if applies.
#define DFM_SYSTEM     0               // Use system font
#define DFM_PARENT     1               // Use font of parent window
#define DFM_FIXED      2               // Use dlgfontindex
#define DFM_FIXALL     3               // Use dlgfontindex for all controls

#define HEXLEN         1024            // Max length of hex edit string, bytes

#define NSEARCHCMD     128             // Max number of assembler search models

typedef struct t_control               // Descriptor of dialog control
{
    ulong          type;                 // Type of control, CA_xxx
    int            id;                   // Control's ID or -1 if unimportant
    int            x;                    // X coordinate, chars/4
    int            y;                    // Y coordinate, chars/8
    int            dx;                   // X size, chars/4
    int            dy;                   // Y size, chars/8
    int            *var;                 // Pointer to control variable or NULL
    wchar_t        *text;                // Name or contents of the control
    wchar_t        *help;                // Tooltip or NULL
    int            oldvar;               // Copy of control variable, internal
} t_control;

typedef struct t_dialog                // Descriptor of OllyDbg dialog
{
    t_control      *controls;            // List of controls to place in dialog
    wchar_t        *title;               // Pointer to the dialog's title
    int            focus;                // ID of control with focus
    int            item;                 // Index of processing item
    ulong          u;                    // Doubleword data
    uchar          data[16];             // Data in other formats
    ulong          addr0;                // Address
    ulong          addr1;                // Address
    int            letter;               // First character entered in dialog
    int            x;                    // X reference screen coordinate
    int            y;                    // Y reference screen coordinate
    int            fi;                   // Index of font to use in dialog
    int            mode;                 // Dialog operation mode, set of DIA_xxx
    int            cesav[8];             // NM_xxx of CA_CESAVn
    HFONT          fixfont;              // Fixed font used in dialog
    int            isfullunicode;        // Whether fixfont UNICODE
    int            fixdx;                // Width of dialog fixed font
    int            fixdy;                // Height of dialog fixed font
    HWND           htooltip;             // Handle of tooltip window
    HWND           hwwarn;               // Handle of WARN control, if any
    int            initdone;             // WM_INITDIALOG finished
} t_dialog;

// ATTENTION, size of structure t_hexstr must not exceed DATALEN!
typedef struct t_hexstr                // Data for hex/text search
{
    ulong          n;                    // Data length, bytes
    ulong          nmax;                 // Maximal data length, bytes
    uchar          data[HEXLEN];         // Data
    uchar          mask[HEXLEN];         // Mask, 0 bits are masked
} t_hexstr;

typedef int  BROWSECODEFUNC(int,void *,ulong *,wchar_t *);

stdapi (t_control *) Findcontrol(HWND hw);
stdapi (int)     Defaultactions(HWND hparent,t_control *pctr,
                                WPARAM wp,LPARAM lp);
stdapi (void)    Addstringtocombolist(HWND hc,wchar_t *s);
stdapi (int)     Preparedialog(HWND hw,t_dialog *pdlg);
stdapi (int)     Endotdialog(HWND hw,int result);
stdapi (int)     Getregister(HWND hparent,int reg,ulong *data,int letter,
                             int x,int y,int fi,int mode);
stdapi (int)     Getinteger(HWND hparent,wchar_t *title,ulong *data,int letter,
                            int x,int y,int fi,int mode);
stdapi (int)     Getdword(HWND hparent,wchar_t *title,ulong *data,int letter,
                          int x,int y,int fi,int mode);
stdapi (int)     Getlasterrorcode(HWND hparent,wchar_t *title,ulong *data,
                                  int letter,int x,int y,int fi);
stdapi (int)     Getaddressrange(HWND hparent,wchar_t *title,
                                 ulong *rmin,ulong *rmax,int x,int y,int fi,int mode);
stdapi (int)     Getexceptionrange(HWND hparent,wchar_t *title,
                                   ulong *rmin,ulong *rmax,int x,int y,int fi);
stdapi (int)     Getstructuretype(HWND hparent,wchar_t *title,wchar_t *text,
                                  wchar_t *strname,int x,int y,int fi);
stdapi (int)     Getfpureg(HWND hparent,int reg,void *data,int letter,
                           int x,int y,int fi);
stdapi (int)     Get3dnow(HWND hparent,wchar_t *title,void *data,int letter,
                          int x,int y,int fi,int mode);
stdapi (int)     Getfloat(HWND hparent,wchar_t *title,void *data,int letter,
                          int x,int y,int fi,int mode);
stdapi (int)     Getmmx(HWND hparent,wchar_t *title,void *data,int letter,
                        int x,int y,int fi);
stdapi (int)     Getsse(HWND hparent,wchar_t *title,void *data,int letter,
                        int x,int y,int fi,int mode);
stdapi (int)     Getstring(HWND hparent,wchar_t *title,wchar_t *s,int length,
                           int savetype,int letter,int x,int y,int fi,int mode);
stdapi (int)     Getdwordexpression(HWND hparent,wchar_t *title,ulong *u,
                                    ulong threadid,int savetype,int x,int y,int fi,int mode);
stdapi (int)     Getgotoexpression(HWND hparent,wchar_t *title,ulong *u,
                                   ulong threadid,int savetype,int x,int y,int fi,int mode);
stdapi (int)     Asmindump(HWND hparent,wchar_t *title,struct t_dump *pd,
                           int letter,int x,int y,int fi,int mode);
stdapi (int)     Getasmsearchmodel(HWND hparent,wchar_t *title,t_asmmod *model,
                                   int nmodel,int x,int y,int fi,int mode);
stdapi (int)     Getseqsearchmodel(HWND hparent,wchar_t *title,t_asmmod *model,
                                   int nmodel,int x,int y,int fi,int mode);
stdapi (int)     Binaryedit(HWND hparent,wchar_t *title,t_hexstr *hstr,
                            int letter,int x,int y,int fi,int mode);
stdapi (int)     Getpredefinedtypebyindex(int fnindex,wchar_t *type);
stdapi (int)     Getindexbypredefinedtype(wchar_t *type);
stdapi (int)     Condbreakpoint(HWND hparent,ulong *addr,int naddr,
                                wchar_t *title,int x,int y,int fi);
stdapi (int)     Condlogbreakpoint(HWND hparent,ulong *addr,int naddr,
                                   int fnindex,wchar_t *title,int x,int y,int fi);
stdapi (int)     Membreakpoint(HWND hparent,ulong addr,ulong size,
                               int x,int y,int fi,int mode);
stdapi (int)     Memlogbreakpoint(HWND hparent,ulong addr,ulong size,
                                  int x,int y,int fi,int mode);
stdapi (int)     Hardbreakpoint(HWND hparent,ulong addr,
                                int x,int y,int fi,int mode);
stdapi (int)     Hardlogbreakpoint(HWND hparent,ulong addr,int fnindex,
                                   int x,int y,int fi,int mode);
stdapi (void)    Setrtcond(HWND hparent,int x,int y,int fi);
stdapi (void)    Setrtprot(HWND hparent,int x,int y,int fi);
stdapi (ulong)   Browsecodelocations(HWND hparent,wchar_t *title,
                                     BROWSECODEFUNC *bccallback,void *data);
stdapi (int)     Fillcombowithcodepages(HWND hw,int select);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PLUGIN OPTIONS ////////////////////////////////

#define OPT_TITLE      9001            // Pane title
#define OPT_1          9011            // First automatical control
#define OPT_2          9012            // Second automatical control
#define OPT_3          9013            // Third automatical control
#define OPT_4          9014            // Fourth automatical control
#define OPT_5          9015            // Fifth automatical control
#define OPT_6          9016            // Sixth automatical control
#define OPT_7          9017            // Seventh automatical control
#define OPT_8          9018            // Eighth automatical control
#define OPT_9          9019            // Ninth automatical control
#define OPT_10         9020            // Tenth automatical control
#define OPT_11         9021            // Eleventh automatical control
#define OPT_12         9022            // Twelfth automatical control
#define OPT_13         9023            // Thirteen automatical control
#define OPT_14         9024            // Fourteen automatical control
#define OPT_15         9025            // Fifteen automatical control
#define OPT_16         9026            // Sixteen automatical control
#define OPT_17         9027            // Seventeen automatical control
#define OPT_18         9028            // Eighteen automatical control
#define OPT_19         9029            // Nineteen automatical control
#define OPT_20         9030            // Twentieth automatical control
#define OPT_21         9031            // Twenty-first automatical control
#define OPT_22         9032            // Twenty-second automatical control
#define OPT_23         9033            // Twenty-third automatical control
#define OPT_24         9034            // Twenty-fourth automatical control
#define OPT_W1         9101            // First automatical autowarn control
#define OPT_W2         9102            // Second automatical autowarn control
#define OPT_W3         9103            // Third automatical autowarn control
#define OPT_W4         9104            // Fourth automatical autowarn control
#define OPT_W5         9105            // Fifth automatical autowarn control
#define OPT_W6         9106            // Sixth automatical autowarn control
#define OPT_W7         9107            // Seventh automatical autowarn control
#define OPT_W8         9108            // Eighth automatical autowarn control
#define OPT_W9         9109            // Ninth automatical autowarn control
#define OPT_W10        9110            // Tenth automatical autowarn control
#define OPT_W11        9111            // Eleventh automatical autowarn control
#define OPT_W12        9112            // Twelfth automatical autowarn control
#define OPT_S1         9121            // First autowarn-if-turned-on control
#define OPT_S2         9122            // Second autowarn-if-turned-on control
#define OPT_S3         9123            // Third autowarn-if-turned-on control
#define OPT_S4         9124            // Fourth autowarn-if-turned-on control
#define OPT_S5         9125            // Fifth autowarn-if-turned-on control
#define OPT_S6         9126            // Sixth autowarn-if-turned-on control
#define OPT_S7         9127            // Seventh autowarn-if-turned-on control
#define OPT_S8         9128            // Eighth autowarn-if-turned-on control
#define OPT_S9         9129            // Ninth autowarn-if-turned-on control
#define OPT_S10        9130            // Tenth autowarn-if-turned-on control
#define OPT_S11        9131            // Eleventh autowarn-if-turned-on control
#define OPT_S12        9132            // Twelfth autowarn-if-turned-on control
#define OPT_X1         9141            // First autowarn-if-all-on control
#define OPT_X2         9142            // Second autowarn-if-all-on control
#define OPT_X3         9143            // Third autowarn-if-all-on control
#define OPT_X4         9144            // Fourth autowarn-if-all-on control
#define OPT_X5         9145            // Fifth autowarn-if-all-on control
#define OPT_X6         9146            // Sixth autowarn-if-all-on control
#define OPT_X7         9147            // Seventh autowarn-if-all-on control
#define OPT_X8         9148            // Eighth autowarn-if-all-on control
#define OPT_X9         9149            // Ninth autowarn-if-all-on control
#define OPT_X10        9150            // Tenth autowarn-if-all-on control
#define OPT_X11        9151            // Eleventh autowarn-if-all-on control
#define OPT_X12        9152            // Twelfth autowarn-if-all-on control

#define OPT_CUSTMIN    9500            // Custom controls by plugins
#define OPT_CUSTMAX    9999            // End of custom area


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// COMMENTS ///////////////////////////////////

// Comments types used by Commentaddress().
#define COMM_USER      0x00000001      // Add user-defined comment
#define COMM_MARK      0x00000002      // Add important arguments
#define COMM_PROC      0x00000004      // Add procedure description
#define COMM_ALL       0xFFFFFFFF      // Add all possible comments

stdapi (int)     Stringtotext(wchar_t *data,int ndata,wchar_t *text,int ntext,
                              int stopatzero);
stdapi (int)     Isstring(ulong addr,int isstatic,wchar_t *symb,int nsymb);
stdapi (int)     Squeezename(wchar_t *dest,int ndest,wchar_t *src,int nsrc);
stdapi (void)    Uncapitalize(wchar_t *s);
stdapi (int)     Decoderelativeoffset(ulong addr,int addrmode,
                                      wchar_t *symb,int nsymb);
stdapi (int)     Decodeaddress(ulong addr,ulong amod,int mode,
                               wchar_t *symb,int nsymb,wchar_t *comment);
stdapi (int)     Decodearglocal(ulong ip,ulong offs,ulong datasize,
                                wchar_t *name,int len);
stdapi (int)     Getanalysercomment(struct t_module *pmod,ulong addr,
                                    wchar_t *comment,int len);
stdapi (int)     Getswitchcomment(ulong addr,wchar_t *comment,int len);
stdapi (int)     Getloopcomment(struct t_module *pmod,ulong addr,int level,
                                wchar_t *comment,int len);
stdapi (int)     Getproccomment(ulong addr,ulong acall,
                                wchar_t *comment,int len,int argonly);
stdapi (int)     Commentaddress(ulong addr,int typelist,
                                wchar_t *comment,int len);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// LOG WINDOW //////////////////////////////////

stdapi (void)    Redrawlist(void);
varapi (void)    Addtolist(ulong addr,int color,wchar_t *format,...);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// DUMP /////////////////////////////////////

#define DU_STACK       0x80000000      // Used for internal purposes
#define DU_NOSMALL     0x40000000      // Used for internal purposes
#define DU_MODEMASK    0x3C000000      // Mask for mode bits
#define   DU_SMALL     0x20000000      // Small-size dump
#define   DU_FIXADDR   0x10000000      // Fix first visible address
#define   DU_BACKUP    0x08000000      // Display backup instead of actual data
#define   DU_USEDEC    0x04000000      // Show contents using decoding data
#define DU_COMMMASK    0x03000000      // Mask for disassembly comments
#define   DU_COMMENT   0x00000000      // Show comments
#define   DU_SOURCE    0x01000000      // Show source
#define DU_DISCARD     0x00800000      // Discardable by Esc
#define DU_PROFILE     0x00400000      // Show profile
#define DU_TYPEMASK    0x003F0000      // Mask for dump type
#define   DU_HEXTEXT   0x00010000      // Hexadecimal dump with ASCII text
#define   DU_HEXUNI    0x00020000      // Hexadecimal dump with UNICODE text
#define   DU_TEXT      0x00030000      // Character dump
#define   DU_UNICODE   0x00040000      // Unicode dump
#define   DU_INT       0x00050000      // Integer signed dump
#define   DU_UINT      0x00060000      // Integer unsigned dump
#define   DU_IHEX      0x00070000      // Integer hexadecimal dump
#define   DU_FLOAT     0x00080000      // Floating-point dump
#define   DU_ADDR      0x00090000      // Address dump
#define   DU_ADRASC    0x000A0000      // Address dump with ASCII text
#define   DU_ADRUNI    0x000B0000      // Address dump with UNICODE text
#define   DU_DISASM    0x000C0000      // Disassembly
#define   DU_DECODE    0x000D0000      // Same as DU_DISASM but for decoded data
#define DU_COUNTMASK   0x0000FF00      // Mask for number of items/line
#define DU_SIZEMASK    0x000000FF      // Mask for size of single item

#define DU_MAINPART    (DU_TYPEMASK|DU_COUNTMASK|DU_SIZEMASK)

#define DUMP_HEXA8     0x00010801      // Hex/ASCII dump, 8 bytes per line
#define DUMP_HEXA16    0x00011001      // Hex/ASCII dump, 16 bytes per line
#define DUMP_HEXU8     0x00020801      // Hex/UNICODE dump, 8 bytes per line
#define DUMP_HEXU16    0x00021001      // Hex/UNICODE dump, 16 bytes per line
#define DUMP_ASC32     0x00032001      // ASCII dump, 32 characters per line
#define DUMP_ASC64     0x00034001      // ASCII dump, 64 characters per line
#define DUMP_UNI16     0x00041002      // UNICODE dump, 16 characters per line
#define DUMP_UNI32     0x00042002      // UNICODE dump, 32 characters per line
#define DUMP_UNI64     0x00044002      // UNICODE dump, 64 characters per line
#define DUMP_INT16     0x00050802      // 16-bit signed integer dump, 8 items
#define DUMP_INT16S    0x00050402      // 16-bit signed integer dump, 4 items
#define DUMP_INT32     0x00050404      // 32-bit signed integer dump, 4 items
#define DUMP_INT32S    0x00050204      // 32-bit signed integer dump, 2 items
#define DUMP_UINT16    0x00060802      // 16-bit unsigned integer dump, 8 items
#define DUMP_UINT16S   0x00060402      // 16-bit unsigned integer dump, 4 items
#define DUMP_UINT32    0x00060404      // 32-bit unsigned integer dump, 4 items
#define DUMP_UINT32S   0x00060204      // 32-bit unsigned integer dump, 2 items
#define DUMP_IHEX16    0x00070802      // 16-bit hex integer dump, 8 items
#define DUMP_IHEX16S   0x00070402      // 16-bit hex integer dump, 4 items
#define DUMP_IHEX32    0x00070404      // 32-bit hex integer dump, 4 items
#define DUMP_IHEX32S   0x00070204      // 32-bit hex integer dump, 2 items
#define DUMP_FLOAT32   0x00080404      // 32-bit floats, 4 items
#define DUMP_FLOAT32S  0x00080104      // 32-bit floats, 1 item
#define DUMP_FLOAT64   0x00080208      // 64-bit floats, 2 items
#define DUMP_FLOAT64S  0x00080108      // 64-bit floats, 1 item
#define DUMP_FLOAT80   0x0008010A      // 80-bit floats
#define DUMP_ADDR      0x00090104      // Address dump
#define DUMP_ADDRASC   0x000A0104      // Address dump with ASCII text
#define DUMP_ADDRUNI   0x000B0104      // Address dump with UNICODE text
#define DUMP_DISASM    0x000C0110      // Disassembly (max. 16 bytes per cmd)
#define DUMP_DECODE    0x000D0110      // Decoded data (max. 16 bytes per line)

// Types of dump menu in t_dump.menutype.
#define DMT_FIXTYPE    0x00000001      // Fixed dump type, no change
#define DMT_STRUCT     0x00000002      // Dump of the structure
#define DMT_CPUMASK    0x00070000      // Dump belongs to CPU window
#define   DMT_CPUDASM  0x00010000      // This is CPU Disassembler pane
#define   DMT_CPUDUMP  0x00020000      // This is CPU Dump pane
#define   DMT_CPUSTACK 0x00040000      // This is CPU Stack pane

// Modes of Scrolldumpwindow().
#define SD_REALIGN     0x01            // Realign on specified address
#define SD_CENTERY     0x02            // Center destination vertically

// Modes of t_dump.dumpselfunc() and Reportdumpselection().
#define SCH_SEL0       0x01            // t_dump.sel0 changed
#define SCH_SEL1       0x02            // t_dump.sel1 changed

// Modes of Copydumpselection().
#define CDS_TITLES     0x00000001      // Prepend window name and column titles
#define CDS_NOGRAPH    0x00000002      // Replace graphical symbols by spaces

typedef void DUMPSELFUNC(struct t_dump *,int);

typedef struct t_dump                  // Descriptor of dump data and window
{
    ulong          base;                 // Start of memory block or file
    ulong          size;                 // Size of memory block or file
    ulong          dumptype;             // Dump type, DU_xxx+count+size=DUMP_xxx
    ulong          menutype;             // Menu type, set of DMT_xxx
    ulong          itemwidth;            // Width of one item, characters
    ulong          threadid;             // Use decoding and registers if not 0
    t_table        table;                // Dump window is a custom table
    ulong          addr;                 // Address of first visible byte
    ulong          sel0;                 // Address of first selected byte
    ulong          sel1;                 // Last selected byte (not included!)
    ulong          selstart;             // Addr of first byte of selection start
    ulong          selend;               // Addr of first byte of selection end
    uchar          *filecopy;            // Copy of the file or NULL
    wchar_t        path[MAXPATH];        // Name of displayed file
    uchar          *backup;              // Old backup of memory/file or NULL
    wchar_t        strname[SHORTNAME];   // Name of the structure to decode
    uchar          *decode;              // Local decoding information or NULL
    wchar_t        bkpath[MAXPATH];      // Name of last used backup file
    int            relreg;               // Addresses relative to register
    ulong          reladdr;              // Addresses relative to this address
    ulong          hilitereg;            // One of OP_SOMEREG if reg highlighting
    int            hiregindex;           // Index of register to highlight
    ulong          graylimit;            // Gray data below this address
    DUMPSELFUNC    *dumpselfunc;         // Callback indicating change of sel0
} t_dump;

stdapi (void)    Setdumptype(t_dump *pd,ulong dumptype);
stdapi (int)     Ensurememorybackup(t_memory *pmem,int makebackup);
stdapi (void)    Backupusercode(struct t_module *pm,int force);
stdapi (HGLOBAL) Copydumpselection(t_dump *pd,int mode);
stdapi (ulong)   Dumpback(t_dump *pd,ulong addr,int n);
stdapi (ulong)   Dumpforward(t_dump *pd,ulong addr,int n);
stdapi (ulong)   Scrolldumpwindow(t_dump *pd,ulong addr,int mode);
stdapi (int)     Alignselection(t_dump *pd,ulong *sel0,ulong *sel1);
stdapi (int)     Getproclimits(ulong addr,ulong *amin,ulong *amax);
stdapi (int)     Getextproclimits(ulong addr,ulong *amin,ulong *amax);
stdapi (int)     Newdumpselection(t_dump *pd,ulong addr,ulong size);
stdapi (t_dump *) Findfiledump(wchar_t *path);
stdapi (HWND)    Createdumpwindow(wchar_t *title,ulong base,ulong size,
                                  wchar_t *path,ulong dumptype,ulong sel0,ulong sel1,
                                  wchar_t *strname);
stdapi (HWND)    Embeddumpwindow(HWND hw,t_dump *pd,ulong dumptype);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// SEARCH ////////////////////////////////////

// Layouts of search panel.
#define SL_UNDEF       0               // Undefined layout
#define SL_DISASM      1               // Commands or refs within one module
#define SL_SEQASM      2               // Sequences within one module
#define SL_STRINGS     3               // Referenced strings within one module
#define SL_GUIDS       4               // Referenced GUIDs within one module
#define SL_COMMENTS    5               // All user-defined comments
#define SL_SWITCHES    6               // Switches and cascaded IFs
#define SL_FLOATS      7               // Referenced floats within one module
#define SL_CALLS       8               // Intermodular calls
#define SL_MOD         9               // Modifications

// Search types.
#define SEARCH_NONE    0               // Type is not yet defined
#define SEARCH_CMD     1               // Search for assembler commands
#define SEARCH_SEQ     2               // Search for the sequence of commands
#define SEARCH_BINARY  3               // Search for binary code
#define SEARCH_CONST   4               // Search for referenced constant range
#define SEARCH_MOD     5               // Search for modifications

// Search directions.
#define SDIR_GLOBAL    0               // Search forward from the beginning
#define SDIR_FORWARD   1               // Search forward from selection
#define SDIR_BACKWARD  2               // Search backward from selection

// Search modes.
#define SRCH_NEW       0               // Ask for new search pattern
#define SRCH_NEWMEM    1               // Ask for new pattern, memory mode
#define SRCH_SAMEDIR   2               // Search in the specified direction
#define SRCH_OPPDIR    3               // Search in the opposite direction
#define SRCH_MEM       4               // Search forward, memory mode

// Mode bits in Comparesequence().
#define CSEQ_IGNORECMD 0x00000001      // Ignore non-influencing commands
#define CSEQ_ALLOWJMP  0x00000002      // Allow jumps from outside

typedef struct t_found                 // Search result
{
    ulong          addr;                 // Address of found item
    ulong          size;                 // Size of found item, or 0 on error
} t_found;

typedef struct t_search                // Descriptor of found item
{
    ulong          addr;                 // Address of found item
    ulong          size;                 // Must be 1
    ulong          type;                 // Type of found item, TY_xxx+SE_xxx
    ulong          data;                 // Mode-related data
    ulong          seqlen;               // Length of command sequence
} t_search;

stdapi (ulong)   Comparecommand(uchar *cmd,ulong cmdsize,ulong cmdip,
                                t_asmmod *model,int nmodel,int *pa,int *pb,t_disasm *da);
stdapi (ulong)   Comparesequence(uchar *cmd,ulong cmdsize,ulong cmdip,
                                 uchar *decode,t_asmmod *model,int nmodel,int mode,
                                 int *pa,int *pb,t_disasm *da,ulong *amatch,int namatch);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// PATCHES ////////////////////////////////////

#define PATCHSIZE      512             // Maximal patch size, bytes

typedef struct t_patch
{
    ulong          addr;                 // Base address of patch in memory
    ulong          size;                 // Size of patch, bytes
    ulong          type;                 // Type of patch, set of TY_xxx
    uchar          orig[PATCHSIZE];      // Original code
    uchar          mod[PATCHSIZE];       // Patched code
} t_patch;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// BREAKPOINTS //////////////////////////////////

// Actions that must be performed if breakpoint of type BP_ONESHOT or BP_TEMP
// is hit.
#define BA_PERMANENT   0x00000001      // Permanent INT3 BP_TEMP on system call
#define BA_PLUGIN      0x80000000      // Pass notification to plugin

typedef struct t_bpoint                // INT3 breakpoints
{
    ulong          addr;                 // Address of breakpoint
    ulong          size;                 // Must be 1
    ulong          type;                 // Type of breakpoint, TY_xxx+BP_xxx
    ushort         fnindex;              // Index of predefined function
    uchar          cmd;                  // First byte of original command
    uchar          patch;                // Used only in .udd files
    ulong          limit;                // Original pass count (0 if not set)
    ulong          count;                // Actual pass count
    ulong          actions;              // Actions, set of BA_xxx
} t_bpoint;

typedef struct t_bpmem                 // Memory breakpoints
{
    ulong          addr;                 // Address of breakpoint
    ulong          size;                 // Size of the breakpoint, bytes
    ulong          type;                 // Type of breakpoint, TY_xxx+BP_xxx
    ulong          limit;                // Original pass count (0 if not set)
    ulong          count;                // Actual pass count
} t_bpmem;

typedef struct t_bppage                // Pages with modified attributes
{
    ulong          base;                 // Base address of memory page
    ulong          size;                 // Always PAGESIZE
    ulong          type;                 // Set of TY_xxx+BP_ACCESSMASK
    ulong          oldaccess;            // Initial access
    ulong          newaccess;            // Modified (actual) access
} t_bppage;

typedef struct t_bphard                // Hardware breakpoints
{
    ulong          index;                // Index of the breakpoint (0..NHARD-1)
    ulong          dummy;                // Must be 1
    ulong          type;                 // Type of the breakpoint, TY_xxx+BP_xxx
    ulong          addr;                 // Address of breakpoint
    ulong          size;                 // Size of the breakpoint, bytes
    int            fnindex;              // Index of predefined function
    ulong          limit;                // Original pass count (0 if not set)
    ulong          count;                // Actual pass count
    ulong          actions;              // Actions, set of BA_xxx
    ulong          modbase;              // Module base, used by .udd only
    wchar_t        path[MAXPATH];        // Full module name, used by .udd only
} t_bphard;

stdapi (int)     Removeint3breakpoint(ulong addr,ulong type);
stdapi (int)     Setint3breakpoint(ulong addr,ulong type,int fnindex,
                                   int limit,int count,ulong actions,
                                   wchar_t *condition,wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enableint3breakpoint(ulong addr,int enable);
stdapi (int)     Confirmint3breakpoint(ulong addr);
stdapi (int)     Confirmhardwarebreakpoint(ulong addr);
stdapi (int)     Confirmint3breakpointlist(ulong *addr,int naddr);
stdapi (void)    Wipebreakpointrange(ulong addr0,ulong addr1);
stdapi (int)     Removemembreakpoint(ulong addr);
stdapi (int)     Setmembreakpoint(ulong addr,ulong size,ulong type,
                                  int limit,int count,wchar_t *condition,
                                  wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enablemembreakpoint(ulong addr,int enable);
stdapi (int)     Removehardbreakpoint(int index);
stdapi (int)     Sethardbreakpoint(int index,ulong size,ulong type,int fnindex,
                                   ulong addr,int limit,int count,ulong actions,
                                   wchar_t *condition,wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enablehardbreakpoint(int index,int enable);
stdapi (int)     Findfreehardbreakslot(ulong type);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// CPU //////////////////////////////////////

// Mode bits for Setcpu().
#define CPU_ASMHIST    0x00000001      // Add change to Disassembler history
#define CPU_ASMCENTER  0x00000004      // Make address in the middle of window
#define CPU_ASMFOCUS   0x00000008      // Move focus to Disassembler
#define CPU_DUMPHIST   0x00000010      // Add change to Dump history
#define CPU_DUMPFIRST  0x00000020      // Make address the first byte in Dump
#define CPU_DUMPFOCUS  0x00000080      // Move focus to Dump
#define CPU_STACKFOCUS 0x00000100      // Move focus to Stack
#define CPU_STACKCTR   0x00000200      // Center stack instead moving to top
#define CPU_REGAUTO    0x00001000      // Automatically switch to FPU/MMX/3DNow!
#define CPU_NOCREATE   0x00002000      // Don't create CPU window if absent
#define CPU_REDRAW     0x00004000      // Redraw CPU window immediately
#define CPU_NOFOCUS    0x00008000      // Don't assign focus to main window
#define CPU_RUNTRACE   0x00010000      // asmaddr is run trace backstep
#define CPU_NOTRACE    0x00020000      // Stop run trace display

// Options for autoregtype.
#define ASR_OFF        0               // No FPU/MMX/3DNow! autoselection
#define ASR_EVENT      1               // Autoselection on debug events
#define ASR_ALWAYS     2               // Autoselection when command selected

#define NHISTORY       1024            // Length of history buffer, records

typedef struct t_histrec               // Walk history record
{
    ulong          threadid;             // Thread ID, ignored by Dump pane
    ulong          dumptype;             // Dump type, ignored by Disasm pane
    ulong          addr;                 // Address of first visible line
    ulong          sel0;                 // Begin of selection
    ulong          sel1;                 // End of selection (not included)
} t_histrec;

// Note that hnext points to the free record following the last written, and
// hcurr points record that follows currently selected one.
typedef struct t_history               // Walk history data
{
    t_histrec      h[NHISTORY];          // Circular buffer with history records
    int            holdest;              // Index of oldest valid record in h
    int            hnext;                // Index of first free record in h
    int            hcurr;                // Index of record following actual in h
} t_history;

stdapi (void)    Redrawcpudisasm(void);
stdapi (void)    Redrawcpureg(void);
stdapi (ulong)   Getcputhreadid(void);
stdapi (int)     Getcpuruntracebackstep(void);
stdapi (t_dump *) Getcpudisasmdump(void);
stdapi (ulong)   Getcpudisasmselection(void);
stdapi (t_table *) Getcpudisasmtable(void);
stdapi (void)    Addtohistory(t_history *ph,ulong threadid,ulong dumptype,
                              ulong addr,ulong sel0,ulong sel1);
stdapi (int)     Walkhistory(t_history *ph,int dir,ulong *threadid,
                             ulong *dumptype,ulong *addr,ulong *sel0,ulong *sel1);
stdapi (int)     Checkhistory(t_history *ph,int dir,int *isnewest);
stdapi (void)    Setcpu(ulong threadid,ulong asmaddr,ulong dumpaddr,
                        ulong selsize,ulong stackaddr,int mode);


////////////////////////////////////////////////////////////////////////////////
/////////////////////// DEBUGGING AND TRACING FUNCTIONS ////////////////////////

#define NIGNORE        32              // Max. no. of ignored exception ranges
#define NRTPROT        64              // No. of protocolled address ranges

#define FP_SYSBP       0               // First pause on system breakpoint
#define FP_TLS         1               // First pause on TLS callback, if any
#define FP_ENTRY       2               // First pause on program entry point
#define FP_WINMAIN     3               // First pause on WinMain, if known
#define FP_NONE        4               // Run program immediately

#define AP_SYSBP       0               // Attach pause on system breakpoint
#define AP_CODE        1               // Attach pause on program code
#define AP_NONE        2               // Run attached program immediately

#define DP_LOADDLL     0               // Loaddll pause on Loaddll entry point
#define DP_ENTRY       1               // Loaddll pause on DllEntryPoint()
#define DP_LOADED      2               // Loaddll pause after LoadLibrary()
#define DP_NONE        3               // Run Loaddll immediately

#define DR6_SET        0xFFFF0FF0      // DR6 bits specified as always 1
#define DR6_TRAP       0x00004000      // Single-step trap
#define DR6_BD         0x00002000      // Debug register access detected
#define DR6_BHIT       0x0000000F      // Some hardware breakpoint hit
#define   DR6_B3       0x00000008      // Hardware breakpoint 3 hit
#define   DR6_B2       0x00000004      // Hardware breakpoint 2 hit
#define   DR6_B1       0x00000002      // Hardware breakpoint 1 hit
#define   DR6_B0       0x00000001      // Hardware breakpoint 0 hit

#define DR7_GD         0x00002000      // Enable debug register protection
#define DR7_SET        0x00000400      // DR7 bits specified as always 1
#define DR7_EXACT      0x00000100      // Local exact instruction detection
#define DR7_G3         0x00000080      // Enable breakpoint 3 globally
#define DR7_L3         0x00000040      // Enable breakpoint 3 locally
#define DR7_G2         0x00000020      // Enable breakpoint 2 globally
#define DR7_L2         0x00000010      // Enable breakpoint 2 locally
#define DR7_G1         0x00000008      // Enable breakpoint 1 globally
#define DR7_L1         0x00000004      // Enable breakpoint 1 locally
#define DR7_G0         0x00000002      // Enable breakpoint 0 globally
#define DR7_L0         0x00000001      // Enable breakpoint 0 locally

#define DR7_IMPORTANT  (DR7_G3|DR7_L3|DR7_G2|DR7_L2|DR7_G1|DR7_L1|DR7_G0|DR7_L0)

#define NCOND          4               // Number of run trace conditions
#define NRANGE         2               // Number of memory ranges
#define NCMD           2               // Number of commands
#define NMODLIST       24              // Number of modules in pause list

// Run trace condition bits.
#define RTC_COND1      0x00000001      // Stop run trace if condition 1 is met
#define RTC_COND2      0x00000002      // Stop run trace if condition 2 is met
#define RTC_COND3      0x00000004      // Stop run trace if condition 3 is met
#define RTC_COND4      0x00000008      // Stop run trace if condition 4 is met
#define RTC_CMD1       0x00000010      // Stop run trace if command 1 matches
#define RTC_CMD2       0x00000020      // Stop run trace if command 2 matches
#define RTC_INRANGE    0x00000100      // Stop run trace if in range
#define RTC_OUTRANGE   0x00000200      // Stop run trace if out of range
#define RTC_COUNT      0x00000400      // Stop run trace if count is reached
#define RTC_MEM1       0x00001000      // Access to memory range 1
#define RTC_MEM2       0x00002000      // Access to memory range 2
#define RTC_MODCMD     0x00008000      // Attempt to execute modified command

// Run trace protocol types.
#define RTL_ALL        0               // Log all commands
#define RTL_JUMPS      1               // Taken jmp/call/ret/int + destinations
#define RTL_CDEST      2               // Call destinations only
#define RTL_MEM        3               // Access to memory

// Hit trace outside the code section.
#define HTNC_RUN       0               // Continue trace the same way as code
#define HTNC_PAUSE     1               // Pause hit trace if outside the code
#define HTNC_TRACE     2               // Trace command by command (run trace)

// SFX extraction mode.
#define SFM_RUNTRACE   0               // Use run trace to extract SFX
#define SFM_HITTRACE   1               // Use hit trace to extract SFX

typedef struct t_rtcond                // Run trace break condition
{
    // These fields are saved to .udd data directly.
    int            options;              // Set of RTC_xxx
    ulong          inrange0;             // Start of in range
    ulong          inrange1;             // End of in range (not included)
    ulong          outrange0;            // Start of out range
    ulong          outrange1;            // End of out range (not included)
    ulong          count;                // Stop count
    ulong          currcount;            // Actual command count
    int            memaccess[NRANGE];    // Type of access (0:R, 1:W, 2:R/W)
    ulong          memrange0[NRANGE];    // Start of memory range
    ulong          memrange1[NRANGE];    // End of memory range
    // These fields are saved to .udd data truncated by first null.
    wchar_t        cond[NCOND][TEXTLEN]; // Conditions as text
    wchar_t        cmd[NCMD][TEXTLEN];   // Matching commands
    // These fields are not saved to .udd data.
    uchar          ccomp[NCOND][TEXTLEN];// Precompiled conditions
    int            validmodels;          // Valid command models, RTC_xxx
    t_asmmod       model[NCMD][NSEARCHCMD]; // Command search models
    int            nmodel[NCMD];         // Number of slots in each model
} t_rtcond;

typedef struct t_rtprot                // Run trace protocol condition
{
    int            tracelogtype;         // Commands to protocol, one of RTL_xxx
    int            memranges;            // 0x1: range 1, 0x2: range 2 active
    int            memaccess[NRANGE];    // Type of access (0:R, 1:W, 2:R/W)
    ulong          memrange0[NRANGE];    // Start of memory range
    ulong          memrange1[NRANGE];    // End of memory range
    int            rangeactive;          // Log only commands in the range
    t_range        range[NRTPROT];       // Set of EIP ranges to protocol
} t_rtprot;

stdapi (void)    Suspendallthreads(void);
stdapi (void)    Resumeallthreads(void);
stdapi (int)     Pauseprocess(void);
stdapi (int)     Closeprocess(int confirm);
stdapi (int)     Detachprocess(void);
stdapi (int)     Getlasterror(t_thread *pthr,ulong *error,wchar_t *s);
stdapi (ulong)   Followcall(ulong addr);
stdapi (int)     Run(t_status status,int pass);
stdapi (int)     Checkfordebugevent(void);
stdapi (int)     Addprotocolrange(ulong addr0,ulong addr1);
stdapi (int)     Getruntrace(int nback,t_reg *preg,uchar *cmd);
stdapi (int)     Findruntracerecord(ulong addr0,ulong addr1);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// LIST OF GUIDS /////////////////////////////////

#define GUIDSIZE       16              // GUID size, bytes

stdapi (int)     Getguidname(uchar *data,ulong ndata,wchar_t *name);
stdapi (int)     Isguid(ulong addr,wchar_t *name,int nname);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SOURCE CODE //////////////////////////////////

typedef struct t_srcline               // Descriptor of source line
{
    ulong          offset;               // Offset in source text
    int            nextent;              // Number of code extents (-1: unknown)
    int            extent;               // Index of first extent (nextent>0)
} t_srcline;

typedef struct t_srcext                // Descriptor of code extent
{
    ulong          amin;                 // Address of the first command
    ulong          amax;                 // Address of last command, included
} t_srcext;

typedef struct t_source                // Descriptor of source file
{
    ulong          addr;                 // Module base plus file index
    ulong          size;                 // Dummy parameter, must be 1
    ulong          type;                 // Type, TY_xxx+SRC_xxx
    wchar_t        path[MAXPATH];        // File path
    int            nameoffs;             // Name offset in path, characters
    char           *text;                // Source code in UTF-8 format or NULL
    t_srcline      *line;                // nline+1 line descriptors or NULL
    int            nline;                // Number of lines (0: as yet unknown)
    t_srcext       *extent;              // List of code extents
    int            maxextent;            // Capacity of extent table
    int            nextent;              // Current number of extents
    int            lastline;             // Last selected line
    int            lastoffset;           // Last topmost visible line
} t_source;

stdapi (t_source *) Findsource(ulong base,wchar_t *path);
stdapi (int)     Getsourceline(ulong base,wchar_t *path,int line,int skipspaces,
                               wchar_t *text,wchar_t *fname,t_srcext **extent,int *nextent);
stdapi (int)     Showsourcecode(ulong base,wchar_t *path,int line);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// DEBUGGEE ///////////////////////////////////

// Types of exception in application.
#define AE_NONE        0               // No exception, or caused by OllyDbg
#define AE_APP         1               // Exception in the application
#define AE_SYS         2               // System exception, don't pass

typedef struct t_run                   // Run status of debugged application
{
    t_status       status;               // Operation mode, one of STAT_xxx
    ulong          threadid;             // ID of single running thread, 0 if all
    ulong          tpausing;             // Tick count when pausing was requested
    int            wakestep;             // 0: wait, 1: waked, 2: warned
    ulong          eip;                  // EIP at last debugging event
    ulong          ecx;                  // ECX at last debugging event
    ulong          restoreint3addr;      // Address of temporarily removed INT3
    ulong          stepoverdest;         // Destination of STAT_STEPOVER
    int            updatebppage;         // Update temporarily removed bppage's
    DEBUG_EVENT    de;                   // Information from WaitForDebugEvent()
    int            indebugevent;         // Paused on event, threads suspended
    int            netevent;             // Event is from .NET debugger
    int            isappexception;       // Exception in application, AE_xxx
    ulong          lastexception;        // Last exception in application or 0
    int            suspended;            // Suspension counter
    int            suspendonpause;       // Whether first suspension on pause
    int            updatedebugreg;       // 1: set, -1: reset HW breakpoints
    int            dregmodified;         // Debug regs modified by application
} t_run;


////////////////////////////////////////////////////////////////////////////////
//////////// OLLYDBG VARIABLES AND STRUCTURES ACCESSIBLE BY PLUGINS ////////////

// ATTENTION, never, ever change these variables directly! Either use plugin
// API or keep your hands off! Names of variables are preceded with underscore.

///////////////////////////////// DISASSEMBLER /////////////////////////////////

oddata (t_bincmd) bincmd[];            // List of 80x86 commands

oddata (wchar_t *) regname[3][NREG];   // Names of 8/16/32-bit registers
oddata (wchar_t *) segname[NREG];      // Names of segment registers
oddata (wchar_t *) fpuname[2][NREG];   // FPU regs (ST(n) and STn forms)
oddata (wchar_t *) mmxname[NREG];      // Names of MMX/3DNow! registers
oddata (wchar_t *) ssename[NREG];      // Names of SSE registers
oddata (wchar_t *) crname[NREG];       // Names of control registers
oddata (wchar_t *) drname[NREG];       // Names of debug registers
oddata (wchar_t *) sizename[17];       // Data size keywords
oddata (wchar_t *) sizekey[17];        // Keywords for immediate data
oddata (wchar_t *) sizeatt[17];        // Keywords for immediate data, AT&T

/////////////////////////////// OLLYDBG SETTINGS ///////////////////////////////

oddata (wchar_t) ollyfile[MAXPATH];    // Path to OllyDbg
oddata (wchar_t) ollydir[MAXPATH];     // OllyDbg directory w/o backslash
oddata (wchar_t) systemdir[MAXPATH];   // Windows system directory
oddata (wchar_t) plugindir[MAXPATH];   // Plugin data dir without backslash

oddata (HINSTANCE) hollyinst;          // Current OllyDbg instance
oddata (HWND)    hwollymain;           // Handle of the main OllyDbg window
oddata (HWND)    hwclient;             // Handle of MDI client or NULL
oddata (wchar_t) ottable[SHORTNAME];   // Class of table windows
oddata (ulong)   cpufeatures;          // CPUID feature information
oddata (int)     ischild;              // Whether child debugger

oddata (int)     asciicodepage;        // Code page to display ASCII dumps
#ifdef FILE                            // Requires <stdio.h>
oddata (FILE *)  tracefile;            // System log file or NULL
#endif
oddata (int)     restorewinpos;        // Restore window position & appearance

////////////////////////////// OLLYDBG STRUCTURES //////////////////////////////

oddata (t_font)  font[NFIXFONTS];      // Fixed fonts used in table windows
oddata (t_font)  sysfont;              // Proportional system font
oddata (t_font)  titlefont;            // Proportional, 2x height of sysfont
oddata (t_font)  fixfont;              // Fixed system font
oddata (COLORREF) color[NCOLORS];      // Colours used by OllyDbg
oddata (t_scheme) scheme[NSCHEMES];    // Colour schemes used in table windows
oddata (t_scheme) hilite[NHILITE];     // Colour schemes used for highlighting

/////////////////////////////////// DEBUGGEE ///////////////////////////////////

oddata (wchar_t) executable[MAXPATH];  // Path to main (.exe) file
oddata (wchar_t) arguments[ARGLEN];    // Command line passed to debuggee

oddata (int)     netdbg;               // .NET debugging active
oddata (int)     rundll;               // Debugged file is a DLL
oddata (HANDLE)  process;              // Handle of Debuggee or NULL
oddata (ulong)   processid;            // Process ID of Debuggee or 0
oddata (ulong)   mainthreadid;         // Thread ID of main thread or 0
oddata (t_run)   run;                  // Run status of debugged application
oddata (int)     skipsystembp;         // First system INT3 not yet hit

oddata (ulong)   debugbreak;           // Address of DebugBreak() in Debuggee
oddata (ulong)   dbgbreakpoint;        // Address of DbgBreakPoint() in Debuggee
oddata (ulong)   kiuserexcept;         // Address of KiUserExceptionDispatcher()
oddata (ulong)   zwcontinue;           // Address of ZwContinue() in Debuggee
oddata (ulong)   uefilter;             // Address of UnhandledExceptionFilter()
oddata (ulong)   ntqueryinfo;          // Address of NtQueryInformationProcess()
oddata (ulong)   corexemain;           // Address of MSCOREE:_CorExeMain()
oddata (ulong)   peblock;              // Address of PE block in Debuggee
oddata (ulong)   kusershareddata;      // Address of KUSER_SHARED_DATA
oddata (ulong)   userspacelimit;       // Size of virtual process memory

oddata (t_rtcond) rtcond;              // Run trace break condition
oddata (t_rtprot) rtprot;              // Run trace protocol condition

///////////////////////////////// DATA TABLES //////////////////////////////////

oddata (t_table) list;                 // List descriptor
oddata (t_sorted) premod;              // Preliminary module data
oddata (t_table) module;               // Loaded modules
oddata (t_sorted) aqueue;              // Modules that are not yet analysed
oddata (t_table) thread;               // Active threads
oddata (t_table) memory;               // Allocated memory blocks
oddata (t_table) win;                  // List of windows
oddata (t_table) bpoint;               // INT3 breakpoints
oddata (t_table) bpmem;                // Memory breakpoints
oddata (t_sorted) bppage;              // Memory pages with changed attributes
oddata (t_table) bphard;               // Hardware breakpoints
oddata (t_table) watch;                // Watch expressions
oddata (t_table) patch;                // List of patches from previous runs
oddata (t_sorted) procdata;            // Descriptions of analyzed procedures
oddata (t_table) source;               // List of source files
oddata (t_table) srccode;              // Source code


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PLUGIN EXPORTS ////////////////////////////////

// Relatively infrequent events passed to ODBG2_Pluginnotify().
#define PN_NEWPROC     1               // New process is created
#define PN_ENDPROC     2               // Process is terminated
#define PN_NEWTHR      3               // New thread is created
#define PN_ENDTHR      4               // Thread is terminated
#define PN_PREMOD      5               // New module is reported by Windows
#define PN_NEWMOD      6               // New module is added to the table
#define PN_ENDMOD      7               // Module is removed from the memory
#define PN_STATUS      8               // Execution status has changed
#define PN_REMOVE      16              // OllyDbg removes analysis from range
#define PN_RUN         24              // User continues code execution

// Flags returned by ODBG2_Pluginexception().
#define PE_IGNORED     0x00000000      // Plugin does not process exception
#define PE_CONTINUE    0x00000001      // Exception by plugin, continue
#define PE_STEP        0x00000002      // Exception by plugin, execute command
#define PE_PAUSE       0x00000004      // Exception by plugin, pause program

pentry (int)         ODBG2_Pluginquery(int ollydbgversion,ulong *features,
                                       wchar_t pluginname[SHORTNAME],
                                       wchar_t pluginversion[SHORTNAME]);
pentry (int)         ODBG2_Plugininit(void);
pentry (void)        ODBG2_Pluginanalyse(t_module *pmod);
pentry (void)        ODBG2_Pluginmainloop(DEBUG_EVENT *debugevent);
pentry (int)         ODBG2_Pluginexception(t_run *prun,const t_disasm *da,
        t_thread *pthr,t_reg *preg,wchar_t *message);
pentry (void)        ODBG2_Plugintempbreakpoint(ulong addr,
        const t_disasm *da,t_thread *pthr,t_reg *preg);
pentry (void)        ODBG2_Pluginnotify(int code,void *data,
                                        ulong parm1,ulong parm2);
pentry (int)         ODBG2_Plugindump(t_dump *pd,wchar_t *s,uchar *mask,
                                      int n,int *select,ulong addr,int column);
pentry (t_menu *)    ODBG2_Pluginmenu(wchar_t *type);
pentry (t_control *) ODBG2_Pluginoptions(UINT msg,WPARAM wp,LPARAM lp);
pentry (void)        ODBG2_Pluginsaveudd(t_uddsave *psave,t_module *pmod,
        int ismainmodule);
pentry (void)        ODBG2_Pluginuddrecord(t_module *pmod,int ismainmodule,
        ulong tag,ulong size,void *data);
pentry (void)        ODBG2_Pluginreset(void);
pentry (int)         ODBG2_Pluginclose(void);
pentry (void)        ODBG2_Plugindestroy(void);

#endif                                 // __ODBG_PLUGIN_H




================================================
File: 3rdparty/titan/TitanEngine.h
================================================
#ifndef TITANENGINE
#define TITANENGINE

#define TITCALL

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>

#pragma pack(push, 1)

// Global.Constant.Structure.Declaration:
// Engine.External:
#define UE_STRUCT_PE32STRUCT 1
#define UE_STRUCT_PE64STRUCT 2
#define UE_STRUCT_PESTRUCT 3
#define UE_STRUCT_IMPORTENUMDATA 4
#define UE_STRUCT_THREAD_ITEM_DATA 5
#define UE_STRUCT_LIBRARY_ITEM_DATA 6
#define UE_STRUCT_LIBRARY_ITEM_DATAW 7
#define UE_STRUCT_PROCESS_ITEM_DATA 8
#define UE_STRUCT_HANDLERARRAY 9
#define UE_STRUCT_PLUGININFORMATION 10
#define UE_STRUCT_HOOK_ENTRY 11
#define UE_STRUCT_FILE_STATUS_INFO 12
#define UE_STRUCT_FILE_FIX_INFO 13

#define UE_ACCESS_READ 0
#define UE_ACCESS_WRITE 1
#define UE_ACCESS_ALL 2

#define UE_HIDE_PEBONLY 0
#define UE_HIDE_BASIC 1

#define UE_PLUGIN_CALL_REASON_PREDEBUG 1
#define UE_PLUGIN_CALL_REASON_EXCEPTION 2
#define UE_PLUGIN_CALL_REASON_POSTDEBUG 3
#define UE_PLUGIN_CALL_REASON_UNHANDLEDEXCEPTION 4

#define TEE_HOOK_NRM_JUMP 1
#define TEE_HOOK_NRM_CALL 3
#define TEE_HOOK_IAT 5

#define UE_ENGINE_ALOW_MODULE_LOADING 1
#define UE_ENGINE_AUTOFIX_FORWARDERS 2
#define UE_ENGINE_PASS_ALL_EXCEPTIONS 3
#define UE_ENGINE_NO_CONSOLE_WINDOW 4
#define UE_ENGINE_BACKUP_FOR_CRITICAL_FUNCTIONS 5
#define UE_ENGINE_CALL_PLUGIN_CALLBACK 6
#define UE_ENGINE_RESET_CUSTOM_HANDLER 7
#define UE_ENGINE_CALL_PLUGIN_DEBUG_CALLBACK 8

#define UE_OPTION_REMOVEALL 1
#define UE_OPTION_DISABLEALL 2
#define UE_OPTION_REMOVEALLDISABLED 3
#define UE_OPTION_REMOVEALLENABLED 4

#define UE_STATIC_DECRYPTOR_XOR 1
#define UE_STATIC_DECRYPTOR_SUB 2
#define UE_STATIC_DECRYPTOR_ADD 3

#define UE_STATIC_DECRYPTOR_FOREWARD 1
#define UE_STATIC_DECRYPTOR_BACKWARD 2

#define UE_STATIC_KEY_SIZE_1 1
#define UE_STATIC_KEY_SIZE_2 2
#define UE_STATIC_KEY_SIZE_4 4
#define UE_STATIC_KEY_SIZE_8 8

#define UE_STATIC_APLIB 1
#define UE_STATIC_APLIB_DEPACK 2
#define UE_STATIC_LZMA 3

#define UE_STATIC_HASH_MD5 1
#define UE_STATIC_HASH_SHA1 2
#define UE_STATIC_HASH_CRC32 3

#define UE_RESOURCE_LANGUAGE_ANY -1

#define UE_PE_OFFSET 0
#define UE_IMAGEBASE 1
#define UE_OEP 2
#define UE_SIZEOFIMAGE 3
#define UE_SIZEOFHEADERS 4
#define UE_SIZEOFOPTIONALHEADER 5
#define UE_SECTIONALIGNMENT 6
#define UE_IMPORTTABLEADDRESS 7
#define UE_IMPORTTABLESIZE 8
#define UE_RESOURCETABLEADDRESS 9
#define UE_RESOURCETABLESIZE 10
#define UE_EXPORTTABLEADDRESS 11
#define UE_EXPORTTABLESIZE 12
#define UE_TLSTABLEADDRESS 13
#define UE_TLSTABLESIZE 14
#define UE_RELOCATIONTABLEADDRESS 15
#define UE_RELOCATIONTABLESIZE 16
#define UE_TIMEDATESTAMP 17
#define UE_SECTIONNUMBER 18
#define UE_CHECKSUM 19
#define UE_SUBSYSTEM 20
#define UE_CHARACTERISTICS 21
#define UE_NUMBEROFRVAANDSIZES 22
#define UE_BASEOFCODE 23
#define UE_BASEOFDATA 24
//leaving some enum space here for future additions
#define UE_SECTIONNAME 40
#define UE_SECTIONVIRTUALOFFSET 41
#define UE_SECTIONVIRTUALSIZE 42
#define UE_SECTIONRAWOFFSET 43
#define UE_SECTIONRAWSIZE 44
#define UE_SECTIONFLAGS 45

#define UE_VANOTFOUND = -2;

#define UE_CH_BREAKPOINT 1
#define UE_CH_SINGLESTEP 2
#define UE_CH_ACCESSVIOLATION 3
#define UE_CH_ILLEGALINSTRUCTION 4
#define UE_CH_NONCONTINUABLEEXCEPTION 5
#define UE_CH_ARRAYBOUNDSEXCEPTION 6
#define UE_CH_FLOATDENORMALOPERAND 7
#define UE_CH_FLOATDEVIDEBYZERO 8
#define UE_CH_INTEGERDEVIDEBYZERO 9
#define UE_CH_INTEGEROVERFLOW 10
#define UE_CH_PRIVILEGEDINSTRUCTION 11
#define UE_CH_PAGEGUARD 12
#define UE_CH_EVERYTHINGELSE 13
#define UE_CH_CREATETHREAD 14
#define UE_CH_EXITTHREAD 15
#define UE_CH_CREATEPROCESS 16
#define UE_CH_EXITPROCESS 17
#define UE_CH_LOADDLL 18
#define UE_CH_UNLOADDLL 19
#define UE_CH_OUTPUTDEBUGSTRING 20
#define UE_CH_AFTEREXCEPTIONPROCESSING 21
#define UE_CH_ALLEVENTS 22
#define UE_CH_SYSTEMBREAKPOINT 23
#define UE_CH_UNHANDLEDEXCEPTION 24
#define UE_CH_RIPEVENT 25

#define UE_OPTION_HANDLER_RETURN_HANDLECOUNT 1
#define UE_OPTION_HANDLER_RETURN_ACCESS 2
#define UE_OPTION_HANDLER_RETURN_FLAGS 3
#define UE_OPTION_HANDLER_RETURN_TYPENAME 4

#define UE_BREAKPOINT_INT3 1
#define UE_BREAKPOINT_LONG_INT3 2
#define UE_BREAKPOINT_UD2 3

#define UE_BPXREMOVED 0
#define UE_BPXACTIVE 1
#define UE_BPXINACTIVE 2

#define UE_BREAKPOINT 0
#define UE_SINGLESHOOT 1
#define UE_HARDWARE 2
#define UE_MEMORY 3
#define UE_MEMORY_READ 4
#define UE_MEMORY_WRITE 5
#define UE_MEMORY_EXECUTE 6
#define UE_BREAKPOINT_TYPE_INT3 0x10000000
#define UE_BREAKPOINT_TYPE_LONG_INT3 0x20000000
#define UE_BREAKPOINT_TYPE_UD2 0x30000000

#define UE_HARDWARE_EXECUTE 4
#define UE_HARDWARE_WRITE 5
#define UE_HARDWARE_READWRITE 6

#define UE_HARDWARE_SIZE_1 7
#define UE_HARDWARE_SIZE_2 8
#define UE_HARDWARE_SIZE_4 9
#define UE_HARDWARE_SIZE_8 10

#define UE_ON_LIB_LOAD 1
#define UE_ON_LIB_UNLOAD 2
#define UE_ON_LIB_ALL 3

#define UE_APISTART 0
#define UE_APIEND 1

#define UE_PLATFORM_x86 1
#define UE_PLATFORM_x64 2
#define UE_PLATFORM_ALL 3

#define UE_FUNCTION_STDCALL 1
#define UE_FUNCTION_CCALL 2
#define UE_FUNCTION_FASTCALL 3
#define UE_FUNCTION_STDCALL_RET 4
#define UE_FUNCTION_CCALL_RET 5
#define UE_FUNCTION_FASTCALL_RET 6
#define UE_FUNCTION_STDCALL_CALL 7
#define UE_FUNCTION_CCALL_CALL 8
#define UE_FUNCTION_FASTCALL_CALL 9
#define UE_PARAMETER_BYTE 0
#define UE_PARAMETER_WORD 1
#define UE_PARAMETER_DWORD 2
#define UE_PARAMETER_QWORD 3
#define UE_PARAMETER_PTR_BYTE 4
#define UE_PARAMETER_PTR_WORD 5
#define UE_PARAMETER_PTR_DWORD 6
#define UE_PARAMETER_PTR_QWORD 7
#define UE_PARAMETER_STRING 8
#define UE_PARAMETER_UNICODE 9

#define UE_EAX 1
#define UE_EBX 2
#define UE_ECX 3
#define UE_EDX 4
#define UE_EDI 5
#define UE_ESI 6
#define UE_EBP 7
#define UE_ESP 8
#define UE_EIP 9
#define UE_EFLAGS 10
#define UE_DR0 11
#define UE_DR1 12
#define UE_DR2 13
#define UE_DR3 14
#define UE_DR6 15
#define UE_DR7 16
#define UE_RAX 17
#define UE_RBX 18
#define UE_RCX 19
#define UE_RDX 20
#define UE_RDI 21
#define UE_RSI 22
#define UE_RBP 23
#define UE_RSP 24
#define UE_RIP 25
#define UE_RFLAGS 26
#define UE_R8 27
#define UE_R9 28
#define UE_R10 29
#define UE_R11 30
#define UE_R12 31
#define UE_R13 32
#define UE_R14 33
#define UE_R15 34
#define UE_CIP 35
#define UE_CSP 36
#ifdef _WIN64
#define UE_CFLAGS UE_RFLAGS
#else
#define UE_CFLAGS UE_EFLAGS
#endif
#define UE_SEG_GS 37
#define UE_SEG_FS 38
#define UE_SEG_ES 39
#define UE_SEG_DS 40
#define UE_SEG_CS 41
#define UE_SEG_SS 42

typedef struct
{
    DWORD PE32Offset;
    DWORD ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE32Struct, *PPE32Struct;

typedef struct
{
    DWORD PE64Offset;
    DWORD64 ImageBase;
    DWORD OriginalEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD NtSizeOfImage;
    DWORD NtSizeOfHeaders;
    WORD SizeOfOptionalHeaders;
    DWORD FileAlignment;
    DWORD SectionAligment;
    DWORD ImportTableAddress;
    DWORD ImportTableSize;
    DWORD ResourceTableAddress;
    DWORD ResourceTableSize;
    DWORD ExportTableAddress;
    DWORD ExportTableSize;
    DWORD TLSTableAddress;
    DWORD TLSTableSize;
    DWORD RelocationTableAddress;
    DWORD RelocationTableSize;
    DWORD TimeDateStamp;
    WORD SectionNumber;
    DWORD CheckSum;
    WORD SubSystem;
    WORD Characteristics;
    DWORD NumberOfRvaAndSizes;
} PE64Struct, *PPE64Struct;

#if defined(_WIN64)
typedef PE64Struct PEStruct;
#else
typedef PE32Struct PEStruct;
#endif

typedef struct
{
    bool NewDll;
    int NumberOfImports;
    ULONG_PTR ImageBase;
    ULONG_PTR BaseImportThunk;
    ULONG_PTR ImportThunk;
    char* APIName;
    char* DLLName;
} ImportEnumData, *PImportEnumData;

typedef struct
{
    HANDLE hThread;
    DWORD dwThreadId;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
    void* TebAddress;
    ULONG WaitTime;
    LONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} THREAD_ITEM_DATA, *PTHREAD_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    char szLibraryPath[MAX_PATH];
    char szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATA, *PLIBRARY_ITEM_DATA;

typedef struct
{
    HANDLE hFile;
    void* BaseOfDll;
    HANDLE hFileMapping;
    void* hFileMappingView;
    wchar_t szLibraryPath[MAX_PATH];
    wchar_t szLibraryName[MAX_PATH];
} LIBRARY_ITEM_DATAW, *PLIBRARY_ITEM_DATAW;

typedef struct
{
    HANDLE hProcess;
    DWORD dwProcessId;
    HANDLE hThread;
    DWORD dwThreadId;
    HANDLE hFile;
    void* BaseOfImage;
    void* ThreadStartAddress;
    void* ThreadLocalBase;
} PROCESS_ITEM_DATA, *PPROCESS_ITEM_DATA;

typedef struct
{
    ULONG ProcessId;
    HANDLE hHandle;
} HandlerArray, *PHandlerArray;

typedef struct
{
    char PluginName[64];
    DWORD PluginMajorVersion;
    DWORD PluginMinorVersion;
    HMODULE PluginBaseAddress;
    void* TitanDebuggingCallBack;
    void* TitanRegisterPlugin;
    void* TitanReleasePlugin;
    void* TitanResetPlugin;
    bool PluginDisabled;
} PluginInformation, *PPluginInformation;

#define TEE_MAXIMUM_HOOK_SIZE 14
#define TEE_MAXIMUM_HOOK_RELOCS 7
#if defined(_WIN64)
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 14
#else
#define TEE_MAXIMUM_HOOK_INSERT_SIZE 5
#endif

typedef struct HOOK_ENTRY
{
    bool IATHook;
    BYTE HookType;
    DWORD HookSize;
    void* HookAddress;
    void* RedirectionAddress;
    BYTE HookBytes[TEE_MAXIMUM_HOOK_SIZE];
    BYTE OriginalBytes[TEE_MAXIMUM_HOOK_SIZE];
    void* IATHookModuleBase;
    DWORD IATHookNameHash;
    bool HookIsEnabled;
    bool HookIsRemote;
    void* PatchedEntry;
    DWORD RelocationInfo[TEE_MAXIMUM_HOOK_RELOCS];
    int RelocationCount;
} HOOK_ENTRY, *PHOOK_ENTRY;

#define UE_DEPTH_SURFACE 0
#define UE_DEPTH_DEEP 1

#define UE_UNPACKER_CONDITION_SEARCH_FROM_EP 1

#define UE_UNPACKER_CONDITION_LOADLIBRARY 1
#define UE_UNPACKER_CONDITION_GETPROCADDRESS 2
#define UE_UNPACKER_CONDITION_ENTRYPOINTBREAK 3
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT1 4
#define UE_UNPACKER_CONDITION_RELOCSNAPSHOT2 5

#define UE_FIELD_OK 0
#define UE_FIELD_BROKEN_NON_FIXABLE 1
#define UE_FIELD_BROKEN_NON_CRITICAL 2
#define UE_FIELD_BROKEN_FIXABLE_FOR_STATIC_USE 3
#define UE_FIELD_BROKEN_BUT_CAN_BE_EMULATED 4
#define UE_FIELD_FIXABLE_NON_CRITICAL 5
#define UE_FIELD_FIXABLE_CRITICAL 6
#define UE_FIELD_NOT_PRESET 7
#define UE_FIELD_NOT_PRESET_WARNING 8

#define UE_RESULT_FILE_OK 10
#define UE_RESULT_FILE_INVALID_BUT_FIXABLE 11
#define UE_RESULT_FILE_INVALID_AND_NON_FIXABLE 12
#define UE_RESULT_FILE_INVALID_FORMAT 13

typedef struct
{
    BYTE OveralEvaluation;
    bool EvaluationTerminatedByException;
    bool FileIs64Bit;
    bool FileIsDLL;
    bool FileIsConsole;
    bool MissingDependencies;
    bool MissingDeclaredAPIs;
    BYTE SignatureMZ;
    BYTE SignaturePE;
    BYTE EntryPoint;
    BYTE ImageBase;
    BYTE SizeOfImage;
    BYTE FileAlignment;
    BYTE SectionAlignment;
    BYTE ExportTable;
    BYTE RelocationTable;
    BYTE ImportTable;
    BYTE ImportTableSection;
    BYTE ImportTableData;
    BYTE IATTable;
    BYTE TLSTable;
    BYTE LoadConfigTable;
    BYTE BoundImportTable;
    BYTE COMHeaderTable;
    BYTE ResourceTable;
    BYTE ResourceData;
    BYTE SectionTable;
} FILE_STATUS_INFO, *PFILE_STATUS_INFO;

typedef struct
{
    BYTE OveralEvaluation;
    bool FixingTerminatedByException;
    bool FileFixPerformed;
    bool StrippedRelocation;
    bool DontFixRelocations;
    DWORD OriginalRelocationTableAddress;
    DWORD OriginalRelocationTableSize;
    bool StrippedExports;
    bool DontFixExports;
    DWORD OriginalExportTableAddress;
    DWORD OriginalExportTableSize;
    bool StrippedResources;
    bool DontFixResources;
    DWORD OriginalResourceTableAddress;
    DWORD OriginalResourceTableSize;
    bool StrippedTLS;
    bool DontFixTLS;
    DWORD OriginalTLSTableAddress;
    DWORD OriginalTLSTableSize;
    bool StrippedLoadConfig;
    bool DontFixLoadConfig;
    DWORD OriginalLoadConfigTableAddress;
    DWORD OriginalLoadConfigTableSize;
    bool StrippedBoundImports;
    bool DontFixBoundImports;
    DWORD OriginalBoundImportTableAddress;
    DWORD OriginalBoundImportTableSize;
    bool StrippedIAT;
    bool DontFixIAT;
    DWORD OriginalImportAddressTableAddress;
    DWORD OriginalImportAddressTableSize;
    bool StrippedCOM;
    bool DontFixCOM;
    DWORD OriginalCOMTableAddress;
    DWORD OriginalCOMTableSize;
} FILE_FIX_INFO, *PFILE_FIX_INFO;

#ifdef __cplusplus
extern "C"
{
#endif

// Global.Function.Declaration:
// TitanEngine.Dumper.functions:
__declspec(dllexport) bool TITCALL DumpProcess(HANDLE hProcess, LPVOID ImageBase, char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessW(HANDLE hProcess, LPVOID ImageBase, wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessEx(DWORD ProcessId, LPVOID ImageBase, char* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpProcessExW(DWORD ProcessId, LPVOID ImageBase, wchar_t* szDumpFileName, ULONG_PTR EntryPoint);
__declspec(dllexport) bool TITCALL DumpMemory(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryW(HANDLE hProcess, LPVOID MemoryStart, ULONG_PTR MemorySize, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryEx(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpMemoryExW(DWORD ProcessId, LPVOID MemoryStart, ULONG_PTR MemorySize, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpRegions(HANDLE hProcess, char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsW(HANDLE hProcess, wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsEx(DWORD ProcessId, char* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpRegionsExW(DWORD ProcessId, wchar_t* szDumpFolder, bool DumpAboveImageBaseOnly);
__declspec(dllexport) bool TITCALL DumpModule(HANDLE hProcess, LPVOID ModuleBase, char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleW(HANDLE hProcess, LPVOID ModuleBase, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleEx(DWORD ProcessId, LPVOID ModuleBase, char* szDumpFileName);
__declspec(dllexport) bool TITCALL DumpModuleExW(DWORD ProcessId, LPVOID ModuleBase, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL PastePEHeader(HANDLE hProcess, LPVOID ImageBase, char* szDebuggedFileName);
__declspec(dllexport) bool TITCALL PastePEHeaderW(HANDLE hProcess, LPVOID ImageBase, wchar_t* szDebuggedFileName);
__declspec(dllexport) bool TITCALL ExtractSection(char* szFileName, char* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ExtractSectionW(wchar_t* szFileName, wchar_t* szDumpFileName, DWORD SectionNumber);
__declspec(dllexport) bool TITCALL ResortFileSections(char* szFileName);
__declspec(dllexport) bool TITCALL ResortFileSectionsW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL FindOverlay(char* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL FindOverlayW(wchar_t* szFileName, LPDWORD OverlayStart, LPDWORD OverlaySize);
__declspec(dllexport) bool TITCALL ExtractOverlay(char* szFileName, char* szExtactedFileName);
__declspec(dllexport) bool TITCALL ExtractOverlayW(wchar_t* szFileName, wchar_t* szExtactedFileName);
__declspec(dllexport) bool TITCALL AddOverlay(char* szFileName, char* szOverlayFileName);
__declspec(dllexport) bool TITCALL AddOverlayW(wchar_t* szFileName, wchar_t* szOverlayFileName);
__declspec(dllexport) bool TITCALL CopyOverlay(char* szInFileName, char* szOutFileName);
__declspec(dllexport) bool TITCALL CopyOverlayW(wchar_t* szInFileName, wchar_t* szOutFileName);
__declspec(dllexport) bool TITCALL RemoveOverlay(char* szFileName);
__declspec(dllexport) bool TITCALL RemoveOverlayW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWE(char* szFileName);
__declspec(dllexport) bool TITCALL MakeAllSectionsRWEW(wchar_t* szFileName);
__declspec(dllexport) long TITCALL AddNewSectionEx(char* szFileName, char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSectionExW(wchar_t* szFileName, char* szSectionName, DWORD SectionSize, DWORD SectionAttributes, LPVOID SectionContent, DWORD ContentSize);
__declspec(dllexport) long TITCALL AddNewSection(char* szFileName, char* szSectionName, DWORD SectionSize);
__declspec(dllexport) long TITCALL AddNewSectionW(wchar_t* szFileName, char* szSectionName, DWORD SectionSize);
__declspec(dllexport) bool TITCALL ResizeLastSection(char* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) bool TITCALL ResizeLastSectionW(wchar_t* szFileName, DWORD NumberOfExpandBytes, bool AlignResizeData);
__declspec(dllexport) void TITCALL SetSharedOverlay(char* szFileName);
__declspec(dllexport) void TITCALL SetSharedOverlayW(wchar_t* szFileName);
__declspec(dllexport) char* TITCALL GetSharedOverlay();
__declspec(dllexport) wchar_t* TITCALL GetSharedOverlayW();
__declspec(dllexport) bool TITCALL DeleteLastSection(char* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL DeleteLastSectionEx(char* szFileName, DWORD NumberOfSections);
__declspec(dllexport) bool TITCALL DeleteLastSectionExW(wchar_t* szFileName, DWORD NumberOfSections);
__declspec(dllexport) long long TITCALL GetPE32DataFromMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) long long TITCALL GetPE32Data(char* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) long long TITCALL GetPE32DataW(wchar_t* szFileName, DWORD WhichSection, DWORD WhichData);
__declspec(dllexport) bool TITCALL GetPE32DataFromMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataEx(char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL GetPE32DataExW(wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFile(ULONG_PTR FileMapVA, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32Data(char* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataW(wchar_t* szFileName, DWORD WhichSection, DWORD WhichData, ULONG_PTR NewDataValue);
__declspec(dllexport) bool TITCALL SetPE32DataForMappedFileEx(ULONG_PTR FileMapVA, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataEx(char* szFileName, LPVOID DataStorage);
__declspec(dllexport) bool TITCALL SetPE32DataExW(wchar_t* szFileName, LPVOID DataStorage);
__declspec(dllexport) long TITCALL GetPE32SectionNumberFromVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert);
__declspec(dllexport) long long TITCALL ConvertVAtoFileOffset(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) long long TITCALL ConvertVAtoFileOffsetEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool AddressIsRVA, bool ReturnType);
__declspec(dllexport) long long TITCALL ConvertFileOffsetToVA(ULONG_PTR FileMapVA, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) long long TITCALL ConvertFileOffsetToVAEx(ULONG_PTR FileMapVA, DWORD FileSize, ULONG_PTR ImageBase, ULONG_PTR AddressToConvert, bool ReturnType);
__declspec(dllexport) bool TITCALL MemoryReadSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T * lpNumberOfBytesRead);
__declspec(dllexport) bool TITCALL MemoryWriteSafe(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T * lpNumberOfBytesWritten);
// TitanEngine.Realigner.functions:
__declspec(dllexport) bool TITCALL FixHeaderCheckSum(char* szFileName);
__declspec(dllexport) bool TITCALL FixHeaderCheckSumW(wchar_t* szFileName);
__declspec(dllexport) long TITCALL RealignPE(ULONG_PTR FileMapVA, DWORD FileSize, DWORD RealingMode);
__declspec(dllexport) long TITCALL RealignPEEx(char* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) long TITCALL RealignPEExW(wchar_t* szFileName, DWORD RealingFileSize, DWORD ForcedFileAlignment);
__declspec(dllexport) bool TITCALL WipeSection(char* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL WipeSectionW(wchar_t* szFileName, int WipeSectionNumber, bool RemovePhysically);
__declspec(dllexport) bool TITCALL IsPE32FileValidEx(char* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL IsPE32FileValidExW(wchar_t* szFileName, DWORD CheckDepth, LPVOID FileStatusInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileEx(char* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL FixBrokenPE32FileExW(wchar_t* szFileName, LPVOID FileStatusInfo, LPVOID FileFixInfo);
__declspec(dllexport) bool TITCALL IsFileDLL(char* szFileName, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL IsFileDLLW(wchar_t* szFileName, ULONG_PTR FileMapVA);
// TitanEngine.Hider.functions:
__declspec(dllexport) void* TITCALL GetPEBLocation(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetPEBLocation64(HANDLE hProcess);
__declspec(dllexport) void* TITCALL GetTEBLocation(HANDLE hThread);
__declspec(dllexport) void* TITCALL GetTEBLocation64(HANDLE hThread);
__declspec(dllexport) bool TITCALL HideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
__declspec(dllexport) bool TITCALL UnHideDebugger(HANDLE hProcess, DWORD PatchAPILevel);
// TitanEngine.Relocater.functions:
__declspec(dllexport) void TITCALL RelocaterCleanup();
__declspec(dllexport) void TITCALL RelocaterInit(DWORD MemorySize, ULONG_PTR OldImageBase, ULONG_PTR NewImageBase);
__declspec(dllexport) void TITCALL RelocaterAddNewRelocation(HANDLE hProcess, ULONG_PTR RelocateAddress, DWORD RelocateState);
__declspec(dllexport) long TITCALL RelocaterEstimatedSize();
__declspec(dllexport) bool TITCALL RelocaterExportRelocation(ULONG_PTR StorePlace, DWORD StorePlaceRVA, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationEx(char* szFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterExportRelocationExW(wchar_t* szFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTable(HANDLE hProcess, ULONG_PTR MemoryStart, DWORD MemorySize);
__declspec(dllexport) bool TITCALL RelocaterGrabRelocationTableEx(HANDLE hProcess, ULONG_PTR MemoryStart, ULONG_PTR MemorySize, DWORD NtSizeOfImage);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshot(HANDLE hProcess, char* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterMakeSnapshotW(HANDLE hProcess, wchar_t* szSaveFileName, LPVOID MemoryStart, ULONG_PTR MemorySize);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshots(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, char* szDumpFile1, char* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterCompareTwoSnapshotsW(HANDLE hProcess, ULONG_PTR LoadedImageBase, ULONG_PTR NtSizeOfImage, wchar_t* szDumpFile1, wchar_t* szDumpFile2, ULONG_PTR MemStart);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBase(char* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterChangeFileBaseW(wchar_t* szFileName, ULONG_PTR NewImageBase);
__declspec(dllexport) bool TITCALL RelocaterRelocateMemoryBlock(ULONG_PTR FileMapVA, ULONG_PTR MemoryLocation, void* RelocateMemory, DWORD RelocateMemorySize, ULONG_PTR CurrentLoadedBase, ULONG_PTR RelocateBase);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTable(char* szFileName);
__declspec(dllexport) bool TITCALL RelocaterWipeRelocationTableW(wchar_t* szFileName);
// TitanEngine.Resourcer.functions:
__declspec(dllexport) long long TITCALL ResourcerLoadFileForResourceUse(char* szFileName);
__declspec(dllexport) long long TITCALL ResourcerLoadFileForResourceUseW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ResourcerFreeLoadedFile(LPVOID LoadedFileBase);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileEx(ULONG_PTR FileMapVA, char* szResourceType, char* szResourceName, char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFile(char* szFileName, char* szResourceType, char* szResourceName, char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerExtractResourceFromFileW(wchar_t* szFileName, char* szResourceType, char* szResourceName, char* szExtractedFileName);
__declspec(dllexport) bool TITCALL ResourcerFindResource(char* szFileName, char* szResourceType, DWORD ResourceType, char* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceW(wchar_t* szFileName, wchar_t* szResourceType, DWORD ResourceType, wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) bool TITCALL ResourcerFindResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, wchar_t* szResourceType, DWORD ResourceType, wchar_t* szResourceName, DWORD ResourceName, DWORD ResourceLanguage, PULONG_PTR pResourceData, LPDWORD pResourceSize);
__declspec(dllexport) void TITCALL ResourcerEnumerateResource(char* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceW(wchar_t* szFileName, void* CallBack);
__declspec(dllexport) void TITCALL ResourcerEnumerateResourceEx(ULONG_PTR FileMapVA, DWORD FileSize, void* CallBack);
// TitanEngine.Threader.functions:
__declspec(dllexport) bool TITCALL ThreaderImportRunningThreadData(DWORD ProcessId);
__declspec(dllexport) void* TITCALL ThreaderGetThreadInfo(HANDLE hThread, DWORD ThreadId);
__declspec(dllexport) void TITCALL ThreaderEnumThreadInfo(void* EnumCallBack);
__declspec(dllexport) bool TITCALL ThreaderPauseThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderResumeThread(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderTerminateThread(HANDLE hThread, DWORD ThreadExitCode);
__declspec(dllexport) bool TITCALL ThreaderPauseAllThreads(bool LeaveMainRunning);
__declspec(dllexport) bool TITCALL ThreaderResumeAllThreads(bool LeaveMainPaused);
__declspec(dllexport) bool TITCALL ThreaderPauseProcess();
__declspec(dllexport) bool TITCALL ThreaderResumeProcess();
__declspec(dllexport) long long TITCALL ThreaderCreateRemoteThread(ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCode(LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) long long TITCALL ThreaderCreateRemoteThreadEx(HANDLE hProcess, ULONG_PTR ThreadStartAddress, bool AutoCloseTheHandle, LPVOID ThreadPassParameter, LPDWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderInjectAndExecuteCodeEx(HANDLE hProcess, LPVOID InjectCode, DWORD StartDelta, DWORD InjectSize);
__declspec(dllexport) void TITCALL ThreaderSetCallBackForNextExitThreadEvent(LPVOID exitThreadCallBack);
__declspec(dllexport) bool TITCALL ThreaderIsThreadStillRunning(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsThreadActive(HANDLE hThread);
__declspec(dllexport) bool TITCALL ThreaderIsAnyThreadActive();
__declspec(dllexport) bool TITCALL ThreaderExecuteOnlyInjectedThreads();
__declspec(dllexport) long long TITCALL ThreaderGetOpenHandleForThread(DWORD ThreadId);
__declspec(dllexport) bool TITCALL ThreaderIsExceptionInMainThread();
// TitanEngine.Debugger.functions:
__declspec(dllexport) void* TITCALL StaticDisassembleEx(ULONG_PTR DisassmStart, LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL StaticDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL DisassembleEx(HANDLE hProcess, LPVOID DisassmAddress, bool ReturnInstructionType);
__declspec(dllexport) void* TITCALL Disassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL StaticLengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassembleEx(HANDLE hProcess, LPVOID DisassmAddress);
__declspec(dllexport) long TITCALL LengthDisassemble(LPVOID DisassmAddress);
__declspec(dllexport) void* TITCALL InitDebug(char* szFileName, char* szCommandLine, char* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugW(wchar_t* szFileName, wchar_t* szCommandLine, wchar_t* szCurrentFolder);
__declspec(dllexport) void* TITCALL InitDebugEx(char* szFileName, char* szCommandLine, char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDebugExW(wchar_t* szFileName, wchar_t* szCommandLine, wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebug(char* szFileName, bool ReserveModuleBase, char* szCommandLine, char* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) void* TITCALL InitDLLDebugW(wchar_t* szFileName, bool ReserveModuleBase, wchar_t* szCommandLine, wchar_t* szCurrentFolder, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL StopDebug();
__declspec(dllexport) void TITCALL SetBPXOptions(long DefaultBreakPointType);
__declspec(dllexport) bool TITCALL IsBPXEnabled(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL EnableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL DisableBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetBPX(ULONG_PTR bpxAddress, DWORD bpxType, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SafeDeleteBPX(ULONG_PTR bpxAddress);
__declspec(dllexport) bool TITCALL SetAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxType, DWORD bpxPlace, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SafeDeleteAPIBreakPoint(const char* szDLLName, const char* szAPIName, DWORD bpxPlace);
__declspec(dllexport) bool TITCALL SetMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL SetMemoryBPXEx(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory, DWORD BreakPointType, bool RestoreOnHit, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL RemoveMemoryBPX(ULONG_PTR MemoryStart, SIZE_T SizeOfMemory);
__declspec(dllexport) bool TITCALL GetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) long long TITCALL GetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister);
__declspec(dllexport) long long TITCALL GetContextData(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL SetContextFPUDataEx(HANDLE hActiveThread, void* FPUSaveArea);
__declspec(dllexport) bool TITCALL SetContextDataEx(HANDLE hActiveThread, DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) bool TITCALL SetContextData(DWORD IndexOfRegister, ULONG_PTR NewRegisterValue);
__declspec(dllexport) void TITCALL ClearExceptionNumber();
__declspec(dllexport) long TITCALL CurrentExceptionNumber();
__declspec(dllexport) bool TITCALL MatchPatternEx(HANDLE hProcess, void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) bool TITCALL MatchPattern(void* MemoryToCheck, int SizeOfMemoryToCheck, void* PatternToMatch, int SizeOfPatternToMatch, PBYTE WildCard);
__declspec(dllexport) long long TITCALL FindEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
extern "C" __declspec(dllexport) long long TITCALL Find(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, LPBYTE WildCard);
__declspec(dllexport) bool TITCALL FillEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL Fill(LPVOID MemoryStart, DWORD MemorySize, PBYTE FillByte);
__declspec(dllexport) bool TITCALL PatchEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL Patch(LPVOID MemoryStart, DWORD MemorySize, LPVOID ReplacePattern, DWORD ReplaceSize, bool AppendNOP, bool PrependNOP);
__declspec(dllexport) bool TITCALL ReplaceEx(HANDLE hProcess, LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) bool TITCALL Replace(LPVOID MemoryStart, DWORD MemorySize, LPVOID SearchPattern, DWORD PatternSize, DWORD NumberOfRepetitions, LPVOID ReplacePattern, DWORD ReplaceSize, PBYTE WildCard);
__declspec(dllexport) void* TITCALL GetDebugData();
__declspec(dllexport) void* TITCALL GetTerminationData();
__declspec(dllexport) long TITCALL GetExitCode();
__declspec(dllexport) long long TITCALL GetDebuggedDLLBaseAddress();
__declspec(dllexport) unsigned long long TITCALL GetDebuggedFileBaseAddress();
__declspec(dllexport) bool TITCALL GetRemoteString(HANDLE hProcess, LPVOID StringAddress, LPVOID StringStorage, int MaximumStringSize);
__declspec(dllexport) long long TITCALL GetFunctionParameter(HANDLE hProcess, DWORD FunctionType, DWORD ParameterNumber, DWORD ParameterType);
__declspec(dllexport) long long TITCALL GetJumpDestinationEx(HANDLE hProcess, ULONG_PTR InstructionAddress, bool JustJumps);
__declspec(dllexport) long long TITCALL GetJumpDestination(HANDLE hProcess, ULONG_PTR InstructionAddress);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecuteEx(HANDLE hProcess, HANDLE hThread, ULONG_PTR InstructionAddress, ULONG_PTR RegFlags);
__declspec(dllexport) bool TITCALL IsJumpGoingToExecute();
__declspec(dllexport) void TITCALL SetCustomHandler(DWORD ExceptionId, LPVOID CallBack);
__declspec(dllexport) void TITCALL ForceClose();
__declspec(dllexport) void TITCALL StepInto(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOver(LPVOID traceCallBack);
__declspec(dllexport) void TITCALL StepOut(LPVOID StepOut, bool StepFinal);
__declspec(dllexport) void TITCALL SingleStep(DWORD StepCount, LPVOID StepCallBack);
__declspec(dllexport) bool TITCALL GetUnusedHardwareBreakPointRegister(LPDWORD RegisterIndex);
__declspec(dllexport) bool TITCALL SetHardwareBreakPointEx(HANDLE hActiveThread, ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack, LPDWORD IndexOfSelectedRegister);
__declspec(dllexport) bool TITCALL SetHardwareBreakPoint(ULONG_PTR bpxAddress, DWORD IndexOfRegister, DWORD bpxType, DWORD bpxSize, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL DeleteHardwareBreakPoint(DWORD IndexOfRegister);
__declspec(dllexport) bool TITCALL RemoveAllBreakPoints(DWORD RemoveOption);
__declspec(dllexport) void* TITCALL GetProcessInformation();
__declspec(dllexport) void* TITCALL GetStartupInformation();
__declspec(dllexport) void TITCALL DebugLoop();
__declspec(dllexport) void TITCALL SetDebugLoopTimeOut(DWORD TimeOut);
__declspec(dllexport) void TITCALL SetNextDbgContinueStatus(DWORD SetDbgCode);
__declspec(dllexport) bool TITCALL AttachDebugger(DWORD ProcessId, bool KillOnExit, LPVOID DebugInfo, LPVOID CallBack);
__declspec(dllexport) bool TITCALL DetachDebugger(DWORD ProcessId);
__declspec(dllexport) bool TITCALL DetachDebuggerEx(DWORD ProcessId);
__declspec(dllexport) void TITCALL DebugLoopEx(DWORD TimeOut);
__declspec(dllexport) void TITCALL AutoDebugEx(char* szFileName, bool ReserveModuleBase, char* szCommandLine, char* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) void TITCALL AutoDebugExW(wchar_t* szFileName, bool ReserveModuleBase, wchar_t* szCommandLine, wchar_t* szCurrentFolder, DWORD TimeOut, LPVOID EntryCallBack);
__declspec(dllexport) bool TITCALL IsFileBeingDebugged();
__declspec(dllexport) void TITCALL SetErrorModel(bool DisplayErrorMessages);
// TitanEngine.FindOEP.functions:
__declspec(dllexport) void TITCALL FindOEPInit();
__declspec(dllexport) bool TITCALL FindOEPGenerically(char* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
__declspec(dllexport) bool TITCALL FindOEPGenericallyW(wchar_t* szFileName, LPVOID TraceInitCallBack, LPVOID CallBack);
// TitanEngine.Importer.functions:
__declspec(dllexport) void TITCALL ImporterAddNewDll(char* szDLLName, ULONG_PTR FirstThunk);
__declspec(dllexport) void TITCALL ImporterAddNewAPI(char* szAPIName, ULONG_PTR ThunkValue);
__declspec(dllexport) void TITCALL ImporterAddNewOrdinalAPI(ULONG_PTR OrdinalNumber, ULONG_PTR ThunkValue);
__declspec(dllexport) long TITCALL ImporterGetAddedDllCount();
__declspec(dllexport) long TITCALL ImporterGetAddedAPICount();
__declspec(dllexport) bool TITCALL ImporterExportIAT(ULONG_PTR StorePlace, ULONG_PTR FileMapVA, HANDLE hFileMap);
__declspec(dllexport) long TITCALL ImporterEstimatedSize();
__declspec(dllexport) bool TITCALL ImporterExportIATEx(char* szDumpFileName, char* szExportFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterExportIATExW(wchar_t* szDumpFileName, wchar_t* szExportFileName, wchar_t* szSectionName = L".RL!TEv2");
__declspec(dllexport) long long TITCALL ImporterFindAPIWriteLocation(char* szAPIName);
__declspec(dllexport) long long TITCALL ImporterFindOrdinalAPIWriteLocation(ULONG_PTR OrdinalNumber);
__declspec(dllexport) long long TITCALL ImporterFindAPIByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) long long TITCALL ImporterFindDLLByWriteLocation(ULONG_PTR APIWriteLocation);
__declspec(dllexport) void* TITCALL ImporterGetDLLName(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameW(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPIName(ULONG_PTR APIAddress);
__declspec(dllexport) long long TITCALL ImporterGetAPIOrdinalNumber(ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long long TITCALL ImporterGetRemoteAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long long TITCALL ImporterGetRemoteAPIAddressEx(char* szDLLName, char* szAPIName);
__declspec(dllexport) long long TITCALL ImporterGetLocalAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetDLLNameFromDebugeeW(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetAPINameFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long long TITCALL ImporterGetAPIOrdinalNumberFromDebugee(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetDLLIndexEx(ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long TITCALL ImporterGetDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long long TITCALL ImporterGetRemoteDLLBase(HANDLE hProcess, HMODULE LocalModuleBase);
__declspec(dllexport) long long TITCALL ImporterGetRemoteDLLBaseEx(HANDLE hProcess, char* szModuleName);
__declspec(dllexport) void* TITCALL ImporterGetRemoteDLLBaseExW(HANDLE hProcess, wchar_t* szModuleName);
__declspec(dllexport) bool TITCALL ImporterIsForwardedAPI(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetForwardedDLLName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long TITCALL ImporterGetForwardedDLLIndex(HANDLE hProcess, ULONG_PTR APIAddress, ULONG_PTR DLLBasesList);
__declspec(dllexport) long long TITCALL ImporterGetForwardedAPIOrdinalNumber(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) long long TITCALL ImporterGetNearestAPIAddress(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) void* TITCALL ImporterGetNearestAPIName(HANDLE hProcess, ULONG_PTR APIAddress);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIAT(char* szOriginalFile, char* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterCopyOriginalIATW(wchar_t* szOriginalFile, wchar_t* szDumpFile);
__declspec(dllexport) bool TITCALL ImporterLoadImportTable(char* szFileName);
__declspec(dllexport) bool TITCALL ImporterLoadImportTableW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIAT(char* szOriginalFile, char* szDumpFile, char* szSectionName);
__declspec(dllexport) bool TITCALL ImporterMoveOriginalIATW(wchar_t* szOriginalFile, wchar_t* szDumpFile, char* szSectionName);
__declspec(dllexport) void TITCALL ImporterAutoSearchIAT(DWORD ProcessId, char* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATW(DWORD ProcessIds, wchar_t* szFileName, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterAutoSearchIATEx(DWORD ProcessId, ULONG_PTR ImageBase, ULONG_PTR SearchStart, LPVOID pIATStart, LPVOID pIATSize);
__declspec(dllexport) void TITCALL ImporterEnumAddedData(LPVOID EnumCallBack);
__declspec(dllexport) long TITCALL ImporterAutoFixIATEx(DWORD ProcessId, char* szDumpedFile, char* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart, bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIATExW(DWORD ProcessId, wchar_t* szDumpedFile, wchar_t* szSectionName, bool DumpRunningProcess, bool RealignFile, ULONG_PTR EntryPointAddress, ULONG_PTR ImageBase, ULONG_PTR SearchStart,  bool TryAutoFix, bool FixEliminations, LPVOID UnknownPointerFixCallback);
__declspec(dllexport) long TITCALL ImporterAutoFixIAT(DWORD ProcessId, char* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) long TITCALL ImporterAutoFixIATW(DWORD ProcessId, wchar_t* szDumpedFile, ULONG_PTR SearchStart);
__declspec(dllexport) bool TITCALL ImporterDeleteAPI(DWORD_PTR apiAddr);
// Global.Engine.Hook.functions:
__declspec(dllexport) bool TITCALL HooksSafeTransitionEx(LPVOID HookAddressArray, int NumberOfHooks, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksSafeTransition(LPVOID HookAddress, bool TransitionStart);
__declspec(dllexport) bool TITCALL HooksIsAddressRedirected(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetTrampolineAddress(LPVOID HookAddress);
__declspec(dllexport) void* TITCALL HooksGetHookEntryDetails(LPVOID HookAddress);
__declspec(dllexport) bool TITCALL HooksInsertNewRedirection(LPVOID HookAddress, LPVOID RedirectTo, int HookType);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirectionEx(ULONG_PTR FileMapVA, ULONG_PTR LoadedModuleBase, char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksInsertNewIATRedirection(char* szModuleName, char* szHookFunction, LPVOID RedirectTo);
__declspec(dllexport) bool TITCALL HooksRemoveRedirection(LPVOID HookAddress, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksRemoveRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksRemoveIATRedirection(char* szModuleName, char* szHookFunction, bool RemoveAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirection(LPVOID HookAddress, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksDisableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksDisableIATRedirection(char* szModuleName, char* szHookFunction, bool DisableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirection(LPVOID HookAddress, bool EnableAll);
__declspec(dllexport) bool TITCALL HooksEnableRedirectionsForModule(HMODULE ModuleBase);
__declspec(dllexport) bool TITCALL HooksEnableIATRedirection(char* szModuleName, char* szHookFunction, bool EnableAll);
__declspec(dllexport) void TITCALL HooksScanModuleMemory(HMODULE ModuleBase, LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemory(LPVOID CallBack);
__declspec(dllexport) void TITCALL HooksScanEntireProcessMemoryEx();
// TitanEngine.Tracer.functions:
__declspec(dllexport) void TITCALL TracerInit();
__declspec(dllexport) long long TITCALL TracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) long long TITCALL HashTracerLevel1(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD InputNumberOfInstructions);
__declspec(dllexport) long TITCALL TracerDetectRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace);
__declspec(dllexport) long long TITCALL TracerFixKnownRedirection(HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD RedirectionId);
__declspec(dllexport) long long TITCALL TracerFixRedirectionViaModule(HMODULE hModuleHandle, HANDLE hProcess, ULONG_PTR AddressToTrace, DWORD IdParameter);
__declspec(dllexport) long TITCALL TracerFixRedirectionViaImpRecPlugin(HANDLE hProcess, char* szPluginName, ULONG_PTR AddressToTrace);
// TitanEngine.Exporter.functions:
__declspec(dllexport) void TITCALL ExporterCleanup();
__declspec(dllexport) void TITCALL ExporterSetImageBase(ULONG_PTR ImageBase);
__declspec(dllexport) void TITCALL ExporterInit(DWORD MemorySize, ULONG_PTR ImageBase, DWORD ExportOrdinalBase, char* szExportModuleName);
__declspec(dllexport) bool TITCALL ExporterAddNewExport(char* szExportName, DWORD ExportRelativeAddress);
__declspec(dllexport) bool TITCALL ExporterAddNewOrdinalExport(DWORD OrdinalNumber, DWORD ExportRelativeAddress);
__declspec(dllexport) long TITCALL ExporterGetAddedExportCount();
__declspec(dllexport) long TITCALL ExporterEstimatedSize();
__declspec(dllexport) bool TITCALL ExporterBuildExportTable(ULONG_PTR StorePlace, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableEx(char* szExportFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterBuildExportTableExW(wchar_t* szExportFileName, char* szSectionName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTable(char* szFileName);
__declspec(dllexport) bool TITCALL ExporterLoadExportTableW(wchar_t* szFileName);
// TitanEngine.Librarian.functions:
__declspec(dllexport) bool TITCALL LibrarianSetBreakPoint(char* szLibraryName, DWORD bpxType, bool SingleShoot, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL LibrarianRemoveBreakPoint(char* szLibraryName, DWORD bpxType);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfo(char* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoW(wchar_t* szLibraryName);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoEx(void* BaseOfDll);
__declspec(dllexport) void* TITCALL LibrarianGetLibraryInfoExW(void* BaseOfDll);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfo(void* EnumCallBack);
__declspec(dllexport) void TITCALL LibrarianEnumLibraryInfoW(void* EnumCallBack);
// TitanEngine.Process.functions:
__declspec(dllexport) long TITCALL GetActiveProcessId(char* szImageName);
__declspec(dllexport) long TITCALL GetActiveProcessIdW(wchar_t* szImageName);
__declspec(dllexport) void TITCALL EnumProcessesWithLibrary(char* szLibraryName, void* EnumFunction);
// TitanEngine.TLSFixer.functions:
__declspec(dllexport) bool TITCALL TLSBreakOnCallBack(LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSGrabCallBackData(char* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSGrabCallBackDataW(wchar_t* szFileName, LPVOID ArrayOfCallBacks, LPDWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackEx(char* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSBreakOnCallBackExW(wchar_t* szFileName, LPVOID bpxCallBack);
__declspec(dllexport) bool TITCALL TLSRemoveCallback(char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveCallbackW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTable(char* szFileName);
__declspec(dllexport) bool TITCALL TLSRemoveTableW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupData(char* szFileName);
__declspec(dllexport) bool TITCALL TLSBackupDataW(wchar_t* szFileName);
__declspec(dllexport) bool TITCALL TLSRestoreData();
__declspec(dllexport) bool TITCALL TLSBuildNewTable(ULONG_PTR FileMapVA, ULONG_PTR StorePlace, ULONG_PTR StorePlaceRVA, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableEx(char* szFileName, char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
__declspec(dllexport) bool TITCALL TLSBuildNewTableExW(wchar_t* szFileName, char* szSectionName, LPVOID ArrayOfCallBacks, DWORD NumberOfCallBacks);
// TitanEngine.TranslateName.functions:
__declspec(dllexport) void* TITCALL TranslateNativeName(char* szNativeName);
__declspec(dllexport) void* TITCALL TranslateNativeNameW(wchar_t* szNativeName);
// TitanEngine.Handler.functions:
__declspec(dllexport) long TITCALL HandlerGetActiveHandleCount(DWORD ProcessId);
__declspec(dllexport) bool TITCALL HandlerIsHandleOpen(DWORD ProcessId, HANDLE hHandle);
__declspec(dllexport) void* TITCALL HandlerGetHandleName(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) void* TITCALL HandlerGetHandleNameW(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, bool TranslateName);
__declspec(dllexport) long TITCALL HandlerEnumerateOpenHandles(DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long long TITCALL HandlerGetHandleDetails(HANDLE hProcess, DWORD ProcessId, HANDLE hHandle, DWORD InformationReturn);
__declspec(dllexport) bool TITCALL HandlerCloseRemoteHandle(HANDLE hProcess, HANDLE hHandle);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long TITCALL HandlerEnumerateLockHandlesW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated, LPVOID HandleDataBuffer, DWORD MaxHandleCount);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandles(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerCloseAllLockHandlesW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLocked(char* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
__declspec(dllexport) bool TITCALL HandlerIsFileLockedW(wchar_t* szFileOrFolderName, bool NameIsFolder, bool NameIsTranslated);
// TitanEngine.Handler[Mutex].functions:
__declspec(dllexport) long TITCALL HandlerEnumerateOpenMutexes(HANDLE hProcess, DWORD ProcessId, LPVOID HandleBuffer, DWORD MaxHandleCount);
__declspec(dllexport) long long TITCALL HandlerGetOpenMutexHandle(HANDLE hProcess, DWORD ProcessId, char* szMutexString);
__declspec(dllexport) long long TITCALL HandlerGetOpenMutexHandleW(HANDLE hProcess, DWORD ProcessId, wchar_t* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutex(char* szMutexString);
__declspec(dllexport) long TITCALL HandlerGetProcessIdWhichCreatedMutexW(wchar_t* szMutexString);
// TitanEngine.Injector.functions:
__declspec(dllexport) bool TITCALL RemoteLoadLibrary(HANDLE hProcess, char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteLoadLibraryW(HANDLE hProcess, wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule, char* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteFreeLibraryW(HANDLE hProcess, HMODULE hModule, wchar_t* szLibraryFile, bool WaitForThreadExit);
__declspec(dllexport) bool TITCALL RemoteExitProcess(HANDLE hProcess, DWORD ExitCode);
// TitanEngine.StaticUnpacker.functions:
__declspec(dllexport) bool TITCALL StaticFileLoad(char* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileLoadW(wchar_t* szFileName, DWORD DesiredAccess, bool SimulateLoad, LPHANDLE FileHandle, LPDWORD LoadedSize, LPHANDLE FileMap, PULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnload(char* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileUnloadW(wchar_t* szFileName, bool CommitChanges, HANDLE FileHandle, DWORD LoadedSize, HANDLE FileMap, ULONG_PTR FileMapVA);
__declspec(dllexport) bool TITCALL StaticFileOpen(char* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileOpenW(wchar_t* szFileName, DWORD DesiredAccess, LPHANDLE FileHandle, LPDWORD FileSizeLow, LPDWORD FileSizeHigh);
__declspec(dllexport) bool TITCALL StaticFileGetContent(HANDLE FileHandle, DWORD FilePositionLow, LPDWORD FilePositionHigh, void* Buffer, DWORD Size);
__declspec(dllexport) void TITCALL StaticFileClose(HANDLE FileHandle);
__declspec(dllexport) void TITCALL StaticMemoryDecrypt(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) void TITCALL StaticMemoryDecryptEx(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticMemoryDecryptSpecial(LPVOID MemoryStart, DWORD MemorySize, DWORD DecryptionKeySize, DWORD SpecDecryptionType, void* DecryptionCallBack);
__declspec(dllexport) void TITCALL StaticSectionDecrypt(ULONG_PTR FileMapVA, DWORD SectionNumber, bool SimulateLoad, DWORD DecryptionType, DWORD DecryptionKeySize, ULONG_PTR DecryptionKey);
__declspec(dllexport) bool TITCALL StaticMemoryDecompress(void* Source, DWORD SourceSize, void* Destination, DWORD DestinationSize, int Algorithm);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopy(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyW(HANDLE hFile, ULONG_PTR FileMapVA, ULONG_PTR VitualAddressToCopy, DWORD Size, bool AddressIsRVA, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyExW(HANDLE hFile, DWORD RawAddressToCopy, DWORD Size, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, char* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticRawMemoryCopyEx64W(HANDLE hFile, DWORD64 RawAddressToCopy, DWORD64 Size, wchar_t* szDumpFileName);
__declspec(dllexport) bool TITCALL StaticHashMemory(void* MemoryToHash, DWORD SizeOfMemory, void* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFileW(wchar_t* szFileName, char* HashDigest, bool OutputString, int Algorithm);
__declspec(dllexport) bool TITCALL StaticHashFile(char* szFileName, char* HashDigest, bool OutputString, int Algorithm);
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL EngineUnpackerInitialize(char* szFileName, char* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) void TITCALL EngineUnpackerInitializeW(wchar_t* szFileName, wchar_t* szUnpackedFileName, bool DoLogData, bool DoRealignFile, bool DoMoveOverlay, void* EntryCallBack);
__declspec(dllexport) bool TITCALL EngineUnpackerSetBreakCondition(void* SearchStart, DWORD SearchSize, void* SearchPattern, DWORD PatternSize, DWORD PatternDelta, ULONG_PTR BreakType, bool SingleBreak, DWORD Parameter1, DWORD Parameter2);
__declspec(dllexport) void TITCALL EngineUnpackerSetEntryPointAddress(ULONG_PTR UnpackedEntryPointAddress);
__declspec(dllexport) void TITCALL EngineUnpackerFinalizeUnpacking();
// TitanEngine.Engine.functions:
__declspec(dllexport) void TITCALL SetEngineVariable(DWORD VariableId, bool VariableSet);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependencies(char* szFileName, char* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineCreateMissingDependenciesW(wchar_t* szFileName, wchar_t* szOutputFolder, bool LogCreatedFiles);
__declspec(dllexport) bool TITCALL EngineFakeMissingDependencies(HANDLE hProcess);
__declspec(dllexport) bool TITCALL EngineDeleteCreatedDependencies();
__declspec(dllexport) bool TITCALL EngineCreateUnpackerWindow(char* WindowUnpackerTitle, char* WindowUnpackerLongTitle, char* WindowUnpackerName, char* WindowUnpackerAuthor, void* StartUnpackingCallBack);
__declspec(dllexport) void TITCALL EngineAddUnpackerWindowLogMessage(char* szLogMessage);
__declspec(dllexport) bool TITCALL EngineCheckStructAlignment(DWORD StructureType, ULONG_PTR StructureSize);
// Global.Engine.Extension.Functions:
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginLoaded(char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerIsPluginEnabled(char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerDisableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerDisablePlugin(char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerEnableAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerEnablePlugin(char* szPluginName);
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadAllPlugins();
__declspec(dllexport) bool TITCALL ExtensionManagerUnloadPlugin(char* szPluginName);
__declspec(dllexport) void* TITCALL ExtensionManagerGetPluginInfo(char* szPluginName);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif /*TITANENGINE*/



================================================
File: 3rdparty/x64dbg/_dbgfunctions.h
================================================
#ifndef _DBGFUNCTIONS_H
#define _DBGFUNCTIONS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

typedef struct
{
    char mod[MAX_MODULE_SIZE];
    duint addr;
    unsigned char oldbyte;
    unsigned char newbyte;
} DBGPATCHINFO;

typedef struct
{
    duint addr;
    duint from;
    duint to;
    char comment[MAX_COMMENT_SIZE];
} DBGCALLSTACKENTRY;

typedef struct
{
    int total;
    DBGCALLSTACKENTRY* entries;
} DBGCALLSTACK;

typedef struct
{
    duint addr;
    duint handler;
} DBGSEHRECORD;

typedef struct
{
    duint total;
    DBGSEHRECORD* records;
} DBGSEHCHAIN;

typedef struct
{
    DWORD dwProcessId;
    char szExeFile[MAX_PATH];
    char szExeMainWindowTitle[MAX_PATH];
    char szExeArgs[MAX_COMMAND_LINE_SIZE];
} DBGPROCESSINFO;

typedef struct
{
    DWORD rva;
    BYTE type;
    WORD size;
} DBGRELOCATIONINFO;

typedef enum
{
    InstructionBody = 0,
    InstructionHeading = 1,
    InstructionTailing = 2,
    InstructionOverlapped = 3, // The byte was executed with differing instruction base addresses
    DataByte,  // This and the following is not implemented yet.
    DataWord,
    DataDWord,
    DataQWord,
    DataFloat,
    DataDouble,
    DataLongDouble,
    DataXMM,
    DataYMM,
    DataMMX,
    DataMixed, //the byte is accessed in multiple ways
    InstructionDataMixed //the byte is both executed and written
} TRACERECORDBYTETYPE;

typedef enum
{
    TraceRecordNone,
    TraceRecordBitExec,
    TraceRecordByteWithExecTypeAndCounter,
    TraceRecordWordWithExecTypeAndCounter
} TRACERECORDTYPE;

typedef struct
{
    duint Handle;
    unsigned char TypeNumber;
    unsigned int GrantedAccess;
} HANDLEINFO;

// The longest ip address is 1234:6789:1234:6789:1234:6789:123.567.901.345 (46 bytes)
#define TCP_ADDR_SIZE 50

typedef struct
{
    char RemoteAddress[TCP_ADDR_SIZE];
    unsigned short RemotePort;
    char LocalAddress[TCP_ADDR_SIZE];
    unsigned short LocalPort;
    char StateText[TCP_ADDR_SIZE];
    unsigned int State;
} TCPCONNECTIONINFO;

typedef struct
{
    duint handle;
    duint parent;
    DWORD threadId;
    DWORD style;
    DWORD styleEx;
    duint wndProc;
    bool enabled;
    RECT position;
    char windowTitle[MAX_COMMENT_SIZE];
    char windowClass[MAX_COMMENT_SIZE];
} WINDOW_INFO;

typedef struct
{
    duint addr;
    duint size;
    duint flags;
} HEAPINFO;

typedef struct
{
    const char* name;
    duint value;
} CONSTANTINFO;

typedef bool (*ASSEMBLEATEX)(duint addr, const char* instruction, char* error, bool fillnop);
typedef bool (*SECTIONFROMADDR)(duint addr, char* section);
typedef bool (*MODNAMEFROMADDR)(duint addr, char* modname, bool extension);
typedef duint(*MODBASEFROMADDR)(duint addr);
typedef duint(*MODBASEFROMNAME)(const char* modname);
typedef duint(*MODSIZEFROMADDR)(duint addr);
typedef bool (*ASSEMBLE)(duint addr, unsigned char* dest, int* size, const char* instruction, char* error);
typedef bool (*PATCHGET)(duint addr);
typedef bool (*PATCHINRANGE)(duint start, duint end);
typedef bool (*MEMPATCH)(duint va, const unsigned char* src, duint size);
typedef void (*PATCHRESTORERANGE)(duint start, duint end);
typedef bool (*PATCHENUM)(DBGPATCHINFO* patchlist, size_t* cbsize);
typedef bool (*PATCHRESTORE)(duint addr);
typedef int (*PATCHFILE)(DBGPATCHINFO* patchlist, int count, const char* szFileName, char* error);
typedef int (*MODPATHFROMADDR)(duint addr, char* path, int size);
typedef int (*MODPATHFROMNAME)(const char* modname, char* path, int size);
typedef bool (*DISASMFAST)(const unsigned char* data, duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
typedef void (*MEMUPDATEMAP)();
typedef void (*GETCALLSTACK)(DBGCALLSTACK* callstack);
typedef void (*GETSEHCHAIN)(DBGSEHCHAIN* sehchain);
typedef void (*SYMBOLDOWNLOADALLSYMBOLS)(const char* szSymbolStore);
typedef bool (*GETJIT)(char* jit, bool x64);
typedef bool (*GETJITAUTO)(bool* jitauto);
typedef bool (*GETDEFJIT)(char* defjit);
typedef bool (*GETPROCESSLIST)(DBGPROCESSINFO** entries, int* count);
typedef bool (*GETPAGERIGHTS)(duint addr, char* rights);
typedef bool (*SETPAGERIGHTS)(duint addr, const char* rights);
typedef bool (*PAGERIGHTSTOSTRING)(DWORD protect, char* rights);
typedef bool (*ISPROCESSELEVATED)();
typedef bool (*GETCMDLINE)(char* cmdline, size_t* cbsize);
typedef bool (*SETCMDLINE)(const char* cmdline);
typedef duint(*FILEOFFSETTOVA)(const char* modname, duint offset);
typedef duint(*VATOFILEOFFSET)(duint va);
typedef duint(*GETADDRFROMLINE)(const char* szSourceFile, int line, duint* displacement);
typedef bool (*GETSOURCEFROMADDR)(duint addr, char* szSourceFile, int* line);
typedef bool (*VALFROMSTRING)(const char* string, duint* value);
typedef bool (*PATCHGETEX)(duint addr, DBGPATCHINFO* info);
typedef bool (*GETBRIDGEBP)(BPXTYPE type, duint addr, BRIDGEBP* bp);
typedef bool (*STRINGFORMATINLINE)(const char* format, size_t resultSize, char* result);
typedef void (*GETMNEMONICBRIEF)(const char* mnem, size_t resultSize, char* result);
typedef unsigned int (*GETTRACERECORDHITCOUNT)(duint address);
typedef TRACERECORDBYTETYPE(*GETTRACERECORDBYTETYPE)(duint address);
typedef bool (*SETTRACERECORDTYPE)(duint pageAddress, TRACERECORDTYPE type);
typedef TRACERECORDTYPE(*GETTRACERECORDTYPE)(duint pageAddress);
typedef bool (*ENUMHANDLES)(ListOf(HANDLEINFO) handles);
typedef bool (*GETHANDLENAME)(duint handle, char* name, size_t nameSize, char* typeName, size_t typeNameSize);
typedef bool (*ENUMTCPCONNECTIONS)(ListOf(TCPCONNECTIONINFO) connections);
typedef duint(*GETDBGEVENTS)();
typedef int (*MODGETPARTY)(duint base);
typedef void (*MODSETPARTY)(duint base, int party);
typedef bool(*WATCHISWATCHDOGTRIGGERED)(unsigned int id);
typedef bool(*MEMISCODEPAGE)(duint addr, bool refresh);
typedef bool(*ANIMATECOMMAND)(const char* command);
typedef void(*DBGSETDEBUGGEEINITSCRIPT)(const char* fileName);
typedef const char* (*DBGGETDEBUGGEEINITSCRIPT)();
typedef bool(*HANDLESENUMWINDOWS)(ListOf(WINDOW_INFO) windows);
typedef bool(*HANDLESENUMHEAPS)(ListOf(HEAPINFO) heaps);
typedef bool(*THREADGETNAME)(DWORD tid, char* name);
typedef bool(*ISDEPENABLED)();
typedef void(*GETCALLSTACKEX)(DBGCALLSTACK* callstack, bool cache);
typedef bool(*GETUSERCOMMENT)(duint addr, char* comment);
typedef void(*ENUMCONSTANTS)(ListOf(CONSTANTINFO) constants);
typedef duint(*MEMBPSIZE)(duint addr);
typedef bool(*MODRELOCATIONSFROMADDR)(duint addr, ListOf(DBGRELOCATIONINFO) relocations);
typedef bool(*MODRELOCATIONATADDR)(duint addr, DBGRELOCATIONINFO* relocation);
typedef bool(*MODRELOCATIONSINRANGE)(duint addr, duint size, ListOf(DBGRELOCATIONINFO) relocations);

//The list of all the DbgFunctions() return value.
//WARNING: This list is append only. Do not insert things in the middle or plugins would break.
typedef struct DBGFUNCTIONS_
{
    ASSEMBLEATEX AssembleAtEx;
    SECTIONFROMADDR SectionFromAddr;
    MODNAMEFROMADDR ModNameFromAddr;
    MODBASEFROMADDR ModBaseFromAddr;
    MODBASEFROMNAME ModBaseFromName;
    MODSIZEFROMADDR ModSizeFromAddr;
    ASSEMBLE Assemble;
    PATCHGET PatchGet;
    PATCHINRANGE PatchInRange;
    MEMPATCH MemPatch;
    PATCHRESTORERANGE PatchRestoreRange;
    PATCHENUM PatchEnum;
    PATCHRESTORE PatchRestore;
    PATCHFILE PatchFile;
    MODPATHFROMADDR ModPathFromAddr;
    MODPATHFROMNAME ModPathFromName;
    DISASMFAST DisasmFast;
    MEMUPDATEMAP MemUpdateMap;
    GETCALLSTACK GetCallStack;
    GETSEHCHAIN GetSEHChain;
    SYMBOLDOWNLOADALLSYMBOLS SymbolDownloadAllSymbols;
    GETJITAUTO GetJitAuto;
    GETJIT GetJit;
    GETDEFJIT GetDefJit;
    GETPROCESSLIST GetProcessList;
    GETPAGERIGHTS GetPageRights;
    SETPAGERIGHTS SetPageRights;
    PAGERIGHTSTOSTRING PageRightsToString;
    ISPROCESSELEVATED IsProcessElevated;
    GETCMDLINE GetCmdline;
    SETCMDLINE SetCmdline;
    FILEOFFSETTOVA FileOffsetToVa;
    VATOFILEOFFSET VaToFileOffset;
    GETADDRFROMLINE GetAddrFromLine;
    GETSOURCEFROMADDR GetSourceFromAddr;
    VALFROMSTRING ValFromString;
    PATCHGETEX PatchGetEx;
    GETBRIDGEBP GetBridgeBp;
    STRINGFORMATINLINE StringFormatInline;
    GETMNEMONICBRIEF GetMnemonicBrief;
    GETTRACERECORDHITCOUNT GetTraceRecordHitCount;
    GETTRACERECORDBYTETYPE GetTraceRecordByteType;
    SETTRACERECORDTYPE SetTraceRecordType;
    GETTRACERECORDTYPE GetTraceRecordType;
    ENUMHANDLES EnumHandles;
    GETHANDLENAME GetHandleName;
    ENUMTCPCONNECTIONS EnumTcpConnections;
    GETDBGEVENTS GetDbgEvents;
    MODGETPARTY ModGetParty;
    MODSETPARTY ModSetParty;
    WATCHISWATCHDOGTRIGGERED WatchIsWatchdogTriggered;
    MEMISCODEPAGE MemIsCodePage;
    ANIMATECOMMAND AnimateCommand;
    DBGSETDEBUGGEEINITSCRIPT DbgSetDebuggeeInitScript;
    DBGGETDEBUGGEEINITSCRIPT DbgGetDebuggeeInitScript;
    HANDLESENUMWINDOWS EnumWindows;
    HANDLESENUMHEAPS EnumHeaps;
    THREADGETNAME ThreadGetName;
    ISDEPENABLED IsDepEnabled;
    GETCALLSTACKEX GetCallStackEx;
    GETUSERCOMMENT GetUserComment;
    ENUMCONSTANTS EnumConstants;
    ENUMCONSTANTS EnumErrorCodes;
    ENUMCONSTANTS EnumExceptions;
    MEMBPSIZE MemBpSize;
    MODRELOCATIONSFROMADDR ModRelocationsFromAddr;
    MODRELOCATIONATADDR ModRelocationAtAddr;
    MODRELOCATIONSINRANGE ModRelocationsInRange;
} DBGFUNCTIONS;

#ifdef BUILD_DBG

const DBGFUNCTIONS* dbgfunctionsget();
void dbgfunctionsinit();

#endif //BUILD_DBG

#endif //_DBGFUNCTIONS_H



================================================
File: 3rdparty/x64dbg/_plugin_types.h
================================================
#ifndef _PLUGIN_DATA_H
#define _PLUGIN_DATA_H

#ifdef BUILD_DBG

#include "_global.h"
#include "jansson/jansson.h"
#include <dbghelp.h>

#else

#ifdef __GNUC__
#include "dbghelp/dbghelp.h"
#else
#include <dbghelp.h>
#endif // __GNUC__

#ifndef deflen
#define deflen 1024
#endif // deflen

#include "bridgemain.h"
#include "_dbgfunctions.h"
#include "jansson/jansson.h"

#endif // BUILD_DBG

#endif // _PLUGIN_DATA_H



================================================
File: 3rdparty/x64dbg/_plugins.h
================================================
#ifndef _PLUGINS_H
#define _PLUGINS_H

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifndef PLUG_IMPEXP
#ifdef BUILD_DBG
#define PLUG_IMPEXP __declspec(dllexport)
#else
#define PLUG_IMPEXP __declspec(dllimport)
#endif //BUILD_DBG
#endif //PLUG_IMPEXP

#include "_plugin_types.h"

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

//defines
#define PLUG_SDKVERSION 1

#define PLUG_DB_LOADSAVE_DATA 1
#define PLUG_DB_LOADSAVE_ALL 2

//structures
typedef struct
{
    //provided by the debugger
    int pluginHandle;
    //provided by the pluginit function
    int sdkVersion;
    int pluginVersion;
    char pluginName[256];
} PLUG_INITSTRUCT;

typedef struct
{
    //provided by the debugger
    HWND hwndDlg; //gui window handle
    int hMenu; //plugin menu handle
    int hMenuDisasm; //plugin disasm menu handle
    int hMenuDump; //plugin dump menu handle
    int hMenuStack; //plugin stack menu handle
} PLUG_SETUPSTRUCT;

typedef struct
{
    void* data; //user data
} PLUG_SCRIPTSTRUCT;

//callback structures
typedef struct
{
    const char* szFileName;
} PLUG_CB_INITDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STOPDEBUG;

typedef struct
{
    CREATE_PROCESS_DEBUG_INFO* CreateProcessInfo;
    IMAGEHLP_MODULE64* modInfo;
    const char* DebugFileName;
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_CREATEPROCESS;

typedef struct
{
    EXIT_PROCESS_DEBUG_INFO* ExitProcess;
} PLUG_CB_EXITPROCESS;

typedef struct
{
    CREATE_THREAD_DEBUG_INFO* CreateThread;
    DWORD dwThreadId;
} PLUG_CB_CREATETHREAD;

typedef struct
{
    EXIT_THREAD_DEBUG_INFO* ExitThread;
    DWORD dwThreadId;
} PLUG_CB_EXITTHREAD;

typedef struct
{
    void* reserved;
} PLUG_CB_SYSTEMBREAKPOINT;

typedef struct
{
    LOAD_DLL_DEBUG_INFO* LoadDll;
    IMAGEHLP_MODULE64* modInfo;
    const char* modname;
} PLUG_CB_LOADDLL;

typedef struct
{
    UNLOAD_DLL_DEBUG_INFO* UnloadDll;
} PLUG_CB_UNLOADDLL;

typedef struct
{
    OUTPUT_DEBUG_STRING_INFO* DebugString;
} PLUG_CB_OUTPUTDEBUGSTRING;

typedef struct
{
    EXCEPTION_DEBUG_INFO* Exception;
} PLUG_CB_EXCEPTION;

typedef struct
{
    BRIDGEBP* breakpoint;
} PLUG_CB_BREAKPOINT;

typedef struct
{
    void* reserved;
} PLUG_CB_PAUSEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_RESUMEDEBUG;

typedef struct
{
    void* reserved;
} PLUG_CB_STEPPED;

typedef struct
{
    DWORD dwProcessId;
} PLUG_CB_ATTACH;

typedef struct
{
    PROCESS_INFORMATION* fdProcessInfo;
} PLUG_CB_DETACH;

typedef struct
{
    DEBUG_EVENT* DebugEvent;
} PLUG_CB_DEBUGEVENT;

typedef struct
{
    int hEntry;
} PLUG_CB_MENUENTRY;

typedef struct
{
    MSG* message;
    long* result;
    bool retval;
} PLUG_CB_WINEVENT;

typedef struct
{
    MSG* message;
    bool retval;
} PLUG_CB_WINEVENTGLOBAL;

typedef struct
{
    json_t* root;
    int loadSaveType;
} PLUG_CB_LOADSAVEDB;

typedef struct
{
    const char* symbol;
    bool retval;
} PLUG_CB_FILTERSYMBOL;

typedef struct
{
    duint cip;
    bool stop;
} PLUG_CB_TRACEEXECUTE;

typedef struct
{
    int hWindow;
    duint VA;
} PLUG_CB_SELCHANGED;

typedef struct
{
    BridgeCFGraphList graph;
} PLUG_CB_ANALYZE;

typedef struct
{
    duint addr;
    BRIDGE_ADDRINFO* addrinfo;
    bool retval;
} PLUG_CB_ADDRINFO;

typedef struct
{
    const char* string;
    duint value;
    int* value_size;
    bool* isvar;
    bool* hexonly;
    bool retval;
} PLUG_CB_VALFROMSTRING;

typedef struct
{
    const char* string;
    duint value;
    bool retval;
} PLUG_CB_VALTOSTRING;

typedef struct
{
    int hMenu;
} PLUG_CB_MENUPREPARE;

//enums
typedef enum
{
    CB_INITDEBUG, //PLUG_CB_INITDEBUG
    CB_STOPDEBUG, //PLUG_CB_STOPDEBUG
    CB_CREATEPROCESS, //PLUG_CB_CREATEPROCESS
    CB_EXITPROCESS, //PLUG_CB_EXITPROCESS
    CB_CREATETHREAD, //PLUG_CB_CREATETHREAD
    CB_EXITTHREAD, //PLUG_CB_EXITTHREAD
    CB_SYSTEMBREAKPOINT, //PLUG_CB_SYSTEMBREAKPOINT
    CB_LOADDLL, //PLUG_CB_LOADDLL
    CB_UNLOADDLL, //PLUG_CB_UNLOADDLL
    CB_OUTPUTDEBUGSTRING, //PLUG_CB_OUTPUTDEBUGSTRING
    CB_EXCEPTION, //PLUG_CB_EXCEPTION
    CB_BREAKPOINT, //PLUG_CB_BREAKPOINT
    CB_PAUSEDEBUG, //PLUG_CB_PAUSEDEBUG
    CB_RESUMEDEBUG, //PLUG_CB_RESUMEDEBUG
    CB_STEPPED, //PLUG_CB_STEPPED
    CB_ATTACH, //PLUG_CB_ATTACHED (before attaching, after CB_INITDEBUG)
    CB_DETACH, //PLUG_CB_DETACH (before detaching, before CB_STOPDEBUG)
    CB_DEBUGEVENT, //PLUG_CB_DEBUGEVENT (called on any debug event)
    CB_MENUENTRY, //PLUG_CB_MENUENTRY
    CB_WINEVENT, //PLUG_CB_WINEVENT
    CB_WINEVENTGLOBAL, //PLUG_CB_WINEVENTGLOBAL
    CB_LOADDB, //PLUG_CB_LOADSAVEDB
    CB_SAVEDB, //PLUG_CB_LOADSAVEDB
    CB_FILTERSYMBOL, //PLUG_CB_FILTERSYMBOL
    CB_TRACEEXECUTE, //PLUG_CB_TRACEEXECUTE
    CB_SELCHANGED, //PLUG_CB_SELCHANGED
    CB_ANALYZE, //PLUG_CB_ANALYZE
    CB_ADDRINFO, //PLUG_CB_ADDRINFO
    CB_VALFROMSTRING, //PLUG_CB_VALFROMSTRING
    CB_VALTOSTRING, //PLUG_CB_VALTOSTRING
    CB_MENUPREPARE, //PLUG_CB_MENUPREPARE
    CB_LAST
} CBTYPE;

typedef enum
{
    FORMAT_ERROR, //generic failure (no message)
    FORMAT_SUCCESS, //success
    FORMAT_ERROR_MESSAGE, //formatting failed but an error was put in the buffer (there are always at least 511 characters available).
    FORMAT_BUFFER_TOO_SMALL //buffer too small (x64dbg will retry until the buffer is big enough)
} FORMATRESULT;

//typedefs
typedef void (*CBPLUGIN)(CBTYPE cbType, void* callbackInfo);
typedef bool (*CBPLUGINCOMMAND)(int argc, char** argv);
typedef void (*CBPLUGINSCRIPT)();
typedef duint(*CBPLUGINEXPRFUNCTION)(int argc, duint* argv, void* userdata);
typedef FORMATRESULT(*CBPLUGINFORMATFUNCTION)(char* dest, size_t destCount, int argc, char* argv[], duint value, void* userdata);
typedef bool (*CBPLUGINPREDICATE)(void* userdata);

//exports
#ifdef __cplusplus
extern "C"
{
#endif

PLUG_IMPEXP void _plugin_registercallback(int pluginHandle, CBTYPE cbType, CBPLUGIN cbPlugin);
PLUG_IMPEXP bool _plugin_unregistercallback(int pluginHandle, CBTYPE cbType);
PLUG_IMPEXP bool _plugin_registercommand(int pluginHandle, const char* command, CBPLUGINCOMMAND cbCommand, bool debugonly);
PLUG_IMPEXP bool _plugin_unregistercommand(int pluginHandle, const char* command);
PLUG_IMPEXP void _plugin_logprintf(const char* format, ...);
PLUG_IMPEXP void _plugin_logputs(const char* text);
PLUG_IMPEXP void _plugin_logprint(const char* text);
PLUG_IMPEXP void _plugin_debugpause();
PLUG_IMPEXP void _plugin_debugskipexceptions(bool skip);
PLUG_IMPEXP int _plugin_menuadd(int hMenu, const char* title);
PLUG_IMPEXP bool _plugin_menuaddentry(int hMenu, int hEntry, const char* title);
PLUG_IMPEXP bool _plugin_menuaddseparator(int hMenu);
PLUG_IMPEXP bool _plugin_menuclear(int hMenu);
PLUG_IMPEXP void _plugin_menuseticon(int hMenu, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentryseticon(int pluginHandle, int hEntry, const ICONDATA* icon);
PLUG_IMPEXP void _plugin_menuentrysetchecked(int pluginHandle, int hEntry, bool checked);
PLUG_IMPEXP void _plugin_menusetvisible(int pluginHandle, int hMenu, bool visible);
PLUG_IMPEXP void _plugin_menuentrysetvisible(int pluginHandle, int hEntry, bool visible);
PLUG_IMPEXP void _plugin_menusetname(int pluginHandle, int hMenu, const char* name);
PLUG_IMPEXP void _plugin_menuentrysetname(int pluginHandle, int hEntry, const char* name);
PLUG_IMPEXP void _plugin_menuentrysethotkey(int pluginHandle, int hEntry, const char* hotkey);
PLUG_IMPEXP bool _plugin_menuremove(int hMenu);
PLUG_IMPEXP bool _plugin_menuentryremove(int pluginHandle, int hEntry);
PLUG_IMPEXP void _plugin_startscript(CBPLUGINSCRIPT cbScript);
PLUG_IMPEXP bool _plugin_waituntilpaused();
PLUG_IMPEXP bool _plugin_registerexprfunction(int pluginHandle, const char* name, int argc, CBPLUGINEXPRFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterexprfunction(int pluginHandle, const char* name);
PLUG_IMPEXP bool _plugin_unload(const char* pluginName);
PLUG_IMPEXP bool _plugin_load(const char* pluginName);
PLUG_IMPEXP duint _plugin_hash(const void* data, duint size);
PLUG_IMPEXP bool _plugin_registerformatfunction(int pluginHandle, const char* type, CBPLUGINFORMATFUNCTION cbFunction, void* userdata);
PLUG_IMPEXP bool _plugin_unregisterformatfunction(int pluginHandle, const char* type);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _PLUGINS_H



================================================
File: 3rdparty/x64dbg/bridgegraph.h
================================================
#ifndef _GRAPH_H
#define _GRAPH_H

typedef struct
{
    duint addr; //virtual address of the instruction
    unsigned char data[15]; //instruction bytes
} BridgeCFInstruction;

typedef struct
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    ListInfo exits; //exits (including brtrue and brfalse, duint)
    ListInfo instrs; //block instructions
} BridgeCFNodeList;

typedef struct
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    ListInfo nodes; //graph nodes (BridgeCFNodeList)
} BridgeCFGraphList;

#ifdef __cplusplus
#if _MSC_VER >= 1700 && !defined(NO_CPP11)

#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <utility>

struct BridgeCFNode
{
    duint parentGraph; //function of which this node is a part
    duint start; //start of the block
    duint end; //end of the block (inclusive)
    duint brtrue; //destination if condition is true
    duint brfalse; //destination if condition is false
    duint icount; //number of instructions in node
    bool terminal; //node is a RET
    bool split; //node is a split (brtrue points to the next node)
    bool indirectcall; //node contains indirect calls (call reg, call [reg+X])
    void* userdata; //user data
    std::vector<duint> exits; //exits (including brtrue and brfalse)
    std::vector<BridgeCFInstruction> instrs; //block instructions

    static void Free(const BridgeCFNodeList* nodeList)
    {
        if(!BridgeList<duint>::Free(&nodeList->exits))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::Free(&nodeList->instrs))
            __debugbreak();
    }

    explicit BridgeCFNode(const BridgeCFNodeList* nodeList, bool freedata)
    {
        if(!nodeList)
            __debugbreak();
        parentGraph = nodeList->parentGraph;
        start = nodeList->start;
        end = nodeList->end;
        brtrue = nodeList->brtrue;
        brfalse = nodeList->brfalse;
        icount = nodeList->icount;
        terminal = nodeList->terminal;
        indirectcall = nodeList->indirectcall;
        split = nodeList->split;
        userdata = nodeList->userdata;
        if(!BridgeList<duint>::ToVector(&nodeList->exits, exits, freedata))
            __debugbreak();
        if(!BridgeList<BridgeCFInstruction>::ToVector(&nodeList->instrs, instrs, freedata))
            __debugbreak();
    }

    explicit BridgeCFNode(duint parentGraph, duint start, duint end)
        : parentGraph(parentGraph),
          start(start),
          end(end),
          brtrue(0),
          brfalse(0),
          icount(0),
          terminal(false),
          indirectcall(false),
          split(false),
          userdata(nullptr)
    {
    }

    explicit BridgeCFNode()
        : parentGraph(0),
          start(0),
          end(0),
          brtrue(0),
          brfalse(0),
          icount(0),
          terminal(false),
          split(false),
          userdata(nullptr)
    {
    }

    BridgeCFNodeList ToNodeList() const
    {
        BridgeCFNodeList out;
        out.parentGraph = parentGraph;
        out.start = start;
        out.end = end;
        out.brtrue = brtrue;
        out.brfalse = brfalse;
        out.icount = icount;
        out.terminal = terminal;
        out.indirectcall = indirectcall;
        out.split = split;
        out.userdata = userdata;
        BridgeList<duint>::CopyData(&out.exits, exits);
        BridgeList<BridgeCFInstruction>::CopyData(&out.instrs, instrs);
        return std::move(out);
    }
};

struct BridgeCFGraph
{
    duint entryPoint; //graph entry point
    void* userdata; //user data
    std::unordered_map<duint, BridgeCFNode> nodes; //CFNode.start -> CFNode
    std::unordered_map<duint, std::unordered_set<duint>> parents; //CFNode.start -> parents

    static void Free(const BridgeCFGraphList* graphList)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            BridgeCFNode::Free(&data[i]);
        BridgeFree(data);
    }

    explicit BridgeCFGraph(const BridgeCFGraphList* graphList, bool freedata)
    {
        if(!graphList || graphList->nodes.size != graphList->nodes.count * sizeof(BridgeCFNodeList))
            __debugbreak();
        entryPoint = graphList->entryPoint;
        userdata = graphList->userdata;
        auto data = (BridgeCFNodeList*)graphList->nodes.data;
        for(int i = 0; i < graphList->nodes.count; i++)
            AddNode(BridgeCFNode(&data[i], freedata));
        if(freedata && data)
            BridgeFree(data);
    }

    explicit BridgeCFGraph(duint entryPoint)
        : entryPoint(entryPoint),
          userdata(nullptr)
    {
    }

    void AddNode(const BridgeCFNode & node)
    {
        nodes[node.start] = node;
        AddParent(node.start, node.brtrue);
        AddParent(node.start, node.brfalse);
    }

    void AddParent(duint child, duint parent)
    {
        if(!child || !parent)
            return;
        auto found = parents.find(child);
        if(found == parents.end())
        {
            parents[child] = std::unordered_set<duint>();
            parents[child].insert(parent);
        }
        else
            found->second.insert(parent);
    }

    BridgeCFGraphList ToGraphList() const
    {
        BridgeCFGraphList out;
        out.entryPoint = entryPoint;
        out.userdata = userdata;
        std::vector<BridgeCFNodeList> nodeList;
        nodeList.reserve(nodes.size());
        for(const auto & nodeIt : nodes)
            nodeList.push_back(nodeIt.second.ToNodeList());
        BridgeList<BridgeCFNodeList>::CopyData(&out.nodes, nodeList);
        return std::move(out);
    }
};

#endif //_MSC_VER
#endif //__cplusplus

#endif //_GRAPH_H


================================================
File: 3rdparty/x64dbg/bridgelist.h
================================================
#ifndef _LIST_H
#define _LIST_H

typedef struct
{
    int count; //Number of element in the list.
    size_t size; //Size of list in bytes (used for type checking).
    void* data; //Pointer to the list contents. Must be deleted by the caller using BridgeFree (or BridgeList::Free).
} ListInfo;

#define ListOf(Type) ListInfo*

#ifdef __cplusplus

#include <vector>

/**
\brief A list object. This object is NOT thread safe.
\tparam Type BridgeList contents type.
*/
template<typename Type>
class BridgeList
{
public:
    /**
    \brief BridgeList constructor.
    \param _freeData (Optional) the free function.
    */
    explicit BridgeList()
    {
        memset(&_listInfo, 0, sizeof(_listInfo));
    }

    /**
    \brief BridgeList destructor.
    */
    ~BridgeList()
    {
        Cleanup();
    }

    /**
    \brief Gets the list data.
    \return Returns ListInfo->data. Can be null if the list was never initialized. Will be destroyed once this object goes out of scope!
    */
    Type* Data() const
    {
        return reinterpret_cast<Type*>(_listInfo.data);
    }

    /**
    \brief Gets the number of elements in the list. This will crash the program if the data is not consistent with the specified template argument.
    \return The number of elements in the list.
    */
    int Count() const
    {
        if(_listInfo.size != _listInfo.count * sizeof(Type)) //make sure the user is using the correct type.
            __debugbreak();
        return _listInfo.count;
    }

    /**
    \brief Cleans up the list, freeing the list data when it is not null.
    */
    void Cleanup()
    {
        if(_listInfo.data)
        {
            BridgeFree(_listInfo.data);
            _listInfo.data = nullptr;
        }
    }

    /**
    \brief Reference operator (cleans up the previous list)
    \return Pointer to the ListInfo.
    */
    ListInfo* operator&()
    {
        Cleanup();
        return &_listInfo;
    }

    /**
    \brief Array indexer operator. This will crash if you try to access out-of-bounds.
    \param index Zero-based index of the item you want to get.
    \return Reference to a value at that index.
    */
    Type & operator[](size_t index) const
    {
        if(index >= size_t(Count())) //make sure the out-of-bounds access is caught as soon as possible.
            __debugbreak();
        return Data()[index];
    }

    /**
    \brief Copies data to a ListInfo structure..
    \param [out] listInfo If non-null, information describing the list.
    \param listData Data to copy in the ListInfo structure.
    \return true if it succeeds, false if it fails.
    */
    static bool CopyData(ListInfo* listInfo, const std::vector<Type> & listData)
    {
        if(!listInfo)
            return false;
        listInfo->count = int(listData.size());
        listInfo->size = listInfo->count * sizeof(Type);
        if(listInfo->count)
        {
            listInfo->data = BridgeAlloc(listInfo->size);
            Type* curItem = reinterpret_cast<Type*>(listInfo->data);
            for(const auto & item : listData)
            {
                *curItem = item;
                ++curItem;
            }
        }
        else
            listInfo->data = nullptr;
        return true;
    }

    static bool Free(const ListInfo* listInfo)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        BridgeFree(listInfo->data);
        return true;
    }

    static bool ToVector(const ListInfo* listInfo, std::vector<Type> & listData, bool freedata = true)
    {
        if(!listInfo || listInfo->size != listInfo->count * sizeof(Type) || (listInfo->count && !listInfo->data))
            return false;
        listData.resize(listInfo->count);
        for(int i = 0; i < listInfo->count; i++)
            listData[i] = ((Type*)listInfo->data)[i];
        if(freedata && listInfo->data)
            BridgeFree(listInfo->data);
        return true;
    }

private:
    ListInfo _listInfo;
};

#endif //__cplusplus

#endif //_LIST_H


================================================
File: 3rdparty/x64dbg/bridgemain.h
================================================
#ifndef _BRIDGEMAIN_H_
#define _BRIDGEMAIN_H_

#include <windows.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif

//default structure alignments forced
#ifdef _WIN64
#pragma pack(push, 16)
#else //x86
#pragma pack(push, 8)
#endif //_WIN64

#ifdef _WIN64
typedef unsigned long long duint;
typedef signed long long dsint;
#else
typedef unsigned long duint;
typedef signed long dsint;
#endif //_WIN64

#ifndef BRIDGE_IMPEXP
#ifdef BUILD_BRIDGE
#define BRIDGE_IMPEXP __declspec(dllexport)
#else
#define BRIDGE_IMPEXP __declspec(dllimport)
#endif //BUILD_BRIDGE
#endif //BRIDGE_IMPEXP

#ifdef __cplusplus
extern "C"
{
#endif

//Bridge defines
#define MAX_SETTING_SIZE 65536
#define DBG_VERSION 25

//Bridge functions

/// <summary>
/// Initialize the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeInit();

/// <summary>
/// Start the bridge.
/// </summary>
/// <returns>On error it returns a non-null error message.</returns>
BRIDGE_IMPEXP const wchar_t* BridgeStart();

/// <summary>
/// Allocate buffer. Use BridgeFree to free the buffer.
/// </summary>
/// <param name="size">Size in bytes of the buffer to allocate.</param>
/// <returns>A pointer to the allocated buffer. This function will trigger a crash dump if unsuccessful.</returns>
BRIDGE_IMPEXP void* BridgeAlloc(size_t size);

/// <summary>
/// Free buffer allocated by BridgeAlloc.
/// </summary>
/// <param name="ptr">Buffer to free.</param>
BRIDGE_IMPEXP void BridgeFree(void* ptr);

/// <summary>
/// Get a string setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output buffer for the value. Should be of MAX_SETTING_SIZE. Cannot be null.</param>
/// <returns>True if the setting was found and copied in the value parameter.</returns>
BRIDGE_IMPEXP bool BridgeSettingGet(const char* section, const char* key, char* value);

/// <summary>
/// Get an integer setting from the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Cannot be null.</param>
/// <param name="value">Output value.</param>
/// <returns>True if the setting was found and successfully converted to an integer.</returns>
BRIDGE_IMPEXP bool BridgeSettingGetUint(const char* section, const char* key, duint* value);

/// <summary>
/// Set a string setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value. Set to null to remove the key from the section.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSet(const char* section, const char* key, const char* value);

/// <summary>
/// Set an integer setting in the in-memory setting store.
/// </summary>
/// <param name="section">Section the setting is in. Cannot be null.</param>
/// <param name="key">Setting key (name). Set to null to clear the whole section.</param>
/// <param name="value">New setting value.</param>
/// <returns>True if the operation was successful.</returns>
BRIDGE_IMPEXP bool BridgeSettingSetUint(const char* section, const char* key, duint value);

/// <summary>
/// Flush the in-memory setting store to disk.
/// </summary>
/// <returns></returns>
BRIDGE_IMPEXP bool BridgeSettingFlush();

/// <summary>
/// Read the in-memory setting store from disk.
/// </summary>
/// <param name="errorLine">Line where the error occurred. Set to null to ignore this.</param>
/// <returns>True if the setting were read and parsed correctly.</returns>
BRIDGE_IMPEXP bool BridgeSettingRead(int* errorLine);

/// <summary>
/// Get the debugger version.
/// </summary>
/// <returns>25</returns>
BRIDGE_IMPEXP int BridgeGetDbgVersion();

#ifdef __cplusplus
}
#endif

//list structure (and C++ wrapper)
#include "bridgelist.h"

#include "bridgegraph.h"

#ifdef __cplusplus
extern "C"
{
#endif

//Debugger defines
#define MAX_LABEL_SIZE 256
#define MAX_COMMENT_SIZE 512
#define MAX_MODULE_SIZE 256
#define MAX_IMPORT_SIZE 65536
#define MAX_BREAKPOINT_SIZE 256
#define MAX_CONDITIONAL_EXPR_SIZE 256
#define MAX_CONDITIONAL_TEXT_SIZE 256
#define MAX_SCRIPT_LINE_SIZE 2048
#define MAX_THREAD_NAME_SIZE 256
#define MAX_WATCH_NAME_SIZE 256
#define MAX_STRING_SIZE 512
#define MAX_ERROR_SIZE 512
#define RIGHTS_STRING_SIZE (sizeof("ERWCG") + 1)
#define MAX_SECTION_SIZE 10
#define MAX_COMMAND_LINE_SIZE 256
#define MAX_MNEMONIC_SIZE 64
#define PAGE_SIZE 0x1000

//Debugger enums
typedef enum
{
    initialized,
    paused,
    running,
    stopped
} DBGSTATE;

typedef enum
{
    SEG_DEFAULT,
    SEG_ES,
    SEG_DS,
    SEG_FS,
    SEG_GS,
    SEG_CS,
    SEG_SS
} SEGMENTREG;

typedef enum
{
    flagmodule = 0x1,
    flaglabel = 0x2,
    flagcomment = 0x4,
    flagbookmark = 0x8,
    flagfunction = 0x10,
    flagloop = 0x20,
    flagargs = 0x40,
    flagNoFuncOffset = 0x80
} ADDRINFOFLAGS;

typedef enum
{
    bp_none = 0,
    bp_normal = 1,
    bp_hardware = 2,
    bp_memory = 4,
    bp_dll = 8,
    bp_exception = 16
} BPXTYPE;

typedef enum
{
    FUNC_NONE,
    FUNC_BEGIN,
    FUNC_MIDDLE,
    FUNC_END,
    FUNC_SINGLE
} FUNCTYPE;

typedef enum
{
    LOOP_NONE,
    LOOP_BEGIN,
    LOOP_MIDDLE,
    LOOP_ENTRY,
    LOOP_END,
    LOOP_SINGLE
} LOOPTYPE;

//order by most important type last
typedef enum
{
    XREF_NONE,
    XREF_DATA,
    XREF_JMP,
    XREF_CALL
} XREFTYPE;

typedef enum
{
    ARG_NONE,
    ARG_BEGIN,
    ARG_MIDDLE,
    ARG_END,
    ARG_SINGLE
} ARGTYPE;

typedef enum
{
    DBG_SCRIPT_LOAD,                // param1=const char* filename,      param2=unused
    DBG_SCRIPT_UNLOAD,              // param1=unused,                    param2=unused
    DBG_SCRIPT_RUN,                 // param1=int destline,              param2=unused
    DBG_SCRIPT_STEP,                // param1=unused,                    param2=unused
    DBG_SCRIPT_BPTOGGLE,            // param1=int line,                  param2=unused
    DBG_SCRIPT_BPGET,               // param1=int line,                  param2=unused
    DBG_SCRIPT_CMDEXEC,             // param1=const char* command,       param2=unused
    DBG_SCRIPT_ABORT,               // param1=unused,                    param2=unused
    DBG_SCRIPT_GETLINETYPE,         // param1=int line,                  param2=unused
    DBG_SCRIPT_SETIP,               // param1=int line,                  param2=unused
    DBG_SCRIPT_GETBRANCHINFO,       // param1=int line,                  param2=SCRIPTBRANCH* info
    DBG_SYMBOL_ENUM,                // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_ASSEMBLE_AT,                // param1=duint addr,                param2=const char* instruction
    DBG_MODBASE_FROM_NAME,          // param1=const char* modname,       param2=unused
    DBG_DISASM_AT,                  // param1=duint addr,                 param2=DISASM_INSTR* instr
    DBG_STACK_COMMENT_GET,          // param1=duint addr,                param2=STACK_COMMENT* comment
    DBG_GET_THREAD_LIST,            // param1=THREADALLINFO* list,       param2=unused
    DBG_SETTINGS_UPDATED,           // param1=unused,                    param2=unused
    DBG_DISASM_FAST_AT,             // param1=duint addr,                param2=BASIC_INSTRUCTION_INFO* basicinfo
    DBG_MENU_ENTRY_CLICKED,         // param1=int hEntry,                param2=unused
    DBG_FUNCTION_GET,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_OVERLAPS,          // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_ADD,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_FUNCTION_DEL,               // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_GET,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_OVERLAPS,              // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_ADD,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_LOOP_DEL,                   // param1=FUNCTION_LOOP_INFO* info,  param2=unused
    DBG_IS_RUN_LOCKED,              // param1=unused,                    param2=unused
    DBG_IS_BP_DISABLED,             // param1=duint addr,                param2=unused
    DBG_SET_AUTO_COMMENT_AT,        // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_COMMENT_RANGE,  // param1=duint start,               param2=duint end
    DBG_SET_AUTO_LABEL_AT,          // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_LABEL_RANGE,    // param1=duint start,               param2=duint end
    DBG_SET_AUTO_BOOKMARK_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_BOOKMARK_RANGE, // param1=duint start,               param2=duint end
    DBG_SET_AUTO_FUNCTION_AT,       // param1=duint addr,                param2=const char* text
    DBG_DELETE_AUTO_FUNCTION_RANGE, // param1=duint start,               param2=duint end
    DBG_GET_STRING_AT,              // param1=duint addr,                param2=unused
    DBG_GET_FUNCTIONS,              // param1=unused,                    param2=unused
    DBG_WIN_EVENT,                  // param1=MSG* message,              param2=long* result
    DBG_WIN_EVENT_GLOBAL,           // param1=MSG* message,              param2=unused
    DBG_INITIALIZE_LOCKS,           // param1=unused,                    param2=unused
    DBG_DEINITIALIZE_LOCKS,         // param1=unused,                    param2=unused
    DBG_GET_TIME_WASTED_COUNTER,    // param1=unused,                    param2=unused
    DBG_SYMBOL_ENUM_FROMCACHE,      // param1=SYMBOLCBINFO* cbInfo,      param2=unused
    DBG_DELETE_COMMENT_RANGE,       // param1=duint start,               param2=duint end
    DBG_DELETE_LABEL_RANGE,         // param1=duint start,               param2=duint end
    DBG_DELETE_BOOKMARK_RANGE,      // param1=duint start,               param2=duint end
    DBG_GET_XREF_COUNT_AT,          // param1=duint addr,                param2=unused
    DBG_GET_XREF_TYPE_AT,           // param1=duint addr,                param2=unused
    DBG_XREF_ADD,                   // param1=duint addr,                param2=duint from
    DBG_XREF_DEL_ALL,               // param1=duint addr,                param2=unused
    DBG_XREF_GET,                   // param1=duint addr,                param2=XREF_INFO* info
    DBG_GET_ENCODE_TYPE_BUFFER,     // param1=duint addr,                param2=unused
    DBG_ENCODE_TYPE_GET,            // param1=duint addr,                param2=duint size
    DBG_DELETE_ENCODE_TYPE_RANGE,   // param1=duint start,               param2=duint end
    DBG_ENCODE_SIZE_GET,            // param1=duint addr,                param2=duint codesize
    DBG_DELETE_ENCODE_TYPE_SEG,     // param1=duint addr,                param2=unused
    DBG_RELEASE_ENCODE_TYPE_BUFFER, // param1=void* buffer,              param2=unused
    DBG_ARGUMENT_GET,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_OVERLAPS,          // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_ADD,               // param1=FUNCTION* info,            param2=unused
    DBG_ARGUMENT_DEL,               // param1=FUNCTION* info,            param2=unused
    DBG_GET_WATCH_LIST,             // param1=ListOf(WATCHINFO),         param2=unused
    DBG_SELCHANGED,                 // param1=hWindow,                   param2=VA
    DBG_GET_PROCESS_HANDLE,         // param1=unused,                    param2=unused
    DBG_GET_THREAD_HANDLE,          // param1=unused,                    param2=unused
    DBG_GET_PROCESS_ID,             // param1=unused,                    param2=unused
    DBG_GET_THREAD_ID,              // param1=unused,                    param2=unused
    DBG_GET_PEB_ADDRESS,            // param1=DWORD ProcessId,           param2=unused
    DBG_GET_TEB_ADDRESS,            // param1=DWORD ThreadId,            param2=unused
    DBG_ANALYZE_FUNCTION,           // param1=BridgeCFGraphList* graph,  param2=duint entry
    DBG_MENU_PREPARE,               // param1=int hMenu,                 param2=unused
} DBGMSG;

typedef enum
{
    linecommand,
    linebranch,
    linelabel,
    linecomment,
    lineempty,
} SCRIPTLINETYPE;

typedef enum
{
    scriptnobranch,
    scriptjmp,
    scriptjnejnz,
    scriptjejz,
    scriptjbjl,
    scriptjajg,
    scriptjbejle,
    scriptjaejge,
    scriptcall
} SCRIPTBRANCHTYPE;

typedef enum
{
    instr_normal,
    instr_branch,
    instr_stack
} DISASM_INSTRTYPE;

typedef enum
{
    arg_normal,
    arg_memory
} DISASM_ARGTYPE;

typedef enum
{
    str_none,
    str_ascii,
    str_unicode
} STRING_TYPE;

typedef enum
{
    _PriorityIdle = -15,
    _PriorityAboveNormal = 1,
    _PriorityBelowNormal = -1,
    _PriorityHighest = 2,
    _PriorityLowest = -2,
    _PriorityNormal = 0,
    _PriorityTimeCritical = 15,
    _PriorityUnknown = 0x7FFFFFFF
} THREADPRIORITY;

typedef enum
{
    _Executive = 0,
    _FreePage = 1,
    _PageIn = 2,
    _PoolAllocation = 3,
    _DelayExecution = 4,
    _Suspended = 5,
    _UserRequest = 6,
    _WrExecutive = 7,
    _WrFreePage = 8,
    _WrPageIn = 9,
    _WrPoolAllocation = 10,
    _WrDelayExecution = 11,
    _WrSuspended = 12,
    _WrUserRequest = 13,
    _WrEventPair = 14,
    _WrQueue = 15,
    _WrLpcReceive = 16,
    _WrLpcReply = 17,
    _WrVirtualMemory = 18,
    _WrPageOut = 19,
    _WrRendezvous = 20,
    _Spare2 = 21,
    _Spare3 = 22,
    _Spare4 = 23,
    _Spare5 = 24,
    _WrCalloutStack = 25,
    _WrKernel = 26,
    _WrResource = 27,
    _WrPushLock = 28,
    _WrMutex = 29,
    _WrQuantumEnd = 30,
    _WrDispatchInt = 31,
    _WrPreempted = 32,
    _WrYieldExecution = 33,
    _WrFastMutex = 34,
    _WrGuardedMutex = 35,
    _WrRundown = 36,
} THREADWAITREASON;

typedef enum
{
    size_byte = 1,
    size_word = 2,
    size_dword = 4,
    size_qword = 8
} MEMORY_SIZE;

typedef enum
{
    enc_unknown,  //must be 0
    enc_byte,     //1 byte
    enc_word,     //2 bytes
    enc_dword,    //4 bytes
    enc_fword,    //6 bytes
    enc_qword,    //8 bytes
    enc_tbyte,    //10 bytes
    enc_oword,    //16 bytes
    enc_mmword,   //8 bytes
    enc_xmmword,  //16 bytes
    enc_ymmword,  //32 bytes
    enc_zmmword,  //64 bytes avx512 not supported
    enc_real4,    //4 byte float
    enc_real8,    //8 byte double
    enc_real10,   //10 byte decimal
    enc_ascii,    //ascii sequence
    enc_unicode,  //unicode sequence
    enc_code,     //start of code
    enc_junk,     //junk code
    enc_middle    //middle of data
} ENCODETYPE;

typedef enum
{
    TYPE_UINT, // unsigned integer
    TYPE_INT,  // signed integer
    TYPE_FLOAT,// single precision floating point value
    TYPE_ASCII, // ascii string
    TYPE_UNICODE, // unicode string
    TYPE_INVALID // invalid watch expression or data type
} WATCHVARTYPE;

typedef enum
{
    MODE_DISABLED, // watchdog is disabled
    MODE_ISTRUE,   // alert if expression is not 0
    MODE_ISFALSE,  // alert if expression is 0
    MODE_CHANGED,  // alert if expression is changed
    MODE_UNCHANGED // alert if expression is not changed
} WATCHDOGMODE;

typedef enum
{
    hw_access,
    hw_write,
    hw_execute
} BPHWTYPE;

typedef enum
{
    mem_access,
    mem_read,
    mem_write,
    mem_execute
} BPMEMTYPE;

typedef enum
{
    dll_load = 1,
    dll_unload,
    dll_all
} BPDLLTYPE;

typedef enum
{
    ex_firstchance = 1,
    ex_secondchance,
    ex_all
} BPEXTYPE;

typedef enum
{
    hw_byte,
    hw_word,
    hw_dword,
    hw_qword
} BPHWSIZE;

//Debugger typedefs
typedef MEMORY_SIZE VALUE_SIZE;
typedef struct SYMBOLINFO_ SYMBOLINFO;
typedef struct DBGFUNCTIONS_ DBGFUNCTIONS;

typedef void (*CBSYMBOLENUM)(SYMBOLINFO* symbol, void* user);

//Debugger structs
typedef struct
{
    MEMORY_BASIC_INFORMATION mbi;
    char info[MAX_MODULE_SIZE];
} MEMPAGE;

typedef struct
{
    int count;
    MEMPAGE* page;
} MEMMAP;

typedef struct
{
    BPXTYPE type;
    duint addr;
    bool enabled;
    bool singleshoot;
    bool active;
    char name[MAX_BREAKPOINT_SIZE];
    char mod[MAX_MODULE_SIZE];
    unsigned short slot;
    // extended part
    unsigned char typeEx; //BPHWTYPE/BPMEMTYPE/BPDLLTYPE/BPEXTYPE
    unsigned char hwSize; //BPHWSIZE
    unsigned int hitCount;
    bool fastResume;
    bool silent;
    char breakCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char logText[MAX_CONDITIONAL_TEXT_SIZE];
    char logCondition[MAX_CONDITIONAL_EXPR_SIZE];
    char commandText[MAX_CONDITIONAL_TEXT_SIZE];
    char commandCondition[MAX_CONDITIONAL_EXPR_SIZE];
} BRIDGEBP;

typedef struct
{
    int count;
    BRIDGEBP* bp;
} BPMAP;

typedef struct
{
    char WatchName[MAX_WATCH_NAME_SIZE];
    char Expression[MAX_CONDITIONAL_EXPR_SIZE];
    unsigned int window;
    unsigned int id;
    WATCHVARTYPE varType;
    WATCHDOGMODE watchdogMode;
    duint value;
    bool watchdogTriggered;
} WATCHINFO;

typedef struct
{
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} FUNCTION;

typedef struct
{
    int depth; //IN
    duint start; //OUT
    duint end; //OUT
    duint instrcount; //OUT
} LOOP;

typedef struct
{
    int flags; //ADDRINFOFLAGS (IN)
    char module[MAX_MODULE_SIZE]; //module the address is in
    char label[MAX_LABEL_SIZE];
    char comment[MAX_COMMENT_SIZE];
    bool isbookmark;
    FUNCTION function;
    LOOP loop;
    FUNCTION args;
} BRIDGE_ADDRINFO;

struct SYMBOLINFO_
{
    duint addr;
    char* decoratedSymbol;
    char* undecoratedSymbol;
    bool isImported;
};

typedef struct
{
    duint base;
    char name[MAX_MODULE_SIZE];
} SYMBOLMODULEINFO;

typedef struct
{
    duint base;
    CBSYMBOLENUM cbSymbolEnum;
    void* user;
} SYMBOLCBINFO;

typedef struct
{
    bool c;
    bool p;
    bool a;
    bool z;
    bool s;
    bool t;
    bool i;
    bool d;
    bool o;
} FLAGS;

typedef struct
{
    bool FZ;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool IM;
    bool DM;
    bool DAZ;
    bool PE;
    bool UE;
    bool OE;
    bool ZE;
    bool DE;
    bool IE;

    unsigned short RC;
} MXCSRFIELDS;

typedef struct
{
    bool B;
    bool C3;
    bool C2;
    bool C1;
    bool C0;
    bool ES;
    bool SF;
    bool P;
    bool U;
    bool O;
    bool Z;
    bool D;
    bool I;

    unsigned short TOP;

} X87STATUSWORDFIELDS;

typedef struct
{
    bool IC;
    bool IEM;
    bool PM;
    bool UM;
    bool OM;
    bool ZM;
    bool DM;
    bool IM;

    unsigned short RC;
    unsigned short PC;

} X87CONTROLWORDFIELDS;

typedef struct DECLSPEC_ALIGN(16) _XMMREGISTER
{
    ULONGLONG Low;
    LONGLONG High;
} XMMREGISTER;

typedef struct
{
    XMMREGISTER Low; //XMM/SSE part
    XMMREGISTER High; //AVX part
} YMMREGISTER;

typedef struct
{
    BYTE    data[10];
    int     st_value;
    int     tag;
} X87FPUREGISTER;

typedef struct
{
    WORD   ControlWord;
    WORD   StatusWord;
    WORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    DWORD   Cr0NpxState;
} X87FPU;

typedef struct
{
    ULONG_PTR cax;
    ULONG_PTR ccx;
    ULONG_PTR cdx;
    ULONG_PTR cbx;
    ULONG_PTR csp;
    ULONG_PTR cbp;
    ULONG_PTR csi;
    ULONG_PTR cdi;
#ifdef _WIN64
    ULONG_PTR r8;
    ULONG_PTR r9;
    ULONG_PTR r10;
    ULONG_PTR r11;
    ULONG_PTR r12;
    ULONG_PTR r13;
    ULONG_PTR r14;
    ULONG_PTR r15;
#endif //_WIN64
    ULONG_PTR cip;
    ULONG_PTR eflags;
    unsigned short gs;
    unsigned short fs;
    unsigned short es;
    unsigned short ds;
    unsigned short cs;
    unsigned short ss;
    ULONG_PTR dr0;
    ULONG_PTR dr1;
    ULONG_PTR dr2;
    ULONG_PTR dr3;
    ULONG_PTR dr6;
    ULONG_PTR dr7;
    BYTE RegisterArea[80];
    X87FPU x87fpu;
    DWORD MxCsr;
#ifdef _WIN64
    XMMREGISTER XmmRegisters[16];
    YMMREGISTER YmmRegisters[16];
#else // x86
    XMMREGISTER XmmRegisters[8];
    YMMREGISTER YmmRegisters[8];
#endif
} REGISTERCONTEXT;

typedef struct
{
    DWORD code;
    char name[128];
} LASTERROR;

typedef struct
{
    REGISTERCONTEXT regcontext;
    FLAGS flags;
    X87FPUREGISTER x87FPURegisters[8];
    unsigned long long mmx[8];
    MXCSRFIELDS MxCsrFields;
    X87STATUSWORDFIELDS x87StatusWordFields;
    X87CONTROLWORDFIELDS x87ControlWordFields;
    LASTERROR lastError;
} REGDUMP;

typedef struct
{
    DISASM_ARGTYPE type; //normal/memory
    SEGMENTREG segment;
    char mnemonic[64];
    duint constant; //constant in the instruction (imm/disp)
    duint value; //equal to constant or equal to the register value
    duint memvalue; //memsize:[value]
} DISASM_ARG;

typedef struct
{
    char instruction[64];
    DISASM_INSTRTYPE type;
    int argcount;
    int instr_size;
    DISASM_ARG arg[3];
} DISASM_INSTR;

typedef struct
{
    char color[8]; //hex color-code
    char comment[MAX_COMMENT_SIZE];
} STACK_COMMENT;

typedef struct
{
    int ThreadNumber;
    HANDLE Handle;
    DWORD ThreadId;
    duint ThreadStartAddress;
    duint ThreadLocalBase;
    char threadName[MAX_THREAD_NAME_SIZE];
} THREADINFO;

typedef struct
{
    THREADINFO BasicInfo;
    duint ThreadCip;
    DWORD SuspendCount;
    THREADPRIORITY Priority;
    THREADWAITREASON WaitReason;
    DWORD LastError;
    FILETIME UserTime;
    FILETIME KernelTime;
    FILETIME CreationTime;
    ULONG64 Cycles; // Windows Vista or greater
} THREADALLINFO;

typedef struct
{
    int count;
    THREADALLINFO* list;
    int CurrentThread;
} THREADLIST;

typedef struct
{
    duint value; //displacement / addrvalue (rip-relative)
    MEMORY_SIZE size; //byte/word/dword/qword
    char mnemonic[MAX_MNEMONIC_SIZE];
} MEMORY_INFO;

typedef struct
{
    duint value;
    VALUE_SIZE size;
} VALUE_INFO;

//definitions for BASIC_INSTRUCTION_INFO.type
#define TYPE_VALUE 1
#define TYPE_MEMORY 2
#define TYPE_ADDR 4

typedef struct
{
    DWORD type; //value|memory|addr
    VALUE_INFO value; //immediat
    MEMORY_INFO memory;
    duint addr; //addrvalue (jumps + calls)
    bool branch; //jumps/calls
    bool call; //instruction is a call
    int size;
    char instruction[MAX_MNEMONIC_SIZE * 4];
} BASIC_INSTRUCTION_INFO;

typedef struct
{
    SCRIPTBRANCHTYPE type;
    int dest;
    char branchlabel[256];
} SCRIPTBRANCH;

typedef struct
{
    duint addr;
    duint start;
    duint end;
    bool manual;
    int depth;
} FUNCTION_LOOP_INFO;

typedef struct
{
    duint addr;
    XREFTYPE type;
} XREF_RECORD;

typedef struct
{
    duint refcount;
    XREF_RECORD* references;
} XREF_INFO;

//Debugger functions
BRIDGE_IMPEXP const char* DbgInit();
BRIDGE_IMPEXP void DbgExit();
BRIDGE_IMPEXP bool DbgMemRead(duint va, void* dest, duint size);
BRIDGE_IMPEXP bool DbgMemWrite(duint va, const void* src, duint size);
BRIDGE_IMPEXP duint DbgMemGetPageSize(duint base);
BRIDGE_IMPEXP duint DbgMemFindBaseAddr(duint addr, duint* size);

/// <summary>
/// Asynchronously execute a debugger command by adding it to the command queue.
/// Note: the command may not have completed before this call returns. Use this
/// function if you don't care when the command gets executed.
///
/// Example: DbgCmdExec("ClearLog")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command was successfully submitted to the command queue. False if the submission failed.</returns>
BRIDGE_IMPEXP bool DbgCmdExec(const char* cmd);

/// <summary>
/// Performs synchronous execution of a debugger command. This function call only
/// returns after the command has completed.
///
/// Example: DbgCmdExecDirect("loadlib advapi32.dll")
/// </summary>
/// <param name="cmd">The command to execute.</param>
/// <returns>True if the command executed successfully, False if there was a problem.</returns>
BRIDGE_IMPEXP bool DbgCmdExecDirect(const char* cmd);
BRIDGE_IMPEXP bool DbgMemMap(MEMMAP* memmap);
BRIDGE_IMPEXP bool DbgIsValidExpression(const char* expression);
BRIDGE_IMPEXP bool DbgIsDebugging();
BRIDGE_IMPEXP bool DbgIsJumpGoingToExecute(duint addr);
BRIDGE_IMPEXP bool DbgGetLabelAt(duint addr, SEGMENTREG segment, char* text);
BRIDGE_IMPEXP bool DbgSetLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetCommentAt(duint addr, char* text);
BRIDGE_IMPEXP bool DbgSetCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetBookmarkAt(duint addr);
BRIDGE_IMPEXP bool DbgSetBookmarkAt(duint addr, bool isbookmark);
BRIDGE_IMPEXP void DbgClearBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetModuleAt(duint addr, char* text);
BRIDGE_IMPEXP BPXTYPE DbgGetBpxTypeAt(duint addr);
BRIDGE_IMPEXP duint DbgValFromString(const char* string);
BRIDGE_IMPEXP bool DbgGetRegDump(REGDUMP* regdump);
BRIDGE_IMPEXP bool DbgValToString(const char* string, duint value);
BRIDGE_IMPEXP bool DbgMemIsValidReadPtr(duint addr);
BRIDGE_IMPEXP int DbgGetBpList(BPXTYPE type, BPMAP* list);
BRIDGE_IMPEXP FUNCTYPE DbgGetFunctionTypeAt(duint addr);
BRIDGE_IMPEXP LOOPTYPE DbgGetLoopTypeAt(duint addr, int depth);
BRIDGE_IMPEXP duint DbgGetBranchDestination(duint addr);
BRIDGE_IMPEXP void DbgScriptLoad(const char* filename);
BRIDGE_IMPEXP void DbgScriptUnload();
BRIDGE_IMPEXP void DbgScriptRun(int destline);
BRIDGE_IMPEXP void DbgScriptStep();
BRIDGE_IMPEXP bool DbgScriptBpToggle(int line);
BRIDGE_IMPEXP bool DbgScriptBpGet(int line);
BRIDGE_IMPEXP bool DbgScriptCmdExec(const char* command);
BRIDGE_IMPEXP void DbgScriptAbort();
BRIDGE_IMPEXP SCRIPTLINETYPE DbgScriptGetLineType(int line);
BRIDGE_IMPEXP void DbgScriptSetIp(int line);
BRIDGE_IMPEXP bool DbgScriptGetBranchInfo(int line, SCRIPTBRANCH* info);
BRIDGE_IMPEXP void DbgSymbolEnum(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP void DbgSymbolEnumFromCache(duint base, CBSYMBOLENUM cbSymbolEnum, void* user);
BRIDGE_IMPEXP bool DbgAssembleAt(duint addr, const char* instruction);
BRIDGE_IMPEXP duint DbgModBaseFromName(const char* name);
BRIDGE_IMPEXP void DbgDisasmAt(duint addr, DISASM_INSTR* instr);
BRIDGE_IMPEXP bool DbgStackCommentGet(duint addr, STACK_COMMENT* comment);
BRIDGE_IMPEXP void DbgGetThreadList(THREADLIST* list);
BRIDGE_IMPEXP void DbgSettingsUpdated();
BRIDGE_IMPEXP void DbgDisasmFastAt(duint addr, BASIC_INSTRUCTION_INFO* basicinfo);
BRIDGE_IMPEXP void DbgMenuEntryClicked(int hEntry);
BRIDGE_IMPEXP bool DbgFunctionGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgFunctionOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgFunctionDel(duint addr);
BRIDGE_IMPEXP bool DbgArgumentGet(duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgArgumentOverlaps(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgArgumentDel(duint addr);
BRIDGE_IMPEXP bool DbgLoopGet(int depth, duint addr, duint* start, duint* end);
BRIDGE_IMPEXP bool DbgLoopOverlaps(int depth, duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopAdd(duint start, duint end);
BRIDGE_IMPEXP bool DbgLoopDel(int depth, duint addr);
BRIDGE_IMPEXP bool DbgXrefAdd(duint addr, duint from);
BRIDGE_IMPEXP bool DbgXrefDelAll(duint addr);
BRIDGE_IMPEXP bool DbgXrefGet(duint addr, XREF_INFO* info);
BRIDGE_IMPEXP size_t DbgGetXrefCountAt(duint addr);
BRIDGE_IMPEXP XREFTYPE DbgGetXrefTypeAt(duint addr);
BRIDGE_IMPEXP bool DbgIsRunLocked();
BRIDGE_IMPEXP bool DbgIsBpDisabled(duint addr);
BRIDGE_IMPEXP bool DbgSetAutoCommentAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoCommentRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoLabelAt(duint addr, const char* text);
BRIDGE_IMPEXP void DbgClearAutoLabelRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoBookmarkAt(duint addr);
BRIDGE_IMPEXP void DbgClearAutoBookmarkRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgSetAutoFunctionAt(duint start, duint end);
BRIDGE_IMPEXP void DbgClearAutoFunctionRange(duint start, duint end);
BRIDGE_IMPEXP bool DbgGetStringAt(duint addr, char* text);
BRIDGE_IMPEXP const DBGFUNCTIONS* DbgFunctions();
BRIDGE_IMPEXP bool DbgWinEvent(MSG* message, long* result);
BRIDGE_IMPEXP bool DbgWinEventGlobal(MSG* message);
BRIDGE_IMPEXP bool DbgIsRunning();
BRIDGE_IMPEXP duint DbgGetTimeWastedCounter();
BRIDGE_IMPEXP ARGTYPE DbgGetArgTypeAt(duint addr);
BRIDGE_IMPEXP void* DbgGetEncodeTypeBuffer(duint addr, duint* size);
BRIDGE_IMPEXP void DbgReleaseEncodeTypeBuffer(void* buffer);
BRIDGE_IMPEXP ENCODETYPE DbgGetEncodeTypeAt(duint addr, duint size);
BRIDGE_IMPEXP duint DbgGetEncodeSizeAt(duint addr, duint codesize);
BRIDGE_IMPEXP bool DbgSetEncodeType(duint addr, duint size, ENCODETYPE type);
BRIDGE_IMPEXP void DbgDelEncodeTypeRange(duint start, duint end);
BRIDGE_IMPEXP void DbgDelEncodeTypeSegment(duint start);
BRIDGE_IMPEXP bool DbgGetWatchList(ListOf(WATCHINFO) list);
BRIDGE_IMPEXP void DbgSelChanged(int hWindow, duint VA);
BRIDGE_IMPEXP HANDLE DbgGetProcessHandle();
BRIDGE_IMPEXP HANDLE DbgGetThreadHandle();
BRIDGE_IMPEXP DWORD DbgGetProcessId();
BRIDGE_IMPEXP DWORD DbgGetThreadId();
BRIDGE_IMPEXP duint DbgGetPebAddress(DWORD ProcessId);
BRIDGE_IMPEXP duint DbgGetTebAddress(DWORD ThreadId);
BRIDGE_IMPEXP bool DbgAnalyzeFunction(duint entry, BridgeCFGraphList* graph);
BRIDGE_IMPEXP duint DbgEval(const char* expression, bool* success = 0);
BRIDGE_IMPEXP void DbgMenuPrepare(int hMenu);

//Gui defines
#define GUI_PLUGIN_MENU 0
#define GUI_DISASM_MENU 1
#define GUI_DUMP_MENU 2
#define GUI_STACK_MENU 3

#define GUI_DISASSEMBLY 0
#define GUI_DUMP 1
#define GUI_STACK 2
#define GUI_GRAPH 3
#define GUI_MEMMAP 4
#define GUI_SYMMOD 5

#define GUI_MAX_LINE_SIZE 65536
#define GUI_MAX_DISASSEMBLY_SIZE 2048

//Gui enums
typedef enum
{
    GUI_DISASSEMBLE_AT,             // param1=(duint)va,            param2=(duint)cip
    GUI_SET_DEBUG_STATE,            // param1=(DBGSTATE)state,      param2=unused
    GUI_ADD_MSG_TO_LOG,             // param1=(const char*)msg,     param2=unused
    GUI_CLEAR_LOG,                  // param1=unused,               param2=unused
    GUI_UPDATE_REGISTER_VIEW,       // param1=unused,               param2=unused
    GUI_UPDATE_DISASSEMBLY_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_BREAKPOINTS_VIEW,    // param1=unused,               param2=unused
    GUI_UPDATE_WINDOW_TITLE,        // param1=(const char*)file,    param2=unused
    GUI_GET_WINDOW_HANDLE,          // param1=unused,               param2=unused
    GUI_DUMP_AT,                    // param1=(duint)va             param2=unused
    GUI_SCRIPT_ADD,                 // param1=int count,            param2=const char** lines
    GUI_SCRIPT_CLEAR,               // param1=unused,               param2=unused
    GUI_SCRIPT_SETIP,               // param1=int line,             param2=unused
    GUI_SCRIPT_ERROR,               // param1=int line,             param2=const char* message
    GUI_SCRIPT_SETTITLE,            // param1=const char* title,    param2=unused
    GUI_SCRIPT_SETINFOLINE,         // param1=int line,             param2=const char* info
    GUI_SCRIPT_MESSAGE,             // param1=const char* message,  param2=unused
    GUI_SCRIPT_MSGYN,               // param1=const char* message,  param2=unused
    GUI_SYMBOL_LOG_ADD,             // param1(const char*)msg,      param2=unused
    GUI_SYMBOL_LOG_CLEAR,           // param1=unused,               param2=unused
    GUI_SYMBOL_SET_PROGRESS,        // param1=int percent           param2=unused
    GUI_SYMBOL_UPDATE_MODULE_LIST,  // param1=int count,            param2=SYMBOLMODULEINFO* modules
    GUI_REF_ADDCOLUMN,              // param1=int width,            param2=(const char*)title
    GUI_REF_SETROWCOUNT,            // param1=int rows,             param2=unused
    GUI_REF_GETROWCOUNT,            // param1=unused,               param2=unused
    GUI_REF_DELETEALLCOLUMNS,       // param1=unused,               param2=unused
    GUI_REF_SETCELLCONTENT,         // param1=(CELLINFO*)info,      param2=unused
    GUI_REF_GETCELLCONTENT,         // param1=int row,              param2=int col
    GUI_REF_RELOADDATA,             // param1=unused,               param2=unused
    GUI_REF_SETSINGLESELECTION,     // param1=int index,            param2=bool scroll
    GUI_REF_SETPROGRESS,            // param1=int progress,         param2=unused
    GUI_REF_SETCURRENTTASKPROGRESS, // param1=int progress,         param2=const char* taskTitle
    GUI_REF_SETSEARCHSTARTCOL,      // param1=int col               param2=unused
    GUI_STACK_DUMP_AT,              // param1=duint addr,           param2=duint csp
    GUI_UPDATE_DUMP_VIEW,           // param1=unused,               param2=unused
    GUI_UPDATE_THREAD_VIEW,         // param1=unused,               param2=unused
    GUI_ADD_RECENT_FILE,            // param1=(const char*)file,    param2=unused
    GUI_SET_LAST_EXCEPTION,         // param1=unsigned int code,    param2=unused
    GUI_GET_DISASSEMBLY,            // param1=duint addr,           param2=char* text
    GUI_MENU_ADD,                   // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_ENTRY,             // param1=int hMenu,            param2=const char* title
    GUI_MENU_ADD_SEPARATOR,         // param1=int hMenu,            param2=unused
    GUI_MENU_CLEAR,                 // param1=int hMenu,            param2=unused
    GUI_SELECTION_GET,              // param1=int hWindow,          param2=SELECTIONDATA* selection
    GUI_SELECTION_SET,              // param1=int hWindow,          param2=const SELECTIONDATA* selection
    GUI_GETLINE_WINDOW,             // param1=const char* title,    param2=char* text
    GUI_AUTOCOMPLETE_ADDCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_DELCMD,        // param1=const char* cmd,      param2=ununsed
    GUI_AUTOCOMPLETE_CLEARALL,      // param1=unused,               param2=unused
    GUI_SCRIPT_ENABLEHIGHLIGHTING,  // param1=bool enable,          param2=unused
    GUI_ADD_MSG_TO_STATUSBAR,       // param1=const char* msg,      param2=unused
    GUI_UPDATE_SIDEBAR,             // param1=unused,               param2=unused
    GUI_REPAINT_TABLE_VIEW,         // param1=unused,               param2=unused
    GUI_UPDATE_PATCHES,             // param1=unused,               param2=unused
    GUI_UPDATE_CALLSTACK,           // param1=unused,               param2=unused
    GUI_UPDATE_SEHCHAIN,            // param1=unused,               param2=unused
    GUI_SYMBOL_REFRESH_CURRENT,     // param1=unused,               param2=unused
    GUI_UPDATE_MEMORY_VIEW,         // param1=unused,               param2=unused
    GUI_REF_INITIALIZE,             // param1=const char* name,     param2=unused
    GUI_LOAD_SOURCE_FILE,           // param1=const char* path,     param2=line
    GUI_MENU_SET_ICON,              // param1=int hMenu,            param2=ICONINFO*
    GUI_MENU_SET_ENTRY_ICON,        // param1=int hEntry,           param2=ICONINFO*
    GUI_SHOW_CPU,                   // param1=unused,               param2=unused
    GUI_ADD_QWIDGET_TAB,            // param1=QWidget*,             param2=unused
    GUI_SHOW_QWIDGET_TAB,           // param1=QWidget*,             param2=unused
    GUI_CLOSE_QWIDGET_TAB,          // param1=QWidget*,             param2=unused
    GUI_EXECUTE_ON_GUI_THREAD,      // param1=GUICALLBACK,          param2=unused
    GUI_UPDATE_TIME_WASTED_COUNTER, // param1=unused,               param2=unused
    GUI_SET_GLOBAL_NOTES,           // param1=const char* text,     param2=unused
    GUI_GET_GLOBAL_NOTES,           // param1=char** text,          param2=unused
    GUI_SET_DEBUGGEE_NOTES,         // param1=const char* text,     param2=unused
    GUI_GET_DEBUGGEE_NOTES,         // param1=char** text,          param2=unused
    GUI_DUMP_AT_N,                  // param1=int index,            param2=duint va
    GUI_DISPLAY_WARNING,            // param1=const char *text,     param2=unused
    GUI_REGISTER_SCRIPT_LANG,       // param1=SCRIPTTYPEINFO* info, param2=unused
    GUI_UNREGISTER_SCRIPT_LANG,     // param1=int id,               param2=unused
    GUI_UPDATE_ARGUMENT_VIEW,       // param1=unused,               param2=unused
    GUI_FOCUS_VIEW,                 // param1=int hWindow,          param2=unused
    GUI_UPDATE_WATCH_VIEW,          // param1=unused,               param2=unused
    GUI_LOAD_GRAPH,                 // param1=BridgeCFGraphList*    param2=unused
    GUI_GRAPH_AT,                   // param1=duint addr            param2=unused
    GUI_UPDATE_GRAPH_VIEW,          // param1=unused,               param2=unused
    GUI_SET_LOG_ENABLED,            // param1=bool isEnabled        param2=unused
    GUI_ADD_FAVOURITE_TOOL,         // param1=const char* name      param2=const char* description
    GUI_ADD_FAVOURITE_COMMAND,      // param1=const char* command   param2=const char* shortcut
    GUI_SET_FAVOURITE_TOOL_SHORTCUT,// param1=const char* name      param2=const char* shortcut
    GUI_FOLD_DISASSEMBLY,           // param1=duint startAddress    param2=duint length
    GUI_SELECT_IN_MEMORY_MAP,       // param1=duint addr,           param2=unused
    GUI_GET_ACTIVE_VIEW,            // param1=ACTIVEVIEW*,          param2=unused
    GUI_MENU_SET_ENTRY_CHECKED,     // param1=int hEntry,           param2=bool checked
    GUI_ADD_INFO_LINE,              // param1=const char* infoline, param2=unused
    GUI_PROCESS_EVENTS,             // param1=unused,               param2=unused
    GUI_TYPE_ADDNODE,               // param1=void* parent,         param2=TYPEDESCRIPTOR* type
    GUI_TYPE_CLEAR,                 // param1=unused,               param2=unused
    GUI_UPDATE_TYPE_WIDGET,         // param1=unused,               param2=unused
    GUI_CLOSE_APPLICATION,          // param1=unused,               param2=unused
    GUI_MENU_SET_VISIBLE,           // param1=int hMenu,            param2=bool visible
    GUI_MENU_SET_ENTRY_VISIBLE,     // param1=int hEntry,           param2=bool visible
    GUI_MENU_SET_NAME,              // param1=int hMenu,            param2=const char* name
    GUI_MENU_SET_ENTRY_NAME,        // param1=int hEntry,           param2=const char* name
    GUI_FLUSH_LOG,                  // param1=unused,               param2=unused
    GUI_MENU_SET_ENTRY_HOTKEY,      // param1=int hEntry,           param2=const char* hack
    GUI_REF_SEARCH_GETROWCOUNT,     // param1=unused,               param2=unused
    GUI_REF_SEARCH_GETCELLCONTENT,  // param1=int row,              param2=int col
    GUI_MENU_REMOVE,                // param1=int hEntryMenu,       param2=unused
    GUI_REF_ADDCOMMAND              // param1=const char* title,    param2=const char* command
} GUIMSG;

//GUI Typedefs
struct _TYPEDESCRIPTOR;

typedef void (*GUICALLBACK)();
typedef bool (*GUISCRIPTEXECUTE)(const char* text);
typedef void (*GUISCRIPTCOMPLETER)(const char* text, char** entries, int* entryCount);
typedef bool (*TYPETOSTRING)(const struct _TYPEDESCRIPTOR* type, char* dest, size_t* destCount); //don't change destCount for final failure

//GUI structures
typedef struct
{
    int row;
    int col;
    const char* str;
} CELLINFO;

typedef struct
{
    duint start;
    duint end;
} SELECTIONDATA;

typedef struct
{
    const void* data;
    duint size;
} ICONDATA;

typedef struct
{
    char name[64];
    int id;
    GUISCRIPTEXECUTE execute;
    GUISCRIPTCOMPLETER completeCommand;
} SCRIPTTYPEINFO;

typedef struct
{
    void* titleHwnd;
    void* classHwnd;
    char title[MAX_STRING_SIZE];
    char className[MAX_STRING_SIZE];
} ACTIVEVIEW;

typedef struct _TYPEDESCRIPTOR
{
    bool expanded; //is the type node expanded?
    bool reverse; //big endian?
    const char* name; //type name (int b)
    duint addr; //virtual address
    duint offset; //offset to addr for the actual location
    int id; //type id
    int size; //sizeof(type)
    TYPETOSTRING callback; //convert to string
    void* userdata; //user data
} TYPEDESCRIPTOR;

//GUI functions
//code page is utf8
BRIDGE_IMPEXP const char* GuiTranslateText(const char* Source);
BRIDGE_IMPEXP void GuiDisasmAt(duint addr, duint cip);
BRIDGE_IMPEXP void GuiSetDebugState(DBGSTATE state);
BRIDGE_IMPEXP void GuiSetDebugStateFast(DBGSTATE state);
BRIDGE_IMPEXP void GuiAddLogMessage(const char* msg);
BRIDGE_IMPEXP void GuiLogClear();
BRIDGE_IMPEXP void GuiUpdateAllViews();
BRIDGE_IMPEXP void GuiUpdateRegisterView();
BRIDGE_IMPEXP void GuiUpdateDisassemblyView();
BRIDGE_IMPEXP void GuiUpdateBreakpointsView();
BRIDGE_IMPEXP void GuiUpdateWindowTitle(const char* filename);
BRIDGE_IMPEXP HWND GuiGetWindowHandle();
BRIDGE_IMPEXP void GuiDumpAt(duint va);
BRIDGE_IMPEXP void GuiScriptAdd(int count, const char** lines);
BRIDGE_IMPEXP void GuiScriptClear();
BRIDGE_IMPEXP void GuiScriptSetIp(int line);
BRIDGE_IMPEXP void GuiScriptError(int line, const char* message);
BRIDGE_IMPEXP void GuiScriptSetTitle(const char* title);
BRIDGE_IMPEXP void GuiScriptSetInfoLine(int line, const char* info);
BRIDGE_IMPEXP void GuiScriptMessage(const char* message);
BRIDGE_IMPEXP int GuiScriptMsgyn(const char* message);
BRIDGE_IMPEXP void GuiScriptEnableHighlighting(bool enable);
BRIDGE_IMPEXP void GuiSymbolLogAdd(const char* message);
BRIDGE_IMPEXP void GuiSymbolLogClear();
BRIDGE_IMPEXP void GuiSymbolSetProgress(int percent);
BRIDGE_IMPEXP void GuiSymbolUpdateModuleList(int count, SYMBOLMODULEINFO* modules);
BRIDGE_IMPEXP void GuiSymbolRefreshCurrent();
BRIDGE_IMPEXP void GuiReferenceAddColumn(int width, const char* title);
BRIDGE_IMPEXP void GuiReferenceSetRowCount(int count);
BRIDGE_IMPEXP int GuiReferenceGetRowCount();
BRIDGE_IMPEXP int GuiReferenceSearchGetRowCount();
BRIDGE_IMPEXP void GuiReferenceDeleteAllColumns();
BRIDGE_IMPEXP void GuiReferenceInitialize(const char* name);
BRIDGE_IMPEXP void GuiReferenceSetCellContent(int row, int col, const char* str);
BRIDGE_IMPEXP char* GuiReferenceGetCellContent(int row, int col);
BRIDGE_IMPEXP char* GuiReferenceSearchGetCellContent(int row, int col);
BRIDGE_IMPEXP void GuiReferenceReloadData();
BRIDGE_IMPEXP void GuiReferenceSetSingleSelection(int index, bool scroll);
BRIDGE_IMPEXP void GuiReferenceSetProgress(int progress);
BRIDGE_IMPEXP void GuiReferenceSetCurrentTaskProgress(int progress, const char* taskTitle);
BRIDGE_IMPEXP void GuiReferenceSetSearchStartCol(int col);
BRIDGE_IMPEXP void GuiStackDumpAt(duint addr, duint csp);
BRIDGE_IMPEXP void GuiUpdateDumpView();
BRIDGE_IMPEXP void GuiUpdateWatchView();
BRIDGE_IMPEXP void GuiUpdateThreadView();
BRIDGE_IMPEXP void GuiUpdateMemoryView();
BRIDGE_IMPEXP void GuiAddRecentFile(const char* file);
BRIDGE_IMPEXP void GuiSetLastException(unsigned int exception);
BRIDGE_IMPEXP bool GuiGetDisassembly(duint addr, char* text);
BRIDGE_IMPEXP int GuiMenuAdd(int hMenu, const char* title);
BRIDGE_IMPEXP int GuiMenuAddEntry(int hMenu, const char* title);
BRIDGE_IMPEXP void GuiMenuAddSeparator(int hMenu);
BRIDGE_IMPEXP void GuiMenuClear(int hMenu);
BRIDGE_IMPEXP void GuiMenuRemove(int hEntryMenu);
BRIDGE_IMPEXP bool GuiSelectionGet(int hWindow, SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiSelectionSet(int hWindow, const SELECTIONDATA* selection);
BRIDGE_IMPEXP bool GuiGetLineWindow(const char* title, char* text);
BRIDGE_IMPEXP void GuiAutoCompleteAddCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteDelCmd(const char* cmd);
BRIDGE_IMPEXP void GuiAutoCompleteClearAll();
BRIDGE_IMPEXP void GuiAddStatusBarMessage(const char* msg);
BRIDGE_IMPEXP void GuiUpdateSideBar();
BRIDGE_IMPEXP void GuiRepaintTableView();
BRIDGE_IMPEXP void GuiUpdatePatches();
BRIDGE_IMPEXP void GuiUpdateCallStack();
BRIDGE_IMPEXP void GuiUpdateSEHChain();
BRIDGE_IMPEXP void GuiLoadSourceFile(const char* path, int line);
BRIDGE_IMPEXP void GuiMenuSetIcon(int hMenu, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryIcon(int hEntry, const ICONDATA* icon);
BRIDGE_IMPEXP void GuiMenuSetEntryChecked(int hEntry, bool checked);
BRIDGE_IMPEXP void GuiMenuSetVisible(int hMenu, bool visible);
BRIDGE_IMPEXP void GuiMenuSetEntryVisible(int hEntry, bool visible);
BRIDGE_IMPEXP void GuiMenuSetName(int hMenu, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryName(int hEntry, const char* name);
BRIDGE_IMPEXP void GuiMenuSetEntryHotkey(int hEntry, const char* hack);
BRIDGE_IMPEXP void GuiShowCpu();
BRIDGE_IMPEXP void GuiAddQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiShowQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiCloseQWidgetTab(void* qWidget);
BRIDGE_IMPEXP void GuiExecuteOnGuiThread(GUICALLBACK cbGuiThread);
BRIDGE_IMPEXP void GuiUpdateTimeWastedCounter();
BRIDGE_IMPEXP void GuiSetGlobalNotes(const char* text);
BRIDGE_IMPEXP void GuiGetGlobalNotes(char** text);
BRIDGE_IMPEXP void GuiSetDebuggeeNotes(const char* text);
BRIDGE_IMPEXP void GuiGetDebuggeeNotes(char** text);
BRIDGE_IMPEXP void GuiDumpAtN(duint va, int index);
BRIDGE_IMPEXP void GuiDisplayWarning(const char* title, const char* text);
BRIDGE_IMPEXP void GuiRegisterScriptLanguage(SCRIPTTYPEINFO* info);
BRIDGE_IMPEXP void GuiUnregisterScriptLanguage(int id);
BRIDGE_IMPEXP void GuiUpdateArgumentWidget();
BRIDGE_IMPEXP void GuiFocusView(int hWindow);
BRIDGE_IMPEXP bool GuiIsUpdateDisabled();
BRIDGE_IMPEXP void GuiUpdateEnable(bool updateNow);
BRIDGE_IMPEXP void GuiUpdateDisable();
BRIDGE_IMPEXP bool GuiLoadGraph(BridgeCFGraphList* graph, duint addr);
BRIDGE_IMPEXP duint GuiGraphAt(duint addr);
BRIDGE_IMPEXP void GuiUpdateGraphView();
BRIDGE_IMPEXP void GuiDisableLog();
BRIDGE_IMPEXP void GuiEnableLog();
BRIDGE_IMPEXP void GuiAddFavouriteTool(const char* name, const char* description);
BRIDGE_IMPEXP void GuiAddFavouriteCommand(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiSetFavouriteToolShortcut(const char* name, const char* shortcut);
BRIDGE_IMPEXP void GuiFoldDisassembly(duint startAddress, duint length);
BRIDGE_IMPEXP void GuiSelectInMemoryMap(duint addr);
BRIDGE_IMPEXP void GuiGetActiveView(ACTIVEVIEW* activeView);
BRIDGE_IMPEXP void GuiAddInfoLine(const char* infoLine);
BRIDGE_IMPEXP void GuiProcessEvents();
BRIDGE_IMPEXP void* GuiTypeAddNode(void* parent, const TYPEDESCRIPTOR* type);
BRIDGE_IMPEXP bool GuiTypeClear();
BRIDGE_IMPEXP void GuiUpdateTypeWidget();
BRIDGE_IMPEXP void GuiCloseApplication();
BRIDGE_IMPEXP void GuiFlushLog();
BRIDGE_IMPEXP void GuiReferenceAddCommand(const char* title, const char* command);

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif // _BRIDGEMAIN_H_



================================================
File: 3rdparty/x64dbg/jansson/jansson.h
================================================
/*
 * Copyright (c) 2009-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 */

#ifndef JANSSON_H
#define JANSSON_H

#include <stdio.h>
#include <stdlib.h>  /* for size_t */
#include <stdarg.h>

#include "jansson_config.h"

#ifdef __cplusplus
extern "C" {
#endif

/* version */

#define JANSSON_MAJOR_VERSION  2
#define JANSSON_MINOR_VERSION  9
#define JANSSON_MICRO_VERSION  0

/* Micro version is omitted if it's 0 */
#define JANSSON_VERSION  "2.9"

/* Version as a 3-byte hex number, e.g. 0x010201 == 1.2.1. Use this
   for numeric comparisons, e.g. #if JANSSON_VERSION_HEX >= ... */
#define JANSSON_VERSION_HEX  ((JANSSON_MAJOR_VERSION << 16) |   \
                              (JANSSON_MINOR_VERSION << 8)  |   \
                              (JANSSON_MICRO_VERSION << 0))


/* types */

typedef enum
{
    JSON_OBJECT,
    JSON_ARRAY,
    JSON_STRING,
    JSON_INTEGER,
    JSON_REAL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NULL
} json_type;

typedef struct json_t
{
    json_type type;
    size_t refcount;
} json_t;

#ifndef JANSSON_USING_CMAKE /* disabled if using cmake */
#if JSON_INTEGER_IS_LONG_LONG
#ifdef _WIN32
#define JSON_INTEGER_FORMAT "I64d"
#else
#define JSON_INTEGER_FORMAT "lld"
#endif
typedef long long json_int_t;
#else
#define JSON_INTEGER_FORMAT "ld"
typedef long json_int_t;
#endif /* JSON_INTEGER_IS_LONG_LONG */
#endif

#define json_typeof(json)      ((json)->type)
#define json_is_object(json)   ((json) && json_typeof(json) == JSON_OBJECT)
#define json_is_array(json)    ((json) && json_typeof(json) == JSON_ARRAY)
#define json_is_string(json)   ((json) && json_typeof(json) == JSON_STRING)
#define json_is_integer(json)  ((json) && json_typeof(json) == JSON_INTEGER)
#define json_is_real(json)     ((json) && json_typeof(json) == JSON_REAL)
#define json_is_number(json)   (json_is_integer(json) || json_is_real(json))
#define json_is_true(json)     ((json) && json_typeof(json) == JSON_TRUE)
#define json_is_false(json)    ((json) && json_typeof(json) == JSON_FALSE)
#define json_boolean_value     json_is_true
#define json_is_boolean(json)  (json_is_true(json) || json_is_false(json))
#define json_is_null(json)     ((json) && json_typeof(json) == JSON_NULL)

/* construction, destruction, reference counting */

__declspec(dllimport) json_t* json_object(void);
__declspec(dllimport) json_t* json_array(void);
__declspec(dllimport) json_t* json_string(const char* value);
__declspec(dllimport) json_t* json_stringn(const char* value, size_t len);
__declspec(dllimport) json_t* json_string_nocheck(const char* value);
__declspec(dllimport) json_t* json_stringn_nocheck(const char* value, size_t len);
__declspec(dllimport) json_t* json_integer(json_int_t value);
__declspec(dllimport) json_t* json_real(double value);
__declspec(dllimport) json_t* json_true(void);
__declspec(dllimport) json_t* json_false(void);
#define json_boolean(val)      ((val) ? json_true() : json_false())
__declspec(dllimport) json_t* json_null(void);

static JSON_INLINE
json_t* json_incref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1)
        ++json->refcount;
    return json;
}

/* do not call json_delete directly */
__declspec(dllimport) void json_delete(json_t* json);

static JSON_INLINE
void json_decref(json_t* json)
{
    if(json && json->refcount != (size_t) - 1 && --json->refcount == 0)
        json_delete(json);
}

#if defined(__GNUC__) || defined(__clang__)
static JSON_INLINE
void json_decrefp(json_t** json)
{
    if(json)
    {
        json_decref(*json);
        *json = NULL;
    }
}

#define json_auto_t json_t __attribute__((cleanup(json_decrefp)))
#endif


/* error reporting */

#define JSON_ERROR_TEXT_LENGTH    160
#define JSON_ERROR_SOURCE_LENGTH   80

typedef struct
{
    int line;
    int column;
    int position;
    char source[JSON_ERROR_SOURCE_LENGTH];
    char text[JSON_ERROR_TEXT_LENGTH];
} json_error_t;


/* getters, setters, manipulation */

__declspec(dllimport) void json_object_seed(size_t seed);
__declspec(dllimport) size_t json_object_size(const json_t* object);
__declspec(dllimport) json_t* json_object_get(const json_t* object, const char* key);
__declspec(dllimport) int json_object_set_new(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_set_new_nocheck(json_t* object, const char* key, json_t* value);
__declspec(dllimport) int json_object_del(json_t* object, const char* key);
__declspec(dllimport) int json_object_clear(json_t* object);
__declspec(dllimport) int json_object_update(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_existing(json_t* object, json_t* other);
__declspec(dllimport) int json_object_update_missing(json_t* object, json_t* other);
__declspec(dllimport) void* json_object_iter(json_t* object);
__declspec(dllimport) void* json_object_iter_at(json_t* object, const char* key);
__declspec(dllimport) void* json_object_key_to_iter(const char* key);
__declspec(dllimport) void* json_object_iter_next(json_t* object, void* iter);
__declspec(dllimport) const char* json_object_iter_key(void* iter);
__declspec(dllimport) json_t* json_object_iter_value(void* iter);
__declspec(dllimport) int json_object_iter_set_new(json_t* object, void* iter, json_t* value);

#define json_object_foreach(object, key, value) \
    for(key = json_object_iter_key(json_object_iter(object)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(json_object_iter_next(object, json_object_key_to_iter(key))))

#define json_object_foreach_safe(object, n, key, value)     \
    for(key = json_object_iter_key(json_object_iter(object)), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)); \
        key && (value = json_object_iter_value(json_object_key_to_iter(key))); \
        key = json_object_iter_key(n), \
            n = json_object_iter_next(object, json_object_key_to_iter(key)))

#define json_array_foreach(array, index, value) \
    for(index = 0; \
        index < json_array_size(array) && (value = json_array_get(array, index)); \
        index++)

static JSON_INLINE
int json_object_set(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_set_nocheck(json_t* object, const char* key, json_t* value)
{
    return json_object_set_new_nocheck(object, key, json_incref(value));
}

static JSON_INLINE
int json_object_iter_set(json_t* object, void* iter, json_t* value)
{
    return json_object_iter_set_new(object, iter, json_incref(value));
}

__declspec(dllimport) size_t json_array_size(const json_t* array);
__declspec(dllimport) json_t* json_array_get(const json_t* array, size_t index);
__declspec(dllimport) int json_array_set_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_append_new(json_t* array, json_t* value);
__declspec(dllimport) int json_array_insert_new(json_t* array, size_t index, json_t* value);
__declspec(dllimport) int json_array_remove(json_t* array, size_t index);
__declspec(dllimport) int json_array_clear(json_t* array);
__declspec(dllimport) int json_array_extend(json_t* array, json_t* other);

static JSON_INLINE
int json_array_set(json_t* array, size_t ind, json_t* value)
{
    return json_array_set_new(array, ind, json_incref(value));
}

static JSON_INLINE
int json_array_append(json_t* array, json_t* value)
{
    return json_array_append_new(array, json_incref(value));
}

static JSON_INLINE
int json_array_insert(json_t* array, size_t ind, json_t* value)
{
    return json_array_insert_new(array, ind, json_incref(value));
}

__declspec(dllimport) const char* json_string_value(const json_t* string);
__declspec(dllimport) size_t json_string_length(const json_t* string);
__declspec(dllimport) json_int_t json_integer_value(const json_t* integer);
__declspec(dllimport) double json_real_value(const json_t* real);
__declspec(dllimport) double json_number_value(const json_t* json);

__declspec(dllimport) int json_string_set(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_string_set_nocheck(json_t* string, const char* value);
__declspec(dllimport) int json_string_setn_nocheck(json_t* string, const char* value, size_t len);
__declspec(dllimport) int json_integer_set(json_t* integer, json_int_t value);
__declspec(dllimport) int json_real_set(json_t* real, double value);

/* pack, unpack */

__declspec(dllimport) json_t* json_pack(const char* fmt, ...);
__declspec(dllimport) json_t* json_pack_ex(json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) json_t* json_vpack_ex(json_error_t* error, size_t flags, const char* fmt, va_list ap);

#define JSON_VALIDATE_ONLY  0x1
#define JSON_STRICT         0x2

__declspec(dllimport) int json_unpack(json_t* root, const char* fmt, ...);
__declspec(dllimport) int json_unpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, ...);
__declspec(dllimport) int json_vunpack_ex(json_t* root, json_error_t* error, size_t flags, const char* fmt, va_list ap);


/* equality */

__declspec(dllimport) int json_equal(json_t* value1, json_t* value2);


/* copying */

__declspec(dllimport) json_t* json_copy(json_t* value);
__declspec(dllimport) json_t* json_deep_copy(const json_t* value);


/* decoding */

#define JSON_REJECT_DUPLICATES  0x1
#define JSON_DISABLE_EOF_CHECK  0x2
#define JSON_DECODE_ANY         0x4
#define JSON_DECODE_INT_AS_REAL 0x8
#define JSON_ALLOW_NUL          0x10

typedef size_t (*json_load_callback_t)(void* buffer, size_t buflen, void* data);

__declspec(dllimport) json_t* json_loads(const char* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadb(const char* buffer, size_t buflen, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_loadf(FILE* input, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_file(const char* path, size_t flags, json_error_t* error);
__declspec(dllimport) json_t* json_load_callback(json_load_callback_t callback, void* data, size_t flags, json_error_t* error);


/* encoding */

#define JSON_MAX_INDENT         0x1F
#define JSON_INDENT(n)          ((n) & JSON_MAX_INDENT)
#define JSON_COMPACT            0x20
#define JSON_ENSURE_ASCII       0x40
#define JSON_SORT_KEYS          0x80
#define JSON_PRESERVE_ORDER     0x100
#define JSON_ENCODE_ANY         0x200
#define JSON_ESCAPE_SLASH       0x400
#define JSON_REAL_PRECISION(n)  (((n) & 0x1F) << 11)

typedef int (*json_dump_callback_t)(const char* buffer, size_t size, void* data);

__declspec(dllimport) char* json_dumps(const json_t* json, size_t flags);
__declspec(dllimport) int json_dumpf(const json_t* json, FILE* output, size_t flags);
__declspec(dllimport) int json_dump_file(const json_t* json, const char* path, size_t flags);
__declspec(dllimport) int json_dump_callback(const json_t* json, json_dump_callback_t callback, void* data, size_t flags);

/* custom memory allocation */

typedef void* (*json_malloc_t)(size_t);
typedef void (*json_free_t)(void*);

__declspec(dllimport) void json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn);
__declspec(dllimport) void json_get_alloc_funcs(json_malloc_t* malloc_fn, json_free_t* free_fn);

#ifdef __cplusplus
}
#endif

#endif



================================================
File: 3rdparty/x64dbg/jansson/jansson_config.h
================================================
/*
 * Copyright (c) 2010-2016 Petri Lehtinen <petri@digip.org>
 *
 * Jansson is free software; you can redistribute it and/or modify
 * it under the terms of the MIT license. See LICENSE for details.
 *
 *
 * This file specifies a part of the site-specific configuration for
 * Jansson, namely those things that affect the public API in
 * jansson.h.
 *
 * The CMake system will generate the jansson_config.h file and
 * copy it to the build and install directories.
 */

#ifndef JANSSON_CONFIG_H
#define JANSSON_CONFIG_H

/* Define this so that we can disable scattered automake configuration in source files */
#ifndef JANSSON_USING_CMAKE
#define JANSSON_USING_CMAKE
#endif

/* Note: when using cmake, JSON_INTEGER_IS_LONG_LONG is not defined nor used,
 * as we will also check for __int64 etc types.
 * (the definition was used in the automake system) */

/* Bring in the cmake-detected defines */
#define HAVE_STDINT_H 1
/* #undef HAVE_INTTYPES_H */
/* #undef HAVE_SYS_TYPES_H */

/* Include our standard type header for the integer typedef */

#if defined(HAVE_STDINT_H)
#  include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#  include <inttypes.h>
#elif defined(HAVE_SYS_TYPES_H)
#  include <sys/types.h>
#endif


/* If your compiler supports the inline keyword in C, JSON_INLINE is
   defined to `inline', otherwise empty. In C++, the inline is always
   supported. */
#ifdef __cplusplus
#define JSON_INLINE inline
#else
#define JSON_INLINE __inline
#endif


#define json_int_t long long
#define json_strtoint strtoll
#define JSON_INTEGER_FORMAT "I64d"


/* If locale.h and localeconv() are available, define to 1, otherwise to 0. */
#define JSON_HAVE_LOCALECONV 1


/* Maximum recursion depth for parsing JSON input.
   This limits the depth of e.g. array-within-array constructions. */
#define JSON_PARSER_MAX_DEPTH 2048


#endif



================================================
File: 3rdparty/x64dbg/jansson/jansson_x64dbg.h
================================================
#pragma once

#include "jansson.h"

typedef json_t* JSON;

static JSON_INLINE
json_t* json_hex(unsigned json_int_t value)
{
    char hexvalue[20];
    sprintf_s(hexvalue, "0x%llX", value);
    return json_string(hexvalue);
}

static JSON_INLINE
unsigned json_int_t json_hex_value(const json_t* hex)
{
    unsigned json_int_t ret = 0;
    const char* hexvalue;
    hexvalue = json_string_value(hex);
    if(!hexvalue)
        return 0;
    sscanf_s(hexvalue, "0x%llX", &ret);
    return ret;
}


================================================
File: ConfigCollection/scylla_hide.ini
================================================
[SETTINGS]
CurrentProfile=VMProtect x86/x64
[VMProtect x86/x64]
DLLNormal=1
DLLStealth=0
DLLUnload=0
GetLocalTimeHook=0
GetSystemTimeHook=0
GetTickCount64Hook=0
GetTickCountHook=0
KiUserExceptionDispatcherHook=0
NtCloseHook=1
NtContinueHook=0
NtCreateThreadExHook=0
NtGetContextThreadHook=0
NtQueryInformationProcessHook=1
NtQueryObjectHook=1
NtQueryPerformanceCounterHook=0
NtQuerySystemInformationHook=0
NtQuerySystemTimeHook=0
NtSetContextThreadHook=0
NtSetDebugFilterStateHook=0
NtSetInformationThreadHook=1
NtUserBuildHwndListHook=0
NtUserFindWindowExHook=0
NtUserQueryWindowHook=0
NtUserGetForegroundWindowHook=0
NtYieldExecutionHook=0
OutputDebugStringHook=0
PebBeingDebugged=1
PebHeapFlags=1
PebNtGlobalFlag=1
PebStartupInfo=1
PebOsBuildNumber=1
PreventThreadCreation=0
RemoveDebugPrivileges=0
AutostartServer=1
ServerPort=1337
BreakOnTLS=1
FixOllyBugs=1
RemoveEPBreak=1
SkipEPOutsideCode=1
X64Fix=1
WindowTitle=VMP
NtSetInformationProcessHook=0
NtUserBlockInputHook=0
KillAntiAttach=0
handleExceptionPrint=0
handleExceptionRip=0
handleExceptionIllegalInstruction=0
handleExceptionInvalidLockSequence=0
handleExceptionNoncontinuableException=0
handleExceptionAssertionFailure=0
handleExceptionBreakpoint=0
handleExceptionGuardPageViolation=0
handleExceptionWx86Breakpoint=0
advancedGoto=0
ignoreBadPEImage=0
skipCompressedDoAnalyze=0
skipCompressedDoNothing=0
skipLoadDllDoLoad=0
skipLoadDllDoNothing=0
advancedInfobar=0
[Obsidium x86/x64]
DLLNormal=1
DLLStealth=0
DLLUnload=0
GetLocalTimeHook=0
GetSystemTimeHook=0
GetTickCount64Hook=0
GetTickCountHook=0
KiUserExceptionDispatcherHook=0
NtCloseHook=1
NtContinueHook=0
NtCreateThreadExHook=0
NtGetContextThreadHook=0
NtQueryInformationProcessHook=1
NtQueryObjectHook=0
NtQueryPerformanceCounterHook=0
NtQuerySystemInformationHook=1
NtQuerySystemTimeHook=0
NtSetContextThreadHook=0
NtSetDebugFilterStateHook=0
NtSetInformationThreadHook=0
NtUserBuildHwndListHook=1
NtUserFindWindowExHook=1
NtUserQueryWindowHook=1
NtUserGetForegroundWindowHook=0
NtYieldExecutionHook=0
OutputDebugStringHook=0
PebBeingDebugged=1
PebHeapFlags=1
PebNtGlobalFlag=1
PebStartupInfo=1
PebOsBuildNumber=1
PreventThreadCreation=0
RemoveDebugPrivileges=0
AutostartServer=1
ServerPort=1337
BreakOnTLS=1
FixOllyBugs=1
RemoveEPBreak=0
SkipEPOutsideCode=1
X64Fix=1
WindowTitle=Obsidium
[Themida x86/x64]
DLLNormal=1
DLLStealth=0
DLLUnload=0
GetLocalTimeHook=0
GetSystemTimeHook=0
GetTickCount64Hook=0
GetTickCountHook=0
KiUserExceptionDispatcherHook=0
NtCloseHook=1
NtContinueHook=0
NtCreateThreadExHook=1
NtGetContextThreadHook=0
NtQueryInformationProcessHook=1
NtQueryObjectHook=0
NtQueryPerformanceCounterHook=0
NtQuerySystemInformationHook=1
NtQuerySystemTimeHook=0
NtSetContextThreadHook=0
NtSetDebugFilterStateHook=0
NtSetInformationThreadHook=1
NtSetInformationProcessHook=0
NtUserBlockInputHook=0
NtUserBuildHwndListHook=1
NtUserFindWindowExHook=1
NtUserQueryWindowHook=1
NtUserGetForegroundWindowHook=1
NtYieldExecutionHook=0
OutputDebugStringHook=0
PebBeingDebugged=1
PebHeapFlags=1
PebNtGlobalFlag=1
PebStartupInfo=1
PebOsBuildNumber=1
PreventThreadCreation=0
RemoveDebugPrivileges=0
AutostartServer=1
ServerPort=1337
BreakOnTLS=1
FixOllyBugs=1
RemoveEPBreak=0
SkipEPOutsideCode=1
X64Fix=1
WindowTitle=Themida
[Armadillo x86]
DLLNormal=1
DLLStealth=0
DLLUnload=0
GetLocalTimeHook=0
GetSystemTimeHook=0
GetTickCount64Hook=0
GetTickCountHook=0
KiUserExceptionDispatcherHook=0
NtCloseHook=1
NtContinueHook=0
NtCreateThreadExHook=0
NtGetContextThreadHook=0
NtQueryInformationProcessHook=0
NtQueryObjectHook=0
NtQueryPerformanceCounterHook=0
NtQuerySystemInformationHook=0
NtQuerySystemTimeHook=0
NtSetContextThreadHook=0
NtSetDebugFilterStateHook=0
NtSetInformationThreadHook=0
NtSetInformationProcessHook=0
NtUserBlockInputHook=0
NtUserBuildHwndListHook=0
NtUserFindWindowExHook=0
NtUserQueryWindowHook=0
NtUserGetForegroundWindowHook=0
NtYieldExecutionHook=0
OutputDebugStringHook=1
PebBeingDebugged=1
PebHeapFlags=1
PebNtGlobalFlag=1
PebStartupInfo=1
PebOsBuildNumber=1
PreventThreadCreation=0
RemoveDebugPrivileges=0
AutostartServer=1
ServerPort=1337
BreakOnTLS=0
FixOllyBugs=1
RemoveEPBreak=0
SkipEPOutsideCode=1
X64Fix=1
WindowTitle=Armadillo
[Basic]
DLLNormal=1
DLLStealth=0
DLLUnload=0
GetLocalTimeHook=0
GetSystemTimeHook=0
GetTickCount64Hook=0
GetTickCountHook=0
KiUserExceptionDispatcherHook=0
NtCloseHook=0
NtContinueHook=0
NtCreateThreadExHook=0
NtGetContextThreadHook=0
NtQueryInformationProcessHook=0
NtQueryObjectHook=0
NtQueryPerformanceCounterHook=0
NtQuerySystemInformationHook=0
NtQuerySystemTimeHook=0
NtSetContextThreadHook=0
NtSetDebugFilterStateHook=0
NtSetInformationThreadHook=0
NtSetInformationProcessHook=0
NtUserBuildHwndListHook=0
NtUserFindWindowExHook=0
NtUserQueryWindowHook=0
NtUserGetForegroundWindowHook=0
NtYieldExecutionHook=0
OutputDebugStringHook=0
PebBeingDebugged=1
PebHeapFlags=1
PebNtGlobalFlag=1
PebStartupInfo=1
PebOsBuildNumber=1
PreventThreadCreation=0
RemoveDebugPrivileges=0
KillAntiAttach=0
handleExceptionPrint=0
handleExceptionRip=0
handleExceptionIllegalInstruction=0
handleExceptionInvalidLockSequence=0
handleExceptionNoncontinuableException=0
handleExceptionAssertionFailure=0
handleExceptionBreakpoint=0
handleExceptionGuardPageViolation=0
handleExceptionWx86Breakpoint=0
AutostartServer=1
ServerPort=1337
BreakOnTLS=0
FixOllyBugs=0
RemoveEPBreak=0
SkipEPOutsideCode=0
X64Fix=0
WindowTitle=VMP
advancedGoto=0
ignoreBadPEImage=0
skipCompressedDoAnalyze=0
skipCompressedDoNothing=0
skipLoadDllDoLoad=0
skipLoadDllDoNothing=0
advancedInfobar=0
[Disabled]
DLLNormal=1
DLLStealth=0
DLLUnload=0
GetLocalTimeHook=0
GetSystemTimeHook=0
GetTickCount64Hook=0
GetTickCountHook=0
KiUserExceptionDispatcherHook=0
NtCloseHook=0
NtContinueHook=0
NtCreateThreadExHook=0
NtGetContextThreadHook=0
NtQueryInformationProcessHook=0
NtQueryObjectHook=0
NtQueryPerformanceCounterHook=0
NtQuerySystemInformationHook=0
NtQuerySystemTimeHook=0
NtSetContextThreadHook=0
NtSetDebugFilterStateHook=0
NtSetInformationThreadHook=0
NtSetInformationProcessHook=0
NtUserBlockInputHook=0
NtUserBuildHwndListHook=0
NtUserFindWindowExHook=0
NtUserQueryWindowHook=0
NtUserGetForegroundWindowHook=0
NtYieldExecutionHook=0
OutputDebugStringHook=0
PebBeingDebugged=0
PebHeapFlags=0
PebNtGlobalFlag=0
PebStartupInfo=0
PebOsBuildNumber=0
PreventThreadCreation=0
RemoveDebugPrivileges=0
KillAntiAttach=0
handleExceptionPrint=0
handleExceptionRip=0
handleExceptionIllegalInstruction=0
handleExceptionInvalidLockSequence=0
handleExceptionNoncontinuableException=0
handleExceptionAssertionFailure=0
handleExceptionBreakpoint=0
handleExceptionGuardPageViolation=0
handleExceptionWx86Breakpoint=0
AutostartServer=1
ServerPort=1337
BreakOnTLS=0
FixOllyBugs=0
RemoveEPBreak=0
SkipEPOutsideCode=0
X64Fix=0
WindowTitle=VMP
advancedGoto=0
ignoreBadPEImage=0
skipCompressedDoAnalyze=0
skipCompressedDoNothing=0
skipLoadDllDoLoad=0
skipLoadDllDoNothing=0
advancedInfobar=0



================================================
File: Documentation/README
================================================
This documentation was created with MiKTeX Version 2.9.6850: https://miktex.org/

Compiler Setting: LuaLaTeX+MakeIndex+BibTex



================================================
File: Documentation/ScyllaHideDocumentation.tex
================================================
\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[english]{isodate}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}


\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=leftline,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=9pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{black}, % the style that is used for the line-numbers
}

\lstset{escapechar=@,style=customc}
\hypersetup{
  colorlinks   = true,    % Colours links instead of ugly boxes
  urlcolor     = black,    % Colour for external hyperlinks
  linkcolor    = black,    % Colour of internal links
  citecolor    = red      % Colour of citations
}

\title{ScyllaHide v1.4 - Documentation}
\author{}
\date{2019-05-17}

\begin{document}


\maketitle
 
\pagenumbering{Roman}
\tableofcontents
\listoffigures
\lstlistoflistings

\newpage
\pagenumbering{arabic}

\section{Description}

ScyllaHide is an advanced open-source x64/x86 usermode Anti-Anti-Debug library. It hooks various functions in usermode to hide debugging. This tool is intended to stay in usermode (ring3). If you need kernelmode (ring0) Anti-Anti-Debug please see \href{https://github.com/mrexodia/TitanHide}{TitanHide}. ScyllaHide hooks as stealthily as possible in usermode and the goal is to not interfere with any other functionality.

ScyllaHide supports various debuggers with plugins:
\begin{itemize}
\item OllyDbg v1 and v2 \url{http://www.ollydbg.de}
\item x64dbg \url{http://x64dbg.com} or \url{https://github.com/x64dbg/x64dbg}
\item Hex-Rays IDA v6 \url{https://www.hex-rays.com/products/ida}
\item TitanEngine v2 \url{https://bitbucket.org/mrexodia/titanengine-update} and \url{http://www.reversinglabs.com/open-source/titanengine.html}
\end{itemize}

PE x64 debugging is fully supported with plugins for x64dbg and IDA.

Please note: ScyllaHide is not limited to these debuggers. You can use the standalone commandline version of ScyllaHide. You can inject ScyllaHide in any process debugged by any debugger.

\section{Usage Information}
\subsection{Standalone (debugger-independent)}
InjectorCLI.exe "process name" "HookLibrary.dll path" [nowait]

InjectorCLI.exe pid:\textit{process ID} "HookLibrary.dll path" [nowait]

For example:
InjectorCLI.exe crackme.exe \path{C:\HookLibrary.dll}

The injector waits for a keystroke after injection by default. You can modify this behaviour by passing "nowait" (without quotes) as the last parameter.

\subsection{OllyDbg v1}
Copy scylla\_hide.ini, HookLibraryx86.dll and ScyllaHideOlly1.dll to your specific plugins directory.

\subsection{OllyDbg v2}
Copy scylla\_hide.ini, HookLibraryx86.dll and ScyllaHideOlly2.dll to your specific plugins directory.

\subsection{IDA v6}
\textbf{32-bit:}
Copy scylla\_hide.ini, HookLibraryx86.dll and ScyllaHideIDA.plw to your IDA plugins directory.

\textbf{64-bit:}
Copy scylla\_hide.ini, HookLibraryx64.dll, ScyllaHideIDASrvx64.exe and ScyllaHideIDA.p64 to your IDA plugins directory.

Note: \\Start ScyllaHideIDASrvx64.exe to debug 64bit applications remotely. \\Start ScyllaHideIDASrvx86.exe to debug 32bit applications remotely.

Command line: ScyllaHideIDASrvxXX.exe <port>\\
For example: ScyllaHideIDASrvxXX.exe 1345

ScyllaHideIDASrv needs HookLibraryxXX.dll.

\subsection{x64dbg}
\textbf{32-bit:}
Copy scylla\_hide.ini, HookLibraryx86.dll and ScyllaHideX64DBGPlugin.dp32 to your \path{\x32\plugins\} directory.

\textbf{64-bit:}
Copy scylla\_hide.ini, HookLibraryx64.dll and ScyllaHideX64DBGPlugin.dp64 to your \path{\x64\plugins\} directory.

\subsection{TitanEngine}
\textbf{32-bit:}
Copy scylla\_hide.ini, HookLibraryx86.dll and ScyllaHideTEx86.dll to your \path{\plugins\x86\} directory.

\textbf{64-bit:}
Copy scylla\_hide.ini, HookLibraryx64.dll and ScyllaHideTEx64.dll to your \path{\plugins\x64\} directory.

\section{Features}

\subsection{Anti-Anti-Debug}

\subsubsection{Process Environment Block (PEB)}
The most important anti-anti-debug option. Almost every protector checks for PEB values. There are three important options and one minor option.
\begin{itemize}
\item BeingDebugged: Very important option, should always be enabled. \textit{IsDebuggerPresent} uses this value to check for debuggers.
\item NtGlobalFlag: Very important option, a lot of protectors check this value.
\item HeapFlags: Very important option. E.g. Themida checks for heap artifacts and heap flags.
\item StartupInfo: This is not really important, only a few protectors check for this. Maybe Enigma checks it.
\item OsBuildNumber: VMProtect checks this on newer versions of Windows 10 (2019 onwards).
\end{itemize}

\subsubsection{NtSetInformationThread}
\label{sec:NtSetInformationThread_section}
The THREADINFOCLASS value ThreadHideFromDebugger (17) is a well-known anti-debug measurement. The debugger cannot handle hidden threads. This leads to a loss of control over the target.

\subsubsection{NtSetInformationProcess}
\label{sec:NtSetInformationProcess_section}
The PROCESSINFOCLASS value ProcessHandleTracing (32) can be used to detect a debugger. The PROCESSINFOCLASS value ProcessBreakOnTermination (29) can be used to generate a Blue Screen of Death on process termination. ScyllaHide protects from both. The function \textit{RtlSetProcessIsCritical} from ntdll.dll uses ProcessBreakOnTermination internally.

\subsubsection{NtQuerySystemInformation}
The SYSTEM\_INFORMATION\_CLASS value SystemKernelDebuggerInformation (35) can be used to detect kernel debuggers. The SYSTEM\_INFORMATION\_CLASS value SystemProcessInformation (5) is used to get a process list. A debugger should be hidden in a process list and the debugee should have a good parent process ID like the ID from explorer.exe.

\subsubsection{NtQueryInformationProcess}
A very important option. Various PROCESSINFOCLASS values can be used to detect a debugger:
\begin{itemize}
\item ProcessDebugFlags (31): Should return 1 in the supplied buffer, unless this value was previously set to PROCESS\_DEBUG\_INHERIT (0x1), then 0.
\item ProcessDebugPort (7): Should return 0 in the supplied buffer.
\item ProcessDebugObjectHandle (30): Should write 0 to the supplied buffer, close the debug object handle, and return the error STATUS\_PORT\_NOT\_SET (0xC0000353).
\item ProcessBasicInformation (0): Reveals the parent process ID.
\item ProcessBreakOnTermination (29): Please see \textit{NtSetInformationProcess} in Section~\ref{sec:NtSetInformationProcess_section}.
\item ProcessHandleTracing (32): Please see \textit{NtSetInformationProcess} in Section~\ref{sec:NtSetInformationProcess_section}.
\end{itemize}
A lot of protectors use this function to detect debuggers. The windows API \textit{CheckRemoteDebuggerPresent} uses \textit{NtQueryInformationProcess} with ProcessDebugPort internally.

\subsubsection{NtQueryObject}
The OBJECT\_INFORMATION\_CLASS ObjectTypesInformation (3) and ObjectTypeInformation (2) can be used to detect debuggers. ScyllaHide filters DebugObject references.

\subsubsection{NtYieldExecution}
A very unrealiable anti-debug method. This is only used in some UnpackMe's or in some Proof of Concept code. Only activate this if you really need it. Probably you will never need this option. This function is used in the kernel32.dll \textit{SwitchToThread} function.

\begin{lstlisting}[language=C, caption=SwitchToThread Implementation]
BOOL __stdcall SwitchToThread()
{
  //STATUS_NO_YIELD_PERFORMED 0x40000024
  return NtYieldExecution() != 0x40000024;
}
\end{lstlisting}

\subsubsection{NtCreateThreadEx}
Threads hidden from debuggers can be created with a special creation flag THREAD\_CREATE\_FLAGS\_HIDE\_FROM\_DEBUGGER (4). ScyllaHide doesn't allow hidden threads. The anti-debug effect is similar to \textit{NtSetInformationThread} in Section~\ref{sec:NtSetInformationThread_section}.

\subsubsection{OutputDebugStringA (deprecated since v1.3)}
\textit{OutputDebugStringW} uses \textit{OutputDebugStringA} internally, so hooking the ANSI version is enough. This is a very unreliable anti-debug method, so you will not need this option very often. The Listing shows the implementation of the function. The recent versions of ScyllaHide don't need this hook anymore, because they handle the DBG\_PRINTEXCEPTION\_C exception. See Section~\ref{sec:RaiseException_section}.

\begin{lstlisting}[language=C, caption=OutputDebugStringA Implementation]
void __stdcall OutputDebugStringA(LPCSTR lpOutputString)
{
     ULONG_PTR args[2];
     args[0] = (ULONG_PTR)strlen(lpOutputString);
     args[1] = (ULONG_PTR)lpOutputString;
     RaiseException(0x40010006, 0, 2, args);//DBG_PRINTEXCEPTION_C
}
\end{lstlisting}

\subsubsection{NtUserBlockInput}
Very effective anti-debug method. This is used e.g. in Yoda's Protector. "Blocks keyboard and mouse input events from reaching applications."

\subsubsection{NtUserFindWindowEx}
This is a system call function in user32.dll. The windows APIs \textit{FindWindowA/W} and \textit{FindWindowExA/W} call this internally. The debugger window will be hidden.

\subsubsection{NtUserBuildHwndList}
This is a system call function in user32.dll. The windows APIs \textit{EnumWindows} and \textit{EnumThreadWindows} call this internally. The debugger window will be hidden.

\subsubsection{NtUserQueryWindow}
This is a system call function in user32.dll. The windows API \textit{GetWindowThreadProcessId} calls this internally, see Listing for implementation. This is used to hide the debugger process.

\begin{lstlisting}[language=C, caption=GetWindowThreadProcessId Implementation]
DWORD __stdcall GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
{
	if (lpdwProcessId != 0)
		*lpdwProcessId = (DWORD)NtUserQueryWindow(hwnd, WindowProcess);//0
	return (DWORD)NtUserQueryWindow(hwnd, WindowThread);//2
}
\end{lstlisting}

\subsubsection{NtSetDebugFilterState}
ScyllaHide returns STATUS\_ACCESS\_DENIED unless the process has debug privileges enabled. If the process has debug privileges, ScyllaHide will take no action and return success. This anti-debug measurement isn't used very often. Probably you will never need this option in a real world target.

\subsubsection{NtClose}
This is called with an invalid handle to detect a debugger. ScyllaHide calls \textit{NtQueryObject} to check the validity of the handle. A few protectors are using this method.

\subsubsection{Remove Debug Privileges}
If a debugger creates the process of the target, the target may have debug privileges. This is an unreliable way to detect a debugger.

\subsubsection{Hardware Breakpoint Protection (DRx)}
Hardware breakpoints can be detected/cleared with exceptions or the windows APIs \textit{NtGetContextThread/NtSetContextThread}. Enable this option only if you need it!

\subsubsection{Timing}
There are a few windows APIs to measure the time. Timing can be used to detect debuggers, because they slow down execution. Enable with care and only if you need it!

\subsubsection{Raise Exception}
\label{sec:RaiseException_section}
It is possible to raise specific exceptions with various windows API functions (e.g. \textit{RaiseException} from kernel32.dll). The problem is that various debuggers consume various different exceptions and the exception is not returned to the application. The application can detect a debugger if there is no exception triggered. Please see the Listing for an example code.

\begin{lstlisting}[language=C, caption=Raise Exception Example]
__try
{
    RaiseException(0x40010006, 0, 0, 0);//DBG_PRINTEXCEPTION_C
    MessageBox("Debugger detected");
}
__except(EXCEPTION_EXECUTE_HANDLER) //catch exception
{
    MessageBox("Debugger NOT detected");
}
\end{lstlisting}

Examples for swallowed exceptions are:

\begin{itemize}
\item 0x4000001F STATUS\_WX86\_BREAKPOINT
\item 0x40010006 DBG\_PRINTEXCEPTION\_C
\item 0x40010007 DBG\_RIPEXCEPTION
\item 0x80000001 STATUS\_GUARD\_PAGE\_VIOLATION
\item 0x80000003 STATUS\_BREAKPOINT
\item 0xC0000025 STATUS\_NONCONTINUABLE\_EXCEPTION
\item 0xC0000420 STATUS\_ASSERTION\_FAILURE
\end{itemize}

\begin{table}[H]
\caption{OllyDbg v1, v2 and WinDbg v6 comparision on Windows 7 64-bit.}
\begin{tabular}{lrcccl}
 & \multicolumn{1}{c}{} & \textbf{Olly v1}    & \textbf{Olly v2}    & \textbf{WinDbg v6}    &  \\
 & \textbf{DBG\_RIPEXCEPTION}     & X                    & X                    & X                    &  \\
 & \textbf{DBG\_PRINTEXCEPTION\_C}      & X                    & X                    & X                    &  \\
 & \textbf{NONCONTINUABLE\_EXCEPTION}      & X                    & X                    &                     &  \\
 & \textbf{WX86\_BREAKPOINT}      & X                    &                     &                     &  \\
 & \textbf{GUARD\_PAGE\_VIOLATION}      & X                    &                     &                     &  \\
 & \textbf{BREAKPOINT}      & X                    &                     &                     &  \\
 & \textbf{ASSERTION\_FAILURE}      &                     &                     & X                    &  \\
 & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & 
\end{tabular}
\end{table}

\subsection{Special}
\subsubsection{DLL Injection}
Normal DLL injection or stealth dll injection. You better try the normal injection first...

\pagebreak

\subsubsection{Prevent Thread Creation}
This option prevents the creation of new threads. This can be useful if a protector uses a lot of protection threads. This option can be useful for EXECryptor. Enable with care and only if you need it! You must know what you are doing here!

\subsubsection{RunPE Unpacker}
This option hooks \textit{NtResumeThread}. If the malware creates a new process, ScyllaHide terminates and dumps any newly created process. If you are unpacking malware, enable and try it. Should only be used inside a Virtual Machine.

A typical RunPE workflow:

\begin{enumerate}
\item Create a new process of any target in suspended state (process flag CREATE\_SUSPENDED: 0x00000004)
\item Replace the original process PE image with a new (malicious) PE image. This can involve several steps and various windows API functions.
\item Start the process with the Windows API function \textit{ResumeThread} (or \textit{NtResumeThread}).
\end{enumerate}

\subsubsection{Improved Attach Dialog}
Use the integrated window finder to quickly select your attach target. Drag'n'Drop the bullseye/crosshair to your target window or enter the Process ID manually in decimal or hexadecimal notation.
\begin{figure}[H]
\centering
\includegraphics[scale=1]{newattachdialog.PNG}
\caption{Improved Attach Dialog}
\end{figure}

\subsection{OllyDbg v1 Specific}

\begin{figure}[H]
\centering
\includegraphics[scale=1]{ollyv1plugin.PNG}
\caption{OllyDbg v1 Plugin}
\end{figure}

\subsubsection{Remove entry point breakpoint}
Some protectors use Thread-Local-Storage (TLS) as entrypoint and check for breakpoints at the normal PE entrypoint address. You must remove the PE entrypoint to hide your debugger. This option is necessary for VMProtect.

\pagebreak

\subsubsection{Fix Olly Bugs}
This option fixes various OllyDbg bugs: 
\begin{itemize}
\item PE fix for NumOfRvaAndSizes
\item ForegroundWindow fix
\item FPU bug
\item Format string (sprintf) bug, CVE-2004-0733 \url{http://www.cvedetails.com/cve/CVE-2004-0733/}
\item NT Symbols path bug, patch by blabberer \url{http://www.woodmann.com/forum/showthread.php?8460-Debug-symbols-information-symbol-server-setup&p=56246&viewfull=1#post56246}
\item Faulty handle bug. Sometimes Olly does not terminate and this error appears "Operating system reports error ERROR\_ACCESS\_DENIED"
\item System DLL detection on Windows x64. Olly thinks that the system dlls are located at C:\textbackslash{}windows\textbackslash{}system32 but on Windows x64 they are at C:\textbackslash{}windows\textbackslash{}SysWOW64. The result is that various Olly features will not work properly for example "Execute till user code".
\end{itemize}

\subsubsection{x64 single-step fix}
OllyDbg doesn't work very well on x64 operating systems. This option fixes the most annoying bug. More information here: \url{http://waleedassar.blogspot.de/2012/03/ollydbg-v110-and-wow64.html}
\subsubsection{Skip Entrypoint outside code}
Annoying warning can be skipped.
\subsubsection{Ignore bad PE image}
Annoying warning can be skipped.
\subsubsection{Skip compressed code warning}
Annoying warning "Compressed code?" can be skipped with a default behaviour.
\subsubsection{Skip "load dll" warning}
Annoying warning "Request to load DLL" can be skipped with a default behaviour.
\subsubsection{Break on TLS}
This option sets a breakpoint on any available Thread-Local-Storage (TLS) address. This is necessary for various protectors e.g. VMProtect.
\subsubsection{Advanced CTRL+G}
Replaces the default OllyDbg "Go to Address" dialog. Now you can enter RVA and offset values. Be sure to select the correct module.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{ollyadvancedctrlg.PNG}
\caption{Advanced CTRL+G}
\end{figure}

\subsubsection{Change window caption}
Changes the OllyDbg window caption. This can be useful against e.g. FindWindow anti-debug tricks. You don't need to enable this, if you have the NtUser* hooks enabled! Hint: You can use it to make the currently used profile visible.

\subsubsection{Special Keyboard Shortcuts}

\begin{itemize}
\item "INSERT" will fill the selected data with 0x00 bytes
\item "DELETE" will fill the selected data with 0x90 (NOP) bytes
\end{itemize}

\subsubsection{Custom Toolbar}
This setting displays a custom toolbar while using the dump and cpu window.


\subsubsection{Exception Problem}
OllyDbg has a problem with several exceptions. The exceptions can be triggered in different ways. They cannot be ignored with the exception options.

\begin{itemize}
\item 0x40010006 STATUS\_ILLEGAL\_INSTRUCTION
\item 0xC000001E STATUS\_INVALID\_LOCK\_SEQUENCE
\end{itemize}

For example, EXECryptor uses STATUS\_INVALID\_LOCK\_SEQUENCE to defeat OllyDbg. Obsidium uses STATUS\_ILLEGAL\_INSTRUCTION.

\subsubsection{Detach Process}
Olly v1 does not support detaching from a process. ScyllaHide implements a "detach process" feature. All user software breakpoints will be cleared prior to detaching the process. Olly is terminated, but the process will be alive.


\subsection{OllyDbg v2 Specific}

\begin{figure}[H]
\centering
\includegraphics[scale=1]{ollyv2plugin.PNG}
\caption{OllyDbg v2 Plugin}
\end{figure}

\subsubsection{Change window caption}
Changes the OllyDbg window caption. This can be useful against e.g. FindWindow anti-debug tricks. You don't need to enable this, if you have the NtUser* hooks enabled! Hint: You can use it to make the currently used profile visible.

\subsection{IDA Specific}

\begin{figure}[H]
\centering
\includegraphics[scale=1]{idaplugin.PNG}
\caption{IDA Plugin}
\end{figure}

\subsubsection{Server Option}
Remote debugging is fully supported. Define the TCP port for the special IDA Server application. X64 debugging requires remote debugging, because IDA (64-bit) is a 32-bit application.

% Matti: commented out because these sections were empty.
% Uncomment these if there is x64dbg or TE-specific info to add
%\subsection{x64dbg Specific}
%\subsection{TitanEngine Specific}

% Matti: force page break here because the section title was on a different page than the rest
\pagebreak

\section{Advanced Information}
\subsection{Nt* APIs from user32.dll}

\begin{lstlisting}[language=C, caption=Special Nt* APIs declaration]
BOOL
NTAPI
NtUserBlockInput(
    IN BOOL fBlockIt);

HWND
NTAPI
NtUserFindWindowEx(
    IN HWND hwndParent,
    IN HWND hwndChild,
    IN PUNICODE_STRING pstrClassName OPTIONAL,
    IN PUNICODE_STRING pstrWindowName OPTIONAL,
    IN DWORD dwType);

NTSTATUS
NTAPI
NtUserBuildHwndList(
    IN HDESK hdesk,
    IN HWND hwndNext,
    IN BOOL fEnumChildren,
    IN DWORD idThread,
    IN UINT cHwndMax,
    OUT HWND *phwndFirst,
    OUT PUINT pcHwndNeeded);

HANDLE
NTAPI
NtUserQueryWindow(
    IN HWND hwnd,
    IN WINDOWINFOCLASS WindowInfo);
\end{lstlisting}

\subsection{Special PEB Fix Information}

There is a special piece of code inside the debug loop of the plugins and it seems like there is a bug:
\begin{lstlisting}[language=C, caption=Special PEB Fix Code]
    if (pHideOptions.PEBHeapFlags)
    {
        if (specialPebFix)
        {
            StartFixBeingDebugged(ProcessId, false);
            specialPebFix = false;
        }

        if (debugevent->u.LoadDll.lpBaseOfDll == hNtdllModule)
        {
            StartFixBeingDebugged(ProcessId, true);
            specialPebFix = true;
        }
    }
\end{lstlisting}
But this code is correct and very important. This nice trick removes heap artifacts (You can read more about it here: \url{http://pferrie.tripod.com/papers/unpackers.pdf} "The heap"). Themida and other protectors check for heap artifacts. Instead of manually wiping the artifacts, the code prevents the heap artifact creation.

\section{Developer Contact Information}

\begin{center}
\textbf{Carbon} \textit{alias} \textbf{Aguila} \textit{alias} \textbf{NtQuery}
\begin{itemize}
\item \url{https://github.com/NtQuery/}
\item \url{https://bitbucket.org/NtQuery/}
\item \url{https://forum.tuts4you.com/user/22354-aguila/}
\item \url{https://forum.exetools.com/member.php?u=36473}
\end{itemize}


\textbf{cypher} \textit{alias} \textbf{cypherpunk}
\begin{itemize}
\item \url{https://bitbucket.org/cypherpunk/}
\item \url{https://forum.tuts4you.com/user/77269-cypher/}
\item \url{https://forum.exetools.com/member.php?u=36610}
\end{itemize}

\textbf{mrexodia}
\begin{itemize}
\item \url{https://github.com/mrexodia/}
\item \url{https://bitbucket.org/mrexodia/}
\item \url{https://forum.tuts4you.com/profile/54652-mrexodia/}
\end{itemize}

\textbf{Mattiwatti}
\begin{itemize}
\item \url{https://github.com/Mattiwatti/}
\item \url{https://bitbucket.org/Mattiwatti/}
\item \url{https://forum.tuts4you.com/profile/93562-mattiwatti/}
\end{itemize}
\end{center}

\section{Version History}

Version 1.4
\begin{itemize}
\item Fixed bug with PEB heap flags, bug found by kao \url{http://lifeinhex.com/net-scyllahide-and-heap_create_enable_execute/}
\item All Plugins: Cool ghost icon
\item Olly v1 Plugin: Fix bug - system dll detection
\item Olly v1 Plugin: Detach from process feature
\end{itemize}

Version 1.3
\begin{itemize}
\item All Plugins: Improved tooltips
\item All Plugins: Bugfixes
\item All Plugins: Don't swallow exceptions like DBG\_RIPEXCEPTION or DBG\_PRINTEXCEPTION\_C
\item Olly v1 Plugin: Custom Toolbar for Dump and CPU window
\item Olly v1 Plugin: Special shortcuts
\end{itemize}

Version 1.2
\begin{itemize}
\item All Plugins: New attach dialog with crosshair/bullseye window finder.
\item All Plugins: Tooltips with information (unfinished).
\item Olly v1 Plugin: Fix for NT Symbols path
\item Olly v1 Plugin: Fix for faulty handle bug
\end{itemize}

Version 1.1
\begin{itemize}
\item Added "thanks" to About
\item Added kill anti-attach (for x86 only)
\item Olly v1 Plugin: Advanced CTRL+G
\item Olly v1 Plugin: Skip "compressed code" message
\item Olly v1 Plugin: Ignore bad PE image (WinUPack)
\item Olly v1 Plugin: Skip "Load DLL" message
\end{itemize}

\include{gpl-3.0}

\end{document}


================================================
File: Documentation/gpl-3.0.tex
================================================
\newpage
\begin{flushleft}
\section{License Information}
\end{flushleft}
\begin{center}

GNU GENERAL PUBLIC LICENSE

Version 3, 29 June 2007

Copyright \copyright\  2007 Free Software Foundation, Inc. \texttt{http://fsf.org/}

\bigskip
Everyone is permitted to copy and distribute verbatim copies of this

license document, but changing it is not allowed.

\end{center}

\renewcommand{\abstractname}{Preamble}
\begin{abstract}
The GNU General Public License is a free, copyleft license for
software and other kinds of works.

The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

The precise terms and conditions for copying, distribution and
modification follow.
\end{abstract}

\begin{center}
{\Large \sc Terms and Conditions}
\end{center}


\begin{enumerate}

\addtocounter{enumi}{-1}

\item Definitions.

``This License'' refers to version 3 of the GNU General Public License.

``Copyright'' also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

``The Program'' refers to any copyrightable work licensed under this
License.  Each licensee is addressed as ``you''.  ``Licensees'' and
``recipients'' may be individuals or organizations.

To ``modify'' a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a ``modified version'' of the
earlier work or a work ``based on'' the earlier work.

A ``covered work'' means either the unmodified Program or a work based
on the Program.

To ``propagate'' a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

To ``convey'' a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

An interactive user interface displays ``Appropriate Legal Notices''
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

\item Source Code.

The ``source code'' for a work means the preferred form of the work
for making modifications to it.  ``Object code'' means any non-source
form of a work.

A ``Standard Interface'' means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

The ``System Libraries'' of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
``Major Component'', in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

The ``Corresponding Source'' for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

The Corresponding Source for a work in source code form is that
same work.

\item Basic Permissions.

All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

\item Protecting Users' Legal Rights From Anti-Circumvention Law.

No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

\item Conveying Verbatim Copies.

You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

\item Conveying Modified Source Versions.

You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:
  \begin{enumerate}
  \item The work must carry prominent notices stating that you modified
  it, and giving a relevant date.

  \item The work must carry prominent notices stating that it is
  released under this License and any conditions added under section
  7.  This requirement modifies the requirement in section 4 to
  ``keep intact all notices''.

  \item You must license the entire work, as a whole, under this
  License to anyone who comes into possession of a copy.  This
  License will therefore apply, along with any applicable section 7
  additional terms, to the whole of the work, and all its parts,
  regardless of how they are packaged.  This License gives no
  permission to license the work in any other way, but it does not
  invalidate such permission if you have separately received it.

  \item If the work has interactive user interfaces, each must display
  Appropriate Legal Notices; however, if the Program has interactive
  interfaces that do not display Appropriate Legal Notices, your
  work need not make them do so.
\end{enumerate}
A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
``aggregate'' if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

\item Conveying Non-Source Forms.

You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:
  \begin{enumerate}
  \item Convey the object code in, or embodied in, a physical product
  (including a physical distribution medium), accompanied by the
  Corresponding Source fixed on a durable physical medium
  customarily used for software interchange.

  \item Convey the object code in, or embodied in, a physical product
  (including a physical distribution medium), accompanied by a
  written offer, valid for at least three years and valid for as
  long as you offer spare parts or customer support for that product
  model, to give anyone who possesses the object code either (1) a
  copy of the Corresponding Source for all the software in the
  product that is covered by this License, on a durable physical
  medium customarily used for software interchange, for a price no
  more than your reasonable cost of physically performing this
  conveying of source, or (2) access to copy the
  Corresponding Source from a network server at no charge.

  \item Convey individual copies of the object code with a copy of the
  written offer to provide the Corresponding Source.  This
  alternative is allowed only occasionally and noncommercially, and
  only if you received the object code with such an offer, in accord
  with subsection 6b.

  \item Convey the object code by offering access from a designated
  place (gratis or for a charge), and offer equivalent access to the
  Corresponding Source in the same way through the same place at no
  further charge.  You need not require recipients to copy the
  Corresponding Source along with the object code.  If the place to
  copy the object code is a network server, the Corresponding Source
  may be on a different server (operated by you or a third party)
  that supports equivalent copying facilities, provided you maintain
  clear directions next to the object code saying where to find the
  Corresponding Source.  Regardless of what server hosts the
  Corresponding Source, you remain obligated to ensure that it is
  available for as long as needed to satisfy these requirements.

  \item Convey the object code using peer-to-peer transmission, provided
  you inform other peers where the object code and Corresponding
  Source of the work are being offered to the general public at no
  charge under subsection 6d.
  \end{enumerate}

A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

A ``User Product'' is either (1) a ``consumer product'', which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, ``normally used'' refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

``Installation Information'' for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

\item Additional Terms.

``Additional permissions'' are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:
  \begin{enumerate}
  \item Disclaiming warranty or limiting liability differently from the
  terms of sections 15 and 16 of this License; or

  \item Requiring preservation of specified reasonable legal notices or
  author attributions in that material or in the Appropriate Legal
  Notices displayed by works containing it; or

  \item Prohibiting misrepresentation of the origin of that material, or
  requiring that modified versions of such material be marked in
  reasonable ways as different from the original version; or

  \item Limiting the use for publicity purposes of names of licensors or
  authors of the material; or

  \item Declining to grant rights under trademark law for use of some
  trade names, trademarks, or service marks; or

  \item Requiring indemnification of licensors and authors of that
  material by anyone who conveys the material (or modified versions of
  it) with contractual assumptions of liability to the recipient, for
  any liability that these contractual assumptions directly impose on
  those licensors and authors.
  \end{enumerate}

All other non-permissive additional terms are considered ``further
restrictions'' within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

\item Termination.

You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

\item Acceptance Not Required for Having Copies.

You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

\item Automatic Licensing of Downstream Recipients.

Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

An ``entity transaction'' is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

\item Patents.

A ``contributor'' is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's ``contributor version''.

A contributor's ``essential patent claims'' are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, ``control'' includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

In the following three paragraphs, a ``patent license'' is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To ``grant'' such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  ``Knowingly relying'' means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

A patent license is ``discriminatory'' if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

\item No Surrender of Others' Freedom.

If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

\item Use with the GNU Affero General Public License.

Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

\item Revised Versions of this License.

The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License ``or any later version'' applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

\item Disclaimer of Warranty.

\begin{sloppypar}
 THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
 APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE
 COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ``AS IS''
 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE
 RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
 SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
 NECESSARY SERVICING, REPAIR OR CORRECTION.
\end{sloppypar}

\item Limitation of Liability.

 IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
 WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
 AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
 DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
 DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
 (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
 INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE
 OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH
 HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 DAMAGES.

\item Interpretation of Sections 15 and 16.

If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

\begin{center}
{\Large\sc End of Terms and Conditions}

\bigskip
How to Apply These Terms to Your New Programs
\end{center}

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the ``copyright'' line and a pointer to where the full notice is found.

{\footnotesize
\begin{verbatim}
<one line to give the program's name and a brief idea of what it does.>

Copyright (C) <textyear>  <name of author>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
\end{verbatim}
}

Also add information on how to contact you by electronic and paper mail.

If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

{\footnotesize
\begin{verbatim}
<program>  Copyright (C) <year>  <name of author>

This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
This is free software, and you are welcome to redistribute it
under certain conditions; type `show c' for details.
\end{verbatim}
}

The hypothetical commands {\tt show w} and {\tt show c} should show
the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an ``about box''.

You should also get your employer (if you work as a programmer) or
school, if any, to sign a ``copyright disclaimer'' for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see \texttt{http://www.gnu.org/licenses/}.

The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use
the GNU Lesser General Public License instead of this License.  But
first, please read \texttt{http://www.gnu.org/philosophy/why-not-lgpl.html}.

\end{enumerate}





================================================
File: Documentation/.gitignore
================================================
*.aux
*.lof
*.lol
*.pdf
*.gz
*.toc
*.out


================================================
File: HookLibrary/DllMain.cpp
================================================
#include <ntdll/ntdll.h>

#pragma comment(linker, "/ENTRY:DllMain")

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    LdrDisableThreadCalloutsForDll(hinstDLL);
    return TRUE;
}


================================================
File: HookLibrary/Export.def
================================================
LIBRARY
EXPORTS
HookDllData
HookedGetLocalTime
HookedGetSystemTime
HookedGetTickCount
HookedGetTickCount64
HookedKiUserExceptionDispatcher
HookedNativeCallInternal
HookedNtClose
HookedNtContinue
HookedNtCreateThread
HookedNtCreateThreadEx
HookedNtDuplicateObject
HookedNtGetContextThread
HookedNtQueryInformationProcess
HookedNtQueryObject
HookedNtQueryPerformanceCounter
HookedNtQuerySystemInformation
HookedNtQuerySystemTime
HookedNtSetContextThread
HookedNtSetDebugFilterState
HookedNtSetInformationProcess
HookedNtSetInformationThread
HookedNtUserBlockInput
HookedNtUserBuildHwndList
HookedNtUserBuildHwndList_Eight
HookedNtUserFindWindowEx
HookedNtUserGetForegroundWindow
HookedNtUserQueryWindow
HookedNtYieldExecution
HookedOutputDebugStringA
HookedNtResumeThread
HookedNtOpenFile
HookedNtCreateSection
HookedNtMapViewOfSection


================================================
File: HookLibrary/HookHelper.cpp
================================================
#include "HookHelper.h"

#include <ntdll/ntdll.h>

#include "HookedFunctions.h"
#include "HookMain.h"

const WCHAR * BadProcessnameList[] =
{
	L"ollydbg.exe",
	L"ida.exe",
	L"ida64.exe",
	L"idag.exe",
	L"idag64.exe",
	L"idaw.exe",
	L"idaw64.exe",
	L"idaq.exe",
	L"idaq64.exe",
	L"idau.exe",
	L"idau64.exe",
	L"scylla.exe",
	L"scylla_x64.exe",
	L"scylla_x86.exe",
	L"protection_id.exe",
	L"x64dbg.exe",
	L"x32dbg.exe",
	L"windbg.exe",
	L"reshacker.exe",
	L"ImportREC.exe",
	L"IMMUNITYDEBUGGER.EXE",
	L"devenv.exe",
	L"Procmon.exe",
	L"Procmon64.exe",
	L"APIMonitor.exe",
	L"apimonitor-x64.exe",
	L"apimonitor-x86.exe",
	L"cheatengine-" // cheatengine-i386.exe, cheatengine-x86_64.exe, cheatengine-x86_64-SSE4-AVX2.exe, ...
};

const WCHAR * BadWindowTextList[] =
{
	L"OLLYDBG",
	L"ida",
	L"disassembly",
	L"scylla",
	L"Debug",
	L"[CPU",
	L"Immunity",
	L"WinDbg",
	L"x32dbg",
	L"x64dbg",
	L"WinDbg",
	L"Import reconstructor",
	L"Process Monitor - Sysinternals: www.sysinternals.com",
	L"API Monitor",
	L"Monitored Processes",
	L"Cheat Engine"
};

const WCHAR * BadWindowClassList[] =
{
	L"OLLYDBG",
	L"Zeta Debugger",
	L"Rock Debugger",
	L"ObsidianGUI",
	L"ID", // Immunity Debugger
	L"WinDbgFrameClass", // classic WinDBG
	L"DbgX.Shell", // new WinDBG
	L"idawindow",
	L"tnavbox",
	L"idaview",
	L"tgrzoom",
	L"PROCMON_WINDOW_CLASS", // Process Monitor
	L"APIMonitor By Rohitab",
	L"99929D61-1338-48B1-9433-D42A1D94F0D2" // API Monitor
};

extern "C" void InstrumentationCallbackAsm();

extern HOOK_DLL_DATA HookDllData;
extern SAVE_DEBUG_REGISTERS ArrayDebugRegister[100];

static USHORT DebugObjectTypeIndex = 0;
static USHORT ProcessTypeIndex = 0;
static USHORT ThreadTypeIndex = 0;

bool IsProcessNameBad(PUNICODE_STRING processName)
{
	if (processName == nullptr || processName->Length == 0 || processName->Buffer == nullptr)
		return false;

	UNICODE_STRING badProcessName;
	for (int i = 0; i < _countof(BadProcessnameList); i++)
	{
		RtlInitUnicodeString(&badProcessName, const_cast<PWSTR>(BadProcessnameList[i]));
		if (RtlEqualUnicodeString(processName, &badProcessName, TRUE))
			return true;
	}
	return false;
}

bool IsWindowClassNameBad(PUNICODE_STRING className)
{
	if (className == nullptr || className->Length == 0 || className->Buffer == nullptr)
		return false;

	UNICODE_STRING badWindowClassName;
	for (int i = 0; i < _countof(BadWindowClassList); i++)
	{
		RtlInitUnicodeString(&badWindowClassName, const_cast<PWSTR>(BadWindowClassList[i]));
		if (RtlUnicodeStringContains(className, &badWindowClassName, TRUE))
			return true;
	}
	return false;
}

bool IsWindowNameBad(PUNICODE_STRING windowName)
{
	if (windowName == nullptr || windowName->Length == 0 || windowName->Buffer == nullptr)
		return false;

	UNICODE_STRING badWindowName;
	for (int i = 0; i < _countof(BadWindowTextList); i++)
	{
		RtlInitUnicodeString(&badWindowName, const_cast<PWSTR>(BadWindowTextList[i]));
		if (RtlUnicodeStringContains(windowName, &badWindowName, TRUE))
			return true;
	}
	return false;
}

bool IsWindowBad(HWND hWnd)
{
	if (HookDllData.EnableProtectProcessId)
	{
		const ULONG Pid = HookDllData.dNtUserQueryWindow != nullptr
			? HandleToULong(HookDllData.dNtUserQueryWindow(hWnd, WindowProcess))
			: HandleToULong(HookDllData.NtUserQueryWindow(hWnd, WindowProcess));
		if (Pid == HookDllData.dwProtectedProcessId)
			return true;
	}

	DECLARE_UNICODE_STRING_SIZE(ClassName, 256);
	DECLARE_UNICODE_STRING_SIZE(WindowText, 512);

	ClassName.Length = (USHORT)HookDllData.NtUserGetClassName(hWnd, FALSE, &ClassName) * sizeof(WCHAR);
	ClassName.Buffer[ClassName.Length / sizeof(WCHAR)] = UNICODE_NULL;
	if (IsWindowClassNameBad(&ClassName))
		return true;

	WindowText.Length = (USHORT)HookDllData.NtUserInternalGetWindowText(hWnd, WindowText.Buffer, (INT)(WindowText.MaximumLength / sizeof(WCHAR))) * sizeof(WCHAR);
	WindowText.Buffer[WindowText.Length / sizeof(WCHAR)] = UNICODE_NULL;
	return IsWindowNameBad(&WindowText);
}

static void GetBadObjectTypes()
{
	// If NtQSI is not hooked, this function is N/A
	if (HookDllData.dNtQuerySystemInformation == nullptr)
		return;

	// Only get the object type indices once
	if (DebugObjectTypeIndex != 0 || ProcessTypeIndex != 0 || ThreadTypeIndex != 0)
		return;

	// Create handles to three bad object types: an empty debug object and our own process and thread
	HANDLE DebugObjectHandle = nullptr, ProcessHandle = nullptr, ThreadHandle = nullptr;
	OBJECT_ATTRIBUTES ObjectAttributes = { sizeof(OBJECT_ATTRIBUTES) };
	CLIENT_ID ClientId = NtCurrentTeb()->ClientId;
	NtCreateDebugObject(&DebugObjectHandle, DEBUG_ALL_ACCESS, &ObjectAttributes, 0);
	NtOpenProcess(&ProcessHandle, PROCESS_ALL_ACCESS, &ObjectAttributes, &ClientId);
	NtOpenThread(&ThreadHandle, THREAD_ALL_ACCESS, &ObjectAttributes, &ClientId);
	
	SYSTEM_HANDLE_INFORMATION_EX Dummy; // Prevent getting STATUS_INFO_LENGTH_MISMATCH twice
	PSYSTEM_HANDLE_INFORMATION_EX HandleInfo = &Dummy;
	ULONG Size;
	NTSTATUS Status;
	if ((Status = HookDllData.dNtQuerySystemInformation(SystemExtendedHandleInformation,
														HandleInfo,
														sizeof(Dummy),
														&Size)) != STATUS_INFO_LENGTH_MISMATCH)
		goto exit;

	HandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)RtlAllocateHeap(RtlProcessHeap(), 0, 2 * Size);
	Status = HookDllData.dNtQuerySystemInformation(SystemExtendedHandleInformation,
													HandleInfo,
													2 * Size,
													nullptr);
	if (!NT_SUCCESS(Status))
		goto exit;

	// Enumerate all handles
	for (ULONG i = 0; i < HandleInfo->NumberOfHandles; ++i)
	{
		SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Entry = HandleInfo->Handles[i];
		if (Entry.UniqueProcessId != (ULONG_PTR)NtCurrentTeb()->ClientId.UniqueProcess)
			continue; // Not our process

		if (Entry.HandleValue == (ULONG_PTR)DebugObjectHandle)
			DebugObjectTypeIndex = Entry.ObjectTypeIndex;
		else if (Entry.HandleValue == (ULONG_PTR)ProcessHandle)
			ProcessTypeIndex = Entry.ObjectTypeIndex;
		else if (Entry.HandleValue == (ULONG_PTR)ThreadHandle)
			ThreadTypeIndex = Entry.ObjectTypeIndex;
	}

exit:
	if (DebugObjectHandle != nullptr)
		NtClose(DebugObjectHandle);
	if (ProcessHandle != nullptr)
		NtClose(ProcessHandle);
	if (ThreadHandle != nullptr)
		NtClose(ThreadHandle);
	if (HandleInfo != &Dummy)
		RtlFreeHeap(RtlProcessHeap(), 0, HandleInfo);
}

bool IsObjectTypeBad(USHORT objectTypeIndex)
{
	GetBadObjectTypes();
	return objectTypeIndex == DebugObjectTypeIndex ||
		objectTypeIndex == ProcessTypeIndex ||
		objectTypeIndex == ThreadTypeIndex;
}

static LUID ConvertLongToLuid(LONG value)
{
	LUID luid;
	LARGE_INTEGER largeInt;
	largeInt.QuadPart = value;
	luid.LowPart = largeInt.LowPart;
	luid.HighPart = largeInt.HighPart;
	return luid;
}

bool HasDebugPrivileges(HANDLE hProcess)
{
	HANDLE hToken;
	NTSTATUS status = NtOpenProcessToken(hProcess, TOKEN_QUERY, &hToken);
	if (!NT_SUCCESS(status))
		return false;

	const LUID SeDebugPrivilege = ConvertLongToLuid(SE_DEBUG_PRIVILEGE);

	PRIVILEGE_SET privilegeSet;
	privilegeSet.PrivilegeCount = 1;
	privilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
	privilegeSet.Privilege[0].Luid = SeDebugPrivilege;
	privilegeSet.Privilege[0].Attributes = 0;

	BOOLEAN hasDebugPrivileges = FALSE;
	NtPrivilegeCheck(hToken, &privilegeSet, &hasDebugPrivileges);

	NtClose(hToken);
	return hasDebugPrivileges == TRUE;
}

bool IsWow64Process(HANDLE ProcessHandle)
{
	PPEB WoW64Peb = nullptr;
	const NTSTATUS Status = NtQueryInformationProcess(ProcessHandle,
													ProcessWow64Information,
													&WoW64Peb,
													sizeof(PPEB),
													nullptr);

	return NT_SUCCESS(Status) && WoW64Peb != nullptr;
}

NTSTATUS
InstallInstrumentationCallbackHook(
	_In_ HANDLE ProcessHandle,
	_In_ BOOLEAN Remove
	)
{
	const PVOID Callback = Remove ? nullptr : (PVOID)InstrumentationCallbackAsm;
	NTSTATUS Status = STATUS_NOT_SUPPORTED;

	if (RtlNtMajorVersion() > 6)
	{
		// Windows 10
		PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION InstrumentationCallbackInfo;
#ifdef _WIN64
		InstrumentationCallbackInfo.Version = 0;
#else
		// Native x86 instrumentation callbacks don't work correctly
		if (!IsWow64Process(ProcessHandle))
		{
			//InstrumentationCallbackInfo.Version = 1; // Value to use if they did
			return Status;
		}

		// WOW64: set the callback pointer in the version field
		InstrumentationCallbackInfo.Version = (ULONG_PTR)Callback;
#endif
		InstrumentationCallbackInfo.Reserved = 0;
		InstrumentationCallbackInfo.Callback = Callback;

		Status = HookDllData.dNtSetInformationProcess != nullptr
			? HookDllData.dNtSetInformationProcess(ProcessHandle,
													ProcessInstrumentationCallback,
													&InstrumentationCallbackInfo,
													sizeof(InstrumentationCallbackInfo))
			: NtSetInformationProcess(ProcessHandle,
									ProcessInstrumentationCallback,
									&InstrumentationCallbackInfo,
									sizeof(InstrumentationCallbackInfo));
	}
#ifdef _WIN64 // Windows 7-8.1 do not support x86/WOW64 instrumentation callbacks
	else if (RtlNtMajorVersion() == 6 && RtlNtMinorVersion() >= 1)
	{
		// Windows 7-8.1 require SE_DEBUG for this to work, even on the current process
		BOOLEAN SeDebugWasEnabled;
		Status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, TRUE, FALSE, &SeDebugWasEnabled);
		if (!NT_SUCCESS(Status))
			return Status;

		Status = HookDllData.dNtSetInformationProcess != nullptr
			? HookDllData.dNtSetInformationProcess(ProcessHandle,
													ProcessInstrumentationCallback,
													(PVOID)&Callback,
													sizeof(Callback))
			: NtSetInformationProcess(ProcessHandle,
									ProcessInstrumentationCallback,
									(PVOID)&Callback,
									sizeof(Callback));

		RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, SeDebugWasEnabled, FALSE, &SeDebugWasEnabled);
	}
#endif

	return Status;
}

void * GetPEBRemote(HANDLE hProcess)
{
	PROCESS_BASIC_INFORMATION pbi;

	if (HookDllData.dNtQueryInformationProcess)
	{
		if (HookDllData.dNtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), 0) >= 0)
		{
			return pbi.PebBaseAddress;
		}
	}
	else
	{
		//maybe not hooked
		if (NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), 0) >= 0)
		{
			return pbi.PebBaseAddress;
		}
	}

	return 0;
}


DWORD GetProcessIdByProcessHandle(HANDLE hProcess)
{
	PROCESS_BASIC_INFORMATION pbi;

	if (HookDllData.dNtQueryInformationProcess)
	{
		if (HookDllData.dNtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), 0) >= 0)
		{
			return HandleToULong(pbi.UniqueProcessId);
		}
	}
	else
	{
		//maybe not hooked
		if (NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), 0) >= 0)
		{
			return HandleToULong(pbi.UniqueProcessId);
		}
	}

	return 0;
}

DWORD GetProcessIdByThreadHandle(HANDLE hThread)
{
	THREAD_BASIC_INFORMATION tbi;

	if (NT_SUCCESS(NtQueryInformationThread(hThread, ThreadBasicInformation, &tbi, sizeof(THREAD_BASIC_INFORMATION), 0)))
	{
		return HandleToULong(tbi.ClientId.UniqueProcess);
	}

	return 0;
}

void TerminateProcessByProcessId(DWORD dwProcess)
{
	if (dwProcess == 0)
		return;

	OBJECT_ATTRIBUTES attributes = { sizeof(OBJECT_ATTRIBUTES) };
	CLIENT_ID clientId = { ULongToHandle(dwProcess) };
	HANDLE hProcess;
	NTSTATUS status = NtOpenProcess(&hProcess, PROCESS_TERMINATE, &attributes, &clientId);
	if (NT_SUCCESS(status))
	{
		NtTerminateProcess(hProcess, STATUS_SUCCESS);
		NtClose(hProcess);
	}
}

static DWORD dwExplorerPid = 0;

DWORD GetExplorerProcessId()
{
	if (dwExplorerPid == 0)
	{
		UNICODE_STRING explorerName = RTL_CONSTANT_STRING(L"explorer.exe");
		dwExplorerPid = GetProcessIdByName(&explorerName);
	}
	return dwExplorerPid;
}

DWORD GetProcessIdByName(PUNICODE_STRING processName)
{
	ULONG size;
	if (NtQuerySystemInformation(SystemProcessInformation, nullptr, 0, &size) != STATUS_INFO_LENGTH_MISMATCH)
		return 0;
	const PSYSTEM_PROCESS_INFORMATION systemProcessInfo =
		static_cast<PSYSTEM_PROCESS_INFORMATION>(RtlAllocateHeap(RtlProcessHeap(), 0, 2 * size));
	NTSTATUS status;
	if (HookDllData.dNtQuerySystemInformation != nullptr)
	{
		status = HookDllData.dNtQuerySystemInformation(SystemProcessInformation,
													systemProcessInfo,
													2 * size,
													nullptr);
	}
	else
	{
		status = NtQuerySystemInformation(SystemProcessInformation,
											systemProcessInfo,
											2 * size,
											nullptr);
	}
	if (!NT_SUCCESS(status))
		return 0;

	DWORD pid = 0;
	PSYSTEM_PROCESS_INFORMATION process = systemProcessInfo;
	while (true)
	{
		if (RtlEqualUnicodeString(&process->ImageName, processName, TRUE))
		{
			pid = HandleToULong(process->UniqueProcessId);
			break;
		}

		if (process->NextEntryOffset == 0)
			break;
		process = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)process + process->NextEntryOffset);
	}

	RtlFreeHeap(RtlProcessHeap(), 0, systemProcessInfo);
	return pid;
}

bool RtlUnicodeStringContains(PUNICODE_STRING Str, PUNICODE_STRING SubStr, BOOLEAN CaseInsensitive)
{
	if (Str == nullptr || SubStr == nullptr || Str->Length < SubStr->Length)
		return false;

	const USHORT numCharsDiff = (Str->Length - SubStr->Length) / sizeof(WCHAR);
	UNICODE_STRING slice = *Str;
	slice.Length = SubStr->Length;

	for (USHORT i = 0; i <= numCharsDiff; ++i, ++slice.Buffer, slice.MaximumLength -= sizeof(WCHAR))
	{
		if (RtlEqualUnicodeString(&slice, SubStr, CaseInsensitive))
			return true;
	}
	return false;
}

void ThreadDebugContextRemoveEntry(const int index)
{
	ArrayDebugRegister[index].dwThreadId = 0;
}

void ThreadDebugContextSaveContext(const int index, const PCONTEXT ThreadContext)
{
	ArrayDebugRegister[index].dwThreadId = HandleToULong(NtCurrentTeb()->ClientId.UniqueThread);
	ArrayDebugRegister[index].Dr0 = ThreadContext->Dr0;
	ArrayDebugRegister[index].Dr1 = ThreadContext->Dr1;
	ArrayDebugRegister[index].Dr2 = ThreadContext->Dr2;
	ArrayDebugRegister[index].Dr3 = ThreadContext->Dr3;
	ArrayDebugRegister[index].Dr6 = ThreadContext->Dr6;
	ArrayDebugRegister[index].Dr7 = ThreadContext->Dr7;
}

int ThreadDebugContextFindExistingSlotIndex()
{
	for (int i = 0; i < _countof(ArrayDebugRegister); i++)
	{
		if (ArrayDebugRegister[i].dwThreadId != 0)
		{
			if (ArrayDebugRegister[i].dwThreadId == HandleToULong(NtCurrentTeb()->ClientId.UniqueThread))
			{
				return i;
			}
		}
	}

	return -1;
}

int ThreadDebugContextFindFreeSlotIndex()
{
	for (int i = 0; i < _countof(ArrayDebugRegister); i++)
	{
		if (ArrayDebugRegister[i].dwThreadId == 0)
		{
			return i;
		}
	}

	return -1;
}

// GetSystemTime and GetLocalTime are reimplemented here because the KernelBase functions use
// RIP-relative addressing which breaks hooking. https://github.com/x64dbg/ScyllaHide/issues/31
void NTAPI RealGetSystemTime(PSYSTEMTIME lpSystemTime)
{
	TIME_FIELDS TimeFields;
	RtlTimeToTimeFields((PLARGE_INTEGER)& SharedUserData->SystemTime, &TimeFields);

	lpSystemTime->wYear = TimeFields.Year;
	lpSystemTime->wMonth = TimeFields.Month;
	lpSystemTime->wDay = TimeFields.Day;
	lpSystemTime->wHour = TimeFields.Hour;
	lpSystemTime->wMinute = TimeFields.Minute;
	lpSystemTime->wSecond = TimeFields.Second;
	lpSystemTime->wMilliseconds = TimeFields.Milliseconds;
	lpSystemTime->wDayOfWeek = TimeFields.Weekday;
}

void NTAPI RealGetLocalTime(LPSYSTEMTIME lpSystemTime)
{
	TIME_FIELDS TimeFields;
	LARGE_INTEGER SystemTime = *(PLARGE_INTEGER)& SharedUserData->SystemTime;
	LARGE_INTEGER TimeZoneBias = *(PLARGE_INTEGER)& SharedUserData->TimeZoneBias;

	SystemTime.QuadPart -= TimeZoneBias.QuadPart;
	RtlTimeToTimeFields(&SystemTime, &TimeFields);

	lpSystemTime->wYear = TimeFields.Year;
	lpSystemTime->wMonth = TimeFields.Month;
	lpSystemTime->wDay = TimeFields.Day;
	lpSystemTime->wHour = TimeFields.Hour;
	lpSystemTime->wMinute = TimeFields.Minute;
	lpSystemTime->wSecond = TimeFields.Second;
	lpSystemTime->wMilliseconds = TimeFields.Milliseconds;
	lpSystemTime->wDayOfWeek = TimeFields.Weekday;
}

void IncreaseSystemTime(LPSYSTEMTIME lpTime)
{
	lpTime->wMilliseconds++;

	//The hour. The valid values for this member are 0 through 23.
	//The minute. The valid values for this member are 0 through 59.
	//The second. The valid values for this member are 0 through 59.
	//The millisecond. The valid values for this member are 0 through 999.

	if (lpTime->wMilliseconds > 999)
	{
		lpTime->wSecond++;
		lpTime->wMilliseconds = 0;

		if (lpTime->wSecond > 59)
		{
			lpTime->wMinute++;
			lpTime->wSecond = 0;

			if (lpTime->wMinute > 59)
			{
				lpTime->wHour++;
				lpTime->wMinute = 0;

				if (lpTime->wHour > 23)
				{
					lpTime->wDay++;
					lpTime->wDayOfWeek++;
					lpTime->wHour = 0;
				}
			}
		}
	}
}


BYTE memory[sizeof(IMAGE_NT_HEADERS) + 0x100] = {0};

void DumpMalware(DWORD dwProcessId)
{
	OBJECT_ATTRIBUTES attributes = { sizeof(OBJECT_ATTRIBUTES) };
	CLIENT_ID clientId = { ULongToHandle(dwProcessId) };
	HANDLE hProcess;
	NTSTATUS status = NtOpenProcess(&hProcess, PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, &attributes, &clientId);
	if (!NT_SUCCESS(status))
		return;

	PPEB peb = (PPEB)GetPEBRemote(hProcess);
	if (peb)
	{
		DWORD_PTR imagebase = 0;
		NtReadVirtualMemory(hProcess, &peb->ImageBaseAddress, &imagebase, sizeof(DWORD_PTR), nullptr);

		NtReadVirtualMemory(hProcess, (PVOID)imagebase, memory, sizeof(memory), nullptr);

		PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)memory;
		if (pDos->e_magic == IMAGE_DOS_SIGNATURE)
		{
			PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDos + pDos->e_lfanew);
			if (pNt->Signature == IMAGE_NT_SIGNATURE)
			{
				PVOID tempMem = nullptr;
				SIZE_T size = pNt->OptionalHeader.SizeOfImage;
				status = NtAllocateVirtualMemory(NtCurrentProcess, &tempMem, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
				if (NT_SUCCESS(status))
				{
					NtReadVirtualMemory(hProcess, (PVOID)imagebase, tempMem, pNt->OptionalHeader.SizeOfImage, nullptr);
						
					WriteMalwareToDisk(tempMem, pNt->OptionalHeader.SizeOfImage, imagebase);

					size = 0;
					NtFreeVirtualMemory(NtCurrentProcess, &tempMem, &size, MEM_RELEASE);
				}
			}
		}
	}
	NtClose(hProcess);
}

WCHAR MalwareFile[MAX_PATH] = {0};
const WCHAR MalwareFilename[] = L"Unpacked.exe";

bool WriteMalwareToDisk(LPCVOID buffer, DWORD bufferSize, DWORD_PTR imagebase)
{
	if (MalwareFile[0] == 0)
	{
		PUNICODE_STRING imagePath = &NtCurrentPeb()->ProcessParameters->ImagePathName;
		ULONG size = MIN(sizeof(MalwareFile) - 1, imagePath->Length);
		RtlCopyMemory(MalwareFile, imagePath->Buffer, size);
		MalwareFile[size / sizeof(WCHAR)] = L'\0';

		for (int i = (int)(size / sizeof(WCHAR)) - 1; i >= 0; i--)
		{
			if (MalwareFile[i] == L'\\')
			{
				MalwareFile[i+1] = L'\0';
				break;
			}
		}

		wcscat(MalwareFile, MalwareFilename);
	}

	return WriteMemoryToFile(MalwareFile, buffer,bufferSize, imagebase);
}

bool WriteMemoryToFile(const WCHAR * filename, LPCVOID buffer, DWORD bufferSize, DWORD_PTR imagebase)
{
	PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buffer;
	PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDos + pDos->e_lfanew);
	PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNt);

	UNICODE_STRING NtPath;
	if (!RtlDosPathNameToNtPathName_U(filename, &NtPath, nullptr, nullptr))
		return false;
	OBJECT_ATTRIBUTES objectAttributes;
	IO_STATUS_BLOCK ioStatusBlock;
	InitializeObjectAttributes(&objectAttributes, &NtPath, OBJ_CASE_INSENSITIVE, nullptr, nullptr);

	HANDLE hFile;
	NTSTATUS status = NtCreateFile(&hFile,
								FILE_GENERIC_WRITE,
								&objectAttributes,
								&ioStatusBlock,
								nullptr,
								FILE_ATTRIBUTE_NORMAL,
								FILE_SHARE_READ,
								FILE_OVERWRITE_IF,
								FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
								nullptr,
								0);
	if (!NT_SUCCESS(status))
		return false;

	status = NtWriteFile(hFile, nullptr, nullptr, nullptr, &ioStatusBlock, (PVOID)buffer,
		pNt->OptionalHeader.SizeOfHeaders, nullptr, nullptr);

	for (WORD i = 0; i < pNt->FileHeader.NumberOfSections; i++)
	{
		status = NtWriteFile(hFile, nullptr, nullptr, nullptr, &ioStatusBlock, (BYTE *)buffer + pSection->VirtualAddress,
			pSection->SizeOfRawData, nullptr, nullptr);
		pSection++;
	}
	NtClose(hFile);

	return NT_SUCCESS(status);
}



================================================
File: HookLibrary/HookHelper.h
================================================
#pragma once

#include <ntdll/ntdll.h>

FORCEINLINE ULONG NTAPI RtlNtMajorVersion()
{
	return *(PULONG)(0x7FFE0000 + 0x26C);
}

FORCEINLINE ULONG NTAPI RtlNtMinorVersion()
{
	return *(PULONG)(0x7FFE0000 + 0x270);
}

FORCEINLINE ULONG NTAPI RtlGetTickCount()
{
	return (ULONG)(*(PULONG64)(0x7FFE0000 + 0x320) * *(PULONG)(0x7FFE0000 + 0x4) >> 24);
}

bool HasDebugPrivileges(HANDLE hProcess);
bool IsWow64Process(HANDLE ProcessHandle);
NTSTATUS InstallInstrumentationCallbackHook(HANDLE ProcessHandle, BOOLEAN Remove);
DWORD GetExplorerProcessId();
DWORD GetProcessIdByName(PUNICODE_STRING processName);
bool IsProcessNameBad(PUNICODE_STRING processName);

DWORD GetProcessIdByProcessHandle(HANDLE hProcess);
DWORD GetProcessIdByThreadHandle(HANDLE hThread);

bool RtlUnicodeStringContains(PUNICODE_STRING Str, PUNICODE_STRING SubStr, BOOLEAN CaseInsensitive);

bool IsWindowNameBad(PUNICODE_STRING windowName);
bool IsWindowClassNameBad(PUNICODE_STRING className);
bool IsWindowBad(HWND hWnd);
bool IsObjectTypeBad(USHORT objectTypeIndex);

int ThreadDebugContextFindFreeSlotIndex();
int ThreadDebugContextFindExistingSlotIndex();
void ThreadDebugContextRemoveEntry(const int index);
void ThreadDebugContextSaveContext(const int index, const PCONTEXT ThreadContext);

void NTAPI RealGetSystemTime(PSYSTEMTIME lpSystemTime);
void NTAPI RealGetLocalTime(LPSYSTEMTIME lpSystemTime);
void IncreaseSystemTime(LPSYSTEMTIME lpTime);

void TerminateProcessByProcessId(DWORD dwProcess);
bool WriteMalwareToDisk(LPCVOID buffer, DWORD bufferSize, DWORD_PTR imagebase);
bool WriteMemoryToFile(const WCHAR * filename, LPCVOID buffer, DWORD bufferSize, DWORD_PTR imagebase);
void * GetPEBRemote(HANDLE hProcess);
void DumpMalware(DWORD dwProcessId);



================================================
File: HookLibrary/HookLibrary.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{C36C2313-72A8-4583-B7D8-28E193D5287F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>HookLibrary</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
    <Import Project="hook.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
    <Import Project="hook.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
    <Import Project="hook.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
    <Import Project="hook.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>$(TargetName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>$(TargetName)x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;HOOKLIBRARY_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <StringPooling>true</StringPooling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>Export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;HOOKLIBRARY_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <StringPooling>true</StringPooling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>Export.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;HOOKLIBRARY_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <SDLCheck />
      <StringPooling>true</StringPooling>
      <FunctionLevelLinking>true</FunctionLevelLinking>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>Export.def</ModuleDefinitionFile>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;HOOKLIBRARY_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <SDLCheck />
      <StringPooling>true</StringPooling>
      <FunctionLevelLinking>true</FunctionLevelLinking>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>Export.def</ModuleDefinitionFile>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="HookedFunctions.cpp" />
    <ClCompile Include="HookHelper.cpp" />
    <ClCompile Include="DllMain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Export.def" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Scylla\VersionPatch.h" />
    <ClInclude Include="HookedFunctions.h" />
    <ClInclude Include="HookHelper.h" />
    <ClInclude Include="HookMain.h" />
    <ClInclude Include="Tls.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="InstrumentationCallbackX86.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </MASM>
    <MASM Include="InstrumentationCallbackX64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>


================================================
File: HookLibrary/HookLibrary.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HookedFunctions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HookHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DllMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Export.def">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HookMain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HookedFunctions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HookHelper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Tls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="InstrumentationCallbackX86.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="InstrumentationCallbackX64.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>


================================================
File: HookLibrary/HookMain.h
================================================
#pragma once

#include <ntdll/ntdll.h>

typedef BOOL(WINAPI * t_DllMain)(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);

typedef void  (WINAPI * t_GetSystemTime)(LPSYSTEMTIME lpSystemTime); //Kernel32.dll / kernelbase
typedef void  (WINAPI * t_GetLocalTime)(LPSYSTEMTIME lpSystemTime); //Kernel32.dll / kernelbase
typedef DWORD(WINAPI * t_timeGetTime)(void); //Winmm.dll -> sometimes GetTickCount
typedef DWORD(WINAPI * t_GetTickCount)(void); //Kernel32.dll / kernelbase
typedef ULONGLONG(WINAPI * t_GetTickCount64)(void);
typedef BOOL(WINAPI * t_QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount); //Kernel32.dll -> ntdll.RtlQueryPerformanceCounter -> NO NATIVE CALL
typedef BOOL(WINAPI * t_QueryPerformanceFrequency)(LARGE_INTEGER *lpFrequency); //kernel32.dll -> ntdll.RtlQueryPerformanceFrequency -> ntdll.ZwQueryPerformanceCounter

typedef DWORD(WINAPI * t_OutputDebugStringA)(LPCSTR lpOutputString); //Kernel32.dll
typedef DWORD(WINAPI * t_OutputDebugStringW)(LPCWSTR lpOutputString); //Kernel32.dll
//WIN 7 X64: OutputDebugStringW -> OutputDebugStringA

#define MAX_NATIVE_HOOKS 32

#pragma pack(push, 1)
typedef struct _HOOK_NATIVE_CALL32 {
    DWORD eaxValue;
    DWORD ecxValue;
    PVOID hookedFunction;
} HOOK_NATIVE_CALL32;

typedef struct _HOOK_DLL_DATA {
    HMODULE hDllImage;

    BOOLEAN EnablePebBeingDebugged;
    BOOLEAN EnablePebHeapFlags;
    BOOLEAN EnablePebNtGlobalFlag;
    BOOLEAN EnablePebStartupInfo;
    BOOLEAN EnablePebOsBuildNumber;

    BOOLEAN EnableOutputDebugStringHook;

    BOOLEAN EnableNtSetInformationThreadHook;
    BOOLEAN EnableNtQuerySystemInformationHook;
    BOOLEAN EnableNtQueryInformationProcessHook;
	BOOLEAN EnableNtSetInformationProcessHook;
    BOOLEAN EnableNtQueryObjectHook;
    BOOLEAN EnableNtYieldExecutionHook;
    BOOLEAN EnableNtCloseHook;

    BOOLEAN EnablePreventThreadCreation;
    BOOLEAN EnableNtCreateThreadExHook;

    //Protect and Hide Hardware Breakpoints
    BOOLEAN EnableNtGetContextThreadHook;
    BOOLEAN EnableNtSetContextThreadHook;
    BOOLEAN EnableNtContinueHook;
    BOOLEAN EnableKiUserExceptionDispatcherHook;

    //Native user32.dll/win32u.dll functions
    ULONG_PTR NtUserBlockInputVA;
    ULONG_PTR NtUserQueryWindowVA;
    ULONG_PTR NtUserGetForegroundWindowVA;
    ULONG_PTR NtUserBuildHwndListVA;
    ULONG_PTR NtUserFindWindowExVA;
    ULONG_PTR NtUserGetClassNameVA;
    ULONG_PTR NtUserInternalGetWindowTextVA;
    ULONG_PTR NtUserGetThreadStateVA;

    BOOLEAN EnableNtUserBlockInputHook;
    BOOLEAN EnableNtUserQueryWindowHook;
    BOOLEAN EnableNtUserGetForegroundWindowHook;
    BOOLEAN EnableNtUserBuildHwndListHook;
    BOOLEAN EnableNtUserFindWindowExHook;
    BOOLEAN EnableNtSetDebugFilterStateHook;

	BOOLEAN EnableGetTickCountHook;
	BOOLEAN EnableGetTickCount64Hook;
	BOOLEAN EnableGetLocalTimeHook;
	BOOLEAN EnableGetSystemTimeHook;
	BOOLEAN EnableNtQuerySystemTimeHook;
	BOOLEAN EnableNtQueryPerformanceCounterHook;

	//special
	BOOLEAN EnableMalwareRunPeUnpacker;
	//t_NtWriteVirtualMemory dNtWriteVirtualMemory;
	//DWORD NtWriteVirtualMemoryBackupSize;
	t_NtResumeThread dNtResumeThread;
	DWORD NtResumeThreadBackupSize;

	t_NtSetDebugFilterState dNtSetDebugFilterState;
	DWORD NtSetDebugFilterStateBackupSize;
    t_NtSetInformationThread dNtSetInformationThread;
    DWORD NtSetInformationThreadBackupSize;
    t_NtQuerySystemInformation dNtQuerySystemInformation;
    DWORD NtQuerySystemInformationBackupSize;
    t_NtSetInformationProcess dNtSetInformationProcess;
    DWORD NtSetInformationProcessBackupSize;
    t_NtQueryInformationProcess dNtQueryInformationProcess;
    DWORD NtQueryInformationProcessBackupSize;
    t_NtQueryObject dNtQueryObject;
    DWORD NtQueryObjectBackupSize;
    t_NtYieldExecution dNtYieldExecution;
    DWORD NtYieldExecutionBackupSize;
    t_NtGetContextThread dNtGetContextThread;
    DWORD NtGetContextThreadBackupSize;
    t_NtSetContextThread dNtSetContextThread;
    DWORD NtSetContextThreadBackupSize;
    t_KiUserExceptionDispatcher dKiUserExceptionDispatcher;
    DWORD KiUserExceptionDispatcherBackupSize;
    t_NtContinue dNtContinue;
    DWORD NtContinueBackupSize;
    t_NtClose dNtClose;
    DWORD NtCloseBackupSize;
    t_NtDuplicateObject dNtDuplicateObject;
    DWORD NtDuplicateObjectBackupSize;

    t_NtCreateThreadEx dNtCreateThreadEx; //only since vista
    DWORD NtCreateThreadExBackupSize;
    t_NtCreateThread dNtCreateThread;
    DWORD NtCreateThreadBackupSize;

    t_NtOpenFile dNtOpenFile;
    DWORD NtOpenFileBackupSize;
    t_NtCreateSection dNtCreateSection;
    DWORD NtCreateSectionBackupSize;
    t_NtMapViewOfSection dNtMapViewOfSection;
    DWORD NtMapViewOfSectionBackupSize;

	/////////////////////////////////////////////////////////
	t_GetTickCount dGetTickCount;
	DWORD GetTickCountBackupSize;
	t_GetTickCount64 dGetTickCount64;
	DWORD GetTickCount64BackupSize;

	t_GetLocalTime dGetLocalTime;
	DWORD GetLocalTimeBackupSize;
	t_GetSystemTime dGetSystemTime;
	DWORD GetSystemTimeBackupSize;

	t_NtQuerySystemTime dNtQuerySystemTime;
	DWORD NtQuerySystemTimeBackupSize;
	t_NtQueryPerformanceCounter dNtQueryPerformanceCounter;
	DWORD NtQueryPerformanceCounterBackupSize;
	/////////////////////////////////////////////////////////


    t_OutputDebugStringA dOutputDebugStringA;
    DWORD OutputDebugStringABackupSize;

    t_NtUserBlockInput dNtUserBlockInput;
    DWORD NtUserBlockInputBackupSize;
    t_NtUserFindWindowEx dNtUserFindWindowEx;
    DWORD NtUserFindWindowExBackupSize;
    t_NtUserBuildHwndList /*or t_NtUserBuildHwndList_Eight*/ dNtUserBuildHwndList;
    DWORD NtUserBuildHwndListBackupSize;
    t_NtUserQueryWindow dNtUserQueryWindow;
    DWORD NtUserQueryWindowBackupSize;
    t_NtUserGetForegroundWindow dNtUserGetForegroundWindow;
    DWORD NtUserGetForegroundWindowBackupSize;


    t_NtUserQueryWindow NtUserQueryWindow;
    t_NtUserGetClassName NtUserGetClassName;
    t_NtUserInternalGetWindowText NtUserInternalGetWindowText;
    t_NtUserGetThreadState NtUserGetThreadState;

    DWORD dwProtectedProcessId;
    BOOLEAN EnableProtectProcessId;


    BOOLEAN isNtdllHooked;
    BOOLEAN isKernel32Hooked;
    BOOLEAN isUserDllHooked;

#ifndef _WIN64
    HOOK_NATIVE_CALL32 HookNative[MAX_NATIVE_HOOKS];
    PVOID NativeCallContinue;
#endif
} HOOK_DLL_DATA;
#pragma pack(pop)

#define HOOK_ERROR_SUCCESS 0
#define HOOK_ERROR_RESOLVE_IMPORT 1
#define HOOK_ERROR_DLLMAIN 2
#define HOOK_ERROR_PEHEADER 3




================================================
File: HookLibrary/HookedFunctions.cpp
================================================
#include "HookMain.h"

#pragma intrinsic(_ReturnAddress)

HOOK_DLL_DATA HookDllData = { 0 };

#include "HookedFunctions.h"
#include "HookHelper.h"
#include "Tls.h"

#include "Scylla/VersionPatch.h"

void FakeCurrentParentProcessId(PSYSTEM_PROCESS_INFORMATION pInfo);
void FakeCurrentOtherOperationCount(PSYSTEM_PROCESS_INFORMATION pInfo);
void FilterHandleInfo(PSYSTEM_HANDLE_INFORMATION pHandleInfo, PULONG pReturnLengthAdjust);
void FilterHandleInfoEx(PSYSTEM_HANDLE_INFORMATION_EX pHandleInfoEx, PULONG pReturnLengthAdjust);
void FilterProcess(PSYSTEM_PROCESS_INFORMATION pInfo);
void FilterObjects(POBJECT_TYPES_INFORMATION pObjectTypes);
void FilterObject(POBJECT_TYPE_INFORMATION pObject, bool zeroTotal);
void FilterHwndList(HWND * phwndFirst, PUINT pcHwndNeeded);

SAVE_DEBUG_REGISTERS ArrayDebugRegister[100] = { 0 }; //Max 100 threads

// https://forum.tuts4you.com/topic/40011-debugme-vmprotect-312-build-886-anti-debug-method-improved/#comment-192824
// https://github.com/x64dbg/ScyllaHide/issues/47
// https://github.com/mrexodia/TitanHide/issues/27
#define BACKUP_RETURNLENGTH() \
    ULONG TempReturnLength = 0; \
    if(ReturnLength != nullptr) \
        TempReturnLength = *ReturnLength

#define RESTORE_RETURNLENGTH() \
    if(ReturnLength != nullptr) \
        (*ReturnLength) = TempReturnLength

NTSTATUS NTAPI HookedNtSetInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength)
{
    if (ThreadInformationClass == ThreadHideFromDebugger && ThreadInformationLength == 0) // NB: ThreadInformation is not checked, this is deliberate
    {
        if (ThreadHandle == NtCurrentThread ||
			HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess) == GetProcessIdByThreadHandle(ThreadHandle)) //thread inside this process?
        {
            return STATUS_SUCCESS;
        }
    }
    return HookDllData.dNtSetInformationThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
}

NTSTATUS NTAPI HookedNtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength)
{
    if (SystemInformationClass == SystemKernelDebuggerInformation ||
        SystemInformationClass == SystemProcessInformation ||
        SystemInformationClass == SystemSessionProcessInformation ||
        SystemInformationClass == SystemHandleInformation ||
        SystemInformationClass == SystemExtendedHandleInformation ||
        SystemInformationClass == SystemExtendedProcessInformation ||   // Vista+
        SystemInformationClass == SystemCodeIntegrityInformation ||     // Vista+
        SystemInformationClass == SystemKernelDebuggerInformationEx ||  // 8.1+
        SystemInformationClass == SystemKernelDebuggerFlags ||          // 10+
        SystemInformationClass == SystemCodeIntegrityUnlockInformation) // 10+
    {
        NTSTATUS ntStat = HookDllData.dNtQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
        if (NT_SUCCESS(ntStat) && SystemInformation != nullptr && SystemInformationLength != 0)
        {
            if (SystemInformationClass == SystemKernelDebuggerInformation)
            {
                BACKUP_RETURNLENGTH();

                ((PSYSTEM_KERNEL_DEBUGGER_INFORMATION)SystemInformation)->KernelDebuggerEnabled = FALSE;
                ((PSYSTEM_KERNEL_DEBUGGER_INFORMATION)SystemInformation)->KernelDebuggerNotPresent = TRUE;

                RESTORE_RETURNLENGTH();
            }
            else if (SystemInformationClass == SystemHandleInformation)
            {
                BACKUP_RETURNLENGTH();
                ULONG ReturnLengthAdjust = 0;

                FilterHandleInfo((PSYSTEM_HANDLE_INFORMATION)SystemInformation, &ReturnLengthAdjust);

                if (ReturnLengthAdjust <= TempReturnLength)
				    TempReturnLength -= ReturnLengthAdjust;
                RESTORE_RETURNLENGTH();
            }
            else if (SystemInformationClass == SystemExtendedHandleInformation)
            {
                BACKUP_RETURNLENGTH();
                ULONG ReturnLengthAdjust = 0;

                FilterHandleInfoEx((PSYSTEM_HANDLE_INFORMATION_EX)SystemInformation, &ReturnLengthAdjust);

                if (ReturnLengthAdjust <= TempReturnLength)
                    TempReturnLength -= ReturnLengthAdjust;
                RESTORE_RETURNLENGTH();
            }
            else if (SystemInformationClass == SystemProcessInformation ||
                    SystemInformationClass == SystemSessionProcessInformation ||
                    SystemInformationClass == SystemExtendedProcessInformation)
            {
                BACKUP_RETURNLENGTH();

                PSYSTEM_PROCESS_INFORMATION ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;
                if (SystemInformationClass == SystemSessionProcessInformation)
                    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)((PSYSTEM_SESSION_PROCESS_INFORMATION)SystemInformation)->Buffer;

                FilterProcess(ProcessInfo);
                FakeCurrentParentProcessId(ProcessInfo);
                FakeCurrentOtherOperationCount(ProcessInfo);

                RESTORE_RETURNLENGTH();
            }
            else if (SystemInformationClass == SystemCodeIntegrityInformation)
            {
                BACKUP_RETURNLENGTH();

                ((PSYSTEM_CODEINTEGRITY_INFORMATION)SystemInformation)->CodeIntegrityOptions = CODEINTEGRITY_OPTION_ENABLED;

                RESTORE_RETURNLENGTH();
            }
            else if (SystemInformationClass == SystemKernelDebuggerInformationEx)
            {
                BACKUP_RETURNLENGTH();

                ((PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)SystemInformation)->DebuggerAllowed = FALSE;
                ((PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)SystemInformation)->DebuggerEnabled = FALSE;
                ((PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX)SystemInformation)->DebuggerPresent = FALSE;

                RESTORE_RETURNLENGTH();
            }
            else if (SystemInformationClass == SystemKernelDebuggerFlags)
            {
                BACKUP_RETURNLENGTH();

                *(PUCHAR)SystemInformation = 0;

                RESTORE_RETURNLENGTH();
            }
            else if (SystemInformationClass == SystemCodeIntegrityUnlockInformation)
            {
                BACKUP_RETURNLENGTH();

                // The size of the buffer for this class changed from 4 to 36, but the output should still be all zeroes
                RtlZeroMemory(SystemInformation, SystemInformationLength);

                RESTORE_RETURNLENGTH();
            }
        }

        return ntStat;
    }
    return HookDllData.dNtQuerySystemInformation(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);
}

static ULONG ValueProcessBreakOnTermination = FALSE;
static ULONG ValueProcessDebugFlags = PROCESS_DEBUG_INHERIT; // actual value is no inherit
static bool IsProcessHandleTracingEnabled = false;

#ifndef STATUS_INVALID_PARAMETER
#define STATUS_INVALID_PARAMETER         ((DWORD   )0xC000000DL)
#endif

// Instrumentation callback

static LONG volatile InstrumentationCallbackHookInstalled = 0;
static ULONG NumManualSyscalls = 0;

extern "C"
ULONG_PTR
NTAPI
InstrumentationCallback(
    _In_ ULONG_PTR ReturnAddress, // ECX/R10
    _Inout_ ULONG_PTR ReturnVal // EAX/RAX
    )
{
    if (InterlockedOr(TlsGetInstrumentationCallbackDisabled(), 0x1) == 0x1)
        return ReturnVal; // Do not recurse

    const PVOID ImageBase = NtCurrentPeb()->ImageBaseAddress;
    const PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(ImageBase);
    if (NtHeaders != nullptr && ReturnAddress >= (ULONG_PTR)ImageBase &&
        ReturnAddress < (ULONG_PTR)ImageBase + NtHeaders->OptionalHeader.SizeOfImage)
    {
        // Syscall return address within the exe file
        ReturnVal = (ULONG_PTR)(ULONG)STATUS_PORT_NOT_SET;

        // Uninstall ourselves after we have completed the sequence { NtQIP, NtQIP }. More NtSITs will follow but we can't do anything about them
        NumManualSyscalls++;
        if (NumManualSyscalls >= 2)
        {
            InstallInstrumentationCallbackHook(NtCurrentProcess, TRUE);
        }
    }

    InterlockedAnd(TlsGetInstrumentationCallbackDisabled(), 0);

    return ReturnVal;
}

NTSTATUS NTAPI HookedNtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength)
{
    if (NumManualSyscalls == 0 &&
        InterlockedOr(&InstrumentationCallbackHookInstalled, 0x1) == 0)
    {
        InstallInstrumentationCallbackHook(NtCurrentProcess, FALSE);
    }

    NTSTATUS Status;
    if (ProcessInformationClass == ProcessDebugObjectHandle && // Handle ProcessDebugObjectHandle early
        ProcessInformation != nullptr &&
        ProcessInformationLength == sizeof(HANDLE) &&
        (ProcessHandle == NtCurrentProcess || HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess) == GetProcessIdByProcessHandle(ProcessHandle)))
    {
        // Verify (1) that the handle has PROCESS_QUERY_INFORMATION access, and (2) that writing
        // to ProcessInformation and/or ReturnLength does not cause any access or alignment violations
        Status = HookDllData.dNtQueryInformationProcess(ProcessHandle,
                                                        ProcessDebugPort, // Note: not ProcessDebugObjectHandle
                                                        ProcessInformation,
                                                        sizeof(HANDLE),
                                                        ReturnLength);
        if (!NT_SUCCESS(Status))
            return Status;

        // The kernel calls DbgkOpenProcessDebugPort here

        // This should be done in a try/except block, but since we are a mapped DLL we cannot use SEH.
        // Rely on the fact that the NtQIP call we just did wrote to the same buffers successfully
        *(PHANDLE)ProcessInformation = nullptr;
        if (ReturnLength != nullptr)
            *ReturnLength = sizeof(HANDLE);

        return STATUS_PORT_NOT_SET;
    }

    if ((ProcessInformationClass == ProcessDebugFlags ||
        ProcessInformationClass == ProcessDebugPort ||
        ProcessInformationClass == ProcessBasicInformation ||
        ProcessInformationClass == ProcessBreakOnTermination ||
        ProcessInformationClass == ProcessHandleTracing ||
        ProcessInformationClass == ProcessIoCounters) &&
        (ProcessHandle == NtCurrentProcess || HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess) == GetProcessIdByProcessHandle(ProcessHandle)))
    {
        Status = HookDllData.dNtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);

        if (NT_SUCCESS(Status) && ProcessInformation != nullptr && ProcessInformationLength != 0)
        {
            if (ProcessInformationClass == ProcessDebugFlags)
            {
                BACKUP_RETURNLENGTH();

                *((ULONG *)ProcessInformation) = ((ValueProcessDebugFlags & PROCESS_NO_DEBUG_INHERIT) != 0) ? 0 : PROCESS_DEBUG_INHERIT;

                RESTORE_RETURNLENGTH();
            }
            else if (ProcessInformationClass == ProcessDebugPort)
            {
                BACKUP_RETURNLENGTH();

                *((HANDLE *)ProcessInformation) = nullptr;

                RESTORE_RETURNLENGTH();
            }
            else if (ProcessInformationClass == ProcessBasicInformation) //Fake parent
            {
                BACKUP_RETURNLENGTH();

                ((PPROCESS_BASIC_INFORMATION)ProcessInformation)->InheritedFromUniqueProcessId = ULongToHandle(GetExplorerProcessId());

                RESTORE_RETURNLENGTH();
            }
            else if (ProcessInformationClass == ProcessBreakOnTermination)
            {
                BACKUP_RETURNLENGTH();

                *((ULONG *)ProcessInformation) = ValueProcessBreakOnTermination;

                RESTORE_RETURNLENGTH();
            }
			else if (ProcessInformationClass == ProcessHandleTracing)
			{
                BACKUP_RETURNLENGTH();
                RESTORE_RETURNLENGTH(); // Trigger any possible exceptions caused by messing with the output buffer before changing the final return status

                Status = IsProcessHandleTracingEnabled ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
			}
            else if (ProcessInformationClass == ProcessIoCounters)
            {
                BACKUP_RETURNLENGTH();

                ((PIO_COUNTERS)ProcessInformation)->OtherOperationCount = 1;

                RESTORE_RETURNLENGTH();
            }
        }

        return Status;
    }
    return HookDllData.dNtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
}

NTSTATUS NTAPI HookedNtSetInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength)
{
	if (ProcessHandle == NtCurrentProcess || HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess) == GetProcessIdByProcessHandle(ProcessHandle))
    {
        if (ProcessInformationClass == ProcessBreakOnTermination)
        {
			if (ProcessInformationLength != sizeof(ULONG))
			{
				return STATUS_INFO_LENGTH_MISMATCH;
			}

			// NtSetInformationProcess will happily dereference this pointer
			if (ProcessInformation == NULL)
			{
				return STATUS_ACCESS_VIOLATION;
			}

			// A process must have debug privileges enabled to set the ProcessBreakOnTermination flag
			if (!HasDebugPrivileges(NtCurrentProcess))
			{
				return STATUS_PRIVILEGE_NOT_HELD;
			}

            ValueProcessBreakOnTermination = *((ULONG *)ProcessInformation);
            return STATUS_SUCCESS;
        }

		// Don't allow changing the debug inherit flag, and keep track of the new value to report in NtQIP
		if (ProcessInformationClass == ProcessDebugFlags)
		{
			if (ProcessInformationLength != sizeof(ULONG))
			{
				return STATUS_INFO_LENGTH_MISMATCH;
			}

			if (ProcessInformation == NULL)
			{
				return STATUS_ACCESS_VIOLATION;
			}

			ULONG Flags = *(ULONG*)ProcessInformation;
			if ((Flags & ~PROCESS_DEBUG_INHERIT) != 0)
			{
				return STATUS_INVALID_PARAMETER;
			}

			if ((Flags & PROCESS_DEBUG_INHERIT) != 0)
			{
				ValueProcessDebugFlags &= ~PROCESS_NO_DEBUG_INHERIT;
			}
			else
			{
				ValueProcessDebugFlags |= PROCESS_NO_DEBUG_INHERIT;
			}
			return STATUS_SUCCESS;
		}

		//PROCESS_HANDLE_TRACING_ENABLE -> ULONG, PROCESS_HANDLE_TRACING_ENABLE_EX -> ULONG,ULONG
		if (ProcessInformationClass == ProcessHandleTracing)
		{
			bool enable = ProcessInformationLength != 0; // A length of 0 is valid and indicates we should disable tracing
			if (enable)
			{
				if (ProcessInformationLength != sizeof(ULONG) && ProcessInformationLength != (sizeof(ULONG) * 2))
				{
					return STATUS_INFO_LENGTH_MISMATCH;
				}

				// NtSetInformationProcess will happily dereference this pointer
				if (ProcessInformation == NULL)
				{
					return STATUS_ACCESS_VIOLATION;
				}

				PPROCESS_HANDLE_TRACING_ENABLE_EX phtEx = (PPROCESS_HANDLE_TRACING_ENABLE_EX)ProcessInformation;
				if (phtEx->Flags != 0)
				{
					return STATUS_INVALID_PARAMETER;
				}
			}

			IsProcessHandleTracingEnabled = enable;
			return STATUS_SUCCESS;
		}
    }
    return HookDllData.dNtSetInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength);
}

NTSTATUS NTAPI HookedNtQueryObject(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength)
{
    NTSTATUS ntStat = HookDllData.dNtQueryObject(Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength, ReturnLength);

    if ((ObjectInformationClass == ObjectTypesInformation ||
        ObjectInformationClass == ObjectTypeInformation) &&
        (NT_SUCCESS(ntStat) && ObjectInformation))
    {
        if (ObjectInformationClass == ObjectTypesInformation)
        {
            BACKUP_RETURNLENGTH();

            FilterObjects((POBJECT_TYPES_INFORMATION)ObjectInformation);

            RESTORE_RETURNLENGTH();
        }
        else if (ObjectInformationClass == ObjectTypeInformation)
        {
            BACKUP_RETURNLENGTH();

            FilterObject((POBJECT_TYPE_INFORMATION)ObjectInformation, false);

            RESTORE_RETURNLENGTH();
        }
    }

    return ntStat;
}

NTSTATUS NTAPI HookedNtYieldExecution()
{
    HookDllData.dNtYieldExecution();
    return STATUS_ACCESS_DENIED; //better than STATUS_SUCCESS or STATUS_NO_YIELD_PERFORMED
}

NTSTATUS NTAPI HookedNtGetContextThread(HANDLE ThreadHandle, PCONTEXT ThreadContext)
{
    DWORD ContextBackup = 0;
    BOOLEAN DebugRegistersRequested = FALSE;
    if (ThreadHandle == NtCurrentThread ||
		HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess) == GetProcessIdByThreadHandle(ThreadHandle)) //thread inside this process?
    {
        if (ThreadContext)
        {
            ContextBackup = ThreadContext->ContextFlags;
            ThreadContext->ContextFlags &= ~CONTEXT_DEBUG_REGISTERS;
            DebugRegistersRequested = ThreadContext->ContextFlags != ContextBackup;
        }
    }

    NTSTATUS ntStat = HookDllData.dNtGetContextThread(ThreadHandle, ThreadContext);

    if (ContextBackup)
    {
        ThreadContext->ContextFlags = ContextBackup;
        if (DebugRegistersRequested)
        {
            ThreadContext->Dr0 = 0;
            ThreadContext->Dr1 = 0;
            ThreadContext->Dr2 = 0;
            ThreadContext->Dr3 = 0;
            ThreadContext->Dr6 = 0;
            ThreadContext->Dr7 = 0;
#ifdef _WIN64
            ThreadContext->LastBranchToRip = 0;
            ThreadContext->LastBranchFromRip = 0;
            ThreadContext->LastExceptionToRip = 0;
            ThreadContext->LastExceptionFromRip = 0;
#endif
        }
    }
    return ntStat;
}

NTSTATUS NTAPI HookedNtSetContextThread(HANDLE ThreadHandle, PCONTEXT ThreadContext)
{
    DWORD ContextBackup = 0;
    if (ThreadHandle == NtCurrentThread ||
		HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess) == GetProcessIdByThreadHandle(ThreadHandle)) //thread inside this process?
    {
        if (ThreadContext)
        {
            ContextBackup = ThreadContext->ContextFlags;
            ThreadContext->ContextFlags &= ~CONTEXT_DEBUG_REGISTERS;
        }
    }

    NTSTATUS ntStat = HookDllData.dNtSetContextThread(ThreadHandle, ThreadContext);

    if (ContextBackup)
    {
        ThreadContext->ContextFlags = ContextBackup;
    }

    return ntStat;
}

void NTAPI HandleKiUserExceptionDispatcher(PEXCEPTION_RECORD pExcptRec, PCONTEXT ContextFrame)
{
    if (ContextFrame && (ContextFrame->ContextFlags & CONTEXT_DEBUG_REGISTERS))
    {
        int slotIndex = ThreadDebugContextFindFreeSlotIndex();
        if (slotIndex != -1)
        {
            ThreadDebugContextSaveContext(slotIndex, ContextFrame);
        }

        ContextFrame->Dr0 = 0;
        ContextFrame->Dr1 = 0;
        ContextFrame->Dr2 = 0;
        ContextFrame->Dr3 = 0;
        ContextFrame->Dr6 = 0;
        ContextFrame->Dr7 = 0;
    }
}
#ifdef _WIN64
void NTAPI HookedKiUserExceptionDispatcher()
{
    // inline assembly is not supported in x86_64 with CL.  a more elegant
    // way to do this would be to modify the project to include an .asm
    // source file that defines 'HookedKiUserExceptionDispatcher' for both
    // 32 and 64 bit.
    // the + 8 in the line below is because we arrive at this function via
    // a CALL instruction which causes the stack to shift.  This CALL in
    // the trampoline is necessary because HandleKiUserExceptionDispatcher
    // will end in a RET instruction, and the CALL preserves the stack.
    PCONTEXT ContextFrame = (PCONTEXT)(((UINT_PTR)_AddressOfReturnAddress()) + 8);

    HandleKiUserExceptionDispatcher(nullptr, ContextFrame);
}
#else
VOID NAKED NTAPI HookedKiUserExceptionDispatcher()// (PEXCEPTION_RECORD pExcptRec, PCONTEXT ContextFrame) //remove DRx Registers
{
    //MOV ECX,DWORD PTR SS:[ESP+4] <- ContextFrame
    //MOV EBX,DWORD PTR SS:[ESP] <- pExcptRec
    __asm
    {
        MOV EAX, [ESP + 4]
        MOV ECX, [ESP]
        PUSH EAX
        PUSH ECX
        CALL HandleKiUserExceptionDispatcher
        jmp HookDllData.dKiUserExceptionDispatcher
    }

    //return HookDllData.dKiUserExceptionDispatcher(pExcptRec, ContextFrame);
}
#endif

static DWORD_PTR KiUserExceptionDispatcherAddress = 0;

NTSTATUS NTAPI HookedNtContinue(PCONTEXT ThreadContext, BOOLEAN RaiseAlert) //restore DRx Registers
{
    DWORD_PTR retAddress = (DWORD_PTR)_ReturnAddress();
    if (!KiUserExceptionDispatcherAddress)
    {
        UNICODE_STRING NtdllName = RTL_CONSTANT_STRING(L"ntdll.dll");
        PVOID Ntdll;
        if (NT_SUCCESS(LdrGetDllHandle(nullptr, nullptr, &NtdllName, &Ntdll)))
        {
            ANSI_STRING KiUserExceptionDispatcherName = RTL_CONSTANT_ANSI_STRING("KiUserExceptionDispatcher");
            LdrGetProcedureAddress(Ntdll, &KiUserExceptionDispatcherName, 0, (PVOID*)&KiUserExceptionDispatcherAddress);
        }
    }

    if (ThreadContext != nullptr &&
        retAddress >= KiUserExceptionDispatcherAddress && retAddress < (KiUserExceptionDispatcherAddress + 0x100))
    {
        int index = ThreadDebugContextFindExistingSlotIndex();
        if (index != -1)
        {
            ThreadContext->Dr0 = ArrayDebugRegister[index].Dr0;
            ThreadContext->Dr1 = ArrayDebugRegister[index].Dr1;
            ThreadContext->Dr2 = ArrayDebugRegister[index].Dr2;
            ThreadContext->Dr3 = ArrayDebugRegister[index].Dr3;
            ThreadContext->Dr6 = ArrayDebugRegister[index].Dr6;
            ThreadContext->Dr7 = ArrayDebugRegister[index].Dr7;
            ThreadDebugContextRemoveEntry(index);
        }
    }

    return HookDllData.dNtContinue(ThreadContext, RaiseAlert);
}

#ifndef _WIN64
PVOID NTAPI HandleNativeCallInternal(DWORD eaxValue, DWORD ecxValue)
{
    for (ULONG i = 0; i < _countof(HookDllData.HookNative); i++)
    {
        if (HookDllData.HookNative[i].eaxValue == eaxValue)
        {
            if (HookDllData.HookNative[i].ecxValue)
            {
                if (HookDllData.HookNative[i].ecxValue == ecxValue)
                {
                    return HookDllData.HookNative[i].hookedFunction;
                }
            }
            else
            {
                return HookDllData.HookNative[i].hookedFunction;
            }
        }
    }

    return 0;
}
#endif

void NAKED NTAPI HookedNativeCallInternal()
{
#ifndef _WIN64
    __asm
    {
        PUSHAD
        PUSH ECX
        PUSH EAX
        CALL HandleNativeCallInternal
        cmp eax, 0
        je NoHook
        POPAD
        ADD ESP,4
        PUSH ECX
        PUSH EAX
        CALL HandleNativeCallInternal
        jmp eax
        NoHook:
        POPAD
        jmp HookDllData.NativeCallContinue
    }
#endif
}

NTSTATUS NTAPI HookedNtClose(HANDLE Handle)
{
    OBJECT_HANDLE_FLAG_INFORMATION flags;
    NTSTATUS Status;
    if (HookDllData.dNtQueryObject != nullptr)
        Status = HookDllData.dNtQueryObject(Handle, ObjectHandleFlagInformation, &flags, sizeof(OBJECT_HANDLE_FLAG_INFORMATION), nullptr);
    else
        Status = NtQueryObject(Handle, ObjectHandleFlagInformation, &flags, sizeof(OBJECT_HANDLE_FLAG_INFORMATION), nullptr);

    if (NT_SUCCESS(Status))
    {
        if (flags.ProtectFromClose)
        {
            return STATUS_HANDLE_NOT_CLOSABLE;
        }

        return HookDllData.dNtClose(Handle);
    }

    return STATUS_INVALID_HANDLE;
}

NTSTATUS NTAPI HookedNtDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options)
{
	if (Options & DUPLICATE_CLOSE_SOURCE)
	{
		// If a process is being debugged and duplicates a handle with DUPLICATE_CLOSE_SOURCE, *and* the handle has the ProtectFromClose bit set, a STATUS_HANDLE_NOT_CLOSABLE exception will occur.
		// This is actually the exact same exception we already check for in NtClose, but the difference is that this NtClose call happens inside the kernel which we obviously can't hook.
		// When a process is not being debugged, NtDuplicateObject will simply return success without closing the source. This is because ObDuplicateObject ignores NtClose return values
		OBJECT_HANDLE_FLAG_INFORMATION HandleFlags;
		NTSTATUS Status;
		if (HookDllData.dNtQueryObject != nullptr)
			Status = HookDllData.dNtQueryObject(SourceHandle, ObjectHandleFlagInformation, &HandleFlags, sizeof(HandleFlags), nullptr);
		else
			Status = NtQueryObject(SourceHandle, ObjectHandleFlagInformation, &HandleFlags, sizeof(HandleFlags), nullptr);

		if (NT_SUCCESS(Status) && HandleFlags.ProtectFromClose)
		{
			// Prevent the exception
			Options &= ~DUPLICATE_CLOSE_SOURCE;
		}
	}

	return HookDllData.dNtDuplicateObject(SourceProcessHandle, SourceHandle, TargetProcessHandle, TargetHandle, DesiredAccess, HandleAttributes, Options);
}

//////////////////////////////////////////////////////////////
////////////////////// TIME FUNCTIONS ////////////////////////
//////////////////////////////////////////////////////////////

static DWORD OneTickCount = 0;

DWORD WINAPI HookedGetTickCount(void)
{
    if (!OneTickCount)
    {
        OneTickCount = HookDllData.dGetTickCount();
    }
    else
    {
        OneTickCount++;
    }
    return OneTickCount;
}

ULONGLONG WINAPI HookedGetTickCount64(void) //yes we can use DWORD
{
	if (!OneTickCount)
	{
		if (HookDllData.dGetTickCount)
		{
			OneTickCount = HookDllData.dGetTickCount();
		}
		else
		{
			OneTickCount = RtlGetTickCount();
		}
	}
	else
	{
		OneTickCount++;
	}
	return OneTickCount;
}

static SYSTEMTIME OneLocalTime = {0};
static SYSTEMTIME OneSystemTime = {0};

void WINAPI HookedGetLocalTime(LPSYSTEMTIME lpSystemTime)
{
	if (!OneLocalTime.wYear)
	{
		RealGetLocalTime(&OneLocalTime);

		if (HookDllData.dGetSystemTime)
		{
			RealGetSystemTime(&OneSystemTime);
		}
	}
	else
	{
		IncreaseSystemTime(&OneLocalTime);

		if (HookDllData.dGetSystemTime)
		{
			IncreaseSystemTime(&OneSystemTime);
		}
	}

	if (lpSystemTime)
	{
		memcpy(lpSystemTime, &OneLocalTime, sizeof(SYSTEMTIME));
	}
}

void WINAPI HookedGetSystemTime(LPSYSTEMTIME lpSystemTime)
{
	if (!OneSystemTime.wYear)
	{
		RealGetSystemTime(&OneSystemTime);

		if (HookDllData.dGetLocalTime)
		{
			RealGetLocalTime(&OneLocalTime);
		}
	}
	else
	{
		IncreaseSystemTime(&OneSystemTime);

		if (HookDllData.dGetLocalTime)
		{
			IncreaseSystemTime(&OneLocalTime);
		}
	}

	if (lpSystemTime)
	{
		memcpy(lpSystemTime, &OneSystemTime, sizeof(SYSTEMTIME));
	}
}

static LARGE_INTEGER OneNativeSysTime = {0};

NTSTATUS WINAPI HookedNtQuerySystemTime(PLARGE_INTEGER SystemTime)
{
	if (!OneNativeSysTime.QuadPart)
	{
		HookDllData.dNtQuerySystemTime(&OneNativeSysTime);
	}
	else
	{
		OneNativeSysTime.QuadPart++;
	}

	NTSTATUS ntStat = HookDllData.dNtQuerySystemTime(SystemTime);

	if (ntStat == STATUS_SUCCESS)
	{
		if (SystemTime)
		{
			SystemTime->QuadPart = OneNativeSysTime.QuadPart;
		}
	}

	return ntStat;
}

static LARGE_INTEGER OnePerformanceCounter = {0};
static LARGE_INTEGER OnePerformanceFrequency = {0};

NTSTATUS NTAPI HookedNtQueryPerformanceCounter(PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency)
{
	if (!OnePerformanceCounter.QuadPart)
	{
		HookDllData.dNtQueryPerformanceCounter(&OnePerformanceCounter, &OnePerformanceFrequency);
	}
	else
	{
		OnePerformanceCounter.QuadPart++;
	}

	NTSTATUS ntStat = HookDllData.dNtQueryPerformanceCounter(PerformanceCounter, PerformanceFrequency);

	if (ntStat == STATUS_SUCCESS)
	{
		if (PerformanceFrequency) //OPTIONAL
		{
			PerformanceFrequency->QuadPart = OnePerformanceFrequency.QuadPart;
		}

		if (PerformanceCounter)
		{
			PerformanceCounter->QuadPart = OnePerformanceCounter.QuadPart;
		}
	}

	return ntStat;
}

//////////////////////////////////////////////////////////////
////////////////////// TIME FUNCTIONS ////////////////////////
//////////////////////////////////////////////////////////////


static BOOL isBlocked = FALSE;

BOOL NTAPI HookedNtUserBlockInput(BOOL fBlockIt)
{
    if (isBlocked == FALSE && fBlockIt != FALSE)
    {
        isBlocked = TRUE;
        return TRUE;
    }
    else if (isBlocked != FALSE && fBlockIt == FALSE)
    {
        isBlocked = FALSE;
        return TRUE;
    }

    return FALSE;
}

//GetLastError() function might not change if a  debugger is present (it has never been the case that it is always set to zero).
DWORD WINAPI HookedOutputDebugStringA(LPCSTR lpOutputString) //Worst anti-debug ever
{
    if (RtlNtMajorVersion() >= 6) // Vista or later
        return 0;

    NtCurrentTeb()->LastErrorValue = NtCurrentTeb()->LastErrorValue + 1; //change last error
    return 1; //WinXP EAX -> 1
}

HWND NTAPI HookedNtUserFindWindowEx(HWND hWndParent, HWND hWndChildAfter, PUNICODE_STRING lpszClass, PUNICODE_STRING lpszWindow, DWORD dwType)
{
    HWND resultHwnd = HookDllData.dNtUserFindWindowEx(hWndParent, hWndChildAfter, lpszClass, lpszWindow, dwType);
    if (resultHwnd)
    {
        if (IsWindowClassNameBad(lpszClass) || IsWindowNameBad(lpszWindow))
        {
            return 0;
        }

		if (HookDllData.EnableProtectProcessId == TRUE)
		{
			DWORD dwProcessId;
			if (HookDllData.dNtUserQueryWindow)
			{
				dwProcessId = HandleToULong(HookDllData.dNtUserQueryWindow(resultHwnd, WindowProcess));
			}
			else
			{
				dwProcessId = HandleToULong(HookDllData.NtUserQueryWindow(resultHwnd, WindowProcess));
			}

			if (dwProcessId == HookDllData.dwProtectedProcessId)
			{
				return 0;
			}
		}
    }
    return resultHwnd;
}

NTSTATUS NTAPI HookedNtSetDebugFilterState(ULONG ComponentId, ULONG Level, BOOLEAN State)
{
    return HasDebugPrivileges(NtCurrentProcess) ? STATUS_SUCCESS : STATUS_ACCESS_DENIED;
}

void FilterHwndList(HWND * phwndFirst, PULONG pcHwndNeeded)
{
    for (UINT i = 0; i < *pcHwndNeeded; i++)
    {
        if (phwndFirst[i] != nullptr && IsWindowBad(phwndFirst[i]))
        {
            if (i == 0)
            {
                // Find the first HWND that belongs to a different process (i + 1, i + 2... may still be ours)
                for (UINT j = i + 1; j < *pcHwndNeeded; j++)
                {
                    if (phwndFirst[j] != nullptr && !IsWindowBad(phwndFirst[j]))
                    {
                        phwndFirst[i] = phwndFirst[j];
                        break;
                    }
                }
            }
            else
            {
                phwndFirst[i] = phwndFirst[i - 1]; //just override with previous
            }
        }
    }
}

NTSTATUS NTAPI HookedNtUserBuildHwndList(HDESK hDesktop, HWND hwndParent, BOOLEAN bChildren, ULONG dwThreadId, ULONG lParam, HWND* pWnd, PULONG pBufSize)
{
    NTSTATUS ntStat = HookDllData.dNtUserBuildHwndList(hDesktop, hwndParent, bChildren, dwThreadId, lParam, pWnd, pBufSize);

    if (NT_SUCCESS(ntStat) && pWnd != nullptr && pBufSize != nullptr)
    {
        FilterHwndList(pWnd, pBufSize);
    }

    return ntStat;
}

NTSTATUS NTAPI HookedNtUserBuildHwndList_Eight(HDESK hDesktop, HWND hwndParent, BOOLEAN bChildren, BOOLEAN bUnknownFlag, ULONG dwThreadId, ULONG lParam, HWND* pWnd, PULONG pBufSize)
{
    NTSTATUS ntStat = ((t_NtUserBuildHwndList_Eight)HookDllData.dNtUserBuildHwndList)(hDesktop, hwndParent, bChildren, bUnknownFlag, dwThreadId, lParam, pWnd, pBufSize);

    if (NT_SUCCESS(ntStat) && pWnd != nullptr && pBufSize != nullptr)
    {
        FilterHwndList(pWnd, pBufSize);
    }

    return ntStat;
}

HANDLE NTAPI HookedNtUserQueryWindow(HWND hwnd, WINDOWINFOCLASS WindowInfo)
{
	if ((WindowInfo == WindowProcess || WindowInfo == WindowThread) && IsWindowBad(hwnd))
	{
		if (WindowInfo == WindowProcess)
			return NtCurrentTeb()->ClientId.UniqueProcess;
		if (WindowInfo == WindowThread)
			return NtCurrentTeb()->ClientId.UniqueThread;
	}
	return HookDllData.dNtUserQueryWindow(hwnd, WindowInfo);
}

HWND NTAPI HookedNtUserGetForegroundWindow()
{
	HWND Hwnd = HookDllData.dNtUserGetForegroundWindow();
	if (Hwnd != nullptr && IsWindowBad(Hwnd))
	{
		Hwnd = (HWND)HookDllData.NtUserGetThreadState(THREADSTATE_ACTIVEWINDOW);
	}
	return Hwnd;
}

//WIN XP: CreateThread -> CreateRemoteThread -> NtCreateThread
NTSTATUS NTAPI HookedNtCreateThread(PHANDLE ThreadHandle,ACCESS_MASK DesiredAccess,POBJECT_ATTRIBUTES ObjectAttributes,HANDLE ProcessHandle,PCLIENT_ID ClientId,PCONTEXT ThreadContext,PINITIAL_TEB InitialTeb,BOOLEAN CreateSuspended)
{
    if (ProcessHandle == NtCurrentProcess)
    {
        return STATUS_INSUFFICIENT_RESOURCES;//STATUS_INVALID_PARAMETER STATUS_INVALID_HANDLE STATUS_INSUFFICIENT_RESOURCES
    }
    return HookDllData.dNtCreateThread(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId,ThreadContext, InitialTeb,CreateSuspended);
}

//WIN 7: CreateThread -> CreateRemoteThreadEx -> NtCreateThreadEx
NTSTATUS NTAPI HookedNtCreateThreadEx(PHANDLE ThreadHandle,ACCESS_MASK DesiredAccess,POBJECT_ATTRIBUTES ObjectAttributes,HANDLE ProcessHandle,PUSER_THREAD_START_ROUTINE StartRoutine,PVOID Argument,ULONG CreateFlags,ULONG_PTR ZeroBits,SIZE_T StackSize,SIZE_T MaximumStackSize,PPS_ATTRIBUTE_LIST AttributeList)
{
    if (HookDllData.EnableNtCreateThreadExHook == TRUE) //prevent hide from debugger
    {
        if (CreateFlags & THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER)
        {
            CreateFlags ^= THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER;
        }
    }

    if (HookDllData.EnablePreventThreadCreation == TRUE)
    {
        if (ProcessHandle == NtCurrentProcess)
        {
            return STATUS_INSUFFICIENT_RESOURCES;//STATUS_INVALID_PARAMETER STATUS_INVALID_HANDLE STATUS_INSUFFICIENT_RESOURCES
        }
    }

    return HookDllData.dNtCreateThreadEx(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize,AttributeList);
}

void FilterHandleInfo(PSYSTEM_HANDLE_INFORMATION pHandleInfo, PULONG pReturnLengthAdjust)
{
    *pReturnLengthAdjust = 0;
    const ULONG TrueCount = pHandleInfo->NumberOfHandles;
    for (ULONG i = 0; i < TrueCount; ++i)
    {
        // TODO: protect processes by name too
        if ((HookDllData.EnableProtectProcessId == TRUE && (ULONG)(pHandleInfo->Handles[i].UniqueProcessId == HookDllData.dwProtectedProcessId)) &&
            IsObjectTypeBad(pHandleInfo->Handles[i].ObjectTypeIndex))
        {
            pHandleInfo->NumberOfHandles--;
            *pReturnLengthAdjust += sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO);
            for (ULONG j = i; j < TrueCount - 1; ++j)
            {
                pHandleInfo->Handles[j] = pHandleInfo->Handles[j + 1];
                RtlZeroMemory(&pHandleInfo->Handles[j + 1], sizeof(pHandleInfo->Handles[j + 1]));
            }
            i--;
        }
    }
}

void FilterHandleInfoEx(PSYSTEM_HANDLE_INFORMATION_EX pHandleInfoEx, PULONG pReturnLengthAdjust)
{
    *pReturnLengthAdjust = 0;
    const ULONG TrueCount = (ULONG)pHandleInfoEx->NumberOfHandles;
    for (ULONG i = 0; i < TrueCount; ++i)
    {
        // TODO: protect processes by name too
        if ((HookDllData.EnableProtectProcessId == TRUE && (ULONG)(pHandleInfoEx->Handles[i].UniqueProcessId == HookDllData.dwProtectedProcessId)) &&
            IsObjectTypeBad(pHandleInfoEx->Handles[i].ObjectTypeIndex))
        {
            pHandleInfoEx->NumberOfHandles--;
            *pReturnLengthAdjust += sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX);
            for (ULONG j = i; j < TrueCount - 1; ++j)
            {
                pHandleInfoEx->Handles[j] = pHandleInfoEx->Handles[j + 1];
                RtlZeroMemory(&pHandleInfoEx->Handles[j + 1], sizeof(pHandleInfoEx->Handles[j + 1]));
            }
            i--;
        }
    }
}

void FilterObjects(POBJECT_TYPES_INFORMATION pObjectTypes)
{
    POBJECT_TYPE_INFORMATION pObject = pObjectTypes->TypeInformation;
    for (ULONG i = 0; i < pObjectTypes->NumberOfTypes; i++)
    {
        FilterObject(pObject, true);

        pObject = (POBJECT_TYPE_INFORMATION)(((PCHAR)(pObject + 1) + ALIGN_UP(pObject->TypeName.MaximumLength, ULONG_PTR)));
    }
}

void FilterObject(POBJECT_TYPE_INFORMATION pObject, bool zeroTotal)
{
    UNICODE_STRING debugObjectName = RTL_CONSTANT_STRING(L"DebugObject");
    if (RtlEqualUnicodeString(&debugObjectName, &pObject->TypeName, FALSE))
    {
        // Subtract just one from both counts for our debugger, unless the query was a generic one for all object types
        pObject->TotalNumberOfObjects = zeroTotal || pObject->TotalNumberOfObjects == 0 ? 0 : pObject->TotalNumberOfObjects - 1;
        pObject->TotalNumberOfHandles = zeroTotal || pObject->TotalNumberOfHandles == 0 ? 0 : pObject->TotalNumberOfHandles - 1;
    }
}

void FakeCurrentParentProcessId(PSYSTEM_PROCESS_INFORMATION pInfo)
{
    while (true)
    {
        if (pInfo->UniqueProcessId == NtCurrentTeb()->ClientId.UniqueProcess)
        {
            pInfo->InheritedFromUniqueProcessId = ULongToHandle(GetExplorerProcessId());
            break;
        }

        if (pInfo->NextEntryOffset == 0)
            break;

        pInfo = (PSYSTEM_PROCESS_INFORMATION)((DWORD_PTR)pInfo + pInfo->NextEntryOffset);
    }
}

void FakeCurrentOtherOperationCount(PSYSTEM_PROCESS_INFORMATION pInfo)
{
    while (true)
    {
        if (pInfo->UniqueProcessId == NtCurrentTeb()->ClientId.UniqueProcess)
        {
            LARGE_INTEGER one;
            one.QuadPart = 1;
            pInfo->OtherOperationCount = one;
            break;
        }

        if (pInfo->NextEntryOffset == 0)
            break;

        pInfo = (PSYSTEM_PROCESS_INFORMATION)((DWORD_PTR)pInfo + pInfo->NextEntryOffset);
    }
}

void FilterProcess(PSYSTEM_PROCESS_INFORMATION pInfo)
{
    PSYSTEM_PROCESS_INFORMATION pPrev = pInfo;

    while (TRUE)
    {
        if (IsProcessNameBad(&pInfo->ImageName) || ((HookDllData.EnableProtectProcessId == TRUE) && (HandleToULong(pInfo->UniqueProcessId) == HookDllData.dwProtectedProcessId)))
        {
            if (pInfo->ImageName.Buffer)
                ZeroMemory(pInfo->ImageName.Buffer, pInfo->ImageName.Length);

            if (pInfo->NextEntryOffset == 0) //last element
            {
                pPrev->NextEntryOffset = 0;
            }
            else
            {
                pPrev->NextEntryOffset += pInfo->NextEntryOffset;
            }
        }
        else
        {
            pPrev = pInfo;
        }

        if (pInfo->NextEntryOffset == 0)
        {
            break;
        }
        else
        {
            pInfo = (PSYSTEM_PROCESS_INFORMATION)((DWORD_PTR)pInfo + pInfo->NextEntryOffset);
        }
    }
}

NTSTATUS NTAPI HookedNtResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount)
{
	DWORD dwProcessId = GetProcessIdByThreadHandle(ThreadHandle);
	if (dwProcessId != HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess)) //malware starts the thread of another process
	{
		DumpMalware(dwProcessId);
		TerminateProcessByProcessId(dwProcessId); //terminate it
		DbgPrint((PCH)"Malware called ResumeThread");
		DbgBreakPoint();
		return STATUS_SUCCESS;
	}
	else
	{
		return HookDllData.dNtResumeThread(ThreadHandle, PreviousSuspendCount);
	}
}

HANDLE hNtdllFile = INVALID_HANDLE_VALUE;
HANDLE hNtdllSection = INVALID_HANDLE_VALUE;

NTSTATUS NTAPI HookedNtOpenFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions)
{
    NTSTATUS status = HookDllData.dNtOpenFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions);

    if (NT_SUCCESS(status))
    {
        UNICODE_STRING usNtdll;
        RtlInitUnicodeString(&usNtdll, L"\\ntdll.dll");
        if (RtlUnicodeStringContains(ObjectAttributes->ObjectName, &usNtdll, TRUE))
        {
            hNtdllFile = *FileHandle;
        }
    }

    return status;
}

NTSTATUS NTAPI HookedNtCreateSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle)
{
    if (AllocationAttributes == SEC_IMAGE_NO_EXECUTE && RtlNtMajorVersion() <= 6 && (RtlNtMajorVersion() < 6 || RtlNtMinorVersion() < 2))
    {
        // Fix for VMProtect. It attempts to use SEC_IMAGE_NO_EXECUTE on OSes that don't support it.
        AllocationAttributes = SEC_IMAGE;
    }
    NTSTATUS status = HookDllData.dNtCreateSection(SectionHandle, DesiredAccess, ObjectAttributes, MaximumSize, SectionPageProtection, AllocationAttributes, FileHandle);

    if (NT_SUCCESS(status) && hNtdllFile != INVALID_HANDLE_VALUE && FileHandle == hNtdllFile)
    {
        hNtdllFile = INVALID_HANDLE_VALUE;
        hNtdllSection = *SectionHandle;
    }

    return status;
}

void DestroyMappedNtApi(const char *szProcName, PVOID hRealNtdll, PVOID pMapping)
{
    PVOID ProcedureAddress;
    ANSI_STRING ProcedureName;
    RtlInitAnsiString(&ProcedureName, (PSTR)szProcName);
    if (NT_SUCCESS(LdrGetProcedureAddress(hRealNtdll, &ProcedureName, 0, &ProcedureAddress)))
    {
        SIZE_T delta = (ULONG_PTR)ProcedureAddress - (ULONG_PTR)hRealNtdll;
        PUCHAR pMappedApi = (PUCHAR)pMapping + delta;

#ifdef _WIN64
        if (*(PDWORD)pMappedApi != 0xB8D18B4C) // mov r10,rcx; mov eax, callNr
            return;

        PVOID ProtAddress = pMappedApi;
        SIZE_T RegionSize = 5;
        ULONG OldProtect;
        if (NT_SUCCESS(NtProtectVirtualMemory(NtCurrentProcess, &ProtAddress, &RegionSize, PAGE_READWRITE, &OldProtect)))
        {
            *(PWORD)pMappedApi = 0x0B0F; // UD2
            *(PWORD)(pMappedApi + 3) = 0x0B0F; // UD2
            NtProtectVirtualMemory(NtCurrentProcess, &ProtAddress, &RegionSize, OldProtect, &OldProtect);
        }
#else
        if (*pMappedApi != 0xB8) // mov eax, callNr
            return;

        PVOID ProtAddress = pMappedApi;
        SIZE_T RegionSize = 2;
        ULONG OldProtect;
        if (NT_SUCCESS(NtProtectVirtualMemory(NtCurrentProcess, &ProtAddress, &RegionSize, PAGE_READWRITE, &OldProtect)))
        {
            *(PWORD)pMappedApi = 0x0B0F; // UD2
            NtProtectVirtualMemory(NtCurrentProcess, &ProtAddress, &RegionSize, OldProtect, &OldProtect);
        }
#endif
    }
}

NTSTATUS NTAPI HookedNtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Win32Protect)
{
    NTSTATUS status = HookDllData.dNtMapViewOfSection(SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect);

    if (NT_SUCCESS(status) && ProcessHandle == NtCurrentProcess && hNtdllSection != INVALID_HANDLE_VALUE && SectionHandle == hNtdllSection)
    {
        hNtdllSection = INVALID_HANDLE_VALUE;
        ApplyNtdllVersionPatch(ProcessHandle, *BaseAddress);

        // Prevent syscall numbers from being extracted from API code.
        PVOID hRealNtdll;
        UNICODE_STRING usNtdll;
        RtlInitUnicodeString(&usNtdll, L"ntdll.dll");
        if (NT_SUCCESS(LdrGetDllHandle(NULL, NULL, &usNtdll, &hRealNtdll)))
        {
            DestroyMappedNtApi("NtSetInformationProcess", hRealNtdll, *BaseAddress); // If VMProtect can syscall this, it will unset the instrumentation callback.
            DestroyMappedNtApi("NtQueryInformationProcess", hRealNtdll, *BaseAddress);
            DestroyMappedNtApi("NtSetInformationThread", hRealNtdll, *BaseAddress);
            DestroyMappedNtApi("NtQueryInformationThread", hRealNtdll, *BaseAddress);
            DestroyMappedNtApi("NtQuerySystemInformation", hRealNtdll, *BaseAddress);
            DestroyMappedNtApi("NtQueryVirtualMemory", hRealNtdll, *BaseAddress);
        }
    }

    return status;
}



================================================
File: HookLibrary/HookedFunctions.h
================================================
#pragma once

#include <ntdll/ntdll.h>


#define STATUS_PRIVILEGE_NOT_HELD ((NTSTATUS)0xC0000061L)
#define STATUS_PORT_NOT_SET ((NTSTATUS)0xC0000353L)
#define STATUS_HANDLE_NOT_CLOSABLE ((NTSTATUS)0xC0000235L)
#define STATUS_INSUFFICIENT_RESOURCES ((NTSTATUS)0xC000009AL)
#define PROCESS_DEBUG_INHERIT 0x00000001 // default for a non-debugged process
#define PROCESS_NO_DEBUG_INHERIT 0x00000002 // default for a debugged process
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004

#ifndef _WIN64
#define NAKED __declspec(naked)
#else
#define NAKED
#endif

typedef struct _SAVE_DEBUG_REGISTERS
{
    DWORD dwThreadId;
    DWORD_PTR Dr0;
    DWORD_PTR Dr1;
    DWORD_PTR Dr2;
    DWORD_PTR Dr3;
    DWORD_PTR Dr6;
    DWORD_PTR Dr7;
} SAVE_DEBUG_REGISTERS;

//DbgBreakPoint

NTSTATUS NTAPI HookedNtSetInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);
NTSTATUS NTAPI HookedNtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtQueryObject(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI HookedNtYieldExecution();
NTSTATUS NTAPI HookedNtGetContextThread(HANDLE ThreadHandle, PCONTEXT ThreadContext);
NTSTATUS NTAPI HookedNtSetContextThread(HANDLE ThreadHandle, PCONTEXT ThreadContext);
NTSTATUS NTAPI HookedNtContinue(PCONTEXT ThreadContext, BOOLEAN RaiseAlert);
NTSTATUS NTAPI HookedNtSetInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);
NTSTATUS NTAPI HookedNtClose(HANDLE Handle);
NTSTATUS NTAPI HookedNtDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG HandleAttributes, ULONG Options);
NTSTATUS NTAPI HookedNtSetDebugFilterState(ULONG ComponentId, ULONG Level, BOOLEAN State);
NTSTATUS NTAPI HookedNtUserBuildHwndList(HDESK hDesktop, HWND hwndParent, BOOLEAN bChildren, ULONG dwThreadId, ULONG lParam, HWND* pWnd, PULONG pBufSize);
NTSTATUS NTAPI HookedNtUserBuildHwndList_Eight(HDESK hDesktop, HWND hwndParent, BOOLEAN bChildren, BOOLEAN bUnknownFlag, ULONG dwThreadId, ULONG lParam, HWND* pWnd, PULONG pBufSize);
NTSTATUS NTAPI HookedNtCreateThread(PHANDLE ThreadHandle,ACCESS_MASK DesiredAccess,POBJECT_ATTRIBUTES ObjectAttributes,HANDLE ProcessHandle,PCLIENT_ID ClientId,PCONTEXT ThreadContext,PINITIAL_TEB InitialTeb,BOOLEAN CreateSuspended);
NTSTATUS NTAPI HookedNtCreateThreadEx(PHANDLE ThreadHandle,ACCESS_MASK DesiredAccess,POBJECT_ATTRIBUTES ObjectAttributes,HANDLE ProcessHandle,PUSER_THREAD_START_ROUTINE StartRoutine,PVOID Argument,ULONG CreateFlags,ULONG_PTR ZeroBits,SIZE_T StackSize,SIZE_T MaximumStackSize,PPS_ATTRIBUTE_LIST AttributeList);
HANDLE NTAPI HookedNtUserQueryWindow(HWND hwnd, WINDOWINFOCLASS WindowInfo);
HWND NTAPI HookedNtUserGetForegroundWindow();
BOOL NTAPI HookedNtUserBlockInput(BOOL fBlockIt);


DWORD WINAPI HookedGetTickCount(void);
ULONGLONG WINAPI HookedGetTickCount64(void);
void WINAPI HookedGetLocalTime(LPSYSTEMTIME lpSystemTime);
void WINAPI HookedGetSystemTime(LPSYSTEMTIME lpSystemTime);
NTSTATUS WINAPI HookedNtQuerySystemTime(PLARGE_INTEGER SystemTime);
NTSTATUS NTAPI HookedNtQueryPerformanceCounter(PLARGE_INTEGER PerformanceCounter, PLARGE_INTEGER PerformanceFrequency);

DWORD WINAPI HookedOutputDebugStringA(LPCSTR lpOutputString);
#ifdef _WIN64
void NTAPI HandleKiUserExceptionDispatcher(PEXCEPTION_RECORD pExcptRec, PCONTEXT ContextFrame);
#else
VOID NTAPI HookedKiUserExceptionDispatcher();//(PEXCEPTION_RECORD pExcptRec, PCONTEXT ContextFrame);
#endif

HWND NTAPI HookedNtUserFindWindowEx(HWND hWndParent, HWND hWndChildAfter, PUNICODE_STRING lpszClass, PUNICODE_STRING lpszWindow, DWORD dwType);

NTSTATUS NTAPI HookedNtResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount);

NTSTATUS NTAPI HookedNtOpenFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
NTSTATUS NTAPI HookedNtCreateSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection, ULONG AllocationAttributes, HANDLE FileHandle);
NTSTATUS NTAPI HookedNtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset, PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Win32Protect);



================================================
File: HookLibrary/InstrumentationCallbackX64.asm
================================================
include ksamd64.inc

extern InstrumentationCallback:near

.code
InstrumentationCallbackAsm proc

	cmp eax, 0			; STATUS_SUCCESS
	jne ReturnToCaller

	push rax ; return value
	push rcx
	push rbx
	push rbp
	push rdi
	push rsi
	push rsp
	push r10
	push r11
	push r12
	push r13
	push r14
	push r15

	sub rsp, 20h
	mov rcx, r10
	mov rdx, rax
	call InstrumentationCallback
	add rsp, 20h

	pop r15
	pop r14
	pop r13
	pop r12
	pop r11
	pop r10
	pop rsp
	pop rsi
	pop rdi
	pop rbp
	pop rbx
	pop rcx
	add rsp, 8 ; preserve new rax

ReturnToCaller:
	jmp r10

InstrumentationCallbackAsm endp

end



================================================
File: HookLibrary/InstrumentationCallbackX86.asm
================================================
include CallConv.inc
.model flat

extern _InstrumentationCallback@8:near

.code
_InstrumentationCallbackAsm proc

	cmp eax, 0			; STATUS_SUCCESS
	jne ReturnToCaller

	pushad

	push eax
	push ecx
	call _InstrumentationCallback@8
	
	pop edi
	pop esi
	pop ebp
	add esp, 4
	pop ebx
	pop edx
	pop ecx
	add esp, 4 ; preserve new eax

ReturnToCaller:
	jmp ecx

_InstrumentationCallbackAsm endp

end



================================================
File: HookLibrary/Tls.h
================================================
#pragma once

#include <ntdll/ntdll.h>

// Hackplementation of thread local storage without using the CRT or LdrpAllocateTls

static constexpr ULONG_PTR TebAllocationSize = (sizeof(TEB) + PAGE_SIZE - 1) & (~(PAGE_SIZE - 1));

#ifdef _WIN64
// On x64 we can freely write past the end of the TEB since 2 zeroed pages are allocated for it. Leave some headroom for the TEB to grow in future Windows versions
static constexpr LONG_PTR TebPadding = 0x200; // +512
#else
// On x86 and Wow64 we have a problem because sizeof(TEB) == PAGE_SIZE == TebAllocationSize, i.e. there are no spare zeroes past the end of the TEB, at least on Win 10.
// Instead abuse the SpareBytes field for this. Because (1) this field has a slightly different offset on different versions of Windows (+1AC for 7 vs +1B9 for 10),
// and (2) this field is not pointer-aligned, round the address up to pointer alignment. The offset is negative from the end since we are writing to the TEB, not past it
static constexpr LONG_PTR TebPaddingFromEnd = (static_cast<LONG_PTR>(TebAllocationSize) - FIELD_OFFSET(TEB, SpareBytes)); // 4096 - 441 = 3655
static constexpr LONG_PTR TebPadding = ((-1 * TebPaddingFromEnd) + static_cast<LONG_PTR>(alignof(PVOID)) - 1) & (~(static_cast<LONG_PTR>(alignof(PVOID)) - 1)); // ALIGN_UP(-1 * 3655, PVOID) = -3652
static_assert(TebPadding == -3652, "You touched ntdll.h didn't you?");
#endif

// To create a TLS variable, declare it here
enum class TlsVariable : ULONG_PTR
{
	InstrumentationCallbackDisabled, // The only TLS variable we currently actually use...
	MaxTlsVariable // Must be last
};

template<TlsVariable Variable>
struct TebOffset
{
	constexpr static ULONG_PTR Value = (static_cast<LONG_PTR>(sizeof(TEB)) + TebPadding) + (static_cast<ULONG_PTR>(Variable) * alignof(PVOID));
};

static_assert(TebOffset<TlsVariable::MaxTlsVariable>::Value <= TebAllocationSize - sizeof(PVOID), "TLS variable offsets exceed TEB allocation size");
static_assert(static_cast<ULONG_PTR>(TlsVariable::MaxTlsVariable) - 1 <= 5, "All out of TEB SpareBytes, find some new field to abuse"); // Only really applies to x86, but check on both

FORCEINLINE
volatile
LONG*
TlsGetInstrumentationCallbackDisabled(
	)
{
	return reinterpret_cast<volatile LONG*>(reinterpret_cast<ULONG_PTR>(NtCurrentTeb()) + TebOffset<TlsVariable::InstrumentationCallbackDisabled>::Value);
}



================================================
File: HookLibrary/hook.props
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <ItemDefinitionGroup>
    <ClCompile>
      <DebugInformationFormat>None</DebugInformationFormat>
      <Optimization>MinSpace</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntdll\ntdllp_$(PlatformShortName).lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
</Project>


================================================
File: InjectorCLI/ApplyHooking.cpp
================================================
#include <Scylla/Logger.h>
#include <Scylla/OsInfo.h>
#include <Scylla/PebHider.h>
#include "Scylla/VersionPatch.h"

#include "ApplyHooking.h"
#include "DynamicMapping.h"
#include "RemoteHook.h"

#define STR(x) #x
#define HOOK(name) { \
    hdd->d##name = (t_##name)DetourCreateRemote(hProcess, "" STR(name) "", (void*)_##name, Hooked##name, true, &hdd->name##BackupSize); \
    if (hdd->d##name == nullptr) { return false; } }
#define HOOK_NATIVE(name) { \
    hdd->d##name = (t_##name)DetourCreateRemoteNative(hProcess, "" STR(name) "", (void*)_##name, Hooked##name, true, &hdd->name##BackupSize); \
    if (hdd->d##name == nullptr) { return false; } }
#define HOOK_NATIVE_NOTRAMP(name) DetourCreateRemoteNative(hProcess, "" STR(name) "", (void*)_##name, Hooked##name, false, &hdd->name##BackupSize)
#define FREE_HOOK(name) FreeMemory(hProcess, (void*)hdd->d##name); hdd->d##name = 0
#define RESTORE_JMP(name) RestoreJumper(hProcess, (void*)_##name, (void*)hdd->d##name, hdd->name##BackupSize)

extern scl::Logger g_log;

void * HookedNativeCallInternal = 0;
void * NativeCallContinue = 0;
int countNativeHooks = 0;
HOOK_NATIVE_CALL32 * HookNative = 0;
bool onceNativeCallContinue = false;
bool fatalFindSyscallIndexFailure = false;
bool fatalAlreadyHookedFailure = false;

#ifndef _WIN64
extern BYTE KiFastSystemCallBackup[20];
extern BYTE KiFastSystemCallWow64Backup[7];
extern DWORD KiFastSystemCallAddress;
extern DWORD KiFastSystemCallWow64Address;
#endif

HMODULE hKernel = 0;
HMODULE hKernelbase = 0;
HMODULE hNtdll = 0;
HMODULE hUser = 0;

t_KiUserExceptionDispatcher _KiUserExceptionDispatcher = 0;
t_OutputDebugStringA _OutputDebugStringA = 0;
t_GetTickCount _GetTickCount = 0;
t_GetTickCount64 _GetTickCount64 = 0;
t_GetLocalTime _GetLocalTime = 0;
t_GetSystemTime _GetSystemTime = 0;

t_NtUserBlockInput _NtUserBlockInput = 0;
t_NtUserBuildHwndList _NtUserBuildHwndList = 0;
t_NtUserFindWindowEx _NtUserFindWindowEx = 0;
t_NtUserQueryWindow _NtUserQueryWindow = 0;
t_NtUserGetForegroundWindow _NtUserGetForegroundWindow = 0;

t_NtSetInformationThread _NtSetInformationThread = 0;
t_NtQuerySystemInformation _NtQuerySystemInformation = 0;
t_NtQueryInformationProcess _NtQueryInformationProcess = 0;
t_NtSetInformationProcess _NtSetInformationProcess = 0;
t_NtQueryObject _NtQueryObject = 0;
t_NtYieldExecution _NtYieldExecution = 0;
t_NtGetContextThread _NtGetContextThread = 0;
t_NtSetContextThread _NtSetContextThread = 0;
t_NtContinue _NtContinue = 0;
t_NtClose _NtClose = 0;
t_NtDuplicateObject _NtDuplicateObject = 0;
t_NtSetDebugFilterState _NtSetDebugFilterState = 0;
t_NtCreateThread _NtCreateThread = 0;
t_NtCreateThreadEx _NtCreateThreadEx = 0;
t_NtQuerySystemTime _NtQuerySystemTime = 0;
t_NtQueryPerformanceCounter _NtQueryPerformanceCounter = 0;
t_NtResumeThread _NtResumeThread = 0;
t_NtOpenFile _NtOpenFile = 0;
t_NtCreateSection _NtCreateSection = 0;
t_NtMapViewOfSection _NtMapViewOfSection = 0;

bool ApplyNtdllHook(HOOK_DLL_DATA * hdd, HANDLE hProcess, BYTE * dllMemory, DWORD_PTR imageBase)
{
    hNtdll = GetModuleHandleW(L"ntdll.dll");

#ifndef _WIN64
    countNativeHooks = 0;
    onceNativeCallContinue = false;
    HookNative = hdd->HookNative;
#endif

    void * HookedNtSetInformationThread = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtSetInformationThread") + imageBase);
    void * HookedNtQuerySystemInformation = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtQuerySystemInformation") + imageBase);
    void * HookedNtQueryInformationProcess = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtQueryInformationProcess") + imageBase);
    void * HookedNtSetInformationProcess = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtSetInformationProcess") + imageBase);
    void * HookedNtQueryObject = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtQueryObject") + imageBase);
    void * HookedNtYieldExecution = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtYieldExecution") + imageBase);
    void * HookedNtGetContextThread = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtGetContextThread") + imageBase);
    void * HookedNtSetContextThread = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtSetContextThread") + imageBase);
    void * HookedKiUserExceptionDispatcher = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedKiUserExceptionDispatcher") + imageBase);
    void * HookedNtContinue = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtContinue") + imageBase);
    void * HookedNtClose = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtClose") + imageBase);
    void * HookedNtDuplicateObject = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtDuplicateObject") + imageBase);
    void * HookedNtSetDebugFilterState = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtSetDebugFilterState") + imageBase);
    void * HookedNtCreateThread = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtCreateThread") + imageBase);
    void * HookedNtCreateThreadEx = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtCreateThreadEx") + imageBase);
    void * HookedNtQuerySystemTime = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtQuerySystemTime") + imageBase);
    void * HookedNtQueryPerformanceCounter = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtQueryPerformanceCounter") + imageBase);
    void * HookedNtResumeThread = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtResumeThread") + imageBase);
    void * HookedNtOpenFile = (void*)(GetDllFunctionAddressRVA(dllMemory, "HookedNtOpenFile") + imageBase);
    void * HookedNtCreateSection = (void*)(GetDllFunctionAddressRVA(dllMemory, "HookedNtCreateSection") + imageBase);
    void * HookedNtMapViewOfSection = (void*)(GetDllFunctionAddressRVA(dllMemory, "HookedNtMapViewOfSection") + imageBase);

    HookedNativeCallInternal = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNativeCallInternal") + imageBase);

    _NtSetInformationThread = (t_NtSetInformationThread)GetProcAddress(hNtdll, "NtSetInformationThread");
    _NtQuerySystemInformation = (t_NtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
    _NtQueryInformationProcess = (t_NtQueryInformationProcess)GetProcAddress(hNtdll, "NtQueryInformationProcess");
    _NtSetInformationProcess = (t_NtSetInformationProcess)GetProcAddress(hNtdll, "NtSetInformationProcess");
    _NtQueryObject = (t_NtQueryObject)GetProcAddress(hNtdll, "NtQueryObject");
    _NtYieldExecution = (t_NtYieldExecution)GetProcAddress(hNtdll, "NtYieldExecution");
    _NtGetContextThread = (t_NtGetContextThread)GetProcAddress(hNtdll, "NtGetContextThread");
    _NtSetContextThread = (t_NtSetContextThread)GetProcAddress(hNtdll, "NtSetContextThread");
    _KiUserExceptionDispatcher = (t_KiUserExceptionDispatcher)GetProcAddress(hNtdll, "KiUserExceptionDispatcher");
    _NtContinue = (t_NtContinue)GetProcAddress(hNtdll, "NtContinue");
    _NtClose = (t_NtClose)GetProcAddress(hNtdll, "NtClose");
    _NtDuplicateObject = (t_NtDuplicateObject)GetProcAddress(hNtdll, "NtDuplicateObject");
    _NtSetDebugFilterState = (t_NtSetDebugFilterState)GetProcAddress(hNtdll, "NtSetDebugFilterState");
    _NtCreateThread = (t_NtCreateThread)GetProcAddress(hNtdll, "NtCreateThread");
    _NtCreateThreadEx = (t_NtCreateThreadEx)GetProcAddress(hNtdll, "NtCreateThreadEx");
    _NtQuerySystemTime = (t_NtQuerySystemTime)GetProcAddress(hNtdll, "NtQuerySystemTime");
    _NtQueryPerformanceCounter = (t_NtQueryPerformanceCounter)GetProcAddress(hNtdll, "NtQueryPerformanceCounter");
    _NtResumeThread = (t_NtResumeThread)GetProcAddress(hNtdll, "NtResumeThread");
    _NtOpenFile = (t_NtOpenFile)GetProcAddress(hNtdll, "NtOpenFile");
    _NtCreateSection = (t_NtCreateSection)GetProcAddress(hNtdll, "NtCreateSection");
    _NtMapViewOfSection = (t_NtMapViewOfSection)GetProcAddress(hNtdll, "NtMapViewOfSection");

    g_log.LogDebug(L"ApplyNtdllHook -> _NtSetInformationThread %p _NtQuerySystemInformation %p _NtQueryInformationProcess %p _NtSetInformationProcess %p _NtQueryObject %p",
        _NtSetInformationThread,
        _NtQuerySystemInformation,
        _NtQueryInformationProcess,
        _NtSetInformationProcess,
        _NtQueryObject);
    g_log.LogDebug(L"ApplyNtdllHook -> _NtYieldExecution %p _NtGetContextThread %p _NtSetContextThread %p _KiUserExceptionDispatcher %p _NtContinue %p",
        _NtYieldExecution,
        _NtGetContextThread,
        _NtSetContextThread,
        _KiUserExceptionDispatcher,
        _NtContinue);
    g_log.LogDebug(L"ApplyNtdllHook -> _NtClose %p _NtDuplicateObject %p _NtSetDebugFilterState %p _NtCreateThread %p _NtCreateThreadEx %p _NtQuerySystemTime %p _NtQueryPerformanceCounter %p _NtResumeThread %p",
        _NtClose,
        _NtDuplicateObject,
        _NtSetDebugFilterState,
        _NtCreateThread,
        _NtCreateThreadEx,
        _NtQuerySystemTime,
        _NtQueryPerformanceCounter,
        _NtResumeThread);
    g_log.LogDebug(L"ApplyNtdllHook -> _NtOpenFile %p _NtCreateSection %p _NtMapViewOfSection %p",
        _NtOpenFile,
        _NtCreateSection,
        _NtMapViewOfSection);

    if (hdd->EnableNtSetInformationThreadHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtSetInformationThread");
        HOOK_NATIVE(NtSetInformationThread);
    }
    if (hdd->EnableNtQuerySystemInformationHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtQuerySystemInformation");
        HOOK_NATIVE(NtQuerySystemInformation);
    }
    if (hdd->EnableNtQueryInformationProcessHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtQueryInformationProcess");
        HOOK_NATIVE(NtQueryInformationProcess);
    }
    if (hdd->EnableNtSetInformationProcessHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtSetInformationProcess");
        HOOK_NATIVE(NtSetInformationProcess);
    }

    if (hdd->EnableNtQueryObjectHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtQueryObject");
        HOOK_NATIVE(NtQueryObject);
    }
    if (hdd->EnableNtYieldExecutionHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtYieldExecution");
        HOOK_NATIVE(NtYieldExecution);
    }
    if (hdd->EnableNtGetContextThreadHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtGetContextThread");
        HOOK_NATIVE(NtGetContextThread);
    }
    if (hdd->EnableNtSetContextThreadHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtSetContextThread");
        HOOK_NATIVE(NtSetContextThread);
    }

    if (hdd->EnableNtCloseHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtClose");
        HOOK_NATIVE(NtClose);
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtDuplicateObject");
        HOOK_NATIVE(NtDuplicateObject);
    }
    if (hdd->EnablePreventThreadCreation == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtCreateThread");
        HOOK_NATIVE(NtCreateThread);
    }

    if (((hdd->EnablePreventThreadCreation == TRUE) || (hdd->EnableNtCreateThreadExHook == TRUE)) && _NtCreateThreadEx != 0)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtCreateThreadEx");
        HOOK_NATIVE(NtCreateThreadEx);
    }

    if (hdd->EnableNtSetDebugFilterStateHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtSetDebugFilterState");
        HOOK_NATIVE_NOTRAMP(NtSetDebugFilterState);
    }

    if (hdd->EnableKiUserExceptionDispatcherHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking KiUserExceptionDispatcher");
#ifdef _WIN64
        // The x86_64 version of this function currently contains relative offset instructions
        // which will cause problems with the naive trampoline generation currently in use.
        // Therefore, let us apply some manual patching instead.
        PVOID address = (PVOID)_KiUserExceptionDispatcher;
        const bool startsWithCld = ((UINT8*)address)[0] == 0xFC; // true on Vista and later
        if ((startsWithCld && *(PUINT32)address != 0x058B48FC) ||
            (!startsWithCld && (*(PUINT32)address & 0xFFFFFF) != 0x058B48))
        {
            g_log.LogError(L"ApplyNtdllHook -> KiUserExceptionDispatcher pattern mismatch 0x%lx", *(PUINT32)address);
        }
        else
        {
            // This function currently has a nine byte NOP before it, probably for hot patching?
            // There is also some alignment space. Let's borrow this to write our trampoline.
            uint8_t trampoline[] =
            {
                0xFF, 0x15, 0x0F, 0x00, 0x00, 0x00,         // call qword ptr[+15]
                0xFC,                                       // cld
                0x48, 0x8B, 0x05, 0x22, 0xA4, 0x0D, 0x00,   // mov rax, qword ptr:[<Wow64PrepareForException>]
                0x48, 0x85, 0xC0,                           // test rax,rax
                0xEB, 0x0B                                  // jmp <next real instruction>
            };

            // Deal with XP/2003
            if (!startsWithCld)
            {
                trampoline[6] = 0x90;                       // cld -> nop
                trampoline[18] -= 0x1;                      // <next real instruction> -= 1
            }

            // update RVA of Wow64PrepareForException
            UINT32 rvaWow64PrepareForException;
            ReadProcessMemory(hProcess, (LPCVOID)(((UINT_PTR)address) + (startsWithCld ? 4 : 3)), (PVOID)&rvaWow64PrepareForException,
                sizeof(rvaWow64PrepareForException), nullptr);

            // instruction is moved up 12/13 bytes. update trampoline
            rvaWow64PrepareForException += (startsWithCld ? 13 : 12);
            memcpy(&trampoline[10], &rvaWow64PrepareForException, sizeof(rvaWow64PrepareForException));

            uint8_t hook[] =
            {
                0xEB, 0xEB,     // jmp -21
                0xFE, 0xED, 0xFA, 0xCE, 0xDE, 0xAD, 0xBE, 0xEF,
            };

            // insert hook into payload
            memcpy(&hook[2], &HookedKiUserExceptionDispatcher, sizeof(PVOID));

            // for most hooks the following fields are for the trampoline. this works for them because
            // the trampoline is an identical copy of what was at the start of the function. since this
            // is not the case for us, we must preserve the original bytes in memory we deliberately set
            // aside for this purpose.
            PVOID backup_location = VirtualAllocEx(hProcess, nullptr, sizeof(hook), MEM_COMMIT,
                PAGE_READWRITE);

            hdd->dKiUserExceptionDispatcher = (decltype(hdd->dKiUserExceptionDispatcher))(backup_location);
            hdd->KiUserExceptionDispatcherBackupSize = sizeof(hook);

            // backup start of function
            uint8_t backup_prologue[sizeof(hook)];
            ReadProcessMemory(hProcess, address, backup_prologue, sizeof(backup_prologue), nullptr);
            WriteProcessMemory(hProcess, backup_location, backup_prologue, sizeof(backup_prologue), nullptr);

            // install trampoline
            PVOID trampoline_location = (PVOID)(((UINT_PTR)address) - sizeof(trampoline));
            WriteProcessMemory(hProcess, trampoline_location, trampoline, sizeof(trampoline), nullptr);

            // install hook
            WriteProcessMemory(hProcess, address, hook, sizeof(hook), nullptr);
        }
#else
        HOOK(KiUserExceptionDispatcher);
#endif
    }
    if (hdd->EnableNtContinueHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtContinue");
        HOOK_NATIVE(NtContinue);
    }

    if (hdd->EnableNtQuerySystemTimeHook == TRUE && _NtQuerySystemTime != 0)
    {
#ifdef _WIN64
        ULONG_PTR address = (ULONG_PTR)_NtQuerySystemTime;
        if (*(PUCHAR)address == 0xE9) // jmp rel32
        {
            g_log.LogDebug(L"ApplyNtdllHook -> Finding jmp to RtlQuerySystemTime at NtQuerySystemTime");
            LONG relativeOffset = *(PLONG)(address + 1);
            _NtQuerySystemTime = (t_NtQuerySystemTime)(address + relativeOffset + 5);
        }
#endif
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtQuerySystemTime at %p", _NtQuerySystemTime);
        HOOK_NATIVE(NtQuerySystemTime);
    }
    if (hdd->EnableNtQueryPerformanceCounterHook == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtQueryPerformanceCounter");
        HOOK_NATIVE(NtQueryPerformanceCounter);
    }

    if (hdd->EnableMalwareRunPeUnpacker == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtResumeThread for RUNPE UNPACKER");
        HOOK_NATIVE(NtResumeThread);
    }

    if (hdd->EnablePebOsBuildNumber == TRUE)
    {
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtOpenFile");
        HOOK_NATIVE(NtOpenFile);
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtCreateSection");
        HOOK_NATIVE(NtCreateSection);
        g_log.LogDebug(L"ApplyNtdllHook -> Hooking NtMapViewOfSection");
        HOOK_NATIVE(NtMapViewOfSection);
    }

    hdd->isNtdllHooked = TRUE;

    return true;
}

bool ApplyKernel32Hook(HOOK_DLL_DATA * hdd, HANDLE hProcess, BYTE * dllMemory, DWORD_PTR imageBase)
{
    hKernel = GetModuleHandleW(L"kernel32.dll");
    hKernelbase = GetModuleHandleW(L"kernelbase.dll");

    if (GetModuleBaseRemote(hProcess, L"kernel32.dll") == nullptr ||
        (hKernelbase != nullptr && GetModuleBaseRemote(hProcess, L"kernelbase.dll") == nullptr))
    {
        hdd->isKernel32Hooked = FALSE;
        return true;
    }

    void * HookedOutputDebugStringA = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedOutputDebugStringA") + imageBase);
    void * HookedGetTickCount = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedGetTickCount") + imageBase);
    void * HookedGetTickCount64 = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedGetTickCount64") + imageBase);
    void * HookedGetLocalTime = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedGetLocalTime") + imageBase);
    void * HookedGetSystemTime = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedGetSystemTime") + imageBase);

    HMODULE hCurrent = hKernel;
    if (hKernelbase)
    {
        hCurrent = hKernelbase;
        g_log.LogDebug(L"ApplyKernel32Hook -> Using Kernelbase %p instead of kernel32 %p", hKernelbase, hKernel);
    }

    _GetTickCount = (t_GetTickCount)GetProcAddress(hCurrent, "GetTickCount");
    _GetTickCount64 = (t_GetTickCount64)GetProcAddress(hCurrent, "GetTickCount64");
    _GetLocalTime = (t_GetLocalTime)GetProcAddress(hCurrent, "GetLocalTime");
    _GetSystemTime = (t_GetSystemTime)GetProcAddress(hCurrent, "GetSystemTime");

    _OutputDebugStringA = (t_OutputDebugStringA)GetProcAddress(hCurrent, "OutputDebugStringA");

    g_log.LogDebug(L"ApplyKernel32Hook -> _GetTickCount %p _GetTickCount64 %p _GetLocalTime %p _GetSystemTime %p _OutputDebugStringA %p",
        _GetTickCount,
        _GetTickCount64,
        _GetLocalTime,
        _GetSystemTime,
        _OutputDebugStringA);

    if (hdd->EnableGetTickCountHook == TRUE)
    {
        g_log.LogDebug(L"ApplyKernel32Hook -> Hooking GetTickCount");
        HOOK(GetTickCount);
    }
    if (hdd->EnableGetTickCount64Hook == TRUE && _GetTickCount64 != 0)
    {
        g_log.LogDebug(L"ApplyKernel32Hook -> Hooking GetTickCount64");
        HOOK(GetTickCount64);
    }
    if (hdd->EnableGetLocalTimeHook == TRUE)
    {
        g_log.LogDebug(L"ApplyKernel32Hook -> Hooking GetLocalTime");
        HOOK(GetLocalTime);
    }
    if (hdd->EnableGetSystemTimeHook == TRUE)
    {
        g_log.LogDebug(L"ApplyKernel32Hook -> Hooking GetSystemTime");
        HOOK(GetSystemTime);
    }
    if (hdd->EnableOutputDebugStringHook == TRUE)
    {
        g_log.LogDebug(L"ApplyKernel32Hook -> Hooking OutputDebugStringA");
        HOOK(OutputDebugStringA);
    }
    hdd->isKernel32Hooked = TRUE;

    return true;
}

bool ApplyUserHook(HOOK_DLL_DATA * hdd, HANDLE hProcess, BYTE * dllMemory, DWORD_PTR imageBase)
{
    if (GetModuleBaseRemote(hProcess, L"user32.dll") == nullptr &&
        GetModuleBaseRemote(hProcess, L"win32u.dll") == nullptr)
    {
        hdd->isUserDllHooked = FALSE;
        return true;
    }

    void * HookedNtUserBlockInput = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtUserBlockInput") + imageBase);
    void * HookedNtUserFindWindowEx = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtUserFindWindowEx") + imageBase);
    void * HookedNtUserBuildHwndList = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtUserBuildHwndList") + imageBase);
    void * HookedNtUserBuildHwndList_Eight = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtUserBuildHwndList_Eight") + imageBase);
    void * HookedNtUserQueryWindow = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtUserQueryWindow") + imageBase);
    void * HookedNtUserGetForegroundWindow = (void *)(GetDllFunctionAddressRVA(dllMemory, "HookedNtUserGetForegroundWindow") + imageBase);

    g_log.LogDebug(L"ApplyUserHook -> HookedNtUserBlockInput %p HookedNtUserFindWindowEx %p HookedNtUserBuildHwndList %p HookedNtUserBuildHwndList_Eight %p HookedNtUserQueryWindow %p HookedNtUserGetForegroundWindow %p",
        HookedNtUserBlockInput,
        HookedNtUserFindWindowEx,
        HookedNtUserBuildHwndList,
        HookedNtUserBuildHwndList_Eight,
        HookedNtUserQueryWindow,
        HookedNtUserGetForegroundWindow);

    _NtUserBlockInput = (t_NtUserBlockInput)hdd->NtUserBlockInputVA;
    _NtUserFindWindowEx = (t_NtUserFindWindowEx)hdd->NtUserFindWindowExVA;
    _NtUserBuildHwndList = (t_NtUserBuildHwndList)hdd->NtUserBuildHwndListVA;
    _NtUserQueryWindow = (t_NtUserQueryWindow)hdd->NtUserQueryWindowVA;
    _NtUserGetForegroundWindow = (t_NtUserGetForegroundWindow)hdd->NtUserGetForegroundWindowVA;

    hdd->NtUserQueryWindow = _NtUserQueryWindow;
    hdd->NtUserGetClassName = (t_NtUserGetClassName)hdd->NtUserGetClassNameVA;
    hdd->NtUserInternalGetWindowText = (t_NtUserInternalGetWindowText)hdd->NtUserInternalGetWindowTextVA;
    hdd->NtUserGetThreadState = (t_NtUserGetThreadState)hdd->NtUserGetThreadStateVA;

    g_log.LogDebug(L"ApplyUserHook -> _NtUserBlockInput %p _NtUserFindWindowEx %p _NtUserBuildHwndList %p _NtUserQueryWindow %p _NtUserGetForegroundWindow %p",
        _NtUserBlockInput,
        _NtUserFindWindowEx,
        _NtUserBuildHwndList,
        _NtUserQueryWindow,
        _NtUserGetForegroundWindow);

    if (hdd->EnableNtUserBlockInputHook)
    {
        g_log.LogDebug(L"ApplyUserHook -> Hooking NtUserBlockInput");
        HOOK_NATIVE(NtUserBlockInput);
    }
    if (hdd->EnableNtUserFindWindowExHook)
    {
        g_log.LogDebug(L"ApplyUserHook -> Hooking NtUserFindWindowEx");
        HOOK_NATIVE(NtUserFindWindowEx);
    }
    if (hdd->EnableNtUserBuildHwndListHook)
    {
        g_log.LogDebug(L"ApplyUserHook -> Hooking NtUserBuildHwndList");
        //HOOK_NATIVE(NtUserBuildHwndList); // Not possible here because Windows >= 8 uses a different function export
        hdd->dNtUserBuildHwndList = (t_NtUserBuildHwndList)DetourCreateRemoteNative(hProcess, "NtUserBuildHwndList", (PVOID)_NtUserBuildHwndList,
            (scl::GetWindowsVersion() <= scl::OS_WIN_7 ? HookedNtUserBuildHwndList : HookedNtUserBuildHwndList_Eight),
            true, &hdd->NtUserBuildHwndListBackupSize);
        if (hdd->dNtUserBuildHwndList == nullptr)
            return false;
    }
    if (hdd->EnableNtUserQueryWindowHook)
    {
        g_log.LogDebug(L"ApplyUserHook -> Hooking NtUserQueryWindow");
        HOOK_NATIVE(NtUserQueryWindow);
    }
    if (hdd->EnableNtUserGetForegroundWindowHook)
    {
        g_log.LogDebug(L"ApplyUserHook -> Hooking NtUserGetForegroundWindow");
        HOOK_NATIVE(NtUserGetForegroundWindow);
    }

    hdd->isUserDllHooked = TRUE;

    return true;
}

void ApplyPEBPatch(HANDLE hProcess, DWORD flags)
{
    auto peb = scl::GetPeb(hProcess);
    if (!peb) {
        g_log.LogError(L"Failed to read PEB from remote process");
    }
    else
    {
        if (flags & PEB_PATCH_BeingDebugged)
            peb->BeingDebugged = FALSE;
        if (flags & PEB_PATCH_NtGlobalFlag)
            peb->NtGlobalFlag &= ~0x70;

        if (flags & PEB_PATCH_ProcessParameters) {
            if (!scl::PebPatchProcessParameters(peb.get(), hProcess))
                g_log.LogError(L"Failed to patch PEB!ProcessParameters");
        }

        if (flags & PEB_PATCH_HeapFlags)
        {
            if (!scl::PebPatchHeapFlags(peb.get(), hProcess))
                g_log.LogError(L"Failed to patch flags in PEB!ProcessHeaps");
        }

        if (flags & PEB_PATCH_OsBuildNumber)
        {
            peb->OSBuildNumber = FAKE_VERSION;
        }

        if (!scl::SetPeb(hProcess, peb.get()))
            g_log.LogError(L"Failed to write PEB to remote process");

    }

#ifndef _WIN64
    if (!scl::IsWow64Process(hProcess))
        return;

    auto peb64 = scl::Wow64GetPeb64(hProcess);
    if (!peb64) {
        g_log.LogError(L"Failed to read PEB64 from remote process");
    }
    else
    {
        if (flags & PEB_PATCH_BeingDebugged)
            peb64->BeingDebugged = FALSE;
        if (flags & PEB_PATCH_NtGlobalFlag)
            peb64->NtGlobalFlag &= ~0x70;

        if (flags & PEB_PATCH_ProcessParameters) {
            if (!scl::Wow64Peb64PatchProcessParameters(peb64.get(), hProcess))
                g_log.LogError(L"Failed to patch PEB64!ProcessParameters");
        }

        if (flags & PEB_PATCH_HeapFlags)
        {
            if (!scl::Wow64Peb64PatchHeapFlags(peb64.get(), hProcess))
                g_log.LogError(L"Failed to patch flags in PEB64!ProcessHeaps");
        }

        if (flags & PEB_PATCH_OsBuildNumber)
        {
            peb64->OSBuildNumber = FAKE_VERSION;
        }

        if (!scl::Wow64SetPeb64(hProcess, peb64.get()))
            g_log.LogError(L"Failed to write PEB64 to remote process");
    }
#endif
}

void ApplyNtdllVersionPatch(HANDLE hProcess)
{
    // This will get the 32 bit ntdll if we are on Wow64, which is fine.
    // Note that this relies on the addresses of DLLs in \KnownDlls[32] to be the same for all processes
    const PVOID Ntdll = GetModuleHandleW(L"ntdll.dll");
    ApplyNtdllVersionPatch(hProcess, Ntdll);
}

void RestoreMemory(HANDLE hProcess, DWORD_PTR address, void * buffer, int bufferSize)
{
    DWORD protect = 0;
    if (address && buffer && bufferSize)
    {
        if (VirtualProtectEx(hProcess, (void *)address, bufferSize, PAGE_EXECUTE_READWRITE, &protect))
        {
            WriteProcessMemory(hProcess, (void *)address, buffer, bufferSize, 0);

            VirtualProtectEx(hProcess, (void *)address, bufferSize, protect, &protect);
        }
    }

}

void RestoreJumper(HANDLE hProcess, void* address, void * backupAddress, DWORD backupSize)
{
    if (address && backupAddress && backupSize)
    {
        void * backup = malloc(backupSize);
        if (backup)
        {
            if (ReadProcessMemory(hProcess, backupAddress, backup, backupSize, 0))
            {
                RestoreMemory(hProcess, (DWORD_PTR)address, backup, backupSize);
            }

            free(backup);
        }
    }
}

void FreeMemory(HANDLE hProcess, void * buffer)
{
    if (hProcess && buffer)
    {
        VirtualFreeEx(hProcess, buffer, 0, MEM_RELEASE);
    }
}

void RestoreNtdllHooks(HOOK_DLL_DATA * hdd, HANDLE hProcess)
{
#ifndef _WIN64
    if (scl::IsWow64Process(hProcess))
    {
        RestoreMemory(hProcess, KiFastSystemCallWow64Address, KiFastSystemCallWow64Backup, sizeof(KiFastSystemCallWow64Backup));
    }
    else
    {
        if (KiFastSystemCallAddress != 0)
        {
            RestoreMemory(hProcess, KiFastSystemCallAddress, KiFastSystemCallBackup, sizeof(KiFastSystemCallBackup));
        }
        else
        {
            RESTORE_JMP(NtClose);
            RESTORE_JMP(NtDuplicateObject);
            RESTORE_JMP(NtContinue);
            RESTORE_JMP(NtCreateThreadEx);
            RESTORE_JMP(NtCreateThread);
            RESTORE_JMP(NtSetContextThread);
            RESTORE_JMP(NtGetContextThread);
            RESTORE_JMP(NtYieldExecution);
            RESTORE_JMP(NtQueryObject);
            RESTORE_JMP(NtSetInformationProcess);
            RESTORE_JMP(NtQueryInformationProcess);
            RESTORE_JMP(NtQuerySystemInformation);
            RESTORE_JMP(NtSetInformationThread);
            RESTORE_JMP(NtOpenFile);
            RESTORE_JMP(NtCreateSection);
            RESTORE_JMP(NtMapViewOfSection);
        }
    }
#else
    RESTORE_JMP(NtClose);
    RESTORE_JMP(NtDuplicateObject);
    RESTORE_JMP(NtContinue);
    RESTORE_JMP(NtCreateThreadEx);
    RESTORE_JMP(NtCreateThread);
    RESTORE_JMP(NtSetContextThread);
    RESTORE_JMP(NtGetContextThread);
    RESTORE_JMP(NtYieldExecution);
    RESTORE_JMP(NtQueryObject);
    RESTORE_JMP(NtSetInformationProcess);
    RESTORE_JMP(NtQueryInformationProcess);
    RESTORE_JMP(NtQuerySystemInformation);
    RESTORE_JMP(NtSetInformationThread);
    RESTORE_JMP(NtOpenFile);
    RESTORE_JMP(NtCreateSection);
    RESTORE_JMP(NtMapViewOfSection);
#endif

    FREE_HOOK(NtClose);
    FREE_HOOK(NtDuplicateObject);
    FREE_HOOK(NtContinue);
    FREE_HOOK(NtCreateThreadEx);
    FREE_HOOK(NtCreateThread);
    FREE_HOOK(NtSetContextThread);
    FREE_HOOK(NtGetContextThread);
    FREE_HOOK(NtYieldExecution);
    FREE_HOOK(NtQueryObject);
    FREE_HOOK(NtSetInformationProcess);
    FREE_HOOK(NtQueryInformationProcess);
    FREE_HOOK(NtQuerySystemInformation);
    FREE_HOOK(NtSetInformationThread);
    FREE_HOOK(NtOpenFile);
    FREE_HOOK(NtCreateSection);
    FREE_HOOK(NtMapViewOfSection);


    RESTORE_JMP(KiUserExceptionDispatcher);
    FREE_HOOK(KiUserExceptionDispatcher);


    hdd->isNtdllHooked = FALSE;
}

void RestoreKernel32Hooks(HOOK_DLL_DATA * hdd, HANDLE hProcess)
{
    RESTORE_JMP(OutputDebugStringA);
    RESTORE_JMP(GetTickCount);
    RESTORE_JMP(GetTickCount64);
    RESTORE_JMP(GetLocalTime);
    RESTORE_JMP(GetSystemTime);

    FREE_HOOK(OutputDebugStringA);
    FREE_HOOK(GetTickCount);
    FREE_HOOK(GetTickCount64);
    FREE_HOOK(GetLocalTime);
    FREE_HOOK(GetSystemTime);

    hdd->isKernel32Hooked = FALSE;
}

void RestoreUserHooks(HOOK_DLL_DATA * hdd, HANDLE hProcess)
{
#ifndef _WIN64
    if (!scl::IsWow64Process(hProcess) && KiFastSystemCallAddress == 0)
    {
        RESTORE_JMP(NtUserBlockInput);
        RESTORE_JMP(NtUserFindWindowEx);
        RESTORE_JMP(NtUserBuildHwndList);
        RESTORE_JMP(NtUserQueryWindow);
        RESTORE_JMP(NtUserGetForegroundWindow);
    }
#else
    RESTORE_JMP(NtUserBlockInput);
    RESTORE_JMP(NtUserFindWindowEx);
    RESTORE_JMP(NtUserBuildHwndList);
    RESTORE_JMP(NtUserQueryWindow);
    RESTORE_JMP(NtUserGetForegroundWindow);
#endif

    FREE_HOOK(NtUserBlockInput);
    FREE_HOOK(NtUserFindWindowEx);
    FREE_HOOK(NtUserBuildHwndList);
    FREE_HOOK(NtUserQueryWindow);
    FREE_HOOK(NtUserGetForegroundWindow);

    hdd->isUserDllHooked = FALSE;
}

void RestoreHooks(HOOK_DLL_DATA * hdd, HANDLE hProcess)
{
    if (hdd->isNtdllHooked)
    {
        RestoreNtdllHooks(hdd, hProcess);
    }

    if (hdd->isKernel32Hooked)
    {
        RestoreKernel32Hooks(hdd, hProcess);
    }

    if (hdd->isUserDllHooked)
    {
        RestoreUserHooks(hdd, hProcess);
    }

    FreeMemory(hProcess, hdd->hDllImage);
    hdd->hDllImage = 0;
}

bool ApplyHook(HOOK_DLL_DATA * hdd, HANDLE hProcess, BYTE * dllMemory, DWORD_PTR imageBase)
{
    bool success = true;
    hdd->hDllImage = (HMODULE)imageBase;

    if (!hdd->isNtdllHooked)
    {
        success = success && ApplyNtdllHook(hdd, hProcess, dllMemory, imageBase);
    }
    if (!hdd->isKernel32Hooked)
    {
        success = success && ApplyKernel32Hook(hdd, hProcess, dllMemory, imageBase);
    }
    if (!hdd->isUserDllHooked)
    {
        success = success && ApplyUserHook(hdd, hProcess, dllMemory, imageBase);
    }

#ifndef _WIN64
    hdd->NativeCallContinue = NativeCallContinue;
#endif

    return success;
}



================================================
File: InjectorCLI/ApplyHooking.h
================================================
#pragma once
#include <windows.h>
#include "..\HookLibrary\HookMain.h"

void ApplyPEBPatch(HANDLE hProcess, DWORD flags);
void ApplyNtdllVersionPatch(HANDLE hProcess);
bool ApplyHook(HOOK_DLL_DATA * hdd, HANDLE hProcess, BYTE * dllMemory, DWORD_PTR imageBase);
void RestoreHooks(HOOK_DLL_DATA * hdd, HANDLE hProcess);



================================================
File: InjectorCLI/CliMain.cpp
================================================
#include <Windows.h>
#include <Shlwapi.h>
#include <TlHelp32.h>
#include <cstdio>
#include <cstring>
#include <Scylla/Logger.h>
#include <Scylla/PebHider.h>
#include <Scylla/Settings.h>
#include <Scylla/Util.h>

#include "DynamicMapping.h"
#include "..\HookLibrary\HookMain.h"
#include "ApplyHooking.h"
#include "../PluginGeneric/Injector.h"

scl::Settings g_settings;
scl::Logger g_log;
std::wstring g_scyllaHideIniPath;

HOOK_DLL_DATA g_hdd;


void ChangeBadWindowText();
void ReadSettings();
DWORD GetProcessIdByName(const WCHAR * processName);
bool startInjection(DWORD targetPid, const WCHAR * dllPath);
bool SetDebugPrivileges();
BYTE * ReadFileToMemory(const WCHAR * targetFilePath);
bool startInjectionProcess(HANDLE hProcess, BYTE * dllMemory);
bool StartHooking(HANDLE hProcess, BYTE * dllMemory, DWORD_PTR imageBase);
bool convertNumber(const wchar_t* str, unsigned long & result, int radix);

// Check if argument starts with text (case insensitive).
bool ArgStartsWith(wchar_t* arg, const wchar_t* with);

// Check if argument starts with text (case insensitive) and return param after the text.
bool ArgStartsWith(wchar_t* arg, const wchar_t* text, wchar_t* &param);

#define PREFIX_PATH L"C:\\Users\\Admin\\Documents\\Visual Studio 2010\\Projects\\ScyllaHide"

static void LogCallback(const wchar_t *msg)
{
    _putws(msg);
}

int wmain(int argc, wchar_t* argv[])
{
    DWORD targetPid = 0;
    WCHAR * dllPath = 0;

    auto wstrPath = scl::GetModuleFileNameW();
    wstrPath.resize(wstrPath.find_last_of(L'\\') + 1);

    g_scyllaHideIniPath = wstrPath + scl::Settings::kFileName;

    auto log_file = wstrPath + scl::Logger::kFileName;
    g_log.SetLogFile(log_file.c_str());
    g_log.SetLogCb(scl::Logger::Info, LogCallback);
    g_log.SetLogCb(scl::Logger::Error, LogCallback);

    ReadNtApiInformation(&g_hdd);
    SetDebugPrivileges();
    //ChangeBadWindowText();
    g_settings.Load(g_scyllaHideIniPath.c_str());
    ReadSettings();

    bool waitOnExit = true;

    if (argc >= 3)
    {
        wchar_t* pid;

        if (ArgStartsWith(argv[1], L"pid:", pid))
        {
            auto radix = 10;
            if(wcsstr(pid, L"0x") == pid)
                radix = 16, pid += 2;
            if(!convertNumber(pid, targetPid, radix))
                targetPid = 0;
        }
        else
            targetPid = GetProcessIdByName(argv[1]);

        dllPath = argv[2];

        if (argc >= 4)
            waitOnExit = !(ArgStartsWith(argv[3], L"nowait"));
    }
    else
    {

#ifdef _WIN64
        targetPid = GetProcessIdByName(L"scylla_x64.exe");//scylla_x64
        dllPath = PREFIX_PATH L"\\Release\\HookLibraryx64.dll";
#else
        targetPid = GetProcessIdByName(L"ThemidaTest.exe");//GetProcessIdByName(L"ThemidaTest.exe");//GetProcessIdByName(L"VMProtect.vmp.exe");//GetProcessIdByName(L"scylla_x86.exe");
        dllPath = PREFIX_PATH L"\\Release\\HookLibraryx86.dll";
#endif
    }

    int result = 0;

    if (targetPid && dllPath)
    {
        wprintf(L"\nPID\t: %d 0x%X\nDLL Path: %s\n\n", targetPid, targetPid, dllPath);
        if (!startInjection(targetPid, dllPath))
            result = 1; // failure
    }
    else
    {
        wprintf(L"Usage: %s <process name> <dll path> [nowait]\n", argv[0]);
        wprintf(L"Usage: %s pid:<process id> <dll path> [nowait]", argv[0]);
    }

    if (waitOnExit)
        getchar();

    return 0;
}

static bool StartHooking(HANDLE hProcess, BYTE * dllMemory, DWORD_PTR imageBase)
{
    g_hdd.dwProtectedProcessId = 0;
    g_hdd.EnableProtectProcessId = FALSE;

    DWORD peb_flags = 0;
    if (g_settings.opts().fixPebBeingDebugged)
        peb_flags |= PEB_PATCH_BeingDebugged;
    if (g_settings.opts().fixPebHeapFlags)
        peb_flags |= PEB_PATCH_HeapFlags;
    if (g_settings.opts().fixPebNtGlobalFlag)
        peb_flags |= PEB_PATCH_NtGlobalFlag;
    if (g_settings.opts().fixPebStartupInfo)
        peb_flags |= PEB_PATCH_ProcessParameters;
    if (g_settings.opts().fixPebOsBuildNumber)
        peb_flags |= PEB_PATCH_OsBuildNumber;

    ApplyPEBPatch(hProcess, peb_flags);
    if (g_settings.opts().fixPebOsBuildNumber)
        ApplyNtdllVersionPatch(hProcess);

    if (dllMemory == nullptr || imageBase == 0)
        return peb_flags != 0; // Not injecting hook DLL

    return ApplyHook(&g_hdd, hProcess, dllMemory, imageBase);
}

bool startInjectionProcess(HANDLE hProcess, BYTE * dllMemory)
{
    PROCESS_SUSPEND_INFO suspendInfo;
    if (!SafeSuspendProcess(hProcess, &suspendInfo))
        return false;

    if (g_settings.opts().removeDebugPrivileges)
    {
        RemoveDebugPrivileges(hProcess);
    }

    const bool injectDll = g_settings.hook_dll_needed();
    bool success = false;
    if (injectDll)
    {
        LPVOID remoteImageBase = MapModuleToProcess(hProcess, dllMemory, true);
        if (remoteImageBase != nullptr)
        {
            FillHookDllData(hProcess, &g_hdd);
            DWORD hookDllDataAddressRva = GetDllFunctionAddressRVA(dllMemory, "HookDllData");

            if (StartHooking(hProcess, dllMemory, (DWORD_PTR)remoteImageBase))
            {
                if (WriteProcessMemory(hProcess, (LPVOID)((DWORD_PTR)hookDllDataAddressRva + (DWORD_PTR)remoteImageBase), &g_hdd, sizeof(HOOK_DLL_DATA), 0))
                {
                    wprintf(L"Hook injection successful, image base %p\n", remoteImageBase);
                    success = true;
                }
                else
                {
                    wprintf(L"Failed to write hook dll data\n");
                }
            }
        }
    }
    else
    {
        if (StartHooking(hProcess, nullptr, 0))
            wprintf(L"PEB patch successful, hook injection not needed\n");
        success = true;
    }

    SafeResumeProcess(&suspendInfo);

    return success;
}

bool startInjection(DWORD targetPid, const WCHAR * dllPath)
{
    bool result = false;

    HANDLE hProcess = OpenProcess( PROCESS_SUSPEND_RESUME | PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION,
        0, targetPid);
    if (hProcess)
    {
        BYTE * dllMemory = ReadFileToMemory(dllPath);
        if (dllMemory)
        {
            result = startInjectionProcess(hProcess, dllMemory);
            if (g_settings.opts().killAntiAttach)
            {
                if (!ApplyAntiAntiAttach(targetPid))
                {
                    wprintf(L"Anti-Anti-Attach failed\n");
                }
            }
            free(dllMemory);
        }
        else
        {
            wprintf(L"Cannot read file to memory %s\n", dllPath);
        }
        CloseHandle(hProcess);
    }
    else
    {
        wprintf(L"Cannot open process handle %d\n", targetPid);
    }

    return result;
}

bool SetDebugPrivileges()
{
    TOKEN_PRIVILEGES Debug_Privileges;
	bool retVal = false;

    if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &Debug_Privileges.Privileges[0].Luid))
	{
		HANDLE hToken = 0;
		if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
		{
			Debug_Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
			Debug_Privileges.PrivilegeCount = 1;

			retVal = AdjustTokenPrivileges(hToken, FALSE, &Debug_Privileges, 0, NULL, NULL) != FALSE;

			CloseHandle(hToken);
		}
	}

    return retVal;
}

DWORD GetProcessIdByName(const WCHAR * processName)
{
    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hProcessSnap == INVALID_HANDLE_VALUE)
    {
        return 0;
    }

    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hProcessSnap, &pe32))
    {
        wprintf(L"Error getting first process\n");
        CloseHandle(hProcessSnap);
        return 0;
    }

    DWORD pid = 0;

    do
    {
        if (!_wcsicmp(pe32.szExeFile, processName))
        {
            pid = pe32.th32ProcessID;
            break;
        }
    } while (Process32Next(hProcessSnap, &pe32));

    CloseHandle(hProcessSnap);
    return pid;
}

void ReadSettings()
{
    g_hdd.EnableGetLocalTimeHook = g_settings.opts().hookGetLocalTime;
    g_hdd.EnableGetSystemTimeHook = g_settings.opts().hookGetSystemTime;
    g_hdd.EnableGetTickCount64Hook = g_settings.opts().hookGetTickCount64;
    g_hdd.EnableGetTickCountHook = g_settings.opts().hookGetTickCount;
    g_hdd.EnableKiUserExceptionDispatcherHook = g_settings.opts().hookKiUserExceptionDispatcher;
    g_hdd.EnableNtCloseHook = g_settings.opts().hookNtClose;
    g_hdd.EnableNtContinueHook = g_settings.opts().hookNtContinue;
    g_hdd.EnableNtCreateThreadExHook = g_settings.opts().hookNtCreateThreadEx;
    g_hdd.EnableNtGetContextThreadHook = g_settings.opts().hookNtGetContextThread;
    g_hdd.EnableNtQueryInformationProcessHook = g_settings.opts().hookNtQueryInformationProcess;
    g_hdd.EnableNtQueryObjectHook = g_settings.opts().hookNtQueryObject;
    g_hdd.EnableNtQueryPerformanceCounterHook = g_settings.opts().hookNtQueryPerformanceCounter;
    g_hdd.EnableNtQuerySystemInformationHook = g_settings.opts().hookNtQuerySystemInformation;
    g_hdd.EnableNtQuerySystemTimeHook = g_settings.opts().hookNtQuerySystemTime;
    g_hdd.EnableNtSetContextThreadHook = g_settings.opts().hookNtSetContextThread;
    g_hdd.EnableNtSetDebugFilterStateHook = g_settings.opts().hookNtSetDebugFilterState;
    g_hdd.EnableNtSetInformationThreadHook = g_settings.opts().hookNtSetInformationThread;
    g_hdd.EnableNtUserBlockInputHook = g_settings.opts().hookNtUserBlockInput;
    g_hdd.EnableNtUserBuildHwndListHook = g_settings.opts().hookNtUserBuildHwndList;
    g_hdd.EnableNtUserFindWindowExHook = g_settings.opts().hookNtUserFindWindowEx;
    g_hdd.EnableNtUserQueryWindowHook = g_settings.opts().hookNtUserQueryWindow;
    g_hdd.EnableNtUserGetForegroundWindowHook = g_settings.opts().hookNtUserGetForegroundWindow;
    g_hdd.EnableNtYieldExecutionHook = g_settings.opts().hookNtYieldExecution;
    g_hdd.EnableOutputDebugStringHook = g_settings.opts().hookOutputDebugStringA;
    g_hdd.EnablePebBeingDebugged = g_settings.opts().fixPebBeingDebugged;
    g_hdd.EnablePebHeapFlags = g_settings.opts().fixPebHeapFlags;
    g_hdd.EnablePebNtGlobalFlag = g_settings.opts().fixPebNtGlobalFlag;
    g_hdd.EnablePebStartupInfo = g_settings.opts().fixPebStartupInfo;
    g_hdd.EnablePebOsBuildNumber = g_settings.opts().fixPebOsBuildNumber;
    g_hdd.EnablePreventThreadCreation = g_settings.opts().preventThreadCreation;
    g_hdd.EnableProtectProcessId = g_settings.opts().protectProcessId;
}

bool convertNumber(const wchar_t* str, unsigned long & result, int radix)
{
    errno = 0;
    wchar_t* end;
    result = wcstoul(str, &end, radix);
    if(!result && end == str)
        return false;
    if(result == ULLONG_MAX && errno)
        return false;
    if(*end)
        return false;
    return true;
}

bool ArgStartsWith(wchar_t* arg, const wchar_t* with)
{
    return _wcsnicmp(arg, with, wcslen(with)) == 0;
}

bool ArgStartsWith(wchar_t* arg, const wchar_t* text, wchar_t* &param)
{
    auto len = wcslen(text);

    if (_wcsnicmp(arg, text, len) == 0 && arg[len])
    {
        param = arg + len;
        return true;
    }

    param = nullptr;
    return false;
}



================================================
File: InjectorCLI/DynamicMapping.cpp
================================================
#include "DynamicMapping.h"
#include <Psapi.h>
#include <ntdll/ntdll.h>

#pragma comment(lib, "psapi.lib")

LPVOID MapModuleToProcess(HANDLE hProcess, BYTE * dllMemory, bool wipeHeaders)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dllMemory;
    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDosHeader + pDosHeader->e_lfanew);
    PIMAGE_SECTION_HEADER pSecHeader = IMAGE_FIRST_SECTION(pNtHeader);

    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE || pNtHeader->Signature != IMAGE_NT_SIGNATURE)
    {
        return nullptr;
    }

    IMAGE_DATA_DIRECTORY relocDir = pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    bool relocatable = (pNtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) != 0;
    bool hasRelocDir = pNtHeader->OptionalHeader.NumberOfRvaAndSizes >= IMAGE_DIRECTORY_ENTRY_BASERELOC && relocDir.VirtualAddress > 0 && relocDir.Size > 0;
    if (!hasRelocDir && (pNtHeader->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED)) // A relocation dir is optional, but it must not have been stripped
    {
        return nullptr;
    }

    ULONG_PTR headersBase = pNtHeader->OptionalHeader.ImageBase;
    LPVOID preferredBase = relocatable ? nullptr : (LPVOID)headersBase;
    LPVOID imageRemote = VirtualAllocEx(hProcess, preferredBase, pNtHeader->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    LPVOID imageLocal = VirtualAlloc(nullptr, pNtHeader->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    if (!imageLocal || !imageRemote)
    {
        return nullptr;
    }

    // Update the headers to the relocated image base
    if (relocatable && (ULONG_PTR)imageRemote != pNtHeader->OptionalHeader.ImageBase)
        pNtHeader->OptionalHeader.ImageBase = (ULONG_PTR)imageRemote;

    memcpy((LPVOID)imageLocal, (LPVOID)pDosHeader, pNtHeader->OptionalHeader.SizeOfHeaders);

    SIZE_T imageSize = pNtHeader->OptionalHeader.SizeOfImage;
    for (WORD i = 0; i < pNtHeader->FileHeader.NumberOfSections; i++)
    {
        if (hasRelocDir && i == pNtHeader->FileHeader.NumberOfSections - 1 &&
            pSecHeader->VirtualAddress == relocDir.VirtualAddress && (pSecHeader->Characteristics & IMAGE_SCN_MEM_DISCARDABLE))
            imageSize = pSecHeader->VirtualAddress; // Limit the maximum VA to copy to the process to exclude .reloc if it is the last section

        memcpy((LPVOID)((DWORD_PTR)imageLocal + pSecHeader->VirtualAddress), (LPVOID)((DWORD_PTR)pDosHeader + pSecHeader->PointerToRawData), pSecHeader->SizeOfRawData);
        pSecHeader++;
    }

    if (hasRelocDir)
    {
        DWORD_PTR dwDelta = (DWORD_PTR)imageRemote - headersBase;
        DoBaseRelocation(
            (PIMAGE_BASE_RELOCATION)((DWORD_PTR)imageLocal + relocDir.VirtualAddress),
            (DWORD_PTR)imageLocal,
            dwDelta);
    }

    ResolveImports((PIMAGE_IMPORT_DESCRIPTOR)((DWORD_PTR)imageLocal + pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress), (DWORD_PTR)imageLocal);

    SIZE_T skipBytes = wipeHeaders ? pNtHeader->OptionalHeader.SizeOfHeaders : 0;
    if (WriteProcessMemory(hProcess, (PVOID)((ULONG_PTR)imageRemote + skipBytes), (PVOID)((ULONG_PTR)imageLocal + skipBytes),
        imageSize - skipBytes, nullptr))
    {
        VirtualFree(imageLocal, 0, MEM_RELEASE);
    }
    else
    {
        VirtualFree(imageLocal, 0, MEM_RELEASE);
        VirtualFreeEx(hProcess, imageRemote, 0, MEM_RELEASE);
        imageRemote = nullptr;
    }
    return imageRemote;
}

bool ResolveImports(PIMAGE_IMPORT_DESCRIPTOR pImport, DWORD_PTR module)
{
    PIMAGE_THUNK_DATA thunkRef;
    PIMAGE_THUNK_DATA funcRef;

    while (pImport->FirstThunk)
    {
        char * moduleName = (char *)(module + pImport->Name);

        HMODULE hModule = GetModuleHandleA(moduleName);

        if (!hModule)
        {
            hModule = LoadLibraryA(moduleName);
            if (!hModule)
            {
                return false;
            }
        }

        funcRef = (PIMAGE_THUNK_DATA)(module + pImport->FirstThunk);
        if (pImport->OriginalFirstThunk)
        {
            thunkRef = (PIMAGE_THUNK_DATA)(module + pImport->OriginalFirstThunk);
        }
        else
        {
            thunkRef = (PIMAGE_THUNK_DATA)(module + pImport->FirstThunk);
        }

        while (thunkRef->u1.Function)
        {
            if (IMAGE_SNAP_BY_ORDINAL(thunkRef->u1.Function))
            {
                funcRef->u1.Function = (DWORD_PTR)GetProcAddress(hModule, (LPCSTR)IMAGE_ORDINAL(thunkRef->u1.Ordinal));
            }
            else
            {
                PIMAGE_IMPORT_BY_NAME thunkData = (PIMAGE_IMPORT_BY_NAME)(module + thunkRef->u1.AddressOfData);
                funcRef->u1.Function = (DWORD_PTR)GetProcAddress(hModule, (LPCSTR)thunkData->Name);
            }

            if (!funcRef->u1.Function)
            {
                MessageBoxA(0, "Function not resolved", moduleName, 0);
                return false;
            }

            thunkRef++;
            funcRef++;
        }

        pImport++;
    }

    return true;
}

void DoBaseRelocation(PIMAGE_BASE_RELOCATION relocation, DWORD_PTR memory, DWORD_PTR dwDelta)
{
    DWORD_PTR * patchAddress;
    WORD type, offset;

    while (relocation->VirtualAddress)
    {
        PBYTE dest = (PBYTE)(memory + relocation->VirtualAddress);
        DWORD count = (relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        WORD * relocInfo = (WORD *)((DWORD_PTR)relocation + sizeof(IMAGE_BASE_RELOCATION));

        for (DWORD i = 0; i < count; i++)
        {
            type = relocInfo[i] >> 12;
            offset = relocInfo[i] & 0xfff;

            switch (type)
            {
            case IMAGE_REL_BASED_ABSOLUTE:
                break;
            case IMAGE_REL_BASED_HIGHLOW:
            case IMAGE_REL_BASED_DIR64:
                patchAddress = (DWORD_PTR *)(dest + offset);
                *patchAddress += dwDelta;
                break;
            default:
                break;
            }
        }

        relocation = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)relocation + relocation->SizeOfBlock);
    }
}

DWORD RVAToOffset(PIMAGE_NT_HEADERS pNtHdr, DWORD dwRVA)
{
    PIMAGE_SECTION_HEADER pSectionHdr = IMAGE_FIRST_SECTION(pNtHdr);

    for (WORD i = 0; i < pNtHdr->FileHeader.NumberOfSections; i++)
    {
        if (pSectionHdr->VirtualAddress <= dwRVA)
        {
            if ((pSectionHdr->VirtualAddress + pSectionHdr->Misc.VirtualSize) > dwRVA)
            {
                dwRVA -= pSectionHdr->VirtualAddress;
                dwRVA += pSectionHdr->PointerToRawData;

                return (dwRVA);
            }

        }
        pSectionHdr++;
    }

    return (0);
}

DWORD GetDllFunctionAddressRVA(BYTE * dllMemory, LPCSTR apiName)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dllMemory;
    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDosHeader + pDosHeader->e_lfanew);
    PIMAGE_EXPORT_DIRECTORY pExportDir;

    DWORD exportDirRVA = pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD exportDirOffset = RVAToOffset(pNtHeader, exportDirRVA);

    pExportDir = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)dllMemory + exportDirOffset);

    DWORD * addressOfFunctionsArray = (DWORD *)((DWORD)pExportDir->AddressOfFunctions - exportDirRVA + (DWORD_PTR)pExportDir);
    DWORD * addressOfNamesArray = (DWORD *)((DWORD)pExportDir->AddressOfNames - exportDirRVA + (DWORD_PTR)pExportDir);
    WORD * addressOfNameOrdinalsArray = (WORD *)((DWORD)pExportDir->AddressOfNameOrdinals - exportDirRVA + (DWORD_PTR)pExportDir);

    for (DWORD i = 0; i < pExportDir->NumberOfNames; i++)
    {
        char * functionName = (char*)(addressOfNamesArray[i] - exportDirRVA + (DWORD_PTR)pExportDir);

        if (!_stricmp(functionName, apiName))
        {
            return addressOfFunctionsArray[addressOfNameOrdinalsArray[i]];
        }
    }

    return 0;
}

HMODULE GetModuleBaseRemote(HANDLE hProcess, const wchar_t* szDLLName)
{
    DWORD cbNeeded = 0;
    wchar_t szModuleName[MAX_PATH] = { 0 };
    if (EnumProcessModules(hProcess, 0, 0, &cbNeeded))
    {
        HMODULE* hMods = (HMODULE*)malloc(cbNeeded*sizeof(HMODULE));
        if (EnumProcessModules(hProcess, hMods, cbNeeded, &cbNeeded))
        {
            for (unsigned int i = 0; i < cbNeeded / sizeof(HMODULE); i++)
            {
                szModuleName[0] = 0;
                if (GetModuleFileNameExW(hProcess, hMods[i], szModuleName, _countof(szModuleName)))
                {
                    wchar_t* dllName = wcsrchr(szModuleName, L'\\');
                    if (dllName)
                    {
                        dllName++;
                        if (!_wcsicmp(dllName, szDLLName))
                        {
                            HMODULE module = hMods[i];
                            free(hMods);
                            return module;
                        }
                    }
                }
            }
        }
        free(hMods);
    }
    return 0;
}



================================================
File: InjectorCLI/DynamicMapping.h
================================================
#pragma once

#include <windows.h>

typedef struct _SameTebFlags
{
    union
    {
        struct
        {
            USHORT DbgSafeThunkCall : 1;
            USHORT DbgInDebugPrint : 1;
            USHORT DbgHasFiberData : 1;
            USHORT DbgSkipThreadAttach : 1;
            USHORT DbgWerInShipAssertCode : 1;
            USHORT DbgIssuedInitialBp : 1;
            USHORT DbgClonedThread : 1;
            USHORT SpareSameTebBits : 9;
        };
        USHORT SameTebFlags;
    };
} SameTebFlags;

#ifdef _WIN64
#define TEB_OFFSET_SAME_TEB_FLAGS 0x17EE
#else
#define TEB_OFFSET_SAME_TEB_FLAGS 0xFCA
#endif

LPVOID MapModuleToProcess(HANDLE hProcess, BYTE * dllMemory, bool wipeHeaders);
void DoBaseRelocation(PIMAGE_BASE_RELOCATION relocation, DWORD_PTR memory, DWORD_PTR dwDelta);
DWORD GetDllFunctionAddressRVA(BYTE * dllMemory, LPCSTR apiName);
DWORD RVAToOffset(PIMAGE_NT_HEADERS pNtHdr, DWORD dwRVA);
HMODULE GetModuleBaseRemote(HANDLE hProcess, const wchar_t* szDLLName);
bool ResolveImports(PIMAGE_IMPORT_DESCRIPTOR pImport, DWORD_PTR module);



================================================
File: InjectorCLI/Icon.rc
================================================
[Non-text file]


================================================
File: InjectorCLI/InjectorCLI.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{92C90AAD-036E-474D-902C-CFD1E7422899}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>InjectorCLI</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\PluginGeneric\Injector.cpp" />
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="ApplyHooking.cpp" />
    <ClCompile Include="DynamicMapping.cpp" />
    <ClCompile Include="CliMain.cpp" />
    <ClCompile Include="RemoteHook.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Scylla\VersionPatch.h" />
    <ClInclude Include="ApplyHooking.h" />
    <ClInclude Include="DynamicMapping.h" />
    <ClInclude Include="RemoteHook.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Icon.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\ghost.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: InjectorCLI/InjectorCLI.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DynamicMapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CliMain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RemoteHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ApplyHooking.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DynamicMapping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RemoteHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ApplyHooking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Icon.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\ghost.ico">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: InjectorCLI/RemoteHook.cpp
================================================
#include "RemoteHook.h"
#include <distorm/distorm.h>
#include <distorm/mnemonics.h>
#include <Scylla/OsInfo.h>
#include <Scylla/Settings.h>
#include <Scylla/Peb.h>
#include "ApplyHooking.h"
#include <stdio.h>

#pragma comment(lib, "distorm.lib")

// GDT selector numbers on AMD64
#define KGDT64_R3_CMCODE (2 * 16)   // user mode 32-bit code
#define KGDT64_R3_CODE (3 * 16)     // user mode 64-bit code
#define RPL_MASK 3

#if !defined(_WIN64)
_DecodeType DecodingType = Decode32Bits;
#else
_DecodeType DecodingType = Decode64Bits;
#endif

#ifdef _WIN64
const int minDetourLen = 2 + sizeof(DWORD)+sizeof(DWORD_PTR) + 1; //8+4+2+1=15
#else
const int minDetourLen = sizeof(DWORD) + 1;
const int detourLenWow64FarJmp = 1 + sizeof(DWORD) + sizeof(USHORT); // EA far jmp
#endif


extern scl::Settings g_settings;
extern void * HookedNativeCallInternal;
extern void * NativeCallContinue;
extern HOOK_NATIVE_CALL32 * HookNative;
extern int countNativeHooks;
extern bool onceNativeCallContinue;
extern bool fatalFindSyscallIndexFailure;
extern bool fatalAlreadyHookedFailure;

BYTE originalBytes[60] = { 0 };
BYTE changedBytes[60] = { 0 };

void WriteJumper(unsigned char * lpbFrom, unsigned char * lpbTo)
{
#ifdef _WIN64
    lpbFrom[0] = 0xFF;
    lpbFrom[1] = 0x25;
    *(DWORD*)&lpbFrom[2] = 0;
    *(DWORD_PTR*)&lpbFrom[6] = (DWORD_PTR)lpbTo;
#else
    lpbFrom[0] = 0xE9;
    *(DWORD*)&lpbFrom[1] = (DWORD)((DWORD)lpbTo - (DWORD)lpbFrom - 5);
#endif
}

void WriteJumper(unsigned char * lpbFrom, unsigned char * lpbTo, unsigned char * buf, bool prefixNop)
{
#ifdef _WIN64
    UNREFERENCED_PARAMETER(lpbFrom);

    ULONG i = 0;
    if (prefixNop)
        buf[i++] = 0x90;

    buf[i] = 0xFF;
    buf[i + 1] = 0x25;
    *(DWORD*)&buf[i + 2] = 0;
    *(DWORD_PTR*)&buf[i + 6] = (DWORD_PTR)lpbTo;
#else
    UNREFERENCED_PARAMETER(prefixNop);

    buf[0] = 0xE9;
    *(DWORD*)&buf[1] = (DWORD)((DWORD)lpbTo - (DWORD)lpbFrom - 5);
#endif
}

#ifndef _WIN64
void WriteWow64Jumper(unsigned char * lpbTo, unsigned char * buf)
{
    // Preserve EA prefix (absolute far jmp), but use the 32 bit segment selector to avoid transitioning into x64 mode
    buf[0] = 0xEA;
    *(DWORD*)&buf[1] = (DWORD)lpbTo;
    *(USHORT*)&buf[5] = (USHORT)(KGDT64_R3_CMCODE | RPL_MASK);
}
#endif

void ClearSyscallBreakpoint(const char* funcName, unsigned char* funcBytes)
{
    // Do nothing if this is not a syscall stub
    if ((funcName == nullptr || funcName[0] == '\0') ||
        (funcName[0] != 'N' || funcName[1] != 't') &&
        (funcName[0] != 'Z' || funcName[1] != 'w'))
        return;

    if (funcBytes[0] == 0xCC || // int 3
        (funcBytes[0] == 0xCD && funcBytes[1] == 0x03) || // long int 3
        (funcBytes[0] == 0xF0 && funcBytes[1] == 0x0B)) // UD2
    {
#ifdef _WIN64
        // x64 stubs always start with 'mov r10, rcx'
        funcBytes[0] = 0x4C;
        funcBytes[1] = 0x8B;
#else
        // For x86 and WOW64 stubs, we can only restore int 3 breakpoints since the second byte is the (unknown) syscall number
        if (funcBytes[0] != 0xCC)
            MessageBoxA(nullptr, "ClearSyscallBreakpoint failed! Please use INT 3 breakpoints instead of long INT 3 or UD2.", "ScyllaHide", MB_ICONERROR);
        else
            funcBytes[0] = 0xB8; // mov eax, <syscall num>
#endif
    }
}

#ifndef _WIN64

DWORD GetEcxSysCallIndex32(const BYTE * data, int dataSize)
{
    unsigned int DecodedInstructionsCount = 0;
    _CodeInfo decomposerCi = { 0 };
    _DInst decomposerResult[10] = { 0 };

    decomposerCi.code = data;
    decomposerCi.codeLen = dataSize;
    decomposerCi.dt = DecodingType;
    decomposerCi.codeOffset = (LONG_PTR)data;

    if (distorm_decompose(&decomposerCi, decomposerResult, _countof(decomposerResult), &DecodedInstructionsCount) != DECRES_INPUTERR)
    {
        if (decomposerResult[0].flags != FLAG_NOT_DECODABLE && decomposerResult[1].flags != FLAG_NOT_DECODABLE)
        {
            if (decomposerResult[0].opcode == I_MOV && decomposerResult[1].opcode == I_MOV)
            {
                if (decomposerResult[1].ops[0].index == R_ECX)
                {
                    return decomposerResult[1].imm.dword;
                }
            }
        }
    }

    return 0;
}

DWORD GetSysCallIndex32(const BYTE * data)
{
    unsigned int DecodedInstructionsCount = 0;
    _CodeInfo decomposerCi = { 0 };
    _DInst decomposerResult[1] = { 0 };

    decomposerCi.code = data;
    decomposerCi.codeLen = MAXIMUM_INSTRUCTION_SIZE;
    decomposerCi.dt = DecodingType;
    decomposerCi.codeOffset = (LONG_PTR)data;

    if (distorm_decompose(&decomposerCi, decomposerResult, _countof(decomposerResult), &DecodedInstructionsCount) != DECRES_INPUTERR)
    {
        if (decomposerResult[0].flags != FLAG_NOT_DECODABLE)
        {
            if (decomposerResult[0].opcode == I_MOV)
            {
                return decomposerResult[0].imm.dword;
            }
            else
            {
                MessageBoxA(nullptr, "GetSysCallIndex32: Opcode is not I_MOV", "Distorm ERROR", MB_ICONERROR);
            }
        }
        else
        {
            MessageBoxA(nullptr, "GetSysCallIndex32: Distorm flags == FLAG_NOT_DECODABLE", "Distorm ERROR", MB_ICONERROR);
        }
    }
    else
    {
        MessageBoxA(nullptr, "GetSysCallIndex32: distorm_decompose() returned DECRES_INPUTERR", "Distorm ERROR", MB_ICONERROR);
    }

    return (DWORD)-1; // Don't return 0 here, it is a valid syscall index
}

DWORD GetCallDestination(HANDLE hProcess, const BYTE * data, int dataSize)
{
    unsigned int DecodedInstructionsCount = 0;
    _CodeInfo decomposerCi = { 0 };
    _DInst decomposerResult[100] = { 0 };

    decomposerCi.code = data;
    decomposerCi.codeLen = dataSize;
    decomposerCi.dt = DecodingType;
    decomposerCi.codeOffset = (LONG_PTR)data;

    if (distorm_decompose(&decomposerCi, decomposerResult, _countof(decomposerResult), &DecodedInstructionsCount) != DECRES_INPUTERR)
    {
        if (DecodedInstructionsCount > 2)
        {
            //B8 EA000000      MOV EAX,0EA
            //BA 0003FE7F      MOV EDX,7FFE0300
            //FF12             CALL DWORD PTR DS:[EDX]
            //C2 1400          RETN 14
            //0xB8,0xEA,0x00,0x00,0x00,0xBA,0x00,0x03,0xFE,0x7F,0xFF,0x12,0xC2,0x14,0x00

            //MOV EAX,0EA
            //MOV EDX, 7FFE0300h ; EDX = 7FFE0300h
            //	CALL EDX ; call 7FFE0300h
            //	RETN 14
            //0xB8,0xEA,0x00,0x00,0x00,0xBA,0x00,0x03,0xFE,0x7F,0xFF,0xD2,0xC2,0x14,0x00

            if (decomposerResult[0].flags != FLAG_NOT_DECODABLE && decomposerResult[1].flags != FLAG_NOT_DECODABLE)
            {
                if (decomposerResult[0].opcode == I_MOV && decomposerResult[1].opcode == I_MOV && decomposerResult[2].opcode == I_CALL)
                {
                    if (decomposerResult[2].ops[0].type == O_SMEM) //CALL DWORD PTR DS:[EDX]
                    {
                        DWORD pKUSER_SHARED_DATASysCall = decomposerResult[1].imm.dword;
                        if (pKUSER_SHARED_DATASysCall)
                        {
                            DWORD callDestination = 0;
                            ReadProcessMemory(hProcess, (void*)pKUSER_SHARED_DATASysCall, &callDestination, sizeof(DWORD), 0);
                            return callDestination;
                        }
                    }
                    else if (decomposerResult[2].ops[0].type == O_REG) //CALL EDX
                    {
                        return decomposerResult[1].imm.dword;
                    }
                }
            }

            MessageBoxA(nullptr, "Unknown syscall structure!", "ScyllaHide", 0);
        }
    }

    return NULL;
}

DWORD GetFunctionSizeRETN(BYTE * data, int dataSize)
{
    unsigned int DecodedInstructionsCount = 0;
    _CodeInfo decomposerCi = { 0 };
    _DInst decomposerResult[100] = { 0 };

    decomposerCi.code = data;
    decomposerCi.codeLen = dataSize;
    decomposerCi.dt = DecodingType;
    decomposerCi.codeOffset = (LONG_PTR)data;

    if (distorm_decompose(&decomposerCi, decomposerResult, _countof(decomposerResult), &DecodedInstructionsCount) != DECRES_INPUTERR)
    {
        for (unsigned int i = 0; i < DecodedInstructionsCount; i++)
        {
            if (decomposerResult[i].flags != FLAG_NOT_DECODABLE)
            {
                if (decomposerResult[i].opcode == I_RET)
                {
                    return (DWORD)(((DWORD_PTR)decomposerResult[i].addr + (DWORD_PTR)decomposerResult[i].size) - (DWORD_PTR)data);
                }
            }
        }

    }

    return 0;
}

DWORD GetCallOffset(const BYTE * data, int dataSize, DWORD * callSize)
{
    unsigned int DecodedInstructionsCount = 0;
    _CodeInfo decomposerCi = { 0 };
    _DInst decomposerResult[100] = { 0 };

    decomposerCi.code = data;
    decomposerCi.codeLen = dataSize;
    decomposerCi.dt = DecodingType;
    decomposerCi.codeOffset = (LONG_PTR)data;

    if (distorm_decompose(&decomposerCi, decomposerResult, _countof(decomposerResult), &DecodedInstructionsCount) != DECRES_INPUTERR)
    {
        for (unsigned int i = 0; i < DecodedInstructionsCount; i++)
        {
            if (decomposerResult[i].flags != FLAG_NOT_DECODABLE)
            {
                if (decomposerResult[i].opcode == I_CALL || decomposerResult[i].opcode == I_CALL_FAR)
                {
                    *callSize = decomposerResult[i].size;
                    return (DWORD)((DWORD_PTR)decomposerResult[i].addr - (DWORD_PTR)data);
                }
            }
        }

    }

    return 0;
}

ULONG_PTR FindPattern(ULONG_PTR base, ULONG size, const UCHAR* pattern, ULONG patternSize)
{
    for (PUCHAR Address = (PUCHAR)base; Address < (PUCHAR)(base + size - patternSize); ++Address)
    {
        ULONG i;
        for (i = 0; i < patternSize; ++i)
        {
            if (pattern[i] != 0xCC && (*(Address + i) != pattern[i]))
                break;
        }

        if (i == patternSize)
            return (ULONG_PTR)Address;
    }
    return 0;
}

BYTE KiFastSystemCallWow64Backup[7] = { 0 };
DWORD KiFastSystemCallWow64Address = 0; // In wow64cpu.dll, named X86SwitchTo64BitMode prior to Windows 8

void * DetourCreateRemoteWow64(void * hProcess, bool createTramp)
{
    PBYTE trampoline = nullptr;
    DWORD protect;
    bool onceNativeCallContinueWasSet = onceNativeCallContinue;
    onceNativeCallContinue = true;

    // NtQueryInformationProcess on Windows 10 under sysWow64 has an irregular structure, this is a call at +4 or bytes from itself
    // Another case for Windows 10 is 'call $+5'
    bool bSpecialSyscallStructure = (originalBytes[5] == 0xE8 && (originalBytes[6] == 0x04 || originalBytes[6] == 0x00));

    // We're "borrowing" another api's code as a template, the ret must match
    if (bSpecialSyscallStructure)
    {
        //g_log.LogDebug(L"NtQueryInformationProcess Windows 10 detected");

        BYTE syscallAddressBytes[5];	// save syscall id eg. Mov eax, 0x19

        memcpy(syscallAddressBytes, originalBytes, sizeof(syscallAddressBytes));			// Copy the syscall id bytes

        //g_log.LogDebug(L"syscallAddressBytes: %x", syscallAddressBytes);

        // This is a "normal" function and both have a ret 14
        DWORD ntQueryKey = (DWORD)GetProcAddress(GetModuleHandleA("ntdll"), "NtQueryKey");

        //g_log.LogDebug(L"NtQueryKey address: %x", ntQueryKey);

        ReadProcessMemory(hProcess, (LPCVOID)ntQueryKey, &originalBytes, sizeof(originalBytes), 0);
        ReadProcessMemory(hProcess, (LPCVOID)ntQueryKey, &changedBytes, sizeof(originalBytes), 0);

        memcpy(originalBytes, syscallAddressBytes, sizeof(syscallAddressBytes));
        memcpy(changedBytes, syscallAddressBytes, sizeof(syscallAddressBytes));
    }

    DWORD funcSize = GetFunctionSizeRETN(originalBytes, sizeof(originalBytes));
    DWORD callSize = 0;
    DWORD callOffset = GetCallOffset(originalBytes, sizeof(originalBytes), &callSize);

    if (!onceNativeCallContinueWasSet)
    {
        if (NtCurrentPeb()->OSBuildNumber >= 14393) // Windows 10 >= RS1?
        {
            // ntdll32!Wow64Transition will point to wow64cpu!KiFastSystemCall in 99% of cases. However, it is possible that the process
            // has the 'prohibit dynamic code execution' mitigation enabled, in which case it will point to the no fun allowed version
            // wow64cpu!KiFastSystemCall2, which pushes the x64 segment selector on the stack to do a jmp far fword ptr [esp] (FF 2C 24).
            // Hooking KiFastSystemCall2 is pointless because ScyllaHide is mega incompatible with the entire mitigation policy anyway due to its many RWX allocations.
            PVOID* pWow64Transition = (PVOID*)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "Wow64Transition");
            ULONG Wow64Transition = 0;
            if (pWow64Transition != nullptr &&
                ReadProcessMemory(hProcess, pWow64Transition, &Wow64Transition, sizeof(Wow64Transition), nullptr) &&
                Wow64Transition != 0)
            {
                if (((PUCHAR)Wow64Transition)[0] != 0xEA)
                {
                    MessageBoxA(nullptr, "Wow64Transition[0] != 0xEA! The process is probably prohibiting dynamic code execution.", "ScyllaHide", MB_ICONERROR);
                    return nullptr;
                }

                KiFastSystemCallWow64Address = Wow64Transition;
            }
        }

        if (KiFastSystemCallWow64Address == 0)
        {
            ULONG64 Wow64cpu = (ULONG64)scl::Wow64GetModuleHandle64(hProcess, L"wow64cpu.dll");
            if (Wow64cpu == 0 || Wow64cpu > (ULONG32)Wow64cpu) // wow64cpu.dll should always be below 4GB
            {
                MessageBoxA(nullptr, "Failed to obtain address of wow64cpu.dll!", "ScyllaHide", MB_ICONERROR);
                return nullptr;
            }

            // EA XXXXXXXX 3300
            // ^ absolute non-indirect far jmp
            //    ^ 32 bit address
            //             ^ x64 cs segment selector
            constexpr UCHAR Wow64FarJmpPattern[] = { 0xEA, 0xCC, 0xCC, 0xCC, 0xCC, (UCHAR)(KGDT64_R3_CODE | RPL_MASK), 0x00 };

            PIMAGE_NT_HEADERS64 NtHeaders64 = (PIMAGE_NT_HEADERS64)RtlImageNtHeader((PVOID)Wow64cpu);
            PIMAGE_SECTION_HEADER TextSection = IMAGE_FIRST_SECTION(NtHeaders64);
            KiFastSystemCallWow64Address = (ULONG)FindPattern((ULONG_PTR)Wow64cpu + TextSection->VirtualAddress,
                NtHeaders64->OptionalHeader.SizeOfImage - TextSection->Misc.VirtualSize, Wow64FarJmpPattern, sizeof(Wow64FarJmpPattern));
            if (KiFastSystemCallWow64Address == 0)
            {
                // For when you're debugging the debugger and forget to turn off your own hooks...
                constexpr UCHAR Wow64FarJmpIntoX86Pattern[] = { 0xEA, 0xCC, 0xCC, 0xCC, 0xCC, (UCHAR)(KGDT64_R3_CMCODE | RPL_MASK), 0x00 };
                KiFastSystemCallWow64Address = (ULONG)FindPattern((ULONG_PTR)Wow64cpu + TextSection->VirtualAddress,
                    NtHeaders64->OptionalHeader.SizeOfImage - TextSection->Misc.VirtualSize, Wow64FarJmpIntoX86Pattern, sizeof(Wow64FarJmpIntoX86Pattern));
            }
                
            if (KiFastSystemCallWow64Address == 0)
            {
                MessageBoxA(nullptr, "Failed to find KiFastSystemCall/X86SwitchTo64BitMode in wow64cpu.dll!", "ScyllaHide", MB_ICONERROR);
                return nullptr;
            }
        }

        if (ReadProcessMemory(hProcess, (void*)KiFastSystemCallWow64Address, KiFastSystemCallWow64Backup, sizeof(KiFastSystemCallWow64Backup), nullptr))
        {
            if (KiFastSystemCallWow64Backup[5] == (KGDT64_R3_CMCODE | RPL_MASK))
            {
                // PENDING: it should be safe to just undo this since we are likely the only ones using this retarded 'far jmp into x86' type hook
                //fatalAlreadyHookedFailure = true;
                MessageBoxA(nullptr, "KiFastSystemCall/X86SwitchTo64BitMode in wow64cpu.dll is already hooked! Trying to salvage this...", "ScyllaHide", MB_ICONWARNING);
                //return nullptr;

                KiFastSystemCallWow64Backup[5] = (KGDT64_R3_CODE | RPL_MASK);
            }

            NativeCallContinue = VirtualAllocEx(hProcess, nullptr, sizeof(KiFastSystemCallWow64Backup), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (!WriteProcessMemory(hProcess, NativeCallContinue, KiFastSystemCallWow64Backup, sizeof(KiFastSystemCallWow64Backup), nullptr))
            {
                MessageBoxA(nullptr, "Failed to write NativeCallContinue routine", "ScyllaHide", MB_ICONERROR);
                return nullptr;
            }
            VirtualProtectEx(hProcess, NativeCallContinue, sizeof(KiFastSystemCallWow64Backup), PAGE_EXECUTE_READ, &protect);
        }
        else
        {
            MessageBoxA(nullptr, "Failed to read KiFastSystemCall/X86SwitchTo64BitMode bytes in wow64cpu.dll", "ScyllaHide", MB_ICONERROR);
            return nullptr;
        }
    }

    if (funcSize != 0 && createTramp)
    {
        trampoline = (PBYTE)VirtualAllocEx(hProcess, nullptr, sizeof(changedBytes), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (trampoline == nullptr)
            return nullptr;

        changedBytes[callOffset] = 0x68; //PUSH
        *((DWORD*)&changedBytes[callOffset + 1]) = ((DWORD)trampoline + (DWORD)callOffset + 5 + 7);
        memcpy(changedBytes + callOffset + 5, KiFastSystemCallWow64Backup, sizeof(KiFastSystemCallWow64Backup));

        memcpy(changedBytes + callOffset + 5 + sizeof(KiFastSystemCallWow64Backup), originalBytes + callOffset + callSize, funcSize - callOffset - callSize);

        WriteProcessMemory(hProcess, trampoline, changedBytes, sizeof(changedBytes), nullptr);
        VirtualProtectEx(hProcess, trampoline, sizeof(changedBytes), PAGE_EXECUTE_READ, &protect);
    }

    if (!onceNativeCallContinueWasSet)
    {
        if (VirtualProtectEx(hProcess, (void *)KiFastSystemCallWow64Address, detourLenWow64FarJmp, PAGE_EXECUTE_READWRITE, &protect))
        {
            // Write a faux WOW64 transition far jmp with disregard for space used
            UCHAR jumperBytes[detourLenWow64FarJmp];
            RtlZeroMemory(jumperBytes, sizeof(jumperBytes));
            WriteWow64Jumper((PBYTE)HookedNativeCallInternal, jumperBytes);
            if (!WriteProcessMemory(hProcess, (void *)KiFastSystemCallWow64Address, jumperBytes, detourLenWow64FarJmp, nullptr))
            {
                MessageBoxA(nullptr, "Failed to write KiFastSystemCall/X86SwitchTo64BitMode replacement to wow64cpu.dll", "ScyllaHide", MB_ICONERROR);
            }

            VirtualProtectEx(hProcess, (void *)KiFastSystemCallWow64Address, detourLenWow64FarJmp, protect, &protect);
        }
        else
        {
            MessageBoxA(nullptr, "Failed to unprotect KiFastSystemCall/X86SwitchTo64BitMode in wow64cpu.dll", "ScyllaHide", MB_ICONERROR);
        }
    }

    return trampoline;
}

//7C91E4F0 ntdll.KiFastSystemCall  EB F9   JMP 7C91E4EB

BYTE KiFastSystemCallJmpPatch[] = { 0xE9, 0x00, 0x00, 0x00, 0x00, 0xEB, 0xF9 };
BYTE KiFastSystemCallBackup[20] = { 0 };
DWORD KiFastSystemCallAddress = 0;
DWORD KiFastSystemCallBackupSize = 0;

void * DetourCreateRemoteX86(void * hProcess, bool createTramp)
{
    PBYTE trampoline = 0;
    DWORD protect;

    DWORD funcSize = GetFunctionSizeRETN(originalBytes, sizeof(originalBytes));

    DWORD callSize = 0;
    DWORD callOffset = GetCallOffset(originalBytes, sizeof(originalBytes), &callSize);
    KiFastSystemCallAddress = GetCallDestination(hProcess, originalBytes, sizeof(originalBytes));

    if (!onceNativeCallContinue)
    {
        ReadProcessMemory(hProcess, (void*)KiFastSystemCallAddress, KiFastSystemCallBackup, sizeof(KiFastSystemCallBackup), 0);
        KiFastSystemCallBackupSize = GetFunctionSizeRETN(KiFastSystemCallBackup, sizeof(KiFastSystemCallBackup));
        if (KiFastSystemCallBackupSize)
        {
            NativeCallContinue = VirtualAllocEx(hProcess, 0, KiFastSystemCallBackupSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (NativeCallContinue)
            {
                WriteProcessMemory(hProcess, NativeCallContinue, KiFastSystemCallBackup, KiFastSystemCallBackupSize, 0);
                VirtualProtectEx(hProcess, NativeCallContinue, sizeof(KiFastSystemCallBackupSize), PAGE_EXECUTE_READ, &protect);
            }
            else
            {
                MessageBoxA(nullptr, "DetourCreateRemoteX86 -> NativeCallContinue", "ScyllaHide", MB_ICONERROR);
            }
        }
        else
        {
            MessageBoxA(nullptr, "DetourCreateRemoteX86 -> KiSystemCallBackupSize", "ScyllaHide", MB_ICONERROR);
        }
    }

    if (funcSize && createTramp)
    {
        trampoline = (PBYTE)VirtualAllocEx(hProcess, nullptr, sizeof(changedBytes), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (!trampoline)
            return nullptr;

        changedBytes[callOffset] = 0x68; //PUSH
        *((DWORD*)&changedBytes[callOffset + 1]) = ((DWORD)trampoline + (DWORD)callOffset + 5 + KiFastSystemCallBackupSize);
        memcpy(changedBytes + callOffset + 5, KiFastSystemCallBackup, KiFastSystemCallBackupSize);

        memcpy(changedBytes + callOffset + 5 + KiFastSystemCallBackupSize, originalBytes + callOffset + callSize, funcSize - callOffset - callSize);

        WriteProcessMemory(hProcess, trampoline, changedBytes, sizeof(changedBytes), 0);
        VirtualProtectEx(hProcess, trampoline, sizeof(changedBytes), PAGE_EXECUTE_READ, &protect);
    }

    if (!onceNativeCallContinue)
    {
        DWORD_PTR patchAddr = (DWORD_PTR)KiFastSystemCallAddress - 5;

        if (VirtualProtectEx(hProcess, (void *)patchAddr, 5 + 2, PAGE_EXECUTE_READWRITE, &protect))
        {
            WriteJumper((PBYTE)patchAddr, (PBYTE)HookedNativeCallInternal, KiFastSystemCallJmpPatch, false);
            WriteProcessMemory(hProcess, (void *)patchAddr, KiFastSystemCallJmpPatch, 5 + 2, 0);

            VirtualProtectEx(hProcess, (void *)patchAddr, 5 + 2, protect, &protect);
        }
        onceNativeCallContinue = true;
    }

    return trampoline;
}

void * DetourCreateRemote32(void * hProcess, const char* funcName, void * lpFuncOrig, void * lpFuncDetour, bool createTramp, unsigned long * backupSize)
{
    if (!scl::IsWow64Process(hProcess))
    {
        // Handle special cases on native x86 where hooks should be placed inside the function and not at KiFastSystemCall.
        // TODO: why does DetourCreateRemoteX86 even exist? DetourCreateRemote works fine on any OS
        if (scl::GetWindowsVersion() >= scl::OS_WIN_8)
        {
            // The native x86 syscall structure was changed in Windows 8. https://github.com/x64dbg/ScyllaHide/issues/49
            return DetourCreateRemote(hProcess, funcName, lpFuncOrig, lpFuncDetour, createTramp, backupSize);
        }

        if (g_settings.profile_name().find(L"Obsidium") != std::wstring::npos)
        {
            // This is an extremely lame hack because Obsidium doesn't like where we put our hooks
            return DetourCreateRemote(hProcess, funcName, lpFuncOrig, lpFuncDetour, createTramp, backupSize);
        }
    }

    if (fatalFindSyscallIndexFailure || fatalAlreadyHookedFailure)
        return nullptr; // Don't spam user with repeated error message boxes

    memset(changedBytes, 0x90, sizeof(changedBytes));
    memset(originalBytes, 0x90, sizeof(originalBytes));

    if (!ReadProcessMemory(hProcess, lpFuncOrig, originalBytes, sizeof(originalBytes), nullptr))
    {
        MessageBoxA(nullptr, "DetourCreateRemoteX86->ReadProcessMemory failed.", "ScyllaHide", MB_ICONERROR);
        return nullptr;
    }

    ClearSyscallBreakpoint(funcName, originalBytes);

    memcpy(changedBytes, originalBytes, sizeof(originalBytes));

    DWORD sysCallIndex = GetSysCallIndex32(originalBytes);

    if (sysCallIndex == (DWORD)-1)
    {
        fatalFindSyscallIndexFailure = true; // Do not attempt any more hooks after this
        char errorMessage[256];
        _snprintf_s(errorMessage, sizeof(errorMessage), sizeof(errorMessage) - sizeof(char),
            "Error: syscall index of %hs not found.\nThis can happen if the function is already hooked, or if it contains a breakpoint.", funcName);
        MessageBoxA(nullptr, errorMessage, "ScyllaHide", MB_ICONERROR);
        return nullptr;
    }

    HookNative[countNativeHooks].eaxValue = sysCallIndex;
    HookNative[countNativeHooks].ecxValue = 0;
    HookNative[countNativeHooks].hookedFunction = lpFuncDetour;

    PVOID result;
    if (!scl::IsWow64Process(hProcess))
    {
        result = DetourCreateRemoteX86(hProcess, createTramp);
    }
    else
    {
        HookNative[countNativeHooks].ecxValue = GetEcxSysCallIndex32(originalBytes, sizeof(originalBytes));
        result = DetourCreateRemoteWow64(hProcess, createTramp);
    }

    countNativeHooks++;

    return result;
}

#endif

void * DetourCreateRemote(void * hProcess, const char* funcName, void * lpFuncOrig, void * lpFuncDetour, bool createTramp, DWORD * backupSize)
{
    BYTE originalBytes[50] = { 0 };
    BYTE tempSpace[1000] = { 0 };
    PBYTE trampoline = 0;
    DWORD protect;

    bool success = false;

    if (fatalFindSyscallIndexFailure || fatalAlreadyHookedFailure)
        return nullptr; // Don't spam user with repeated error message boxes

    if (!ReadProcessMemory(hProcess, lpFuncOrig, originalBytes, sizeof(originalBytes), nullptr))
    {
        MessageBoxA(nullptr, "DetourCreateRemote->ReadProcessMemory failed.", "ScyllaHide", MB_ICONERROR);
        return nullptr;
    }

    ClearSyscallBreakpoint(funcName, originalBytes);

    // Note that this check will give a false negative in the case that a function is hooked *and* has a breakpoint set on it (now cleared).
    // We can clear the breakpoint or detect the hook, not both. (If the hook is ours, this is actually a hack because we should be properly unhooking)
#ifdef _WIN64
    const bool isHooked = (originalBytes[0] == 0xFF && originalBytes[1] == 0x25) ||
        (originalBytes[0] == 0x90 && originalBytes[1] == 0xFF && originalBytes[2] == 0x25);
#else
    const bool isHooked = originalBytes[0] == 0xE9;
#endif
    if (isHooked)
    {
        fatalAlreadyHookedFailure = true;
        char errorMessage[256];
        _snprintf_s(errorMessage, sizeof(errorMessage), sizeof(errorMessage) - sizeof(char),
            "Error: %hs is already hooked!", funcName);
        MessageBoxA(nullptr, errorMessage, "ScyllaHide", MB_ICONERROR);
        return nullptr;
    }

    int detourLen = GetDetourLen(originalBytes, minDetourLen);

    if (createTramp)
    {
        *backupSize = detourLen;

        trampoline = (PBYTE)VirtualAllocEx(hProcess, 0, detourLen + minDetourLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (!trampoline)
            return 0;

        WriteProcessMemory(hProcess, trampoline, originalBytes, detourLen, 0);

        ZeroMemory(tempSpace, sizeof(tempSpace));
        WriteJumper(trampoline + detourLen, (PBYTE)lpFuncOrig + detourLen, tempSpace, false);
        WriteProcessMemory(hProcess, trampoline + detourLen, tempSpace, minDetourLen, 0);
        VirtualProtectEx(hProcess, trampoline, detourLen + minDetourLen, PAGE_EXECUTE_READ, &protect);
    }

    if (VirtualProtectEx(hProcess, lpFuncOrig, detourLen, PAGE_EXECUTE_READWRITE, &protect))
    {
        ZeroMemory(tempSpace, sizeof(tempSpace));
        WriteJumper((PBYTE)lpFuncOrig, (PBYTE)lpFuncDetour, tempSpace, scl::IsWindows64() && !scl::IsWow64Process(NtCurrentProcess));
        WriteProcessMemory(hProcess, lpFuncOrig, tempSpace, minDetourLen, 0);

        VirtualProtectEx(hProcess, lpFuncOrig, detourLen, protect, &protect);
        success = true;
    }

    if (createTramp)
    {
        if (!success)
        {
            VirtualFree(trampoline, 0, MEM_RELEASE);
            trampoline = 0;
        }
        return trampoline;
    }
    else
    {
        return 0;
    }
}

void * DetourCreate(void * lpFuncOrig, void * lpFuncDetour, bool createTramp)
{
    PBYTE trampoline = 0;
    DWORD protect;

    bool success = false;

    int detourLen = GetDetourLen(lpFuncOrig, minDetourLen);

    if (createTramp)
    {
        trampoline = (PBYTE)VirtualAlloc(0, detourLen + minDetourLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (!trampoline)
            return 0;

        memcpy(trampoline, lpFuncOrig, detourLen);
        WriteJumper(trampoline + detourLen, (PBYTE)lpFuncOrig + detourLen);
        VirtualProtect(trampoline, detourLen + minDetourLen, PAGE_EXECUTE_READ, &protect);
    }


    if (VirtualProtect(lpFuncOrig, detourLen, PAGE_EXECUTE_READWRITE, &protect))
    {
        WriteJumper((PBYTE)lpFuncOrig, (PBYTE)lpFuncDetour);

        VirtualProtect(lpFuncOrig, detourLen, protect, &protect);
        success = true;
    }

    if (createTramp)
    {
        if (!success)
        {
            VirtualFree(trampoline, 0, MEM_RELEASE);
            trampoline = 0;
        }
        return trampoline;
    }
    else
    {
        return 0;
    }
}

int GetDetourLen(const void * lpStart, const int minSize)
{
    int totalLen = 0;
    unsigned char * lpDataPos = (unsigned char *)lpStart;

    while (totalLen < minSize)
    {
        int len = (int)LengthDisassemble((void *)lpDataPos);
        if (len < 1) //len < 1 will cause infinite loops
            len = 1;
        lpDataPos += len;
        totalLen += len;
    }

    return totalLen;
}

int LengthDisassemble(LPVOID DisassmAddress)
{
    unsigned int DecodedInstructionsCount = 0;
    _CodeInfo decomposerCi = { 0 };
    _DInst decomposerResult[1] = { 0 };

    decomposerCi.code = (BYTE *)DisassmAddress;
    decomposerCi.codeLen = MAXIMUM_INSTRUCTION_SIZE;
    decomposerCi.dt = DecodingType;
    decomposerCi.codeOffset = (LONG_PTR)DisassmAddress;

    if (distorm_decompose(&decomposerCi, decomposerResult, _countof(decomposerResult), &DecodedInstructionsCount) != DECRES_INPUTERR)
    {
        if (decomposerResult[0].flags != FLAG_NOT_DECODABLE)
        {
            return decomposerResult[0].size;
        }
    }

    return -1; //this is dangerous
}



================================================
File: InjectorCLI/RemoteHook.h
================================================
#pragma once


#define MAXIMUM_INSTRUCTION_SIZE (16) //maximum instruction size == 16

int GetDetourLen(const void * lpStart, const int minSize);
void WriteJumper(unsigned char * lpbFrom, unsigned char * lpbTo);
void * DetourCreate(void * lpFuncOrig, void * lpFuncDetour, bool createTramp);
void * DetourCreateRemote(void * hProcess, const char* funcName, void * lpFuncOrig, void * lpFuncDetour, bool createTramp, unsigned long * backupSize);

#ifdef _WIN64
#define DetourCreateRemoteNative DetourCreateRemote
#else
void * DetourCreateRemote32(void * hProcess, const char* funcName, void * lpFuncOrig, void * lpFuncDetour, bool createTramp, unsigned long * backupSize);
void * DetourCreateRemoteWow64(void * hProcess, bool createTramp);

#define DetourCreateRemoteNative DetourCreateRemote32
#endif

int LengthDisassemble(void* DisassmAddress);



================================================
File: InjectorCLI/resource.h
================================================
[Non-text file]


================================================
File: PluginGeneric/AttachDialog.cpp
================================================
#include "AttachDialog.h"
#include <Psapi.h>
#include <string>

#ifdef OLLY1
#include "..\ScyllaHideOlly1Plugin\resource.h"
#elif OLLY2
#include "..\ScyllaHideOlly2Plugin\resource.h"
#include <ollydbg2/plugin.h>
#elif __IDP__
#include "..\ScyllaHideIDAProPlugin\resource.h"
#include <idp.hpp>
#elif X64DBG
#include "..\ScyllaHideX64DBGPlugin\resource.h"
#endif

#define BULLSEYE_CENTER_X_OFFSET		15
#define BULLSEYE_CENTER_Y_OFFSET		18

typedef void(__cdecl * t_AttachProcess)(DWORD dwPID);

t_AttachProcess _AttachProcess = 0;

extern HINSTANCE hinst;
#ifdef OLLY1
extern HWND hwmain; // Handle of main OllyDbg window
#elif OLLY2
HWND hwmain = hwollymain;
#elif __IDP__
HWND hwmain = (HWND)callui(ui_get_hwnd).vptr;
#elif X64DBG
extern HWND hwndDlg;
HWND hwmain;
#endif
HBITMAP hBitmapFinderToolFilled = NULL;
HBITMAP hBitmapFinderToolEmpty = NULL;
HCURSOR hCursorPrevious = NULL;
HCURSOR hCursorSearchWindow = NULL;
BOOL bStartSearchWindow = FALSE;
HWND hwndFoundWindow = NULL;
wchar_t title[256];
wchar_t pidTextHex[9];
wchar_t pidTextDec[11];
DWORD pid = NULL;

//toggles the finder image
void SetFinderToolImage(HWND hwnd, BOOL bSet)
{
    HBITMAP hBmpToSet = NULL;

    if (bSet)
    {
        hBmpToSet = hBitmapFinderToolFilled;
    }
    else
    {
        hBmpToSet = hBitmapFinderToolEmpty;
    }

    SendDlgItemMessage(hwnd, IDC_ICON_FINDER, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmpToSet);
}

//centers cursor in bullseye. adds to the illusion that the bullseye can be dragged out
void MoveCursorPositionToBullsEye(HWND hwnd)
{
    HWND hwndToolFinder = NULL;
    RECT rect;
    POINT screenpoint;

    hwndToolFinder = GetDlgItem(hwnd, IDC_ICON_FINDER);

    if (hwndToolFinder)
    {
        GetWindowRect(hwndToolFinder, &rect);
        screenpoint.x = rect.left + BULLSEYE_CENTER_X_OFFSET;
        screenpoint.y = rect.top + BULLSEYE_CENTER_Y_OFFSET;
        SetCursorPos(screenpoint.x, screenpoint.y);
    }
}

//does some sanity checks on a possible found window
BOOL CheckWindowValidity(HWND hwnd, HWND hwndToCheck)
{
    HWND hwndTemp = NULL;

    if (hwndToCheck == NULL)
    {
        return FALSE;
    }

    if (IsWindow(hwndToCheck) == FALSE)
    {
        return FALSE;
    }

    //same window as previous?
    if (hwndToCheck == hwndFoundWindow)
    {
        return FALSE;
    }

    //debugger window is not a valid one
    if (hwndToCheck == hwmain)
    {
        return FALSE;
    }

    // It also must not be the "Search Window" dialog box itself.
    if (hwndToCheck == hwnd)
    {
        return FALSE;
    }

    // It also must not be one of the dialog box's children...
    hwndTemp = GetParent(hwndToCheck);
    if ((hwndTemp == hwnd) || (hwndTemp == hwmain))
    {
        return FALSE;
    }

    hwndFoundWindow = hwndToCheck;
    return TRUE;
}

void DisplayExe(HWND hwnd, DWORD dwPid)
{
    WCHAR filepath[MAX_PATH] = { 0 };
    HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwPid);
    if (hProc)
    {
        GetModuleFileNameExW(hProc, NULL, filepath, _countof(filepath));
        CloseHandle(hProc);

        if (wcslen(filepath) > 0)
        {
            SetDlgItemTextW(hwnd, IDC_EXEPATH, wcsrchr(filepath, L'\\') + 1);
        }
        else
        {
            SetDlgItemTextW(hwnd, IDC_EXEPATH, L"UNKNOWN");
        }
    }
    else
    {
        SetDlgItemTextW(hwnd, IDC_EXEPATH, L"UNKNOWN");
    }
}

//attach dialog proc
INT_PTR CALLBACK AttachProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    wchar_t buf[20] = { 0 };

    switch (message)
    {
    case WM_INITDIALOG:
    {
#ifdef X64DBG
        hwmain = hwndDlg;
#endif

        hBitmapFinderToolFilled = LoadBitmap(hinst, MAKEINTRESOURCE(IDB_FINDERFILLED));
        hBitmapFinderToolEmpty = LoadBitmap(hinst, MAKEINTRESOURCE(IDB_FINDEREMPTY));
        hCursorSearchWindow = LoadCursor(hinst, MAKEINTRESOURCE(IDC_CURSOR_SEARCH_WINDOW));

        break;
    }
    case WM_CLOSE:
    {
        EndDialog(hWnd, NULL);
    }
    break;

    case WM_COMMAND:
    {
        switch (LOWORD(wParam)) {
        case IDOK: { //attach
            if (pid != NULL) {
                EndDialog(hWnd, NULL);

                if (_AttachProcess != 0)
                {
                    _AttachProcess(pid);
                }
                else
                {
                    MessageBoxW(0, L"Developer!!! You forgot something _AttachProcess!!!!!", L"ERROR", 0);
                }
            }
            break;
        }
        case IDCANCEL: {
            EndDialog(hWnd, NULL);
            break;
        }
        case IDC_PIDHEX: {
            if (0 < GetDlgItemTextW(hWnd, IDC_PIDHEX, buf, _countof(buf))) {
                if (wcscmp(buf, pidTextHex) != 0) {
                    wcscpy(pidTextHex, buf);
                    swscanf(pidTextHex, L"%X", &pid);
                    wsprintfW(pidTextDec, L"%d", pid);
                    SetDlgItemTextW(hWnd, IDC_PIDDEC, pidTextDec);
                    DisplayExe(hWnd, pid);
                    SetDlgItemTextW(hWnd, IDC_TITLE, L"");
                }
            }
            break;
        }
        case IDC_PIDDEC:
        {

            if (0 < GetDlgItemTextW(hWnd, IDC_PIDDEC, buf, _countof(buf))) {
                if (wcscmp(buf, pidTextDec) != 0) {
                    wcscpy(pidTextDec, buf);
                    swscanf(pidTextDec, L"%d", &pid);
                    wsprintfW(pidTextHex, L"%X", pid);
                    SetDlgItemTextW(hWnd, IDC_PIDHEX, pidTextHex);
                    DisplayExe(hWnd, pid);
                    SetDlgItemTextW(hWnd, IDC_TITLE, L"");
                }
            }
            break;
        }
        case IDC_ICON_FINDER: {
            bStartSearchWindow = TRUE;

            SetFinderToolImage(hWnd, FALSE);

            MoveCursorPositionToBullsEye(hWnd);

            // Set the screen cursor to the BullsEye cursor.
            if (hCursorSearchWindow)
            {
                hCursorPrevious = SetCursor(hCursorSearchWindow);
            }
            else
            {
                hCursorPrevious = NULL;
            }

            //redirect all mouse events to this AttachProc
            SetCapture(hWnd);

            ShowWindow(hwmain, SW_HIDE);
            break;
        }

        }

        break;
    }

    case WM_MOUSEMOVE:
    {
        if (bStartSearchWindow)
        {
            POINT screenpoint;
            HWND hwndCurrentWindow = NULL;

            GetCursorPos(&screenpoint);

            hwndCurrentWindow = WindowFromPoint(screenpoint);

            if (CheckWindowValidity(hWnd, hwndCurrentWindow))
            {
                //get some info about the window
                GetWindowThreadProcessId(hwndFoundWindow, &pid);

                DisplayExe(hWnd, pid);

                if (GetWindowTextW(hwndCurrentWindow, title, _countof(title)) > 0)
                {
                    SetDlgItemTextW(hWnd, IDC_TITLE, title);
                }
                else
                {
                    SetDlgItemTextW(hWnd, IDC_TITLE, L"");
                }

                wsprintfW(pidTextHex, L"%X", pid);
                wsprintfW(pidTextDec, L"%d", pid);
                SetDlgItemTextW(hWnd, IDC_PIDHEX, pidTextHex);
                SetDlgItemTextW(hWnd, IDC_PIDDEC, pidTextDec);

            }
        }

        break;
    }

    case WM_LBUTTONUP:
    {
        if (bStartSearchWindow)
        {
            // restore cursor
            if (hCursorPrevious)
            {
                SetCursor(hCursorPrevious);
            }

            SetFinderToolImage(hWnd, TRUE);

            // release the mouse capture.
            ReleaseCapture();

            ShowWindow(hwmain, SW_SHOWNORMAL);

            bStartSearchWindow = FALSE;
        }

        break;
    }

    default:
    {
        return FALSE;
    }
    }

    return 0;
}



================================================
File: PluginGeneric/AttachDialog.h
================================================
#pragma once
#include <windows.h>

INT_PTR CALLBACK AttachProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);



================================================
File: PluginGeneric/Injector.cpp
================================================
#include "Injector.h"
#include <Psapi.h>
#include "Scylla/Logger.h"
#include <Scylla/User32Loader.h>
#include <Scylla/OsInfo.h>
#include <Scylla/PebHider.h>
#include <Scylla/Settings.h>
#include <Scylla/Util.h>

#include "..\InjectorCLI\\ApplyHooking.h"

extern scl::Settings g_settings;
extern scl::Logger g_log;

static LPVOID remoteImageBase = 0;

typedef void(__cdecl * t_SetDebuggerBreakpoint)(DWORD_PTR address);
t_SetDebuggerBreakpoint _SetDebuggerBreakpoint = 0;

//anti-attach vars
DWORD ExitThread_addr;
BYTE* DbgUiIssueRemoteBreakin_addr;
DWORD jmpback;
DWORD DbgUiRemoteBreakin_addr;
BYTE* RemoteBreakinPatch;
BYTE OllyRemoteBreakInReplacement[8];
HANDLE hDebuggee;

void ReadNtApiInformation(HOOK_DLL_DATA *hdd)
{
    scl::User32Loader user32Loader;
    if (!user32Loader.FindSyscalls({
        "NtUserBlockInput",
        "NtUserBuildHwndList",
        "NtUserFindWindowEx",
        "NtUserQueryWindow",
        "NtUserGetForegroundWindow",
        "NtUserGetClassName",
        "NtUserInternalGetWindowText",
        "NtUserGetThreadState" }))
    {
        g_log.LogError(L"Failed to find user32.dll/win32u.dll syscalls!");
        return;
    }

    hdd->NtUserBlockInputVA = user32Loader.GetUserSyscallVa("NtUserBlockInput");
    hdd->NtUserQueryWindowVA = user32Loader.GetUserSyscallVa("NtUserQueryWindow");
    hdd->NtUserGetForegroundWindowVA = user32Loader.GetUserSyscallVa("NtUserGetForegroundWindow");
    hdd->NtUserBuildHwndListVA = user32Loader.GetUserSyscallVa("NtUserBuildHwndList");
    hdd->NtUserFindWindowExVA = user32Loader.GetUserSyscallVa("NtUserFindWindowEx");
    hdd->NtUserGetClassNameVA = user32Loader.GetUserSyscallVa("NtUserGetClassName");
    hdd->NtUserInternalGetWindowTextVA = user32Loader.GetUserSyscallVa("NtUserInternalGetWindowText");
    hdd->NtUserGetThreadStateVA = user32Loader.GetUserSyscallVa("NtUserGetThreadState");

    g_log.LogInfo(L"Loaded VA for NtUserBlockInput = 0x%p", hdd->NtUserBlockInputVA);
    g_log.LogInfo(L"Loaded VA for NtUserQueryWindow = 0x%p", hdd->NtUserQueryWindowVA);
    g_log.LogInfo(L"Loaded VA for NtUserGetForegroundWindow = 0x%p", hdd->NtUserGetForegroundWindowVA);
    g_log.LogInfo(L"Loaded VA for NtUserBuildHwndList = 0x%p", hdd->NtUserBuildHwndListVA);
    g_log.LogInfo(L"Loaded VA for NtUserFindWindowEx = 0x%p", hdd->NtUserFindWindowExVA);
    g_log.LogInfo(L"Loaded VA for NtUserGetClassName = 0x%p", hdd->NtUserGetClassNameVA);
    g_log.LogInfo(L"Loaded VA for NtUserInternalGetWindowText = 0x%p", hdd->NtUserInternalGetWindowTextVA);
    g_log.LogInfo(L"Loaded VA for NtUserGetThreadState = 0x%p", hdd->NtUserGetThreadStateVA);
}

#ifndef _WIN64
void __declspec(naked) handleAntiAttach()
{
    _asm {
        push ebp //stolen bytes
        mov ebp, esp //stolen bytes
        pushad
        mov eax, dword ptr[ebp + 0x8]
        mov hDebuggee, eax
    }

    //write our RemoteBreakIn patch to target memory
    RemoteBreakinPatch = (BYTE*)VirtualAllocEx(hDebuggee, 0, sizeof(OllyRemoteBreakInReplacement), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hDebuggee, (LPVOID)RemoteBreakinPatch, OllyRemoteBreakInReplacement, sizeof(OllyRemoteBreakInReplacement), NULL);

    //find push ntdll.DbgUiRemoteBreakin and patch our patch function addr there
    while (*(DWORD*)DbgUiIssueRemoteBreakin_addr != DbgUiRemoteBreakin_addr) {
        DbgUiIssueRemoteBreakin_addr++;
    }
    WriteProcessMemory(GetCurrentProcess(), DbgUiIssueRemoteBreakin_addr, &RemoteBreakinPatch, 4, NULL);
    ULONG oldProtect;
    VirtualProtectEx(hDebuggee, RemoteBreakinPatch, sizeof(OllyRemoteBreakInReplacement), PAGE_EXECUTE_READ, &oldProtect);

    _asm {
        popad
        mov eax, jmpback
        jmp eax
    }
}
#endif

void InstallAntiAttachHook()
{
#ifndef _WIN64
    HANDLE hOlly = GetCurrentProcess();

    DbgUiIssueRemoteBreakin_addr = (BYTE*)GetProcAddress(GetModuleHandleA("ntdll.dll"), "DbgUiIssueRemoteBreakin");
    DbgUiRemoteBreakin_addr = (DWORD)GetProcAddress(GetModuleHandleA("ntdll.dll"), "DbgUiRemoteBreakin");
    ExitThread_addr = (DWORD)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ExitThread");
    jmpback = (DWORD)DbgUiIssueRemoteBreakin_addr;
    jmpback += 5;

    BYTE jmp[1] = { 0xE9 };
    WriteProcessMemory(hOlly, DbgUiIssueRemoteBreakin_addr, &jmp, sizeof(jmp), NULL);
    DWORD patch = (DWORD)handleAntiAttach;
    patch -= (DWORD)DbgUiIssueRemoteBreakin_addr;
    patch -= 5;
    WriteProcessMemory(hOlly, DbgUiIssueRemoteBreakin_addr + 1, &patch, 4, NULL);

    //init our remote breakin patch
    BYTE* p = &OllyRemoteBreakInReplacement[0];
    *p = 0xCC;  //int3
    p++;
    *p = 0x68;  //push
    p++;
    *(DWORD*)(p) = ExitThread_addr;
    p += 4;
    *p = 0xC3; //retn
#endif
}

bool StartFixBeingDebugged(DWORD targetPid, bool setToNull)
{
    scl::Handle hProcess(OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, 0, targetPid));
    if (!hProcess.get())
        return false;

    auto peb = scl::GetPeb(hProcess.get());
    if (!peb)
        return false;

    peb->BeingDebugged = setToNull ? FALSE : TRUE;
    if (!scl::SetPeb(hProcess.get(), peb.get()))
        return false;

    if (scl::IsWow64Process(hProcess.get()))
    {
        auto peb64 = scl::Wow64GetPeb64(hProcess.get());
        if (!peb64)
            return false;

        peb->BeingDebugged = setToNull ? FALSE : TRUE;
        if (!scl::Wow64SetPeb64(hProcess.get(), peb64.get()))
            return false;
    }

    return true;
}

static bool GetProcessInfo(HANDLE hProcess, PPROCESS_SUSPEND_INFO processInfo)
{
    PROCESS_BASIC_INFORMATION basicInfo = { 0 };
    NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &basicInfo, sizeof(basicInfo), nullptr);
    if (!NT_SUCCESS(status))
        return false;
    ULONG size;
    status = NtQuerySystemInformation(SystemProcessInformation, nullptr, 0, &size);
    if (status != STATUS_INFO_LENGTH_MISMATCH)
        return false;
    const PSYSTEM_PROCESS_INFORMATION systemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, 2 * size);
    if (systemProcessInfo == nullptr)
        return false;
    status = NtQuerySystemInformation(SystemProcessInformation, systemProcessInfo, 2 * size, nullptr);
    if (!NT_SUCCESS(status))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, systemProcessInfo);
        return false;
    }

    // Count threads
    ULONG numThreads = 0;
    PSYSTEM_PROCESS_INFORMATION entry = systemProcessInfo;

    while (true)
    {
        if (entry->UniqueProcessId == basicInfo.UniqueProcessId)
        {
            numThreads = entry->NumberOfThreads;
            break;
        }
        if (entry->NextEntryOffset == 0)
            break;
        entry = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)entry + entry->NextEntryOffset);
    }

    if (numThreads == 0)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, systemProcessInfo);
        return false;
    }

    // Fill process info
    processInfo->ProcessId = basicInfo.UniqueProcessId;
    processInfo->ProcessHandle = hProcess;
    processInfo->NumThreads = numThreads;

    // Fill thread IDs
    processInfo->ThreadSuspendInfo = (PTHREAD_SUSPEND_INFO)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, numThreads * sizeof(THREAD_SUSPEND_INFO));
    for (ULONG i = 0; i < numThreads; ++i)
    {
        processInfo->ThreadSuspendInfo[i].ThreadId = entry->Threads[i].ClientId.UniqueThread;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, systemProcessInfo);
    return true;
}

// NtSuspendProcess does not return STATUS_SUSPEND_COUNT_EXCEEDED (or any other error) when one or more thread(s) in the process is/are at the suspend limit.
// This replacement suspends all threads in a process, storing the individual thread suspend statuses. True is returned iff all threads are suspended.
bool SafeSuspendProcess(HANDLE hProcess, PPROCESS_SUSPEND_INFO suspendInfo)
{
    // Get process info
    if (!GetProcessInfo(hProcess, suspendInfo))
        return false;

    for (ULONG i = 0; i < suspendInfo->NumThreads; ++i)
    {
        PTHREAD_SUSPEND_INFO threadSuspendInfo = &suspendInfo->ThreadSuspendInfo[i];
        OBJECT_ATTRIBUTES objectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES((PUNICODE_STRING)nullptr, 0);
        CLIENT_ID clientId = { suspendInfo->ProcessId, suspendInfo->ThreadSuspendInfo[i].ThreadId };

        // Open the thread by thread ID
        NTSTATUS status = NtOpenThread(&threadSuspendInfo->ThreadHandle, THREAD_SUSPEND_RESUME, &objectAttributes, &clientId);
        if (!NT_SUCCESS(status))
        {
            RtlFreeHeap(RtlProcessHeap(), 0, suspendInfo->ThreadSuspendInfo);
            return false;
        }

        // Suspend the thread, ignoring (but saving) STATUS_SUSPEND_COUNT_EXCEEDED errors
        threadSuspendInfo->SuspendStatus = NtSuspendThread(threadSuspendInfo->ThreadHandle, nullptr);
        if (!NT_SUCCESS(threadSuspendInfo->SuspendStatus) && threadSuspendInfo->SuspendStatus != STATUS_SUSPEND_COUNT_EXCEEDED)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, suspendInfo->ThreadSuspendInfo);
            return false;
        }
    }

    return true;
}

// Replacement for NtResumeProcess, to be used with info obtained from a prior call to SafeSuspendProcess
bool SafeResumeProcess(PPROCESS_SUSPEND_INFO suspendInfo)
{
    bool success = true;

    for (ULONG i = 0; i < suspendInfo->NumThreads; ++i)
    {
        if (NT_SUCCESS(suspendInfo->ThreadSuspendInfo[i].SuspendStatus) &&
            !NT_SUCCESS(NtResumeThread(suspendInfo->ThreadSuspendInfo[i].ThreadHandle, nullptr)))
            success = false;
        if (!NT_SUCCESS(NtClose(suspendInfo->ThreadSuspendInfo[i].ThreadHandle)))
            success = false;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, suspendInfo->ThreadSuspendInfo);
    return success;
}

bool StartHooking(HANDLE hProcess, HOOK_DLL_DATA *hdd, BYTE * dllMemory, DWORD_PTR imageBase)
{
    hdd->dwProtectedProcessId = GetCurrentProcessId();
    hdd->EnableProtectProcessId = TRUE;

    DWORD peb_flags = 0;
    if (g_settings.opts().fixPebBeingDebugged)
        peb_flags |= PEB_PATCH_BeingDebugged;
    if (g_settings.opts().fixPebHeapFlags)
        peb_flags |= PEB_PATCH_HeapFlags;
    if (g_settings.opts().fixPebNtGlobalFlag)
        peb_flags |= PEB_PATCH_NtGlobalFlag;
    if (g_settings.opts().fixPebStartupInfo)
        peb_flags |= PEB_PATCH_ProcessParameters;
    if (g_settings.opts().fixPebOsBuildNumber)
        peb_flags |= PEB_PATCH_OsBuildNumber;

    ApplyPEBPatch(hProcess, peb_flags);
    if (g_settings.opts().fixPebOsBuildNumber)
        ApplyNtdllVersionPatch(hProcess);

    if (dllMemory == nullptr || imageBase == 0)
        return peb_flags != 0; // Not injecting hook DLL

    return ApplyHook(hdd, hProcess, dllMemory, imageBase);
}

void startInjectionProcess(HANDLE hProcess, HOOK_DLL_DATA *hdd, BYTE * dllMemory, bool newProcess)
{
    PROCESS_SUSPEND_INFO suspendInfo;
    if (!SafeSuspendProcess(hProcess, &suspendInfo))
        return;

    const bool injectDll = g_settings.hook_dll_needed() || hdd->isNtdllHooked || hdd->isKernel32Hooked || hdd->isUserDllHooked;

    DWORD hookDllDataAddressRva = GetDllFunctionAddressRVA(dllMemory, "HookDllData");

    if (!newProcess)
    {
        //g_log.Log(L"Apply hooks again");
        if (injectDll && StartHooking(hProcess, hdd, dllMemory, (DWORD_PTR)remoteImageBase))
        {
            WriteProcessMemory(hProcess, (LPVOID)((DWORD_PTR)hookDllDataAddressRva + (DWORD_PTR)remoteImageBase), hdd, sizeof(HOOK_DLL_DATA), 0);
        }
        else if (!injectDll)
        {
            StartHooking(hProcess, hdd, nullptr, 0);
        }
    }
    else
    {
        if (g_settings.opts().removeDebugPrivileges)
        {
            RemoveDebugPrivileges(hProcess);
        }

        RestoreHooks(hdd, hProcess);

        if (injectDll)
        {
            remoteImageBase = MapModuleToProcess(hProcess, dllMemory, true);
            if (remoteImageBase)
            {
                FillHookDllData(hProcess, hdd);

                if (StartHooking(hProcess, hdd, dllMemory, (DWORD_PTR)remoteImageBase) &&
                    WriteProcessMemory(hProcess, (LPVOID)((DWORD_PTR)hookDllDataAddressRva + (DWORD_PTR)remoteImageBase), hdd, sizeof(HOOK_DLL_DATA), 0))
                {
                    g_log.LogInfo(L"Hook injection successful, image base %p", remoteImageBase);
                }
                else
                {
                    g_log.LogError(L"Failed to write hook dll data");
                }
            }
            else
            {
                g_log.LogError(L"Failed to map image!");
            }
        }
        else
        {
            if (StartHooking(hProcess, hdd, nullptr, 0))
                g_log.LogInfo(L"PEB patch successful, hook injection not needed\n");
        }
    }

    SafeResumeProcess(&suspendInfo);
}

void startInjection(DWORD targetPid, HOOK_DLL_DATA *hdd, const WCHAR * dllPath, bool newProcess)
{
    HANDLE hProcess = OpenProcess( PROCESS_SUSPEND_RESUME | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION,
        0, targetPid);
    if (hProcess)
    {
        BYTE * dllMemory = ReadFileToMemory(dllPath);
        if (dllMemory)
        {
            startInjectionProcess(hProcess, hdd, dllMemory, newProcess);
            free(dllMemory);
        }
        else
        {
            g_log.LogError(L"Cannot find %s", dllPath);
            MessageBoxW(nullptr, L"Failed to load ScyllaHide hook library DLL! Make sure it is installed correctly and has not been deleted by an anti-virus.", L"Error", MB_ICONERROR);
        }
        CloseHandle(hProcess);
    }
    else
    {
        g_log.LogError(L"Cannot open process handle %d", targetPid);
    }
}

NTSTATUS CreateAndWaitForThread(HANDLE hProcess, LPTHREAD_START_ROUTINE threadStart, PVOID parameter, PHANDLE threadHandle, BOOLEAN suppressDllMains)
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    const t_NtCreateThreadEx fpNtCreateThreadEx = (t_NtCreateThreadEx)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateThreadEx");
    if (fpNtCreateThreadEx == nullptr)
    {
        // We are on XP/2003 - use CreateRemoteThread
        *threadHandle = CreateRemoteThread(hProcess, nullptr, 0, threadStart, parameter, CREATE_SUSPENDED, nullptr);
        if (*threadHandle != nullptr)
        {
            NtSetInformationThread(*threadHandle, ThreadHideFromDebugger, 0, 0);
            status = STATUS_SUCCESS;
        }
    }
    else
    {
        // Create sneaky thread
        status = fpNtCreateThreadEx(threadHandle,
                                    THREAD_ALL_ACCESS,
                                    nullptr,
                                    hProcess,
                                    (PUSER_THREAD_START_ROUTINE)threadStart,
                                    parameter,
                                    THREAD_CREATE_FLAGS_CREATE_SUSPENDED | THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER | (suppressDllMains ? THREAD_CREATE_FLAGS_SUPPRESS_DLLMAINS : 0),
                                    0,
                                    0,
                                    0,
                                    nullptr);
    }

    if (NT_SUCCESS(status))
    {
        // Wait for thread to exit
        SetThreadPriority(*threadHandle, THREAD_PRIORITY_TIME_CRITICAL);
        ResumeThread(*threadHandle);
        WaitForSingleObject(*threadHandle, INFINITE);
    }
    return status;
}

LPVOID NormalDllInjection(HANDLE hProcess, const WCHAR * dllPath)
{
    SIZE_T memorySize = (wcslen(dllPath) + 1) * sizeof(WCHAR);

    LPVOID remoteMemory = VirtualAllocEx(hProcess, NULL, memorySize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    LPVOID hModule = nullptr;

    if (!remoteMemory)
    {
        g_log.LogError(L"DLL INJECTION: VirtualAllocEx failed!");
        return 0;
    }

    if (WriteProcessMemory(hProcess, remoteMemory, dllPath, memorySize, 0))
    {
        HANDLE hThread;
        NTSTATUS status = CreateAndWaitForThread(hProcess, (LPTHREAD_START_ROUTINE)LoadLibraryW, remoteMemory, &hThread, FALSE);
        if (NT_SUCCESS(status))
        {
            GetExitCodeThread(hThread, (LPDWORD)&hModule);

            if (!hModule)
            {
                g_log.LogError(L"DLL INJECTION: Failed load library!");
            }

            CloseHandle(hThread);
        }
        else
        {
            g_log.LogError(L"DLL INJECTION: Failed to start thread: 0x%08X!", status);
        }
    }
    else
    {
        g_log.LogError(L"DLL INJECTION: Failed WriteProcessMemory!");
    }

    VirtualFreeEx(hProcess, remoteMemory, 0, MEM_RELEASE);

    return hModule;
}

DWORD GetAddressOfEntryPoint(BYTE * dllMemory)
{
    PIMAGE_NT_HEADERS ntHeaders = RtlImageNtHeader(dllMemory);
    return HEADER_FIELD(ntHeaders, AddressOfEntryPoint);
}

LPVOID StealthDllInjection(HANDLE hProcess, const WCHAR * dllPath, BYTE * dllMemory)
{
    LPVOID remoteImageBaseOfInjectedDll = 0;

    if (dllMemory)
    {
        remoteImageBaseOfInjectedDll = MapModuleToProcess(hProcess, dllMemory, false);
        if (remoteImageBaseOfInjectedDll)
        {

            DWORD_PTR entryPoint = (DWORD_PTR)GetAddressOfEntryPoint(dllMemory);

            if (entryPoint)
            {
                DWORD_PTR dllMain = entryPoint + (DWORD_PTR)remoteImageBaseOfInjectedDll;

                g_log.LogInfo(L"DLL INJECTION: Starting thread at RVA %p VA %p!", entryPoint, dllMain);

                HANDLE hThread;
                NTSTATUS status = CreateAndWaitForThread(hProcess, (LPTHREAD_START_ROUTINE)dllMain, remoteImageBaseOfInjectedDll, &hThread, TRUE);
                if (NT_SUCCESS(status))
                {
                    CloseHandle(hThread);
                }
                else
                {
                    g_log.LogError(L"DLL INJECTION: Failed to start thread: 0x%08X!", status);
                }
            }
        }
        else
        {
            g_log.LogError(L"DLL INJECTION: Failed to map image of %s!", dllPath);
        }
    }

    return remoteImageBaseOfInjectedDll;
}

void injectDll(DWORD targetPid, const WCHAR * dllPath)
{
    HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, 0, targetPid);
    if (hProcess == nullptr)
    {
        g_log.LogError(L"DLL INJECTION: Cannot open process handle %d", targetPid);
        return;
    }

    BYTE* dllMemory = ReadFileToMemory(dllPath);
    if (dllMemory == nullptr)
    {
        g_log.LogError(L"DLL INJECTION: Failed to read file %s!", dllPath);
        CloseHandle(hProcess);
        return;
    }

    PIMAGE_NT_HEADERS ntHeaders = RtlImageNtHeader(dllMemory);
    if (ntHeaders == nullptr)
    {
        g_log.LogError(L"DLL INJECTION: Invalid PE file %s!", dllPath);
        free(dllMemory);
        CloseHandle(hProcess);
        return;
    }

    bool processIsWow64 = scl::IsWow64Process(hProcess);
    if ((scl::IsWindows64() &&
        ((processIsWow64 && ntHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) ||
        (!processIsWow64 && ntHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64)))
        ||
        (!scl::IsWindows64() && ntHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_I386))
    {
        g_log.LogError(L"DLL INJECTION: DLL %s is of wrong bitness for process!", dllPath);
        free(dllMemory);
        CloseHandle(hProcess);
        return;
    }

    LPVOID remoteImage = nullptr;
    DWORD entryPoint = GetAddressOfEntryPoint(dllMemory);
    if (entryPoint != 0)
        g_log.LogInfo(L"DLL entry point (DllMain) RVA %X!", entryPoint);

    if (g_settings.opts().dllStealth)
    {
        g_log.LogInfo(L"Starting Stealth DLL Injection!");
        remoteImage = StealthDllInjection(hProcess, dllPath, dllMemory);
    }
    else if (g_settings.opts().dllNormal)
    {
        g_log.LogInfo(L"Starting Normal DLL Injection!");
        remoteImage = NormalDllInjection(hProcess, dllPath);
    }
    else
    {
        g_log.LogError(L"DLL INJECTION: No injection type selected!");
    }

    if (remoteImage != nullptr)
    {
        g_log.LogInfo(L"DLL INJECTION: Injection of %s successful, Imagebase %p", dllPath, remoteImage);

        if (g_settings.opts().dllUnload)
        {
            g_log.LogInfo(L"DLL INJECTION: Unloading Imagebase %p", remoteImage);

            if (g_settings.opts().dllNormal)
            {
                HANDLE hThread;
                NTSTATUS status = CreateAndWaitForThread(hProcess, (LPTHREAD_START_ROUTINE)FreeLibrary, remoteImage, &hThread, FALSE);
                if (NT_SUCCESS(status))
                {
                    CloseHandle(hThread);
                    g_log.LogInfo(L"DLL INJECTION: Unloading Imagebase %p successful", remoteImage);
                }
                else
                {
                    g_log.LogError(L"DLL INJECTION: Unloading Imagebase %p FAILED: 0x%08X", remoteImage, status);
                }
            }
            else if (g_settings.opts().dllStealth)
            {
                VirtualFreeEx(hProcess, remoteImage, 0, MEM_RELEASE);
                g_log.LogInfo(L"DLL INJECTION: Unloading Imagebase %p successful", remoteImage);
            }
        }
    }

    free(dllMemory);
    CloseHandle(hProcess);
}

BYTE * ReadFileToMemory(const WCHAR * targetFilePath)
{
    HANDLE hFile;
    DWORD dwBytesRead;
    DWORD FileSize;
    BYTE* FilePtr = 0;

    hFile = CreateFileW(targetFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        FileSize = GetFileSize(hFile, NULL);
        if (FileSize > 0)
        {
            FilePtr = (BYTE*)calloc(FileSize + 1, 1);
            if (FilePtr)
            {
                if (!ReadFile(hFile, (LPVOID)FilePtr, FileSize, &dwBytesRead, NULL))
                {
                    free(FilePtr);
                    FilePtr = 0;
                }

            }
        }
        CloseHandle(hFile);
    }

    return FilePtr;
}

void FillHookDllData(HANDLE hProcess, HOOK_DLL_DATA *hdd)
{
    hdd->EnablePebBeingDebugged = g_settings.opts().fixPebBeingDebugged;
    hdd->EnablePebHeapFlags = g_settings.opts().fixPebHeapFlags;
    hdd->EnablePebNtGlobalFlag = g_settings.opts().fixPebNtGlobalFlag;
    hdd->EnablePebStartupInfo = g_settings.opts().fixPebStartupInfo;
    hdd->EnablePebOsBuildNumber = g_settings.opts().fixPebOsBuildNumber;
    hdd->EnableOutputDebugStringHook = g_settings.opts().hookOutputDebugStringA;
    hdd->EnableNtSetInformationThreadHook = g_settings.opts().hookNtSetInformationThread;
    hdd->EnableNtQueryInformationProcessHook = g_settings.opts().hookNtQueryInformationProcess;
    hdd->EnableNtQuerySystemInformationHook = g_settings.opts().hookNtQuerySystemInformation;
    hdd->EnableNtQueryObjectHook = g_settings.opts().hookNtQueryObject;
    hdd->EnableNtYieldExecutionHook = g_settings.opts().hookNtYieldExecution;
    hdd->EnableNtCloseHook = g_settings.opts().hookNtClose;
    hdd->EnableNtCreateThreadExHook = g_settings.opts().hookNtCreateThreadEx;
    hdd->EnablePreventThreadCreation = g_settings.opts().preventThreadCreation;
    hdd->EnableNtUserBlockInputHook = g_settings.opts().hookNtUserBlockInput;
    hdd->EnableNtUserFindWindowExHook = g_settings.opts().hookNtUserFindWindowEx;
    hdd->EnableNtUserBuildHwndListHook = g_settings.opts().hookNtUserBuildHwndList;
    hdd->EnableNtUserQueryWindowHook = g_settings.opts().hookNtUserQueryWindow;
    hdd->EnableNtUserGetForegroundWindowHook = g_settings.opts().hookNtUserGetForegroundWindow;
    hdd->EnableNtSetDebugFilterStateHook = g_settings.opts().hookNtSetDebugFilterState;
    hdd->EnableGetTickCountHook = g_settings.opts().hookGetTickCount;
    hdd->EnableGetTickCount64Hook = g_settings.opts().hookGetTickCount64;
    hdd->EnableGetLocalTimeHook = g_settings.opts().hookGetLocalTime;
    hdd->EnableGetSystemTimeHook = g_settings.opts().hookGetSystemTime;
    hdd->EnableNtQuerySystemTimeHook = g_settings.opts().hookNtQuerySystemTime;
    hdd->EnableNtQueryPerformanceCounterHook = g_settings.opts().hookNtQueryPerformanceCounter;
    hdd->EnableNtSetInformationProcessHook = g_settings.opts().hookNtSetInformationProcess;

    hdd->EnableNtGetContextThreadHook = g_settings.opts().hookNtGetContextThread;
    hdd->EnableNtSetContextThreadHook = g_settings.opts().hookNtSetContextThread;
    hdd->EnableNtContinueHook = g_settings.opts().hookNtContinue | g_settings.opts().killAntiAttach;
    hdd->EnableKiUserExceptionDispatcherHook = g_settings.opts().hookKiUserExceptionDispatcher;
    hdd->EnableMalwareRunPeUnpacker = g_settings.opts().malwareRunpeUnpacker;

    hdd->isKernel32Hooked = FALSE;
    hdd->isNtdllHooked = FALSE;
    hdd->isUserDllHooked = FALSE;
}

bool RemoveDebugPrivileges(HANDLE hProcess)
{
    TOKEN_PRIVILEGES Debug_Privileges;

    if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &Debug_Privileges.Privileges[0].Luid))
    {
        HANDLE hToken = 0;
        if (OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &hToken))
        {
            Debug_Privileges.Privileges[0].Attributes = 0;
            Debug_Privileges.PrivilegeCount = 1;

            AdjustTokenPrivileges(hToken, FALSE, &Debug_Privileges, 0, NULL, NULL);
            CloseHandle(hToken);
            return true;
        }
    }

    return false;
}

#define DbgBreakPoint_FUNC_SIZE 0x10
#define DbgUiRemoteBreakin_FUNC_SIZE 0x80
#define NtContinue_FUNC_SIZE 0x40

typedef struct _PATCH_FUNC {
    PCHAR funcName;
    PVOID funcAddr;
    SIZE_T funcSize;
} PATCH_FUNC;


PATCH_FUNC patchFunctions[] = {
    {
        "DbgBreakPoint", 0, DbgBreakPoint_FUNC_SIZE
    },
    {
        "DbgUiRemoteBreakin", 0, DbgUiRemoteBreakin_FUNC_SIZE
    },
    {
        "NtContinue", 0, NtContinue_FUNC_SIZE
    }
};

bool ApplyAntiAntiAttach(DWORD targetPid)
{
    bool result = false;
    HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, 0, targetPid);

    if (!hProcess)
        return result;

    HMODULE hMod = GetModuleHandleW(L"ntdll.dll");

    for (ULONG i = 0; i < _countof(patchFunctions); i++)
    {
        patchFunctions[i].funcAddr = (PVOID)GetProcAddress(hMod, patchFunctions[i].funcName);
    }

    for (ULONG i = 0; i < _countof(patchFunctions); i++)
    {
        ULONG oldProtection;
        if (VirtualProtectEx(hProcess, patchFunctions[i].funcAddr, patchFunctions[i].funcSize, PAGE_EXECUTE_READWRITE, &oldProtection) &&
            WriteProcessMemory(hProcess, patchFunctions[i].funcAddr, patchFunctions[i].funcAddr, patchFunctions[i].funcSize, nullptr))
        {
            VirtualProtectEx(hProcess, patchFunctions[i].funcAddr, patchFunctions[i].funcSize, oldProtection, &oldProtection);
            result = true;
        }
        else
        {
            result = false;
            break;
        }
    }

    CloseHandle(hProcess);

    return result;
}



================================================
File: PluginGeneric/Injector.h
================================================
#include <windows.h>
#include "..\HookLibrary\HookMain.h"
#include "..\InjectorCLI\DynamicMapping.h"

#define IMAGE32(NtHeaders) ((NtHeaders)->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
#define IMAGE64(NtHeaders) ((NtHeaders)->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)

#define HEADER_FIELD(NtHeaders, Field) (IMAGE64(NtHeaders) \
	? ((PIMAGE_NT_HEADERS64)(NtHeaders))->OptionalHeader.Field \
	: ((PIMAGE_NT_HEADERS32)(NtHeaders))->OptionalHeader.Field)
#define THUNK_VAL(NtHeaders, Ptr, Val) (IMAGE64(NtHeaders) \
	? ((PIMAGE_THUNK_DATA64)(Ptr))->Val \
	: ((PIMAGE_THUNK_DATA32)(Ptr))->Val)

typedef struct _THREAD_SUSPEND_INFO
{
    HANDLE ThreadId;
    HANDLE ThreadHandle;
    NTSTATUS SuspendStatus;
} THREAD_SUSPEND_INFO, *PTHREAD_SUSPEND_INFO;

typedef struct _PROCESS_SUSPEND_INFO
{
    HANDLE ProcessId;
    HANDLE ProcessHandle;
    ULONG NumThreads;
    PTHREAD_SUSPEND_INFO ThreadSuspendInfo; // THREAD_SUSPEND_INFO[NumThreads]
} PROCESS_SUSPEND_INFO, *PPROCESS_SUSPEND_INFO;

void ReadNtApiInformation(HOOK_DLL_DATA *hdd);

void InstallAntiAttachHook();
void startInjectionProcess(HANDLE hProcess, HOOK_DLL_DATA *hdd, BYTE * dllMemory, bool newProcess);
void startInjection(DWORD targetPid, HOOK_DLL_DATA *hdd, const WCHAR * dllPath, bool newProcess);
void injectDll(DWORD targetPid, const WCHAR * dllPath);
BYTE * ReadFileToMemory(const WCHAR * targetFilePath);
void FillHookDllData(HANDLE hProcess, HOOK_DLL_DATA * data);
bool StartFixBeingDebugged(DWORD targetPid, bool setToNull);
bool ApplyAntiAntiAttach(DWORD targetPid);

DWORD GetAddressOfEntryPoint(BYTE * dllMemory);
bool RemoveDebugPrivileges(HANDLE hProcess);
bool SafeSuspendProcess(HANDLE hProcess, PPROCESS_SUSPEND_INFO suspendInfo);
bool SafeResumeProcess(PPROCESS_SUSPEND_INFO suspendInfo);



================================================
File: PluginGeneric/OllyExceptionHandler.cpp
================================================
#include "OllyExceptionHandler.h"
#include <Scylla/Logger.h>
#include <Scylla/Settings.h>

#include "Injector.h"
#include "..\InjectorCLI\RemoteHook.h"


t_WaitForDebugEvent dWaitForDebugEvent = nullptr;

#ifdef OLLY1
typedef bool (__cdecl * t_IsAddressBreakpoint)(DWORD_PTR address);
t_IsAddressBreakpoint _IsAddressBreakpoint = nullptr;
#endif

extern scl::Settings g_settings;
extern scl::Logger g_log;

char OutputDebugStringBuffer[500] = {0};

void handleOutputDebugString( LPDEBUG_EVENT lpDebugEvent )
{
	if (lpDebugEvent->u.DebugString.nDebugStringLength > 0 && lpDebugEvent->u.DebugString.lpDebugStringData != 0)
	{
		HANDLE hProcess = OpenProcess(PROCESS_VM_READ, 0, lpDebugEvent->dwProcessId);

		if (hProcess)
		{
			if (lpDebugEvent->u.DebugString.nDebugStringLength < sizeof(OutputDebugStringBuffer))
			{
				ZeroMemory(OutputDebugStringBuffer, sizeof(OutputDebugStringBuffer));
				if (ReadProcessMemory(hProcess, lpDebugEvent->u.DebugString.lpDebugStringData, OutputDebugStringBuffer, lpDebugEvent->u.DebugString.nDebugStringLength, NULL))
				{
					g_log.LogInfo(L"Debug String: %S", OutputDebugStringBuffer);
				}
			}
			else
			{
                g_log.LogInfo(L"Debug String is too long: %d", lpDebugEvent->u.DebugString.nDebugStringLength);
			}
			CloseHandle(hProcess);
		}
	}
	else
	{
        g_log.LogInfo(L"Detected possible Anti-Debug method - OUTPUT_DEBUG_STRING");
	}
}

void handleRipEvent( LPDEBUG_EVENT lpDebugEvent )
{
	if (lpDebugEvent->u.RipInfo.dwError == 0)
	{
        g_log.LogInfo(L"Detected possible Anti-Debug method - RIP Exception");
		return;
	}

	if (lpDebugEvent->u.RipInfo.dwType == 0)
	{
        g_log.LogInfo(L"RIP Exception: Error 0x%X Type NONE", lpDebugEvent->u.RipInfo.dwError);
	}
	else if (lpDebugEvent->u.RipInfo.dwType == SLE_ERROR)
	{
        g_log.LogInfo(L"RIP Exception: Error 0x%X Type SLE_ERROR", lpDebugEvent->u.RipInfo.dwError);
	}
	else if (lpDebugEvent->u.RipInfo.dwType == SLE_MINORERROR)
	{
        g_log.LogInfo(L"RIP Exception: Error 0x%X Type SLE_MINORERROR", lpDebugEvent->u.RipInfo.dwError);
	}
	else if (lpDebugEvent->u.RipInfo.dwType == SLE_WARNING)
	{
        g_log.LogInfo(L"RIP Exception: Error 0x%X Type SLE_WARNING", lpDebugEvent->u.RipInfo.dwError);
	}

}

DWORD_PTR hNtdll = 0;
DWORD_PTR hKernel = 0;

bool IsInsideKernelOrNtdll( DWORD_PTR address )
{
	PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)hNtdll;
	PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDos + pDos->e_lfanew);

	DWORD imageSizeNtdll = pNt->OptionalHeader.SizeOfImage;

	pDos = (PIMAGE_DOS_HEADER)hKernel;
	pNt = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDos + pDos->e_lfanew);

	DWORD imageSizeKernel = pNt->OptionalHeader.SizeOfImage;

	return (address > hNtdll && address < (hNtdll + imageSizeNtdll)) ||
			(address > hKernel && address < (hKernel + imageSizeKernel));
}

bool AnalyzeDebugStructure( LPDEBUG_EVENT lpDebugEvent )
{
    if (g_settings.opts().handleExceptionPrint != 0 && lpDebugEvent->dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
	{
		handleOutputDebugString(lpDebugEvent);
		return true;
	}

    if (g_settings.opts().handleExceptionRip != 0 && lpDebugEvent->dwDebugEventCode == RIP_EVENT)
	{
		handleRipEvent(lpDebugEvent);
		return true;
	}

    if (lpDebugEvent->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
	{
        if (g_settings.opts().handleExceptionIllegalInstruction != 0 && lpDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_ILLEGAL_INSTRUCTION)
		{
            g_log.LogInfo(L"Illegal Instruction %p", lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress);
			return true;
		}
        if (g_settings.opts().handleExceptionInvalidLockSequence != 0 && lpDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_INVALID_LOCK_SEQUENCE)
		{
            g_log.LogInfo(L"Invalid Lock Sequence %p", lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress);
			return true;
		}
        if (g_settings.opts().handleExceptionNoncontinuableException != 0 && lpDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_NONCONTINUABLE_EXCEPTION)
		{
            g_log.LogInfo(L"Non-continuable Exception %p", lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress);
			return true;
		}
        if (g_settings.opts().handleExceptionAssertionFailure != 0 && lpDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_ASSERTION_FAILURE)
		{
            g_log.LogInfo(L"Assertion Failure %p", lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress);
			return true;
		}
#ifdef OLLY1 // This may or may not be needed for Olly v2, but we don't have IsAddressBreakPoint() there
        if (g_settings.opts().handleExceptionBreakpoint != 0 && lpDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT)
		{
			if (_IsAddressBreakpoint((DWORD_PTR)lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress) == false)
			{
				//system breakpoint?
				if (!IsInsideKernelOrNtdll((DWORD_PTR)lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress))
				{
                    g_log.LogInfo(L"Breakpoint %p", lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress);
					return true;
				}
			}
		}
        else if (g_settings.opts().handleExceptionWx86Breakpoint != 0 && lpDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_WX86_BREAKPOINT)
		{
			if (_IsAddressBreakpoint((DWORD_PTR)lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress) == false)
			{
				//system breakpoint?
				if (!IsInsideKernelOrNtdll((DWORD_PTR)lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress))
				{
                    g_log.LogInfo(L"Wx86 Breakpoint %p", lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress);
					return true;
				}
			}
		}
#endif
        else if (g_settings.opts().handleExceptionGuardPageViolation != 0 && lpDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == STATUS_GUARD_PAGE_VIOLATION)
		{
            g_log.LogInfo(L"Guard Page Violation %p", lpDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress);
			return true;
		}
	}

	return false;
}

BOOL WINAPI HookedWaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
{
	BOOL retV = dWaitForDebugEvent(lpDebugEvent, dwMilliseconds);

	if (retV)
	{
		while(1)
		{
			if (AnalyzeDebugStructure(lpDebugEvent))
			{
				ContinueDebugEvent(lpDebugEvent->dwProcessId, lpDebugEvent->dwThreadId, DBG_EXCEPTION_NOT_HANDLED);

				retV = dWaitForDebugEvent(lpDebugEvent, dwMilliseconds);
				if (!retV)
				{
					break;
				}
			}
			else
			{
				break;
			}
		}
	}

	return retV;
}

void HookDebugLoop()
{
	hNtdll = (DWORD_PTR)GetModuleHandleW(L"ntdll.dll");
	hKernel = (DWORD_PTR)GetModuleHandleW(L"kernel32.dll");

	BYTE * WaitForIt = (BYTE *)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "WaitForDebugEvent");

	if (*WaitForIt == 0xE9 || *WaitForIt == 0x68) //JMP, PUSH
	{
		MessageBoxW(0, L"kernel32.dll - WaitForDebugEvent is hooked already!", L"Error", MB_ICONERROR);
	}
	else
	{
		dWaitForDebugEvent = (t_WaitForDebugEvent)DetourCreate(WaitForIt,HookedWaitForDebugEvent, true);
	}
}



================================================
File: PluginGeneric/OllyExceptionHandler.h
================================================
#pragma once

#include <ntdll/ntdll.h>

typedef BOOL (WINAPI *t_WaitForDebugEvent)(LPDEBUG_EVENT lpDebugEvent,DWORD dwMilliseconds);

BOOL WINAPI HookedWaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent,DWORD dwMilliseconds);

void HookDebugLoop();



================================================
File: PluginGeneric/OptionsDialog.cpp
================================================
#include "OptionsDialog.h"
#include <CommCtrl.h>
#include <codecvt>
#include <locale>
#include <Scylla/OsInfo.h>
#include <Scylla/Settings.h>
#include <Scylla/Util.h>
#include <Scylla/Version.h>

#include "..\PluginGeneric\Injector.h"

#ifdef OLLY1
#pragma pack(push)
#include <ollydbg1/ollyplugindefinitions.h>
#pragma pack(pop)
#include "..\ScyllaHideOlly1Plugin\resource.h"

#elif defined(OLLY2)
#pragma pack(push)
#include <ollydbg2/plugin.h>
#pragma pack(pop)
#include "..\ScyllaHideOlly2Plugin\resource.h"

#elif defined(__IDP__)
//#define BUILD_IDA_64BIT 1
#include <ida.hpp>
#include <idp.hpp>
#include <dbg.hpp>
#include "..\ScyllaHideIDAProPlugin\IdaServerClient.h"
#include "..\PluginGeneric\AttachDialog.h"
#include "..\ScyllaHideIDAProPlugin\resource.h"

#elif defined(X64DBG)
#include <x64dbg/bridgemain.h>
#include "..\ScyllaHideX64DBGPlugin\resource.h"
#define IDC_EXCEPTION_ALL 123432
#define IDC_SELECT_EXCEPTIONS 23949
#endif

#define SCYLLA_MAX_TOOLTIP_WIDTH    500

extern scl::Settings g_settings;
extern HOOK_DLL_DATA g_hdd;

extern std::wstring g_scyllaHideDllPath;
extern DWORD ProcessId;
extern bool bHooked;

#ifdef OLLY1
extern HWND hwmain;

#elif defined(__IDP__)
extern HINSTANCE hinst;
wchar_t DllPathForInjection[MAX_PATH] = { 0 };
#endif

void createExceptionWindow(HWND hwnd);

static void UpdateOptionsExceptions(HWND hWnd, const scl::Settings *settings)
{
    auto opts = &settings->opts();

#ifdef OLLY1
    auto check = opts->handleExceptionIllegalInstruction &&
        opts->handleExceptionInvalidLockSequence &&
        opts->handleExceptionNoncontinuableException &&
        opts->handleExceptionPrint &&
        opts->handleExceptionRip &&
        opts->handleExceptionBreakpoint &&
        opts->handleExceptionWx86Breakpoint &&
        opts->handleExceptionGuardPageViolation;
#elif defined(OLLY2)
    auto check = opts->handleExceptionNoncontinuableException &&
        opts->handleExceptionPrint &&
        opts->handleExceptionRip;

#elif defined(__IDP__)
    auto check = opts->handleExceptionNoncontinuableException &&
        opts->handleExceptionPrint &&
        opts->handleExceptionAssertionFailure &&
        opts->handleExceptionRip;

#elif defined(X64DBG)
    auto check = true;
#endif

    CheckDlgButton(hWnd, IDC_EXCEPTION_ALL, check ? BST_CHECKED : BST_UNCHECKED);
}

static void UpdateOptions(HWND hWnd, const scl::Settings *settings)
{
    auto opts = &settings->opts();

    CheckDlgButton(hWnd, IDC_PEBBEINGDEBUGGED, opts->fixPebBeingDebugged);
    CheckDlgButton(hWnd, IDC_PEBHEAPFLAGS, opts->fixPebHeapFlags);
    CheckDlgButton(hWnd, IDC_PEBNTGLOBALFLAG, opts->fixPebNtGlobalFlag);
    CheckDlgButton(hWnd, IDC_PEBSTARTUPINFO, opts->fixPebStartupInfo);
    CheckDlgButton(hWnd, IDC_PEBOSBUILDNUMBER, opts->fixPebOsBuildNumber);

    BOOL peb_state = opts->fixPebBeingDebugged && opts->fixPebHeapFlags && opts->fixPebNtGlobalFlag && opts->fixPebStartupInfo && opts->fixPebOsBuildNumber;
    CheckDlgButton(hWnd, IDC_PEB, peb_state);

    CheckDlgButton(hWnd, IDC_NTSETINFORMATIONTHREAD, opts->hookNtSetInformationThread);
    CheckDlgButton(hWnd, IDC_NTSETINFORMATIONPROCESS, opts->hookNtSetInformationProcess);
    CheckDlgButton(hWnd, IDC_NTQUERYSYSTEMINFORMATION, opts->hookNtQuerySystemInformation);
    CheckDlgButton(hWnd, IDC_NTQUERYINFORMATIONPROCESS, opts->hookNtQueryInformationProcess);
    CheckDlgButton(hWnd, IDC_NTQUERYOBJECT, opts->hookNtQueryObject);
    CheckDlgButton(hWnd, IDC_NTYIELDEXECUTION, opts->hookNtYieldExecution);
    CheckDlgButton(hWnd, IDC_OUTPUTDEBUGSTRINGA, opts->hookOutputDebugStringA);
    CheckDlgButton(hWnd, IDC_NTGETCONTEXTTHREAD, opts->hookNtGetContextThread);
    CheckDlgButton(hWnd, IDC_NTSETCONTEXTTHREAD, opts->hookNtSetContextThread);
    CheckDlgButton(hWnd, IDC_NTCONTINUE, opts->hookNtContinue);
    CheckDlgButton(hWnd, IDC_KIUED, opts->hookKiUserExceptionDispatcher);

    BOOL drx_state = opts->hookNtGetContextThread && opts->hookNtSetContextThread && opts->hookNtContinue && opts->hookKiUserExceptionDispatcher;
    CheckDlgButton(hWnd, IDC_PROTECTDRX, drx_state);

    CheckDlgButton(hWnd, IDC_NTUSERBLOCKINPUT, opts->hookNtUserBlockInput);
    CheckDlgButton(hWnd, IDC_NTUSERFINDWINDOWEX, opts->hookNtUserFindWindowEx);
    CheckDlgButton(hWnd, IDC_NTUSERBUILDHWNDLIST, opts->hookNtUserBuildHwndList);
    CheckDlgButton(hWnd, IDC_NTUSERQUERYWINDOW, opts->hookNtUserQueryWindow);
    CheckDlgButton(hWnd, IDC_NTUSERGETFOREGROUNDWINDOW, opts->hookNtUserGetForegroundWindow);
    CheckDlgButton(hWnd, IDC_NTSETDEBUGFILTERSTATE, opts->hookNtSetDebugFilterState);
    CheckDlgButton(hWnd, IDC_NTCLOSE, opts->hookNtClose);
    CheckDlgButton(hWnd, IDC_NTCREATETHREADEX, opts->hookNtCreateThreadEx);
    CheckDlgButton(hWnd, IDC_REMOVEDEBUGPRIV, opts->removeDebugPrivileges);
    CheckDlgButton(hWnd, IDC_PREVENTTHREADCREATION, opts->preventThreadCreation);
    CheckDlgButton(hWnd, IDC_RUNPE, opts->malwareRunpeUnpacker);
    CheckDlgButton(hWnd, IDC_DLLSTEALTH, opts->dllStealth);
    CheckDlgButton(hWnd, IDC_DLLNORMAL, opts->dllNormal);
    CheckDlgButton(hWnd, IDC_DLLUNLOAD, opts->dllUnload);
    CheckDlgButton(hWnd, IDC_GETTICKCOUNT, opts->hookGetTickCount);
    CheckDlgButton(hWnd, IDC_GETTICKCOUNT64, opts->hookGetTickCount64);
    CheckDlgButton(hWnd, IDC_GETLOCALTIME, opts->hookGetLocalTime);
    CheckDlgButton(hWnd, IDC_GETSYSTEMTIME, opts->hookGetSystemTime);
    CheckDlgButton(hWnd, IDC_NTQUERYSYSTEMTIME, opts->hookNtQuerySystemTime);
    CheckDlgButton(hWnd, IDC_NTQUERYPERFCOUNTER, opts->hookNtQueryPerformanceCounter);
    CheckDlgButton(hWnd, IDC_KILLANTIATTACH, opts->killAntiAttach);

#ifdef OLLY1
    SetDlgItemTextW(hWnd, IDC_OLLYTITLE, opts->ollyWindowTitle.c_str());
    CheckDlgButton(hWnd, IDC_DELEPBREAK, opts->ollyRemoveEpBreak);
    CheckDlgButton(hWnd, IDC_FIXOLLY, opts->ollyFixBugs);
    CheckDlgButton(hWnd, IDC_X64FIX, opts->ollyX64Fix);
    CheckDlgButton(hWnd, IDC_SKIPEPOUTSIDE, opts->ollySkipEpOutsideCode);
    CheckDlgButton(hWnd, IDC_BREAKTLS, opts->ollyBreakOnTls);

    auto skip_compressed_state = opts->ollySkipCompressedDoAnalyze || opts->ollySkipCompressedDoNothing;
    CheckDlgButton(hWnd, IDC_COMPRESSED, skip_compressed_state);
    EnableWindow(GetDlgItem(hWnd, IDC_COMPRESSEDANALYZE), skip_compressed_state);
    EnableWindow(GetDlgItem(hWnd, IDC_COMPRESSEDNOTHING), skip_compressed_state);

    CheckDlgButton(hWnd, IDC_COMPRESSEDANALYZE, opts->ollySkipCompressedDoAnalyze);
    CheckDlgButton(hWnd, IDC_COMPRESSEDNOTHING, opts->ollySkipCompressedDoNothing);

    auto skip_load_state = opts->ollySkipLoadDllDoLoad || opts->ollySkipLoadDllDoNothing;
    CheckDlgButton(hWnd, IDC_LOADDLL, skip_load_state);
    EnableWindow(GetDlgItem(hWnd, IDC_LOADDLLLOAD), skip_load_state);
    EnableWindow(GetDlgItem(hWnd, IDC_LOADDLLNOTHING), skip_load_state);

    CheckDlgButton(hWnd, IDC_LOADDLLLOAD, opts->ollySkipLoadDllDoLoad);
    CheckDlgButton(hWnd, IDC_LOADDLLNOTHING, opts->ollySkipLoadDllDoNothing);

    CheckDlgButton(hWnd, IDC_ADVANCEDGOTO, opts->ollyAdvancedGoto);
    CheckDlgButton(hWnd, IDC_BADPEIMAGE, opts->ollyIgnoreBadPeImage);
    CheckDlgButton(hWnd, IDC_ADVANCEDINFOBAR, opts->ollyAdvancedInfobar);
    EnableWindow(GetDlgItem(hWnd, IDC_OUTPUTDEBUGSTRINGA), FALSE);

#elif defined(OLLY2)
    SetDlgItemTextW(hWnd, IDC_OLLYTITLE, opts->ollyWindowTitle.c_str());

#elif defined(__IDP__)
    CheckDlgButton(hWnd, IDC_AUTOSTARTSERVER, opts->idaAutoStartServer);
    SetDlgItemTextW(hWnd, IDC_SERVERPORT, opts->idaServerPort.c_str());

#ifdef BUILD_IDA_64BIT
    EnableWindow(GetDlgItem(hWnd, IDC_AUTOSTARTSERVER), scl::IsWindows64());
#else
    EnableWindow(GetDlgItem(hWnd, IDC_AUTOSTARTSERVER), FALSE);
#endif

    EnableWindow(GetDlgItem(hWnd, IDC_INJECTDLL), (!!ProcessId));
#endif

    UpdateOptionsExceptions(hWnd, settings);
}

void SaveOptions(HWND hWnd, scl::Settings *settings)
{
    auto opts = &settings->opts();

    opts->fixPebBeingDebugged = (IsDlgButtonChecked(hWnd, IDC_PEBBEINGDEBUGGED) == BST_CHECKED);
    opts->fixPebHeapFlags = (IsDlgButtonChecked(hWnd, IDC_PEBHEAPFLAGS) == BST_CHECKED);
    opts->fixPebNtGlobalFlag = (IsDlgButtonChecked(hWnd, IDC_PEBNTGLOBALFLAG) == BST_CHECKED);
    opts->fixPebStartupInfo = (IsDlgButtonChecked(hWnd, IDC_PEBSTARTUPINFO) == BST_CHECKED);
    opts->fixPebOsBuildNumber = (IsDlgButtonChecked(hWnd, IDC_PEBOSBUILDNUMBER) == BST_CHECKED);
    opts->hookNtSetInformationThread = (IsDlgButtonChecked(hWnd, IDC_NTSETINFORMATIONTHREAD) == BST_CHECKED);
    opts->hookNtSetInformationProcess = (IsDlgButtonChecked(hWnd, IDC_NTSETINFORMATIONPROCESS) == BST_CHECKED);
    opts->hookNtQuerySystemInformation = (IsDlgButtonChecked(hWnd, IDC_NTQUERYSYSTEMINFORMATION) == BST_CHECKED);
    opts->hookNtQueryInformationProcess = (IsDlgButtonChecked(hWnd, IDC_NTQUERYINFORMATIONPROCESS) == BST_CHECKED);
    opts->hookNtQueryObject = (IsDlgButtonChecked(hWnd, IDC_NTQUERYOBJECT) == BST_CHECKED);
    opts->hookNtYieldExecution = (IsDlgButtonChecked(hWnd, IDC_NTYIELDEXECUTION) == BST_CHECKED);
    opts->hookOutputDebugStringA = (IsDlgButtonChecked(hWnd, IDC_OUTPUTDEBUGSTRINGA) == BST_CHECKED);
    opts->hookNtGetContextThread = (IsDlgButtonChecked(hWnd, IDC_NTGETCONTEXTTHREAD) == BST_CHECKED);
    opts->hookNtSetContextThread = (IsDlgButtonChecked(hWnd, IDC_NTSETCONTEXTTHREAD) == BST_CHECKED);
    opts->hookNtContinue = (IsDlgButtonChecked(hWnd, IDC_NTCONTINUE) == BST_CHECKED);
    opts->hookKiUserExceptionDispatcher = (IsDlgButtonChecked(hWnd, IDC_KIUED) == BST_CHECKED);
    opts->hookNtUserFindWindowEx = (IsDlgButtonChecked(hWnd, IDC_NTUSERFINDWINDOWEX) == BST_CHECKED);
    opts->hookNtUserBlockInput = (IsDlgButtonChecked(hWnd, IDC_NTUSERBLOCKINPUT) == BST_CHECKED);
    opts->hookNtUserBuildHwndList = (IsDlgButtonChecked(hWnd, IDC_NTUSERBUILDHWNDLIST) == BST_CHECKED);
    opts->hookNtUserQueryWindow = (IsDlgButtonChecked(hWnd, IDC_NTUSERQUERYWINDOW) == BST_CHECKED);
    opts->hookNtUserGetForegroundWindow = (IsDlgButtonChecked(hWnd, IDC_NTUSERGETFOREGROUNDWINDOW) == BST_CHECKED);
    opts->hookNtSetDebugFilterState = (IsDlgButtonChecked(hWnd, IDC_NTSETDEBUGFILTERSTATE) == BST_CHECKED);
    opts->hookNtClose = (IsDlgButtonChecked(hWnd, IDC_NTCLOSE) == BST_CHECKED);
    opts->hookNtCreateThreadEx = (IsDlgButtonChecked(hWnd, IDC_NTCREATETHREADEX) == BST_CHECKED);
    opts->preventThreadCreation = (IsDlgButtonChecked(hWnd, IDC_PREVENTTHREADCREATION) == BST_CHECKED);
    opts->malwareRunpeUnpacker = (IsDlgButtonChecked(hWnd, IDC_RUNPE) == BST_CHECKED);
    opts->removeDebugPrivileges = (IsDlgButtonChecked(hWnd, IDC_REMOVEDEBUGPRIV) == BST_CHECKED);
    opts->dllStealth = (IsDlgButtonChecked(hWnd, IDC_DLLSTEALTH) == BST_CHECKED);
    opts->dllNormal = (IsDlgButtonChecked(hWnd, IDC_DLLNORMAL) == BST_CHECKED);
    opts->dllUnload = (IsDlgButtonChecked(hWnd, IDC_DLLUNLOAD) == BST_CHECKED);
    opts->hookGetTickCount = (IsDlgButtonChecked(hWnd, IDC_GETTICKCOUNT) == BST_CHECKED);
    opts->hookGetTickCount64 = (IsDlgButtonChecked(hWnd, IDC_GETTICKCOUNT64) == BST_CHECKED);
    opts->hookGetLocalTime = (IsDlgButtonChecked(hWnd, IDC_GETLOCALTIME) == BST_CHECKED);
    opts->hookGetSystemTime = (IsDlgButtonChecked(hWnd, IDC_GETSYSTEMTIME) == BST_CHECKED);
    opts->hookNtQuerySystemTime = (IsDlgButtonChecked(hWnd, IDC_NTQUERYSYSTEMTIME) == BST_CHECKED);
    opts->hookNtQueryPerformanceCounter = (IsDlgButtonChecked(hWnd, IDC_NTQUERYPERFCOUNTER) == BST_CHECKED);
    opts->killAntiAttach = (IsDlgButtonChecked(hWnd, IDC_KILLANTIATTACH) == BST_CHECKED);

#ifdef OLLY1
    opts->ollyRemoveEpBreak = (IsDlgButtonChecked(hWnd, IDC_DELEPBREAK) == BST_CHECKED);
    opts->ollyFixBugs = (IsDlgButtonChecked(hWnd, IDC_FIXOLLY) == BST_CHECKED);
    opts->ollyX64Fix = (IsDlgButtonChecked(hWnd, IDC_X64FIX) == BST_CHECKED);
    opts->ollyBreakOnTls = (IsDlgButtonChecked(hWnd, IDC_BREAKTLS) == BST_CHECKED);
    opts->ollySkipEpOutsideCode = (IsDlgButtonChecked(hWnd, IDC_SKIPEPOUTSIDE) == BST_CHECKED);
    opts->ollyIgnoreBadPeImage = (IsDlgButtonChecked(hWnd, IDC_BADPEIMAGE) == BST_CHECKED);
    opts->ollyAdvancedGoto = (IsDlgButtonChecked(hWnd, IDC_ADVANCEDGOTO) == BST_CHECKED);
    opts->ollySkipCompressedDoAnalyze = (IsDlgButtonChecked(hWnd, IDC_COMPRESSEDANALYZE) == BST_CHECKED);
    opts->ollySkipCompressedDoNothing = (IsDlgButtonChecked(hWnd, IDC_COMPRESSEDNOTHING) == BST_CHECKED);
    opts->ollySkipLoadDllDoLoad = (IsDlgButtonChecked(hWnd, IDC_LOADDLLLOAD) == BST_CHECKED);
    opts->ollySkipLoadDllDoNothing = (IsDlgButtonChecked(hWnd, IDC_LOADDLLNOTHING) == BST_CHECKED);
    opts->ollyAdvancedInfobar = (IsDlgButtonChecked(hWnd, IDC_ADVANCEDINFOBAR) == BST_CHECKED);

    opts->ollyWindowTitle = scl::GetDlgItemTextW(hWnd, IDC_OLLYTITLE);
    SetWindowTextW(hwmain, opts->ollyWindowTitle.c_str());

#elif defined(OLLY2)
    opts->ollyWindowTitle = scl::GetDlgItemTextW(hWnd, IDC_OLLYTITLE);
    SetWindowTextW(hwollymain, opts->ollyWindowTitle.c_str());

#elif defined(__IDP__)
    opts->idaAutoStartServer = (IsDlgButtonChecked(hWnd, IDC_AUTOSTARTSERVER) == BST_CHECKED);
    opts->idaServerPort = scl::GetDlgItemTextW(hWnd, IDC_SERVERPORT);
#endif

    settings->Save();
}

HWND CreateTooltips(HWND hDlg)
{
    static const struct
    {
        unsigned ctrl_id;
        const wchar_t *text;
    } ctrl_tips[] = {
        { IDOK, L"Apply Settings and close the dialog" },
        { IDC_PROFILES, L"Select profile" },
        { IDC_SAVEPROFILE, L"Save profile" },
        {
            IDC_PEB,
            L"The most important anti-anti-debug option.\r\n"
            L"Almost every protector checks for PEB values.\r\n"
            L"There are three important options and some minor options."
        },
        {
            IDC_PEBBEINGDEBUGGED,
            L"Very important option, should be always enabled.\r\n"
            L"IsDebuggerPresent is using this value to check for debuggers."
        },
        { IDC_PEBHEAPFLAGS, L"Very important option, a lot of protectors check for this value." },
        { IDC_PEBNTGLOBALFLAG, L"Very important option. E.g. Themida checks for heap artifacts and heap flags." },
        { IDC_PEBSTARTUPINFO, L"This is not really important, only a few protectors check for this. Maybe Enigma checks it." },
        { IDC_PEBOSBUILDNUMBER, L"VMProtect checks this for determining syscall numbers for direct syscalls.\r\n"
                                L"On Windows 10, you also need to put an access HWBP on KUSER_SHARED_DATA+0x260\r\n"
                                L"and patch the build number manually.\r\n"
                                L"NOTE: This won't have the desired effect for WOW64 processes!"},
        {
            IDC_NTSETINFORMATIONTHREAD,
            L"The THREADINFOCLASS value ThreadHideFromDebugger is a well-known\r\n"
            L"anti-debug measurement. The debugger cannot handle hidden threads.\r\n"
            L"This leads to a loss of control over the target."
        },
        {
            IDC_NTSETINFORMATIONPROCESS,
            L"The PROCESSINFOCLASS value ProcessHandleTracing can be used to\r\n"
            L"detect a debugger. The PROCESSINFOCLASS value ProcessBreakOnTermination\r\n"
            L"can be used to generate a Blue Screen of Death on process termination."
        },
        {
            IDC_NTQUERYSYSTEMINFORMATION,
            L"The SYSTEM_INFORMATION_CLASS values SystemKernelDebuggerInformation,\r\n"
            L"SystemKernelDebuggerInformationEx and SystemKernelDebuggerFlags can be used\r\n"
            L"to detect kernel debuggers. The SYSTEM_INFORMATION_CLASS values SystemProcessInformation\r\n"
            L"and SystemExtendedProcessInformation are used to get a process list.\r\n"
            L"SystemHandleInformation and SystemExtendedHandleInformation are used to\r\n"
            L"enumerate system process handles to detect e.g. handles to the debuggee process.\r\n"
            L"The SYSTEM_INFORMATION_CLASS values SystemCodeIntegrityInformation and\r\n"
            L"SystemCodeIntegrityUnlockInformation can be used to detect test signing mode.\r\n"
            L"A debugger should be hidden in a process list and the debugee should have a good parent\r\n"
            L"process ID like the ID from explorer.exe."
        },
        {
            IDC_NTQUERYINFORMATIONPROCESS,
            L"A very important option. Various PROCESSINFOCLASS values can be used\r\nto detect a debugger.\r\n"
            L" ProcessDebugFlags: Should return 1 in the supplied buffer.\r\n"
            L" ProcessDebugPort: Should return 0 in the supplied buffer.\r\n"
            L" ProcessDebugObjectHandle: Should return 0 in the supplied buffer\r\nand the error STATUS_PORT_NOT_SET(0xC0000353)\r\n"
            L" ProcessBasicInformation: Reveals the parent process ID.\r\n"
            L" ProcessBreakOnTermination: Please see NtSetInformationProcess\r\n"
            L" ProcessHandleTracing: Please see NtSetInformationProcess\r\n"
            L"A lot of protectors use this to detect debuggers.\r\n"
            L"The windows API CheckRemoteDebuggerPresent uses NtQueryInformationProcess internally."
        },
        {
            IDC_NTQUERYOBJECT,
            L"The OBJECT_INFORMATION_CLASS ObjectTypesInformation and ObjectTypeInformation\r\n"
            L"can be used to detect debuggers. ScyllaHide filters DebugObject references."
        },
        {
            IDC_NTYIELDEXECUTION,
            L"A very unrealiable anti-debug method. This is only used in some UnpackMe's\r\n"
            L"or in some Proof of Concept code. Only activate this if you really need it.\r\n"
            L"Probably you will never need this option."
        },
        {
            IDC_NTCREATETHREADEX,
            L"Threads hidden from debuggers can be created with a special creation flag\r\n"
            L"THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER. ScyllaHide doesn't\r\n"
            L"allow hidden threads. The anti-debug effect is similar to NtSetInformationThread"
        },
        {
            IDC_OUTPUTDEBUGSTRINGA,
            L"OutputDebugStringW uses OutputDebugStringA internally. ScyllaHide only hooks\r\n"
            L"the ANSI version and this is therefore enough. This is a very unreliable\r\n"
            L"antidebug method, so you will not need this option very often."
        },
        {
            IDC_NTUSERBLOCKINPUT,
            L"Very effective anti-debug method. This is used e.g. in Yoda's Protector.\r\n"
            L"\"Blocks keyboard and mouse input events from reaching applications.\""
        },
        {
            IDC_NTUSERFINDWINDOWEX,
            L"This is a system call function in user32.dll.\r\n"
            L"The windows APIs FindWindowA/W and FindWindowExA/W call this internally.\r\n"
            L"The debugger window will be hidden."
        },
        {
            IDC_NTUSERBUILDHWNDLIST,
            L"This is a system call function in user32.dll.\r\n"
            L"The windows APIs EnumWindows and EnumThreadWindows call this internally.\r\n"
            L"The debugger window will be hidden."
        },
        {
            IDC_NTUSERQUERYWINDOW,
            L"This is a system call function in user32.dll.\r\n"
            L"The windows API GetWindowThreadProcessId calls this internally.\r\n"
            L"This is used to hide the debugger process."
        },
        {
            IDC_NTUSERGETFOREGROUNDWINDOW,
            L"This is a system call function in user32.dll.\r\n"
            L"The windows API GetForegroundWindow calls this internally.\r\n"
            L"The debugger window will be hidden."
        },
        {
            IDC_NTSETDEBUGFILTERSTATE,
            L"ScyllaHide returns always STATUS_ACCESS_DENIED.\r\n"
            L"This anti-debugn measurement isn't used very often.\r\n"
            L"Probably you will never need this option in a real world target."
        },
        {
            IDC_NTCLOSE,
            L"This is called with an invalid handle to detect a debugger.\r\n"
            L"ScyllaHide calls NtQueryObject to check the validity of the handle.\r\n"
            L"A few protectors are using this method."
        },
        {
            IDC_REMOVEDEBUGPRIV,
            L"If a debugger creates the process of the target, the target will have debug\r\n"
            L"privileges. This can be used to detect a debugger."
        },
        {
            IDC_PROTECTDRX,
            L"Hardware breakpoints can be detected/cleared with exceptions or the windows\r\n"
            L"APIs NtGetContextThread/NtSetContextThread. Enable this option only if you need it!"
        },
        {
            IDC_NTGETCONTEXTTHREAD,
            L"Hardware breakpoints can be detected/cleared with exceptions or the windows\r\n"
            L"APIs NtGetContextThread/NtSetContextThread. Enable this option only if you need it!"
        },
        {
            IDC_NTSETCONTEXTTHREAD,
            L"Hardware breakpoints can be detected/cleared with exceptions or the windows\r\n"
            L"APIs NtGetContextThread/NtSetContextThread. Enable this option only if you need it!"
        },
        {
            IDC_NTCONTINUE,
            L"Hardware breakpoints can be detected/cleared with exceptions or the windows\r\n"
            L"APIs NtGetContextThread/NtSetContextThread. Enable this option only if you need it!"
        },
        {
            IDC_KIUED,
            L"Hardware breakpoints can be detected/cleared with exceptions or the windows\r\n"
            L"APIs NtGetContextThread/NtSetContextThread. Enable this option only if you need it!"
        },
        {
            IDC_GETTICKCOUNT,
            L"There are a few windows APIs to measure the time. Timing can be used to\r\n"
            L"detect debuggers, because they slow down the execution. Enable with care\r\nand only if you need it!"
        },
        {
            IDC_GETTICKCOUNT64,
            L"There are a few windows APIs to measure the time. Timing can be used to\r\n"
            L"detect debuggers, because they slow down the execution. Enable with care\r\n"
            L"and only if you need it!"
        },
        {
            IDC_GETLOCALTIME,
            L"There are a few windows APIs to measure the time. Timing can be used to\r\n"
            L"detect debuggers, because they slow down the execution. Enable with care\r\n"
            L"and only if you need it!"
        },
        {
            IDC_GETSYSTEMTIME,
            L"There are a few windows APIs to measure the time. Timing can be used to\r\n"
            L"detect debuggers, because they slow down the execution. Enable with care\r\n"
            L"and only if you need it!"
        },
        {
            IDC_NTQUERYSYSTEMTIME,
            L"There are a few windows APIs to measure the time. Timing can be used to\r\n"
            L"detect debuggers, because they slow down the execution. Enable with care\r\n"
            L"and only if you need it!"
        },
        {
            IDC_NTQUERYPERFCOUNTER,
            L"There are a few windows APIs to measure the time. Timing can be used to\r\n"
            L"detect debuggers, because they slow down the execution. Enable with care\r\n"
            L"and only if you need it!"
        },
        {
            IDC_PREVENTTHREADCREATION,
            L"This option prevents the creation of new threads. This can be useful if a protector\r\n"
            L" uses a lot of protection threads. This option can be useful for EXECryptor.\r\n"
            L"Enable with care and only if you need it!\r\n"
            L"You must know what you are doing here!"
        },
        {
            IDC_RUNPE,
            L"This option hooks NtResumeThread. If the malware creates a new process,\r\n"
            L"ScyllaHide terminates and dumps any newly created process. If you are unpacking\r\n"
            L"malware, enable and try it. Should be only used inside a VM.\r\n"
            L"A typical RunPE workflow:\r\n"
            L" 1. Create a new process of any target in suspended state.\r\n"
            L"    (Process flag CREATE_SUSPENDED: 0x00000004)\r\n"
            L" 2. Replace the original process PE image with a new (malicious) PE image.\r\n"
            L"    This can involve several steps and various windows API functions.\r\n"
            L" 3. Start the process with the windows API function ResumeThread(or NtResumeThread)."
        },
        {
            IDC_DLLSTEALTH,
            L"Normal DLL injection or stealth dll injection.\r\n"
            L"You better try the normal injection first..."
        },
        {
            IDC_DLLNORMAL,
            L"Normal DLL injection or stealth dll injection.\r\n"
            L"You better try the normal injection first..."
        },
        { IDC_DLLUNLOAD, L"Unload after DLLMain" },
        { IDC_KILLANTIATTACH, L"Kill Anti-Attach" },
#ifdef OLLY1
            { IDC_OLLYTITLE, L"Olly caption" },
            {
                IDC_DELEPBREAK,
                L"Some protectors use Thread-Local-Storage (TLS) as entrypoint and check for\r\n"
                L"breakpoints at the normal PE entrypoint address. You must remove the PE\r\n"
                L"entrypoint to hide your debugger. This option is necessary for VMProtect."
            },
            {
                IDC_FIXOLLY,
                L"This option fixes various OllyDbg bugs:\r\n"
                L" - PE Fix for NumOfRvaAndSizes\r\n"
                L" - ForegroundWindow Fix\r\n"
                L" - FPU bugfix\r\n"
                L" - Format string (sprintf) bug\r\n"
                L" - NT Symbols path bug, patch by blabberer\r\n"
                L" - Faulty handle bug. Sometimes Olly does not terminate,\r\n"
                L"   error appears \"Operating system reports error ERROR_ACCESS_DENIED\""
            },
            {
                IDC_X64FIX,
                L"OllyDbg doesn't work very well on x64 operating systems.\r\n"
                L"This option fixes the most annoying bug."
            },
            { IDC_SKIPEPOUTSIDE, L"Skip \"EP outside of Code\"" },
            {
                IDC_BREAKTLS,
                L"This option sets a breakpoint to any available Thread-Local-Storage (TLS)\r\n"
                L"address. This is necessary for various protectors e.g. VMProtect."
            },
            { IDC_COMPRESSED, L"Skip compressed code" },
            { IDC_COMPRESSEDANALYZE, L"Skip compressed code and analyze" },
            { IDC_COMPRESSEDNOTHING, L"Skip compressed code and do nothing" },
            { IDC_LOADDLL, L"Skip \"Load Dll\" and" },
            { IDC_LOADDLLLOAD, L"Skip \"Load Dll\" and load DLL" },
            { IDC_LOADDLLNOTHING, L"Skip \"Load Dll\" and do nothing" },
            {
                IDC_ADVANCEDGOTO,
                L"Replaces the default OllyDbg \"Go to Address\" dialog.\r\n"
                L"Now you can enter RVA and offset values."
            },
            { IDC_ADVANCEDINFOBAR, L"Displays info about selected Bytes in CPU/Dump like Start/End address and size." },
            { IDC_BADPEIMAGE, L"Ignore bad image (WinUPack)" },
#elif defined(OLLY2)
            { IDC_OLLYTITLE, L"Olly caption" },
#elif defined(__IDP__)
            { IDC_AUTOSTARTSERVER, L"" },
            { IDC_SERVERPORT, L"" },
            { IDC_INJECTDLL, L"" },
#endif
    };

    auto hInstance = (HINSTANCE)GetWindowLongPtrW(hDlg, GWLP_HINSTANCE);
    if (!hInstance)
        return nullptr;

    // Create tooltip for main window
    auto hToolTipWnd = CreateWindowExW(WS_EX_TOPMOST, TOOLTIPS_CLASS, nullptr,
        WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        hDlg, nullptr, hInstance, nullptr);

    if (!hToolTipWnd)
        return nullptr;

    for (auto i = 0; i < _countof(ctrl_tips); i++)
    {
        auto hCtrl = GetDlgItem(hDlg, ctrl_tips[i].ctrl_id);
        if (!hCtrl)
            continue;

        TOOLINFOW ti;
        ti.cbSize = TTTOOLINFOW_V1_SIZE;
        ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
        ti.hwnd = hDlg;
        ti.uId = (UINT_PTR)hCtrl;
        ti.hinst = hInstance;
        ti.lpszText = (wchar_t *)(ctrl_tips[i].text);
        ti.lParam = 0;

        SendMessageW(hToolTipWnd, TTM_ADDTOOL, 0, (LPARAM)&ti);
    }

    SendMessageW(hToolTipWnd, TTM_SETMAXTIPWIDTH, 0, SCYLLA_MAX_TOOLTIP_WIDTH);
    SendMessageW(hToolTipWnd, TTM_ACTIVATE, TRUE, 0);

    return hToolTipWnd;
}

//options dialog proc
INT_PTR CALLBACK OptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
    {
        // add current profile to options title
        auto wstrTitle = scl::fmtw(L"[ScyllaHide Options] Profile: %s", g_settings.profile_name().c_str());
        SetWindowTextW(hDlg, wstrTitle.c_str());

        // fill combobox with profiles
        for (size_t i = 0; i < g_settings.profile_names().size(); i++)
        {
            SendDlgItemMessageW(hDlg, IDC_PROFILES, CB_ADDSTRING, 0, (LPARAM)g_settings.profile_names()[i].c_str());
            if (g_settings.profile_name() == g_settings.profile_names()[i])
                SendDlgItemMessageW(hDlg, IDC_PROFILES, CB_SETCURSEL, i, 0);
        }

        UpdateOptions(hDlg, &g_settings);

#ifdef OLLY1
        EnableWindow(GetDlgItem(hDlg, IDC_X64FIX), !scl::IsWindows64());
#endif

        CreateTooltips(hDlg);

        break;
    }
    case WM_CLOSE:
    {
        EndDialog(hDlg, NULL);
    }
    break;

    case WM_COMMAND:
    {
        switch (LOWORD(wParam))
        {
        case IDC_PROFILES:
        {
            if (HIWORD(wParam) != CBN_SELCHANGE)
                break;

            auto profileIdx = (int)SendDlgItemMessageW(hDlg, IDC_PROFILES, CB_GETCURSEL, 0, 0);
            g_settings.SetProfile(g_settings.profile_names()[profileIdx].c_str());

            // update options title
            auto wstrTitle = scl::fmtw(L"[ScyllaHide Options] Profile: %s", g_settings.profile_name().c_str());
            SetWindowTextW(hDlg, wstrTitle.c_str());

            UpdateOptions(hDlg, &g_settings);
            break;
        }

        case IDC_SAVEPROFILE:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            std::wstring wstrNewProfileName;

#ifdef OLLY1
            std::string strNewProfileName;
            strNewProfileName.resize(MAX_PATH);
            if (_Gettext("New profile name?", &strNewProfileName[0], 0, 0, 0) <= 0)
                break;
            wstrNewProfileName = scl::wstr_conv().from_bytes(strNewProfileName.c_str());

#elif defined(OLLY2)
            wstrNewProfileName.resize(MAX_PATH);
            if (Getstring(hDlg, L"New profile name?", &wstrNewProfileName[0], wstrNewProfileName.size(), 0, 0, 0, 0, 0, 0) <= 0)
                break;
            wstrNewProfileName.resize(lstrlenW(wstrNewProfileName.c_str()));

#elif defined(__IDP__)
            auto szNewProfileName = askstr(0, "", "New profile name?");
            if (!szNewProfileName)
                break;
            wstrNewProfileName = scl::wstr_conv().from_bytes(szNewProfileName);

#elif defined(X64DBG)
            std::string strNewProfileName;
            strNewProfileName.resize(GUI_MAX_LINE_SIZE);
            if (!GuiGetLineWindow("New profile name?", &strNewProfileName[0]))
                break;
            wstrNewProfileName = scl::wstr_conv().from_bytes(strNewProfileName.c_str());
#endif

            if (!g_settings.AddProfile(wstrNewProfileName.c_str()))
                break;
            g_settings.SetProfile(wstrNewProfileName.c_str());

            auto wstrTitle = scl::fmtw(L"[ScyllaHide Options] Profile: %s", g_settings.profile_name().c_str());
            SetWindowTextW(hDlg, wstrTitle.c_str());

            SendDlgItemMessageW(hDlg, IDC_PROFILES, CB_ADDSTRING, 0, (LPARAM)wstrNewProfileName.c_str());
            auto profileCount = (int)SendDlgItemMessageW(hDlg, IDC_PROFILES, CB_GETCOUNT, 0, 0);
            SendDlgItemMessageW(hDlg, IDC_PROFILES, CB_SETCURSEL, profileCount - 1, 0);

            UpdateOptions(hDlg, &g_settings);
            break;
        }

        case IDOK:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            SaveOptions(hDlg, &g_settings);

            if (ProcessId)
            {
#ifdef __IDP__
#ifndef BUILD_IDA_64BIT
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
#endif
#else
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
#endif
                bHooked = true;
                MessageBoxW(hDlg, L"Applied changes! Restarting target is NOT necessary!", L"[ScyllaHide Options]", MB_ICONINFORMATION);
            }
            else
            {
                MessageBoxW(hDlg, L"Please start the target to apply changes!", L"[ScyllaHide Options]", MB_ICONINFORMATION);
            }

            EndDialog(hDlg, NULL);
            break;
        }

        case IDC_APPLY:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            SaveOptions(hDlg, &g_settings);
            break;
        }

        case IDC_EXCEPTION_ALL:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            auto value = (IsDlgButtonChecked(hDlg, IDC_EXCEPTION_ALL) == BST_CHECKED);
            g_settings.opts().handleExceptionPrint = value;
            g_settings.opts().handleExceptionIllegalInstruction = value;
            g_settings.opts().handleExceptionInvalidLockSequence = value;
            g_settings.opts().handleExceptionNoncontinuableException = value;
            g_settings.opts().handleExceptionRip = value;
            g_settings.opts().handleExceptionAssertionFailure = value;
            g_settings.opts().handleExceptionBreakpoint = value;
            g_settings.opts().handleExceptionGuardPageViolation = value;
            g_settings.opts().handleExceptionWx86Breakpoint = value;
            break;
        }

        case IDC_PROTECTDRX:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            auto state = IsDlgButtonChecked(hDlg, IDC_PROTECTDRX);
            CheckDlgButton(hDlg, IDC_NTGETCONTEXTTHREAD, state);
            CheckDlgButton(hDlg, IDC_NTSETCONTEXTTHREAD, state);
            CheckDlgButton(hDlg, IDC_NTCONTINUE, state);
            CheckDlgButton(hDlg, IDC_KIUED, state);
            break;
        }

        case IDC_NTGETCONTEXTTHREAD:
        case IDC_NTSETCONTEXTTHREAD:
        case IDC_NTCONTINUE:
        case IDC_KIUED:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            auto checked = IsDlgButtonChecked(hDlg, IDC_NTGETCONTEXTTHREAD)
                || IsDlgButtonChecked(hDlg, IDC_NTSETCONTEXTTHREAD)
                || IsDlgButtonChecked(hDlg, IDC_NTCONTINUE)
                || IsDlgButtonChecked(hDlg, IDC_KIUED);

            CheckDlgButton(hDlg, IDC_PROTECTDRX, checked);
            break;
        }

        case IDC_PEB:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            auto state = IsDlgButtonChecked(hDlg, IDC_PEB);
            CheckDlgButton(hDlg, IDC_PEBBEINGDEBUGGED, state);
            CheckDlgButton(hDlg, IDC_PEBHEAPFLAGS, state);
            CheckDlgButton(hDlg, IDC_PEBNTGLOBALFLAG, state);
            CheckDlgButton(hDlg, IDC_PEBSTARTUPINFO, state);
            CheckDlgButton(hDlg, IDC_PEBOSBUILDNUMBER, state);
            break;
        }

        case IDC_PEBBEINGDEBUGGED:
        case IDC_PEBHEAPFLAGS:
        case IDC_PEBNTGLOBALFLAG:
        case IDC_PEBSTARTUPINFO:
        case IDC_PEBOSBUILDNUMBER:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            auto checked = IsDlgButtonChecked(hDlg, IDC_PEBBEINGDEBUGGED)
                || IsDlgButtonChecked(hDlg, IDC_PEBHEAPFLAGS)
                || IsDlgButtonChecked(hDlg, IDC_PEBNTGLOBALFLAG)
                || IsDlgButtonChecked(hDlg, IDC_PEBSTARTUPINFO)
                || IsDlgButtonChecked(hDlg, IDC_PEBOSBUILDNUMBER);

            CheckDlgButton(hDlg, IDC_PEB, checked);
            break;
        }

#ifdef OLLY1
        case IDC_COMPRESSED:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            auto checked = (IsDlgButtonChecked(hDlg, IDC_COMPRESSED) == BST_CHECKED);

            EnableWindow(GetDlgItem(hDlg, IDC_COMPRESSEDANALYZE), checked);
            EnableWindow(GetDlgItem(hDlg, IDC_COMPRESSEDNOTHING), checked);

            if (!checked) {
                CheckDlgButton(hDlg, IDC_COMPRESSEDANALYZE, BST_UNCHECKED);
                CheckDlgButton(hDlg, IDC_COMPRESSEDNOTHING, BST_UNCHECKED);
            }
            break;
        }

        case IDC_LOADDLL:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            auto checked = (IsDlgButtonChecked(hDlg, IDC_LOADDLL) == BST_CHECKED);

            EnableWindow(GetDlgItem(hDlg, IDC_LOADDLLLOAD), checked);
            EnableWindow(GetDlgItem(hDlg, IDC_LOADDLLNOTHING), checked);

            if (!checked) {
                CheckDlgButton(hDlg, IDC_LOADDLLLOAD, BST_UNCHECKED);
                CheckDlgButton(hDlg, IDC_LOADDLLNOTHING, BST_UNCHECKED);
            }
            break;
        }
#endif

#ifdef __IDP__
        case IDC_DLLNORMAL:
        case IDC_DLLSTEALTH:
        case IDC_DLLUNLOAD:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            //DLL injection options need to be updated on-the-fly coz the injection button is ON the options window
            g_settings.opts().dllStealth = (IsDlgButtonChecked(hDlg, IDC_DLLSTEALTH) == BST_CHECKED);
            g_settings.opts().dllNormal = (IsDlgButtonChecked(hDlg, IDC_DLLNORMAL) == BST_CHECKED);
            g_settings.opts().dllUnload = (IsDlgButtonChecked(hDlg, IDC_DLLUNLOAD) == BST_CHECKED);
            break;
        }

        case IDC_INJECTDLL:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            if (ProcessId)
            {
                if (scl::GetFileDialogW(DllPathForInjection, _countof(DllPathForInjection)))
                {
                    if (dbg->is_remote())
                    {
                        SendInjectToServer(ProcessId);
                    }
                    else
                    {
#ifndef BUILD_IDA_64BIT
                        injectDll(ProcessId, DllPathForInjection);
#endif
                    }

                }
            }
            break;
        }

        case IDC_ATTACH:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            EndDialog(hDlg, NULL);
            DialogBoxW(hinst, MAKEINTRESOURCE(IDD_ATTACH), (HWND)callui(ui_get_hwnd).vptr, &AttachProc);
            break;
        }

        case IDC_ABOUT:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            scl::ShowAboutBox((HWND)callui(ui_get_hwnd).vptr);
            break;
        }
#endif

        case IDC_SELECT_EXCEPTIONS:
        {
            if (HIWORD(wParam) != BN_CLICKED)
                break;

            createExceptionWindow(hDlg);
            UpdateOptionsExceptions(hDlg, &g_settings);
            break;
        }

        default:
            break;
        }

    }
    break;

    default:
    {
        return FALSE;
    }
    }

    return 0;
}



typedef struct _NAME_TOOLTIP {
    const WCHAR * name;
    WCHAR * tooltip;
    ULONG_PTR windowId;
} NAME_TOOLTIP;


enum {
    ID_EXCEPTION_PRINT = 200,
    ID_EXCEPTION_RIP,
    ID_EXCEPTION_Noncontinable,
    ID_EXCEPTION_Illegal,
    ID_EXCEPTION_InvalidLockSequence,
    ID_EXCEPTION_AssertionFailure,
    ID_EXCEPTION_GuardPage,
    ID_EXCEPTION_Breakpoint,
    ID_EXCEPTION_Wx86Breakpoint,
    ID_EXCEPTION_APPLY,
    ID_EXCEPTION_CANCEL
};

NAME_TOOLTIP exceptionNamesTooltip[] = {
    { L"Print", L"DBG_PRINTEXCEPTION_C 0x40010006", ID_EXCEPTION_PRINT },
    { L"RIP", L"DBG_RIPEXCEPTION 0x40010007", ID_EXCEPTION_RIP },
#if defined(OLLY1) || defined(OLLY2)
    { L"Non-continuable", L"STATUS_NONCONTINUABLE_EXCEPTION 0xC0000025", ID_EXCEPTION_Noncontinable },
#endif
#ifdef OLLY1
    { L"Illegal Instruction", L"STATUS_ILLEGAL_INSTRUCTION 0xC000001D", ID_EXCEPTION_Illegal },
    { L"Invalid Lock Sequence", L"STATUS_INVALID_LOCK_SEQUENCE 0xC000001E", ID_EXCEPTION_InvalidLockSequence },
    { L"Guard Page Violation", L"STATUS_GUARD_PAGE_VIOLATION 0x80000001", ID_EXCEPTION_GuardPage },
    { L"Breakpoint", L"STATUS_BREAKPOINT 0x80000003", ID_EXCEPTION_Breakpoint },
    { L"WX86 Breakpoint", L"STATUS_WX86_BREAKPOINT 0x4000001F", ID_EXCEPTION_Wx86Breakpoint },
#endif
#ifdef __IDP__
    { L"Assertion Failure", L"STATUS_ASSERTION_FAILURE 0xC0000420", ID_EXCEPTION_AssertionFailure }
#endif
};

#define HEIGHT_OF_EXCEPTION_CHECKBOX 16
#define EXCEPTION_WINDOW_BASE_HEIGHT 46
#define EXCEPTION_WINDOW_WIDTH 200
LRESULT CALLBACK ExceptionSettingsWndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    RECT rect;
    LONG height;
    HINSTANCE hInst = GetModuleHandleW(0);

    if (msg == WM_CREATE)
    {
        int numOfExceptions = _countof(exceptionNamesTooltip);

        HWND control;
        GetClientRect(hwnd, &rect);
        height = rect.bottom;
        GetWindowRect(hwnd, &rect);
        height = rect.bottom - rect.top - height + (EXCEPTION_WINDOW_BASE_HEIGHT + (numOfExceptions*(HEIGHT_OF_EXCEPTION_CHECKBOX + 5))) + 5;
        SetWindowPos(hwnd, NULL, 0, 0, rect.right - rect.left, height, SWP_NOMOVE | SWP_NOZORDER);

        HFONT hFont;
        NONCLIENTMETRICSW metric = { 0 };
        metric.cbSize = sizeof(NONCLIENTMETRICSW);
        if (SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICSW), &metric, 0))
        {
            hFont = CreateFontIndirectW(&metric.lfMessageFont);
        }
        else
        {
            hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
        }

        HWND hwndTT = CreateWindowExW(WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hwnd, NULL, 0, NULL);

        for (int i = 0, j = 200; i < numOfExceptions; i++, j++)
        {
            control = CreateWindowExW(0, L"Button", exceptionNamesTooltip[i].name, WS_VISIBLE | WS_CHILD | BS_AUTOCHECKBOX, 1, i * 20, EXCEPTION_WINDOW_WIDTH, HEIGHT_OF_EXCEPTION_CHECKBOX, hwnd, (HMENU)exceptionNamesTooltip[i].windowId, hInst, NULL);
            SendMessageW(control, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(1, 0));

            TOOLINFOW ti = { 0 };

            ti.cbSize = TTTOOLINFOW_V1_SIZE;
            ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
            ti.hwnd = hwnd;
            ti.uId = (UINT_PTR)control;
            ti.lpszText = exceptionNamesTooltip[i].tooltip;

            SendMessageW(hwndTT, TTM_ADDTOOL, 0, (LPARAM)&ti);
        }

        if (g_settings.opts().handleExceptionPrint) CheckDlgButton(hwnd, ID_EXCEPTION_PRINT, BST_CHECKED);
        if (g_settings.opts().handleExceptionIllegalInstruction) CheckDlgButton(hwnd, ID_EXCEPTION_Illegal, BST_CHECKED);
        if (g_settings.opts().handleExceptionInvalidLockSequence) CheckDlgButton(hwnd, ID_EXCEPTION_InvalidLockSequence, BST_CHECKED);
        if (g_settings.opts().handleExceptionNoncontinuableException) CheckDlgButton(hwnd, ID_EXCEPTION_Noncontinable, BST_CHECKED);
        if (g_settings.opts().handleExceptionAssertionFailure) CheckDlgButton(hwnd, ID_EXCEPTION_AssertionFailure, BST_CHECKED);
        if (g_settings.opts().handleExceptionBreakpoint) CheckDlgButton(hwnd, ID_EXCEPTION_Breakpoint, BST_CHECKED);
        if (g_settings.opts().handleExceptionGuardPageViolation) CheckDlgButton(hwnd, ID_EXCEPTION_GuardPage, BST_CHECKED);
        if (g_settings.opts().handleExceptionWx86Breakpoint) CheckDlgButton(hwnd, ID_EXCEPTION_Wx86Breakpoint, BST_CHECKED);
        if (g_settings.opts().handleExceptionRip) CheckDlgButton(hwnd, ID_EXCEPTION_RIP, BST_CHECKED);

        control = CreateWindowExW(0, L"Button", L"Apply", WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON, 1, (numOfExceptions)* 20 + 1, 100, 25, hwnd, (HMENU)ID_EXCEPTION_APPLY, hInst, NULL);
        SendMessageW(control, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(1, 0));
        control = CreateWindowExW(0, L"Button", L"Cancel", WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON, 1, (numOfExceptions + 1) * 20 + 5, 100, 25, hwnd, (HMENU)ID_EXCEPTION_CANCEL, hInst, NULL);
        SendMessageW(control, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(1, 0));

        //DeleteObject(hFont);

    }
    else if (msg == WM_COMMAND)
    {
        if (LOWORD(wparam) == ID_EXCEPTION_APPLY)
        {
            g_settings.opts().handleExceptionPrint = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_PRINT) == BST_CHECKED);
            g_settings.opts().handleExceptionIllegalInstruction = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_Illegal) == BST_CHECKED);
            g_settings.opts().handleExceptionInvalidLockSequence = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_InvalidLockSequence) == BST_CHECKED);
            g_settings.opts().handleExceptionNoncontinuableException = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_Noncontinable) == BST_CHECKED);
            g_settings.opts().handleExceptionRip = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_RIP) == BST_CHECKED);
            g_settings.opts().handleExceptionGuardPageViolation = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_GuardPage) == BST_CHECKED);
            g_settings.opts().handleExceptionBreakpoint = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_Breakpoint) == BST_CHECKED);
            g_settings.opts().handleExceptionWx86Breakpoint = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_Wx86Breakpoint) == BST_CHECKED);
            g_settings.opts().handleExceptionAssertionFailure = (IsDlgButtonChecked(hwnd, ID_EXCEPTION_AssertionFailure) == BST_CHECKED);
            DestroyWindow(hwnd);
        }
        else if (LOWORD(wparam) == ID_EXCEPTION_CANCEL)
        {
            DestroyWindow(hwnd);
        }
    }
    else if (msg == WM_CLOSE)
    {
        DestroyWindow(hwnd);
    }
    else if (msg == WM_DESTROY)
    {
        PostQuitMessage(0);
    }
    return DefWindowProcW(hwnd, msg, wparam, lparam);
}


void createExceptionWindow(HWND hwnd)
{
    WCHAR * classname = L"exception_window_config_scyllahide";
    WNDCLASSW wc = { 0 };
    HWND     wnd;
    MSG      msg;
    //wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.hInstance = GetModuleHandleW(0);
    wc.style = CS_PARENTDC | CS_DBLCLKS;
    wc.lpfnWndProc = ExceptionSettingsWndproc;
    wc.lpszClassName = classname;
    RegisterClassW(&wc);

    int windowHeight = EXCEPTION_WINDOW_BASE_HEIGHT + (_countof(exceptionNamesTooltip)*(HEIGHT_OF_EXCEPTION_CHECKBOX + 5));

    wnd = CreateWindowExW(0,
        classname,
        L"Exception Settings",
        WS_VISIBLE | WS_SYSMENU | WS_OVERLAPPED | DS_SYSMODAL,
        (GetSystemMetrics(SM_CXSCREEN) - EXCEPTION_WINDOW_WIDTH) / 2,
        (GetSystemMetrics(SM_CYSCREEN) - windowHeight) / 2,
        EXCEPTION_WINDOW_WIDTH,
        windowHeight,
        hwnd,
        NULL,
        GetModuleHandleW(0),
        NULL);

    ShowWindow(wnd, SW_SHOWNORMAL);
    UpdateWindow(wnd);

    //EnableWindow(hwnd, FALSE);

    while (GetMessageW(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    //EnableWindow(hwnd, TRUE);
    UnregisterClassW(classname, 0);
}



================================================
File: PluginGeneric/OptionsDialog.h
================================================
#pragma once
#include <windows.h>

INT_PTR CALLBACK OptionsDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);



================================================
File: PluginGeneric/findere.bmp
================================================
[Non-text file]


================================================
File: PluginGeneric/finderf.bmp
================================================
[Non-text file]


================================================
File: PluginGeneric/searchwindow.cur
================================================
[Non-text file]


================================================
File: SCMRevGen/SCMRevGen.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{4CEF9C8E-91C8-4148-94B1-AF2A3B597762}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Utility</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup>
    <PreBuildEvent>
      <Command>cmd.exe /C "make_scmrev.h.bat"</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="make_scmrev.h.bat" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="scmrev.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: SCMRevGen/make_scmrev.h.bat
================================================
@echo off

set GIT_VERSION_NUMBER=0 
set GIT_SHORT_HASH=unknown

where git 1>nul 2>&1
if errorlevel 1 goto :nogit

for /f "usebackq delims=" %%i in (`git rev-list --count HEAD`) do (
	set GIT_VERSION_NUMBER=%%i
)
for /f "usebackq delims=" %%i in (`git rev-parse --short HEAD`) do (
	set GIT_SHORT_HASH=%%i
)

:nogit
set COMPILE_DATE=
for /f "usebackq delims=" %%i in (`date.exe +^"%%F %%H:%%M^"`) do (
	set COMPILE_DATE=%%i
)
set COMPILE_YEAR=
for /f "usebackq delims=" %%i in (`date.exe +^"%%Y^"`) do (
	set COMPILE_YEAR=%%i
)

echo #pragma once> scmrev.h
echo.>> scmrev.h
echo #define GIT_VERSION_NUMBER %GIT_VERSION_NUMBER%>> scmrev.h
echo #define GIT_SHORT_HASH_A "%GIT_SHORT_HASH%">> scmrev.h
echo #define GIT_SHORT_HASH_W L"%GIT_SHORT_HASH%">> scmrev.h
echo #define COMPILE_DATE_A "%COMPILE_DATE%">> scmrev.h
echo #define COMPILE_DATE_W L"%COMPILE_DATE%">> scmrev.h
echo #define COMPILE_YEAR_A "%COMPILE_YEAR%">> scmrev.h
echo #define COMPILE_YEAR_W L"%COMPILE_YEAR%">> scmrev.h



================================================
File: Scylla/Logger.cpp
================================================
#include "Logger.h"
#include <cassert>
#include <chrono>
#include <iomanip>
#include "Util.h"

const wchar_t scl::Logger::kFileName[] = L"scylla_hide.log";

scl::Logger::Logger()
{
    ZeroMemory(cb_a_, sizeof(cb_a_));
    ZeroMemory(cb_w_, sizeof(cb_w_));
}

scl::Logger::~Logger()
{
    if (file_.is_open())
        file_.close();
}

bool scl::Logger::SetLogFile(const wchar_t *filepath)
{
    if (file_.is_open())
        file_.close();

    file_.open(filepath);

    return file_.is_open();
}

void scl::Logger::LogDebug(const wchar_t *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    LogGeneric("DEBUG", cb_a_[Debug], cb_w_[Debug], fmt, ap);
    va_end(ap);
}

void scl::Logger::LogInfo(const wchar_t *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    LogGeneric("INFO", cb_a_[Info], cb_w_[Info], fmt, ap);
    va_end(ap);
}

void scl::Logger::LogError(const wchar_t *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    LogGeneric("ERROR", cb_a_[Error], cb_w_[Error], fmt, ap);
    va_end(ap);
}

void scl::Logger::LogGeneric(const char *prefix, LogCbA cb_a, LogCbW cb_w, const wchar_t *fmt, va_list ap)
{
    va_list vap;
    va_copy(vap, ap);
    auto strw = scl::vfmtw(fmt, ap);
    va_end(ap);

    if (cb_w)
        cb_w(strw.c_str());

    if (cb_a || file_.is_open())
    {
        auto stra = scl::wstr_conv().to_bytes(strw);

        if (cb_a)
            cb_a(stra.c_str());

        if (file_.is_open())
        {
            struct tm ltm;
            auto now = std::chrono::system_clock::now();
            auto now_t = std::chrono::system_clock::to_time_t(now);
            localtime_s(&ltm, &now_t);
            file_ << std::put_time(&ltm, "%Y.%m.%d %H:%M:%S ") << prefix << ": " << stra << std::endl;
            file_.flush();
        }
    }
}



================================================
File: Scylla/Logger.h
================================================
#pragma once

#include <cstdarg>
#include <fstream>

namespace scl {

    class Logger
    {
    public:
        typedef void(*LogCbA)(const char *msg);
        typedef void(*LogCbW)(const wchar_t *msg);

        enum Severity
        {
            Debug = 0,
            Info,
            Error,
            MaxSeverity
        };

        static const wchar_t kFileName[];

        Logger();
        ~Logger();

        bool SetLogFile(const wchar_t *filepath);

        void SetLogCb(Severity lvl, LogCbA cb)
        {
            cb_a_[lvl] = cb;
        }

        void SetLogCb(Severity lvl, LogCbW cb)
        {
            cb_w_[lvl] = cb;
        }

        void LogDebug(const wchar_t *fmt, ...);
        void LogInfo(const wchar_t *fmt, ...);
        void LogError(const wchar_t *fmt, ...);

    protected:
        void LogGeneric(const char *prefix, LogCbA cb_a, LogCbW cb_w, const wchar_t *fmt, va_list ap);

    private:
        LogCbA cb_a_[MaxSeverity];
        LogCbW cb_w_[MaxSeverity];
        std::ofstream file_;
    };

}



================================================
File: Scylla/NtApiShim.h
================================================
#pragma once

#include <ntdll/ntdll.h>

#ifndef FLG_HEAP_ENABLE_TAIL_CHECK
#define FLG_HEAP_ENABLE_TAIL_CHECK 0x10
#endif

#ifndef FLG_HEAP_ENABLE_FREE_CHECK
#define FLG_HEAP_ENABLE_FREE_CHECK 0x20
#endif

#ifndef FLG_HEAP_VALIDATE_PARAMETERS
#define FLG_HEAP_VALIDATE_PARAMETERS 0x40
#endif

#ifndef HEAP_SKIP_VALIDATION_CHECKS
#define HEAP_SKIP_VALIDATION_CHECKS 0x10000000
#endif

#ifndef HEAP_VALIDATE_PARAMETERS_ENABLED
#define HEAP_VALIDATE_PARAMETERS_ENABLED 0x40000000
#endif

#ifndef DBG_PRINTEXCEPTION_WIDE_C
#define DBG_PRINTEXCEPTION_WIDE_C ((DWORD)0x4001000A)
#endif

typedef NTSTATUS(WINAPI *t_NtWow64QueryInformationProcess64)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
typedef NTSTATUS(WINAPI *t_NtWow64ReadVirtualMemory64)(HANDLE ProcessHandle, PVOID64 BaseAddress, PVOID Buffer, ULONGLONG BufferSize, PULONGLONG NumberOfBytesRead);
typedef NTSTATUS(WINAPI *t_NtWow64WriteVirtualMemory64)(HANDLE ProcessHandle, PVOID64 BaseAddress, LPCVOID Buffer, ULONGLONG BufferSize, PULONGLONG NumberOfBytesWritten);


namespace scl
{
    template <typename PTR>
    struct UNICODE_STRING
    {
        union
        {
            struct
            {
                WORD Length;
                WORD MaximumLength;
            };
            PTR dummy;
        };
        PTR _Buffer;
    };

    template<typename PTR>
    struct CURDIR {
        UNICODE_STRING<PTR> DosPath;
        PTR Handle;
    };

    template<typename PTR>
    struct PROCESS_BASIC_INFORMATION
    {
        DWORD ExitStatus;
        PTR PebBaseAddress;
        PTR AffinityMask;
        DWORD BasePriority;
        PTR UniqueProcessId;
        PTR InheritedFromUniqueProcessId;
    };

    template<typename PTR>
    struct RTL_USER_PROCESS_PARAMETERS {
        ULONG MaximumLength;
        ULONG Length;

        ULONG Flags;
        ULONG DebugFlags;

        PTR ConsoleHandle;
        ULONG  ConsoleFlags;
        PTR StandardInput;
        PTR StandardOutput;
        PTR StandardError;

        CURDIR<PTR> CurrentDirectory;
        UNICODE_STRING<PTR> DllPath;
        UNICODE_STRING<PTR> ImagePathName;
        UNICODE_STRING<PTR> CommandLine;
        PTR Environment;

        ULONG StartingX;
        ULONG StartingY;
        ULONG CountX;
        ULONG CountY;
        ULONG CountCharsX;
        ULONG CountCharsY;
        ULONG FillAttribute;

        ULONG WindowFlags;
        ULONG ShowWindowFlags;
        UNICODE_STRING<PTR> WindowTitle;
        UNICODE_STRING<PTR> DesktopInfo;
        UNICODE_STRING<PTR> ShellInfo;
        UNICODE_STRING<PTR> RuntimeData;
    };
}



================================================
File: Scylla/OsInfo.cpp
================================================
#include "OsInfo.h"
#include "Peb.h"

/**
 * Operating system                Version number
 * Windows 10                      10.0*
 * Windows Server 2016             10.0*
 * Windows 8.1                     6.3*
 * Windows Server 2012 R2          6.3*
 * Windows 8                       6.2
 * Windows Server 2012             6.2
 * Windows 7                       6.1
 * Windows Server 2008 R2          6.1
 * Windows Server 2008             6.0
 * Windows Vista                   6.0
 * Windows Server 2003 R2          5.2
 * Windows Server 2003             5.2
 * Windows XP 64-Bit Edition       5.2
 * Windows XP                      5.1
 * Windows 2000                    5.0
 */

const SYSTEM_INFO *scl::GetNativeSystemInfo()
{
    static SYSTEM_INFO si = { 0 };
    static auto cached = false;

    if (!cached)
    {
        ::GetNativeSystemInfo(&si);
        cached = true;
    }

    return &si;
}

const RTL_OSVERSIONINFOEXW* scl::GetVersionExW()
{
    static RTL_OSVERSIONINFOEXW osVerInfo = { 0 };
    static auto cached = false;

    if (!cached)
    {
        osVerInfo.dwOSVersionInfoSize = sizeof(osVerInfo);
        RtlGetVersion((PRTL_OSVERSIONINFOW)&osVerInfo);
        auto peb = GetPebAddress(GetCurrentProcess());
        if (peb)
        {
            osVerInfo.dwMajorVersion = peb->OSMajorVersion;
            osVerInfo.dwMinorVersion = peb->OSMinorVersion;
        }
        cached = true;
    }

    return &osVerInfo;
}

bool scl::IsWindows64()
{
#ifdef _WIN64
    return true;
#else
    return (GetNativeSystemInfo()->wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64);
#endif
}

bool scl::IsWow64Process(HANDLE hProcess)
{
    auto fIsWow64 = FALSE;
    return ::IsWow64Process(hProcess, &fIsWow64) && (fIsWow64 == TRUE);
}


scl::eOsVersion scl::GetWindowsVersion()
{
    static auto version = OS_UNKNOWN;

    if (version != OS_UNKNOWN)
        return version;

    version = OS_INVALID;

    const auto osVerInfo = GetVersionExW();

    if (osVerInfo->dwMajorVersion == 5)
    {
        if (osVerInfo->dwMinorVersion == 0)
        {
            version = OS_WIN_2000;
        }
        else if (osVerInfo->dwMinorVersion == 1)
        {
            version = OS_WIN_XP;
        }
        else if (osVerInfo->dwMinorVersion == 2)
        {
            version = OS_WIN_XP64;
        }
    }
    else if (osVerInfo->dwMajorVersion == 6)
    {
        if (osVerInfo->dwMinorVersion == 0)
        {
            version = OS_WIN_VISTA;
        }
        else if (osVerInfo->dwMinorVersion == 1)
        {
            version = OS_WIN_7;
        }
        else if (osVerInfo->dwMinorVersion == 2)
        {
            version = OS_WIN_8;
        }
        else if (osVerInfo->dwMinorVersion == 3)
        {
            version = OS_WIN_81;
        }
    }
    else if (osVerInfo->dwMajorVersion == 10) {
        if (osVerInfo->dwMinorVersion == 0) {
            version = OS_WIN_10;
        }
    }

    return version;
}

const char *scl::GetWindowsVersionNameA()
{
    switch (GetWindowsVersion())
    {
    case OS_WIN_XP:
        return "Windows XP";
    case OS_WIN_XP64:
        return "Windows XP 64 / Server 2003";
    case OS_WIN_VISTA:
        return "Windows Vista / Server 2008";
    case OS_WIN_7:
        return "Windows 7 / Server 2008 R2";
    case OS_WIN_8:
        return "Windows 8 / Server 2012";
    case OS_WIN_81:
        return "Windows 8.1 / Server 2012 R2";
    case OS_WIN_10:
        return "Windows 10 / Server 2016";
    default:
        return "Unknown Windows";
    }
}



================================================
File: Scylla/OsInfo.h
================================================
#pragma once

#include <windows.h>

namespace scl
{
    enum eOsVersion {
        OS_UNKNOWN,
        OS_INVALID,
        OS_WIN_2000,
        OS_WIN_XP,
        OS_WIN_XP64,
        OS_WIN_VISTA,
        OS_WIN_7,
        OS_WIN_8,
        OS_WIN_81,
        OS_WIN_10
    };

    const SYSTEM_INFO *GetNativeSystemInfo();
    const RTL_OSVERSIONINFOEXW* GetVersionExW();

    bool IsWindows64();
    bool IsWow64Process(HANDLE hProcess);
    eOsVersion GetWindowsVersion();
    const char *GetWindowsVersionNameA();
}



================================================
File: Scylla/Peb.cpp
================================================
#include "Peb.h"
#include <Scylla/NtApiShim.h>
#include <Scylla/OsInfo.h>
#include "Util.h"

scl::PEB *scl::GetPebAddress(HANDLE hProcess)
{
    ::PROCESS_BASIC_INFORMATION pbi = { 0 };

    auto status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr);

    return NT_SUCCESS(status) ? (PEB *)pbi.PebBaseAddress : nullptr;
}

/**
 * Get PEB64 address of WOW64 process.
 */
PVOID64 scl::GetPeb64Address(HANDLE hProcess)
{
#ifndef _WIN64
    PROCESS_BASIC_INFORMATION<DWORD64> pbi = { 0 };

    bool success = Wow64QueryInformationProcess64(hProcess, ProcessBasicInformation, &pbi, sizeof(pbi), nullptr);

    return success ? (PVOID64)pbi.PebBaseAddress : nullptr;
#endif

    return nullptr;
}

std::shared_ptr<scl::PEB> scl::GetPeb(HANDLE hProcess)
{
    auto peb_addr = GetPebAddress(hProcess);
    if (!peb_addr)
        return nullptr;

    auto peb = std::make_shared<PEB>();
    if (!ReadProcessMemory(hProcess, peb_addr, peb.get(), sizeof(PEB), nullptr))
        return nullptr;

    return peb;
}

/**
 * @remark Use only real process handles.
 */
std::shared_ptr<scl::PEB64> scl::Wow64GetPeb64(HANDLE hProcess)
{
#ifndef _WIN64
    auto peb64_addr = GetPeb64Address(hProcess);
    if (!peb64_addr)
        return nullptr;

    auto peb64 = std::make_shared<PEB64>();

    if (Wow64ReadProcessMemory64(hProcess, peb64_addr, peb64.get(), sizeof(PEB64), nullptr))
        return peb64;
#endif

    return nullptr;
}

bool scl::SetPeb(HANDLE hProcess, const PEB *pPeb)
{
    auto peb_addr = GetPebAddress(hProcess);
    if (!peb_addr)
        return false;

    return WriteProcessMemory(hProcess, peb_addr, pPeb, sizeof(*pPeb), nullptr) == TRUE;
}

/**
 * @remark Use only real process handles.
 */
bool scl::Wow64SetPeb64(HANDLE hProcess, const PEB64 *pPeb64)
{
#ifndef _WIN64
    auto peb64_addr = GetPeb64Address(hProcess);
    if (!peb64_addr)
        return false;

    return NT_SUCCESS(Wow64WriteProcessMemory64(hProcess, peb64_addr, pPeb64, sizeof(*pPeb64), nullptr));
#endif

    return false;
}

PVOID64 scl::Wow64GetModuleHandle64(HANDLE hProcess, const wchar_t* moduleName)
{
    const auto Peb64 = Wow64GetPeb64(hProcess);
    if (Peb64 == nullptr)
        return nullptr;

    PEB_LDR_DATA64 LdrData64;
    if (!Wow64ReadProcessMemory64(hProcess, (PVOID64)Peb64->Ldr, &LdrData64, sizeof(LdrData64), nullptr))
        return nullptr;

    PVOID64 DllBase = nullptr;
    const ULONG64 LastEntry = Peb64->Ldr + offsetof(PEB_LDR_DATA64, InLoadOrderModuleList);
    LDR_DATA_TABLE_ENTRY64 Head;
    Head.InLoadOrderLinks.Flink = LdrData64.InLoadOrderModuleList.Flink;

    do
    {
        if (!Wow64ReadProcessMemory64(hProcess, (PVOID64)Head.InLoadOrderLinks.Flink, &Head, sizeof(Head), nullptr))
            break;

        wchar_t* BaseDllName = (wchar_t*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, Head.BaseDllName.MaximumLength);
        if (BaseDllName == nullptr ||
            !Wow64ReadProcessMemory64(hProcess, (PVOID64)Head.BaseDllName.Buffer, BaseDllName, Head.BaseDllName.MaximumLength, nullptr))
            break;

        if (_wcsicmp(moduleName, BaseDllName) == 0)
        {
            DllBase = (PVOID64)Head.DllBase;
        }

        RtlFreeHeap(RtlProcessHeap(), 0, BaseDllName);

    } while (Head.InLoadOrderLinks.Flink != LastEntry && DllBase == nullptr);

    return DllBase;
}

DWORD scl::GetHeapFlagsOffset(bool x64)
{
    if (x64)
    {
        if (scl::GetWindowsVersion() >= scl::OS_WIN_VISTA)
            return 0x70;
        else
            return 0x14;
    }
    else
    {
        if (scl::GetWindowsVersion() >= scl::OS_WIN_VISTA)
            return 0x40;
        else
            return 0x0C;
    }
}

DWORD scl::GetHeapForceFlagsOffset(bool x64)
{
    if (x64)
    {
        if (scl::GetWindowsVersion() >= scl::OS_WIN_VISTA)
            return 0x74;
        else
            return 0x18;
    }
    else
    {
        if (scl::GetWindowsVersion() >= scl::OS_WIN_VISTA)
            return 0x44;
        else
            return 0x10;
    }
}



================================================
File: Scylla/Peb.h
================================================
#pragma once

#include <windows.h>
#include <memory>

#include "NtApiShim.h"

//
// http://terminus.rewolf.pl/terminus/structures/ntdll/_PEB_combined.html
//

namespace scl {

#pragma pack(push, 1)
    template <class T>
    struct _LIST_ENTRY_T
    {
        T Flink;
        T Blink;
    };

    template <class T>
    struct _UNICODE_STRING_T
    {
        union
        {
            struct
            {
                WORD Length;
                WORD MaximumLength;
            };
            T dummy;
        };
        T Buffer;
    };

    template <class T>
    struct _LDR_DATA_TABLE_ENTRY_T
    {
        _LIST_ENTRY_T<T> InLoadOrderLinks;
        _LIST_ENTRY_T<T> InMemoryOrderLinks;
        _LIST_ENTRY_T<T> InInitializationOrderLinks;
        T DllBase;
        T EntryPoint;
        union
        {
            DWORD SizeOfImage;
            T dummy01;
        };
        _UNICODE_STRING_T<T> FullDllName;
        _UNICODE_STRING_T<T> BaseDllName;
        DWORD Flags;
        WORD LoadCount;
        WORD TlsIndex;
        union
        {
            _LIST_ENTRY_T<T> HashLinks;
            struct
            {
                T SectionPointer;
                T CheckSum;
            };
        };
        union
        {
            T LoadedImports;
            DWORD TimeDateStamp;
        };
        T EntryPointActivationContext;
        T PatchInformation;
        _LIST_ENTRY_T<T> ForwarderLinks;
        _LIST_ENTRY_T<T> ServiceTagLinks;
        _LIST_ENTRY_T<T> StaticLinks;
        T ContextInformation;
        T OriginalBase;
        _LARGE_INTEGER LoadTime;
    };

    template <class T>
    struct _PEB_LDR_DATA_T
    {
        DWORD Length;
        DWORD Initialized;
        T SsHandle;
        _LIST_ENTRY_T<T> InLoadOrderModuleList;
        _LIST_ENTRY_T<T> InMemoryOrderModuleList;
        _LIST_ENTRY_T<T> InInitializationOrderModuleList;
        T EntryInProgress;
        DWORD ShutdownInProgress;
        T ShutdownThreadId;

    };

    template <typename T, typename NGF, int A>
    struct _PEB_T
    {
        union
        {
            struct
            {
                BYTE InheritedAddressSpace;
                BYTE ReadImageFileExecOptions;
                BYTE BeingDebugged;
                BYTE _SYSTEM_DEPENDENT_01;
            };
            T dummy01;
        };
        T Mutant;
        T ImageBaseAddress;
        T Ldr;
        T ProcessParameters;
        T SubSystemData;
        T ProcessHeap;
        T FastPebLock;
        T _SYSTEM_DEPENDENT_02;
        T _SYSTEM_DEPENDENT_03;
        T _SYSTEM_DEPENDENT_04;
        union
        {
            T KernelCallbackTable;
            T UserSharedInfoPtr;
        };
        DWORD SystemReserved;
        DWORD _SYSTEM_DEPENDENT_05;
        T _SYSTEM_DEPENDENT_06;
        T TlsExpansionCounter;
        T TlsBitmap;
        DWORD TlsBitmapBits[2];
        T ReadOnlySharedMemoryBase;
        T _SYSTEM_DEPENDENT_07;
        T ReadOnlyStaticServerData;
        T AnsiCodePageData;
        T OemCodePageData;
        T UnicodeCaseTableData;
        DWORD NumberOfProcessors;
        union
        {
            DWORD NtGlobalFlag;
            NGF dummy02;
        };
        LARGE_INTEGER CriticalSectionTimeout;
        T HeapSegmentReserve;
        T HeapSegmentCommit;
        T HeapDeCommitTotalFreeThreshold;
        T HeapDeCommitFreeBlockThreshold;
        DWORD NumberOfHeaps;
        DWORD MaximumNumberOfHeaps;
        T ProcessHeaps;
        T GdiSharedHandleTable;
        T ProcessStarterHelper;
        T GdiDCAttributeList;
        T LoaderLock;
        DWORD OSMajorVersion;
        DWORD OSMinorVersion;
        WORD OSBuildNumber;
        WORD OSCSDVersion;
        DWORD OSPlatformId;
        DWORD ImageSubsystem;
        DWORD ImageSubsystemMajorVersion;
        T ImageSubsystemMinorVersion;
        union
        {
            T ImageProcessAffinityMask;
            T ActiveProcessAffinityMask;
        };
        T GdiHandleBuffer[A];
        T PostProcessInitRoutine;
        T TlsExpansionBitmap;
        DWORD TlsExpansionBitmapBits[32];
        T SessionId;
        ULARGE_INTEGER AppCompatFlags;
        ULARGE_INTEGER AppCompatFlagsUser;
        T pShimData;
        T AppCompatInfo;
        UNICODE_STRING<T> CSDVersion;
        T ActivationContextData;
        T ProcessAssemblyStorageMap;
        T SystemDefaultActivationContextData;
        T SystemAssemblyStorageMap;
        T MinimumStackCommit;
    };
#pragma pack(pop)

    typedef _LDR_DATA_TABLE_ENTRY_T<DWORD> LDR_DATA_TABLE_ENTRY32;
    typedef _LDR_DATA_TABLE_ENTRY_T<DWORD64> LDR_DATA_TABLE_ENTRY64;

    typedef _PEB_LDR_DATA_T<DWORD> PEB_LDR_DATA32;
    typedef _PEB_LDR_DATA_T<DWORD64> PEB_LDR_DATA64;

    typedef _PEB_T<DWORD, DWORD64, 34> PEB32;
    typedef _PEB_T<DWORD64, DWORD, 30> PEB64;

#ifdef _WIN64
    typedef PEB64 PEB;
#else
    typedef PEB32 PEB;
#endif

    PEB *GetPebAddress(HANDLE hProcess);
    PVOID64 GetPeb64Address(HANDLE hProcess);

    std::shared_ptr<PEB> GetPeb(HANDLE hProcess);
    std::shared_ptr<PEB64> Wow64GetPeb64(HANDLE hProcess);

    bool SetPeb(HANDLE hProcess, const PEB *pPeb);
    bool Wow64SetPeb64(HANDLE hProcess, const PEB64 *pPeb64);

    PVOID64 Wow64GetModuleHandle64(HANDLE hProcess, const wchar_t* moduleName);

    DWORD GetHeapFlagsOffset(bool x64);
    DWORD GetHeapForceFlagsOffset(bool x64);
    }



================================================
File: Scylla/PebHider.cpp
================================================
#include "PebHider.h"
#include <vector>
#include <Scylla/NtApiShim.h>
#include <Scylla/Peb.h>
#include <Scylla/OsInfo.h>
#include <Scylla/Util.h>

#define HEAP_VALIDATE_ALL_ENABLED       0x20000000
#define HEAP_CAPTURE_STACK_BACKTRACES   0x08000000

// Flags set by RtlDebugCreateHeap
#define RTLDEBUGCREATEHEAP_HEAP_FLAGS   (HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED | HEAP_SKIP_VALIDATION_CHECKS)

// Additional debug flags that may be set depending on NtGlobalFlags
#define NTGLOBALFLAGS_HEAP_FLAGS        (HEAP_DISABLE_COALESCE_ON_FREE | HEAP_FREE_CHECKING_ENABLED | HEAP_TAIL_CHECKING_ENABLED | \
                                        HEAP_VALIDATE_ALL_ENABLED | HEAP_VALIDATE_PARAMETERS_ENABLED | HEAP_CAPTURE_STACK_BACKTRACES)

// The set of heap flags to clear is the union of flags set by RtlDebugCreateHeap and NtGlobalFlags
#define HEAP_CLEARABLE_FLAGS            (RTLDEBUGCREATEHEAP_HEAP_FLAGS | NTGLOBALFLAGS_HEAP_FLAGS)

// Only a subset of possible flags passed to RtlCreateHeap persists into force flags
#define HEAP_VALID_FORCE_FLAGS          (HEAP_NO_SERIALIZE | HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY | HEAP_REALLOC_IN_PLACE_ONLY | \
                                        HEAP_VALIDATE_PARAMETERS_ENABLED | HEAP_VALIDATE_ALL_ENABLED | HEAP_TAIL_CHECKING_ENABLED | \
                                        HEAP_CREATE_ALIGN_16 | HEAP_FREE_CHECKING_ENABLED)

// The set of force flags to clear is the intersection of valid force flags and the debug flags
#define HEAP_CLEARABLE_FORCE_FLAGS      (HEAP_CLEARABLE_FLAGS & HEAP_VALID_FORCE_FLAGS)

bool scl::PebPatchProcessParameters(PEB* peb, HANDLE hProcess)
{
    RTL_USER_PROCESS_PARAMETERS<DWORD_PTR> rupp;

    if (ReadProcessMemory(hProcess, (PVOID)peb->ProcessParameters, &rupp, sizeof(rupp), nullptr) == FALSE)
        return false;

    // Some debuggers manipulate StartUpInfo to start the debugged process and therefore can be detected...
    auto patch_size = (DWORD_PTR)&rupp.WindowFlags - (DWORD_PTR)&rupp.StartingX;
    ZeroMemory(&rupp.WindowFlags, patch_size);

    // https://github.com/x64dbg/ScyllaHide/issues/99
    rupp.WindowFlags = STARTF_USESHOWWINDOW;
    rupp.ShowWindowFlags = SW_SHOWNORMAL;

    // If the debugger used IFEO, the app doesn't need to know that
    rupp.Flags |= RTL_USER_PROCESS_PARAMETERS_IMAGE_KEY_MISSING;

    return (WriteProcessMemory(hProcess, (PVOID)peb->ProcessParameters, &rupp, sizeof(rupp), nullptr) == TRUE);
}

bool scl::Wow64Peb64PatchProcessParameters(PEB64* peb64, HANDLE hProcess)
{
#ifndef _WIN64
    scl::RTL_USER_PROCESS_PARAMETERS<DWORD64> rupp;

    if (!scl::Wow64ReadProcessMemory64(hProcess, (PVOID64)peb64->ProcessParameters, (PVOID)&rupp, sizeof(rupp), nullptr))
        return false;

    // Some debuggers manipulate StartUpInfo to start the debugged process and therefore can be detected...
    auto patch_size = (DWORD_PTR)&rupp.WindowFlags - (DWORD_PTR)&rupp.StartingX;
    ZeroMemory(&rupp.WindowFlags, patch_size);

    // https://github.com/x64dbg/ScyllaHide/issues/99
    rupp.WindowFlags = STARTF_USESHOWWINDOW;
    rupp.ShowWindowFlags = SW_SHOWNORMAL;

    // If the debugger used IFEO, the app doesn't need to know that
    rupp.Flags |= RTL_USER_PROCESS_PARAMETERS_IMAGE_KEY_MISSING;

    return Wow64WriteProcessMemory64(hProcess, (PVOID)peb64->ProcessParameters, &rupp, sizeof(rupp), nullptr);
#endif

    return false;
}

bool scl::PebPatchHeapFlags(PEB* peb, HANDLE hProcess)
{
#ifdef _WIN64
    const auto is_x64 = true;
#else
    const auto is_x64 = false;
#endif

    std::vector<PVOID> heaps;
    heaps.resize(peb->NumberOfHeaps);

    if (ReadProcessMemory(hProcess, (PVOID)peb->ProcessHeaps, (PVOID)heaps.data(), heaps.size()*sizeof(PVOID), nullptr) == FALSE)
        return false;

    std::basic_string<uint8_t> heap;
    heap.resize(0x100); // hacky
    for (DWORD i = 0; i < peb->NumberOfHeaps; i++)
    {
        if (ReadProcessMemory(hProcess, heaps[i], (PVOID)heap.data(), heap.size(), nullptr) == FALSE)
            return false;

        auto flags = (DWORD *)(heap.data() + scl::GetHeapFlagsOffset(is_x64));
        auto force_flags = (DWORD *)(heap.data() + scl::GetHeapForceFlagsOffset(is_x64));

        *flags &= ~HEAP_CLEARABLE_FLAGS;

        *force_flags &= ~HEAP_CLEARABLE_FORCE_FLAGS;

        if (WriteProcessMemory(hProcess, heaps[i], (PVOID)heap.data(), heap.size(), nullptr) == FALSE)
            return false;
    }

    return true;
}

bool scl::Wow64Peb64PatchHeapFlags(PEB64* peb, HANDLE hProcess)
{
    std::vector<PVOID64> heaps;
    heaps.resize(peb->NumberOfHeaps);

    if (scl::Wow64ReadProcessMemory64(hProcess, (PVOID64)peb->ProcessHeaps, (PVOID)heaps.data(), heaps.size()*sizeof(PVOID64), nullptr) == FALSE)
        return false;

    std::basic_string<uint8_t> heap;
    heap.resize(0x100); // hacky
    for (DWORD i = 0; i < peb->NumberOfHeaps; i++)
    {
        if (Wow64ReadProcessMemory64(hProcess, (PVOID64)heaps[i], (PVOID)heap.data(), heap.size(), nullptr) == FALSE)
            return false;

        auto flags = (DWORD *)(heap.data() + scl::GetHeapFlagsOffset(true));
        auto force_flags = (DWORD *)(heap.data() + scl::GetHeapForceFlagsOffset(true));

        *flags &= ~HEAP_CLEARABLE_FLAGS;

        *force_flags &= ~HEAP_CLEARABLE_FORCE_FLAGS;

        if (Wow64WriteProcessMemory64(hProcess, (PVOID64)heaps[i], (PVOID)heap.data(), heap.size(), nullptr) == FALSE)
            return false;
    }

    return true;
}



================================================
File: Scylla/PebHider.h
================================================
#pragma once

#include "Peb.h"

#define PEB_PATCH_BeingDebugged         0x00000001
#define PEB_PATCH_NtGlobalFlag          0x00000002
#define PEB_PATCH_HeapFlags             0x00000004
#define PEB_PATCH_ProcessParameters     0x00000008
#define PEB_PATCH_OsBuildNumber         0x00000010

namespace scl
{
    bool PebPatchProcessParameters(PEB* peb, HANDLE hProcess);
    bool Wow64Peb64PatchProcessParameters(PEB64* peb64, HANDLE hProcess);

    bool PebPatchHeapFlags(PEB* peb, HANDLE hProcess);
    bool Wow64Peb64PatchHeapFlags(PEB64* peb64, HANDLE hProcess);
}



================================================
File: Scylla/Resource.h
================================================
#pragma once

#include <Windows.h>

namespace scl
{
    class Handle
    {
    public:
        explicit Handle(HANDLE handle) : handle_(handle) {}
        ~Handle()
        {
            if (handle_ && (handle_ != INVALID_HANDLE_VALUE))
                CloseHandle(handle_);
        }

        Handle(const Handle &other) = delete;
        Handle &operator=(const Handle &other) = delete;

        HANDLE get() const { return handle_; }

    private:
        HANDLE handle_;
    };
}



================================================
File: Scylla/Scylla.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Logger.cpp" />
    <ClCompile Include="PebHider.cpp" />
    <ClCompile Include="Settings.cpp" />
    <ClCompile Include="OsInfo.cpp" />
    <ClCompile Include="Peb.cpp" />
    <ClCompile Include="User32Loader.cpp" />
    <ClCompile Include="Util.cpp" />
    <ClCompile Include="Version.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Logger.h" />
    <ClInclude Include="NtApiShim.h" />
    <ClInclude Include="PebHider.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="Settings.h" />
    <ClInclude Include="OsInfo.h" />
    <ClInclude Include="Peb.h" />
    <ClInclude Include="User32Loader.h" />
    <ClInclude Include="Util.h" />
    <ClInclude Include="Version.h" />
    <ClInclude Include="Win32kSyscalls.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\SCMRevGen\SCMRevGen.vcxproj">
      <Project>{4cef9c8e-91c8-4148-94b1-af2a3b597762}</Project>
    </ProjectReference>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{E468DA07-48EA-40EB-A845-FA69C39D3396}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Scylla</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Lib>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Lib>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>


================================================
File: Scylla/Scylla.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Peb.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="OsInfo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Settings.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Version.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Logger.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PebHider.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="User32Loader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Peb.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="OsInfo.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Settings.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Version.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Logger.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NtApiShim.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PebHider.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="User32Loader.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Win32kSyscalls.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


================================================
File: Scylla/Settings.cpp
================================================
#include "Settings.h"
#include <algorithm>

#include "Util.h"

#define SCYLLA_HIDE_SETTINGS_SECTION                L"SETTINGS"
#define SCYLLA_HIDE_SETTINGS_CURRENT_PROFILE_KEY    L"CurrentProfile"
#define SCYLLA_HIDE_SETTINGS_DEFAULT_PROFILE        L"SCYLLA_HIDE"

const wchar_t scl::Settings::kFileName[] = L"scylla_hide.ini";

void scl::Settings::Load(const wchar_t *ini_path)
{
    ini_path_ = ini_path;
    profile_names_ = IniLoadSectionNames(ini_path);
    profile_names_.erase(std::remove(profile_names_.begin(), profile_names_.end(), SCYLLA_HIDE_SETTINGS_SECTION), profile_names_.end());

    profile_name_ = IniLoadString(ini_path, SCYLLA_HIDE_SETTINGS_SECTION, SCYLLA_HIDE_SETTINGS_CURRENT_PROFILE_KEY, SCYLLA_HIDE_SETTINGS_DEFAULT_PROFILE);
    LoadProfile(ini_path_.c_str(), profile_name_.c_str(), &profile_);
}

bool scl::Settings::Save() const
{
    if (!FileExistsW(ini_path_.c_str()))
    {
        WORD wBOM = 0xFEFF; // UTF16-LE
        DWORD NumberOfBytesWritten;

        auto hFile = CreateFileW(ini_path_.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, nullptr);
        if (!hFile)
            return false;
        WriteFile(hFile, &wBOM, sizeof(WORD), &NumberOfBytesWritten, nullptr);
        CloseHandle(hFile);
    }

    return SaveProfile(ini_path_.c_str(), profile_name_.c_str(), &profile_);
}

bool scl::Settings::AddProfile(const wchar_t *name)
{
    if (std::find(profile_names_.begin(), profile_names_.end(), name) != profile_names_.end())
        return false;

    profile_names_.push_back(name);
    return true;
}

void scl::Settings::SetProfile(const wchar_t *name)
{
    if (profile_name_ == name)
        return;

    profile_name_ = name;
    IniSaveString(ini_path_.c_str(), SCYLLA_HIDE_SETTINGS_SECTION, SCYLLA_HIDE_SETTINGS_CURRENT_PROFILE_KEY, name);

    LoadProfile(ini_path_.c_str(), name, &profile_);
}


void scl::Settings::LoadProfile(const wchar_t *file, const wchar_t *name, Profile *profile)
{
    profile->dllNormal = IniLoadNum(file, name, L"DLLNormal", 1);
    profile->dllStealth = IniLoadNum(file, name, L"DLLStealth", 0);
    profile->dllUnload = IniLoadNum(file, name, L"DLLUnload", 0);

    profile->hookGetLocalTime = IniLoadNum(file, name, L"GetLocalTimeHook", 1);
    profile->hookGetSystemTime = IniLoadNum(file, name, L"GetSystemTimeHook", 1);
    profile->hookGetTickCount = IniLoadNum(file, name, L"GetTickCountHook", 1);
    profile->hookGetTickCount64 = IniLoadNum(file, name, L"GetTickCount64Hook", 1);
    profile->hookKiUserExceptionDispatcher = IniLoadNum(file, name, L"KiUserExceptionDispatcherHook", 1);
    profile->hookNtClose = IniLoadNum(file, name, L"NtCloseHook", 1);
    profile->hookNtContinue = IniLoadNum(file, name, L"NtContinueHook", 1);
    profile->hookNtCreateThreadEx = IniLoadNum(file, name, L"NtCreateThreadExHook", 1);
    profile->hookNtGetContextThread = IniLoadNum(file, name, L"NtGetContextThreadHook", 1);
    profile->hookNtQueryInformationProcess = IniLoadNum(file, name, L"NtQueryInformationProcessHook", 1);
    profile->hookNtQueryObject = IniLoadNum(file, name, L"NtQueryObjectHook", 1);
    profile->hookNtQueryPerformanceCounter = IniLoadNum(file, name, L"NtQueryPerformanceCounterHook", 1);
    profile->hookNtQuerySystemInformation = IniLoadNum(file, name, L"NtQuerySystemInformationHook", 1);
    profile->hookNtQuerySystemTime = IniLoadNum(file, name, L"NtQuerySystemTimeHook", 1);
    profile->hookNtSetContextThread = IniLoadNum(file, name, L"NtSetContextThreadHook", 1);
    profile->hookNtSetDebugFilterState = IniLoadNum(file, name, L"NtSetDebugFilterStateHook", 1);
    profile->hookNtSetInformationThread = IniLoadNum(file, name, L"NtSetInformationThreadHook", 1);
    profile->hookNtSetInformationProcess = IniLoadNum(file, name, L"NtSetInformationProcessHook", 1);
    profile->hookNtUserBlockInput = IniLoadNum(file, name, L"NtUserBlockInputHook", 1);
    profile->hookNtUserBuildHwndList = IniLoadNum(file, name, L"NtUserBuildHwndListHook", 1);
    profile->hookNtUserFindWindowEx = IniLoadNum(file, name, L"NtUserFindWindowExHook", 1);
    profile->hookNtUserQueryWindow = IniLoadNum(file, name, L"NtUserQueryWindowHook", 1);
    profile->hookNtUserGetForegroundWindow = IniLoadNum(file, name, L"NtUserGetForegroundWindowHook", 1);
    profile->hookNtYieldExecution = IniLoadNum(file, name, L"NtYieldExecutionHook", 1);
    profile->hookOutputDebugStringA = IniLoadNum(file, name, L"OutputDebugStringHook", 1);

    profile->fixPebBeingDebugged = IniLoadNum(file, name, L"PebBeingDebugged", 1);
    profile->fixPebHeapFlags = IniLoadNum(file, name, L"PebHeapFlags", 1);
    profile->fixPebNtGlobalFlag = IniLoadNum(file, name, L"PebNtGlobalFlag", 1);
    profile->fixPebStartupInfo = IniLoadNum(file, name, L"PebStartupInfo", 1);
    profile->fixPebOsBuildNumber = IniLoadNum(file, name, L"PebOsBuildNumber", 1);

    profile->preventThreadCreation = IniLoadNum(file, name, L"PreventThreadCreation", 0);
    profile->protectProcessId = IniLoadNum(file, name, L"ProtectProcessId", 1);
    profile->removeDebugPrivileges = IniLoadNum(file, name, L"RemoveDebugPrivileges", 1);
    profile->killAntiAttach = IniLoadNum(file, name, L"KillAntiAttach", 1);
    profile->malwareRunpeUnpacker = IniLoadNum(file, name, L"MalwareRunPeUnpacker", 0);

    profile->handleExceptionPrint = IniLoadNum(file, name, L"handleExceptionPrint", 1);
    profile->handleExceptionRip = IniLoadNum(file, name, L"handleExceptionRip", 1);
    profile->handleExceptionIllegalInstruction = IniLoadNum(file, name, L"handleExceptionIllegalInstruction", 1);
    profile->handleExceptionInvalidLockSequence = IniLoadNum(file, name, L"handleExceptionInvalidLockSequence", 1);
    profile->handleExceptionNoncontinuableException = IniLoadNum(file, name, L"handleExceptionNoncontinuableException", 1);
    profile->handleExceptionAssertionFailure = IniLoadNum(file, name, L"handleExceptionAssertionFailure", 1);
    profile->handleExceptionBreakpoint = IniLoadNum(file, name, L"handleExceptionBreakpoint", 1);
    profile->handleExceptionGuardPageViolation = IniLoadNum(file, name, L"handleExceptionGuardPageViolation", 1);
    profile->handleExceptionWx86Breakpoint = IniLoadNum(file, name, L"handleExceptionWx86Breakpoint", 1);

    profile->idaAutoStartServer = IniLoadNum(file, name, L"AutostartServer", 1);
    profile->idaServerPort = IniLoadString(file, name, L"ServerPort", L"1337");

    profile->ollyBreakOnTls = IniLoadNum(file, name, L"BreakOnTLS", 1);
    profile->ollyFixBugs = IniLoadNum(file, name, L"FixOllyBugs", 1);
    profile->ollyRemoveEpBreak = IniLoadNum(file, name, L"RemoveEPBreak", 0);
    profile->ollySkipEpOutsideCode = IniLoadNum(file, name, L"SkipEPOutsideCode", 1);
    profile->ollyX64Fix = IniLoadNum(file, name, L"X64Fix", 0);
    profile->ollyAdvancedGoto = IniLoadNum(file, name, L"advancedGoto", 0);
    profile->ollyIgnoreBadPeImage = IniLoadNum(file, name, L"ignoreBadPEImage", 0);
    profile->ollySkipCompressedDoAnalyze = IniLoadNum(file, name, L"skipCompressedDoAnalyze", 0);
    profile->ollySkipCompressedDoNothing = IniLoadNum(file, name, L"skipCompressedDoNothing", 0);
    profile->ollySkipLoadDllDoLoad = IniLoadNum(file, name, L"skipLoadDllDoLoad", 0);
    profile->ollySkipLoadDllDoNothing = IniLoadNum(file, name, L"skipLoadDllDoNothing", 0);
    profile->ollyAdvancedInfobar = IniLoadNum(file, name, L"advancedInfobar", 0);
    profile->ollyWindowTitle = IniLoadString(file, name, L"WindowTitle", L"ScyllaHide");

    if (profile->dllNormal)
        profile->dllStealth = FALSE;
}

bool scl::Settings::SaveProfile(const wchar_t *file, const wchar_t *name, const Profile *profile)
{
    auto success = true;

    success &= IniSaveNum(file, name, L"DLLNormal", profile->dllNormal);
    success &= IniSaveNum(file, name, L"DLLStealth", profile->dllStealth);
    success &= IniSaveNum(file, name, L"DLLUnload", profile->dllUnload);

    success &= IniSaveNum(file, name, L"GetLocalTimeHook", profile->hookGetLocalTime);
    success &= IniSaveNum(file, name, L"GetSystemTimeHook", profile->hookGetSystemTime);
    success &= IniSaveNum(file, name, L"GetTickCount64Hook", profile->hookGetTickCount64);
    success &= IniSaveNum(file, name, L"GetTickCountHook", profile->hookGetTickCount);
    success &= IniSaveNum(file, name, L"KiUserExceptionDispatcherHook", profile->hookKiUserExceptionDispatcher);
    success &= IniSaveNum(file, name, L"NtCloseHook", profile->hookNtClose);
    success &= IniSaveNum(file, name, L"NtContinueHook", profile->hookNtContinue);
    success &= IniSaveNum(file, name, L"NtCreateThreadExHook", profile->hookNtCreateThreadEx);
    success &= IniSaveNum(file, name, L"NtGetContextThreadHook", profile->hookNtGetContextThread);
    success &= IniSaveNum(file, name, L"NtQueryInformationProcessHook", profile->hookNtQueryInformationProcess);
    success &= IniSaveNum(file, name, L"NtQueryObjectHook", profile->hookNtQueryObject);
    success &= IniSaveNum(file, name, L"NtQueryPerformanceCounterHook", profile->hookNtQueryPerformanceCounter);
    success &= IniSaveNum(file, name, L"NtQuerySystemInformationHook", profile->hookNtQuerySystemInformation);
    success &= IniSaveNum(file, name, L"NtQuerySystemTimeHook", profile->hookNtQuerySystemTime);
    success &= IniSaveNum(file, name, L"NtSetContextThreadHook", profile->hookNtSetContextThread);
    success &= IniSaveNum(file, name, L"NtSetDebugFilterStateHook", profile->hookNtSetDebugFilterState);
    success &= IniSaveNum(file, name, L"NtSetInformationThreadHook", profile->hookNtSetInformationThread);
    success &= IniSaveNum(file, name, L"NtSetInformationProcessHook", profile->hookNtSetInformationProcess);
    success &= IniSaveNum(file, name, L"NtUserBlockInputHook", profile->hookNtUserBlockInput);
    success &= IniSaveNum(file, name, L"NtUserBuildHwndListHook", profile->hookNtUserBuildHwndList);
    success &= IniSaveNum(file, name, L"NtUserFindWindowExHook", profile->hookNtUserFindWindowEx);
    success &= IniSaveNum(file, name, L"NtUserQueryWindowHook", profile->hookNtUserQueryWindow);
    success &= IniSaveNum(file, name, L"NtUserGetForegroundWindowHook", profile->hookNtUserGetForegroundWindow);
    success &= IniSaveNum(file, name, L"NtYieldExecutionHook", profile->hookNtYieldExecution);
    success &= IniSaveNum(file, name, L"OutputDebugStringHook", profile->hookOutputDebugStringA);

    success &= IniSaveNum(file, name, L"PebBeingDebugged", profile->fixPebBeingDebugged);
    success &= IniSaveNum(file, name, L"PebHeapFlags", profile->fixPebHeapFlags);
    success &= IniSaveNum(file, name, L"PebNtGlobalFlag", profile->fixPebNtGlobalFlag);
    success &= IniSaveNum(file, name, L"PebStartupInfo", profile->fixPebStartupInfo);
    success &= IniSaveNum(file, name, L"PebOsBuildNumber", profile->fixPebOsBuildNumber);
    success &= IniSaveNum(file, name, L"PreventThreadCreation", profile->preventThreadCreation);
    success &= IniSaveNum(file, name, L"ProtectProcessId", profile->protectProcessId);
    success &= IniSaveNum(file, name, L"RemoveDebugPrivileges", profile->removeDebugPrivileges);
    success &= IniSaveNum(file, name, L"KillAntiAttach", profile->killAntiAttach);
    success &= IniSaveNum(file, name, L"MalwareRunPeUnpacker", profile->malwareRunpeUnpacker);

    success &= IniSaveNum(file, name, L"handleExceptionPrint", profile->handleExceptionPrint);
    success &= IniSaveNum(file, name, L"handleExceptionRip", profile->handleExceptionRip);
    success &= IniSaveNum(file, name, L"handleExceptionIllegalInstruction", profile->handleExceptionIllegalInstruction);
    success &= IniSaveNum(file, name, L"handleExceptionInvalidLockSequence", profile->handleExceptionInvalidLockSequence);
    success &= IniSaveNum(file, name, L"handleExceptionNoncontinuableException", profile->handleExceptionNoncontinuableException);
    success &= IniSaveNum(file, name, L"handleExceptionAssertionFailure", profile->handleExceptionAssertionFailure);
    success &= IniSaveNum(file, name, L"handleExceptionBreakpoint", profile->handleExceptionBreakpoint);
    success &= IniSaveNum(file, name, L"handleExceptionGuardPageViolation", profile->handleExceptionGuardPageViolation);
    success &= IniSaveNum(file, name, L"handleExceptionWx86Breakpoint", profile->handleExceptionWx86Breakpoint);

    success &= IniSaveNum(file, name, L"AutostartServer", profile->idaAutoStartServer);
    success &= IniSaveString(file, name, L"ServerPort", profile->idaServerPort.c_str());

    success &= IniSaveNum(file, name, L"BreakOnTls", profile->ollyBreakOnTls);
    success &= IniSaveNum(file, name, L"FixOllyBugs", profile->ollyFixBugs);
    success &= IniSaveNum(file, name, L"RemoveEPBreak", profile->ollyRemoveEpBreak);
    success &= IniSaveNum(file, name, L"SkipEPOutsideCode", profile->ollySkipEpOutsideCode);
    success &= IniSaveNum(file, name, L"X64Fix", profile->ollyX64Fix);
    success &= IniSaveNum(file, name, L"advancedGoto", profile->ollyAdvancedGoto);
    success &= IniSaveNum(file, name, L"ignoreBadPEImage", profile->ollyIgnoreBadPeImage);
    success &= IniSaveNum(file, name, L"skipCompressedDoAnalyze", profile->ollySkipCompressedDoAnalyze);
    success &= IniSaveNum(file, name, L"skipCompressedDoNothing", profile->ollySkipCompressedDoNothing);
    success &= IniSaveNum(file, name, L"skipLoadDllDoLoad", profile->ollySkipLoadDllDoLoad);
    success &= IniSaveNum(file, name, L"skipLoadDllDoNothing", profile->ollySkipLoadDllDoNothing);
    success &= IniSaveNum(file, name, L"advancedInfobar", profile->ollyAdvancedInfobar);
    success &= IniSaveString(file, name, L"WindowTitle", profile->ollyWindowTitle.c_str());

    return success;
}



================================================
File: Scylla/Settings.h
================================================
#pragma once

#include <Windows.h>
#include <string>
#include <vector>

namespace scl
{
    class Settings
    {
    public:
        struct Profile
        {
            BOOL dllNormal;
            BOOL dllStealth;
            BOOL dllUnload;
            BOOL hookGetLocalTime;
            BOOL hookGetSystemTime;
            BOOL hookGetTickCount;
            BOOL hookGetTickCount64;
            BOOL hookKiUserExceptionDispatcher;
            BOOL hookNtClose;
            BOOL hookNtContinue;
            BOOL hookNtCreateThreadEx;
            BOOL hookNtGetContextThread;
            BOOL hookNtQueryInformationProcess;
            BOOL hookNtQueryObject;
            BOOL hookNtQueryPerformanceCounter;
            BOOL hookNtQuerySystemInformation;
            BOOL hookNtQuerySystemTime;
            BOOL hookNtSetContextThread;
            BOOL hookNtSetDebugFilterState;
            BOOL hookNtSetInformationThread;
            BOOL hookNtSetInformationProcess;
            BOOL hookNtUserBlockInput;
            BOOL hookNtUserBuildHwndList;
            BOOL hookNtUserFindWindowEx;
            BOOL hookNtUserQueryWindow;
            BOOL hookNtUserGetForegroundWindow;
            BOOL hookNtYieldExecution;
            BOOL hookOutputDebugStringA;
            BOOL fixPebBeingDebugged;
            BOOL fixPebHeapFlags;
            BOOL fixPebNtGlobalFlag;
            BOOL fixPebStartupInfo;
            BOOL fixPebOsBuildNumber;
            BOOL preventThreadCreation;
            BOOL protectProcessId;
            BOOL removeDebugPrivileges;
            BOOL killAntiAttach;
            BOOL malwareRunpeUnpacker;
            BOOL handleExceptionPrint;
            BOOL handleExceptionRip;
            BOOL handleExceptionIllegalInstruction;
            BOOL handleExceptionInvalidLockSequence;
            BOOL handleExceptionNoncontinuableException;
            BOOL handleExceptionAssertionFailure;
            BOOL handleExceptionBreakpoint;
            BOOL handleExceptionGuardPageViolation;
            BOOL handleExceptionWx86Breakpoint;
            BOOL idaAutoStartServer;
            std::wstring idaServerPort;
            BOOL ollyBreakOnTls;
            BOOL ollyFixBugs;
            BOOL ollyRemoveEpBreak;
            BOOL ollySkipEpOutsideCode;
            BOOL ollyX64Fix;
            BOOL ollyAdvancedGoto;
            BOOL ollyIgnoreBadPeImage;
            BOOL ollySkipCompressedDoAnalyze;
            BOOL ollySkipCompressedDoNothing;
            BOOL ollySkipLoadDllDoLoad;
            BOOL ollySkipLoadDllDoNothing;
            BOOL ollyAdvancedInfobar;
            std::wstring ollyWindowTitle;
        };

        static const wchar_t kFileName[];

        void Load(const wchar_t *ini_file);
        bool Save() const;

        bool AddProfile(const wchar_t *name);
        void SetProfile(const wchar_t *name);


        const std::vector<std::wstring> &profile_names() const
        {
            return profile_names_;
        }

        const std::wstring &profile_name() const
        {
            return profile_name_;
        }

        const Profile &opts() const
        {
            return profile_;
        }

        Profile &opts()
        {
            return profile_;
        }

        bool hook_dll_needed() const
        {
            return
                profile_.hookGetLocalTime ||
                profile_.hookGetSystemTime ||
                profile_.hookGetTickCount ||
                profile_.hookGetTickCount64 ||
                profile_.hookKiUserExceptionDispatcher ||
                profile_.hookNtClose ||
                profile_.hookNtContinue ||
                profile_.hookNtCreateThreadEx ||
                profile_.hookNtGetContextThread ||
                profile_.hookNtQueryInformationProcess ||
                profile_.hookNtQueryObject ||
                profile_.hookNtQueryPerformanceCounter ||
                profile_.hookNtQuerySystemInformation ||
                profile_.hookNtQuerySystemTime ||
                profile_.hookNtSetContextThread ||
                profile_.hookNtSetDebugFilterState ||
                profile_.hookNtSetInformationThread ||
                profile_.hookNtSetInformationProcess ||
                profile_.hookNtUserBlockInput ||
                profile_.hookNtUserBuildHwndList ||
                profile_.hookNtUserFindWindowEx ||
                profile_.hookNtUserQueryWindow ||
                profile_.hookNtUserGetForegroundWindow ||
                profile_.hookNtYieldExecution ||
                profile_.hookOutputDebugStringA ||
                profile_.preventThreadCreation ||
                profile_.malwareRunpeUnpacker;
        }

    protected:
        static void LoadProfile(const wchar_t *file, const wchar_t *name, Profile *profile);
        static bool SaveProfile(const wchar_t *file, const wchar_t *name, const Profile *profile);

    private:
        std::wstring ini_path_;
        std::vector<std::wstring> profile_names_;
        std::wstring profile_name_;
        Profile profile_{};
    };
}



================================================
File: Scylla/User32Loader.cpp
================================================
#include "User32Loader.h"
#include "Win32kSyscalls.h"
#include "Scylla/OsInfo.h"
#include "Scylla/Logger.h"

extern scl::Logger g_log;

scl::User32Loader::User32Loader() :
	OsBuildNumber(NtCurrentPeb()->OSBuildNumber),
	NativeX86(!scl::IsWindows64() && !scl::IsWow64Process(NtCurrentProcess)),
	Win32kUserDll((PUCHAR)LoadLibraryExW(OsBuildNumber >= 14393 ? L"win32u.dll" : L"user32.dll",
		nullptr, DONT_RESOLVE_DLL_REFERENCES | LOAD_IGNORE_CODE_AUTHZ_LEVEL |
		(OsBuildNumber >= 6002 ? LOAD_LIBRARY_SEARCH_SYSTEM32 : 0)))
{
}

scl::User32Loader::~User32Loader()
{
	if (Win32kUserDll != nullptr)
		FreeLibrary((HMODULE)Win32kUserDll);
}

// Finds the requested user32/win32u syscalls by name for later retrieval with GetUserSyscallVa
bool scl::User32Loader::FindSyscalls(const std::vector<std::string>& syscallNames)
{
	if (Win32kUserDll == nullptr) // Failed to load user32.dll or win32u.dll
		return false;
	if (OsBuildNumber < 2600) // Unsupported or unknown OS
		return false;

	if (OsBuildNumber >= 14393)
	{
		// On >= 10.0.14393.0 we can simply get the VAs from win32u.dll
		for (const auto& syscallName : syscallNames)
		{
			const ULONG_PTR syscallAddress = (ULONG_PTR)GetProcAddress((HMODULE)Win32kUserDll, syscallName.c_str());
			if (syscallAddress == 0)
				return false;
			FunctionNamesAndVas[syscallName] = syscallAddress;
		}
		return true;
	}

	// OS is < 14393. Get the syscall indices of the functions that we want the VAs of
	std::map<std::string, ULONG_PTR> functionNamesAndSyscallNums(FunctionNamesAndVas);
	for (const auto& syscallName : syscallNames)
	{
		const LONG syscallNum = GetUserSyscallIndex(syscallName);
		if (syscallNum == -1)
			return false;
		functionNamesAndSyscallNums[syscallName] = (ULONG_PTR)syscallNum;
	}

	// Find the VAs of the functions we want
	for (const auto& function : functionNamesAndSyscallNums)
	{
		const std::string syscallName = function.first;
		const ULONG_PTR syscallAddress = FindSyscallByIndex((ULONG)function.second);
		if (syscallAddress != 0)
		{
			FunctionNamesAndVas[syscallName] = syscallAddress;
		}
		else
		{
			g_log.LogError(L"Address of syscall %hs with index %u not found",
				syscallName.c_str(), (ULONG)functionNamesAndSyscallNums[syscallName]);
			return false;
		}
	}

	// Sanity check the NtUserBlockInput VA as this is an exported syscall
	const ULONG_PTR BlockInputVa = (ULONG_PTR)GetProcAddress((HMODULE)Win32kUserDll, "BlockInput");
	if (BlockInputVa == 0)
		return false;
	const bool check = GetUserSyscallVa("NtUserBlockInput") == BlockInputVa;
	if (!check)
		g_log.LogError(L"GetUserSyscallVa returned incorrect address 0x%p (expected 0x%p)!", GetUserSyscallVa("NtUserBlockInput"), BlockInputVa);
	
	return check;
}

// Returns the win32k syscall number for a function name
LONG scl::User32Loader::GetUserSyscallIndex(const std::string& functionName) const
{
	if (OsBuildNumber >= 14393)
	{
		const PUCHAR syscallAddress = (PUCHAR)GetProcAddress((HMODULE)Win32kUserDll, functionName.c_str());
		if (syscallAddress == nullptr)
			return -1;
		for (PUCHAR address = syscallAddress; address < syscallAddress + 16; ++address)
		{
			if (address[0] == 0xB8 && address[1] != 0xD1)
				return *(PLONG)(address + 1) & 0xFFFF;
		}
		return -1;
	}

	ANSI_STRING searchFunctionName;
	RtlInitAnsiString(&searchFunctionName, (PSTR)functionName.c_str());
	for (ULONG i = 0; i < ARRAYSIZE(Win32kSyscalls); ++i)
	{
		ANSI_STRING tableFunctionName = Win32kSyscalls[i].Name.ToAnsiString();
		if (!RtlEqualString(&tableFunctionName, &searchFunctionName, TRUE))
			continue;
		return Win32kSyscalls[i].GetSyscallIndex(OsBuildNumber, NativeX86);
	}
	return -1;
}

// Scans user32.dll and returns the VA of the function that performs the syscall with the given index
ULONG_PTR scl::User32Loader::FindSyscallByIndex(LONG win32kSyscallIndex) const
{
	const PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(Win32kUserDll);
	const PIMAGE_SECTION_HEADER codeSection = IMAGE_FIRST_SECTION(NtHeaders);
	const PUCHAR start = Win32kUserDll + codeSection->VirtualAddress;
	const PUCHAR end = Win32kUserDll + codeSection->VirtualAddress + codeSection->SizeOfRawData - 16;

	// Find the syscall pattern for this OS + architecture
	for (PUCHAR address = start; address < end; ++address)
	{
		if (address[0] != 0xB8 || (*(PLONG)(address + 1) & 0xFFFF) != win32kSyscallIndex) // mov eax, <syscall num>
			continue;

		bool isSyscall = false;
#ifdef _WIN64
		// For native x64 syscalls 'mov eax, <num>' is always preceded by 'mov r10, rcx'
		if (address[-3] == 0x4C && address[-2] == 0x8B && address[-1] == 0xD1)
		{
			isSyscall = true;
			address -= 3; // Backtrack to first mov
		}
#else
		if (NativeX86)
		{
			// Native x86, old style: mov edx, 7FFE0300h, call [edx]
			if (address[5] == 0xBA && address[6] == 0x00 && address[7] == 0x03 && address[8] == 0xFE &&
				address[9] == 0x7F && address[10] == 0xFF && address[11] == 0x12)
				isSyscall = true;
			// Win 8+ native x86: call leaf_sub, retn X. leaf_sub: mov edx, esp, sysenter, retn
			else if (address[5] == 0xE8 && address[9] == 0x00 && (address[10] == 0xC2 || address[10] == 0xC3))
			{
				ULONG i = 0;
				for ( ; i < 12; ++i)
				{
					if (address[11 + i] == 0x8B)
						break;
				}
				if (address[11 + i] == 0x8B && address[11 + i + 1] == 0xD4 && address[11 + i + 2] == 0x0F &&
					address[11 + i + 3] == 0x34 && address[11 + i + 4] == 0xC3)
					isSyscall = true;
			}
		}
		else
		{
			if (
				// Wow64, old style: lea edx, [esp+4] / mov ecx, XXXX, call fs:0C0h
				((address[5] == 0x8D || address[10] == 0x8D) && (address[5] == 0xB9 || address[9] == 0xB9))
				||
				// Win 8/8.1 Wow64: call fs:0C0h
				(address[5] == 0x64 && address[6] == 0xFF && address[7] == 0x15 && address[8] == 0xC0 &&
				address[9] == 0x00 && address[10] == 0x00 && address[11] == 0x00)
				||
				// Win 10 Wow64: mov edx, offset Wow64SystemServiceCall, call edx, retn
				(address[5] == 0xBA && address[10] == 0xFF && address[11] == 0xD2 && (address[12] == 0xC2 || address[12] == 0xC3))
				)
			{
				isSyscall = true;
			}
		}
#endif
		if (isSyscall)
			return (ULONG_PTR)address;
	}
	return 0;
}



================================================
File: Scylla/User32Loader.h
================================================
#pragma once

#include <Windows.h>
#include <string>
#include <map>
#include <vector>

namespace scl
{
	class User32Loader
	{
	public:
		User32Loader();
		~User32Loader();

		bool FindSyscalls(const std::vector<std::string>& syscallNames);

		ULONG_PTR GetUserSyscallVa(const std::string& functionName) const { return FunctionNamesAndVas.at(functionName); }
		LONG GetUserSyscallIndex(const std::string& functionName) const;

	private:
		ULONG_PTR FindSyscallByIndex(LONG win32kSyscallIndex) const;

		const USHORT OsBuildNumber;
		const bool NativeX86;
		const PUCHAR Win32kUserDll; // win32u.dll if OsBuildNumber >= 14393, user32.dll otherwise

		std::map<std::string, ULONG_PTR> FunctionNamesAndVas;
	};
}



================================================
File: Scylla/Util.cpp
================================================
#include "Util.h"
#include <cstdio>
#include "NtApiShim.h"

std::wstring scl::fmtw(const wchar_t *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    auto str = vfmtw(fmt, ap);
    va_end(ap);

    return str;
}

std::wstring scl::vfmtw(const wchar_t *fmt, va_list ap)
{
    va_list vap;

    va_copy(vap, ap);
    auto size = ::_vsnwprintf(nullptr, 0, fmt, vap);
    va_end(vap);

    std::wstring wstr;
    wstr.resize(size);

    va_copy(vap, ap);
    ::_vsnwprintf(&wstr[0], wstr.size(), fmt, vap);
    va_end(vap);

    return wstr;
}

std::wstring scl::GetModuleFileNameW(HMODULE hModule)
{
    std::wstring wstrFileName;
    DWORD copied = 0;
    do {
        wstrFileName.resize(wstrFileName.size() + MAX_PATH);
        copied = ::GetModuleFileNameW(hModule, &wstrFileName[0], (DWORD)wstrFileName.size());
    } while (copied >= wstrFileName.size());

    wstrFileName.resize(copied);
    return wstrFileName;
}

std::wstring scl::FormatMessageW(DWORD dwErrnum)
{
    wchar_t *wszBuffer = nullptr;

    ::FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
        nullptr, dwErrnum, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), (LPWSTR)&wszBuffer, 0, nullptr);

    std::wstring wstrError;
    if (wszBuffer) {
        wstrError = wszBuffer;
        wstrError.resize(wstrError.size() - 1); // remove trailing \n
        ::LocalFree(wszBuffer);
    }
    else
    {
        wstrError = L"<FAILED TO RETRIEVE ERROR STRING>";
    }

    return wstrError;
}

std::wstring scl::GetWindowTextW(HWND hWnd)
{
    std::wstring wstr;
    auto len = ::GetWindowTextLengthW(hWnd) + 1;
    wstr.resize(len);
    ::GetWindowTextW(hWnd, &wstr[0], len);
    return wstr;
}

std::wstring scl::GetDlgItemTextW(HWND hDlg, int nIDDlgItem)
{
    return GetWindowTextW(::GetDlgItem(hDlg, nIDDlgItem));
}

bool scl::FileExistsW(const wchar_t *wszPath)
{
    auto dwAttrib = ::GetFileAttributesW(wszPath);

    return (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}

bool scl::GetFileDialogW(wchar_t *buffer, DWORD buffer_size)
{
    OPENFILENAMEW sOpenFileName = { 0 };
    const wchar_t szFilterString[] = L"DLL \0*.dll\0\0";
    const wchar_t szDialogTitle[] = L"ScyllaHide";

    buffer[0] = 0;

    sOpenFileName.lStructSize = sizeof(sOpenFileName);
    sOpenFileName.lpstrFilter = szFilterString;
    sOpenFileName.lpstrFile = buffer;
    sOpenFileName.nMaxFile = buffer_size;
    sOpenFileName.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_LONGNAMES | OFN_EXPLORER | OFN_HIDEREADONLY;
    sOpenFileName.lpstrTitle = szDialogTitle;

    return (TRUE == GetOpenFileNameW(&sOpenFileName));
}


std::vector<std::wstring> scl::IniLoadSectionNames(const wchar_t *file)
{
    std::wstring buf;
    DWORD ret = 0;
    while (((DWORD)buf.size() - ret) < 3) {
        buf.resize(buf.size() + MAX_PATH);
        ret = ::GetPrivateProfileSectionNamesW(&buf[0], (DWORD)buf.size(), file);
    }

    std::vector<std::wstring> sections;
    auto data = buf.c_str();
    for (; data[0]; data += lstrlenW(data) + 1) {
        sections.push_back(data);
    }

    return sections;
}

std::wstring scl::IniLoadString(const wchar_t *file, const wchar_t *section, const wchar_t *key, const wchar_t *default_value)
{
    std::wstring buf;
    DWORD ret = 0;

    while (((DWORD)buf.size() - ret) < 3) {
        buf.resize(buf.size() + MAX_PATH);
        ret = ::GetPrivateProfileStringW(section, key, default_value, &buf[0], (DWORD)buf.size(), file);
    }
    buf.resize(ret);

    return buf;
}

bool scl::IniSaveString(const wchar_t *file, const wchar_t *section, const wchar_t *key, const wchar_t *value)
{
    return WritePrivateProfileStringW(section, key, value, file) == TRUE;
}

std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> &scl::wstr_conv()
{
    static std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> conv;
    return conv;
}

bool scl::Wow64QueryInformationProcess64(HANDLE hProcess, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength)
{
    auto _NtWow64QueryInformationProcess64 = (t_NtWow64QueryInformationProcess64)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtWow64QueryInformationProcess64");
    if (!_NtWow64QueryInformationProcess64)
        return false;

    return NT_SUCCESS(_NtWow64QueryInformationProcess64(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength));
}

bool scl::Wow64ReadProcessMemory64(HANDLE hProcess, PVOID64 address, PVOID buffer, ULONGLONG buffer_size, PULONGLONG bytes_read)
{
#ifndef _WIN64
    auto _NtWow64ReadVirtualMemory64 = (t_NtWow64ReadVirtualMemory64)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtWow64ReadVirtualMemory64");
    if (_NtWow64ReadVirtualMemory64)
    {
        return NT_SUCCESS(_NtWow64ReadVirtualMemory64(hProcess, address, buffer, buffer_size, bytes_read));
    }
    else if ((((DWORD64)address + buffer_size) < (DWORD)(-1)) && (buffer_size <= (DWORD)(-1)))
    {
        SIZE_T bytes_read32 = 0;
        auto ret = ReadProcessMemory(hProcess, (PVOID)(ULONG)(ULONG64)address, buffer, (SIZE_T)buffer_size, &bytes_read32);
        if (bytes_read)
            *bytes_read = bytes_read32;
        return ret == TRUE;
    }
#endif

    return false;
}

bool scl::Wow64WriteProcessMemory64(HANDLE hProcess, PVOID64 address, LPCVOID buffer, ULONGLONG buffer_size, PULONGLONG bytes_written)
{
#ifndef _WIN64
    auto _NtWow64WriteVirtualMemory64 = (t_NtWow64WriteVirtualMemory64)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtWow64WriteVirtualMemory64");
    if (_NtWow64WriteVirtualMemory64)
    {
        return NT_SUCCESS(_NtWow64WriteVirtualMemory64(hProcess, address, buffer, buffer_size, bytes_written));
    }
    else if ((((DWORD64)address + buffer_size) < (DWORD)(-1)) && (buffer_size <= (DWORD)(-1)))
    {
        SIZE_T bytes_written32 = 0;
        auto ret = WriteProcessMemory(hProcess, (PVOID)(ULONG)(ULONG64)(address), buffer, (SIZE_T)buffer_size, &bytes_written32);
        if (bytes_written)
            *bytes_written = bytes_written32;
        return ret == TRUE;
    }
#endif

    return false;
}



================================================
File: Scylla/Util.h
================================================
#pragma once

#include <Windows.h>
#include <codecvt>
#include <locale>
#include <sstream>
#include <string>
#include <vector>
#include "Resource.h"
#include "NtApiShim.h"

namespace scl
{
    std::wstring fmtw(const wchar_t *fmt, ...);
    std::wstring vfmtw(const wchar_t *fmt, va_list ap);

    std::wstring GetModuleFileNameW(HMODULE hModule = nullptr);

    std::wstring FormatMessageW(DWORD dwErrnum);

    std::wstring GetWindowTextW(HWND hWnd);
    std::wstring GetDlgItemTextW(HWND hDlg, int nIDDlgItem);

    bool FileExistsW(const wchar_t *wszPath);

    bool GetFileDialogW(wchar_t *buffer, DWORD buffer_size);

    std::vector<std::wstring> IniLoadSectionNames(const wchar_t *file);

    std::wstring IniLoadString(const wchar_t *file, const wchar_t *section, const wchar_t *key, const wchar_t *default_value);

    bool IniSaveString(const wchar_t *file, const wchar_t *section, const wchar_t *key, const wchar_t *value);

    template<int BASE = 10, typename VALUE_TYPE>
    VALUE_TYPE IniLoadNum(const wchar_t *file, const wchar_t *section, const wchar_t *key, VALUE_TYPE default_value)
    {
        static_assert((BASE == 8) || (BASE == 10) || (BASE == 16), "invalid base");

        std::wstringstream ss;

        if (BASE == 8)
            ss << std::oct;
        else if (BASE == 16)
            ss << std::hex;

        std::wstring default_value_str;
        ss << default_value;
        ss >> default_value_str;
        ss.str(L"");
        ss.clear();

        VALUE_TYPE value;
        ss << IniLoadString(file, section, key, default_value_str.c_str());
        ss >> value;
        return value;
    }

    template<int BASE = 10, typename VALUE_TYPE>
    bool IniSaveNum(const wchar_t *file, const wchar_t *section, const wchar_t *key, VALUE_TYPE value)
    {
        static_assert((BASE == 8) || (BASE == 10) || (BASE == 16), "invalid base");

        std::wstringstream ss;

        if (BASE == 8)
            ss << std::oct;
        else if (BASE == 16)
            ss << std::hex;

        ss << value;

        return IniSaveString(file, section, key, ss.str().c_str());
    }

    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> &wstr_conv();

    bool Wow64QueryInformationProcess64(HANDLE hProcess, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);

    bool Wow64ReadProcessMemory64(HANDLE hProcess, PVOID64 address, PVOID buffer, ULONGLONG buffer_size, PULONGLONG bytes_read);
    bool Wow64WriteProcessMemory64(HANDLE hProcess, PVOID64 address, LPCVOID buffer, ULONGLONG buffer_size, PULONGLONG bytes_written);
};



================================================
File: Scylla/Version.cpp
================================================
#include "Version.h"

void scl::ShowAboutBox(HWND hWnd)
{
    MessageBoxW(hWnd,
        SCYLLA_HIDE_NAME_W L" Plugin v" SCYLLA_HIDE_VERSION_STRING_W L" (" TEXT(__DATE__) L")\n\n"
        L"Copyright (C) 2014-" COMPILE_YEAR_W L" Aguila / cypher\n\n"
        L"Special thanks to:\n"
        L"- What for his POISON assembler source code\n"
        L"- waliedassar for his blog posts\n"
        L"- Peter Ferrie for his Anti-Debug PDFs\n"
        L"- MaRKuS-DJM for OllyAdvanced assembler source code\n"
        L"- Steve Micallef for his IDA SDK doc\n"
        L"- Authors of PhantOm and StrongOD\n"
        L"- Tuts4You, Exetools, Exelab community for testing\n"
        L"- last but not least deepzero & mr.exodia for tech chats",
        SCYLLA_HIDE_NAME_W L" Plugin", MB_ICONINFORMATION);
}



================================================
File: Scylla/Version.h
================================================
#pragma once
#include <Windows.h>
#include "../SCMRevGen/scmrev.h"

#define STRA(x) #x
#define STRW(x) L#x

#define STR_HELPERA(x) STRA(x)
#define STR_HELPERW(x) STRW(x)

#define SCYLLA_HIDE_VERSION_MAJOR 1
#define SCYLLA_HIDE_VERSION_MINOR 4
#define SCYLLA_HIDE_VERSION_PATCH GIT_VERSION_NUMBER

#define SCYLLA_HIDE_NAME_A "ScyllaHide"
#define SCYLLA_HIDE_NAME_W L"ScyllaHide"

#define SCYLLA_HIDE_VERSION_STRING_A STR_HELPERA(SCYLLA_HIDE_VERSION_MAJOR) "." STR_HELPERA(SCYLLA_HIDE_VERSION_MINOR) "." STR_HELPERA(SCYLLA_HIDE_VERSION_PATCH) "-" GIT_SHORT_HASH_A
#define SCYLLA_HIDE_VERSION_STRING_W STR_HELPERW(SCYLLA_HIDE_VERSION_MAJOR) L"." STR_HELPERW(SCYLLA_HIDE_VERSION_MINOR) L"." STR_HELPERW(SCYLLA_HIDE_VERSION_PATCH) L"-" GIT_SHORT_HASH_W

namespace scl
{
    void ShowAboutBox(HWND hWnd);
}



================================================
File: Scylla/VersionPatch.cpp
================================================
#include "VersionPatch.h"

#define STR(x) #x
#define VERSTR(x) STR(x)
#define FAKE_VERSION_WCHAR L"" VERSTR(FAKE_VERSION)

bool NtVirtualProtect(HANDLE hProcess, PVOID Address, SIZE_T Size, ULONG NewProtect, PULONG OldProtect)
{
    PVOID BaseAddress = Address;
    SIZE_T RegionSize = Size;
    return NT_SUCCESS(NtProtectVirtualMemory(hProcess, &BaseAddress, &RegionSize, NewProtect, OldProtect));
}

void PatchFixedFileInfoVersion(HANDLE hProcess, PVOID Address, ULONG Size)
{
    BOOL found = FALSE;
    PUCHAR P;
    for (P = (PUCHAR)Address; P < (PUCHAR)Address + Size; ++P)
    {
        if (*(PDWORD)P == 0xFEEF04BD) // VS_FIXEDFILEINFO signature
        {
            found = TRUE;
            break;
        }
    }
    if (!found)
    {
        DbgPrint("Failed to find fixed version info signature in ntdll.dll VS_VERSION_INFO");
        return;
    }

    P += 14; // Skip to FileVersion build number
    ULONG OldProtect;
    if (NtVirtualProtect(hProcess, P, 10, PAGE_READWRITE, &OldProtect))
    {
        WORD Version = FAKE_VERSION;
        NtWriteVirtualMemory(hProcess, P, &Version, 2, nullptr); // FileVersion
        NtWriteVirtualMemory(hProcess, P + 8, &Version, 2, nullptr); // ProductVersion
        NtVirtualProtect(hProcess, P, 10, OldProtect, &OldProtect);
    }
    else
    {
        DbgPrint("VirtualProtectEx failed on ntdll");
    }
}

void PatchVersionString(HANDLE hProcess, PVOID Address, ULONG Size, const WCHAR* Property)
{
    // VS_VERSIONINFO is a mess to navigate because it is a nested struct of variable size with (grand)children all of variable sizes
    // See: https://docs.microsoft.com/en-gb/windows/win32/menurc/vs-versioninfo
    // Instead of finding VS_VERSIONINFO -> StringFileInfo[] -> StringTable[] -> String (-> WCHAR[]) properly, just do it the memcmp way
    size_t propertyLen = (wcslen(Property) + 1) * 2;
    PUCHAR P = (PUCHAR)Address;
    BOOL found = FALSE;
    for (; P < (PUCHAR)Address + Size - propertyLen; ++P)
    {
        if (memcmp(P, Property, propertyLen) == 0)
        {
            found = TRUE;
            break;
        }
    }
    if (!found)
    {
        DbgPrint("Failed to find %ws in ntdll.dll VS_VERSION_INFO", Property);
        return;
    }

    // Skip to the version number and discard extra nulls
    P += propertyLen;
    while (*(PWCHAR)P == L'\0')
    {
        P += sizeof(WCHAR);
    }

    // P now points at e.g. 6.1.xxxx.yyyy or 10.0.xxxxx.yyyy. Skip the major and minor version numbers to get to the build number xxxx
    const ULONG Skip = NtCurrentPeb()->OSMajorVersion >= 10 ? 5 * sizeof(WCHAR) : 4 * sizeof(WCHAR);
    P += Skip;

    // Write a new bogus build number
    WCHAR NewBuildNumber[] = FAKE_VERSION_WCHAR;
    ULONG OldProtect;
    if (NtVirtualProtect(hProcess, P, sizeof(NewBuildNumber) - sizeof(WCHAR), PAGE_READWRITE, &OldProtect))
    {
        SIZE_T NumWritten;
        NtWriteVirtualMemory(hProcess, P, NewBuildNumber, sizeof(NewBuildNumber) - sizeof(WCHAR), &NumWritten);
        NtVirtualProtect(hProcess, P, sizeof(NewBuildNumber) - sizeof(WCHAR), OldProtect, &OldProtect);
    }
}

void ApplyNtdllVersionPatch(HANDLE hProcess, PVOID Ntdll)
{
    // Get the resource data entry for VS_VERSION_INFO
    LDR_RESOURCE_INFO ResourceIdPath;
    ResourceIdPath.Type = (ULONG_PTR)RT_VERSION;
    ResourceIdPath.Name = VS_VERSION_INFO;
    ResourceIdPath.Language = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry = nullptr;
    NTSTATUS Status = LdrFindResource_U(Ntdll, &ResourceIdPath, 3, &ResourceDataEntry);
    if (!NT_SUCCESS(Status))
    {
        DbgPrint("Failed to find VS_VERSION_INFO resource in ntdll.dll: %08X", Status);
        return;
    }

    // Get the address and size of VS_VERSION_INFO
    PVOID Address = nullptr;
    ULONG Size = 0;
    Status = LdrAccessResource(Ntdll, ResourceDataEntry, &Address, &Size);
    if (!NT_SUCCESS(Status))
    {
        DbgPrint("Failed to obtain size of VS_VERSION_INFO resource in ntdll.dll: %08X", Status);
        return;
    }
    if (Address == nullptr || Size == 0)
    {
        DbgPrint("VS_VERSION_INFO resource in ntdll.dll has size zero");
        return;
    }

    PatchFixedFileInfoVersion(hProcess, Address, Size);
    PatchVersionString(hProcess, Address, Size, L"FileVersion");
    PatchVersionString(hProcess, Address, Size, L"ProductVersion");
}



================================================
File: Scylla/VersionPatch.h
================================================
#pragma once
#include <windows.h>
#include <ntdll/ntdll.h>

// Used for PEB OsBuildNumber patch and NTDLL version resource patches.
#define FAKE_VERSION 1337

void ApplyNtdllVersionPatch(HANDLE hProcess, PVOID Ntdll);



================================================
File: Scylla/Win32kSyscalls.h
================================================
#pragma once

#include <ntdll/ntdll.h>

/*
 * The tables below were generated for each OS version using a modified version of wscg64 (https://github.com/hfiref0x/SyscallTables).
 * They were then converted to the format below to save space. std::map and std::string are banned in this file, they add about 600KB.
 * The syscalls are sorted by name only, so lookup is O(N) and done with string comparisons. This is okay because lookups are rare.
 *
 * All OS versions have separate syscall tables for x86 and x64, except 2600 which only exists as x86. WOW64 processes use the x64 table.
 *
 * Versions 14393 and later are not included because they come with win32u.dll, which exports win32k syscalls like ntdll does for ntoskrnl.
 */

// Space saving hack. The longest name here is 58 chars, so UCHAR is OK
#pragma pack(push, 2)
typedef struct _SMALL_ANSI_STRING
{
	UCHAR Length;
	UCHAR MaximumLength;
	PSTR Buffer;

	constexpr ANSI_STRING ToAnsiString() const { return { (USHORT)Length, (USHORT)MaximumLength, Buffer }; }
} SMALL_ANSI_STRING, *PSMALL_ANSI_STRING;
#pragma pack(pop)

typedef struct _WIN32K_SYSCALL_INFO
{
	SMALL_ANSI_STRING Name;
	struct
	{
		// Index 0 is x86, index 1 is WOW64 and x64.
		// None of the syscall numbers exceed 64K, so store them as SHORTs
		SHORT Index2600;		// XP (x86 only)
		SHORT Index3790[2];		// Server 2003 / XP x64
		SHORT Index6000[2];		// Vista
		SHORT Index7601[2];		// 7
		SHORT Index9200[2];		// 8
		SHORT Index9600[2];		// 8.1
		SHORT Index10240[2];	// 10.0.10240.0
		SHORT Index10586[2];	// 10.0.10586.0
	} s;

	// A value of -1 means Win32k does not have the syscall on this OS/bitness combination.
	constexpr LONG GetSyscallIndex(USHORT osBuildNumber, bool nativeX86) const
	{
		return (LONG)(osBuildNumber == 2600
			? s.Index2600
			: ((osBuildNumber >= 3790 && osBuildNumber <= 3800)
				? s.Index3790[nativeX86 ? 0 : 1]
				: ((osBuildNumber >= 6000 && osBuildNumber <= 6002)
					? s.Index6000[nativeX86 ? 0 : 1]
					: ((osBuildNumber == 7600 || osBuildNumber == 7601)
						? s.Index7601[nativeX86 ? 0 : 1]
						: (osBuildNumber == 9200
							? s.Index9200[nativeX86 ? 0 : 1]
							: (osBuildNumber == 9600
								? s.Index9600[nativeX86 ? 0 : 1]
								: (osBuildNumber == 10240
									? s.Index10240[nativeX86 ? 0 : 1]
									: (osBuildNumber == 10586
										? s.Index10586[nativeX86 ? 0 : 1]
										: -1))))))));
	}
} WIN32K_SYSCALL_INFO, *PWIN32K_SYSCALL_INFO;

#define MIN_WIN32K_SYSCALL_NUM			4096
#define MAX_WIN32K_SYSCALL_NUM			5230

static constexpr WIN32K_SYSCALL_INFO Win32kSyscalls[] =
{
	{ RTL_CONSTANT_ANSI_STRING("NtBindCompositionSurface"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4994, 4383 }, { 5012, 4384 }, { 5069, 4385 }, { 5071, 4385 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtCompositionInputThread"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5030, 4385 }, { 5093, 4386 }, { 5095, 4386 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtCompositionSetDropTarget"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 4387 }, { 5098, 4387 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtCreateCompositionInputSink"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5025, 4386 }, { 5086, 4387 }, { 5088, 4388 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtCreateCompositionSurfaceHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4992, 4384 }, { 5010, 4387 }, { 5067, 4388 }, { 5069, 4389 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtCreateImplicitCompositionInputSink"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5087, 4389 }, { 5089, 4390 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionAddCrossDeviceVisualChild"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5033, 4385 }, { 5066, 4388 }, { 5134, 4390 }, { 5137, 4391 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionAddVisualChild"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5034, 4386 }, { 5067, 4389 }, { 5135, 4391 }, { 5138, 4392 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionAttachMouseWheelToHwnd"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 4393 }, { 5168, 4393 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionBeginFrame"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5008, 4387 }, { 5037, 4390 }, { 5105, 4392 }, { 5108, 4394 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCapturePointer"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5162, 4393 }, { 5164, 4395 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCommitChannel"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5023, 4388 }, { 5052, 4391 }, { 5120, 4394 }, { 5123, 4396 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionConfirmFrame"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5009, 4389 }, { 5038, 4392 }, { 5106, 4395 }, { 5109, 4397 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionConnectPipe"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5050, 4390 }, { 5088, 4393 }, { 5155, 4396 }, { 5157, 4398 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCreateAndBindSharedSection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5085, 4394 }, { 5152, 4397 }, { 5154, 4399 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCreateChannel"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5044, 4391 }, { 5080, 4395 }, { 5148, 4398 }, { 5151, 4400 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCreateConnection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5048, 4396 }, { 5116, 4399 }, { 5119, 4401 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCreateConnectionContext"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5019, 4392 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCreateDwmChannel"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5043, 4393 }, { 5079, 4397 }, { 5147, 4400 }, { 5150, 4402 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCreateResource"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5042, 4394 }, { 5076, 4398 }, { 5144, 4401 }, { 5147, 4403 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionCurrentBatchId"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5029, 4395 }, { 5062, 4399 }, { 5130, 4402 }, { 5133, 4404 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionDestroyChannel"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5020, 4396 }, { 5049, 4400 }, { 5117, 4403 }, { 5120, 4405 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionDestroyConnection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5043, 4401 }, { 5111, 4404 }, { 5114, 4406 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionDestroyConnectionContext"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5014, 4397 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionDiscardFrame"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5011, 4398 }, { 5040, 4402 }, { 5108, 4405 }, { 5111, 4407 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionDuplicateHandleToProcess"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5090, 4403 }, { 5158, 4406 }, { 5160, 4408 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionDuplicateSwapchainHandleToDwm"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5165, 4407 }, { 5167, 4409 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionDwmSyncFlush"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5046, 4399 }, { 5082, 4404 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionEnableDDASupport"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5085, 4408 }, { 5087, 4410 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionEnableMMCSS"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5083, 4409 }, { 5085, 4411 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionGetAnimationTime"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5160, 4410 }, { 5162, 4412 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionGetChannels"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5049, 4400 }, { 5087, 4405 }, { 5154, 4411 }, { 5156, 4413 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionGetConnectionBatch"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5044, 4406 }, { 5112, 4412 }, { 5115, 4414 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionGetConnectionContextBatch"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5015, 4401 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionGetDeletedResources"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5017, 4402 }, { 5046, 4407 }, { 5114, 4413 }, { 5117, 4415 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionGetFrameLegacyTokens"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5013, 4403 }, { 5042, 4408 }, { 5110, 4414 }, { 5113, 4416 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionGetFrameStatistics"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5016, 4404 }, { 5045, 4409 }, { 5113, 4415 }, { 5116, 4417 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionGetFrameSurfaceUpdates"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5012, 4405 }, { 5041, 4410 }, { 5109, 4416 }, { 5112, 4418 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionOpenSharedResource"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5077, 4411 }, { 5145, 4417 }, { 5148, 4419 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionOpenSharedResourceHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5078, 4412 }, { 5146, 4418 }, { 5149, 4420 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionReferenceSharedResourceOnDwmChannel"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5083, 4413 }, { 5150, 4419 }, { 5153, 4421 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionRegisterThumbnailVisual"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5089, 4414 }, { 5156, 4420 }, { 5158, 4422 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionRegisterVirtualDesktopVisual"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5157, 4421 }, { 5159, 4423 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionReleaseAllResources"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5021, 4406 }, { 5050, 4415 }, { 5118, 4422 }, { 5121, 4424 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionReleaseResource"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5030, 4407 }, { 5063, 4416 }, { 5131, 4423 }, { 5134, 4425 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionRemoveCrossDeviceVisualChild"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5031, 4408 }, { 5064, 4417 }, { 5132, 4424 }, { 5135, 4426 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionRemoveVisualChild"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5032, 4409 }, { 5065, 4418 }, { 5133, 4425 }, { 5136, 4427 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionReplaceVisualChildren"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5035, 4410 }, { 5068, 4419 }, { 5136, 4426 }, { 5139, 4428 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionRetireFrame"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5010, 4411 }, { 5039, 4420 }, { 5107, 4427 }, { 5110, 4429 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetChannelCallbackId"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5163, 4428 }, { 5165, 4430 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetChannelCommitCompletionEvent"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5025, 4412 }, { 5054, 4421 }, { 5122, 4429 }, { 5125, 4431 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetDebugCounter"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5086, 4422 }, { 5153, 4430 }, { 5155, 4432 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceAnimationProperty"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5036, 4413 }, { 5069, 4423 }, { 5137, 4431 }, { 5140, 4433 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceBufferProperty"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5039, 4414 }, { 5072, 4424 }, { 5140, 4432 }, { 5143, 4434 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceCallbackId"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5164, 4433 }, { 5166, 4435 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceDeletedNotificationTag"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5018, 4415 }, { 5047, 4425 }, { 5115, 4434 }, { 5118, 4436 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceFloatProperty"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5041, 4416 }, { 5074, 4426 }, { 5142, 4435 }, { 5145, 4437 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceHandleProperty"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5075, 4427 }, { 5143, 4436 }, { 5146, 4438 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceIntegerProperty"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5040, 4417 }, { 5073, 4428 }, { 5141, 4437 }, { 5144, 4439 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceReferenceArrayProperty"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5037, 4418 }, { 5070, 4429 }, { 5138, 4438 }, { 5141, 4440 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetResourceReferenceProperty"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5038, 4419 }, { 5071, 4430 }, { 5139, 4439 }, { 5142, 4441 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSetVisualInputSink"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5159, 4440 }, { 5161, 4442 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSignalGpuFence"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5048, 4420 }, { 5084, 4431 }, { 5151, 4441 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSubmitDWMBatch"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5022, 4421 }, { 5051, 4432 }, { 5119, 4442 }, { 5122, 4443 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionSynchronize"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5045, 4422 }, { 5081, 4433 }, { 5149, 4443 }, { 5152, 4444 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionTelemetryAnimationScenarioBegin"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5059, 4434 }, { 5127, 4444 }, { 5130, 4445 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionTelemetryAnimationScenarioReference"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5060, 4435 }, { 5128, 4445 }, { 5131, 4446 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionTelemetryAnimationScenarioUnreference"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5061, 4436 }, { 5129, 4446 }, { 5132, 4447 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionTelemetrySetApplicationId"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5058, 4437 }, { 5126, 4447 }, { 5129, 4448 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionTelemetryTouchInteractionBegin"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5026, 4423 }, { 5055, 4438 }, { 5123, 4448 }, { 5126, 4449 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionTelemetryTouchInteractionEnd"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5028, 4424 }, { 5057, 4439 }, { 5125, 4449 }, { 5128, 4450 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionTelemetryTouchInteractionUpdate"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5027, 4425 }, { 5056, 4440 }, { 5124, 4450 }, { 5127, 4451 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionUpdatePointerCapture"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5161, 4451 }, { 5163, 4452 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionValidateAndReferenceSystemVisualForHwndTarget"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5047, 4426 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDCompositionWaitForChannel"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5024, 4427 }, { 5053, 4441 }, { 5121, 4452 }, { 5124, 4453 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDesktopCaptureBits"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5082, 4453 }, { 5084, 4454 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtDuplicateCompositionInputSink"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5026, 4442 }, { 5088, 4454 }, { 5090, 4455 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAbortDoc"),	{ 4096, { 4096, 4391 }, { 4096, 4392 }, { 4096, 4383 }, { 4412, 4428 }, { 4414, 4443 }, { 4415, 4455 }, { 4417, 4456 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAbortPath"),	{ 4097, { 4097, -1 }, { 4097, 4393 }, { 4097, 4384 }, { 4411, 4429 }, { 4413, 4444 }, { 4414, 4456 }, { 4416, 4457 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAddEmbFontToDC"),	{ 4310, { 4309, 4393 }, { 4318, 4394 }, { 4320, 4385 }, { 4186, 4430 }, { 4187, 4445 }, { 4188, 4457 }, { 4188, 4458 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAddFontMemResourceEx"),	{ 4100, { 4100, -1 }, { 4100, 4375 }, { 4100, 4368 }, { 4408, 4368 }, { 4410, 4369 }, { 4411, 4370 }, { 4413, 4370 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAddFontResourceW"),	{ 4098, { 4098, -1 }, { 4098, 4395 }, { 4098, 4386 }, { 4410, 4431 }, { 4412, 4446 }, { 4413, 4458 }, { 4415, 4459 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAddRemoteFontToDC"),	{ 4099, { 4099, 4395 }, { 4099, 4396 }, { 4099, 4387 }, { 4409, 4432 }, { 4411, 4447 }, { 4412, 4459 }, { 4414, 4460 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAddRemoteMMInstanceToDC"),	{ 4102, { 4102, 4396 }, { 4102, 4397 }, { 4102, 4388 }, { 4406, 4433 }, { 4408, 4448 }, { 4409, 4460 }, { 4411, 4461 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAlphaBlend"),	{ 4103, { 4103, -1 }, { 4103, 4222 }, { 4103, 4220 }, { 4405, 4220 }, { 4407, 4221 }, { 4408, 4222 }, { 4410, 4222 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAngleArc"),	{ 4104, { 4104, -1 }, { 4104, 4398 }, { 4104, 4389 }, { 4404, 4434 }, { 4406, 4449 }, { 4407, 4461 }, { 4409, 4462 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiAnyLinkedFonts"),	{ 4105, { 4105, 4398 }, { 4105, 4399 }, { 4105, 4390 }, { 4403, 4435 }, { 4405, 4450 }, { 4406, 4462 }, { 4408, 4463 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiArcInternal"),	{ 4107, { 4107, -1 }, { 4107, 4400 }, { 4107, 4391 }, { 4401, 4436 }, { 4403, 4451 }, { 4404, 4463 }, { 4406, 4464 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiBeginGdiRendering"),	{ -1, { -1, -1 }, { -1, -1 }, { 4108, 4397 }, { 4400, 4442 }, { 4402, 4457 }, { 4403, 4469 }, { 4405, 4470 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiBeginPath"),	{ 4108, { 4108, 4367 }, { 4108, 4368 }, { 4109, 4361 }, { 4399, 4361 }, { 4401, 4362 }, { 4402, 4363 }, { 4404, 4363 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiBitBlt"),	{ 4109, { 4109, -1 }, { 4109, 4104 }, { 4110, 4104 }, { 4398, 4105 }, { 4400, 4106 }, { 4401, 4107 }, { 4403, 4107 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiBRUSHOBJ_DeleteRbrush"),	{ 4760, { 4756, 4400 }, { 4793, 4401 }, { 4825, 4392 }, { 4865, 4437 }, { 4874, 4452 }, { 4886, 4464 }, { 4887, 4465 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiBRUSHOBJ_hGetColorTransform"),	{ 4733, { 4729, 4401 }, { 4766, 4402 }, { 4798, 4393 }, { 4835, 4438 }, { 4844, 4453 }, { 4856, 4465 }, { 4857, 4466 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiBRUSHOBJ_pvAllocRbrush"),	{ 4731, { 4727, 4402 }, { 4764, 4403 }, { 4796, 4394 }, { 4837, 4439 }, { 4846, 4454 }, { 4858, 4466 }, { 4859, 4467 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiBRUSHOBJ_pvGetRbrush"),	{ 4732, { 4728, 4403 }, { 4765, 4404 }, { 4797, 4395 }, { 4836, 4440 }, { 4845, 4455 }, { 4857, 4467 }, { 4858, 4468 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiBRUSHOBJ_ulGetBrushColor"),	{ 4730, { 4726, -1 }, { 4763, 4405 }, { 4795, 4396 }, { 4838, 4441 }, { 4847, 4456 }, { 4859, 4468 }, { 4860, 4469 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCancelDC"),	{ 4110, { 4110, 4408 }, { 4110, 4409 }, { 4111, 4401 }, { 4397, 4446 }, { 4399, 4461 }, { 4400, 4473 }, { 4402, 4474 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiChangeGhostFont"),	{ 4309, { 4308, 4409 }, { 4317, 4410 }, { 4319, 4402 }, { 4187, 4447 }, { 4188, 4462 }, { 4189, 4474 }, { 4189, 4475 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCheckBitmapBits"),	{ 4111, { 4111, -1 }, { 4111, 4411 }, { 4112, 4403 }, { 4396, 4448 }, { 4398, 4463 }, { 4399, 4475 }, { 4401, 4476 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiClearBitmapAttributes"),	{ 4113, { 4113, 4411 }, { 4113, 4412 }, { 4114, 4404 }, { 4394, 4449 }, { 4396, 4464 }, { 4397, 4476 }, { 4399, 4477 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiClearBrushAttributes"),	{ 4114, { 4361, 4412 }, { 4114, 4413 }, { 4405, 4405 }, { 4393, 4450 }, { 4395, 4465 }, { 4396, 4477 }, { 4398, 4478 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCLIPOBJ_bEnum"),	{ 4724, { 4720, 4405 }, { 4757, 4406 }, { 4789, 4398 }, { 4834, 4443 }, { 4843, 4458 }, { 4855, 4470 }, { 4856, 4471 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCLIPOBJ_cEnumStart"),	{ 4725, { 4721, -1 }, { 4758, 4407 }, { 4790, 4399 }, { 4833, 4444 }, { 4842, 4459 }, { 4854, 4471 }, { 4855, 4472 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCLIPOBJ_ppoGetPath"),	{ 4726, { 4722, 4407 }, { 4759, 4408 }, { 4791, 4400 }, { 4832, 4445 }, { 4841, 4460 }, { 4853, 4472 }, { 4854, 4473 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCloseFigure"),	{ 4112, { 4112, -1 }, { 4112, 4358 }, { 4113, 4352 }, { 4395, 4352 }, { 4397, 4353 }, { 4398, 4354 }, { 4400, 4354 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiColorCorrectPalette"),	{ 4115, { 4115, -1 }, { 4115, 4414 }, { 4116, 4406 }, { 4392, 4451 }, { 4394, 4466 }, { 4395, 4478 }, { 4397, 4479 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCombineRgn"),	{ 4116, { 4116, 4147 }, { 4116, 4148 }, { 4117, 4148 }, { 4391, 4149 }, { 4393, 4150 }, { 4394, 4151 }, { 4396, 4151 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCombineTransform"),	{ 4117, { 4117, 4340 }, { 4117, 4341 }, { 4118, 4336 }, { 4390, 4336 }, { 4392, 4337 }, { 4393, 4338 }, { 4395, 4338 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiComputeXformCoefficients"),	{ 4118, { 4118, 4236 }, { 4118, 4237 }, { 4119, 4235 }, { 4389, 4235 }, { 4391, 4236 }, { 4392, 4237 }, { 4394, 4237 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiConfigureOPMProtectedOutput"),	{ -1, { -1, -1 }, { 4119, 4415 }, { 4120, 4407 }, { 4388, 4452 }, { 4390, 4467 }, { 4391, 4479 }, { 4393, 4480 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiConsoleTextOut"),	{ 4119, { 4119, 4205 }, { 4120, 4206 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiConvertMetafileRect"),	{ 4120, { 4120, 4414 }, { 4121, 4416 }, { 4121, 4408 }, { 4387, 4453 }, { 4389, 4468 }, { 4390, 4480 }, { 4392, 4481 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateBitmap"),	{ 4121, { 4121, -1 }, { 4122, 4205 }, { 4122, 4205 }, { 4386, 4205 }, { 4388, 4206 }, { 4389, 4207 }, { 4391, 4207 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateBitmapFromDxSurface"),	{ -1, { -1, -1 }, { -1, -1 }, { 4123, 4409 }, { 4385, 4454 }, { 4387, 4469 }, { 4388, 4481 }, { 4390, 4482 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateBitmapFromDxSurface2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4384, 4455 }, { 4386, 4470 }, { 4387, 4482 }, { 4389, 4483 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateClientObj"),	{ 4122, { 4122, 4286 }, { 4123, 4287 }, { 4124, 4282 }, { 4383, 4282 }, { 4385, 4283 }, { 4386, 4284 }, { 4388, 4284 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateColorSpace"),	{ 4123, { 4123, 4388 }, { 4124, 4389 }, { 4125, 4380 }, { 4382, 4380 }, { 4384, 4381 }, { 4385, 4382 }, { 4387, 4382 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateColorTransform"),	{ 4124, { 4124, -1 }, { 4125, 4417 }, { 4126, 4410 }, { 4381, 4456 }, { 4383, 4471 }, { 4384, 4483 }, { 4386, 4484 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateCompatibleBitmap"),	{ 4125, { 4125, 4170 }, { 4126, 4171 }, { 4127, 4171 }, { 4380, 4172 }, { 4382, 4173 }, { 4383, 4174 }, { 4385, 4174 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateCompatibleDC"),	{ 4126, { 4126, 4180 }, { 4127, 4181 }, { 4128, 4181 }, { 4379, 4181 }, { 4381, 4182 }, { 4382, 4183 }, { 4384, 4183 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateDIBBrush"),	{ 4127, { 4127, -1 }, { 4128, 4214 }, { 4129, 4212 }, { 4378, 4212 }, { 4380, 4213 }, { 4381, 4214 }, { 4383, 4214 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateDIBitmapInternal"),	{ 4128, { 4128, -1 }, { 4129, 4257 }, { 4130, 4255 }, { 4377, 4255 }, { 4379, 4256 }, { 4380, 4257 }, { 4382, 4257 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateDIBSection"),	{ 4129, { 4129, -1 }, { 4130, 4252 }, { 4131, 4250 }, { 4376, 4250 }, { 4378, 4251 }, { 4379, 4252 }, { 4381, 4252 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateEllipticRgn"),	{ 4130, { 4130, 4416 }, { 4131, 4418 }, { 4132, 4411 }, { 4374, 4457 }, { 4376, 4472 }, { 4377, 4484 }, { 4379, 4485 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateHalftonePalette"),	{ 4131, { 4131, 4337 }, { 4132, 4338 }, { 4133, 4333 }, { 4373, 4333 }, { 4375, 4334 }, { 4376, 4335 }, { 4378, 4335 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateHatchBrushInternal"),	{ 4132, { 4132, -1 }, { 4133, 4419 }, { 4134, 4412 }, { 4372, 4458 }, { 4374, 4473 }, { 4375, 4485 }, { 4377, 4486 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateMetafileDC"),	{ 4133, { 4133, -1 }, { 4134, 4420 }, { 4135, 4413 }, { 4371, 4459 }, { 4373, 4474 }, { 4374, 4486 }, { 4376, 4487 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateOPMProtectedOutputs"),	{ -1, { -1, -1 }, { 4135, 4421 }, { 4136, 4414 }, { 4370, 4460 }, { 4372, 4475 }, { 4373, 4487 }, { 4375, 4488 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreatePaletteInternal"),	{ 4134, { 4134, 4272 }, { 4136, 4273 }, { 4137, 4268 }, { 4369, 4268 }, { 4371, 4269 }, { 4372, 4270 }, { 4374, 4270 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreatePatternBrushInternal"),	{ 4135, { 4135, 4277 }, { 4137, 4278 }, { 4138, 4273 }, { 4368, 4273 }, { 4370, 4274 }, { 4371, 4275 }, { 4373, 4275 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreatePen"),	{ 4136, { 4136, 4182 }, { 4138, 4183 }, { 4139, 4183 }, { 4367, 4183 }, { 4369, 4184 }, { 4370, 4185 }, { 4372, 4185 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateRectRgn"),	{ 4137, { 4137, 4229 }, { 4139, 4230 }, { 4140, 4228 }, { 4366, 4228 }, { 4368, 4229 }, { 4369, 4230 }, { 4371, 4230 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateRoundRectRgn"),	{ 4138, { 4138, -1 }, { 4140, 4422 }, { 4141, 4415 }, { 4365, 4461 }, { 4367, 4476 }, { 4368, 4488 }, { 4370, 4489 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateServerMetaFile"),	{ 4139, { 4139, -1 }, { 4141, 4423 }, { 4142, 4416 }, { 4364, 4462 }, { 4366, 4477 }, { 4367, 4489 }, { 4369, 4490 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateSessionMappedDIBSection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4375, 4463 }, { 4377, 4478 }, { 4378, 4490 }, { 4380, 4491 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiCreateSolidBrush"),	{ 4140, { 4140, 4284 }, { 4142, 4285 }, { 4143, 4280 }, { 4363, 4280 }, { 4365, 4281 }, { 4366, 4282 }, { 4368, 4282 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiD3dContextCreate"),	{ 4141, { 4141, 4421 }, { 4143, 4424 }, { 4144, 4417 }, { 4362, 4464 }, { 4364, 4479 }, { 4365, 4491 }, { 4367, 4492 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiD3dContextDestroy"),	{ 4142, { 4142, 4422 }, { 4144, 4425 }, { 4145, 4418 }, { 4339, 4465 }, { 4341, 4480 }, { 4364, 4492 }, { 4366, 4493 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiD3dContextDestroyAll"),	{ 4143, { 4143, 4423 }, { 4145, 4426 }, { 4146, 4419 }, { 4342, 4466 }, { 4344, 4481 }, { 4363, 4493 }, { 4365, 4494 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiD3dDrawPrimitives2"),	{ 4145, { 4145, -1 }, { 4147, 4197 }, { 4148, 4197 }, { 4358, 4197 }, { 4360, 4198 }, { 4361, 4199 }, { 4363, 4199 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiD3dValidateTextureStageState"),	{ 4144, { 4144, 4424 }, { 4146, 4427 }, { 4147, 4420 }, { 4357, 4467 }, { 4359, 4482 }, { 4362, 4494 }, { 4364, 4495 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdAddAttachedSurface"),	{ 4147, { 4147, 4425 }, { 4149, 4434 }, { 4150, 4427 }, { 4331, 4474 }, { 4333, 4489 }, { 4359, 4501 }, { 4361, 4502 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdAlphaBlt"),	{ 4148, { 4148, 4426 }, { 4150, 4435 }, { 4151, 4428 }, { 4312, 4475 }, { 4314, 4490 }, { 4358, 4502 }, { 4360, 4503 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdAttachSurface"),	{ 4149, { 4149, 4427 }, { 4151, 4436 }, { 4152, 4429 }, { 4321, 4476 }, { 4323, 4491 }, { 4357, 4503 }, { 4359, 4504 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdBeginMoCompFrame"),	{ 4150, { 4150, 4428 }, { 4152, 4437 }, { 4153, 4430 }, { 4310, 4477 }, { 4312, 4492 }, { 4356, 4504 }, { 4358, 4505 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdBlt"),	{ 4151, { 4151, 4222 }, { 4153, 4223 }, { 4154, 4221 }, { 4314, 4221 }, { 4316, 4222 }, { 4355, 4223 }, { 4357, 4223 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCanCreateD3DBuffer"),	{ 4153, { 4153, 4429 }, { 4155, 4438 }, { 4156, 4431 }, { 4334, 4478 }, { 4336, 4493 }, { 4353, 4505 }, { 4355, 4506 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCanCreateSurface"),	{ 4152, { 4152, 4262 }, { 4154, 4263 }, { 4155, 4258 }, { 4353, 4258 }, { 4355, 4259 }, { 4354, 4260 }, { 4356, 4260 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDDCCIGetCapabilitiesString"),	{ -1, { -1, -1 }, { 4864, 4428 }, { 4908, 4421 }, { 4975, 4468 }, { 4993, 4483 }, { 5050, 4495 }, { 5052, 4496 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDDCCIGetCapabilitiesStringLength"),	{ -1, { -1, -1 }, { 4863, 4429 }, { 4907, 4422 }, { 4976, 4469 }, { 4994, 4484 }, { 5051, 4496 }, { 5053, 4497 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDDCCIGetTimingReport"),	{ -1, { -1, -1 }, { 4865, 4430 }, { 4909, 4423 }, { 4974, 4470 }, { 4992, 4485 }, { 5049, 4497 }, { 5051, 4498 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDDCCIGetVCPFeature"),	{ -1, { -1, -1 }, { 4860, 4431 }, { 4904, 4424 }, { 4979, 4471 }, { 4997, 4486 }, { 5054, 4498 }, { 5056, 4499 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDDCCISaveCurrentSettings"),	{ -1, { -1, -1 }, { 4862, 4432 }, { 4906, 4425 }, { 4977, 4472 }, { 4995, 4487 }, { 5052, 4499 }, { 5054, 4500 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDDCCISetVCPFeature"),	{ -1, { -1, -1 }, { 4861, 4433 }, { 4905, 4426 }, { 4978, 4473 }, { 4996, 4488 }, { 5053, 4500 }, { 5055, 4501 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdColorControl"),	{ 4154, { 4154, 4430 }, { 4156, 4439 }, { 4157, 4432 }, { 4296, 4479 }, { 4298, 4494 }, { 4352, 4506 }, { 4354, 4507 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCreateD3DBuffer"),	{ 4157, { 4157, -1 }, { 4159, 4440 }, { 4160, 4433 }, { 4346, 4480 }, { 4348, 4495 }, { 4349, 4507 }, { 4351, 4508 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCreateDirectDrawObject"),	{ 4155, { 4155, 4432 }, { 4157, 4441 }, { 4158, 4434 }, { 4361, 4481 }, { 4363, 4496 }, { 4351, 4508 }, { 4353, 4509 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCreateFullscreenSprite"),	{ -1, { -1, -1 }, { -1, -1 }, { 4910, 4435 }, { 4983, 4482 }, { 5001, 4497 }, { 5058, 4509 }, { 5060, 4510 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCreateMoComp"),	{ 4158, { 4158, 4433 }, { 4160, 4442 }, { 4161, 4436 }, { 4305, 4483 }, { 4307, 4498 }, { 4348, 4510 }, { 4350, 4511 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCreateSurface"),	{ 4156, { 4156, -1 }, { 4158, 4264 }, { 4159, 4259 }, { 4347, 4259 }, { 4349, 4260 }, { 4350, 4261 }, { 4352, 4261 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCreateSurfaceEx"),	{ 4190, { 4190, 4294 }, { 4192, 4295 }, { 4193, 4290 }, { 4313, 4290 }, { 4315, 4291 }, { 4316, 4292 }, { 4318, 4292 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdCreateSurfaceObject"),	{ 4159, { 4159, -1 }, { 4161, 4296 }, { 4162, 4291 }, { 4344, 4291 }, { 4346, 4292 }, { 4347, 4293 }, { 4349, 4293 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIAbandonSwapChain"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5032, 4511 }, { 5032, 4512 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIAcquireKeyedMutex"),	{ -1, { -1, -1 }, { -1, -1 }, { 4892, 4437 }, { 4947, 4484 }, { 4956, 4499 }, { 4972, 4512 }, { 4973, 4513 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIAcquireKeyedMutex2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4932, 4485 }, { 4941, 4500 }, { 4957, 4513 }, { 4958, 4514 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIAcquireSwapChain"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5030, 4514 }, { 5030, 4515 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIAdjustFullscreenGamma"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5040, 4515 }, { 5040, 4516 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICacheHybridQueryValue"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4980, 4501 }, { 5017, 4516 }, { 5018, 4517 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIChangeVideoMemoryReservation"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5026, 4517 }, { 5026, 4518 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICheckExclusiveOwnership"),	{ -1, { -1, -1 }, { 4850, 4443 }, { 4885, 4438 }, { 4954, 4486 }, { 4963, 4502 }, { 4979, 4518 }, { 4980, 4519 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICheckMonitorPowerState"),	{ -1, { -1, -1 }, { 4849, 4444 }, { 4884, 4439 }, { 4955, 4487 }, { 4964, 4503 }, { 4980, 4519 }, { 4981, 4520 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICheckMultiPlaneOverlaySupport"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4978, 4504 }, { 4996, 4520 }, { 4997, 4521 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICheckMultiPlaneOverlaySupport2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5034, 4521 }, { 5034, 4522 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICheckOcclusion"),	{ -1, { -1, -1 }, { 4847, 4445 }, { 4882, 4440 }, { 4957, 4488 }, { 4966, 4505 }, { 4982, 4522 }, { 4983, 4523 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICheckSharedResourceAccess"),	{ -1, { -1, -1 }, { -1, -1 }, { 4897, 4441 }, { 4942, 4489 }, { 4951, 4506 }, { 4967, 4523 }, { 4968, 4524 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICheckVidPnExclusiveOwnership"),	{ -1, { -1, -1 }, { -1, -1 }, { 4896, 4442 }, { 4943, 4490 }, { 4952, 4507 }, { 4968, 4524 }, { 4969, 4525 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICloseAdapter"),	{ -1, { -1, -1 }, { 4823, 4446 }, { 4857, 4443 }, { 4894, 4491 }, { 4903, 4508 }, { 4915, 4525 }, { 4916, 4526 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIConfigureSharedResource"),	{ -1, { -1, -1 }, { -1, -1 }, { 4894, 4444 }, { 4945, 4492 }, { 4954, 4509 }, { 4970, 4526 }, { 4971, 4527 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateAllocation"),	{ -1, { -1, -1 }, { 4798, 4447 }, { 4831, 4445 }, { 4927, 4493 }, { 4936, 4510 }, { 4952, 4527 }, { 4953, 4528 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateContext"),	{ -1, { -1, -1 }, { 4806, 4448 }, { 4839, 4446 }, { 4914, 4494 }, { 4923, 4511 }, { 4936, 4528 }, { 4937, 4529 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateContextVirtual"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5014, 4529 }, { 5015, 4530 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateDCFromMemory"),	{ -1, { -1, -1 }, { 4836, 4449 }, { 4871, 4447 }, { 4879, 4495 }, { 4888, 4512 }, { 4900, 4530 }, { 4901, 4531 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateDevice"),	{ -1, { -1, -1 }, { 4804, 4450 }, { 4837, 4448 }, { 4916, 4496 }, { 4925, 4513 }, { 4938, 4531 }, { 4939, 4532 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateKeyedMutex"),	{ -1, { -1, -1 }, { -1, -1 }, { 4889, 4449 }, { 4950, 4497 }, { 4959, 4514 }, { 4975, 4532 }, { 4976, 4533 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateKeyedMutex2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4934, 4498 }, { 4943, 4515 }, { 4959, 4533 }, { 4960, 4534 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateOutputDupl"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4939, 4499 }, { 4948, 4516 }, { 4964, 4534 }, { 4965, 4535 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateOverlay"),	{ -1, { -1, -1 }, { 4829, 4451 }, { 4864, 4450 }, { 4886, 4500 }, { 4895, 4517 }, { 4907, 4535 }, { 4908, 4536 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreatePagingQueue"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5004, 4536 }, { 5005, 4537 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateSwapChain"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5027, 4537 }, { 5027, 4538 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDICreateSynchronizationObject"),	{ -1, { -1, -1 }, { 4808, 4452 }, { 4841, 4451 }, { 4912, 4501 }, { 4921, 4518 }, { 4934, 4538 }, { 4935, 4539 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyAllocation"),	{ -1, { -1, -1 }, { 4801, 4453 }, { 4834, 4452 }, { 4919, 4502 }, { 4928, 4519 }, { 4941, 4539 }, { 4942, 4540 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyAllocation2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4942, 4540 }, { 4943, 4541 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyContext"),	{ -1, { -1, -1 }, { 4807, 4454 }, { 4840, 4453 }, { 4913, 4503 }, { 4922, 4520 }, { 4935, 4541 }, { 4936, 4542 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyDCFromMemory"),	{ -1, { -1, -1 }, { 4837, 4455 }, { 4872, 4454 }, { 4878, 4504 }, { 4887, 4521 }, { 4899, 4542 }, { 4900, 4543 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyDevice"),	{ -1, { -1, -1 }, { 4805, 4456 }, { 4838, 4455 }, { 4915, 4505 }, { 4924, 4522 }, { 4937, 4543 }, { 4938, 4544 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyKeyedMutex"),	{ -1, { -1, -1 }, { -1, -1 }, { 4891, 4456 }, { 4948, 4506 }, { 4957, 4523 }, { 4973, 4544 }, { 4974, 4545 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyOutputDupl"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4938, 4507 }, { 4947, 4524 }, { 4963, 4545 }, { 4964, 4546 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyOverlay"),	{ -1, { -1, -1 }, { 4832, 4457 }, { 4867, 4457 }, { 4883, 4508 }, { 4892, 4525 }, { 4904, 4546 }, { 4905, 4547 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroyPagingQueue"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5005, 4547 }, { 5006, 4548 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIDestroySynchronizationObject"),	{ -1, { -1, -1 }, { 4809, 4458 }, { 4843, 4458 }, { 4910, 4509 }, { 4919, 4526 }, { 4932, 4548 }, { 4933, 4549 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIEnumAdapters"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4896, 4510 }, { 4905, 4527 }, { 4917, 4549 }, { 4918, 4550 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIEnumAdapters2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4918, 4550 }, { 4919, 4551 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIEscape"),	{ -1, { -1, -1 }, { 4825, 4459 }, { 4859, 4459 }, { 4892, 4511 }, { 4901, 4528 }, { 4913, 4551 }, { 4914, 4552 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIEvict"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4998, 4552 }, { 4999, 4553 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIFlipOverlay"),	{ -1, { -1, -1 }, { 4831, 4460 }, { 4866, 4460 }, { 4884, 4512 }, { 4893, 4529 }, { 4905, 4553 }, { 4906, 4554 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIFlushHeapTransitions"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 4555 }, { 5043, 4555 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIFreeGpuVirtualAddress"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5012, 4554 }, { 5013, 4556 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetCachedHybridQueryValue"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4979, 4530 }, { 5016, 4555 }, { 5017, 4557 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetContextInProcessSchedulingPriority"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4965, 4513 }, { 4974, 4531 }, { 4992, 4556 }, { 4993, 4558 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetContextSchedulingPriority"),	{ -1, { -1, -1 }, { 4839, 4461 }, { 4874, 4461 }, { 4876, 4514 }, { 4885, 4532 }, { 4897, 4557 }, { 4898, 4559 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetDeviceState"),	{ -1, { -1, -1 }, { 4835, 4462 }, { 4870, 4462 }, { 4880, 4515 }, { 4889, 4533 }, { 4901, 4559 }, { 4902, 4561 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetDisplayModeList"),	{ -1, { -1, -1 }, { 4816, 4463 }, { 4850, 4463 }, { 4903, 4516 }, { 4912, 4534 }, { 4925, 4560 }, { 4926, 4562 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetDWMVerticalBlankEvent"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4989, 4558 }, { 4990, 4560 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetMultisampleMethodList"),	{ -1, { -1, -1 }, { 4818, 4464 }, { 4852, 4464 }, { 4901, 4517 }, { 4910, 4535 }, { 4923, 4561 }, { 4924, 4563 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetOverlayState"),	{ -1, { -1, -1 }, { -1, -1 }, { 4895, 4465 }, { 4944, 4518 }, { 4953, 4536 }, { 4969, 4562 }, { 4970, 4564 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetPresentHistory"),	{ -1, { -1, -1 }, { 4828, 4465 }, { 4862, 4466 }, { 4888, 4519 }, { 4897, 4537 }, { 4909, 4563 }, { 4910, 4565 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetPresentQueueEvent"),	{ -1, { -1, -1 }, { -1, -1 }, { 4863, 4467 }, { 4887, 4520 }, { 4896, 4538 }, { 4908, 4564 }, { 4909, 4566 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetProcessSchedulingPriorityClass"),	{ -1, { -1, -1 }, { 4841, 4466 }, { 4876, 4468 }, { 4874, 4521 }, { 4883, 4539 }, { 4895, 4565 }, { 4896, 4567 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetResourcePresentPrivateDriverData"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5009, 4566 }, { 5010, 4568 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetRuntimeData"),	{ -1, { -1, -1 }, { 4812, 4467 }, { 4846, 4469 }, { 4907, 4522 }, { 4916, 4540 }, { 4929, 4567 }, { 4930, 4569 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetScanLine"),	{ -1, { -1, -1 }, { 4843, 4468 }, { 4878, 4470 }, { 4872, 4523 }, { 4881, 4541 }, { 4893, 4568 }, { 4894, 4570 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetSetSwapChainMetadata"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5029, 4569 }, { 5029, 4571 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetSharedPrimaryHandle"),	{ -1, { -1, -1 }, { 4824, 4469 }, { 4858, 4471 }, { 4893, 4524 }, { 4902, 4542 }, { 4914, 4570 }, { 4915, 4572 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIGetSharedResourceAdapterLuid"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4966, 4525 }, { 4975, 4543 }, { 4993, 4571 }, { 4994, 4573 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIInvalidateActiveVidPn"),	{ -1, { -1, -1 }, { 4846, 4470 }, { 4881, 4472 }, { 4958, 4526 }, { 4967, 4544 }, { 4983, 4572 }, { 4984, 4574 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIInvalidateCache"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5008, 4573 }, { 5009, 4575 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDILock"),	{ -1, { -1, -1 }, { 4814, 4471 }, { 4848, 4473 }, { 4905, 4527 }, { 4914, 4545 }, { 4927, 4574 }, { 4928, 4576 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDILock2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5006, 4575 }, { 5007, 4577 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIMakeResident"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4997, 4576 }, { 4998, 4578 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIMapGpuVirtualAddress"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5010, 4577 }, { 5011, 4579 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIMarkDeviceAsError"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5042, 4578 }, { 5042, 4580 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDINetDispGetNextChunkInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4981, 4546 }, { 5018, 4579 }, { 5019, 4581 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDINetDispQueryMiracastDisplayDeviceStatus"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4985, 4547 }, { 5023, 4580 }, { 5023, 4582 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDINetDispQueryMiracastDisplayDeviceSupport"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4982, 4548 }, { 5019, 4581 }, { 5020, 4583 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDINetDispStartMiracastDisplayDevice"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4983, 4549 }, { 5020, 4582 }, { 5021, 4584 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDINetDispStartMiracastDisplayDeviceEx"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5021, 4583 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDINetDispStopMiracastDisplayDevice"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4984, 4550 }, { 5022, 4584 }, { 5022, 4585 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDINetDispStopSessions"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5024, 4585 }, { 5024, 4586 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOfferAllocations"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4941, 4528 }, { 4950, 4551 }, { 4966, 4586 }, { 4967, 4587 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenAdapterFromDeviceName"),	{ -1, { -1, -1 }, { 4821, 4472 }, { 4855, 4474 }, { 4898, 4529 }, { 4907, 4552 }, { 4920, 4587 }, { 4921, 4588 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenAdapterFromHdc"),	{ -1, { -1, -1 }, { 4822, 4473 }, { 4856, 4475 }, { 4897, 4530 }, { 4906, 4553 }, { 4919, 4588 }, { 4920, 4589 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenAdapterFromLuid"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4895, 4531 }, { 4904, 4554 }, { 4916, 4589 }, { 4917, 4590 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenKeyedMutex"),	{ -1, { -1, -1 }, { -1, -1 }, { 4890, 4476 }, { 4949, 4532 }, { 4958, 4555 }, { 4974, 4590 }, { 4975, 4591 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenKeyedMutex2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4933, 4533 }, { 4942, 4556 }, { 4958, 4591 }, { 4959, 4592 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenNtHandleFromName"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4923, 4534 }, { 4932, 4557 }, { 4947, 4592 }, { 4948, 4593 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenResource"),	{ -1, { -1, -1 }, { 4800, 4474 }, { 4833, 4477 }, { 4922, 4535 }, { 4931, 4558 }, { 4946, 4593 }, { 4947, 4594 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenResourceFromNtHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4920, 4536 }, { 4929, 4559 }, { 4943, 4594 }, { 4944, 4595 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenSwapChain"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5028, 4595 }, { 5028, 4596 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenSynchronizationObject"),	{ -1, { -1, -1 }, { -1, -1 }, { 4842, 4478 }, { 4911, 4538 }, { 4920, 4561 }, { 4933, 4599 }, { 4934, 4600 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenSyncObjectFromNtHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4921, 4537 }, { 4930, 4560 }, { 4944, 4596 }, { 4945, 4597 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenSyncObjectFromNtHandle2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4945, 4597 }, { 4946, 4598 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOpenSyncObjectNtHandleFromName"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4948, 4598 }, { 4949, 4599 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOutputDuplGetFrameInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4937, 4539 }, { 4946, 4562 }, { 4962, 4600 }, { 4963, 4601 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOutputDuplGetMetaData"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4936, 4540 }, { 4945, 4563 }, { 4961, 4601 }, { 4962, 4602 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOutputDuplGetPointerShapeData"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4935, 4541 }, { 4944, 4564 }, { 4960, 4602 }, { 4961, 4603 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOutputDuplPresent"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4930, 4542 }, { 4939, 4565 }, { 4955, 4603 }, { 4956, 4604 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIOutputDuplReleaseFrame"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4928, 4543 }, { 4937, 4566 }, { 4953, 4604 }, { 4954, 4605 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIPinDirectFlipResources"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4961, 4544 }, { 4970, 4567 }, { 4986, 4605 }, { 4987, 4606 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIPollDisplayChildren"),	{ -1, { -1, -1 }, { 4845, 4475 }, { 4880, 4479 }, { 4959, 4545 }, { 4968, 4568 }, { 4984, 4606 }, { 4985, 4607 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIPresent"),	{ -1, { -1, -1 }, { 4819, 4476 }, { 4853, 4480 }, { 4900, 4546 }, { 4909, 4569 }, { 4922, 4607 }, { 4923, 4608 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIPresentMultiPlaneOverlay"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4977, 4570 }, { 4995, 4608 }, { 4996, 4609 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIPresentMultiPlaneOverlay2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5035, 4609 }, { 5035, 4610 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryAdapterInfo"),	{ -1, { -1, -1 }, { 4813, 4477 }, { 4847, 4481 }, { 4906, 4547 }, { 4915, 4571 }, { 4928, 4610 }, { 4929, 4611 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryAllocationResidency"),	{ -1, { -1, -1 }, { 4803, 4478 }, { 4836, 4482 }, { 4917, 4548 }, { 4926, 4572 }, { 4939, 4611 }, { 4940, 4612 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryClockCalibration"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5038, 4612 }, { 5038, 4613 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryRemoteVidPnSourceFromGdiDisplayName"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4929, 4549 }, { 4938, 4573 }, { 4954, 4613 }, { 4955, 4614 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryResourceInfo"),	{ -1, { -1, -1 }, { 4799, 4479 }, { 4832, 4483 }, { 4926, 4550 }, { 4935, 4574 }, { 4951, 4614 }, { 4952, 4615 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryResourceInfoFromNtHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4925, 4551 }, { 4934, 4575 }, { 4950, 4615 }, { 4951, 4616 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryStatistics"),	{ -1, { -1, -1 }, { 4826, 4480 }, { 4860, 4484 }, { 4891, 4552 }, { 4900, 4576 }, { 4912, 4616 }, { 4913, 4617 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryVideoMemoryInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5025, 4618 }, { 5025, 4619 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIQueryVidPnExclusiveOwnership"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5039, 4617 }, { 5039, 4618 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIReclaimAllocations"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4940, 4553 }, { 4949, 4577 }, { 4965, 4619 }, { 4966, 4620 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIReclaimAllocations2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5036, 4620 }, { 5036, 4621 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIReleaseKeyedMutex"),	{ -1, { -1, -1 }, { -1, -1 }, { 4893, 4485 }, { 4946, 4554 }, { 4955, 4578 }, { 4971, 4621 }, { 4972, 4622 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIReleaseKeyedMutex2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4931, 4555 }, { 4940, 4579 }, { 4956, 4622 }, { 4957, 4623 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIReleaseProcessVidPnSourceOwners"),	{ -1, { -1, -1 }, { 4842, 4481 }, { 4877, 4486 }, { 4873, 4556 }, { 4882, 4580 }, { 4894, 4623 }, { 4895, 4624 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIReleaseSwapChain"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5031, 4624 }, { 5031, 4625 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIRender"),	{ -1, { -1, -1 }, { 4820, 4482 }, { 4854, 4487 }, { 4899, 4557 }, { 4908, 4581 }, { 4921, 4625 }, { 4922, 4626 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIReserveGpuVirtualAddress"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5011, 4626 }, { 5012, 4627 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetAllocationPriority"),	{ -1, { -1, -1 }, { 4802, 4483 }, { 4835, 4488 }, { 4918, 4558 }, { 4927, 4582 }, { 4940, 4627 }, { 4941, 4628 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetContextInProcessSchedulingPriority"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4964, 4559 }, { 4973, 4583 }, { 4991, 4628 }, { 4992, 4629 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetContextSchedulingPriority"),	{ -1, { -1, -1 }, { 4838, 4484 }, { 4873, 4489 }, { 4877, 4560 }, { 4886, 4584 }, { 4898, 4629 }, { 4899, 4630 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetDisplayMode"),	{ -1, { -1, -1 }, { 4817, 4485 }, { 4851, 4490 }, { 4902, 4561 }, { 4911, 4585 }, { 4924, 4630 }, { 4925, 4631 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetDisplayPrivateDriverFormat"),	{ -1, { -1, -1 }, { 4851, 4486 }, { 4886, 4491 }, { 4953, 4562 }, { 4962, 4586 }, { 4978, 4631 }, { 4979, 4632 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetDodIndirectSwapchain"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5033, 4632 }, { 5033, 4633 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetGammaRamp"),	{ -1, { -1, -1 }, { 4834, 4487 }, { 4869, 4492 }, { 4881, 4563 }, { 4890, 4587 }, { 4902, 4633 }, { 4903, 4634 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetHwProtectionTeardownRecovery"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 4635 }, { 5044, 4635 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetProcessSchedulingPriorityClass"),	{ -1, { -1, -1 }, { 4840, 4488 }, { 4875, 4493 }, { 4875, 4564 }, { 4884, 4588 }, { 4896, 4634 }, { 4897, 4636 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetQueuedLimit"),	{ -1, { -1, -1 }, { 4844, 4489 }, { 4879, 4494 }, { 4960, 4565 }, { 4969, 4589 }, { 4985, 4635 }, { 4986, 4637 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetStablePowerState"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5037, 4636 }, { 5037, 4638 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetStereoEnabled"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4967, 4566 }, { 4976, 4590 }, { 4994, 4637 }, { 4995, 4639 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetSyncRefreshCountWaitTarget"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4990, 4638 }, { 4991, 4640 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetVidPnSourceHwProtection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5041, 4639 }, { 5041, 4641 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetVidPnSourceOwner"),	{ -1, { -1, -1 }, { 4827, 4490 }, { 4861, 4495 }, { 4890, 4567 }, { 4899, 4591 }, { 4911, 4640 }, { 4912, 4642 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISetVidPnSourceOwner1"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4889, 4568 }, { 4898, 4592 }, { 4910, 4641 }, { 4911, 4643 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISharedPrimaryLockNotification"),	{ -1, { -1, -1 }, { 4852, 4491 }, { 4887, 4496 }, { 4952, 4570 }, { 4961, 4594 }, { 4977, 4643 }, { 4978, 4645 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISharedPrimaryUnLockNotification"),	{ -1, { -1, -1 }, { 4853, 4492 }, { 4888, 4497 }, { 4951, 4571 }, { 4960, 4595 }, { 4976, 4644 }, { 4977, 4646 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIShareObjects"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4924, 4569 }, { 4933, 4593 }, { 4949, 4642 }, { 4950, 4644 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISignalSynchronizationObject"),	{ -1, { -1, -1 }, { 4811, 4493 }, { 4845, 4498 }, { 4908, 4572 }, { 4917, 4596 }, { 4930, 4645 }, { 4931, 4647 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISignalSynchronizationObjectFromCpu"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5000, 4646 }, { 5001, 4648 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISignalSynchronizationObjectFromGpu"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5002, 4647 }, { 5003, 4649 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISignalSynchronizationObjectFromGpu2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5003, 4648 }, { 5004, 4650 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDISubmitCommand"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5015, 4649 }, { 5016, 4651 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIUnlock"),	{ -1, { -1, -1 }, { 4815, 4494 }, { 4849, 4499 }, { 4904, 4573 }, { 4913, 4597 }, { 4926, 4650 }, { 4927, 4652 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIUnlock2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5007, 4651 }, { 5008, 4653 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIUnpinDirectFlipResources"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4962, 4574 }, { 4971, 4598 }, { 4987, 4652 }, { 4988, 4654 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIUpdateGpuVirtualAddress"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5013, 4653 }, { 5014, 4655 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIUpdateOverlay"),	{ -1, { -1, -1 }, { 4830, 4495 }, { 4865, 4500 }, { 4885, 4575 }, { 4894, 4599 }, { 4906, 4654 }, { 4907, 4656 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIWaitForIdle"),	{ -1, { -1, -1 }, { 4848, 4496 }, { 4883, 4501 }, { 4956, 4576 }, { 4965, 4600 }, { 4981, 4655 }, { 4982, 4657 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIWaitForSynchronizationObject"),	{ -1, { -1, -1 }, { 4810, 4497 }, { 4844, 4502 }, { 4909, 4577 }, { 4918, 4601 }, { 4931, 4656 }, { 4932, 4658 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIWaitForSynchronizationObjectFromCpu"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4999, 4657 }, { 5000, 4659 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIWaitForSynchronizationObjectFromGpu"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5001, 4658 }, { 5002, 4660 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIWaitForVerticalBlankEvent"),	{ -1, { -1, -1 }, { 4833, 4498 }, { 4868, 4503 }, { 4882, 4578 }, { 4891, 4602 }, { 4903, 4659 }, { 4904, 4661 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDDIWaitForVerticalBlankEvent2"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4963, 4579 }, { 4972, 4603 }, { 4988, 4660 }, { 4989, 4662 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDeleteDirectDrawObject"),	{ 4160, { 4160, 4434 }, { 4162, 4499 }, { 4163, 4504 }, { 4359, 4580 }, { 4361, 4604 }, { 4346, 4661 }, { 4348, 4663 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDeleteSurfaceObject"),	{ 4161, { 4161, 4258 }, { 4163, 4259 }, { 4164, 4257 }, { 4343, 4257 }, { 4345, 4258 }, { 4345, 4259 }, { 4347, 4259 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDestroyD3DBuffer"),	{ 4164, { 4164, 4435 }, { 4166, 4500 }, { 4167, 4505 }, { 4348, 4581 }, { 4350, 4605 }, { 4342, 4662 }, { 4344, 4664 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDestroyFullscreenSprite"),	{ -1, { -1, -1 }, { -1, -1 }, { 4912, 4506 }, { 4981, 4582 }, { 4999, 4606 }, { 5056, 4663 }, { 5058, 4665 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDestroyMoComp"),	{ 4162, { 4162, 4436 }, { 4164, 4501 }, { 4165, 4507 }, { 4323, 4583 }, { 4325, 4607 }, { 4344, 4664 }, { 4346, 4666 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdDestroySurface"),	{ 4163, { 4163, 4265 }, { 4165, 4266 }, { 4166, 4261 }, { 4292, 4261 }, { 4294, 4262 }, { 4343, 4263 }, { 4345, 4263 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdEndMoCompFrame"),	{ 4165, { 4165, 4437 }, { 4167, 4502 }, { 4168, 4508 }, { 4316, 4584 }, { 4318, 4608 }, { 4341, 4665 }, { 4343, 4667 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdFlip"),	{ 4166, { 4166, -1 }, { 4168, 4503 }, { 4169, 4509 }, { 4337, 4585 }, { 4339, 4609 }, { 4340, 4666 }, { 4342, 4668 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdFlipToGDISurface"),	{ 4167, { 4167, 4439 }, { 4169, 4504 }, { 4170, 4510 }, { 4336, 4586 }, { 4338, 4610 }, { 4339, 4667 }, { 4341, 4669 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetAvailDriverMemory"),	{ 4168, { 4168, 4440 }, { 4170, 4505 }, { 4171, 4511 }, { 4350, 4587 }, { 4352, 4611 }, { 4338, 4668 }, { 4340, 4670 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetBltStatus"),	{ 4169, { 4169, 4441 }, { 4171, 4506 }, { 4172, 4512 }, { 4290, 4588 }, { 4292, 4612 }, { 4337, 4669 }, { 4339, 4671 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetDC"),	{ 4170, { 4170, 4442 }, { 4172, 4507 }, { 4173, 4513 }, { 4326, 4589 }, { 4328, 4613 }, { 4336, 4670 }, { 4338, 4672 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetDriverInfo"),	{ 4171, { 4171, 4443 }, { 4173, 4508 }, { 4174, 4514 }, { 4327, 4590 }, { 4329, 4614 }, { 4335, 4671 }, { 4337, 4673 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetDriverState"),	{ 4146, { 4146, 4444 }, { 4148, 4509 }, { 4149, 4515 }, { 4360, 4591 }, { 4362, 4615 }, { 4360, 4672 }, { 4362, 4674 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetDxHandle"),	{ 4172, { 4172, 4445 }, { 4174, 4510 }, { 4175, 4516 }, { 4308, 4592 }, { 4310, 4616 }, { 4334, 4673 }, { 4336, 4675 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetFlipStatus"),	{ 4173, { 4173, 4446 }, { 4175, 4511 }, { 4176, 4517 }, { 4306, 4593 }, { 4308, 4617 }, { 4333, 4674 }, { 4335, 4676 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetInternalMoCompInfo"),	{ 4174, { 4174, 4447 }, { 4176, 4512 }, { 4177, 4518 }, { 4349, 4594 }, { 4351, 4618 }, { 4332, 4675 }, { 4334, 4677 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetMoCompBuffInfo"),	{ 4175, { 4175, 4448 }, { 4177, 4513 }, { 4178, 4519 }, { 4351, 4595 }, { 4353, 4619 }, { 4331, 4676 }, { 4333, 4678 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetMoCompFormats"),	{ 4177, { 4177, 4449 }, { 4179, 4514 }, { 4180, 4520 }, { 4330, 4596 }, { 4332, 4620 }, { 4329, 4677 }, { 4331, 4679 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetMoCompGuids"),	{ 4176, { 4176, 4450 }, { 4178, 4515 }, { 4179, 4521 }, { 4297, 4597 }, { 4299, 4621 }, { 4330, 4678 }, { 4332, 4680 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdGetScanLine"),	{ 4178, { 4178, 4451 }, { 4180, 4516 }, { 4181, 4522 }, { 4341, 4598 }, { 4343, 4622 }, { 4328, 4679 }, { 4330, 4681 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdLock"),	{ 4179, { 4179, 4452 }, { 4181, 4517 }, { 4182, 4523 }, { 4356, 4599 }, { 4358, 4623 }, { 4327, 4680 }, { 4329, 4682 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdLockD3D"),	{ 4180, { 4180, 4297 }, { 4182, 4298 }, { 4183, 4293 }, { 4315, 4293 }, { 4317, 4294 }, { 4326, 4295 }, { 4328, 4295 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdNotifyFullscreenSpriteUpdate"),	{ -1, { -1, -1 }, { -1, -1 }, { 4911, 4524 }, { 4982, 4600 }, { 5000, 4624 }, { 5057, 4681 }, { 5059, 4683 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdQueryDirectDrawObject"),	{ 4181, { 4181, -1 }, { 4183, 4518 }, { 4184, 4525 }, { 4322, 4601 }, { 4324, 4625 }, { 4325, 4682 }, { 4327, 4684 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdQueryMoCompStatus"),	{ 4182, { 4182, 4454 }, { 4184, 4519 }, { 4185, 4526 }, { 4295, 4602 }, { 4297, 4626 }, { 4324, 4683 }, { 4326, 4685 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdQueryVisRgnUniqueness"),	{ -1, { -1, -1 }, { -1, -1 }, { 4913, 4527 }, { 4980, 4603 }, { 4998, 4627 }, { 5055, 4684 }, { 5057, 4686 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdReenableDirectDrawObject"),	{ 4183, { 4183, 4455 }, { 4185, 4520 }, { 4186, 4528 }, { 4328, 4604 }, { 4330, 4628 }, { 4323, 4685 }, { 4325, 4687 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdReleaseDC"),	{ 4184, { 4184, 4456 }, { 4186, 4521 }, { 4187, 4529 }, { 4319, 4605 }, { 4321, 4629 }, { 4322, 4686 }, { 4324, 4688 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdRenderMoComp"),	{ 4185, { 4185, 4457 }, { 4187, 4522 }, { 4188, 4530 }, { 4294, 4606 }, { 4296, 4630 }, { 4321, 4687 }, { 4323, 4689 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdResetVisrgn"),	{ 4186, { 4186, 4270 }, { 4188, 4271 }, { 4189, 4266 }, { 4332, 4266 }, { 4334, 4267 }, { 4320, 4268 }, { 4322, 4268 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdSetColorKey"),	{ 4187, { 4187, 4458 }, { 4189, 4523 }, { 4190, 4531 }, { 4318, 4607 }, { 4320, 4631 }, { 4319, 4688 }, { 4321, 4690 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdSetExclusiveMode"),	{ 4188, { 4188, 4459 }, { 4190, 4524 }, { 4191, 4532 }, { 4335, 4608 }, { 4337, 4632 }, { 4318, 4689 }, { 4320, 4691 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdSetGammaRamp"),	{ 4189, { 4189, 4460 }, { 4191, 4525 }, { 4192, 4533 }, { 4324, 4609 }, { 4326, 4633 }, { 4317, 4690 }, { 4319, 4692 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdSetOverlayPosition"),	{ 4191, { 4191, 4461 }, { 4193, 4526 }, { 4194, 4534 }, { 4291, 4610 }, { 4293, 4634 }, { 4315, 4691 }, { 4317, 4693 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdUnattachSurface"),	{ 4192, { 4192, 4462 }, { 4194, 4527 }, { 4195, 4535 }, { 4311, 4611 }, { 4313, 4635 }, { 4314, 4692 }, { 4316, 4694 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdUnlock"),	{ 4193, { 4193, 4463 }, { 4195, 4528 }, { 4196, 4536 }, { 4298, 4612 }, { 4300, 4636 }, { 4313, 4693 }, { 4315, 4695 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdUnlockD3D"),	{ 4194, { 4194, 4298 }, { 4196, 4299 }, { 4197, 4294 }, { 4329, 4294 }, { 4331, 4295 }, { 4312, 4296 }, { 4314, 4296 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdUpdateOverlay"),	{ 4195, { 4195, 4464 }, { 4197, 4529 }, { 4198, 4537 }, { 4352, 4613 }, { 4354, 4637 }, { 4311, 4694 }, { 4313, 4696 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDdWaitForVerticalBlank"),	{ 4196, { 4196, 4465 }, { 4198, 4530 }, { 4199, 4538 }, { 4345, 4614 }, { 4347, 4638 }, { 4310, 4695 }, { 4312, 4697 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDeleteClientObj"),	{ 4215, { 4215, 4232 }, { 4217, 4233 }, { 4218, 4231 }, { 4288, 4231 }, { 4290, 4232 }, { 4291, 4233 }, { 4293, 4233 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDeleteColorSpace"),	{ 4216, { 4216, 4389 }, { 4218, 4390 }, { 4219, 4381 }, { 4287, 4381 }, { 4289, 4382 }, { 4290, 4383 }, { 4292, 4383 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDeleteColorTransform"),	{ 4217, { 4217, 4466 }, { 4219, 4531 }, { 4220, 4539 }, { 4286, 4615 }, { 4288, 4639 }, { 4289, 4696 }, { 4291, 4698 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDeleteObjectApp"),	{ 4218, { 4218, 4130 }, { 4220, 4131 }, { 4221, 4131 }, { 4285, 4132 }, { 4287, 4133 }, { 4288, 4134 }, { 4290, 4134 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDescribePixelFormat"),	{ 4219, { 4219, 4467 }, { 4221, 4532 }, { 4222, 4540 }, { 4284, 4616 }, { 4286, 4640 }, { 4287, 4697 }, { 4289, 4699 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDestroyOPMProtectedOutput"),	{ -1, { -1, -1 }, { 4222, 4533 }, { 4223, 4541 }, { 4283, 4617 }, { 4285, 4641 }, { 4286, 4698 }, { 4288, 4700 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDestroyPhysicalMonitor"),	{ -1, { -1, -1 }, { 4859, 4534 }, { 4903, 4542 }, { 4970, 4618 }, { 4988, 4642 }, { 5045, 4699 }, { 5047, 4701 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDoBanding"),	{ 4221, { 4221, 4468 }, { 4224, 4535 }, { 4225, 4543 }, { 4281, 4619 }, { 4283, 4643 }, { 4284, 4700 }, { 4286, 4702 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDoPalette"),	{ 4222, { 4222, -1 }, { 4225, 4167 }, { 4226, 4167 }, { 4280, 4168 }, { 4282, 4169 }, { 4283, 4170 }, { 4285, 4170 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDrawEscape"),	{ 4223, { 4223, 4469 }, { 4226, 4536 }, { 4227, 4544 }, { 4279, 4620 }, { 4281, 4644 }, { 4282, 4701 }, { 4284, 4703 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDrawStream"),	{ 4762, { 4758, 4193 }, { 4795, 4194 }, { 4827, 4194 }, { 4868, 4194 }, { 4877, 4195 }, { 4889, 4196 }, { 4890, 4196 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpAcquireNotification"),	{ 4212, { 4212, 4470 }, { 4214, 4537 }, { 4215, 4545 }, { 4355, 4621 }, { 4357, 4645 }, { 4294, 4702 }, { 4296, 4704 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpCanCreateVideoPort"),	{ 4197, { 4197, 4471 }, { 4199, 4538 }, { 4200, 4546 }, { 4338, 4622 }, { 4340, 4646 }, { 4309, 4703 }, { 4311, 4705 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpColorControl"),	{ 4198, { 4198, 4472 }, { 4200, 4539 }, { 4201, 4547 }, { 4301, 4623 }, { 4303, 4647 }, { 4308, 4704 }, { 4310, 4706 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpCreateVideoPort"),	{ 4199, { 4199, 4473 }, { 4201, 4540 }, { 4202, 4548 }, { 4340, 4624 }, { 4342, 4648 }, { 4307, 4705 }, { 4309, 4707 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpDestroyVideoPort"),	{ 4200, { 4200, 4474 }, { 4202, 4541 }, { 4203, 4549 }, { 4299, 4625 }, { 4301, 4649 }, { 4306, 4706 }, { 4308, 4708 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpFlipVideoPort"),	{ 4201, { 4201, 4475 }, { 4203, 4542 }, { 4204, 4550 }, { 4302, 4626 }, { 4304, 4650 }, { 4305, 4707 }, { 4307, 4709 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpGetVideoPortBandwidth"),	{ 4202, { 4202, 4476 }, { 4204, 4543 }, { 4205, 4551 }, { 4303, 4627 }, { 4305, 4651 }, { 4304, 4708 }, { 4306, 4710 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpGetVideoPortConnectInfo"),	{ 4208, { 4208, 4477 }, { 4210, 4544 }, { 4211, 4552 }, { 4325, 4628 }, { 4327, 4652 }, { 4298, 4709 }, { 4300, 4711 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpGetVideoPortField"),	{ 4203, { 4203, 4478 }, { 4205, 4545 }, { 4206, 4553 }, { 4333, 4629 }, { 4335, 4653 }, { 4303, 4710 }, { 4305, 4712 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpGetVideoPortFlipStatus"),	{ 4204, { 4204, 4479 }, { 4206, 4546 }, { 4207, 4554 }, { 4309, 4630 }, { 4311, 4654 }, { 4302, 4711 }, { 4304, 4713 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpGetVideoPortInputFormats"),	{ 4205, { 4205, 4480 }, { 4207, 4547 }, { 4208, 4555 }, { 4317, 4631 }, { 4319, 4655 }, { 4301, 4712 }, { 4303, 4714 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpGetVideoPortLine"),	{ 4206, { 4206, 4481 }, { 4208, 4548 }, { 4209, 4556 }, { 4354, 4632 }, { 4356, 4656 }, { 4300, 4713 }, { 4302, 4715 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpGetVideoPortOutputFormats"),	{ 4207, { 4207, 4482 }, { 4209, 4549 }, { 4210, 4557 }, { 4307, 4633 }, { 4309, 4657 }, { 4299, 4714 }, { 4301, 4716 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpGetVideoSignalStatus"),	{ 4209, { 4209, 4483 }, { 4211, 4550 }, { 4212, 4558 }, { 4320, 4634 }, { 4322, 4658 }, { 4297, 4715 }, { 4299, 4717 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpReleaseNotification"),	{ 4213, { 4213, 4484 }, { 4215, 4551 }, { 4216, 4559 }, { 4300, 4635 }, { 4302, 4659 }, { 4293, 4716 }, { 4295, 4718 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpUpdateVideoPort"),	{ 4210, { 4210, 4485 }, { 4212, 4552 }, { 4213, 4560 }, { 4293, 4636 }, { 4295, 4660 }, { 4296, 4717 }, { 4298, 4719 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDvpWaitForVideoPortSync"),	{ 4211, { 4211, 4486 }, { 4213, 4553 }, { 4214, 4561 }, { 4304, 4637 }, { 4306, 4661 }, { 4295, 4718 }, { 4297, 4720 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDwmCreatedBitmapRemotingOutput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4871, 4638 }, { 4880, 4662 }, { 4892, 4719 }, { 4893, 4721 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDwmGetDirtyRgn"),	{ -1, { -1, -1 }, { 4796, 4554 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDwmGetSurfaceData"),	{ -1, { -1, -1 }, { 4797, 4555 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiDxgGenericThunk"),	{ 4214, { 4214, -1 }, { 4216, 4556 }, { 4217, 4562 }, { 4289, 4639 }, { 4291, 4663 }, { 4292, 4720 }, { 4294, 4722 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEllipse"),	{ 4224, { 4224, -1 }, { 4227, 4557 }, { 4228, 4563 }, { 4278, 4640 }, { 4280, 4664 }, { 4281, 4721 }, { 4283, 4723 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEnableEudc"),	{ 4225, { 4225, -1 }, { 4228, 4558 }, { 4229, 4564 }, { 4277, 4641 }, { 4279, 4665 }, { 4280, 4722 }, { 4282, 4724 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEndDoc"),	{ 4226, { 4226, 4490 }, { 4229, 4559 }, { 4230, 4565 }, { 4276, 4642 }, { 4278, 4666 }, { 4279, 4723 }, { 4281, 4725 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEndGdiRendering"),	{ -1, { -1, -1 }, { -1, -1 }, { 4231, 4566 }, { 4275, 4643 }, { 4277, 4667 }, { 4278, 4724 }, { 4280, 4726 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEndPage"),	{ 4227, { 4227, 4491 }, { 4230, 4560 }, { 4232, 4567 }, { 4274, 4644 }, { 4276, 4668 }, { 4277, 4725 }, { 4279, 4727 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEndPath"),	{ 4228, { 4228, -1 }, { 4231, 4369 }, { 4233, 4362 }, { 4273, 4362 }, { 4275, 4363 }, { 4276, 4364 }, { 4278, 4364 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngAlphaBlend"),	{ 4716, { 4712, -1 }, { 4749, 4561 }, { 4781, 4568 }, { 4775, 4645 }, { 4778, 4669 }, { 4788, 4726 }, { 4789, 4728 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngAssociateSurface"),	{ 4695, { 4691, 4493 }, { 4728, 4562 }, { 4760, 4569 }, { 4796, 4646 }, { 4799, 4670 }, { 4809, 4727 }, { 4810, 4729 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngBitBlt"),	{ 4707, { 4703, -1 }, { 4740, 4563 }, { 4772, 4570 }, { 4784, 4647 }, { 4787, 4671 }, { 4797, 4728 }, { 4798, 4730 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngCheckAbort"),	{ 4755, { 4751, 4495 }, { 4788, 4564 }, { 4820, 4571 }, { 4859, 4648 }, { 4868, 4672 }, { 4880, 4729 }, { 4881, 4731 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngComputeGlyphSet"),	{ 4700, { 4696, 4496 }, { 4733, 4565 }, { 4765, 4572 }, { 4791, 4649 }, { 4794, 4673 }, { 4804, 4730 }, { 4805, 4732 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngCopyBits"),	{ 4701, { 4697, -1 }, { 4734, 4566 }, { 4766, 4573 }, { 4790, 4650 }, { 4793, 4674 }, { 4803, 4731 }, { 4804, 4733 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngCreateBitmap"),	{ 4696, { 4692, -1 }, { 4729, 4567 }, { 4761, 4574 }, { 4795, 4651 }, { 4798, 4675 }, { 4808, 4732 }, { 4809, 4734 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngCreateClip"),	{ 4728, { 4724, 4499 }, { 4761, 4568 }, { 4793, 4575 }, { 4830, 4652 }, { 4839, 4676 }, { 4851, 4733 }, { 4852, 4735 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngCreateDeviceBitmap"),	{ 4698, { 4694, 4500 }, { 4731, 4569 }, { 4763, 4576 }, { 4793, 4653 }, { 4796, 4677 }, { 4806, 4734 }, { 4807, 4736 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngCreateDeviceSurface"),	{ 4697, { 4693, 4501 }, { 4730, 4570 }, { 4762, 4577 }, { 4794, 4654 }, { 4797, 4678 }, { 4807, 4735 }, { 4808, 4737 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngCreatePalette"),	{ 4699, { 4695, -1 }, { 4732, 4571 }, { 4764, 4578 }, { 4792, 4655 }, { 4795, 4679 }, { 4805, 4736 }, { 4806, 4738 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngDeleteClip"),	{ 4729, { 4725, 4503 }, { 4762, 4572 }, { 4794, 4579 }, { 4829, 4656 }, { 4838, 4680 }, { 4850, 4737 }, { 4851, 4739 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngDeletePalette"),	{ 4702, { 4698, -1 }, { 4735, 4573 }, { 4767, 4580 }, { 4789, 4657 }, { 4792, 4681 }, { 4802, 4738 }, { 4803, 4740 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngDeletePath"),	{ 4727, { 4723, 4505 }, { 4760, 4574 }, { 4792, 4581 }, { 4831, 4658 }, { 4840, 4682 }, { 4852, 4739 }, { 4853, 4741 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngDeleteSurface"),	{ 4703, { 4699, 4506 }, { 4736, 4575 }, { 4768, 4582 }, { 4788, 4659 }, { 4791, 4683 }, { 4801, 4740 }, { 4802, 4742 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngEraseSurface"),	{ 4704, { 4700, 4507 }, { 4737, 4576 }, { 4769, 4583 }, { 4787, 4660 }, { 4790, 4684 }, { 4800, 4741 }, { 4801, 4743 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngFillPath"),	{ 4712, { 4708, -1 }, { 4745, 4577 }, { 4777, 4584 }, { 4779, 4661 }, { 4782, 4685 }, { 4792, 4742 }, { 4793, 4744 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngGradientFill"),	{ 4717, { 4713, -1 }, { 4750, 4578 }, { 4782, 4585 }, { 4774, 4662 }, { 4777, 4686 }, { 4787, 4743 }, { 4788, 4745 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngLineTo"),	{ 4715, { 4711, -1 }, { 4748, 4579 }, { 4780, 4586 }, { 4776, 4663 }, { 4779, 4687 }, { 4789, 4744 }, { 4790, 4746 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngLockSurface"),	{ 4706, { 4702, 4511 }, { 4739, 4580 }, { 4771, 4587 }, { 4785, 4664 }, { 4788, 4688 }, { 4798, 4745 }, { 4799, 4747 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngMarkBandingSurface"),	{ 4710, { 4706, 4512 }, { 4743, 4581 }, { 4775, 4588 }, { 4781, 4665 }, { 4784, 4689 }, { 4794, 4746 }, { 4795, 4748 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngPaint"),	{ 4714, { 4710, -1 }, { 4747, 4582 }, { 4779, 4589 }, { 4777, 4666 }, { 4780, 4690 }, { 4790, 4747 }, { 4791, 4749 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngPlgBlt"),	{ 4709, { 4705, -1 }, { 4742, 4583 }, { 4774, 4590 }, { 4782, 4667 }, { 4785, 4691 }, { 4795, 4748 }, { 4796, 4750 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngStretchBlt"),	{ 4708, { 4704, -1 }, { 4741, 4584 }, { 4773, 4591 }, { 4783, 4668 }, { 4786, 4692 }, { 4796, 4749 }, { 4797, 4751 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngStretchBltROP"),	{ 4720, { 4716, -1 }, { 4753, 4585 }, { 4785, 4592 }, { 4771, 4669 }, { 4774, 4693 }, { 4784, 4750 }, { 4785, 4752 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngStrokeAndFillPath"),	{ 4713, { 4709, -1 }, { 4746, 4586 }, { 4778, 4593 }, { 4778, 4670 }, { 4781, 4694 }, { 4791, 4751 }, { 4792, 4753 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngStrokePath"),	{ 4711, { 4707, -1 }, { 4744, 4587 }, { 4776, 4594 }, { 4780, 4671 }, { 4783, 4695 }, { 4793, 4752 }, { 4794, 4754 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngTextOut"),	{ 4719, { 4715, -1 }, { 4752, 4588 }, { 4784, 4595 }, { 4772, 4672 }, { 4775, 4696 }, { 4785, 4753 }, { 4786, 4755 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngTransparentBlt"),	{ 4718, { 4714, -1 }, { 4751, 4589 }, { 4783, 4596 }, { 4773, 4673 }, { 4776, 4697 }, { 4786, 4754 }, { 4787, 4756 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEngUnlockSurface"),	{ 4705, { 4701, 4521 }, { 4738, 4590 }, { 4770, 4597 }, { 4786, 4674 }, { 4789, 4698 }, { 4799, 4755 }, { 4800, 4757 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEnumFontChunk"),	{ 4229, { 4229, -1 }, { 4232, 4262 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEnumFontClose"),	{ 4230, { 4230, 4259 }, { 4233, 4260 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEnumFontOpen"),	{ 4231, { 4231, -1 }, { 4234, 4261 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEnumFonts"),	{ -1, { -1, -1 }, { -1, -1 }, { 4234, 4598 }, { 4272, 4675 }, { 4274, 4699 }, { 4275, 4756 }, { 4277, 4758 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEnumObjects"),	{ 4232, { 4232, 4522 }, { 4235, 4591 }, { 4235, 4599 }, { 4271, 4676 }, { 4273, 4700 }, { 4274, 4757 }, { 4276, 4759 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEqualRgn"),	{ 4233, { 4233, 4375 }, { 4236, 4376 }, { 4236, 4369 }, { 4270, 4369 }, { 4272, 4370 }, { 4273, 4371 }, { 4275, 4371 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiEudcLoadUnloadLink"),	{ 4234, { 4234, -1 }, { 4237, 4592 }, { 4237, 4600 }, { 4269, 4677 }, { 4271, 4701 }, { 4272, 4758 }, { 4274, 4760 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiExcludeClipRect"),	{ 4235, { 4235, -1 }, { 4238, 4251 }, { 4238, 4249 }, { 4268, 4249 }, { 4270, 4250 }, { 4271, 4251 }, { 4273, 4251 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiExtCreatePen"),	{ 4236, { 4236, -1 }, { 4239, 4272 }, { 4239, 4267 }, { 4267, 4267 }, { 4269, 4268 }, { 4270, 4269 }, { 4272, 4269 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiExtCreateRegion"),	{ 4237, { 4237, 4235 }, { 4240, 4236 }, { 4240, 4234 }, { 4266, 4234 }, { 4268, 4235 }, { 4269, 4236 }, { 4271, 4236 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiExtEscape"),	{ 4238, { 4238, -1 }, { 4241, 4381 }, { 4241, 4374 }, { 4265, 4374 }, { 4267, 4375 }, { 4268, 4376 }, { 4270, 4376 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiExtFloodFill"),	{ 4239, { 4239, -1 }, { 4242, 4593 }, { 4242, 4601 }, { 4264, 4678 }, { 4266, 4702 }, { 4267, 4759 }, { 4269, 4761 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiExtGetObjectW"),	{ 4240, { 4240, 4177 }, { 4243, 4178 }, { 4243, 4178 }, { 4263, 4179 }, { 4265, 4180 }, { 4266, 4181 }, { 4268, 4181 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiExtSelectClipRgn"),	{ 4241, { 4241, 4141 }, { 4244, 4142 }, { 4244, 4142 }, { 4262, 4143 }, { 4264, 4144 }, { 4265, 4145 }, { 4267, 4145 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiExtTextOutW"),	{ 4242, { 4242, -1 }, { 4245, 4152 }, { 4245, 4152 }, { 4261, 4153 }, { 4263, 4154 }, { 4264, 4155 }, { 4266, 4155 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFillPath"),	{ 4243, { 4243, 4369 }, { 4246, 4370 }, { 4246, 4363 }, { 4260, 4363 }, { 4262, 4364 }, { 4263, 4365 }, { 4265, 4365 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFillRgn"),	{ 4244, { 4244, 4312 }, { 4247, 4313 }, { 4247, 4308 }, { 4259, 4308 }, { 4261, 4309 }, { 4262, 4310 }, { 4264, 4310 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFlattenPath"),	{ 4245, { 4245, -1 }, { 4248, 4602 }, { 4248, 4610 }, { 4258, 4687 }, { 4260, 4711 }, { 4261, 4768 }, { 4263, 4770 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFlush"),	{ 4247, { 4246, 4113 }, { 4249, 4114 }, { 4249, 4114 }, { 4257, 4115 }, { 4259, 4116 }, { 4260, 4117 }, { 4262, 4117 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFlushUserBatch"),	{ 4246, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFontIsLinked"),	{ 4106, { 4106, 4534 }, { 4106, 4603 }, { 4106, 4611 }, { 4402, 4688 }, { 4404, 4712 }, { 4405, 4769 }, { 4407, 4771 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFONTOBJ_cGetAllGlyphHandles"),	{ 4743, { 4739, 4525 }, { 4776, 4594 }, { 4808, 4602 }, { 4847, 4679 }, { 4856, 4703 }, { 4868, 4760 }, { 4869, 4762 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFONTOBJ_cGetGlyphs"),	{ 4738, { 4734, -1 }, { 4771, 4595 }, { 4803, 4603 }, { 4844, 4680 }, { 4853, 4704 }, { 4865, 4761 }, { 4866, 4763 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFONTOBJ_pfdg"),	{ 4740, { 4736, 4528 }, { 4773, 4597 }, { 4805, 4605 }, { 4842, 4682 }, { 4851, 4706 }, { 4863, 4763 }, { 4864, 4765 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFONTOBJ_pifi"),	{ 4739, { 4735, 4529 }, { 4772, 4598 }, { 4804, 4606 }, { 4843, 4683 }, { 4852, 4707 }, { 4864, 4764 }, { 4865, 4766 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFONTOBJ_pQueryGlyphAttrs"),	{ 4741, { 4737, 4527 }, { 4774, 4596 }, { 4806, 4604 }, { 4841, 4681 }, { 4850, 4705 }, { 4862, 4762 }, { 4863, 4764 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFONTOBJ_pvTrueTypeFontFile"),	{ 4742, { 4738, 4530 }, { 4775, 4599 }, { 4807, 4607 }, { 4848, 4684 }, { 4857, 4708 }, { 4869, 4765 }, { 4870, 4767 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFONTOBJ_pxoGetXform"),	{ 4737, { 4733, 4531 }, { 4770, 4600 }, { 4802, 4608 }, { 4845, 4685 }, { 4854, 4709 }, { 4866, 4766 }, { 4867, 4768 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFONTOBJ_vGetInfo"),	{ 4736, { 4732, 4532 }, { 4769, 4601 }, { 4801, 4609 }, { 4846, 4686 }, { 4855, 4710 }, { 4867, 4767 }, { 4868, 4769 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiForceUFIMapping"),	{ 4248, { 4247, 4535 }, { 4250, 4604 }, { 4250, 4612 }, { 4256, 4689 }, { 4258, 4713 }, { 4259, 4770 }, { 4261, 4772 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFrameRgn"),	{ 4249, { 4248, -1 }, { 4251, 4605 }, { 4251, 4613 }, { 4255, 4690 }, { 4257, 4714 }, { 4258, 4771 }, { 4260, 4773 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiFullscreenControl"),	{ 4250, { 4249, -1 }, { 4252, 4606 }, { 4252, 4614 }, { 4254, 4691 }, { 4256, 4715 }, { 4257, 4772 }, { 4259, 4774 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetAndSetDCDword"),	{ 4251, { 4250, 4199 }, { 4253, 4200 }, { 4253, 4200 }, { 4253, 4200 }, { 4255, 4201 }, { 4256, 4202 }, { 4258, 4202 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetAppClipBox"),	{ 4252, { 4251, -1 }, { 4254, 4163 }, { 4254, 4163 }, { 4252, 4164 }, { 4254, 4165 }, { 4255, 4166 }, { 4257, 4166 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetBitmapBits"),	{ 4253, { 4252, 4322 }, { 4255, 4323 }, { 4255, 4318 }, { 4251, 4318 }, { 4253, 4319 }, { 4254, 4320 }, { 4256, 4320 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetBitmapDimension"),	{ 4254, { 4253, -1 }, { 4256, 4354 }, { 4256, 4348 }, { 4250, 4348 }, { 4252, 4349 }, { 4253, 4350 }, { 4255, 4350 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetBoundsRect"),	{ 4255, { 4254, -1 }, { 4257, 4607 }, { 4257, 4615 }, { 4249, 4692 }, { 4251, 4716 }, { 4252, 4773 }, { 4254, 4775 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCertificate"),	{ -1, { -1, -1 }, { 4258, 4609 }, { 4258, 4617 }, { 4248, 4694 }, { 4250, 4718 }, { 4251, 4775 }, { 4251, 4777 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCertificateByHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 4778 }, { 4253, 4778 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCertificateSize"),	{ -1, { -1, -1 }, { 4259, 4610 }, { 4259, 4618 }, { 4247, 4695 }, { 4249, 4719 }, { 4250, 4776 }, { 4250, 4779 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCertificateSizeByHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 4780 }, { 4252, 4780 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCharABCWidthsW"),	{ 4256, { 4255, -1 }, { 4260, 4611 }, { 4260, 4619 }, { 4246, 4696 }, { 4248, 4720 }, { 4249, 4777 }, { 4249, 4781 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCharacterPlacementW"),	{ 4257, { 4256, -1 }, { 4261, 4612 }, { 4261, 4620 }, { 4245, 4697 }, { 4247, 4721 }, { 4248, 4778 }, { 4248, 4782 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCharSet"),	{ 4258, { 4257, 4105 }, { 4262, 4105 }, { 4262, 4105 }, { 4244, 4106 }, { 4246, 4107 }, { 4247, 4108 }, { 4247, 4108 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCharWidthInfo"),	{ 4260, { 4259, -1 }, { 4264, 4305 }, { 4264, 4300 }, { 4242, 4300 }, { 4244, 4301 }, { 4245, 4302 }, { 4245, 4302 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCharWidthW"),	{ 4259, { 4258, -1 }, { 4263, 4300 }, { 4263, 4295 }, { 4243, 4295 }, { 4245, 4296 }, { 4246, 4297 }, { 4246, 4297 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetColorAdjustment"),	{ 4261, { 4260, -1 }, { 4265, 4613 }, { 4265, 4621 }, { 4241, 4698 }, { 4243, 4722 }, { 4244, 4779 }, { 4244, 4783 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetColorSpaceforBitmap"),	{ 4262, { 4261, -1 }, { 4266, 4614 }, { 4266, 4622 }, { 4240, 4699 }, { 4242, 4723 }, { 4243, 4780 }, { 4243, 4784 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCOPPCompatibleOPMInformation"),	{ -1, { -1, -1 }, { 4267, 4608 }, { 4267, 4616 }, { 4239, 4693 }, { 4241, 4717 }, { 4242, 4774 }, { 4242, 4776 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetCurrentDpiInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4240, 4724 }, { 4241, 4781 }, { 4241, 4785 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDCDword"),	{ 4263, { 4262, 4158 }, { 4268, 4159 }, { 4268, 4159 }, { 4238, 4160 }, { 4239, 4161 }, { 4240, 4162 }, { 4240, 4162 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDCforBitmap"),	{ 4264, { 4263, -1 }, { 4269, 4253 }, { 4269, 4251 }, { 4237, 4251 }, { 4238, 4252 }, { 4239, 4253 }, { 4239, 4253 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDCObject"),	{ 4265, { 4264, 4148 }, { 4270, 4149 }, { 4270, 4149 }, { 4236, 4150 }, { 4237, 4151 }, { 4238, 4152 }, { 4238, 4152 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDCPoint"),	{ 4266, { 4265, -1 }, { 4271, 4212 }, { 4271, 4211 }, { 4235, 4211 }, { 4236, 4212 }, { 4237, 4213 }, { 4237, 4213 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDeviceCaps"),	{ 4267, { 4266, 4543 }, { 4272, 4615 }, { 4272, 4623 }, { 4234, 4700 }, { 4235, 4725 }, { 4236, 4782 }, { 4236, 4786 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDeviceCapsAll"),	{ 4269, { 4268, 4544 }, { 4274, 4616 }, { 4274, 4624 }, { 4232, 4701 }, { 4233, 4726 }, { 4234, 4783 }, { 4234, 4787 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDeviceGammaRamp"),	{ 4268, { 4267, 4545 }, { 4273, 4617 }, { 4273, 4625 }, { 4233, 4702 }, { 4234, 4727 }, { 4235, 4784 }, { 4235, 4788 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDeviceWidth"),	{ 4375, { 4374, -1 }, { 4383, 4618 }, { 4385, 4626 }, { 4121, 4703 }, { 4122, 4728 }, { 4123, 4785 }, { 4123, 4789 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDhpdev"),	{ 4754, { 4750, 4547 }, { 4787, 4619 }, { 4819, 4627 }, { 4860, 4704 }, { 4869, 4729 }, { 4881, 4786 }, { 4882, 4790 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetDIBitsInternal"),	{ 4270, { 4269, -1 }, { 4275, 4231 }, { 4275, 4229 }, { 4231, 4229 }, { 4232, 4230 }, { 4233, 4231 }, { 4233, 4231 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetEmbedFonts"),	{ 4308, { 4307, 4550 }, { 4316, 4622 }, { 4318, 4630 }, { 4188, 4707 }, { 4189, 4732 }, { 4190, 4789 }, { 4190, 4793 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetEmbUFI"),	{ 4306, { 4305, -1 }, { 4314, 4621 }, { 4316, 4629 }, { 4190, 4706 }, { 4191, 4731 }, { 4192, 4788 }, { 4192, 4792 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetETM"),	{ 4271, { 4270, 4548 }, { 4276, 4620 }, { 4276, 4628 }, { 4230, 4705 }, { 4231, 4730 }, { 4232, 4787 }, { 4232, 4791 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetEudcTimeStampEx"),	{ 4272, { 4271, -1 }, { 4277, 4623 }, { 4277, 4631 }, { 4229, 4708 }, { 4230, 4733 }, { 4231, 4790 }, { 4231, 4794 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetFontData"),	{ 4273, { 4272, -1 }, { 4278, 4316 }, { 4278, 4311 }, { 4228, 4311 }, { 4229, 4312 }, { 4230, 4313 }, { 4230, 4313 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetFontFileData"),	{ -1, { -1, -1 }, { -1, -1 }, { 4279, 4632 }, { 4227, 4709 }, { 4228, 4734 }, { 4229, 4791 }, { 4229, 4795 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetFontFileInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4280, 4633 }, { 4226, 4710 }, { 4227, 4735 }, { 4228, 4792 }, { 4228, 4796 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetFontResourceInfoInternalW"),	{ 4274, { 4273, -1 }, { 4279, 4624 }, { 4281, 4634 }, { 4225, 4711 }, { 4226, 4736 }, { 4227, 4793 }, { 4227, 4797 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetFontUnicodeRanges"),	{ 4311, { 4310, 4553 }, { 4319, 4625 }, { 4321, 4635 }, { 4185, 4712 }, { 4186, 4737 }, { 4187, 4794 }, { 4187, 4798 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetGlyphIndicesW"),	{ 4275, { 4274, -1 }, { 4280, 4626 }, { 4282, 4636 }, { 4224, 4713 }, { 4225, 4738 }, { 4226, 4795 }, { 4226, 4799 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetGlyphIndicesWInternal"),	{ 4276, { 4275, -1 }, { 4281, 4627 }, { 4283, 4637 }, { 4223, 4714 }, { 4224, 4739 }, { 4225, 4796 }, { 4225, 4800 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetGlyphOutline"),	{ 4277, { 4276, -1 }, { 4282, 4628 }, { 4284, 4638 }, { 4222, 4715 }, { 4223, 4740 }, { 4224, 4797 }, { 4224, 4801 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetKerningPairs"),	{ 4278, { 4277, 4557 }, { 4284, 4629 }, { 4286, 4639 }, { 4220, 4716 }, { 4221, 4741 }, { 4222, 4798 }, { 4222, 4802 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetLinkedUFIs"),	{ 4279, { 4278, 4558 }, { 4285, 4630 }, { 4287, 4640 }, { 4219, 4717 }, { 4220, 4742 }, { 4221, 4799 }, { 4221, 4803 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetMiterLimit"),	{ 4280, { 4279, -1 }, { 4286, 4631 }, { 4288, 4641 }, { 4218, 4718 }, { 4219, 4743 }, { 4220, 4800 }, { 4220, 4804 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetMonitorID"),	{ 4281, { 4280, 4560 }, { 4287, 4632 }, { 4289, 4642 }, { 4217, 4719 }, { 4218, 4744 }, { 4219, 4801 }, { 4219, 4805 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetNearestColor"),	{ 4282, { 4281, 4209 }, { 4288, 4210 }, { 4290, 4209 }, { 4216, 4209 }, { 4217, 4210 }, { 4218, 4211 }, { 4218, 4211 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetNearestPaletteIndex"),	{ 4283, { 4282, 4296 }, { 4289, 4297 }, { 4291, 4292 }, { 4215, 4292 }, { 4216, 4293 }, { 4217, 4294 }, { 4217, 4294 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetNumberOfPhysicalMonitors"),	{ -1, { -1, -1 }, { 4856, 4633 }, { 4900, 4643 }, { 4973, 4720 }, { 4991, 4745 }, { 5048, 4802 }, { 5050, 4806 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetObjectBitmapHandle"),	{ 4284, { 4283, -1 }, { 4290, 4636 }, { 4292, 4646 }, { 4214, 4723 }, { 4215, 4748 }, { 4216, 4805 }, { 4216, 4809 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetOPMInformation"),	{ -1, { -1, -1 }, { 4283, 4634 }, { 4285, 4644 }, { 4221, 4721 }, { 4222, 4746 }, { 4223, 4803 }, { 4223, 4807 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetOPMRandomNumber"),	{ -1, { -1, -1 }, { 4291, 4635 }, { 4293, 4645 }, { 4213, 4722 }, { 4214, 4747 }, { 4215, 4804 }, { 4215, 4808 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetOutlineTextMetricsInternalW"),	{ 4285, { 4284, 4279 }, { 4292, 4280 }, { 4294, 4275 }, { 4212, 4275 }, { 4213, 4276 }, { 4214, 4277 }, { 4214, 4277 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetPath"),	{ 4286, { 4285, 4562 }, { 4293, 4637 }, { 4295, 4647 }, { 4211, 4724 }, { 4212, 4749 }, { 4213, 4806 }, { 4213, 4810 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetPerBandInfo"),	{ 4220, { 4220, -1 }, { 4223, 4638 }, { 4224, 4648 }, { 4282, 4725 }, { 4284, 4750 }, { 4285, 4807 }, { 4287, 4811 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetPhysicalMonitorDescription"),	{ -1, { -1, -1 }, { 4858, 4639 }, { 4902, 4649 }, { 4971, 4726 }, { 4989, 4751 }, { 5046, 4808 }, { 5048, 4812 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetPhysicalMonitors"),	{ -1, { -1, -1 }, { 4857, 4640 }, { 4901, 4650 }, { 4972, 4727 }, { 4990, 4752 }, { 5047, 4809 }, { 5049, 4813 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetPixel"),	{ 4287, { 4286, 4291 }, { 4294, 4292 }, { 4296, 4287 }, { 4210, 4287 }, { 4211, 4288 }, { 4212, 4289 }, { 4212, 4289 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetRandomRgn"),	{ 4288, { 4287, 4138 }, { 4295, 4139 }, { 4297, 4139 }, { 4209, 4140 }, { 4210, 4141 }, { 4211, 4142 }, { 4211, 4142 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetRasterizerCaps"),	{ 4289, { 4288, 4331 }, { 4296, 4332 }, { 4298, 4327 }, { 4208, 4327 }, { 4209, 4328 }, { 4210, 4329 }, { 4210, 4329 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetRealizationInfo"),	{ 4290, { 4289, 4564 }, { 4297, 4641 }, { 4299, 4651 }, { 4207, 4728 }, { 4208, 4753 }, { 4209, 4810 }, { 4209, 4814 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetRegionData"),	{ 4291, { 4290, 4159 }, { 4298, 4160 }, { 4300, 4160 }, { 4206, 4161 }, { 4207, 4162 }, { 4208, 4163 }, { 4208, 4163 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetRgnBox"),	{ 4292, { 4291, -1 }, { 4299, 4199 }, { 4301, 4199 }, { 4205, 4199 }, { 4206, 4200 }, { 4207, 4201 }, { 4207, 4201 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetServerMetaFileBits"),	{ 4293, { 4292, -1 }, { 4300, 4642 }, { 4302, 4652 }, { 4204, 4729 }, { 4205, 4754 }, { 4206, 4811 }, { 4206, 4815 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetSpoolMessage"),	{ 4294, { 4293, 4566 }, { 4301, 4643 }, { 4303, 4653 }, { 4203, 4730 }, { 4204, 4755 }, { 4205, 4812 }, { 4205, 4816 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetStats"),	{ 4295, { 4294, -1 }, { 4302, 4644 }, { 4304, 4654 }, { 4202, 4731 }, { 4203, 4756 }, { 4204, 4813 }, { 4204, 4817 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetStockObject"),	{ 4296, { 4295, 4308 }, { 4303, 4309 }, { 4305, 4304 }, { 4201, 4304 }, { 4202, 4305 }, { 4203, 4306 }, { 4203, 4306 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetStringBitmapW"),	{ 4297, { 4296, -1 }, { 4304, 4645 }, { 4306, 4655 }, { 4200, 4732 }, { 4201, 4757 }, { 4202, 4814 }, { 4202, 4818 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetSuggestedOPMProtectedOutputArraySize"),	{ -1, { -1, -1 }, { 4305, 4646 }, { 4307, 4656 }, { 4199, 4733 }, { 4200, 4758 }, { 4201, 4815 }, { 4201, 4819 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetSystemPaletteUse"),	{ 4298, { 4297, 4376 }, { 4306, 4377 }, { 4308, 4370 }, { 4198, 4370 }, { 4199, 4371 }, { 4200, 4372 }, { 4200, 4372 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetTextCharsetInfo"),	{ 4299, { 4298, -1 }, { 4307, 4173 }, { 4309, 4173 }, { 4197, 4174 }, { 4198, 4175 }, { 4199, 4176 }, { 4199, 4176 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetTextExtent"),	{ 4300, { 4299, -1 }, { 4308, 4246 }, { 4310, 4244 }, { 4196, 4244 }, { 4197, 4245 }, { 4198, 4246 }, { 4198, 4246 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetTextExtentExW"),	{ 4301, { 4300, -1 }, { 4309, 4647 }, { 4311, 4657 }, { 4195, 4734 }, { 4196, 4759 }, { 4197, 4816 }, { 4197, 4820 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetTextFaceW"),	{ 4302, { 4301, 4225 }, { 4310, 4226 }, { 4312, 4224 }, { 4194, 4224 }, { 4195, 4225 }, { 4196, 4226 }, { 4196, 4226 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetTextMetricsW"),	{ 4303, { 4302, 4214 }, { 4311, 4215 }, { 4313, 4213 }, { 4193, 4213 }, { 4194, 4214 }, { 4195, 4215 }, { 4195, 4215 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetTransform"),	{ 4304, { 4303, -1 }, { 4312, 4321 }, { 4314, 4316 }, { 4192, 4316 }, { 4193, 4317 }, { 4194, 4318 }, { 4194, 4318 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetUFI"),	{ 4305, { 4304, -1 }, { 4313, 4648 }, { 4315, 4658 }, { 4191, 4735 }, { 4192, 4760 }, { 4193, 4817 }, { 4193, 4821 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetUFIPathname"),	{ 4307, { 4306, -1 }, { 4315, 4649 }, { 4317, 4659 }, { 4189, 4736 }, { 4190, 4761 }, { 4191, 4818 }, { 4191, 4822 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGetWidthTable"),	{ 4312, { 4311, -1 }, { 4320, 4202 }, { 4322, 4202 }, { 4184, 4202 }, { 4185, 4203 }, { 4186, 4204 }, { 4186, 4204 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiGradientFill"),	{ 4313, { 4312, -1 }, { 4321, 4650 }, { 4323, 4660 }, { 4183, 4737 }, { 4184, 4762 }, { 4185, 4819 }, { 4185, 4823 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiHfontCreate"),	{ 4314, { 4313, -1 }, { 4322, 4189 }, { 4324, 4189 }, { 4182, 4189 }, { 4183, 4190 }, { 4184, 4191 }, { 4184, 4191 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiHLSurfGetInformation"),	{ -1, { -1, -1 }, { -1, -1 }, { 4829, 4661 }, { 4870, 4738 }, { 4879, 4763 }, { 4891, 4820 }, { 4892, 4824 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiHLSurfSetInformation"),	{ -1, { -1, -1 }, { -1, -1 }, { 4830, 4662 }, { 4869, 4739 }, { 4878, 4764 }, { 4890, 4821 }, { 4891, 4825 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiHT_Get8BPPFormatPalette"),	{ 4756, { 4752, 4573 }, { 4789, 4651 }, { 4821, 4663 }, { 4862, 4740 }, { 4871, 4765 }, { 4883, 4822 }, { 4884, 4826 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiHT_Get8BPPMaskPalette"),	{ 4757, { 4753, -1 }, { 4790, 4652 }, { 4822, 4664 }, { 4861, 4741 }, { 4870, 4766 }, { 4882, 4823 }, { 4883, 4827 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiIcmBrushInfo"),	{ 4315, { 4314, -1 }, { 4323, 4653 }, { 4325, 4665 }, { 4181, 4742 }, { 4182, 4767 }, { 4183, 4824 }, { 4183, 4828 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiInit"),	{ 4316, { 4315, 4636 }, { 4324, 4654 }, { 4326, 4666 }, { 4180, 4743 }, { 4181, 4768 }, { 4182, 4825 }, { 4182, 4829 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiInitSpool"),	{ 4317, { 4316, 4577 }, { 4325, 4655 }, { 4327, 4667 }, { 4179, 4744 }, { 4180, 4769 }, { 4181, 4826 }, { 4181, 4830 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiIntersectClipRect"),	{ 4318, { 4317, -1 }, { 4326, 4128 }, { 4328, 4128 }, { 4178, 4129 }, { 4179, 4130 }, { 4180, 4131 }, { 4180, 4131 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiInvertRgn"),	{ 4319, { 4318, 4197 }, { 4327, 4198 }, { 4329, 4198 }, { 4177, 4198 }, { 4178, 4199 }, { 4179, 4200 }, { 4179, 4200 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiLineTo"),	{ 4320, { 4319, 4160 }, { 4328, 4161 }, { 4330, 4161 }, { 4176, 4162 }, { 4177, 4163 }, { 4178, 4164 }, { 4178, 4164 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiMakeFontDir"),	{ 4321, { 4320, -1 }, { 4329, 4656 }, { 4331, 4668 }, { 4175, 4745 }, { 4176, 4770 }, { 4177, 4827 }, { 4177, 4831 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiMakeInfoDC"),	{ 4322, { 4321, -1 }, { 4330, 4657 }, { 4332, 4669 }, { 4174, 4746 }, { 4175, 4771 }, { 4176, 4828 }, { 4176, 4832 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiMakeObjectUnXferable"),	{ -1, { 4760, 4580 }, { 4855, 4658 }, { 4899, 4670 }, { 4968, 4747 }, { 4986, 4772 }, { 5043, 4829 }, { 5045, 4833 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiMakeObjectXferable"),	{ -1, { 4759, 4581 }, { 4854, 4659 }, { 4898, 4671 }, { 4969, 4748 }, { 4987, 4773 }, { 5044, 4830 }, { 5046, 4834 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiMaskBlt"),	{ 4323, { 4322, -1 }, { 4331, 4201 }, { 4333, 4201 }, { 4173, 4201 }, { 4174, 4202 }, { 4175, 4203 }, { 4175, 4203 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiMirrorWindowOrg"),	{ 4376, { 4375, 4582 }, { 4384, 4660 }, { 4386, 4672 }, { 4120, 4749 }, { 4121, 4774 }, { 4122, 4831 }, { 4122, 4835 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiModifyWorldTransform"),	{ 4324, { 4323, 4314 }, { 4332, 4315 }, { 4334, 4310 }, { 4172, 4310 }, { 4173, 4311 }, { 4174, 4312 }, { 4174, 4312 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiMonoBitmap"),	{ 4325, { 4324, -1 }, { 4333, 4661 }, { 4335, 4673 }, { 4171, 4750 }, { 4172, 4775 }, { 4173, 4832 }, { 4173, 4836 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiMoveTo"),	{ 4326, { 4325, -1 }, { 4334, 4662 }, { 4336, 4674 }, { 4170, 4751 }, { 4171, 4776 }, { 4172, 4833 }, { 4172, 4837 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiOffsetClipRgn"),	{ 4327, { 4326, 4585 }, { 4335, 4663 }, { 4337, 4675 }, { 4169, 4752 }, { 4170, 4777 }, { 4171, 4834 }, { 4171, 4838 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiOffsetRgn"),	{ 4328, { 4327, 4223 }, { 4336, 4224 }, { 4338, 4222 }, { 4168, 4222 }, { 4169, 4223 }, { 4170, 4224 }, { 4170, 4224 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiOpenDCW"),	{ 4329, { 4328, -1 }, { 4337, 4319 }, { 4339, 4314 }, { 4167, 4314 }, { 4168, 4315 }, { 4169, 4316 }, { 4169, 4316 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPatBlt"),	{ 4330, { 4329, -1 }, { 4338, 4186 }, { 4340, 4186 }, { 4166, 4186 }, { 4167, 4187 }, { 4168, 4188 }, { 4168, 4188 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPATHOBJ_bEnum"),	{ 4750, { 4746, 4586 }, { 4783, 4664 }, { 4815, 4676 }, { 4857, 4753 }, { 4866, 4778 }, { 4878, 4835 }, { 4879, 4839 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPATHOBJ_bEnumClipLines"),	{ 4753, { 4749, 4587 }, { 4786, 4665 }, { 4818, 4677 }, { 4854, 4754 }, { 4863, 4779 }, { 4875, 4836 }, { 4876, 4840 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPATHOBJ_vEnumStart"),	{ 4751, { 4747, -1 }, { 4784, 4666 }, { 4816, 4678 }, { 4856, 4755 }, { 4865, 4780 }, { 4877, 4837 }, { 4878, 4841 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPATHOBJ_vEnumStartClipLines"),	{ 4752, { 4748, 4589 }, { 4785, 4667 }, { 4817, 4679 }, { 4855, 4756 }, { 4864, 4781 }, { 4876, 4838 }, { 4877, 4842 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPATHOBJ_vGetBounds"),	{ 4749, { 4745, 4590 }, { 4782, 4668 }, { 4814, 4680 }, { 4858, 4757 }, { 4867, 4782 }, { 4879, 4839 }, { 4880, 4843 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPathToRegion"),	{ 4332, { 4331, 4591 }, { 4340, 4669 }, { 4342, 4681 }, { 4164, 4758 }, { 4165, 4783 }, { 4166, 4840 }, { 4166, 4844 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPlgBlt"),	{ 4333, { 4332, -1 }, { 4341, 4670 }, { 4343, 4682 }, { 4163, 4759 }, { 4164, 4784 }, { 4165, 4841 }, { 4165, 4845 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPolyDraw"),	{ 4334, { 4333, 4593 }, { 4342, 4671 }, { 4344, 4683 }, { 4162, 4760 }, { 4163, 4785 }, { 4164, 4842 }, { 4164, 4846 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPolyPatBlt"),	{ 4331, { 4330, -1 }, { 4339, 4208 }, { 4341, 4207 }, { 4165, 4207 }, { 4166, 4208 }, { 4167, 4209 }, { 4167, 4209 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPolyPolyDraw"),	{ 4335, { 4334, -1 }, { 4343, 4168 }, { 4345, 4168 }, { 4161, 4169 }, { 4162, 4170 }, { 4163, 4171 }, { 4163, 4171 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPolyTextOutW"),	{ 4336, { 4335, 4594 }, { 4344, 4672 }, { 4346, 4684 }, { 4160, 4761 }, { 4161, 4786 }, { 4162, 4843 }, { 4162, 4847 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPtInRegion"),	{ 4337, { 4336, 4595 }, { 4345, 4673 }, { 4347, 4685 }, { 4159, 4762 }, { 4160, 4787 }, { 4161, 4844 }, { 4161, 4848 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiPtVisible"),	{ 4338, { 4337, 4596 }, { 4346, 4674 }, { 4348, 4686 }, { 4158, 4763 }, { 4159, 4788 }, { 4160, 4845 }, { 4160, 4849 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiQueryFontAssocInfo"),	{ 4340, { 4339, 4345 }, { 4348, 4346 }, { 4350, 4341 }, { 4156, 4341 }, { 4157, 4342 }, { 4158, 4343 }, { 4158, 4343 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiQueryFonts"),	{ 4339, { 4338, 4597 }, { 4347, 4675 }, { 4349, 4687 }, { 4157, 4764 }, { 4158, 4789 }, { 4159, 4846 }, { 4159, 4850 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiRectangle"),	{ 4341, { 4340, -1 }, { 4349, 4242 }, { 4351, 4240 }, { 4155, 4240 }, { 4156, 4241 }, { 4157, 4242 }, { 4157, 4242 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiRectInRegion"),	{ 4342, { 4341, 4289 }, { 4350, 4290 }, { 4352, 4285 }, { 4154, 4285 }, { 4155, 4286 }, { 4156, 4287 }, { 4156, 4287 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiRectVisible"),	{ 4343, { 4342, 4146 }, { 4351, 4147 }, { 4353, 4147 }, { 4153, 4148 }, { 4154, 4149 }, { 4155, 4150 }, { 4155, 4150 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiRemoveFontMemResourceEx"),	{ 4345, { 4344, 4377 }, { 4353, 4378 }, { 4355, 4371 }, { 4151, 4371 }, { 4152, 4372 }, { 4153, 4373 }, { 4153, 4373 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiRemoveFontResourceW"),	{ 4344, { 4343, -1 }, { 4352, 4676 }, { 4354, 4688 }, { 4152, 4765 }, { 4153, 4790 }, { 4154, 4847 }, { 4154, 4851 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiRemoveMergeFont"),	{ 4101, { 4101, 4599 }, { 4101, 4677 }, { 4101, 4689 }, { 4407, 4766 }, { 4409, 4791 }, { 4410, 4848 }, { 4412, 4852 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiResetDC"),	{ 4346, { 4345, -1 }, { 4354, 4678 }, { 4356, 4690 }, { 4150, 4767 }, { 4151, 4792 }, { 4152, 4849 }, { 4152, 4853 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiResizePalette"),	{ 4347, { 4346, 4601 }, { 4355, 4679 }, { 4357, 4691 }, { 4149, 4768 }, { 4150, 4793 }, { 4151, 4850 }, { 4151, 4854 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiRestoreDC"),	{ 4348, { 4347, 4153 }, { 4356, 4154 }, { 4358, 4154 }, { 4148, 4155 }, { 4149, 4156 }, { 4150, 4157 }, { 4150, 4157 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiRoundRect"),	{ 4349, { 4348, -1 }, { 4357, 4680 }, { 4359, 4692 }, { 4147, 4769 }, { 4148, 4794 }, { 4149, 4851 }, { 4149, 4855 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSaveDC"),	{ 4350, { 4349, 4154 }, { 4358, 4155 }, { 4360, 4155 }, { 4146, 4156 }, { 4147, 4157 }, { 4148, 4158 }, { 4148, 4158 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiScaleViewportExtEx"),	{ 4351, { 4350, -1 }, { 4359, 4686 }, { 4361, 4698 }, { 4145, 4775 }, { 4146, 4800 }, { 4147, 4857 }, { 4147, 4861 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiScaleWindowExtEx"),	{ 4352, { 4351, -1 }, { 4360, 4687 }, { 4362, 4699 }, { 4144, 4776 }, { 4145, 4801 }, { 4146, 4858 }, { 4146, 4862 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSelectBitmap"),	{ 4353, { 4352, 4107 }, { 4361, 4107 }, { 4363, 4107 }, { 4143, 4108 }, { 4144, 4109 }, { 4145, 4110 }, { 4145, 4110 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSelectBrush"),	{ 4354, { 4353, -1 }, { 4362, 4688 }, { 4364, 4700 }, { 4142, 4777 }, { 4143, 4802 }, { 4144, 4859 }, { 4144, 4863 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSelectClipPath"),	{ 4355, { 4354, 4611 }, { 4363, 4689 }, { 4365, 4701 }, { 4141, 4778 }, { 4142, 4803 }, { 4143, 4860 }, { 4143, 4864 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSelectFont"),	{ 4356, { 4355, 4152 }, { 4364, 4153 }, { 4366, 4153 }, { 4140, 4154 }, { 4141, 4155 }, { 4142, 4156 }, { 4142, 4156 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSelectPen"),	{ 4357, { 4356, -1 }, { 4365, 4690 }, { 4367, 4702 }, { 4139, 4779 }, { 4140, 4804 }, { 4141, 4861 }, { 4141, 4865 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetBitmapAttributes"),	{ 4358, { 4357, 4613 }, { 4366, 4691 }, { 4368, 4703 }, { 4138, 4780 }, { 4139, 4805 }, { 4140, 4862 }, { 4140, 4866 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetBitmapBits"),	{ 4359, { 4358, 4280 }, { 4367, 4281 }, { 4369, 4276 }, { 4137, 4276 }, { 4138, 4277 }, { 4139, 4278 }, { 4139, 4278 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetBitmapDimension"),	{ 4360, { 4359, -1 }, { 4368, 4382 }, { 4370, 4375 }, { 4136, 4375 }, { 4137, 4376 }, { 4138, 4377 }, { 4138, 4377 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetBoundsRect"),	{ 4361, { 4360, 4351 }, { 4369, 4352 }, { 4371, 4347 }, { 4135, 4347 }, { 4136, 4348 }, { 4137, 4349 }, { 4137, 4349 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetBrushAttributes"),	{ 4362, { 4114, 4614 }, { 4370, 4692 }, { 4372, 4704 }, { 4134, 4781 }, { 4135, 4806 }, { 4136, 4863 }, { 4136, 4867 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetBrushOrg"),	{ 4363, { 4362, -1 }, { 4371, 4274 }, { 4373, 4269 }, { 4133, 4269 }, { 4134, 4270 }, { 4135, 4271 }, { 4135, 4271 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetColorAdjustment"),	{ 4364, { 4363, 4615 }, { 4372, 4693 }, { 4374, 4705 }, { 4132, 4782 }, { 4133, 4807 }, { 4134, 4864 }, { 4134, 4868 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetColorSpace"),	{ 4365, { 4364, 4616 }, { 4373, 4694 }, { 4375, 4706 }, { 4131, 4783 }, { 4132, 4808 }, { 4133, 4865 }, { 4133, 4869 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetDeviceGammaRamp"),	{ 4366, { 4365, 4617 }, { 4374, 4695 }, { 4376, 4707 }, { 4130, 4784 }, { 4131, 4809 }, { 4132, 4866 }, { 4132, 4870 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetDIBitsToDeviceInternal"),	{ 4367, { 4366, -1 }, { 4375, 4137 }, { 4377, 4137 }, { 4129, 4138 }, { 4130, 4139 }, { 4131, 4140 }, { 4131, 4140 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetFontEnumeration"),	{ 4368, { 4367, 4382 }, { 4376, 4383 }, { 4378, 4376 }, { 4128, 4376 }, { 4129, 4377 }, { 4130, 4378 }, { 4130, 4378 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetFontXform"),	{ 4369, { 4368, 4618 }, { 4377, 4696 }, { 4379, 4708 }, { 4127, 4785 }, { 4128, 4810 }, { 4129, 4867 }, { 4129, 4871 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetIcmMode"),	{ 4370, { 4369, 4619 }, { 4378, 4697 }, { 4380, 4709 }, { 4126, 4786 }, { 4127, 4811 }, { 4128, 4868 }, { 4128, 4872 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetLayout"),	{ 4377, { 4376, 4247 }, { 4385, 4248 }, { 4387, 4246 }, { 4119, 4246 }, { 4120, 4247 }, { 4121, 4248 }, { 4121, 4248 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetLinkedUFIs"),	{ 4371, { 4370, 4620 }, { 4379, 4698 }, { 4381, 4710 }, { 4125, 4787 }, { 4126, 4812 }, { 4127, 4869 }, { 4127, 4873 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetMagicColors"),	{ 4372, { 4371, 4621 }, { 4380, 4699 }, { 4382, 4711 }, { 4124, 4788 }, { 4125, 4813 }, { 4126, 4870 }, { 4126, 4874 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetMetaRgn"),	{ 4373, { 4372, -1 }, { 4381, 4329 }, { 4383, 4324 }, { 4123, 4324 }, { 4124, 4325 }, { 4125, 4326 }, { 4125, 4326 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetMiterLimit"),	{ 4374, { 4373, 4329 }, { 4382, 4330 }, { 4384, 4325 }, { 4122, 4325 }, { 4123, 4326 }, { 4124, 4327 }, { 4124, 4327 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetOPMSigningKeyAndSequenceNumbers"),	{ -1, { -1, -1 }, { 4386, 4700 }, { 4388, 4712 }, { 4118, 4789 }, { 4119, 4814 }, { 4120, 4871 }, { 4120, 4875 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetPixel"),	{ 4378, { 4377, 4275 }, { 4387, 4276 }, { 4389, 4271 }, { 4117, 4271 }, { 4118, 4272 }, { 4119, 4273 }, { 4119, 4273 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetPixelFormat"),	{ 4379, { 4378, 4623 }, { 4388, 4702 }, { 4390, 4714 }, { 4116, 4791 }, { 4117, 4816 }, { 4118, 4873 }, { 4118, 4877 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetPUMPDOBJ"),	{ 4759, { 4755, 4622 }, { 4792, 4701 }, { 4824, 4713 }, { 4866, 4790 }, { 4875, 4815 }, { 4887, 4872 }, { 4888, 4876 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetRectRgn"),	{ 4380, { 4379, -1 }, { 4389, 4703 }, { 4391, 4715 }, { 4115, 4792 }, { 4116, 4817 }, { 4117, 4874 }, { 4117, 4878 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetSizeDevice"),	{ 4385, { 4384, 4625 }, { 4394, 4704 }, { 4395, 4716 }, { 4111, 4793 }, { 4112, 4818 }, { 4113, 4875 }, { 4113, 4879 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetSystemPaletteUse"),	{ 4381, { 4380, 4626 }, { 4390, 4705 }, { 4392, 4717 }, { 4114, 4794 }, { 4115, 4819 }, { 4116, 4876 }, { 4116, 4880 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetTextJustification"),	{ 4382, { 4381, 4627 }, { 4391, 4706 }, { 4393, 4718 }, { 4113, 4795 }, { 4114, 4820 }, { 4115, 4877 }, { 4115, 4881 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetUMPDSandboxState"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4867, 4796 }, { 4876, 4821 }, { 4888, 4878 }, { 4889, 4882 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetupPublicCFONT"),	{ 4383, { 4382, 4363 }, { 4392, 4364 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSetVirtualResolution"),	{ 4384, { 4383, -1 }, { 4393, 4331 }, { 4394, 4326 }, { 4112, 4326 }, { 4113, 4327 }, { 4114, 4328 }, { 4114, 4328 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSfmGetNotificationTokens"),	{ -1, { -1, -1 }, { -1, -1 }, { 4828, 4719 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiStartDoc"),	{ 4386, { 4385, 4628 }, { 4395, 4707 }, { 4396, 4720 }, { 4110, 4797 }, { 4111, 4822 }, { 4112, 4879 }, { 4112, 4883 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiStartPage"),	{ 4387, { 4386, 4629 }, { 4396, 4708 }, { 4397, 4721 }, { 4109, 4798 }, { 4110, 4823 }, { 4111, 4880 }, { 4111, 4884 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiStretchBlt"),	{ 4388, { 4387, -1 }, { 4397, 4145 }, { 4398, 4145 }, { 4108, 4146 }, { 4109, 4147 }, { 4110, 4148 }, { 4110, 4148 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiStretchDIBitsInternal"),	{ 4389, { 4388, -1 }, { 4398, 4227 }, { 4399, 4225 }, { 4107, 4225 }, { 4108, 4226 }, { 4109, 4227 }, { 4109, 4227 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSTROBJ_bEnum"),	{ 4744, { 4740, 4603 }, { 4777, 4681 }, { 4809, 4693 }, { 4853, 4770 }, { 4862, 4795 }, { 4874, 4852 }, { 4875, 4856 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSTROBJ_bEnumPositionsOnly"),	{ 4745, { 4741, 4604 }, { 4778, 4682 }, { 4810, 4694 }, { 4852, 4771 }, { 4861, 4796 }, { 4873, 4853 }, { 4874, 4857 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSTROBJ_bGetAdvanceWidths"),	{ 4746, { 4742, 4605 }, { 4779, 4683 }, { 4811, 4695 }, { 4851, 4772 }, { 4860, 4797 }, { 4872, 4854 }, { 4873, 4858 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSTROBJ_dwGetCodePage"),	{ 4748, { 4744, -1 }, { 4781, 4684 }, { 4813, 4696 }, { 4849, 4773 }, { 4858, 4798 }, { 4870, 4855 }, { 4871, 4859 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSTROBJ_vEnumStart"),	{ 4747, { 4743, -1 }, { 4780, 4685 }, { 4812, 4697 }, { 4850, 4774 }, { 4859, 4799 }, { 4871, 4856 }, { 4872, 4860 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiStrokeAndFillPath"),	{ 4390, { 4389, 4630 }, { 4399, 4709 }, { 4400, 4722 }, { 4106, 4799 }, { 4107, 4824 }, { 4108, 4881 }, { 4108, 4885 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiStrokePath"),	{ 4391, { 4390, 4631 }, { 4400, 4710 }, { 4401, 4723 }, { 4105, 4800 }, { 4106, 4825 }, { 4107, 4882 }, { 4107, 4886 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiSwapBuffers"),	{ 4392, { 4391, 4632 }, { 4401, 4711 }, { 4402, 4724 }, { 4104, 4801 }, { 4105, 4826 }, { 4106, 4883 }, { 4106, 4887 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiTransformPoints"),	{ 4393, { 4392, -1 }, { 4402, 4211 }, { 4403, 4210 }, { 4103, 4210 }, { 4104, 4211 }, { 4105, 4212 }, { 4105, 4212 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiTransparentBlt"),	{ 4394, { 4393, -1 }, { 4403, 4712 }, { 4404, 4725 }, { 4102, 4802 }, { 4103, 4827 }, { 4104, 4884 }, { 4104, 4888 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiUMPDEngFreeUserMem"),	{ 4396, { 4395, 4634 }, { 4405, 4713 }, { 4406, 4726 }, { 4864, 4803 }, { 4873, 4828 }, { 4885, 4885 }, { 4886, 4889 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiUnloadPrinterDriver"),	{ 4395, { 4394, 4635 }, { 4404, 4714 }, { 4115, 4727 }, { 4101, 4804 }, { 4102, 4829 }, { 4103, 4886 }, { 4103, 4890 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiUnmapMemFont"),	{ 4761, { 4757, 4576 }, { 4794, 4715 }, { 4826, 4728 }, { 4100, 4805 }, { 4101, 4830 }, { 4102, 4887 }, { 4102, 4891 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiUnrealizeObject"),	{ 4397, { 4396, 4239 }, { 4406, 4240 }, { 4407, 4238 }, { 4099, 4238 }, { 4100, 4239 }, { 4101, 4240 }, { 4101, 4240 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiUpdateColors"),	{ 4398, { 4397, 4637 }, { 4407, 4716 }, { 4408, 4729 }, { 4098, 4806 }, { 4099, 4831 }, { 4100, 4888 }, { 4100, 4892 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiUpdateTransform"),	{ 4758, { 4754, 4638 }, { 4791, 4717 }, { 4823, 4730 }, { 4863, 4807 }, { 4872, 4832 }, { 4884, 4889 }, { 4885, 4893 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiWidenPath"),	{ 4399, { 4398, 4639 }, { 4408, 4718 }, { 4409, 4731 }, { 4097, 4808 }, { 4098, 4833 }, { 4099, 4890 }, { 4099, 4894 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiXFORMOBJ_bApplyXform"),	{ 4734, { 4730, -1 }, { 4767, 4719 }, { 4799, 4732 }, { 4840, 4809 }, { 4849, 4834 }, { 4861, 4891 }, { 4862, 4895 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiXFORMOBJ_iGetXform"),	{ 4735, { 4731, 4641 }, { 4768, 4720 }, { 4800, 4733 }, { 4839, 4810 }, { 4848, 4835 }, { 4860, 4892 }, { 4861, 4896 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiXLATEOBJ_cGetPalette"),	{ 4721, { 4717, 4642 }, { 4754, 4721 }, { 4786, 4734 }, { 4828, 4811 }, { 4837, 4836 }, { 4849, 4893 }, { 4850, 4897 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiXLATEOBJ_hGetColorTransform"),	{ 4723, { 4719, 4643 }, { 4756, 4722 }, { 4788, 4735 }, { 4826, 4812 }, { 4835, 4837 }, { 4847, 4894 }, { 4848, 4898 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtGdiXLATEOBJ_iXlate"),	{ 4722, { 4718, 4644 }, { 4755, 4723 }, { 4787, 4736 }, { 4827, 4813 }, { 4836, 4838 }, { 4848, 4895 }, { 4849, 4899 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtHWCursorUpdatePointer"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5223, 4896 }, { 5228, 4900 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtNotifyPresentToCompositionSurface"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4997, 4814 }, { 5015, 4839 }, { 5072, 4897 }, { 5074, 4901 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtOpenCompositionSurfaceDirtyRegion"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5002, 4815 }, { 5020, 4840 }, { 5077, 4898 }, { 5079, 4902 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtOpenCompositionSurfaceSectionInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4999, 4816 }, { 5017, 4841 }, { 5074, 4899 }, { 5076, 4903 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtOpenCompositionSurfaceSwapChainHandleInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5000, 4817 }, { 5018, 4842 }, { 5075, 4900 }, { 5077, 4904 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtQueryCompositionInputIsImplicit"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5095, 4901 }, { 5097, 4905 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtQueryCompositionInputQueueAndTransform"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5094, 4902 }, { 5096, 4906 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtQueryCompositionInputSink"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5027, 4843 }, { 5089, 4903 }, { 5091, 4907 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtQueryCompositionInputSinkLuid"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5028, 4844 }, { 5090, 4904 }, { 5092, 4908 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtQueryCompositionInputSinkViewId"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5091, 4905 }, { 5093, 4909 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtQueryCompositionSurfaceBinding"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4996, 4818 }, { 5014, 4845 }, { 5071, 4906 }, { 5073, 4910 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtQueryCompositionSurfaceRenderingRealization"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5001, 4819 }, { 5019, 4846 }, { 5076, 4907 }, { 5078, 4911 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtQueryCompositionSurfaceStatistics"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4998, 4820 }, { 5016, 4847 }, { 5073, 4908 }, { 5075, 4912 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtRIMAddInputObserver"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5215, 4909 }, { 5220, 4913 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtRIMGetDevicePreparsedDataLockfree"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5219, 4910 }, { 5224, 4914 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtRIMObserveNextInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5218, 4911 }, { 5223, 4915 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtRIMRemoveInputObserver"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5216, 4912 }, { 5221, 4916 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtRIMUpdateInputObserverRegistration"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5217, 4913 }, { 5222, 4917 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtSetCompositionSurfaceAnalogExclusive"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5104, 4914 }, { 5107, 4918 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtSetCompositionSurfaceBufferCompositionMode"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5023, 4848 }, { 5080, 4915 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtSetCompositionSurfaceBufferCompositionModeAndOrientation"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 4919 }, { 5082, 4919 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtSetCompositionSurfaceIndependentFlipInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5024, 4849 }, { 5081, 4916 }, { 5083, 4920 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtSetCompositionSurfaceOutOfFrameDirectFlipNotification"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5003, 4821 }, { 5021, 4850 }, { 5078, 4917 }, { 5080, 4921 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtSetCompositionSurfaceStatistics"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5004, 4822 }, { 5022, 4851 }, { 5079, 4918 }, { 5081, 4922 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerConfirmOutstandingAnalogToken"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5103, 4919 }, { 5106, 4923 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerCreateCompositionTokenHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5036, 4852 }, { 5100, 4920 }, { 5103, 4924 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerDeleteOutstandingDirectFlipTokens"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5035, 4853 }, { 5099, 4921 }, { 5102, 4925 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerGetAnalogExclusiveSurfaceUpdates"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5102, 4922 }, { 5105, 4926 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerGetAnalogExclusiveTokenEvent"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5101, 4923 }, { 5104, 4927 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerGetOutOfFrameDirectFlipSurfaceUpdates"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5007, 4823 }, { 5034, 4854 }, { 5098, 4924 }, { 5101, 4928 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerOpenEvent"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5005, 4824 }, { 5032, 4855 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerOpenSection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5031, 4856 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerOpenSectionAndEvents"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5096, 4925 }, { 5099, 4929 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtTokenManagerThread"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5006, 4825 }, { 5033, 4857 }, { 5097, 4926 }, { 5100, 4930 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUnBindCompositionSurface"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4995, 4826 }, { 5013, 4858 }, { 5070, 4927 }, { 5072, 4931 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUpdateInputSinkTransforms"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5029, 4859 }, { 5092, 4928 }, { 5094, 4932 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserAcquireIAMKey"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5063, 4827 }, { 5102, 4860 }, { 5177, 4929 }, { 5180, 4933 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserActivateKeyboardLayout"),	{ 4400, { 4399, 4390 }, { 4409, 4391 }, { 4410, 4382 }, { 4465, 4382 }, { 4467, 4383 }, { 4468, 4384 }, { 4470, 4384 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserAddClipboardFormatListener"),	{ -1, { -1, -1 }, { 4410, 4724 }, { 4411, 4737 }, { 4464, 4828 }, { 4466, 4861 }, { 4467, 4930 }, { 4469, 4934 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserAlterWindowStyle"),	{ 4401, { 4400, 4311 }, { 4411, 4312 }, { 4412, 4307 }, { 4463, 4307 }, { 4465, 4308 }, { 4466, 4309 }, { 4468, 4309 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserAssociateInputContext"),	{ 4402, { 4401, 4645 }, { 4412, 4725 }, { 4413, 4738 }, { 4462, 4829 }, { 4464, 4862 }, { 4465, 4931 }, { 4467, 4935 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserAttachThreadInput"),	{ 4403, { 4402, 4336 }, { 4413, 4337 }, { 4414, 4332 }, { 4461, 4332 }, { 4463, 4333 }, { 4464, 4334 }, { 4466, 4334 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserAutoPromoteMouseInPointer"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5073, 4830 }, { 5114, 4863 }, { 5191, 4932 }, { 5195, 4936 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserAutoRotateScreen"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5061, 4831 }, { 5101, 4864 }, { 5176, 4933 }, { 5179, 4937 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserBeginPaint"),	{ 4404, { 4403, 4118 }, { 4414, 4119 }, { 4415, 4119 }, { 4460, 4120 }, { 4462, 4121 }, { 4463, 4122 }, { 4465, 4122 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserBitBltSysBmp"),	{ 4405, { 4404, 4303 }, { 4415, 4304 }, { 4416, 4299 }, { 4459, 4299 }, { 4461, 4300 }, { 4462, 4301 }, { 4464, 4301 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserBlockInput"),	{ 4406, { 4405, 4646 }, { 4416, 4726 }, { 4417, 4739 }, { 4458, 4832 }, { 4460, 4865 }, { 4461, 4934 }, { 4463, 4938 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserBuildHimcList"),	{ 4407, { 4406, 4647 }, { 4417, 4727 }, { 4418, 4740 }, { 4457, 4833 }, { 4459, 4866 }, { 4460, 4935 }, { 4462, 4939 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserBuildHwndList"),	{ 4408, { 4407, 4123 }, { 4418, 4124 }, { 4419, 4124 }, { 4456, 4125 }, { 4458, 4126 }, { 4459, 4127 }, { 4461, 4127 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserBuildNameList"),	{ 4409, { 4408, 4274 }, { 4419, 4275 }, { 4420, 4270 }, { 4455, 4270 }, { 4457, 4271 }, { 4458, 4272 }, { 4460, 4272 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserBuildPropList"),	{ 4410, { 4409, 4648 }, { 4420, 4728 }, { 4421, 4741 }, { 4454, 4834 }, { 4456, 4867 }, { 4457, 4936 }, { 4459, 4940 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCalcMenuBar"),	{ 4662, { 4658, 4248 }, { 4686, 4249 }, { 4699, 4247 }, { 4633, 4247 }, { 4636, 4248 }, { 4639, 4249 }, { 4641, 4249 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCalculatePopupWindowPosition"),	{ -1, { -1, -1 }, { -1, -1 }, { 4698, 4742 }, { 4634, 4835 }, { 4637, 4868 }, { 4640, 4937 }, { 4642, 4941 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallHwnd"),	{ 4411, { 4410, 4370 }, { 4421, 4371 }, { 4422, 4364 }, { 4453, 4364 }, { 4455, 4365 }, { 4456, 4366 }, { 4458, 4366 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallHwndLock"),	{ 4412, { 4411, 4128 }, { 4422, 4129 }, { 4423, 4129 }, { 4452, 4130 }, { 4454, 4131 }, { 4455, 4132 }, { 4457, 4132 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallHwndOpt"),	{ 4413, { 4412, 4649 }, { 4423, 4729 }, { 4424, 4743 }, { 4451, 4836 }, { 4453, 4869 }, { 4454, 4938 }, { 4456, 4942 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallHwndParam"),	{ 4414, { 4413, 4255 }, { 4424, 4256 }, { 4425, 4254 }, { 4450, 4254 }, { 4452, 4255 }, { 4453, 4256 }, { 4455, 4256 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallHwndParamLock"),	{ 4415, { 4414, 4134 }, { 4425, 4135 }, { 4426, 4135 }, { 4449, 4136 }, { 4451, 4137 }, { 4452, 4138 }, { 4454, 4138 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallMsgFilter"),	{ 4416, { 4415, 4116 }, { 4426, 4117 }, { 4427, 4117 }, { 4448, 4118 }, { 4450, 4119 }, { 4451, 4120 }, { 4453, 4120 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallNextHookEx"),	{ 4417, { 4416, 4125 }, { 4427, 4126 }, { 4428, 4126 }, { 4447, 4127 }, { 4449, 4128 }, { 4450, 4129 }, { 4452, 4129 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallNoParam"),	{ 4418, { 4417, 4101 }, { 4428, 4101 }, { 4429, 4101 }, { 4446, 4102 }, { 4448, 4103 }, { 4449, 4104 }, { 4451, 4104 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallOneParam"),	{ 4419, { 4418, 4098 }, { 4429, 4098 }, { 4430, 4098 }, { 4445, 4099 }, { 4447, 4100 }, { 4448, 4101 }, { 4450, 4101 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCallTwoParam"),	{ 4420, { 4419, 4137 }, { 4430, 4138 }, { 4431, 4138 }, { 4444, 4139 }, { 4446, 4140 }, { 4447, 4141 }, { 4449, 4141 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCanBrokerForceForeground"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4416, 4837 }, { 4418, 4870 }, { 4419, 4939 }, { 4421, 4943 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserChangeClipboardChain"),	{ 4421, { 4420, 4383 }, { 4431, 4384 }, { 4432, 4377 }, { 4443, 4377 }, { 4445, 4378 }, { 4446, 4379 }, { 4448, 4379 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserChangeDisplaySettings"),	{ 4422, { 4421, 4650 }, { 4432, 4730 }, { 4433, 4744 }, { 4442, 4838 }, { 4444, 4871 }, { 4445, 4940 }, { 4447, 4944 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserChangeWindowMessageFilterEx"),	{ -1, { -1, -1 }, { -1, -1 }, { 4753, 4745 }, { 4825, 4839 }, { 4834, 4872 }, { 4846, 4941 }, { 4847, 4945 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCheckAccessForIntegrityLevel"),	{ -1, { -1, -1 }, { 4433, 4731 }, { 4439, 4746 }, { 4436, 4840 }, { 4438, 4873 }, { 4439, 4942 }, { 4441, 4946 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCheckDesktopByThreadId"),	{ -1, { -1, -1 }, { 4434, 4732 }, { 4440, 4747 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCheckImeHotKey"),	{ 4423, { 4422, 4212 }, { 4436, 4213 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCheckMenuItem"),	{ 4424, { 4423, 4360 }, { 4437, 4361 }, { 4442, 4355 }, { 4433, 4355 }, { 4435, 4356 }, { 4436, 4357 }, { 4438, 4357 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCheckProcessForClipboardAccess"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5077, 4841 }, { 5118, 4874 }, { 5195, 4943 }, { 5199, 4947 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCheckProcessSession"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4736, 4842 }, { 4739, 4875 }, { 4749, 4944 }, { 4750, 4948 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCheckWindowThreadDesktop"),	{ -1, { -1, -1 }, { 4435, 4733 }, { 4441, 4748 }, { 4434, 4843 }, { 4436, 4876 }, { 4437, 4945 }, { 4439, 4949 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserChildWindowFromPointEx"),	{ 4425, { 4424, 4651 }, { 4438, 4734 }, { 4443, 4749 }, { 4432, 4844 }, { 4434, 4877 }, { 4435, 4946 }, { 4437, 4950 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserClearForeground"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5107, 4878 }, { 5182, 4947 }, { 5185, 4951 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserClipCursor"),	{ 4426, { 4425, 4652 }, { 4439, 4735 }, { 4444, 4750 }, { 4431, 4845 }, { 4433, 4879 }, { 4434, 4948 }, { 4436, 4952 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCloseClipboard"),	{ 4427, { 4426, 4306 }, { 4440, 4307 }, { 4445, 4302 }, { 4430, 4302 }, { 4432, 4303 }, { 4433, 4304 }, { 4435, 4304 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCloseDesktop"),	{ 4428, { 4427, 4266 }, { 4441, 4267 }, { 4446, 4262 }, { 4429, 4262 }, { 4431, 4263 }, { 4432, 4264 }, { 4434, 4264 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCloseWindowStation"),	{ 4429, { 4428, 4281 }, { 4442, 4282 }, { 4447, 4277 }, { 4428, 4277 }, { 4430, 4278 }, { 4431, 4279 }, { 4433, 4279 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCompositionInputSinkLuidFromPoint"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5121, 4880 }, { 5198, 4949 }, { 5202, 4953 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserConsoleControl"),	{ 4430, { 4429, 4323 }, { 4443, 4324 }, { 4448, 4319 }, { 4427, 4319 }, { 4429, 4320 }, { 4430, 4321 }, { 4432, 4321 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserConvertMemHandle"),	{ 4431, { 4430, 4354 }, { 4444, 4355 }, { 4449, 4349 }, { 4426, 4349 }, { 4428, 4350 }, { 4429, 4351 }, { 4431, 4351 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCopyAcceleratorTable"),	{ 4432, { 4431, 4139 }, { 4445, 4140 }, { 4450, 4140 }, { 4425, 4141 }, { 4427, 4142 }, { 4428, 4143 }, { 4430, 4143 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCountClipboardFormats"),	{ 4433, { 4432, 4373 }, { 4446, 4374 }, { 4451, 4367 }, { 4424, 4367 }, { 4426, 4368 }, { 4427, 4369 }, { 4429, 4369 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateAcceleratorTable"),	{ 4434, { 4433, 4341 }, { 4447, 4342 }, { 4452, 4337 }, { 4423, 4337 }, { 4425, 4338 }, { 4426, 4339 }, { 4428, 4339 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateCaret"),	{ 4435, { 4434, 4145 }, { 4448, 4146 }, { 4453, 4146 }, { 4422, 4147 }, { 4424, 4148 }, { 4425, 4149 }, { 4427, 4149 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateDCompositionHwndTarget"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5052, 4846 }, { 5092, 4881 }, { 5167, 4950 }, { 5170, 4954 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateDesktop"),	{ 4436, { 4435, 4653 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateDesktopEx"),	{ -1, { -1, -1 }, { 4449, 4736 }, { 4454, 4751 }, { 4421, 4847 }, { 4423, 4882 }, { 4424, 4951 }, { 4426, 4955 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateInputContext"),	{ 4437, { 4436, -1 }, { 4450, 4737 }, { 4455, 4752 }, { 4420, 4848 }, { 4422, 4883 }, { 4423, 4952 }, { 4425, 4956 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateLocalMemHandle"),	{ 4438, { 4437, 4335 }, { 4451, 4336 }, { 4456, 4331 }, { 4419, 4331 }, { 4421, 4332 }, { 4422, 4333 }, { 4424, 4333 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateWindowEx"),	{ 4439, { 4438, 4215 }, { 4452, 4216 }, { 4457, 4214 }, { 4418, 4214 }, { 4420, 4215 }, { 4421, 4216 }, { 4423, 4216 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCreateWindowStation"),	{ 4440, { 4439, 4655 }, { 4453, 4738 }, { 4458, 4753 }, { 4417, 4849 }, { 4419, 4884 }, { 4420, 4953 }, { 4422, 4957 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserCtxDisplayIOCtl"),	{ 4694, { 4690, 4656 }, { 4719, 4739 }, { 4731, 4754 }, { 4739, 4850 }, { 4742, 4885 }, { 4752, 4954 }, { 4753, 4958 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDdeGetQualityOfService"),	{ 4441, { 4440, 4657 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDdeInitialize"),	{ 4442, { 4441, 4371 }, { 4454, 4372 }, { 4459, 4365 }, { 4415, 4365 }, { 4417, 4366 }, { 4418, 4367 }, { 4420, 4367 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDdeSetQualityOfService"),	{ 4443, { 4442, 4658 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDeferWindowPos"),	{ 4444, { 4443, 4178 }, { 4455, 4179 }, { 4460, 4179 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDeferWindowPosAndBand"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4414, 4851 }, { 4416, 4886 }, { 4417, 4955 }, { 4419, 4959 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDefSetText"),	{ 4445, { 4444, 4224 }, { 4456, 4225 }, { 4461, 4223 }, { 4413, 4223 }, { 4415, 4224 }, { 4416, 4225 }, { 4418, 4225 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDelegateCapturePointers"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4466, 4852 }, { 4468, 4887 }, { 4469, 4956 }, { 4471, 4960 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDelegateInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4467, 4853 }, { 4469, 4888 }, { 4470, 4957 }, { 4472, 4961 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDeleteMenu"),	{ 4446, { 4445, 4288 }, { 4457, 4289 }, { 4462, 4284 }, { 4476, 4284 }, { 4478, 4285 }, { 4479, 4286 }, { 4481, 4286 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDestroyAcceleratorTable"),	{ 4447, { 4446, 4355 }, { 4458, 4356 }, { 4463, 4350 }, { 4475, 4350 }, { 4477, 4351 }, { 4478, 4352 }, { 4480, 4352 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDestroyCursor"),	{ 4448, { 4447, 4253 }, { 4459, 4254 }, { 4464, 4252 }, { 4474, 4252 }, { 4476, 4253 }, { 4477, 4254 }, { 4479, 4254 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDestroyDCompositionHwndTarget"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5051, 4854 }, { 5091, 4889 }, { 5166, 4958 }, { 5169, 4962 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDestroyInputContext"),	{ 4449, { 4448, -1 }, { 4460, 4740 }, { 4465, 4755 }, { 4473, 4855 }, { 4475, 4890 }, { 4476, 4959 }, { 4478, 4963 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDestroyMenu"),	{ 4450, { 4449, 4321 }, { 4461, 4322 }, { 4466, 4317 }, { 4472, 4317 }, { 4474, 4318 }, { 4475, 4319 }, { 4477, 4319 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDestroyWindow"),	{ 4451, { 4450, 4254 }, { 4462, 4255 }, { 4467, 4253 }, { 4471, 4253 }, { 4473, 4254 }, { 4474, 4255 }, { 4476, 4255 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDisableImmersiveOwner"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5066, 4856 }, { 5106, 4891 }, { 5181, 4960 }, { 5184, 4964 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDisableProcessWindowFiltering"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4469, 4857 }, { 4471, 4892 }, { 4472, 4961 }, { 4474, 4965 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDisableThreadIme"),	{ 4452, { 4451, 4660 }, { 4463, 4741 }, { 4468, 4756 }, { 4470, 4858 }, { 4472, 4893 }, { 4473, 4962 }, { 4475, 4966 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDiscardPointerFrameMessages"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4815, 4859 }, { 4823, 4894 }, { 4834, 4963 }, { 4835, 4967 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDispatchMessage"),	{ 4453, { 4452, 4149 }, { 4464, 4150 }, { 4469, 4150 }, { 4468, 4151 }, { 4470, 4152 }, { 4471, 4153 }, { 4473, 4153 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDisplayConfigGetDeviceInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4437, 4757 }, { 4438, 4860 }, { 4440, 4895 }, { 4441, 4964 }, { 4443, 4968 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDisplayConfigSetDeviceInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4438, 4758 }, { 4437, 4861 }, { 4439, 4896 }, { 4440, 4965 }, { 4442, 4969 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDoSoundConnect"),	{ -1, { -1, -1 }, { 4465, 4742 }, { 4470, 4759 }, { 4478, 4862 }, { 4480, 4897 }, { 4481, 4966 }, { 4483, 4970 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDoSoundDisconnect"),	{ -1, { -1, -1 }, { 4466, 4743 }, { 4471, 4760 }, { 4477, 4863 }, { 4479, 4898 }, { 4480, 4967 }, { 4482, 4971 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDragDetect"),	{ 4454, { 4453, 4661 }, { 4467, 4744 }, { 4472, 4761 }, { 4575, 4864 }, { 4576, 4899 }, { 4578, 4968 }, { 4580, 4972 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDragObject"),	{ 4455, { 4454, 4662 }, { 4468, 4745 }, { 4473, 4762 }, { 4574, 4865 }, { 4575, 4900 }, { 4577, 4969 }, { 4579, 4973 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDrawAnimatedRects"),	{ 4456, { 4455, 4663 }, { 4469, 4746 }, { 4474, 4763 }, { 4573, 4866 }, { 4574, 4901 }, { 4576, 4970 }, { 4578, 4974 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDrawCaption"),	{ 4457, { 4456, 4664 }, { 4470, 4747 }, { 4475, 4764 }, { 4572, 4867 }, { 4573, 4902 }, { 4575, 4971 }, { 4577, 4975 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDrawCaptionTemp"),	{ 4458, { 4457, 4665 }, { 4471, 4748 }, { 4476, 4765 }, { 4571, 4868 }, { 4572, 4903 }, { 4574, 4972 }, { 4576, 4976 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDrawIconEx"),	{ 4459, { 4458, 4191 }, { 4472, 4192 }, { 4477, 4192 }, { 4570, 4192 }, { 4571, 4193 }, { 4573, 4194 }, { 4575, 4194 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDrawMenuBarTemp"),	{ 4460, { 4459, 4666 }, { 4473, 4749 }, { 4478, 4766 }, { 4569, 4869 }, { 4570, 4904 }, { 4572, 4973 }, { 4574, 4977 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmGetDxRgn"),	{ -1, { -1, -1 }, { 4726, 4750 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmGetRemoteSessionOcclusionEvent"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4733, 4870 }, { 4736, 4905 }, { 4744, 4974 }, { 4745, 4978 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmGetRemoteSessionOcclusionState"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4734, 4871 }, { 4737, 4906 }, { 4745, 4975 }, { 4746, 4979 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmHintDxUpdate"),	{ -1, { -1, -1 }, { 4725, 4751 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmKernelShutdown"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4746, 4976 }, { 4747, 4980 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmKernelStartup"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4747, 4977 }, { 4748, 4981 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmStartRedirection"),	{ -1, { -1, -1 }, { 4723, 4752 }, { 4735, 4767 }, { 4732, 4872 }, { 4735, 4907 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmStopRedirection"),	{ -1, { -1, -1 }, { 4724, 4753 }, { 4736, 4768 }, { 4731, 4873 }, { 4734, 4908 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserDwmValidateWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4435, 4874 }, { 4437, 4909 }, { 4438, 4978 }, { 4440, 4982 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEmptyClipboard"),	{ 4461, { 4460, 4348 }, { 4474, 4349 }, { 4479, 4344 }, { 4568, 4344 }, { 4569, 4345 }, { 4571, 4346 }, { 4573, 4346 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnableChildWindowDpiMessage"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4677, 4979 }, { 4679, 4983 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnableIAMAccess"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5067, 4875 }, { 5108, 4910 }, { 5183, 4980 }, { 5186, 4984 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnableMenuItem"),	{ 4462, { 4461, 4310 }, { 4475, 4311 }, { 4480, 4306 }, { 4567, 4306 }, { 4568, 4307 }, { 4570, 4308 }, { 4572, 4308 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnableMouseInPointer"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5070, 4876 }, { 5111, 4911 }, { 5188, 4981 }, { 5192, 4985 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnableMouseInputForCursorSuppression"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5074, 4877 }, { 5115, 4912 }, { 5192, 4982 }, { 5196, 4986 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnableScrollBar"),	{ 4463, { 4462, 4283 }, { 4476, 4284 }, { 4481, 4279 }, { 4566, 4279 }, { 4567, 4280 }, { 4569, 4281 }, { 4571, 4281 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnableTouchPad"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4819, 4913 }, { 4830, 4983 }, { 4831, 4987 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEndDeferWindowPosEx"),	{ 4464, { 4463, 4133 }, { 4477, 4134 }, { 4482, 4134 }, { 4565, 4135 }, { 4566, 4136 }, { 4568, 4137 }, { 4570, 4137 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEndMenu"),	{ 4465, { 4464, 4667 }, { 4478, 4754 }, { 4483, 4769 }, { 4564, 4878 }, { 4565, 4914 }, { 4567, 4984 }, { 4569, 4988 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEndPaint"),	{ 4466, { 4465, 4120 }, { 4479, 4121 }, { 4484, 4121 }, { 4563, 4122 }, { 4564, 4123 }, { 4566, 4124 }, { 4568, 4124 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEndTouchOperation"),	{ -1, { -1, -1 }, { -1, -1 }, { 4751, 4770 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnumDisplayDevices"),	{ 4467, { 4466, 4347 }, { 4480, 4348 }, { 4485, 4343 }, { 4562, 4343 }, { 4563, 4344 }, { 4565, 4345 }, { 4567, 4345 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnumDisplayMonitors"),	{ 4468, { 4467, 4169 }, { 4481, 4170 }, { 4486, 4170 }, { 4561, 4171 }, { 4562, 4172 }, { 4564, 4173 }, { 4566, 4173 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEnumDisplaySettings"),	{ 4469, { 4468, 4378 }, { 4482, 4379 }, { 4487, 4372 }, { 4560, 4372 }, { 4561, 4373 }, { 4563, 4374 }, { 4565, 4374 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserEvent"),	{ 4470, { 4469, 4668 }, { 4483, 4755 }, { 4488, 4771 }, { 4559, 4879 }, { 4560, 4915 }, { 4562, 4985 }, { 4564, 4989 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserExcludeUpdateRgn"),	{ 4471, { 4470, 4175 }, { 4484, 4176 }, { 4489, 4176 }, { 4558, 4177 }, { 4559, 4178 }, { 4561, 4179 }, { 4563, 4179 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserFillWindow"),	{ 4472, { 4471, 4234 }, { 4485, 4235 }, { 4490, 4233 }, { 4557, 4233 }, { 4558, 4234 }, { 4560, 4235 }, { 4562, 4235 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserFindExistingCursorIcon"),	{ 4473, { 4472, 4157 }, { 4486, 4158 }, { 4491, 4158 }, { 4556, 4159 }, { 4557, 4160 }, { 4559, 4161 }, { 4561, 4161 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserFindWindowEx"),	{ 4474, { 4473, 4206 }, { 4487, 4207 }, { 4492, 4206 }, { 4555, 4206 }, { 4556, 4207 }, { 4558, 4208 }, { 4560, 4208 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserFlashWindowEx"),	{ 4475, { 4474, 4669 }, { 4488, 4756 }, { 4493, 4772 }, { 4554, 4880 }, { 4555, 4916 }, { 4557, 4986 }, { 4559, 4990 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserFrostCrashedWindow"),	{ -1, { -1, -1 }, { 4489, 4757 }, { 4494, 4773 }, { 4553, 4881 }, { 4554, 4917 }, { 4556, 4987 }, { 4558, 4991 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetAltTabInfo"),	{ 4476, { 4475, 4343 }, { 4490, 4344 }, { 4495, 4339 }, { 4552, 4339 }, { 4553, 4340 }, { 4555, 4341 }, { 4557, 4341 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetAncestor"),	{ 4477, { 4476, 4278 }, { 4491, 4279 }, { 4496, 4274 }, { 4551, 4274 }, { 4552, 4275 }, { 4554, 4276 }, { 4556, 4276 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetAppImeLevel"),	{ 4478, { 4477, -1 }, { 4492, 4758 }, { 4497, 4774 }, { 4550, 4882 }, { 4551, 4918 }, { 4553, 4988 }, { 4555, 4992 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetAsyncKeyState"),	{ 4479, { 4478, 4163 }, { 4493, 4164 }, { 4498, 4164 }, { 4549, 4165 }, { 4550, 4166 }, { 4552, 4167 }, { 4554, 4167 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetAtomName"),	{ 4480, { 4479, 4269 }, { 4494, 4270 }, { 4499, 4265 }, { 4548, 4265 }, { 4549, 4266 }, { 4551, 4267 }, { 4553, 4267 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetAutoRotationState"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5060, 4883 }, { 5100, 4919 }, { 5175, 4989 }, { 5178, 4993 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetCaretBlinkTime"),	{ 4481, { 4480, 4344 }, { 4495, 4345 }, { 4500, 4340 }, { 4547, 4340 }, { 4548, 4341 }, { 4550, 4342 }, { 4552, 4342 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetCaretPos"),	{ 4482, { 4481, 4671 }, { 4496, 4759 }, { 4501, 4775 }, { 4546, 4885 }, { 4547, 4921 }, { 4549, 4991 }, { 4551, 4995 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetCIMSSM"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4533, 4884 }, { 4534, 4920 }, { 4536, 4990 }, { 4538, 4994 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClassInfo"),	{ 4483, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClassInfoEx"),	{ -1, { 4482, 4285 }, { 4497, 4286 }, { 4502, 4281 }, { 4545, 4281 }, { 4546, 4282 }, { 4548, 4283 }, { 4550, 4283 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClassName"),	{ 4484, { 4483, 4220 }, { 4498, 4221 }, { 4503, 4219 }, { 4544, 4219 }, { 4545, 4220 }, { 4547, 4221 }, { 4549, 4221 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClipboardAccessToken"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5078, 4887 }, { 5119, 4923 }, { 5196, 4993 }, { 5200, 4997 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClipboardData"),	{ 4485, { 4484, 4349 }, { 4499, 4350 }, { 4504, 4345 }, { 4543, 4345 }, { 4544, 4346 }, { 4546, 4347 }, { 4548, 4347 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClipboardFormatName"),	{ 4486, { 4485, 4333 }, { 4500, 4334 }, { 4505, 4329 }, { 4542, 4329 }, { 4543, 4330 }, { 4545, 4331 }, { 4547, 4331 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClipboardOwner"),	{ 4487, { 4486, 4301 }, { 4501, 4302 }, { 4506, 4297 }, { 4541, 4297 }, { 4542, 4298 }, { 4544, 4299 }, { 4546, 4299 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClipboardSequenceNumber"),	{ 4488, { 4487, 4181 }, { 4502, 4182 }, { 4507, 4182 }, { 4540, 4182 }, { 4541, 4183 }, { 4543, 4184 }, { 4545, 4184 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClipboardViewer"),	{ 4489, { 4488, 4673 }, { 4503, 4761 }, { 4508, 4777 }, { 4539, 4888 }, { 4540, 4924 }, { 4542, 4994 }, { 4544, 4998 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetClipCursor"),	{ 4490, { 4489, 4672 }, { 4504, 4760 }, { 4509, 4776 }, { 4538, 4886 }, { 4539, 4922 }, { 4541, 4992 }, { 4543, 4996 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetComboBoxInfo"),	{ 4491, { 4490, 4674 }, { 4505, 4762 }, { 4510, 4778 }, { 4537, 4889 }, { 4538, 4925 }, { 4540, 4995 }, { 4542, 4999 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetControlBrush"),	{ 4492, { 4491, 4219 }, { 4506, 4220 }, { 4511, 4218 }, { 4536, 4218 }, { 4537, 4219 }, { 4539, 4220 }, { 4541, 4220 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetControlColor"),	{ 4493, { 4492, 4327 }, { 4507, 4328 }, { 4512, 4323 }, { 4535, 4323 }, { 4536, 4324 }, { 4538, 4325 }, { 4540, 4325 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetCPD"),	{ 4494, { 4493, 4164 }, { 4508, 4165 }, { 4513, 4165 }, { 4534, 4166 }, { 4535, 4167 }, { 4537, 4168 }, { 4539, 4168 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetCurrentInputMessageSource"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4532, 4890 }, { 4533, 4926 }, { 4535, 4996 }, { 4537, 5000 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetCursorDims"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5130, 4927 }, { 5207, 4997 }, { 5211, 5001 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetCursorFrameInfo"),	{ 4495, { 4494, 4342 }, { 4509, 4343 }, { 4514, 4338 }, { 4531, 4338 }, { 4532, 4339 }, { 4534, 4340 }, { 4536, 4340 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetCursorInfo"),	{ 4496, { 4495, 4675 }, { 4510, 4763 }, { 4515, 4779 }, { 4530, 4891 }, { 4531, 4928 }, { 4533, 4998 }, { 4535, 5002 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDC"),	{ 4497, { 4496, 4106 }, { 4511, 4106 }, { 4516, 4106 }, { 4529, 4107 }, { 4530, 4108 }, { 4532, 4109 }, { 4534, 4109 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDCEx"),	{ 4498, { 4497, 4243 }, { 4512, 4244 }, { 4517, 4242 }, { 4528, 4242 }, { 4529, 4243 }, { 4531, 4244 }, { 4533, 4244 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDesktopID"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4527, 4892 }, { 4528, 4929 }, { 4530, 5000 }, { 4532, 5004 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDisplayAutoRotationPreferences"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5057, 4893 }, { 5097, 4930 }, { 5172, 5001 }, { 5175, 5005 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDisplayAutoRotationPreferencesByProcessId"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5056, 4894 }, { 5096, 4931 }, { 5171, 5002 }, { 5174, 5006 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDisplayConfigBufferSizes"),	{ -1, { -1, -1 }, { -1, -1 }, { 4434, 4780 }, { 4441, 4895 }, { 4443, 4932 }, { 4444, 5003 }, { 4446, 5007 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDManipHookInitFunction"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4734, 4999 }, { 4735, 5003 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDoubleClickTime"),	{ 4499, { 4498, 4282 }, { 4513, 4283 }, { 4518, 4278 }, { 4526, 4278 }, { 4527, 4279 }, { 4529, 4280 }, { 4531, 4280 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDpiForMonitor"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5127, 4933 }, { 5204, 5004 }, { 5208, 5008 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetDpiSystemMetrics"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4528, 5005 }, { 4530, 5009 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetForegroundWindow"),	{ 4500, { 4499, 4155 }, { 4514, 4156 }, { 4519, 4156 }, { 4525, 4157 }, { 4526, 4158 }, { 4527, 4159 }, { 4529, 4159 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetGestureConfig"),	{ -1, { -1, -1 }, { -1, -1 }, { 4759, 4781 }, { 4820, 4896 }, { 4829, 4934 }, { 4841, 5006 }, { 4842, 5010 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetGestureExtArgs"),	{ -1, { -1, -1 }, { -1, -1 }, { 4756, 4782 }, { 4822, 4897 }, { 4831, 4935 }, { 4843, 5007 }, { 4844, 5011 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetGestureInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4755, 4783 }, { 4823, 4898 }, { 4832, 4936 }, { 4844, 5008 }, { 4845, 5012 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetGlobalIMEStatus"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4524, 4899 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetGuiResources"),	{ 4501, { 4500, 4676 }, { 4515, 4764 }, { 4520, 4784 }, { 4523, 4900 }, { 4525, 4937 }, { 4526, 5009 }, { 4528, 5013 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetGUIThreadInfo"),	{ 4502, { 4501, 4356 }, { 4516, 4357 }, { 4521, 4351 }, { 4522, 4351 }, { 4524, 4352 }, { 4525, 4353 }, { 4527, 4353 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetHimetricScaleFactorFromPixelLocation"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5125, 4938 }, { 5202, 5010 }, { 5206, 5014 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetIconInfo"),	{ 4503, { 4502, 4174 }, { 4517, 4175 }, { 4522, 4175 }, { 4521, 4176 }, { 4523, 4177 }, { 4524, 4178 }, { 4526, 4178 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetIconSize"),	{ 4504, { 4503, 4233 }, { 4518, 4234 }, { 4523, 4232 }, { 4520, 4232 }, { 4522, 4233 }, { 4523, 4234 }, { 4525, 4234 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetImeHotKey"),	{ 4505, { 4504, 4677 }, { 4519, 4765 }, { 4524, 4785 }, { 4519, 4901 }, { 4521, 4939 }, { 4522, 5011 }, { 4524, 5015 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetImeInfoEx"),	{ 4506, { 4505, 4678 }, { 4520, 4766 }, { 4525, 4786 }, { 4518, 4902 }, { 4520, 4940 }, { 4521, 5012 }, { 4523, 5016 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetInputLocaleInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4526, 4787 }, { 4517, 4903 }, { 4519, 4941 }, { 4520, 5013 }, { 4522, 5017 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetInternalWindowPos"),	{ 4507, { 4506, 4679 }, { 4521, 4767 }, { 4527, 4788 }, { 4516, 4904 }, { 4518, 4942 }, { 4519, 5014 }, { 4521, 5018 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetKeyboardLayoutList"),	{ 4508, { 4507, 4184 }, { 4522, 4185 }, { 4528, 4185 }, { 4515, 4185 }, { 4517, 4186 }, { 4518, 4187 }, { 4520, 4187 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetKeyboardLayoutName"),	{ 4509, { 4508, 4681 }, { 4523, 4769 }, { 4529, 4790 }, { 4514, 4906 }, { 4516, 4944 }, { 4517, 5016 }, { 4519, 5020 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetKeyboardState"),	{ 4510, { 4509, 4217 }, { 4524, 4218 }, { 4530, 4216 }, { 4513, 4216 }, { 4515, 4217 }, { 4516, 4218 }, { 4518, 4218 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetKeyNameText"),	{ 4511, { 4510, 4680 }, { 4525, 4768 }, { 4531, 4789 }, { 4512, 4905 }, { 4514, 4943 }, { 4515, 5015 }, { 4517, 5019 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetKeyState"),	{ 4512, { 4511, 4099 }, { 4526, 4099 }, { 4532, 4099 }, { 4511, 4100 }, { 4513, 4101 }, { 4514, 4102 }, { 4516, 4102 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetLayeredWindowAttributes"),	{ 4676, { 4672, 4682 }, { 4700, 4770 }, { 4713, 4791 }, { 4757, 4907 }, { 4760, 4945 }, { 4770, 5017 }, { 4771, 5021 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetListBoxInfo"),	{ 4513, { 4512, 4683 }, { 4527, 4771 }, { 4533, 4792 }, { 4510, 4908 }, { 4512, 4946 }, { 4513, 5018 }, { 4515, 5022 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetMenuBarInfo"),	{ 4514, { 4513, 4293 }, { 4528, 4294 }, { 4534, 4289 }, { 4509, 4289 }, { 4511, 4290 }, { 4512, 4291 }, { 4514, 4291 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetMenuIndex"),	{ 4515, { 4514, 4684 }, { 4529, 4772 }, { 4535, 4793 }, { 4508, 4909 }, { 4510, 4947 }, { 4511, 5019 }, { 4513, 5023 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetMenuItemRect"),	{ 4516, { 4515, 4685 }, { 4530, 4773 }, { 4536, 4794 }, { 4507, 4910 }, { 4509, 4948 }, { 4510, 5020 }, { 4512, 5024 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetMessage"),	{ 4517, { 4516, 4102 }, { 4531, 4102 }, { 4537, 4102 }, { 4506, 4103 }, { 4508, 4104 }, { 4509, 4105 }, { 4511, 4105 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetMouseMovePointsEx"),	{ 4518, { 4517, 4686 }, { 4532, 4774 }, { 4538, 4795 }, { 4505, 4911 }, { 4507, 4949 }, { 4508, 5021 }, { 4510, 5025 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetObjectInformation"),	{ 4519, { 4518, 4203 }, { 4533, 4204 }, { 4539, 4204 }, { 4504, 4204 }, { 4506, 4205 }, { 4507, 4206 }, { 4509, 4206 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetOpenClipboardWindow"),	{ 4520, { 4519, 4316 }, { 4534, 4317 }, { 4540, 4312 }, { 4503, 4312 }, { 4505, 4313 }, { 4506, 4314 }, { 4508, 4314 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetOwnerTransformedMonitorRect"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5131, 4950 }, { 4096, 4096 }, { 4096, 4096 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPhysicalDeviceRect"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4810, 4951 }, { 4821, 5022 }, { 4822, 5026 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerCursorId"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4818, 4912 }, { 4827, 4952 }, { 4839, 5023 }, { 4840, 5027 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerDevice"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4812, 4913 }, { 4817, 4953 }, { 4828, 5024 }, { 4829, 5028 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerDeviceCursors"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4808, 4914 }, { 4813, 4954 }, { 4824, 5025 }, { 4825, 5029 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerDeviceProperties"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4811, 4915 }, { 4816, 4955 }, { 4827, 5026 }, { 4828, 5030 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerDeviceRects"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4809, 4916 }, { 4814, 4956 }, { 4825, 5027 }, { 4826, 5031 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerDevices"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4813, 4917 }, { 4818, 4957 }, { 4829, 5028 }, { 4830, 5032 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerFrameArrivalTimes"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4836, 5029 }, { 4837, 5033 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerInfoList"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4817, 4918 }, { 4826, 4958 }, { 4838, 5030 }, { 4839, 5034 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerInputTransform"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4825, 4959 }, { 4837, 5031 }, { 4838, 5035 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPointerType"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4819, 4919 }, { 4828, 4960 }, { 4840, 5032 }, { 4841, 5036 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPrecisionTouchPadConfiguration"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4820, 4961 }, { 4831, 5033 }, { 4832, 5037 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetPriorityClipboardFormat"),	{ 4521, { 4520, 4687 }, { 4535, 4775 }, { 4541, 4796 }, { 4502, 4920 }, { 4504, 4962 }, { 4505, 5034 }, { 4507, 5038 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetProcessDpiAwareness"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5126, 4963 }, { 5203, 5035 }, { 5207, 5039 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetProcessUIContextInformation"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5068, 4921 }, { 5109, 4964 }, { 5184, 5036 }, { 5187, 5040 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetProcessWindowStation"),	{ 4522, { 4521, 4129 }, { 4536, 4130 }, { 4542, 4130 }, { 4501, 4131 }, { 4503, 4132 }, { 4504, 4133 }, { 4506, 4133 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetProp"),	{ -1, { -1, -1 }, { 4648, 4110 }, { 4658, 4110 }, { 4684, 4111 }, { 4687, 4112 }, { 4693, 4113 }, { 4694, 4113 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetQueueEventStatus"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5079, 4922 }, { 5120, 4965 }, { 5197, 5037 }, { 5201, 5041 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetRawInputBuffer"),	{ 4523, { 4522, 4688 }, { 4537, 4776 }, { 4543, 4797 }, { 4500, 4923 }, { 4502, 4966 }, { 4503, 5038 }, { 4505, 5042 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetRawInputData"),	{ 4524, { 4523, 4689 }, { 4538, 4777 }, { 4544, 4798 }, { 4499, 4924 }, { 4501, 4967 }, { 4502, 5039 }, { 4504, 5043 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetRawInputDeviceInfo"),	{ 4525, { 4524, 4690 }, { 4539, 4778 }, { 4545, 4799 }, { 4498, 4925 }, { 4500, 4968 }, { 4501, 5040 }, { 4503, 5044 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetRawInputDeviceList"),	{ 4526, { 4525, 4691 }, { 4540, 4779 }, { 4546, 4800 }, { 4497, 4926 }, { 4499, 4969 }, { 4500, 5041 }, { 4502, 5045 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetRawPointerDeviceData"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4807, 4927 }, { 4812, 4970 }, { 4823, 5042 }, { 4824, 5046 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetRegisteredRawInputDevices"),	{ 4527, { 4526, 4692 }, { 4541, 4780 }, { 4547, 4801 }, { 4496, 4928 }, { 4498, 4971 }, { 4499, 5043 }, { 4501, 5047 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetScrollBarInfo"),	{ 4528, { 4527, 4244 }, { 4542, 4245 }, { 4548, 4243 }, { 4495, 4243 }, { 4497, 4244 }, { 4498, 4245 }, { 4500, 4245 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetSystemMenu"),	{ 4529, { 4528, 4192 }, { 4543, 4193 }, { 4549, 4193 }, { 4494, 4193 }, { 4496, 4194 }, { 4497, 4195 }, { 4499, 4195 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetThreadDesktop"),	{ 4530, { 4529, 4228 }, { 4544, 4229 }, { 4550, 4227 }, { 4493, 4227 }, { 4495, 4228 }, { 4496, 4229 }, { 4498, 4229 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetThreadState"),	{ 4531, { 4530, 4096 }, { 4545, 4096 }, { 4551, 4096 }, { 4492, 4097 }, { 4494, 4098 }, { 4495, 4099 }, { 4497, 4099 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetTitleBarInfo"),	{ 4532, { 4531, 4240 }, { 4546, 4241 }, { 4552, 4239 }, { 4491, 4239 }, { 4493, 4240 }, { 4494, 4241 }, { 4496, 4241 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetTopLevelWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { 4553, 4802 }, { 4490, 4929 }, { 4492, 4972 }, { 4493, 5044 }, { 4495, 5048 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetTouchInputInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4752, 4803 }, { 4768, 4930 }, { 4771, 4973 }, { 4781, 5045 }, { 4782, 5049 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetTouchValidationStatus"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4801, 4931 }, { 4804, 4974 }, { 4815, 5046 }, { 4816, 5050 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetUpdatedClipboardFormats"),	{ -1, { -1, -1 }, { 4547, 4781 }, { 4554, 4804 }, { 4489, 4932 }, { 4491, 4975 }, { 4492, 5047 }, { 4494, 5051 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetUpdateRect"),	{ 4533, { 4532, 4179 }, { 4548, 4180 }, { 4555, 4180 }, { 4488, 4180 }, { 4490, 4181 }, { 4491, 4182 }, { 4493, 4182 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetUpdateRgn"),	{ 4534, { 4533, 4231 }, { 4549, 4232 }, { 4556, 4230 }, { 4487, 4230 }, { 4489, 4231 }, { 4490, 4232 }, { 4492, 4232 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowBand"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4486, 4934 }, { 4488, 4977 }, { 4489, 5049 }, { 4491, 5053 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowCompositionAttribute"),	{ -1, { -1, -1 }, { -1, -1 }, { 4558, 4806 }, { 4484, 4935 }, { 4486, 4978 }, { 4487, 5050 }, { 4489, 5054 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowCompositionInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4557, 4807 }, { 4485, 4936 }, { 4487, 4979 }, { 4488, 5051 }, { 4490, 5055 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowDC"),	{ 4535, { 4534, 4195 }, { 4550, 4196 }, { 4559, 4196 }, { 4483, 4196 }, { 4485, 4197 }, { 4486, 4198 }, { 4488, 4198 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowDisplayAffinity"),	{ -1, { -1, -1 }, { -1, -1 }, { 4560, 4808 }, { 4482, 4937 }, { 4484, 4980 }, { 4485, 5052 }, { 4487, 5056 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowFeedbackSetting"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4799, 4938 }, { 4802, 4981 }, { 4813, 5053 }, { 4814, 5057 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowMinimizeRect"),	{ -1, { -1, -1 }, { 4727, 4783 }, { 4737, 4809 }, { 4730, 4939 }, { 4733, 4982 }, { 4743, 5054 }, { 4744, 5058 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowPlacement"),	{ 4536, { 4535, 4313 }, { 4551, 4314 }, { 4561, 4309 }, { 4481, 4309 }, { 4483, 4310 }, { 4484, 4311 }, { 4486, 4311 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWindowRgnEx"),	{ -1, { -1, -1 }, { 4666, 4784 }, { 4678, 4810 }, { 4658, 4940 }, { 4661, 4983 }, { 4664, 5055 }, { 4666, 5059 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGetWOWClass"),	{ 4537, { 4536, 4693 }, { 4552, 4782 }, { 4562, 4805 }, { 4480, 4933 }, { 4482, 4976 }, { 4483, 5048 }, { 4485, 5052 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserGhostWindowFromHungWindow"),	{ -1, { -1, -1 }, { 4553, 4785 }, { 4563, 4811 }, { 4479, 4941 }, { 4481, 4984 }, { 4482, 5056 }, { 4484, 5060 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserHandleDelegatedInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4576, 4942 }, { 4577, 4985 }, { 4579, 5057 }, { 4581, 5061 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserHardErrorControl"),	{ 4538, { 4537, 4694 }, { 4554, 4786 }, { 4564, 4812 }, { 4627, 4943 }, { 4630, 4986 }, { 4632, 5058 }, { 4634, 5062 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserHideCaret"),	{ 4539, { 4538, 4126 }, { 4555, 4127 }, { 4565, 4127 }, { 4626, 4128 }, { 4629, 4129 }, { 4631, 4130 }, { 4633, 4130 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserHidePointerContactVisualization"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4800, 4944 }, { 4803, 4987 }, { 4814, 5059 }, { 4815, 5063 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserHiliteMenuItem"),	{ 4540, { 4539, 4695 }, { 4556, 4787 }, { 4566, 4813 }, { 4625, 4945 }, { 4628, 4988 }, { 4630, 5060 }, { 4632, 5064 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserHungWindowFromGhostWindow"),	{ -1, { -1, -1 }, { 4557, 4788 }, { 4567, 4814 }, { 4624, 4946 }, { 4627, 4989 }, { 4629, 5061 }, { 4631, 5065 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserHwndQueryRedirectionInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4919, 4815 }, { 4991, 4947 }, { 5009, 4990 }, { 5066, 5062 }, { 5068, 5066 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserHwndSetRedirectionInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { 4920, 4816 }, { 4990, 4948 }, { 5008, 4991 }, { 5065, 5063 }, { 5067, 5067 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserImpersonateDdeClientWindow"),	{ 4541, { 4540, 4696 }, { 4558, 4789 }, { 4568, 4817 }, { 4623, 4949 }, { 4626, 4992 }, { 4628, 5064 }, { 4630, 5068 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInitialize"),	{ 4542, { 4541, 4698 }, { 4559, 4791 }, { 4569, 4819 }, { 4622, 4951 }, { 4625, 4994 }, { 4627, 5066 }, { 4629, 5070 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInitializeClientPfnArrays"),	{ 4543, { 4542, 4699 }, { 4560, 4792 }, { 4570, 4820 }, { 4621, 4952 }, { 4624, 4995 }, { 4626, 5067 }, { 4628, 5071 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInitializeInputDeviceInjection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5208, 5068 }, { 5212, 5072 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInitializePointerDeviceInjection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5209, 5069 }, { 5213, 5073 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInitializeTouchInjection"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4802, 4953 }, { 4805, 4996 }, { 4816, 5070 }, { 4817, 5074 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInitTask"),	{ 4544, { 4543, 4697 }, { 4561, 4790 }, { 4571, 4818 }, { 4620, 4950 }, { 4623, 4993 }, { 4625, 5065 }, { 4627, 5069 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInjectDeviceInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5211, 5071 }, { 5216, 5075 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInjectGesture"),	{ -1, { -1, -1 }, { -1, -1 }, { 4754, 4821 }, { 4824, 4954 }, { 4833, 4997 }, { 4845, 5072 }, { 4846, 5076 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInjectKeyboardInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5213, 5073 }, { 5218, 5077 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInjectMouseInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5212, 5074 }, { 5217, 5078 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInjectPointerInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5214, 5075 }, { 5219, 5079 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInjectTouchInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4803, 4955 }, { 4806, 4998 }, { 4817, 5076 }, { 4818, 5080 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInternalClipCursor"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5076, 4956 }, { 5117, 4999 }, { 5194, 5077 }, { 5198, 5081 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInternalGetWindowIcon"),	{ -1, { -1, -1 }, { 4563, 4793 }, { 4573, 4822 }, { 4618, 4957 }, { 4621, 5000 }, { 4623, 5078 }, { 4625, 5082 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInternalGetWindowText"),	{ 4545, { 4544, 4194 }, { 4562, 4195 }, { 4572, 4195 }, { 4619, 4195 }, { 4622, 4196 }, { 4624, 4197 }, { 4626, 4197 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInvalidateRect"),	{ 4546, { 4545, 4100 }, { 4564, 4100 }, { 4574, 4100 }, { 4617, 4101 }, { 4620, 4102 }, { 4622, 4103 }, { 4624, 4103 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserInvalidateRgn"),	{ 4547, { 4546, 4300 }, { 4565, 4301 }, { 4575, 4296 }, { 4616, 4296 }, { 4619, 4297 }, { 4621, 4298 }, { 4623, 4298 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserIsChildWindowDpiMessageEnabled"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4678, 5079 }, { 4680, 5083 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserIsClipboardFormatAvailable"),	{ 4548, { 4547, 4142 }, { 4566, 4143 }, { 4576, 4143 }, { 4615, 4144 }, { 4618, 4145 }, { 4620, 4146 }, { 4622, 4146 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserIsMouseInPointerEnabled"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5071, 4958 }, { 5112, 5001 }, { 5189, 5080 }, { 5193, 5084 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserIsMouseInputEnabled"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5075, 4959 }, { 5116, 5002 }, { 5193, 5081 }, { 5197, 5085 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserIsTopLevelWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { 4577, 4823 }, { 4614, 4960 }, { 4617, 5003 }, { 4619, 5082 }, { 4621, 5086 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserIsTouchWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { 4749, 4824 }, { 4769, 4961 }, { 4772, 5004 }, { 4782, 5083 }, { 4783, 5087 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserIsWindowBroadcastingDpiToChildren"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4679, 5084 }, { 4681, 5088 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserKillTimer"),	{ 4549, { 4548, 4122 }, { 4567, 4123 }, { 4578, 4123 }, { 4613, 4124 }, { 4616, 4125 }, { 4618, 4126 }, { 4620, 4126 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserLayoutCompleted"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4607, 4962 }, { 4609, 5005 }, { 4611, 5085 }, { 4613, 5089 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserLinkDpiCursor"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5129, 5006 }, { 5206, 5086 }, { 5210, 5090 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserLoadKeyboardLayoutEx"),	{ 4550, { 4549, 4700 }, { 4568, 4794 }, { 4579, 4825 }, { 4612, 4963 }, { 4615, 5007 }, { 4617, 5087 }, { 4619, 5091 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserLockWindowStation"),	{ 4551, { 4550, 4701 }, { 4569, 4795 }, { 4580, 4826 }, { 4611, 4964 }, { 4614, 5008 }, { 4616, 5088 }, { 4618, 5092 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserLockWindowUpdate"),	{ 4552, { 4551, 4364 }, { 4570, 4365 }, { 4581, 4358 }, { 4610, 4358 }, { 4613, 4359 }, { 4615, 4360 }, { 4617, 4360 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserLockWorkStation"),	{ 4553, { 4552, 4702 }, { 4571, 4796 }, { 4582, 4827 }, { 4609, 4965 }, { 4612, 5009 }, { 4614, 5089 }, { 4616, 5093 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserLogicalToPerMonitorDPIPhysicalPoint"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4610, 5010 }, { 4612, 5090 }, { 4614, 5094 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserLogicalToPhysicalPoint"),	{ -1, { -1, -1 }, { 4572, 4797 }, { 4583, 4828 }, { 4608, 4966 }, { 4611, 5011 }, { 4613, 5091 }, { 4615, 5095 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMagControl"),	{ -1, { -1, -1 }, { -1, -1 }, { 4916, 4831 }, { 4988, 4969 }, { 5006, 5014 }, { 5063, 5094 }, { 5065, 5098 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMagGetContextInformation"),	{ -1, { -1, -1 }, { -1, -1 }, { 4918, 4832 }, { 4986, 4970 }, { 5004, 5015 }, { 5061, 5095 }, { 5063, 5099 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMagSetContextInformation"),	{ -1, { -1, -1 }, { -1, -1 }, { 4917, 4833 }, { 4987, 4971 }, { 5005, 5016 }, { 5062, 5096 }, { 5064, 5100 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserManageGestureHandlerWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { 4757, 4834 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMapVirtualKeyEx"),	{ 4554, { 4553, 4186 }, { 4573, 4187 }, { 4584, 4187 }, { 4606, 4187 }, { 4608, 4188 }, { 4610, 4189 }, { 4612, 4189 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMenuItemFromPoint"),	{ 4555, { 4554, 4705 }, { 4574, 4800 }, { 4585, 4835 }, { 4605, 4972 }, { 4607, 5017 }, { 4609, 5097 }, { 4611, 5101 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMessageCall"),	{ 4556, { 4555, 4103 }, { 4575, 4103 }, { 4586, 4103 }, { 4604, 4104 }, { 4606, 4105 }, { 4608, 4106 }, { 4610, 4106 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMinMaximize"),	{ 4557, { 4556, 4706 }, { 4576, 4801 }, { 4587, 4836 }, { 4603, 4973 }, { 4605, 5018 }, { 4607, 5098 }, { 4609, 5102 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMNDragLeave"),	{ 4558, { 4557, 4703 }, { 4577, 4798 }, { 4588, 4829 }, { 4602, 4967 }, { 4604, 5012 }, { 4606, 5092 }, { 4608, 5096 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMNDragOver"),	{ 4559, { 4558, 4704 }, { 4578, 4799 }, { 4589, 4830 }, { 4601, 4968 }, { 4603, 5013 }, { 4605, 5093 }, { 4607, 5097 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserModifyUserStartupInfoFlags"),	{ 4560, { 4559, 4372 }, { 4579, 4373 }, { 4590, 4366 }, { 4600, 4366 }, { 4602, 4367 }, { 4604, 4368 }, { 4606, 4368 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserModifyWindowTouchCapability"),	{ -1, { -1, -1 }, { -1, -1 }, { 4748, 4837 }, { 4770, 4974 }, { 4773, 5019 }, { 4783, 5099 }, { 4784, 5103 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserMoveWindow"),	{ 4561, { 4560, 4189 }, { 4580, 4190 }, { 4591, 4190 }, { 4599, 4190 }, { 4601, 4191 }, { 4603, 4192 }, { 4605, 4192 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserNavigateFocus"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5222, 5100 }, { 5227, 5104 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserNotifyIMEStatus"),	{ 4562, { 4561, 4707 }, { 4581, 4802 }, { 4592, 4838 }, { 4598, 4975 }, { 4600, 5020 }, { 4602, 5101 }, { 4604, 5105 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserNotifyProcessCreate"),	{ 4563, { 4562, 4238 }, { 4582, 4239 }, { 4593, 4237 }, { 4597, 4237 }, { 4599, 4238 }, { 4601, 4239 }, { 4603, 4239 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserNotifyWinEvent"),	{ 4564, { 4563, 4140 }, { 4583, 4141 }, { 4594, 4141 }, { 4596, 4142 }, { 4598, 4143 }, { 4600, 4144 }, { 4602, 4144 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserOpenClipboard"),	{ 4565, { 4564, 4307 }, { 4584, 4308 }, { 4595, 4303 }, { 4595, 4303 }, { 4597, 4304 }, { 4599, 4305 }, { 4601, 4305 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserOpenDesktop"),	{ 4566, { 4565, 4267 }, { 4585, 4268 }, { 4596, 4263 }, { 4594, 4263 }, { 4596, 4264 }, { 4598, 4265 }, { 4600, 4265 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserOpenInputDesktop"),	{ 4567, { 4566, 4708 }, { 4586, 4803 }, { 4597, 4839 }, { 4593, 4976 }, { 4595, 5021 }, { 4597, 5102 }, { 4599, 5106 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserOpenThreadDesktop"),	{ -1, { -1, -1 }, { 4587, 4804 }, { 4598, 4840 }, { 4592, 4977 }, { 4594, 5022 }, { 4596, 5103 }, { 4598, 5107 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserOpenWindowStation"),	{ 4568, { 4567, 4257 }, { 4588, 4258 }, { 4599, 4256 }, { 4591, 4256 }, { 4593, 4257 }, { 4595, 4258 }, { 4597, 4258 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPaintDesktop"),	{ 4569, { 4568, 4379 }, { 4589, 4380 }, { 4600, 4373 }, { 4590, 4373 }, { 4592, 4374 }, { 4594, 4375 }, { 4596, 4375 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPaintMenuBar"),	{ 4663, { 4659, 4338 }, { 4687, 4339 }, { 4700, 4334 }, { 4632, 4334 }, { 4635, 4335 }, { 4638, 4336 }, { 4640, 4336 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPaintMonitor"),	{ -1, { -1, -1 }, { 4590, 4805 }, { 4601, 4841 }, { 4589, 4978 }, { 4591, 5023 }, { 4593, 5104 }, { 4595, 5108 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPeekMessage"),	{ 4570, { 4569, 4097 }, { 4591, 4097 }, { 4602, 4097 }, { 4588, 4098 }, { 4590, 4099 }, { 4592, 4100 }, { 4594, 4100 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPerMonitorDPIPhysicalToLogicalPoint"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4584, 5024 }, { 4586, 5105 }, { 4588, 5109 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPhysicalToLogicalPoint"),	{ -1, { -1, -1 }, { 4592, 4806 }, { 4603, 4842 }, { 4587, 4979 }, { 4589, 5025 }, { 4591, 5106 }, { 4593, 5110 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPostMessage"),	{ 4571, { 4570, 4110 }, { 4593, 4111 }, { 4604, 4111 }, { 4586, 4112 }, { 4588, 4113 }, { 4590, 4114 }, { 4592, 4114 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPostThreadMessage"),	{ 4572, { 4571, 4190 }, { 4594, 4191 }, { 4605, 4191 }, { 4585, 4191 }, { 4587, 4192 }, { 4589, 4193 }, { 4591, 4193 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPrintWindow"),	{ 4573, { 4572, 4709 }, { 4595, 4807 }, { 4606, 4843 }, { 4584, 4980 }, { 4586, 5026 }, { 4588, 5107 }, { 4590, 5111 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserProcessConnect"),	{ 4574, { 4573, 4346 }, { 4596, 4347 }, { 4607, 4342 }, { 4583, 4342 }, { 4585, 4343 }, { 4587, 4344 }, { 4589, 4344 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPromoteMouseInPointer"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5072, 4981 }, { 5113, 5027 }, { 5190, 5108 }, { 5194, 5112 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserPromotePointer"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4814, 4982 }, { 4822, 5028 }, { 4833, 5109 }, { 4834, 5113 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserQueryBSDRWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4582, 4983 }, { 4583, 5029 }, { 4585, 5110 }, { 4587, 5114 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserQueryDisplayConfig"),	{ -1, { -1, -1 }, { -1, -1 }, { 4436, 4844 }, { 4439, 4984 }, { 4441, 5030 }, { 4442, 5111 }, { 4444, 5115 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserQueryInformationThread"),	{ 4575, { 4574, 4710 }, { 4597, 4808 }, { 4608, 4845 }, { 4581, 4985 }, { 4582, 5031 }, { 4584, 5112 }, { 4586, 5116 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserQueryInputContext"),	{ 4576, { 4575, 4711 }, { 4598, 4809 }, { 4609, 4846 }, { 4580, 4986 }, { 4581, 5032 }, { 4583, 5113 }, { 4585, 5117 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserQuerySendMessage"),	{ 4577, { 4576, 4712 }, { 4599, 4810 }, { 4610, 4847 }, { 4579, 4987 }, { 4580, 5033 }, { 4582, 5114 }, { 4584, 5118 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserQueryUserCounters"),	{ 4578, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserQueryWindow"),	{ 4579, { 4577, 4111 }, { 4600, 4112 }, { 4611, 4112 }, { 4578, 4113 }, { 4579, 4114 }, { 4581, 4115 }, { 4583, 4115 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRealChildWindowFromPoint"),	{ 4580, { 4578, 4713 }, { 4601, 4811 }, { 4612, 4848 }, { 4577, 4988 }, { 4578, 5034 }, { 4580, 5115 }, { 4582, 5119 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRealInternalGetMessage"),	{ 4581, { 4579, 4334 }, { 4602, 4335 }, { 4613, 4330 }, { 4628, 4330 }, { 4631, 4331 }, { 4633, 4332 }, { 4635, 4332 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRealWaitMessageEx"),	{ 4582, { 4580, 4714 }, { 4603, 4812 }, { 4614, 4849 }, { 4629, 4989 }, { 4632, 5035 }, { 4634, 5116 }, { 4636, 5120 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRedrawWindow"),	{ 4583, { 4581, 4114 }, { 4604, 4115 }, { 4615, 4115 }, { 4728, 4116 }, { 4731, 4117 }, { 4741, 4118 }, { 4742, 4118 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterBSDRWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4727, 4990 }, { 4730, 5036 }, { 4740, 5117 }, { 4741, 5121 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterClassExWOW"),	{ 4584, { 4582, 4276 }, { 4605, 4277 }, { 4616, 4272 }, { 4726, 4272 }, { 4729, 4273 }, { 4739, 4274 }, { 4740, 4274 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterDManipHook"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4733, 5118 }, { 4734, 5122 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterEdgy"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4798, 4991 }, { 4801, 5037 }, { 4811, 5119 }, { 4812, 5123 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterErrorReportingDialog"),	{ -1, { -1, -1 }, { 4606, 4813 }, { 4617, 4850 }, { 4725, 4992 }, { 4728, 5038 }, { 4738, 5120 }, { 4739, 5124 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterHotKey"),	{ 4586, { 4584, 4715 }, { 4608, 4814 }, { 4619, 4851 }, { 4723, 4993 }, { 4726, 5039 }, { 4732, 5121 }, { 4733, 5125 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterManipulationThread"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4735, 5122 }, { 4736, 5126 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterPointerDeviceNotifications"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4810, 4994 }, { 4815, 5040 }, { 4826, 5123 }, { 4827, 5127 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterPointerInputTarget"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4816, 4995 }, { 4824, 5041 }, { 4835, 5124 }, { 4836, 5128 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterRawInputDevices"),	{ 4587, { 4585, 4716 }, { 4609, 4815 }, { 4620, 4852 }, { 4722, 4996 }, { 4725, 5042 }, { 4731, 5125 }, { 4732, 5129 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterServicesProcess"),	{ -1, { -1, -1 }, { -1, -1 }, { 4621, 4853 }, { 4721, 4997 }, { 4724, 5043 }, { 4730, 5126 }, { 4731, 5130 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterSessionPort"),	{ -1, { -1, -1 }, { 4720, 4816 }, { 4732, 4854 }, { 4738, 4998 }, { 4741, 5044 }, { 4751, 5127 }, { 4752, 5131 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterShellPTPListener"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4812, 5128 }, { 4813, 5132 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterTasklist"),	{ 4588, { 4586, 4717 }, { 4610, 4817 }, { 4622, 4855 }, { 4720, 4999 }, { 4723, 5045 }, { 4729, 5129 }, { 4730, 5133 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterTouchHitTestingWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4804, 5000 }, { 4807, 5046 }, { 4818, 5130 }, { 4819, 5134 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterTouchPadCapable"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4811, 5047 }, { 4822, 5131 }, { 4823, 5135 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterUserApiHook"),	{ 4585, { 4583, 4718 }, { 4607, 4818 }, { 4618, 4856 }, { 4724, 5001 }, { 4727, 5048 }, { 4737, 5132 }, { 4738, 5136 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRegisterWindowMessage"),	{ 4589, { 4587, 4150 }, { 4611, 4151 }, { 4623, 4151 }, { 4719, 4152 }, { 4722, 4153 }, { 4728, 4154 }, { 4729, 4154 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserReleaseDwmHitTestWaiters"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4635, 5133 }, { 4637, 5137 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRemoteConnect"),	{ 4690, { 4686, 4719 }, { 4715, 4819 }, { 4727, 4857 }, { 4743, 5002 }, { 4746, 5049 }, { 4756, 5134 }, { 4757, 5138 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRemoteRedrawRectangle"),	{ 4691, { 4687, 4720 }, { 4716, 4820 }, { 4728, 4858 }, { 4742, 5003 }, { 4745, 5050 }, { 4755, 5135 }, { 4756, 5139 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRemoteRedrawScreen"),	{ 4692, { 4688, -1 }, { 4717, 4821 }, { 4729, 4859 }, { 4741, 5004 }, { 4744, 5051 }, { 4754, 5136 }, { 4755, 5140 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRemoteStopScreenUpdates"),	{ 4693, { 4689, -1 }, { 4718, 4822 }, { 4730, 4860 }, { 4740, 5005 }, { 4743, 5052 }, { 4753, 5137 }, { 4754, 5141 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRemoveClipboardFormatListener"),	{ -1, { -1, -1 }, { 4612, 4823 }, { 4624, 4861 }, { 4718, 5006 }, { 4721, 5053 }, { 4727, 5138 }, { 4728, 5142 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRemoveInjectionDevice"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 5143 }, { 5214, 5143 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRemoveMenu"),	{ 4590, { 4588, 4350 }, { 4613, 4351 }, { 4625, 4346 }, { 4717, 4346 }, { 4720, 4347 }, { 4726, 4348 }, { 4727, 4348 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserRemoveProp"),	{ 4591, { 4589, 4165 }, { 4614, 4166 }, { 4626, 4166 }, { 4716, 4167 }, { 4719, 4168 }, { 4725, 4169 }, { 4726, 4169 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserReportInertia"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5128, 5054 }, { 5205, 5139 }, { 5209, 5144 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserResolveDesktop"),	{ 4592, { 4590, 4384 }, { 4615, 4385 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserResolveDesktopForWOW"),	{ 4593, { 4591, 4723 }, { 4616, 4824 }, { 4627, 4862 }, { 4715, 5007 }, { 4718, 5055 }, { 4724, 5140 }, { 4725, 5145 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSBGetParms"),	{ 4594, { 4592, 4173 }, { 4617, 4174 }, { 4628, 4174 }, { 4714, 4175 }, { 4717, 4176 }, { 4723, 4177 }, { 4724, 4177 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserScrollDC"),	{ 4595, { 4593, 4202 }, { 4618, 4203 }, { 4629, 4203 }, { 4713, 4203 }, { 4716, 4204 }, { 4722, 4205 }, { 4723, 4205 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserScrollWindowEx"),	{ 4596, { 4594, 4290 }, { 4619, 4291 }, { 4630, 4286 }, { 4712, 4286 }, { 4715, 4287 }, { 4721, 4288 }, { 4722, 4288 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSelectPalette"),	{ 4597, { 4595, 4124 }, { 4620, 4125 }, { 4631, 4125 }, { 4711, 4126 }, { 4714, 4127 }, { 4720, 4128 }, { 4721, 4128 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSendEventMessage"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4641, 5008 }, { 4644, 5056 }, { 4647, 5141 }, { 4649, 5146 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSendInput"),	{ 4598, { 4596, 4227 }, { 4621, 4228 }, { 4632, 4226 }, { 4710, 4226 }, { 4713, 4227 }, { 4719, 4228 }, { 4720, 4228 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSendTouchInput"),	{ -1, { -1, -1 }, { -1, -1 }, { 4750, 4863 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetActivationFilter"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5103, 5057 }, { 5178, 5142 }, { 5181, 5147 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetActiveProcess"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5055, 5009 }, { 5095, 5058 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetActiveProcessForMonitor"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5170, 5143 }, { 5173, 5148 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetActiveWindow"),	{ 4599, { 4597, 4324 }, { 4622, 4325 }, { 4633, 4320 }, { 4709, 4320 }, { 4712, 4321 }, { 4718, 4322 }, { 4719, 4322 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetAppImeLevel"),	{ 4600, { 4598, 4724 }, { 4623, 4825 }, { 4634, 4864 }, { 4708, 5010 }, { 4711, 5059 }, { 4717, 5144 }, { 4718, 5149 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetAutoRotation"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5059, 5011 }, { 5099, 5060 }, { 5174, 5145 }, { 5177, 5150 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetBrokeredForeground"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5065, 5012 }, { 5105, 5061 }, { 5180, 5146 }, { 5183, 5151 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetCalibrationData"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4806, 5013 }, { 4809, 5062 }, { 4820, 5147 }, { 4821, 5152 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetCapture"),	{ 4601, { 4599, 4168 }, { 4624, 4169 }, { 4635, 4169 }, { 4707, 4170 }, { 4710, 4171 }, { 4716, 4172 }, { 4717, 4172 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetChildWindowNoActivate"),	{ -1, { -1, -1 }, { -1, -1 }, { 4636, 4865 }, { 4706, 5014 }, { 4709, 5063 }, { 4715, 5148 }, { 4716, 5153 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetClassLong"),	{ 4602, { 4600, 4292 }, { 4625, 4293 }, { 4637, 4288 }, { 4705, 4288 }, { 4708, 4289 }, { 4714, 4290 }, { 4715, 4290 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetClassLongPtr"),	{ -1, { -1, 4759 }, { -1, 4868 }, { -1, 4921 }, { -1, 5080 }, { -1, 5132 }, { 5224, 5224 }, { 5229, 5229 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetClassWord"),	{ 4603, { 4601, 4725 }, { 4626, 4826 }, { 4638, 4866 }, { 4704, 5015 }, { 4707, 5064 }, { 4713, 5149 }, { 4714, 5154 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetClipboardData"),	{ 4604, { 4602, 4309 }, { 4627, 4310 }, { 4639, 4305 }, { 4703, 4305 }, { 4706, 4306 }, { 4712, 4307 }, { 4713, 4307 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetClipboardViewer"),	{ 4605, { 4603, 4385 }, { 4628, 4386 }, { 4640, 4378 }, { 4702, 4378 }, { 4705, 4379 }, { 4711, 4380 }, { 4712, 4380 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetConsoleReserveKeys"),	{ 4606, { 4604, 4387 }, { 4629, 4388 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetCoreWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5220, 5150 }, { 5225, 5155 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetCoreWindowPartner"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5221, 5151 }, { 5226, 5156 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetCursor"),	{ 4607, { 4605, 4121 }, { 4630, 4122 }, { 4641, 4122 }, { 4701, 4123 }, { 4704, 4124 }, { 4710, 4125 }, { 4711, 4125 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetCursorContents"),	{ 4608, { 4606, 4726 }, { 4631, 4827 }, { 4642, 4867 }, { 4700, 5016 }, { 4703, 5065 }, { 4709, 5152 }, { 4710, 5157 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetCursorIconData"),	{ 4609, { 4607, 4264 }, { 4632, 4265 }, { 4643, 4260 }, { 4699, 4260 }, { 4702, 4261 }, { 4708, 4262 }, { 4709, 4262 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetDbgTag"),	{ 4610, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetDisplayAutoRotationPreferences"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5058, 5017 }, { 5098, 5066 }, { 5173, 5153 }, { 5176, 5158 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetDisplayConfig"),	{ -1, { -1, -1 }, { -1, -1 }, { 4435, 4868 }, { 4440, 5018 }, { 4442, 5067 }, { 4443, 5154 }, { 4445, 5159 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetDisplayMapping"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4805, 5019 }, { 4808, 5068 }, { 4819, 5155 }, { 4820, 5160 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetFallbackForeground"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5064, 5020 }, { 5104, 5069 }, { 5179, 5156 }, { 5182, 5161 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetFeatureReportResponse"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5210, 5157 }, { 5215, 5162 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetFocus"),	{ 4611, { 4608, 4176 }, { 4633, 4177 }, { 4644, 4177 }, { 4698, 4178 }, { 4701, 4179 }, { 4707, 4180 }, { 4708, 4180 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetGestureConfig"),	{ -1, { -1, -1 }, { -1, -1 }, { 4758, 4869 }, { 4821, 5021 }, { 4830, 5070 }, { 4842, 5158 }, { 4843, 5163 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetImeHotKey"),	{ 4612, { 4609, 4727 }, { 4634, 4828 }, { 4645, 4870 }, { 4697, 5022 }, { 4700, 5071 }, { 4706, 5159 }, { 4707, 5164 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetImeInfoEx"),	{ 4613, { 4610, -1 }, { 4635, 4829 }, { 4646, 4871 }, { 4696, 5023 }, { 4699, 5072 }, { 4705, 5160 }, { 4706, 5165 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetImeOwnerWindow"),	{ 4614, { 4611, 4729 }, { 4636, 4830 }, { 4647, 4872 }, { 4695, 5024 }, { 4698, 5073 }, { 4704, 5161 }, { 4705, 5166 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetImmersiveBackgroundWindow"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4681, 5025 }, { 4684, 5074 }, { 4690, 5162 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetInformationProcess"),	{ 4615, { 4612, 4352 }, { 4637, 4353 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetInformationThread"),	{ 4616, { 4613, 4325 }, { 4638, 4326 }, { 4648, 4321 }, { 4694, 4321 }, { 4697, 4322 }, { 4703, 4323 }, { 4704, 4323 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetInternalWindowPos"),	{ 4617, { 4614, 4730 }, { 4639, 4831 }, { 4649, 4873 }, { 4693, 5026 }, { 4696, 5075 }, { 4702, 5163 }, { 4703, 5167 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetKeyboardState"),	{ 4618, { 4615, 4339 }, { 4640, 4340 }, { 4650, 4335 }, { 4692, 4335 }, { 4695, 4336 }, { 4701, 4337 }, { 4702, 4337 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetLayeredWindowAttributes"),	{ 4677, { 4673, 4731 }, { 4701, 4832 }, { 4714, 4874 }, { 4756, 5027 }, { 4759, 5076 }, { 4769, 5164 }, { 4770, 5168 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetLogonNotifyWindow"),	{ 4619, { 4616, 4732 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetManipulationInputTarget"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4736, 5165 }, { 4737, 5169 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetMenu"),	{ 4620, { 4617, 4733 }, { 4641, 4833 }, { 4651, 4875 }, { 4691, 5028 }, { 4694, 5077 }, { 4700, 5166 }, { 4701, 5170 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetMenuContextHelpId"),	{ 4621, { 4618, 4734 }, { 4642, 4834 }, { 4652, 4876 }, { 4690, 5029 }, { 4693, 5078 }, { 4699, 5167 }, { 4700, 5171 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetMenuDefaultItem"),	{ 4622, { 4619, 4359 }, { 4643, 4360 }, { 4653, 4354 }, { 4689, 4354 }, { 4692, 4355 }, { 4698, 4356 }, { 4699, 4356 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetMenuFlagRtoL"),	{ 4623, { 4620, 4735 }, { 4644, 4835 }, { 4654, 4877 }, { 4688, 5030 }, { 4691, 5079 }, { 4697, 5168 }, { 4698, 5172 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetMirrorRendering"),	{ -1, { -1, -1 }, { 4866, 4836 }, { 4914, 4878 }, { 4985, 5031 }, { 5003, 5080 }, { 5060, 5169 }, { 5062, 5173 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetObjectInformation"),	{ 4624, { 4621, 4736 }, { 4645, 4837 }, { 4655, 4879 }, { 4687, 5032 }, { 4690, 5081 }, { 4696, 5170 }, { 4697, 5174 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetParent"),	{ 4625, { 4622, 4216 }, { 4646, 4217 }, { 4656, 4215 }, { 4686, 4215 }, { 4689, 4216 }, { 4695, 4217 }, { 4696, 4217 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetPrecisionTouchPadConfiguration"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4821, 5082 }, { 4832, 5171 }, { 4833, 5175 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetProcessDPIAware"),	{ -1, { -1, -1 }, { 4660, 4838 }, { 4670, 4880 }, { 4670, 5033 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetProcessDpiAwareness"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4673, 5083 }, { 4676, 5172 }, { 4678, 5176 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetProcessRestrictionExemption"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5069, 5034 }, { 5110, 5084 }, { 5185, 5173 }, { 5188, 5177 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetProcessUIAccessZorder"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4669, 5035 }, { 4672, 5085 }, { 4675, 5174 }, { 4677, 5178 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetProcessWindowStation"),	{ 4626, { 4623, 4268 }, { 4647, 4269 }, { 4657, 4264 }, { 4685, 4264 }, { 4688, 4265 }, { 4694, 4266 }, { 4695, 4266 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetProp"),	{ 4627, { 4624, 4171 }, { 4649, 4172 }, { 4659, 4172 }, { 4683, 4173 }, { 4686, 4174 }, { 4692, 4175 }, { 4693, 4175 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetRipFlags"),	{ 4628, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetScrollInfo"),	{ 4629, { 4625, 4143 }, { 4650, 4144 }, { 4660, 4144 }, { 4682, 4145 }, { 4685, 4146 }, { 4691, 4147 }, { 4692, 4147 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetSensorPresence"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5062, 5036 }, { 4097, 4097 }, { 4098, 4098 }, { 4098, 4098 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetShellWindowEx"),	{ 4630, { 4626, 4737 }, { 4651, 4839 }, { 4661, 4881 }, { 4680, 5037 }, { 4683, 5086 }, { 4689, 5175 }, { 4691, 5179 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetSysColors"),	{ 4631, { 4627, 4738 }, { 4652, 4840 }, { 4662, 4882 }, { 4679, 5038 }, { 4682, 5087 }, { 4688, 5176 }, { 4690, 5180 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetSystemCursor"),	{ 4632, { 4628, 4739 }, { 4653, 4841 }, { 4663, 4883 }, { 4678, 5039 }, { 4681, 5088 }, { 4687, 5177 }, { 4689, 5181 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetSystemMenu"),	{ 4633, { 4629, 4365 }, { 4654, 4366 }, { 4664, 4359 }, { 4677, 4359 }, { 4680, 4360 }, { 4686, 4361 }, { 4688, 4361 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetSystemTimer"),	{ 4634, { 4630, 4740 }, { 4655, 4842 }, { 4665, 4884 }, { 4676, 5040 }, { 4679, 5089 }, { 4685, 5178 }, { 4687, 5182 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetThreadDesktop"),	{ 4635, { 4631, 4242 }, { 4656, 4243 }, { 4666, 4241 }, { 4674, 4241 }, { 4677, 4242 }, { 4683, 4243 }, { 4685, 4243 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetThreadInputBlocked"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4675, 5041 }, { 4678, 5090 }, { 4684, 5179 }, { 4686, 5183 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetThreadLayoutHandles"),	{ 4636, { 4632, 4741 }, { 4657, 4843 }, { 4667, 4885 }, { 4673, 5042 }, { 4676, 5091 }, { 4682, 5180 }, { 4684, 5184 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetThreadState"),	{ 4637, { 4633, 4317 }, { 4658, 4318 }, { 4668, 4313 }, { 4672, 4313 }, { 4675, 4314 }, { 4681, 4315 }, { 4683, 4315 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetTimer"),	{ 4638, { 4634, 4119 }, { 4659, 4120 }, { 4669, 4120 }, { 4671, 4121 }, { 4674, 4122 }, { 4680, 4123 }, { 4682, 4123 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowArrangement"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5186, 5181 }, { 5189, 5185 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowBand"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4668, 5043 }, { 4671, 5092 }, { 4674, 5182 }, { 4676, 5186 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowCompositionAttribute"),	{ -1, { -1, -1 }, { -1, -1 }, { 4671, 4886 }, { 4667, 5044 }, { 4670, 5093 }, { 4673, 5183 }, { 4675, 5187 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowCompositionTransition"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4665, 5045 }, { 4668, 5094 }, { 4671, 5184 }, { 4673, 5188 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowDisplayAffinity"),	{ -1, { -1, -1 }, { -1, -1 }, { 4672, 4887 }, { 4664, 5046 }, { 4667, 5095 }, { 4670, 5185 }, { 4672, 5189 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowFeedbackSetting"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4797, 5047 }, { 4800, 5096 }, { 4810, 5186 }, { 4811, 5190 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowFNID"),	{ 4639, { 4635, 4246 }, { 4661, 4247 }, { 4673, 4245 }, { 4663, 4245 }, { 4666, 4246 }, { 4669, 4247 }, { 4671, 4247 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowLong"),	{ 4640, { 4636, 4187 }, { 4662, 4188 }, { 4674, 4188 }, { 4662, 4188 }, { 4665, 4189 }, { 4668, 4190 }, { 4670, 4190 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowLongPtr"),	{ -1, { -1, 4760 }, { -1, 4869 }, { -1, 4922 }, { -1, 5081 }, { -1, 5133 }, { 5225, 5225 }, { 5230, 5230 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowPlacement"),	{ 4641, { 4637, 4326 }, { 4663, 4327 }, { 4675, 4322 }, { 4661, 4322 }, { 4664, 4323 }, { 4667, 4324 }, { 4669, 4324 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowPos"),	{ 4642, { 4638, 4131 }, { 4664, 4132 }, { 4676, 4132 }, { 4660, 4133 }, { 4663, 4134 }, { 4666, 4135 }, { 4668, 4135 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowRgn"),	{ 4643, { 4639, 4302 }, { 4665, 4303 }, { 4677, 4298 }, { 4659, 4298 }, { 4662, 4299 }, { 4665, 4300 }, { 4667, 4300 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowRgnEx"),	{ -1, { -1, -1 }, { 4667, 4844 }, { 4679, 4888 }, { 4657, 5048 }, { 4660, 5097 }, { 4663, 5187 }, { 4665, 5191 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowsHookAW"),	{ 4644, { 4640, 4358 }, { 4668, 4359 }, { 4680, 4353 }, { 4656, 4353 }, { 4659, 4354 }, { 4662, 4355 }, { 4664, 4355 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowsHookEx"),	{ 4645, { 4641, 4237 }, { 4669, 4238 }, { 4681, 4236 }, { 4655, 4236 }, { 4658, 4237 }, { 4661, 4238 }, { 4663, 4238 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowShowState"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5187, 5188 }, { 5190, 5192 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowStationUser"),	{ 4646, { 4642, 4742 }, { 4670, 4845 }, { 4682, 4889 }, { 4654, 5049 }, { 4657, 5098 }, { 4660, 5189 }, { 4662, 5193 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWindowWord"),	{ 4647, { 4643, 4332 }, { 4671, 4333 }, { 4683, 4328 }, { 4653, 4328 }, { 4656, 4329 }, { 4659, 4330 }, { 4661, 4330 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSetWinEventHook"),	{ 4648, { 4644, 4361 }, { 4672, 4362 }, { 4684, 4356 }, { 4652, 4356 }, { 4655, 4357 }, { 4658, 4358 }, { 4660, 4358 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDestroyLogicalSurfaceBinding"),	{ -1, { -1, -1 }, { -1, -1 }, { 4747, 4890 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDxBindSwapChain"),	{ -1, { -1, -1 }, { -1, -1 }, { 4738, 4891 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDxGetSwapChainStats"),	{ -1, { -1, -1 }, { -1, -1 }, { 4744, 4892 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDxOpenSwapChain"),	{ -1, { -1, -1 }, { -1, -1 }, { 4739, 4893 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDxQuerySwapChainBindingStatus"),	{ -1, { -1, -1 }, { -1, -1 }, { 4742, 4894 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDxReleaseSwapChain"),	{ -1, { -1, -1 }, { -1, -1 }, { 4740, 4895 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDxReportPendingBindingsToDwm"),	{ -1, { -1, -1 }, { -1, -1 }, { 4743, 4896 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDxSetSwapChainBindingStatus"),	{ -1, { -1, -1 }, { -1, -1 }, { 4741, 4897 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmDxSetSwapChainStats"),	{ -1, { -1, -1 }, { -1, -1 }, { 4745, 4898 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSfmGetLogicalSurfaceBinding"),	{ -1, { -1, -1 }, { -1, -1 }, { 4746, 4899 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserShowCaret"),	{ 4649, { 4645, 4132 }, { 4673, 4133 }, { 4685, 4133 }, { 4651, 4134 }, { 4654, 4135 }, { 4657, 4136 }, { 4659, 4136 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserShowScrollBar"),	{ 4650, { 4646, 4156 }, { 4674, 4157 }, { 4686, 4157 }, { 4650, 4158 }, { 4653, 4159 }, { 4656, 4160 }, { 4658, 4160 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserShowSystemCursor"),	{ -1, { -1, -1 }, { 4867, 4846 }, { 4915, 4900 }, { 4984, 5050 }, { 5002, 5099 }, { 5059, 5190 }, { 5061, 5194 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserShowWindow"),	{ 4651, { 4647, 4183 }, { 4675, 4184 }, { 4687, 4184 }, { 4649, 4184 }, { 4652, 4185 }, { 4655, 4186 }, { 4657, 4186 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserShowWindowAsync"),	{ 4652, { 4648, 4386 }, { 4676, 4387 }, { 4688, 4379 }, { 4648, 4379 }, { 4651, 4380 }, { 4654, 4381 }, { 4656, 4381 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserShutdownBlockReasonCreate"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4647, 5051 }, { 4650, 5100 }, { 4653, 5191 }, { 4655, 5195 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserShutdownBlockReasonQuery"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4646, 5052 }, { 4649, 5101 }, { 4652, 5192 }, { 4654, 5196 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserShutdownReasonDestroy"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4645, 5053 }, { 4648, 5102 }, { 4651, 5193 }, { 4653, 5197 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSignalRedirectionStartComplete"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5054, 5054 }, { 5094, 5103 }, { 5169, 5194 }, { 5172, 5198 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSlicerControl"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4989, 5055 }, { 5007, 5104 }, { 5064, 5195 }, { 5066, 5199 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSoundSentry"),	{ 4653, { 4649, -1 }, { 4677, 4847 }, { 4689, 4901 }, { 4644, 5056 }, { 4647, 5105 }, { 4650, 5196 }, { 4652, 5200 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSwitchDesktop"),	{ 4654, { 4650, 4744 }, { 4678, 4848 }, { 4690, 4902 }, { 4643, 5057 }, { 4646, 5106 }, { 4649, 5197 }, { 4651, 5201 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserSystemParametersInfo"),	{ 4655, { 4651, 4161 }, { 4679, 4162 }, { 4691, 4162 }, { 4642, 4163 }, { 4645, 4164 }, { 4648, 4165 }, { 4650, 4165 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserTestForInteractiveUser"),	{ 4656, { 4652, 4745 }, { 4680, 4849 }, { 4692, 4903 }, { 4640, 5058 }, { 4643, 5107 }, { 4646, 5198 }, { 4648, 5202 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserThunkedMenuInfo"),	{ 4657, { 4653, 4366 }, { 4681, 4367 }, { 4693, 4360 }, { 4639, 4360 }, { 4642, 4361 }, { 4645, 4362 }, { 4647, 4362 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserThunkedMenuItemInfo"),	{ 4658, { 4654, 4249 }, { 4682, 4250 }, { 4694, 4248 }, { 4638, 4248 }, { 4641, 4249 }, { 4644, 4250 }, { 4646, 4250 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserToUnicodeEx"),	{ 4659, { 4655, 4218 }, { 4683, 4219 }, { 4695, 4217 }, { 4637, 4217 }, { 4640, 4218 }, { 4643, 4219 }, { 4645, 4219 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserTrackMouseEvent"),	{ 4660, { 4656, 4319 }, { 4684, 4320 }, { 4696, 4315 }, { 4636, 4315 }, { 4639, 4316 }, { 4642, 4317 }, { 4644, 4317 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserTrackPopupMenuEx"),	{ 4661, { 4657, 4746 }, { 4685, 4850 }, { 4697, 4904 }, { 4635, 5059 }, { 4638, 5108 }, { 4641, 5199 }, { 4643, 5203 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserTransformPoint"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5123, 5109 }, { 5200, 5200 }, { 5204, 5204 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserTransformRect"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5124, 5110 }, { 5201, 5201 }, { 5205, 5205 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserTranslateAccelerator"),	{ 4664, { 4660, 4112 }, { 4688, 4113 }, { 4701, 4113 }, { 4631, 4114 }, { 4634, 4115 }, { 4637, 4116 }, { 4639, 4116 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserTranslateMessage"),	{ 4665, { 4661, 4109 }, { 4689, 4109 }, { 4702, 4109 }, { 4630, 4110 }, { 4633, 4111 }, { 4636, 4112 }, { 4638, 4112 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUndelegateInput"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4729, 5060 }, { 4732, 5111 }, { 4742, 5202 }, { 4743, 5206 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUnhookWindowsHookEx"),	{ 4666, { 4662, 4208 }, { 4690, 4209 }, { 4703, 4208 }, { 4767, 4208 }, { 4770, 4209 }, { 4780, 4210 }, { 4781, 4210 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUnhookWinEvent"),	{ 4667, { 4663, 4362 }, { 4691, 4363 }, { 4704, 4357 }, { 4766, 4357 }, { 4769, 4358 }, { 4779, 4359 }, { 4780, 4359 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUnloadKeyboardLayout"),	{ 4668, { 4664, 4747 }, { 4692, 4851 }, { 4705, 4905 }, { 4765, 5061 }, { 4768, 5112 }, { 4778, 5203 }, { 4779, 5207 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUnlockWindowStation"),	{ 4669, { 4665, 4748 }, { 4693, 4852 }, { 4706, 4906 }, { 4764, 5062 }, { 4767, 5113 }, { 4777, 5204 }, { 4778, 5208 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUnregisterClass"),	{ 4670, { 4666, 4287 }, { 4694, 4288 }, { 4707, 4283 }, { 4763, 4283 }, { 4766, 4284 }, { 4776, 4285 }, { 4777, 4285 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUnregisterHotKey"),	{ 4672, { 4668, 4749 }, { 4696, 4853 }, { 4709, 4907 }, { 4761, 5063 }, { 4764, 5114 }, { 4774, 5205 }, { 4775, 5209 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUnregisterSessionPort"),	{ -1, { -1, -1 }, { 4721, 4854 }, { 4733, 4908 }, { 4737, 5064 }, { 4740, 5115 }, { 4750, 5206 }, { 4751, 5210 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUnregisterUserApiHook"),	{ 4671, { 4667, 4750 }, { 4695, 4855 }, { 4708, 4909 }, { 4762, 5065 }, { 4765, 5116 }, { 4775, 5207 }, { 4776, 5211 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUpdateDefaultDesktopThumbnail"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4666, 5066 }, { 4669, 5117 }, { 4672, 5208 }, { 4674, 5212 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUpdateInputContext"),	{ 4673, { 4669, 4751 }, { 4697, 4856 }, { 4710, 4910 }, { 4760, 5067 }, { 4763, 5118 }, { 4773, 5209 }, { 4774, 5213 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUpdateInstance"),	{ 4674, { 4670, 4752 }, { 4698, 4857 }, { 4711, 4911 }, { 4759, 5068 }, { 4762, 5119 }, { 4772, 5210 }, { 4773, 5214 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUpdateLayeredWindow"),	{ 4675, { 4671, 4753 }, { 4699, 4858 }, { 4712, 4912 }, { 4758, 5069 }, { 4761, 5120 }, { 4771, 5211 }, { 4772, 5215 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUpdatePerUserSystemParameters"),	{ 4678, { 4674, 4754 }, { 4702, 4859 }, { 4715, 4913 }, { 4755, 5070 }, { 4758, 5121 }, { 4768, 5212 }, { 4769, 5216 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUpdateWindowInputSinkHints"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5122, 5122 }, { 5199, 5213 }, { 5203, 5217 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUpdateWindowTrackingInfo"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, 5218 }, { 5191, 5218 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUpdateWindowTransform"),	{ -1, { -1, -1 }, { 4722, 4860 }, { 4734, 4914 }, { 4735, 5071 }, { 4738, 5123 }, { 4748, 5214 }, { 4749, 5219 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserUserHandleGrantAccess"),	{ 4679, { 4675, 4755 }, { 4703, 4861 }, { 4716, 4915 }, { 4754, 5072 }, { 4757, 5124 }, { 4767, 5215 }, { 4768, 5220 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserValidateHandleSecure"),	{ 4680, { 4676, 4756 }, { 4704, 4862 }, { 4717, 4916 }, { 4753, 5073 }, { 4756, 5125 }, { 4766, 5216 }, { 4767, 5221 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserValidateRect"),	{ 4681, { 4677, 4305 }, { 4705, 4306 }, { 4718, 4301 }, { 4752, 4301 }, { 4755, 4302 }, { 4765, 4303 }, { 4766, 4303 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserValidateTimerCallback"),	{ 4682, { 4678, 4117 }, { 4706, 4118 }, { 4719, 4118 }, { 4751, 4119 }, { 4754, 4120 }, { 4764, 4121 }, { 4765, 4121 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserVkKeyScanEx"),	{ 4683, { 4679, 4135 }, { 4707, 4136 }, { 4720, 4136 }, { 4750, 4137 }, { 4753, 4138 }, { 4763, 4139 }, { 4764, 4139 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserWaitAvailableMessageEx"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4744, 5074 }, { 4747, 5126 }, { 4757, 5217 }, { 4758, 5222 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserWaitForInputIdle"),	{ 4684, { 4680, 4757 }, { 4708, 4863 }, { 4721, 4917 }, { 4749, 5075 }, { 4752, 5127 }, { 4762, 5218 }, { 4763, 5223 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserWaitForMsgAndEvent"),	{ 4685, { 4681, 4758 }, { 4709, 4864 }, { 4722, 4918 }, { 4748, 5076 }, { 4751, 5128 }, { 4761, 5219 }, { 4762, 5224 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserWaitForRedirectionStartComplete"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5053, 5077 }, { 5093, 5129 }, { 5168, 5220 }, { 5171, 5225 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserWaitMessage"),	{ 4686, { 4682, 4108 }, { 4710, 4108 }, { 4723, 4108 }, { 4747, 4109 }, { 4750, 4110 }, { 4760, 4111 }, { 4761, 4111 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserWin32PoolAllocationStats"),	{ 4687, { 4683, 4761 }, { 4711, 4865 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserWindowFromPhysicalPoint"),	{ -1, { -1, -1 }, { 4712, 4866 }, { 4724, 4919 }, { 4746, 5078 }, { 4749, 5130 }, { 4759, 5221 }, { 4760, 5226 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserWindowFromPoint"),	{ 4688, { 4684, 4115 }, { 4713, 4116 }, { 4725, 4116 }, { 4745, 4117 }, { 4748, 4118 }, { 4758, 4119 }, { 4759, 4119 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtUserYieldTask"),	{ 4689, { 4685, 4762 }, { 4714, 4867 }, { 4726, 4920 }, { 4096, 4096 }, { 4096, 4096 }, { 4097, 4097 }, { 4097, 4097 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtValidateCompositionSurfaceHandle"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 4993, 5079 }, { 5011, 5131 }, { 5068, 5222 }, { 5070, 5227 } } },
	{ RTL_CONSTANT_ANSI_STRING("NtVisualCaptureBits"),	{ -1, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { -1, -1 }, { 5084, 5223 }, { 5086, 5228 } } }
};



================================================
File: Scylla/scylla.debug.props
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <ItemDefinitionGroup>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
</Project>


================================================
File: Scylla/scylla.props
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <IntDir>$(SolutionDir)build\Intermediate\$(Configuration)\$(PlatformName)\$(ProjectName)\</IntDir>
    <OutDir>$(SolutionDir)build\$(Configuration)\$(PlatformName)\</OutDir>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)3rdparty;$(SolutionDir)3rdparty\idasdk\include;</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32_NO_STATUS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DiagnosticsFormat>Caret</DiagnosticsFormat>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <ControlFlowGuard>false</ControlFlowGuard>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <StringPooling>true</StringPooling>
      <MinimalRebuild>false</MinimalRebuild>
      <!-- /Zc:threadSafeInit- is needed for XP support with the static CRT. See: http://www.nynaeve.net/?p=186 and part 6 and 7 of the same series -->
      <AdditionalOptions>/Gw /Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(SolutionDir)3rdparty;$(SolutionDir)3rdparty\idasdk\lib;$(OutDir)</AdditionalLibraryDirectories>
      <AdditionalDependencies>Scylla.lib;ntdll\ntdll_$(PlatformShortName).lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <AdditionalOptions>/NOVCFEATURE /NOCOFFGRPINFO /PDBALTPATH:%_PDB% %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Platform)'=='Win32'">
    <ClCompile>
      <PreprocessorDefinitions Condition="'$(USE_XP_TOOLCHAIN)'!=''">WINVER=0x0501;_WIN32_WINNT=0x0501;NTDDI_VERSION=0x05010000;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(USE_XP_TOOLCHAIN)'==''">WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <Version Condition="'$(USE_XP_TOOLCHAIN)'!=''">5.1</Version>
      <Version Condition="'$(USE_XP_TOOLCHAIN)'==''">6.1</Version>
      <MinimumRequiredVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">5.01</MinimumRequiredVersion>
      <MinimumRequiredVersion Condition="'$(USE_XP_TOOLCHAIN)'==''">6.01</MinimumRequiredVersion>
      <LargeAddressAware>true</LargeAddressAware>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Platform)'=='x64'">
    <ClCompile>
      <PreprocessorDefinitions Condition="'$(USE_XP_TOOLCHAIN)'!=''">WINVER=0x0502;_WIN32_WINNT=0x0502;NTDDI_VERSION=0x05020000;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PreprocessorDefinitions Condition="'$(USE_XP_TOOLCHAIN)'==''">WINVER=0x0601;_WIN32_WINNT=0x0601;NTDDI_VERSION=0x06010000;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <Version Condition="'$(USE_XP_TOOLCHAIN)'!=''">5.2</Version>
      <Version Condition="'$(USE_XP_TOOLCHAIN)'==''">6.1</Version>
      <MinimumRequiredVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">5.02</MinimumRequiredVersion>
      <MinimumRequiredVersion Condition="'$(USE_XP_TOOLCHAIN)'==''">6.01</MinimumRequiredVersion>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <BuildMacro Include="IntDir">
      <Value>$(IntDir)</Value>
    </BuildMacro>
    <BuildMacro Include="OutDir">
      <Value>$(OutDir)</Value>
    </BuildMacro>
  </ItemGroup>
</Project>


================================================
File: Scylla/scylla.release.props
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <ItemDefinitionGroup>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SetChecksum>true</SetChecksum>
    </Link>
  </ItemDefinitionGroup>
</Project>


================================================
File: ScyllaHideGenericPlugin/ScyllaHideGenericPlugin.cpp
================================================
#include "ScyllaHideGenericPlugin.h"
#include <string>
#include <unordered_map>
#include <Scylla/Logger.h>
#include <Scylla/Settings.h>
#include <Scylla/Util.h>

#include "..\PluginGeneric\Injector.h"

struct HookStatus
{
    HookStatus()
        : ProcessId(0),
        bHooked(false),
        specialPebFix(false)
    {
    }

    DWORD ProcessId;
    bool bHooked;
    bool specialPebFix;
};

typedef void(__cdecl * t_AttachProcess)(DWORD dwPID);

#ifdef _WIN64
const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx64.dll";
#else
const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx86.dll";
#endif

scl::Settings g_settings;
scl::Logger g_log;
std::wstring g_scyllaHideDllPath;
std::wstring g_scyllaHideIniPath;

HOOK_DLL_DATA g_hdd;

//globals
static HMODULE hNtdllModule = 0;
static std::unordered_map<DWORD, HookStatus> hookStatusMap;

static void LogCallback(const wchar_t *msg)
{
    _putws(msg);
}

DLL_EXPORT void ScyllaHideDebugLoop(const DEBUG_EVENT* DebugEvent)
{
    auto pid = DebugEvent->dwProcessId;
    auto status = HookStatus();
    auto found = hookStatusMap.find(pid);
    if (found == hookStatusMap.end())
        hookStatusMap[pid] = status;
    else
        status = hookStatusMap[pid];

    if (g_settings.opts().fixPebHeapFlags)
    {
        if (status.specialPebFix)
        {
            StartFixBeingDebugged(status.ProcessId, false);
            status.specialPebFix = false;
        }

        if (DebugEvent->u.LoadDll.lpBaseOfDll == hNtdllModule)
        {
            StartFixBeingDebugged(status.ProcessId, true);
            status.specialPebFix = true;
        }
    }

    switch (DebugEvent->dwDebugEventCode)
    {
    case CREATE_PROCESS_DEBUG_EVENT:
    {
        status.ProcessId = DebugEvent->dwProcessId;
        status.bHooked = false;
        ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));

        if (DebugEvent->u.CreateProcessInfo.lpStartAddress == NULL)
        {
            //ATTACH
            if (g_settings.opts().killAntiAttach)
            {
                if (!ApplyAntiAntiAttach(status.ProcessId))
                {
                    g_log.LogError(L"Anti-Anti-Attach failed");
                }
            }
        }

        break;
    }

    case LOAD_DLL_DEBUG_EVENT:
    {
        if (status.bHooked)
        {
            startInjection(status.ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), false);
        }

        break;
    }

    case EXCEPTION_DEBUG_EVENT:
    {
        switch (DebugEvent->u.Exception.ExceptionRecord.ExceptionCode)
        {
        case STATUS_BREAKPOINT:
        {
            if (!status.bHooked)
            {
                ReadNtApiInformation(&g_hdd);

                status.bHooked = true;
                startInjection(status.ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
            }

            break;
        }
        }

        break;
    }
    }

    hookStatusMap[pid] = status;
}

DLL_EXPORT void ScyllaHideReset()
{
    ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));
    hookStatusMap.clear();
}

DLL_EXPORT void ScyllaHideInit(const WCHAR* Directory, LOGWRAPPER Logger, LOGWRAPPER ErrorLogger)
{
    hNtdllModule = GetModuleHandleW(L"ntdll.dll");

    std::wstring wstrPath;

    if (Directory)
    {
        wstrPath = Directory;
        if (wstrPath.back() != L'\\')
            wstrPath += L'\\';
    } else
    {
        wstrPath = scl::GetModuleFileNameW();
        wstrPath.resize(wstrPath.find_last_of(L'\\') + 1);
    }

    g_scyllaHideDllPath = wstrPath + g_scyllaHideDllFilename;
    g_scyllaHideIniPath = wstrPath + scl::Settings::kFileName;

    auto log_file = wstrPath + scl::Logger::kFileName;
    g_log.SetLogFile(log_file.c_str());

    auto log_cb = Logger ? Logger : LogCallback;
    auto log_err_cb = ErrorLogger ? ErrorLogger : LogCallback;
    g_log.SetLogCb(scl::Logger::Info, log_cb);
    g_log.SetLogCb(scl::Logger::Error, log_err_cb);

    g_settings.Load(g_scyllaHideIniPath.c_str());
}



================================================
File: ScyllaHideGenericPlugin/ScyllaHideGenericPlugin.h
================================================
#ifndef SCYLLAHIDE_GENERIC_PLUGIN_H
#define SCYLLAHIDE_GENERIC_PLUGIN_H

#include <windows.h>

#ifdef SCYLLAHIDEGENERICPLUGIN_EXPORTS
#define DLL_EXPORT extern "C" __declspec(dllexport)
#else
#define DLL_EXPORT extern "C" __declspec(dllimport)
#endif

typedef void(__cdecl * LOGWRAPPER)(const wchar_t *msg);

DLL_EXPORT void ScyllaHideInit(const WCHAR* Directory = NULL, LOGWRAPPER Logger = NULL, LOGWRAPPER ErrorLogger = NULL);
DLL_EXPORT void ScyllaHideReset();
DLL_EXPORT void ScyllaHideDebugLoop(const DEBUG_EVENT* DebugEvent);

#endif //SCYLLAHIDE_GENERIC_PLUGIN_H



================================================
File: ScyllaHideGenericPlugin/ScyllaHideGenericPlugin.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{C2B5EC30-CF03-4963-B963-7576E9F1D01E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ScyllaHideGenericPlugin</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEGENERICPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEGENERICPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEGENERICPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEGENERICPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp" />
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp" />
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp" />
    <ClCompile Include="..\PluginGeneric\Injector.cpp" />
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="ScyllaHideGenericPlugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h" />
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h" />
    <ClInclude Include="..\InjectorCLI\RemoteHook.h" />
    <ClInclude Include="..\PluginGeneric\Injector.h" />
    <ClInclude Include="..\Scylla\VersionPatch.h" />
    <ClInclude Include="ScyllaHideGenericPlugin.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ScyllaHideGenericPlugin/ScyllaHideGenericPlugin.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ScyllaHideGenericPlugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\RemoteHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ScyllaHideGenericPlugin.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


================================================
File: ScyllaHideIDAProPlugin/IdaServerClient.cpp
================================================
#include "IdaServerClient.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include <Scylla/Settings.h>

#include "..\ScyllaHideIDAServer\IdaServerExchange.h"
#include "..\PluginGeneric\Injector.h"

#pragma comment (lib, "Ws2_32.lib")

extern scl::Settings g_settings;


SOCKET serverSock = INVALID_SOCKET;
WSADATA wsaData;

IDA_SERVER_EXCHANGE idaExchange = {0};
extern wchar_t DllPathForInjection[MAX_PATH];

bool StartWinsock()
{
	bool isWinsockUp = true;

	int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0)
	{
		isWinsockUp = false;
	}

	return isWinsockUp;
}

bool SendInjectToServer(unsigned long ProcessId)
{
	return SendEventToServer(inject_dll, ProcessId);
}

bool SendEventToServer(unsigned long notif_code, unsigned long ProcessId)
{
	idaExchange.notif_code = notif_code;
	idaExchange.ProcessId = ProcessId;

    idaExchange.EnablePebBeingDebugged = g_settings.opts().fixPebBeingDebugged;
    idaExchange.EnablePebHeapFlags = g_settings.opts().fixPebHeapFlags;
    idaExchange.EnablePebNtGlobalFlag = g_settings.opts().fixPebNtGlobalFlag;
    idaExchange.EnablePebStartupInfo = g_settings.opts().fixPebStartupInfo;
    idaExchange.EnablePebOsBuildNumber = g_settings.opts().fixPebOsBuildNumber;
    idaExchange.EnableOutputDebugStringHook = g_settings.opts().hookOutputDebugStringA;
    idaExchange.EnableNtSetInformationThreadHook = g_settings.opts().hookNtSetInformationThread;
    idaExchange.EnableNtQueryInformationProcessHook = g_settings.opts().hookNtQueryInformationProcess;
    idaExchange.EnableNtQuerySystemInformationHook = g_settings.opts().hookNtQuerySystemInformation;
    idaExchange.EnableNtQueryObjectHook = g_settings.opts().hookNtQueryObject;
    idaExchange.EnableNtYieldExecutionHook = g_settings.opts().hookNtYieldExecution;
    idaExchange.EnableNtCloseHook = g_settings.opts().hookNtClose;
    idaExchange.EnableNtCreateThreadExHook = g_settings.opts().hookNtCreateThreadEx;
    idaExchange.EnablePreventThreadCreation = g_settings.opts().preventThreadCreation;

    idaExchange.EnableNtGetContextThreadHook = g_settings.opts().hookNtGetContextThread;
    idaExchange.EnableNtSetContextThreadHook = g_settings.opts().hookNtSetContextThread;
    idaExchange.EnableNtContinueHook = g_settings.opts().hookNtContinue;
    idaExchange.EnableKiUserExceptionDispatcherHook = g_settings.opts().hookKiUserExceptionDispatcher;
    idaExchange.EnableNtSetInformationProcessHook = g_settings.opts().hookNtSetInformationProcess;
    idaExchange.EnableMalwareRunPeUnpacker = g_settings.opts().malwareRunpeUnpacker;

    idaExchange.EnableGetTickCountHook = g_settings.opts().hookGetTickCount;
    idaExchange.EnableGetTickCount64Hook = g_settings.opts().hookGetTickCount64;
    idaExchange.EnableGetLocalTimeHook = g_settings.opts().hookGetLocalTime;
    idaExchange.EnableGetSystemTimeHook = g_settings.opts().hookGetSystemTime;
    idaExchange.EnableNtQuerySystemTimeHook = g_settings.opts().hookNtQuerySystemTime;
    idaExchange.EnableNtQueryPerformanceCounterHook = g_settings.opts().hookNtQueryPerformanceCounter;

    idaExchange.EnableNtUserBlockInputHook = g_settings.opts().hookNtUserBlockInput;
    idaExchange.EnableNtUserFindWindowExHook = g_settings.opts().hookNtUserFindWindowEx;
    idaExchange.EnableNtUserBuildHwndListHook = g_settings.opts().hookNtUserBuildHwndList;
    idaExchange.EnableNtUserQueryWindowHook = g_settings.opts().hookNtUserQueryWindow;
    idaExchange.EnableNtUserGetForegroundWindowHook = g_settings.opts().hookNtUserGetForegroundWindow;
    idaExchange.EnableNtSetDebugFilterStateHook = g_settings.opts().hookNtSetDebugFilterState;
    idaExchange.DllInjectNormal = g_settings.opts().dllNormal;
    idaExchange.DllInjectStealth = g_settings.opts().dllStealth;
    idaExchange.UnloadDllAfterInjection = g_settings.opts().dllUnload;

	wcscpy_s(idaExchange.DllPathForInjection, DllPathForInjection);


	int iResult = send(serverSock, (char*)&idaExchange, (int)sizeof(IDA_SERVER_EXCHANGE), 0);
	if (iResult == SOCKET_ERROR)
	{
		//printf("send failed with error: %d\n", WSAGetLastError());
		return false;
	}

	idaExchange.result = RESULT_FAILED;

	iResult = recv(serverSock, (char*)&idaExchange, (int)sizeof(IDA_SERVER_EXCHANGE), 0);

	if (iResult == sizeof(IDA_SERVER_EXCHANGE))
	{
		if (idaExchange.result == RESULT_SUCCESS)
		{
			return true;
		}
	}

	return false;
}

void CloseServerSocket()
{
	closesocket(serverSock);
	serverSock = INVALID_SOCKET;
}

bool ConnectToServer(const char * host, const char * port)
{
	int iResult;
	struct addrinfo *result = NULL,
		*ptr = NULL,
		hints;

	ZeroMemory( &hints, sizeof(hints) );
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	// Resolve the server address and port
	iResult = getaddrinfo(host, port, &hints, &result);
	if ( iResult != 0 )
	{
		//printf("getaddrinfo failed with error: %d\n", iResult);
		return false;
	}

	// Attempt to connect to an address until one succeeds
	for(ptr=result; ptr != NULL ;ptr=ptr->ai_next)
	{

		// Create a SOCKET for connecting to server
		serverSock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
		if (serverSock == INVALID_SOCKET)
		{
			//printf("socket failed with error: %ld\n", WSAGetLastError());
			return false;
		}

		// Connect to server.
		iResult = connect( serverSock, ptr->ai_addr, (int)ptr->ai_addrlen);
		if (iResult == SOCKET_ERROR)
		{
			closesocket(serverSock);
			serverSock = INVALID_SOCKET;
			continue;
		}
		else
		{
			break;
		}
	}

	freeaddrinfo(result);

	if (serverSock == INVALID_SOCKET)
	{
		//printf("Unable to connect to server!\n");
		return false;
	}
	else
	{
		return true;
	}
}

//input: tcp:port=5000,server=localhost
//OR
//input: IP
//IDA v6 BUG!!!!!!!
bool GetHost(char * input, char * output)
{
	char * t = strstr(input, "server=");
	if (t)
	{
		t += 7;
		strcpy(output, t);
	}
	else
	{
		strcpy(output, input);
	}

	return true;
}



================================================
File: ScyllaHideIDAProPlugin/IdaServerClient.h
================================================
#pragma once

bool StartWinsock();
bool ConnectToServer(const char * host, const char * port);
bool SendEventToServer(unsigned long notif_code, unsigned long ProcessId);
void CloseServerSocket();
bool GetHost(char * input, char * output);
bool SendInjectToServer(unsigned long ProcessId);



================================================
File: ScyllaHideIDAProPlugin/ScyllaHideIDAProPlugin.cpp
================================================
#define USE_STANDARD_FILE_FUNCTIONS
#pragma warning(disable : 4996 4512 4127 4201)


//for 64bit - p64
#ifdef BUILD_IDA_64BIT
#define __EA64__
#pragma comment(lib, "x86_win_vc_64/ida.lib")
#else
//for 32bit - plw
#pragma comment(lib, "x86_win_vc_32/ida.lib")
#endif

#include <Windows.h>
#include <ida.hpp>
#include <idp.hpp>
#include <dbg.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <Scylla/Logger.h>
#include <Scylla/Settings.h>
#include <Scylla/Version.h>
#include <Scylla/Util.h>
#include <Scylla/OsInfo.h>

#include "..\PluginGeneric\Injector.h"
#include "..\PluginGeneric\OptionsDialog.h"
#include "IdaServerClient.h"
#include "resource.h"

typedef void(__cdecl * t_AttachProcess)(DWORD dwPID);

extern t_AttachProcess _AttachProcess;

const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx86.dll";
const WCHAR g_scyllaHidex64ServerFilename[] = L"ScyllaHideIDAServerx64.exe";

scl::Settings g_settings;
scl::Logger g_log;
std::wstring g_scyllaHideDllPath;
std::wstring g_scyllaHideIniPath;
std::wstring g_scyllaHidex64ServerPath;

HOOK_DLL_DATA g_hdd;

//globals
HINSTANCE hinst;
DWORD ProcessId = 0;
bool bHooked = false;
HMODULE hNtdllModule = 0;
PROCESS_INFORMATION ServerProcessInfo = { 0 };
STARTUPINFO ServerStartupInfo = { 0 };
bool isAttach = false;

static void LogCallback(const char *message)
{
    msg("[%s] %s\n", SCYLLA_HIDE_NAME_A, message);
}

static void AttachProcess(DWORD dwPID)
{
    int res = attach_process((pid_t)dwPID);

    switch (res) {
    case -1:
    {
        MessageBoxA((HWND)callui(ui_get_hwnd).vptr,
            "Can't attach to that process !",
            "ScyllaHide Plugin", MB_OK | MB_ICONERROR);
        break;
    }
    case -2:
    {
        MessageBoxA((HWND)callui(ui_get_hwnd).vptr,
            "Can't find that PID !",
            "ScyllaHide Plugin", MB_OK | MB_ICONERROR);
        break;
    }
    }
}

static bool SetDebugPrivileges()
{
    TOKEN_PRIVILEGES Debug_Privileges;
    bool retVal = false;

    if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &Debug_Privileges.Privileges[0].Luid))
    {
        HANDLE hToken = 0;
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
        {
            Debug_Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            Debug_Privileges.PrivilegeCount = 1;

            retVal = AdjustTokenPrivileges(hToken, FALSE, &Debug_Privileges, 0, NULL, NULL) != FALSE;

            CloseHandle(hToken);
        }
    }

    return retVal;
}

//callback for various debug events
static int idaapi debug_mainloop(void *user_data, int notif_code, va_list va)
{
    switch (notif_code)
    {
    case dbg_process_attach:
    {
        isAttach = true;
        break; //attaching not supported
    }
    case dbg_process_start:
    {
        isAttach = false;

        const debug_event_t* dbgEvent = va_arg(va, const debug_event_t*);

        ProcessId = dbgEvent->pid;
        bHooked = false;
        ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));

        if (dbg != nullptr)
        {
            //char text[1000];
            //wsprintfA(text, "dbg->id %d processor %s", dbg->id , dbg->processor);
            //MessageBoxA(0, text, text,0);
            // dbg->id DEBUGGER_ID_WINDBG -> 64bit and 32bit
            // dbg->id DEBUGGER_ID_X86_IA32_WIN32_USER -> 32bit

            if (dbg->is_remote())
            {
                qstring hoststring;
                char host[MAX_PATH] = { 0 };
                char port[6] = { 0 };
                wcstombs(port, g_settings.opts().idaServerPort.c_str(), _countof(port));

                get_process_options(NULL, NULL, NULL, &hoststring, NULL, NULL);
                GetHost((char*)hoststring.c_str(), host);

                //msg("Host-String: %s\n", hoststring.c_str());
                //msg("Host: %s\n", host);

#ifdef BUILD_IDA_64BIT
                //autostart server if necessary
                if(g_settings.opts().idaAutoStartServer)
                {
                    if (!scl::FileExistsW(g_scyllaHidex64ServerPath.c_str()))
                    {
                        g_log.LogError(L"Cannot find server executable %s\n", g_scyllaHidex64ServerPath.c_str());
                    }

                    DWORD dwRunningStatus = 0;
                    if (ServerProcessInfo.hProcess)
                    {
                        GetExitCodeProcess(ServerProcessInfo.hProcess, &dwRunningStatus);
                    }

                    if(dwRunningStatus != STILL_ACTIVE)
                    {
                        if (ServerProcessInfo.hProcess)
                        {
                            CloseHandle(ServerProcessInfo.hProcess);
                            CloseHandle(ServerProcessInfo.hThread);
                        }

                        ZeroMemory(&ServerStartupInfo, sizeof(ServerStartupInfo));
                        ZeroMemory(&ServerProcessInfo, sizeof(ServerProcessInfo));

                        WCHAR commandline[MAX_PATH*2] = {0};
                        wcscpy(commandline, g_scyllaHidex64ServerPath.c_str());
                        wcscat(commandline, L" ");
                        wcscat(commandline, g_settings.opts().idaServerPort.c_str());
                        ServerStartupInfo.cb = sizeof(ServerStartupInfo);
                        if (!CreateProcessW(0, commandline, NULL, NULL, FALSE, 0, NULL, NULL, &ServerStartupInfo, &ServerProcessInfo))
                        {
                            g_log.LogError(L"Cannot start server, error %d", GetLastError());
                        }
                        else
                        {
                            g_log.LogInfo(L"Started IDA Server successfully");
                        }
                    }
                }
#endif
                if (ConnectToServer(host, port))
                {
                    if (!SendEventToServer(notif_code, ProcessId))
                    {
                        g_log.LogError(L"SendEventToServer failed");
                    }
                }
                else
                {
                    g_log.LogError(L"Cannot connect to host %s", host);
                }
            }
            else
            {

#ifndef BUILD_IDA_64BIT
                if (!scl::IsWindows64() && !bHooked) // Only apply on native x86 OS, see dbg_library_unload below
                {
                    ReadNtApiInformation(&g_hdd);

                    bHooked = true;
                    startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
                }
#else
                g_log.LogError(L"Error IDA_64BIT please contact ScyllaHide developers!");
#endif
            }
        }
    }
    break;

    case dbg_process_exit:
    {
        if (!isAttach && dbg->is_remote())
        {
            if (!SendEventToServer(notif_code, ProcessId))
            {
                g_log.LogError(L"SendEventToServer failed");
            }

            CloseServerSocket();
        }
        ProcessId = 0;
        bHooked = false;
    }
    break;

    case dbg_library_load:
    {

        if (!isAttach && dbg->is_remote())
        {
            if (!SendEventToServer(notif_code, ProcessId))
            {
                g_log.LogError(L"SendEventToServer failed");
            }
        }
        else if (!isAttach)
        {
#ifndef BUILD_IDA_64BIT
            if (bHooked)
            {
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), false);
            }
#endif
        }

    }
    break;

#ifndef BUILD_IDA_64BIT
    case dbg_library_unload:
    {
        if (scl::IsWindows64() && !bHooked)
        {
            // Bogus unload event which is actually a load of a native x64 DLL (ntdll, wow64, wow64cpu, wow64win)
            ReadNtApiInformation(&g_hdd);

            bHooked = true;
            startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
        }
    }
    break;
#endif

    case dbg_bpt:
    {
        thid_t tid = va_arg(va, thid_t);
        ea_t breakpoint_ea = va_arg(va, ea_t);
        va_arg(va, int*);
    }
    break;

    case dbg_exception:
    {
        const debug_event_t* dbgEvent = va_arg(va, const debug_event_t*);

    }
    break;
    }

    return 0;
}

//cleanup on plugin unload
static void idaapi IDAP_term(void)
{
    unhook_from_notification_point(HT_DBG, debug_mainloop, NULL);
}

//called when user clicks in plugin menu or presses hotkey
static void idaapi IDAP_run(int arg)
{
    DialogBoxW(hinst, MAKEINTRESOURCE(IDD_OPTIONS), (HWND)callui(ui_get_hwnd).vptr, &OptionsDlgProc);
}

//init the plugin
static int idaapi IDAP_init(void)
{
    //ensure target is PE executable
    if (inf.filetype != f_PE) return PLUGIN_SKIP;

    //install hook for debug mainloop
    if (!hook_to_notification_point(HT_DBG, debug_mainloop, NULL))
    {
        g_log.LogError(L"Error hooking notification point");
        return PLUGIN_SKIP;
    }

    msg("##################################################\n");
    msg("# " SCYLLA_HIDE_NAME_A " v" SCYLLA_HIDE_VERSION_STRING_A " Copyright 2014-" COMPILE_YEAR_A " Aguila / cypher #\n");
    msg("##################################################\n");

    bHooked = false;
    ProcessId = 0;
    ZeroMemory(&ServerStartupInfo, sizeof(ServerStartupInfo));
    ZeroMemory(&ServerProcessInfo, sizeof(ServerProcessInfo));

    return PLUGIN_KEEP;
}

// There isn't much use for these yet, but I set them anyway.
static char IDAP_comment[] = SCYLLA_HIDE_NAME_A " usermode Anti-Anti-Debug Plugin";
static char IDAP_help[] = SCYLLA_HIDE_NAME_A;

// The name of the plug-in displayed in the Edit->Plugins menu
static char IDAP_name[] = SCYLLA_HIDE_NAME_A;

// The hot-key the user can use to run your plug-in.
static char IDAP_hotkey[] = "Alt-X";

// The all-important exported PLUGIN object
idaman ida_module_data plugin_t PLUGIN =
{
    IDP_INTERFACE_VERSION,
    0,
    IDAP_init,
    IDAP_term,
    IDAP_run,
    IDAP_comment,
    IDAP_help,
    IDAP_name,
    IDAP_hotkey
};

BOOL WINAPI DllMain(HINSTANCE hInstDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        hinst = hInstDll;
        _AttachProcess = AttachProcess;
        hNtdllModule = GetModuleHandleW(L"ntdll.dll");

        auto wstrPath = scl::GetModuleFileNameW(hInstDll);
        wstrPath.resize(wstrPath.find_last_of(L'\\') + 1);

        g_scyllaHideDllPath = wstrPath + g_scyllaHideDllFilename;
        g_scyllaHideIniPath = wstrPath + scl::Settings::kFileName;
        g_scyllaHidex64ServerPath = wstrPath + g_scyllaHidex64ServerFilename;

        auto log_file = wstrPath + scl::Logger::kFileName;
        g_log.SetLogFile(log_file.c_str());
        g_log.SetLogCb(scl::Logger::Info, LogCallback);
        g_log.SetLogCb(scl::Logger::Error, LogCallback);

        g_settings.Load(g_scyllaHideIniPath.c_str());

        if (!SetDebugPrivileges())
        {
            g_log.LogInfo(L"Failed to set debug privileges");
        }

        if (!StartWinsock())
        {
            MessageBoxW(0, L"Failed to start Winsock!", L"Error", MB_ICONERROR);
        }
    }

    return TRUE;
}



================================================
File: ScyllaHideIDAProPlugin/ScyllaHideIDAProPlugin.rc
================================================
[Non-text file]


================================================
File: ScyllaHideIDAProPlugin/ScyllaHideIDAProPlugin.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{A94B6222-ABEF-41A0-BE48-06801157AAA5}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ScyllaHideIDAProPlugin</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.plw</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.plw</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;__NT__;__IDP__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;__NT__;__IDP__;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp" />
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp" />
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp" />
    <ClCompile Include="..\PluginGeneric\AttachDialog.cpp" />
    <ClCompile Include="..\PluginGeneric\Injector.cpp" />
    <ClCompile Include="..\PluginGeneric\OptionsDialog.cpp" />
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="IdaServerClient.cpp" />
    <ClCompile Include="ScyllaHideIDAProPlugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ScyllaHideIDAProPlugin.rc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h" />
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h" />
    <ClInclude Include="..\InjectorCLI\RemoteHook.h" />
    <ClInclude Include="..\PluginGeneric\AttachDialog.h" />
    <ClInclude Include="..\PluginGeneric\Injector.h" />
    <ClInclude Include="..\PluginGeneric\OptionsDialog.h" />
    <ClInclude Include="..\Scylla\VersionPatch.h" />
    <ClInclude Include="IdaServerClient.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\findere.bmp" />
    <None Include="..\PluginGeneric\finderf.bmp" />
    <None Include="..\PluginGeneric\searchwindow.cur" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ScyllaHideIDAProPlugin/ScyllaHideIDAProPlugin.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ScyllaHideIDAProPlugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IdaServerClient.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\OptionsDialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\AttachDialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ScyllaHideIDAProPlugin.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\RemoteHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IdaServerClient.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\OptionsDialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\AttachDialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\findere.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\PluginGeneric\finderf.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\PluginGeneric\searchwindow.cur">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: ScyllaHideIDAProPlugin/resource.h
================================================
[Non-text file]


================================================
File: ScyllaHideIDAServer/Icon.rc
================================================
[Non-text file]


================================================
File: ScyllaHideIDAServer/IdaServerExchange.h
================================================
#pragma once

#define IDA_SERVER_DEFAULT_PORT_TEXT "1337"
#define IDA_SERVER_DEFAULT_PORT 1337

enum server_dbg_notification_t
{
	dbg_null = 0,

	// debugger low-level event notifications (see IDD.HPP for details).

	dbg_process_start,   // Parameter:  const debug_event_t *event
	//   This event notification is also an asynchronous
	//   function result notification for start_process() !

	dbg_process_exit,    // Parameter:  const debug_event_t *event
	//   This event notification is also an asynchronous
	//   function result notification for exit_process() !

	dbg_process_attach,  // Parameter:  const debug_event_t *event
	//   This event notification is also an asynchronous
	//   function result notification for attach_process() !

	dbg_process_detach,  // Parameter:  const debug_event_t *event
	//   This event notification is also an asynchronous
	//   function result notification for detach_process() !

	dbg_thread_start,    // Parameter:  const debug_event_t *event

	dbg_thread_exit,     // Parameter:  const debug_event_t *event

	dbg_library_load,    // Parameter:  const debug_event_t *event

	dbg_library_unload,  // Parameter:  const debug_event_t *event

	dbg_information,     // Parameter:  const debug_event_t *event

	dbg_exception,       // Parameters: const debug_event_t *event
	//             int                 *warn = -1
	//             Return (in *warn):
	//              -1 - to display an exception warning dialog
	//                   if the process is suspended.
	//               0 - to never display an exception warning dialog.
	//               1 - to always display an exception warning dialog.

	// debugger high-level event notifications

	dbg_suspend_process, // The process is now suspended.
	// Parameter: const debug_event_t *event
	//   This event notification is also an asynchronous
	//   function result notification for suspend_process() !

	dbg_bpt,             // A user defined breakpoint was reached.
	// Parameters: thid_t tid
	//             ea_t        bptea
	//             int        *warn = -1
	//             Return (in *warn):
	//              -1 - to display a breakpoint warning dialog
	//                   if the process is suspended.
	//               0 - to never display a breakpoint warning dialog.
	//               1 - to always display a breakpoint warning dialog.

	dbg_trace,           // A step occured (one instruction was executed). This event
	// notification is only generated if step tracing is enabled.
	// Parameters: thid_t tid
	//             ea_t        ip
	// Returns: 1-do not log this trace event; 0-log it

	dbg_request_error,   // An error occured during the processing of a request.
	// Parameters: ui_notification_t  failed_command
	//             dbg_notification_t failed_dbg_notification

	dbg_step_into,       // Parameter: const debug_event_t *event

	dbg_step_over,       // Parameter: const debug_event_t *event

	dbg_run_to,          // Parameter: const debug_event_t *event

	dbg_step_until_ret,  // Parameter: const debug_event_t *event

	dbg_bpt_changed,     // Breakpoint has been changed

	inject_dll
};

#define RESULT_SUCCESS 1
#define RESULT_FAILED 0

typedef struct _IDA_SERVER_EXCHANGE
{
	unsigned long result;
	unsigned long notif_code; //server_dbg_notification_t
	unsigned long ProcessId;

	unsigned char EnablePebBeingDebugged;
	unsigned char EnablePebHeapFlags;
	unsigned char EnablePebNtGlobalFlag;
	unsigned char EnablePebStartupInfo;
	unsigned char EnablePebOsBuildNumber;

	unsigned char EnableOutputDebugStringHook;

	unsigned char EnableNtSetInformationThreadHook;
	unsigned char EnableNtQuerySystemInformationHook;
	unsigned char EnableNtQueryInformationProcessHook;
	unsigned char EnableNtSetInformationProcessHook;
	unsigned char EnableNtQueryObjectHook;
	unsigned char EnableNtYieldExecutionHook;
	unsigned char EnableNtCloseHook;
	unsigned char EnableMalwareRunPeUnpacker;

	unsigned char EnablePreventThreadCreation;
	unsigned char EnableNtCreateThreadExHook;

	//Protect and Hide Hardware Breakpoints
	unsigned char EnableNtGetContextThreadHook;
	unsigned char EnableNtSetContextThreadHook;
	unsigned char EnableNtContinueHook;
	unsigned char EnableKiUserExceptionDispatcherHook;

	unsigned char EnableNtUserBlockInputHook;
	unsigned char EnableNtUserQueryWindowHook;
	unsigned char EnableNtUserGetForegroundWindowHook;
	unsigned char EnableNtUserBuildHwndListHook;
	unsigned char EnableNtUserFindWindowExHook;
	unsigned char EnableNtSetDebugFilterStateHook;

	unsigned char EnableGetTickCountHook;
	unsigned char EnableGetTickCount64Hook;
	unsigned char EnableGetLocalTimeHook;
	unsigned char EnableGetSystemTimeHook;
	unsigned char EnableNtQuerySystemTimeHook;
	unsigned char EnableNtQueryPerformanceCounterHook;

	unsigned char DllInjectStealth;
	unsigned char DllInjectNormal;
	unsigned char UnloadDllAfterInjection;
	wchar_t DllPathForInjection[300];
} IDA_SERVER_EXCHANGE;


================================================
File: ScyllaHideIDAServer/ScyllaHideIDAServer.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{4506D672-19C3-439B-8E1B-F1BA8BE28844}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ScyllaHideIDAServer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp" />
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp" />
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp" />
    <ClCompile Include="..\PluginGeneric\Injector.cpp" />
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="idaserver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h" />
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h" />
    <ClInclude Include="..\InjectorCLI\RemoteHook.h" />
    <ClInclude Include="..\PluginGeneric\Injector.h" />
    <ClInclude Include="..\Scylla\VersionPatch.h" />
    <ClInclude Include="idaserver.h" />
    <ClInclude Include="IdaServerExchange.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Icon.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\ghost.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ScyllaHideIDAServer/ScyllaHideIDAServer.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="idaserver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="idaserver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\RemoteHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IdaServerExchange.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Icon.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\ghost.ico">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: ScyllaHideIDAServer/idaserver.cpp
================================================
#include <WinSock2.h>
#include <Scylla/Logger.h>
#include <Scylla/OsInfo.h>
#include <Scylla/Settings.h>
#include <Scylla/Util.h>
#include <Scylla/Version.h>

#include "idaserver.h"
#include "IdaServerExchange.h"
#include "..\PluginGeneric\Injector.h"

#ifdef _WIN64
const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx64.dll";
#else
const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx86.dll";
#endif

scl::Settings g_settings;
scl::Logger g_log;
std::wstring g_scyllaHideDllPath;

HOOK_DLL_DATA g_hdd;

WSADATA wsaData;
char * ListenPortString = IDA_SERVER_DEFAULT_PORT_TEXT;
unsigned short ListenPort = IDA_SERVER_DEFAULT_PORT;
IDA_SERVER_EXCHANGE idaExchange = { 0 };
DWORD ProcessId = 0;
bool bHooked = false;

static void LogCallback(const wchar_t * msg)
{
    _putws(msg);
}

static void checkPaths(const std::wstring & wstrPath)
{
    g_scyllaHideDllPath = wstrPath + g_scyllaHideDllFilename;

    bool missing = false;

    if (!scl::FileExistsW(g_scyllaHideDllPath.c_str()))
    {
        wprintf(L"File is missing: %s\n", g_scyllaHideDllPath.c_str());
        missing = true;
    }

    if (!scl::FileExistsW(g_scyllaHideDllPath.c_str()))
    {
        wprintf(L"File is missing: %s\n", g_scyllaHideDllPath.c_str());
        missing = true;
    }

    if (missing)
    {
        getchar();
        ExitProcess(0);
    }
}

static void startListen()
{
    int iResult;

    SOCKET ListenSocket = INVALID_SOCKET;
    SOCKET ClientSocket = INVALID_SOCKET;

    struct addrinfo *result = NULL;
    struct addrinfo hints;

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;
    hints.ai_flags = AI_PASSIVE;

    // Resolve the server address and port
    iResult = getaddrinfo(NULL, ListenPortString, &hints, &result);
    if (iResult != 0)
    {
        printf("getaddrinfo failed with error: %d\n", iResult);
        WSACleanup();
        return;
    }

    // Create a SOCKET for connecting to server
    ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if (ListenSocket == INVALID_SOCKET)
    {
        printf("socket failed with error: %ld\n", WSAGetLastError());
        freeaddrinfo(result);
        WSACleanup();
        return;
    }

    // Setup the TCP listening socket
    iResult = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);
    if (iResult == SOCKET_ERROR)
    {
        printf("bind failed with error: %d\n", WSAGetLastError());
        freeaddrinfo(result);
        closesocket(ListenSocket);
        WSACleanup();
        return;
    }

    freeaddrinfo(result);

    iResult = listen(ListenSocket, SOMAXCONN);
    if (iResult == SOCKET_ERROR)
    {
        printf("listen failed with error: %d\n", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return;
    }

    printf("Listening on port %s...\n", ListenPortString);

    int count = 0;

    while (1)
    {
        ClientSocket = accept(ListenSocket, NULL, NULL);
        if (ClientSocket == INVALID_SOCKET)
        {
            printf("accept failed with error: %d\n", WSAGetLastError());
            break;
        }
        else
        {
            count++;

            printf("Accepted Client %d\n", count);
            handleClient(ClientSocket);
            closesocket(ClientSocket);
        }
    }

    closesocket(ListenSocket);

    WSACleanup();
}

void MapSettings()
{
    g_settings.opts().dllUnload = idaExchange.UnloadDllAfterInjection;
    g_settings.opts().dllNormal = idaExchange.DllInjectNormal;
    g_settings.opts().dllStealth = idaExchange.DllInjectStealth;
    g_settings.opts().hookKiUserExceptionDispatcher = idaExchange.EnableKiUserExceptionDispatcherHook;
    g_settings.opts().hookNtClose = idaExchange.EnableNtCloseHook;
    g_settings.opts().hookNtContinue = idaExchange.EnableNtCloseHook;
    g_settings.opts().hookNtCreateThreadEx = idaExchange.EnableNtCreateThreadExHook;
    g_settings.opts().hookNtGetContextThread = idaExchange.EnableNtGetContextThreadHook;
    g_settings.opts().hookNtQueryInformationProcess = idaExchange.EnableNtQueryInformationProcessHook;
    g_settings.opts().hookNtQueryObject = idaExchange.EnableNtQueryObjectHook;
    g_settings.opts().hookNtQuerySystemInformation = idaExchange.EnableNtQuerySystemInformationHook;
    g_settings.opts().hookNtSetContextThread = idaExchange.EnableNtSetContextThreadHook;
    g_settings.opts().hookNtSetDebugFilterState = idaExchange.EnableNtSetDebugFilterStateHook;
    g_settings.opts().hookNtSetInformationThread = idaExchange.EnableNtSetInformationThreadHook;
    g_settings.opts().hookNtUserBlockInput = idaExchange.EnableNtUserBlockInputHook;
    g_settings.opts().hookNtUserBuildHwndList = idaExchange.EnableNtUserBuildHwndListHook;
    g_settings.opts().hookNtUserFindWindowEx = idaExchange.EnableNtUserFindWindowExHook;
    g_settings.opts().hookNtUserQueryWindow = idaExchange.EnableNtUserQueryWindowHook;
    g_settings.opts().hookNtYieldExecution = idaExchange.EnableNtYieldExecutionHook;
    g_settings.opts().preventThreadCreation = idaExchange.EnablePreventThreadCreation;
    g_settings.opts().hookOutputDebugStringA = idaExchange.EnableOutputDebugStringHook;
    g_settings.opts().hookNtSetInformationProcess = idaExchange.EnableNtSetInformationProcessHook;

    g_settings.opts().hookGetTickCount = idaExchange.EnableGetTickCountHook;
    g_settings.opts().hookGetTickCount64 = idaExchange.EnableGetTickCount64Hook;
    g_settings.opts().hookGetLocalTime = idaExchange.EnableGetLocalTimeHook;
    g_settings.opts().hookGetSystemTime = idaExchange.EnableGetSystemTimeHook;
    g_settings.opts().hookNtQuerySystemTime = idaExchange.EnableNtQuerySystemTimeHook;
    g_settings.opts().hookNtQueryPerformanceCounter = idaExchange.EnableNtQueryPerformanceCounterHook;

    g_settings.opts().fixPebBeingDebugged = idaExchange.EnablePebBeingDebugged;
    g_settings.opts().fixPebHeapFlags = idaExchange.EnablePebHeapFlags;
    g_settings.opts().fixPebNtGlobalFlag = idaExchange.EnablePebNtGlobalFlag;
    g_settings.opts().fixPebStartupInfo = idaExchange.EnablePebStartupInfo;

    g_settings.opts().malwareRunpeUnpacker = idaExchange.EnableMalwareRunPeUnpacker;
}

static void DoSomeBitCheck()
{
    if (scl::IsWindows64())
    {
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, 0, ProcessId);
        if (hProcess)
        {

#ifdef _WIN64
            if (scl::IsWow64Process(hProcess))
            {
                printf("WARNING: This is a 32bit process and I am 64bit!");
                getchar();
                ExitProcess(0);
            }
#else
            if (!scl::IsWow64Process(hProcess))
            {
                printf("WARNING: This is a 64bit process and I am 32bit!");
                getchar();
                ExitProcess(0);
            }
#endif
            CloseHandle(hProcess);
        }
    }
}

static void handleClient(SOCKET ClientSocket)
{
    int iResult;
    bool once = false;

    do
    {
        iResult = recv(ClientSocket, (char*)&idaExchange, sizeof(IDA_SERVER_EXCHANGE), 0);

        if (iResult == sizeof(IDA_SERVER_EXCHANGE))
        {
            MapSettings();

            switch (idaExchange.notif_code)
            {
            case dbg_process_attach:
            {

                break;
            }
            case dbg_process_start:
            {

                ProcessId = idaExchange.ProcessId;
                bHooked = false;
                ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));

                if (!once)
                {
                    DoSomeBitCheck();
                    once = true;
                }

                if (!bHooked)
                {
                    bHooked = true;
                    startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
                }

                break;
            }
            case dbg_process_exit:
            {

                iResult = -1; //terminate loop
                break;
            }
            case dbg_library_load:
            {

                if (bHooked)
                {
                    startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), false);
                }
                break;
            }

            case inject_dll:
            {
                if (!once)
                {
                    DoSomeBitCheck();
                    once = true;
                }

                injectDll(ProcessId, idaExchange.DllPathForInjection);
                break;
            }
            }

            idaExchange.result = RESULT_SUCCESS;
            send(ClientSocket, (char*)&idaExchange, sizeof(IDA_SERVER_EXCHANGE), 0);
        }
        else if (iResult == 0)
        {
            printf("Connection closing...\n");
        }
        else if (iResult < 0)
        {
            printf("recv failed with error: %d\n", WSAGetLastError());
        }
        else
        {
            printf("Something is wrong, unknown struct size %zd\n", sizeof(IDA_SERVER_EXCHANGE));
        }
    } while (iResult > 0);
}


static BOOL startWinsock()
{
    BOOL isWinsockUp = TRUE;

    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0)
    {
        printf("WSAStartup failed: %d\n", iResult);
        isWinsockUp = FALSE;
    }

    return isWinsockUp;
}

static bool SetDebugPrivileges()
{
    TOKEN_PRIVILEGES Debug_Privileges;
    bool retVal = false;

    if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &Debug_Privileges.Privileges[0].Luid))
    {
        HANDLE hToken = 0;
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
        {
            Debug_Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            Debug_Privileges.PrivilegeCount = 1;

            retVal = AdjustTokenPrivileges(hToken, FALSE, &Debug_Privileges, 0, NULL, NULL) != FALSE;

            CloseHandle(hToken);
        }
    }

    return retVal;
}

int main(int argc, char *argv[])
{
    auto wstrPath = scl::GetModuleFileNameW();
    wstrPath.resize(wstrPath.find_last_of(L'\\') + 1);

    auto log_file = wstrPath + L"scylla_hide_idaserver.log";
    g_log.SetLogFile(log_file.c_str());
    g_log.SetLogCb(scl::Logger::Info, LogCallback);
    g_log.SetLogCb(scl::Logger::Error, LogCallback);

    SetDebugPrivileges();

    printf("%s IDA Server v%s\n", SCYLLA_HIDE_NAME_A, SCYLLA_HIDE_VERSION_STRING_A);

    checkPaths(wstrPath);

    if (argc > 1)
    {
        ListenPortString = argv[1];
        ListenPort = (unsigned short)strtoul(ListenPortString, 0, 10);
    }

    printf("Listen Port: %d (0x%X)\n", ListenPort, ListenPort);

    if (startWinsock())
    {
        //printf("Starting Winsock: DONE\n");
        startListen();
    }


    getchar();
    return 0;
}



================================================
File: ScyllaHideIDAServer/idaserver.h
================================================
#pragma once

#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>

#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")

BOOL startWinsock();
void startListen();
void handleClient( SOCKET ClientSocket );





================================================
File: ScyllaHideIDAServer/resource.h
================================================
[Non-text file]


================================================
File: ScyllaHideOlly1Plugin/ScyllaHideOlly1Plugin.cpp
================================================
#include <codecvt>
#include <locale>
#include <sstream>
#include <Scylla/Logger.h>
#include <Scylla/OsInfo.h>
#include <Scylla/Settings.h>
#include <Scylla/Util.h>
#include <Scylla/Version.h>

#include "..\PluginGeneric\Injector.h"
#include "..\PluginGeneric\OptionsDialog.h"
#include "..\PluginGeneric\AttachDialog.h"
#include "..\PluginGeneric\OllyExceptionHandler.h"

#include "resource.h"
#include "olly1patches.h"


#pragma comment(lib, "ollydbg1\\ollydbg.lib")

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif

#define MENU_PROFILES_OFFSET 10

typedef void(__cdecl * t_AttachProcess)(DWORD dwPID);
typedef void(__cdecl * t_SetDebuggerBreakpoint)(DWORD_PTR address);
typedef bool(__cdecl * t_IsAddressBreakpoint)(DWORD_PTR address);

extern t_AttachProcess _AttachProcess;
extern t_SetDebuggerBreakpoint _SetDebuggerBreakpoint;
extern t_IsAddressBreakpoint _IsAddressBreakpoint;

const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx86.dll";

scl::Settings g_settings;
scl::Logger g_log;
std::wstring g_scyllaHideDllPath;
std::wstring g_scyllaHideIniPath;

HOOK_DLL_DATA g_hdd;

//globals
HINSTANCE hinst;
DWORD ProcessId;
DWORD_PTR epaddr = 0;
bool bHooked = false;
static bool bEPBreakRemoved = false;
HWND hwmain; // Handle of main OllyDbg window
bool bHookedDumpProc = false;

HMODULE hNtdllModule = 0;
bool specialPebFix = false;
LPVOID ImageBase = 0;
bool debugLoopHooked = false;
DEBUG_EVENT *currentDebugEvent;

static void LogCallback(const char *msg)
{
    _Message(0, "[%s] %s", SCYLLA_HIDE_NAME_A, msg);
}

static void LogErrorCallback(const char *msg)
{
    _Error("[%s] %s", SCYLLA_HIDE_NAME_A, msg);
}

static void AttachProcess(DWORD dwPID)
{
    int result = _Attachtoactiveprocess((int)dwPID);

    if (result != 0)
    {
        MessageBoxW(hwmain,
            L"Can't attach to that process !",
            L"ScyllaHide Plugin", MB_OK | MB_ICONERROR);
    }
}

static bool IsAddressBreakpoint(DWORD_PTR address)
{
    t_table* pTable = (t_table*)_Plugingetvalue(VAL_BREAKPOINTS);
    if (pTable)
    {
        t_sorted* pSorted = &(pTable->data);
        for (int i = 0; i < pTable->data.n; i++)
        {
            t_bpoint* bp = (t_bpoint*)_Getsortedbyselection(pSorted, i);
            if (bp)
            {
                //char text[100];
                //wsprintfA(text,"%X %X",bp->addr,address);
                //MessageBoxA(0,text,text,0);
                if (bp->addr == address)
                {
                    return true;
                }
            }
        }
    }

    return false;
}

static void MarkSystemDllsOnx64() {
    const char sysPath[] = "windows\\syswow64";
    char lowerCopy[MAX_PATH] = { 0 };

    int t = _Plugingetvalue(VAL_MODULES);
    if (t <= 0)  {
        _Error("Cannot get module list");
        return;
    }

    t_table* ttab = (t_table*)t;
    t_module* tmod;
    for (int i = 0; i < ttab->data.n; i++)
    {
        tmod = (t_module*)_Getsortedbyselection(&ttab->data, i);

        for (int j = 0; tmod->path[j]; j++) {
            lowerCopy[j] = tolower(tmod->path[j]);
        }

        //skip C:/
        if (strncmp(lowerCopy + 3, sysPath, sizeof(sysPath) - 1) == 0) {
            tmod->issystemdll = 1;
        }
        else {
            //MessageBoxA(0, lowerCopy, "NON",0);
        }

    }
}

static void PrepareDetach() {
    //delete breakpoints

    t_table* pTable = (t_table*)_Plugingetvalue(VAL_BREAKPOINTS);
    if (pTable)
    {
        t_sorted* pSorted = &(pTable->data);

        //IMPORTANT: Reverse index loop
        for (int i = pTable->data.n - 1; i >= 0; i--)
        {
            t_bpoint* pBreakpoint = (t_bpoint*)_Getsortedbyselection(pSorted, i);
            if (pBreakpoint)	{
                _Deletebreakpoints(pBreakpoint->addr, (pBreakpoint->addr) + 1, TRUE);   //silent
            }
        }

    }
}

static void HandleDetachProcess()
{
    t_status tStat = _Getstatus();

    if (tStat != STAT_STOPPED && tStat != STAT_RUNNING)
    {
        MessageBoxW(hwmain, L"Process must be in paused or running mode.", L"Detach Error", MB_ICONERROR);
        return;
    }

    PrepareDetach();

    tStat = _Getstatus();

    if (tStat == STAT_STOPPED) {
        if (currentDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT) {

            HANDLE hThread = OpenThread(THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, currentDebugEvent->dwThreadId);
            if (hThread) {
                CONTEXT context = { 0 };
                context.ContextFlags = CONTEXT_ALL;
                GetThreadContext(hThread, &context);
                context.Eip = (DWORD)currentDebugEvent->u.Exception.ExceptionRecord.ExceptionAddress;
                SetThreadContext(hThread, &context);
                CloseHandle(hThread);

                ContinueDebugEvent(currentDebugEvent->dwProcessId, currentDebugEvent->dwThreadId, DBG_CONTINUE);
            }

        }
        else if (currentDebugEvent->u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_SINGLE_STEP) {
            ContinueDebugEvent(currentDebugEvent->dwProcessId, currentDebugEvent->dwThreadId, DBG_CONTINUE);
        }
        else {
            ContinueDebugEvent(currentDebugEvent->dwProcessId, currentDebugEvent->dwThreadId, DBG_EXCEPTION_NOT_HANDLED);
        }
    }

    DebugSetProcessKillOnExit(FALSE);

    //terminate olly
    ExitProcess(0);
}

//register plugin with name
extern "C" int DLL_EXPORT _ODBG_Plugindata(char shortname[32])
{
    strncpy_s(shortname, 32, SCYLLA_HIDE_NAME_A, _TRUNCATE);
    return PLUGIN_VERSION;
}

//initialization happens in here
extern "C" int DLL_EXPORT _ODBG_Plugininit(int ollydbgversion, HWND hw, unsigned long *features)
{
    if (ollydbgversion < PLUGIN_VERSION)
        return -1;

    hwmain = hw;

    g_settings.Load(g_scyllaHideIniPath.c_str());

    _Addtolist(0, 0, "%s Plugin v%s Copyright (C) 2014 Aguila / cypher", SCYLLA_HIDE_NAME_A, SCYLLA_HIDE_VERSION_STRING_A);

    //do some Olly fixes
    if (g_settings.opts().ollyFixBugs) {
        fixBadPEBugs();
        fixForegroundWindow();
        fixFPUBug();
        fixSprintfBug();
        fixNTSymbols();
        fixFaultyHandleOnExit();
    }
    if (g_settings.opts().ollyX64Fix && scl::IsWindows64()) {
        fixX64Bug();
    }
    if (g_settings.opts().ollySkipEpOutsideCode) {
        patchEPOutsideCode();
    }

    if (g_settings.opts().killAntiAttach) {
        InstallAntiAttachHook();
    }

    if (g_settings.opts().ollyIgnoreBadPeImage) {
        fixBadPEImage();
    }

    if (g_settings.opts().ollyAdvancedGoto) {
        advcancedCtrlG();
    };

    if (g_settings.opts().ollySkipCompressedDoAnalyze || g_settings.opts().ollySkipCompressedDoNothing) {
        skipCompressedCode();
    }

    if (g_settings.opts().ollySkipLoadDllDoLoad || g_settings.opts().ollySkipLoadDllDoNothing) {
        skipLoadDll();
    }
    return 0;
};

// OllyDbg calls this optional function when user wants to terminate OllyDbg.
// All MDI windows created by plugins still exist. Function must return 0 if
// it is safe to terminate. Any non-zero return will stop closing sequence. Do
// not misuse this possibility! Always inform user about the reasons why
// termination is not good and ask for his decision!
extern "C" int DLL_EXPORT _ODBG_Pluginclose(void)
{
    //RestoreAllHooks();
    return 0;
}

//add menu entries
extern "C" int DLL_EXPORT _ODBG_Pluginmenu(int origin, char data[4096], void *item)
{
    switch (origin)
    {
    case PM_MAIN:
    {
        std::stringstream ssMenu;
        ssMenu << "0 & Options, 4 & Load Profile{";
        for (size_t i = 0; i < g_settings.profile_names().size(); i++)
        {
            ssMenu << (i + MENU_PROFILES_OFFSET) << ' ' << scl::wstr_conv().to_bytes(g_settings.profile_names()[i].c_str()) << ",";
        }
        ssMenu << "},|2 &Inject DLL|5 &Attach process, 6 &Detach process|1 &About";
        strncpy_s(data, 4096, ssMenu.str().c_str(), ssMenu.str().size());

        //also patch olly title
        SetWindowTextW(hwmain, g_settings.opts().ollyWindowTitle.c_str());
        return 1;
    }
    case PM_THREADS:
    {
        strncpy_s(data, 4096, "0 &Resume all Threads, 1 &Suspend all Threads", _TRUNCATE);
        return 1;
    }

    default:
        break;
    }


    return 0;
}

//handle plugin actions
extern "C" void DLL_EXPORT _ODBG_Pluginaction(int origin, int action, void *item)
{
    if (origin == PM_MAIN) {
        switch (action)
        {
        case 0:
        {
            DialogBoxW(hinst, MAKEINTRESOURCE(IDD_OPTIONS), hwmain, &OptionsDlgProc);
            break;
        }
        case 1:
        {
            scl::ShowAboutBox(hwmain);

            break;
        }
        case 2:
        {
            if (ProcessId) {
                wchar_t dllPath[MAX_PATH] = {};
                if (scl::GetFileDialogW(dllPath, _countof(dllPath)))
                    injectDll(ProcessId, dllPath);
            }
            break;
        }
        case 5:
        {
            DialogBox(hinst, MAKEINTRESOURCE(IDD_ATTACH), hwmain, &AttachProc);
            break;
        }
        case 6:
        {
            HandleDetachProcess();
            break;
        }

        default: {
            //profile names/count is dynamic so we catch loading them with default case
            g_settings.SetProfile(g_settings.profile_names()[action - MENU_PROFILES_OFFSET].c_str());

            if (ProcessId)
            {
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
                bHooked = true;
                MessageBoxA(hwmain, "Applied changes! Restarting target is NOT necessary!", "[ScyllaHide Options]", MB_OK | MB_ICONINFORMATION);
            }
            else
            {
                MessageBoxA(hwmain, "Please start the target to apply changes!", "[ScyllaHide Options]", MB_OK | MB_ICONINFORMATION);
            }
        }
                 break;
        }
    }
    else if (origin == PM_THREADS) {
        t_table* threadWindow = (t_table*)_Plugingetvalue(VAL_THREADS);
        int threadCount = threadWindow->data.n;
        int threadSize = threadWindow->data.itemsize;
        t_thread* thread = (t_thread*)threadWindow->data.data;

        switch (action)
        {
        case 0:
        {
            //resume
            for (int i = 0; i < threadCount; i++) {
                ResumeThread(thread->thread);

                //yup this is super-hacky-pointer-kungfu but thread++ wont work coz there
                //is 0x20bytes extra data between thread elements
                thread = reinterpret_cast<t_thread*>((DWORD)thread + threadSize);
            }
            break;
        }
        case 1:
        {
            //suspend
            for (int i = 0; i < threadCount; i++) {
                SuspendThread(thread->thread);

                //yup this is super-hacky-pointer-kungfu but thread++ wont work coz there
                //is 0x20bytes extra data between thread elements
                thread = reinterpret_cast<t_thread*>((DWORD)thread + threadSize);
            }
            break;
        }
        }
    }
}

//called for every debugloop pass
extern "C" void DLL_EXPORT _ODBG_Pluginmainloop(DEBUG_EVENT *debugevent)
{
    if (!debugevent)
        return;

    if (g_settings.opts().fixPebHeapFlags)
    {
        if (specialPebFix)
        {
            StartFixBeingDebugged(ProcessId, false);
            specialPebFix = false;
        }

        if (debugevent->u.LoadDll.lpBaseOfDll == hNtdllModule)
        {
            StartFixBeingDebugged(ProcessId, true);
            specialPebFix = true;
        }
    }

    switch (debugevent->dwDebugEventCode)
    {
    case CREATE_PROCESS_DEBUG_EVENT:
    {

        if (g_settings.opts().handleExceptionPrint ||
            g_settings.opts().handleExceptionRip ||
            g_settings.opts().handleExceptionIllegalInstruction ||
            g_settings.opts().handleExceptionInvalidLockSequence ||
            g_settings.opts().handleExceptionNoncontinuableException ||
            g_settings.opts().handleExceptionBreakpoint ||
            g_settings.opts().handleExceptionWx86Breakpoint ||
            g_settings.opts().handleExceptionGuardPageViolation
            )
        {
            if (!debugLoopHooked)
            {
                HookDebugLoop();
                debugLoopHooked = true;
            }
        }

        ImageBase = debugevent->u.CreateProcessInfo.lpBaseOfImage;
        ProcessId = debugevent->dwProcessId;
        bHooked = false;
        epaddr = (DWORD_PTR)debugevent->u.CreateProcessInfo.lpStartAddress;

        if (epaddr == NULL)
        {
            //ATTACH to an existing process!
            //Apply anti-anti-attach
            if (g_settings.opts().killAntiAttach)
            {
                if (!ApplyAntiAntiAttach(ProcessId))
                {
                    MessageBoxW(hwmain, L"Anti-Anti-Attach failed", L"Error", MB_ICONERROR);
                }
            }
        }

        ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));

        //change olly caption again !
        SetWindowTextW(hwmain, g_settings.opts().ollyWindowTitle.c_str());

        if (!bHookedDumpProc) {
            hookOllyWindowProcs();
            bHookedDumpProc = true;
        }
        hookOllyBreakpoints();
    }
    break;

    case LOAD_DLL_DEBUG_EVENT:
    {
        if (bHooked)
        {
            if (g_settings.opts().ollyFixBugs && scl::IsWindows64()) {
                MarkSystemDllsOnx64();
            }

            startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), false);
        }
        break;
    }
    case EXCEPTION_DEBUG_EVENT:
    {
        currentDebugEvent = debugevent;

        switch (debugevent->u.Exception.ExceptionRecord.ExceptionCode)
        {
        case STATUS_BREAKPOINT:
        {
            if (!bHooked)
            {
                ReadNtApiInformation(&g_hdd);

                bHooked = true;
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
            }

            break;
        }

        case STATUS_ILLEGAL_INSTRUCTION:
        {
            //THEMIDA
            break;
        }
        }

        break;
    }
    }
}

//reset variables. new target started or restarted
extern "C" void DLL_EXPORT _ODBG_Pluginreset(void)
{
    ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));
    bHooked = false;
    bEPBreakRemoved = false;
    ProcessId = 0;
}

BOOL WINAPI DllMain(HINSTANCE hInstDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        hinst = hInstDll;
        _AttachProcess = AttachProcess;
        _IsAddressBreakpoint = IsAddressBreakpoint;
        hNtdllModule = GetModuleHandleW(L"ntdll.dll");

        auto wstrPath = scl::GetModuleFileNameW(hInstDll);
        wstrPath.resize(wstrPath.find_last_of(L'\\') + 1);

        g_scyllaHideDllPath = wstrPath + g_scyllaHideDllFilename;
        g_scyllaHideIniPath = wstrPath + scl::Settings::kFileName;

        auto log_file = wstrPath + scl::Logger::kFileName;
        g_log.SetLogFile(log_file.c_str());
        g_log.SetLogCb(scl::Logger::Info, LogCallback);
        g_log.SetLogCb(scl::Logger::Error, LogErrorCallback);
    }

    return TRUE;
};



================================================
File: ScyllaHideOlly1Plugin/ScyllaHideOlly1Plugin.rc
================================================
[Non-text file]


================================================
File: ScyllaHideOlly1Plugin/ScyllaHideOlly1Plugin.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{79774D44-ED2A-4FD2-9224-40AF0A590410}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ScyllaHideOlly1Plugin</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEOLLY1PLUGIN_EXPORTS;OLLY1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEOLLY1PLUGIN_EXPORTS;OLLY1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp" />
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp" />
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp" />
    <ClCompile Include="..\PluginGeneric\AttachDialog.cpp" />
    <ClCompile Include="..\PluginGeneric\OllyExceptionHandler.cpp" />
    <ClCompile Include="..\PluginGeneric\Injector.cpp" />
    <ClCompile Include="..\PluginGeneric\OptionsDialog.cpp" />
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="olly1patches.cpp" />
    <ClCompile Include="ScyllaHideOlly1Plugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h" />
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h" />
    <ClInclude Include="..\InjectorCLI\RemoteHook.h" />
    <ClInclude Include="..\PluginGeneric\AttachDialog.h" />
    <ClInclude Include="..\PluginGeneric\OllyExceptionHandler.h" />
    <ClInclude Include="..\PluginGeneric\Injector.h" />
    <ClInclude Include="..\PluginGeneric\OptionsDialog.h" />
    <ClInclude Include="..\Scylla\VersionPatch.h" />
    <ClInclude Include="olly1patches.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ScyllaHideOlly1Plugin.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\findere.bmp" />
    <None Include="..\PluginGeneric\finderf.bmp" />
    <None Include="..\PluginGeneric\searchwindow.cur" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ScyllaHideOlly1Plugin/ScyllaHideOlly1Plugin.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ScyllaHideOlly1Plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="olly1patches.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\OptionsDialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\AttachDialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\OllyExceptionHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\RemoteHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="olly1patches.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\OptionsDialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\AttachDialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\OllyExceptionHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ScyllaHideOlly1Plugin.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\finderf.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\PluginGeneric\findere.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\PluginGeneric\searchwindow.cur">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: ScyllaHideOlly1Plugin/olly1patches.cpp
================================================
#include "olly1patches.h"
#include <Windows.h>
#include <TlHelp32.h>
#include <string>
#include <Scylla/Logger.h>
#include <Scylla/Settings.h>

#include "resource.h"


extern scl::Settings g_settings;
extern scl::Logger g_log;

extern HINSTANCE hinst;
extern LPVOID ImageBase;
extern DWORD ProcessId;
extern DWORD_PTR epaddr;

//naked declarations for handleSprintf
DWORD pFormat;
DWORD retAddr;
//naked declarations for advancedCTRL-G hooks
DWORD lpBase;
HWND hGotoDialog;
MODULEENTRY32 moduleinfo;
HANDLE hSnap;
WPARAM wparam;
char orgExpression[100];
DWORD pOrgExpr;
int selectedType;
DWORD buffer = 0;

HWND hDump;
HWND hDasm;

//taken from strongOD aka "fix NumOfRvaAndSizes"
void fixBadPEBugs()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);
    BOOL fixed = FALSE;

    BYTE peBug1Fix[] = {0xEB}; //JE (74 1C) to JMP (EB 1C)
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x5C671), &peBug1Fix, sizeof(peBug1Fix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed PE-Bug at 0x5C671");

    /*
    Fixed:
    0045D827  |. 74 79          ||JE SHORT OLLYDBG.0045D8A2
    0045D829  |? 893CCA         MOV DWORD PTR DS:[EDX+ECX*8],EDI
    Unpatched:
    0045D827  |. 893CCA         ||MOV DWORD PTR DS:[EDX+ECX*8],EDI
    0045D82A  |. 74 76          ||JE SHORT OLLYDBG.0045D8A2
    */
    BYTE peBug2Fix[] = {0x74,0x79,0x89,0x3C,0xCA};
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x5D827), &peBug2Fix, sizeof(peBug2Fix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed PE-Bug at 0x5D827");

    /*
    0045D8B7  |> 90             |NOP
    0045D8B8  |? 90             NOP
    0045D8B9  |? 90             NOP
    0045D8BA  |. 90             |NOP
    0045D8BB  |? 90             NOP
    0045D8BC  |? 90             NOP
    Unpatched:
    0045D8B7  |> 83C0 03        |ADD EAX,3
    0045D8BA  |. 83E0 FC        |AND EAX,FFFFFFFC
    */
    BYTE peBug3Fix[] = {0x90,0x90,0x90,0x90,0x90,0x90};
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x5D8B7), &peBug3Fix, sizeof(peBug3Fix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed PE-Bug at 0x5D8B7");

    /*
    004C870A   2B31             SUB ESI,DWORD PTR DS:[ECX]
    004C870C   382B             CMP BYTE PTR DS:[EBX],CH
    004C870E   25 422A3238      AND EAX,38322A42
    004C8713   2020             AND BYTE PTR DS:[EAX],AH
    004C8715   2020             AND BYTE PTR DS:[EAX],AH
    004C8717   2020             AND BYTE PTR DS:[EAX],AH
    004C8719   2020             AND BYTE PTR DS:[EAX],AH
    004C871B   2020             AND BYTE PTR DS:[EAX],AH
    Unpatched:
    004C870A   2D 36382B5B      SUB EAX,5B2B3836
    004C870F   25 412B3734      AND EAX,34372B41
    004C8714   5D               POP EBP
    004C8715   2A38             SUB BH,BYTE PTR DS:[EAX]
    004C8717   2B25 422A3238    SUB ESP,DWORD PTR DS:[38322A42]
    */
    BYTE peBug4Fix[] = {0x2B,0x31,0x38,0x2B,0x25,0x42,0x2A,0x32,0x38,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20};
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0xC870A), &peBug4Fix, sizeof(peBug4Fix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed PE-Bug at 0xC870A");
}

//taken from strongOD
void fixForegroundWindow()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);
    BOOL fixed = false;

    BYTE fgWinFix[] = {0xEB}; //JNZ (75 1C) to JMP (EB 1C)
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x3A1FB), &fgWinFix, sizeof(fgWinFix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed ForegroundWindow at 0x3A1FB");
}

//taken from http://waleedassar.blogspot.de/2012/03/ollydbg-v110-and-wow64.html
void fixX64Bug()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);
    BOOL fixed = false;

    BYTE x64Patch[] = {0xEB}; //JE to JMP
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x311C2), &x64Patch, sizeof(x64Patch), NULL);
    if(fixed) _Addtolist(0,-1,"Patched single-step break on x64 at 0x311C2");
}

//taken from POISON source https://tuts4you.com/download.php?view.2281
void fixFPUBug()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);
    BOOL fixed = false;

    BYTE fpuBugFix[] = {0xDB};
    BYTE buf[1];
    ReadProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0xAA2F0), &buf, 1, NULL);
    if(buf[0] == 0xDB)
        fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0xAA2F2), &fpuBugFix, sizeof(fpuBugFix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed FPU-Bug at 0xAA2F2");
}

//taken from olly-advanced RVA 8225+385
void fixSprintfBug()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);

    DWORD sprintf = (DWORD)handleSprintf;
    DWORD patchAddr = 0xA74D0;
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &sprintf, 4, NULL);
    patchAddr -= 1;
    BYTE push[] = {0x68};
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &push, sizeof(push), NULL);
    patchAddr += 5;
    BYTE retn[] = {0xC3};
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &retn, sizeof(retn), NULL);

    _Addtolist(0,-1,"Patched sprintf bug at 0xA74CF");
}

//logic taken from olly-advanced RVA 76AF and modified
void __declspec(naked) handleSprintf()
{
    _asm {
        pushfd
        pushad
        mov pFormat, edx
        pushad
    };

    retAddr = (DWORD)GetModuleHandle(NULL);

    if(IsBadCodePtr((FARPROC) pFormat)==0) {
        //all good
        _asm {
            popad
            cmp byte ptr[edx], 0 //stolen bytes
            jz goback
            add retAddr, 0xa74c2
            popad
            popfd
            jmp [retAddr]

            goback:
            add retAddr, 0xa759e
        }
    } else {
        //a crash would have happened
        _asm {
            popad
            add retAddr, 0xa759e
        };

    }

    _asm {
        popad
        popfd
        jmp [retAddr]
    };
}

//taken from OllyAdvanced patch function at RVA 8225+3A0
void patchEPOutsideCode()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);
    BOOL fixed = false;

    BYTE EPOutsideFix[] = {0x83,0xC4,0x10,0x90,0x90}; //call MessageBoxA to "add esp,0x10;nop;nop"
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x5DB81), &EPOutsideFix, sizeof(EPOutsideFix), NULL);
    if(fixed) _Addtolist(0,-1,"Patched EP outside of code message at 0x3A1FB");
}

//taken from POISON source https://tuts4you.com/download.php?view.2281
void hookOllyBreakpoints()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);

    DWORD breakpoints = (DWORD)handleBreakpoints;
    DWORD patchAddr = 0x2F91D;
    breakpoints -= lpBaseAddr;
    breakpoints -= patchAddr;
    patchAddr -= 4;
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &breakpoints, 4, NULL);
    patchAddr -= 1;
    BYTE call[] = {0xE8};
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &call, sizeof(call), NULL);

    _Addtolist(0,-1,"Hooked Olly Breakpoints handler for TLS at 0x2F918");
}

void __declspec(naked) handleBreakpoints()
{
    _asm { pushad };

    if (g_settings.opts().ollyRemoveEpBreak)
    {
        CreateThread(NULL, NULL, removeEPBreak, NULL, NULL, NULL);
    }

    if (g_settings.opts().ollyBreakOnTls)
    {
        ReadTlsAndSetBreakpoints(ProcessId, (LPVOID)ImageBase);
    }

    //replay stolen bytes and adjust return address
    _asm {
        popad
        CMP DWORD PTR DS:[004D734Ch],0
        mov dword ptr [esp], 0042F91Fh
        ret
    };
}

DWORD _stdcall removeEPBreak(LPVOID lpParam)
{
    Sleep(0x200);
    if (epaddr != NULL)
    {
        _Deletebreakpoints(epaddr,epaddr+2, 0);
    }
    return 0;
}

void ReadTlsAndSetBreakpoints(DWORD dwProcessId, LPVOID baseofImage)
{
    BYTE memory[0x1000] = {0};
    IMAGE_TLS_DIRECTORY tlsDir = {0};
    PVOID callbacks[64] = {0};
	CHAR label[100] = {0};

    HANDLE hProcess = OpenProcess(PROCESS_VM_READ, 0, dwProcessId);

    if (!hProcess)
        return;

    ReadProcessMemory(hProcess, baseofImage, memory, sizeof(memory), 0);

    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)memory;
    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDos + pDos->e_lfanew);
    if (pNt->Signature == IMAGE_NT_SIGNATURE)
    {
        if (pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress)
        {
            //g_log.LogDebug("TLS directory %X found", pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);

            ReadProcessMemory(hProcess, (PVOID)((DWORD_PTR)baseofImage + pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress), &tlsDir, sizeof(IMAGE_TLS_DIRECTORY), 0);

            if (tlsDir.AddressOfCallBacks)
            {
                //g_log.LogDebug("TLS AddressOfCallBacks %X found", tlsDir.AddressOfCallBacks);

                ReadProcessMemory(hProcess, (PVOID)tlsDir.AddressOfCallBacks, callbacks, sizeof(callbacks), 0);

                for (int i = 0; i < _countof(callbacks); i++)
                {
                    if (callbacks[i])
                    {
                        g_log.LogInfo(L"TLS callback found: Index %d Address %X", i, callbacks[i]);
                        _Tempbreakpoint((DWORD)callbacks[i], TY_ONESHOT);

						sprintf(label, "TLS_CALLBACK_%d", i+1);
						_Insertname((DWORD)callbacks[i], NM_LABEL, label);
						_Insertname((DWORD)callbacks[i], NM_COMMENT, label);
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
    }

    CloseHandle(hProcess);
}

//NOTE: for this to work IDC_EXPRESSION _NEEDS_ to be 5101, same as equivalent control in orig Olly
void advcancedCtrlG()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);

    DWORD patchAddr = 0x4376C;
    BYTE push[] = {0x68};
    BYTE nopnop[] = {0x90,0x90};
    //patch Hinstance param of DialogBoxParamA call
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &push, sizeof(push), NULL);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr+1), &hinst, sizeof(HINSTANCE), NULL);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr+5), &nopnop, sizeof(nopnop), NULL);
    //patch templatename
    DWORD resourceId = (DWORD)MAKEINTRESOURCE(IDD_GOTO);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr-4), &resourceId, sizeof(DWORD), NULL);

    //hook WMCOMMAND and WMINIT and forwarding of entered value for the goto dialog
    BYTE retn[] = {0xC3};
    DWORD hookWMINITaddr = 0x432D0;
    DWORD hookWMINIT = (DWORD)advancedCtrlG_WMINIT;
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookWMINITaddr), &push, sizeof(push), NULL);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookWMINITaddr+1), &hookWMINIT, sizeof(DWORD), NULL);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookWMINITaddr+5), &retn, sizeof(retn), NULL);

    DWORD hookWMCOMMANDaddr = 0x4349A;
    DWORD hookWMCOMMAND = (DWORD)advancedCtrlG_WMCOMMAND;
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookWMCOMMANDaddr), &push, sizeof(push), NULL);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookWMCOMMANDaddr+1), &hookWMCOMMAND, sizeof(DWORD), NULL);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookWMCOMMANDaddr+5), &retn, sizeof(retn), NULL);

    DWORD hookSaveAddr = 0x43682;
    DWORD hookSave = (DWORD)advancedCtrlG_Save;
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookSaveAddr), &push, sizeof(push), NULL);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookSaveAddr+1), &hookSave, sizeof(DWORD), NULL);
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+hookSaveAddr+5), &retn, sizeof(retn), NULL);
}

void __declspec(naked) advancedCtrlG_WMINIT()
{
    lpBase = (DWORD)GetModuleHandle(NULL);
    _asm { mov hGotoDialog, esi };

    //stolen bytes
    _asm {
        mov edx,lpBase
        add edx,0e3B68h
        mov edx,dword ptr [edx]
        push edx
    };
    _asm { pushad };

    //handle WM_INIT
    CheckDlgButton(hGotoDialog, IDC_RADIOVA, BST_CHECKED);

    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcessId);
    moduleinfo.dwSize = sizeof(MODULEENTRY32W);
    Module32FirstW(hSnap, &moduleinfo);

    do {
        SendMessageW(GetDlgItem(hGotoDialog, IDC_MODULES), CB_ADDSTRING, 0, (LPARAM)moduleinfo.szModule);
    }
    while(Module32NextW(hSnap, &moduleinfo) == TRUE);
    CloseHandle(hSnap);
    SendMessageW(GetDlgItem(hGotoDialog, IDC_MODULES), CB_SETCURSEL, 0, 0);
    //end handle WM_INIT

    _asm {
        add lpBase, 0x432d7
        popad
        jmp [lpBase]
    };
}

void __declspec(naked) advancedCtrlG_WMCOMMAND()
{
    //stolen bytes
    _asm {
        mov edx,ebx
        and dx,0FFFFh
    };
    //end stolen bytes

    lpBase = (DWORD)GetModuleHandle(NULL);
    _asm {
        mov hGotoDialog, esi
        mov wparam, edx
    };

    //handle WM_COMMAND
    if(wparam == IDC_RADIOVA) {
        ShowWindow(GetDlgItem(hGotoDialog, IDC_MODULES), SW_HIDE);
    }
    else if(wparam == IDC_RADIORVA || wparam == IDC_RADIOOFFSET) {
        ShowWindow(GetDlgItem(hGotoDialog, IDC_MODULES), SW_SHOW);
    }

    if(wparam == IDOK ) {
        _asm { pushad };

        if(IsDlgButtonChecked(hGotoDialog, IDC_RADIOVA) == 1) {
            selectedType = 1;
            //do nothing, VA is same as original olly does, so just jump back
            _asm {
                popad
                add lpBase, 0x434ab
                jmp [lpBase]
            };
        }
        else if(IsDlgButtonChecked(hGotoDialog, IDC_RADIORVA) == 1) {
            selectedType = ADDR_TYPE_RVA;
            if(advancedCtrlG_handleGotoExpression(ADDR_TYPE_RVA)) {
                _asm {
                    popad
                    add lpBase, 0x434ab
                    jmp [lpBase]
                };
            }
        }
        else if(IsDlgButtonChecked(hGotoDialog, IDC_RADIOOFFSET) == 1) {
            selectedType = ADDR_TYPE_OFFSET;
            if(advancedCtrlG_handleGotoExpression(ADDR_TYPE_OFFSET)) {
                _asm {
                    popad
                    add lpBase, 0x434ab
                    jmp [lpBase]
                };
            }
        }

        _asm { popad };
    }
    //end handle WM_COMMAND

    _asm {
        add lpBase, 0x434a5
        jmp [lpBase]
    };
}

char expression[100] = {0};
BYTE tempMemory[0x1000] = {0};

DWORD ConvertOffsetToRVA( const WCHAR * szExePath, DWORD offset )
{
    DWORD result = 0;
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)tempMemory;
    PIMAGE_NT_HEADERS pNt = 0;
    DWORD lpNumberOfBytesRead = 0;
    LARGE_INTEGER lpFileSize = {0};
    HANDLE hFile = CreateFileW(szExePath, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        GetFileSizeEx(hFile, &lpFileSize);
        long filesize = (long)lpFileSize.QuadPart;

        if (filesize > sizeof(tempMemory))
        {
            filesize = sizeof(tempMemory);
        }

        if (ReadFile(hFile, tempMemory, filesize, &lpNumberOfBytesRead, 0))
        {
            pNt = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDosHeader + pDosHeader->e_lfanew);
            PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNt);

            if (offset < pSection->PointerToRawData) //before the first section...
            {
                result = offset;
            }
            else
            {
                for (WORD i = 0; i < pNt->FileHeader.NumberOfSections; i++)
                {
                    if ((pSection->PointerToRawData <= offset) && ((pSection->PointerToRawData + pSection->SizeOfRawData) > offset))
                    {
                        result = ((offset - pSection->PointerToRawData) + pSection->VirtualAddress);
                        break;
                    }

                    pSection++;
                }
            }

        }

        CloseHandle(hFile);
    }

    return result;
}

bool advancedCtrlG_handleGotoExpression(int addrType)
{
    lpBase = (DWORD)GetModuleHandle(NULL);


    if (!GetDlgItemTextA(hGotoDialog, IDC_EXPRESSION, expression, sizeof(expression)))
    {
        SetDlgItemTextA(hGotoDialog, IDC_ERROR, "Address wrong!");
        return false;
    }
    int len = strlen(expression);

    if(len>=9) { //bad address
        SetDlgItemTextA(hGotoDialog, IDC_ERROR, "Address too long!");
        return false;
        /*
        _asm {
            add esp,4
            popad
            add lpBase, 0x436a5
            jmp [lpBase]
        };*/
    } else if (len == 0) {
        SetDlgItemTextA(hGotoDialog, IDC_ERROR, "Address wrong!");
        return false;
    }

    DWORD addrToFind = strtoul(expression, 0, 16);

    if (addrToFind == 0)
    {
        SetDlgItemTextA(hGotoDialog, IDC_ERROR, "Address wrong!");
        return false;
    }

    //copy original expression for history with style
    wsprintfA(orgExpression, "%X", addrToFind);
    pOrgExpr = (DWORD)orgExpression;

    int selectedModule = SendMessage(GetDlgItem(hGotoDialog, IDC_MODULES), CB_GETCURSEL, 0, 0);

    hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcessId);
    moduleinfo.dwSize = sizeof(MODULEENTRY32);
    Module32FirstW(hSnap, &moduleinfo);

    //step to the selected module
    while(selectedModule!=0) {
        Module32NextW(hSnap, &moduleinfo);
        selectedModule--;
    }

    //calc the VA based on the passed RVA/Offset

    if(addrType == ADDR_TYPE_OFFSET)
    {
        addrToFind = ConvertOffsetToRVA(moduleinfo.szExePath, addrToFind);
        if (addrToFind == 0)
        {
            SetDlgItemTextA(hGotoDialog, IDC_ERROR, "Invalid offset address!");
            return false;
        }
    }

    if(addrType == ADDR_TYPE_RVA || addrType == ADDR_TYPE_OFFSET) {
        addrToFind += (DWORD)moduleinfo.modBaseAddr;
        wsprintfA(expression, "%08X", addrToFind);
        SetDlgItemTextA(hGotoDialog, IDC_EXPRESSION, expression);
    }

    CloseHandle(hSnap);

    return true;
}

void __declspec(naked) advancedCtrlG_Save()
{
    lpBase = (DWORD)GetModuleHandle(NULL);

    _asm {
        mov eax, dword ptr[esp]
        mov buffer, eax
    };

    //this is for adding the RVA/Offset value user typed in to the Goto history
    //instead of the calculated VA
    if(buffer==1 && selectedType!=1) {
        _asm {
            mov eax, pOrgExpr
            mov dword ptr [esp+8], eax
        };
    }

    _asm {
        mov eax,lpBase
        add eax,0063EFCh
        call eax
        add esp,0ch
        add lpBase, 4368ah
        jmp [lpBase]
    };
}

void fixBadPEImage()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);
    BOOL fixed = FALSE;

    DWORD patchAddr = 0x5D5DF;
    BYTE zero[] = {0x00};
    BYTE eb[] = {0xEB};
    BYTE nopjmp[] = {0x90,0xE9};
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &zero, sizeof(zero), NULL);
    patchAddr = 0x7F30F;
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &eb, sizeof(eb), NULL);
    patchAddr = 0x5d7c9;
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &nopjmp, sizeof(nopjmp), NULL);

    if(fixed) _Addtolist(0,-1,"Patched bad PE image error");
}

void skipCompressedCode()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);

    DWORD patchAddr = 0x7F5C8;
    BYTE patch[] = {0x83,0xC4,0x10,0x90,0x90}; //add esp,10;nop;nop
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &patch, sizeof(patch), NULL);

    if (g_settings.opts().ollySkipCompressedDoAnalyze) {
        BYTE jmp[] = {0xEB};
        WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr+10), &jmp, sizeof(jmp), NULL);
    }
    else if (g_settings.opts().ollySkipCompressedDoNothing) {
        BYTE zero[] = {0x00};
        WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr+11), &zero, sizeof(zero), NULL);
    }
}

void skipLoadDll()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);

    DWORD patchAddr = 0x77709;
    BYTE patch[] = {0x83,0xC4,0x10,0x90,0x90}; //add esp,10;nop;nop
    WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr), &patch, sizeof(patch), NULL);

    if (g_settings.opts().ollySkipLoadDllDoLoad) {
        BYTE jmp[] = {0xEB};
        WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr+8), &jmp, sizeof(jmp), NULL);
    }
    else if (g_settings.opts().ollySkipLoadDllDoNothing) {
        BYTE zero[] = {0x00};
        WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+patchAddr+9), &zero, sizeof(zero), NULL);
    }
}


//Thanks to blabberer
//http://www.woodmann.com/forum/showthread.php?8460-Debug-symbols-information-symbol-server-setup&p=56246&viewfull=1#post56246
//Fix so Olly doesn't override the default symbols search path.
void fixNTSymbols()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);
    BOOL fixed = FALSE;

    //00491107  81CA 10120000    OR EDX,1210
    BYTE ntSym1Fix[] = {0x37,0x02,0x03,0x80}; // change 10120000 to 37020380
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x91109), &ntSym1Fix, sizeof(ntSym1Fix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed load NT Symbols at 0x91109");

    //004911EC  74 2E  JE 0049121C
    BYTE ntSym2Fix[] = {0xEB}; // change 74 to eb
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x911EC), &ntSym2Fix, sizeof(ntSym2Fix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed load NT Symbols at 0x911EC");
}

void fixFaultyHandleOnExit()
{
    HANDLE hOlly = GetCurrentProcess();
    DWORD lpBaseAddr = (DWORD)GetModuleHandle(NULL);
    BOOL fixed = false;

    BYTE faultyHandleFix[] = {0xEB}; //JNZ (75 4D) to JMP (EB 4D)
    fixed = WriteProcessMemory(hOlly, (LPVOID)(lpBaseAddr+0x7599f), &faultyHandleFix, sizeof(faultyHandleFix), NULL);
    if(fixed) _Addtolist(0,-1,"Fixed ERROR_ACCESS_DENIED with faulty handle at 0x7599f");
}

void hookOllyWindowProcs()
{
    t_dump* dump = (t_dump*) _Plugingetvalue(VAL_CPUDDUMP);
    t_dump* dasm = (t_dump*) _Plugingetvalue(VAL_CPUDASM);
    hDump = dump->table.hw;
    hDasm = dasm->table.hw;

    DWORD hookedProc = (DWORD)hookedOllyWindowProc;
    LONG hOllyDumpProc = SetWindowLong(hDump, GWL_WNDPROC, (LONG)hookedProc);
    SetWindowLong(hDump, GWL_USERDATA, hOllyDumpProc);
    LONG hOllyDasmProc = SetWindowLong(hDasm, GWL_WNDPROC, (LONG)hookedProc);
    SetWindowLong(hDasm, GWL_USERDATA, hOllyDasmProc);
}

void memsetRemoteMemory(DWORD startAddress, DWORD endAddress, BYTE byte)
{
	if (endAddress > startAddress)
	{
		DWORD len = endAddress - startAddress;
		BYTE* tempmem = (BYTE*)malloc(len);
		if (tempmem)
		{
			memset(tempmem,byte,len);
			_Writememory(tempmem, startAddress, len, MM_RESTORE | MM_DELANAL);
			free(tempmem);
		}
	}
}

void hookedOllyWindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int window = 0;
    if(hWnd == hDasm) {
        window = VAL_CPUDASM;
    } else {
        window = VAL_CPUDDUMP;
    }
    t_dump* dump = (t_dump*) _Plugingetvalue(window);

	if (!dump)
	{
		MessageBoxW(hWnd, L"t_dump is NULL", L"Error", MB_ICONERROR);
		CallWindowProc((WNDPROC)GetWindowLong(hWnd, GWL_USERDATA), hWnd, message, wParam, lParam);
		return;
	}

    if((message == WM_LBUTTONUP ||
            ((message == WM_LBUTTONDOWN || WM_MOUSEMOVE) && wParam == MK_LBUTTON)) &&
            g_settings.opts().ollyAdvancedInfobar
      )  {
        DWORD startAddr = dump->sel0;
        DWORD endAddr = dump->sel1;

        t_module* module = _Findmodule(startAddr);

        char modName[20] = "unknown";
        char sectName[20] = "unknown";
        if(module != NULL)
		{
			ZeroMemory(modName, sizeof(modName));
            strncpy_s(modName, SHORTLEN, module->name, _TRUNCATE);

            IMAGE_SECTION_HEADER* hdr = module->sect;
            for(int i=0; i<module->nsect; i++) {
                if((hdr->VirtualAddress+module->base) < startAddr && (hdr->VirtualAddress+module->base+hdr->Misc.VirtualSize) > startAddr) {
                    ZeroMemory(sectName, sizeof(sectName));
                    strncpy_s(sectName, SHORTLEN, (char*)hdr->Name, _TRUNCATE);
                    break;
                }

                hdr++;
            }
        }

        _Infoline("VA: 0x%08X -> 0x%08X | Size: 0x%08X Bytes | Module: [%s]%s", startAddr, endAddr, endAddr-startAddr, modName, sectName);
    }
    else if(message == WM_KEYUP) {
        switch(wParam) {
        case VK_DELETE: {
                DWORD startAddr = dump->sel0;
                DWORD endAddr = dump->sel1;

				if (dump->backup == 0)
				{
					_Dumpbackup(dump, BKUP_CREATE);
				}

				memsetRemoteMemory(startAddr, endAddr, 0x90);

        break;
        }
        case VK_INSERT: {
                DWORD startAddr = dump->sel0;
                DWORD endAddr = dump->sel1;

				if (dump->backup == 0)
				{
					_Dumpbackup(dump, BKUP_CREATE);
				}

				memsetRemoteMemory(startAddr, endAddr, 0x00);
        break;
        }
        default: {
                break;
            }
            }
    }

    //forward the call to Olly
    CallWindowProc((WNDPROC)GetWindowLong(hWnd, GWL_USERDATA), hWnd, message, wParam, lParam);
}



================================================
File: ScyllaHideOlly1Plugin/olly1patches.h
================================================
#pragma once

#include <Windows.h>
#pragma pack(push)
#include <ollydbg1/ollyplugindefinitions.h>
#pragma pack(pop)

#define ADDR_TYPE_RVA 2
#define ADDR_TYPE_OFFSET 3

void fixBadPEBugs();
void fixForegroundWindow();
void fixX64Bug();
void fixFPUBug();
void patchEPOutsideCode();
void hookOllyBreakpoints();
void fixSprintfBug();
DWORD _stdcall removeEPBreak(LPVOID lpParam);
void ReadTlsAndSetBreakpoints(DWORD dwProcessId, LPVOID baseofImage);
void advcancedCtrlG();
bool advancedCtrlG_handleGotoExpression(int addrType);
void fixBadPEImage();
void skipCompressedCode();
void skipLoadDll();
void fixNTSymbols();
void fixFaultyHandleOnExit();
void hookOllyWindowProcs();

//hooks
void handleBreakpoints();
void handleSprintf();
void advancedCtrlG_WMINIT();
void advancedCtrlG_WMCOMMAND();
void advancedCtrlG_Save();
void hookedOllyWindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);



================================================
File: ScyllaHideOlly1Plugin/resource.h
================================================
[Non-text file]


================================================
File: ScyllaHideOlly2Plugin/ScyllaHideOlly2Plugin.cpp
================================================
#include <windows.h>
#include <cstdio>
#pragma pack(push)
#include <ollydbg2/plugin.h>
#pragma pack(pop)
#include <Scylla/Logger.h>
#include <Scylla/OsInfo.h>
#include <Scylla/Settings.h>
#include <Scylla/Util.h>
#include <Scylla/Version.h>

#include "..\PluginGeneric\Injector.h"
#include "..\PluginGeneric\OptionsDialog.h"
#include "..\PluginGeneric\AttachDialog.h"
#include "..\PluginGeneric\OllyExceptionHandler.h"

#include "resource.h"

#pragma comment(lib, "ollydbg2\\ollydbg.lib")

#define OLLY201_Attachtoactiveprocess_VA 0x44B108
#define OLLY201_Attachtoactiveprocess_CHECKVALUE 0x55 // PUSH EBP

#define MAX_PROFILES 128

typedef int(__cdecl * t_Attachtoactiveprocess)(int newprocessid);
typedef void(__cdecl * t_AttachProcess)(DWORD dwPID);

extern t_AttachProcess _AttachProcess;

const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx86.dll";

scl::Settings g_settings;
scl::Logger g_log;
std::wstring g_scyllaHideDllPath;
std::wstring g_scyllaHideIniPath;

HOOK_DLL_DATA g_hdd;

HINSTANCE hinst;
HMODULE hNtdllModule = 0;
bool specialPebFix = false;
bool debugLoopHooked = false;
DWORD ProcessId = 0;
bool bHooked = false;

static t_menu profilemenu[MAX_PROFILES];

static void LogCallback(const wchar_t *msg)
{
    Message(0, L"[%s] %s", SCYLLA_HIDE_NAME_W, msg);
}

static void LogErrorCallback(const wchar_t *msg)
{
    Error(L"[%s] %s", SCYLLA_HIDE_NAME_W, msg);
}

static void AttachProcess(DWORD dwPID)
{
    t_Attachtoactiveprocess _Attachtoactiveprocess = (t_Attachtoactiveprocess)OLLY201_Attachtoactiveprocess_VA;
    BYTE * pCheck = (BYTE *)OLLY201_Attachtoactiveprocess_VA;

    if (*pCheck == OLLY201_Attachtoactiveprocess_CHECKVALUE)
    {
        int result = _Attachtoactiveprocess((int)dwPID);
        if (result == 0)
        {
            Setstatus(STAT_ATTACHING);
        }
        else
        {
            //Olly displays an error message
            //MessageBoxW(hwollymain,
            //	L"Can't attach to that process !",
            //	L"ScyllaHide Plugin",MB_OK|MB_ICONERROR);
        }
    }
    else
    {
        MessageBoxW(hwollymain, L"Your Olly Version is not supported! Please use version 201 http://www.ollydbg.de/odbg201.zip", L"ERROR", MB_ICONERROR);
    }
}

//Menu->Options
static int Moptions(t_table *pt, wchar_t *name, ulong index, int mode)
{
    if (mode == MENU_VERIFY)
        return MENU_NORMAL;
    else if (mode == MENU_EXECUTE)
    {
        DialogBoxW(hinst, MAKEINTRESOURCE(IDD_OPTIONS), hwollymain, &OptionsDlgProc);
        return MENU_REDRAW;
    };
    return MENU_ABSENT;
}

//Menu->Load Profile
static int Mprofiles(t_table *pt, wchar_t *name, ulong index, int mode)
{
    if (mode == MENU_VERIFY) {
        if (name == g_settings.profile_name())
            return MENU_CHECKED;

        return MENU_NORMAL;
    }
    else if (mode == MENU_EXECUTE)
    {
        g_settings.SetProfile(g_settings.profile_names()[index].c_str());

        if (ProcessId)
        {
            startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
            bHooked = true;
            MessageBoxA(hwollymain, "Applied changes! Restarting target is NOT necessary!", "[ScyllaHide Options]", MB_OK | MB_ICONINFORMATION);
        }
        else
        {
            MessageBoxA(hwollymain, "Please start the target to apply changes!", "[ScyllaHide Options]", MB_OK | MB_ICONINFORMATION);
        }

        return MENU_REDRAW;
    };
    return MENU_ABSENT;
}

//Menu->Inject DLL
static int MinjectDll(t_table *pt, wchar_t *name, ulong index, int mode)
{
    if (mode == MENU_VERIFY)
        if (!ProcessId) return MENU_GRAYED;
        else return MENU_NORMAL;
    else if (mode == MENU_EXECUTE)
    {
        wchar_t dllPath[MAX_PATH] = {};
        if (scl::GetFileDialogW(dllPath, _countof(dllPath)))
            injectDll(ProcessId, dllPath);

        return MENU_REDRAW;
    };
    return MENU_ABSENT;
}

//Menu->Attach Process
static int MattachProcess(t_table *pt, wchar_t *name, ulong index, int mode)
{
    if (mode == MENU_VERIFY)
        return MENU_NORMAL;
    else if (mode == MENU_EXECUTE)
    {
        DialogBox(hinst, MAKEINTRESOURCE(IDD_ATTACH), hwollymain, &AttachProc);
        return MENU_REDRAW;
    };
    return MENU_ABSENT;
}

//Context Menu in Thread window -> Suspend/Resume all Threads
static int Mthreads(t_table *pt, wchar_t *name, ulong index, int mode)
{
    if (mode == MENU_VERIFY)
        return MENU_NORMAL;
    else if (mode == MENU_EXECUTE)
    {
        t_table threadWindow = thread;
        int threadCount = threadWindow.sorted.n;
        int threadSize = threadWindow.sorted.itemsize;
        t_thread* threadData = (t_thread*)threadWindow.sorted.data;

        switch (index)
        {
        case 0:
        {
            //Resumeallthreads(); doesnt work as expected
            for (int i = 0; i < threadCount; i++) {
                ResumeThread(threadData->thread);

                //yup this is super-hacky-pointer-kungfu but threadData++ wont work coz there
                //is 0x20bytes extra data between thread elements
                threadData = reinterpret_cast<t_thread*>((DWORD)threadData + threadSize);
            }
            break;
        }
        case 1:
        {
            //Suspendallthreads(); doesnt work as expected
            for (int i = 0; i < threadCount; i++) {
                SuspendThread(threadData->thread);

                //yup this is super-hacky-pointer-kungfu but threadData++ wont work coz there
                //is 0x20bytes extra data between thread elements
                threadData = reinterpret_cast<t_thread*>((DWORD)threadData + threadSize);
            }
            break;
        }
        }
        return MENU_REDRAW;
    };
    return MENU_ABSENT;
}

//Menu->About
static int Mabout(t_table *pt, wchar_t *name, ulong index, int mode)
{
    if (mode == MENU_VERIFY)
        return MENU_NORMAL;
    else if (mode == MENU_EXECUTE)
    {
        // Debuggee should continue execution while message box is displayed.
        Resumeallthreads();

        scl::ShowAboutBox(hwollymain);

        // Suspendallthreads() and Resumeallthreads() must be paired, even if they
        // are called in inverse order!
        Suspendallthreads();
        return MENU_NOREDRAW;
    };
    return MENU_ABSENT;
}

static t_menu mainmenu[] =
{
    {
        L"Options",
        L"Select Hiding Options",
        K_NONE, Moptions, NULL, 0
    },
    {
        L"Load Profile",
        L"Load a saved profile",
        K_NONE, NULL, profilemenu, 0
    },
    {
        L"|Inject DLL",
        L"Inject a DLL into the debugged process",
        K_NONE, MinjectDll, NULL, 0
    },
    {
        L"|Attach process",
        L"Attach to a process by window finder or PID",
        K_NONE, MattachProcess, NULL, 0
    },
    {
        L"|About",
        L"About ScyllaHide plugin",
        K_NONE, Mabout, NULL, 0
    },
    { NULL, NULL, K_NONE, NULL, NULL, 0 }
};

static t_menu threadmenu[] =
{
    {
        L"Resume all Threads",
        L"Resume all Threads",
        K_NONE, Mthreads, NULL, 0
    },
    {
        L"Suspend all Threads",
        L"Suspend all Threads",
        K_NONE, Mthreads, NULL, 1
    },
    { NULL, NULL, K_NONE, NULL, NULL, 0 }
};

//register plugin
extc int ODBG2_Pluginquery(int ollydbgversion, ulong *features, wchar_t pluginname[SHORTNAME], wchar_t pluginversion[SHORTNAME])
{
    if (ollydbgversion < 201)
        return 0;

    wcscpy(pluginname, SCYLLA_HIDE_NAME_W);
    wcscpy(pluginversion, SCYLLA_HIDE_VERSION_STRING_W);

    return PLUGIN_VERSION;
};

//initialization happens in here
extc int ODBG2_Plugininit(void)
{
    g_settings.Load(g_scyllaHideIniPath.c_str());

    Addtolist(0, 0, SCYLLA_HIDE_NAME_W L" Plugin v" SCYLLA_HIDE_VERSION_STRING_W);
    Addtolist(0, 2, L"  Copyright (C) 2014 Aguila / cypher");
    Addtolist(0, 2, L"  Operating System: %S", scl::GetWindowsVersionNameA());

    //change olly caption
    SetWindowTextW(hwollymain, g_settings.opts().ollyWindowTitle.c_str());

    if (g_settings.opts().killAntiAttach) {
        InstallAntiAttachHook();
    }

    return 0;
}

//setup menus
extc t_menu* ODBG2_Pluginmenu(wchar_t *type)
{
    if (wcscmp(type, PWM_MAIN) == 0) {
        // add profiles to menu
        for (size_t i = 0; i < g_settings.profile_names().size(); i++)
        {
            profilemenu[i] = {
                (wchar_t *)&g_settings.profile_names()[i][0], (wchar_t *)&g_settings.profile_names()[i][0], K_NONE, Mprofiles, NULL, { i }
            };
        }
        t_menu menu_end = { NULL, NULL, K_NONE, NULL, NULL, 0 };
        profilemenu[g_settings.profile_names().size()] = menu_end;

        return mainmenu;
    }
    else if (wcscmp(type, PWM_THREADS) == 0)
        return threadmenu;

    return NULL;
}

//called for every debugloop pass
extc void ODBG2_Pluginmainloop(DEBUG_EVENT *debugevent)
{
    if (!debugevent)
        return;


    if (g_settings.opts().fixPebHeapFlags)
    {
        if (specialPebFix)
        {
            StartFixBeingDebugged(ProcessId, false);
            specialPebFix = false;
        }

        if (debugevent->u.LoadDll.lpBaseOfDll == hNtdllModule)
        {
            StartFixBeingDebugged(ProcessId, true);
            specialPebFix = true;
        }
    }

    switch (debugevent->dwDebugEventCode)
    {
    case CREATE_PROCESS_DEBUG_EVENT:
    {
        // TODO // FIXME // WTF
        // This is copied from the Olly v1 plugin since at least some (all?) of its exception handling problems seem to have carried over to v2.
        // 1. Figure out which of these are still relevant. At the very least this includes debug prints (https://github.com/x64dbg/ScyllaHide/issues/44)
        // 2. Add v2 version of IsAddressBreakPoint() for handleExceptionBreakpoint / handleExceptionWx86Breakpoint (currently ignored)
        if (g_settings.opts().handleExceptionPrint ||
            g_settings.opts().handleExceptionRip ||
            g_settings.opts().handleExceptionIllegalInstruction ||
            g_settings.opts().handleExceptionInvalidLockSequence ||
            g_settings.opts().handleExceptionNoncontinuableException ||
            g_settings.opts().handleExceptionGuardPageViolation
            )
        {
            if (!debugLoopHooked)
            {
                HookDebugLoop();
                debugLoopHooked = true;
            }
        }

        ProcessId = debugevent->dwProcessId;
        bHooked = false;
        ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));

        if (debugevent->u.CreateProcessInfo.lpStartAddress == NULL)
        {
            //ATTACH
            if (g_settings.opts().killAntiAttach)
            {
                if (!ApplyAntiAntiAttach(ProcessId))
                {
                    MessageBoxW(hwollymain, L"Anti-Anti-Attach failed", L"Error", MB_ICONERROR);
                }
            }
        }

        //change olly caption again !
        SetWindowTextW(hwollymain, g_settings.opts().ollyWindowTitle.c_str());
    }
    break;
    case LOAD_DLL_DEBUG_EVENT:
    {
        if (bHooked)
        {
            startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), false);
        }
        break;
    }
    case EXCEPTION_DEBUG_EVENT:
    {
        switch (debugevent->u.Exception.ExceptionRecord.ExceptionCode)
        {
        case STATUS_BREAKPOINT:
        {
            if (!bHooked)
            {
                ReadNtApiInformation(&g_hdd);

                bHooked = true;
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
            }
        }
        break;
        }
    }
    break;
    }
}

//reset variables. new target started or restarted
extc void ODBG2_Pluginreset(void)
{
    bHooked = false;
    ProcessId = 0;
}

BOOL WINAPI DllMain(HINSTANCE hi, DWORD reason, LPVOID reserved)
{
    if (reason == DLL_PROCESS_ATTACH)
    {
        hinst = hi;
        _AttachProcess = AttachProcess;
        hNtdllModule = GetModuleHandleW(L"ntdll.dll");

        auto wstrPath = scl::GetModuleFileNameW(hi);
        wstrPath.resize(wstrPath.find_last_of(L'\\') + 1);

        g_scyllaHideDllPath = wstrPath + g_scyllaHideDllFilename;
        g_scyllaHideIniPath = wstrPath + scl::Settings::kFileName;

        auto log_file = wstrPath + scl::Logger::kFileName;
        g_log.SetLogFile(log_file.c_str());
        g_log.SetLogCb(scl::Logger::Info, LogCallback);
        g_log.SetLogCb(scl::Logger::Error, LogErrorCallback);
    }
    return TRUE;
};



================================================
File: ScyllaHideOlly2Plugin/ScyllaHideOlly2Plugin.rc
================================================
[Non-text file]


================================================
File: ScyllaHideOlly2Plugin/ScyllaHideOlly2Plugin.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{9EEA6D78-4E74-47B9-8746-B8754B15525D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ScyllaHideOlly2Plugin</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <IgnoreImportLibrary>false</IgnoreImportLibrary>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;OLLY2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/J %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;OLLY2;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/J %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp" />
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp" />
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp" />
    <ClCompile Include="..\PluginGeneric\AttachDialog.cpp" />
    <ClCompile Include="..\PluginGeneric\OllyExceptionHandler.cpp" />
    <ClCompile Include="..\PluginGeneric\Injector.cpp" />
    <ClCompile Include="..\PluginGeneric\OptionsDialog.cpp" />
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="ScyllaHideOlly2Plugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h" />
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h" />
    <ClInclude Include="..\InjectorCLI\RemoteHook.h" />
    <ClInclude Include="..\PluginGeneric\AttachDialog.h" />
    <ClInclude Include="..\PluginGeneric\OllyExceptionHandler.h" />
    <ClInclude Include="..\PluginGeneric\Injector.h" />
    <ClInclude Include="..\PluginGeneric\OptionsDialog.h" />
    <ClInclude Include="..\Scylla\VersionPatch.h" />
    <ClInclude Include="olly2patches.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ScyllaHideOlly2Plugin.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\findere.bmp" />
    <None Include="..\PluginGeneric\finderf.bmp" />
    <None Include="..\PluginGeneric\searchwindow.cur" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ScyllaHideOlly2Plugin/ScyllaHideOlly2Plugin.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ScyllaHideOlly2Plugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\OptionsDialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\AttachDialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\OllyExceptionHandler.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\RemoteHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\OptionsDialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\AttachDialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\OllyExceptionHandler.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="olly2patches.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ScyllaHideOlly2Plugin.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\findere.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\PluginGeneric\finderf.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\PluginGeneric\searchwindow.cur">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: ScyllaHideOlly2Plugin/resource.h
================================================
[Non-text file]


================================================
File: ScyllaHideTEPlugin/ScyllaHideTEPlugin.cpp
================================================
#include <Windows.h>
#include <Scylla/Logger.h>
#include <Scylla/Settings.h>
#include <Scylla/Version.h>
#include <Scylla/Util.h>
#include <titan/TitanEngine.h>

#include "..\PluginGeneric\Injector.h"

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif

#ifdef _WIN64
const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx64.dll";
#else
const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx86.dll";
#endif

scl::Settings g_settings;
scl::Logger g_log;
std::wstring g_scyllaHideDllPath;
std::wstring g_scyllaHideIniPath;

HOOK_DLL_DATA g_hdd;

bool bHooked;
DWORD ProcessId;

static void LogCallback(const wchar_t *msg)
{
}

static bool SetDebugPrivileges()
{
    TOKEN_PRIVILEGES Debug_Privileges;
    bool retVal = false;

    if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &Debug_Privileges.Privileges[0].Luid))
    {
        HANDLE hToken = 0;
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
        {
            Debug_Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            Debug_Privileges.PrivilegeCount = 1;

            retVal = AdjustTokenPrivileges(hToken, FALSE, &Debug_Privileges, 0, NULL, NULL) != FALSE;

            CloseHandle(hToken);
        }
    }

    return retVal;
}

extern "C" DLL_EXPORT void TitanDebuggingCallBack(LPDEBUG_EVENT debugEvent, int CallReason)
{
    switch(CallReason)
    {
    case UE_PLUGIN_CALL_REASON_EXCEPTION:
    {
        switch(debugEvent->dwDebugEventCode)
        {
        case CREATE_PROCESS_DEBUG_EVENT:
        {
            ProcessId=debugEvent->dwProcessId;
            bHooked = false;
            ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));
            break;
        }

        case LOAD_DLL_DEBUG_EVENT:
        {
            if (bHooked)
            {
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), false);
            }
            break;
        }
        case EXCEPTION_DEBUG_EVENT:
        {
            switch(debugEvent->u.Exception.ExceptionRecord.ExceptionCode)
            {
            case STATUS_BREAKPOINT:
            {
                if (!bHooked)
                {
                    ReadNtApiInformation(&g_hdd);

                    bHooked = true;
                    startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
                }
                break;
            }

            }

            break;
        }

        }
    }
    break;
    }
}

extern "C" DLL_EXPORT bool TitanRegisterPlugin(char* szPluginName, DWORD* titanPluginMajorVersion, DWORD* titanPluginMinorVersion)
{
    if(titanPluginMajorVersion && titanPluginMinorVersion)
    {
        *titanPluginMajorVersion = SCYLLA_HIDE_VERSION_MAJOR;
        *titanPluginMinorVersion = SCYLLA_HIDE_VERSION_MINOR;
        strncpy_s(szPluginName, sizeof(SCYLLA_HIDE_NAME_A), SCYLLA_HIDE_NAME_A, _TRUNCATE);
        return true;
    }
    return false;
}

BOOL WINAPI DllMain(HINSTANCE hInstDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        auto wstrPath = scl::GetModuleFileNameW(hInstDll);
        wstrPath.resize(wstrPath.find_last_of(L'\\') + 1);

        g_scyllaHideDllPath = wstrPath + g_scyllaHideDllFilename;
        g_scyllaHideIniPath = wstrPath + scl::Settings::kFileName;

        auto log_file = wstrPath + scl::Logger::kFileName;
        g_log.SetLogFile(log_file.c_str());
        g_log.SetLogCb(scl::Logger::Info, LogCallback);
        g_log.SetLogCb(scl::Logger::Error, LogCallback);

        g_settings.Load(g_scyllaHideIniPath.c_str());

        SetDebugPrivileges();
    }
    return TRUE;
}



================================================
File: ScyllaHideTEPlugin/ScyllaHideTEPlugin.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{0520906F-4296-4BEC-BD5F-B370E1F7800A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ScyllaHideTEPlugin</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x86</TargetName>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(TargetName)x64</TargetName>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;SCYLLAHIDETEPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;SCYLLAHIDETEPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;SCYLLAHIDETEPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;SCYLLAHIDETEPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp" />
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp" />
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp" />
    <ClCompile Include="..\PluginGeneric\Injector.cpp" />
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="ScyllaHideTEPlugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h" />
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h" />
    <ClInclude Include="..\InjectorCLI\RemoteHook.h" />
    <ClInclude Include="..\PluginGeneric\Injector.h" />
    <ClInclude Include="..\Scylla\VersionPatch.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ScyllaHideTEPlugin/ScyllaHideTEPlugin.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ScyllaHideTEPlugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\RemoteHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>


================================================
File: ScyllaHideX64DBGPlugin/ScyllaHideX64DBGPlugin.cpp
================================================
#include <codecvt>
#include <Scylla/Logger.h>
#include <Scylla/OsInfo.h>
#include <Scylla/Settings.h>
#include <Scylla/Util.h>
#include <Scylla/Version.h>
#include <x64dbg/_plugins.h>

#include "..\PluginGeneric\Injector.h"
#include "..\PluginGeneric\OptionsDialog.h"
#include "..\PluginGeneric\AttachDialog.h"

#include "resource.h"


#ifdef _WIN64
#pragma comment(lib, "x64dbg\\x64dbg.lib")
#pragma comment(lib, "x64dbg\\x64bridge.lib")
#else
#pragma comment(lib, "x64dbg\\x32dbg.lib")
#pragma comment(lib, "x64dbg\\x32bridge.lib")
#endif

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif

typedef void(__cdecl * t_AttachProcess)(DWORD dwPID);

enum ScyllaMenuItems : int {
    MENU_OPTIONS = 0,
    MENU_PROFILES,
    MENU_INJECTDLL,
    MENU_ATTACH,
    MENU_ABOUT,
    MENU_MAX
};

extern t_AttachProcess _AttachProcess;

#ifdef _WIN64
const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx64.dll";
#else
const WCHAR g_scyllaHideDllFilename[] = L"HookLibraryx86.dll";
#endif

scl::Settings g_settings;
scl::Logger g_log;
std::wstring g_scyllaHideDllPath;
std::wstring g_scyllaHideIniPath;

HOOK_DLL_DATA g_hdd = { 0 };

HINSTANCE hinst;
HMODULE hNtdllModule = 0;
bool specialPebFix = false;
int pluginHandle;
HWND hwndDlg;
int hMenu;
DWORD ProcessId = 0;
bool bHooked = false;
ICONDATA mainIconData = { 0 };

static void LogCallback(const char *msg)
{
    _plugin_logprintf("[%s] %s\n", SCYLLA_HIDE_NAME_A, msg);
}

static void AttachProcess(DWORD dwPID)
{
    char cmd[30] = { 0 };
    wsprintfA(cmd, "attach %x", dwPID);
    if (!DbgCmdExec(cmd))
    {
        MessageBoxW(hwndDlg,
            L"Can't attach to that process !",
            L"ScyllaHide Plugin", MB_OK | MB_ICONERROR);
    }
}

static void cbMenuEntry(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_MENUENTRY* info = (PLUG_CB_MENUENTRY*)callbackInfo;
    switch (info->hEntry)
    {
    case MENU_OPTIONS:
    {
        DialogBoxW(hinst, MAKEINTRESOURCE(IDD_OPTIONS), hwndDlg, &OptionsDlgProc);
        break;
    }
    case MENU_INJECTDLL:
    {
        if (ProcessId) {
            wchar_t dllPath[MAX_PATH] = {};
            if (scl::GetFileDialogW(dllPath, _countof(dllPath)))
                injectDll(ProcessId, dllPath);
        }
        break;
    }
    case MENU_ATTACH:
    {
        DialogBox(hinst, MAKEINTRESOURCE(IDD_ATTACH), hwndDlg, &AttachProc);
        break;
    }
    case MENU_ABOUT:
    {
        scl::ShowAboutBox(hwndDlg);

        break;
    }
    default: {
        auto profile_name = g_settings.profile_names()[info->hEntry - MENU_MAX].c_str();
        g_settings.SetProfile(profile_name);

        if (ProcessId)
        {
            startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
            bHooked = true;
            MessageBoxA(hwndDlg, "Applied changes! Restarting target is NOT necessary!", "[ScyllaHide Options]", MB_OK | MB_ICONINFORMATION);
        }
        else
        {
            MessageBoxA(hwndDlg, "Please start the target to apply changes!", "[ScyllaHide Options]", MB_OK | MB_ICONINFORMATION);
        }
        break;
    }
    }
}

static void cbDebugloop(CBTYPE cbType, void* callbackInfo)
{
    PLUG_CB_DEBUGEVENT* d = (PLUG_CB_DEBUGEVENT*)callbackInfo;

    if (g_settings.opts().fixPebHeapFlags)
    {
        if (specialPebFix)
        {
            StartFixBeingDebugged(ProcessId, false);
            specialPebFix = false;
        }

        if (d->DebugEvent->u.LoadDll.lpBaseOfDll == hNtdllModule)
        {
            StartFixBeingDebugged(ProcessId, true);
            specialPebFix = true;
        }
    }

    switch (d->DebugEvent->dwDebugEventCode)
    {
    case CREATE_PROCESS_DEBUG_EVENT:
    {
        ProcessId = d->DebugEvent->dwProcessId;
        bHooked = false;
        ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));

        if (d->DebugEvent->u.CreateProcessInfo.lpStartAddress == NULL)
        {
            //ATTACH
            if (g_settings.opts().killAntiAttach)
            {
                if (!ApplyAntiAntiAttach(ProcessId))
                {
                    MessageBoxW(hwndDlg, L"Anti-Anti-Attach failed", L"Error", MB_ICONERROR);
                }
            }
            //In newest x64dbg version the auto break on attach was removed so ScyllaHide would never inject.
            if (!bHooked)
            {
                ReadNtApiInformation(&g_hdd);

                bHooked = true;
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
            }
        }

        break;
    }
    case LOAD_DLL_DEBUG_EVENT:
    {
        if (bHooked)
        {
            startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), false);
        }
        break;
    }
    case EXCEPTION_DEBUG_EVENT:
    {
        switch (d->DebugEvent->u.Exception.ExceptionRecord.ExceptionCode)
        {
        case STATUS_BREAKPOINT:
        {
            if (!bHooked)
            {
                ReadNtApiInformation(&g_hdd);

                bHooked = true;
                startInjection(ProcessId, &g_hdd, g_scyllaHideDllPath.c_str(), true);
            }
            break;
        }

        }

        break;
    }
    }
}

static void cbReset(CBTYPE cbType, void* callbackInfo)
{
    ZeroMemory(&g_hdd, sizeof(HOOK_DLL_DATA));
    bHooked = false;
    ProcessId = 0;
}

extern "C" DLL_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    initStruct->pluginVersion = (SCYLLA_HIDE_VERSION_MAJOR * 100) + (SCYLLA_HIDE_VERSION_MINOR * 10) + SCYLLA_HIDE_VERSION_PATCH;
    initStruct->sdkVersion = PLUG_SDKVERSION;
    strncpy_s(initStruct->pluginName, sizeof(initStruct->pluginName), SCYLLA_HIDE_NAME_A, _TRUNCATE);
    pluginHandle = initStruct->pluginHandle;

    _plugin_registercallback(pluginHandle, CB_MENUENTRY, cbMenuEntry);
    _plugin_registercallback(pluginHandle, CB_DEBUGEVENT, cbDebugloop);
    _plugin_registercallback(pluginHandle, CB_STOPDEBUG, cbReset);

    return true;
}

extern "C" DLL_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    hwndDlg = setupStruct->hwndDlg;
    hMenu = setupStruct->hMenu;

    g_settings.Load(g_scyllaHideIniPath.c_str());

    _plugin_logprintf("%s Plugin v%s Copyright (C) 2014 Aguila / cypher\n", SCYLLA_HIDE_NAME_A, SCYLLA_HIDE_VERSION_STRING_A);

    _plugin_menuaddentry(hMenu, MENU_OPTIONS, "&Options");
    int hProfile = _plugin_menuadd(hMenu, "&Load Profile");

    //add profiles to menu
    for (size_t i = 0; i < g_settings.profile_names().size(); i++)
    {
        auto mbstrName = scl::wstr_conv().to_bytes(g_settings.profile_names()[i].c_str());
        _plugin_menuaddentry(hProfile, (int)i + MENU_MAX, mbstrName.c_str());
    }

    _plugin_menuaddseparator(hMenu);
    _plugin_menuaddentry(hMenu, MENU_INJECTDLL, "&Inject DLL");
    _plugin_menuaddseparator(hMenu);
    _plugin_menuaddentry(hMenu, MENU_ATTACH, "&Attach process");
    _plugin_menuaddseparator(hMenu);
    _plugin_menuaddentry(hMenu, MENU_ABOUT, "&About");

    //load png

    HRSRC hResPng = FindResourceW(hinst, MAKEINTRESOURCEW(IDB_GHOSTPNG), L"PNG");
    if (hResPng != NULL)
    {
        HGLOBAL hResLoad = LoadResource(hinst, hResPng);
        if (hResLoad != NULL)
        {
            mainIconData.data = LockResource(hResLoad);
            mainIconData.size = SizeofResource(hinst, hResPng);

            if (mainIconData.data != NULL && mainIconData.size != 0)
            {
                _plugin_menuseticon(hMenu, (const ICONDATA *)&mainIconData);
            }
            else
            {
                _plugin_logprintf("Warning: Cannot lock ScyllaHide icon! LockResource, SizeofResource\n");
            }
        }
        else
        {
            _plugin_logprintf("Warning: Cannot load ScyllaHide icon! LoadResource\n");
        }
    }
    else
    {
        _plugin_logprintf("Warning: Cannot find ScyllaHide icon! FindResourceW\n");
    }
}

BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        hinst = hInstDLL;
        _AttachProcess = AttachProcess;
        hNtdllModule = GetModuleHandleW(L"ntdll.dll");

        auto wstrPath = scl::GetModuleFileNameW(hInstDLL);
        wstrPath.resize(wstrPath.find_last_of(L'\\') + 1);

        g_scyllaHideDllPath = wstrPath + g_scyllaHideDllFilename;
        g_scyllaHideIniPath = wstrPath + scl::Settings::kFileName;

        auto log_file = wstrPath + scl::Logger::kFileName;
        g_log.SetLogFile(log_file.c_str());
        g_log.SetLogCb(scl::Logger::Info, LogCallback);
        g_log.SetLogCb(scl::Logger::Error, LogCallback);
    }

    return TRUE;
}



================================================
File: ScyllaHideX64DBGPlugin/ScyllaHideX64DBGPlugin.rc
================================================
[Non-text file]


================================================
File: ScyllaHideX64DBGPlugin/ScyllaHideX64DBGPlugin.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{B00C9DA1-867E-4438-9C6E-1B53AE0506B7}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ScyllaHideX64DBGPlugin</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(SolutionDir)Scylla\scylla.props" />
    <Import Project="$(SolutionDir)Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp32</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp64</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp32</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetExt>.dp64</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>X64DBG;WIN32;_DEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEX64DBGPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>_M_IX86;_X86_;_USING_V110_SDK71_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>X64DBG;_DEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEX64DBGPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>_M_AMD64;_AMD64_;_WIN64;_USING_V110_SDK71_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>X64DBG;WIN32;NDEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEX64DBGPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>_M_IX86;_X86_;_USING_V110_SDK71_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>X64DBG;NDEBUG;_WINDOWS;_USRDLL;SCYLLAHIDEX64DBGPLUGIN_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <ResourceCompile>
      <PreprocessorDefinitions>_M_AMD64;_AMD64_;_WIN64;_USING_V110_SDK71_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp" />
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp" />
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp" />
    <ClCompile Include="..\PluginGeneric\AttachDialog.cpp" />
    <ClCompile Include="..\PluginGeneric\Injector.cpp" />
    <ClCompile Include="..\PluginGeneric\OptionsDialog.cpp" />
    <ClCompile Include="..\Scylla\VersionPatch.cpp" />
    <ClCompile Include="ScyllaHideX64DBGPlugin.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h" />
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h" />
    <ClInclude Include="..\InjectorCLI\RemoteHook.h" />
    <ClInclude Include="..\PluginGeneric\AttachDialog.h" />
    <ClInclude Include="..\PluginGeneric\Injector.h" />
    <ClInclude Include="..\PluginGeneric\OptionsDialog.h" />
    <ClInclude Include="..\Scylla\VersionPatch.h" />
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ScyllaHideX64DBGPlugin.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\findere.bmp" />
    <None Include="..\PluginGeneric\finderf.bmp" />
    <None Include="..\PluginGeneric\searchwindow.cur" />
    <None Include="Ghost-icon.png" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ScyllaHideX64DBGPlugin/ScyllaHideX64DBGPlugin.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ScyllaHideX64DBGPlugin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\OptionsDialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\ApplyHooking.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\DynamicMapping.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\InjectorCLI\RemoteHook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\PluginGeneric\AttachDialog.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Scylla\VersionPatch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\PluginGeneric\OptionsDialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\ApplyHooking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\DynamicMapping.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\InjectorCLI\RemoteHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\PluginGeneric\AttachDialog.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\Scylla\VersionPatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ScyllaHideX64DBGPlugin.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\PluginGeneric\findere.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\PluginGeneric\finderf.bmp">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="..\PluginGeneric\searchwindow.cur">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="Ghost-icon.png">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>


================================================
File: ScyllaHideX64DBGPlugin/resource.h
================================================
[Non-text file]


================================================
File: ScyllaTest/ScyllaTest.vcxproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{5EEACDD3-61B9-4E6A-BB47-5F37C03973C3}</ProjectGuid>
    <RootNamespace>ScyllaTest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <VcpkgEnabled>false</VcpkgEnabled>
    <VCToolsVersion Condition="'$(USE_XP_TOOLCHAIN)'!=''">14.27.29110</VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Scylla\scylla.props" />
    <Import Project="..\Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Scylla\scylla.props" />
    <Import Project="..\Scylla\scylla.debug.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Scylla\scylla.props" />
    <Import Project="..\Scylla\scylla.release.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Scylla\scylla.props" />
    <Import Project="..\Scylla\scylla.release.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetName>$(ProjectName)_x86</TargetName>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>$(ProjectName)_x86</TargetName>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>$(ProjectName)_x64</TargetName>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>$(ProjectName)_x64</TargetName>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile />
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile />
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile />
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile />
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>


================================================
File: ScyllaTest/ScyllaTest.vcxproj.filters
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>


================================================
File: ScyllaTest/main.cpp
================================================
#include <Windows.h>
#include <cstdio>
#include <Scylla/NtApiShim.h>
#include <Scylla/OsInfo.h>
#include <Scylla/Peb.h>
#include <Scylla/Util.h>

enum ScyllaTestResult
{
    ScyllaTestOk = 0,
    ScyllaTestFail,
    ScyllaTestDetected,
    ScyllaTestSkip
};

#define SCYLLA_TEST_FAIL_IF(x) if (x) return ScyllaTestFail;
#define SCYLLA_TEST_CHECK(x) ((x) ? ScyllaTestOk : ScyllaTestDetected);

#ifdef _WIN64
const bool is_x64 = true;
#else
const bool is_x64 = false;
#endif

static HANDLE g_proc_handle, g_stopEvent;

static BOOL NTAPI CtrlHandler(ULONG)
{
    // Signal test stop, and don't pass to next handler
    NtSetEvent(g_stopEvent, nullptr);
    return TRUE;
}

static HANDLE GetRealCurrentProcess()
{
    auto pseudo_handle = GetCurrentProcess();
    auto hRealHandle = INVALID_HANDLE_VALUE;
    DuplicateHandle(pseudo_handle, pseudo_handle, pseudo_handle, &hRealHandle, 0, FALSE, DUPLICATE_SAME_ACCESS);
    return hRealHandle;
}

static NTSTATUS GetOtherOperationCount(PULONGLONG otherOperationCount)
{
    *otherOperationCount = 0;
    ULONGLONG otherOperationCountSystemProcessInformation = 0,
        otherOperationCountSystemExtendedProcessInformation = 0;

    // NtQSI(SystemProcessInformation)
    ULONG size;
    NTSTATUS status = NtQuerySystemInformation(SystemProcessInformation, nullptr, 0, &size);
    if (status != STATUS_INFO_LENGTH_MISMATCH)
        return status;
    const PSYSTEM_PROCESS_INFORMATION SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, size * 2);
    if (SystemProcessInfo == nullptr)
        return STATUS_INSUFFICIENT_RESOURCES;
    status = NtQuerySystemInformation(SystemProcessInformation, SystemProcessInfo, size * 2, nullptr);
    if (!NT_SUCCESS(status))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, SystemProcessInfo);
        return status;
    }

    PSYSTEM_PROCESS_INFORMATION entry = SystemProcessInfo;
    status = STATUS_NOT_FOUND;

    while (true)
    {
        if (entry->UniqueProcessId == NtCurrentTeb()->ClientId.UniqueProcess)
        {
            otherOperationCountSystemProcessInformation = entry->OtherOperationCount.QuadPart;
            status = STATUS_SUCCESS;
            break;
        }
        
        if (entry->NextEntryOffset == 0)
            break;
        entry = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)entry + entry->NextEntryOffset);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, SystemProcessInfo);
    if (!NT_SUCCESS(status))
        return status;

    // NtQSI(SystemExtendedProcessInformation)
    status = NtQuerySystemInformation(SystemExtendedProcessInformation, nullptr, 0, &size);
    if (status != STATUS_INFO_LENGTH_MISMATCH)
        return status;
    const PSYSTEM_PROCESS_INFORMATION systemExtendedProcessInfo = (PSYSTEM_PROCESS_INFORMATION)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, size * 2);
    if (SystemProcessInfo == nullptr)
        return STATUS_INSUFFICIENT_RESOURCES;
    status = NtQuerySystemInformation(SystemExtendedProcessInformation, systemExtendedProcessInfo, size * 2, nullptr);
    if (!NT_SUCCESS(status))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, systemExtendedProcessInfo);
        return status;
    }

    entry = systemExtendedProcessInfo;
    status = STATUS_NOT_FOUND;

    while (true)
    {
        if (entry->UniqueProcessId == NtCurrentTeb()->ClientId.UniqueProcess)
        {
            otherOperationCountSystemExtendedProcessInformation = entry->OtherOperationCount.QuadPart;
            status = STATUS_SUCCESS;
            break;
        }
        
        if (entry->NextEntryOffset == 0)
            break;
        entry = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)entry + entry->NextEntryOffset);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, systemExtendedProcessInfo);
    if (!NT_SUCCESS(status))
        return status;

    // NtQIP(IoCounters)
    IO_COUNTERS ioCounters;
    status = NtQueryInformationProcess(g_proc_handle, ProcessIoCounters, &ioCounters, sizeof(ioCounters), nullptr);
    if (!NT_SUCCESS(status))
        return status;

    // All four counts should be the same
    if (otherOperationCountSystemProcessInformation != otherOperationCountSystemExtendedProcessInformation ||
        otherOperationCountSystemProcessInformation != ioCounters.OtherOperationCount)
        return STATUS_DATA_NOT_ACCEPTED;

    // Return final count
    *otherOperationCount = otherOperationCountSystemProcessInformation;
    return STATUS_SUCCESS;
}

static ScyllaTestResult Check_PEB_BeingDebugged()
{
    const auto peb = scl::GetPebAddress(g_proc_handle);
    SCYLLA_TEST_FAIL_IF(!peb);
    return SCYLLA_TEST_CHECK(peb->BeingDebugged == 0);
}

static ScyllaTestResult Check_Wow64PEB64_BeingDebugged()
{
    const auto peb64 = scl::Wow64GetPeb64(g_proc_handle);
    SCYLLA_TEST_FAIL_IF(!peb64);

    return SCYLLA_TEST_CHECK(peb64->BeingDebugged == 0);
}

static ScyllaTestResult Check_PEB_NtGlobalFlag()
{
    const DWORD bad_flags = FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS;
    const auto peb = scl::GetPebAddress(g_proc_handle);
    SCYLLA_TEST_FAIL_IF(!peb);
    return SCYLLA_TEST_CHECK((peb->NtGlobalFlag & bad_flags) == 0);
}

static ScyllaTestResult Check_Wow64PEB64_NtGlobalFlag()
{
    const DWORD bad_flags = FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS;
    const auto peb64 = scl::Wow64GetPeb64(g_proc_handle);
    SCYLLA_TEST_FAIL_IF(!peb64);
    return SCYLLA_TEST_CHECK((peb64->NtGlobalFlag & bad_flags) == 0);
}

static ScyllaTestResult Check_PEB_HeapFlags()
{
    const DWORD bad_flags = HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED | HEAP_SKIP_VALIDATION_CHECKS | HEAP_VALIDATE_PARAMETERS_ENABLED;

    const auto peb = scl::GetPebAddress(g_proc_handle);
    SCYLLA_TEST_FAIL_IF(!peb);

    auto heaps = (void **)peb->ProcessHeaps;
    for (DWORD i = 0; i < peb->NumberOfHeaps; i++)
    {
        auto flags = *(DWORD *)((BYTE *)heaps[i] + scl::GetHeapFlagsOffset(is_x64));
        auto force_flags = *(DWORD *)((BYTE *)heaps[i] + scl::GetHeapForceFlagsOffset(is_x64));

        if ((flags & bad_flags) || (force_flags & bad_flags))
            return ScyllaTestDetected;
    }

    return ScyllaTestOk;
}

static ScyllaTestResult Check_Wow64PEB64_HeapFlags()
{
    const DWORD bad_flags = HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED | HEAP_SKIP_VALIDATION_CHECKS | HEAP_VALIDATE_PARAMETERS_ENABLED;
    const auto peb64 = scl::Wow64GetPeb64(g_proc_handle);
    SCYLLA_TEST_FAIL_IF(!peb64);

    std::basic_string<PVOID64> heaps64;
    heaps64.resize(peb64->NumberOfHeaps);

    SCYLLA_TEST_FAIL_IF(!scl::Wow64ReadProcessMemory64(g_proc_handle, (PVOID64)peb64->ProcessHeaps, (PVOID)heaps64.data(), heaps64.size()*sizeof(PVOID64), nullptr));

    std::basic_string<uint8_t> heap;
    heap.resize(0x100); // hacky
    for (DWORD i = 0; i < peb64->NumberOfHeaps; i++)
    {
        SCYLLA_TEST_FAIL_IF(!scl::Wow64ReadProcessMemory64(g_proc_handle, heaps64[i], (PVOID)heap.data(), heap.size(), nullptr));

        auto flags = *(DWORD *)(heap.data() + scl::GetHeapFlagsOffset(true));
        auto force_flags = *(DWORD *)(heap.data() + scl::GetHeapForceFlagsOffset(true));

        if ((flags & bad_flags) || (force_flags & bad_flags))
            return ScyllaTestDetected;
    }

    return ScyllaTestOk;
}

static ScyllaTestResult Check_PEB_ProcessParameters()
{
    const auto peb = scl::GetPebAddress(g_proc_handle);
    SCYLLA_TEST_FAIL_IF(!peb);

    auto rupp = (scl::RTL_USER_PROCESS_PARAMETERS<DWORD_PTR> *)peb->ProcessParameters;

    return SCYLLA_TEST_CHECK((rupp->Flags & 0x4000) != 0);
}

static ScyllaTestResult Check_Wow64PEB64_ProcessParameters()
{
    const auto peb64 = scl::GetPebAddress(g_proc_handle);
    SCYLLA_TEST_FAIL_IF(!peb64);

    scl::RTL_USER_PROCESS_PARAMETERS<DWORD64> rupp{};

    SCYLLA_TEST_FAIL_IF(!scl::Wow64ReadProcessMemory64(g_proc_handle, (PVOID64)peb64->ProcessParameters, (PVOID)&rupp, sizeof(rupp), nullptr));

    return SCYLLA_TEST_CHECK((rupp.Flags & 0x4000) != 0);
}

static ScyllaTestResult Check_IsDebuggerPresent()
{
    return SCYLLA_TEST_CHECK(!IsDebuggerPresent());
}

static ScyllaTestResult Check_CheckRemoteDebuggerPresent()
{
    BOOL present;
    CheckRemoteDebuggerPresent(g_proc_handle, &present);
    return SCYLLA_TEST_CHECK(!present);
}

static ScyllaTestResult Check_OutputDebugStringA_LastError()
{
    const DWORD last_error = 0xDEAD;
    SetLastError(last_error);
    OutputDebugStringA("test");
    return SCYLLA_TEST_CHECK(GetLastError() != last_error);
}

static ScyllaTestResult Check_OutputDebugStringA_Exception()
{
    char text[] = "test";
    ULONG_PTR args[2];
    args[0] = (ULONG_PTR)strlen(text) + 1;
    args[1] = (ULONG_PTR)text;

    __try
    {
        RaiseException(DBG_PRINTEXCEPTION_C, 0, 2, args);
        return ScyllaTestDetected;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return ScyllaTestOk;
    }
}

static ScyllaTestResult Check_OutputDebugStringW_Exception()
{
    wchar_t text_w[] = L"test";
    char text_a[_countof(text_w)] = { 0 };
    WideCharToMultiByte(CP_ACP, 0, text_w, -1, text_a, sizeof(text_a), nullptr, nullptr);

    ULONG_PTR args[4];

    args[0] = (ULONG_PTR)wcslen(text_w) + 1;
    args[1] = (ULONG_PTR)text_w;
    args[2] = (ULONG_PTR)strlen(text_a) + 1;
    args[3] = (ULONG_PTR)text_a;

    __try
    {
        RaiseException(DBG_PRINTEXCEPTION_WIDE_C, 0, 4, args);
        return ScyllaTestDetected;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return ScyllaTestOk;
    }
}

static ScyllaTestResult Check_NtQueryInformationProcess_ProcessDebugPort()
{
    HANDLE handle = nullptr;
    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(NtQueryInformationProcess(g_proc_handle, ProcessDebugPort, &handle, sizeof(handle), nullptr)));
    return SCYLLA_TEST_CHECK(handle == nullptr);
}

static ScyllaTestResult Check_NtQuerySystemInformation_KernelDebugger()
{
    SYSTEM_KERNEL_DEBUGGER_INFORMATION SysKernDebInfo;

    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(NtQuerySystemInformation(SystemKernelDebuggerInformation, &SysKernDebInfo, sizeof(SysKernDebInfo), NULL)));

    if (SysKernDebInfo.KernelDebuggerEnabled || !SysKernDebInfo.KernelDebuggerNotPresent)
    {
        return ScyllaTestDetected;
    }
    return ScyllaTestOk;
}

static ScyllaTestResult Check_NtQuery_OverlappingReturnLength() // https://github.com/x64dbg/ScyllaHide/issues/47
{
    UCHAR Buffer[sizeof(OBJECT_TYPE_INFORMATION) + 64];
    RtlZeroMemory(Buffer, sizeof(Buffer));
    PULONG pReturnLength = (PULONG)&Buffer[0];

    NTSTATUS Status = NtQueryInformationProcess(g_proc_handle, ProcessDebugObjectHandle, Buffer, sizeof(HANDLE), pReturnLength);
    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(Status) && Status != STATUS_PORT_NOT_SET);
    if (*pReturnLength != sizeof(HANDLE))
        return ScyllaTestDetected;

    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(NtQuerySystemInformation(SystemKernelDebuggerInformation, Buffer, sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION), pReturnLength)));
    if (*pReturnLength != sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION))
        return ScyllaTestDetected;

    HANDLE DebugObjectHandle;
    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(NtCreateDebugObject(&DebugObjectHandle, DEBUG_ALL_ACCESS, nullptr, 0)));

    pReturnLength = (PULONG)(Buffer + FIELD_OFFSET(OBJECT_TYPE_INFORMATION, TotalNumberOfObjects)); // Where TotalNumberOfObjects would be
    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(NtQueryObject(DebugObjectHandle, ObjectTypeInformation, Buffer, sizeof(Buffer), pReturnLength)));
    if (*pReturnLength < sizeof(OBJECT_TYPE_INFORMATION) + sizeof(ULONG))
        return ScyllaTestDetected;

    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(NtClose(DebugObjectHandle)));

    return ScyllaTestOk;
}

static ScyllaTestResult Check_NtClose()
{
    __try
    {
        NtClose((HANDLE)(ULONG_PTR)0x1337);
        return ScyllaTestOk;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return GetExceptionCode() == EXCEPTION_INVALID_HANDLE
            ? ScyllaTestDetected
            : ScyllaTestFail;
    }
}

static ScyllaTestResult Check_OtherOperationCount() // https://everdox.blogspot.com/2013/11/debugger-detection-with.html
{
    // Open some file
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING ntdllPath = RTL_CONSTANT_STRING(L"\\SystemRoot\\System32\\ntdll.dll");
    OBJECT_ATTRIBUTES objectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES((PUNICODE_STRING)&ntdllPath, OBJ_CASE_INSENSITIVE);
    HANDLE fileHandle;
    NTSTATUS status = NtCreateFile(&fileHandle,
                                SYNCHRONIZE | FILE_EXECUTE,
                                &objectAttributes,
                                &ioStatusBlock,
                                nullptr,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ,
                                FILE_OPEN,
                                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                                nullptr,
                                0);
    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(status));

    // Create section. Must be SEC_IMAGE, not SEC_COMMIT
    HANDLE SectionHandle;
    status = NtCreateSection(&SectionHandle,
                            SECTION_MAP_EXECUTE,
                            nullptr,
                            nullptr,
                            PAGE_EXECUTE,
                            SEC_IMAGE,
                            fileHandle);
    NtClose(fileHandle);
    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(status));

    // Query other operation count (first go)
    ULONGLONG otherOperationCountBefore;
    status = GetOtherOperationCount(&otherOperationCountBefore);
    if (!NT_SUCCESS(status))
    {
        NtClose(SectionHandle);
        return status == STATUS_DATA_NOT_ACCEPTED
            ? ScyllaTestDetected
            : ScyllaTestFail;
    }

    // Map a view of the section
    PVOID baseAddress = nullptr;
    SIZE_T viewSize = 0;
    status = NtMapViewOfSection(SectionHandle,
                                g_proc_handle,
                                &baseAddress,
                                0, 
                                0,
                                nullptr,
                                &viewSize,
                                ViewUnmap,
                                0,
                                PAGE_EXECUTE);
    NtClose(SectionHandle);
    SCYLLA_TEST_FAIL_IF(!NT_SUCCESS(status));

    // Query other operation count (second go)
    ULONGLONG otherOperationCountAfter;
    status = GetOtherOperationCount(&otherOperationCountAfter);

    NtUnmapViewOfSection(g_proc_handle, baseAddress);

    if (!NT_SUCCESS(status))
    {
        return status == STATUS_DATA_NOT_ACCEPTED
            ? ScyllaTestDetected
            : ScyllaTestFail;
    }

    // If the other operation count was incremented, the image was mapped into a debugger
    return otherOperationCountAfter > otherOperationCountBefore
        ? ScyllaTestDetected
        : ScyllaTestOk;
}

static void PrintScyllaTestResult(ScyllaTestResult result, ULONG charsPrinted)
{
    // Neither stdout nor GetStdHandle() work and I cba with this kernel32/CRT shit anymore. Pay me
    const HANDLE stdOut = NtCurrentPeb()->ProcessParameters->StandardOutput;
    CONSOLE_SCREEN_BUFFER_INFO consoleBufferInfo = { sizeof(CONSOLE_SCREEN_BUFFER_INFO) };
    GetConsoleScreenBufferInfo(stdOut, &consoleBufferInfo);
    const USHORT defaultColours = consoleBufferInfo.wAttributes;

    const ULONG pad = charsPrinted <= 48 ? 48 - charsPrinted : 0;
    for (ULONG i = 0; i < pad; ++i)
        printf(" ");

    switch (result)
    {
    case ScyllaTestOk:
    {
        SetConsoleTextAttribute(stdOut, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
        printf("OK\n");
        break;
    }
    case ScyllaTestFail:
    {
        SetConsoleTextAttribute(stdOut, FOREGROUND_RED | BACKGROUND_BLUE | FOREGROUND_INTENSITY);
        printf("FAIL\n");
        break;
    }
    case ScyllaTestDetected:
    {
        SetConsoleTextAttribute(stdOut, FOREGROUND_RED | FOREGROUND_INTENSITY);
        printf("DETECTED\n");
        break;
    }
    case ScyllaTestSkip:
    {
        SetConsoleTextAttribute(stdOut, FOREGROUND_GREEN | FOREGROUND_BLUE);
        printf("SKIP\n");
        break;
    }
    default:
        printf("UNKNOWN\n");
        break;
    }
    SetConsoleTextAttribute(stdOut, defaultColours);
}

static bool OpenConsole()
{
    if (!AllocConsole())
    {
        auto text = L"Failed to allocate console: " + scl::FormatMessageW(GetLastError());
        MessageBoxW(HWND_DESKTOP, text.c_str(), L"Error", MB_ICONERROR);
        return false;
    }

    freopen("CONIN$", "r", stdin);
    freopen("CONOUT$", "w", stdout);
    freopen("CONOUT$", "w", stderr);

    if (!SetConsoleCtrlHandler(CtrlHandler, TRUE))
        return false;

    return true;
}

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow)
{
    if (!OpenConsole())
        return -1;

    g_proc_handle = GetRealCurrentProcess();
    if (g_proc_handle == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "Failed to obtain real process handle.\n");
        return -1;
    }

    auto ver = scl::GetWindowsVersion();
    if (ver < scl::OS_WIN_XP)
    {
        fprintf(stderr, "Unsupported OS version.\n");
        return -1;
    }
    
    WCHAR title[64];
    _snwprintf_s(title, sizeof(title), L"[ScyllaTest] PID: %u", (ULONG)(ULONG_PTR)NtCurrentTeb()->ClientId.UniqueProcess);
    SetConsoleTitleW(title);

    auto is_wow64 = scl::IsWow64Process(g_proc_handle);
    if (!NT_SUCCESS(NtCreateEvent(&g_stopEvent, EVENT_ALL_ACCESS, nullptr, NotificationEvent, FALSE)))
        return -1;

#define SCYLLA_TEST_IF(condition, x)      \
    { ULONG n = printf("%s: ", #x);          \
    if (!(condition)) { PrintScyllaTestResult(ScyllaTestSkip, n); } \
    else { auto ret = Check_ ## x(); PrintScyllaTestResult(ret, n); } }
#define SCYLLA_TEST(x) SCYLLA_TEST_IF(true, x)

    printf("Starting test loop. Press CTRL+C or the power button on your PC to exit.\n\n");
    while (true)
    {
        LARGE_INTEGER timeout;
        timeout.QuadPart = -1LL * 10000LL * 1500LL; // 1500 ms
        if (NtWaitForSingleObject(g_stopEvent, FALSE, &timeout) != STATUS_TIMEOUT)
            break;

        printf("--------------------\n");

        SCYLLA_TEST(PEB_BeingDebugged);
        SCYLLA_TEST_IF(is_wow64, Wow64PEB64_BeingDebugged);
        SCYLLA_TEST(PEB_NtGlobalFlag);
        SCYLLA_TEST_IF(is_wow64, Wow64PEB64_NtGlobalFlag);
        SCYLLA_TEST(PEB_HeapFlags);
        SCYLLA_TEST_IF(is_wow64, Wow64PEB64_HeapFlags);
        SCYLLA_TEST(PEB_ProcessParameters);
        SCYLLA_TEST_IF(is_wow64, Wow64PEB64_ProcessParameters);
        SCYLLA_TEST(IsDebuggerPresent);
        SCYLLA_TEST(CheckRemoteDebuggerPresent);
        SCYLLA_TEST_IF(ver < scl::OS_WIN_VISTA, OutputDebugStringA_LastError);
        SCYLLA_TEST(OutputDebugStringA_Exception);
        SCYLLA_TEST_IF(ver >= scl::OS_WIN_10, OutputDebugStringW_Exception);
        SCYLLA_TEST(NtQueryInformationProcess_ProcessDebugPort);
        SCYLLA_TEST(NtQuerySystemInformation_KernelDebugger);
        SCYLLA_TEST(NtQuery_OverlappingReturnLength);
        SCYLLA_TEST(NtClose);
        SCYLLA_TEST_IF(ver >= scl::OS_WIN_VISTA, OtherOperationCount);

        printf("--------------------\n\n");
    }

    NtClose(g_stopEvent);
    NtClose(g_proc_handle);
    SetConsoleCtrlHandler(nullptr, FALSE);
    FreeConsole();
    return 0;
}



================================================
File: .github/workflows/build.yml
================================================
name: Visual Studio

on: [push, pull_request]

jobs:
  build:
    # Skip building pull requests from the same repository
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository) }}
    runs-on: windows-2019
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Setup VS environment
      uses: ilammy/msvc-dev-cmd@cec98b9d092141f74527d0afa6feb2af698cfe89 # v1.12.0
      with:
        #vsversion: 2019 # blows up on github. lol...
        # toolset should be 14.27, but it's not installed on Github. release.bat will help out here instead so we will eventually get a 14.27 env
        toolset: 14.29

    - name: Build
      run: |
        cmd /c call release.bat

    - name: Get current time
      uses: srfrnk/current-time@5a4163ad035ccd9a407ec9e519c3b6ba1b633d1e # v1.1.0
      id: current-time
      with:
        format: YYYY-MM-DD_HH-MM
    
    - uses: actions/upload-artifact@v3
      with:
        name: ${{ github.event.repository.name }}_${{ steps.current-time.outputs.formattedTime }}
        path: Release/
    
    - name: Compress artifacts
      uses: vimtor/action-zip@26a249fb00d43ca98dad77a4b3838025fc226aa1 # v1.1
      if: ${{ startsWith(github.ref, 'refs/tags/') }}
      with:
        files: Release/
        dest: ${{ github.event.repository.name }}_${{ steps.current-time.outputs.formattedTime }}.zip

    - name: Release
      uses: softprops/action-gh-release@de2c0eb89ae2a093876385947365aca7b0e5f844 # v0.1.15
      if: ${{ startsWith(github.ref, 'refs/tags/') }}
      with:
        prerelease: ${{ !startsWith(github.ref, 'refs/tags/v') || contains(github.ref, '-pre') }}
        files: ${{ github.event.repository.name }}_${{ steps.current-time.outputs.formattedTime }}.zip
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}



Directory structure:
└── washi1337-oldrod/
    ├── README.md
    ├── LICENSE.md
    ├── OldRod.sln
    ├── appveyor.yml
    ├── .editorconfig
    ├── deps/
    │   └── Rivers/
    ├── doc/
    │   ├── Recompiler.md
    │   ├── example-config.json
    │   └── index.md
    ├── src/
    │   ├── OldRod/
    │   │   ├── ConsoleAsciiImage.cs
    │   │   ├── ConsoleLogger.cs
    │   │   ├── OldRod.csproj
    │   │   ├── Program.cs
    │   │   ├── packages.config
    │   │   ├── CommandLine/
    │   │   │   ├── CommandLineParseException.cs
    │   │   │   ├── CommandLineParser.cs
    │   │   │   ├── CommandLineSwitch.cs
    │   │   │   ├── CommandLineSwitches.cs
    │   │   │   └── CommandParseResult.cs
    │   │   ├── Json/
    │   │   │   └── ConstantsConfiguration.cs
    │   │   └── Resources/
    │   ├── OldRod.Core/
    │   │   ├── EmptyLogger.cs
    │   │   ├── FileOutputLogger.cs
    │   │   ├── FilteredLogger.cs
    │   │   ├── ILogger.cs
    │   │   ├── LogCounter.cs
    │   │   ├── LoggerCollection.cs
    │   │   ├── OldRod.Core.csproj
    │   │   ├── Utilities.cs
    │   │   ├── Architecture/
    │   │   │   ├── EHType.cs
    │   │   │   ├── ILCode.cs
    │   │   │   ├── ILFlowControl.cs
    │   │   │   ├── ILInstruction.cs
    │   │   │   ├── ILOpCode.cs
    │   │   │   ├── ILOpCodes.cs
    │   │   │   ├── ILOperandType.cs
    │   │   │   ├── ILStackBehaviour.cs
    │   │   │   ├── KoiStream.cs
    │   │   │   ├── Utils.cs
    │   │   │   ├── VMCalls.cs
    │   │   │   ├── VMConstants.cs
    │   │   │   ├── VMECallOpCode.cs
    │   │   │   ├── VMExportInfo.cs
    │   │   │   ├── VMFlags.cs
    │   │   │   ├── VMFunctionSignature.cs
    │   │   │   ├── VMRegisters.cs
    │   │   │   └── VMType.cs
    │   │   ├── Ast/
    │   │   │   ├── AstNodeCollection.cs
    │   │   │   ├── IAstNode.cs
    │   │   │   ├── Cil/
    │   │   │   │   ├── CilAssignmentStatement.cs
    │   │   │   │   ├── CilAstBlock.cs
    │   │   │   │   ├── CilAstFormatter.cs
    │   │   │   │   ├── CilAstNode.cs
    │   │   │   │   ├── CilCompilationUnit.cs
    │   │   │   │   ├── CilExpression.cs
    │   │   │   │   ├── CilExpressionStatement.cs
    │   │   │   │   ├── CilInstructionExpression.cs
    │   │   │   │   ├── CilParameter.cs
    │   │   │   │   ├── CilStatement.cs
    │   │   │   │   ├── CilUnboxToVmExpression.cs
    │   │   │   │   ├── CilVariable.cs
    │   │   │   │   ├── CilVariableExpression.cs
    │   │   │   │   └── ICilAstVisitor.cs
    │   │   │   └── IL/
    │   │   │       ├── IILArgumentsProvider.cs
    │   │   │       ├── IILAstVisitor.cs
    │   │   │       ├── ILAssignmentStatement.cs
    │   │   │       ├── ILAstBlock.cs
    │   │   │       ├── ILAstBuilder.cs
    │   │   │       ├── ILAstBuilderException.cs
    │   │   │       ├── ILAstNode.cs
    │   │   │       ├── ILCompilationUnit.cs
    │   │   │       ├── ILExceptionExpression.cs
    │   │   │       ├── ILExpression.cs
    │   │   │       ├── ILExpressionStatement.cs
    │   │   │       ├── ILFlagsVariable.cs
    │   │   │       ├── ILInstructionExpression.cs
    │   │   │       ├── ILParameter.cs
    │   │   │       ├── ILPhiExpression.cs
    │   │   │       ├── ILStatement.cs
    │   │   │       ├── ILVCallExpression.cs
    │   │   │       ├── ILVariable.cs
    │   │   │       ├── ILVariableExpression.cs
    │   │   │       ├── VariableUsageCollector.cs
    │   │   │       ├── Pattern/
    │   │   │       │   ├── ILAssignmentPattern.cs
    │   │   │       │   ├── ILAstPattern.cs
    │   │   │       │   ├── ILExpressionPattern.cs
    │   │   │       │   ├── ILExpressionStatementPattern.cs
    │   │   │       │   ├── ILInstructionPattern.cs
    │   │   │       │   ├── ILOpCodePattern.cs
    │   │   │       │   ├── ILOperandPattern.cs
    │   │   │       │   ├── ILSequencePattern.cs
    │   │   │       │   ├── ILStatementPattern.cs
    │   │   │       │   ├── ILVariablePattern.cs
    │   │   │       │   └── MatchResult.cs
    │   │   │       └── Transform/
    │   │   │           ├── FlagDataSourceMarker.cs
    │   │   │           ├── FlagOperationSimplifier.cs
    │   │   │           ├── IILAstTransform.cs
    │   │   │           ├── ILTransformEventArgs.cs
    │   │   │           ├── LogicSimplifier.cs
    │   │   │           ├── PhiRemovalTransform.cs
    │   │   │           ├── PushMinimizer.cs
    │   │   │           ├── SsaTransform.cs
    │   │   │           ├── StackFrameTransform.cs
    │   │   │           ├── TransformLoop.cs
    │   │   │           └── VariableInliner.cs
    │   │   ├── CodeGen/
    │   │   │   ├── CilCodeGenerator.cs
    │   │   │   ├── CilCodeGeneratorException.cs
    │   │   │   ├── CilMethodBodyGenerator.cs
    │   │   │   ├── CodeGenerationContext.cs
    │   │   │   ├── EHComparer.cs
    │   │   │   ├── VmHelper.cs
    │   │   │   ├── VmHelperGenerator.cs
    │   │   │   └── Blocks/
    │   │   │       ├── BasicBlock.cs
    │   │   │       ├── Block.cs
    │   │   │       ├── BlockGenerator.cs
    │   │   │       ├── ExceptionHandlerBlock.cs
    │   │   │       ├── ScopeBlock.cs
    │   │   │       └── TopologicalSorter.cs
    │   │   ├── Disassembly/
    │   │   │   ├── DisassemblyException.cs
    │   │   │   ├── InstructionDecoder.cs
    │   │   │   ├── Annotations/
    │   │   │   │   ├── Annotation.cs
    │   │   │   │   ├── BoxAnnotation.cs
    │   │   │   │   ├── CallAnnotation.cs
    │   │   │   │   ├── CastAnnotation.cs
    │   │   │   │   ├── ECallAnnotation.cs
    │   │   │   │   ├── FieldAnnotation.cs
    │   │   │   │   ├── IMemberProvider.cs
    │   │   │   │   ├── JumpAnnotation.cs
    │   │   │   │   ├── LdftnAnnotation.cs
    │   │   │   │   ├── ThrowAnnotation.cs
    │   │   │   │   ├── TokenAnnotation.cs
    │   │   │   │   ├── TypeAnnotation.cs
    │   │   │   │   ├── UnboxAnnotation.cs
    │   │   │   │   └── VCallAnnotation.cs
    │   │   │   ├── ControlFlow/
    │   │   │   │   ├── ControlFlowGraph.cs
    │   │   │   │   ├── ControlFlowGraphBuilder.cs
    │   │   │   │   └── ILBasicBlock.cs
    │   │   │   ├── DataFlow/
    │   │   │   │   ├── EHFrame.cs
    │   │   │   │   ├── ProgramState.cs
    │   │   │   │   ├── RegisterState.cs
    │   │   │   │   ├── StackState.cs
    │   │   │   │   └── SymbolicValue.cs
    │   │   │   └── Inference/
    │   │   │       ├── FunctionEventArgs.cs
    │   │   │       ├── FunctionReference.cs
    │   │   │       ├── FunctionReferenceType.cs
    │   │   │       ├── IExitKeyResolver.cs
    │   │   │       ├── ISMCTrampolineDetector.cs
    │   │   │       ├── IVMFunctionFactory.cs
    │   │   │       ├── InferenceDisassembler.cs
    │   │   │       ├── InstructionProcessor.cs
    │   │   │       ├── VCallProcessor.cs
    │   │   │       └── VMFunction.cs
    │   │   ├── Emulation/
    │   │   │   ├── EmulationException.cs
    │   │   │   ├── InstructionEmulator.cs
    │   │   │   └── VMSlot.cs
    │   │   ├── Memory/
    │   │   │   ├── DefaultFrameLayout.cs
    │   │   │   ├── DefaultFrameLayoutDetector.cs
    │   │   │   ├── FrameField.cs
    │   │   │   ├── FrameFieldKind.cs
    │   │   │   ├── FrameLayoutDetectionException.cs
    │   │   │   ├── IFrameLayout.cs
    │   │   │   └── IFrameLayoutDetector.cs
    │   │   └── Recompiler/
    │   │       ├── ILToCilRecompiler.cs
    │   │       ├── IVMFunctionResolver.cs
    │   │       ├── RecompilerContext.cs
    │   │       ├── RecompilerException.cs
    │   │       ├── RecompilerService.cs
    │   │       ├── IL/
    │   │       │   ├── CallRecompiler.cs
    │   │       │   ├── CmpRecompiler.cs
    │   │       │   ├── IOpCodeRecompiler.cs
    │   │       │   ├── NopRecompiler.cs
    │   │       │   ├── PushRecompiler.cs
    │   │       │   ├── RelationalOpCodeRecompiler.cs
    │   │       │   ├── SimpleOpCodeRecompiler.cs
    │   │       │   └── SindRecompiler.cs
    │   │       ├── Transform/
    │   │       │   ├── ArrayAccessTransform.cs
    │   │       │   ├── BoxMinimizer.cs
    │   │       │   ├── CilTransformEventArgs.cs
    │   │       │   ├── ICilAstTransform.cs
    │   │       │   ├── TypeConversionInsertion.cs
    │   │       │   ├── TypeHelper.cs
    │   │       │   └── TypeInference.cs
    │   │       └── VCall/
    │   │           ├── BoxRecompiler.cs
    │   │           ├── CastRecompiler.cs
    │   │           ├── CkOverflowRecompiler.cs
    │   │           ├── ECallRecompiler.cs
    │   │           ├── IVCallRecompiler.cs
    │   │           ├── InitObjRecompiler.cs
    │   │           ├── LdfldRecompiler.cs
    │   │           ├── LdftnRecompiler.cs
    │   │           ├── LocallocRecompiler.cs
    │   │           ├── SizeOfRecompiler.cs
    │   │           ├── StfldRecompiler.cs
    │   │           ├── ThrowRecompiler.cs
    │   │           ├── TokenRecompiler.cs
    │   │           └── UnboxRecompiler.cs
    │   └── OldRod.Pipeline/
    │       ├── BasicBlockSerializer.cs
    │       ├── DebuggingUtilities.cs
    │       ├── DevirtualisationContext.cs
    │       ├── DevirtualisationException.cs
    │       ├── DevirtualisationOptions.cs
    │       ├── Devirtualiser.cs
    │       ├── IdSelection.cs
    │       ├── KoiVmAwareStreamReader.cs
    │       ├── OldRod.Pipeline.csproj
    │       ├── OutputOptions.cs
    │       ├── VirtualisedMethod.cs
    │       └── Stages/
    │           ├── IStage.cs
    │           ├── AstBuilding/
    │           │   └── AstBuilderStage.cs
    │           ├── CleanUp/
    │           │   └── CleanUpStage.cs
    │           ├── CodeAnalysis/
    │           │   └── CodeAnalysisStage.cs
    │           ├── ConstantsResolution/
    │           │   └── ConstantsResolutionStage.cs
    │           ├── OpCodeResolution/
    │           │   ├── OpCodeInfo.cs
    │           │   ├── OpCodeInterfaceInfo.cs
    │           │   ├── OpCodeMapping.cs
    │           │   └── OpCodeResolutionStage.cs
    │           ├── Recompiling/
    │           │   └── RecompilerStage.cs
    │           ├── VMCodeRecovery/
    │           │   ├── BasicSMCTrampolineDetector.cs
    │           │   ├── ExportsAwareFunctionFactory.cs
    │           │   ├── SimpleExitKeyBruteForce.cs
    │           │   └── VMCodeRecoveryStage.cs
    │           └── VMMethodDetection/
    │               ├── VMEntryInfo.cs
    │               └── VMMethodDetectionStage.cs
    └── .github/
        └── ISSUE_TEMPLATE/
            ├── bug_report.md
            └── feature_request.md

================================================
File: README.md
================================================
Project Old Rod - KoiVM Devirtualisation tool
=============================================
[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)  [![Master branch build status](https://img.shields.io/appveyor/ci/Washi1337/OldRod/master.svg)](https://ci.appveyor.com/project/Washi1337/OldRod/branch/master)

Project Old Rod is an automated command-line utility that attempts to disassemble any .NET application protected by the KoiVM virtualiser plugin for ConfuserEx. Additionally, it tries to recompile the VM code back to .NET CIL in an attempt to recover the original code. 

Project Old Rod is released under the GPLv3 license.

Usage:
------

- **N00b users:**
    Just drag and drop the protected executable in `OldRod` and observe how the majestic Magikarp fixes your code all by itself. Pretty nice huh?

- **Advanced users:**
    Old Rod has a lot of features! Type the following command in a terminal to get an overview of all available options and flags:
    ```
    OldRod.exe --help
    ```

    Some of the niceties include:
    - `--output-directory`, which sets the output directory (who would have thought!?).
    - `--koi-stream-name`, `--koi-stream-data`, `--entry-type`, `--constants-type`, `--run-sig-1` and `--run-sig-2` which help the magestic Magikarp finding the data it needs.
    - `--config` for providing a custom constants mapping, see [example-config.json](doc/example-config.json) for an example configuration file.
    - `--no-pause` if you don't like pressing a key to continue at the end of it all.

    Examples:
    - Use KoiVM stream name `#CustomName`: 
      ```
      OldRod.exe --koi-stream-name #CustomName 
      ```
    - Use custom type parameters for the run methods:
      ```
      OldRod.exe --run-sig-1 System.RuntimeTypeHandle,System.UInt32,System.Object[] --run-sig-2 System.RuntimeTypeHandle,System.UInt32,System.Void*[],System.Void*,System.String
      ```
  
Dependencies
------------
The devirtualiser is powered by the following projects:
- [AsmResolver](https://github.com/Washi1337/AsmResolver): .NET inspection library [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
- [Rivers](https://github.com/Washi1337/Rivers): Graph analysis library [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
- [Newtonsoft.JSON](https://github.com/JamesNK/Newtonsoft.Json): JSON file parser.  [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

These are submodules or nuget packages. Be sure to clone/restore all of them when building the project.

Binaries
---------
Get the latest build from the [AppVeyor build server](https://ci.appveyor.com/project/Washi1337/oldrod/build/artifacts). 

Alternatively, you can build the project yourself using MSBuild or an IDE that works with MSBuild (such as Visual Studio and JetBrains Rider).


FAQ
===

Is Old Rod a deobfuscator?
-------------------------
No. It only disassembles the code and recompiles it. It will not simplify control flow, nor will it decrypt your strings, simplify arithmetic expressions, rename all symbols, decrypt resources, or anything like that. For this, other tools exist.

Will Old Rod support modifications of KoiVM?
--------------------------------------------
Yes and no.

Old Rod's recompiler is quite generic and is built to be able to resist several architectural changes. For example, it does not rely on hardcoded opcode sequences or the like in the actual virtualized code. See [here](/doc/Recompiler.md) for more information on how that is done. Furthermore, there are some command-line arguments that you can use to override certain auto detection systems and behaviour (see `OldRod.exe --help`).

That being said, it will always be possible to break Old Rod's automatic detection systems with very minimal changes to vanilla KoiVM (lazy modifications such as changing the signature of the methods in `VMEntry` or `VMConstants`). It is not worth the time and effort to support each and every one of them that can be found on the internet, unless one of these mods gets very popular. Therefore, don't expect drag-n-drop to always work on binaries protected by modifications of KoiVM, nor support for them in the near future.


Heeeeeelp! it...
-----------------

- ... crashes,
- ... prints errors I don't want to read,
- ... produces corrupted files.

These are features, not bugs. You can turn them off by using:
```
OldRod.exe <input-file> --dont-crash --no-errors --no-output-corruption
```

If the above does not work, please consider going to the [issue tracker](https://github.com/Washi1337/OldRod/issues) and file a _detailed_ bug report, **preferably using the issue template and sample binary**. 

How do I troubleshoot Old Rod?
-----------------------------
Old Rod has quite a few diagnostics built-in that might help you out:
- `--verbose` (`-v`) or `--very-verbose` (`-vv`) will print debug and full error messages to the standard output.
- `--log-file` will produce a `report.log` in the output directory containing a log that is similar to enabling `--verbose`. You don't need to include `--verbose` to get a verbose output in the log file.
- `--dump-il`, `--dump-cil`, `--dump-cfg` and/or `--dump-cfg-all` will create all kinds of dumps of intermediate steps of the devirtualisation process in the output directory.
- `--rename-symbols` will rename most (but not all) symbols in the KoiVM runtime library to something more meaningful.
- `--only-export 1,2,3` or `--ignore-export 1,2,3` will only include or exclude exports 1, 2 and 3 respectively.
- `--salvage` will let the devirtualiser try to recover from errors as much as possible. Note that this is a very mysterious feature, and enabling this feature might have cool side-effects and result in incorrect binaries being produced.

Why did you create this?
------------------------
I thought it would be a cool project. 

Why did you release this?
-------------------------
The original author of KoiVM [released the source code for free](https://github.com/yck1509/KoiVM).

Why is the project so complicated?
----------------------------------
Because KoiVM is more complicated than the average VM that is out there for .NET. Check out the [docs](doc/) to find out how the recompiler works.

Also I am probably not the best coder or reverse engineer.

Couldn't you just use pattern matching for every CIL instruction like normal people?
------------------------------------------------------------------------------------
Sure, but I am stubborn, I don't like to write countless of patterns, and I like writing compilers. The last reason is also the main reason this project was started in the first place.

What is the OldRod.Core.CodeGen namespace that is injected?
-----------------------------------------------------------
Not all instructions are always perfectly translated to CIL, and still require some of the original features of KoiVM (most notably, the flags register as the CLR does not have one). For this, the code generator might inject some code to emulate the behaviour of these features. This is put into this namespace.

What's with the name and the Magikarp?
--------------------------------------
In the original release of KoiVM, the plugin description mentions a Magikarp virtualising your code. In the original PokÃ©mon games, the best way to catch a Magikarp is using an old rod. 

...

Honestly, I don't know, I am probably weird...



================================================
File: LICENSE.md
================================================
GNU General Public License
==========================

_Version 3, 29 June 2007_  
_Copyright © 2007 Free Software Foundation, Inc. &lt;<http://fsf.org/>&gt;_

Everyone is permitted to copy and distribute verbatim copies of this license
document, but changing it is not allowed.

## Preamble

The GNU General Public License is a free, copyleft license for software and other
kinds of works.

The licenses for most software and other practical works are designed to take away
your freedom to share and change the works. By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change all versions of a
program--to make sure it remains free software for all its users. We, the Free
Software Foundation, use the GNU General Public License for most of our software; it
applies also to any other work released this way by its authors. You can apply it to
your programs, too.

When we speak of free software, we are referring to freedom, not price. Our General
Public Licenses are designed to make sure that you have the freedom to distribute
copies of free software (and charge for them if you wish), that you receive source
code or can get it if you want it, that you can change the software or use pieces of
it in new free programs, and that you know you can do these things.

To protect your rights, we need to prevent others from denying you these rights or
asking you to surrender the rights. Therefore, you have certain responsibilities if
you distribute copies of the software, or if you modify it: responsibilities to
respect the freedom of others.

For example, if you distribute copies of such a program, whether gratis or for a fee,
you must pass on to the recipients the same freedoms that you received. You must make
sure that they, too, receive or can get the source code. And you must show them these
terms so they know their rights.

Developers that use the GNU GPL protect your rights with two steps: **(1)** assert
copyright on the software, and **(2)** offer you this License giving you legal permission
to copy, distribute and/or modify it.

For the developers' and authors' protection, the GPL clearly explains that there is
no warranty for this free software. For both users' and authors' sake, the GPL
requires that modified versions be marked as changed, so that their problems will not
be attributed erroneously to authors of previous versions.

Some devices are designed to deny users access to install or run modified versions of
the software inside them, although the manufacturer can do so. This is fundamentally
incompatible with the aim of protecting users' freedom to change the software. The
systematic pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable. Therefore, we have designed
this version of the GPL to prohibit the practice for those products. If such problems
arise substantially in other domains, we stand ready to extend this provision to
those domains in future versions of the GPL, as needed to protect the freedom of
users.

Finally, every program is threatened constantly by software patents. States should
not allow patents to restrict development and use of software on general-purpose
computers, but in those that do, we wish to avoid the special danger that patents
applied to a free program could make it effectively proprietary. To prevent this, the
GPL assures that patents cannot be used to render the program non-free.

The precise terms and conditions for copying, distribution and modification follow.

## TERMS AND CONDITIONS

### 0. Definitions

“This License” refers to version 3 of the GNU General Public License.

“Copyright” also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

“The Program” refers to any copyrightable work licensed under this
License. Each licensee is addressed as “you”. “Licensees” and
“recipients” may be individuals or organizations.

To “modify” a work means to copy from or adapt all or part of the work in
a fashion requiring copyright permission, other than the making of an exact copy. The
resulting work is called a “modified version” of the earlier work or a
work “based on” the earlier work.

A “covered work” means either the unmodified Program or a work based on
the Program.

To “propagate” a work means to do anything with it that, without
permission, would make you directly or secondarily liable for infringement under
applicable copyright law, except executing it on a computer or modifying a private
copy. Propagation includes copying, distribution (with or without modification),
making available to the public, and in some countries other activities as well.

To “convey” a work means any kind of propagation that enables other
parties to make or receive copies. Mere interaction with a user through a computer
network, with no transfer of a copy, is not conveying.

An interactive user interface displays “Appropriate Legal Notices” to the
extent that it includes a convenient and prominently visible feature that **(1)**
displays an appropriate copyright notice, and **(2)** tells the user that there is no
warranty for the work (except to the extent that warranties are provided), that
licensees may convey the work under this License, and how to view a copy of this
License. If the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

### 1. Source Code

The “source code” for a work means the preferred form of the work for
making modifications to it. “Object code” means any non-source form of a
work.

A “Standard Interface” means an interface that either is an official
standard defined by a recognized standards body, or, in the case of interfaces
specified for a particular programming language, one that is widely used among
developers working in that language.

The “System Libraries” of an executable work include anything, other than
the work as a whole, that **(a)** is included in the normal form of packaging a Major
Component, but which is not part of that Major Component, and **(b)** serves only to
enable use of the work with that Major Component, or to implement a Standard
Interface for which an implementation is available to the public in source code form.
A “Major Component”, in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system (if any) on which
the executable work runs, or a compiler used to produce the work, or an object code
interpreter used to run it.

The “Corresponding Source” for a work in object code form means all the
source code needed to generate, install, and (for an executable work) run the object
code and to modify the work, including scripts to control those activities. However,
it does not include the work's System Libraries, or general-purpose tools or
generally available free programs which are used unmodified in performing those
activities but which are not part of the work. For example, Corresponding Source
includes interface definition files associated with source files for the work, and
the source code for shared libraries and dynamically linked subprograms that the work
is specifically designed to require, such as by intimate data communication or
control flow between those subprograms and other parts of the work.

The Corresponding Source need not include anything that users can regenerate
automatically from other parts of the Corresponding Source.

The Corresponding Source for a work in source code form is that same work.

### 2. Basic Permissions

All rights granted under this License are granted for the term of copyright on the
Program, and are irrevocable provided the stated conditions are met. This License
explicitly affirms your unlimited permission to run the unmodified Program. The
output from running a covered work is covered by this License only if the output,
given its content, constitutes a covered work. This License acknowledges your rights
of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not convey, without
conditions so long as your license otherwise remains in force. You may convey covered
works to others for the sole purpose of having them make modifications exclusively
for you, or provide you with facilities for running those works, provided that you
comply with the terms of this License in conveying all material for which you do not
control copyright. Those thus making or running the covered works for you must do so
exclusively on your behalf, under your direction and control, on terms that prohibit
them from making any copies of your copyrighted material outside their relationship
with you.

Conveying under any other circumstances is permitted solely under the conditions
stated below. Sublicensing is not allowed; section 10 makes it unnecessary.

### 3. Protecting Users' Legal Rights From Anti-Circumvention Law

No covered work shall be deemed part of an effective technological measure under any
applicable law fulfilling obligations under article 11 of the WIPO copyright treaty
adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention
of such measures.

When you convey a covered work, you waive any legal power to forbid circumvention of
technological measures to the extent such circumvention is effected by exercising
rights under this License with respect to the covered work, and you disclaim any
intention to limit operation or modification of the work as a means of enforcing,
against the work's users, your or third parties' legal rights to forbid circumvention
of technological measures.

### 4. Conveying Verbatim Copies

You may convey verbatim copies of the Program's source code as you receive it, in any
medium, provided that you conspicuously and appropriately publish on each copy an
appropriate copyright notice; keep intact all notices stating that this License and
any non-permissive terms added in accord with section 7 apply to the code; keep
intact all notices of the absence of any warranty; and give all recipients a copy of
this License along with the Program.

You may charge any price or no price for each copy that you convey, and you may offer
support or warranty protection for a fee.

### 5. Conveying Modified Source Versions

You may convey a work based on the Program, or the modifications to produce it from
the Program, in the form of source code under the terms of section 4, provided that
you also meet all of these conditions:

* **a)** The work must carry prominent notices stating that you modified it, and giving a
relevant date.
* **b)** The work must carry prominent notices stating that it is released under this
License and any conditions added under section 7. This requirement modifies the
requirement in section 4 to “keep intact all notices”.
* **c)** You must license the entire work, as a whole, under this License to anyone who
comes into possession of a copy. This License will therefore apply, along with any
applicable section 7 additional terms, to the whole of the work, and all its parts,
regardless of how they are packaged. This License gives no permission to license the
work in any other way, but it does not invalidate such permission if you have
separately received it.
* **d)** If the work has interactive user interfaces, each must display Appropriate Legal
Notices; however, if the Program has interactive interfaces that do not display
Appropriate Legal Notices, your work need not make them do so.

A compilation of a covered work with other separate and independent works, which are
not by their nature extensions of the covered work, and which are not combined with
it such as to form a larger program, in or on a volume of a storage or distribution
medium, is called an “aggregate” if the compilation and its resulting
copyright are not used to limit the access or legal rights of the compilation's users
beyond what the individual works permit. Inclusion of a covered work in an aggregate
does not cause this License to apply to the other parts of the aggregate.

### 6. Conveying Non-Source Forms

You may convey a covered work in object code form under the terms of sections 4 and
5, provided that you also convey the machine-readable Corresponding Source under the
terms of this License, in one of these ways:

* **a)** Convey the object code in, or embodied in, a physical product (including a
physical distribution medium), accompanied by the Corresponding Source fixed on a
durable physical medium customarily used for software interchange.
* **b)** Convey the object code in, or embodied in, a physical product (including a
physical distribution medium), accompanied by a written offer, valid for at least
three years and valid for as long as you offer spare parts or customer support for
that product model, to give anyone who possesses the object code either **(1)** a copy of
the Corresponding Source for all the software in the product that is covered by this
License, on a durable physical medium customarily used for software interchange, for
a price no more than your reasonable cost of physically performing this conveying of
source, or **(2)** access to copy the Corresponding Source from a network server at no
charge.
* **c)** Convey individual copies of the object code with a copy of the written offer to
provide the Corresponding Source. This alternative is allowed only occasionally and
noncommercially, and only if you received the object code with such an offer, in
accord with subsection 6b.
* **d)** Convey the object code by offering access from a designated place (gratis or for
a charge), and offer equivalent access to the Corresponding Source in the same way
through the same place at no further charge. You need not require recipients to copy
the Corresponding Source along with the object code. If the place to copy the object
code is a network server, the Corresponding Source may be on a different server
(operated by you or a third party) that supports equivalent copying facilities,
provided you maintain clear directions next to the object code saying where to find
the Corresponding Source. Regardless of what server hosts the Corresponding Source,
you remain obligated to ensure that it is available for as long as needed to satisfy
these requirements.
* **e)** Convey the object code using peer-to-peer transmission, provided you inform
other peers where the object code and Corresponding Source of the work are being
offered to the general public at no charge under subsection 6d.

A separable portion of the object code, whose source code is excluded from the
Corresponding Source as a System Library, need not be included in conveying the
object code work.

A “User Product” is either **(1)** a “consumer product”, which
means any tangible personal property which is normally used for personal, family, or
household purposes, or **(2)** anything designed or sold for incorporation into a
dwelling. In determining whether a product is a consumer product, doubtful cases
shall be resolved in favor of coverage. For a particular product received by a
particular user, “normally used” refers to a typical or common use of
that class of product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected to use, the
product. A product is a consumer product regardless of whether the product has
substantial commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

“Installation Information” for a User Product means any methods,
procedures, authorization keys, or other information required to install and execute
modified versions of a covered work in that User Product from a modified version of
its Corresponding Source. The information must suffice to ensure that the continued
functioning of the modified object code is in no case prevented or interfered with
solely because modification has been made.

If you convey an object code work under this section in, or with, or specifically for
use in, a User Product, and the conveying occurs as part of a transaction in which
the right of possession and use of the User Product is transferred to the recipient
in perpetuity or for a fixed term (regardless of how the transaction is
characterized), the Corresponding Source conveyed under this section must be
accompanied by the Installation Information. But this requirement does not apply if
neither you nor any third party retains the ability to install modified object code
on the User Product (for example, the work has been installed in ROM).

The requirement to provide Installation Information does not include a requirement to
continue to provide support service, warranty, or updates for a work that has been
modified or installed by the recipient, or for the User Product in which it has been
modified or installed. Access to a network may be denied when the modification itself
materially and adversely affects the operation of the network or violates the rules
and protocols for communication across the network.

Corresponding Source conveyed, and Installation Information provided, in accord with
this section must be in a format that is publicly documented (and with an
implementation available to the public in source code form), and must require no
special password or key for unpacking, reading or copying.

### 7. Additional Terms

“Additional permissions” are terms that supplement the terms of this
License by making exceptions from one or more of its conditions. Additional
permissions that are applicable to the entire Program shall be treated as though they
were included in this License, to the extent that they are valid under applicable
law. If additional permissions apply only to part of the Program, that part may be
used separately under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option remove any
additional permissions from that copy, or from any part of it. (Additional
permissions may be written to require their own removal in certain cases when you
modify the work.) You may place additional permissions on material, added by you to a
covered work, for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you add to a
covered work, you may (if authorized by the copyright holders of that material)
supplement the terms of this License with terms:

* **a)** Disclaiming warranty or limiting liability differently from the terms of
sections 15 and 16 of this License; or
* **b)** Requiring preservation of specified reasonable legal notices or author
attributions in that material or in the Appropriate Legal Notices displayed by works
containing it; or
* **c)** Prohibiting misrepresentation of the origin of that material, or requiring that
modified versions of such material be marked in reasonable ways as different from the
original version; or
* **d)** Limiting the use for publicity purposes of names of licensors or authors of the
material; or
* **e)** Declining to grant rights under trademark law for use of some trade names,
trademarks, or service marks; or
* **f)** Requiring indemnification of licensors and authors of that material by anyone
who conveys the material (or modified versions of it) with contractual assumptions of
liability to the recipient, for any liability that these contractual assumptions
directly impose on those licensors and authors.

All other non-permissive additional terms are considered “further
restrictions” within the meaning of section 10. If the Program as you received
it, or any part of it, contains a notice stating that it is governed by this License
along with a term that is a further restriction, you may remove that term. If a
license document contains a further restriction but permits relicensing or conveying
under this License, you may add to a covered work material governed by the terms of
that license document, provided that the further restriction does not survive such
relicensing or conveying.

If you add terms to a covered work in accord with this section, you must place, in
the relevant source files, a statement of the additional terms that apply to those
files, or a notice indicating where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the form of a
separately written license, or stated as exceptions; the above requirements apply
either way.

### 8. Termination

You may not propagate or modify a covered work except as expressly provided under
this License. Any attempt otherwise to propagate or modify it is void, and will
automatically terminate your rights under this License (including any patent licenses
granted under the third paragraph of section 11).

However, if you cease all violation of this License, then your license from a
particular copyright holder is reinstated **(a)** provisionally, unless and until the
copyright holder explicitly and finally terminates your license, and **(b)** permanently,
if the copyright holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is reinstated permanently
if the copyright holder notifies you of the violation by some reasonable means, this
is the first time you have received notice of violation of this License (for any
work) from that copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the licenses of
parties who have received copies or rights from you under this License. If your
rights have been terminated and not permanently reinstated, you do not qualify to
receive new licenses for the same material under section 10.

### 9. Acceptance Not Required for Having Copies

You are not required to accept this License in order to receive or run a copy of the
Program. Ancillary propagation of a covered work occurring solely as a consequence of
using peer-to-peer transmission to receive a copy likewise does not require
acceptance. However, nothing other than this License grants you permission to
propagate or modify any covered work. These actions infringe copyright if you do not
accept this License. Therefore, by modifying or propagating a covered work, you
indicate your acceptance of this License to do so.

### 10. Automatic Licensing of Downstream Recipients

Each time you convey a covered work, the recipient automatically receives a license
from the original licensors, to run, modify and propagate that work, subject to this
License. You are not responsible for enforcing compliance by third parties with this
License.

An “entity transaction” is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an organization, or
merging organizations. If propagation of a covered work results from an entity
transaction, each party to that transaction who receives a copy of the work also
receives whatever licenses to the work the party's predecessor in interest had or
could give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if the predecessor
has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the rights granted or
affirmed under this License. For example, you may not impose a license fee, royalty,
or other charge for exercise of rights granted under this License, and you may not
initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging
that any patent claim is infringed by making, using, selling, offering for sale, or
importing the Program or any portion of it.

### 11. Patents

A “contributor” is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based. The work thus
licensed is called the contributor's “contributor version”.

A contributor's “essential patent claims” are all patent claims owned or
controlled by the contributor, whether already acquired or hereafter acquired, that
would be infringed by some manner, permitted by this License, of making, using, or
selling its contributor version, but do not include claims that would be infringed
only as a consequence of further modification of the contributor version. For
purposes of this definition, “control” includes the right to grant patent
sublicenses in a manner consistent with the requirements of this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free patent license
under the contributor's essential patent claims, to make, use, sell, offer for sale,
import and otherwise run, modify and propagate the contents of its contributor
version.

In the following three paragraphs, a “patent license” is any express
agreement or commitment, however denominated, not to enforce a patent (such as an
express permission to practice a patent or covenant not to sue for patent
infringement). To “grant” such a patent license to a party means to make
such an agreement or commitment not to enforce a patent against the party.

If you convey a covered work, knowingly relying on a patent license, and the
Corresponding Source of the work is not available for anyone to copy, free of charge
and under the terms of this License, through a publicly available network server or
other readily accessible means, then you must either **(1)** cause the Corresponding
Source to be so available, or **(2)** arrange to deprive yourself of the benefit of the
patent license for this particular work, or **(3)** arrange, in a manner consistent with
the requirements of this License, to extend the patent license to downstream
recipients. “Knowingly relying” means you have actual knowledge that, but
for the patent license, your conveying the covered work in a country, or your
recipient's use of the covered work in a country, would infringe one or more
identifiable patents in that country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or arrangement, you
convey, or propagate by procuring conveyance of, a covered work, and grant a patent
license to some of the parties receiving the covered work authorizing them to use,
propagate, modify or convey a specific copy of the covered work, then the patent
license you grant is automatically extended to all recipients of the covered work and
works based on it.

A patent license is “discriminatory” if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on the
non-exercise of one or more of the rights that are specifically granted under this
License. You may not convey a covered work if you are a party to an arrangement with
a third party that is in the business of distributing software, under which you make
payment to the third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties who would receive
the covered work from you, a discriminatory patent license **(a)** in connection with
copies of the covered work conveyed by you (or copies made from those copies), or **(b)**
primarily for and in connection with specific products or compilations that contain
the covered work, unless you entered into that arrangement, or that patent license
was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting any implied
license or other defenses to infringement that may otherwise be available to you
under applicable patent law.

### 12. No Surrender of Others' Freedom

If conditions are imposed on you (whether by court order, agreement or otherwise)
that contradict the conditions of this License, they do not excuse you from the
conditions of this License. If you cannot convey a covered work so as to satisfy
simultaneously your obligations under this License and any other pertinent
obligations, then as a consequence you may not convey it at all. For example, if you
agree to terms that obligate you to collect a royalty for further conveying from
those to whom you convey the Program, the only way you could satisfy both those terms
and this License would be to refrain entirely from conveying the Program.

### 13. Use with the GNU Affero General Public License

Notwithstanding any other provision of this License, you have permission to link or
combine any covered work with a work licensed under version 3 of the GNU Affero
General Public License into a single combined work, and to convey the resulting work.
The terms of this License will continue to apply to the part which is the covered
work, but the special requirements of the GNU Affero General Public License, section
13, concerning interaction through a network will apply to the combination as such.

### 14. Revised Versions of this License

The Free Software Foundation may publish revised and/or new versions of the GNU
General Public License from time to time. Such new versions will be similar in spirit
to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number. If the Program specifies that
a certain numbered version of the GNU General Public License “or any later
version” applies to it, you have the option of following the terms and
conditions either of that numbered version or of any later version published by the
Free Software Foundation. If the Program does not specify a version number of the GNU
General Public License, you may choose any version ever published by the Free
Software Foundation.

If the Program specifies that a proxy can decide which future versions of the GNU
General Public License can be used, that proxy's public statement of acceptance of a
version permanently authorizes you to choose that version for the Program.

Later license versions may give you additional or different permissions. However, no
additional obligations are imposed on any author or copyright holder as a result of
your choosing to follow a later version.

### 15. Disclaimer of Warranty

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE
QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

### 16. Limitation of Liability

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY
COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS
PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE
WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

### 17. Interpretation of Sections 15 and 16

If the disclaimer of warranty and limitation of liability provided above cannot be
given local legal effect according to their terms, reviewing courts shall apply local
law that most closely approximates an absolute waiver of all civil liability in
connection with the Program, unless a warranty or assumption of liability accompanies
a copy of the Program in return for a fee.

_END OF TERMS AND CONDITIONS_


================================================
File: OldRod.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "OldRod", "src\OldRod\OldRod.csproj", "{B909EF5F-7621-4DCF-988F-EF2FBD6DBC77}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "OldRod.Core", "src\OldRod.Core\OldRod.Core.csproj", "{19AE2108-A02E-4434-B44A-FAC1F7279DFE}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "OldRod.Pipeline", "src\OldRod.Pipeline\OldRod.Pipeline.csproj", "{FF063C6A-2CAF-4870-8E5F-F83F42B19F36}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Rivers", "deps\Rivers\Rivers\Rivers.csproj", "{A69FCA6D-3FDC-4BE2-95E1-6312418D1BA2}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "deps", "deps", "{E2E7F909-A9C3-41D5-9D9A-9176999AE712}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{5503AF20-DBCA-4262-8021-8654F15C6BE5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B909EF5F-7621-4DCF-988F-EF2FBD6DBC77}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B909EF5F-7621-4DCF-988F-EF2FBD6DBC77}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B909EF5F-7621-4DCF-988F-EF2FBD6DBC77}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B909EF5F-7621-4DCF-988F-EF2FBD6DBC77}.Release|Any CPU.Build.0 = Release|Any CPU
		{19AE2108-A02E-4434-B44A-FAC1F7279DFE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{19AE2108-A02E-4434-B44A-FAC1F7279DFE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{19AE2108-A02E-4434-B44A-FAC1F7279DFE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{19AE2108-A02E-4434-B44A-FAC1F7279DFE}.Release|Any CPU.Build.0 = Release|Any CPU
		{FF063C6A-2CAF-4870-8E5F-F83F42B19F36}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FF063C6A-2CAF-4870-8E5F-F83F42B19F36}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FF063C6A-2CAF-4870-8E5F-F83F42B19F36}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FF063C6A-2CAF-4870-8E5F-F83F42B19F36}.Release|Any CPU.Build.0 = Release|Any CPU
		{A69FCA6D-3FDC-4BE2-95E1-6312418D1BA2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A69FCA6D-3FDC-4BE2-95E1-6312418D1BA2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A69FCA6D-3FDC-4BE2-95E1-6312418D1BA2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A69FCA6D-3FDC-4BE2-95E1-6312418D1BA2}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{B909EF5F-7621-4DCF-988F-EF2FBD6DBC77} = {5503AF20-DBCA-4262-8021-8654F15C6BE5}
		{19AE2108-A02E-4434-B44A-FAC1F7279DFE} = {5503AF20-DBCA-4262-8021-8654F15C6BE5}
		{FF063C6A-2CAF-4870-8E5F-F83F42B19F36} = {5503AF20-DBCA-4262-8021-8654F15C6BE5}
		{A69FCA6D-3FDC-4BE2-95E1-6312418D1BA2} = {E2E7F909-A9C3-41D5-9D9A-9176999AE712}
	EndGlobalSection
EndGlobal



================================================
File: appveyor.yml
================================================
-
  branches:
    only:
      - master
  
  image: Visual Studio 2022
  version: 0.10.{build}
  configuration: Release

  install:
    - cmd: git submodule update --init
  
  before_build:
    - cmd: nuget restore

  build:
    project: OldRod.sln
    verbosity: minimal

  artifacts:
    - path: src/OldRod/bin/Release




================================================
File: .editorconfig
================================================

[*]
charset = utf-8
end_of_line = crlf
trim_trailing_whitespace = false
insert_final_newline = false
indent_style = space
indent_size = 4

# Microsoft .NET properties
csharp_new_line_before_members_in_object_initializers = false
csharp_preferred_modifier_order = public, private, protected, internal, new, abstract, virtual, sealed, override, static, readonly, extern, unsafe, volatile, async:suggestion
csharp_style_var_elsewhere = true:suggestion
csharp_style_var_for_built_in_types = false:suggestion
csharp_style_var_when_type_is_apparent = true:suggestion
dotnet_style_parentheses_in_arithmetic_binary_operators = never_if_unnecessary:none
dotnet_style_parentheses_in_other_binary_operators = never_if_unnecessary:none
dotnet_style_parentheses_in_relational_binary_operators = never_if_unnecessary:none
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_predefined_type_for_member_access = true:suggestion
dotnet_style_qualification_for_event = false:suggestion
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
dotnet_style_require_accessibility_modifiers = for_non_interface_members:suggestion

# ReSharper properties
resharper_autodetect_indent_settings = true
resharper_csharp_naming_rule.enum_member = AaBb, AA_BB
resharper_csharp_wrap_before_binary_opsign = true
resharper_csharp_wrap_before_first_type_parameter_constraint = true
resharper_keep_existing_embedded_arrangement = false
resharper_keep_existing_switch_expression_arrangement = false
resharper_max_array_initializer_elements_on_line = 20
resharper_max_enum_members_on_line = 1
resharper_max_initializer_elements_on_line = 1
resharper_place_abstract_accessorholder_on_single_line = false
resharper_place_attribute_on_same_line = false
resharper_place_constructor_initializer_on_same_line = false
resharper_place_simple_embedded_statement_on_same_line = false
resharper_place_simple_initializer_on_single_line = false
resharper_use_indent_from_vs = false
resharper_wrap_array_initializer_style = chop_if_long

# ReSharper inspection severities
resharper_arrange_redundant_parentheses_highlighting = hint
resharper_arrange_this_qualifier_highlighting = hint
resharper_arrange_type_member_modifiers_highlighting = hint
resharper_arrange_type_modifiers_highlighting = hint
resharper_built_in_type_reference_style_for_member_access_highlighting = hint
resharper_built_in_type_reference_style_highlighting = hint
resharper_inconsistent_naming_highlighting = hint
resharper_introduce_optional_parameters_global_highlighting = none
resharper_loop_can_be_converted_to_query_highlighting = none
resharper_redundant_base_qualifier_highlighting = warning
resharper_shift_expression_real_shift_count_is_zero_highlighting = hint
resharper_shift_expression_result_equals_zero_highlighting = hint
resharper_shift_expression_zero_left_operand_highlighting = hint
resharper_suggest_var_or_type_built_in_types_highlighting = hint
resharper_suggest_var_or_type_elsewhere_highlighting = hint
resharper_suggest_var_or_type_simple_types_highlighting = hint
resharper_unused_member_global_highlighting = hint
resharper_web_config_module_not_resolved_highlighting = warning
resharper_web_config_type_not_resolved_highlighting = warning
resharper_web_config_wrong_module_highlighting = warning

[{*.yaml,*.yml}]
indent_style = space
indent_size = 2

[*.{appxmanifest,asax,ascx,aspx,axaml,build,cg,cginc,compute,cs,cshtml,dtd,fs,fsi,fsscript,fsx,hlsl,hlsli,hlslinc,master,ml,mli,nuspec,paml,razor,resw,resx,shader,skin,usf,ush,vb,xaml,xamlx,xoml,xsd}]
indent_style = space
indent_size = 4
tab_width = 4




================================================
File: doc/Recompiler.md
================================================
Recompiler
==========

First, how it doesn't work
--------------------------

While KoiVM does not implement a 1:1 mapping between CIL opcode and VM opcode, it still does more or less define a mapping between CIL opcode and groups of VM instructions. Therefore, in theory, pattern matching on the VM code could be done to figure out what the original CIL code was.

For example, the following CIL code
```
ldloc.1
ldc.i4.2
add
```

could potentially in one version of KoiVM be translated to the following VM code:
```
pushr_dword bp  ; push value of variable 1 stored in current stack frame
pushi_dword 1
add_dword
lind_dword

pushi_dword 2   ; push constant 2

add_dword       ; perform addition
```

Pattern matching is effective and an easy way to create a devirtualizer. However, this is not the approach that Old Rod takes. This is because there is a couple of issues with this method:

- There are quite a few CIL opcodes, which means lots of patterns would have to be defined for the devirtualizer to work (which gets tedious very quickly).
- Because there are so many, this will be very error prone.
- This is not scalable. If a fork of KoiVM slightly changes the code to something equivalent (e.g. changing the order of instructions, inserting bogus instructions etc.), the entire devirtualizer will stop working and all patterns would have to be revisited.
- Lots of type information is lost when the CIL code is translated to the VM code. Pattern matching will only help you to some extend to recover this.

The IL-AST
----------

While disassembling the VM code, the devirtualizer keeps track of control flow and data flow. By paying attention to how many values each instruction pushes onto- and pops from the stack, the devirtualizer figures out which instructions depend on each other, essentially constructing not only a control flow graph (CFG), but also a data flow graph (DFG).

After it has done so, the devirtualizer builds an intermediate representation in the form of an abstract syntax tree (AST) from these two data structures. This is a representation of a custom intermediate language (IL) that aims to completely remove the notion of the stack and registers from the code, and replaces them with variables instead.

Essentially, this translates the VM code to a bunch of assignments:
```
tmp1 = pushr_dword(bp)
tmp2 = pushi_dword(1)
tmp3 = add_dword(tmp1, tmp2)
tmp4 = lind_dword(tmp3)

tmp5 = pushi_dword(2)

tmp6 = add_dword(tmp4, tmp5)
```

These are then inlined in one of the optimisation steps where possible:
```
tmp6 = add(lind_dword(add_dword(pushr_dword(bp), pushi_dword(1))), pushi_dword(2))
```

or in AST form:

```
                       tmp6 = 
                          |
                      add_dword
                          |
                .---------+---------.
                |                   |
           lind_dword         pushi_dword 2
                |
            add_dword
                |
        .-------+-------.
        |               |
  pushr_dword bp   pushi_dword 1
```


The great benefit of this approach is that the resulting tree is not dependent anymore on the raw physical code sequence. Any instructions that would be inserted by some fork, or any shuffling in order of instructions would be removed automatically, making the virtualizer a lot more generic. Furthermore, a tree-like structure is easy to process by using various traversal algorithms and/or visitor patterns. Pattern matching is also much more reliable if we perform it on the AST instead of the raw code for the same reason as previously mentioned. Finally, lots of compiler theory is based on ASTs. Writing a devirtualizer can therefore leverage from this research to recompile and optimise the code.

Optimisations on the IL-AST
------------------------------------------------
While Old Rod does not define patterns for every CIL instruction, it does use pattern matching on some of the IL-AST structures to do certain optimisations. For example, in the left subtree of the resulting IL-AST we obtained, we see a very common construct for loading a variable from the current stack frame. We optimise these away to improve some readability of the code and attempt to reduce the number of variables introduced.

```             
                :
           lind_dword                   
                |                                      :
            add_dword               =>          pushr_dword var1
                |
        .-------+-------.
        |               |
  pushr_dword bp   pushi_dword 1
```

The CIL-AST
-----------

After the IL AST has been made, it is translated to a CIL AST:
```
                       stloc 0
                          |
                         add
                          |
                .---------+---------.
                |                   |
             ldloc 1            ldc.i4 2
```
or in expression form:
```
stloc(0, add(ldloc(1), ldc.i4(2)))
```

In this step, we also reintroduce the .NET typing system. We look at all uses of each variable and guess the corresponding variable type based on its context, and add any missing type casts in the code. Since KoiVM destroys all information about typing, this is a necessary step.

For example, in the tree above we can infer that variable 1 is probably a 32 bit integral type (`int` or `uint`), as it is used in an `add_dword` expression.

Generating the final CIL code
------------------------------

Finally. by performing a depth-first traversal on the resulting CIL-AST, we can obtain the corresponding CIL code:

```
ldloc 1
ldc.i4 2
add
stloc 0
```


================================================
File: doc/example-config.json
================================================
{
    "opcodes": {
        "nop": 0,
        "lind_ptr": 1,
        "lind_object": 2,
        "lind_byte": 3,
        "lind_word": 4,
        "lind_dword": 5,
        "lind_qword": 6,
        "sind_ptr": 7,
        "sind_object": 8,
        "sind_byte": 9,
        "sind_word": 10,
        "sind_dword": 11,
        "sind_qword": 12,
        "pop": 13,
        "pushr_object": 14,
        "pushr_byte": 15,
        "pushr_word": 16,
        "pushr_dword": 17,
        "pushr_qword": 18,
        "pushi_dword": 19,
        "pushi_qword": 20,
        "sx_byte": 21,
        "sx_word": 22,
        "sx_dword": 23,
        "call": 24,
        "ret": 25,
        "nor_dword": 26,
        "nor_qword": 27,
        "cmp": 28,
        "cmp_dword": 29,
        "cmp_qword": 30,
        "cmp_r32": 31,
        "cmp_r64": 32,
        "jz": 33,
        "jnz": 34,
        "jmp": 35,
        "swt": 36,
        "add_dword": 37,
        "add_qword": 38,
        "add_r32": 39,
        "add_r64": 40,
        "sub_r32": 41,
        "sub_r64": 42,
        "mul_dword": 43,
        "mul_qword": 44,
        "mul_r32": 45,
        "mul_r64": 46,
        "div_dword": 47,
        "div_qword": 48,
        "div_r32": 49,
        "div_r64": 50,
        "rem_dword": 51,
        "rem_qword": 52,
        "rem_r32": 53,
        "rem_r64": 54,
        "shr_dword": 55,
        "shr_qword": 56,
        "shl_dword": 57,
        "shl_qword": 58,
        "fconv_r32_r64": 59,
        "fconv_r64_r32": 60,
        "fconv_r32": 61,
        "fconv_r64": 62,
        "iconv_ptr": 63,
        "iconv_r64": 64,
        "vcall": 65,
        "try": 66,
        "leave": 67
    },
    "flags": {
        "overflow": 1,
        "carry": 2,
        "zero": 4,
        "sign": 8,
        "unsigned": 16,
        "behav1": 32,
        "behav2": 64,
        "behav3": 128
    },
    "registers": {
        "r0": 0,
        "r1": 1,
        "r2": 2,
        "r3": 3,
        "r4": 4,
        "r5": 5,
        "r6": 6,
        "r7": 7,
        "bp": 8,
        "sp": 9,
        "ip": 10,
        "fl": 11,
        "k1": 12,
        "k2": 13,
        "m1": 14,
        "m2": 15
    },
    "vmcalls": {
        "exit": 0,
        "break": 1,
        "ecall": 2,
        "cast": 3,
        "ckfinite": 4,
        "ckoverflow": 5,
        "rangechk": 6,
        "initobj": 7,
        "ldfld": 8,
        "ldftn": 9,
        "token": 10,
        "throw": 11,
        "sizeof": 12,
        "stfld": 13,
        "box": 14,
        "unbox": 15,
        "localloc": 16
    },
    "ecalls": {
        "call": 0,
        "callvirt": 1,
        "newobj": 2,
        "callvirt_constrained": 3
    },
    "ehtypes": {
        "catch": 0,
        "filter": 1,
        "fault": 2,
        "finally": 3,
    },
    "misc": {
        "helper_init": 0,
        "flag_instance": 1
    }
}


================================================
File: doc/index.md
================================================
Overview
========

This collection of (mostly unfinished) documents try to explain the inner workings of Project Old Rod. Old Rod is (probably unnecessarily) complex, and I understand that most people probably won't like to sift over my spaghetti code.

In a Nutshell
-------------
The devirtualization process consists of a couple of stages, and are implemented in the `OldRod.Pipeline` sub project:

1. Locate VM types and constants,
2. Parse the injected VM binary stream headers,
3. Locate virtualized methods,
4. Map constants to VM opcodes and their handlers,
5. Disassemble all virtualized methods,
    - Also discover any hidden or non-exported functions,
6. Analyze the VM code,
    - Detect stack layouts,
    - Add any non-exported method to the .NET metadata,
7. Build AST from disassembled VM code,
    - Translate from stack based to a variable based language,
    - Perform optimisations on AST level,
8. Recompile AST to CIL,
    - Convert AST to a "CIL AST",
    - Perform type inference and insert missing type conversions,
    - Serialize CIL AST to normal CIL,
10. Clean up.

Some deeper explanations:
-------------------------
- [The recompiler](Recompiler.md)


================================================
File: src/OldRod/ConsoleAsciiImage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;

namespace OldRod
{
    public class ConsoleAsciiImage
    {
        private static readonly IDictionary<Color, ConsoleColor> ColorMapping = new Dictionary<Color, ConsoleColor>
        {
            [Color.Red] = ConsoleColor.Red,
            [Color.DarkRed] = ConsoleColor.DarkRed,
            [Color.Blue] = ConsoleColor.Blue,
            [Color.DarkBlue] = ConsoleColor.DarkBlue,
            [Color.Gray] = ConsoleColor.Gray,
            [Color.DimGray] = ConsoleColor.DarkGray,
            [Color.Cyan] = ConsoleColor.Cyan,
            [Color.DarkCyan] = ConsoleColor.DarkCyan,
            [Color.Green] = ConsoleColor.Green,
            [Color.DarkGreen] = ConsoleColor.DarkGreen,
            [Color.Yellow] = ConsoleColor.Yellow,
            [Color.DarkGoldenrod] = ConsoleColor.DarkYellow,
            [Color.Magenta] = ConsoleColor.Magenta,
            [Color.DarkMagenta] = ConsoleColor.DarkMagenta,
            [Color.Black] = ConsoleColor.Black,
            [Color.White] = ConsoleColor.White,
        };

        public ConsoleAsciiImage(Bitmap image)
        {
            Image = image ?? throw new ArgumentNullException(nameof(image));
        }

        public Bitmap Image
        {
            get;
        }

        public string CharacterMap => " .:owM";
        
        public unsafe void PrintAscii(bool asciiMode)
        {
            var info = Image.LockBits(
                new Rectangle(0, 0, Image.Width, Image.Height), 
                ImageLockMode.ReadOnly,
                Image.PixelFormat);

            try
            {
                for (int y = 0; y < info.Height; y++)
                {
                    for (int x = 0; x < info.Width; x++)
                    {
                        int raw = *(int*) (info.Scan0 + y * info.Stride + x * 4);
                        var color = Color.FromArgb(raw);

                        if (asciiMode)
                        {
                            Console.ForegroundColor = GetClosestConsoleColor(color);
                            Console.Write(CharacterMap[(int) (color.A / 255f * (CharacterMap.Length - 1))]);
                        }
                        else
                        {
                            Console.BackgroundColor = GetClosestConsoleColor(color);
                            Console.Write(' ');
                        }
                    }

                    Console.WriteLine();
                }
            }
            finally
            {
                Image.UnlockBits(info);
            }
            
            Console.ResetColor();
        }

        private ConsoleColor GetClosestConsoleColor(Color color)
        {
            Color best = Color.White;
            ConsoleColor bestMapping = ConsoleColor.White;
            
            foreach (var entry in ColorMapping)
            {
                if (GetDifference(color, entry.Key) < GetDifference(color, best))
                {
                    best = entry.Key;
                    bestMapping = entry.Value;
                }
            }

            return bestMapping;
        }

        private static int GetDifference(Color color, Color other)
        {
            int rdiff = Math.Abs(color.R - other.R);
            int gdiff = Math.Abs(color.G - other.G);
            int bdiff = Math.Abs(color.B - other.B);
            return (rdiff + gdiff + bdiff) / 3;
        }
    }
}


================================================
File: src/OldRod/ConsoleLogger.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using OldRod.Core;

namespace OldRod
{
    public class ConsoleLogger : ILogger
    {
        private static void WriteMessage(ConsoleColor color, string tag, string message)
        {
            var previous = Console.ForegroundColor;
            Console.ForegroundColor = color;
            var time = DateTime.Now;
            Console.WriteLine($"{time.Hour:00}:{time.Minute:00}:{time.Second:00}.{time.Millisecond:000} [{tag}]: {message}");
            Console.ForegroundColor = previous;
        }

        public void Debug2(string tag, string message)
        {
            WriteMessage(ConsoleColor.DarkGray, tag, message);
        }

        public void Debug(string tag, string message)
        {
            WriteMessage(ConsoleColor.DarkGray, tag, message);
        }

        public void Log(string tag, string message)
        {
            WriteMessage(ConsoleColor.Gray, tag, message);
        }

        public void Warning(string tag, string message)
        {
            WriteMessage(ConsoleColor.Yellow, tag, message);
        }

        public void Error(string tag, string message)
        {
            WriteMessage(ConsoleColor.Red, tag, message);
        }
    }
}


================================================
File: src/OldRod/OldRod.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <Title>OldRod</Title>
        <Version>0.10.1.0</Version>
        <Copyright>Copyright 2019-2022 Washi</Copyright>
        <Description>An automated KoiVM devirtualisation utility</Description>
        <Authors>Washi</Authors>
        <AssemblyVersion>0.10.1.0</AssemblyVersion>
        <FileVersion>0.10.1.0</FileVersion>
        <OutputType>Exe</OutputType>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <TargetFrameworks>net471;netcoreapp3.1</TargetFrameworks>
    </PropertyGroup>
    <ItemGroup>
      <ProjectReference Include="..\OldRod.Core\OldRod.Core.csproj" />
      <ProjectReference Include="..\OldRod.Pipeline\OldRod.Pipeline.csproj" />
    </ItemGroup>
    <ItemGroup>
        <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
        <PackageReference Include="System.Drawing.Common" Version="6.0.0" />
        <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
        </PackageReference>
    </ItemGroup>
    <ItemGroup>
      <None Remove="Resources\magikarp.png" />
      <EmbeddedResource Include="Resources\magikarp.png" />
    </ItemGroup>
</Project>


================================================
File: src/OldRod/Program.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Metadata.Tables;
using OldRod.CommandLine;
using OldRod.Core;
using OldRod.Json;
using OldRod.Pipeline;
using Rivers;

namespace OldRod
{
    internal class Program
    {
        public const string Tag = "TUI";
        
        private static void PrintAbout()
        {
            if (Console.BufferHeight - Console.CursorTop > 43)
                WriteAlignedAbout();
            else
                WriteFallbackAbout();
        }

        private static void WriteFallbackAbout()
        {  
#if DEBUG
            Console.WriteLine("Project Old Rod (DEBUG)");
#else
            Console.WriteLine("Project Old Rod");
#endif
            Console.WriteLine("Catching Koi fish (or magikarps if you will) from the .NET binary!");
            
            var tui = FileVersionInfo.GetVersionInfo(typeof(Program).Assembly.Location);
            var core = FileVersionInfo.GetVersionInfo(typeof(ILogger).Assembly.Location);
            var pipeline = FileVersionInfo.GetVersionInfo(typeof(Devirtualiser).Assembly.Location);
            var asmres = FileVersionInfo.GetVersionInfo(typeof(AssemblyDefinition).Assembly.Location);
            var rivers = FileVersionInfo.GetVersionInfo(typeof(Graph).Assembly.Location);

            Console.WriteLine();
            Console.WriteLine("KoiVM devirtualisation utility");
            Console.WriteLine("TUI Version:         " + tui.FileVersion);
            Console.WriteLine("Recompiler Version:  " + core.FileVersion);
            Console.WriteLine("Pipelining Version:  " + pipeline.FileVersion);
            Console.WriteLine("AsmResolver Version: " + asmres.FileVersion);
            Console.WriteLine("Rivers Version:      " + rivers.FileVersion);
            Console.WriteLine("Copyright:           " + tui.LegalCopyright);
            Console.WriteLine("GIT + issue tracker: https://github.com/Washi1337/OldRod");
            Console.WriteLine();
            Console.WriteLine("This program comes with ABSOLUTELY NO WARRANTY.");
            Console.WriteLine("This is free software, and you are welcome to redistribute it");
            Console.WriteLine("under the conditions of GPLv3.");
        }

        private static void WriteAlignedAbout()
        {
            int top = Console.CursorTop;
            using (var stream = typeof(Program).Assembly.GetManifestResourceStream("OldRod.Resources.magikarp.png"))
            using (var image = new Bitmap(Image.FromStream(stream), 43, 25))
            {
                var ascii = new ConsoleAsciiImage(image);
                ascii.PrintAscii(true);
            }

            int next = Console.CursorTop;

            Console.CursorTop = top + 5;

#if DEBUG
            PrintAlignedLine("Project Old Rod (DEBUG)");
#else
            PrintAlignedLine("Project Old Rod");
#endif

            var tui = FileVersionInfo.GetVersionInfo(typeof(Program).Assembly.Location);
            var core = FileVersionInfo.GetVersionInfo(typeof(ILogger).Assembly.Location);
            var pipeline = FileVersionInfo.GetVersionInfo(typeof(Devirtualiser).Assembly.Location);
            var asmres = FileVersionInfo.GetVersionInfo(typeof(AssemblyDefinition).Assembly.Location);
            var rivers = FileVersionInfo.GetVersionInfo(typeof(Graph).Assembly.Location);

            PrintAlignedLine("Catching Koi fish (or magikarps if you will) from the .NET binary!");
            Console.CursorTop++;
            PrintAlignedLine("KoiVM devirtualisation utility");
            PrintAlignedLine("TUI Version:         " + tui.FileVersion);
            PrintAlignedLine("Recompiler Version:  " + core.FileVersion);
            PrintAlignedLine("Pipelining Version:  " + pipeline.FileVersion);
            PrintAlignedLine("AsmResolver Version: " + asmres.FileVersion);
            PrintAlignedLine("Rivers Version:      " + rivers.FileVersion);
            PrintAlignedLine("Copyright:           " + tui.LegalCopyright);
            PrintAlignedLine("GIT + issue tracker: https://github.com/Washi1337/OldRod");
            Console.CursorTop++;
            PrintAlignedLine("This program comes with ABSOLUTELY NO WARRANTY.");
            PrintAlignedLine("This is free software, and you are welcome to redistribute it");
            PrintAlignedLine("under the conditions of GPLv3.");

            Console.CursorTop = next;
            Console.CursorLeft = 0;
            Console.WriteLine();
        }

        private static void PrintAlignedLine(string message)
        {
            Console.CursorLeft = 45;
            Console.Write(message);
            Console.CursorTop++;
        }

        private static void PrintHelp()
        {
            Console.WriteLine("Usage: ");
            Console.WriteLine("   OldRod.exe [options] <input-file> [options]");
            Console.WriteLine();
            Console.WriteLine("Available options:");
            foreach (var @switch in CommandLineSwitches.AllSwitches.OrderBy(x => x.Identifiers.First()))
            {
                var identifiers = @switch.Identifiers
                    .OrderByDescending(x => x.Length)
                    .ToArray();
                
                Console.Write("   -" + identifiers[0].PadRight(25));
                Console.WriteLine(@switch.Description);
                
                for (int i = 1; i < identifiers.Length;i++)
                    Console.WriteLine("   -" + identifiers[i]);
                Console.WriteLine();
            }

            Console.WriteLine();
            Console.WriteLine("Examples: ");
            Console.WriteLine("   OldRod.exe -v C:\\Path\\To\\Input\\File.exe");
            Console.WriteLine("   OldRod.exe C:\\Path\\To\\Input\\File.exe -o C:\\OutputDirectory");
            Console.WriteLine();
        }
        
        public static void Main(string[] args)
        {
            PrintAbout();

            bool pauseOnExit = true;

            var consoleLogger = new FilteredLogger(new ConsoleLogger());
            var counter = new LogCounter();
            
            var loggers = new LoggerCollection {consoleLogger, counter};
            FileOutputLogger fileLogger = null;
            
            var parser = new CommandLineParser();
            foreach (var @switch in CommandLineSwitches.AllSwitches)
                parser.AddSwitch(@switch);

            try
            {
                var result = parser.Parse(args);
                if (result.Flags.Contains(CommandLineSwitches.EnableTroublenoobing))
                    throw new DevirtualisationException("Magikarp uses Splash! It was not very effective...");

                pauseOnExit = !result.Flags.Contains(CommandLineSwitches.NoPause);

                if (result.Flags.Contains(CommandLineSwitches.Help))
                {
                    PrintHelp();
                }
                else
                {
                    consoleLogger.IncludeDebug = result.Flags.Contains(CommandLineSwitches.VerboseOutput)
                                                 || result.Flags.Contains(CommandLineSwitches.VeryVerboseOutput);
                    consoleLogger.IncludeDebug2 = result.Flags.Contains(CommandLineSwitches.VeryVerboseOutput);

                    var options = GetDevirtualisationOptions(result);
                    options.OutputOptions.EnsureDirectoriesExist();

                    if (result.Flags.Contains(CommandLineSwitches.OutputLogFile))
                    {
                        fileLogger =
                            new FileOutputLogger(Path.Combine(options.OutputOptions.RootDirectory, "report.log"));
                        loggers.Add(fileLogger);
                    }

                    if (result.Flags.Contains(CommandLineSwitches.SalvageData))
                    {
                        loggers.Warning(Tag,
                            "Salvage mode is enabled. Output files might not be an accurate representation of the original binary.");
                    }

                    var devirtualiser = new Devirtualiser(loggers);
                    devirtualiser.Devirtualise(options);
                }
            }
            catch (CommandLineParseException ex)
            {
                consoleLogger.Error(Tag, ex.Message);
                consoleLogger.Log(Tag, "Use -h for help.");
            }
            catch (Exception ex) when (!Debugger.IsAttached) 
            {
                consoleLogger.Error(Tag, "Something went wrong! Try the latest version or report a bug at the repository.");
                if (consoleLogger.IncludeDebug)
                {
                    loggers.Error(Tag, ex.ToString());
                }
                else
                {
                    PrintExceptions(new LoggerCollection {consoleLogger, counter}, new[] {ex});
                    fileLogger?.Error(Tag, ex.ToString());
                    consoleLogger.Error(Tag, "Use --verbose or inspect the full report.log using --log-file for more details.");
                }
            }
            finally
            {
                loggers.Log(Tag, $"Process finished with {counter.Warnings} warnings and {counter.Errors} errors.");
                fileLogger?.Dispose();
            }
            
            if (pauseOnExit)
            {
                Console.WriteLine("Press any key to continue...");
                Console.ReadKey();
            }
        }
        
        private static DevirtualisationOptions GetDevirtualisationOptions(CommandParseResult result)
        {
            string filePath = result.FilePath
                              ?? throw new CommandLineParseException("No input file path specified.");
            
            string outputDirectory = result.GetOptionOrDefault(CommandLineSwitches.OutputDirectory,
                Path.Combine(Path.GetDirectoryName(filePath), "Devirtualised"));

            var options = new DevirtualisationOptions(filePath, outputDirectory)
            {
                OutputOptions =
                {
                    DumpControlFlowGraphs = result.Flags.Contains(CommandLineSwitches.DumpCfg),
                    DumpAllControlFlowGraphs = result.Flags.Contains(CommandLineSwitches.DumpAllCfg),
                    DumpDisassembledIL = result.Flags.Contains(CommandLineSwitches.DumpIL),
                    DumpRecompiledCil =  result.Flags.Contains(CommandLineSwitches.DumpCIL),
                },
                EnableSalvageMode = result.Flags.Contains(CommandLineSwitches.SalvageData),
                KoiStreamName = result.GetOptionOrDefault(CommandLineSwitches.KoiStreamName),
                KoiStreamDataFile = result.GetOptionOrDefault(CommandLineSwitches.KoiStreamData),
                RenameSymbols = result.Flags.Contains(CommandLineSwitches.RenameConstants),
                RuntimeFile = result.GetOptionOrDefault(CommandLineSwitches.RuntimeLibFileName),
                NoExportMapping = result.Flags.Contains(CommandLineSwitches.NoExportMapping),
                IgnoreInvalidMD = result.Flags.Contains(CommandLineSwitches.IgnoreInvalidMD),
            };

            if (result.Flags.Contains(CommandLineSwitches.ForceEmbeddedRuntimeLib))
                options.RuntimeFile = options.InputFile;

            if (result.Options.ContainsKey(CommandLineSwitches.OverrideVMEntry))
            {
                options.VMEntryToken = new MetadataToken(uint.Parse(
                    result.GetOptionOrDefault(CommandLineSwitches.OverrideVMEntry), NumberStyles.HexNumber));
            }

            if (result.Options.ContainsKey(CommandLineSwitches.OverrideVMConstants))
            {
                options.VMConstantsToken = new MetadataToken(uint.Parse(
                    result.GetOptionOrDefault(CommandLineSwitches.OverrideVMConstants), NumberStyles.HexNumber));
            }
            
            if (result.Options.ContainsKey(CommandLineSwitches.OverrideVMContextType))
            {
                options.VMContextToken = new MetadataToken(uint.Parse(
                    result.GetOptionOrDefault(CommandLineSwitches.OverrideVMContextType), NumberStyles.HexNumber));
            }

            if (result.Options.ContainsKey(CommandLineSwitches.IgnoreExports))
            {
                var ignoredExports = result.GetOptionOrDefault(CommandLineSwitches.IgnoreExports)
                    .Split(',')
                    .Select(uint.Parse)
                    .ToArray();

                var selection = new ExclusionIdSelection();
                selection.ExcludedIds.UnionWith(ignoredExports);
                options.SelectedExports = selection;
            }

            if (result.Options.ContainsKey(CommandLineSwitches.OnlyExports))
            {
                if (options.SelectedExports != IdSelection.All)
                {
                    throw new CommandLineParseException(
                        "Cannot use the --ignore-exports and --only-exports command-line switches at the same time.");
                }

                var ignoredExports = result.GetOptionOrDefault(CommandLineSwitches.OnlyExports)
                    .Split(',')
                    .Select(uint.Parse)
                    .ToArray();

                var selection = new IncludedIdSelection();
                selection.IncludedIds.UnionWith(ignoredExports);
                options.SelectedExports = selection;
            }

            if (result.Options.ContainsKey(CommandLineSwitches.IgnoreMethods))
            {
                var ignoredMethods = result.GetOptionOrDefault(CommandLineSwitches.IgnoreMethods)
                    .Split(',')
                    .Select(uint.Parse)
                    .ToArray();

                var selection = new ExclusionIdSelection();
                selection.ExcludedIds.UnionWith(ignoredMethods);
                options.SelectedMethods = selection;
            }

            if (result.Options.ContainsKey(CommandLineSwitches.OnlyMethods))
            {
                if (options.SelectedMethods != IdSelection.All)
                {
                    throw new CommandLineParseException(
                        "Cannot use the --ignore-methods and --only-methods command-line switches at the same time.");
                }

                var ignoredMethods = result.GetOptionOrDefault(CommandLineSwitches.OnlyMethods)
                    .Split(',')
                    .Select(uint.Parse)
                    .ToArray();

                var selection = new IncludedIdSelection();
                selection.IncludedIds.UnionWith(ignoredMethods);
                options.SelectedMethods = selection;
            }

            if (result.Options.ContainsKey(CommandLineSwitches.RunMethod1Signature))
            {
                options.Run1ExpectedTypes.Clear();
                foreach (string typeName in result.GetOptionOrDefault(CommandLineSwitches.RunMethod1Signature).Split(','))
                    options.Run1ExpectedTypes.Add(typeName);
            }

            if (result.Options.ContainsKey(CommandLineSwitches.RunMethod2Signature))
            {
                options.Run2ExpectedTypes.Clear();
                foreach (string typeName in result.GetOptionOrDefault(CommandLineSwitches.RunMethod2Signature).Split(','))
                    options.Run2ExpectedTypes.Add(typeName);
            }

            if (result.Options.TryGetValue(CommandLineSwitches.ConfigurationFile, out string configFile))
            {
                configFile = configFile.Replace("\"", "");
                var jsonConfig = ConstantsConfiguration.FromFile(configFile);
                options.Constants = jsonConfig.CreateVmConstants();
            }

            if (result.Options.TryGetValue(CommandLineSwitches.MaxSimplificationPasses, out string maxPasses))
            {
                options.MaxSimplificationPasses = int.Parse(maxPasses);
            }
            
            return options;
        }

        private static void PrintExceptions(ILogger logger, IEnumerable<Exception> exceptions, int level = 0)
        {
            foreach (var exception in exceptions)
            {
                logger.Error(Tag, $"{new string(' ', level * 3)}{exception.GetType().Name}: {exception.Message}");
                
                if (exception is AggregateException a)
                    PrintExceptions(logger, a.InnerExceptions, level + 1);
                else if (exception.InnerException != null)
                    PrintExceptions(logger, new[] {exception.InnerException}, level + 1);
            }
        }
        
    }
}


================================================
File: src/OldRod/packages.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Newtonsoft.Json" version="13.0.1" targetFramework="net472" />
</packages>


================================================
File: src/OldRod/CommandLine/CommandLineParseException.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;

namespace OldRod.CommandLine
{
    public class CommandLineParseException : Exception
    {
        public CommandLineParseException(string message) 
            : base(message)
        {
        }
    }
}


================================================
File: src/OldRod/CommandLine/CommandLineParser.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;

namespace OldRod.CommandLine
{
    public class CommandLineParser
    {
        private IDictionary<string, CommandLineSwitch> _flags = new Dictionary<string, CommandLineSwitch>();
        private IDictionary<string, CommandLineSwitch> _options = new Dictionary<string, CommandLineSwitch>();

        public void AddSwitch(CommandLineSwitch @switch)
        {
            IDictionary<string, CommandLineSwitch> collection = @switch.HasArgument
                ? _options
                : _flags;

            foreach (var identifier in @switch.Identifiers)
                collection[identifier] = @switch;
        }
        
        public CommandParseResult Parse(string[] args)
        {
            var result = new CommandParseResult();

            for (int i = 0; i < args.Length; i++)
            {
                if (args[i][0] == '-')
                {
                    string word = args[i].Substring(1);

                    if (_flags.TryGetValue(word, out var flag))
                    {
                        result.Flags.Add(flag);
                    }
                    else if (_options.TryGetValue(word, out var option))
                    {
                        result.Options[option] = args[i + 1];
                        i++;
                    }
                    else
                    {
                        throw new CommandLineParseException($"Unknown flag or option -{word}.");
                    }
                }
                else if (result.FilePath == null)
                {
                    result.FilePath = args[i].Replace("\"", "");
                }
                else
                {
                    throw new CommandLineParseException("Too many input files specified.");
                }
            }

            return result;
        }        
    }
}


================================================
File: src/OldRod/CommandLine/CommandLineSwitch.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;

namespace OldRod.CommandLine
{
    public class CommandLineSwitch
    {
        internal CommandLineSwitch(IEnumerable<string> identifiers, string description)
        {
            Description = description;
            Identifiers = identifiers.ToList().AsReadOnly();
            CommandLineSwitches.AllSwitches.Add(this);
        }

        internal CommandLineSwitch(IEnumerable<string> identifiers, string description, string defaultValue)
            : this(identifiers, description)
        {
            HasArgument = true;
            DefaultArgument = defaultValue;
        }

        public ICollection<string> Identifiers
        {
            get;
        }

        public string Description
        {
            get;
        }

        public bool HasArgument
        {
            get;
        }

        public string DefaultArgument
        {
            get;
        }

        public override string ToString()
        {
            return "One of " + string.Join(" ", Identifiers);
        }
    }
}


================================================
File: src/OldRod/CommandLine/CommandLineSwitches.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;

namespace OldRod.CommandLine
{
    public static class CommandLineSwitches
    {
        public static readonly ICollection<CommandLineSwitch> AllSwitches = new List<CommandLineSwitch>();
        
        public static readonly CommandLineSwitch Help = new CommandLineSwitch(new[]
        {
            "h", "-help"
        }, "Shows help.");
        
        public static readonly CommandLineSwitch NoPause = new CommandLineSwitch(new[]
        {
            "-no-pause"
        }, "Prevent the \"Press any key to continue...\" from appearing on exit.");
        
        public static readonly CommandLineSwitch VerboseOutput = new CommandLineSwitch(new[]
        {
            "v", "-verbose"
        }, "Enable verbose output. Useful for debugging purposes.");
        
        public static readonly CommandLineSwitch VeryVerboseOutput = new CommandLineSwitch(new[]
        {
            "vv", "-very-verbose"
        }, "Enable very verbose output. Useful for debugging purposes, but can get big very quickly.");
        
        public static readonly CommandLineSwitch DumpIL = new CommandLineSwitch(new[]
        {
            "-dump-il"
        }, "Dump disassembled KoiVM IL code of each function defined in the #Koi stream.");
        
        public static readonly CommandLineSwitch DumpCfg = new CommandLineSwitch(new[]
        {
            "-dump-cfg"
        }, "Dump reconstructed control flow graphs of each function defined in the #Koi stream.");
        
        public static readonly CommandLineSwitch DumpAllCfg = new CommandLineSwitch(new[]
        {
            "-dump-cfg-all"
        }, "Dump control flow graphs after each AST optimisation step (Useful for debugging).");
        
        public static readonly CommandLineSwitch DumpCIL = new CommandLineSwitch(new[]
        {
            "-dump-cil"
        }, "Dump recompiled CIL for each function defined in the #Koi stream.");
        
        public static readonly CommandLineSwitch RenameConstants = new CommandLineSwitch(new[]
        {
            "-rename-symbols" 
        }, "Rename all VM configuration fields, opcode interfaces and classes and the like in the runtime assembly.");
        
        public static readonly CommandLineSwitch OutputDirectory = new CommandLineSwitch(new[]
        {
            "o", "-output-directory"
        }, "Set output directory of the devirtualiser.", null);
        
        public static readonly CommandLineSwitch OverrideVMEntry = new CommandLineSwitch(new[]
        {
            "-entry-type"
        }, "Override metadata token for VMEntry type (instead of auto detection).", null);

        public static readonly CommandLineSwitch OverrideVMConstants = new CommandLineSwitch(new[]
        {
            "-constants-type"
        }, "Override metadata token for VMConstants type (instead of auto detection).", null);
        
        public static readonly CommandLineSwitch OverrideVMContextType = new CommandLineSwitch(new[]
        {
            "-context-type"
        }, "Override metadata token for VMContext type (instead of auto detection).", null);

        public static readonly CommandLineSwitch KoiStreamName = new CommandLineSwitch(new[]
        {
            "kn", "-koi-stream-name"
        }, "Override name of KoiVM metadata stream (instead of #Koi).", "#Koi");
        
        public static readonly CommandLineSwitch KoiStreamData = new CommandLineSwitch(new[]
        {
            "kd", "-koi-stream-data"
        }, "Override data of KoiVM metadata stream by the specified file (instead of stream embedded into the target file).", null);
        
        public static readonly CommandLineSwitch IgnoreExports = new CommandLineSwitch(new[]
        {
            "-ignore-export"
        }, "Prevent all specified exports from being devirtualised (comma-separated string of export IDs).", null);

        public static readonly CommandLineSwitch OnlyExports = new CommandLineSwitch(new[]
        {
            "-only-export"
        }, "Only devirtualise all specified exports (comma-separated string of export IDs).", null);

        public static readonly CommandLineSwitch IgnoreMethods = new CommandLineSwitch(new[]
        {
            "-ignore-method"
        }, "Prevent all specified all specified methods from being devirtualised (comma-separated string of RIDs).", null);

        public static readonly CommandLineSwitch OnlyMethods = new CommandLineSwitch(new[]
        {
            "-only-method"
        }, "Only devirtualise all specified methods (comma-separated string of RIDs).", null);

        public static readonly CommandLineSwitch NoExportMapping = new CommandLineSwitch(new[]
        {
            "-no-export-mapping"
        }, "Prevent all exports from being mapped to physical methods and only create new physical methods in <Module>."); 
            
        public static readonly CommandLineSwitch IgnoreInvalidMD = new CommandLineSwitch(new[]
        {
            "-ignore-invalid-md"
        }, "Ignores all invalid metadata.");
        
        public static readonly CommandLineSwitch OutputLogFile = new CommandLineSwitch(new[]
        {
            "l", "-log-file"
        }, "Create a log file in the output directory of the process.");
        
        public static readonly CommandLineSwitch RuntimeLibFileName = new CommandLineSwitch(new[]
        {
            "rt", "-runtime-path"
        }, "Force runtime library file path (instead of auto detection). This can be a relative or an absolute path.", null);
        
        public static readonly CommandLineSwitch ForceEmbeddedRuntimeLib = new CommandLineSwitch(new[]
        {
            "-runtime-embedded"
        }, "Force runtime library to be embedded in the target assembly (instead of auto detection).");
        
        public static readonly CommandLineSwitch ConfigurationFile = new CommandLineSwitch(new[]
        {
            "-config"
        }, "Use opcode configuration from the provided JSON file.", null);
        
        public static readonly CommandLineSwitch MaxSimplificationPasses = new CommandLineSwitch(new[]
        {
            "-max-opt-passes"
        }, "Specify a maximum amount of iterations the logic simplifier can use for optimizing expressions.", null);
        
        public static readonly CommandLineSwitch RunMethod1Signature = new CommandLineSwitch(new[]
        {
            "r1", "-run-sig-1"
        }, "Specify a comma-separated list of parameter type names of the first run method.", null);
        
        public static readonly CommandLineSwitch RunMethod2Signature = new CommandLineSwitch(new[]
        {
            "r2", "-run-sig-2"
        }, "Specify a comma-separated list of parameter type names of the second run method.", null);
        
        public static readonly CommandLineSwitch SalvageData = new CommandLineSwitch(new[]
        {
            "-salvage"
        }, "Salvage as much data as possible when an error occurs.");
        
        public static readonly CommandLineSwitch EnableTroublenoobing = new CommandLineSwitch(new[]
        {
            "-dont-crash", "-no-errors", "-no-output-corruption"
        }, "Enable additional troubleshooting settings.");
        
    }
}


================================================
File: src/OldRod/CommandLine/CommandParseResult.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;

namespace OldRod.CommandLine
{
    public class CommandParseResult
    {
        public string FilePath
        {
            get;
            set;
        }

        public ICollection<CommandLineSwitch> Flags
        {
            get;
        } = new List<CommandLineSwitch>();

        public IDictionary<CommandLineSwitch, string> Options
        {
            get;
        } = new Dictionary<CommandLineSwitch, string>();

        public string GetOptionOrDefault(CommandLineSwitch option)
        {
            if (!Options.TryGetValue(option, out string value))
                value = option.DefaultArgument;
            return value;
        }
        
        public string GetOptionOrDefault(CommandLineSwitch option, string defaultValue)
        {
            if (!Options.TryGetValue(option, out string value))
                value = defaultValue;
            return value;
        }
    }
}


================================================
File: src/OldRod/Json/ConstantsConfiguration.cs
================================================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using OldRod.Core.Architecture;

namespace OldRod.Json
{
    public class ConstantsConfiguration
    {
        private static readonly JsonSerializer Serializer = new JsonSerializer();

        public static ConstantsConfiguration FromFile(string path)
        {
            using (var reader = new StreamReader(path))
                return FromReader(reader);
        }

        public static ConstantsConfiguration FromReader(TextReader reader)
        {
            return Serializer.Deserialize<ConstantsConfiguration>(new JsonTextReader(reader));
        }

        [JsonProperty("opcodes")]
        public Dictionary<string, byte> OpCodes
        {
            get;
        } = new Dictionary<string, byte>(StringComparer.OrdinalIgnoreCase);

        [JsonProperty("flags")]
        public Dictionary<string, byte> Flags
        {
            get;
        } = new Dictionary<string, byte>(StringComparer.OrdinalIgnoreCase);

        [JsonProperty("registers")]
        public Dictionary<string, byte> Registers
        {
            get;
        } = new Dictionary<string, byte>(StringComparer.OrdinalIgnoreCase);

        [JsonProperty("vmcalls")]
        public Dictionary<string, byte> VMCalls
        {
            get;
        } = new Dictionary<string, byte>(StringComparer.OrdinalIgnoreCase);

        [JsonProperty("ecalls")]
        public Dictionary<string, byte> ECalls
        {
            get;
        } = new Dictionary<string, byte>(StringComparer.OrdinalIgnoreCase);

        [JsonProperty("ehtypes")]
        public Dictionary<string, byte> EHTypes
        {
            get;
        } = new Dictionary<string, byte>(StringComparer.OrdinalIgnoreCase);

        [JsonProperty("misc")]
        public Dictionary<string, byte> Misc
        {
            get;
        } = new Dictionary<string, byte>(StringComparer.OrdinalIgnoreCase);

        private static IDictionary<string, T> CreateEnumDictionary<T>()
        {
            return Enum.GetValues(typeof(T))
                .Cast<T>()
                .Where(x => x.ToString() != "Max" && !x.ToString().StartsWith("__"))
                .ToDictionary(x => x.ToString(), x => x, StringComparer.OrdinalIgnoreCase);
        }

        private static void Process<T>(IDictionary<string, byte> config, IDictionary<string, T> stringToEnum, IDictionary<byte, T> target)
        {
            foreach (var entry in config)
            {
                if (!stringToEnum.TryGetValue(entry.Key, out var enumKey))
                    throw new KeyNotFoundException($"Unknown constant {entry.Key}.");
                
                if (target.TryGetValue(entry.Value, out var existing))
                    throw new ArgumentException(
                        $"Duplicate mapping found. {existing} and {enumKey} both map to {entry.Value} (0x{entry.Value:X2}).");

                stringToEnum.Remove(entry.Key);
                target.Add(entry.Value, enumKey);
            }
        }

        public VMConstants CreateVmConstants()
        {
            var ilCodes = CreateEnumDictionary<ILCode>();
            var flags = CreateEnumDictionary<VMFlags>();
            var registers = CreateEnumDictionary<VMRegisters>();
            var vmCalls = CreateEnumDictionary<VMCalls>();
            var eCalls = CreateEnumDictionary<VMECallOpCode>();
            var ehTypes = CreateEnumDictionary<EHType>();
            
            var constants = new VMConstants();
            var missing = new List<string>();

            Process(OpCodes, ilCodes, constants.OpCodes);
            Process(Flags, flags, constants.Flags);
            Process(Registers, registers, constants.Registers);
            Process(VMCalls, vmCalls, constants.VMCalls);
            Process(ECalls, eCalls, constants.ECallOpCodes);
            Process(EHTypes, ehTypes, constants.EHTypes);
            
            missing.AddRange(ilCodes.Keys);
            missing.AddRange(flags.Keys);
            missing.AddRange(registers.Keys);
            missing.AddRange(vmCalls.Keys);
            missing.AddRange(eCalls.Keys);
            missing.AddRange(ehTypes.Keys);

            if (Misc.TryGetValue("HELPER_INIT", out byte value))
                constants.HelperInit = value;
            else
                missing.Add("HELPER_INIT");
            
            if (Misc.TryGetValue("FLAG_INSTANCE", out value))
                constants.FlagInstance = value;
            else
                missing.Add("FLAG_INSTANCE");

            int missingCount = missing.Count;
            if (missingCount > 0)
            {
                string suffix = string.Empty;
                if (missingCount > 5)
                {
                    missing.RemoveRange(5, missingCount - 6);
                    suffix = $" and {missingCount - 6} more";
                }

                throw new ArgumentException(
                    $"Incomplete configuration file. Missing constants {string.Join(", ", missing)}{suffix}.");
            }
            
            return constants;
        }

    }
}




================================================
File: src/OldRod.Core/EmptyLogger.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core
{
    public class EmptyLogger : ILogger
    {
        public static EmptyLogger Instance
        {
            get;
        } = new EmptyLogger();

        private EmptyLogger()
        {
        }

        public void Debug2(string tag, string message)
        {
        }

        public void Debug(string tag, string message)
        {
        }

        public void Log(string tag, string message)
        {
        }

        public void Warning(string tag, string message)
        {
        }

        public void Error(string tag, string message)
        {
        }
    }
}


================================================
File: src/OldRod.Core/FileOutputLogger.cs
================================================
using System;
using System.IO;

namespace OldRod.Core
{
    public class FileOutputLogger : ILogger, IDisposable
    {
        private readonly StreamWriter _writer;

        public FileOutputLogger(string path)
        {
            _writer = new StreamWriter(path);
        }

        private void WriteMessage(string severity, string tag, string message)
        {
            var time = DateTime.Now;
            _writer.WriteLine("{0,7}: {1:00}:{2:00}:{3:00}.{4:000} [{5}]: {6}", 
                severity, 
                time.Hour, 
                time.Minute, 
                time.Second,
                time.Millisecond,
                tag,
                message);
        }

        public void Debug2(string tag, string message)
        {
            WriteMessage("DEBUG", tag, message);
        }

        public void Debug(string tag, string message)
        {
            WriteMessage("DEBUG", tag, message);
        }

        public void Log(string tag, string message)
        {
            WriteMessage("INFO", tag, message);
        }

        public void Warning(string tag, string message)
        {
            WriteMessage("WARNING", tag, message);
        }

        public void Error(string tag, string message)
        {
            WriteMessage("ERROR", tag, message);
        }

        public void Dispose()
        {
            _writer.Flush();
            _writer.Dispose();
        }
    }
}


================================================
File: src/OldRod.Core/FilteredLogger.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core
{
    public class FilteredLogger : ILogger
    {
        private readonly ILogger _logger;

        public FilteredLogger(ILogger logger)
        {
            _logger = logger;
        }

        public bool IncludeDebug2
        {
            get;
            set;
        } = false;

        public bool IncludeDebug
        {
            get;
            set;
        } = true;

        public bool IncludeLog
        {
            get;
            set;
        } = true;

        public bool IncludeWarning
        {
            get;
            set;
        } = true;

        public bool IncludeError
        {
            get;
            set;
        } = true;

        public void Debug2(string tag, string message)
        {
            if (IncludeDebug2)
                _logger.Debug2(tag, message);
        }

        public void Debug(string tag, string message)
        {
            if (IncludeDebug)
                _logger.Debug(tag, message);
        }

        public void Log(string tag, string message)
        {
            if (IncludeLog)
                _logger.Log(tag, message);
        }

        public void Warning(string tag, string message)
        {
            if (IncludeWarning)
                _logger.Warning(tag, message);
        }

        public void Error(string tag, string message)
        {
            if (IncludeError)
                _logger.Error(tag, message);
        }
    }
}


================================================
File: src/OldRod.Core/ILogger.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core
{
    public interface ILogger
    {
        void Debug2(string tag, string message);
        
        void Debug(string tag, string message);
        
        void Log(string tag, string message);

        void Warning(string tag, string message);
        
        void Error(string tag, string message);
    }
}


================================================
File: src/OldRod.Core/LogCounter.cs
================================================
namespace OldRod.Core
{
    public class LogCounter : ILogger
    {
        public int DebugMessages2
        {
            get;
            private set;
        }
        public int DebugMessages
        {
            get;
            private set;
        }

        public int Messages
        {
            get;
            private set;
        }

        public int Warnings
        {
            get;
            private set;
        }

        public int Errors
        {
            get;
            private set;
        }

        public void Debug2(string tag, string message)
        {
            DebugMessages2++;
        }

        public void Debug(string tag, string message)
        {
            DebugMessages++;
        }

        public void Log(string tag, string message)
        {
            Messages++;
        }

        public void Warning(string tag, string message)
        {
            Warnings++;
        }

        public void Error(string tag, string message)
        {
            Errors++;
        }
    }
}


================================================
File: src/OldRod.Core/LoggerCollection.cs
================================================
using System.Collections.Generic;

namespace OldRod.Core
{
    public class LoggerCollection : List<ILogger>, ILogger
    {
        public void Debug2(string tag, string message)
        {
            foreach (var logger in this)
                logger.Debug2(tag, message);
        }

        public void Debug(string tag, string message)
        {
            foreach (var logger in this)
                logger.Debug(tag, message);
        }

        public void Log(string tag, string message)
        {
            foreach (var logger in this)
                logger.Log(tag, message);
        }

        public void Warning(string tag, string message)
        {
            foreach (var logger in this)
                logger.Warning(tag, message);
        }

        public void Error(string tag, string message)
        {
            foreach (var logger in this)
                logger.Error(tag, message);
        }
    }
}


================================================
File: src/OldRod.Core/OldRod.Core.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <Title>OldRod.Core</Title>
    <Version>0.10.1.0</Version>
    <Copyright>Copyright 2019-2022 Washi</Copyright>
    <Description>Core KoiVM devirtualisation library</Description>
    <Authors>Washi</Authors>
    <AssemblyVersion>0.10.1.0</AssemblyVersion>
    <FileVersion>0.10.1.0</FileVersion>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <TargetFramework>netstandard2.0</TargetFramework>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="$(SolutionDir)\deps\Rivers\Rivers\Rivers.csproj" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="AsmResolver.DotNet" Version="5.4.0" />
  </ItemGroup>
</Project>


================================================
File: src/OldRod.Core/Utilities.cs
================================================
using AsmResolver.DotNet;

namespace OldRod.Core
{
    internal static class Utilities
    {
        public static bool RequiresSpecialAccess(this ITypeDefOrRef type)
        {
            var typeDef = type.Resolve();
            while (typeDef != null)
            {
                if (typeDef.IsNestedPrivate
                    || typeDef.IsNestedFamily
                    || typeDef.IsNestedFamilyAndAssembly
                    || typeDef.IsNestedFamilyOrAssembly)
                    return true;
                typeDef = typeDef.DeclaringType;
            }

            return false;
        }
    }
}


================================================
File: src/OldRod.Core/Architecture/EHType.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum EHType : byte
    {
        CATCH,
        FILTER,
        FAULT,
        FINALLY,
        
        Max,
    }
}


================================================
File: src/OldRod.Core/Architecture/ILCode.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum ILCode
    {
        NOP,

        LIND_PTR,
        LIND_OBJECT,
        LIND_BYTE,
        LIND_WORD,
        LIND_DWORD,
        LIND_QWORD,

        SIND_PTR,
        SIND_OBJECT,
        SIND_BYTE,
        SIND_WORD,
        SIND_DWORD,
        SIND_QWORD,

        POP,

        PUSHR_OBJECT,
        PUSHR_BYTE,
        PUSHR_WORD,
        PUSHR_DWORD,
        PUSHR_QWORD,

        PUSHI_DWORD,
        PUSHI_QWORD,

        SX_BYTE,
        SX_WORD,
        SX_DWORD,

        CALL,
        RET,

        NOR_DWORD,
        NOR_QWORD,

        CMP,
        CMP_DWORD,
        CMP_QWORD,
        CMP_R32,
        CMP_R64,

        JZ,
        JNZ,
        JMP,
        SWT,

        ADD_DWORD,
        ADD_QWORD,
        ADD_R32,
        ADD_R64,

        SUB_R32,
        SUB_R64,

        MUL_DWORD,
        MUL_QWORD,
        MUL_R32,
        MUL_R64,

        DIV_DWORD,
        DIV_QWORD,
        DIV_R32,
        DIV_R64,

        REM_DWORD,
        REM_QWORD,
        REM_R32,
        REM_R64,

        SHR_DWORD,
        SHR_QWORD,
        SHL_DWORD,
        SHL_QWORD,

        FCONV_R32_R64,
        FCONV_R64_R32,
        FCONV_R32,
        FCONV_R64,
        ICONV_PTR,
        ICONV_R64,

        VCALL,

        TRY,
        LEAVE,

        Max,
        
        // Pseudo opcodes
        __NOT_DWORD,
        __NOT_QWORD,
        
        __NEG_DWORD,
        __NEG_QWORD,
        __NEG_R32,
        __NEG_R64,
        
        __OR_DWORD,
        __OR_QWORD,
        
        __AND_DWORD,
        __AND_QWORD,
        
        __XOR_DWORD,
        __XOR_QWORD,
        
        __SUB_DWORD,
        __SUB_QWORD,
        
        __PUSH_EXCEPTION,
        
        __EQUALS_DWORD,
        __EQUALS_QWORD,
        __EQUALS_R32,
        __EQUALS_R64,
        __EQUALS_OBJECT,
        
        __GT_DWORD,
        __GT_QWORD,
        __GT_R32,
        __GT_R64,
        
        __LT_DWORD,
        __LT_QWORD,
        __LT_R32,
        __LT_R64,
    }
}


================================================
File: src/OldRod.Core/Architecture/ILFlowControl.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum ILFlowControl : byte
    {
        Next,
        Jump,
        ConditionalJump,
        Call,
        Return,
        VCall
    }
}


================================================
File: src/OldRod.Core/Architecture/ILInstruction.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Disassembly.Annotations;
using OldRod.Core.Disassembly.DataFlow;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Core.Architecture
{
    public class ILInstruction
    {
        public ILInstruction(int offset, ILOpCode opCode, object operand)
        {
            Offset = offset;
            OpCode = opCode;
            Operand = operand;
        }
        
        public int Offset
        {
            get;
            set;
        }
        
        public ILOpCode OpCode
        {
            get;
            set;
        }

        public object Operand
        {
            get;
            set;
        }

        public ProgramState ProgramState
        {
            get;
            set;
        }

        public Annotation Annotation
        {
            get;
            set;
        }

        public IList<SymbolicValue> Dependencies
        {
            get;
        } = new List<SymbolicValue>();

        public int Size
        {
            get
            {
                switch (OpCode.OperandType)
                {
                    case ILOperandType.None:
                        return 2;
                    case ILOperandType.Register:
                        return 3;
                    case ILOperandType.ImmediateDword:
                        return 6;
                    case ILOperandType.ImmediateQword:
                        return 10;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        public override string ToString()
        {
            return $"IL_{Offset:X4}: {OpCode}{GetOperandString()}";
        }

        private string GetOperandString()
        {
            switch (OpCode.OperandType)
            {
                case ILOperandType.None:
                    return string.Empty;
                case ILOperandType.Register:
                    return " " + Operand;
                case ILOperandType.ImmediateDword:
                    return " " + Convert.ToUInt32(Operand).ToString("X8");
                case ILOperandType.ImmediateQword:
                    return " " + Convert.ToUInt64(Operand).ToString("X16");
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
        
        public IEnumerable<ILInstruction> GetAllDependencies()
        {
            var dataSources = Enumerable.Empty<ILInstruction>();
            switch (OpCode.Code)
            {
                case ILCode.PUSHR_BYTE:
                case ILCode.PUSHR_WORD:
                case ILCode.PUSHR_DWORD:
                case ILCode.PUSHR_QWORD:
                case ILCode.PUSHR_OBJECT:

                    var register = (VMRegisters) Operand;
                    if (register != VMRegisters.IP)
                        dataSources = ProgramState.Registers[register].DataSources;
                    break;
                default:
                    dataSources = Dependencies.SelectMany(x => x.DataSources);
                    break;
            }
            
            foreach (var source in dataSources)
            {
                yield return source;
                foreach (var dep in source.GetAllDependencies())
                    yield return dep;
            }
        }
        
    }
}


================================================
File: src/OldRod.Core/Architecture/ILOpCode.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;

namespace OldRod.Core.Architecture
{
    public struct ILOpCode
    {
        internal const int AffectedFlagsOffset       = 0;
        internal const int AffectedFlagsMask         = 0b11111111;
        internal const int OperandTypeOffset         = 8;
        internal const int OperandTypeMask           = 0b11;
        internal const int FlowControlOffset         = 10;
        internal const int FlowControlMask           = 0b111;
        internal const int StackBehaviourPopOffset   = 13;
        internal const int StackBehaviourPopMask     = 0b11111;
        internal const int StackBehaviourPushOffset  = 18;
        internal const int StackBehaviourPushMask    = 0b11111;
            
        private readonly int _flags;

        internal ILOpCode(ILCode code, int flags)
        {
            _flags = flags;
            Code = code;
            ILOpCodes.All[(int) code] = this;
        }

        public ILCode Code
        {
            get;
        }

        public bool AffectsFlags => AffectedFlags != 0;

        public VMFlags AffectedFlags => (VMFlags) ((_flags >> AffectedFlagsOffset) & AffectedFlagsMask);

        public ILOperandType OperandType => (ILOperandType) ((_flags >> OperandTypeOffset) & OperandTypeMask);

        public ILFlowControl FlowControl => (ILFlowControl) ((_flags >> FlowControlOffset) & FlowControlMask);

        public ILStackBehaviour StackBehaviourPop => (ILStackBehaviour) ((_flags >> StackBehaviourPopOffset) & StackBehaviourPopMask);

        public ILStackBehaviour StackBehaviourPush => (ILStackBehaviour) ((_flags >> StackBehaviourPushOffset) & StackBehaviourPushMask);


        public override string ToString()
        {
            return Code.ToString();
        }
    }
}


================================================
File: src/OldRod.Core/Architecture/ILOpCodes.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using static OldRod.Core.Architecture.ILOpCode;

namespace OldRod.Core.Architecture
{
    public static class ILOpCodes
    {
        public static readonly ILOpCode[] All = new ILOpCode[256];

        public static readonly ILOpCode NOP = new ILOpCode(ILCode.NOP,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset));

        public static readonly ILOpCode LIND_PTR = new ILOpCode(ILCode.LIND_PTR,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushPtr << StackBehaviourPushOffset));

        public static readonly ILOpCode LIND_OBJECT = new ILOpCode(ILCode.LIND_OBJECT,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushObject << StackBehaviourPushOffset));

        public static readonly ILOpCode LIND_BYTE = new ILOpCode(ILCode.LIND_BYTE,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushByte << StackBehaviourPushOffset));

        public static readonly ILOpCode LIND_WORD = new ILOpCode(ILCode.LIND_WORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushWord << StackBehaviourPushOffset));

        public static readonly ILOpCode LIND_DWORD = new ILOpCode(ILCode.LIND_DWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode LIND_QWORD = new ILOpCode(ILCode.LIND_QWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode SIND_PTR = new ILOpCode(ILCode.SIND_PTR,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopPtr_PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode SIND_OBJECT = new ILOpCode(ILCode.SIND_OBJECT,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopObject_PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode SIND_BYTE = new ILOpCode(ILCode.SIND_BYTE,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopByte_PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode SIND_WORD = new ILOpCode(ILCode.SIND_WORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopWord_PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode SIND_DWORD = new ILOpCode(ILCode.SIND_DWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode SIND_QWORD = new ILOpCode(ILCode.SIND_QWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopPtr << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode POP = new ILOpCode(ILCode.POP,
            ((byte) ILOperandType.Register << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopAny << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode PUSHR_OBJECT = new ILOpCode(ILCode.PUSHR_OBJECT,
            ((byte) ILOperandType.Register << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushObject << StackBehaviourPushOffset));

        public static readonly ILOpCode PUSHR_BYTE = new ILOpCode(ILCode.PUSHR_BYTE,
            ((byte) ILOperandType.Register << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushByte << StackBehaviourPushOffset));

        public static readonly ILOpCode PUSHR_WORD = new ILOpCode(ILCode.PUSHR_WORD,
            ((byte) ILOperandType.Register << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushWord << StackBehaviourPushOffset));

        public static readonly ILOpCode PUSHR_DWORD = new ILOpCode(ILCode.PUSHR_DWORD,
            ((byte) ILOperandType.Register << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode PUSHR_QWORD = new ILOpCode(ILCode.PUSHR_QWORD,
            ((byte) ILOperandType.Register << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode PUSHI_DWORD = new ILOpCode(ILCode.PUSHI_DWORD,
            ((byte) ILOperandType.ImmediateDword << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode PUSHI_QWORD = new ILOpCode(ILCode.PUSHI_QWORD,
            ((byte) ILOperandType.ImmediateQword << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode SX_BYTE = new ILOpCode(ILCode.SX_BYTE,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopByte << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode SX_WORD = new ILOpCode(ILCode.SX_WORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopWord << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode SX_DWORD = new ILOpCode(ILCode.SX_DWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode CALL = new ILOpCode(ILCode.CALL,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Call << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopVar << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode RET = new ILOpCode(ILCode.RET,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Return << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode NOR_DWORD = new ILOpCode(ILCode.NOR_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode NOR_QWORD = new ILOpCode(ILCode.NOR_QWORD,
            ((byte)(VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode CMP = new ILOpCode(ILCode.CMP,
            ((byte)(VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopObject_PopObject << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode CMP_DWORD = new ILOpCode(ILCode.CMP_DWORD,
            ((byte)(VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode CMP_QWORD = new ILOpCode(ILCode.CMP_QWORD,
            ((byte)(VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode CMP_R32 = new ILOpCode(ILCode.CMP_R32,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode CMP_R64 = new ILOpCode(ILCode.CMP_R64,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode JZ = new ILOpCode(ILCode.JZ,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.ConditionalJump << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode JNZ = new ILOpCode(ILCode.JNZ,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.ConditionalJump << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode JMP = new ILOpCode(ILCode.JMP,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Jump << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode SWT = new ILOpCode(ILCode.SWT,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.ConditionalJump << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode ADD_DWORD = new ILOpCode(ILCode.ADD_DWORD,
            ((byte)(VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode ADD_QWORD = new ILOpCode(ILCode.ADD_QWORD,
            ((byte)(VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode ADD_R32 = new ILOpCode(ILCode.ADD_R32,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal32 << StackBehaviourPushOffset));

        public static readonly ILOpCode ADD_R64 = new ILOpCode(ILCode.ADD_R64,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal64 << StackBehaviourPushOffset));

        public static readonly ILOpCode SUB_R32 = new ILOpCode(ILCode.SUB_R32,
            ((byte)(VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal32 << StackBehaviourPushOffset));

        public static readonly ILOpCode SUB_R64 = new ILOpCode(ILCode.SUB_R64,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal64 << StackBehaviourPushOffset));

        public static readonly ILOpCode MUL_DWORD = new ILOpCode(ILCode.MUL_DWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode MUL_QWORD = new ILOpCode(ILCode.MUL_QWORD,
            ((byte)(VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode MUL_R32 = new ILOpCode(ILCode.MUL_R32,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal32 << StackBehaviourPushOffset));

        public static readonly ILOpCode MUL_R64 = new ILOpCode(ILCode.MUL_R64,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal64 << StackBehaviourPushOffset));

        public static readonly ILOpCode DIV_DWORD = new ILOpCode(ILCode.DIV_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode DIV_QWORD = new ILOpCode(ILCode.DIV_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode DIV_R32 = new ILOpCode(ILCode.DIV_R32,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal32 << StackBehaviourPushOffset));

        public static readonly ILOpCode DIV_R64 = new ILOpCode(ILCode.DIV_R64,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal64 << StackBehaviourPushOffset));

        public static readonly ILOpCode REM_DWORD = new ILOpCode(ILCode.REM_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode REM_QWORD = new ILOpCode(ILCode.REM_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode REM_R32 = new ILOpCode(ILCode.REM_R32,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal32 << StackBehaviourPushOffset));

        public static readonly ILOpCode REM_R64 = new ILOpCode(ILCode.REM_R64,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal64 << StackBehaviourPushOffset));

        public static readonly ILOpCode SHR_DWORD = new ILOpCode(ILCode.SHR_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode SHR_QWORD = new ILOpCode(ILCode.SHR_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode SHL_DWORD = new ILOpCode(ILCode.SHL_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode SHL_QWORD = new ILOpCode(ILCode.SHL_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode FCONV_R32_R64 = new ILOpCode(ILCode.FCONV_R32_R64,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal64 << StackBehaviourPushOffset));

        public static readonly ILOpCode FCONV_R64_R32 = new ILOpCode(ILCode.FCONV_R64_R32,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal32 << StackBehaviourPushOffset));

        public static readonly ILOpCode FCONV_R32 = new ILOpCode(ILCode.FCONV_R32,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal32 << StackBehaviourPushOffset));

        public static readonly ILOpCode FCONV_R64 = new ILOpCode(ILCode.FCONV_R64,
            ((byte) VMFlags.UNSIGNED << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal64 << StackBehaviourPushOffset));

        public static readonly ILOpCode ICONV_PTR = new ILOpCode(ILCode.ICONV_PTR,
            ((byte) VMFlags.OVERFLOW << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushPtr << StackBehaviourPushOffset));

        public static readonly ILOpCode ICONV_R64 = new ILOpCode(ILCode.ICONV_R64,
            ((byte) (VMFlags.OVERFLOW | VMFlags.UNSIGNED) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode VCALL = new ILOpCode(ILCode.VCALL,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.VCall << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopVar << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushVar << StackBehaviourPushOffset));

        public static readonly ILOpCode TRY = new ILOpCode(ILCode.TRY,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopVar << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));

        public static readonly ILOpCode LEAVE = new ILOpCode(ILCode.LEAVE,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPushOffset));
        
        // Pseudo opcodes.
        public static readonly ILOpCode __NOT_DWORD = new ILOpCode(ILCode.__NOT_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            |((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __NOT_QWORD = new ILOpCode(ILCode.__NOT_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            |((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static ILOpCode __NEG_DWORD = new ILOpCode(ILCode.__NEG_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static ILOpCode __NEG_QWORD = new ILOpCode(ILCode.__NEG_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static ILOpCode __NEG_R32 = new ILOpCode(ILCode.__NEG_R32,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal32 << StackBehaviourPushOffset));

        public static ILOpCode __NEG_R64 = new ILOpCode(ILCode.__NEG_R64,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushReal64 << StackBehaviourPushOffset));

        public static ILOpCode __SUB_DWORD = new ILOpCode(ILCode.__SUB_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static ILOpCode __SUB_QWORD = new ILOpCode(ILCode.__SUB_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN | VMFlags.OVERFLOW | VMFlags.CARRY) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __OR_DWORD = new ILOpCode(ILCode.__OR_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __OR_QWORD = new ILOpCode(ILCode.__OR_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode __AND_DWORD = new ILOpCode(ILCode.__AND_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode __AND_QWORD = new ILOpCode(ILCode.__AND_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode __XOR_DWORD = new ILOpCode(ILCode.__XOR_DWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));

        public static readonly ILOpCode __XOR_QWORD = new ILOpCode(ILCode.__XOR_QWORD,
            ((byte) (VMFlags.ZERO | VMFlags.SIGN) << AffectedFlagsOffset)
            | ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushQword << StackBehaviourPushOffset));

        public static readonly ILOpCode __PUSH_EXCEPTION = new ILOpCode(ILCode.__PUSH_EXCEPTION,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.None << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushObject << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __EQUALS_DWORD = new ILOpCode(ILCode.__EQUALS_DWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __EQUALS_QWORD = new ILOpCode(ILCode.__EQUALS_QWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __EQUALS_R32 = new ILOpCode(ILCode.__EQUALS_R32,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __EQUALS_R64 = new ILOpCode(ILCode.__EQUALS_R64,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __EQUALS_OBJECT = new ILOpCode(ILCode.__EQUALS_OBJECT,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopObject_PopObject << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __GT_DWORD = new ILOpCode(ILCode.__GT_DWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __GT_QWORD = new ILOpCode(ILCode.__GT_QWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __GT_R32 = new ILOpCode(ILCode.__GT_R32,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __GT_R64 = new ILOpCode(ILCode.__GT_R64,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __LT_DWORD = new ILOpCode(ILCode.__LT_DWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopDword_PopDword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __LT_QWORD = new ILOpCode(ILCode.__LT_QWORD,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopQword_PopQword << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __LT_R32 = new ILOpCode(ILCode.__LT_R32,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal32_PopReal32 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
        
        public static readonly ILOpCode __LT_R64 = new ILOpCode(ILCode.__LT_R64,
            ((byte) ILOperandType.None << OperandTypeOffset)
            | ((byte) ILFlowControl.Next << FlowControlOffset)
            | ((byte) ILStackBehaviour.PopReal64_PopReal64 << StackBehaviourPopOffset)
            | ((byte) ILStackBehaviour.PushDword << StackBehaviourPushOffset));
    }
}


================================================
File: src/OldRod.Core/Architecture/ILOperandType.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum ILOperandType : byte
    {
        None,
        Register,
        ImmediateDword,
        ImmediateQword,
    }
}


================================================
File: src/OldRod.Core/Architecture/ILStackBehaviour.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum ILStackBehaviour : byte
    {
        None,
        PopAny,
        PopPtr,
        PopByte,
        PopWord,
        PopDword,
        PopQword,
        PopReal32,
        PopReal64,
        PopDword_PopDword,
        PopQword_PopQword,
        PopObject_PopObject,
        PopReal32_PopReal32,
        PopReal64_PopReal64,
        PopPtr_PopPtr,
        PopObject_PopPtr,
        PopByte_PopPtr,
        PopWord_PopPtr,
        PopDword_PopPtr,
        PopQword_PopPtr,
        PopVar,
        PushPtr,
        PushByte,
        PushWord,
        PushDword,
        PushQword,
        PushReal32,
        PushReal64,
        PushObject,
        PushVar,
    }
}


================================================
File: src/OldRod.Core/Architecture/KoiStream.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsmResolver;
using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Metadata;
using AsmResolver.PE.DotNet.Metadata.Tables;
using OldRod.Core.Disassembly;

namespace OldRod.Core.Architecture
{
    public class KoiStream : CustomMetadataStream
    {
        public const int Signature = 0x68736966;
        private const string Tag = "KoiStream";

        public KoiStream(string name, IReadableSegment contents, ILogger logger)
            : base(name, contents)
        {
            var reader = contents.CreateReader();

            logger.Debug(Tag, "Reading koi stream header...");
            uint magic = reader.ReadUInt32();
            
            if (magic != Signature)
                logger.Warning(Tag, $"Koi stream data does not start with a valid signature (Expected 0x{Signature:X4} but read 0x{magic:X4}).");
            
            uint mdCount = reader.ReadUInt32();
            uint strCount = reader.ReadUInt32();
            uint expCount = reader.ReadUInt32();

            logger.Debug(Tag, $"Reading {mdCount} references...");
            for (int i = 0; i < mdCount; i++)
            {
                uint id = Utils.ReadCompressedUInt(ref reader);
                uint token = Utils.FromCodedToken(Utils.ReadCompressedUInt(ref reader));
                References.Add(id, new MetadataToken(token));
            }

            logger.Debug(Tag, $"Reading {strCount} strings...");
            for (int i = 0; i < strCount; i++)
            {
                uint id = Utils.ReadCompressedUInt(ref reader);
                int length = (int) Utils.ReadCompressedUInt(ref reader);

                byte[] buffer = new byte[length * 2];
                reader.ReadBytes(buffer, 0, buffer.Length);
                Strings.Add(id, Encoding.Unicode.GetString(buffer));
            }

            logger.Debug(Tag, $"Reading {expCount} exports...");
            for (int i = 0; i < expCount; i++)
            {
                uint id = Utils.ReadCompressedUInt(ref reader);
                var exportInfo = VMExportInfo.FromReader(ref reader);
                
                // Exports in KoiVM either point to entrypoints of virtualised methods, or just act as a descriptor
                // for methods that are intra linked through instructions like ldftn.
                
                if (exportInfo.IsSignatureOnly)
                    logger.Debug(Tag, $"Export {id} maps to a method signature of an intra-linked method.");
                else
                    logger.Debug(Tag, $"Export {id} maps to function_{exportInfo.EntrypointAddress:X4}.");
                
                Exports.Add(id, exportInfo);
            }
        }

        public IDictionary<uint, MetadataToken> References
        {
            get;
        } = new Dictionary<uint, MetadataToken>();

        public IDictionary<uint, string> Strings
        {
            get;
        } = new Dictionary<uint, string>();

        public IDictionary<uint, VMExportInfo> Exports
        {
            get;
        } = new Dictionary<uint, VMExportInfo>();

        public ModuleDefinition ResolutionContext
        {
            get;
            set;
        }

        public new IReadableSegment Contents => (IReadableSegment) base.Contents;

        public IMetadataMember ResolveReference(ILogger logger, int instructionOffset, uint id, params TableIndex[] expectedMembers)
        {
            if (!References.TryGetValue(id, out var token))
            {
                throw new DisassemblyException($"Detected an invalid reference ID on the stack " +
                                               $"used for resolution at offset IL_{instructionOffset:X4}.");
            }

            if (expectedMembers.Length > 0 && !expectedMembers.Contains(token.Table))
            {
                logger.Warning(Tag,
                    $"Unexpected reference to a {token.Table} member used in one of the arguments of IL_{instructionOffset:X4}.");
            }

            var reference = ResolutionContext.LookupMember(token);
            if (reference is null)
            {
                throw new DisassemblyException(
                    $"Could not resolve the member {token} referenced in one of the arguments of IL_{instructionOffset:X4}.");
            }

            return ToDefinitionInOwnModule(reference) ?? reference;
        }

        private IMetadataMember ToDefinitionInOwnModule(IMetadataMember reference)
        {
            switch (reference)
            {
                case TypeReference type:
                    if (IsDefinedInOwnModule(type))
                        return type.Resolve();
                    break;
                
                case MemberReference member:
                    if (IsDefinedInOwnModule(member.DeclaringType))
                        return member.Resolve();
                    break;
            }

            return null;
        }

        private bool IsDefinedInOwnModule(ITypeDefOrRef type)
        {
            if (type.Scope == null)
                return false;    
            while (type.Scope is TypeReference scope)
                type = scope;

            return type.Scope == ResolutionContext;
        }
    }
}



================================================
File: src/OldRod.Core/Architecture/Utils.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using AsmResolver.DotNet;
using AsmResolver.IO;
using OldRod.Core.Disassembly.DataFlow;

namespace OldRod.Core.Architecture
{
    public static class Utils
    {
        private static readonly IDictionary<ILStackBehaviour, VMType[]> _argumentTypes =
            new Dictionary<ILStackBehaviour, VMType[]>
            {
                [ILStackBehaviour.None] = Array.Empty<VMType>(),
                [ILStackBehaviour.PopAny] = new[] {VMType.Object},
                [ILStackBehaviour.PopPtr] = new[] {VMType.Pointer},
                [ILStackBehaviour.PopByte] = new[] {VMType.Byte},
                [ILStackBehaviour.PopWord] = new[] {VMType.Word},
                [ILStackBehaviour.PopDword] = new[] {VMType.Dword},
                [ILStackBehaviour.PopQword] = new[] {VMType.Qword},
                [ILStackBehaviour.PopReal32] = new[] {VMType.Real32},
                [ILStackBehaviour.PopReal64] = new[] {VMType.Real64},
                [ILStackBehaviour.PopDword_PopDword] = new[] {VMType.Dword, VMType.Dword},
                [ILStackBehaviour.PopQword_PopQword] = new[] {VMType.Qword, VMType.Qword},
                [ILStackBehaviour.PopObject_PopObject] = new[] {VMType.Object, VMType.Object},
                [ILStackBehaviour.PopReal32_PopReal32] = new[] {VMType.Real32, VMType.Real32},
                [ILStackBehaviour.PopReal64_PopReal64] = new[] {VMType.Real64, VMType.Real64},
                [ILStackBehaviour.PopPtr_PopPtr] = new[] {VMType.Pointer, VMType.Pointer},
                [ILStackBehaviour.PopByte_PopPtr] = new[] {VMType.Byte, VMType.Pointer},
                [ILStackBehaviour.PopWord_PopPtr] = new[] {VMType.Word, VMType.Pointer},
                [ILStackBehaviour.PopDword_PopPtr] = new[] {VMType.Dword, VMType.Pointer},
                [ILStackBehaviour.PopQword_PopPtr] = new[] {VMType.Qword, VMType.Pointer},
                [ILStackBehaviour.PopObject_PopPtr] = new[] {VMType.Object, VMType.Pointer},
            };

        private static readonly IDictionary<ILStackBehaviour, VMType> _resultTypes =
            new Dictionary<ILStackBehaviour, VMType>
            {
                [ILStackBehaviour.PushPtr] = VMType.Pointer,
                [ILStackBehaviour.PushByte] = VMType.Byte,
                [ILStackBehaviour.PushWord] = VMType.Word,
                [ILStackBehaviour.PushDword] = VMType.Dword,
                [ILStackBehaviour.PushQword] = VMType.Qword,
                [ILStackBehaviour.PushReal32] = VMType.Real32,
                [ILStackBehaviour.PushReal64] = VMType.Real64,
                [ILStackBehaviour.PushObject] = VMType.Object,
            };
        
        public static uint ReadCompressedUInt(ref BinaryStreamReader reader)
        {
            uint num = 0;
            var shift = 0;
            byte current;
            do
            {
                current = reader.ReadByte();
                num |= (current & 0x7fu) << shift;
                shift += 7;
            } while((current & 0x80) != 0);
            return num;
        }

        public static uint FromCodedToken(uint codedToken)
        {
            var rid = codedToken >> 3;
            switch(codedToken & 7)
            {
                case 1:
                    return rid | 0x02000000;
                case 2:
                    return rid | 0x01000000;
                case 3:
                    return rid | 0x1b000000;
                case 4:
                    return rid | 0x0a000000;
                case 5:
                    return rid | 0x06000000;
                case 6:
                    return rid | 0x04000000;
                case 7:
                    return rid | 0x2b000000;
            }
            return rid;
        }
        
        public static VMType GetArgumentType(this ILStackBehaviour popBehaviour, int argumentIndex)
        {
            return _argumentTypes[popBehaviour][argumentIndex];
        }

        public static VMType GetResultType(this ILStackBehaviour pushBehaviour)
        {
            return _resultTypes.TryGetValue(pushBehaviour, out var type) ? type : VMType.Unknown;
        }

        public static VMType ToVMType(this ITypeDescriptor type)
        {
            if (type.Namespace != "System")
                return VMType.Object;

            switch (type.Name)
            {
                case "Boolean":
                case "Byte":
                case "SByte":
                    return VMType.Byte;
                case "Int16":
                case "UInt16":
                    return VMType.Word;
                case "Int32":
                case "UInt32":
                    return VMType.Dword;
                case "Int64":
                case "UInt64":
                    return VMType.Qword;
                case "Single":
                    return VMType.Real32;
                case "Double":
                    return VMType.Real64;
                case "IntPtr":
                case "UIntPtr":
                    return VMType.Pointer;
                case "Void":
                    return VMType.Unknown;
            }

            return VMType.Object;
        }

        public static ITypeDescriptor ToMetadataType(this VMType type, ModuleDefinition module)
        {
            switch (type)
            {
                case VMType.Unknown:
                case VMType.Object:
                    return module.CorLibTypeFactory.Object;
                case VMType.Pointer:
                    return module.CorLibTypeFactory.IntPtr;
                case VMType.Byte:
                    return module.CorLibTypeFactory.Byte;
                case VMType.Word:
                    return module.CorLibTypeFactory.UInt16;
                case VMType.Dword:
                    return module.CorLibTypeFactory.UInt32;
                case VMType.Qword:
                    return module.CorLibTypeFactory.UInt64;
                case VMType.Real32:
                    return module.CorLibTypeFactory.Single;
                case VMType.Real64:
                    return module.CorLibTypeFactory.Double;
                default:
                    throw new ArgumentOutOfRangeException(nameof(type), type, null);
            }
        }

        public static void AddOrMerge(this IList<SymbolicValue> values, int index, SymbolicValue value)
        {
            if (index < values.Count)
                values[index].MergeWith(value);
            else if (index == values.Count)
                values.Add(value);
            else
                throw new ArgumentOutOfRangeException(nameof(index));
        }

        public static ILFlowControl GetImpliedFlowControl(this VMCalls call)
        {
            switch (call)
            {
                case VMCalls.ECALL:
                    return ILFlowControl.Call;
                
                case VMCalls.EXIT:
                case VMCalls.THROW:
                    return ILFlowControl.Return;
            }

            return ILFlowControl.Next;
        }
    }
}


================================================
File: src/OldRod.Core/Architecture/VMCalls.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum VMCalls
    {
        EXIT = 0,
        BREAK = 1,
        ECALL = 2,
        CAST = 3,
        CKFINITE = 4,
        CKOVERFLOW = 5,
        RANGECHK = 6,
        INITOBJ = 7,
        LDFLD = 8,
        LDFTN = 9,
        TOKEN = 10,
        THROW = 11,
        SIZEOF = 12,
        STFLD = 13,
        BOX = 14,
        UNBOX = 15,
        LOCALLOC = 16,
    
        Max
    }
}


================================================
File: src/OldRod.Core/Architecture/VMConstants.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.DotNet;

namespace OldRod.Core.Architecture
{
    public class VMConstants
    {
        public IDictionary<FieldDefinition, byte> ConstantFields
        {
            get;
        } = new Dictionary<FieldDefinition, byte>();
        
        public IDictionary<byte, ILCode> OpCodes
        {
            get;
        } = new Dictionary<byte, ILCode>();
        
        public IDictionary<byte, VMFlags> Flags
        {
            get;
        } = new Dictionary<byte, VMFlags>();
        
        public IDictionary<byte, VMRegisters> Registers
        {
            get;
        } = new Dictionary<byte, VMRegisters>();
        
        public IDictionary<byte, VMCalls> VMCalls
        {
            get;
        } = new Dictionary<byte, VMCalls>();

        public byte HelperInit
        {
            get;
            set;
        }

        public IDictionary<byte, VMECallOpCode> ECallOpCodes
        {
            get;
        } = new Dictionary<byte, VMECallOpCode>();

        public byte FlagInstance
        {
            get;
            set;
        }

        public IDictionary<byte, EHType> EHTypes
        {
            get;
        } = new Dictionary<byte, EHType>();

        public uint KeyScalar
        {
            get;
            set;
        }

        public VMFlags ToFlags(byte value)
        {
            VMFlags result = 0;
            
            foreach (var entry in Flags)
            {
                if ((value & entry.Key) != 0) 
                    result |= entry.Value;
            }

            return result;
        }
        
        public byte GetFlagMask(VMFlags flags)
        {
            byte result = 0;

            foreach (var entry in Flags)
            {
                if (flags.HasFlag(entry.Value))
                    result |= entry.Key;
            }

            return result;
        }
        
    }
}


================================================
File: src/OldRod.Core/Architecture/VMECallOpCode.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum VMECallOpCode : byte
    {
        CALL,
        CALLVIRT,
        NEWOBJ,
        CALLVIRT_CONSTRAINED
    }
}


================================================
File: src/OldRod.Core/Architecture/VMExportInfo.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.IO;

namespace OldRod.Core.Architecture
{
    public class VMExportInfo
    {
        public static VMExportInfo FromReader(ref BinaryStreamReader reader)
        {
            uint offset = reader.ReadUInt32();
            uint entryKey = offset != 0 ? reader.ReadUInt32() : 0;

            return new VMExportInfo
            {
                EntrypointAddress = offset,
                EntryKey = entryKey,
                Signature = VMFunctionSignature.FromReader(ref reader)
            };
        }
        
        public uint EntrypointAddress
        {
            get;
            set;
        }

        public uint EntryKey
        {
            get;
            set;
        }

        public bool IsSignatureOnly => EntrypointAddress == 0;
        
        public VMFunctionSignature Signature
        {
            get;
            set;
        }

        public override string ToString()
        {
            return $"{nameof(EntrypointAddress)}: {EntrypointAddress:X8}, {nameof(EntryKey)}: {EntryKey:X8}, {nameof(Signature)}: {Signature}";
        }
    }
}


================================================
File: src/OldRod.Core/Architecture/VMFlags.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;

namespace OldRod.Core.Architecture
{
    [Flags]
    public enum VMFlags
    {
        OVERFLOW = 1,
        CARRY = 2,
        ZERO = 4,
        SIGN = 8,
        UNSIGNED = 16,
        BEHAV1 = 32,
        BEHAV2 = 64,
        BEHAV3 = 128,

        Max
    }
}


================================================
File: src/OldRod.Core/Architecture/VMFunctionSignature.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.IO;
using AsmResolver.PE.DotNet.Metadata.Tables;

namespace OldRod.Core.Architecture
{
    public class VMFunctionSignature
    {
        public static VMFunctionSignature FromReader(ref BinaryStreamReader reader)
        {
            var result = new VMFunctionSignature
            {
                Flags = reader.ReadByte()
            };
            
            uint count = Utils.ReadCompressedUInt(ref reader);
            for (var i = 0; i < count; i++)
            {
                result.ParameterTokens.Add(
                    new MetadataToken(Utils.FromCodedToken(Utils.ReadCompressedUInt(ref reader))));
            }

            result.ReturnToken = new MetadataToken(Utils.FromCodedToken(Utils.ReadCompressedUInt(ref reader)));

            return result;
        }

        public byte Flags
        {
            get;
            set;
        }

        public IList<MetadataToken> ParameterTokens
        {
            get;
        } = new List<MetadataToken>();

        public MetadataToken ReturnToken
        {
            get;
            set;
        }

        public override string ToString()
        {
            return $"{nameof(Flags)}: {Flags}, {nameof(ParameterTokens)}: {{{string.Join(", ", ParameterTokens)}}}, {nameof(ReturnToken)}: {ReturnToken}";
        }
        
    }
}


================================================
File: src/OldRod.Core/Architecture/VMRegisters.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum VMRegisters
    {
        R0 = 0,
        R1 = 1,
        R2 = 2,
        R3 = 3,
        R4 = 4,
        R5 = 5,
        R6 = 6,
        R7 = 7,

        BP = 8,
        SP = 9,
        IP = 10,
        FL = 11,
        K1 = 12,
        K2 = 13,
        M1 = 14,
        M2 = 15,

        Max
    }
}


================================================
File: src/OldRod.Core/Architecture/VMType.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Architecture
{
    public enum VMType
    {
        Unknown,
        Object,
        Pointer,
        Byte,
        Word,
        Dword,
        Qword,
        Real32,
        Real64,
    }
}


================================================
File: src/OldRod.Core/Ast/AstNodeCollection.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.ObjectModel;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Ast
{
    public class AstNodeCollection<TNode> : Collection<TNode>
        where TNode : IAstNode
    {
        public AstNodeCollection(IAstNode owner)
        {
            Owner = owner ?? throw new ArgumentNullException(nameof(owner));
        }
        
        public IAstNode Owner
        {
            get;
        }
        
        protected override void SetItem(int index, TNode item)
        {
            if (item.Parent != null)
                throw new ArgumentException("Item is already added to another node.");
            Items[index].Parent = null;
            base.SetItem(index, item);
            item.Parent = Owner;
        }

        protected override void ClearItems()
        {
            foreach (var item in Items)
                item.Parent = null;
            base.ClearItems();
        }

        protected override void RemoveItem(int index)
        {
            var item = Items[index];
            base.RemoveItem(index);
            item.Parent = null;
        }

        protected override void InsertItem(int index, TNode item)
        {
            if (item.Parent != null)
                throw new ArgumentException("Item is already added to another node.");
            base.InsertItem(index, item);
            item.Parent = Owner;
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IAstNode.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;

namespace OldRod.Core.Ast
{
    public interface IAstNode
    {
        IAstNode Parent
        {
            get;
            set;
        }

        IEnumerable<IAstNode> GetChildren();
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilAssignmentStatement.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;

namespace OldRod.Core.Ast.Cil
{
    public class CilAssignmentStatement : CilStatement
    {
        private CilVariable _variable;
        private CilExpression _value;

        public CilAssignmentStatement(CilVariable variable, CilExpression value)
        {
            Variable = variable;
            Value = value;
        }
        
        public CilVariable Variable
        {
            get => _variable;
            set
            {
                _variable?.AssignedBy.Remove(this);
                _variable = value;
                _variable?.AssignedBy.Add(this);
            }
        }

        public CilExpression Value
        {
            get => _value;
            set
            {
                if (value?.Parent != null)
                    throw new ArgumentException("Item is already added to another node.");
                if (_value != null)
                    _value.Parent = null;
                _value = value;
                if (value != null)
                    value.Parent = this;
            }
        }
        
        public override void ReplaceNode(CilAstNode node, CilAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            Value = (CilExpression) newNode;   
        }

        public override IEnumerable<CilAstNode> GetChildren()
        {
            return new[] {Value};
        }

        public override void AcceptVisitor(ICilAstVisitor visitor)
        {
            visitor.VisitAssignmentStatement(this);
        }

        public override TResult AcceptVisitor<TResult>(ICilAstVisitor<TResult> visitor)
        {
            return visitor.VisitAssignmentStatement(this);
        }

        public override string ToString()
        {
            return $"stloc {Variable.Name}({Value})";
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilAstBlock.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.PE.DotNet.Cil;

namespace OldRod.Core.Ast.Cil
{
    public class CilAstBlock : CilStatement
    {
        public const string AstBlockProperty = "cilastblock";

        public CilAstBlock()
        {
            Statements = new AstNodeCollection<CilStatement>(this);
            BlockHeader = new CilInstruction(CilOpCodes.Nop);
        }

        public CilInstruction BlockHeader
        {
            get;
        }
        
        public IList<CilStatement> Statements
        {
            get;
        }

        public override void ReplaceNode(CilAstNode node, CilAstNode newNode)
        {            
            AssertNodeParents(node, newNode);
            int index = Statements.IndexOf((CilStatement) node);
            Statements[index] = (CilStatement) newNode;
        }

        public override IEnumerable<CilAstNode> GetChildren()
        {
            return Statements;
        }

        public override void AcceptVisitor(ICilAstVisitor visitor)
        {
            visitor.VisitBlock(this);
        }

        public override TResult AcceptVisitor<TResult>(ICilAstVisitor<TResult> visitor)
        {
            return visitor.VisitBlock(this);
        }

        public override string ToString()
        {
            return string.Join("\n", Statements);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilAstFormatter.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Linq;
using System.Text;
using AsmResolver.PE.DotNet.Cil;

namespace OldRod.Core.Ast.Cil
{
    public class CilAstFormatter : ICilAstVisitor<string>
    {
        private readonly CilInstructionFormatter _formatter = new CilInstructionFormatter();
        
        public string VisitCompilationUnit(CilCompilationUnit unit) => throw new NotImplementedException();

        public string VisitBlock(CilAstBlock block)
        {
            const int maxLineLength = 100;
            var builder = new StringBuilder();

            foreach (var value in block.Statements)
            {
                string stringValue = value.AcceptVisitor(this);

                for (int i = 0; i < stringValue.Length; i += maxLineLength)
                {
                    int lineLength = Math.Min(stringValue.Length - i, maxLineLength);
                    string line = stringValue.Substring(i, lineLength);
                    if (i > 0)
                        builder.Append("     ");
                    builder.Append(line);
                    builder.Append("\\l");
                }
            }
            
            return builder.ToString();
        }

        public string VisitExpressionStatement(CilExpressionStatement statement)
        {
            return statement.Expression.AcceptVisitor(this);
        }

        public string VisitAssignmentStatement(CilAssignmentStatement statement)
        {
            return $"stloc {statement.Variable.Name} ({statement.Value.AcceptVisitor(this)})";
        }

        public string VisitInstructionExpression(CilInstructionExpression expression)
        {
            string instructionsString =
                (expression.ShouldEmitFlagsUpdate ? "fl_" : "")
                + string.Join(" - ", expression.Instructions.Select(i => i.Operand == null
                    ? _formatter.FormatOpCode(i.OpCode)
                    : _formatter.FormatOpCode(i.OpCode) + " " +
                      _formatter.FormatOperand(i.OpCode.OperandType, i.Operand)));

            return expression.Arguments.Count == 0
                ? instructionsString
                : $"{instructionsString}({string.Join(", ", expression.Arguments.Select(a=>a.AcceptVisitor(this)))})";
        }

        public string VisitUnboxToVmExpression(CilUnboxToVmExpression expression)
        {
            return $"unbox.tovm({expression.Type})({expression.Expression.AcceptVisitor(this)})";
        }

        public string VisitVariableExpression(CilVariableExpression expression)
        {
            return $"ldloc {expression.Variable.Name}";
        }
     
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilAstNode.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;

namespace OldRod.Core.Ast.Cil
{
    public abstract class CilAstNode : IAstNode
    { 
        public CilAstNode Parent
        {
            get;
            internal set;
        }

        IAstNode IAstNode.Parent
        {
            get => Parent;
            set => Parent = (CilAstNode) value;
        }

        public CilAstNode Remove()
        {
            ReplaceWith(null);
            return this;
        }

        public void ReplaceWith(CilAstNode node)
        {
            Parent.ReplaceNode(this, node);
        }

        public abstract void ReplaceNode(CilAstNode node, CilAstNode newNode);

        public abstract IEnumerable<CilAstNode> GetChildren();
        
        IEnumerable<IAstNode> IAstNode.GetChildren()
        {
            return GetChildren();
        }

        public abstract void AcceptVisitor(ICilAstVisitor visitor);

        public abstract TResult AcceptVisitor<TResult>(ICilAstVisitor<TResult> visitor);
        
        protected void AssertNodeParents(CilAstNode node, CilAstNode newNode)
        {
            if (node.Parent != this)
                throw new ArgumentException("Item is not a member of this node.");
            if (newNode?.Parent != null)
                throw new ArgumentException("Item is already a member of another node.");
        }

    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilCompilationUnit.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Disassembly.ControlFlow;

namespace OldRod.Core.Ast.Cil
{
    public class CilCompilationUnit : CilAstNode
    {
        public CilCompilationUnit(ControlFlowGraph graph)
        {
            ControlFlowGraph = graph;
        }
        
        public ICollection<CilVariable> Variables
        {
            get;
        } = new List<CilVariable>();
        
        public ICollection<CilParameter> Parameters
        {
            get;
        } = new List<CilParameter>();

        public CilVariable FlagVariable
        {
            get;
            set;
        }
        
        public ControlFlowGraph ControlFlowGraph
        {
            get;
        }
        
        public override void ReplaceNode(CilAstNode node, CilAstNode newNode)
        {
            throw new System.NotImplementedException();
        }

        public override IEnumerable<CilAstNode> GetChildren()
        {
            return ControlFlowGraph.Nodes.Select(x => (CilAstBlock) x.UserData[CilAstBlock.AstBlockProperty]);
        }

        public override void AcceptVisitor(ICilAstVisitor visitor)
        {
            visitor.VisitCompilationUnit(this);
        }

        public override TResult AcceptVisitor<TResult>(ICilAstVisitor<TResult> visitor)
        {
            return visitor.VisitCompilationUnit(this);
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilExpression.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.Cil
{
    public abstract class CilExpression : CilAstNode
    {
        private static readonly SignatureComparer Comparer = new SignatureComparer();
        private ITypeDescriptor _expectedType;
        private ITypeDescriptor _expressionType;

        public ITypeDescriptor ExpressionType
        {
            get => _expressionType;
            set => _expressionType = value;
        }

        public ITypeDescriptor ExpectedType
        {
            get => _expectedType;
            set => _expectedType = value;
        }

        public VMFlags AffectedFlags
        {
            get;
            set;
        }

        public bool ShouldEmitFlagsUpdate
        {
            get;
            set;
        }
        
        public bool InvertedFlagsUpdate
        {
            get;
            set;
        }
      
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilExpressionStatement.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;

namespace OldRod.Core.Ast.Cil
{
    public class CilExpressionStatement : CilStatement
    {
        private CilExpression _expression;

        public CilExpressionStatement(CilExpression expression)
        {
            Expression = expression;
        }
        
        public CilExpression Expression
        {
            get => _expression;
            set
            {
                if (value?.Parent != null)
                    throw new ArgumentException("Item is already added to another node.");
                if (_expression != null)
                    _expression.Parent = null;
                _expression = value;
                if (value != null)
                    value.Parent = this;
            }
        }
        
        public override void ReplaceNode(CilAstNode node, CilAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            Expression = (CilExpression) newNode;
        }

        public override IEnumerable<CilAstNode> GetChildren()
        {
            return new[] {Expression};
        }

        public override void AcceptVisitor(ICilAstVisitor visitor)
        {
            visitor.VisitExpressionStatement(this);
        }

        public override TResult AcceptVisitor<TResult>(ICilAstVisitor<TResult> visitor)
        {
            return visitor.VisitExpressionStatement(this);
        }

        public override string ToString()
        {
            return Expression.ToString();
        }
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilInstructionExpression.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.PE.DotNet.Cil;

namespace OldRod.Core.Ast.Cil
{
    public class CilInstructionExpression : CilExpression
    {
        public CilInstructionExpression()
        {
            Instructions = new List<CilInstruction>();
            Arguments = new AstNodeCollection<CilExpression>(this);
        }
        
        public CilInstructionExpression(CilOpCode opCode)
            : this(opCode, null, Enumerable.Empty<CilExpression>())
        {
        }
       
        public CilInstructionExpression(CilOpCode opCode, object operand)
            : this(opCode, operand, Enumerable.Empty<CilExpression>())
        {
        }

        public CilInstructionExpression(CilOpCode opCode, object operand, params CilExpression[] arguments)
            : this(opCode, operand, arguments.AsEnumerable())
        {
        }

        public CilInstructionExpression(CilOpCode opCode, object operand, IEnumerable<CilExpression> arguments)
            : this(new[] {new CilInstruction(0, opCode, operand) }, arguments)
        {
        }

        public CilInstructionExpression(IEnumerable<CilInstruction> instructions, IEnumerable<CilExpression> arguments)
        {
            Instructions = new List<CilInstruction>(instructions);
            Arguments = new AstNodeCollection<CilExpression>(this);
            
            foreach (var argument in arguments)
                Arguments.Add(argument);   
        }

        public IList<CilInstruction> Instructions
        {
            get;
        }

        public IList<CilExpression> Arguments
        {
            get;
        }

        public override void ReplaceNode(CilAstNode node, CilAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            int index = Arguments.IndexOf((CilExpression) node);
            
            if (newNode == null)
                Arguments.RemoveAt(index);
            else
                Arguments[index] = (CilExpression) newNode;
        }

        public override IEnumerable<CilAstNode> GetChildren()
        {
            return Arguments;
        }

        public override void AcceptVisitor(ICilAstVisitor visitor)
        {
            visitor.VisitInstructionExpression(this);
        }

        public override TResult AcceptVisitor<TResult>(ICilAstVisitor<TResult> visitor)
        {
            return visitor.VisitInstructionExpression(this);
        }

        public override string ToString()
        {
            string instructionsString =
                (ShouldEmitFlagsUpdate ? "fl_" : string.Empty)
                + string.Join(" - ",
                    Instructions.Select(i => i.Operand == null
                        ? i.OpCode.Mnemonic
                        : i.OpCode.Mnemonic + " " + i.Operand));

            return Arguments.Count == 0
                ? instructionsString
                : $"{instructionsString}({string.Join(", ", Arguments)})";
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilParameter.cs
================================================
using AsmResolver.DotNet.Signatures.Types;

namespace OldRod.Core.Ast.Cil
{
    public class CilParameter : CilVariable
    {
        public CilParameter(string name, TypeSignature variableType, int parameterIndex, bool hasFixedType)
            : base(name, variableType)
        {
            ParameterIndex = parameterIndex;
            HasFixedType = hasFixedType;
        }

        public int ParameterIndex
        {
            get;
        }

        public bool HasFixedType
        {
            get;
        }
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilStatement.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.Cil
{
    public abstract class CilStatement : CilAstNode
    {
        
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilUnboxToVmExpression.cs
================================================
using System;
using System.Collections.Generic;
using AsmResolver.DotNet;

namespace OldRod.Core.Ast.Cil
{
    public class CilUnboxToVmExpression : CilExpression
    {
        private CilExpression _expression;

        public CilUnboxToVmExpression(ITypeDefOrRef type, CilExpression expression)
        {
            Type = type;
            Expression = expression;
        }
        
        public ITypeDefOrRef Type
        {
            get;
            set;
        }
        
        public CilExpression Expression
        {
            get => _expression;
            set
            {
                if (value?.Parent != null)
                    throw new ArgumentException("Item is already added to another node.");
                if (_expression != null)
                    _expression.Parent = null;
                _expression = value;
                if (value != null)
                    value.Parent = this;
            }
        }
        
        public override void ReplaceNode(CilAstNode node, CilAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            Expression = (CilExpression) newNode;
        }

        public override IEnumerable<CilAstNode> GetChildren()
        {
            return new[] {Expression};
        }

        public override void AcceptVisitor(ICilAstVisitor visitor)
        {
            visitor.VisitUnboxToVmExpression(this);
        }

        public override TResult AcceptVisitor<TResult>(ICilAstVisitor<TResult> visitor)
        {
            return visitor.VisitUnboxToVmExpression(this);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilVariable.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.DotNet.Signatures.Types;

namespace OldRod.Core.Ast.Cil
{
    public class CilVariable
    {
        public CilVariable(string name, TypeSignature variableType)
        {
            Name = name;
            VariableType = variableType;
        }
        
        public string Name
        {
            get;
        }

        public TypeSignature VariableType
        {
            get;
            set;
        }

        public IList<CilVariableExpression> UsedBy
        {
            get;
        } = new List<CilVariableExpression>();

        public IList<CilAssignmentStatement> AssignedBy
        {
            get;
        } = new List<CilAssignmentStatement>();

        public override string ToString()
        {
            return $"{VariableType} {Name}";
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/CilVariableExpression.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Ast.Cil
{
    public class CilVariableExpression : CilExpression
    {
        private CilVariable _variable;

        public CilVariableExpression(CilVariable variable)
        {
            Variable = variable;
        }
        
        public CilVariable Variable
        {
            get => _variable;
            set
            {
                _variable?.UsedBy.Remove(this);
                _variable = value;
                if (value != null)
                {
                    value.UsedBy.Add(this);
                    ExpressionType = value.VariableType;
                }
            }
        }

        public bool IsParameter => Variable is CilParameter;
        
        public bool IsReference
        {
            get;
            set;
        }
        
        public override void ReplaceNode(CilAstNode node, CilAstNode newNode)
        {
            throw new InvalidOperationException();
        }

        public override IEnumerable<CilAstNode> GetChildren()
        {
            return Enumerable.Empty<CilAstNode>();
        }

        public override void AcceptVisitor(ICilAstVisitor visitor)
        {
            visitor.VisitVariableExpression(this);
        }

        public override TResult AcceptVisitor<TResult>(ICilAstVisitor<TResult> visitor)
        {
            return visitor.VisitVariableExpression(this);
        }

        public override string ToString()
        {
            return IsParameter
                ? IsReference
                    ? $"ldarga {Variable.Name}"
                    : $"ldarg {Variable.Name}"
                : IsReference
                    ? $"ldloca {Variable.Name}"
                    : $"ldloc {Variable.Name}";
        }
    }
}


================================================
File: src/OldRod.Core/Ast/Cil/ICilAstVisitor.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.Cil
{
    public interface ICilAstVisitor
    {
        void VisitCompilationUnit(CilCompilationUnit unit);
        void VisitBlock(CilAstBlock block);
        void VisitExpressionStatement(CilExpressionStatement statement);
        void VisitAssignmentStatement(CilAssignmentStatement statement);
        void VisitInstructionExpression(CilInstructionExpression expression);
        void VisitUnboxToVmExpression(CilUnboxToVmExpression expression);
        void VisitVariableExpression(CilVariableExpression expression);
    }

    public interface ICilAstVisitor<out TResult>
    {
        TResult VisitCompilationUnit(CilCompilationUnit unit);
        TResult VisitBlock(CilAstBlock block);
        TResult VisitExpressionStatement(CilExpressionStatement statement);
        TResult VisitAssignmentStatement(CilAssignmentStatement statement);
        TResult VisitInstructionExpression(CilInstructionExpression expression);
        TResult VisitUnboxToVmExpression(CilUnboxToVmExpression expression);
        TResult VisitVariableExpression(CilVariableExpression expression);
    }
}


================================================
File: src/OldRod.Core/Ast/IL/IILArgumentsProvider.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;

namespace OldRod.Core.Ast.IL
{
    public interface IILArgumentsProvider
    {
        IList<ILExpression> Arguments
        {
            get;
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/IL/IILAstVisitor.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.IL
{
    public interface IILAstVisitor
    {
        void VisitCompilationUnit(ILCompilationUnit unit);
        void VisitBlock(ILAstBlock block);
        void VisitExpressionStatement(ILExpressionStatement statement);
        void VisitAssignmentStatement(ILAssignmentStatement statement);
        void VisitInstructionExpression(ILInstructionExpression expression);
        void VisitVariableExpression(ILVariableExpression expression);
        void VisitVCallExpression(ILVCallExpression expression);
        void VisitPhiExpression(ILPhiExpression expression);
        void VisitExceptionExpression(ILExceptionExpression expression);
    }
    
    public interface IILAstVisitor<out TResult>
    {
        TResult VisitCompilationUnit(ILCompilationUnit unit);
        TResult VisitBlock(ILAstBlock block);
        TResult VisitExpressionStatement(ILExpressionStatement statement);
        TResult VisitAssignmentStatement(ILAssignmentStatement statement);
        TResult VisitInstructionExpression(ILInstructionExpression expression);
        TResult VisitVariableExpression(ILVariableExpression expression);
        TResult VisitVCallExpression(ILVCallExpression expression);
        TResult VisitPhiExpression(ILPhiExpression expression);
        TResult VisitExceptionExpression(ILExceptionExpression expression);
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILAssignmentStatement.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;

namespace OldRod.Core.Ast.IL
{
    public class ILAssignmentStatement : ILStatement
    {
        private ILExpression _value;
        private ILVariable _variable;

        public ILAssignmentStatement(ILVariable variable, ILExpression value)
        {
            Variable = variable;
            Value = value;
        }

        public ILVariable Variable
        {
            get => _variable;
            set
            {
                _variable?.AssignedBy.Remove(this);
                _variable = value;
                value?.AssignedBy.Add(this);
            }
        }

        public ILExpression Value
        {
            get => _value;
            set
            {
                if (value?.Parent != null)
                    throw new ArgumentException("Item is already added to another node.");
                if (_value != null)
                    _value.Parent = null;
                _value = value;
                if (value != null)
                    value.Parent = this;
            }
        }

        public override bool HasPotentialSideEffects => Value.HasPotentialSideEffects;

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            Value = (ILExpression) newNode;
        }


        public override string ToString()
        {
            return $"{Variable.Name} = {Value}";
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return new[] {Value};
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitAssignmentStatement(this);
        }

        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitAssignmentStatement(this);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILAstBlock.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using Rivers;

namespace OldRod.Core.Ast.IL
{
    public class ILAstBlock : ILAstNode
    {
        public const string AstBlockProperty = "ilastblock";

        public ILAstBlock(Node cfgNode)
        {
            CfgNode = cfgNode ?? throw new ArgumentNullException(nameof(cfgNode));
            Statements = new AstNodeCollection<ILStatement>(this);
        }

        public Node CfgNode
        {
            get;
        }
        
        public IList<ILStatement> Statements
        {
            get;
        }

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            int index = Statements.IndexOf((ILStatement) node);

            if (newNode == null)
                Statements.RemoveAt(index);
            else
                Statements[index] = (ILStatement) newNode;
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return Statements;
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitBlock(this);
        }

        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitBlock(this);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILAstBuilder.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.IL.Transform;
using OldRod.Core.Disassembly.Annotations;
using OldRod.Core.Disassembly.ControlFlow;
using OldRod.Core.Disassembly.DataFlow;
using OldRod.Core.Disassembly.Inference;
using OldRod.Core.Memory;

namespace OldRod.Core.Ast.IL
{
    public class ILAstBuilder
    {
        public event EventHandler<ILCompilationUnit> InitialAstBuilt;
        public event EventHandler<ILTransformEventArgs> TransformStart;
        public event EventHandler<ILTransformEventArgs> TransformEnd;
        
        private const string Tag = "AstBuilder";

        private readonly IDictionary<string, string> _sharedVariables = new Dictionary<string, string>();
        
        public ILogger Logger
        {
            get;
            set;
        } = EmptyLogger.Instance;

        public int? MaxSimplificationPasses
        {
            get;
            set;
        }
        
        public ILCompilationUnit BuildAst(
            ControlFlowGraph graph, 
            IFrameLayout frameLayout,
            VMConstants constants)
        {
            Logger.Debug(Tag, "Building initial IL-AST...");
            var result = BuildBasicAst(graph, frameLayout);
            OnInitialAstBuilt(result);
            
            Logger.Debug(Tag, "Applying IL-AST transforms...");
            ApplyTransformations(result, constants);
            
            return result;
        }

        private ILCompilationUnit BuildBasicAst(ControlFlowGraph graph, IFrameLayout frameLayout)
        {
            var result = new ILCompilationUnit(graph, frameLayout);

            // Introduce variables:
            Logger.Debug2(Tag, "Determining variables...");
            var resultVariables = DetermineVariables(result);

            // Build AST blocks.
            Logger.Debug2(Tag, "Building AST blocks...");
            BuildAstBlocks(result, resultVariables);

            Logger.Debug2(Tag, "Marking expressions affecting flags...");
            var marker = new FlagDataSourceMarker();
            result.AcceptVisitor(marker);

            return result;
        }

        private IDictionary<int, ILVariable> DetermineVariables(ILCompilationUnit result)
        {
            IntroduceRegisterVariables(result);
            return IntroduceResultVariables(result);
        }
       
        private static void IntroduceRegisterVariables(ILCompilationUnit result)
        {
            for (int i = 0; i < (int) VMRegisters.Max; i++)
            {
                var register = (VMRegisters) i;
                var registerVar = result.GetOrCreateVariable(register.ToString());

                registerVar.VariableType = register == VMRegisters.FL
                    ? VMType.Byte
                    : VMType.Object;
            }
        }

        private IDictionary<int, ILVariable> IntroduceResultVariables(ILCompilationUnit result)
        {
            // Determine result variables based on where the value is used by other instructions.
            // Find for each instruction the dependent instructions and assign to each of those dependent instructions
            // the same variable.
            
            var resultVariables = new Dictionary<int, ILVariable>();
            var instructions = result.ControlFlowGraph.Nodes
                .Select(x => (ILBasicBlock) x.UserData[ILBasicBlock.BasicBlockProperty])
                .SelectMany(x => x.Instructions);
            
            foreach (var instruction in instructions)
            {
                if (instruction.OpCode.Code == ILCode.CALL)
                {
                    // Calls have implicit dependencies to the parameters pushed onto the stack.
                    // We need to add them for the expression builder to work properly.
                    
                    var callAnnotation = (CallAnnotation) instruction.Annotation;
                    int parametersCount = callAnnotation.Function.FrameLayout.Parameters.Count;

                    // Create a copy of the stack and pop the first dependency (the call address) from it.
                    var stackCopy = instruction.ProgramState.Stack.Copy();
                    stackCopy.Pop(); 
                    
                    // TODO: Respect the frame layout rather than hardcoding it.
                    
                    // Pop all arguments from the stack.
                    var arguments = new SymbolicValue[parametersCount];
                    for (int i = parametersCount - 1; i >= 0; i--)
                        arguments[i] = stackCopy.Pop();

                    // Add new dependencies.
                    for (int i = 0; i < parametersCount; i++)
                        instruction.Dependencies.AddOrMerge(i + 1, arguments[i]);
                }
                
                for (int i = 0; i < instruction.Dependencies.Count; i++)
                {
                    var dep = instruction.Dependencies[i];
                    
                    // Check if the pushed value already has a result variable assigned to it.
                    var resultVar = GetExistingVariableForStackSlot(resultVariables, dep);

                    string variableName = GetOperandVariableName(instruction, i);
                    if (resultVar == null)
                    {
                        // Introduce variable for dependency.
                        resultVar = result.GetOrCreateVariable(variableName);
                        resultVar.VariableType = dep.Type;

                        // Assign this variable to all instructions that determine the value of this dependency.
                        foreach (var source in dep.DataSources)
                            resultVariables[source.Offset] = resultVar;
                    }
                    else
                    {
                        _sharedVariables[variableName] = resultVar.Name;
                    }
                    
                }
            }

            return resultVariables;
        }

        private static ILVariable GetExistingVariableForStackSlot(IReadOnlyDictionary<int, ILVariable> resultVariables, SymbolicValue dep)
        {
            foreach (var source in dep.DataSources)
            {
                if (resultVariables.TryGetValue(source.Offset, out var existingVariable))
                    return existingVariable;
            }

            return null;
        }

        private static string GetOperandVariableName(ILInstruction instruction, int operandIndex)
        {
            return $"operand_{instruction.Offset:X}_{operandIndex.ToString()}";
        }

        private void BuildAstBlocks(ILCompilationUnit result, IDictionary<int, ILVariable> resultVariables)
        {
            foreach (var node in result.ControlFlowGraph.Nodes)
            {
                var ilBlock = (ILBasicBlock) node.UserData[ILBasicBlock.BasicBlockProperty];
                var astBlock = new ILAstBlock(node);
                
                foreach (var instruction in ilBlock.Instructions)
                    astBlock.Statements.Add(BuildStatement(result, resultVariables, instruction));

                node.UserData[ILAstBlock.AstBlockProperty] = astBlock;
            }
        }

        private ILStatement BuildStatement(ILCompilationUnit result, IDictionary<int, ILVariable> resultVariables, ILInstruction instruction)
        {
            // Build expression.
            var expression = BuildExpression(instruction, result);

            switch (instruction.OpCode.Code)
            {
                case ILCode.POP:
                    return BuildPopStatement(result, instruction, expression);
                case ILCode.CALL:
                    return BuildCallStatement(result, instruction, expression);
                case ILCode.RET:
                    return BuildRetStatement(result, instruction, expression);
                default:
                    return BuildAssignment(resultVariables, instruction, expression);
            }
        }

        private static ILStatement BuildPopStatement(ILCompilationUnit result, ILInstruction instruction,
            ILExpression expression)
        {
            // Since we treat registers as variables, we should treat POP instructions as assignment
            // statements instead of a normal ILExpressionStatement. This makes it easier to apply
            // analysis and transformations (such as variable inlining) later, in the same way we do
            // that with normal variables.
            var register = (VMRegisters) instruction.Operand;

            // Get the variable associated to the register. FL registers need special care, as they
            // are used in various optimisation stages.
            var registerVar = register == VMRegisters.FL
                ? result.GetOrCreateFlagsVariable(new[] {instruction.Offset})
                : result.GetOrCreateVariable(register.ToString());

            var value = (ILExpression) ((IILArgumentsProvider) expression).Arguments[0].Remove();

            return new ILAssignmentStatement(registerVar, value);
        }

        private static ILStatement BuildCallStatement(ILCompilationUnit result, ILInstruction instruction,
            ILExpression expression)
        {
            // CALL instructions that call non-void methods store the result in R0.
            // TODO: Respect frame layout instead of hardcoding R0 as return value.

            var callAnnotation = (CallAnnotation) instruction.Annotation;

            var statement = callAnnotation.Function.FrameLayout.ReturnsValue
                ? (ILStatement) new ILAssignmentStatement(
                    result.GetOrCreateVariable(nameof(VMRegisters.R0)), expression)
                : new ILExpressionStatement(expression);

            return statement;
        }

        private static ILStatement BuildRetStatement(ILCompilationUnit result, ILInstruction instruction,
            ILExpression expression)
        {
            // TODO: Respect frame layout instead of hardcoding R0 as return value.
            var returnExpr = (IILArgumentsProvider) expression;

            foreach (var use in expression.AcceptVisitor(VariableUsageCollector.Instance))
                use.Variable = null;

            returnExpr.Arguments.Clear();

            var ehStack = instruction.ProgramState.EHStack;
            if (result.FrameLayout.ReturnsValue && !instruction.ProgramState.IgnoreExitKey
                || ehStack.Count > 0 && ehStack.Peek().Type == EHType.FILTER)
            {
                var registerVar = result.GetOrCreateVariable(nameof(VMRegisters.R0));
                returnExpr.Arguments.Add(new ILVariableExpression(registerVar));
            }

            return new ILExpressionStatement(expression);
        }

        private static ILStatement BuildAssignment(IDictionary<int, ILVariable> resultVariables, ILInstruction instruction,
            ILExpression expression)
        {
            // Build statement around expression.
            var statement = resultVariables.TryGetValue(instruction.Offset, out var resultVariable)
                ? (ILStatement) new ILAssignmentStatement(resultVariable, expression)
                : new ILExpressionStatement(expression);

            return statement;
        }

        private ILExpression BuildExpression(ILInstruction instruction, ILCompilationUnit result)
        {
            IILArgumentsProvider expression;
            switch (instruction.OpCode.Code)
            {
                case ILCode.VCALL:
                    expression = new ILVCallExpression((VCallAnnotation) instruction.Annotation);
                    break;
                
                case ILCode.PUSHR_BYTE:
                case ILCode.PUSHR_WORD:
                case ILCode.PUSHR_DWORD:
                case ILCode.PUSHR_QWORD:
                case ILCode.PUSHR_OBJECT:
                    expression = BuildPushrExpression(instruction, result);
                    break;

                default:
                    expression = new ILInstructionExpression(instruction);
                    break;
            }


            for (int i = 0; i < instruction.Dependencies.Count; i++)
            {
                ILExpression argument;
                var firstDataSource = instruction.Dependencies[i].DataSources.First();
                if (firstDataSource.Offset == InstructionProcessor.PushExceptionOffset)
                {
                    var exceptionType = (ITypeDefOrRef) firstDataSource.Operand;
                    argument = new ILExceptionExpression(exceptionType);
                }
                else
                {
                    // Get the variable containing the value of the argument and add it as an argument to the expression.
                    string variableName = GetOperandVariableName(instruction, i);
                    if (_sharedVariables.TryGetValue(variableName, out string realName))
                        variableName = realName;
                    
                    argument = new ILVariableExpression(
                        result.GetOrCreateVariable(variableName));
                }

                expression.Arguments.Add(argument);
            }

            return (ILExpression) expression;
        }

        private static IILArgumentsProvider BuildPushrExpression(ILInstruction instruction, ILCompilationUnit result)
        {
            // Since we treat registers as variables, we should interpret the operand as a variable and add it 
            // as an argument to the expression instead of keeping it just as an operand. This makes it easier
            // to apply analysis and transformations (such as variable inlining) later, in the same way we do
            // that with normal variables.

            IILArgumentsProvider expression = new ILInstructionExpression(instruction);

            ILVariable registerVar;
            if (instruction.Operand is VMRegisters.FL)
            {
                var dataSources = instruction.ProgramState.Registers[VMRegisters.FL].DataSources
                    .Select(i => i.Offset)
                    .ToArray();

                var flagsVariable = result.GetOrCreateFlagsVariable(dataSources);
                registerVar = flagsVariable;
            }
            else
            {
                registerVar = result.GetOrCreateVariable(instruction.Operand.ToString());
            }

            var varExpression = new ILVariableExpression(registerVar);
            expression.Arguments.Add(varExpression);
            
            return expression;
        }

        private void ApplyTransformations(ILCompilationUnit result, VMConstants constants)
        {
            var pipeline = new IILAstTransform[]
            {
                new StackFrameTransform(),
                new SsaTransform(),
                new TransformLoop("Expression Simplification", MaxSimplificationPasses, new IChangeAwareILAstTransform[]
                {
                    new VariableInliner(),
                    new PushMinimizer(), 
                    new LogicSimplifier(),
                    new FlagOperationSimplifier(constants), 
                }),
                new PhiRemovalTransform(),
            };

            foreach (var transform in pipeline)
            {
                if (transform is TransformLoop loop)
                {
                    loop.TransformStart += (sender, args) => OnTransformStart(args);
                    loop.TransformEnd += (sender, args) => OnTransformEnd(args);
                }
                
                Logger.Debug2(Tag, $"Applying {transform.Name}...");
                OnTransformStart(new ILTransformEventArgs(result, transform, 1));
                transform.ApplyTransformation(result, Logger);
                OnTransformEnd(new ILTransformEventArgs(result, transform, 1));
            }
        }

        protected virtual void OnInitialAstBuilt(ILCompilationUnit result)
        {
            InitialAstBuilt?.Invoke(this, result);
        }

        protected virtual void OnTransformStart(ILTransformEventArgs e)
        {
            TransformStart?.Invoke(this, e);
        }

        protected virtual void OnTransformEnd(ILTransformEventArgs e)
        {
            TransformEnd?.Invoke(this, e);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILAstBuilderException.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;

namespace OldRod.Core.Ast.IL
{
    public class ILAstBuilderException : Exception
    {
        public ILAstBuilderException(string message) 
            : base(message)
        {
        }

        public ILAstBuilderException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILAstNode.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using Rivers;

namespace OldRod.Core.Ast.IL
{
    public abstract class ILAstNode : IAstNode
    {
        public ILAstNode Parent
        {
            get;
            internal set;
        }

        IAstNode IAstNode.Parent
        {
            get => Parent;
            set => Parent = (ILAstNode) value;
        }

        public ILAstNode Remove()
        {
            ReplaceWith(null);
            return this;
        }

        public void ReplaceWith(ILAstNode node)
        {
            Parent.ReplaceNode(this, node);
        }
        
        public abstract void ReplaceNode(ILAstNode node, ILAstNode newNode);

        public Node GetParentNode()
        {
            var current = this;
            while (current.Parent != null) 
                current = current.Parent;

            if (current is ILAstBlock block)
                return block.CfgNode;
            throw new ArgumentException("Node is not added to a control flow graph.");
        }

        public IEnumerable<ILAstNode> GetAncestors()
        {
            var current = Parent;
            while (current != null)
            {
                yield return current;
                current = current.Parent;
            }
        }

        public ILAstNode GetCommonAncestor(ILAstNode other)
        {
            var ancestors = new HashSet<ILAstNode>(GetAncestors());
            return other.GetAncestors().FirstOrDefault(x => ancestors.Contains(x));
        }

        public abstract IEnumerable<ILAstNode> GetChildren();
        
        IEnumerable<IAstNode> IAstNode.GetChildren()
        {
            return GetChildren();
        }
        
        public abstract void AcceptVisitor(IILAstVisitor visitor);
        
        public abstract TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor);
        
        protected void AssertNodeParents(ILAstNode node, ILAstNode newNode)
        {
            if (node.Parent != this)
                throw new ArgumentException("Item is not a member of this node.");
            if (newNode?.Parent != null)
                throw new ArgumentException("Item is already a member of another node.");
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILCompilationUnit.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Memory;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.ControlFlow;
using Rivers;
using Rivers.Analysis;

namespace OldRod.Core.Ast.IL
{
    public class ILCompilationUnit : ILAstNode
    {
        private readonly IDictionary<string, ILVariable> _variables = new Dictionary<string, ILVariable>();

        public ILCompilationUnit(ControlFlowGraph controlFlowGraph, IFrameLayout frameLayout)
        {
            ControlFlowGraph = controlFlowGraph ?? throw new ArgumentNullException(nameof(controlFlowGraph));
            FrameLayout = frameLayout;
            DominatorInfo = new DominatorInfo(controlFlowGraph.Entrypoint);
            DominatorTree = DominatorInfo.ToDominatorTree();

            for (int i = 0; i < frameLayout.Parameters.Count; i++)
            {
                var parameter = new ILParameter("arg_" + i, i);
                Parameters.Add(parameter);
                _variables.Add(parameter.Name, parameter);
            }
        }

        public IList<ILParameter> Parameters
        {
            get;
        } = new List<ILParameter>();
        
        public ICollection<ILVariable> Variables => _variables.Values;
        
        public ControlFlowGraph ControlFlowGraph
        {
            get;
        }

        public IFrameLayout FrameLayout
        {
            get;
        }

        public DominatorInfo DominatorInfo
        {
            get;
        }

        public Graph DominatorTree
        {
            get;
        }

        public ILFlagsVariable GetOrCreateFlagsVariable(ICollection<int> dataOffsets)
        {
            string name = "FL_" + string.Join("_", dataOffsets
                              .OrderBy(o => o)
                              .Select(o => o.ToString("X4")));
            if (!_variables.TryGetValue(name, out var v))
            {
                v = new ILFlagsVariable(name, dataOffsets);
                _variables.Add(name, v);
            }

            return (ILFlagsVariable) v;
        }

        public ILVariable GetOrCreateVariable(FrameField field)
        {
            string name;
            switch (field.FieldKind)
            {
                case FrameFieldKind.Parameter:
                    name = "arg_" + field.Index;
                    break;
                case FrameFieldKind.ReturnAddress:
                    name = "return_address";
                    break;
                case FrameFieldKind.CallersBasePointer:
                    name = "caller_bp";
                    break;
                case FrameFieldKind.LocalVariable:
                    name = "local_" + field.Index;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            var variable = GetOrCreateVariable(name);
            variable.IsVirtual = false;
            return variable;
        }
        
        public ILVariable GetOrCreateVariable(string name)
        {
            if (!_variables.TryGetValue(name, out var variable))
                _variables.Add(name, variable = new ILVariable(name));
            return variable;
        }

        public bool RemoveNonUsedVariables()
        {
            bool changed = false;
            foreach (var entry in _variables.ToArray())
            {
                if (entry.Value.UsedBy.Count == 0)
                {
                    _variables.Remove(entry.Key);
                    changed = true;
                }
            }

            return changed;
        }

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            throw new NotSupportedException();
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return ControlFlowGraph.Nodes.Select(x => (ILAstBlock) x.UserData[ILAstBlock.AstBlockProperty]);
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitCompilationUnit(this);
        }
        
        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitCompilationUnit(this);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILExceptionExpression.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL
{
    public class ILExceptionExpression : ILExpression
    {
        public ILExceptionExpression(ITypeDefOrRef exceptionType) 
            : base(VMType.Object)
        {
            ExceptionType = exceptionType;
        }

        public override bool HasPotentialSideEffects => true;

        public ITypeDefOrRef ExceptionType
        {
            get;
        }

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            throw new NotSupportedException();
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return Enumerable.Empty<ILAstNode>();
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitExceptionExpression(this);
        }

        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitExceptionExpression(this);
        }

        public override string ToString()
        {
            return "PUSH_EXCEPTION";
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILExpression.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL
{
    public abstract class ILExpression : ILAstNode
    {
        private ILFlagsVariable _flagsVariable;

        protected ILExpression(VMType expressionType)
        {
            ExpressionType = expressionType;
        }
        
        public VMType ExpressionType
        {
            get;
            set;
        }

        public abstract bool HasPotentialSideEffects
        {
            get;
        }

        public ILFlagsVariable FlagsVariable
        {
            get => _flagsVariable;
            set
            {
                _flagsVariable?.ImplicitAssignments.Remove(this);
                _flagsVariable = value;
                _flagsVariable?.ImplicitAssignments.Add(this);
            }
        }

        public bool IsFlagDataSource => FlagsVariable != null;
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILExpressionStatement.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Ast.IL
{
    public class ILExpressionStatement : ILStatement
    {
        private ILExpression _expression;

        public ILExpressionStatement(ILExpression expression)
        {
            Expression = expression;
        }

        public ILExpression Expression
        {
            get => _expression;
            set
            {
                if (value?.Parent != null)
                    throw new ArgumentException("Item is already added to another node.");
                if (_expression != null)
                    _expression.Parent = null;
                _expression = value;
                if (value != null)
                    value.Parent = this;
            }
        }

        public override bool HasPotentialSideEffects => Expression.HasPotentialSideEffects;

        public override string ToString()
        {
            return Expression.ToString();
        }

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            Expression = (ILExpression) newNode;
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return new[] {Expression};
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitExpressionStatement(this);
        }
        
        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitExpressionStatement(this);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILFlagsVariable.cs
================================================
using System.Collections.Generic;
using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL
{
    public class ILFlagsVariable : ILVariable
    {
        public ILFlagsVariable(string name, IEnumerable<int> dataOffsets) 
            : base(name)
        {
            VariableType = VMType.Byte;
            DataSources.UnionWith(dataOffsets);
        }

        public ISet<int> DataSources
        {
            get;
        } = new HashSet<int>();

        public ICollection<ILExpression> ImplicitAssignments
        {
            get;
        } = new HashSet<ILExpression>();
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILInstructionExpression.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Ast.IL
{
    public class ILInstructionExpression : ILExpression, IILArgumentsProvider
    {
        public ILInstructionExpression(ILInstruction instruction)
            : this(instruction.Offset, instruction.OpCode, instruction.Operand, instruction.OpCode.StackBehaviourPush.GetResultType())
        {
            Annotation = instruction.Annotation;
        }

        public ILInstructionExpression(int originalOffset, ILOpCode opCode, object operand, VMType type)
            : base(type)
        {
            OriginalOffset = originalOffset;
            OpCode = opCode;
            Operand = operand;
            Arguments = new AstNodeCollection<ILExpression>(this);
        }

        public override bool HasPotentialSideEffects
        {
            get
            {
                if (IsFlagDataSource)
                    return true;
                
                switch (OpCode.Code)
                {
                    case ILCode.CALL:
                        return true;
                    
                    default:
                        return Arguments.Any(x => x.HasPotentialSideEffects);
                }
            }
        }
        
        public int OriginalOffset
        {
            get;
            set;
        }

        public ILOpCode OpCode
        {
            get;
            set;
        }

        public object Operand
        {
            get;
            set;
        }
        
        public IList<ILExpression> Arguments
        {
            get;
        }

        public Annotation Annotation
        {
            get;
            set;
        }

        public override string ToString()
        {
            if (Operand == null)
                return $"{OpCode}({string.Join(", ", Arguments)})";
            if (Arguments.Count == 0)
                return OpCode + "(" + Operand + ")";
            return $"{OpCode}({Operand} : {string.Join(", ", Arguments)})";
        }

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            int index = Arguments.IndexOf((ILExpression) node);
            
            if (newNode == null)
                Arguments.RemoveAt(index);
            else
                Arguments[index] = (ILExpression) newNode;
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return Arguments;
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitInstructionExpression(this);
        }
        
        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitInstructionExpression(this);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILParameter.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.IL
{
    public class ILParameter : ILVariable
    {
        public ILParameter(string name, int parameterIndex) 
            : base(name)
        {
            ParameterIndex = parameterIndex;
            IsVirtual = false;
        }

        public int ParameterIndex
        {
            get;
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILPhiExpression.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL
{
    public class ILPhiExpression : ILExpression
    {
        public ILPhiExpression(params ILVariableExpression[] variables)
            : this(variables.AsEnumerable())
        {
        }

        public ILPhiExpression(IEnumerable<ILVariableExpression> variables)
            : base(VMType.Object)
        {
            Variables = new AstNodeCollection<ILVariableExpression>(this);
            foreach (var variable in variables)
                Variables.Add(variable);
            ExpressionType = Variables[0].ExpressionType;
        }
        
        public override bool HasPotentialSideEffects => false;
        
        public IList<ILVariableExpression> Variables
        {
            get;
        }

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            int index = Variables.IndexOf((ILVariableExpression) node);
            
            if (newNode == null)
                Variables.RemoveAt(index);
            else
                Variables[index] = (ILVariableExpression) newNode;
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return Variables;
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitPhiExpression(this);
        }

        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitPhiExpression(this);
        }

        public override string ToString()
        {
            return $"Ï†({string.Join(", ", Variables)})";
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILStatement.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.IL
{
    public abstract class ILStatement : ILAstNode
    {
        public abstract bool HasPotentialSideEffects
        {
            get;
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILVCallExpression.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Ast.IL
{
    public class ILVCallExpression : ILExpression, IILArgumentsProvider
    {
        public ILVCallExpression(VCallAnnotation annotation)
            : base(annotation.ReturnType)
        {
            Annotation = annotation;
            Arguments = new AstNodeCollection<ILExpression>(this);
        }

        public override bool HasPotentialSideEffects
        {
            get
            {
                switch (Call)
                {
                    case VMCalls.BOX:
                        var boxAnnotation = (BoxAnnotation) Annotation;
                        if (boxAnnotation.Type.IsTypeOf("System", "String") && !boxAnnotation.IsUnknownValue)
                            return false;
                        return Arguments.Any(x => x.HasPotentialSideEffects);
                    
                    case VMCalls.UNBOX:
                    case VMCalls.CAST:
                    case VMCalls.SIZEOF:
                    case VMCalls.TOKEN:
                    case VMCalls.LDFLD:
                    case VMCalls.LDFTN:
                        return Arguments.Any(x => x.HasPotentialSideEffects);
                    
                    default:
                        return true;
                }
            }
        }

        public VMCalls Call => Annotation.VMCall;
        
        public VCallAnnotation Annotation
        {
            get;
            set;
        }

        public IList<ILExpression> Arguments
        {
            get;
        }

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            AssertNodeParents(node, newNode);
            int index = Arguments.IndexOf((ILExpression) node);
            
            if (newNode == null)
                Arguments.RemoveAt(index);
            else
                Arguments[index] = (ILExpression) newNode;
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return Arguments;
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitVCallExpression(this);
        }

        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitVCallExpression(this);
        }

        public override string ToString()
        {
            return Arguments.Count == 0
                ? $"{Call}({Annotation})"
                : $"{Call}({Annotation} : {string.Join(", ", Arguments)})";
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILVariable.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL
{
    public class ILVariable
    {
        public ILVariable(string name)
        {
            Name = name;
        }
        
        public string Name
        {
            get;
        }

        public VMType VariableType
        {
            get;
            set;
        }

        public bool IsVirtual
        {
            get;
            set;
        } = true;

        public IList<ILAssignmentStatement> AssignedBy
        {
            get;
        } = new List<ILAssignmentStatement>();

        public IList<ILVariableExpression> UsedBy
        {
            get;
        } = new List<ILVariableExpression>();

        public override string ToString()
        {
            return Name;
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/ILVariableExpression.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Ast.IL
{
    public class ILVariableExpression : ILExpression
    {
        private ILVariable _variable;

        public ILVariableExpression(ILVariable variable) 
            : base(variable.VariableType)
        {
            Variable = variable;
            ExpressionType = variable.VariableType;
        }

        public ILVariable Variable
        {
            get => _variable;
            set
            {
                _variable?.UsedBy.Remove(this);
                _variable = value;
                value?.UsedBy.Add(this);
            }
        }

        public override bool HasPotentialSideEffects => false;

        public bool IsReference
        {
            get;
            set;
        }

        public override string ToString()
        {
            return (IsReference ? "&" : "") + Variable.Name;
        }

        public override void ReplaceNode(ILAstNode node, ILAstNode newNode)
        {
            throw new InvalidOperationException();
        }

        public override IEnumerable<ILAstNode> GetChildren()
        {
            return Enumerable.Empty<ILAstNode>();
        }

        public override void AcceptVisitor(IILAstVisitor visitor)
        {
            visitor.VisitVariableExpression(this);
        }
        
        public override TResult AcceptVisitor<TResult>(IILAstVisitor<TResult> visitor)
        {
            return visitor.VisitVariableExpression(this);
        }

    }
}


================================================
File: src/OldRod.Core/Ast/IL/VariableUsageCollector.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Ast.IL
{
    public class VariableUsageCollector : IILAstVisitor<IEnumerable<ILVariableExpression>>
    {
        public static readonly VariableUsageCollector Instance = new VariableUsageCollector();
        
        public IEnumerable<ILVariableExpression> VisitCompilationUnit(ILCompilationUnit unit)
        {
            var result = new List<ILVariableExpression>();

            foreach (var node in unit.ControlFlowGraph.Nodes)
            {
                var block = (ILAstBlock) node.UserData[ILAstBlock.AstBlockProperty];
                result.AddRange(block.AcceptVisitor(this));
            }

            return result;
        }

        public IEnumerable<ILVariableExpression> VisitBlock(ILAstBlock block)
        {
            var result = new List<ILVariableExpression>();
            foreach (var statement in block.Statements)
                result.AddRange(statement.AcceptVisitor(this));
            return result;
        }

        public IEnumerable<ILVariableExpression> VisitExpressionStatement(ILExpressionStatement statement)
        {
            return statement.Expression.AcceptVisitor(this);
        }

        public IEnumerable<ILVariableExpression> VisitAssignmentStatement(ILAssignmentStatement statement)
        {
            return statement.Value.AcceptVisitor(this);
        }

        public IEnumerable<ILVariableExpression> VisitInstructionExpression(ILInstructionExpression expression)
        {
            var result = new List<ILVariableExpression>();
            foreach (var argument in expression.Arguments)
                result.AddRange(argument.AcceptVisitor(this));
            return result;
        }

        public IEnumerable<ILVariableExpression> VisitVariableExpression(ILVariableExpression expression)
        {
            return new[] {expression};
        }

        public IEnumerable<ILVariableExpression> VisitVCallExpression(ILVCallExpression expression)
        {
            var result = new List<ILVariableExpression>();
            foreach (var argument in expression.Arguments)
                result.AddRange(argument.AcceptVisitor(this));
            return result;
        }

        public IEnumerable<ILVariableExpression> VisitPhiExpression(ILPhiExpression expression)
        {
            return expression.Variables;
        }

        public IEnumerable<ILVariableExpression> VisitExceptionExpression(ILExceptionExpression expression)
        {
            return Enumerable.Empty<ILVariableExpression>();
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILAssignmentPattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.IL.Pattern
{
    public class ILAssignmentPattern : ILStatementPattern
    {
        public ILAssignmentPattern(ILVariablePattern variable, ILExpressionPattern value)
        {
            Variable = variable;
            Value = value;
        }
        
        public ILVariablePattern Variable
        {
            get;
        }

        public ILExpressionPattern Value
        {
            get;
        }
        
        public override MatchResult Match(ILAstNode node)
        {
            var result = new MatchResult(false);

            if (node is ILAssignmentStatement statement)
            {
                result.Success = Variable.VariableName == null || Variable.VariableName == statement.Variable.Name;
                if (result.Success) 
                    result.CombineWith(Value.Match(statement.Value));
            }

            AddCaptureIfNecessary(result, node);
            return result;
        }

        public override string ToString()
        {
            return $"{Variable} = {Value}";
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILAstPattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL.Pattern
{
    public abstract class ILAstPattern
    {
        public bool Captured
        {
            get;
            protected set;
        }

        public string CaptureName
        {
            get;
            protected set;
        }

        public abstract MatchResult Match(ILAstNode node);

        public virtual ILAstPattern Capture(string name)
        {
            Captured = true;
            CaptureName = name;
            return this;
        }

        protected void AddCaptureIfNecessary(MatchResult result, ILAstNode node)
        {
            if (result.Success && Captured)
                result.AddCapture(CaptureName, node);
        }

        public static ILSequencePattern<T> Sequence<T>(params ILAstPattern[] sequence) 
            where T : ILAstNode
        {
            return new ILSequencePattern<T>(sequence);
        }

        public static ILAssignmentPattern Assignment(VMRegisters variable, ILExpressionPattern value)
        {
            return new ILAssignmentPattern(variable, value);
        }

        public static ILExpressionStatementPattern Expression(ILExpressionPattern pattern)
        {
            return new ILExpressionStatementPattern(pattern);
        }
        
        public static ILAssignmentPattern Assignment(ILVariablePattern variable, ILExpressionPattern value)
        {
            return new ILAssignmentPattern(variable, value);
        }

        public static ILInstructionPattern Instruction(params ILCode[] opCodes)
        {
            return new ILInstructionPattern(new ILOpCodePattern(opCodes));
        }

        public static ILInstructionPattern PushDwordReg(VMRegisters register)
        {
            return Instruction(ILCode.PUSHR_DWORD)
                .WithOperand(register)
                .WithArguments(new ILVariablePattern(register));
        }

        public static ILInstructionPattern PushAnyObjectReg()
        {
            return Instruction(ILCode.PUSHR_OBJECT)
                .WithAnyOperand()
                .WithArguments(ILVariablePattern.Any);
        }

        public static ILInstructionPattern PushAnyDword()
        {
            return Instruction(ILCode.PUSHI_DWORD)
                .WithAnyOperand();
        }

    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILExpressionPattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.IL.Pattern
{
    public abstract class ILExpressionPattern : ILAstPattern
    {
        public static readonly ILExpressionPattern Any = new ILExpressionAnyPattern();
        
        private sealed class ILExpressionAnyPattern : ILExpressionPattern
        {
            public override MatchResult Match(ILAstNode node)
            {
                var result = new MatchResult(node is ILExpression);
                AddCaptureIfNecessary(result, node);
                return result;
            }

            public override ILAstPattern Capture(string name)
            {
                return new ILExpressionAnyPattern
                {
                    Captured = true,
                    CaptureName = name
                };
            }

            public override string ToString()
            {
                return "?";
            }
        }

        public ILExpressionPattern CaptureExpr(string name)
        {
            return (ILExpressionPattern) Capture(name);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILExpressionStatementPattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.IL.Pattern
{
    public class ILExpressionStatementPattern : ILStatementPattern
    {
        public static implicit operator ILExpressionStatementPattern(ILExpressionPattern expressionPattern)
        {
            return new ILExpressionStatementPattern(expressionPattern);
        }
        
        public ILExpressionStatementPattern(ILExpressionPattern expression)
        {
            Expression = expression;
        }
        
        public ILExpressionPattern Expression
        {
            get;
        }

        public override MatchResult Match(ILAstNode node)
        {
            var result = new MatchResult(false);
            if (node is ILExpressionStatement statement)
            {
                result.Success = true;
                result.CombineWith(Expression.Match(statement.Expression));
            }

            AddCaptureIfNecessary(result, node);
            return result;
        }

        public override string ToString()
        {
            return Expression.ToString();
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILInstructionPattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL.Pattern
{
    public class ILInstructionPattern : ILExpressionPattern
    {
        public ILInstructionPattern(ILOpCodePattern opCode)
        {
            OpCode = opCode ?? throw new ArgumentNullException(nameof(opCode));
            Operand = ILOperandPattern.Null;
            Arguments = new List<ILExpressionPattern>();
        }

        public ILInstructionPattern(ILOpCodePattern opCode, ILOperandPattern operand,
            params ILExpressionPattern[] arguments)
        {
            OpCode = opCode ?? throw new ArgumentNullException(nameof(opCode));
            Operand = operand;
            Arguments = new List<ILExpressionPattern>(arguments);
        }

        public ILOpCodePattern OpCode
        {
            get;
            set;
        }

        public ILOperandPattern Operand
        {
            get;
            set;
        }

        public IList<ILExpressionPattern> Arguments
        {
            get;
        }

        public override MatchResult Match(ILAstNode node)
        {
            var result = new MatchResult(false);

            if (node is ILInstructionExpression expression)
            {
                result.Success = OpCode.Match(expression.OpCode.Code)
                                 && Operand.Match(expression.Operand)
                                 && expression.Arguments.Count == Arguments.Count;

                for (int i = 0; result.Success && i < expression.Arguments.Count; i++)
                {
                    var argumentMatch = Arguments[i].Match(expression.Arguments[i]);
                    result.CombineWith(argumentMatch);
                }
            }

            AddCaptureIfNecessary(result, node);
            return result;
        }

        public new ILInstructionPattern Capture(string name)
        {
            return (ILInstructionPattern) base.Capture(name);
        }

        public ILInstructionPattern WithOpCode(params ILCode[] opCodes)
        {
            OpCode = new ILOpCodePattern(opCodes);
            return this;
        }

        public ILInstructionPattern WithOpCode(ILOpCodePattern opCode)
        {
            OpCode = opCode;
            return this;
        }

        public ILInstructionPattern WithOperand(ILOperandPattern operand)
        {
            Operand = operand;
            return this;
        }

        public ILInstructionPattern WithAnyOperand()
        {
            Operand = ILOperandPattern.Any;
            return this;
        }

        public ILInstructionPattern WithOperand(params object[] operands)
        {
            Operand = new ILOperandPattern(operands);
            return this;
        }

        public ILInstructionPattern WithArguments(params ILExpressionPattern[] arguments)
        {
            Arguments.Clear();
            foreach (var arg in arguments)
                Arguments.Add(arg);
            return this;
        }

        public override string ToString()
        {
            if (Operand is { Operands.Count: 0 })
                return $"{OpCode}({string.Join(", ", Arguments)})";
            if (Arguments.Count == 0)
                return OpCode + "(" + Operand + ")";
            return $"{OpCode}({Operand} : {string.Join(", ", Arguments)})";
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILOpCodePattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL.Pattern
{
    public class ILOpCodePattern
    {
        public static implicit operator ILOpCodePattern(ILCode code)
        {
            return new ILOpCodePattern(code);
        } 
        
        public static readonly ILOpCodePattern Any = new ILOpCodeAnyPattern();
        
        private sealed class ILOpCodeAnyPattern : ILOpCodePattern
        {
            public override bool Match(ILCode code)
            {
                return true;
            }

            public override string ToString()
            {
                return "?";
            }
        }
        
        public ILOpCodePattern(params ILCode[] opCode)
        {
            OpCodes = new HashSet<ILCode>(opCode);
        }
        
        public ISet<ILCode> OpCodes
        {
            get;
        }
        
        public virtual bool Match(ILCode code)
        {
            return OpCodes.Contains(code);
        }

        public override string ToString()
        {
            return OpCodes.Count == 1 
                ? OpCodes.First().ToString() 
                : $"({string.Join("|", OpCodes)})";
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILOperandPattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Ast.IL.Pattern
{
    public class ILOperandPattern
    {
        public static readonly ILOperandPattern Any = new ILOperandAnyPattern();
        
        public static readonly ILOperandPattern Null = new ILOperandPattern(default(object));
        
        private sealed class ILOperandAnyPattern : ILOperandPattern
        {
            public ILOperandAnyPattern() 
                : base(default(object))
            {
            }
            
            public override bool Match(object operand)
            {
                return true;
            }

            public override string ToString()
            {
                return "?";
            }
        }
        
        public ILOperandPattern(object operand)
        {
            Operands = new List<object> { operand };
        }
        
        public ILOperandPattern(params object[] operands)
        {
            Operands = new List<object>(operands);
        }
        
        public ILOperandPattern(IEnumerable<object> operands)
        {
            Operands = new List<object>(operands);
        }

        public IList<object> Operands
        {
            get;
        }

        public virtual bool Match(object operand)
        {
            return Operands.Contains(operand);
        }

        public override string ToString()
        {
            return $"{{{string.Join(", ", Operands.Select(o => o is null ? "null" : o.ToString()))}}}";
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILSequencePattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;

namespace OldRod.Core.Ast.IL.Pattern
{
    public class ILSequencePattern<TNode> 
        where TNode : ILAstNode
    {
        public ILSequencePattern(params ILAstPattern[] patterns)
        {
            Sequence = new List<ILAstPattern>(patterns);
        }
        
        public IList<ILAstPattern> Sequence
        {
            get;
        }
        
        public MatchResult Match(IList<TNode> nodes, int start = 0)
        {
            var result = new MatchResult(start < nodes.Count 
                && start + Sequence.Count < nodes.Count);

            for (int i = 0; result.Success && i < Sequence.Count; i++)
                result.CombineWith(Sequence[i].Match(nodes[i + start]));

            return result;
        }

        public MatchResult FindMatch(IList<TNode> nodes)
        {
            for (int i = 0; i < nodes.Count - Sequence.Count; i++)
            {
                var result = Match(nodes, i);
                if (result.Success)
                    return result;
            }
            
            return new MatchResult(false);
        }

        public override string ToString()
        {
            return string.Join(" -> ", Sequence);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILStatementPattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Ast.IL.Pattern
{
    public abstract class ILStatementPattern : ILAstPattern
    {
        public static readonly ILStatementPattern Any = new ILStatementAnyPattern();
        
        private sealed class ILStatementAnyPattern : ILStatementPattern
        {
            public override MatchResult Match(ILAstNode node)
            {
                var result = new MatchResult(node is ILStatement);
                AddCaptureIfNecessary(result, node);
                return result;
            }

            public override ILAstPattern Capture(string name)
            {
                return new ILStatementAnyPattern
                {
                    Captured = true,
                    CaptureName = name
                };
            }

            public override string ToString()
            {
                return "?";
            }
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/ILVariablePattern.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Architecture;

namespace OldRod.Core.Ast.IL.Pattern
{
    public class ILVariablePattern : ILExpressionPattern
    {
        public static implicit operator ILVariablePattern(string variableName)
        {
            return new ILVariablePattern(variableName);
        }
        
        public static implicit operator ILVariablePattern(VMRegisters register)
        {
            return new ILVariablePattern(register);
        }
        
        public new static readonly ILVariablePattern Any = new ILVariableAnyPattern();
        
        private sealed class ILVariableAnyPattern : ILVariablePattern
        {
            public ILVariableAnyPattern() 
                : base(null)
            {
            }

            public override MatchResult Match(ILAstNode node)
            {
                var result = new MatchResult(node is ILVariableExpression);
                AddCaptureIfNecessary(result, node);
                return result;
            }

            public override ILAstPattern Capture(string name)
            {
                var result = new ILVariableAnyPattern
                {
                    Captured = true,
                    CaptureName = name
                };
                return result;
            }

            public override string ToString()
            {
                return "?";
            }
        }

        public static readonly ILVariablePattern FL = new ILFLPattern();

        private sealed class ILFLPattern : ILVariablePattern
        {
            public ILFLPattern()
                : base(VMRegisters.FL)
            {
            }
            
            public override MatchResult Match(ILAstNode node)
            {
                var result = new MatchResult(node is ILVariableExpression expression
                                             && expression.Variable is ILFlagsVariable);
                AddCaptureIfNecessary(result, node);
                return result;
            }
        }
        
        public ILVariablePattern(string variableName)
        {
            VariableName = variableName;
        }
        
        public ILVariablePattern(VMRegisters register)
        {
            VariableName = register.ToString();
        }

        public string VariableName
        {
            get;
        }
        
        public override MatchResult Match(ILAstNode node)
        {
            var result = new MatchResult(node is ILVariableExpression expression
                                         && expression.Variable.Name == VariableName);
            AddCaptureIfNecessary(result, node);
            return result;
        }

        public ILVariablePattern CaptureVar(string name)
        {
            return (ILVariablePattern) Capture(name);
        }

        public override string ToString()
        {
            return VariableName;
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Pattern/MatchResult.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;

namespace OldRod.Core.Ast.IL.Pattern
{
    public class MatchResult
    {
        public MatchResult()
            : this(true)
        {
        }
        
        public MatchResult(bool success)
        {
            Success = success;
        }

        public bool Success
        {
            get;
            set;
        }

        public IDictionary<string, IList<ILAstNode>> Captures
        {
            get;
        } = new Dictionary<string, IList<ILAstNode>>();

        public void AddCapture(string name, ILAstNode node)
        {
            if (!Captures.TryGetValue(name, out var captures))
                Captures.Add(name, captures = new List<ILAstNode>());

            captures.Add(node);
        }
        
        public void CombineWith(MatchResult result)
        {
            if (!result.Success)
                Success = false;

            foreach (var entry in result.Captures)
            {
                if (!Captures.TryGetValue(entry.Key, out var captures))
                    Captures.Add(entry.Key, captures = new List<ILAstNode>());

                foreach (var capture in entry.Value)
                    captures.Add(capture);
            }
        }

        public override string ToString()
        {
            return $"{nameof(Success)}: {Success}";
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/FlagDataSourceMarker.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Ast.IL.Transform
{
    public class FlagDataSourceMarker : IILAstVisitor
    {
        private readonly IDictionary<int, ILFlagsVariable> _offsets = new Dictionary<int, ILFlagsVariable>();
        
        public void VisitCompilationUnit(ILCompilationUnit unit)
        {
            _offsets.Clear();
            foreach (var variable in unit.Variables.OfType<ILFlagsVariable>())
            {
                foreach (int dataSource in variable.DataSources)
                    _offsets.Add(dataSource, variable);
            }
            
            foreach (var node in unit.ControlFlowGraph.Nodes)
            {
                var block = (ILAstBlock) node.UserData[ILAstBlock.AstBlockProperty];
                block.AcceptVisitor(this);
            }
        }

        public void VisitBlock(ILAstBlock block)
        {
            foreach (var statement in block.Statements)
                statement.AcceptVisitor(this);
        }

        public void VisitExpressionStatement(ILExpressionStatement statement)
        {
            statement.Expression.AcceptVisitor(this);
        }

        public void VisitAssignmentStatement(ILAssignmentStatement statement)
        {
            statement.Value.AcceptVisitor(this);
        }

        public void VisitInstructionExpression(ILInstructionExpression expression)
        {
            foreach (var argument in expression.Arguments)
                argument.AcceptVisitor(this);
            
            if (_offsets.TryGetValue(expression.OriginalOffset, out var variable))
            {
                expression.FlagsVariable = variable;
                variable.ImplicitAssignments.Add(expression);
            }
        }

        public void VisitVariableExpression(ILVariableExpression expression)
        {
        }

        public void VisitVCallExpression(ILVCallExpression expression)
        {
            foreach (var argument in expression.Arguments)
                argument.AcceptVisitor(this);
        }

        public void VisitPhiExpression(ILPhiExpression expression)
        {
        }

        public void VisitExceptionExpression(ILExceptionExpression expression)
        {
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/FlagOperationSimplifier.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.IL.Pattern;

namespace OldRod.Core.Ast.IL.Transform
{
    public class FlagOperationSimplifier : ChangeAwareILAstTransform
    {
        private static readonly ILInstructionPattern FLAndConstantPattern = ILAstPattern
            .Instruction(ILCode.__AND_DWORD)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.PUSHR_DWORD)
                    .WithAnyOperand()
                    .WithArguments(ILVariablePattern.FL.CaptureVar("fl")),
                ILAstPattern.Instruction(ILCode.PUSHI_DWORD)
                    .WithAnyOperand()
                    .Capture("constant")
            );

        private static readonly ILInstructionPattern ComparePattern = ILAstPattern
            .Instruction(ILCode.CMP,
                ILCode.CMP_R32, ILCode.CMP_R64,
                ILCode.CMP_DWORD, 
                ILCode.CMP_QWORD)
            .WithArguments(
                ILExpressionPattern.Any.CaptureExpr("left"),
                ILExpressionPattern.Any.CaptureExpr("right"));

        private static readonly ILInstructionPattern AndRegistersPattern = ILAstPattern
            .Instruction(ILCode.__AND_DWORD)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.PUSHR_DWORD)
                    .WithAnyOperand()
                    .WithArguments(ILVariablePattern.Any.CaptureVar("left")),
                ILAstPattern.Instruction(ILCode.PUSHR_DWORD)
                    .WithAnyOperand()
                    .WithArguments(ILVariablePattern.Any.CaptureVar("right"))
            );

        private static readonly ILInstructionPattern BigRelationalPattern = ILAstPattern
            .Instruction(ILCode.__NOT_DWORD)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.NOR_DWORD)
                    .WithArguments(
                        ILAstPattern.Instruction(ILCode.__EQUALS_DWORD)
                            .WithArguments(
                                ILAstPattern.Instruction(ILCode.PUSHR_DWORD)
                                    .WithAnyOperand()
                                    .WithArguments(ILVariablePattern.Any.CaptureVar("var")),
                                ILAstPattern.Instruction(ILCode.PUSHI_DWORD)
                                    .WithAnyOperand()
                                    .Capture("constant1")
                            ),
                        ILAstPattern.Instruction(ILCode.__AND_DWORD)
                            .WithArguments(
                                ILAstPattern.Instruction(ILCode.PUSHR_DWORD)
                                    .WithAnyOperand()
                                    .WithArguments(ILVariablePattern.FL.CaptureVar("fl")),
                                ILAstPattern.Instruction(ILCode.PUSHI_DWORD)
                                    .WithAnyOperand()
                                    .Capture("constant2")
                            )
                    )
            );
            
        private readonly VMConstants _constants;

        public FlagOperationSimplifier(VMConstants constants)
        {
            _constants = constants;
        }

        public override string Name => "Flag Operation Simplifier";

        public override bool VisitCompilationUnit(ILCompilationUnit unit)
        {
            bool changed = false;
            bool continueLoop = true;

            while (continueLoop)
            {
                continueLoop = false;
                
                foreach (var variable in unit.Variables.OfType<ILFlagsVariable>())
                {
                    if (variable.UsedBy.Count == 1)
                    {
                        var use = variable.UsedBy[0];

                        var andExpression = use.Parent.Parent;
                        var andMatch = FLAndConstantPattern.Match(andExpression);
                        if (andMatch.Success)
                        {
                            var fl = (ILFlagsVariable) ((ILVariableExpression) andMatch.Captures["fl"][0]).Variable;
                            var constant = (ILInstructionExpression) andMatch.Captures["constant"][0];
                            var flags = _constants.ToFlags((byte) (uint) constant.Operand);

                            continueLoop = TryOptimizeFlagComparison(unit, use, fl, flags);
                            if (continueLoop)
                            {
                                changed = true;
                                break;
                            }
                        }
                    }

                }
            }

            return changed;
        }

        private bool TryOptimizeFlagComparison(ILCompilationUnit unit, ILVariableExpression flagUsage, ILFlagsVariable fl, VMFlags flags)
        {
            // TODO: support other flag combinations.
            bool changed = false;
            
            switch (flags)
            {
                case VMFlags.ZERO:
                    changed |= TryOptimizeCompareWithZero(unit, fl, flagUsage);
                    break;
            }

            return changed;
        }

        private bool TryOptimizeCompareWithZero(ILCompilationUnit unit, ILFlagsVariable fl, ILVariableExpression flUsage)
        {
            if (fl.ImplicitAssignments.Count != 1)
                return false;

            var flAssignment = fl.ImplicitAssignments.First();
            
            MatchResult match;
            if ((match = ComparePattern.Match(flAssignment)).Success) // (cmp(a, b); equals(FL, 0)) <=> (a == b)
                return TryOptimizeToEquals(unit, fl, flUsage, flAssignment, match);
            if ((match = BigRelationalPattern.Match(flAssignment)).Success)
                return TryOptimizeToLessThan(unit, fl, flUsage, flAssignment, match);
            if ((match = AndRegistersPattern.Match(flAssignment)).Success)
                return TryOptimizeToGreaterThan(unit, fl, flUsage, flAssignment, match);

            return false;
        }

        private bool TryOptimizeToEquals(
            ILCompilationUnit unit,  
            ILFlagsVariable fl, 
            ILVariableExpression flUsage,
            ILExpression flAssignment,
            MatchResult match)
        {
            // Replace FL operation with the new comparison operation.
            ILOpCode opcode;
            switch (((ILInstructionExpression) flAssignment).OpCode.Code)
            {
                case ILCode.CMP:
                    opcode = ILOpCodes.__EQUALS_OBJECT;
                    break;
                case ILCode.CMP_R32:
                    opcode = ILOpCodes.__EQUALS_R32;
                    break;
                case ILCode.CMP_R64:
                    opcode = ILOpCodes.__EQUALS_R64;
                    break;
                case ILCode.CMP_DWORD:
                    opcode = ILOpCodes.__EQUALS_DWORD;
                    break;
                case ILCode.CMP_QWORD:
                    opcode = ILOpCodes.__EQUALS_QWORD;
                    break;
                default:
                    return false;
            }

            // Introduce new variable for storing the result of the comparison.
            var resultVar = unit.GetOrCreateVariable($"simplified_{fl.Name}");
            resultVar.VariableType = VMType.Dword;
            
            var assignment = new ILAssignmentStatement(resultVar,
                new ILInstructionExpression(-1, opcode, null, VMType.Dword)
                {
                    Arguments =
                    {
                        (ILExpression) match.Captures["left"][0].Remove(),
                        (ILExpression) match.Captures["right"][0].Remove()
                    }
                });

            fl.ImplicitAssignments.Remove(flAssignment);
            flAssignment.Parent.ReplaceWith(assignment);

            // Replace FL reference with new variable.
            flUsage.Variable = null;
            flUsage.Parent.Parent.ReplaceWith(new ILVariableExpression(resultVar));

            return true;
        }

        private bool TryOptimizeToLessThan(
            ILCompilationUnit unit,
            ILFlagsVariable finalFl,
            ILVariableExpression finalFlUsage,
            ILExpression finalFlAssignment,
            MatchResult relationalMatch)
        {
            if (!ValidateRelationalMatch(relationalMatch, out var variable))
                return false;

            var fl = (ILVariableExpression) relationalMatch.Captures["fl"][0];
            var flAssignment = ((ILFlagsVariable) fl.Variable).ImplicitAssignments.First();
            var andMatch = AndRegistersPattern.Match(flAssignment);
            if (!andMatch.Success)
                return false;

            if (!ValidateRemainingRelationalNodes(andMatch, variable, VMFlags.OVERFLOW | VMFlags.SIGN,
                out var varAssignment, out var flAssignment2, out var cmpMatch))
            {
                return false;
            }

            // We have a match! Decide which opcode to use based on the original comparison that was made.
            ILOpCode opcode;
            switch (((ILInstructionExpression) flAssignment2).OpCode.Code)
            {
                case ILCode.CMP_R32:
                    opcode = ILOpCodes.__LT_R32;
                    break;
                case ILCode.CMP_R64:
                    opcode = ILOpCodes.__LT_R64;
                    break;
                case ILCode.CMP_DWORD:
                    opcode = ILOpCodes.__LT_DWORD;
                    break;
                case ILCode.CMP_QWORD:
                    opcode = ILOpCodes.__LT_QWORD;
                    break;
                default:
                    return false;
            }

            // Introduce new variable for storing the result of the comparison.
            var resultVar = unit.GetOrCreateVariable("simplified_" + finalFl.Name);
            resultVar.VariableType = VMType.Dword;

            var newAssignment = new ILAssignmentStatement(resultVar,
                new ILInstructionExpression(-1, opcode, null, VMType.Dword)
                {
                    Arguments =
                    {
                        (ILExpression) cmpMatch.Captures["left"][0].Remove(),
                        (ILExpression) cmpMatch.Captures["right"][0].Remove()
                    }
                });

            // Remove var0 assignment.
            varAssignment.Variable = null;
            varAssignment.Remove();

            // Remove comparison.
            flAssignment2.FlagsVariable = null;
            flAssignment2.Parent.Remove();

            // Clear references to variables.
            var referencesToRemove = new List<ILVariableExpression>();
            referencesToRemove.AddRange(finalFlAssignment.AcceptVisitor(VariableUsageCollector.Instance));
            referencesToRemove.AddRange(flAssignment.AcceptVisitor(VariableUsageCollector.Instance));
            referencesToRemove.AddRange(varAssignment.AcceptVisitor(VariableUsageCollector.Instance));
            referencesToRemove.AddRange(flAssignment2.AcceptVisitor(VariableUsageCollector.Instance));

            foreach (var reference in referencesToRemove)
                reference.Variable = null;

            flAssignment.FlagsVariable = null;
            flAssignment.Parent.Remove();

            // Replace assignment and use of FL with new variable.
            finalFlAssignment.FlagsVariable = null;
            finalFlAssignment.Parent.ReplaceWith(newAssignment);
            finalFlUsage.Variable = null;
            finalFlUsage.Parent.Parent.ReplaceWith(new ILVariableExpression(resultVar));
            
            return true;
        }

        private bool TryOptimizeToGreaterThan(
            ILCompilationUnit unit,  
            ILFlagsVariable fl,
            ILVariableExpression flUsage,
            ILExpression flAssignment, 
            MatchResult match)
        {
            var root = flUsage.Parent?.Parent?.Parent?.Parent;
            var relationalMatch = BigRelationalPattern.Match(root);
            if (!relationalMatch.Success || !ValidateRelationalMatch(relationalMatch, out var variable))
                return false;

            if (!ValidateRemainingRelationalNodes(match, variable, VMFlags.OVERFLOW | VMFlags.SIGN | VMFlags.ZERO,
                out var varAssignment, out var flAssignment2, out var cmpMatch))
            {
                return false;
            }

            // We have a match! Decide which opcode to use based on the original comparison that was made.
            ILOpCode opcode;
            switch (((ILInstructionExpression) flAssignment2).OpCode.Code)
            {
                case ILCode.CMP_R32:
                    opcode = ILOpCodes.__GT_R64;
                    break;
                case ILCode.CMP_R64:
                    opcode = ILOpCodes.__GT_R64;
                    break;
                case ILCode.CMP_DWORD:
                    opcode = ILOpCodes.__GT_DWORD;
                    break;
                case ILCode.CMP_QWORD:
                    opcode = ILOpCodes.__GT_QWORD;
                    break;
                default:
                    return false;
            }

            // Introduce new variable for storing the result of the comparison.
            var resultVar = unit.GetOrCreateVariable("simplified_" + fl.Name);
            resultVar.VariableType = VMType.Dword;

            var newAssignment = new ILAssignmentStatement(resultVar,
                new ILInstructionExpression(-1, opcode, null, VMType.Dword)
                {
                    Arguments =
                    {
                        (ILExpression) cmpMatch.Captures["left"][0].Remove(),
                        (ILExpression) cmpMatch.Captures["right"][0].Remove()
                    }
                });

            // Remove var0 assignment.
            varAssignment.Variable = null;
            varAssignment.Remove();

            // Remove comparison.
            flAssignment2.Parent.Remove();

            // Clear references to variables.
            var referencesToRemove = new List<ILVariableExpression>();
            referencesToRemove.AddRange(root.AcceptVisitor(VariableUsageCollector.Instance));
            referencesToRemove.AddRange(flAssignment.AcceptVisitor(VariableUsageCollector.Instance));
            referencesToRemove.AddRange(varAssignment.AcceptVisitor(VariableUsageCollector.Instance));
            referencesToRemove.AddRange(flAssignment2.AcceptVisitor(VariableUsageCollector.Instance));

            foreach (var reference in referencesToRemove)
            {
                reference.Variable = null;
                reference.Remove();
            }

            // Replace assignment and use of FL with new variable.
            flAssignment.FlagsVariable = null;
            flAssignment.Parent.ReplaceWith(newAssignment);
            root.ReplaceWith(new ILVariableExpression(resultVar));
            
            return true;
        }

        private bool ValidateRelationalMatch(MatchResult relationalMatch, out ILVariableExpression variable)
        {
            var constant1 = (ILInstructionExpression) relationalMatch.Captures["constant1"][0];
            var constant2 = (ILInstructionExpression) relationalMatch.Captures["constant2"][0];
            variable = (ILVariableExpression) relationalMatch.Captures["var"][0];

            return (byte) (uint) constant1.Operand == _constants.GetFlagMask(VMFlags.OVERFLOW | VMFlags.SIGN)
                   && (byte) (uint) constant2.Operand == _constants.GetFlagMask(VMFlags.ZERO);
        }

        private bool ValidateRemainingRelationalNodes(MatchResult match, ILVariableExpression variable, VMFlags flags,
            out ILAssignmentStatement varAssignment, out ILExpression flAssignment2, out MatchResult cmpMatch)
        {
            varAssignment = null;
            flAssignment2 = null;
            cmpMatch = null;
            
            // Check if __AND_DWORD(var, var)
            var (left, right) = GetOperands(match);
            if (left.Variable != right.Variable
                || left.Variable != variable.Variable
                || left.Variable.AssignedBy.Count != 1)
                return false;

            // Check if __AND_DWORD(fl2, overflow | sign | zero)
            varAssignment = left.Variable.AssignedBy[0];
            var flMatch = FLAndConstantPattern.Match(varAssignment.Value);
            if (!flMatch.Success)
                return false;

            var constant3 = (ILInstructionExpression) flMatch.Captures["constant"][0];
            if ((byte) (uint) constant3.Operand != _constants.GetFlagMask(flags))
                return false;

            // Check if CMP_xxxx(op0, op1)
            var flUsage2 = (ILFlagsVariable) ((ILVariableExpression) flMatch.Captures["fl"][0]).Variable;
            if (flUsage2.ImplicitAssignments.Count != 1)
                return false;

            flAssignment2 = flUsage2.ImplicitAssignments.First();
            cmpMatch = ComparePattern.Match(flAssignment2);
            if (!cmpMatch.Success)
                return false;
            
            return true;
        }


        private static (ILVariableExpression left, ILVariableExpression right) GetOperands(MatchResult matchResult)
        {
            var left = (ILVariableExpression) matchResult.Captures["left"][0];
            var right = (ILVariableExpression) matchResult.Captures["right"][0];
            return (left, right);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/IILAstTransform.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Linq;

namespace OldRod.Core.Ast.IL.Transform
{
    public interface IILAstTransform
    {
        string Name { get; }
        
        void ApplyTransformation(ILCompilationUnit unit, ILogger logger);
    }

    public interface IChangeAwareILAstTransform : IILAstTransform
    {
        new bool ApplyTransformation(ILCompilationUnit unit, ILogger logger);
    }

    public abstract class ChangeAwareILAstTransform : IChangeAwareILAstTransform, IILAstVisitor<bool>
    {
        public abstract string Name
        {
            get;
        }

        void IILAstTransform.ApplyTransformation(ILCompilationUnit unit, ILogger logger)
        {
            ApplyTransformation(unit, logger);
        }

        public virtual bool ApplyTransformation(ILCompilationUnit unit, ILogger logger)
        {
            bool changed = false;
            while (unit.AcceptVisitor(this))
            {
                changed = true;
                // Repeat until no more changes.
            }

            return changed;
        }

        public virtual bool VisitCompilationUnit(ILCompilationUnit unit)
        {
            bool changed = false;
            foreach (var node in unit.ControlFlowGraph.Nodes)
            {
                var block = (ILAstBlock) node.UserData[ILAstBlock.AstBlockProperty];
                changed |= block.AcceptVisitor(this);
            }

            return changed;
        }

        public virtual bool VisitBlock(ILAstBlock block)
        {
            bool changed = false;
            foreach (var statement in block.Statements)
                changed |= statement.AcceptVisitor(this);
            return changed;
        }

        public virtual bool VisitExpressionStatement(ILExpressionStatement statement)
        {
            return statement.Expression.AcceptVisitor(this);
        }

        public virtual bool VisitAssignmentStatement(ILAssignmentStatement statement)
        {
            return statement.Value.AcceptVisitor(this);
        }

        public virtual bool VisitInstructionExpression(ILInstructionExpression expression)
        {
            return TryOptimiseArguments(expression);
        }

        public virtual bool VisitVariableExpression(ILVariableExpression expression)
        {
            return false;
        }

        public virtual bool VisitVCallExpression(ILVCallExpression expression)
        {
            return TryOptimiseArguments(expression);
        }

        public virtual bool VisitPhiExpression(ILPhiExpression expression)
        {
            return false;
        }

        public virtual bool VisitExceptionExpression(ILExceptionExpression expression)
        {
            return false;
        }

        private bool TryOptimiseArguments(IILArgumentsProvider provider)
        {
            bool changed = false;
            foreach (var argument in provider.Arguments.ToArray())
                changed |= argument.AcceptVisitor(this);
            return changed;
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/ILTransformEventArgs.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;

namespace OldRod.Core.Ast.IL.Transform
{
    public class ILTransformEventArgs : EventArgs
    {
        public ILTransformEventArgs(ILCompilationUnit unit, IILAstTransform transform, int iteration)
        {
            Unit = unit;
            Transform = transform;
            Iteration = iteration;
        }

        public ILCompilationUnit Unit
        {
            get;
        }
        
        public IILAstTransform Transform
        {
            get;
        }

        public int Iteration
        {
            get;
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/LogicSimplifier.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.IL.Pattern;

namespace OldRod.Core.Ast.IL.Transform
{
    public class LogicSimplifier : ChangeAwareILAstTransform
    {
        /*
         * TODO: Some patterns defined in here might not be sufficient as many of these operators are commutative.
         *       For example, a or b = b or a.
         *
         *       Currently the checks do not take this into account and are hardcoded to recognize just the patterns
         *       emitted by vanilla KoiVM.
         */

        // Â¬(p or p) <=> Â¬p
        private static readonly ILExpressionPattern NotPattern = ILAstPattern
            .Instruction(ILCode.NOR_DWORD, ILCode.NOR_QWORD)
            .WithAnyOperand()
            .WithArguments(
                ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                    .WithAnyOperand()
                    .WithArguments(ILVariablePattern.Any.CaptureVar("left")),
                ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                    .WithAnyOperand()
                    .WithArguments(ILVariablePattern.Any.CaptureVar("right"))
            );

        // Â¬(Â¬p or Â¬q) <=> p and q
        private static readonly ILExpressionPattern AndPattern = ILAstPattern
            .Instruction(ILCode.NOR_DWORD, ILCode.NOR_QWORD)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.__NOT_DWORD, ILCode.__NOT_QWORD)
                    .WithAnyOperand()
                    .WithArguments(
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("left"))),
                ILAstPattern.Instruction(ILCode.__NOT_DWORD, ILCode.__NOT_QWORD)
                    .WithAnyOperand()
                    .WithArguments(
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("right")))
            );

        // Â¬(Â¬(p or q)) <=> p or q
        private static readonly ILExpressionPattern OrPattern = ILAstPattern
            .Instruction(ILCode.__NOT_DWORD, ILCode.__NOT_QWORD)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.NOR_DWORD, ILCode.NOR_QWORD)
                    .WithArguments(
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("left")),
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("right"))
                    )
            );
        
        // Â¬((p and q) or Â¬(p or q)) <=> p xor q
        private static readonly ILExpressionPattern XorPattern = ILAstPattern
            .Instruction(ILCode.NOR_DWORD, ILCode.NOR_QWORD)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.__AND_DWORD, ILCode.__AND_QWORD)
                    .WithArguments(
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("left")),
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithArguments(ILVariablePattern.Any.CaptureVar("right"))
                    ),
                ILAstPattern.Instruction(ILCode.NOR_DWORD, ILCode.NOR_QWORD)
                    .WithArguments(
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("left")),
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("right"))
                    )
            );
            

        // a + ~b + 1 <=> a - b
        private static readonly ILExpressionPattern SubPattern = ILAstPattern
            .Instruction(ILCode.ADD_DWORD, ILCode.ADD_QWORD)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.ADD_DWORD, ILCode.ADD_QWORD)
                    .WithArguments(
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("left")),
                        ILAstPattern.Instruction(ILCode.__NOT_DWORD, ILCode.__NOT_QWORD)
                            .WithArguments(
                                ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                                    .WithAnyOperand()
                                    .WithArguments(ILVariablePattern.Any.CaptureVar("right"))
                            )
                    ),
                ILAstPattern.Instruction(ILCode.PUSHI_DWORD, ILCode.PUSHI_QWORD)
                    .WithOperand(1u, 1ul)
            );

        // ~a + 1 <=> -a
        private static readonly ILExpressionPattern NegIntegerPattern = ILAstPattern
            .Instruction(ILCode.ADD_DWORD, ILCode.ADD_QWORD)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.__NOT_DWORD, ILCode.__NOT_QWORD)
                    .WithArguments(
                        ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                            .WithAnyOperand()
                            .WithArguments(ILVariablePattern.Any.CaptureVar("value"))
                    ),
                ILAstPattern.Instruction(ILCode.PUSHI_DWORD, ILCode.PUSHI_QWORD)
                    .WithOperand(1u, 1ul)
            );

        // 0 - a <=> -a
        private static readonly ILExpressionPattern NegRealPattern = ILAstPattern
            .Instruction(ILCode.SUB_R32, ILCode.SUB_R64)
            .WithArguments(
                ILAstPattern.Instruction(ILCode.PUSHI_DWORD, ILCode.PUSHI_QWORD)
                    .WithOperand(0u, 0ul),
                ILAstPattern.Instruction(ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD)
                    .WithAnyOperand()
                    .WithArguments(ILVariablePattern.Any.CaptureVar("value"))
            );

        public override string Name => "Logic simplifier";

        public override bool VisitInstructionExpression(ILInstructionExpression expression)
        {
            // Depth-first to minimize the amount of iterations.
            bool changed = base.VisitInstructionExpression(expression);

            MatchResult matchResult;
            if ((matchResult = NotPattern.Match(expression)).Success)
                changed = TryOptimiseToNot(matchResult, expression);
            else if ((matchResult = NegIntegerPattern.Match(expression)).Success
                     || (matchResult = NegRealPattern.Match(expression)).Success)
                changed = TryOptimiseToNeg(matchResult, expression);
            else if ((matchResult = AndPattern.Match(expression)).Success)
                changed = TryOptimiseToAnd(matchResult, expression);
            else if ((matchResult = OrPattern.Match(expression)).Success)
                changed = TryOptimiseToOr(matchResult, expression);
            else if ((matchResult = XorPattern.Match(expression)).Success)
                changed = TryOptimiseToXor(matchResult, expression);
            else if ((matchResult = SubPattern.Match(expression)).Success)
                changed = TryOptimiseToSub(matchResult, expression);

            return changed;
        }

        private static bool TryOptimiseToNot(MatchResult matchResult, ILInstructionExpression expression)
        {
            var (left, right) = GetOperands(matchResult);
            if (left.Variable == right.Variable)
            {
                // Unregister one of the variable uses.
                right.Variable = null;

                // Replace with NOT pseudo opcode.
                var newExpression = new ILInstructionExpression(
                    expression.OriginalOffset,
                    expression.OpCode.Code switch
                    {
                        ILCode.NOR_DWORD => ILOpCodes.__NOT_DWORD,
                        ILCode.NOR_QWORD => ILOpCodes.__NOT_QWORD,
                        _ => throw new ArgumentOutOfRangeException(nameof(expression))
                    },
                    null,
                    expression.OpCode.StackBehaviourPush.GetResultType());
                newExpression.Arguments.Add((ILExpression) left.Parent.Remove());
                newExpression.FlagsVariable = expression.FlagsVariable;
                expression.FlagsVariable = null;
                expression.ReplaceWith(newExpression);

                return true;
            }

            return false;
        }

        private static bool TryOptimiseToNeg(MatchResult matchResult, ILInstructionExpression expression)
        {
            var value = matchResult.Captures["value"][0];

            // Replace with neg pseudo opcode.
            var newExpression = new ILInstructionExpression(
                expression.OriginalOffset,
                expression.OpCode.Code switch
                {
                    ILCode.ADD_DWORD => ILOpCodes.__NEG_DWORD,
                    ILCode.ADD_QWORD => ILOpCodes.__NEG_QWORD,
                    ILCode.SUB_R32 => ILOpCodes.__NEG_R32,
                    ILCode.SUB_R64 => ILOpCodes.__NEG_R64,
                    _ => throw new ArgumentOutOfRangeException(nameof(expression))
                },
                null,
                expression.OpCode.StackBehaviourPush.GetResultType());
            newExpression.Arguments.Add((ILExpression) value.Remove());
            newExpression.FlagsVariable = expression.FlagsVariable;
            expression.FlagsVariable = null;
            expression.ReplaceWith(newExpression);

            return true;
        }

        private static bool TryOptimiseToAnd(MatchResult matchResult, ILInstructionExpression expression)
        {
            var (left, right) = GetOperands(matchResult);

            // Replace with AND pseudo opcode.
            var newExpression = new ILInstructionExpression(
                expression.OriginalOffset,
                expression.OpCode.Code switch
                {
                    ILCode.NOR_DWORD => ILOpCodes.__AND_DWORD,
                    ILCode.NOR_QWORD => ILOpCodes.__AND_QWORD,
                    _ => throw new ArgumentOutOfRangeException(nameof(expression))
                },
                null,
                expression.OpCode.StackBehaviourPush.GetResultType());
            newExpression.Arguments.Add((ILExpression) left.Parent.Remove());
            newExpression.Arguments.Add((ILExpression) right.Parent.Remove());
            newExpression.FlagsVariable = expression.FlagsVariable;
            expression.FlagsVariable = null;
            expression.ReplaceWith(newExpression);

            return true;
        }

        private static bool TryOptimiseToOr(MatchResult matchResult, ILInstructionExpression expression)
        {
            var (left, right) = GetOperands(matchResult);

            // Replace with OR pseudo opcode.
            var newExpression = new ILInstructionExpression(
                expression.OriginalOffset,
                expression.OpCode.Code switch
                {
                    ILCode.__NOT_DWORD => ILOpCodes.__OR_DWORD,
                    ILCode.__NOT_QWORD => ILOpCodes.__OR_QWORD,
                    _ => throw new ArgumentOutOfRangeException(nameof(expression))
                },
                null,
                expression.OpCode.StackBehaviourPush.GetResultType());
            newExpression.Arguments.Add((ILExpression) left.Parent.Remove());
            newExpression.Arguments.Add((ILExpression) right.Parent.Remove());
            newExpression.FlagsVariable = expression.FlagsVariable;
            expression.FlagsVariable = null;
            expression.ReplaceWith(newExpression);

            return true;
        }

        private static bool TryOptimiseToXor(MatchResult matchResult, ILInstructionExpression expression)
        {
            var lefts = matchResult.Captures["left"];
            var rights = matchResult.Captures["right"];

            if (((ILVariableExpression) lefts[0]).Variable == ((ILVariableExpression) lefts[1]).Variable
                && ((ILVariableExpression) rights[0]).Variable == ((ILVariableExpression) rights[1]).Variable)
            {
                // Unregister remaining variable references.
                ((ILVariableExpression) lefts[1]).Variable = null;
                ((ILVariableExpression) rights[1]).Variable = null;

                // Replace with XOR pseudo opcode.  
                var newExpression = new ILInstructionExpression(
                    expression.OriginalOffset,
                    expression.OpCode.Code switch
                    {
                        ILCode.NOR_DWORD => ILOpCodes.__XOR_DWORD,
                        ILCode.NOR_QWORD => ILOpCodes.__XOR_QWORD,
                        _ => throw new ArgumentOutOfRangeException(nameof(expression))
                    },
                    null,
                    expression.OpCode.StackBehaviourPush.GetResultType());
                newExpression.Arguments.Add((ILExpression) lefts[0].Parent.Remove());
                newExpression.Arguments.Add((ILExpression) rights[0].Parent.Remove());
                newExpression.FlagsVariable = expression.FlagsVariable;
                expression.FlagsVariable = null;
                expression.ReplaceWith(newExpression);

                return true;
            }

            return false;
        }

        private static bool TryOptimiseToSub(MatchResult matchResult, ILInstructionExpression expression)
        {
            var (left, right) = GetOperands(matchResult);

            // Replace with SUB pseudo opcode.
            var newExpression = new ILInstructionExpression(
                expression.OriginalOffset,
                expression.OpCode.Code switch
                {
                    ILCode.ADD_DWORD => ILOpCodes.__SUB_DWORD,
                    ILCode.ADD_QWORD => ILOpCodes.__SUB_QWORD,
                    _ => throw new ArgumentOutOfRangeException(nameof(expression))
                },
                null,
                expression.OpCode.StackBehaviourPush.GetResultType());
            newExpression.Arguments.Add((ILExpression) left.Parent.Remove());
            newExpression.Arguments.Add((ILExpression) right.Parent.Remove());
            newExpression.FlagsVariable = expression.FlagsVariable;
            expression.FlagsVariable = null;
            expression.ReplaceWith(newExpression);

            return true;
        }

        private static (ILVariableExpression left, ILVariableExpression right) GetOperands(MatchResult matchResult)
        {
            var left = (ILVariableExpression) matchResult.Captures["left"][0];
            var right = (ILVariableExpression) matchResult.Captures["right"][0];
            return (left, right);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/PhiRemovalTransform.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Ast.IL.Transform
{
    public class PhiRemovalTransform : IILAstTransform
    {
        private sealed class PhiCongruenceClass
        {
            public PhiCongruenceClass(ILVariable representative)
            {
                Representative = representative ?? throw new ArgumentNullException(nameof(representative));
            }
            
            public ILVariable Representative
            {
                get;
            }

            public ISet<ILVariable> Variables
            {
                get;
            } = new HashSet<ILVariable>();

            public void ReplaceVarsWithRepresentative()
            {
                foreach (var variable in Variables)
                {
                    foreach (var use in variable.UsedBy.ToArray())
                        use.Variable = Representative;
                    foreach (var assign in variable.AssignedBy.ToArray())
                        assign.Variable = Representative;
                }   
            }
            
            public void RemovePhiNodes()
            {
                foreach (var assign in Representative.AssignedBy.ToArray())
                {
                    if (assign.Value is ILPhiExpression phi)
                    {
                        if (phi.Variables.Any(x => x.Variable != Representative))
                        {
                            // Should never happen. If it does, we have a faulty algorithm :L
                            throw new ILAstBuilderException("Attempted to remove a phi node that still has unresolved variable references.");
                        }

                        assign.Remove();
                    }
                }
            }
            
            public override string ToString()
            {
                return $"{{{string.Join(", ", Variables.Select(x => x.Name))}}}";
            }
        }
        
        public string Name => "Phi Removal";

        public void ApplyTransformation(ILCompilationUnit unit, ILogger logger)
        {
            var classes = ObtainPhiCongruenceClasses(unit);

            foreach (var @class in classes)
            {
                @class.ReplaceVarsWithRepresentative();
                @class.RemovePhiNodes();
            }
        }

        private static IEnumerable<PhiCongruenceClass> ObtainPhiCongruenceClasses(ILCompilationUnit unit)
        {
            var classes = new HashSet<PhiCongruenceClass>();
            var variableToClass = new Dictionary<ILVariable, PhiCongruenceClass>();
            foreach (var variable in unit.Variables.ToArray())
            {
                // Phi nodes are always present in the form:
                // v = phi(v1, v2, ..., vn)
                
                // A situation like the following might happen:
                // 
                // a3 = phi(a1, a2)
                // ...
                // a5 = phi(a3, a5)
                //
                // Here, a3 and a5 are connected and form an equivalence class.
                //
                
                if (variable.AssignedBy.Count == 1 && variable.AssignedBy[0].Value is ILPhiExpression phi)
                {
                    // Check if variable does not belong to any equivalence class already.
                    var connectedVariables = new HashSet<ILVariable>(phi.Variables.Select(x => x.Variable)) {variable};

                    var congruenceClasses = new List<PhiCongruenceClass>();
                    foreach (var connectedVar in connectedVariables.ToArray())
                    {
                        if (variableToClass.TryGetValue(connectedVar, out var congruenceClass))
                        {
                            // The referenced variable is already part of another class, we need to combine the
                            // two classes together. 
                            congruenceClasses.Add(congruenceClass);
                            classes.Remove(congruenceClass);
                            connectedVariables.UnionWith(congruenceClass.Variables);
                        }
                    }

                    PhiCongruenceClass finalClass;
                    if (congruenceClasses.Count == 0)
                    {
                        // No variable was part of a class yet => We need a new one.
                        var representative = unit.GetOrCreateVariable($"phi_{variableToClass.Count.ToString()}");
                        representative.IsVirtual = connectedVariables.First().IsVirtual;
                        representative.VariableType = variable.VariableType;
                        finalClass = new PhiCongruenceClass(representative);
                    }
                    else
                    {
                        // At least one of the variables was part of a class already.
                        // Pick one class that we are going to expand.
                        finalClass = congruenceClasses[0];
                    }

                    // Add all connected variables to the new class.
                    finalClass.Variables.UnionWith(connectedVariables);
                    foreach (var connectedVar in connectedVariables)
                        variableToClass[connectedVar] = finalClass;

                    classes.Add(finalClass);
                }
            }

            return classes;
        }

    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/PushMinimizer.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Architecture;
using OldRod.Core.Ast.IL.Pattern;

namespace OldRod.Core.Ast.IL.Transform
{
    public class PushMinimizer : ChangeAwareILAstTransform
    {
        private static readonly ILInstructionPattern PushPattern =
            ILAstPattern.Instruction(
                    ILCode.PUSHR_BYTE, ILCode.PUSHR_WORD, ILCode.PUSHR_DWORD,
                    ILCode.PUSHR_QWORD, ILCode.PUSHR_OBJECT)
                .WithAnyOperand()
                .WithArguments(ILExpressionPattern.Any.CaptureExpr("expr"));
        
        public override string Name => "Push Minimizer";

        public override bool VisitInstructionExpression(ILInstructionExpression expression)
        {
            // Any push expression that pushes the same type as its argument is superfluous.
            
            bool changed = base.VisitInstructionExpression(expression);

            var match = PushPattern.Match(expression);
            if (match.Success)
            {
                var expr = (ILExpression) match.Captures["expr"][0];
                if (expression.ExpressionType == expr.ExpressionType)
                {
                    expression.ReplaceWith(expr.Remove());
                    changed = true;
                }
            }

            return changed;
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/SsaTransform.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using Rivers;
using Rivers.Analysis;

namespace OldRod.Core.Ast.IL.Transform
{
    // Algorithm based on:
    // http://staff.cs.upt.ro/~chirila/teaching/upt/c51-pt/aamcij/7113/Fly0142.html
    
    public class SsaTransform : IILAstTransform
    {  
        public string Name => "Static Single Assignment Transform";

        public void ApplyTransformation(ILCompilationUnit unit, ILogger logger)
        {
            var phiNodes = InsertPhiNodes(unit);
            RenameVariables(unit, phiNodes);
        }

        private static Dictionary<Node, ICollection<ILAssignmentStatement>> InsertPhiNodes(ILCompilationUnit unit)
        {
            var result = unit.ControlFlowGraph.Nodes.ToDictionary(
                x => x,
                x => (ICollection<ILAssignmentStatement>) new List<ILAssignmentStatement>());

            // We try to find all variables that have more than one assignment, and therefore have multiple
            // versions of it during execution of the program. This is only a problem when they have different
            // values at join nodes, as depicted below. We therefore need to get to the dominance frontier of
            // those nodes and insert phi nodes there. 
            //
            //  [ x1 <- value1 ]         [ x2 <- value2 ]
            //        |                        |
            //        '------------+-----------'
            //                     |
            //          [ x3 <- phi(x1, x2) ]
            //

            // Collect all nodes that contain a variable assignment (i.e. a new definition).
            var variableBlocks = unit.Variables.ToDictionary(
                x => x,
                x => new HashSet<Node>(x.AssignedBy.Select(a => a.GetParentNode())));

            foreach (var variable in unit.Variables.Where(x =>
                    x.AssignedBy.Count > 1 // If the variable has more than one definition 
                    || GetNodesReferencingVariable(x).Count() > 1) // Or is used in multiple nodes.
            )
            {
                var agenda = new Queue<Node>(variableBlocks[variable]);
                while (agenda.Count > 0)
                {
                    var current = agenda.Dequeue();
                    foreach (var frontierNode in unit.DominatorInfo.GetDominanceFrontier(current))
                    {
                        // If the frontier node does not define a phi node already for this variable, we need to add it.
                        if (result[frontierNode].All(x => x.Variable != variable))
                        {
                            // Check if the variable is defined in the frontier node.
                            bool defined = variableBlocks[variable].Contains(frontierNode);

                            // Build phi node.
                            // The number of different versions of the variable is equal to the amount of predecessors. 
                            var phiExpression = new ILPhiExpression(Enumerable
                                .Repeat(variable, frontierNode.InDegree)
                                .Select(v => new ILVariableExpression(v)));

                            var phiNode = new ILAssignmentStatement(variable, phiExpression);

                            // Insert at top of the current block.
                            var block = (ILAstBlock) frontierNode.UserData[ILAstBlock.AstBlockProperty];
                            block.Statements.Insert(0, phiNode);

                            // Register phi node.
                            result[frontierNode].Add(phiNode);

                            // We might have to check this node again if we introduce a new version of this variable
                            // at this node.
                            if (!defined)
                                agenda.Enqueue(frontierNode);
                        }
                    }
                }
            }

            return result;
        }

        private static IEnumerable<Node> GetNodesReferencingVariable(ILVariable x)
        {
            var nodes = new HashSet<Node>();
            nodes.UnionWith(x.UsedBy.Select(n => n.GetParentNode()));
            nodes.UnionWith(x.AssignedBy.Select(n => n.GetParentNode()));
            return nodes;
        }

        private static void RenameVariables(ILCompilationUnit unit,
            IDictionary<Node, ICollection<ILAssignmentStatement>> phiNodes)
        {
            // We keep track of two variables for each variable.
            // - A counter to introduce new variables with new names that are unique throughout the entire function.
            // - A stack containing the current versions of the variable.
            var counter = new Dictionary<ILVariable, int>();
            var stack = new Dictionary<ILVariable, Stack<ILVariable>>();

            foreach (var variable in unit.Variables.Union(unit.Parameters))
            {
                counter[variable] = 0;
                stack[variable] = new Stack<ILVariable>();
                
                // Note: This is a slight deviation of the original algorithm.
                // Some variables (such as registers) do not have an initial value specified in the method.
                // To avoid problems, we add the "global" definition to the stack.
                stack[variable].Push(variable); 
            }
            
            // Start at the entry point of the graph.
            Rename(unit.ControlFlowGraph.Entrypoint);
            
            void Rename(Node n)
            {
                var block = (ILAstBlock) n.UserData[ILAstBlock.AstBlockProperty];
                var originalVars = new Dictionary<ILAssignmentStatement, ILVariable>();
                
                foreach (var statement in block.Statements)
                {
                    bool updateVariables = true;
                    
                    if (statement is ILAssignmentStatement assignment)
                    {
                        var variable = assignment.Variable;
                        originalVars.Add(assignment, variable);
                    
                        // We have a new version of a variable. Let's introduce a new version.
                        counter[variable]++;
                        var newVariable = unit.GetOrCreateVariable($"{variable.Name}_v{counter[variable].ToString()}");
                        newVariable.IsVirtual = variable.IsVirtual;
                        newVariable.VariableType = variable.VariableType;
                        stack[variable].Push(newVariable);

                        // Update the variable in the assignment.
                        assignment.Variable = newVariable;
                        
                        // Don't update arguments of phi nodes. They are updated somewhere else.
                        if (assignment.Value is ILPhiExpression) 
                            updateVariables = false;
                    }

                    if (updateVariables)
                    {
                        // Update variables inside the statement with the new versions.
                        foreach (var use in statement.AcceptVisitor(VariableUsageCollector.Instance))
                            use.Variable = stack[use.Variable].Peek();
                    }
                }

                // Update phi statements in successor nodes.
                foreach (var successor in n.GetSuccessors())
                {
                    // Determine the index of the phi expression argument. 
                    // TODO: Might be inefficient to do an OrderBy every time.
                    //       Maybe optimise by ordering (e.g. numbering) the edges beforehand?
                    int argumentIndex = successor.GetPredecessors()
                        .OrderBy(x => x.Name)
                        .ToList()
                        .IndexOf(n);
                    
                    // Update all variables in the phi nodes to the new versions.
                    foreach (var phiNode in phiNodes[successor])
                    {
                        var phiExpression = (ILPhiExpression) phiNode.Value;
                        var oldVariable = phiExpression.Variables[argumentIndex].Variable;
                        var newVariable = stack[oldVariable].Peek();
                        phiExpression.Variables[argumentIndex].Variable = newVariable;
                    }
                }

                foreach (var child in unit.DominatorTree.Nodes[n.Name].GetSuccessors())
                    Rename(unit.ControlFlowGraph.Nodes[child.Name]);

                // We are done with the newly introduced variables.
                // Pop all new versions of the variable from their stacks.
                foreach (var entry in originalVars)
                    stack[entry.Value].Pop();
            }
        }
        
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/StackFrameTransform.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Linq;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.IL.Pattern;
using OldRod.Core.Memory;

namespace OldRod.Core.Ast.IL.Transform
{
    public class StackFrameTransform : IILAstTransform
    {
        public const string Tag = "StackFrameTransform";
        
        /* The following makes an assumption that each field in the stack frame
         * is referenced using the BP register. Forks of the virtualiser plugin
         * could deviate from this, using a different register or make more use
         * of registers in general.
         *
         * Newer versions of the devirtualiser could therefore benefit from a more
         * generic approach.
         * 
         */

        // op0 = pushr_dword(sp)
        // op1 = pushi_dword($push_local_count)
        // op2 = add_dword(op0, op1)
        // sp = op2
        private static readonly ILSequencePattern<ILStatement> AllocateLocalsPattern =
            ILAstPattern.Sequence<ILStatement>(
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushDwordReg(VMRegisters.SP)),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushAnyDword().Capture("push_local_count")),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.Instruction(ILCode.ADD_DWORD)
                    .WithArguments(ILVariablePattern.Any, ILVariablePattern.Any)),
                ILAstPattern.Assignment(VMRegisters.SP, ILVariablePattern.Any)
            );

        // op0 = pushr_dword(bp)
        // op1 = pushi_dword(offset)
        // op2 = add_dword(op0, op1)
        // sind_xxxx(value, op2)
        private static readonly ILSequencePattern<ILStatement> StoreToLocalPattern =
            ILAstPattern.Sequence<ILStatement>(
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushDwordReg(VMRegisters.BP)),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushAnyDword().Capture("push_offset")),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.Instruction(ILCode.ADD_DWORD)
                    .WithArguments(ILVariablePattern.Any, ILVariablePattern.Any)),
                ILAstPattern.Expression(ILAstPattern.Instruction(
                            ILCode.SIND_PTR, ILCode.SIND_BYTE,
                            ILCode.SIND_WORD, ILCode.SIND_DWORD,
                            ILCode.SIND_QWORD, ILCode.SIND_OBJECT)
                        .WithArguments(ILVariablePattern.Any, ILVariablePattern.Any)
                    )
                    .Capture("store")
            );

        /*
         * TODO: The load patterns could perhaps be generalized to a single pattern or a more clever inference algorithm,
         * because the basic structure is always the same, which is similar to e.g. x86:
         *
         * 1) Push BP onto the stack
         * 2) Push the offset of the variable onto the stack
         * 3) Add the two numbers together.
         * 3) Read the value at the new address.
         *
         * The difference however is that KoiVM uses a little trick that makes a PUSHR_DWORD BP not actually
         * push a DWORD, but a StackRef instead, which is essentially a pointer object. As a consequence, it can be used 
         * in normal pointer arithmetic using a PUSHR_OBJECT afterwards, combined with one of the ADD opcodes.
         *
         * This has a result that it saves KoiVM having to emit special VCALLs for boxing simple types like int32s
         * that can be put onto the stack directly. It introduces a bit of complexity in detecting it, so for now
         * there is a separate pattern. This might (and should) be generalised more in the future.
         */

        // op0 = pushr_dword(bp)
        // op1 = pushi_dword(offset)
        // op2 = add_dword(op0, op1)
        // op3 = lind_xxxx(op2)
        private static readonly ILSequencePattern<ILStatement> LoadLocalPattern =
            ILAstPattern.Sequence<ILStatement>(
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushDwordReg(VMRegisters.BP)),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushAnyDword().Capture("push_offset")),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.Instruction(ILCode.ADD_DWORD)
                    .WithArguments(ILVariablePattern.Any, ILVariablePattern.Any)),
                ILAstPattern.Assignment(ILVariablePattern.Any,
                    ILAstPattern.Instruction(
                            ILCode.LIND_PTR, ILCode.LIND_BYTE,
                            ILCode.LIND_WORD, ILCode.LIND_DWORD,
                            ILCode.LIND_QWORD, ILCode.LIND_OBJECT)
                        .WithArguments(ILVariablePattern.Any)
                        .Capture("load")
                )
            );

        // op0 = pushr_dword(bp)
        // r0 = op0
        // op1 = pushr_object(r0)
        // op2 = pushi_dword(offset)
        // op3 = add_qword(op1, op2)
        // r0 = op3
        private static readonly ILSequencePattern<ILStatement> LoadLocalRefPattern =
            ILAstPattern.Sequence<ILStatement>(
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushDwordReg(VMRegisters.BP)),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILVariablePattern.Any),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushAnyObjectReg()),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.PushAnyDword().Capture("push_offset")),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILAstPattern.Instruction(ILCode.ADD_QWORD)
                    .WithArguments(ILVariablePattern.Any, ILVariablePattern.Any)
                ),
                ILAstPattern.Assignment(ILVariablePattern.Any, ILVariablePattern.Any.CaptureVar("final_value"))
            );
        
        public string Name => "Stack Frame Transform";

        public void ApplyTransformation(ILCompilationUnit unit, ILogger logger)
        {
            DetermineAndDeclareLocals(unit);
            RemoveSPAssignments(unit);
            ReplaceRawLocalReferences(unit, logger);
        }

        private static void RemoveSPAssignments(ILCompilationUnit unit)
        {
            // We assume all stack related operations are already handled. 
            // We can therefore safely remove any reference to SP.
            
            var sp = unit.GetOrCreateVariable("SP");
            foreach (var assign in sp.AssignedBy.ToArray())
            {
                assign.Variable = null;
                foreach (var use in assign.Value.AcceptVisitor(VariableUsageCollector.Instance))
                    use.Variable = null;
                assign.Remove();
            }
        }

        private static void DetermineAndDeclareLocals(ILCompilationUnit unit)
        {
            int localsCount = DetermineLocalCountFromPrologue(unit);

            for (int i = 0; i < localsCount; i++)
                unit.GetOrCreateVariable($"local_{i.ToString()}");
        }

        private static int DetermineLocalCountFromPrologue(ILCompilationUnit unit)
        {
            var entryBlock = (ILAstBlock) unit.ControlFlowGraph.Entrypoint.UserData[ILAstBlock.AstBlockProperty];
           
            var match = AllocateLocalsPattern.FindMatch(entryBlock.Statements);
            if (match.Success)
            {
                var pushLocalCount = (ILInstructionExpression) match.Captures["push_local_count"][0];
                return Convert.ToInt32(pushLocalCount.Operand);
            }
            
            return 0;
        }

        private static void ReplaceRawLocalReferences(ILCompilationUnit unit, ILogger logger)
        {
            // Find in each block the patterns for loading and/or storing local variable values,
            // and replace them with a normal variable expression or assignment statement. 
            
            foreach (var node in unit.ControlFlowGraph.Nodes)
            {
                var block = (ILAstBlock) node.UserData[ILAstBlock.AstBlockProperty];

                for (int i = 0; i < block.Statements.Count; i++)
                {
                    // TODO: Might need some extra checks after the match of a pattern.
                    //       Variables referenced in the expressions are not checked for 
                    //       equality.
                    
                    MatchResult match;
                    if ((match = StoreToLocalPattern.Match(block.Statements, i)).Success) 
                        ReplaceStoreToLocal(unit, match, logger);
                    else if ((match = LoadLocalPattern.Match(block.Statements, i)).Success)
                        ReplaceLoadToLocal(unit, match, logger);
                    else if ((match = LoadLocalRefPattern.Match(block.Statements, i)).Success)
                        ReplaceLoadLocalRef(unit, match, logger);
                }
            }
        }

        private static void ReplaceStoreToLocal(ILCompilationUnit unit, MatchResult match, ILogger logger)
        {
            // Obtain variable that is referenced.
            var pushOffset = (ILInstructionExpression) match.Captures["push_offset"][0];
            int offset = unchecked((int) Convert.ToUInt32(pushOffset.Operand));
            var variable = ResolveVariable(unit, offset, logger);

            // Obtain SIND_xxxx expression.
            var statement = (ILExpressionStatement) match.Captures["store"][0];
            var sindExpr = (ILInstructionExpression) statement.Expression;
            
            // Remove value.
            var value = (ILExpression) sindExpr.Arguments[0].Remove();
            
            // Remove the original expression containing the address and unregister the
            // associated variable.
            var address = (ILVariableExpression) sindExpr.Arguments[0].Remove();
            address.Variable = null;
            
            // Replace with normal assignment.
            statement.ReplaceWith(new ILAssignmentStatement(variable, value));
        }

        private static void ReplaceLoadToLocal(ILCompilationUnit unit, MatchResult match, ILogger logger)
        {
            // Obtain variable that is referenced.
            var pushOffset = (ILInstructionExpression) match.Captures["push_offset"][0];
            int offset = unchecked((int) Convert.ToUInt32(pushOffset.Operand));
            var variable = ResolveVariable(unit, offset, logger);

            // Remove the original expression containing the address and unregister the
            // associated variable.
            var lindExpr = (ILInstructionExpression) match.Captures["load"][0];
            var address = (ILVariableExpression) lindExpr.Arguments[0].Remove();
            address.Variable = null;
            
            // Replace with normal variable expression.
            lindExpr.ReplaceWith(new ILVariableExpression(variable));
        }

        private static void ReplaceLoadLocalRef(ILCompilationUnit unit, MatchResult match, ILogger logger)
        {
            // Obtain variable that is referenced.
            var pushOffset = (ILInstructionExpression) match.Captures["push_offset"][0];
            int offset = unchecked((int) Convert.ToUInt32(pushOffset.Operand));
            var variable = ResolveVariable(unit, offset, logger);

            // Obtain reference to final loaded value of the variable. 
            var finalValue = (ILVariableExpression) match.Captures["final_value"][0];
            finalValue.Variable = null;
            
            // Replace with normal variable expression.
            finalValue.ReplaceWith(new ILVariableExpression(variable)
            {
                IsReference = true,
                ExpressionType = VMType.Object
            });
        }

        private static ILVariable ResolveVariable(ILCompilationUnit unit, int offset, ILogger logger)
        {
            var field = unit.FrameLayout.Resolve(offset);
            if (!field.IsValid)
            {
                switch (field.FieldKind)
                {
                    case FrameFieldKind.Parameter:
                        logger.Warning(Tag, $"Reference to non-existing parameter {field.Index.ToString()} detected.");
                        break;
                    case FrameFieldKind.ReturnAddress:
                        logger.Warning(Tag, $"Reference to return address detected.");
                        break;
                    case FrameFieldKind.CallersBasePointer:
                        logger.Warning(Tag, $"Reference to callers base pointer detected.");
                        break;
                    case FrameFieldKind.LocalVariable:
                        logger.Warning(Tag, $"Reference to non-existing local variable {field.Index.ToString()} detected.");
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            return unit.GetOrCreateVariable(field);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/TransformLoop.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;

namespace OldRod.Core.Ast.IL.Transform
{
    public class TransformLoop : IChangeAwareILAstTransform
    {
        public event EventHandler IterationStart;
        public event EventHandler IterationEnd;
        public event EventHandler<ILTransformEventArgs> TransformStart;
        public event EventHandler<ILTransformEventArgs> TransformEnd;
        
        public TransformLoop(string name, int? maxIterations, IEnumerable<IChangeAwareILAstTransform> transforms)
        {
            Name = name;
            MaxIterations = maxIterations;
            Transforms = new List<IChangeAwareILAstTransform>(transforms);
        }
        
        public string Name
        {
            get;
        }

        public IList<IChangeAwareILAstTransform> Transforms
        {
            get;
        }

        public int? MaxIterations
        {
            get;
        }

        public bool ApplyTransformation(ILCompilationUnit unit, ILogger logger)
        {
            int iteration = 0;
            
            bool changed = true;
            while (changed && (MaxIterations is null || iteration < MaxIterations))
            {
                iteration++;
                logger.Debug2(Name, $"Started iteration {iteration.ToString()}...");
                OnIterationStart();
                
                changed = PerformSingleIteration(unit, logger, iteration);
                
                logger.Debug2(Name, $"Finished iteration {iteration.ToString()} (AST has changed: {changed.ToString()}).");
                OnIterationEnd();
            }

            if (iteration == MaxIterations && changed)
            {
                logger.Warning(Name,
                    $"Reached maximum amount of iterations of {MaxIterations.ToString()} and AST is "
                    + "still changing. This might be a bug in the transformer pipeline where transforms keep "
                    + "cancelling each other out, or the method to devirtualise is too complex for the provided "
                    + "upper bound of iterations.");
            }

            return iteration > 1;
        }

        private bool PerformSingleIteration(ILCompilationUnit unit, ILogger logger, int iterationNumber)
        {
            bool changed = false;
            foreach (var transform in Transforms)
            {
                logger.Debug2(Name, "Applying " + transform.Name + "...");
                OnTransformStart(new ILTransformEventArgs(unit, transform, iterationNumber));
                changed |= transform.ApplyTransformation(unit, logger);
                OnTransformEnd(new ILTransformEventArgs(unit, transform, iterationNumber));
            }

            return changed;
        }

        void IILAstTransform.ApplyTransformation(ILCompilationUnit unit, ILogger logger)
        {
            ApplyTransformation(unit, logger);
        }

        protected virtual void OnTransformStart(ILTransformEventArgs e)
        {
            TransformStart?.Invoke(this, e);
        }

        protected virtual void OnTransformEnd(ILTransformEventArgs e)
        {
            TransformEnd?.Invoke(this, e);
        }

        protected virtual void OnIterationStart()
        {
            IterationStart?.Invoke(this, EventArgs.Empty);
        }

        protected virtual void OnIterationEnd()
        {
            IterationEnd?.Invoke(this, EventArgs.Empty);
        }
    }
}


================================================
File: src/OldRod.Core/Ast/IL/Transform/VariableInliner.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Architecture;
using OldRod.Core.Ast.IL.Pattern;

namespace OldRod.Core.Ast.IL.Transform
{
    public class VariableInliner : ChangeAwareILAstTransform
    {
        private static readonly ILInstructionPattern PushPattern = ILAstPattern
            .Instruction(ILCode.PUSHR_BYTE, ILCode.PUSHR_WORD,
                ILCode.PUSHR_DWORD, ILCode.PUSHR_QWORD,
                ILCode.PUSHR_OBJECT)
            .WithAnyOperand()
            .WithArguments(ILExpressionPattern.Any);

        public override string Name => "Variable Inlining";

        public override bool ApplyTransformation(ILCompilationUnit unit, ILogger logger)
        {
            return base.ApplyTransformation(unit, logger) && unit.RemoveNonUsedVariables();
        }
        
        public override bool VisitBlock(ILAstBlock block)
        {
            // Find all assignments of variables, and count the amount of usages for each variable.
            // If the variable is not used it can be removed. If it is only used once, it can be inlined.
            
            bool changed = false;
            for (var i = 0; i < block.Statements.Count; i++)
            {
                // Find assignment statement:
                var statement = block.Statements[i];
                if (statement is ILAssignmentStatement assignmentStatement && !(assignmentStatement.Variable is ILParameter))
                {
                    bool removeStatement = true;
                    var usages = assignmentStatement.Variable.UsedBy;
                 
                    // Count usages.
                    switch (usages.Count)
                    {
                        case 0:
                        {
                            if (assignmentStatement.Variable is ILFlagsVariable)
                            {
                                removeStatement = false;
                            }
                            if (assignmentStatement.Value.HasPotentialSideEffects)
                            {
                                // If the value has side effects, it cannot be removed.
                                removeStatement = false;
                                assignmentStatement.ReplaceWith(new ILExpressionStatement((ILExpression) assignmentStatement.Value.Remove()));
                            }
                            else
                            {
                                // Find all variables that are referenced in the statement, and remove them from the 
                                // usage lists.
                                var embeddedReferences = assignmentStatement.Value.AcceptVisitor(VariableUsageCollector.Instance);
                                foreach (var reference in embeddedReferences)
                                    reference.Variable.UsedBy.Remove(reference);
                            }

                            break;
                        }
                        case 1 when assignmentStatement.Variable.IsVirtual
                            // We cannot inline into phi nodes.
                            && !(usages[0].Parent is ILPhiExpression)
                            // We also cannot insert phi nodes in arbitrary expressions other than assignments.
                            && !(assignmentStatement.Value is ILPhiExpression)
                            // Finally, we cannot inline expressions with side effects => depend on order of execution.
                            && (!assignmentStatement.Value.HasPotentialSideEffects || !HasNoSideEffectsInBetween(assignmentStatement, usages[0])):
                        {
                            // Inline the variable's value.
                            InlineVariable(usages[0], assignmentStatement);
                            usages.Clear();
                            break;
                        }
                        default:
                        {
                            removeStatement = false;
                            break;
                        }
                    }

                    if (removeStatement)
                    {
                        // We applied a transformation, remove the original statement.
                        block.Statements.RemoveAt(i);
                        i--;
                        changed = true;
                    }
                }
            }

            return changed;
        }

        private static void InlineVariable(ILVariableExpression usage, ILAssignmentStatement assignmentStatement)
        {
            var replacement = assignmentStatement.Value;
            
            // Simple inlining can cause massive PUSH chains. For example, the following:
            //
            //     R0 = PUSHR_DWORD(expr)
            //     R1 = PUSHR_DWORD(R0)
            //
            // would be optimised to
            //
            //     R1 = PUSHR_DWORD(PUSHR_DWORD(expr))
            //
            // But this can be simply:
            //
            //     R1 = PUSHR_DWORD(expr)
            //
            // Try to optimise for this:
            var match1 = PushPattern.Match(usage.Parent);
            var match2 = PushPattern.Match(assignmentStatement.Value);
            if (match1.Success && match2.Success)
            {
                var pushVariable = (ILInstructionExpression) usage.Parent;
                var value = (ILInstructionExpression) assignmentStatement.Value;

                if (pushVariable.OpCode.Code == value.OpCode.Code)
                    replacement = value.Arguments[0];
            }

            usage.Variable = null;
            usage.ReplaceWith(replacement.Remove());
        }

        private static bool HasNoSideEffectsInBetween(ILStatement statement, ILExpression expression)
        {
            // Check if all expressions that are evaluated before the provided expression in the same containing statement
            // have potential side effects.  
            var currentExpression = expression;
            while (true)
            {
                // Obtain the parent expression that contains the argument.
                var parentExpression = currentExpression.Parent as IILArgumentsProvider;
                if (parentExpression == null)
                    break;

                // Figure out if all arguments evaluated before the current expression have any potential side effects.
                for (int i = 0; parentExpression.Arguments[i] != currentExpression; i++)
                {
                    if (i >= parentExpression.Arguments.Count || parentExpression.Arguments[i].HasPotentialSideEffects)
                        return true;
                }

                currentExpression = (ILExpression) parentExpression;
            }

            // Verify that the two statements occur in the same block.
            var statement2 = (ILStatement) currentExpression.Parent;
            var block = (ILAstBlock) statement2.Parent;

            if ((ILAstBlock) statement.Parent != block)
                return true;

            // Start at the first statement, and move up till we find the second statement containing the expression,
            // and figure out if any of the statements in between have potential side effects.
            int startIndex = block.Statements.IndexOf(statement);
            for (int i = startIndex + 1; block.Statements[i] != statement2; i++)
            {
                if (i >= block.Statements.Count || block.Statements[i].HasPotentialSideEffects)
                    return true;
            }
            
            // Nothing has been found that could cause side effects.
            return false;
        }

    }
}


================================================
File: src/OldRod.Core/CodeGen/CilCodeGenerator.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.CodeGen.Blocks;
using OldRod.Core.Disassembly.ControlFlow;
using OldRod.Core.Disassembly.DataFlow;
using Rivers;
using Rivers.Analysis;
using Rivers.Analysis.Connectivity;

namespace OldRod.Core.CodeGen
{
    public class CilCodeGenerator : ICilAstVisitor<IList<CilInstruction>>
    {
        private const string InvalidAstMessage =
            "The provided CIL AST is invalid or incomplete. " +
            "This might be because the IL to CIL recompiler contains a bug. " +
            "For more details, inspect the control flow graphs generated by the recompiler.";

        private readonly CilAstFormatter _formatter;
        private readonly CodeGenerationContext _context;

        private IDictionary<Node, CilInstruction> _blockEntries;
        private IDictionary<Node, CilInstruction> _blockExits;
        
        public CilCodeGenerator(CodeGenerationContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
            _formatter = new CilAstFormatter();
        }
        
        public IList<CilInstruction> VisitCompilationUnit(CilCompilationUnit unit)
        {
            // Add variable signatures to the end result.
            BindVariablesToSignatures(unit);
            
            var result = GenerateInstructions(unit);

            var instructions = new CilInstructionCollection(_context.MethodBody);
            instructions.AddRange(result);
            instructions.CalculateOffsets();
            
            CreateExceptionHandlers(unit, instructions);

            return instructions;
        }

        private void BindVariablesToSignatures(CilCompilationUnit unit)
        {
            foreach (var variable in unit.Variables)
                _context.Variables.Add(variable, new CilLocalVariable(variable.VariableType));

            foreach (var parameter in unit.Parameters)
            {
                var physicalParameter = _context.MethodBody.Owner.Parameters
                    .GetBySignatureIndex(parameter.ParameterIndex);
                
                if (physicalParameter != _context.MethodBody.Owner.Parameters.ThisParameter)
                    physicalParameter.ParameterType = parameter.VariableType;

                _context.Parameters.Add(parameter, physicalParameter);
            }
        }

        private IList<CilInstruction> GenerateInstructions(CilCompilationUnit unit)
        {
            // Define block headers to use as branch targets later.
            foreach (var node in unit.ControlFlowGraph.Nodes)
                _context.BlockHeaders[node] = new CilInstruction(CilOpCodes.Nop);

            var generator = new BlockGenerator(unit.ControlFlowGraph, this);
            var rootScope = generator.CreateBlock();

            var result = rootScope.GenerateInstructions();

            _blockEntries = generator.BlockEntries;
            _blockExits = generator.BlockExits;

            return result;
        }

        private void CreateExceptionHandlers(CilCompilationUnit unit, CilInstructionCollection result)
        {
            foreach (var subGraph in unit.ControlFlowGraph.SubGraphs)
            {
                var ehFrame = (EHFrame) subGraph.UserData[EHFrame.EHFrameProperty];
                
                CilExceptionHandlerType type;
                switch (ehFrame.Type)
                {
                    case EHType.CATCH:
                        type = CilExceptionHandlerType.Exception;
                        break;
                    case EHType.FILTER:
                        type = CilExceptionHandlerType.Filter;
                        break;
                    case EHType.FAULT:
                        type = CilExceptionHandlerType.Fault;
                        break;
                    case EHType.FINALLY:
                        type = CilExceptionHandlerType.Finally;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                // Find first and last nodes of try block.
                var tryBody = (ICollection<Node>) subGraph.UserData[ControlFlowGraph.TryBlockProperty];
                var (tryStartNode, tryEndNode) = FindMinMaxNodes(tryBody);
                
                // Find first and last nodes of handler block.
                var handlerBody = (ICollection<Node>) subGraph.UserData[ControlFlowGraph.HandlerBlockProperty];
                var (handlerStartNode, handlerEndNode) = FindMinMaxNodes(handlerBody);

                // Create handler.
                var handler = new CilExceptionHandler();
                handler.HandlerType = type;
                
                handler.TryStart = new CilInstructionLabel(_blockEntries[tryStartNode]);
                handler.TryEnd = GetHandlerEndLabel(result, tryEndNode, "try");
                
                handler.HandlerStart = new CilInstructionLabel(_blockEntries[handlerStartNode]);
                handler.HandlerEnd = GetHandlerEndLabel(result, handlerEndNode, "handler");
                
                handler.ExceptionType = ehFrame.CatchType;

                if (ehFrame.Type == EHType.FILTER)
                {
                    var filterStartNode = (Node) subGraph.UserData[ControlFlowGraph.FilterStartProperty];
                    handler.FilterStart = new CilInstructionLabel(_blockEntries[filterStartNode]);
                }

                _context.ExceptionHandlers.Add(ehFrame, handler);
            }
        }

        private ICilLabel GetHandlerEndLabel(CilInstructionCollection result, Node endNode, string type)
        {
            var instruction = result.GetByOffset(_blockExits[endNode].Offset + _blockExits[endNode].Size);
            if (instruction is null)
            {
                throw new CilCodeGeneratorException(
                    $"Could not infer end of {type} block in {_context.MethodBody.Owner.Name}.");
            }

            return new CilInstructionLabel(instruction);
        }

        private static (Node minNode, Node maxNode) FindMinMaxNodes(ICollection<Node> nodes)
        {
            Node minNode = null;
            Node maxNode = null;
            int minOffset = int.MaxValue;
            int maxOffset = -1;
            foreach (var node in nodes)
            {
                var block = (CilAstBlock) node.UserData[CilAstBlock.AstBlockProperty];
                if (block.BlockHeader.Offset < minOffset)
                {
                    minNode = node;
                    minOffset = block.BlockHeader.Offset;
                }
                
                if (block.BlockHeader.Offset > maxOffset)
                {
                    maxNode = node;
                    maxOffset = block.BlockHeader.Offset;
                }
            }

            return (minNode, maxNode);
        }

        public IList<CilInstruction> VisitBlock(CilAstBlock block)
        {
            var result = new List<CilInstruction>();
            result.Add(block.BlockHeader);
            foreach (var statement in block.Statements)
                result.AddRange(statement.AcceptVisitor(this));
            return result;
        }

        public IList<CilInstruction> VisitExpressionStatement(CilExpressionStatement statement)
        {
            return statement.Expression.AcceptVisitor(this);
        }

        public IList<CilInstruction> VisitAssignmentStatement(CilAssignmentStatement statement)
        {
            var result = new List<CilInstruction>();
            result.AddRange(statement.Value.AcceptVisitor(this));
            result.Add(new CilInstruction(CilOpCodes.Stloc, _context.Variables[statement.Variable]));
            return result;
        }

        public IList<CilInstruction> VisitInstructionExpression(CilInstructionExpression expression)
        {
            var result = new List<CilInstruction>();

            // Sanity check for expression validity. 
            ValidateExpression(expression);

            // Decide whether to emit FL updates or not.
            if (expression.ShouldEmitFlagsUpdate)
            {
                var first = expression.Arguments[0];

                switch (expression.Arguments.Count)
                {
                    case 1:
                        result.AddRange(_context.BuildFlagAffectingExpression32(
                            first.AcceptVisitor(this),
                            expression.Instructions,
                            _context.Constants.GetFlagMask(expression.AffectedFlags), 
                            expression.ExpressionType != null));
                        break;
                    case 2:
                        var second = expression.Arguments[1];
                        
                        result.AddRange(_context.BuildFlagAffectingExpression32(
                            first.AcceptVisitor(this),
                            second.AcceptVisitor(this),
                            expression.Instructions,
                            _context.Constants.GetFlagMask(expression.AffectedFlags), 
                            expression.InvertedFlagsUpdate,
                            expression.ExpressionType != null));
                        break;
                }
            }
            else
            {
                foreach (var argument in expression.Arguments)
                    result.AddRange(argument.AcceptVisitor(this));
                result.AddRange(expression.Instructions);
            }
            
            return result;
        }

        public IList<CilInstruction> VisitUnboxToVmExpression(CilUnboxToVmExpression expression)
        {
            var result = new List<CilInstruction>(expression.Expression.AcceptVisitor(this));
            
            if (expression.Type.IsTypeOf("System", "Object"))
            {
                var convertMethod = _context.VmHelperType.Methods.First(x =>
                    x.Name == nameof(VmHelper.ConvertToVmType)
                    && x.Parameters.Count == 1);
                
                result.Add(new CilInstruction(CilOpCodes.Call, convertMethod));
            }
            else
            {
                var convertMethod = _context.VmHelperType.Methods.First(x =>
                    x.Name == nameof(VmHelper.ConvertToVmType)
                    && x.Parameters.Count == 2);
                
                var scope = _context.TargetModule.CorLibTypeFactory.CorLibScope;

                var typeRef = new TypeReference(_context.TargetModule, scope, "System", "Type");
                var rtTypeHandleRef = new TypeReference(_context.TargetModule, scope, "System", "RuntimeTypeHandle");
                var methodRef = new MemberReference(typeRef, "GetTypeFromHandle",
                    MethodSignature.CreateStatic(typeRef.ToTypeSignature(), rtTypeHandleRef.ToTypeSignature()));

                var typeFromHandle = _context.ReferenceImporter.ImportMethod(methodRef);
                result.AddRange(new[]
                {
                    new CilInstruction(CilOpCodes.Ldtoken, expression.Type),
                    new CilInstruction(CilOpCodes.Call, typeFromHandle), 
                    new CilInstruction(CilOpCodes.Call, convertMethod),
                });
            }
            
            return result;
        }

        public IList<CilInstruction> VisitVariableExpression(CilVariableExpression expression)
        {
            CilInstruction instruction;
            if (expression.IsParameter)
            {
                instruction = new CilInstruction(expression.IsReference
                        ? CilOpCodes.Ldarga
                        : CilOpCodes.Ldarg,
                    _context.Parameters[(CilParameter) expression.Variable]);
            }
            else
            {
                instruction = new CilInstruction(expression.IsReference
                        ? CilOpCodes.Ldloca
                        : CilOpCodes.Ldloc,
                    _context.Variables[expression.Variable]);
            }

            return new[]
            {
                instruction
            };
        }

        private void ValidateExpression(CilInstructionExpression expression)
        {
            int stackSize = expression.Arguments.Count;
            foreach (var instruction in expression.Instructions)
            {
                stackSize += Math.Max(0, instruction.GetStackPopCount(_context.MethodBody));
                if (stackSize < 0)
                {
                    throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                        $"Insufficient arguments are pushed onto the stack'{expression.AcceptVisitor(_formatter)}'."));
                }

                stackSize += instruction.GetStackPushCount();

                ValidateInstruction(expression, instruction);
            }
        }

        private void ValidateInstruction(CilInstructionExpression expression, CilInstruction instruction)
        {
            switch (instruction.OpCode.OperandType)
            {
                case CilOperandType.ShortInlineBrTarget:
                case CilOperandType.InlineBrTarget:
                    if (!(instruction.Operand is ICilLabel))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a branch target operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineMethod:
                case CilOperandType.InlineField:
                case CilOperandType.InlineType:
                case CilOperandType.InlineTok:
                    if (!(instruction.Operand is IMemberDescriptor))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a member reference operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineSig:
                    if (!(instruction.Operand is StandAloneSignature))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a signature operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineI:
                    if (!(instruction.Operand is int))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected an int32 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineI8:
                    if (!(instruction.Operand is long))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected an int64 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineNone:
                    if (instruction.Operand != null)
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Unexpected operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;

                case CilOperandType.InlineR:
                    if (!(instruction.Operand is double))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a float64 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.ShortInlineI:
                    if (!(instruction.Operand is sbyte))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected an int8 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.ShortInlineR:
                    if (!(instruction.Operand is float))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a float32 operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineString:
                    if (!(instruction.Operand is string))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a string operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineSwitch:
                    if (!(instruction.Operand is IList<ICilLabel>))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a switch table operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;

                case CilOperandType.ShortInlineVar:
                case CilOperandType.InlineVar:
                    if (!(instruction.Operand is CilLocalVariable))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a variable operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;
                case CilOperandType.InlineArgument:
                case CilOperandType.ShortInlineArgument:
                    if (!(instruction.Operand is CilLocalVariable))
                    {
                        throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                            $"Expected a parameter operand in '{expression.AcceptVisitor(_formatter)}'."));
                    }

                    break;

                default:
                    throw new CilCodeGeneratorException(InvalidAstMessage, new ArgumentException(
                        $"Unexpected opcode in '{expression.AcceptVisitor(_formatter)}'."));
            }
        }
        
    }
}


================================================
File: src/OldRod.Core/CodeGen/CilCodeGeneratorException.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;

namespace OldRod.Core.CodeGen
{
    public class CilCodeGeneratorException : Exception
    {
        public CilCodeGeneratorException(string message) 
            : base(message)
        {
        }

        public CilCodeGeneratorException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}


================================================
File: src/OldRod.Core/CodeGen/CilMethodBodyGenerator.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;

namespace OldRod.Core.CodeGen
{
    public class CilMethodBodyGenerator
    {
        private readonly VMConstants _constants;
        private readonly TypeDefinition _flagHelperType;

        public CilMethodBodyGenerator(VMConstants constants, TypeDefinition flagHelperType)
        {
            _constants = constants ?? throw new ArgumentNullException(nameof(constants));
            _flagHelperType = flagHelperType ?? throw new ArgumentNullException(nameof(flagHelperType));
        }

        public bool EnableStackVerification
        {
            get;
            set;
        } = true;

        public bool EnableExceptionHandlerValidation
        {
            get;
            set;
        } = true;

        public CilMethodBody Compile(MethodDefinition method, CilCompilationUnit unit)
        {
            var methodBody = new CilMethodBody(method);
            
            var context = new CodeGenerationContext(methodBody, _constants, unit.FlagVariable, _flagHelperType);
            
            var cilGenerator = new CilCodeGenerator(context);
            context.CodeGenerator = cilGenerator;
            
            // Traverse and recompile the AST.
            methodBody.Instructions.AddRange(unit.AcceptVisitor(cilGenerator));
            
            // Add variables to the method body.
            if (context.Variables.Count > 0)
            {
                foreach (var variable in context.Variables.Values)
                    methodBody.LocalVariables.Add(variable);
                methodBody.InitializeLocals = true;
            }

            methodBody.Instructions.OptimizeMacros();
            
            // Add all generated exception handlers to the method body.
            var handlers = context.ExceptionHandlers.Values.ToList();
            handlers.Sort(new EHComparer());
            foreach (var handler in handlers)
            {
                if (EnableExceptionHandlerValidation)
                    AssertValidityExceptionHandler(method, handler);
                methodBody.ExceptionHandlers.Add(handler);
            }

            if (!EnableStackVerification)
            {
                methodBody.ComputeMaxStackOnBuild = false;
                methodBody.MaxStack = ushort.MaxValue;
            }
            
            return methodBody;
        }

        private static void AssertValidityExceptionHandler(MethodDefinition method, CilExceptionHandler handler)
        {
            if (handler.TryStart == null
                || handler.TryEnd == null
                || handler.HandlerStart == null
                || handler.HandlerEnd == null)
            {
                throw new CilCodeGeneratorException(
                    $"Detected an incomplete exception handler in the generated method body of {method}. "
                    + $"This could be a bug in the code generator.",
                    new NullReferenceException("One or more of the EH boundaries was set to null."));
            }

            switch (handler.HandlerType)
            {
                case CilExceptionHandlerType.Exception:
                    if (handler.ExceptionType == null)
                    {
                        throw new CilCodeGeneratorException(
                            $"Detected an incomplete exception handler in the generated method body of {method}. "
                            + $"This could be a bug in the code generator.",
                            new NullReferenceException("Expected an exception type in a try-catch construct."));
                    }
                    break;
                
                case CilExceptionHandlerType.Filter:
                    if (handler.FilterStart == null)
                    {
                        throw new CilCodeGeneratorException(
                            $"Detected an incomplete exception handler in the generated method body of {method}. "
                            + $"This could be a bug in the code generator.",
                            new NullReferenceException("Expected a filter start in a try-filter construct."));
                    }
                    break;
                
                case CilExceptionHandlerType.Finally:
                case CilExceptionHandlerType.Fault:
                    if (handler.ExceptionType != null || handler.FilterStart != null)
                    {
                        throw new CilCodeGeneratorException(
                            $"Detected an exception handler with too many parameters in the generated method body of {method}. "
                            + $"This could be a bug in the code generator.");
                    }
                    break;
                
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

    }
}


================================================
File: src/OldRod.Core/CodeGen/CodeGenerationContext.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Collections;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Disassembly.DataFlow;
using Rivers;

namespace OldRod.Core.CodeGen
{
    public class CodeGenerationContext
    {
        private readonly CilVariable _flagVariable;
        private readonly CilVariable _arg0;
        private readonly CilVariable _arg1;
        private readonly CilVariable _result;
        private bool _intermediateVariablesAdded;

        public CodeGenerationContext(CilMethodBody methodBody, VMConstants constants, CilVariable flagVariable,
            TypeDefinition flagHelperType)
        {
            MethodBody = methodBody;
            Constants = constants;
            _flagVariable = flagVariable;
            
            VmHelperType = flagHelperType;

            ReferenceImporter = new ReferenceImporter(TargetModule);

            _arg0 = new CilVariable("__arg0", TargetModule.CorLibTypeFactory.UInt32);
            _arg1 = new CilVariable("__arg1", TargetModule.CorLibTypeFactory.UInt32);
            _result = new CilVariable("__result", TargetModule.CorLibTypeFactory.UInt32);
        }

        public ModuleDefinition TargetModule => MethodBody.Owner.Module;

        public CilMethodBody MethodBody
        {
            get;
        }

        public ReferenceImporter ReferenceImporter
        {
            get;
        }

        public VMConstants Constants
        {
            get;
        }

        public CilCodeGenerator CodeGenerator
        {
            get;
            set;
        }

        public TypeDefinition VmHelperType
        {
            get;
        }

        public IDictionary<Node, CilInstruction> BlockHeaders
        {
            get;
        } = new Dictionary<Node, CilInstruction>();

        public IDictionary<CilVariable, CilLocalVariable> Variables
        {
            get;
        } = new Dictionary<CilVariable, CilLocalVariable>();

        public IDictionary<CilParameter, Parameter> Parameters
        {
            get;
        } = new Dictionary<CilParameter, Parameter>();
        
        public IDictionary<EHFrame, CilExceptionHandler> ExceptionHandlers
        {
            get;
        } = new Dictionary<EHFrame, CilExceptionHandler>();

        private void EnsureIntermediateVariablesAdded()
        {
            if (!_intermediateVariablesAdded)
            {
                _intermediateVariablesAdded = true;
                Variables.Add(_arg0, new CilLocalVariable(_arg0.VariableType));
                Variables.Add(_arg1, new CilLocalVariable(_arg1.VariableType));
                Variables.Add(_result, new CilLocalVariable(_result.VariableType));
            }
            
            if (_flagVariable != null && !Variables.ContainsKey(_flagVariable))
                Variables.Add(_flagVariable, new CilLocalVariable(_flagVariable.VariableType));
        }
        
        public IEnumerable<CilInstruction> BuildFlagAffectingExpression32(
            IEnumerable<CilInstruction> argument,
            IEnumerable<CilInstruction> @operator,
            byte mask,
            bool pushResult = true)
        {  
            EnsureIntermediateVariablesAdded();

            var result = new List<CilInstruction>();
            
            result.AddRange(argument);
            result.Add(new CilInstruction(CilOpCodes.Stloc, Variables[_arg0]));

            result.Add(new CilInstruction(CilOpCodes.Ldloc, Variables[_arg0]));
            result.AddRange(@operator);
            result.Add(new CilInstruction(CilOpCodes.Stloc, Variables[_result]));

            var updateFl = VmHelperType.Methods.First(x =>
                x.Name == "UpdateFL"
                && x.Parameters[0].ParameterType.IsTypeOf("System", "UInt32"));

            result.AddRange(new[]
            {
                new CilInstruction(CilOpCodes.Ldloc, Variables[_arg0]),
                new CilInstruction(CilOpCodes.Ldloc, Variables[_arg0]),
                new CilInstruction(CilOpCodes.Ldloc, Variables[_result]),
                new CilInstruction(CilOpCodes.Ldloc, Variables[_result]),
                new CilInstruction(CilOpCodes.Ldloca, Variables[_flagVariable]),
                CilInstruction.CreateLdcI4(mask),
                new CilInstruction(CilOpCodes.Call, updateFl),
            });
            
            if (pushResult)
                result.Add(new CilInstruction(CilOpCodes.Ldloc, Variables[_result]));

            return result;
        }

        public IEnumerable<CilInstruction> BuildFlagAffectingExpression32(
            IEnumerable<CilInstruction> argument0,
            IEnumerable<CilInstruction> argument1,
            IEnumerable<CilInstruction> @operator,
            byte mask,
            bool invertedOrder = false,
            bool pushResult = true)
        {
            EnsureIntermediateVariablesAdded();
            
            var result = new List<CilInstruction>();

            result.AddRange(argument0);
            result.Add(new CilInstruction(CilOpCodes.Stloc, Variables[_arg0]));
            result.AddRange(argument1);
            result.Add(new CilInstruction(CilOpCodes.Stloc, Variables[_arg1]));

            result.Add(new CilInstruction(CilOpCodes.Ldloc, Variables[_arg0]));
            result.Add(new CilInstruction(CilOpCodes.Ldloc, Variables[_arg1]));
            result.AddRange(@operator);
            result.Add(new CilInstruction(CilOpCodes.Stloc, Variables[_result]));

            var updateFl = VmHelperType.Methods.First(x =>
                x.Name == "UpdateFL"
                && x.Parameters[0].ParameterType.IsTypeOf("System", "UInt32"));

            if (invertedOrder)
            {
                result.AddRange(new[]
                {
                    new CilInstruction(CilOpCodes.Ldloc, Variables[_result]),
                    new CilInstruction(CilOpCodes.Ldloc, Variables[_arg1]),
                    new CilInstruction(CilOpCodes.Ldloc, Variables[_arg0]),
                    new CilInstruction(CilOpCodes.Ldloc, Variables[_result]),
                });
            }
            else
            {
                result.AddRange(new[]
                {
                    new CilInstruction(CilOpCodes.Ldloc, Variables[_arg0]),
                    new CilInstruction(CilOpCodes.Ldloc, Variables[_arg1]),
                    new CilInstruction(CilOpCodes.Ldloc, Variables[_result]),
                    new CilInstruction(CilOpCodes.Ldloc, Variables[_result]),
                });
            }

            result.AddRange(new[]
            {
                new CilInstruction(CilOpCodes.Ldloca, Variables[_flagVariable]),
                CilInstruction.CreateLdcI4(mask),
                new CilInstruction(CilOpCodes.Call, updateFl),
            });
            
            if (pushResult)
                result.Add(new CilInstruction(CilOpCodes.Ldloc, Variables[_result]));

            return result;
        }
    }
}


================================================
File: src/OldRod.Core/CodeGen/EHComparer.cs
================================================
using System.Collections.Generic;
using AsmResolver.DotNet.Code.Cil;

namespace OldRod.Core.CodeGen
{
    public class EHComparer : IComparer<CilExceptionHandler>
    {
        public int Compare(CilExceptionHandler x, CilExceptionHandler y)
        {
            if (x == null || y == null)
                return 0;

            // Make sure x starts at a later point than y.
            if (x.TryStart.Offset < y.TryStart.Offset)
                return -Compare(y, x);
            
            // If x also ends earlier, then we have a nested EH. x should be prioritized. 
            if (x.TryEnd.Offset < y.TryEnd.Offset)
                return -1;

            // If x does not have the same try block, then we know that x appears after y.
            if (x.TryEnd.Offset != y.TryEnd.Offset)
                return 1;
            
            // Prioritize handler that starts earlier. 
            return x.HandlerStart.Offset.CompareTo(y.HandlerStart.Offset);
        }
        
    }
}


================================================
File: src/OldRod.Core/CodeGen/VmHelper.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Reflection;

// Disable warnings for unassigned / unused fields.
#pragma warning disable 169
#pragma warning disable 649

namespace OldRod.Core.CodeGen
{
    public static class VmHelper
    { 
        private static readonly byte FL_OVERFLOW;
        private static readonly byte FL_CARRY;
        private static readonly byte FL_ZERO;
        private static readonly byte FL_SIGN;
        private static readonly byte FL_UNSIGNED;
        private static readonly byte FL_BEHAV1;
        private static readonly byte FL_BEHAV2;
        private static readonly byte FL_BEHAV3;

        static VmHelper()
        {
            // Filled in by the compiler.
        }
        
        public static void UpdateFL(uint op1, uint op2, uint flResult, uint result, ref byte fl, byte mask)
        {
            const ulong SignMask = 1U << 31;
            byte flag = 0;
            if(result == 0)
                flag |= FL_ZERO;
            if((result & SignMask) != 0)
                flag |= FL_SIGN;
            if(((op1 ^ flResult) & (op2 ^ flResult) & SignMask) != 0)
                flag |= FL_OVERFLOW;
            if(((op1 ^ ((op1 ^ op2) & (op2 ^ flResult))) & SignMask) != 0)
                flag |= FL_CARRY;
            fl = (byte) ((fl & ~mask) | (flag & mask));
        }

        public static void UpdateFL(ulong op1, ulong op2, ulong flResult, ulong result, ref byte fl, byte mask)
        {
            const ulong SignMask = 1U << 63;
            byte flag = 0;
            if(result == 0)
                flag |= FL_ZERO;
            if((result & SignMask) != 0)
                flag |= FL_SIGN;
            if(((op1 ^ flResult) & (op2 ^ flResult) & SignMask) != 0)
                flag |= FL_OVERFLOW;
            if(((op1 ^ ((op1 ^ op2) & (op2 ^ flResult))) & SignMask) != 0)
                flag |= FL_CARRY;
            fl = (byte) ((fl & ~mask) | (flag & mask));
        }

        public static object ConvertToVmType(object obj)
        {
            return obj != null ? ConvertToVmType(obj, obj.GetType()) : null;
        }
        
        public static unsafe object ConvertToVmType(object obj, Type type)
        {
            while (true)
            {
                if (type.IsEnum)
                {
                    // For enums we need the underlying type.
                    var elemType = Enum.GetUnderlyingType(type);
                    obj = Convert.ChangeType(obj, elemType);
                    type = elemType;
                }
                else
                {
                    // Convert any signed type to its unsigned form, and box it again.
                    switch (Type.GetTypeCode(type))
                    {
                        case TypeCode.SByte:
                            return (byte) (sbyte) obj;
                        case TypeCode.Boolean:
                            return (byte) ((bool) obj ? 1 : 0);
                        case TypeCode.Int16:
                            return (ushort) (short) obj;
                        case TypeCode.Char:
                            return (char) obj;
                        case TypeCode.Int32:
                            return (uint) (int) obj;
                        case TypeCode.Int64:
                            return (ulong) (long) obj;
                        default:
                            if (obj is Pointer)
                                return (ulong) Pointer.Unbox(obj);
                            if (obj is IntPtr signedPointer)
                                return signedPointer;
                            if (obj is UIntPtr unsignedPointer)
                                return (ulong) unsignedPointer;
                            return obj;
                    }
                }
            }
        }
        
    }
}


================================================
File: src/OldRod.Core/CodeGen/VmHelperGenerator.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Cloning;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;

namespace OldRod.Core.CodeGen
{
    public class VmHelperGenerator
    {
        private static readonly TypeDefinition VmHelperType;
        
        static VmHelperGenerator()
        {
            var module = ModuleDefinition.FromFile(typeof(VmHelper).Assembly.Location);
            VmHelperType = module.TopLevelTypes.First(x => x.Name == nameof(VmHelper));
        }
        
        public static TypeDefinition ImportFlagHelper(ModuleDefinition module, VMConstants constants)
        {
            // Clone flag helper class.
            var cloner = new MemberCloner(module, context => new UseExistingCorlibReferenceImporter(context));
            cloner.Include(VmHelperType);
            var result = cloner.Clone();
            var flagHelperType = result.ClonedMembers.OfType<TypeDefinition>().First();
            
            module.Assembly.Modules[0].TopLevelTypes.Add(flagHelperType);

            // Obtain static cctor.
            var constructor = flagHelperType.Methods.First(x => x.IsConstructor && x.IsStatic);
            var instructions = constructor.CilMethodBody.Instructions;
            instructions.Clear();

            // Assign values of flags to the fields.
            foreach (var entry in constants.Flags.OrderBy(x => x.Value))
            {
                instructions.Add(CilInstruction.CreateLdcI4(entry.Key));
                instructions.Add(new CilInstruction(CilOpCodes.Stsfld,
                    flagHelperType.Fields.First(x => x.Name == "FL_" + entry.Value.ToString())));
            }

            instructions.Add(new CilInstruction(CilOpCodes.Ret));

            return flagHelperType;
        }

        private sealed class UseExistingCorlibReferenceImporter : CloneContextAwareReferenceImporter
        {
            internal UseExistingCorlibReferenceImporter(MemberCloneContext context) : base(context) 
            {
            }

            protected override ITypeDefOrRef ImportType(TypeReference type)
            {
                var defAsm = type.Scope?.GetAssembly();
                if (defAsm is not null && defAsm.IsCorLib)
                    return new TypeReference(Context.Module, TargetModule.CorLibTypeFactory.CorLibScope, type.Namespace, type.Name);
                return base.ImportType(type);
            }
        }
    }
}


================================================
File: src/OldRod.Core/CodeGen/Blocks/BasicBlock.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.PE.DotNet.Cil;

namespace OldRod.Core.CodeGen.Blocks
{
    public class BasicBlock : Block
    {
        public BasicBlock(IEnumerable<CilInstruction> instructions)
        {
            Instructions = new List<CilInstruction>(instructions);
        }

        public IList<CilInstruction> Instructions
        {
            get;
        }

        public override IList<CilInstruction> GenerateInstructions()
        {
            return Instructions;
        }

        public override string ToString()
        {
            return $"{{\n{string.Join("\n", Instructions)}\n}}";
        }
    }
}


================================================
File: src/OldRod.Core/CodeGen/Blocks/Block.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.PE.DotNet.Cil;

namespace OldRod.Core.CodeGen.Blocks
{
    public abstract class Block
    {
        public abstract IList<CilInstruction> GenerateInstructions();
    }
}


================================================
File: src/OldRod.Core/CodeGen/Blocks/BlockGenerator.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Disassembly.ControlFlow;
using OldRod.Core.Disassembly.DataFlow;
using Rivers;
using Rivers.Analysis;
using Rivers.Analysis.Connectivity;

namespace OldRod.Core.CodeGen.Blocks
{
    public class BlockGenerator
    {
        private readonly ControlFlowGraph _cfg;
        private readonly CilCodeGenerator _generator;

        public BlockGenerator(ControlFlowGraph cfg, CilCodeGenerator generator)
        {
            _cfg = cfg ?? throw new ArgumentNullException(nameof(cfg));
            _generator = generator;
            
        }

        public IDictionary<Node, CilInstruction> BlockEntries
        {
            get;
        } = new Dictionary<Node, CilInstruction>();

        public IDictionary<Node, CilInstruction> BlockExits
        {
            get;
        } = new Dictionary<Node, CilInstruction>();

        public ScopeBlock CreateBlock()
        {
            var sorter = new TopologicalSorter(n =>
            {
                return n.OutgoingEdges
                    .OrderByDescending(IsNormalEdge)
                    .Select(e => e.Target)
                    .ToList();
            });

            var sorting = sorter.GetTopologicalSorting(_cfg.Entrypoint);
            
            var rootScope = new ScopeBlock();
            foreach (var node in sorting.Reverse())
                rootScope.Blocks.Add(CreateBasicBlock(node));
            
            return rootScope;
        }
        
        private BasicBlock CreateBasicBlock(Node node)
        {
            var astBlock = (CilAstBlock) node.UserData[CilAstBlock.AstBlockProperty];
            var instructions = astBlock.AcceptVisitor(_generator);

            BlockEntries[node] = instructions[0];
            BlockExits[node] = instructions[instructions.Count - 1];
            
            return new BasicBlock(instructions);
        }

        private static bool IsNormalEdge(Edge edge)
        {
            if (!edge.UserData.TryGetValue(ControlFlowGraph.ConditionProperty, out var c))
                return true;

            var conditions = (ICollection<int>) c;

            return !conditions.Contains(ControlFlowGraph.ExceptionConditionLabel)
                   && !conditions.Contains(ControlFlowGraph.EndFinallyConditionLabel);
        }
        
    }
}


================================================
File: src/OldRod.Core/CodeGen/Blocks/ExceptionHandlerBlock.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.PE.DotNet.Cil;

namespace OldRod.Core.CodeGen.Blocks
{
    public class ExceptionHandlerBlock : Block
    {
        public ScopeBlock TryBlock
        {
            get;
            set;
        }

        public ScopeBlock HandlerBlock
        {
            get;
            set;
        }

        public override IList<CilInstruction> GenerateInstructions()
        {
            var result = new List<CilInstruction>();
            result.AddRange(TryBlock.GenerateInstructions());
            result.AddRange(HandlerBlock.GenerateInstructions());
            return result;
        }

        public override string ToString()
        {
            return $".try\n{TryBlock} handler {HandlerBlock}";
        }
    }
}


================================================
File: src/OldRod.Core/CodeGen/Blocks/ScopeBlock.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.PE.DotNet.Cil;

namespace OldRod.Core.CodeGen.Blocks
{
    public class ScopeBlock : Block
    {
        public IList<Block> Blocks
        {
            get;
        } = new List<Block>();

        public override IList<CilInstruction> GenerateInstructions()
        {
            return Blocks.SelectMany(x => x.GenerateInstructions()).ToList();
        }

        public override string ToString()
        {
            return string.Join("\n", Blocks);
        }
    }
}


================================================
File: src/OldRod.Core/CodeGen/Blocks/TopologicalSorter.cs
================================================
using System.Collections.Generic;
using Rivers;

namespace OldRod.Core.CodeGen.Blocks
{
    /// <summary>
    /// Provides a mechanism for sorting nodes in a graph, such that for every edge from node A to node B in the graph we
    /// have that node A comes before node B in the final ordering, also known as a topological sorting of the graph.
    /// </summary>
    public class TopologicalSorter
    {
        /// <summary>
        /// Represents the method that obtains an ordered list of children of a node in a graph. 
        /// </summary>
        /// <param name="node">The node to list the children for.</param>
        public delegate IReadOnlyList<Node> ChildrenLister(Node node);

        /// <summary>
        /// Creates a new instance of the <see cref="TopologicalSorter"/> class.
        /// </summary>
        /// <param name="childrenLister">The method to call when obtaining an ordered list of children of a node.</param>
        public TopologicalSorter(ChildrenLister childrenLister)
        {
            TopologicalChildrenLister = childrenLister;
        }
        
        /// <summary>
        /// Gets the method to call when obtaining an ordered list of children of a node.
        /// </summary>
        public ChildrenLister TopologicalChildrenLister
        {
            get;
        }

        /// <summary>
        /// Obtains the topological sorting of a graph, using the provided node as the root.
        /// </summary>
        /// <param name="root">The root of the graph.</param>
        /// <returns>
        /// An ordered list of nodes, such that any node A appears before any other node B if the edge A to B
        /// exists in the graph.
        /// </returns>
        public IEnumerable<Node> GetTopologicalSorting(Node root)
        {
            // We find a topological sorting of the node using the altered DFS algorithm as described here:
            // https://en.wikipedia.org/wiki/Topological_sorting
            // The algorithm used to be recursive, but was rewritten to be iterative to avoid stack overflows. 

            var result = new List<Node>();
            var permanent = new HashSet<Node>();
            var temporary = new HashSet<Node>();

            var agenda = new Stack<State>();
            agenda.Push(new State(root, false));

            while (agenda.Count > 0)
            {
                var current = agenda.Pop();
                if (!current.HasTraversedDescendants)
                {
                    if (permanent.Contains(current.Node) || temporary.Contains(current.Node))
                        continue;

                    temporary.Add(current.Node);

                    // Schedule remaining steps. We push this before pushing dependencies so it gets executed after
                    // the dependencies are traversed.
                    agenda.Push(new State(current.Node, true));

                    // Schedule children to be processed.
                    var children = TopologicalChildrenLister(current.Node);
                    for (int i = children.Count - 1; i >= 0; i--)
                        agenda.Push(new State(children[i], false));
                }
                else
                {
                    temporary.Remove(current.Node);
                    permanent.Add(current.Node);
                    result.Add(current.Node);
                }
            }

            return result;
        }

        private readonly struct State
        {
            public State(Node node, bool hasTraversedDescendants)
            {
                Node = node;
                HasTraversedDescendants = hasTraversedDescendants;
            }
            
            public Node Node
            {
                get;
            }

            public bool HasTraversedDescendants
            {
                get;
            }
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/DisassemblyException.cs
================================================
using System;

namespace OldRod.Core.Disassembly
{
    public class DisassemblyException : Exception
    {
        public DisassemblyException(string message) 
            : base(message)
        {
        }

        public DisassemblyException(string message, Exception innerException) 
            : base(message, innerException)
        {
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/InstructionDecoder.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using AsmResolver.IO;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly
{
    public class InstructionDecoder
    {
        private readonly VMConstants _constants;
        private BinaryStreamReader _reader;

        public InstructionDecoder(VMConstants constants, BinaryStreamReader reader)
            : this(constants, reader, 0)
        {
        }
        
        public InstructionDecoder(VMConstants constants, BinaryStreamReader reader, uint key)
        {
            _constants = constants;
            _reader = reader;
            CurrentKey = key;
        }

        public ulong ReaderOffset 
        {
            get => _reader.Offset;
            set => _reader.Offset = value;
        }

        public uint CurrentKey
        {
            get;
            set;
        }
        
        public byte? SMCTrampolineKey
        {
            get;
            set;
        }

        public ILInstruction ReadNextInstruction()
        {
            int offset = (int) _reader.Offset;
            var opcode = ReadNextOpCode();
            var operand = ReadNextOperand(opcode.OperandType);
            return new ILInstruction(offset, opcode, operand);
        }
        
        public ILInstruction ReadNextInstruction(byte smcTrampolineKey)
        {
            SMCTrampolineKey = smcTrampolineKey;
            var instruction = ReadNextInstruction();
            SMCTrampolineKey = null;
            return instruction;
        }
        
        public bool TryReadNextInstruction(out ILInstruction instruction)
        {
            int offset = (int) _reader.Offset;
            if (TryReadNextOpCode(out var opcode) && TryReadNextOperand(opcode.OperandType, out var operand))
            {
                instruction = new ILInstruction(offset, opcode, operand);
                return true;
            }

            instruction = null;
            return false;
        }

        private byte ReadByte()
        {
            uint key = CurrentKey;
            byte rawValue = _reader.ReadByte();
            
            if (SMCTrampolineKey.HasValue)
                rawValue ^= SMCTrampolineKey.Value;

            byte b = (byte) (rawValue ^ key);
            key = key * _constants.KeyScalar + b;
            CurrentKey = key;
            return b;
        }

        public byte ReadNonEncryptedByte() 
        {
            return _reader.ReadByte();
        }

        private ILOpCode ReadNextOpCode()
        {
            long offset = (long) _reader.Offset;

            if (TryReadNextOpCode(out var opcode))
                return opcode;
            
            throw new DisassemblyException($"Byte at offset {offset:X4} not recognized as a valid opcode.");
        }

        private bool TryReadNextOpCode(out ILOpCode opCode) 
        {
            byte b = ReadByte();
            ReadByte();

            if (!_constants.OpCodes.TryGetValue(b, out var mappedOpCode)) 
            {
                opCode = default;
                return false;
            }

            opCode = ILOpCodes.All[(int)mappedOpCode];
            return true;
        }

        private bool TryReadRegister(out VMRegisters register)
        {
            return _constants.Registers.TryGetValue(ReadByte(), out register);
        }

        private uint ReadDword()
        {
            return ReadByte()
                   | ((uint) ReadByte() << 8)
                   | ((uint) ReadByte() << 16)
                   | ((uint) ReadByte() << 24);
        }

        private ulong ReadQword()
        {
            return ReadByte()
                   | ((ulong) ReadByte() << 8)
                   | ((ulong) ReadByte() << 16)
                   | ((ulong) ReadByte() << 24)
                   | ((ulong) ReadByte() << 32)
                   | ((ulong) ReadByte() << 40)
                   | ((ulong) ReadByte() << 48)
                   | ((ulong) ReadByte() << 56);
        }

        private object ReadNextOperand(ILOperandType operandType) 
        {
            if (TryReadNextOperand(operandType, out object operand))
                return operand;
            throw new DisassemblyException($"Failed to read {operandType} operand!");
        }
        
        private bool TryReadNextOperand(ILOperandType operandType, out object operand)
        {
            operand = null;
            switch (operandType)
            {
                case ILOperandType.None:
                    return true;
                case ILOperandType.Register:
                    if (TryReadRegister(out var register)) 
                    {
                        operand = register;
                        return true;
                    }
                    return false;
                case ILOperandType.ImmediateDword:
                    operand = ReadDword();
                    return true;
                case ILOperandType.ImmediateQword:
                    operand = ReadQword();
                    return true;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/Annotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Disassembly.Annotations
{
    public class Annotation
    {
        public int InferredPushCount
        {
            get;
            set;
        }

        public int InferredPopCount
        {
            get;
            set;
        }

        public int InferredStackDelta => InferredPushCount - InferredPopCount; 

        public override string ToString()
        {
            return $"Pop: {InferredPopCount.ToString()}, Push: {InferredPushCount.ToString()}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/BoxAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Annotations
{
    public class BoxAnnotation : TypeAnnotation
    {
        public BoxAnnotation(ITypeDefOrRef type, object value)
            : base(VMCalls.BOX, type)
        {
            Value = value;
        }

        public object Value
        {
            get;
        }

        public bool IsUnknownValue => Value == null;

        public override string ToString()
        {
            return $"BOX {Type} ({(IsUnknownValue ? "?" : Value)})";
        }

    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/CallAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Disassembly.Inference;

namespace OldRod.Core.Disassembly.Annotations
{
    public class CallAnnotation : Annotation
    {
        public VMFunction Function
        {
            get;
            set;
        }

        public override string ToString()
        {
            return $"Call function_{Function.EntrypointAddress:X4}";
        }
        
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/CastAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Annotations
{
    public class CastAnnotation : TypeAnnotation
    {
        public CastAnnotation(ITypeDefOrRef type, bool isSafeCast) 
            : base(VMCalls.CAST, type)
        {
            IsSafeCast = isSafeCast;
        }

        public bool IsSafeCast
        {
            get;
        }

        public override string ToString()
        {
            return $"{VMCall.ToString()} {(IsSafeCast ? "safe " : "")}{Type}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/ECallAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Annotations
{
    public class ECallAnnotation : VCallAnnotation, IMemberProvider
    {
        public ECallAnnotation(IMethodDescriptor method, VMECallOpCode opCode)
            : base(VMCalls.ECALL, method.Signature.ReturnType.ToVMType())
        {
            Method = method;
            OpCode = opCode;
        }
       
        public IMethodDescriptor Method
        {
            get;
        }
        
        IMemberDescriptor IMemberProvider.Member => Method;

        public bool RequiresSpecialAccess
        {
            get
            {
                var methodDef = Method.Resolve();
                if (methodDef is null)
                    return false;
                
                return methodDef.IsPrivate
                       || methodDef.IsFamily
                       || methodDef.IsFamilyAndAssembly
                       || methodDef.IsFamilyOrAssembly
                       || methodDef.DeclaringType.RequiresSpecialAccess();
            }   
        }

        public VMECallOpCode OpCode
        {
            get;
        }

        public bool IsConstrained => OpCode == VMECallOpCode.CALLVIRT_CONSTRAINED;

        public ITypeDefOrRef ConstrainedType
        {
            get;
            set;
        }
        
        public override string ToString()
        {
            return IsConstrained 
                ? $"{OpCode} ({ConstrainedType}) {Method}" 
                : $"{OpCode} {Method}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/FieldAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Annotations
{
    internal class FieldAnnotation : VCallAnnotation, IMemberProvider
    {
        public FieldAnnotation(VMCalls vmCall, IFieldDescriptor field)
            : base(vmCall, field.Signature.FieldType.ToVMType())
        {
            Field = field;
        }

        public IFieldDescriptor Field
        {
            get;
        }

        IMemberDescriptor IMemberProvider.Member => Field;

        public bool RequiresSpecialAccess
        {
            get
            {
                var fieldDef = Field.Resolve();
                if (fieldDef is null)
                    return false;
                
                return fieldDef.IsPrivate
                       || fieldDef.IsFamily
                       || fieldDef.IsFamilyAndAssembly
                       || fieldDef.IsFamilyOrAssembly
                       || fieldDef.DeclaringType.RequiresSpecialAccess();
            }   
        }
        public bool IsAddress
        {
            get;
            set;
        }
        
        public override string ToString()
        {
            return $"{VMCall} {Field}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/IMemberProvider.cs
================================================
using AsmResolver.DotNet;

namespace OldRod.Core.Disassembly.Annotations
{
    public interface IMemberProvider
    {
        IMemberDescriptor Member
        {
            get;
        }
        
        bool RequiresSpecialAccess
        {
            get;
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/JumpAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Disassembly.Annotations
{
    public class JumpAnnotation : Annotation
    {
        public JumpAnnotation()
            : this(Enumerable.Empty<ulong>())
        {
        }

        public JumpAnnotation(params ulong[] targets)
            : this(targets.AsEnumerable())
        {    
        }
        
        public JumpAnnotation(IEnumerable<ulong> inferredJumpTargets)
        {
            InferredJumpTargets = new List<ulong>(inferredJumpTargets);
        }

        public IList<ulong> InferredJumpTargets
        {
            get;
        }

        public override string ToString()
        {
            return InferredJumpTargets.Count == 1
                ? $"Jump to {InferredJumpTargets[0]:X4}"
                : $"Jump to one of {{{string.Join(", ", InferredJumpTargets.Select(x => x.ToString("X4")))}}}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/LdftnAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Core.Disassembly.Annotations
{
    public class LdftnAnnotation : VCallAnnotation
    {
        public LdftnAnnotation(VMFunction function, VMFunctionSignature signature) 
            : base(VMCalls.LDFTN, VMType.Pointer)
        {
            Function = function;
            Signature = signature;
            Method = null;
            IsVirtual = false;
        }

        public LdftnAnnotation(IMethodDescriptor method, bool isVirtual) 
            : base(VMCalls.LDFTN, VMType.Pointer)
        {
            Function = null;
            Signature = null;
            Method = method;
            IsVirtual = isVirtual;
        }

        public bool IsIntraLinked => Function != null;

        public VMFunction Function
        {
            get;
        }

        public VMFunctionSignature Signature
        {
            get;
        }

        public IMethodDescriptor Method
        {
            get;
        }

        public bool IsVirtual
        {
            get;
        }

        public override string ToString()
        {
            return IsIntraLinked
                ? $"{VMCall} function_{Function.EntrypointAddress:X4} ({Signature})"
                : $"{VMCall} {Method}";
        }
    }
    
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/ThrowAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Annotations
{
    public class ThrowAnnotation : VCallAnnotation
    {
        public ThrowAnnotation(bool isRethrow)
            : base(VMCalls.THROW, VMType.Unknown)
        {
            IsRethrow = isRethrow;
        }

        public bool IsRethrow
        {
            get;
        }

        public override string ToString()
        {
            return IsRethrow ? "RETHROW" : "THROW";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/TokenAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Annotations
{
    public class TokenAnnotation : VCallAnnotation
    {
        public TokenAnnotation(IMetadataMember member)
            : base(VMCalls.TOKEN, VMType.Pointer)
        {
            Member = member;
        }
       
        public IMetadataMember Member
        {
            get;
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/TypeAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Annotations
{
    public class TypeAnnotation : VCallAnnotation, IMemberProvider
    {
        public TypeAnnotation(VMCalls vmCall, ITypeDefOrRef type)
            : base(vmCall, VMType.Object)
        {
            Type = type;
        }
        
        public ITypeDefOrRef Type
        {
            get;
        }

        IMemberDescriptor IMemberProvider.Member => Type;


        public bool RequiresSpecialAccess => Type.RequiresSpecialAccess();

        public override string ToString()
        {
            return $"{VMCall} {Type}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/UnboxAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Annotations
{
    public class UnboxAnnotation : TypeAnnotation
    {
        public UnboxAnnotation(ITypeDefOrRef type, bool IsUnboxPointer)
            : base(VMCalls.UNBOX, type)
        {
            this.IsUnboxPointer = IsUnboxPointer;
        }

        public bool IsUnboxPointer
        {
            get;
        }

        public override string ToString()
        {
            return $"{VMCall} {(IsUnboxPointer ? "ptr " : "")}{Type}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Annotations/VCallAnnotation.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Core.Disassembly.Annotations
{
    public class VCallAnnotation : Annotation
    {
        public VCallAnnotation(VMCalls vmCall, VMType returnType)
        {
            VMCall = vmCall;
            ReturnType = returnType;
        }
        
        public VMCalls VMCall
        {
            get;
        }

        public VMType ReturnType
        {
            get;
        }

        public override string ToString()
        {
            return VMCall.ToString();
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/ControlFlow/ControlFlowGraph.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Disassembly.DataFlow;
using Rivers;

namespace OldRod.Core.Disassembly.ControlFlow
{
    public class ControlFlowGraph : Graph
    {
        // Edge condition labels.
        public const string ConditionProperty = "label";
        public const int ExceptionConditionLabel = -1;
        public const int EndFinallyConditionLabel = -2;
        
        // Node EH labels.
        public const string TopMostEHProperty = "topmosteh";
        public const string TryBlockProperty = "try";
        public const string HandlerBlockProperty = "handler";
        public const string TryStartProperty = "trystart";
        public const string HandlerStartProperty = "handlerstart";
        public const string FilterStartProperty = "filterstart";

        public Node Entrypoint
        {
            get;
            set;
        }

        public Node FindBlockWithOffset(long offset)
        {
            foreach (var node in Nodes)
            {
                if (node.UserData[ILBasicBlock.BasicBlockProperty] is ILBasicBlock block
                    && block.Instructions[0].Offset >= offset
                    && block.Instructions[block.Instructions.Count - 1].Offset < offset)
                {
                    return node;
                }
            }

            return null;
        }

        public string GetNodeName(long startOffset)
        {
            return $"Block_{startOffset:X4}";
        }

        public string GetClusterName(EHFrame frame)
        {
            return frame.ToString();
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/ControlFlow/ControlFlowGraphBuilder.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Annotations;
using OldRod.Core.Disassembly.DataFlow;
using OldRod.Core.Disassembly.Inference;
using Rivers;
using Rivers.Analysis;
using Rivers.Serialization.Dot;

namespace OldRod.Core.Disassembly.ControlFlow
{
    public class ControlFlowGraphBuilder
    {
        public const string Tag = "CFGBuilder";
        public ILogger Logger
        {
            get;
            set;
        } = EmptyLogger.Instance;

        public bool SalvageOnError
        {
            get;
            set;
        }
        
        public ControlFlowGraph BuildGraph(VMFunction function)
        {
            var graph = new ControlFlowGraph();

            CollectBlocks(graph, function.Instructions.Values, function.BlockHeaders);
            graph.Entrypoint = GetNode(graph, function.EntrypointAddress);
            ConnectNodes(graph);

            try
            {
                CreateEHClusters(graph);
                AddAbnormalEdges(graph);
            }
            catch (Exception ex) when (SalvageOnError)
            {
                Logger.Error(Tag,
                    $"Failed to create EH clusters in CFG of function_{function.EntrypointAddress:X4}. {ex.Message}");
            }

            return graph;
        }

        private Node GetNode(ControlFlowGraph graph, long offset)
        {
            string name = graph.GetNodeName(offset);
            
            if (!graph.Nodes.TryGetNode(name, out var node))
            {
                Logger.Error(Tag, $"Reference to an unexplored basic block IL_{offset:X4} found. Inserting dummy node.");
                node = graph.Nodes.Add(name);
            }

            return node;
        }

        private Edge CreateEdge(Node source, Node target, params int[] conditions)
        {
            ISet<int> edgeLabel = null;
            if (source.OutgoingEdges.TryGetEdge(target, out var edge))
            {
                edgeLabel = (ISet<int>) edge.UserData[ControlFlowGraph.ConditionProperty];
            }
            else
            {
                edge = new Edge(source, target);
                edgeLabel = new HashSet<int>();
                edge.UserData[ControlFlowGraph.ConditionProperty] = edgeLabel;
            }

            edgeLabel.UnionWith(conditions);
            return edge;
        }

        private T GetUserData<T>(Node node, string property)
        {
            if (!node.UserData.TryGetValue(property, out var value))
                return default(T);
            return (T) value;
        }

        private void CollectBlocks(ControlFlowGraph graph, ICollection<ILInstruction> instructions, ICollection<long> blockHeaders)
        {
            Node currentNode = null;
            ILBasicBlock currentBlock = null;
            foreach (var instruction in instructions.OrderBy(x => x.Offset))
            {
                // If current instruction is a basic block header, we start a new block. 
                if (currentNode == null || blockHeaders.Contains(instruction.Offset))
                {
                    currentNode = graph.Nodes.Add(graph.GetNodeName(instruction.Offset));
                    currentBlock = new ILBasicBlock();
                    currentNode.UserData[ILBasicBlock.BasicBlockProperty] = currentBlock;
                }

                // Add instruction to current block.
                currentBlock.Instructions.Add(instruction);

                // If next offset is also a header, we also create a new block.
                // This check is necessary as blocks might not appear in sequence after each other. 
                if (blockHeaders.Contains(instruction.Offset + instruction.Size))
                    currentNode = null;
            }
        }

        private void ConnectNodes(ControlFlowGraph graph)
        {
            foreach (var node in graph.Nodes.ToArray())
            {
                var block = GetUserData<ILBasicBlock>(node, ILBasicBlock.BasicBlockProperty);
                if (block != null)
                {
                    var last = block.Instructions[block.Instructions.Count - 1];
                    AddNormalEdges(graph, last.OpCode.FlowControl, node);
                }
            }
        }

        private void AddNormalEdges(ControlFlowGraph graph, ILFlowControl flowControl, Node node)
        {
            // Get the last instruction of the block.
            var block = GetUserData<ILBasicBlock>(node, ILBasicBlock.BasicBlockProperty);
            var last = block.Instructions[block.Instructions.Count - 1];
            long nextOffset = last.Offset + last.Size;
            switch (flowControl)
            {
                case ILFlowControl.Next:
                    AddFallThroughEdge(graph, node, nextOffset);
                    break;
                case ILFlowControl.Jump:
                    AddJumpTargetEdges(graph, node, last);
                    break;
                case ILFlowControl.ConditionalJump:
                    AddJumpTargetEdges(graph, node, last);
                    AddFallThroughEdge(graph, node, nextOffset);
                    break;
                case ILFlowControl.Call:
                case ILFlowControl.Return:
                    break;
                case ILFlowControl.VCall:
                    var annotation = (VCallAnnotation) last.Annotation;
                    AddNormalEdges(graph, annotation?.VMCall.GetImpliedFlowControl() ?? ILFlowControl.Return, node);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void AddFallThroughEdge(ControlFlowGraph graph, Node node, long nextOffset)
        {
            node.OutgoingEdges.Add(GetNode(graph, nextOffset));
        }

        private void AddJumpTargetEdges(ControlFlowGraph graph, Node node, ILInstruction jump)
        {
            if (jump.Annotation is not JumpAnnotation jumpMetadata)
                return;

            for (int i = 0; i < jumpMetadata.InferredJumpTargets.Count; i++)
            {
                ulong target = jumpMetadata.InferredJumpTargets[i];
                var edge = CreateEdge(node, GetNode(graph, (long) target), i);
                graph.Edges.Add(edge);
            }
        }

        private void CreateEHClusters(ControlFlowGraph graph)
        {
            var clusters = new Dictionary<EHFrame, SubGraph>();
            
            foreach (var node in graph.Nodes.ToArray())
            {
                var block = GetUserData<ILBasicBlock>(node, ILBasicBlock.BasicBlockProperty);
                if (block == null)
                    continue;
                
                var state = block.Instructions[0].ProgramState;
                
                foreach (var frame in state.EHStack)
                {
                    if (!clusters.TryGetValue(frame, out var subGraph))
                    {
                        subGraph = new SubGraph(graph, graph.GetClusterName(frame));
                        subGraph.UserData[EHFrame.EHFrameProperty] = frame;
                        graph.SubGraphs.Add(subGraph);
                        clusters.Add(frame, subGraph);
                    }
                    
                    subGraph.Nodes.Add(node);
                }
            }
        }

        private void AddAbnormalEdges(ControlFlowGraph graph)
        {
            if (graph.SubGraphs.Count == 0)
                return;
            
            // Since exception handlers make it possible to transfer control to the handler block
            // at any time, we have these "abnormal edges" from each node in the try block 
            // to the first node in the handler block (or filter block).

            // First, add the initial abnormal handler edges from every try-start to the handler-start (or filter start).
            // This allows us to do some more dominator-magic, where we can just infer the handler body based
            // on the nodes dominated by the handler node.
            foreach (var subGraph in graph.SubGraphs.OrderBy(x => x.Nodes.Count))
            {
                var ehFrame = (EHFrame) subGraph.UserData[EHFrame.EHFrameProperty];

                // Find the try entry node.
                var tryEntry = GetNode(graph, (long) ehFrame.TryStart);
                tryEntry.UserData[ControlFlowGraph.TryStartProperty] = ehFrame;

                // Find the handler entry node.
                var handlerEntry = GetNode(graph, (long) ehFrame.HandlerAddress);
                handlerEntry.UserData[ControlFlowGraph.HandlerStartProperty] = ehFrame;

                // Add initial abnormal edge.
                if (ehFrame.Type != EHType.FILTER)
                {
                    // Jump straight to the handler entry.
                    AddAbnormalEdge(graph, tryEntry, ehFrame, handlerEntry);
                }
                else
                {
                    // Jump to the filter entry.
                    var filterEntry = GetNode(graph, (long) ehFrame.FilterAddress);
                    filterEntry.UserData[ControlFlowGraph.FilterStartProperty] = ehFrame;
                    AddAbnormalEdge(graph, tryEntry, ehFrame, filterEntry);
                    
                    // Connect all terminators of the filter block to the handler entry.
                    foreach (var terminator in FindReachableReturnNodes(filterEntry))
                        AddAbnormalEdge(graph, terminator, ehFrame, handlerEntry);
                }
            }

            // Obtain dominator info.
            var dominatorInfo = new DominatorInfo(graph.Entrypoint);            
            
            // Add all handler nodes to the cluster, and add abnormal edges for each try node to the handler start node.
            var handlerExits = new Dictionary<EHFrame, ICollection<Node>>();
            foreach (var subGraph in graph.SubGraphs.OrderBy(x => x.Nodes.Count))
            {
                var ehFrame = (EHFrame) subGraph.UserData[EHFrame.EHFrameProperty];
                var tryEntry = GetNode(graph, (long) ehFrame.TryStart);
                var handlerEntry = GetNode(graph, (long) ehFrame.HandlerAddress);

                // Determine the handler exits.
                var handlerBody = CollectHandlerNodes(handlerEntry, dominatorInfo.GetDominatedNodes(handlerEntry));
                foreach (var handlerNode in handlerBody)
                    subGraph.Nodes.Add(handlerNode);
                
                handlerExits.Add(ehFrame, new HashSet<Node>(handlerBody.Where(x => x.OutgoingEdges.Count == 0)));

                // Add for each node in the try block an abnormal edge.
                var tryBody = new HashSet<Node>(subGraph.Nodes.Except(handlerBody));
                foreach (var node in tryBody.Where(n =>
                    !n.UserData.ContainsKey(ControlFlowGraph.TopMostEHProperty) && n != tryEntry))
                {
                    AddAbnormalEdge(graph, node, ehFrame, handlerEntry);
                }

                // Register EH boundaries in the sub graph.
                subGraph.UserData[ControlFlowGraph.TryBlockProperty] = tryBody;
                subGraph.UserData[ControlFlowGraph.HandlerBlockProperty] = handlerBody;
                
                if (ehFrame.Type == EHType.FILTER)
                {
                    var filterEntry = GetNode(graph, (long) ehFrame.FilterAddress);
                    subGraph.UserData[ControlFlowGraph.FilterStartProperty] = filterEntry;
                }
            }

            // Since a LEAVE instruction might not directly transfer control to the referenced instruction,
            // but rather transfer control to a finally block first,  we have to add edges to these nodes 
            // as well.
            
            foreach (var node in graph.Nodes)
            {
                if (node.SubGraphs.Count > 0)
                {
                    // Check if the node ends with a LEAVE.
                    var block = GetUserData<ILBasicBlock>(node, ILBasicBlock.BasicBlockProperty);
                    if (block == null)
                        continue;
                    
                    var last = block.Instructions[block.Instructions.Count - 1];
                    if (last.OpCode.Code == ILCode.LEAVE)
                    {
                        // Find the frame we're jumping out of.
                        var ehFrame = last.ProgramState.EHStack.Peek();

                        // Add for each handler exit an edge to the referenced instruction.
                        foreach (var exit in handlerExits[ehFrame])
                        {
                            var edge = CreateEdge(exit, node.OutgoingEdges.First().Target, ControlFlowGraph.EndFinallyConditionLabel);
                            exit.UserData[ControlFlowGraph.TopMostEHProperty] = ehFrame;
                            graph.Edges.Add(edge);
                        }
                    }
                }
            }
            
        }

        private void AddAbnormalEdge(ControlFlowGraph graph, Node node, EHFrame ehFrame, Node handlerEntry)
        {
            node.UserData[ControlFlowGraph.TopMostEHProperty] = ehFrame;
            var edge = CreateEdge(node, handlerEntry, 
                ControlFlowGraph.ExceptionConditionLabel);
            graph.Edges.Add(edge);
        }

        private IEnumerable<Node> FindReachableReturnNodes(Node filterEntry)
        {
            var agenda = new Stack<Node>();
            var visited = new HashSet<Node>();
            agenda.Push(filterEntry);

            while (agenda.Count > 0)
            {
                var current = agenda.Pop();
                if (!visited.Add(current))
                    continue;
                
                var block = GetUserData<ILBasicBlock>(current, ILBasicBlock.BasicBlockProperty);
                if (block == null)
                    continue;
                
                var last = block.Instructions[block.Instructions.Count - 1];
                if (last.OpCode.Code == ILCode.RET)
                {
                    yield return current;
                    continue;
                }

                foreach (var edge in current.OutgoingEdges)
                {
                    if (!edge.UserData.TryGetValue(ControlFlowGraph.ConditionProperty, out object data))
                    {
                        agenda.Push(edge.Target);
                        continue;
                    }

                    // Exclude abnormal edges.
                    var conditions = (ISet<int>) data; 
                    if (!conditions.Contains(ControlFlowGraph.ExceptionConditionLabel)
                        && !conditions.Contains(ControlFlowGraph.EndFinallyConditionLabel))
                    {
                        agenda.Push(edge.Target);
                    }
                }
            }
        }

        private ISet<Node> CollectHandlerNodes(Node handlerEntry, ISet<Node> scope)
        {
            int ehFrameCount = GetUserData<ILBasicBlock>(handlerEntry, ILBasicBlock.BasicBlockProperty).Instructions[0]
                .ProgramState.EHStack.Count;
            
            var result = new HashSet<Node>();
            
            var agenda = new Stack<Node>();
            var visited = new HashSet<Node>();
            agenda.Push(handlerEntry);

            while (agenda.Count > 0)
            {
                var current = agenda.Pop();
                if (!visited.Add(current) || !scope.Contains(current))
                    continue;

                var block = GetUserData<ILBasicBlock>(current, ILBasicBlock.BasicBlockProperty);
                if (block == null)
                    continue;

                var last = block.Instructions[block.Instructions.Count - 1];
                
                // HACK: The following is not exactly correct, this doesn't work for nested EHs inside handler blocks. 
                // We probably need a more sophisticated approach, one that does not rely on the original EH frame stack,
                // but our own EH frame stack that also pushes on entering handlers, and pops on leave / ret instructions.
                // As this requires quite some arch changes probably, this will require some thought. For now at least
                // this allows "recompilation" of the code, just incorrect nestings sometimes.
                if (last.ProgramState.EHStack.Count < ehFrameCount)
                    continue;

                result.Add(current);
                
                if (last.OpCode.Code is ILCode.RET or ILCode.LEAVE)
                    continue;
                
                foreach (var edge in current.OutgoingEdges)
                    agenda.Push(edge.Target);
            }

            return result;
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/ControlFlow/ILBasicBlock.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.ControlFlow
{
    public class ILBasicBlock
    {
        public const string BasicBlockProperty = "basicblock";
        
        public IList<ILInstruction> Instructions
        {
            get;
        } = new List<ILInstruction>();
    }
}


================================================
File: src/OldRod.Core/Disassembly/DataFlow/EHFrame.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.DataFlow
{
    public class EHFrame
    {
        public const string EHFrameProperty = "eh";
        
        public ulong TryStart
        {
            get;
            set;
        }
        
        public EHType Type
        {
            get;
            set;
        }

        public ITypeDefOrRef CatchType
        {
            get;
            set;
        }

        public ulong FilterAddress
        {
            get;
            set;
        }

        public ulong HandlerAddress
        {
            get;
            set;
        }

        public override string ToString()
        {
            return $"{Type} (try: {TryStart:X4}, handler: {HandlerAddress:X4})";
        }
        
    }
}


================================================
File: src/OldRod.Core/Disassembly/DataFlow/ProgramState.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;

namespace OldRod.Core.Disassembly.DataFlow
{
    public class ProgramState
    {
        public ulong IP
        {
            get;
            set;
        }

        public uint Key
        {
            get;
            set;
        }
        
        public StackState Stack
        {
            get;
            private set;
        } = new StackState();

        public RegisterState Registers
        {
            get;
            private set;
        } = new RegisterState();

        public Stack<EHFrame> EHStack
        {
            get;
        } = new Stack<EHFrame>();

        public bool IgnoreExitKey
        {
            get;
            set;
        }
        
        public bool MergeWith(ProgramState other)
        {
            return Stack.MergeWith(other.Stack) | Registers.MergeWith(other.Registers);
        }

        public ProgramState Copy()
        {
            var copy = new ProgramState
            {
                IP = IP,
                Key = Key,
                Stack = Stack.Copy(),
                Registers = Registers.Copy(),
                IgnoreExitKey = IgnoreExitKey
            };
           
            foreach (var value in EHStack.Reverse())
                copy.EHStack.Push(value);
            
            return copy;
        }

        public override string ToString()
        {
            return $"{nameof(Stack)}: {Stack}, {nameof(Registers)}: {Registers}";
        }
        
    }
}


================================================
File: src/OldRod.Core/Disassembly/DataFlow/RegisterState.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Text;
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.DataFlow
{
    public class RegisterState
    {
        private readonly SymbolicValue[] _registers = new SymbolicValue[(int) VMRegisters.Max];

        public RegisterState()
        {
            for (int i = 0; i < (int) VMRegisters.Max; i++)
                _registers[i] = new SymbolicValue();
        }

        public SymbolicValue this[VMRegisters register]
        {
            get => _registers[(int) register];
            set => _registers[(int) register] = value ?? throw new ArgumentNullException(nameof(value));
        }

        public bool MergeWith(RegisterState other)
        {
            bool changed = false;
            for (int i = 0; i < (int) VMRegisters.Max; i++)
            {
                var reg = (VMRegisters) i;
                if (reg != VMRegisters.IP)
                    changed |= _registers[(int) reg].MergeWith(other[reg]);
            }

            return changed;
        }

        public RegisterState Copy()
        {
            var result = new RegisterState();
            for (int i = 0; i < (int) VMRegisters.Max; i++)
                result[(VMRegisters) i].MergeWith(_registers[i]);
            return result;
        }

        public override string ToString()
        {
            var builder = new StringBuilder();
            
            builder.Append('{');
            for (int i = 0; i < (int) VMRegisters.Max; i++)
            {
                if (builder.Length > 1)
                    builder.Append(", ");
                if (!_registers[i].IsUnknown)
                    builder.AppendFormat("{0}: {1}", (VMRegisters) i, _registers[i]);
            }
            builder.Append('}');
            
            return builder.ToString();
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/DataFlow/StackState.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections;
using System.Collections.Generic;

namespace OldRod.Core.Disassembly.DataFlow
{
    public class StackState : IEnumerable<SymbolicValue>
    {
        private readonly IList<SymbolicValue> _slots = new List<SymbolicValue>();

        public int Count => _slots.Count;

        public SymbolicValue Top => _slots.Count == 0 ? null : _slots[_slots.Count - 1];
        
        public void Push(SymbolicValue slot)
        {
            _slots.Add(slot);
        }

        public SymbolicValue Pop()
        {
            var value = _slots[_slots.Count - 1];
            _slots.RemoveAt(_slots.Count - 1);
            return value;
        }

        public StackState Copy()
        {
            var copy = new StackState();
            foreach (var value in _slots)
                copy._slots.Add(value.Copy());
            return copy;
        }

        public bool MergeWith(StackState other)
        {
            if (other._slots.Count != _slots.Count)
                throw new DisassemblyException("Stack states are not the same size.");

            bool changed = false;
            for (int i = 0; i < _slots.Count; i++) 
                changed |= _slots[i].MergeWith(other._slots[i]);
            return changed;
        }

        public IEnumerator<SymbolicValue> GetEnumerator()
        {
            return _slots.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override string ToString()
        {
            return $"{{{string.Join(", ", _slots)}}}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/DataFlow/SymbolicValue.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Architecture;
using OldRod.Core.Emulation;

namespace OldRod.Core.Disassembly.DataFlow
{
    public class SymbolicValue
    {
        public SymbolicValue()
        {   
        }
        
        public SymbolicValue(ILInstruction dataSource, VMType type)
        {
            DataSources.Add(dataSource);
            Type = type;
        }

        private SymbolicValue(IEnumerable<ILInstruction> dataSources)
        {
            DataSources.UnionWith(dataSources);
        }

        public ISet<ILInstruction> DataSources
        {
            get;
        } = new HashSet<ILInstruction>();

        public bool IsUnknown => DataSources.Count == 0;

        public VMType Type
        {
            get;
            set;
        }
        
        public bool MergeWith(SymbolicValue value)
        {
            if (ReferenceEquals(this, value))
                return false;
            
            Type = value.Type;            
            int size = DataSources.Count;
            DataSources.UnionWith(value.DataSources);
            return size != DataSources.Count;
        }
        
        public SymbolicValue Copy()
        {
            return new SymbolicValue(DataSources) {Type = Type};
        }
        
        public override string ToString()
        {
            return IsUnknown
                ? "?"
                : string.Format("{0} ({1})",
                    string.Join(" | ", DataSources.Select(x => x.Offset.ToString("X4"))),
                    Type.ToString().ToLower());
        }
        
        public VMSlot InferStackValue()
        {
            var emulator = new InstructionEmulator();
            var pushValue = DataSources.First(); // TODO: might need to verify multiple data sources.
            emulator.EmulateDependentInstructions(pushValue);
            emulator.EmulateInstruction(pushValue);
            return emulator.Stack.Pop();
        }
        
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/FunctionEventArgs.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;

namespace OldRod.Core.Disassembly.Inference
{
    public class FunctionEventArgs : EventArgs
    {
        public FunctionEventArgs(VMFunction function)
        {
            Function = function;
        }
        
        public VMFunction Function
        {
            get;
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/FunctionReference.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Core.Disassembly.Inference
{
    public struct FunctionReference
    {
        public FunctionReference(VMFunction caller, int offset, FunctionReferenceType referenceType, VMFunction callee)
        {
            Caller = caller;
            Offset = offset;
            Callee = callee;
            ReferenceType = referenceType;
        }
        
        public VMFunction Caller
        {
            get;
        }

        public int Offset
        {
            get;
        }

        public FunctionReferenceType ReferenceType
        {
            get;
        }

        public VMFunction Callee
        {
            get;
        }

        public override string ToString()
        {
            return $"<{Caller}> IL_{Offset:X4} {ReferenceType} {Callee}";
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/FunctionReferenceType.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
namespace OldRod.Core.Disassembly.Inference
{
    public enum FunctionReferenceType
    {
        Ldftn,
        Call
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/IExitKeyResolver.cs
================================================
using OldRod.Core.Architecture;

namespace OldRod.Core.Disassembly.Inference
{
    public interface IExitKeyResolver
    {
        string Name
        {
            get;
        }
        
        uint? ResolveExitKey(ILogger logger, KoiStream koiStream, VMConstants constants, VMFunction function);
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/ISMCTrampolineDetector.cs
================================================
ï»¿using OldRod.Core.Disassembly.DataFlow;

namespace OldRod.Core.Disassembly.Inference 
{
    public interface ISMCTrampolineDetector 
    {
        bool IsSMCTrampoline(ProgramState currentState, out byte smcKey, out ulong smcTrampolineEnd);
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/IVMFunctionFactory.cs
================================================
namespace OldRod.Core.Disassembly.Inference
{
    public interface IVMFunctionFactory
    {
        VMFunction CreateFunction(uint entryAddress, uint entryKey);
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/InferenceDisassembler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.ControlFlow;
using OldRod.Core.Disassembly.DataFlow;

namespace OldRod.Core.Disassembly.Inference
{
    public class InferenceDisassembler
    {
        public event EventHandler<FunctionEventArgs> FunctionInferred;
        
        private const string Tag = "InferenceDisasm";
        
        private readonly InstructionDecoder _decoder;
        private readonly InstructionProcessor _processor;
        private readonly IDictionary<uint, VMFunction> _functions = new Dictionary<uint, VMFunction>();
        private readonly ControlFlowGraphBuilder _cfgBuilder;

        public InferenceDisassembler(VMConstants constants, KoiStream koiStream)
        {
            Constants = constants ?? throw new ArgumentNullException(nameof(constants));
            KoiStream = koiStream ?? throw new ArgumentNullException(nameof(koiStream));
            _decoder = new InstructionDecoder(constants, KoiStream.Contents.CreateReader());
            _processor = new InstructionProcessor(this);
            _cfgBuilder = new ControlFlowGraphBuilder();

        }

        public ILogger Logger
        {
            get => _cfgBuilder.Logger;
            set => _cfgBuilder.Logger = value;
        }

        public VMConstants Constants
        {
            get;
        }

        public KoiStream KoiStream
        {
            get;
        }

        public IVMFunctionFactory FunctionFactory
        {
            get;
            set;
        }

        public bool SalvageCfgOnError
        {
            get => _cfgBuilder.SalvageOnError;
            set => _cfgBuilder.SalvageOnError = value;
        }

        public IExitKeyResolver ExitKeyResolver
        {
            get;
            set;
        }

        public bool ResolveUnknownExitKeys
        {
            get;
            set;
        } = false;
        
        public ISMCTrampolineDetector SMCTrampolineDetector 
        {
            get;
            set;
        }
        
        public void AddFunction(VMFunction function)
        {
            _functions.Add(function.EntrypointAddress, function);
        }

        public VMFunction GetOrCreateFunctionInfo(uint address, uint entryKey)
        {
            if (!_functions.TryGetValue(address, out var function))
            {
                Logger.Debug(Tag, $"Inferred new function_{address:X4} with entry key {entryKey:X8}.");

                function = FunctionFactory != null
                    ? FunctionFactory.CreateFunction(address, entryKey)
                    : new VMFunction(address, entryKey);
                
                _functions.Add(address, function);
                OnFunctionInferred(new FunctionEventArgs(function));
            }

            return function;
        }
        
        public IDictionary<uint, ControlFlowGraph> DisassembleFunctions()
        {
            if (_functions.Count == 0)
                throw new InvalidOperationException("Cannot start disassembly procedure if no functions have been added yet to the symbols.");

            try
            {
                while (DisassembleFunctionsImpl() 
                       && _functions.Any(f => !f.Value.ExitKey.HasValue)
                       && ResolveUnknownExitKeys
                       && TryResolveExitKeys())
                {
                    // Try continuing the disassembly until no more changes are being observed.
                }
            }
            catch (DisassemblyException ex) when (SalvageCfgOnError)
            {
                Logger.Error(Tag, ex.Message);
                Logger.Log(Tag, "Attempting to salvage control flow graphs...");
            }

            return ConstructControlFlowGraphs();
        }

        private bool DisassembleFunctionsImpl()
        {
            bool changedAtLeastOnce = false;
            bool changed = true;

            while (changed)
            {
                changed = false;

                int functionsCount = _functions.Count;
                foreach (var function in _functions.Values.ToArray())
                    changed |= ContinueDisassemblyForFunction(function);

                changedAtLeastOnce |= changed;
                changed |= functionsCount != _functions.Count;
            }

            return changedAtLeastOnce;
        }

        private bool ContinueDisassemblyForFunction(VMFunction function)
        {
            bool changed = false;
            
            var initialStates = new List<ProgramState>();
            if (function.Instructions.Count == 0)
            {
                // First run. We just start at the very beginning of the export.
                Logger.Debug(Tag, $"Started disassembling function_{function.EntrypointAddress:X4}...");
                var initialState = new ProgramState()
                {
                    IP = function.EntrypointAddress,
                    Key = function.EntryKey,
                };
                initialState.Stack.Push(new SymbolicValue(
                    new ILInstruction(1, ILOpCodes.CALL, function.EntrypointAddress),
                    VMType.Qword));
                initialStates.Add(initialState);
                function.BlockHeaders.Add(function.EntrypointAddress);
            }
            else if (function.UnresolvedOffsets.Count > 0)
            {
                // We still have some instructions were we could not fully resolve the next program states from.
                // Currently the only reason for this to happen is when we disassembled a CALL instruction, and
                // inferred that it called a method whose exit key was not yet known, and could therefore not
                // continue disassembly.

                // Continue disassembly at this position:
                Logger.Debug(Tag,
                    $"Revisiting {function.UnresolvedOffsets.Count} unresolved offsets of function_{function.EntrypointAddress:X4}...");
                foreach (long offset in function.UnresolvedOffsets)
                    initialStates.Add(function.Instructions[offset].ProgramState);
            }

            if (initialStates.Count > 0)
            {
                changed = ContinueDisassembly(function, initialStates);

                if (function.UnresolvedOffsets.Count > 0)
                {
                    Logger.Debug(Tag,
                        $"Disassembly procedure stopped with {function.UnresolvedOffsets.Count} "
                        + $"unresolved offsets (new instructions decoded: {changed}).");
                }
                else if (function.Instructions.Count == 0)
                {
                    Logger.Warning(Tag,
                        $"Disassembly finalised with {function.Instructions.Count} instructions.");
                }
                else
                {
                    Logger.Debug(Tag,
                        $"Disassembly finalised with {function.Instructions.Count} instructions.");
                }
            }

            return changed;
        }

        private bool ContinueDisassembly(VMFunction function, IEnumerable<ProgramState> initialStates)
        {
            bool changed = false;
            
            var agenda = new Stack<ProgramState>();
            var initials = new HashSet<ulong>();
            foreach (var state in initialStates)
            {
                initials.Add(state.IP);
                agenda.Push(state);
            }

            while (agenda.Count > 0)
            {
                var currentState = agenda.Pop();

                // Check if offset is already visited before.
                if (function.Instructions.TryGetValue((long) currentState.IP, out var instruction))
                {
                    // Check if the (potentially different) key resolves to the same instruction.
                    _decoder.ReaderOffset = (uint) currentState.IP;
                    _decoder.CurrentKey = currentState.Key;
                    
                    ILInstruction instruction2;
                    if (function.SMCTrampolineOffsetRange.Contains(currentState.IP))
                        instruction2 = _decoder.ReadNextInstruction(function.SMCTrampolineKey);
                    else
                        instruction2 = _decoder.ReadNextInstruction();

                    if (instruction2.OpCode.Code != instruction.OpCode.Code)
                    {
                        // This should not happen in vanilla KoiVM.
                        throw new DisassemblyException(
                            $"Detected joining control flow paths in function_{function.EntrypointAddress:X4} "
                              + $"converging to the same offset (IL_{instruction.Offset:X4}) but decoding to different instructions.");
                    }

                    if (instruction.ProgramState.MergeWith(currentState) || initials.Contains(currentState.IP))
                        currentState = instruction.ProgramState;
                    else
                        continue;
                }
                else
                {
                    // Offset is not visited yet, read instruction. 
                    _decoder.ReaderOffset = (uint) currentState.IP;
                    _decoder.CurrentKey = currentState.Key;

                    // If the instruction at the current IP is a block header and a SMC trampoline block
                    // has not yet been detected, check if we might be entering a SMC trampoline block.
                    // The check for block headers is a performance improvement.
                    if (SMCTrampolineDetector is not null && function.SMCTrampolineOffsetRange.IsEmpty
                                                          && function.BlockHeaders.Contains((long)currentState.IP)
                                                          && SMCTrampolineDetector.IsSMCTrampoline(currentState, out byte smcKey, out ulong trampolineEnd)) 
                    {
                        function.SMCTrampolineOffsetRange = new OffsetRange(currentState.IP, trampolineEnd);
                        function.SMCTrampolineKey = smcKey;
                    }

                    if (function.SMCTrampolineOffsetRange.Contains(currentState.IP))
                        instruction = _decoder.ReadNextInstruction(function.SMCTrampolineKey);
                    else
                        instruction = _decoder.ReadNextInstruction();

                    instruction.ProgramState = currentState;
                    function.Instructions.Add((long) currentState.IP, instruction);
                    changed = true;
                }

                currentState.Registers[VMRegisters.IP] = new SymbolicValue(instruction, VMType.Qword);

                // Determine next states.
                try
                {
                    foreach (var state in _processor.GetNextStates(function, currentState, instruction,
                                 _decoder.CurrentKey))
                    {
                        agenda.Push(state);
                    }
                }
                catch (Exception ex) when (SalvageCfgOnError)
                {
                    Logger.Error(Tag, $"Could not infer next program states of {instruction}. " + ex.Message);
                }
            }

            return changed;
        }

        private Dictionary<uint, ControlFlowGraph> ConstructControlFlowGraphs()
        {   
            var result = new Dictionary<uint, ControlFlowGraph>();
            foreach (var entry in _functions)
            {
                try
                {
                    if (entry.Value.UnresolvedOffsets.Count > 0)
                    {
                        Logger.Warning(Tag,
                            string.Format("Could not resolve the next states of some offsets of function_{0:X4} ({1}).",
                                entry.Key,
                                string.Join(", ", entry.Value.UnresolvedOffsets
                                    .Select(x => "IL_" + x.ToString("X4")))));
                    }

                    Logger.Debug(Tag, $"Constructing CFG of function_{entry.Key:X4}...");
                    result[entry.Key] = _cfgBuilder.BuildGraph(entry.Value);   
                }
                catch (Exception ex) when (SalvageCfgOnError)
                {
                    Logger.Error(Tag,
                        $"Failed to construct control flow graph of function_{entry.Key:X4}. " + ex.Message);
                }
            }

            return result;
        }

        private bool TryResolveExitKeys()
        {
            if (ExitKeyResolver == null)
            {
                throw new DisassemblyException(
                    $"{nameof(ResolveUnknownExitKeys)} was set to true, but no exit key resolver was provided.");
            }

            Logger.Log(Tag, $"Trying to resolve any exit keys using {ExitKeyResolver.Name}...");
            
            // Collect all functions that do not have an exit key yet, and order then by the amount of references.
            // The more references, the more information is known about the function.
            var unresolvedFunctions = _functions.Values
                    .Where(f => !f.ExitKey.HasValue)
                    .OrderByDescending(f => f.References.Count)
#if DEBUG
                    .ToArray()
#endif
                ;
            
            foreach (var function in unresolvedFunctions)
            {
                Logger.Log(Tag, $"Attempting to resolve exit key of function_{function.EntrypointAddress:X4}...");
                var exitKey = ExitKeyResolver.ResolveExitKey(Logger, KoiStream, Constants, function);
                if (exitKey.HasValue)
                {
                    // We found an exit key, let's continue disassembly like normal.
                    Logger.Log(Tag,
                        $"Resolved exit key {exitKey.Value:X8} for function_{function.EntrypointAddress:X4}.");
                    function.ExitKey = exitKey;
                    return true;
                }
            }

            return false;
        }

        protected virtual void OnFunctionInferred(FunctionEventArgs e)
        {
            FunctionInferred?.Invoke(this, e);
        }
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/InstructionProcessor.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver;
using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Metadata.Tables;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Annotations;
using OldRod.Core.Disassembly.DataFlow;
using OldRod.Core.Emulation;

namespace OldRod.Core.Disassembly.Inference
{
    public class InstructionProcessor
    {
        public const string Tag = "InstructionProcessor";

        public const int PushExceptionOffset = -1;
        
        private readonly InferenceDisassembler _disassembler;
        private readonly VCallProcessor _vCallProcessor;


        public InstructionProcessor(InferenceDisassembler disassembler)
        {
            _disassembler = disassembler;
            _vCallProcessor = new VCallProcessor(disassembler);
        }

        private ILogger Logger => _disassembler.Logger;
        private KoiStream KoiStream => _disassembler.KoiStream;
        private VMConstants Constants => _disassembler.Constants;

        public IList<ProgramState> GetNextStates(
            VMFunction function,
            ProgramState currentState,
            ILInstruction instruction,
            uint nextKey)
        {
            var nextStates = new List<ProgramState>(1);
            var next = currentState.Copy();
            next.IP += (ulong) instruction.Size;
            next.Key = nextKey;
            
            if (instruction.OpCode.AffectsFlags)
                next.Registers[VMRegisters.FL] = new SymbolicValue(instruction, VMType.Byte);

            switch (instruction.OpCode.Code)
            {
                case ILCode.CALL:
                    nextStates.AddRange(ProcessCall(function, instruction, next));
                    break;
                case ILCode.RET:
                    ProcessRet(function, instruction, next);
                    function.BlockHeaders.Add((long) next.IP);
                    break;
                case ILCode.VCALL:
                    // VCalls have embedded opcodes with different behaviours.
                    nextStates.AddRange(_vCallProcessor.GetNextStates(function, instruction, next));
                    break;
                case ILCode.TRY:
                    // TRY opcodes have a very distinct behaviour from the other common opcodes.
                    nextStates.AddRange(ProcessTry(instruction, next));
                    foreach (var state in nextStates)
                        function.BlockHeaders.Add((long) state.IP);
                    break;
                case ILCode.LEAVE:
                    nextStates.AddRange(ProcessLeave(instruction, next));
                    function.BlockHeaders.Add((long) next.IP);
                    break;
                case ILCode.POP when (VMRegisters) instruction.Operand == VMRegisters.SP:
                    nextStates.Add(ProcessPopSp(instruction, next));
                    break;
                case ILCode.SWT:
                    nextStates.AddRange(ProcessSwt(instruction, next));
                    function.BlockHeaders.UnionWith(nextStates.Select(s => (long) s.IP));
                    break;
                default:
                {
                    // Push/pop necessary values from stack.
                    int initial = next.Stack.Count;
                    PopSymbolicValues(instruction, next);
                    int popCount = initial - next.Stack.Count;

                    initial = next.Stack.Count;
                    PushSymbolicValues(instruction, next);
                    int pushCount = next.Stack.Count - initial;
                
                    // Apply control flow.
                    PerformFlowControl(function, instruction, nextStates, next);

                    instruction.Annotation ??= new Annotation();
                
                    instruction.Annotation.InferredPopCount = popCount;
                    instruction.Annotation.InferredPushCount = pushCount;
                    break;
                }
            }

            return nextStates;
        }

        private IEnumerable<ProgramState> ProcessCall(VMFunction function, ILInstruction instruction, ProgramState next)
        {
            var symbolicAddress = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(0, symbolicAddress);

            uint address = (uint) symbolicAddress.InferStackValue().U8;

            if (address >= KoiStream.Contents.GetPhysicalSize())
            {
                Logger.Warning(Tag,
                    $"Call instruction at IL_{instruction.Offset:X4} "
                    + $"transfers control to a function outside of the KoiVM stream (IL_{address:X4}.");
            }

            var callee = _disassembler.GetOrCreateFunctionInfo(address, next.Key);

            callee.References.Add(new FunctionReference(function, instruction.Offset, FunctionReferenceType.Call, callee));
            instruction.Annotation = new CallAnnotation
            {
                Function = callee,
                InferredPopCount = 1,
                InferredPushCount = 1,
            };

            if (!callee.ExitKey.HasValue)
            {
                // Exit key of called function is not known yet.
                // We cannot continue disassembly yet because of the encryption used in KoiVM.
                function.UnresolvedOffsets.Add(instruction.Offset);
                Logger.Debug(Tag,
                    $"Stopped at call instruction at IL_{instruction.Offset:X4} "
                    + $"as exit key of function_{address:X4} is not known yet.");
                return Enumerable.Empty<ProgramState>();
            }
            else
            {
                // Exit key is known, we can continue disassembly!
                function.UnresolvedOffsets.Remove(instruction.Offset);
                next.Key = callee.ExitKey.Value;         

                return new[] {next};
            }
        }

        private void ProcessRet(VMFunction function, ILInstruction instruction, ProgramState next)
        {
            // Pop return address.
            var symbolicReturnAddress = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(0, symbolicReturnAddress);

            // Add metadata.
            instruction.Annotation = new Annotation
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 0
            };
            
            if (!next.IgnoreExitKey)
            {
                // Returns indicate the end of the method, and therefore also determine the encryption key of the 
                // instruction after a call instruction. Store this information so it can be used to continue
                // disassembly at these points later in time.

                if (function.ExitKey.HasValue)
                {
                    if (function.ExitKey != next.Key)
                    {
                        Logger.Debug2(Tag, 
                            $"Resolved an alternative exit key ({next.Key:X8}) at offset " +
                            $"IL_{instruction.Offset:X4}for function_{function.EntrypointAddress:X4}.");
                    }
                }
                else
                {
                    Logger.Debug2(Tag, $"Inferred exit key {next.Key:X8} at offset IL_{instruction.Offset:X4}.");
                    function.ExitKey = next.Key;
                }
            }
        }

        private IEnumerable<ProgramState> ProcessTry(ILInstruction instruction, ProgramState next)
        {
            var result = new List<ProgramState> {next};

            int dependencyIndex = 0;         
            
            // Pop and infer handler type.
            var symbolicType = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(dependencyIndex++, symbolicType);

            var frame = new EHFrame
            {
                Type = Constants.EHTypes[symbolicType.InferStackValue().U1],
                TryStart = (ulong) (instruction.Offset + instruction.Size)
            };
            next.EHStack.Push(frame);

            bool pushException = false;
            bool ignoreExitKeyInHandler = false;
            switch (frame.Type)
            {
                case EHType.CATCH:
                    // Pop and infer catch type.
                    var symbolicCatchType = next.Stack.Pop();
                    uint catchTypeId = symbolicCatchType.InferStackValue().U4;
                    frame.CatchType = (ITypeDefOrRef) KoiStream.ResolveReference(Logger, instruction.Offset, catchTypeId,
                        TableIndex.TypeDef, TableIndex.TypeRef, TableIndex.TypeSpec);
                    instruction.Dependencies.AddOrMerge(dependencyIndex++, symbolicCatchType);
                    pushException = true;
                    break;
                
                case EHType.FILTER:
                    // Pop and infer filter address.
                    var symbolicFilterAddress = next.Stack.Pop();
                    frame.FilterAddress = symbolicFilterAddress.InferStackValue().U8;
                    instruction.Dependencies.AddOrMerge(dependencyIndex++, symbolicFilterAddress);
                    pushException = true;
                    break;
                
                case EHType.FAULT:
                case EHType.FINALLY:
                    // No extra values on the stack.
                    ignoreExitKeyInHandler = true;
                    break;
                
                default:
                    throw new ArgumentOutOfRangeException();
            }

            // Pop and infer handler address.
            var symbolicHandlerAddress = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(dependencyIndex, symbolicHandlerAddress);
            frame.HandlerAddress = symbolicHandlerAddress.InferStackValue().U8;

            // Branch to handler block.
            var handlerState = next.Copy();
            handlerState.Key = 0;
            handlerState.IP = frame.HandlerAddress;
            handlerState.EHStack.Pop();
            handlerState.IgnoreExitKey = ignoreExitKeyInHandler;
            
            // Push exception object on stack of handler when needed.
            if (pushException)
            {
                handlerState.Stack.Push(new SymbolicValue(
                    new ILInstruction(PushExceptionOffset, ILOpCodes.__PUSH_EXCEPTION, frame.CatchType),
                    VMType.Object));
            }
            
            result.Add(handlerState);
            
            // Branch to filter block if necessary.
            if (frame.FilterAddress != 0)
            {
                var filterState = next.Copy();
                filterState.Key = 0;
                filterState.IP = frame.FilterAddress;
                filterState.IgnoreExitKey = true;
                filterState.Stack.Push(new SymbolicValue(
                    new ILInstruction(PushExceptionOffset, ILOpCodes.__PUSH_EXCEPTION, frame.CatchType),
                    VMType.Object));
                result.Add(filterState);
            }

            instruction.Annotation = new Annotation
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 0,
            };
                    
            Logger.Debug2(Tag, $"Entered exception handler (Type: {frame.Type}, Try: IL_{instruction.Offset:X4}, Handler: IL_{frame.HandlerAddress:X4}).");
            return result;
        }

        private IEnumerable<ProgramState> ProcessLeave(ILInstruction instruction, ProgramState next)
        {
            // Not really necessary to resolve this to a value since KoiVM only uses this as some sort of sanity check.
            var symbolicHandler = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(0, symbolicHandler);

            var frame = next.EHStack.Pop();

            instruction.Annotation = new Annotation
            {
                InferredPopCount = 1,
                InferredPushCount = 0
            };
            
            Logger.Debug2(Tag, $"Exited exception handler at IL_{instruction.Offset:X4} (Type: {frame.Type}, Try: IL_{instruction.Offset:X4}, Handler: IL_{frame.HandlerAddress:X4}).");
            return new[] {next};
        }

        private ProgramState ProcessPopSp(ILInstruction instruction, ProgramState next)
        {
            int oldValue = next.Stack.Count;
            var symbolicValue = next.Stack.Pop();
            int newValue = (int) symbolicValue.InferStackValue().U4;
            int difference = (newValue + 1) - oldValue;

            instruction.Dependencies.AddOrMerge(0, symbolicValue);
            instruction.Annotation = new Annotation
            {
                InferredPopCount = 1
            };
            
            if (difference > 0)
            {
                // Allocation of new stack slots.
                for (int i = 0; i < difference; i++) 
                    next.Stack.Push(new SymbolicValue(instruction, VMType.Unknown));
                instruction.Annotation.InferredPushCount = difference;
            }
            else if (difference < 0) 
            {
                // Popping multiple values from the stack.
                for (int i = 0; i < -difference; i++)
                    next.Stack.Pop();
                instruction.Annotation.InferredPopCount += -difference;
            }
            
            return next;
        }

        private IEnumerable<ProgramState> ProcessSwt(ILInstruction instruction, ProgramState next)
        {
            var result = new List<ProgramState>();
            
            var symbolicTableSlot = next.Stack.Pop();
            var symbolicValue = next.Stack.Pop();
            
            instruction.Dependencies.AddOrMerge(0, symbolicTableSlot);
            instruction.Dependencies.AddOrMerge(1, symbolicValue);

            var annotation = new JumpAnnotation
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 0
            };

            ulong tableAddress = symbolicTableSlot.InferStackValue().U8;

            var reader = KoiStream.Contents.CreateReader();
            reader.Offset = (uint) (tableAddress - 2);
            
            ushort count = reader.ReadUInt16();
            for (int i = 0; i < count; i++)
            {
                int relativeOffset = reader.ReadInt32();
                ulong nextIp = (ulong) ((long) next.IP + relativeOffset);

                Logger.Debug2(Tag, $"Inferred edge IL_{instruction.Offset:X4} -> IL_{nextIp:X4}");
                
                var caseState = next.Copy();
                caseState.IP = nextIp;
                result.Add(caseState);
                
                annotation.InferredJumpTargets.Add(nextIp);
            }
            
            result.Add(next);
            instruction.Annotation = annotation;
            return result;
        }

        private void PopSymbolicValues(ILInstruction instruction, ProgramState next)
        {
            var arguments = new List<SymbolicValue>(2);
            switch (instruction.OpCode.StackBehaviourPop)
            {
                case ILStackBehaviour.None:
                    break;
                
                case ILStackBehaviour.PopAny:
                case ILStackBehaviour.PopPtr:
                case ILStackBehaviour.PopByte:
                case ILStackBehaviour.PopWord:
                case ILStackBehaviour.PopDword:
                case ILStackBehaviour.PopQword:
                case ILStackBehaviour.PopReal32:
                case ILStackBehaviour.PopReal64:
                    var argument = next.Stack.Pop();
                    
                    if (instruction.OpCode.StackBehaviourPop != ILStackBehaviour.PopAny)
                        argument.Type = instruction.OpCode.StackBehaviourPop.GetArgumentType(0);
                    
                    // Check if instruction pops a value to a register.
                    if (instruction.OpCode.OperandType == ILOperandType.Register)
                        next.Registers[(VMRegisters) instruction.Operand] = new SymbolicValue(instruction, argument.Type);
                    
                    arguments.Add(argument);
                    break;
                
                case ILStackBehaviour.PopDword_PopDword:
                case ILStackBehaviour.PopQword_PopQword:
                case ILStackBehaviour.PopPtr_PopPtr:
                case ILStackBehaviour.PopObject_PopPtr:
                case ILStackBehaviour.PopByte_PopPtr:
                case ILStackBehaviour.PopWord_PopPtr:
                case ILStackBehaviour.PopDword_PopPtr:
                case ILStackBehaviour.PopQword_PopPtr:
                case ILStackBehaviour.PopObject_PopObject:
                case ILStackBehaviour.PopReal32_PopReal32:
                case ILStackBehaviour.PopReal64_PopReal64:
                    var argument2 = next.Stack.Pop();
                    var argument1 = next.Stack.Pop();

                    argument1.Type = instruction.OpCode.StackBehaviourPop.GetArgumentType(0);
                    argument2.Type = instruction.OpCode.StackBehaviourPop.GetArgumentType(1);
                    
                    arguments.Add(argument2);
                    arguments.Add(argument1);
                    break;
                
                case ILStackBehaviour.PopVar:
                    
                    // Should never happen. Instructions with a variable amount of values popped from the stack
                    // are handled separately.
                    throw new DisassemblyException(
                        $"Attempted to infer static stack pop behaviour of a PopVar instruction at IL_{instruction.Offset:X4}.");
                    
                default:
                    throw new ArgumentOutOfRangeException();
            }

            // Add instruction dependencies for data flow graph, in reverse order to negate natural stack behaviour.
            for (int i = arguments.Count - 1, j = 0; i >= 0; i--, j++)
                instruction.Dependencies.AddOrMerge(j, arguments[i]);
        }

        private void PushSymbolicValues(ILInstruction instruction, ProgramState next)
        {
            switch (instruction.OpCode.StackBehaviourPush)
            {
                case ILStackBehaviour.None:
                    break;
                
                case ILStackBehaviour.PushPtr:
                case ILStackBehaviour.PushByte:
                case ILStackBehaviour.PushWord:
                case ILStackBehaviour.PushDword:
                case ILStackBehaviour.PushQword:
                case ILStackBehaviour.PushReal32:
                case ILStackBehaviour.PushReal64:
                case ILStackBehaviour.PushObject:
                case ILStackBehaviour.PushVar:
                    next.Stack.Push(new SymbolicValue(
                        instruction,
                        instruction.OpCode.StackBehaviourPush.GetResultType())
                    );
                    break;
                
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void PerformFlowControl(VMFunction function, ILInstruction instruction, List<ProgramState> nextStates, ProgramState next)
        {
            switch (instruction.OpCode.FlowControl)
            {
                case ILFlowControl.Next:
                {
                    // Normal flow.
                    nextStates.Add(next);
                    break;
                }
                case ILFlowControl.Jump:
                {
                    function.BlockHeaders.Add((long) next.IP);
                    
                    // Unconditional jump target.
                    var metadata = InferJumpTargets(instruction);
                    if (metadata != null)
                    {
                        next.IP = metadata.InferredJumpTargets[0];
                        function.BlockHeaders.Add((long) next.IP);
                        nextStates.Add(next);
                    }

                    break;
                }
                case ILFlowControl.ConditionalJump:
                {
                    // We need to consider that the condition might be true or false.
                    
                    // Conditional branch(es): 
                    var metadata = InferJumpTargets(instruction);
                    if (metadata != null)
                    {
                        foreach (var target in metadata.InferredJumpTargets)
                        {
                            var branch = next.Copy();
                            branch.IP = target;
                            nextStates.Add(branch);
                            function.BlockHeaders.Add((long) branch.IP);
                        }
                    }

                    // Fall through branch:
                    nextStates.Add(next);
                    function.BlockHeaders.Add((long) next.IP);
                    
                    break;
                }
                default:
                {
                    throw new ArgumentOutOfRangeException();
                }
            }
        }

        private JumpAnnotation InferJumpTargets(ILInstruction instruction)
        {
            try
            {
                var metadata = new JumpAnnotation();
                var symbolicAddress = instruction.Dependencies[instruction.Dependencies.Count - 1];

                foreach (var dataSource in symbolicAddress.DataSources)
                {
                    var emulator = new InstructionEmulator();
                    emulator.EmulateDependentInstructions(dataSource);
                    emulator.EmulateInstruction(dataSource);
                    
                    // After partial emulation, IP is on stack.
                    uint nextIp = (uint) emulator.Stack.Pop().U8;
                    
                    Logger.Debug2(Tag, $"Inferred edge IL_{instruction.Offset:X4} -> IL_{nextIp:X4}");

                    if (nextIp > (ulong) KoiStream.Contents.GetPhysicalSize())
                    {
                        Logger.Warning(Tag,
                            $"Jump instruction at IL_{instruction.Offset:X4} "
                            + $"transfers control to an instruction outside of the KoiVM stream (IL_{nextIp:X4}.");
                    }
                    
                    metadata.InferredJumpTargets.Add(nextIp);
                }

                instruction.Annotation = metadata;
                return metadata;
            }
            catch (NotSupportedException e)
            {
                Logger.Warning(Tag, $"Could not infer jump target for {instruction.Offset:X4}. {e.Message}");
            }

            return null;
        }
        
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/VCallProcessor.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Metadata.Tables;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Annotations;
using OldRod.Core.Disassembly.DataFlow;

namespace OldRod.Core.Disassembly.Inference
{
    public class VCallProcessor
    {
        private const string Tag = "VCallProcessor";
        
        private readonly InferenceDisassembler _disassembler;

        public VCallProcessor(InferenceDisassembler disassembler)
        {
            _disassembler = disassembler ?? throw new ArgumentNullException(nameof(disassembler));
        }

        private ILogger Logger => _disassembler.Logger;
        private VMConstants Constants => _disassembler.Constants;
        private KoiStream KoiStream => _disassembler.KoiStream;
        
        public IList<ProgramState> GetNextStates(VMFunction function, ILInstruction instruction, ProgramState next)
        {
            var nextStates = new List<ProgramState>(1);
            var metadata = instruction.Annotation as VCallAnnotation;

            int stackSize = next.Stack.Count;
            
            var symbolicVCallValue = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(0, symbolicVCallValue);
            var vcall = metadata?.VMCall ?? Constants.VMCalls[symbolicVCallValue.InferStackValue().U1];

            bool returnNextState = true;
            switch (vcall)
            {
                case VMCalls.BOX:
                    ProcessBox(instruction, next);
                    break;
                case VMCalls.CAST:
                    ProcessCast(instruction, next);
                    break;
                case VMCalls.CKFINITE:
                    ProcessCkFinite(instruction, next);
                    break;
                case VMCalls.CKOVERFLOW:
                    ProcessCkOverflow(instruction, next);
                    break;
                case VMCalls.ECALL:
                    ProcessECall(instruction, next);
                    break;
                case VMCalls.INITOBJ:
                    ProcessInitObj(instruction, next);
                    break;
                case VMCalls.LOCALLOC:
                    ProcessLocalloc(instruction, next);
                    break;
                case VMCalls.LDFLD:
                    ProcessLdfld(instruction, next);
                    break;
                case VMCalls.LDFTN:
                    ProcessLdftn(function, instruction, next);
                    break;
                case VMCalls.RANGECHK:
                    ProcessRangeChk(instruction, next);
                    break;
                case VMCalls.SIZEOF:
                    ProcessSizeOf(instruction, next);
                    break;
                case VMCalls.STFLD:
                    ProcessStfld(instruction, next);
                    break;
                case VMCalls.THROW:
                    ProcessThrow(instruction, next);
                    returnNextState = false;
                    break;
                case VMCalls.TOKEN:
                    ProcessToken(instruction, next);
                    break;
                case VMCalls.UNBOX:
                    ProcessUnbox(instruction, next);
                    break;
                case VMCalls.EXIT:
                case VMCalls.BREAK:
                    throw new NotSupportedException($"VCALL {vcall} is not supported.");
                default:
                    throw new ArgumentOutOfRangeException();
            }
            
            if (returnNextState)
                nextStates.Add(next);

            if ((next.Stack.Count - stackSize) != instruction.Annotation.InferredStackDelta)
            {
                // Should not happen, but sanity checks are always nice to check whether we have implemented the 
                // vcall processors correctly.
                throw new DisassemblyException($"VCall at offset IL_{instruction.Offset:X4} ({vcall}) inferred stack delta does not match the emulated stack delta.");
            }
            
            return nextStates;
        }

        private void ProcessBox(ILInstruction instruction, ProgramState next)
        {
            // Pop arguments and add dependencies.
            var symbolicType = next.Stack.Pop();
            var symbolicValue = next.Stack.Pop();

            instruction.Dependencies.AddOrMerge(1, symbolicType);
            instruction.Dependencies.AddOrMerge(2, symbolicValue);

            next.Stack.Push(new SymbolicValue(instruction, VMType.Object));
            
            // Infer type.
            uint typeId = symbolicType.InferStackValue().U4;
            var type = (ITypeDefOrRef) KoiStream.ResolveReference(Logger, instruction.Offset, typeId,
                TableIndex.TypeDef, TableIndex.TypeRef, TableIndex.TypeSpec);

            // Infer value.
            
            // TODO: Box values pushed onto the stack might not be constants, but might be part of 
            //       a normal conversion of a stack value from value type to object. We need a way
            //       to detect this and encode this in the metadata somehow.
            //
            //       Perhaps by checking whether registers or stack slots are used in the dependent
            //       instructions?
                       
            object value;
            if (type.IsTypeOf("System", "String"))
            {
                var valueSlot = symbolicValue.InferStackValue();
                value = KoiStream.Strings[valueSlot.U4];
            }
            else
            {
                value = null; // TODO: infer value types.
            }

            // Add metadata
            instruction.Annotation = new BoxAnnotation(type, value)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 1
            };
        }

        private void ProcessCkFinite(ILInstruction instruction, ProgramState next)
        {
            // Pop arguments and add dependencies.
            var symbolicValue = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(1, symbolicValue);

            instruction.Annotation = new VCallAnnotation(VMCalls.CKFINITE, VMType.Unknown)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 0
            };
        }
        
        private void ProcessCkOverflow(ILInstruction instruction, ProgramState next)
        {
            // Pop arguments and add dependencies.
            var symbolicValue = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(1, symbolicValue);

            instruction.Annotation = new VCallAnnotation(VMCalls.CKOVERFLOW, VMType.Unknown)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 0
            };
        }

        private void ProcessECall(ILInstruction instruction, ProgramState next)
        {
            int index = 1;
            
            // Pop raw method value from stack.
            var symbolicMethod = next.Stack.Pop();
            instruction.Dependencies.AddOrMerge(index++, symbolicMethod);
            
            // Infer method and opcode used.
            var methodSlot = symbolicMethod.InferStackValue();
            uint methodId = methodSlot.U4 & 0x3fffffff;
            var opCode = Constants.ECallOpCodes[(byte) (methodSlot.U4 >> 30)];
            var method = (IMethodDescriptor) KoiStream.ResolveReference(Logger, instruction.Offset, methodId,
                TableIndex.Method, TableIndex.MethodSpec, TableIndex.MemberRef);
            var methodSignature = method.Signature;

            ITypeDefOrRef constrainedType = null;
            if (opCode == VMECallOpCode.CALLVIRT_CONSTRAINED)
            {
                var symbolicType = next.Stack.Pop();
                instruction.Dependencies.AddOrMerge(index++, symbolicType);
                uint typeId = symbolicType.InferStackValue().U4;
                
                constrainedType = (ITypeDefOrRef) KoiStream.ResolveReference(Logger, instruction.Offset, typeId, 
                    TableIndex.TypeDef, 
                    TableIndex.TypeRef,
                    TableIndex.TypeSpec);
            }
            
            // Collect method arguments:
            var arguments = new List<SymbolicValue>();
            for (int i = 0; i < methodSignature.ParameterTypes.Count; i++)
                arguments.Add(next.Stack.Pop());
            if (method.Signature.HasThis && opCode != VMECallOpCode.NEWOBJ)
                arguments.Add(next.Stack.Pop());
            
            arguments.Reverse();
            
            // Add argument dependencies.
            foreach (var argument in arguments)
                instruction.Dependencies.AddOrMerge(index++, argument);
            
            // Push result, if any.
            bool hasResult = !methodSignature.ReturnType.IsTypeOf("System", "Void")
                             || opCode == VMECallOpCode.NEWOBJ;
            if (hasResult)
            {
                next.Stack.Push(new SymbolicValue(instruction, methodSignature.ReturnType.ToVMType()));
            }

            // Add metadata
            instruction.Annotation = new ECallAnnotation(method, opCode)
            {
                ConstrainedType = constrainedType,
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = hasResult ? 1 : 0
            };
        }

        private void ProcessLdfld(ILInstruction instruction, ProgramState next)
        {
            var symbolicField = next.Stack.Pop();
            var symbolicObject = next.Stack.Pop();

            // Resolve field.
            uint fieldId = symbolicField.InferStackValue().U4;
            var field = (IFieldDescriptor) KoiStream.ResolveReference(Logger, instruction.Offset, 
                fieldId & 0x7FFFFFFF,
                TableIndex.Field, TableIndex.MemberRef);
            var fieldSig = (FieldSignature) field.Signature;
            
            // Add dependencies.
            instruction.Dependencies.AddOrMerge(1, symbolicField);
            instruction.Dependencies.AddOrMerge(2, symbolicObject);

            // Push field value.
            next.Stack.Push(new SymbolicValue(instruction, fieldSig.FieldType.ToVMType()));
            
            // Create metadata.
            instruction.Annotation = new FieldAnnotation(VMCalls.LDFLD, field)
            {
                IsAddress = (fieldId & 0x80000000) != 0,
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 1
            };
        }

        private void ProcessLdftn(VMFunction currentFunction, ILInstruction instruction, ProgramState next)
        {
            var symbolicMethod = next.Stack.Pop();
            var symbolicObject = next.Stack.Pop();

            instruction.Dependencies.AddOrMerge(1, symbolicMethod);
            instruction.Dependencies.AddOrMerge(2, symbolicObject);

            var methodSlot = symbolicMethod.InferStackValue();
            
            if (symbolicObject.Type == VMType.Object)
            {
                // This is a virtual dispatched ldftn.

                var method = (IMethodDescriptor) KoiStream.ResolveReference(Logger, instruction.Offset, methodSlot.U4,
                    TableIndex.Method,
                    TableIndex.MemberRef,
                    TableIndex.MethodSpec);

                instruction.Annotation = new LdftnAnnotation(method, true);
            }
            else
            {
                // This is a static ldftn.
                
                var obj = symbolicObject.InferStackValue();
                if (obj.U8 != 0)
                {
                    // We are dealing with intra-linked methods.
                    
                    // Pop entry key.
                    var symbolicEntryKey = next.Stack.Pop();
                    instruction.Dependencies.AddOrMerge(3, symbolicEntryKey);
                    uint entryKey = symbolicEntryKey.InferStackValue().U4;

                    // Obtain export containing signature.
                    uint exportId = obj.U4;
                    var exportInfo = KoiStream.Exports[exportId];
                    
                    // Get the function at the pushed address and register reference.
                    uint codeAddress = (uint) methodSlot.U8;
                    var function = _disassembler.GetOrCreateFunctionInfo(codeAddress, entryKey);
                    function.References.Add(new FunctionReference(
                        currentFunction, 
                        instruction.Offset,
                        FunctionReferenceType.Ldftn, 
                        function));
                    
                    instruction.Annotation = new LdftnAnnotation(function, exportInfo.Signature);
                }
                else
                {
                    // Resolve method.
                    var method = (IMethodDescriptor) KoiStream.ResolveReference(Logger, instruction.Offset, methodSlot.U4,
                        TableIndex.Method,
                        TableIndex.MemberRef,
                        TableIndex.MethodSpec);

                    instruction.Annotation = new LdftnAnnotation(method, false);
                }
            }

            next.Stack.Push(new SymbolicValue(instruction, VMType.Pointer));
            
            instruction.Annotation.InferredPopCount = instruction.Dependencies.Count;
            instruction.Annotation.InferredPushCount = 1;
        }

        private void ProcessStfld(ILInstruction instruction, ProgramState next)
        {
            var symbolicField = next.Stack.Pop();
            var symbolicValue = next.Stack.Pop();
            var symbolicObject = next.Stack.Pop();

            // Resolve field.
            uint fieldId = symbolicField.InferStackValue().U4;
            var field = (IFieldDescriptor) KoiStream.ResolveReference(Logger, instruction.Offset, fieldId,
                TableIndex.Field, TableIndex.MemberRef);

            // Add dependencies.
            instruction.Dependencies.AddOrMerge(1, symbolicField);
            instruction.Dependencies.AddOrMerge(2, symbolicObject);
            instruction.Dependencies.AddOrMerge(3, symbolicValue);

            // Create metadata.
            instruction.Annotation = new FieldAnnotation(VMCalls.STFLD, field)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 0
            };
        }

        private void ProcessThrow(ILInstruction instruction, ProgramState next)
        {
            var symbolicType = next.Stack.Pop();
            var symbolicException = next.Stack.Pop();
            
            // Resolve throw type.
            uint type = symbolicType.InferStackValue().U4;
            bool isRethrow = type == 1;

            // Add dependencies.
            instruction.Dependencies.AddOrMerge(1, symbolicType);
            instruction.Dependencies.AddOrMerge(2, symbolicException);

            // Create metadata.
            instruction.Annotation = new ThrowAnnotation(isRethrow)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 0
            };
        }

        private void ProcessToken(ILInstruction instruction, ProgramState next)
        {
            var symbolicToken = next.Stack.Pop();
            
            // Resolve member.
            uint memberId = symbolicToken.InferStackValue().U4;
            var member = KoiStream.ResolveReference(Logger, instruction.Offset, memberId,
                TableIndex.TypeRef,
                TableIndex.TypeDef,
                TableIndex.TypeSpec,
                TableIndex.Method,
                TableIndex.MethodSpec,
                TableIndex.Field,
                TableIndex.MemberRef);
            
            // Add dependencies.
            instruction.Dependencies.AddOrMerge(1, symbolicToken);
            
            // Push result.
            next.Stack.Push(new SymbolicValue(instruction, VMType.Object));

            // Create metadata.
            instruction.Annotation = new TokenAnnotation(member)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 1
            };
        }

        private void ProcessSizeOf(ILInstruction instruction, ProgramState next)
        {
            var symbolicType = next.Stack.Pop();

            // Resolve type.
            uint typeId = symbolicType.InferStackValue().U4;
            var type = (ITypeDefOrRef) KoiStream.ResolveReference(Logger, instruction.Offset, typeId,
                TableIndex.TypeDef,
                TableIndex.TypeRef,
                TableIndex.TypeSpec);

            // Add dependency.
            instruction.Dependencies.AddOrMerge(1, symbolicType);
            
            // Push value.
            next.Stack.Push(new SymbolicValue(instruction, VMType.Dword));

            // Add metadata.
            instruction.Annotation = new TypeAnnotation(VMCalls.SIZEOF, type)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 1
            };
        }

        private void ProcessCast(ILInstruction instruction, ProgramState next)
        {
            var symbolicType = next.Stack.Pop();
            var symbolicValue = next.Stack.Pop();

            // Resolve type and cast safety.
            uint typeId = symbolicType.InferStackValue().U4;
            bool isSafeCast = (typeId & 0x80000000) == 0;
            var type = (ITypeDefOrRef) KoiStream.ResolveReference(Logger, instruction.Offset,typeId & ~0x80000000,
                TableIndex.TypeDef,
                TableIndex.TypeRef,
                TableIndex.TypeSpec);

            // Add dependencies.
            instruction.Dependencies.AddOrMerge(1, symbolicType);
            instruction.Dependencies.AddOrMerge(2, symbolicValue);
            
            // Push new value.
            next.Stack.Push(new SymbolicValue(instruction, VMType.Object));

            // Add metadata.
            instruction.Annotation = new CastAnnotation(type, isSafeCast)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 1
            };
        }

        private void ProcessUnbox(ILInstruction instruction, ProgramState next)
        {
            var symbolicType = next.Stack.Pop();
            var symbolicValue = next.Stack.Pop();

            // Resolve type and unbox kind.
            uint typeId = symbolicType.InferStackValue().U4;
            bool isUnboxPtr = (typeId & 0x80000000) != 0;
            var type = (ITypeDefOrRef) KoiStream.ResolveReference(Logger, instruction.Offset, typeId & ~0x80000000,
                TableIndex.TypeDef,
                TableIndex.TypeRef,
                TableIndex.TypeSpec);

            // Add dependencies.
            instruction.Dependencies.AddOrMerge(1, symbolicType);
            instruction.Dependencies.AddOrMerge(2, symbolicValue);
            
            // Push new value.
            next.Stack.Push(new SymbolicValue(instruction, VMType.Object));

            // Add metadata.
            instruction.Annotation = new UnboxAnnotation(type, isUnboxPtr)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 1
            };
        }

        private void ProcessInitObj(ILInstruction instruction, ProgramState next)
        {
            var symbolicType = next.Stack.Pop();
            var symbolicValue = next.Stack.Pop();
            
            // Resolve type.
            uint typeId = symbolicType.InferStackValue().U4;
            var type = (ITypeDefOrRef) KoiStream.ResolveReference(Logger, instruction.Offset, typeId,
                TableIndex.TypeDef,
                TableIndex.TypeRef,
                TableIndex.TypeSpec);

            instruction.Dependencies.AddOrMerge(1, symbolicType);
            instruction.Dependencies.AddOrMerge(2, symbolicValue);
            
            instruction.Annotation = new TypeAnnotation(VMCalls.INITOBJ, type)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 0
            };
        }

        private void ProcessRangeChk(ILInstruction instruction, ProgramState next)
        {
            // Pop arguments.
            var symbolicValue = next.Stack.Pop();
            var symbolicMax = next.Stack.Pop();
            var symbolicMin = next.Stack.Pop();
            
            // Add dependencies.
            instruction.Dependencies.AddOrMerge(1, symbolicValue);
            instruction.Dependencies.AddOrMerge(2, symbolicMax);
            instruction.Dependencies.AddOrMerge(3, symbolicMin);

            // Push result.
            next.Stack.Push(new SymbolicValue(instruction, VMType.Qword));
            
            // Add metadata.
            instruction.Annotation = new VCallAnnotation(VMCalls.RANGECHK, VMType.Qword)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 1
            };
        }

        private void ProcessLocalloc(ILInstruction instruction, ProgramState next)
        {
            // Pop arguments.
            var symbolicLength = next.Stack.Pop();
            
            // Add dependencies.
            instruction.Dependencies.AddOrMerge(1, symbolicLength);

            // Push result.
            next.Stack.Push(new SymbolicValue(instruction, VMType.Qword));
            
            // Add metadata.
            instruction.Annotation = new VCallAnnotation(VMCalls.LOCALLOC, VMType.Pointer)
            {
                InferredPopCount = instruction.Dependencies.Count,
                InferredPushCount = 1
            };
        }
        
    }
}


================================================
File: src/OldRod.Core/Disassembly/Inference/VMFunction.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.ControlFlow;
using OldRod.Core.Memory;

namespace OldRod.Core.Disassembly.Inference
{
    public class VMFunction
    {
        public VMFunction(uint entrypointAddress, uint entryKey)
        {
            EntrypointAddress = entrypointAddress;
            EntryKey = entryKey;
        }

        public uint EntrypointAddress
        {
            get;
        }

        public uint EntryKey
        {
            get;
        }

        public uint? ExitKey
        {
            get;
            set;
        }

        public IFrameLayout FrameLayout
        {
            get;
            set;
        }

        public IDictionary<long, ILInstruction> Instructions
        {
            get;
        } = new Dictionary<long, ILInstruction>();

        public ISet<long> BlockHeaders
        {
            get;
        } = new HashSet<long>();
            
        public ISet<long> UnresolvedOffsets
        {
            get;
        } = new HashSet<long>();

        public ISet<FunctionReference> References
        {
            get;
        } = new HashSet<FunctionReference>();
        
        public byte SMCTrampolineKey 
        {
            get;
            set;
        }

        public OffsetRange SMCTrampolineOffsetRange 
        {
            get;
            set;
        }

        public override string ToString()
        {
            return $"function_{EntrypointAddress:X4}";
        }
    }
}


================================================
File: src/OldRod.Core/Emulation/EmulationException.cs
================================================
using System;

namespace OldRod.Core.Emulation
{
    public class EmulationException : Exception
    {
        public EmulationException()
        {
        }

        public EmulationException(string message)
            : base(message)
        {
        }

        public EmulationException(string message, Exception innerException) 
            : base(message, innerException)
        {
        }
    }
}


================================================
File: src/OldRod.Core/Emulation/InstructionEmulator.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using OldRod.Core.Architecture;

namespace OldRod.Core.Emulation
{
    // NOTE:
    // This emulator is more of a mini-emulator and is far from complete. As a result, the emulation might be very
    // inaccurate in lots of cases or result in an exception. Do not use for complete method emulation.
    
    public class InstructionEmulator
    {
        public InstructionEmulator()
        {
            for (int i = 0; i < (int) VMRegisters.Max; i++)
                Registers[(VMRegisters) i] = new VMSlot();
        }
        
        public IDictionary<VMRegisters, VMSlot> Registers
        {
            get;
        } = new Dictionary<VMRegisters, VMSlot>();
        
        public Stack<VMSlot> Stack
        {
            get;
        } = new Stack<VMSlot>();

        public void EmulateInstruction(ILInstruction instruction)
        {
            // TODO: Perhaps include flag register updates?

            Registers[VMRegisters.IP] = new VMSlot() {U8 = (ulong) (instruction.Offset + instruction.Size)};

            if (instruction.ProgramState is null)
            {
                throw new EmulationException(
                    $"Failed to infer stack depth of {instruction} because the instruction does not have a program state assigned.");
            }

            Registers[VMRegisters.SP] = new VMSlot() {U4 = (uint) instruction.ProgramState.Stack.Count};
            
            switch (instruction.OpCode.Code)
            {
                case ILCode.PUSHR_OBJECT:
                {
                    // TODO: This is definitely not accurate, but works for the purpose of this mini emulator (pushr_object sp).
                    Stack.Push(new VMSlot
                    {
                        U8 = Registers[(VMRegisters) instruction.Operand].U8 
                    });
                    break;
                }
                case ILCode.PUSHR_BYTE:
                    Stack.Push(new VMSlot
                    {
                        U1 = Registers[(VMRegisters) instruction.Operand].U1
                    });
                    break;
              
                case ILCode.PUSHR_WORD:
                    Stack.Push(new VMSlot
                    {
                        U2 = Registers[(VMRegisters) instruction.Operand].U2
                    });
                    break;
                
                case ILCode.PUSHR_DWORD:
                    Stack.Push(new VMSlot
                    {
                        U4 = Registers[(VMRegisters) instruction.Operand].U4
                    });
                    break;
                
                case ILCode.PUSHR_QWORD:
                    Stack.Push(new VMSlot
                    {
                        U8 = Registers[(VMRegisters) instruction.Operand].U8
                    });
                    break;

                case ILCode.PUSHI_DWORD:
                    uint imm = Convert.ToUInt32(instruction.Operand);
                    ulong sx = (imm & 0x80000000) != 0 ? 0xffffffffUL << 32 : 0;
                    Stack.Push(new VMSlot
                    {
                        U8 = sx | imm
                    });
                    break;
                
                case ILCode.PUSHI_QWORD:
                    Stack.Push(new VMSlot
                    {
                        U8 = Convert.ToUInt64(instruction.Operand)
                    });
                    break;

                case ILCode.ADD_DWORD:
                {
                    var op2 = Stack.Pop();
                    var op1 = Stack.Pop();
                    Stack.Push(new VMSlot
                    {
                        U4 = op1.U4 + op2.U4
                    });
                    break;
                }

                case ILCode.ADD_QWORD:
                {
                    var op2 = Stack.Pop();
                    var op1 = Stack.Pop();
                    Stack.Push(new VMSlot
                    {
                        U8 = op1.U8 + op2.U8
                    });
                    break;
                }

                case ILCode.POP:
                {
                    Registers[(VMRegisters) instruction.Operand] = Stack.Pop();
                    break;
                }
                
                case ILCode.NOP:
                    break;
                
                default:
                    throw new EmulationException($"Failed to emulate the instruction {instruction}.",
                        new NotSupportedException($"OpCode {instruction.OpCode.Code} not supported yet!"));
            }
        }
        
        public void EmulateDependentInstructions(ILInstruction instruction)
        {
            // TODO: Use data flow graph instead to determine order of instructions.
            var queue = instruction.GetAllDependencies()
                .OrderBy(x => x.Offset)
                .ToList();

            foreach (var source in queue)
                EmulateInstruction(source);
        }
    }
}


================================================
File: src/OldRod.Core/Emulation/VMSlot.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Runtime.InteropServices;

namespace OldRod.Core.Emulation
{
    [StructLayout(LayoutKind.Explicit)]
    public struct VMSlot
    {
        [FieldOffset(0)] 
        private ulong _u8;
        [FieldOffset(0)] 
        private double _r8;
        [FieldOffset(0)] 
        private uint _u4;
        [FieldOffset(0)] 
        private float _r4;
        [FieldOffset(0)] 
        private ushort _u2;
        [FieldOffset(0)] 
        private byte _u1;
        [FieldOffset(8)] 
        private object _o;

        public ulong U8
        {
            get => _u8;
            set
            {
                _u8 = value;
                _o = null;
            }
        }

        public uint U4
        {
            get => _u4;
            set
            {
                _u4 = value;
                _o = null;
            }
        }

        public ushort U2
        {
            get => _u2;
            set
            {
                _u2 = value;
                _o = null;
            }
        }

        public byte U1
        {
            get => _u1;
            set
            {
                _u1 = value;
                _o = null;
            }
        }

        public double R8
        {
            get => _r8;
            set
            {
                _r8 = value;
                _o = null;
            }
        }

        public float R4
        {
            get => _r4;
            set
            {
                _r4 = value;
                _o = null;
            }
        }

        public object O
        {
            get => _o;
            set
            {
                _o = value;
                _u8 = 0;
            }
        }
    }
}


================================================
File: src/OldRod.Core/Memory/DefaultFrameLayout.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures.Types;

namespace OldRod.Core.Memory
{
    public class DefaultFrameLayout : IFrameLayout
    {
        /* Vanilla KoiVM uses the following stack frame layout.
         * Assuming that n is the number of arguments, and m is the number of
         * local variables, vanilla KoiVM then uses the following stack layout:
         *
         *  | Offset | Value
         *  +--------+---------------
         *  | BP - n | Argument 0
         *  : ...    : ...
         *  | BP - 3 | Argument n-2
         *  | BP - 2 | Argument n-1
         *  | BP - 1 | Return Address
         *  | BP     | Caller's BP
         *  | BP + 1 | Local 0
         *  | BP + 2 | Local 1
         *  : ...    : ...
         *  | BP + m | Local m-1
         *
         * Locals are allocated by simply increasing the SP pointer, like many
         * other calling conventions do.
         */
        
        private readonly ModuleDefinition _module;

        public const string Tag = "FrameLayout";

        public DefaultFrameLayout(
            ModuleDefinition module, 
            IList<TypeSignature> parameters,
            IList<TypeSignature> locals, 
            TypeSignature returnType,
            bool hasThis)
        {
            _module = module;
            for (int i = 0; i < parameters.Count; i++)
                Parameters.Add(new FrameField(i, FrameFieldKind.Parameter, true, parameters[i]));
            for (int i = 0; i < locals.Count; i++)
                Parameters.Add(new FrameField(i, FrameFieldKind.LocalVariable, true, locals[i]));
            ReturnType = returnType;
            HasThis = hasThis;
        }
        
        public IList<FrameField> Parameters
        {
            get;
        } = new List<FrameField>();

        public IList<FrameField> Locals
        {
            get;
        } = new List<FrameField>();

        public TypeSignature ReturnType
        {
            get;
        }

        public bool HasThis
        {
            get;
        }

        public bool ReturnsValue => ReturnType == null || !ReturnType.IsTypeOf("System", "Void");

        public FrameField Resolve(int offset)
        {
            if (offset <= -2)
            {
                int argumentIndex = Parameters.Count + offset + 1;
                if (argumentIndex < 0 || argumentIndex >= Parameters.Count)
                    return new FrameField(argumentIndex, FrameFieldKind.Parameter, false, null);

                return Parameters[argumentIndex];
            }

            switch (offset)
            {
                case -1:
                    return new FrameField(0, FrameFieldKind.ReturnAddress, true, _module.CorLibTypeFactory.IntPtr);
                case 0:
                    return new FrameField(0, FrameFieldKind.CallersBasePointer, true, _module.CorLibTypeFactory.IntPtr);
                default:
                    int variableIndex = offset - 1;
                    if (variableIndex >= 0 && variableIndex < Locals.Count)
                        return Locals[variableIndex];
                    return new FrameField(variableIndex, FrameFieldKind.LocalVariable, true, null);
            }
        }
        
    }
}


================================================
File: src/OldRod.Core/Memory/DefaultFrameLayoutDetector.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures.Types;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly;
using OldRod.Core.Disassembly.Annotations;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Core.Memory
{
    public class DefaultFrameLayoutDetector : IFrameLayoutDetector
    {
        public const string Tag = "FrameLayoutDetector";
        
        public IFrameLayout DetectFrameLayout(VMConstants constants, ModuleDefinition module,
            VMFunction function)
        {
            if (function.References.Count == 0)
                throw new ArgumentException("Can only infer frame layout of a function that is at least referenced once.");

            var exceptions = new List<Exception>();
            
            // Order the references by reference type, as LDFTN references are more reliable.
            foreach (var reference in function.References.OrderBy(r => r.ReferenceType))
            {
                try
                {
                    switch (reference.ReferenceType)
                    {
                        case FunctionReferenceType.Call:
                            return InferLayoutFromCallReference(module, reference);
                        case FunctionReferenceType.Ldftn:
                            return InferLayoutFromLdftnReference(constants, module, reference);
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                }
                catch (Exception ex)
                {
                    exceptions.Add(ex);
                }
            }

            throw new AggregateException(
                $"Failed to infer the stack frame layout of function_{function.EntrypointAddress:X4}.", exceptions);
        }

        private static IFrameLayout InferLayoutFromLdftnReference(VMConstants constants, ModuleDefinition module, FunctionReference reference)
        {
            // LDFTN instructions reference a physical method, or an export defined in the export table containing
            // the signature of an intra-linked method. We can therefore reliably extract the necessary information
            // without too much guessing.
            
            var ldftn = reference.Caller.Instructions[reference.Offset];
            var annotation = (LdftnAnnotation) ldftn.Annotation;

            var parameterTypes = new List<TypeSignature>();
            TypeSignature returnType;
            bool hasThis;
            
            if (annotation.IsIntraLinked)
            {
                returnType = ((ITypeDefOrRef) module.LookupMember(annotation.Signature.ReturnToken))
                    .ToTypeSignature();

                foreach (var token in annotation.Signature.ParameterTokens)
                {
                    parameterTypes.Add(((ITypeDefOrRef) module.LookupMember(token))
                        .ToTypeSignature());
                }

                hasThis = (annotation.Signature.Flags & constants.FlagInstance) != 0;
            }
            else
            {
                var methodSig = annotation.Method.Signature;
                foreach (var parameterType in methodSig.ParameterTypes)
                    parameterTypes.Add(parameterType);
                returnType = methodSig.ReturnType;
                hasThis = methodSig.HasThis;
            }

            return new DefaultFrameLayout(
                module,
                parameterTypes,
                Array.Empty<TypeSignature>(),
                returnType,
                hasThis);
        }

        private static IFrameLayout InferLayoutFromCallReference(ModuleDefinition module, FunctionReference reference)
        {
            // This is kind of a hack, but works perfectly fine for vanilla KoiVM.  
            //
            // Vanilla KoiVM uses the calling convention where the caller cleans up the stack after the call.
            // The assumption is that each post-call code of the function is using the default calling convention is
            // in some variation of the following code: 
            // 
            //    CALL                                  ; Original call instruction.
            //
            //    PUSHR_xxxx R0                         ; Only present if the function returns something.      
            //    POP R0
            //
            //    PUSHR_DWORD SP                        ; Clean up of arguments on the stack.  
            //    PUSHI_DWORD <number of parameters>      
            //    ADD_DWORD                 
            //    POP SP
            //
            // Note that forks can deviate from this.
            //

            // Find the POP SP instruction.
            bool returnsValue = false;
            
            int currentOffset = reference.Offset;
            ILInstruction instruction;
            do
            {
                if (!reference.Caller.Instructions.TryGetValue(currentOffset, out instruction))
                {
                    throw new FrameLayoutDetectionException(
                        $"Could not infer the number of arguments of function_{reference.Callee.EntrypointAddress:X4} " +
                        $"due to an incomplete or unsupported post-call of IL_{reference.Offset:X4} (function_{reference.Caller.EntrypointAddress:X4}).",
                        new DisassemblyException(
                            $"Offset IL_{currentOffset:X4} is not disassembled or does not belong to function_{reference.Caller.EntrypointAddress:X4}."));
                }

                switch (instruction.OpCode.Code)
                {
                    case ILCode.PUSHR_BYTE:
                    case ILCode.PUSHR_WORD:
                    case ILCode.PUSHR_DWORD:
                    case ILCode.PUSHR_QWORD:
                    case ILCode.PUSHR_OBJECT:

                        if ((VMRegisters) instruction.Operand == VMRegisters.R0)
                            returnsValue = true;
                        break;
                }

                currentOffset += instruction.Size;
            } while (instruction.OpCode.Code != ILCode.POP || (VMRegisters) instruction.Operand != VMRegisters.SP);

            // The number of arguments pushed onto the stack is the number of values implicitly popped from the stack
            // at this POP SP instruction.
            int argumentCount = instruction.Annotation.InferredPopCount - 1;

            return new DefaultFrameLayout(
                module,
                Enumerable.Repeat<TypeSignature>(null, argumentCount).ToList(),
                Array.Empty<TypeSignature>(),
                returnsValue ? module.CorLibTypeFactory.Object : module.CorLibTypeFactory.Void,
                false);
        }

        public IFrameLayout DetectFrameLayout(VMConstants constants, ModuleDefinition module, VMExportInfo export)
        {   
            var parameterTypes = new List<TypeSignature>();
            foreach (var token in export.Signature.ParameterTokens)
            {
                parameterTypes.Add(((ITypeDefOrRef) module.LookupMember(token))
                    .ToTypeSignature());
            }

            var returnType = ((ITypeDefOrRef) module.LookupMember(export.Signature.ReturnToken))
                .ToTypeSignature();

            bool hasThis = (export.Signature.Flags & constants.FlagInstance) != 0;
            
            return new DefaultFrameLayout(
                module,
                parameterTypes,
                Array.Empty<TypeSignature>(),
                returnType,
                hasThis);
        }
        
    }
}


================================================
File: src/OldRod.Core/Memory/FrameField.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.


using AsmResolver.DotNet.Signatures.Types;

namespace OldRod.Core.Memory
{
    public struct FrameField
    {
        public FrameField(int index, FrameFieldKind fieldKind, bool isValid, TypeSignature type)
        {
            Index = index;
            FieldKind = fieldKind;
            IsValid = isValid;
            Type = type;
        }
        
        public int Index
        {
            get;
        }

        public FrameFieldKind FieldKind
        {
            get;
        }

        public bool IsValid
        {
            get;
        }

        public TypeSignature Type
        {
            get;
        }
    }
}


================================================
File: src/OldRod.Core/Memory/FrameFieldKind.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
namespace OldRod.Core.Memory
{
    public enum FrameFieldKind
    {
        Parameter,
        ReturnAddress,
        CallersBasePointer,
        LocalVariable,
    }
}


================================================
File: src/OldRod.Core/Memory/FrameLayoutDetectionException.cs
================================================
using System;

namespace OldRod.Core.Memory
{
    public class FrameLayoutDetectionException : Exception
    {
        public FrameLayoutDetectionException(string message) 
            : base(message)
        {
        }

        public FrameLayoutDetectionException(string message, Exception innerException)
            : base(message, innerException)
        {
        }
    }
}


================================================
File: src/OldRod.Core/Memory/IFrameLayout.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.DotNet.Signatures.Types;

namespace OldRod.Core.Memory
{
    public interface IFrameLayout
    {
        IList<FrameField> Parameters
        {
            get;
        }
        
        IList<FrameField> Locals
        {
            get;
        }
        
        TypeSignature ReturnType
        {
            get;
        }

        bool HasThis
        {
            get;
        }
        
        bool ReturnsValue
        {
            get;
        }
        
        FrameField Resolve(int offset);
    }
}


================================================
File: src/OldRod.Core/Memory/IFrameLayoutDetector.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Core.Memory
{
    public interface IFrameLayoutDetector
    {
        IFrameLayout DetectFrameLayout(VMConstants constants, ModuleDefinition module, VMFunction function);
        
        IFrameLayout DetectFrameLayout(VMConstants constants, ModuleDefinition module, VMExportInfo export);
    }
}


================================================
File: src/OldRod.Core/Recompiler/ILToCilRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.ControlFlow;
using OldRod.Core.Disassembly.DataFlow;
using OldRod.Core.Recompiler.Transform;

namespace OldRod.Core.Recompiler
{
    public class ILToCilRecompiler : IILAstVisitor<CilAstNode>
    {
        public const string Tag = "IL2CIL";
        
        public event EventHandler<CilCompilationUnit> InitialAstBuilt;
        public event EventHandler<CilTransformEventArgs> TransformStart;
        public event EventHandler<CilTransformEventArgs> TransformEnd;
        
        private readonly RecompilerContext _context;

        public ILToCilRecompiler(CilMethodBody methodBody, ModuleDefinition targetModule, IVMFunctionResolver exportResolver)
        {
            _context = new RecompilerContext(methodBody, targetModule, this, exportResolver);
        }

        public ILogger Logger
        {
            get => _context.Logger;
            set => _context.Logger = value;
        }

        public bool InferParameterTypes
        {
            get;
            set;
        }

        public CilCompilationUnit Recompile(ILCompilationUnit unit)
        {
            Logger.Debug(Tag, $"Building initial CIL AST...");
            var cilUnit = (CilCompilationUnit) unit.AcceptVisitor(this);
            OnInitialAstBuilt(cilUnit);
            
            Logger.Debug(Tag, $"Applying CIL AST transformations...");
            ApplyTransformations(cilUnit);

            foreach (var variable in _context.Variables.Values)
            {
                if (variable.AssignedBy.Count == 0 && variable.UsedBy.Count == 0)
                    cilUnit.Variables.Remove(variable);
            }
            
            return cilUnit;
        }

        private void ApplyTransformations(CilCompilationUnit cilUnit)
        {
            var transforms = new ICilAstTransform[]
            {
                new TypeInference(),
                new ArrayAccessTransform(),
                new TypeConversionInsertion(),
                new BoxMinimizer(), 
            };

            foreach (var transform in transforms)
            {
                var args = new CilTransformEventArgs(cilUnit, transform);
                Logger.Debug2(Tag, $"Applying {transform.Name}...");
                
                OnTransformStart(args);
                transform.ApplyTransformation(_context, cilUnit);
                OnTransformEnd(args);
            }
        }

        public CilAstNode VisitCompilationUnit(ILCompilationUnit unit)
        {
            var result = new CilCompilationUnit(unit.ControlFlowGraph);

            // Convert variables.
            foreach (var variable in unit.Variables)
            {
                switch (variable)
                {
                    case ILFlagsVariable _:
                    {
                        CilVariable cilVariable;
                        
                        if (result.FlagVariable == null)
                        {
                            cilVariable = new CilVariable("FL", _context.TargetModule.CorLibTypeFactory.Byte);
                            
                            result.FlagVariable = cilVariable;
                            _context.FlagVariable = cilVariable;
                            result.Variables.Add(cilVariable);
                        }

                        cilVariable = result.FlagVariable;
                        _context.Variables[variable] = cilVariable;
                        break;
                    }

                    case ILParameter parameter:
                    {
                        var methodBody = _context.MethodBody;
                        var physicalParameter = methodBody.Owner.Parameters.GetBySignatureIndex(parameter.ParameterIndex);
                        bool isThisParameter = physicalParameter == methodBody.Owner.Parameters.ThisParameter;
                        
                        var cilParameter = new CilParameter(
                            parameter.Name,
                            physicalParameter.ParameterType,
                            parameter.ParameterIndex,
                            !InferParameterTypes || isThisParameter);

                        result.Parameters.Add(cilParameter);
                        _context.Parameters[parameter] = cilParameter;
                        break;
                    }

                    default:
                    {
                        var cilVariable = new CilVariable(variable.Name, variable.VariableType
                            .ToMetadataType(_context.TargetModule)
                            .ToTypeSignature());
                        result.Variables.Add(cilVariable);
                        _context.Variables[variable] = cilVariable;
                        break;
                    }
                }
            }

            if (result.FlagVariable == null)
            {
                var flagVariable = new CilVariable("FL", _context.TargetModule.CorLibTypeFactory.Byte);
                result.FlagVariable = flagVariable;
                _context.FlagVariable = flagVariable;
                result.Variables.Add(flagVariable);
            }

            // Create all Cil blocks.
            foreach (var node in result.ControlFlowGraph.Nodes)
                node.UserData[CilAstBlock.AstBlockProperty] = new CilAstBlock();

            // Convert all IL blocks.
            foreach (var node in result.ControlFlowGraph.Nodes)
            {
                var ilBlock = (ILAstBlock) node.UserData[ILAstBlock.AstBlockProperty];
                var cilBlock = (CilAstBlock) ilBlock.AcceptVisitor(this);
                node.UserData[CilAstBlock.AstBlockProperty] = cilBlock;
            }
            
            return result;
        }

        public CilAstNode VisitBlock(ILAstBlock block)
        {
            var currentNode = block.GetParentNode();
            var result = (CilAstBlock) currentNode.UserData[CilAstBlock.AstBlockProperty];
            foreach (var statement in block.Statements)
                result.Statements.Add((CilStatement) statement.AcceptVisitor(this));
            return result;
        }

        public CilAstNode VisitExpressionStatement(ILExpressionStatement statement)
        {
            // Compile embedded expression.
            var node = statement.Expression.AcceptVisitor(this);
            
            // Some recompilers actually recompile the embedded expression directly to a statement (e.g. jump recompilers). 
            // If the result is just a normal expression, we need to embed it into an expression statement.
            if (node is CilExpression expression)
            {
                // Check if the expression returned anything, and therefore needs to be popped from the stack
                // as it is not used.
                if (expression.ExpressionType != null
                    && !expression.ExpressionType.IsTypeOf("System", "Void"))
                {
                    expression = new CilInstructionExpression(CilOpCodes.Pop, null, expression);
                }

                return new CilExpressionStatement(expression);
            }

            return (CilStatement) node;
        }

        public CilAstNode VisitAssignmentStatement(ILAssignmentStatement statement)
        {
            // Compile value.
            var cilExpression = (CilExpression) statement.Value.AcceptVisitor(this);
            
            // Create assignment.
            var cilVariable = _context.Variables[statement.Variable];

            cilExpression.ExpectedType = cilVariable.VariableType;
            return new CilAssignmentStatement(cilVariable, cilExpression);
        }

        public CilAstNode VisitInstructionExpression(ILInstructionExpression expression)
        {
            // Jumps and returns are dealt with directly as they produce statements rather than expressions.

            if (expression.OpCode.Code == ILCode.LEAVE)
                return TranslateLeaveExpression(expression);
            
            switch (expression.OpCode.FlowControl)
            {
                case ILFlowControl.Jump:
                    return TranslateJumpExpression(expression);
                case ILFlowControl.ConditionalJump:
                    return TranslateConditionalJumpExpression(expression);
                case ILFlowControl.Return:
                    return TranslateRetExpression(expression);
                default:
                    // Forward the call to the appropriate recompiler of the opcode.
                    return RecompilerService.GetOpCodeRecompiler(expression.OpCode.Code).Translate(_context, expression);
            }
        }

        private CilStatement TranslateRetExpression(ILInstructionExpression expression)
        {
            var node = expression.GetParentNode();

            CilOpCode opCode;
            ITypeDescriptor expectedType;
            
            // KoiVM uses ret for exiting finally and filter blocks. Therefore, if it is part of a subgraph,
            // then adjust accordingly and choose the appropriate opcode and expected return type.
            if (node.SubGraphs.Count == 0)
            {
                expectedType = _context.MethodBody.Owner.Signature!.ReturnType;
                opCode = CilOpCodes.Ret;
            }
            else
            {
                if (!node.UserData.TryGetValue(ControlFlowGraph.TopMostEHProperty, out var data))
                    throw new RecompilerException($"Exit node {node.Name} within an EH does not contain top most EH information.");

                switch (((EHFrame) data).Type)
                {
                    case EHType.FILTER:
                        opCode = CilOpCodes.Endfilter;
                        expectedType = _context.TargetModule.CorLibTypeFactory.Boolean;
                        break;

                    case EHType.FAULT:
                    case EHType.FINALLY:
                        opCode = CilOpCodes.Endfinally;
                        expectedType = null;
                        break;

                    case EHType.CATCH:
                        throw new RecompilerException($"Exit node {node.Name} attempts to return from a catch block.");
                    
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            // Build final expression.
            var expr = new CilInstructionExpression(opCode);
            if (expression.Arguments.Count > 0)
            {
                var value = (CilExpression) expression.Arguments[0].AcceptVisitor(this);
                value.ExpectedType = expectedType;
                expr.Arguments.Add(value);
            }

            // Wrap into stand-alone statement.
            return new CilExpressionStatement(expr);
        }

        private CilStatement TranslateJumpExpression(ILInstructionExpression expression)
        {
            var currentNode = expression.GetParentNode();
            var targetNode = currentNode.OutgoingEdges.First().Target;
            
            var targetBlock = (CilAstBlock) targetNode.UserData[CilAstBlock.AstBlockProperty];
            bool isLeave = currentNode.SubGraphs.Except(targetNode.SubGraphs).Any();
                
            return new CilExpressionStatement(new CilInstructionExpression(
                isLeave ? CilOpCodes.Leave : CilOpCodes.Br, 
                new CilInstructionLabel(targetBlock.BlockHeader)));
        }

        private CilStatement TranslateConditionalJumpExpression(ILInstructionExpression expression)
        {
            // Choose the right opcode.
            switch (expression.OpCode.Code)
            {
                case ILCode.JZ:
                    return TranslateSimpleCondJumpExpression(expression, CilOpCodes.Brfalse);
                case ILCode.JNZ:
                    return TranslateSimpleCondJumpExpression(expression, CilOpCodes.Brtrue);
                case ILCode.SWT:
                    return TranslateSwitchExpression(expression);
                default:
                    throw new ArgumentOutOfRangeException(nameof(expression));
            }
        }

        private CilStatement TranslateSimpleCondJumpExpression(ILInstructionExpression expression, CilOpCode opCode)
        {          
            // Figure out target blocks.
            var currentNode = expression.GetParentNode();
            var trueBlock = (CilAstBlock) currentNode.OutgoingEdges
                .First(x => x.UserData.ContainsKey(ControlFlowGraph.ConditionProperty))
                .Target
                .UserData[CilAstBlock.AstBlockProperty];
            
            var falseBlock = (CilAstBlock) currentNode.OutgoingEdges
                .First(x => !x.UserData.ContainsKey(ControlFlowGraph.ConditionProperty))
                .Target
                .UserData[CilAstBlock.AstBlockProperty];

            // Create conditional jump.
            var conditionalBranch = new CilInstructionExpression(opCode,
                new CilInstructionLabel(trueBlock.BlockHeader));
            conditionalBranch.Arguments.Add((CilExpression) expression.Arguments[0].AcceptVisitor(this));
            
            return new CilAstBlock
            {
                Statements =
                {
                    // Add conditional jump.
                    new CilExpressionStatement(conditionalBranch),
                    
                    // Create fall through jump:
                    // TODO: optimise away in code generator?
                    new CilExpressionStatement(new CilInstructionExpression(CilOpCodes.Br, 
                        new CilInstructionLabel(falseBlock.BlockHeader))),
                }
            };   
        }

        private CilStatement TranslateSwitchExpression(ILInstructionExpression expression)
        {
            var currentNode = expression.GetParentNode();

            var caseBlocks = new Dictionary<int, CilAstBlock>();
            CilAstBlock defaultBlock = null; 
            foreach (var edge in currentNode.OutgoingEdges)
            {
                var targetBlock = (CilAstBlock) edge.Target.UserData[CilAstBlock.AstBlockProperty];
                
                // Check if the branch contains any conditions.
                if (edge.UserData.TryGetValue(ControlFlowGraph.ConditionProperty, out var c))
                {
                    // Collect all block targets.
                    var conditions = (IEnumerable<int>) c;
                    
                    foreach (int condition in conditions)
                    {
                        // Ignore abnormal (EH) edges.
                        if (condition != ControlFlowGraph.ExceptionConditionLabel
                            && condition != ControlFlowGraph.EndFinallyConditionLabel)
                        {
                            caseBlocks[condition] = targetBlock;
                        }
                    } 
                        
                }
                // Fall-through edge = the default case.
                else if (defaultBlock == null)
                {
                    defaultBlock = targetBlock;
                }
                // Sanity check: Multiple fall-through edges should be impossible.
                else
                {
                    throw new RecompilerException(
                        "Encountered a switch instruction that has multiple default case blocks."
                        + " This could mean the IL AST builder contains a bug or is incomplete. For more details, inspect "
                        + "the control flow graphs generated by the IL AST builder and each transform.");
                }
            }

            // Sanity check: A switch should have one default edge.
            if (defaultBlock == null)
            {
                throw new RecompilerException(
                    "Encountered a switch instruction that does not have an edge to a default case block."
                    + " This could mean the IL AST builder contains a bug or is incomplete. For more details, inspect "
                    + "the control flow graphs generated by the IL AST builder and each transform.");
            }

            // Construct labels array, and fill up the gaps.
            var caseLabels = new List<CilAstBlock>(caseBlocks.Count);
            foreach (var entry in caseBlocks.OrderBy(e => e.Key))
            {
                // Fill up the gaps with labels to the default case.
                for (int i = caseLabels.Count; i < entry.Key; i++)
                    caseLabels.Add(defaultBlock);
                
                // Add label to target case block.
                caseLabels.Add(entry.Value);
            }

            // Construct switch.
            var valueExpression = (CilExpression) expression.Arguments[1].AcceptVisitor(this);
            valueExpression.ExpectedType = _context.TargetModule.CorLibTypeFactory.Int32;
            
            var table = caseLabels
                .Select(x => (ICilLabel) new CilInstructionLabel(x.BlockHeader))
                .ToArray();
            
            var switchExpression = new CilInstructionExpression(CilOpCodes.Switch, table, valueExpression);

            return new CilAstBlock
            {
                Statements =
                {
                    // Add conditional jump.
                    new CilExpressionStatement(switchExpression),

                    // Create fall through jump:
                    // TODO: optimise away in code generator?
                    new CilExpressionStatement(new CilInstructionExpression(CilOpCodes.Br,
                        new CilInstructionLabel(defaultBlock.BlockHeader))),
                }
            };
        }

        private CilStatement TranslateLeaveExpression(ILInstructionExpression expression)
        {
            var targetBlock = (CilAstBlock) expression.GetParentNode().OutgoingEdges.First()
                .Target.UserData[CilAstBlock.AstBlockProperty];
            
            var result = new CilInstructionExpression(CilOpCodes.Leave, 
                new CilInstructionLabel(targetBlock.BlockHeader));
            return new CilExpressionStatement(result);
        }

        public CilAstNode VisitVariableExpression(ILVariableExpression expression)
        {
            var cilVariable = expression.Variable is ILParameter parameter
                ? _context.Parameters[parameter]
                : _context.Variables[expression.Variable];

            var result = new CilVariableExpression(cilVariable)
            {
                ExpressionType = cilVariable.VariableType,
                IsReference = expression.IsReference,
            };

            if (expression.IsReference)
                result.ExpressionType = new ByReferenceTypeSignature((TypeSignature) result.ExpressionType);
            
            return result;
        }

        public CilAstNode VisitVCallExpression(ILVCallExpression expression)
        {
            return RecompilerService.GetVCallRecompiler(expression.Call).Translate(_context, expression);
        }

        public CilAstNode VisitPhiExpression(ILPhiExpression expression)
        {
            // This method should never be reached.
            
            // If it does, that means the IL AST builder did not clean up all phi nodes,
            // which could mean there is an error in one of the transformations that the
            // IL AST builder performs.
            
            throw new RecompilerException(
                "Encountered a stray phi node in the IL AST. This could mean the IL AST builder contains a "
                + "bug or is incomplete. For more details, inspect the control flow graphs generated by the IL AST "
                + "builder and each transform.");
        }

        public CilAstNode VisitExceptionExpression(ILExceptionExpression expression)
        {
            // HACK: Leave the exception object on the stack.
            return new CilInstructionExpression(CilOpCodes.Nop)
            {
                ExpressionType = expression.ExceptionType
            }; 
        }

        protected virtual void OnInitialAstBuilt(CilCompilationUnit cilUnit)
        {
            InitialAstBuilt?.Invoke(this, cilUnit);
        }

        protected virtual void OnTransformStart(CilTransformEventArgs e)
        {
            TransformStart?.Invoke(this, e);
        }

        protected virtual void OnTransformEnd(CilTransformEventArgs e)
        {
            TransformEnd?.Invoke(this, e);
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/IVMFunctionResolver.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;

namespace OldRod.Core.Recompiler
{
    public interface IVMFunctionResolver
    {
        MethodDefinition ResolveMethod(uint functionAddress);
    }
}


================================================
File: src/OldRod.Core/Recompiler/RecompilerContext.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Recompiler.Transform;

namespace OldRod.Core.Recompiler
{
    public class RecompilerContext
    {
        private readonly Stack<GenericContext> _genericContexts = new Stack<GenericContext>();
        
        public RecompilerContext(CilMethodBody methodBody, ModuleDefinition targetModule,
            ILToCilRecompiler recompiler, IVMFunctionResolver exportResolver)
        {
            MethodBody = methodBody ?? throw new ArgumentNullException(nameof(methodBody));
            TargetModule = targetModule ?? throw new ArgumentNullException(nameof(targetModule));
            Recompiler = recompiler ?? throw new ArgumentNullException(nameof(recompiler));
            ExportResolver = exportResolver ?? throw new ArgumentNullException(nameof(exportResolver));
            ReferenceImporter = new ReferenceImporter(targetModule);
            TypeHelper = new TypeHelper(ReferenceImporter);
            _genericContexts.Push(new GenericContext(null, null));
        }

        public ILogger Logger
        {
            get;
            set;
        } = EmptyLogger.Instance;
        
        public CilMethodBody MethodBody
        {
            get;
        }

        public ModuleDefinition TargetModule
        {
            get;
        }

        public IVMFunctionResolver ExportResolver
        {
            get;
        }

        public ILToCilRecompiler Recompiler
        {
            get;
        }

        public ReferenceImporter ReferenceImporter
        {
            get;
        }

        public TypeHelper TypeHelper
        {
            get;
        }
        
        public IDictionary<ILVariable, CilVariable> Variables
        {
            get;
        } = new Dictionary<ILVariable, CilVariable>();

        public IDictionary<ILParameter, CilParameter> Parameters
        {
            get;
        } = new Dictionary<ILParameter, CilParameter>();
        
        public CilVariable FlagVariable
        {
            get;
            set;
        }

        public GenericContext GenericContext => _genericContexts.Peek();
        
        public void EnterMember(IMetadataMember member)
        {
            IGenericArgumentsProvider type = null;
            IGenericArgumentsProvider method = null;

            if (member is TypeSpecification typeSpec)
            {
                type = typeSpec.Signature as GenericInstanceTypeSignature;
            }
            else if (member is IMemberDescriptor memberRef)
            {
                if (memberRef.DeclaringType is TypeSpecification declaringType)
                    type = declaringType.Signature as GenericInstanceTypeSignature;
                if (member is MethodSpecification methodSpec)
                    method = methodSpec.Signature;
            }

            _genericContexts.Push(new GenericContext(type, method));
        }

        public void ExitMember()
        {
            _genericContexts.Pop();
        }
        
        public IList<CilExpression> RecompileCallArguments(
            IMethodDescriptor method, 
            IList<ILExpression> arguments,
            VMECallOpCode opCode,
            ITypeDescriptor constrainedType = null)
        {
            var methodSig = method.Signature;
            var result = new List<CilExpression>();
            
            // Emit arguments.
            for (var i = 0; i < arguments.Count; i++)
            {
                // Recompile argument.
                var cilArgument = (CilExpression) arguments[i].AcceptVisitor(Recompiler);

                // Figure out expected argument type.
                TypeSignature argumentType;
                if (methodSig.HasThis && opCode != VMECallOpCode.NEWOBJ)
                {
                    // Instance method invocation.
                    
                    if (i == 0)
                    {
                        // First parameter is the object instance that this method is called on (implicit this parameter).
                        argumentType = constrainedType?.ToTypeSignature() ?? method.DeclaringType.ToTypeSignature();
                        
                        // Calls on instance methods of value types need the this parameter to be passed on by-ref.
                        if (argumentType.IsValueType)
                            argumentType = new ByReferenceTypeSignature(argumentType);
                    }
                    else
                    {
                        argumentType = methodSig.ParameterTypes[i - 1];
                    }
                }
                else
                {
                    // Static method invocation.
                    argumentType = methodSig.ParameterTypes[i];
                }

                cilArgument.ExpectedType = argumentType.InstantiateGenericTypes(GenericContext);
                result.Add(cilArgument);
            }
            return result;
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/RecompilerException.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;

namespace OldRod.Core.Recompiler
{
    public class RecompilerException : Exception
    {
        public RecompilerException(string message) 
            : base(message)
        {
        }

        public RecompilerException(string message, Exception innerException) 
            : base(message, innerException)
        {
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/RecompilerService.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Recompiler.IL;
using OldRod.Core.Recompiler.VCall;

namespace OldRod.Core.Recompiler
{
    public static class RecompilerService
    {
        private static readonly IDictionary<ILCode, IOpCodeRecompiler> OpCodeRecompilers =
            new Dictionary<ILCode, IOpCodeRecompiler>();
        
        private static readonly IDictionary<VMCalls, IVCallRecompiler> VCallRecompilers =
            new Dictionary<VMCalls, IVCallRecompiler>();

        static RecompilerService()
        {
            SetupOpCodeRecompilers();
            SetupVCallRecompilers();
        }

        private static void SetupOpCodeRecompilers()
        {
            var nop = new NopRecompiler();
            OpCodeRecompilers[ILCode.NOP] = nop;
            OpCodeRecompilers[ILCode.TRY] = nop;
            
            // Push
            var push = new PushRecompiler();
            OpCodeRecompilers[ILCode.PUSHR_BYTE] = push;
            OpCodeRecompilers[ILCode.PUSHR_WORD] = push;
            OpCodeRecompilers[ILCode.PUSHR_DWORD] = push;
            OpCodeRecompilers[ILCode.PUSHR_QWORD] = push;
            OpCodeRecompilers[ILCode.PUSHR_OBJECT] = push;
            OpCodeRecompilers[ILCode.PUSHI_DWORD] = push;
            OpCodeRecompilers[ILCode.PUSHI_QWORD] = push;

            // Add
            var add = new SimpleOpCodeRecompiler(CilOpCodes.Add,
                ILCode.ADD_DWORD, ILCode.ADD_QWORD, ILCode.ADD_R32, ILCode.ADD_R64);
            OpCodeRecompilers[ILCode.ADD_DWORD] = add;
            OpCodeRecompilers[ILCode.ADD_QWORD] = add;
            OpCodeRecompilers[ILCode.ADD_R32] = add;
            OpCodeRecompilers[ILCode.ADD_R64] = add;

            // Sub
            var sub = new SimpleOpCodeRecompiler(CilOpCodes.Sub,
                ILCode.SUB_R32, ILCode.SUB_R64, ILCode.__SUB_DWORD, ILCode.__SUB_QWORD);
            OpCodeRecompilers[ILCode.SUB_R32] = sub;
            OpCodeRecompilers[ILCode.SUB_R64] = sub;
            
            // Mul
            var mul = new SimpleOpCodeRecompiler(CilOpCodes.Mul,
                ILCode.MUL_R32, ILCode.MUL_R64, ILCode.MUL_DWORD, ILCode.MUL_QWORD);
            OpCodeRecompilers[ILCode.MUL_R32] = mul;
            OpCodeRecompilers[ILCode.MUL_R64] = mul;
            OpCodeRecompilers[ILCode.MUL_DWORD] = mul;
            OpCodeRecompilers[ILCode.MUL_QWORD] = mul;
            
            // Div
            var div = new SimpleOpCodeRecompiler(CilOpCodes.Div_Un,
                ILCode.DIV_R32, ILCode.DIV_R64, ILCode.DIV_DWORD, ILCode.DIV_QWORD);
            OpCodeRecompilers[ILCode.DIV_R32] = div;
            OpCodeRecompilers[ILCode.DIV_R64] = div;
            OpCodeRecompilers[ILCode.DIV_DWORD] = div;
            OpCodeRecompilers[ILCode.DIV_QWORD] = div;
            
            // Rem
            var rem = new SimpleOpCodeRecompiler(CilOpCodes.Rem_Un,
                ILCode.REM_R32, ILCode.REM_R64, ILCode.REM_DWORD, ILCode.REM_QWORD);
            OpCodeRecompilers[ILCode.REM_R32] = rem;
            OpCodeRecompilers[ILCode.REM_R64] = rem;
            OpCodeRecompilers[ILCode.REM_DWORD] = rem;
            OpCodeRecompilers[ILCode.REM_QWORD] = rem;
            
            // Shr
            var shr = new SimpleOpCodeRecompiler(CilOpCodes.Shr_Un, // TODO: support signed shift
                ILCode.SHR_DWORD, ILCode.SHR_QWORD);
            OpCodeRecompilers[ILCode.SHR_DWORD] = shr;
            OpCodeRecompilers[ILCode.SHR_QWORD] = shr;
            
            // Shl
            var shl = new SimpleOpCodeRecompiler(CilOpCodes.Shl,
                ILCode.SHL_DWORD, ILCode.SHL_QWORD);
            OpCodeRecompilers[ILCode.SHL_DWORD] = shl;
            OpCodeRecompilers[ILCode.SHL_QWORD] = shl;

            // Cmp
            var cmp = new CmpRecompiler();
            OpCodeRecompilers[ILCode.CMP] = cmp;
            OpCodeRecompilers[ILCode.CMP_DWORD] = cmp;
            OpCodeRecompilers[ILCode.CMP_QWORD] = cmp;
            OpCodeRecompilers[ILCode.CMP_R32] = cmp;
            OpCodeRecompilers[ILCode.CMP_R64] = cmp;

            // Nor
            var nor = new SimpleOpCodeRecompiler(new[] { CilOpCodes.Or, CilOpCodes.Not, }, 
                ILCode.NOR_DWORD, ILCode.NOR_QWORD);
            OpCodeRecompilers[ILCode.NOR_DWORD] = nor;
            OpCodeRecompilers[ILCode.NOR_QWORD] = nor;

            // Call
            OpCodeRecompilers[ILCode.CALL] = new CallRecompiler();

            // Conversions to float32
            var convToR32 = new SimpleOpCodeRecompiler(CilOpCodes.Conv_R4, 
                ILCode.FCONV_R32, ILCode.FCONV_R64_R32);
            OpCodeRecompilers[ILCode.FCONV_R32] = convToR32;
            OpCodeRecompilers[ILCode.FCONV_R64_R32] = convToR32;
            
            // Conversions to float64
            var convToR64 = new SimpleOpCodeRecompiler(CilOpCodes.Conv_R8, 
                ILCode.FCONV_R64, ILCode.FCONV_R32_R64);
            OpCodeRecompilers[ILCode.FCONV_R64] = convToR64;
            OpCodeRecompilers[ILCode.FCONV_R32_R64] = convToR64;

            // Conversions to int64
            OpCodeRecompilers[ILCode.ICONV_R64] = new SimpleOpCodeRecompiler(CilOpCodes.Conv_I8, 
                ILCode.ICONV_R64);

            // SX_xxxx
            OpCodeRecompilers[ILCode.SX_DWORD] = new SimpleOpCodeRecompiler(CilOpCodes.Conv_I8,
                ILCode.SX_DWORD);
            OpCodeRecompilers[ILCode.SX_WORD] = new SimpleOpCodeRecompiler(CilOpCodes.Conv_I4,
                ILCode.SX_WORD);
            OpCodeRecompilers[ILCode.SX_BYTE] = new SimpleOpCodeRecompiler(CilOpCodes.Conv_I4,
                ILCode.SX_BYTE);

            // lind
            OpCodeRecompilers[ILCode.LIND_BYTE] = new SimpleOpCodeRecompiler(CilOpCodes.Ldind_U1, ILCode.LIND_BYTE);
            OpCodeRecompilers[ILCode.LIND_WORD] = new SimpleOpCodeRecompiler(CilOpCodes.Ldind_U2, ILCode.LIND_WORD);
            OpCodeRecompilers[ILCode.LIND_DWORD] = new SimpleOpCodeRecompiler(CilOpCodes.Ldind_I4, ILCode.LIND_DWORD);
            OpCodeRecompilers[ILCode.LIND_QWORD] = new SimpleOpCodeRecompiler(CilOpCodes.Ldind_I8, ILCode.LIND_QWORD);
            OpCodeRecompilers[ILCode.LIND_PTR] = new SimpleOpCodeRecompiler(CilOpCodes.Ldind_I, ILCode.LIND_PTR);
            OpCodeRecompilers[ILCode.LIND_OBJECT] = new SimpleOpCodeRecompiler(CilOpCodes.Ldind_Ref, ILCode.LIND_OBJECT);
            
            var sind = new SindRecompiler();
            OpCodeRecompilers[ILCode.SIND_BYTE] = sind;
            OpCodeRecompilers[ILCode.SIND_WORD] = sind;
            OpCodeRecompilers[ILCode.SIND_DWORD] = sind;
            OpCodeRecompilers[ILCode.SIND_QWORD] = sind;
            OpCodeRecompilers[ILCode.SIND_PTR] = sind;
            OpCodeRecompilers[ILCode.SIND_OBJECT] = sind;
            
            // Pseudo opcodes.
            OpCodeRecompilers[ILCode.__SUB_DWORD] = sub;
            OpCodeRecompilers[ILCode.__SUB_QWORD] = sub;
            
            var or = new SimpleOpCodeRecompiler(CilOpCodes.Or, ILCode.__OR_DWORD, ILCode.__OR_QWORD);
            OpCodeRecompilers[ILCode.__OR_DWORD] = or;
            OpCodeRecompilers[ILCode.__OR_QWORD] = or;

            var and = new SimpleOpCodeRecompiler(CilOpCodes.And, ILCode.__AND_DWORD, ILCode.__AND_QWORD);
            OpCodeRecompilers[ILCode.__AND_DWORD] = and;
            OpCodeRecompilers[ILCode.__AND_QWORD] = and;

            var xor = new SimpleOpCodeRecompiler(CilOpCodes.Xor, ILCode.__XOR_DWORD, ILCode.__XOR_QWORD);
            OpCodeRecompilers[ILCode.__XOR_DWORD] = xor;
            OpCodeRecompilers[ILCode.__XOR_QWORD] = xor;

            var not = new SimpleOpCodeRecompiler(CilOpCodes.Not, ILCode.__NOT_DWORD, ILCode.__NOT_QWORD);
            OpCodeRecompilers[ILCode.__NOT_DWORD] = not;
            OpCodeRecompilers[ILCode.__NOT_QWORD] = not;
            
            var neg = new SimpleOpCodeRecompiler(CilOpCodes.Neg, ILCode.__NEG_DWORD, ILCode.__NEG_QWORD, ILCode.__NEG_R32, ILCode.__NEG_R64);
            OpCodeRecompilers[ILCode.__NEG_DWORD] = neg;
            OpCodeRecompilers[ILCode.__NEG_QWORD] = neg;
            OpCodeRecompilers[ILCode.__NEG_R32] = neg;
            OpCodeRecompilers[ILCode.__NEG_R64] = neg;
            
            var relational = new RelationalOpCodeRecompiler();
            OpCodeRecompilers[ILCode.__EQUALS_R32] = relational;
            OpCodeRecompilers[ILCode.__EQUALS_R64] = relational;
            OpCodeRecompilers[ILCode.__EQUALS_DWORD] = relational;
            OpCodeRecompilers[ILCode.__EQUALS_QWORD] = relational;
            OpCodeRecompilers[ILCode.__EQUALS_OBJECT] = relational;
            OpCodeRecompilers[ILCode.__GT_R32] = relational;
            OpCodeRecompilers[ILCode.__GT_R64] = relational;
            OpCodeRecompilers[ILCode.__GT_DWORD] = relational;
            OpCodeRecompilers[ILCode.__GT_QWORD] = relational;
            OpCodeRecompilers[ILCode.__LT_R32] = relational;
            OpCodeRecompilers[ILCode.__LT_R64] = relational;
            OpCodeRecompilers[ILCode.__LT_DWORD] = relational;
            OpCodeRecompilers[ILCode.__LT_QWORD] = relational;
        }

        private static void SetupVCallRecompilers()
        {
            VCallRecompilers[VMCalls.BOX] = new BoxRecompiler();
            VCallRecompilers[VMCalls.CAST] = new CastRecompiler();
            VCallRecompilers[VMCalls.ECALL] = new ECallRecompiler();
            VCallRecompilers[VMCalls.INITOBJ] = new InitObjRecompiler();
            VCallRecompilers[VMCalls.LDFLD] = new LdfldRecompiler();
            VCallRecompilers[VMCalls.LDFTN] = new LdftnRecompiler();
            VCallRecompilers[VMCalls.SIZEOF] = new SizeOfRecompiler();
            VCallRecompilers[VMCalls.STFLD] = new StfldRecompiler();
            VCallRecompilers[VMCalls.THROW] = new ThrowRecompiler();
            VCallRecompilers[VMCalls.TOKEN] = new TokenRecompiler();
            VCallRecompilers[VMCalls.UNBOX] = new UnboxRecompiler();
            VCallRecompilers[VMCalls.LOCALLOC] = new LocallocRecompiler();
            VCallRecompilers[VMCalls.CKOVERFLOW] = new CkOverflowRecompiler();
        }

        public static IOpCodeRecompiler GetOpCodeRecompiler(ILCode code)
        {
            if (!OpCodeRecompilers.TryGetValue(code, out var recompiler))
                throw new NotSupportedException($"Recompilation of opcode {code} is not supported.");
            return recompiler;
        }

        public static IVCallRecompiler GetVCallRecompiler(VMCalls call)
        {
            if (!VCallRecompilers.TryGetValue(call, out var recompiler))
                throw new NotSupportedException($"Recompilation of vcall {call} is not supported.");
            return recompiler;
        }

    }
}



================================================
File: src/OldRod.Core/Recompiler/IL/CallRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Linq;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.IL
{
    public class CallRecompiler : IOpCodeRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILInstructionExpression expression)
        {
            var callMetadata = (CallAnnotation) expression.Annotation;
            
            // Convert entrypoint address to physical method def.
            var method = context.ExportResolver.ResolveMethod(callMetadata.Function.EntrypointAddress);
            var methodSig = ((MethodSignature) method.Signature);
            
            // Create call instruction.
            CilExpression result = new CilInstructionExpression(CilOpCodes.Call, method,
                context.RecompileCallArguments(method, expression.Arguments.Skip(1).ToArray(), VMECallOpCode.CALL))
            {
                ExpressionType = methodSig.ReturnType
            };

            // Make sure the resulting object is converted to an unsigned integer if necessary.
            return result;

        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/IL/CmpRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.IL
{
    public class CmpRecompiler : SimpleOpCodeRecompiler
    {
        public CmpRecompiler()
            : base(CilOpCodes.Sub, 
                ILCode.CMP, ILCode.CMP_R32, 
                ILCode.CMP_R64, ILCode.CMP_DWORD, 
                ILCode.CMP_QWORD)
        {
            InvertedFlagsUpdate = true;
        }

        public override CilExpression Translate(RecompilerContext context, ILInstructionExpression expression)
        {
            var result = base.Translate(context, expression);
            result.ExpressionType = null;
            return result;
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/IL/IOpCodeRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.IL
{
    public interface IOpCodeRecompiler
    {
        CilExpression Translate(RecompilerContext context, ILInstructionExpression expression);
    }
}


================================================
File: src/OldRod.Core/Recompiler/IL/NopRecompiler.cs
================================================
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.IL
{
    public class NopRecompiler : IOpCodeRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILInstructionExpression expression)
        {
            return new CilInstructionExpression(CilOpCodes.Nop);
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/IL/PushRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Reflection;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.IL
{
    public class PushRecompiler : IOpCodeRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILInstructionExpression expression)
        {
            switch (expression.OpCode.Code)
            {
                case ILCode.PUSHR_OBJECT:
                case ILCode.PUSHR_BYTE:
                case ILCode.PUSHR_WORD:
                case ILCode.PUSHR_DWORD:
                case ILCode.PUSHR_QWORD:
                    return CompileRegisterPush(context, expression);

                case ILCode.PUSHI_DWORD:
                    return new CilInstructionExpression(CilOpCodes.Ldc_I4,
                        unchecked((int) (uint) expression.Operand))
                    {
                        ExpressionType = context.TargetModule.CorLibTypeFactory.Int32
                    };
                
                case ILCode.PUSHI_QWORD:
                    return new CilInstructionExpression(CilOpCodes.Ldc_I8,
                        unchecked((long) (ulong) expression.Operand))
                    {
                        ExpressionType = context.TargetModule.CorLibTypeFactory.Int64
                    };

                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private static CilExpression CompileRegisterPush(RecompilerContext context, ILInstructionExpression expression)
        {
            var cilExpression = (CilExpression) expression.Arguments[0].AcceptVisitor(context.Recompiler);

            var resultType = expression.OpCode.StackBehaviourPush.GetResultType();

            if (cilExpression is CilUnboxToVmExpression)
            {
                // HACK: Unbox expressions unbox the value from the stack, but also convert it to their unsigned
                //       variant and box it again into an object. We need to unpack it again, however, we do not
                //       know the actual type of the value inside the box, as this is determined at runtime.
                //
                //       For now, we just make use of the Convert class provided by .NET, which works but would rather
                //       see a true "native" CIL conversion instead. 

                var corLibTypeFactory = context.TargetModule.CorLibTypeFactory;

                string methodName;
                TypeSignature returnType;
                switch (resultType)
                {
                    case VMType.Byte:
                        methodName = "ToByte";
                        returnType = corLibTypeFactory.Byte;
                        break;
                    case VMType.Word:
                        methodName = "ToUInt16";
                        returnType = corLibTypeFactory.UInt16;
                        break;
                    case VMType.Dword:
                        methodName = "ToUInt32";
                        returnType = corLibTypeFactory.UInt32;
                        break;
                    case VMType.Qword:
                        methodName = "ToUInt64";
                        returnType = corLibTypeFactory.UInt64;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

                var convertTypeRef = new TypeReference(context.TargetModule, corLibTypeFactory.CorLibScope, "System", "Convert");
                var methodRef = new MemberReference(convertTypeRef, methodName,
                    MethodSignature.CreateStatic(returnType, corLibTypeFactory.Object));

                cilExpression.ExpectedType = corLibTypeFactory.Object;
                cilExpression = new CilInstructionExpression(
                    CilOpCodes.Call,
                    context.ReferenceImporter.ImportMethod(methodRef),
                    cilExpression);
            }

            if (resultType == VMType.Object)
            {
                if (cilExpression.ExpressionType.IsValueType)
                {
                    if (cilExpression is CilInstructionExpression instructionExpression
                        && instructionExpression.Instructions.Count == 1
                        && instructionExpression.Instructions[0].IsLdcI4()
                        && instructionExpression.Instructions[0].GetLdcI4Constant() == 0)
                    {
                        cilExpression = new CilInstructionExpression(CilOpCodes.Ldnull);
                    }
                    else
                    {
                        // If expression returns a value type, we have to box it to an object.
                        cilExpression = new CilInstructionExpression(CilOpCodes.Box,
                            context.ReferenceImporter.ImportType(cilExpression.ExpressionType.ToTypeDefOrRef()),
                            cilExpression);
                    }
                }
                else
                {
                    // Use the reference type of the expression instead of System.Object. 
                    cilExpression.ExpressionType = cilExpression.ExpressionType;
                }
            }
            
            if (cilExpression.ExpressionType == null)
                cilExpression.ExpressionType = resultType.ToMetadataType(context.TargetModule);

            return cilExpression;
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/IL/RelationalOpCodeRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Linq;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.IL
{
    public class RelationalOpCodeRecompiler : IOpCodeRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILInstructionExpression expression)
        {
            var arguments = expression.Arguments
                .Select(a => (CilExpression) a.AcceptVisitor(context.Recompiler))
                .ToArray();

            CilOpCode opCode;
            switch (expression.OpCode.Code)
            {
                case ILCode.__EQUALS_OBJECT:
                    opCode = CilOpCodes.Ceq;
                    break;    
                    
                case ILCode.__EQUALS_R32:
                case ILCode.__EQUALS_R64:
                case ILCode.__EQUALS_DWORD:
                case ILCode.__EQUALS_QWORD:
                    opCode = CilOpCodes.Ceq;
                    break;
                
                case ILCode.__GT_R32:
                case ILCode.__GT_R64:
                    opCode = CilOpCodes.Cgt;
                    break;
                
                case ILCode.__GT_DWORD:
                case ILCode.__GT_QWORD:
                    opCode = CilOpCodes.Cgt_Un;
                    break;
                
                case ILCode.__LT_R32:
                case ILCode.__LT_R64:
                    opCode = CilOpCodes.Clt;
                    break;
                
                case ILCode.__LT_DWORD:
                case ILCode.__LT_QWORD:
                    opCode = CilOpCodes.Clt_Un;
                    break;
                
                default:
                    throw new ArgumentOutOfRangeException(nameof(expression));
            }

            var argumentType = expression.OpCode.StackBehaviourPop.GetArgumentType(0)
                .ToMetadataType(context.TargetModule)
                .ToTypeSignature();
            
            var result = new CilInstructionExpression(opCode)
            {
                ExpressionType = context.TargetModule.CorLibTypeFactory.Boolean
            };

            foreach (var argument in arguments)
            {
                argument.ExpectedType = argumentType;
                result.Arguments.Add(argument);
            }

            return result;
        }
    }
    
}


================================================
File: src/OldRod.Core/Recompiler/IL/SimpleOpCodeRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.IL
{
    public class SimpleOpCodeRecompiler : IOpCodeRecompiler
    {
        public SimpleOpCodeRecompiler(CilOpCode newOpCode, params ILCode[] opCodes)
            : this(new[] {new CilInstruction(newOpCode)}, opCodes.AsEnumerable())
        {
        }

        public SimpleOpCodeRecompiler(IEnumerable<CilOpCode> newOpCodes, params ILCode[] opCodes)
            : this(newOpCodes.Select(x => new CilInstruction(x)), opCodes.AsEnumerable())
        {
        }

        public SimpleOpCodeRecompiler(IEnumerable<CilInstruction> newInstructions, IEnumerable<ILCode> opCodes)
        {
            NewInstructions = new List<CilInstruction>(newInstructions);
            SupportedOpCodes = new HashSet<ILCode>(opCodes);
        }

        public IList<CilInstruction> NewInstructions
        {
            get;
        }

        public ISet<ILCode> SupportedOpCodes
        {
            get;
        }

        public bool InvertedFlagsUpdate
        {
            get;
            set;
        }

        public virtual CilExpression Translate(RecompilerContext context, ILInstructionExpression expression)
        {
            if (!SupportedOpCodes.Contains(expression.OpCode.Code))
                throw new NotSupportedException();

            var result = new CilInstructionExpression();
            
            // Copy instructions
            foreach (var instruction in NewInstructions)
                result.Instructions.Add(new CilInstruction(0, instruction.OpCode, instruction.Operand));

            // Create arguments
            for (var i = 0; i < expression.Arguments.Count; i++)
            {
                // Convert argument.
                var argument = expression.Arguments[i];
                var cilArgument = (CilExpression) argument.AcceptVisitor(context.Recompiler);
                
                // Check type.
                cilArgument.ExpectedType = expression.OpCode.StackBehaviourPop
                    .GetArgumentType(i)
                    .ToMetadataType(context.TargetModule);
                
                // Convert if necessary, and add to argument list.
                result.Arguments.Add(cilArgument);
            }
         
            // Determine expression type from opcode.
            if (expression.OpCode.StackBehaviourPush != ILStackBehaviour.None)
            {
                result.ExpressionType = expression.OpCode.StackBehaviourPush
                    .GetResultType()
                    .ToMetadataType(context.TargetModule);
            }

            result.ShouldEmitFlagsUpdate = expression.IsFlagDataSource;
            if (expression.IsFlagDataSource)
            {
                result.AffectedFlags = expression.OpCode.AffectedFlags;
                result.InvertedFlagsUpdate = InvertedFlagsUpdate;
            }

            return result;
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/IL/SindRecompiler.cs
================================================
using System;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.IL
{
    public class SindRecompiler : IOpCodeRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILInstructionExpression expression)
        {
            CilOpCode code;
            switch (expression.OpCode.Code)
            {
                case ILCode.SIND_PTR:
                    code = CilOpCodes.Stind_I;
                    break;
                case ILCode.SIND_BYTE:
                    code = CilOpCodes.Stind_I1;
                    break;
                case ILCode.SIND_WORD:
                    code = CilOpCodes.Stind_I2;
                    break;
                case ILCode.SIND_DWORD:
                    code = CilOpCodes.Stind_I4;
                    break;
                case ILCode.SIND_QWORD:
                    code = CilOpCodes.Stind_I8;
                    break;
                case ILCode.SIND_OBJECT:
                    code = CilOpCodes.Stind_Ref;
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(expression));
            }

            var value = (CilExpression) expression.Arguments[0].AcceptVisitor(context.Recompiler);
            var destination = (CilExpression) expression.Arguments[1].AcceptVisitor(context.Recompiler);

            switch (destination.ExpressionType)
            {
                case PointerTypeSignature pointerType:
                    value.ExpectedType = pointerType.BaseType;
                    break;
                case ByReferenceTypeSignature byRefType:
                    value.ExpectedType = byRefType.BaseType;
                    break;
            }


            return new CilInstructionExpression(code, null, destination, value)
            {
                ExpressionType = null
            };
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/Transform/ArrayAccessTransform.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using OldRod.Core.Ast.Cil;

namespace OldRod.Core.Recompiler.Transform
{
    public class ArrayAccessTransform : ICilAstTransform, ICilAstVisitor
    {
        private RecompilerContext _context;

        public string Name => "Array Access Transform";

        public void ApplyTransformation(RecompilerContext context, CilCompilationUnit unit)
        {
            _context = context;
            VisitCompilationUnit(unit);
        }

        public void VisitCompilationUnit(CilCompilationUnit unit)
        {
            foreach (var child in unit.GetChildren())
                child.AcceptVisitor(this);
        }

        public void VisitBlock(CilAstBlock block)
        {
            foreach (var statement in block.Statements)
                statement.AcceptVisitor(this);
        }

        public void VisitExpressionStatement(CilExpressionStatement statement)
        {
            statement.Expression.AcceptVisitor(this);
        }

        public void VisitAssignmentStatement(CilAssignmentStatement statement)
        {
            statement.Value.AcceptVisitor(this);
        }

        public void VisitInstructionExpression(CilInstructionExpression expression)
        {
            if (expression.Instructions.Count == 1
                && IsArrayMemberAccess(expression.Instructions[0], out var method))
            {
                var arrayExpr = expression.Arguments[0];

                if (arrayExpr.ExpressionType is SzArrayTypeSignature arrayType)
                {
                    if (IsArrayGetLength(method))
                        ReplaceWithLdlen(expression, arrayType);
                    else if (IsArrayGetValue(method))
                        ReplaceWithLdelem(expression, arrayType);
                    else if (IsArraySetValue(method))
                        ReplaceWithStelem(expression, arrayType);
                    else if (IsArrayAddress(method))
                        ReplaceWithLdelema(expression, arrayType);
                }
            }

            foreach (var argument in expression.Arguments.ToArray())
                argument.AcceptVisitor(this);
        }

        public void VisitUnboxToVmExpression(CilUnboxToVmExpression expression)
        {
            expression.Expression.AcceptVisitor(this);
        }

        public void VisitVariableExpression(CilVariableExpression expression)
        {
        }

        private static bool IsArrayMemberAccess(CilInstruction instruction, out IMethodDefOrRef memberRef)
        {
            if (instruction.OpCode.Code == CilCode.Call
                && instruction.Operand is IMethodDefOrRef m
                && (m.DeclaringType.IsTypeOf("System", "Array") 
                    || (m.DeclaringType is TypeSpecification ts 
                        && ts.Signature is SzArrayTypeSignature)))
            {
                memberRef = m;
                return true;
            }
            
            memberRef = null;
            return false;
        }

        private static bool IsArrayGetLength(IMethodDefOrRef memberRef)
        {
            return memberRef.Name == "get_Length"
                   && memberRef.Signature is MethodSignature methodSig
                   && methodSig.ParameterTypes.Count == 0
                   && methodSig.HasThis
                   && methodSig.ReturnType.IsTypeOf("System", "Int32");
        }

        private static bool IsArrayGetValue(IMethodDefOrRef memberRef)
        {
            return memberRef.Name == "GetValue"
                   && memberRef.Signature is MethodSignature methodSig
                   && methodSig.ParameterTypes.Count == 1
                   && methodSig.HasThis
                   && methodSig.ReturnType.IsTypeOf("System", "Object")
                   && methodSig.ParameterTypes[0].IsTypeOf("System", "Int32");
        }

        private static bool IsArraySetValue(IMethodDefOrRef memberRef)
        {
            return memberRef.Name == "SetValue"
                   && memberRef.Signature is MethodSignature methodSig
                   && methodSig.ParameterTypes.Count == 2
                   && methodSig.HasThis
                   && methodSig.ReturnType.IsTypeOf("System", "Void")
                   && methodSig.ParameterTypes[0].IsTypeOf("System", "Object")
                   && methodSig.ParameterTypes[1].IsTypeOf("System", "Int32");
        }
        
        private static bool IsArrayAddress(IMethodDefOrRef memberRef)
        {
            return memberRef.Name == "Address"
                   && memberRef.Signature is MethodSignature methodSig
                   && methodSig.ParameterTypes.Count == 1
                   && methodSig.HasThis
                   && methodSig.ReturnType is ByReferenceTypeSignature
                   && methodSig.ParameterTypes[0].IsTypeOf("System", "Int32");
        }

        private void ReplaceWithLdlen(CilInstructionExpression expression, SzArrayTypeSignature arrayType)
        {
            var arrayExpr = expression.Arguments[0];
            arrayExpr.ExpectedType = arrayType;

            var arrayLengthExpr = new CilInstructionExpression(CilOpCodes.Ldlen, null,
                (CilExpression) arrayExpr.Remove())
            {
                ExpressionType = _context.TargetModule.CorLibTypeFactory.Int32
            };

            expression.ReplaceWith(arrayLengthExpr);
        }
        
        private void ReplaceWithLdelem(CilInstructionExpression expression, SzArrayTypeSignature arrayType)
        {
            var arrayExpr = expression.Arguments[0];
            var indexExpr = expression.Arguments[1];

            arrayExpr.ExpectedType = arrayType;
            var elementTypeRef = _context.ReferenceImporter
                .ImportType(arrayType.BaseType.ToTypeDefOrRef());

            // Select appropriate opcode.
            CilOpCode opCode;
            object operand = null;
            switch (arrayType.BaseType.ElementType)
            {
                case ElementType.I1:
                    opCode = CilOpCodes.Ldelem_I1;
                    break;
                case ElementType.U1:
                    opCode = CilOpCodes.Ldelem_U1;
                    break;
                case ElementType.I2:
                    opCode = CilOpCodes.Ldelem_I2;
                    break;
                case ElementType.Char:
                case ElementType.U2:
                    opCode = CilOpCodes.Ldelem_U2;
                    break;
                case ElementType.Boolean:
                case ElementType.I4:
                    opCode = CilOpCodes.Ldelem_I4;
                    break;
                case ElementType.U4:
                    opCode = CilOpCodes.Ldelem_U4;
                    break;
                case ElementType.I8:
                case ElementType.U8:
                    opCode = CilOpCodes.Ldelem_I8;
                    break;
                case ElementType.R4:
                    opCode = CilOpCodes.Ldelem_R4;
                    break;
                case ElementType.R8:
                    opCode = CilOpCodes.Ldelem_R8;
                    break;
                case ElementType.I:
                case ElementType.U:
                    opCode = CilOpCodes.Ldelem_I;
                    break;
                case ElementType.ValueType:
                    opCode = CilOpCodes.Ldelem;
                    operand = elementTypeRef;
                    break;
                default:
                    opCode = CilOpCodes.Ldelem_Ref;
                    break;
            }
            
            // Create the ldelem expression
            var arrayLoadExpr = new CilInstructionExpression(opCode, operand,
                (CilExpression) arrayExpr.Remove(),
                (CilExpression) indexExpr.Remove())
            {
                ExpressionType = arrayType.BaseType
            };

            if (arrayType.BaseType.IsValueType)
            {
                // Array.GetValue boxes value typed values.
                arrayLoadExpr = new CilInstructionExpression(CilOpCodes.Box, elementTypeRef, arrayLoadExpr)
                {
                    ExpectedType = expression.ExpectedType,
                    ExpressionType = expression.ExpressionType
                };
            }

            expression.ReplaceWith(arrayLoadExpr);
        }

        private void ReplaceWithStelem(CilInstructionExpression expression, SzArrayTypeSignature arrayType)
        {
            var arrayExpr = expression.Arguments[0];
            var valueExpr = expression.Arguments[1];
            var indexExpr = expression.Arguments[2];

            arrayExpr.ExpectedType = arrayType;

            // Select appropriate opcode.
            CilOpCode opCode;
            object operand = null;
            switch (arrayType.BaseType.ElementType)
            {
                case ElementType.I1:
                case ElementType.U1:
                    opCode = CilOpCodes.Stelem_I1;
                    break;
                case ElementType.Char:
                case ElementType.I2:
                case ElementType.U2:
                    opCode = CilOpCodes.Stelem_I2;
                    break;
                case ElementType.Boolean:
                case ElementType.I4:
                case ElementType.U4:
                    opCode = CilOpCodes.Stelem_I4;
                    break;
                case ElementType.I8:
                case ElementType.U8:
                    opCode = CilOpCodes.Stelem_I8;
                    break;
                case ElementType.R4:
                    opCode = CilOpCodes.Stelem_R4;
                    break;
                case ElementType.R8:
                    opCode = CilOpCodes.Stelem_R8;
                    break;
                case ElementType.I:
                case ElementType.U:
                    opCode = CilOpCodes.Stelem_I;
                    break; 
                case ElementType.ValueType:
                    opCode = CilOpCodes.Stelem;
                    operand = _context.ReferenceImporter
                        .ImportType(arrayType.BaseType.ToTypeDefOrRef());
                    break;
                default:
                    opCode = CilOpCodes.Stelem_Ref;
                    break;
            }
            
            valueExpr.ExpectedType = arrayType.BaseType;

            var arrayStoreExpr = new CilInstructionExpression(opCode, operand,
                (CilExpression) arrayExpr.Remove(),
                (CilExpression) indexExpr.Remove(),
                (CilExpression) valueExpr.Remove());

            expression.ReplaceWith(arrayStoreExpr);
        }

        private void ReplaceWithLdelema(CilInstructionExpression expression, SzArrayTypeSignature arrayType)
        {
            var arrayExpr = expression.Arguments[0];
            var indexExpr = expression.Arguments[1];

            arrayExpr.ExpectedType = arrayType;
            var elementTypeRef = _context.ReferenceImporter
                .ImportType(arrayType.BaseType.ToTypeDefOrRef());
            
            var arrayLoadExpr = new CilInstructionExpression(CilOpCodes.Ldelema, elementTypeRef,
                (CilExpression) arrayExpr.Remove(),
                (CilExpression) indexExpr.Remove())
            {
                ExpressionType = new ByReferenceTypeSignature(arrayType.BaseType)
            };
            
            expression.ReplaceWith(arrayLoadExpr);
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/Transform/BoxMinimizer.cs
================================================
using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;

namespace OldRod.Core.Recompiler.Transform
{
    public class BoxMinimizer : ChangeAwareCilAstTransform
    {
        public override string Name => "Box Minimizer";

        public override bool VisitInstructionExpression(CilInstructionExpression expression)
        {
            if (expression.Instructions.Count == 1
                && expression.Instructions[0].OpCode.Code == CilCode.Unbox_Any
                && IsBoxExpression(expression.Arguments[0], out var argument, out var boxedType)
                && expression.Instructions[0].Operand is ITypeDefOrRef type 
                && type.FullName == boxedType.FullName)
            {
                argument.ExpectedType = expression.ExpectedType;
                expression.ReplaceWith(argument.Remove());
            }
            
            return base.VisitInstructionExpression(expression);
        }

        public override bool VisitUnboxToVmExpression(CilUnboxToVmExpression expression)
        {
            var argument = expression.Expression;
            if (expression.ExpectedType != null)
            {
                if (!expression.ExpectedType.IsValueType 
                    || expression.ExpectedType.FullName == argument.ExpressionType.FullName)
                {
                    argument.ExpectedType = expression.ExpectedType;
                    expression.ReplaceWith(argument.Remove());

                    argument.AcceptVisitor(this);
                    return true;
                }
            }

            return base.VisitUnboxToVmExpression(expression);
        }

        private bool IsBoxExpression(CilExpression expression, out CilExpression argument, out ITypeDefOrRef boxedType)
        {
            if (expression is CilInstructionExpression arg
                && arg.Instructions.Count == 1
                && arg.Instructions[0].OpCode.Code == CilCode.Box)
            {
                argument = arg.Arguments[0];
                boxedType = (ITypeDefOrRef) arg.Instructions[0].Operand;
                return true;
            }

            argument = null;
            boxedType = null;
            return false;
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/Transform/CilTransformEventArgs.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using OldRod.Core.Ast.Cil;

namespace OldRod.Core.Recompiler.Transform
{
    public class CilTransformEventArgs : EventArgs
    {
        public CilTransformEventArgs(CilCompilationUnit unit, ICilAstTransform transform)
        {
            Transform = transform;
            Unit = unit;
        }

        public CilCompilationUnit Unit
        {
            get;
        }
        
        public ICilAstTransform Transform
        {
            get;
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/Transform/ICilAstTransform.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Linq;
using OldRod.Core.Ast.Cil;

namespace OldRod.Core.Recompiler.Transform
{
    public interface ICilAstTransform
    {
        string Name
        {
            get;
        }
        
        void ApplyTransformation(RecompilerContext context, CilCompilationUnit unit);
    }
    public interface IChangeAwareCilAstTransform : ICilAstTransform
    {
        new bool ApplyTransformation(RecompilerContext context, CilCompilationUnit unit);
    }

    public abstract class ChangeAwareCilAstTransform : IChangeAwareCilAstTransform, ICilAstVisitor<bool>
    {
        public abstract string Name
        {
            get;
        }

        void ICilAstTransform.ApplyTransformation(RecompilerContext context, CilCompilationUnit unit)
        {
            ApplyTransformation(context, unit);
        }

        public virtual bool ApplyTransformation(RecompilerContext context, CilCompilationUnit unit)
        {
            bool changed = false;
            while (unit.AcceptVisitor(this))
            {
                changed = true;
                // Repeat until no more changes.
            }

            return changed;
        }

        public virtual bool VisitCompilationUnit(CilCompilationUnit unit)
        {
            bool changed = false;
            foreach (var node in unit.ControlFlowGraph.Nodes)
            {
                var block = (CilAstBlock) node.UserData[CilAstBlock.AstBlockProperty];
                changed |= block.AcceptVisitor(this);
            }

            return changed;
        }

        public virtual bool VisitBlock(CilAstBlock block)
        {
            bool changed = false;
            foreach (var statement in block.Statements)
                changed |= statement.AcceptVisitor(this);
            return changed;
        }

        public virtual bool VisitExpressionStatement(CilExpressionStatement statement)
        {
            return statement.Expression.AcceptVisitor(this);
        }

        public virtual bool VisitAssignmentStatement(CilAssignmentStatement statement)
        {
            return statement.Value.AcceptVisitor(this);
        }

        public virtual bool VisitInstructionExpression(CilInstructionExpression expression)
        {
            bool changed = false;
            foreach (var argument in expression.Arguments.ToArray())
                changed |= argument.AcceptVisitor(this);
            return changed;
        }

        public virtual bool VisitUnboxToVmExpression(CilUnboxToVmExpression expression)
        {
            return expression.Expression.AcceptVisitor(this);
        }

        public virtual bool VisitVariableExpression(CilVariableExpression expression)
        {
            return false;
        }


    }
}


================================================
File: src/OldRod.Core/Recompiler/Transform/TypeConversionInsertion.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using OldRod.Core.Ast.Cil;

namespace OldRod.Core.Recompiler.Transform
{
    public class TypeConversionInsertion : ChangeAwareCilAstTransform
    {
        private RecompilerContext _context;

        public override string Name => "Type Conversion Insertion";

        public override bool ApplyTransformation(RecompilerContext context, CilCompilationUnit unit)
        {
            _context = context;
            return base.ApplyTransformation(context, unit);
        }

        public override bool VisitInstructionExpression(CilInstructionExpression expression)
        {
            // KoiVM emits pushi_dword or pushi_qwords not only for pushing integers, but also for pushing null or 
            // floating point numbers as well. 
            if (TryOptimizeLdcI(expression))
                return true;
            
            // Insert conversions in all arguments.
            bool changed = base.VisitInstructionExpression(expression);

            // Ensure type safety for all processed arguments. 
            foreach (var argument in expression.Arguments.ToArray())
                changed = EnsureTypeSafety(argument);

            return changed;
        }

        public override bool VisitAssignmentStatement(CilAssignmentStatement statement)
        {
            return base.VisitAssignmentStatement(statement) | EnsureTypeSafety(statement.Value);
        }

        private static unsafe bool TryOptimizeLdcI(CilInstructionExpression expression)
        {
            if (expression.Instructions.Count != 1 || expression.ExpectedType == null)
                return false;

            var instruction = expression.Instructions[0];
            
            if (instruction.IsLdcI4())
            {
                int i4Value = instruction.GetLdcI4Constant();
                if (!expression.ExpectedType.IsValueType)
                {
                    if (i4Value == 0)
                    {
                        // If ldc.i4.0 and expected type is a ref type, the ldc.i4.0 pushes null. We can therefore
                        // optimize to ldnull.
                        ReplaceWithSingleInstruction(expression, new CilInstruction(CilOpCodes.Ldnull));
                        return true;
                    }
                }
                else if (expression.ExpectedType.IsTypeOf("System", "Single"))
                {
                    // KoiVM pushes floats using the pushi_dword instruction. Convert to ldc.r4 if a float is expected
                    // but an ldc.i4 instruction is pushing the value.
                    float actualValue = *(float*) &i4Value;
                    ReplaceWithSingleInstruction(expression, new CilInstruction(CilOpCodes.Ldc_R4, actualValue));
                    return true;
                }
            }
            else if (instruction.OpCode.Code == CilCode.Ldc_I8 && expression.ExpectedType.IsTypeOf("System", "Double"))
            {
                // KoiVM pushes doubles using the pushi_qword instruction. Convert to ldc.r8 if a double is expected
                // but an ldc.i8 instruction is pushing the value.
                long i8Value = (long) instruction.Operand;
                double actualValue = *(double*) &i8Value;
                ReplaceWithSingleInstruction(expression, new CilInstruction(CilOpCodes.Ldc_R8, actualValue));
                return true;
            }

            return false;
        }

        private static void ReplaceWithSingleInstruction(CilInstructionExpression expression, CilInstruction newInstruction)
        {
            expression.Instructions.Clear();
            expression.Instructions.Add(newInstruction);
            expression.ExpressionType = expression.ExpectedType;
        }

        private bool EnsureTypeSafety(CilExpression argument)
        {
            bool changed = false;
            
            if (!_context.TypeHelper.IsAssignableTo(argument.ExpressionType, argument.ExpectedType))
            {
                if (!argument.ExpressionType.IsValueType && argument.ExpectedType.IsValueType)
                {
                    // Reference type -> Value type.
                    changed = ConvertRefTypeToValueType(argument);
                }
                else if (!argument.ExpressionType.IsValueType && !argument.ExpectedType.IsValueType)
                {
                    // Reference type -> Reference type.
                    CastClass(argument);
                    changed = true;
                }
                else if (argument.ExpressionType.IsValueType && !argument.ExpectedType.IsValueType)
                {
                    // Value type -> Reference type.
                    var newArg = Box(argument);
                    if (!newArg.ExpectedType.IsTypeOf("System", "Object"))
                        CastClass(newArg);

                    changed = true;
                }
                else if (argument.ExpressionType.IsValueType && argument.ExpectedType.IsValueType)
                {
                    // Value type -> Value type.
                    ConvertValueType(argument);
                    changed = true;
                }
            }

            return changed;
        }

        private bool ConvertRefTypeToValueType(CilExpression argument)
        {
            if (argument.ExpressionType.IsTypeOf("System", "Object"))
            {
                if (argument is CilInstructionExpression e
                    && e.Instructions.Count == 1)
                {
                    switch (e.Instructions[0].OpCode.Code)
                    {
                        case CilCode.Ldind_Ref:
                            // Load from pointer.
                            LdObj(e);
                            break;

                        case CilCode.Box:
                            // If argument is a box expression, then we can apply an optimisation; remove both
                            // box and unbox, and convert the embedded expression directly:
                            e.Arguments[0].ExpectedType = argument.ExpectedType;
                            argument.ReplaceWith(ConvertValueType(e.Arguments[0]).Remove());
                            return true;

                        default:
                            // Argument is something else. We need to unbox.
                            UnboxAny(argument);
                            break;
                    }
                }
                else
                {
                    UnboxAny(argument);
                }

                return true;
            }

            if (argument.ExpressionType is PointerTypeSignature)
            {
                ConvertValueType(argument);
                return true;
            }

            return false;
        }

        private CilExpression UnboxAny(CilExpression argument)
        {
            var newArgument = new CilInstructionExpression(CilOpCodes.Unbox_Any,
                _context.ReferenceImporter.ImportType(argument.ExpectedType.ToTypeDefOrRef()))
            {
                ExpectedType = argument.ExpectedType,
                ExpressionType = argument.ExpectedType,
            };   
            ReplaceArgument(argument, newArgument);
            
            return newArgument;
        }

        private CilExpression LdObj(CilInstructionExpression argument)
        {
            var newArgument = new CilInstructionExpression(CilOpCodes.Ldobj,
                _context.ReferenceImporter.ImportType(argument.ExpectedType.ToTypeDefOrRef()))
            {
                ExpectedType = argument.ExpectedType,
                ExpressionType = argument.ExpectedType
            };
            argument.ReplaceWith(newArgument);
            
            foreach (var arg in argument.Arguments.ToArray())
                newArgument.Arguments.Add((CilExpression) arg.Remove());
            
            return newArgument;
        }

        private CilExpression Box(CilExpression argument)
        {
            var newArgument = new CilInstructionExpression(CilOpCodes.Box,
                _context.ReferenceImporter.ImportType(argument.ExpressionType.ToTypeDefOrRef()))
            {
                ExpectedType = argument.ExpectedType,
                ExpressionType = _context.TargetModule.CorLibTypeFactory.Object,
            };
            ReplaceArgument(argument, newArgument);

            return newArgument;
        }

        private CilExpression CastClass(CilExpression argument)
        {
            var newArgument = new CilInstructionExpression(CilOpCodes.Castclass,
                _context.ReferenceImporter.ImportType(argument.ExpectedType.ToTypeDefOrRef()))
            {
                ExpectedType = argument.ExpectedType,
                ExpressionType = argument.ExpectedType,
            };
            ReplaceArgument(argument, newArgument);
            
            return newArgument;
        }

        private CilExpression ConvertValueType(CilExpression argument)
        {
            if (argument.ExpectedType.FullName == argument.ExpressionType.FullName)
                return argument;
            
            var corlibType = _context.TargetModule.CorLibTypeFactory.FromType(argument.ExpectedType);
            if (corlibType == null)
            {
                var typeDef = argument.ExpectedType.Resolve();

                // If the expected type is an enum, we might not even need the type conversion in the first place.
                // Check the enum underlying type if it's indeed the case.
                if (typeDef.IsEnum)
                {
                    var underlyingType = typeDef.GetEnumUnderlyingType();
                    if (argument.ExpressionType.FullName == underlyingType.FullName)
                    {
                        // Enum type is the same as the expression type, we don't need an explicit conversion.
                        argument.ExpressionType = argument.ExpectedType;
                        return argument;
                    }
                    
                    // Types still mismatch, we need the explicit conversion.
                    corlibType = _context.TargetModule.CorLibTypeFactory.FromType(underlyingType);
                }
                
                if (corlibType == null)
                    throw new RecompilerException($"Conversion from value type {argument.ExpressionType} to value type {argument.ExpectedType} is not supported yet.");
            }
            
            var opCode = SelectPrimitiveConversionOpCode(argument, corlibType.ElementType);
            var newArgument = new CilInstructionExpression(opCode)
            {
                ExpectedType = argument.ExpectedType,
                ExpressionType = argument.ExpectedType
            };
            ReplaceArgument(argument, newArgument);

            return newArgument;
        }

        private static CilOpCode SelectPrimitiveConversionOpCode(CilExpression argument, ElementType elementType)
        {
            CilOpCode code;
            switch (elementType)
            {
                case ElementType.I1:
                    code = CilOpCodes.Conv_I1;
                    break;
                case ElementType.U1:
                    code = CilOpCodes.Conv_U1;
                    break;
                case ElementType.I2:
                    code = CilOpCodes.Conv_I2;
                    break;
                case ElementType.Char:
                case ElementType.U2:
                    code = CilOpCodes.Conv_U2;
                    break;
                case ElementType.Boolean:
                case ElementType.I4:
                    code = CilOpCodes.Conv_I4;
                    break;
                case ElementType.U4:
                    code = CilOpCodes.Conv_U4;
                    break;
                case ElementType.I8:
                    code = CilOpCodes.Conv_I8;
                    break;
                case ElementType.U8:
                    code = CilOpCodes.Conv_U8;
                    break;
                case ElementType.R4:
                    code = CilOpCodes.Conv_R4;
                    break;
                case ElementType.R8:
                    code = CilOpCodes.Conv_R8;
                    break;
                case ElementType.I:
                    code = CilOpCodes.Conv_I;
                    break;
                case ElementType.U:
                    code = CilOpCodes.Conv_U;
                    break;
                default:
                    throw new RecompilerException(
                        $"Conversion from value type {argument.ExpressionType} to value type {argument.ExpectedType} is not supported.");
            }

            return code;
        }

        private static void ReplaceArgument(CilExpression argument, CilInstructionExpression newArgument)
        {
            argument.ReplaceWith(newArgument);
            argument.ExpectedType = argument.ExpressionType;
            newArgument.Arguments.Add(argument);
        }
            
    }
}


================================================
File: src/OldRod.Core/Recompiler/Transform/TypeHelper.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;

namespace OldRod.Core.Recompiler.Transform
{
    public class TypeHelper
    {
        private readonly ITypeDefOrRef _arrayType;
        private readonly ITypeDefOrRef _objectType;

        private readonly IList<TypeSignature> _signedIntegralTypes;
        private readonly IList<TypeSignature> _unsignedIntegralTypes;
        private readonly IList<TypeSignature> _integralTypes;

        public TypeHelper(ReferenceImporter importer)
        {
            var ownerModule = importer.TargetModule;
            var factory = ownerModule.CorLibTypeFactory;
            var scope = ownerModule.CorLibTypeFactory.CorLibScope;

            _arrayType = new TypeReference(ownerModule, scope, "System", "Array");
            _objectType = new TypeReference(ownerModule, scope, "System", "Object");

            _signedIntegralTypes = new TypeSignature[]
            {
                factory.SByte,
                factory.Int16,
                factory.Int32,
                factory.IntPtr,
                factory.Int64,
            };
            
            _unsignedIntegralTypes = new TypeSignature[]
            {
                factory.Byte,
                factory.UInt16,
                factory.UInt32,
                factory.UIntPtr,
                factory.UInt64,
            };

            _integralTypes = new TypeSignature[]
            {
                factory.SByte,
                factory.Byte,
                factory.Int16,
                factory.UInt16,
                factory.Int32,
                factory.UInt32,
                factory.IntPtr,
                factory.UIntPtr,
                factory.Int64,
                factory.UInt64,
            };
        }
        
        public IList<ITypeDescriptor> GetTypeHierarchy(ITypeDescriptor type)
        {
            var result = new List<ITypeDescriptor>();
            
            TypeSignature typeSig;
            switch (type)
            {
                // The base type of an array type signature is System.Array, so it needs a special case. 
                // Get the type hierarchy of System.Array and then append the original array type sig.
                case ArrayTypeSignature _:
                case SzArrayTypeSignature _:
                    result.AddRange(GetTypeHierarchy(_arrayType));
                    result.Add(type);
                    return result;
                
                case ByReferenceTypeSignature byRef:
                    result.AddRange(GetTypeHierarchy(byRef.BaseType));
//                    result.Add(byRef);
                    return result;
                
                // Type specification's Resolve method resolves the underlying element type.
                // We therefore need a special case here, to get the type hierarchy of the embedded signature first.
                case TypeSpecification typeSpec:
                    result.AddRange(GetTypeHierarchy(typeSpec.Signature));
                    result.Add(typeSpec);
                    return result;
                
                case GenericParameterSignature genericParam:
                    // TODO: Resolve to actual generic parameter type.
                    result.Add(_objectType);
                    return result;
                
                // No type means no hierarchy.
                case null:
                    return Array.Empty<ITypeDescriptor>();
                
                default:
                    typeSig = type.ToTypeSignature();
                    break;
            }
            
            var genericContext = new GenericContext(null, null);
            
            while (typeSig != null)
            {
                if (typeSig is GenericInstanceTypeSignature genericInstance)
                    genericContext = new GenericContext(genericInstance, null);

                result.Add(typeSig);

                var typeDef = typeSig.ToTypeDefOrRef().Resolve();
                if (typeDef is null)
                {
                    throw new ArgumentException(
                        $"Could not resolve type {typeSig.FullName} in {typeSig.Scope.GetAssembly()}.");
                }

                if (typeDef.IsEnum)
                    typeSig = typeDef.GetEnumUnderlyingType();
                else if (typeDef.IsInterface && typeDef.BaseType is null)
                    typeSig = _objectType.ToTypeSignature();
                else
                    typeSig = typeDef.BaseType?.ToTypeSignature().InstantiateGenericTypes(genericContext);
            }

            result.Reverse();
            return result;
        }

        public bool IsIntegralType(ITypeDescriptor type)
        {
            return _integralTypes.Any(x => type.IsTypeOf(x.Namespace, x.Name));
        }
        
        public bool IsOnlyIntegral(IEnumerable<ITypeDescriptor> types)
        {
            return types.All(IsIntegralType);
        }

        public TypeSignature GetBiggestIntegralType(IEnumerable<ITypeDescriptor> types)
        {
            TypeSignature biggest = null;
            int biggestIndex = 0;
            
            foreach (var type in types)
            {
                int index = 0;
                for (index = 0; index < _integralTypes.Count; index++)
                {
                    if (_integralTypes[index].IsTypeOf(type.Namespace, type.Name))
                        break;
                }

                if (index > biggestIndex && index < _integralTypes.Count)
                {
                    biggest = _integralTypes[index];
                    biggestIndex = index;
                }
            }

            return biggest;
        }
        
        public ITypeDescriptor GetCommonBaseType(ICollection<ITypeDescriptor> types)
        {
            if (types.Count == 1)
                return types.First();
            
            if (IsOnlyIntegral(types))
                return GetBiggestIntegralType(types);

            // Strategy:
            // Get each type hierarchy, and walk from least specific (System.Object) to most specific type.
            // Break when there is a difference between two type hierarchies. This is a branch in the
            // total type hierarchy graph. 
            
            // TODO: For now we remove interfaces from the list to increase the chance of finding a more specific
            //       common type. This can be improved.
            
            // Obtain all base types for all types.
            var hierarchies = types
                .Where(t => !t.Resolve().IsInterface) 
                .Select(GetTypeHierarchy).ToList();
            if (hierarchies.Count == 0)
                return _objectType;
            
            ITypeDescriptor commonType = _objectType;

            int currentTypeIndex = 0;
            while (hierarchies.Count > 0)
            {
                ITypeDescriptor nextType = null;

                for (int i = 0; i < hierarchies.Count; i++)
                {
                    var hierarchy = hierarchies[i];
                    if (currentTypeIndex >= hierarchy.Count)
                    {
                        // Hierarchy is out of types. We can safely ignore this hierarchy any further
                        // since up to this point, this hierarchy has been exactly the same as the other hierarchies. 
                        hierarchies.RemoveAt(i);
                        i--;
                    }
                    else if (nextType == null)
                    {
                        nextType = hierarchy[currentTypeIndex];
                    }
                    else
                    {
                        // Check if the current hierarchy has branched from the other hierarchies.
                        if (hierarchy[currentTypeIndex].FullName != nextType.FullName)
                            return commonType;
                    }
                }

                if (nextType == null)
                    return commonType;
                
                commonType = nextType;
                currentTypeIndex++;
            }

            return commonType;
        }

        public bool IsAssignableTo(ITypeDescriptor from, ITypeDescriptor to)
        {
            if (to == null
                || from.FullName == to.FullName
                || from.IsTypeOf("System", "Int32") && to.IsTypeOf("System", "Boolean"))
            {
                return true;
            }

            if (from.IsValueType != to.IsValueType)
                return false;

            var typeHierarchy = GetTypeHierarchy(from);
            return typeHierarchy.Any(x => x.FullName == to.FullName);
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/Transform/TypeInference.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using OldRod.Core.Ast.Cil;

namespace OldRod.Core.Recompiler.Transform
{
    public class TypeInference : ChangeAwareCilAstTransform
    {
        private static readonly SignatureComparer Comparer = new SignatureComparer();
        
        private TypeHelper _helper;
        private RecompilerContext _context;
        
        public override string Name => "Type Inference";

        public override bool ApplyTransformation(RecompilerContext context, CilCompilationUnit unit)
        {
            _context = context;
            _helper = new TypeHelper(context.ReferenceImporter);
            return base.ApplyTransformation(context, unit);
        }

        public override bool VisitCompilationUnit(CilCompilationUnit unit)
        {
            bool changed = false;
            
            // Go over each variable, and figure out the common base type of all the values that are assigned to it.
            // This is the new variable type.
            foreach (var variable in unit.Variables.Where(x => x.UsedBy.Count > 0))
                changed |= TryInferVariableType(variable);

            foreach (var parameter in unit.Parameters.Where(x => x.UsedBy.Count > 0 && !x.HasFixedType))
                changed |= TryInferVariableType(parameter);

            return changed;
        }

        private bool TryInferVariableType(CilVariable variable)
        {
            // Do not update the type of the flags variable.
            if (_context.FlagVariable == variable)
                return false;
            
            // Collect expected types.
            var expectedTypes = CollectExpectedTypes(variable);

            ITypeDescriptor newVariableType = null;
            
            if (expectedTypes.Any(t => t.IsTypeOf("System", "Array")))
                newVariableType = TryInferArrayType(variable);

            if (newVariableType == null) 
                newVariableType = _helper.GetCommonBaseType(expectedTypes);

            return TrySetVariableType(variable, newVariableType);
        }

        private ICollection<ITypeDescriptor> CollectExpectedTypes(CilVariable variable)
        {
            var expectedTypes = new List<ITypeDescriptor>();
            foreach (var use in variable.UsedBy)
            {
                var expectedType = use.ExpectedType;
                if (expectedType == null)
                    continue;
                
                if (!use.IsReference)
                {
                    // Normal read reference to the variable (e.g. using a ldloc or ldarg).
                    expectedTypes.Add(expectedType);
                }
                else if (expectedType is ByReferenceTypeSignature byRefType)
                {
                    // The variable's address was used (e.g. using a ldloca or ldarga). To avoid the type inference 
                    // to think that the variable is supposed to be a byref type, we get the base type instead.
                    expectedTypes.Add(byRefType.BaseType);
                }
                else
                {
                    // If this happens, we probably have an error somewhere in an earlier stage of the recompiler.
                    // Variable loaded by reference should always have a byref type sig as expected type. 

                    throw new RecompilerException(
                        $"Variable {use.Variable.Name} in the expression `{use.Parent}` in "
                        + $"{_context.MethodBody.Owner.Name} ({_context.MethodBody.Owner.MetadataToken}) was passed on " +
                        $"by reference, but does not have a by-reference expected type.");
                }
            }

            return expectedTypes;
        }

        private ITypeDescriptor TryInferArrayType(CilVariable variable)
        {
            if (variable.AssignedBy.Count == 0)
                return null;
            
            var types = variable.AssignedBy
                .Select(a => a.Value.ExpressionType)
                .ToArray();

            if (types[0] is SzArrayTypeSignature arrayType
                && types.All(t => Comparer.Equals(t, arrayType)))
            {
                return arrayType;
            }

            return null;
        }

        private bool TrySetVariableType(CilVariable variable, ITypeDescriptor variableType)
        {
            if (variableType != null && variable.VariableType.FullName != variableType.FullName)
            {
                var newType = _context.TargetModule.CorLibTypeFactory.FromType(variableType)
                              ?? _context.ReferenceImporter.ImportTypeSignature(variableType.ToTypeSignature());
                variable.VariableType = newType;

                // Update the expression type of all references to the variable.
                foreach (var use in variable.UsedBy)
                {
                    use.ExpressionType = use.IsReference
                        ? new ByReferenceTypeSignature(newType)
                        : newType;
                }

                // Update the expected type of all expressions that are assigned to the variable.
                foreach (var assign in variable.AssignedBy)
                    assign.Value.ExpectedType = newType;

                return true;
            }

            return false;
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/BoxRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class BoxRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var boxMetadata = (BoxAnnotation) expression.Annotation;
            switch (boxMetadata.ReturnType)
            {
                case VMType.Object:
                    switch (boxMetadata.Value)
                    {
                        case string stringValue:
                            return new CilInstructionExpression(CilOpCodes.Ldstr, stringValue)
                            {
                                ExpressionType = context.TargetModule.CorLibTypeFactory.String
                            };
                        
                        case null:
                            var argument = (CilExpression) expression.Arguments[expression.Arguments.Count - 1]
                                .AcceptVisitor(context.Recompiler);
                            argument.ExpectedType = boxMetadata.Type;
                            return new CilInstructionExpression(CilOpCodes.Box, boxMetadata.Type, argument)
                            {
                                ExpressionType = context.TargetModule.CorLibTypeFactory.Object,
                            };
                        
                        default:
                            throw new NotImplementedException();    
                    }
                    
                case VMType.Byte:
                case VMType.Word:
                case VMType.Dword:
                    return new CilInstructionExpression(CilOpCodes.Ldc_I4, Convert.ToInt32(boxMetadata.Value))
                    {
                        ExpressionType = context.TargetModule.CorLibTypeFactory.Int32,    
                    };
                case VMType.Qword:
                    return new CilInstructionExpression(CilOpCodes.Ldc_I8, Convert.ToInt64(boxMetadata.Value))
                    {
                        ExpressionType = context.TargetModule.CorLibTypeFactory.Int64,    
                    };
                case VMType.Real32:
                    return new CilInstructionExpression(CilOpCodes.Ldc_R4, Convert.ToSingle(boxMetadata.Value))
                    {
                        ExpressionType = context.TargetModule.CorLibTypeFactory.Single,    
                    };
                case VMType.Real64:
                    return new CilInstructionExpression(CilOpCodes.Ldc_R8, Convert.ToDouble(boxMetadata.Value))
                    {
                        ExpressionType = context.TargetModule.CorLibTypeFactory.Double,    
                    };

                case VMType.Unknown:
                case VMType.Pointer:
                default:
                    throw new NotImplementedException();
            }
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/CastRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class CastRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var metadata = (CastAnnotation) expression.Annotation;
            
            var opCode = metadata.IsSafeCast ? CilOpCodes.Isinst : CilOpCodes.Castclass;
            var value = (CilExpression) expression.Arguments[expression.Arguments.Count - 1]
                .AcceptVisitor(context.Recompiler);
            
            return new CilInstructionExpression(opCode, metadata.Type, value)
            {
                ExpressionType = metadata.Type
            };
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/CkOverflowRecompiler.cs
================================================
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.VCall
{
    public class CkOverflowRecompiler : IVCallRecompiler
    {
        public const string Tag = "CkOverflow";
        
        /// <inheritdoc />
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            // CKOVERFLOW is currently not supported. This is in most cases not a big issue as the extra properties of
            // the overflow checked instructions are not really used all that often in real world applications.
            // We therefore just emit a NOP for now.
            
            var method = context.MethodBody.Owner;

            string displayName = method.MetadataToken != 0 
                ? method.MetadataToken.ToInt32().ToString("X8") 
                : method.Name!.Value;

            context.Logger.Warning(Tag,
                $"Virtualized method {displayName} contains overflow checks which are not supported by OldRod. Resulting code might be inaccurate.");

            return new CilInstructionExpression(CilOpCodes.Nop);
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/ECallRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Linq;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class ECallRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var ecall = (ECallAnnotation) expression.Annotation;
            var methodSig = ecall.Method.Signature;

            // Select calling instruction, return type and call prefix.
            CilInstruction prefix = null;
            TypeSignature resultType;
            CilOpCode opcode;
            object operand = ecall.Method;
            
            switch (ecall.OpCode)
            {
                case VMECallOpCode.CALL:
                    opcode = CilOpCodes.Call;
                    resultType = methodSig.ReturnType;
                    break;
                case VMECallOpCode.CALLVIRT:
                    opcode = CilOpCodes.Callvirt;
                    resultType = methodSig.ReturnType;
                    break;
                case VMECallOpCode.NEWOBJ:
                    opcode = CilOpCodes.Newobj;
                    resultType = ecall.Method.DeclaringType.ToTypeSignature();
                    
                    // KoiVM translates "newarr ElementType" instructions to "newobj ElementType[]::.ctor(int32)".
                    // Revert this operation if necessary:
                    if (resultType is SzArrayTypeSignature arrayType)
                    {
                        opcode = CilOpCodes.Newarr;
                        operand = context.ReferenceImporter.ImportType(arrayType.BaseType.ToTypeDefOrRef());
                    }

                    break;
                case VMECallOpCode.CALLVIRT_CONSTRAINED:
                    prefix = new CilInstruction(CilOpCodes.Constrained, ecall.ConstrainedType);
                    opcode = CilOpCodes.Callvirt;
                    resultType = methodSig.ReturnType;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            // Enter generic context of method.
            context.EnterMember(ecall.Method);

            // Collect arguments.
            var arguments = expression.Arguments
                .Skip(ecall.IsConstrained ? 3 : 2)
                .ToArray();
            
            // Build call expression.
            var result = new CilInstructionExpression(opcode, operand,
                context.RecompileCallArguments(ecall.Method, arguments, ecall.OpCode, ecall.ConstrainedType))
            {
                ExpressionType = resultType.InstantiateGenericTypes(context.GenericContext)
            };

            // Add prefix when necessary.
            if (prefix != null)
                result.Instructions.Insert(0, prefix);
            
            // Leave generic context.
            context.ExitMember();

            return result;
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/IVCallRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.VCall
{
    public interface IVCallRecompiler
    {
        CilExpression Translate(RecompilerContext context, ILVCallExpression expression);
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/InitObjRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class InitObjRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var annotation = (TypeAnnotation) expression.Annotation;

            var argument = (CilExpression) expression.Arguments[expression.Arguments.Count - 1]
                .AcceptVisitor(context.Recompiler);

            argument.ExpectedType = new ByReferenceTypeSignature(
                context.ReferenceImporter.ImportTypeSignature(annotation.Type.ToTypeSignature()));
            
            var result = new CilInstructionExpression(CilOpCodes.Initobj, annotation.Type, argument)
            {
                ExpressionType = null
            };

            return result;
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/LdfldRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class LdfldRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var metadata = (FieldAnnotation) expression.Annotation;

            // Enter generic context for member.
            context.EnterMember(metadata.Field);

            var fieldDef = metadata.Field.Resolve();
            bool hasThis = !fieldDef?.IsStatic ?? metadata.Field.Signature.HasThis;

            // Select opcode and expression type.
            var expressionType = metadata.Field.Signature.FieldType;
            CilOpCode opCode;
            if (metadata.IsAddress)
            {
                expressionType = new ByReferenceTypeSignature(expressionType);
                opCode = hasThis ? CilOpCodes.Ldflda : CilOpCodes.Ldsflda;
            }
            else
            {
                opCode = hasThis ? CilOpCodes.Ldfld : CilOpCodes.Ldsfld;
            }

            // Construct CIL expression.
            var result = new CilInstructionExpression(opCode, metadata.Field)
            {
                ExpressionType = expressionType.InstantiateGenericTypes(context.GenericContext)
            };

            if (hasThis)
            {
                // Recompile object expression if field is an instance field.
                var objectExpression = (CilExpression) expression.Arguments[expression.Arguments.Count - 1]
                    .AcceptVisitor(context.Recompiler);
                
                var objectType = metadata.Field.DeclaringType
                    .ToTypeSignature()
                    .InstantiateGenericTypes(context.GenericContext);
                
                if (metadata.IsAddress)
                    objectType = new ByReferenceTypeSignature(objectType);
                
                objectExpression.ExpectedType = objectType;
                result.Arguments.Add(objectExpression);
            }
            
            // Leave generic context.
            context.ExitMember();
            
            return result;
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/LdftnRecompiler.cs
================================================

using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class LdftnRecompiler : IVCallRecompiler 
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var annotation = (LdftnAnnotation) expression.Annotation;

            IMethodDescriptor method;
            if (!annotation.IsIntraLinked)
            {
                method = annotation.Method;
            }
            else
            {
                method = context.ExportResolver.ResolveMethod(annotation.Function.EntrypointAddress);
                if (method == null)
                {
                    throw new RecompilerException(
                        $"Could not resolve function_{annotation.Function.EntrypointAddress:X4} to a physical method.");
                }
            }

            var result = new CilInstructionExpression(CilOpCodes.Ldftn, method)
            {
                ExpressionType = context.TargetModule.CorLibTypeFactory.IntPtr
            };

            if (annotation.IsVirtual)
            {
                var callingObject = (CilExpression) expression.Arguments[expression.Arguments.Count - 1]
                    .AcceptVisitor(context.Recompiler);
                result.Instructions[0].OpCode = CilOpCodes.Ldvirtftn;
                result.Arguments.Add(callingObject);
            }
            
            return result;
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/LocallocRecompiler.cs
================================================
using System.Linq;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;

namespace OldRod.Core.Recompiler.VCall
{
    public class LocallocRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var argument = (CilExpression) expression.Arguments.Last().AcceptVisitor(context.Recompiler);
            argument.ExpectedType = context.TargetModule.CorLibTypeFactory.UIntPtr;

            return new CilInstructionExpression(CilOpCodes.Localloc, null, argument)
            {
                ExpressionType = new PointerTypeSignature(context.TargetModule.CorLibTypeFactory.Byte)
            };
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/SizeOfRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class SizeOfRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var metadata = (TypeAnnotation) expression.Annotation;

            return new CilInstructionExpression(CilOpCodes.Sizeof, metadata.Type)
            {
                ExpressionType = context.TargetModule.CorLibTypeFactory.Int32
            };
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/StfldRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class StfldRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var metadata = (FieldAnnotation) expression.Annotation;
            var fieldType = metadata.Field.Signature.FieldType;
            
            // Enter generic context.
            context.EnterMember(metadata.Field);

            var fieldDef = metadata.Field.Resolve();
            bool hasThis = !fieldDef?.IsStatic ?? metadata.Field.Signature.HasThis;

            // Construct CIL expression.
            var result = new CilInstructionExpression(hasThis ? CilOpCodes.Stfld : CilOpCodes.Stsfld, metadata.Field);

            if (hasThis)
            {
                // Recompile object expression if field is an instance field.
                var objectExpression = (CilExpression) expression.Arguments[expression.Arguments.Count - 2]
                    .AcceptVisitor(context.Recompiler);
                
                var objectType = metadata.Field.DeclaringType
                    .ToTypeSignature()
                    .InstantiateGenericTypes(context.GenericContext);
                
                // Struct members can only be accessed when the object is passed on by reference.
                if (metadata.Field.DeclaringType.IsValueType)
                    objectType = new ByReferenceTypeSignature(objectType);

                objectExpression.ExpectedType = objectType;
                result.Arguments.Add(objectExpression);
            }

            // Recompile value.
            var valueExpression = (CilExpression) expression.Arguments[expression.Arguments.Count - 1]
                .AcceptVisitor(context.Recompiler);
            valueExpression.ExpectedType = fieldType.InstantiateGenericTypes(context.GenericContext);
            result.Arguments.Add(valueExpression);

            // Exit generic context.
            context.ExitMember();
            
            return result;
        }
        
    }
    
}


================================================
File: src/OldRod.Core/Recompiler/VCall/ThrowRecompiler.cs
================================================
using System;
using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class ThrowRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var annotation = (ThrowAnnotation) expression.Annotation;

            if (annotation.IsRethrow)
                return new CilInstructionExpression(CilOpCodes.Rethrow);

            var argument = (CilExpression) expression.Arguments[2].AcceptVisitor(context.Recompiler);

            var scope = context.TargetModule.CorLibTypeFactory.CorLibScope;
            argument.ExpectedType = new TypeReference(context.TargetModule, scope, "System", "Exception");
            
            var result = new CilInstructionExpression(CilOpCodes.Throw,
                null,
                argument);

            return result;
        }
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/TokenRecompiler.cs
================================================
using System;
using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Cil;
using AsmResolver.PE.DotNet.Metadata.Tables;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class TokenRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var annotation = (TokenAnnotation) expression.Annotation;

            var member = annotation.Member;

            string typeName;
            switch (member.MetadataToken.Table)
            {
                case TableIndex.TypeDef:
                case TableIndex.TypeRef:
                case TableIndex.TypeSpec:
                    typeName = nameof(RuntimeTypeHandle);
                    break;
                case TableIndex.Method:
                case TableIndex.MethodSpec:
                    typeName = nameof(RuntimeMethodHandle);
                    break;
                case TableIndex.Field:
                    typeName = nameof(RuntimeFieldHandle);
                    break;
                case TableIndex.MemberRef:
                    var reference = (MemberReference) member;
                    if (reference.Signature.IsMethod)
                        typeName = nameof(RuntimeMethodHandle);
                    else if (reference.Signature.IsField)
                        typeName = nameof(RuntimeFieldHandle);
                    else
                        throw new RecompilerException("Detected a reference to a MemberRef that is not a method or a field.");
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return new CilInstructionExpression(CilOpCodes.Ldtoken, annotation.Member)
            {
                ExpressionType = new TypeReference(
                    context.TargetModule,
                    context.TargetModule.CorLibTypeFactory.CorLibScope,
                    "System",
                    typeName)
            };
        }
        
    }
}


================================================
File: src/OldRod.Core/Recompiler/VCall/UnboxRecompiler.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.Annotations;

namespace OldRod.Core.Recompiler.VCall
{
    public class UnboxRecompiler : IVCallRecompiler
    {
        public CilExpression Translate(RecompilerContext context, ILVCallExpression expression)
        {
            var annotation = (UnboxAnnotation) expression.Annotation;

            var value = (CilExpression) expression.Arguments[expression.Arguments.Count - 1]
                .AcceptVisitor(context.Recompiler);
            value.ExpectedType = context.TargetModule.CorLibTypeFactory.Object;

            return new CilUnboxToVmExpression(annotation.Type, value)
            {
                ExpressionType = context.TargetModule.CorLibTypeFactory.Object
            };
        }
        
    }
}


================================================
File: src/OldRod.Pipeline/BasicBlockSerializer.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Text;
using AsmResolver.DotNet.Code.Cil;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.ControlFlow;
using Rivers.Serialization.Dot;

namespace OldRod.Pipeline
{
    internal class BasicBlockSerializer : IUserDataSerializer
    {
        private readonly CilAstFormatter _formatter;
        private readonly DefaultUserDataSerializer _default = new DefaultUserDataSerializer();

        public BasicBlockSerializer()
        {
        }
        
        public BasicBlockSerializer(CilMethodBody methodBody)
        {
            _formatter = new CilAstFormatter();
        }
        
        public string Serialize(string attributeName, object attributeValue)
        {
            switch (attributeValue)
            {
                case ILBasicBlock basicBlock:
                    return ToLinesWithMaxLength(basicBlock.Instructions);
                case ILAstBlock ilAstBlock:
                    return ToLinesWithMaxLength(ilAstBlock.Statements);
                case CilAstBlock cilAstBlock when _formatter != null:
                    return cilAstBlock.AcceptVisitor(_formatter);
                case CilAstBlock cilAstBlock:
                    return ToLinesWithMaxLength(cilAstBlock.Statements);
                default:
                    return _default.Serialize(attributeName, attributeValue);
            }
        }

        public object Deserialize(string attributeName, string rawValue)
        {
            return _default.Deserialize(attributeName, rawValue);
        }

        public static string ToLinesWithMaxLength(IEnumerable<object> values, int maxLineLength = 100)
        {
            var builder = new StringBuilder();

            foreach (var value in values)
            {
                string stringValue = value.ToString();

                for (int i = 0; i < stringValue.Length; i += maxLineLength)
                {
                    int lineLength = Math.Min(stringValue.Length - i, maxLineLength);
                    string line = stringValue.Substring(i, lineLength);
                    if (i > 0)
                        builder.Append("     ");
                    builder.Append(line);
                    builder.Append("\\l");
                }
            }
            
            return builder.ToString();
        }
    }
}


================================================
File: src/OldRod.Pipeline/DebuggingUtilities.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Ast;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.ControlFlow;
using Rivers;

namespace OldRod.Pipeline
{
  
    internal static class DebuggingUtilities
    {
        public static Graph ConvertToGraphViz(this Graph graph, string nodeContentsProperty)
        {
            var newGraph = new Graph();

            var clusters = new Dictionary<SubGraph, SubGraph>();
            foreach (var subGraph in graph.SubGraphs)
            {
                var newSubGraph = new SubGraph(newGraph, "cluster_" + clusters.Count);
                newSubGraph.UserData["color"] = "red";
                newGraph.SubGraphs.Add(newSubGraph);
                clusters[subGraph] = newSubGraph;
            }

            foreach (var node in graph.Nodes)
            {
                var newNode = newGraph.Nodes.Add(node.Name);
                newNode.UserData["shape"] = "box3d";

                if (node.UserData.TryGetValue(nodeContentsProperty, out var contents))
                {
                    newNode.UserData["label"] = contents;
                }
                else
                {
                    newNode.UserData["color"] = "red";
                    newNode.UserData["label"] = "?";
                }

                foreach (var subGraph in node.SubGraphs)
                    newNode.SubGraphs.Add(clusters[subGraph]);
            }

            foreach (var edge in graph.Edges)
            {
                var newEdge = newGraph.Edges.Add(edge.Source.Name, edge.Target.Name);
                if (edge.UserData.ContainsKey(ControlFlowGraph.ConditionProperty))
                {
                    if (edge.UserData[ControlFlowGraph.ConditionProperty] is ICollection<int> x)
                    {
                        if (x.Contains(ControlFlowGraph.ExceptionConditionLabel) ||
                            x.Contains(ControlFlowGraph.EndFinallyConditionLabel))
                        {
                            newEdge.UserData["color"] = "grey";
                            newEdge.UserData["style"] = "dashed";
                        }
                        else if (x.Contains(0))
                        {
                            newEdge.UserData["color"] = "red";
                        }
                        
                        newEdge.UserData["label"] = string.Join(", ", x);
                    }
                }
            }

            return newGraph;
        }

        public static Graph ConvertToGraphViz(this IAstNode astNode)
        {
            var formatter = new ShortAstFormatter(new CilInstructionFormatter());
            
            var graph = new Graph(false);
            var nodes = new Dictionary<IAstNode, Node>();
            var stack = new Stack<IAstNode>();
            stack.Push(astNode);

            while (stack.Count > 0)
            {
                var current = stack.Pop();

                string name;
                switch (current)
                {
                    case ILAstNode il:
                        name = il.AcceptVisitor(formatter);
                        break;
                    case CilAstNode cil:
                        name = cil.AcceptVisitor(formatter);
                        break;
                    default:
                        name = current.GetType().Name;
                        break;
                }

                var node = graph.Nodes.Add(nodes.Count.ToString());
                nodes.Add(current, node);
                node.UserData["shape"] = "box";
                node.UserData["label"] = nodes.Count + ": " + name;

                if (current.Parent != null && nodes.TryGetValue(current.Parent, out var parentNode))
                    parentNode.OutgoingEdges.Add(node);

                foreach (var child in current.GetChildren().Reverse())
                    stack.Push(child);
            }

            return graph;
        }

        private sealed class ShortAstFormatter : ICilAstVisitor<string>, IILAstVisitor<string>
        {
            private readonly CilInstructionFormatter _formatter;

            public ShortAstFormatter(CilInstructionFormatter formatter)
            {
                _formatter = formatter;
            }
            
            public string VisitCompilationUnit(CilCompilationUnit unit) => "unit";
            public string VisitBlock(CilAstBlock block) => "block";
            public string VisitExpressionStatement(CilExpressionStatement statement) => "statement";
            public string VisitAssignmentStatement(CilAssignmentStatement statement) => $"stloc {statement.Variable.Name}";

            public string VisitInstructionExpression(CilInstructionExpression expression)
            {
                return string.Join(" - ", expression.Instructions.Select(i => i.Operand == null
                    ? _formatter.FormatOpCode(i.OpCode)
                    : $"{_formatter.FormatOpCode(i.OpCode)} {_formatter.FormatOperand(i.OpCode.OperandType, i.Operand)}"));
            }

            public string VisitUnboxToVmExpression(CilUnboxToVmExpression expression) => $"unbox.tovm {expression.Type}";
            public string VisitVariableExpression(CilVariableExpression expression)
                => (expression.IsReference ? "&" : "") + expression.Variable.Name;

            public string VisitCompilationUnit(ILCompilationUnit unit) => "unit";
            public string VisitBlock(ILAstBlock block) => "block";
            public string VisitExpressionStatement(ILExpressionStatement statement) => "statement";
            public string VisitAssignmentStatement(ILAssignmentStatement statement) => statement.Variable + " = ";
            public string VisitInstructionExpression(ILInstructionExpression expression) => $"{expression.OpCode} {expression.Operand}";
            
            public string VisitVariableExpression(ILVariableExpression expression) 
                => (expression.IsReference ? "&" : "") + expression.Variable.Name;
            
            public string VisitVCallExpression(ILVCallExpression expression) => expression.Annotation.ToString();
            public string VisitPhiExpression(ILPhiExpression expression) => "phi";
            public string VisitExceptionExpression(ILExceptionExpression expression) => "exception";
        }
    }
}


================================================
File: src/OldRod.Pipeline/DevirtualisationContext.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using OldRod.Core;
using OldRod.Core.Architecture;
using OldRod.Core.Recompiler;
using OldRod.Pipeline.Stages.OpCodeResolution;
using OldRod.Pipeline.Stages.VMMethodDetection;

namespace OldRod.Pipeline
{
    public class DevirtualisationContext : IVMFunctionResolver
    {
        public DevirtualisationContext(DevirtualisationOptions options, ModuleDefinition targetModule,
            ModuleDefinition runtimeModule, KoiStream koiStream, ILogger logger)
        {
            Options = options ?? throw new ArgumentNullException(nameof(options));
            TargetModule = targetModule ?? throw new ArgumentNullException(nameof(targetModule));
            RuntimeModule = runtimeModule ?? throw new ArgumentNullException(nameof(runtimeModule));
            KoiStream = koiStream ?? throw new ArgumentNullException(nameof(koiStream));
            Logger = logger ?? throw new ArgumentNullException(nameof(logger));

            ReferenceImporter = new ReferenceImporter(targetModule);
        }

        public DevirtualisationOptions Options
        {
            get;
        }

        public ILogger Logger
        {
            get;
        }

        public ModuleDefinition TargetModule
        {
            get;
        }

        public ModuleDefinition RuntimeModule
        {
            get;
        }

        public ReferenceImporter ReferenceImporter
        {
            get;
        }

        public KoiStream KoiStream
        {
            get;
            set;
        }

        public VMEntryInfo VMEntryInfo
        {
            get;
            set;
        }

        public VMConstants Constants
        {
            get;
            set;
        }

        public OpCodeMapping OpCodeMapping
        {
            get;
            set;
        }

        public ICollection<VirtualisedMethod> VirtualisedMethods
        {
            get;
        } = new List<VirtualisedMethod>();

        public bool AllVirtualisedMethodsRecompiled => VirtualisedMethods.All(x => x.CilCompilationUnit != null);

        public MethodDefinition ResolveMethod(uint functionAddress)
        {
            // TODO: make use of dictionary instead of linear search.
            return VirtualisedMethods.FirstOrDefault(x => x.Function.EntrypointAddress == functionAddress)?.CallerMethod;
        }
    }
}


================================================
File: src/OldRod.Pipeline/DevirtualisationException.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;

namespace OldRod.Pipeline
{
    public class DevirtualisationException : Exception
    {
        public DevirtualisationException()
        {
        }

        public DevirtualisationException(string message) 
            : base(message)
        {
        }

        public DevirtualisationException(string message, Exception innerException) 
            : base(message, innerException)
        {
        }
    }
}


================================================
File: src/OldRod.Pipeline/DevirtualisationOptions.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.IO;
using AsmResolver.PE.DotNet.Metadata.Tables;
using OldRod.Core.Architecture;

namespace OldRod.Pipeline
{
    public class DevirtualisationOptions
    {
        public DevirtualisationOptions(string inputFile)
            : this(inputFile, Path.Combine(Path.GetDirectoryName(inputFile), "Devirtualised"))
        {
        }

        public DevirtualisationOptions(string inputFile, string outputDirectory)
        {
            InputFile = inputFile ?? throw new ArgumentNullException(nameof(inputFile));
            OutputOptions.RootDirectory = outputDirectory ?? throw new ArgumentNullException(nameof(outputDirectory));
        }
        
        /// <summary>
        /// Gets the path to the input file.
        /// </summary>
        public string InputFile
        {
            get;
        }

        /// <summary>
        /// Gets or sets the path to the assembly containing the KoiVM runtime. 
        /// </summary>
        /// <remarks>
        /// If this value is <c>null</c>, the devirtualizer will attempt to auto-detect the path to the runtime assembly.
        /// If this value is the same as the input file, the devirtualizer will assume the runtime is embedded into the
        /// input file.
        /// </remarks>
        public string RuntimeFile
        {
            get;
            set;
        }

        /// <summary>
        /// Gets a value indicating whether the runtime is embedded into the target assembly or not.
        /// </summary>
        public bool RuntimeIsEmbedded => RuntimeFile == InputFile;

        /// <summary>
        /// Gets a value indicating whether the location of the runtime should be auto detected or not.
        /// </summary>
        public bool AutoDetectRuntimeFile => RuntimeFile == null;
        
        /// <summary>
        /// Gets options regarding output generation.
        /// </summary>
        public OutputOptions OutputOptions
        {
            get;
        } = new OutputOptions();

        /// <summary>
        /// Gets a value indicating whether a metadata token of the type containing the VM constants was provided. 
        /// </summary>
        public bool OverrideVMConstantsToken => VMConstantsToken != null;

        /// <summary>
        /// Gets or sets a value indicating the metadata token of the type containing the VM constants. 
        /// </summary>
        /// <remarks>
        /// If this value is <c>null</c>, then the devirtualizer will attempt to auto-detect the constants type.
        /// This value is ignored if <see cref="OverrideConstants"/> is <c>True</c>.
        /// </remarks>
        public MetadataToken? VMConstantsToken
        {
            get;
            set;
        }

        /// <summary>
        /// Gets a value indicating whether a metadata token of the VM context type was provided. 
        /// </summary>
        public bool OverrideVMContextToken => VMContextToken != null;
        
        /// <summary>
        /// Gets or sets a value indicating the metadata token of the VM context type. 
        /// </summary>
        /// /// <remarks>
        /// If this value is <c>null</c>, then the devirtualizer will attempt to auto-detect the context type.
        /// </remarks>
        public MetadataToken? VMContextToken
        {
            get;
            set;
        }

        /// <summary>
        /// Gets a value indicating whether a set of VM constants is assigned to use for devirtualizing the input file.
        /// </summary>
        public bool OverrideConstants => Constants != null;
        
        /// <summary>
        /// Gets or sets the VM constants that should be used by the devirtualizer. 
        /// </summary>
        /// <remarks>
        /// If this value is <c>null</c>, the devirtualizer will attempt to auto-detect the constants for the provided
        /// input file.
        /// </remarks>
        public VMConstants Constants
        {
            get;
            set;
        }

        /// <summary>
        /// Gets a value indicating whether a metadata token to the VMEntry type was provided.
        /// </summary>
        public bool OverrideVMEntryToken => VMEntryToken != null;

        /// <summary>
        /// Gets or sets the metadata token to the VMEntry type.
        /// </summary>
        /// <remarks>
        /// If this value is <c>null</c>, the devirtualizer will attempt to auto-detect the VMEntry class for the provided
        /// input file.
        /// </remarks>
        public MetadataToken? VMEntryToken
        {
            get;
            set;
        }
        
        /// <summary>
        /// Gets or sets the name of the metadata stream containing the VM data. 
        /// </summary>
        public string KoiStreamName
        {
            get;
            set;
        } = "#Koi";

        /// <summary>
        /// Gets a value indicating whether an external file was provided containing the VM data. 
        /// </summary>
        public bool OverrideKoiStreamData => KoiStreamDataFile != null;

        /// <summary>
        /// Gets or sets the path to a file containing the VM data.
        /// </summary>
        /// <remarks>
        /// If this value is <c>null</c>, the devirtualizer will assume the VM data is in the metadata stream with the name
        /// specified in <see cref="KoiStreamName"/>. 
        /// </remarks>
        public string KoiStreamDataFile
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a selection of exports to devirtualize.
        /// </summary>
        public IdSelection SelectedExports
        {
            get;
            set;
        } = IdSelection.All;

        /// <summary>
        /// Gets or sets a selection of methods to devirtualize.
        /// </summary>
        public IdSelection SelectedMethods
        {
            get;
            set;
        } = IdSelection.All;

        /// <summary>
        /// Gets or sets a value indicating whether exports defined by the VM data should be mapped to physical methods
        /// in the input file.
        /// </summary>
        public bool NoExportMapping
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the devirtualizer should ignore all invalid metadata that might
        /// be present in the target assembly.
        /// </summary>
        public bool IgnoreInvalidMD
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the devirtualizer should rename runtime symbols.
        /// </summary>
        public bool RenameSymbols
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating the devirtualizer should work in salvage mode. That is, ignore as many errors
        /// as possible if they occur. 
        /// </summary>
        /// <remarks>
        /// This is a dangerous option to enable, and can produce invalid binaries or undefined behaviour in the
        /// devirtualizer.
        /// </remarks>
        public bool EnableSalvageMode
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating the maximum amount of iterations the logic simplifier can use for
        /// optimizing expressions. Null for no limit.
        /// </summary>
        public int? MaxSimplificationPasses
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the list of expected type names for the first run method in the VMEntry class.
        /// </summary>
        public IList<string> Run1ExpectedTypes
        {
            get;
        } = new List<string>
        {
            "System.RuntimeTypeHandle",
            "System.UInt32",
            "System.Object[]"
        };

        /// <summary>
        /// Gets the list of expected type names for the second run method in the VMEntry class.
        /// </summary>
        public IList<string> Run2ExpectedTypes
        {
            get;
        } = new List<string>
        {
            "System.RuntimeTypeHandle",
            "System.UInt32",
            "System.Void*[]",
            "System.Void*",
        };
    }
}


================================================
File: src/OldRod.Pipeline/Devirtualiser.cs
================================================
ï»¿// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using AsmResolver;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Builder;
using AsmResolver.DotNet.Serialized;
using AsmResolver.PE;
using AsmResolver.PE.DotNet.Builder;
using AsmResolver.PE.DotNet.Metadata;
using AsmResolver.PE.File;
using OldRod.Core;
using OldRod.Core.Architecture;
using OldRod.Pipeline.Stages;
using OldRod.Pipeline.Stages.AstBuilding;
using OldRod.Pipeline.Stages.CleanUp;
using OldRod.Pipeline.Stages.CodeAnalysis;
using OldRod.Pipeline.Stages.ConstantsResolution;
using OldRod.Pipeline.Stages.OpCodeResolution;
using OldRod.Pipeline.Stages.Recompiling;
using OldRod.Pipeline.Stages.VMCodeRecovery;
using OldRod.Pipeline.Stages.VMMethodDetection;

namespace OldRod.Pipeline
{
    public class Devirtualiser
    {
        private const string Tag = "Main";
        
        private static ISet<string> RuntimeAssemblyNames = new HashSet<string>
        {
            "Virtualization",
            "KoiVM.Runtime",
        };

        public Devirtualiser(ILogger logger)
        {
            Logger = logger ?? throw new ArgumentNullException(nameof(logger));
            Stages = new List<IStage>
            {
                new ConstantsResolutionStage(),
                new VMMethodDetectionStage(),
                new OpCodeResolutionStage(),
                new VMCodeRecoveryStage(),
                new CodeAnalysisStage(),
                new AstBuilderStage(),
                new RecompilerStage(),
                new CleanUpStage()
            };
        }

        public ILogger Logger
        {
            get;
        }

        public IList<IStage> Stages
        {
            get;
        }

        public void Devirtualise(DevirtualisationOptions options)
        {
            Logger.Log(Tag, "Started devirtualisation.");

            // Create output directory.
            options.OutputOptions.EnsureDirectoriesExist();

            var context = CreateDevirtualisationContext(options);

            // Run pipeline.
            RunPipeline(context);

            // Rebuild.
            Rebuild(options, context);

            Logger.Log(Tag, $"Finished. All fish were caught and served!");
        }

        private DevirtualisationContext CreateDevirtualisationContext(DevirtualisationOptions options)
        {
            string workingDirectory = Path.GetDirectoryName(options.InputFile);
            
            // Open target PE.
            Logger.Log(Tag, $"Opening target file {options.InputFile}...");
            var peFile = PEFile.FromFile(options.InputFile);
            
            // Create #Koi stream aware metadata reader.
            var streamReader = options.OverrideKoiStreamData
                ? new DefaultMetadataStreamReader()
                : (IMetadataStreamReader) new KoiVmAwareStreamReader(options.KoiStreamName, Logger);

            var peImage = PEImage.FromFile(peFile, new PEReaderParameters
            {
                MetadataStreamReader = streamReader
            });

            var metadata = peImage.DotNetDirectory?.Metadata;
            if (metadata is null)
                throw new BadImageFormatException("Assembly does not contain a valid .NET header.");

            // If custom koi stream data was provided, inject it.
            KoiStream koiStream;
            if (!options.OverrideKoiStreamData)
            {
                koiStream = metadata.GetStream<KoiStream>() ?? throw new DevirtualisationException(
                    "Koi stream was not found in the target PE. This could be because the input file is " +
                    "not protected with KoiVM, or the metadata stream uses a name that is different " +
                    "from the one specified in the input parameters.");
            }
            else
            {
                string path = Path.IsPathRooted(options.KoiStreamDataFile)
                    ? options.KoiStreamDataFile
                    : Path.Combine(workingDirectory, options.KoiStreamDataFile);

                Logger.Log(Tag, $"Opening external Koi stream data file {path}...");
                var contents = File.ReadAllBytes(path);

                // Replace original koi stream if it existed.
                koiStream = new KoiStream(options.KoiStreamName, new DataSegment(contents), Logger);
            }

            // Ignore invalid / encrypted method bodies when specified.
            var moduleReadParameters = new ModuleReaderParameters(workingDirectory,
                options.IgnoreInvalidMD ? (IErrorListener)ThrowErrorListener.Instance : EmptyErrorListener.Instance);
            
            var module = ModuleDefinition.FromImage(peImage, moduleReadParameters);
            var runtimeModule = ResolveRuntimeModule(options, module);

            koiStream.ResolutionContext = module;
            return new DevirtualisationContext(options, module, runtimeModule, koiStream, Logger);
        }

        private ModuleDefinition ResolveRuntimeModule(DevirtualisationOptions options, ModuleDefinition targetModule)
        {
            ModuleDefinition runtimeModule = null;

            if (options.AutoDetectRuntimeFile)
            {
                Logger.Debug(Tag, "Attempting to autodetect location of the runtime library...");
                var runtimeAssemblies = targetModule.AssemblyReferences
                    .Where(r => RuntimeAssemblyNames.Contains(r.Name))
                    .ToArray();
                
                switch (runtimeAssemblies.Length)
                {
                    case 0:
                        // No assembly references detected, default to embedded.
                        Logger.Debug(Tag, "No references found to a runtime library.");
                        options.RuntimeFile = options.InputFile;
                        break;
                    case 1:
                        // A single assembly reference with a known KoiVM runtime library name was found.
                        Logger.Debug(Tag, $"Reference to runtime library detected ({runtimeAssemblies[0].Name}).");
                        options.RuntimeFile =
                            Path.Combine(Path.GetDirectoryName(options.InputFile), runtimeAssemblies[0].Name + ".dll");
                        break;
                    default:
                        // Multiple assembly references with a known KoiVM runtime library name were found.
                        // Report to the user that they have to choose which one to use. 
                        throw new DevirtualisationException(
                            "Multiple runtime assembly reference detected. "
                            + "Please specify the location of the runtime assembly to use in the devirtualizer options.");
                }
            }

            if (options.RuntimeIsEmbedded)
            {
                // Runtime is embedded into the assembly, so they share the same metadata image.
                Logger.Log(Tag, "Runtime is embedded in the target assembly.");
                runtimeModule = targetModule;
            }
            else if (options.RuntimeFile != null)
            {
                // Resolve runtime library.
                Logger.Log(Tag, $"Opening external runtime library located at {options.RuntimeFile}...");

                string runtimePath = Path.IsPathRooted(options.RuntimeFile)
                    ? options.RuntimeFile
                    : Path.Combine(Path.GetDirectoryName(options.InputFile), options.RuntimeFile);
                runtimeModule = ModuleDefinition.FromFile(runtimePath);
            }
            else
            {
                throw new DevirtualisationException(
                    "Failed to resolve runtime library. This could be a bug in the initial scanning phase. "
                    + "Try specifying the location of the runtime assembly in the devirtualizer options.");
            }

            return runtimeModule;
        }

        private void RunPipeline(DevirtualisationContext context)
        {
            foreach (var stage in Stages)
            {
                Logger.Log(Tag, $"Executing {stage.Name}...");
                stage.Run(context);
            }
        }

        private void Rebuild(DevirtualisationOptions options, DevirtualisationContext context)
        {
            bool rebuildRuntimeImage = options.RenameSymbols && !options.RuntimeIsEmbedded;
            
            Logger.Log(Tag, $"Reassembling image...");
            SerializeImageToDisk(options, context, context.TargetModule, Path.GetFileName(options.InputFile));

            if (rebuildRuntimeImage)
            {
                Logger.Log(Tag, $"Reassembling runtime image...");
                SerializeImageToDisk(options, context, context.RuntimeModule, Path.GetFileName(context.Options.RuntimeFile));
            }
        }

        private static void SerializeImageToDisk(
            DevirtualisationOptions options, 
            DevirtualisationContext context,
            ModuleDefinition module,
            string fileName)
        {
            var diagnosticBag = new DiagnosticBag();
            var imageBuilder = new ManagedPEImageBuilder(diagnosticBag);

            var result = imageBuilder.CreateImage(module);
            if (diagnosticBag.IsFatal)
                throw new AggregateException(diagnosticBag.Exceptions);

            foreach (var error in diagnosticBag.Exceptions)
                context.Logger.Error(Tag, error.Message);

            var fileBuilder = new ManagedPEFileBuilder();
            var file = fileBuilder.CreateFile(result.ConstructedImage);
            
            file.Write(Path.Combine(options.OutputOptions.RootDirectory, fileName));
        }
    }
}


================================================
File: src/OldRod.Pipeline/IdSelection.cs
================================================
using System.Collections.Generic;

namespace OldRod.Pipeline
{
    public abstract class IdSelection
    {
        public static readonly IdSelection All = new AllIdsSelection();

        public abstract bool Contains(uint id);

        private sealed class AllIdsSelection : IdSelection
        {
            public override bool Contains(uint id) => true;
        }
    }
    
    public class ExclusionIdSelection : IdSelection
    {
        public ISet<uint> ExcludedIds
        {
            get;
        } = new HashSet<uint>();

        public override bool Contains(uint id)
        {
            return !ExcludedIds.Contains(id);
        }
    }

    public class IncludedIdSelection : IdSelection
    {
        public ISet<uint> IncludedIds
        {
            get;
        } = new HashSet<uint>();
        
        public override bool Contains(uint id)
        {
            return IncludedIds.Contains(id);
        }
    }
}


================================================
File: src/OldRod.Pipeline/KoiVmAwareStreamReader.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using AsmResolver;
using AsmResolver.IO;
using AsmResolver.PE.DotNet.Metadata;
using OldRod.Core;
using OldRod.Core.Architecture;

namespace OldRod.Pipeline
{
    public class KoiVmAwareStreamReader : IMetadataStreamReader
    {
        private readonly IMetadataStreamReader _reader;

        public KoiVmAwareStreamReader(ILogger logger)
            : this("#Koi", logger)
        {
        }

        public KoiVmAwareStreamReader(string koiStreamName, ILogger logger)
        {
            KoiStreamName = koiStreamName ?? throw new ArgumentNullException(nameof(koiStreamName));
            Logger = logger;
            _reader = new DefaultMetadataStreamReader();
        }
        
        public string KoiStreamName
        {
            get;
        }

        public ILogger Logger
        {
            get;
        }

        public IMetadataStream ReadStream(MetadataReaderContext context, MetadataStreamHeader header, ref BinaryStreamReader reader)
        {
            return header.Name == KoiStreamName
                ? new KoiStream(KoiStreamName, new DataSegment(reader.ReadToEnd()), Logger)
                : _reader.ReadStream(context, header, ref reader);
        }
    }
}


================================================
File: src/OldRod.Pipeline/OldRod.Pipeline.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <Title>OldRod</Title>
    <Version>0.10.1.0</Version>
    <Copyright>Copyright 2019-2022 Washi</Copyright>
    <Description>KoiVM devirtualisation pipeline library</Description>
    <Authors>Washi</Authors>
    <AssemblyVersion>0.10.1.0</AssemblyVersion>
    <FileVersion>0.10.1.0</FileVersion>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <TargetFramework>netstandard2.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="$(SolutionDir)\src\OldRod.Core\OldRod.Core.csproj" />
    <ProjectReference Include="$(SolutionDir)\deps\Rivers\Rivers\Rivers.csproj" />
  </ItemGroup>
</Project>


================================================
File: src/OldRod.Pipeline/OutputOptions.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.IO;

namespace OldRod.Pipeline
{
    public class OutputOptions
    {
        public string RootDirectory
        {
            get;
            set;
        }

        public string DumpsDirectory => Path.Combine(RootDirectory, "Dumps");

        public string ILDumpsDirectory => Path.Combine(DumpsDirectory, "IL");
        
        public string ILAstDumpsDirectory => Path.Combine(DumpsDirectory, "IL-AST");
        
        public string CilAstDumpsDirectory => Path.Combine(DumpsDirectory, "CIL-AST");
        
        public string CilDumpsDirectory => Path.Combine(DumpsDirectory, "CIL");
        
        public bool DumpControlFlowGraphs
        {
            get;
            set;
        }
        
        public bool DumpAllControlFlowGraphs
        {
            get;
            set;
        }

        public bool DumpDisassembledIL
        {
            get;
            set;
        }

        public bool DumpRecompiledCil
        {
            get;
            set;
        }

        private IEnumerable<string> GetNecessaryDirectories()
        {
            var result = new List<string> {RootDirectory};

            if (DumpDisassembledIL || DumpControlFlowGraphs || DumpRecompiledCil)
                result.Add(DumpsDirectory);
            
            if (DumpDisassembledIL || DumpControlFlowGraphs)
                result.Add(ILDumpsDirectory);
            
            if (DumpControlFlowGraphs || DumpAllControlFlowGraphs)
            {
                result.Add(ILAstDumpsDirectory);
                result.Add(CilAstDumpsDirectory);
            }

            if (DumpRecompiledCil)
                result.Add(CilDumpsDirectory);
            
            return result;
        }

        public void EnsureDirectoriesExist()
        {
            foreach (var directory in GetNecessaryDirectories())
            {
                if (!Directory.Exists(directory))
                    Directory.CreateDirectory(directory);
            }
        }
        
    }
}


================================================
File: src/OldRod.Pipeline/VirtualisedMethod.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using OldRod.Core.Architecture;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Ast.IL;
using OldRod.Core.Disassembly.ControlFlow;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Pipeline
{
    public class VirtualisedMethod
    {
        public VirtualisedMethod(VMFunction function)
        {
            Function = function;
        }
        
        public VirtualisedMethod(VMFunction function, uint exportId, VMExportInfo exportInfo)
        {
            Function = function;
            ExportId = exportId;
            ExportInfo = exportInfo;
        }

        public VMFunction Function
        {
            get;
        }

        public VMExportInfo ExportInfo
        {
            get;
        }
        public bool IsExport => ExportId != null;

        public uint? ExportId
        {
            get;
        }

        public MethodSignature MethodSignature
        {
            get;
            set;
        }

        public bool IsMethodSignatureInferred
        {
            get;
            set;
        }

        public MethodDefinition CallerMethod
        {
            get;
            set;
        }

        public ControlFlowGraph ControlFlowGraph
        {
            get;
            set;
        }

        public ILCompilationUnit ILCompilationUnit
        {
            get;
            set;
        }

        public CilCompilationUnit CilCompilationUnit
        {
            get;
            set;
        }

        public override string ToString()
        {
            return IsExport
                ? $"{Function} (Export {ExportId}, Method: {CallerMethod})"
                : $"{Function} (Method: {CallerMethod})";
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/IStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Pipeline.Stages
{
    public interface IStage
    {
        string Name { get; }

        void Run(DevirtualisationContext context);
    }
}


================================================
File: src/OldRod.Pipeline/Stages/AstBuilding/AstBuilderStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.IO;
using System.Linq;
using OldRod.Core.Ast.IL;
using OldRod.Core.Memory;
using Rivers.Serialization.Dot;

namespace OldRod.Pipeline.Stages.AstBuilding
{
    public class AstBuilderStage : IStage
    {
        private const string Tag = "AstBuilder";
        
        public string Name => "IL AST builder stage";

        public void Run(DevirtualisationContext context)
        {
            foreach (var method in context.VirtualisedMethods)
            {
                if (method.IsExport
                    && !context.Options.SelectedExports.Contains(method.ExportId.Value))
                    continue;
                    
                context.Logger.Debug(Tag, $"Building IL AST for function_{method.Function.EntrypointAddress:X4}...");

                // Create builder.
                var builder = new ILAstBuilder
                {
                    Logger = context.Logger,
                    MaxSimplificationPasses = context.Options.MaxSimplificationPasses 
                };

                // Subscribe to progress events if user specified it in the options. 
                if (context.Options.OutputOptions.DumpAllControlFlowGraphs)
                {
                    int step = 1;
                    builder.InitialAstBuilt += (sender, args) =>
                    {
                        context.Logger.Debug2(Tag, $"Dumping initial IL AST for function_{method.Function.EntrypointAddress:X4}...");
                        method.ILCompilationUnit = args;
                        DumpILAst(context, method, $" (0. Initial)");
                    };

                    builder.TransformEnd += (sender, args) =>
                    {
                        context.Logger.Debug2(Tag,$"Dumping tentative IL AST for function_{method.Function.EntrypointAddress:X4}...");
                        method.ILCompilationUnit = args.Unit;
                        DumpILAst(context, method, $" ({step++}. {args.Transform.Name}-{args.Iteration})");
                    };
                }

                // Build the AST.
                try
                {
                    method.ILCompilationUnit = builder.BuildAst(method.ControlFlowGraph, method.Function.FrameLayout,
                        context.Constants);
                }
                catch (Exception ex) when (context.Options.EnableSalvageMode)
                {
                    context.Logger.Error(Tag,
                        $"Failed to construct IL-AST of function_{method.Function.EntrypointAddress:X4}. "
                        + $"The function will not be recompiled. {ex.Message}");
                }

                // Dump graphs if user specified it in the options.
                if (method.ILCompilationUnit != null && context.Options.OutputOptions.DumpControlFlowGraphs)
                {
                    context.Logger.Log(Tag, $"Dumping IL AST for function_{method.Function.EntrypointAddress:X4}...");
                    DumpILAst(context, method);
                    DumpILAstTree(context, method);
                }
            }
        }

        private static void DumpILAstTree(DevirtualisationContext context, VirtualisedMethod method)
        {
            using (var fs = File.CreateText(Path.Combine(context.Options.OutputOptions.ILAstDumpsDirectory,
                $"function_{method.Function.EntrypointAddress:X4}_tree.dot")))
            {
                WriteHeader(fs, method);
                var writer = new DotWriter(fs, new BasicBlockSerializer());
                writer.Write(method.ILCompilationUnit.ConvertToGraphViz());
            }
        }

        private static void DumpILAst(DevirtualisationContext context, VirtualisedMethod method, string suffix = null)
        {
            using (var fs = File.CreateText(Path.Combine(
                context.Options.OutputOptions.ILAstDumpsDirectory, 
                $"function_{method.Function.EntrypointAddress:X4}{suffix}.dot")))
            {
                WriteHeader(fs, method);
                var writer = new DotWriter(fs, new BasicBlockSerializer());
                writer.Write(method.ControlFlowGraph.ConvertToGraphViz(ILAstBlock.AstBlockProperty));
            }
        }

        private static void WriteHeader(TextWriter writer, VirtualisedMethod method)
        {   
            writer.WriteLine("// Export ID: " + (method.ExportId?.ToString() ?? "<none>"));

            var exportInfo = method.ExportInfo;
            if (exportInfo != null)
            {
                writer.WriteLine("// Raw function signature: ");
                writer.WriteLine("//    Flags: 0x{0:X2} (0b{1})",
                    exportInfo.Signature.Flags,
                    Convert.ToString(exportInfo.Signature.Flags, 2).PadLeft(8, '0'));
                writer.WriteLine($"//    Return Type: {exportInfo.Signature.ReturnToken}");
                writer.WriteLine($"//    Parameter Types: " + string.Join(", ", exportInfo.Signature.ParameterTokens));
            }

            writer.WriteLine("// Inferred method signature: " + method.MethodSignature);
            writer.WriteLine("// Physical method: " + method.CallerMethod);
            writer.WriteLine("// Entrypoint Offset: " + method.Function.EntrypointAddress.ToString("X4"));
            writer.WriteLine("// Entrypoint Key: " + method.Function.EntryKey.ToString("X8"));
                
            writer.WriteLine();
            
            writer.WriteLine("// Variables: ");
            
            foreach (var variable in method.ILCompilationUnit.Variables)
                writer.WriteLine($"//    {variable.Name}: {variable.VariableType} (assigned {variable.AssignedBy.Count}x, used {variable.UsedBy.Count}x)");
            
            writer.WriteLine();
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/CleanUp/CleanUpStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

namespace OldRod.Pipeline.Stages.CleanUp
{
    public class CleanUpStage : IStage
    {
        private const string Tag = "CleanUp";
        
        public string Name => "Clean up stage";

        public void Run(DevirtualisationContext context)
        {
            
        }
    }
}



================================================
File: src/OldRod.Pipeline/Stages/CodeAnalysis/CodeAnalysisStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Annotations;
using OldRod.Core.Disassembly.Inference;
using OldRod.Core.Memory;

namespace OldRod.Pipeline.Stages.CodeAnalysis
{
    public class CodeAnalysisStage : IStage
    {
        private static readonly SignatureComparer Comparer = new SignatureComparer();
        
        public const string Tag = "CodeAnalysis";
        
        public string Name => "Code Analysis Stage";

        public IFrameLayoutDetector FrameLayoutDetector
        {
            get;
            set;
        } = new DefaultFrameLayoutDetector();
        
        public void Run(DevirtualisationContext context)
        {
            foreach (var method in context.VirtualisedMethods)
            {   
                // Detect stack frame layout of function.
                context.Logger.Debug(Tag, $"Detecting stack frame layout for function_{method.Function.EntrypointAddress:X4}...");
                method.Function.FrameLayout = method.IsExport
                    ? FrameLayoutDetector.DetectFrameLayout(context.Constants, context.TargetModule, method.ExportInfo)
                    : FrameLayoutDetector.DetectFrameLayout(context.Constants, context.TargetModule, method.Function);

                if (method.MethodSignature == null)
                {
                    // Create missing method signature based on the frame layout.
                    context.Logger.Debug(Tag, $"Inferring method signature from stack frame layout of function_{method.Function.EntrypointAddress:X4}...");
                    method.MethodSignature = CreateMethodSignature(context, method.Function.FrameLayout);
                    method.IsMethodSignatureInferred =
                        method.Function.References.All(r => r.ReferenceType != FunctionReferenceType.Ldftn);
                }
                
                if (method.CallerMethod == null)
                {
                    // Create methods for VM functions that are not mapped to any physical methods.
                    // This can happen if the VM method detection stage fails to map all methods to physical method defs,
                    // or the virtualised code refers to internal calls into the VM code.
                    context.Logger.Debug(Tag, $"Creating new physical method for function_{method.Function.EntrypointAddress:X4}...");
                    AddPhysicalMethod(context, method);
                }
            }
        }

        private static MethodSignature CreateMethodSignature(DevirtualisationContext context, IFrameLayout layout)
        {
            var flags = layout.HasThis ? CallingConventionAttributes.HasThis : 0;
            var returnType = layout.ReturnType ?? context.TargetModule.CorLibTypeFactory.Object;
            var parameterTypes = new List<TypeSignature>();
            
            // Add parameters.
            for (int i = 0; i < layout.Parameters.Count; i++){
                parameterTypes.Add(layout.Parameters[i].Type ?? context.TargetModule.CorLibTypeFactory.Object);}

            return new MethodSignature(flags, returnType, parameterTypes);
        }

        private static void AddPhysicalMethod(DevirtualisationContext context, VirtualisedMethod method)
        {
            bool isHelperInit = method.ExportId == context.Constants.HelperInit;
            
            // Decide on a name of the new method.
            string name;
            if (!method.IsExport)
                name = "__VMFUNCTION__" + method.Function.EntrypointAddress.ToString("X4");
            else if (isHelperInit)
                name = "__VMHELPER_INIT__";
            else
                name = "__VMEXPORT__" + method.ExportId;

            // Create new physical method.
            var dummy = new MethodDefinition(name,
                MethodAttributes.Public,
                method.MethodSignature);
            dummy.IsStatic = !method.MethodSignature.HasThis;
            dummy.CilMethodBody = new CilMethodBody(dummy);
            method.CallerMethod = dummy;
            
            // We perform a heuristic analysis on all private members that are accessed in the code, as these are only
            // able to be accessed if the caller is in the same type.

            var inferredDeclaringType = TryInferDeclaringTypeFromMemberAccesses(context, method);

            // If that fails (e.g. there are no private member accesses), we check if the method is an instance member.
            // If it is, the this parameter is always the declaring type, EXCEPT for one scenario:
            // 
            // When the method is intra-linked and only referenced through a LDFTN function, the this parameter type
            // can be inaccurate. KoiVM does not care for the type of the this object, as everything is done through
            // reflection, so it reuses the method signature for things like instance event handlers (object, EventArgs),
            // even though the hidden this parameter might have had a different type.
            
            if (inferredDeclaringType == null && !dummy.IsStatic)
                inferredDeclaringType = TryInferDeclaringTypeFromThisParameter(context, dummy);

            if (inferredDeclaringType != null)
            {
                // We found a declaring type!
                context.Logger.Debug(Tag,
                    $"Inferred declaring type of function_{method.Function.EntrypointAddress:X4} ({inferredDeclaringType}).");
                
                // Remove this parameter from the method signature if necessary.
                if (!dummy.IsStatic && dummy.Signature.ParameterTypes.Count > 0)
                    dummy.Signature.ParameterTypes.RemoveAt(0);
            }
            else
            {
                // Fallback method: Add to <Module> and make static.
                context.Logger.Debug(Tag, isHelperInit
                    ? $"Adding HELPER_INIT to <Module>."
                    : $"Could not infer declaring type of function_{method.Function.EntrypointAddress:X4}. Adding to <Module> instead.");

                dummy.IsStatic = true;
                method.MethodSignature.HasThis = false;
                inferredDeclaringType = context.TargetModule.Assembly.Modules[0].TopLevelTypes[0];
            }

            inferredDeclaringType.Methods.Add(dummy);
            dummy.Parameters.PullUpdatesFromMethodSignature();
        }
        
        private static TypeDefinition TryInferDeclaringTypeFromMemberAccesses(
            DevirtualisationContext context,
            VirtualisedMethod method)
        {
            // Get all private member accesses.
            var privateMemberRefs = new HashSet<IMemberDescriptor>();

            foreach (var instruction in method.Function.Instructions.Values)
            {
                IMemberProvider provider;
                
                var annotation = instruction.Annotation;
                switch (annotation)
                {
                    case IMemberProvider p:
                        provider = p;
                        break;

                    case CallAnnotation call:
                        var resolvedMethod = context.ResolveMethod(call.Function.EntrypointAddress);
                        if (resolvedMethod == null)
                            continue;
                        provider = new ECallAnnotation(resolvedMethod, VMECallOpCode.CALL);
                        break;
                    
                    default:
                        continue;
                }

                if (provider.Member.DeclaringType != null
                    && provider.Member.DeclaringType.Scope.GetAssembly() == context.TargetModule.Assembly
                    && provider.RequiresSpecialAccess)
                {
                    privateMemberRefs.Add(provider.Member);
                }
            }

            var types = new List<TypeDefinition>();
            foreach (var member in privateMemberRefs)
            {
                var memberDef = member.Resolve();
                var declaringTypes = GetDeclaringTypes(memberDef as TypeDefinition ?? memberDef.DeclaringType);
                types.Add(declaringTypes.First(t => memberDef.IsAccessibleFromType(t)));
            }

            if (types.Count == 0)
                return null;
            
            types.Sort((a, b) =>
            {
                if (a.IsAccessibleFromType(b))
                    return b.IsAccessibleFromType(a) ? 0 : 1;
                else
                    return b.IsAccessibleFromType(a) ? 0 : -1;
            });

            return types[0];
        }

        private static IList<TypeDefinition> GetDeclaringTypes(TypeDefinition type)
        {
            var types = new List<TypeDefinition>();
            while (type != null)
            {
                types.Add(type);
                type = type.DeclaringType;
            }

            types.Reverse();
            return types;
        }

        private static TypeDefinition TryInferDeclaringTypeFromThisParameter(
            DevirtualisationContext context,
            MethodDefinition dummy)
        {
            if (dummy.Signature.ParameterTypes.Count == 0)
            {
                context.Logger.Warning(Tag,
                    $"Method {dummy.Name} is marked as an instance method but does " +
                    "not define any parameters. The method will be made static instead.");
                return null;
            }
            
            var thisType = dummy.Signature.ParameterTypes[0];
            return thisType.Scope == context.TargetModule.Assembly.Modules[0]
                ? thisType.Resolve()
                : null;
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/ConstantsResolution/ConstantsResolutionStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.Architecture;

namespace OldRod.Pipeline.Stages.ConstantsResolution
{
    public class ConstantsResolutionStage : IStage
    {
        private const string Tag = "ConstantsResolver";

        public string Name => "Constants resolution stage";

        public void Run(DevirtualisationContext context)
        {
            if (context.Options.OverrideConstants)
            {
                context.Logger.Debug(Tag, "Using pre-defined constants.");
                context.Constants = context.Options.Constants;
            }
            else
            {
                context.Logger.Debug(Tag, "Attempting to auto-detect constants...");
                context.Constants = AutoDetectConstants(context);
            }

            context.Logger.Debug(Tag, "Attempting to extract key scalar value...");
            context.Constants.KeyScalar = FindKeyScalarValue(context);
        }

        private VMConstants AutoDetectConstants(DevirtualisationContext context)
        {
            bool rename = context.Options.RenameSymbols;

            var constants = new VMConstants();
            var fields = FindConstantFieldsAndValues(context);

            foreach (var field in fields)
                constants.ConstantFields.Add(field.Key, field.Value);

            // TODO:
            // We assume that the constants appear in the same order as they were defined in the original source code.
            // This means the metadata tokens of the fields are also in increasing order. However, this could cause
            // problems when a fork of the obfuscation tool is made which scrambles the order.  A more robust way of
            // matching should be done that is order agnostic.

            var sortedFields = fields
                .OrderBy(x => x.Key.MetadataToken.ToUInt32())
                .ToArray();

            int currentIndex = 0;

            context.Logger.Debug2(Tag, "Resolving register mapping...");
            for (int i = 0; i < (int) VMRegisters.Max; i++, currentIndex++)
            {
                constants.Registers.Add(sortedFields[currentIndex].Value, (VMRegisters) i);
                if (rename)
                    sortedFields[currentIndex].Key.Name = "REG_" + (VMRegisters) i;
            }

            context.Logger.Debug2(Tag, "Resolving flag mapping...");
            for (int i = 1; i < (int) VMFlags.Max; i <<= 1, currentIndex++)
            {
                constants.Flags.Add(sortedFields[currentIndex].Value, (VMFlags) i);
                if (rename)
                    sortedFields[currentIndex].Key.Name = "FLAG_" + (VMFlags) i;
            }

            context.Logger.Debug2(Tag, "Resolving opcode mapping...");
            for (int i = 0; i < (int) ILCode.Max; i++, currentIndex++)
            {
                constants.OpCodes.Add(sortedFields[currentIndex].Value, (ILCode) i);
                if (rename)
                    sortedFields[currentIndex].Key.Name = "OPCODE_" + (ILCode) i;
            }

            context.Logger.Debug2(Tag, "Resolving vmcall mapping...");
            for (int i = 0; i < (int) VMCalls.Max; i++, currentIndex++)
            {
                constants.VMCalls.Add(sortedFields[currentIndex].Value, (VMCalls) i);
                if (rename)
                    sortedFields[currentIndex].Key.Name = "VMCALL_" + (VMCalls) i;
            }

            context.Logger.Debug2(Tag, "Resolving helper init ID...");
            if (rename)
                sortedFields[currentIndex].Key.Name = "HELPER_INIT";
            constants.HelperInit = sortedFields[currentIndex++].Value;

            context.Logger.Debug2(Tag, "Resolving ECall mapping...");
            for (int i = 0; i < 4; i++, currentIndex++)
            {
                constants.ECallOpCodes.Add(sortedFields[currentIndex].Value, (VMECallOpCode) i);
                if (rename)
                    sortedFields[currentIndex].Key.Name = "ECALL_" + (VMECallOpCode) i;
            }

            context.Logger.Debug2(Tag, "Resolving function signature flags...");
            sortedFields[currentIndex].Key.Name = "FLAG_INSTANCE";
            constants.FlagInstance = sortedFields[currentIndex++].Value;

            context.Logger.Debug2(Tag, "Resolving exception handler types...");
            for (int i = 0; i < (int) EHType.Max; i++, currentIndex++)
            {
                constants.EHTypes.Add(sortedFields[currentIndex].Value, (EHType) i);
                if (rename)
                    sortedFields[currentIndex].Key.Name = "EH_" + (EHType) i;
            }

            return constants;
        }

        private IDictionary<FieldDefinition, byte> FindConstantFieldsAndValues(DevirtualisationContext context)
        {
            context.Logger.Debug(Tag, "Locating constants type...");
            var constantsType = LocateConstantsType(context);
            if (constantsType == null)
                throw new DevirtualisationException("Could not locate constants type!");
            context.Logger.Debug(Tag, $"Found constants type ({constantsType.MetadataToken}).");

            if (context.Options.RenameSymbols)
            {
                constantsType.Namespace = "KoiVM.Runtime.Dynamic";
                constantsType.Name = "Constants";
            }
            
            context.Logger.Debug(Tag, $"Resolving constants table...");
            return ParseConstantValues(constantsType);
        }

        private static TypeDefinition LocateConstantsType(DevirtualisationContext context)
        {
            TypeDefinition constantsType = null;
            
            if (context.Options.OverrideVMConstantsToken)
            {
                context.Logger.Debug(Tag, $"Using token {context.Options.VMConstantsToken} for constants type.");
                constantsType = (TypeDefinition) context.RuntimeModule.LookupMember(context.Options.VMConstantsToken.Value);
            }
            else
            {
                // Constants type contains a lot of public static byte fields, and only those byte fields. 
                // Therefore we pattern match on this signature, by finding the type with the most public
                // static byte fields.

                // It is unlikely that any other type has that many byte fields, although it is possible.
                // This could be improved later on.

                int max = 0;
                foreach (var type in context.RuntimeModule.Assembly.Modules[0].TopLevelTypes)
                {
                    // Optimisation: Check first count of all fields. We need at least the amount of opcodes of fields. 
                    if (type.Fields.Count < (int) ILCode.Max)
                        continue;
                    
                    // Count public static byte fields.
                    int byteFields = type.Fields.Count(x =>
                        x.IsPublic && x.IsStatic && x.Signature.FieldType.IsTypeOf("System", "Byte"));

                    if (byteFields == type.Fields.Count && max < byteFields)
                    {
                        constantsType = type;
                        max = byteFields;
                    }
                }
            }

            return constantsType;
        }

        private static IDictionary<FieldDefinition, byte> ParseConstantValues(TypeDefinition constantsType)
        {
            // .cctor initialises the fields using a repetition of the following sequence:
            //
            //     ldnull
            //     ldc.i4 x
            //     stfld constantfield
            //
            // We can simply go over each instruction and "emulate" the ldc.i4 and stfld instructions.

            var result = new Dictionary<FieldDefinition, byte>();
            var cctor = constantsType.GetStaticConstructor();
            if (cctor == null)
                throw new DevirtualisationException("Specified constants type does not have a static constructor.");

            byte nextValue = 0;
            foreach (var instruction in cctor.CilMethodBody.Instructions)
            {
                if (instruction.IsLdcI4())
                    nextValue = (byte) instruction.GetLdcI4Constant();
                else if (instruction.OpCode.Code == CilCode.Stfld || instruction.OpCode.Code == CilCode.Stsfld)
                    result[(FieldDefinition) instruction.Operand] = nextValue;
            }

            return result;
        }

        private static uint FindKeyScalarValue(DevirtualisationContext context) 
        {
            context.Logger.Debug(Tag, "Locating VMContext type...");
            var vmCtxType = LocateVmContextType(context);
            if (vmCtxType is null) 
            {
                context.Logger.Warning(Tag, "Could not locate VMContext type, using default scalar value!");
                return 7;
            }
            context.Logger.Debug(Tag, $"Found VMContext type ({vmCtxType.MetadataToken}).");
            
            if (context.Options.RenameSymbols)
            {
                vmCtxType.Namespace = "KoiVM.Runtime.Execution";
                vmCtxType.Name = "VMContext";
            }

            var readByteMethod = vmCtxType.Methods.First(x => x.Signature.ReturnType.IsTypeOf("System", "Byte"));

            if (context.Options.RenameSymbols)
                readByteMethod.Name = "ReadByte";
            
            var instructions = readByteMethod.CilMethodBody.Instructions;
            for (int i = 0; i < instructions.Count; i++) 
            {
                var instr = instructions[i];
                if (instr.IsLdcI4() && instructions[i + 1].OpCode.Code == CilCode.Mul)
                    return (uint)instr.GetLdcI4Constant();
            }

            context.Logger.Warning(Tag, "Could not locate scalar value, using default!");
            return 7;
        }

        private static TypeDefinition LocateVmContextType(DevirtualisationContext context) 
        {
            if (context.Options.OverrideVMContextToken)
            {
                context.Logger.Debug(Tag, $"Using token {context.Options.VMContextToken} for constants type.");
                return (TypeDefinition)context.RuntimeModule.LookupMember(context.Options.VMContextToken.Value);
            }
            
            for (int i = 0; i < context.RuntimeModule.TopLevelTypes.Count; i++) 
            {
                var type = context.RuntimeModule.TopLevelTypes[i];
                if (type.IsAbstract)
                    continue;
                if (type.Methods.Count < 2)
                    continue;
                if (type.Fields.Count < 5)
                    continue;
                if (type.Methods.Count(x => x.IsPublic && x.Signature.ReturnType.IsTypeOf("System", "Byte")) != 1)
                    continue;
                if (type.Fields.Count(x => x.IsPublic && x.IsInitOnly && x.Signature.FieldType is SzArrayTypeSignature) != 1)
                    continue;

                int foundArrays = 0;
                int foundLists = 0;
                for (int j = 0; j < type.Fields.Count; j++) 
                {
                    var field = type.Fields[j];
                    if (field.IsPublic && field.IsInitOnly) 
                    {
                        if (field.Signature.FieldType is GenericInstanceTypeSignature genericSig &&
                            genericSig.GenericType.IsTypeOf("System.Collections.Generic", "List`1"))
                            foundLists++;

                        if (field.Signature.FieldType is SzArrayTypeSignature arraySig && arraySig.BaseType.IsValueType)
                            foundArrays++;
                    }
                }

                if (foundArrays != 1 || foundLists != 2)
                    continue;

                return type;
            }

            return null;
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/OpCodeResolution/OpCodeInfo.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;
using OldRod.Core.Architecture;

namespace OldRod.Pipeline.Stages.OpCodeResolution
{
    public struct OpCodeInfo
    {
        public OpCodeInfo(TypeDefinition opCodeType, ILCode opCode)
        {
            OpCodeType = opCodeType;
            OpCode = opCode;
        }

        public TypeDefinition OpCodeType { get; }

        public ILCode OpCode { get; }

        public override string ToString()
        {
            return $"{OpCode} ({OpCodeType.MetadataToken})";
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/OpCodeResolution/OpCodeInterfaceInfo.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;

namespace OldRod.Pipeline.Stages.OpCodeResolution
{
    public class OpCodeInterfaceInfo
    {
        public OpCodeInterfaceInfo(TypeDefinition interfaceType, MethodDefinition getCode, MethodDefinition run)
        {
            InterfaceType = interfaceType;
            GetCodeMethod = getCode;
            RunMethod = run;
        }
        
        public TypeDefinition InterfaceType { get; }
        
        public MethodDefinition GetCodeMethod { get; }
        
        public MethodDefinition RunMethod { get; }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/OpCodeResolution/OpCodeMapping.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using AsmResolver.DotNet;

namespace OldRod.Pipeline.Stages.OpCodeResolution
{
    public class OpCodeMapping
    {
        public OpCodeMapping(IDictionary<byte, OpCodeInfo> opCodes, IDictionary<byte, TypeDefinition> vCalls)
        {
            OpCodes = opCodes;
            VCalls = vCalls;
        }
        
        public IDictionary<byte, OpCodeInfo> OpCodes { get; }

        public IDictionary<byte, TypeDefinition> VCalls { get; }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/OpCodeResolution/OpCodeResolutionStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Cil;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;

namespace OldRod.Pipeline.Stages.OpCodeResolution
{
    /*
     * NOTE: This stage might be redundant for a correct devirtualization.
     * 
     * At the moment, DevirtualisationContext.OpCodeMapping is not really used, and finding the opcode handlers is
     * only used for debugging purposes and the renaming symbols feature.
     */
    
    public class OpCodeResolutionStage : IStage
    {
        public const string Tag = "MappingResolver";
        private static readonly SignatureComparer Comparer = new SignatureComparer();
        
        public string Name => "OpCode mapping resolution stage";
        
        public void Run(DevirtualisationContext context)
        {
            if (context.Constants.ConstantFields.Count == 0)
            {
                context.Logger.Warning(Tag, "Finding opcode handlers using custom constant mapping is unsupported.");
                return;
            }
            
            context.OpCodeMapping = ResolveOpCodeLookupTable(context);
        }

        private static OpCodeMapping ResolveOpCodeLookupTable(DevirtualisationContext context)
        {
            context.Logger.Debug(Tag, "Locating opcode interface...");
            var infos = LocateOpCodeInterfaces(context);
            if (infos.Count == 0)
            {
                // Since finding the opcode handlers is not really used (yet) in the devirtualizer, except for debugging
                // purposes and renaming of symbols, it is enough to just warn the user instead of throwing an exception.
                context.Logger.Warning(Tag, "Could not locate opcode interfaces.");
                return null;
            }

            context.Logger.Debug(Tag,
                $"Opcode interfaces found ({string.Join(", ", infos.Select(x => x.InterfaceType.MetadataToken))}).");

            context.Logger.Debug(Tag, "Resolving opcode lookup table...");
            return MatchOpCodeTypes(context, infos);
        }

        private static IList<OpCodeInterfaceInfo> LocateOpCodeInterfaces(DevirtualisationContext context)
        {
            var result = new List<OpCodeInterfaceInfo>();
            foreach (var type in context.RuntimeModule.Assembly.Modules[0].TopLevelTypes.Where(x => x.IsInterface && x.Methods.Count == 2))
            {
                MethodDefinition getter = null;
                MethodDefinition run = null;
                
                foreach (var method in type.Methods)
                {
                    if (method.Parameters.Count == 0 && method.Signature.ReturnType.IsTypeOf("System", "Byte"))
                    {
                        // Matched signature byte get_Code(): 
                        getter = method;
                    }
                    else if (method.Parameters.Count == 2
                             && (method.Parameters[1].Definition.Attributes.HasFlag(ParameterAttributes.Out))
                             && method.Signature.ReturnType.IsTypeOf("System", "Void"))
                    {
                        // Matched signature of void Run(VMContext, out ExecutionStage).
                        run = method;
                    }
                }

                if (getter != null && run != null)
                    result.Add(new OpCodeInterfaceInfo(type, getter, run));
            }

            return result;
        }

        private static OpCodeMapping MatchOpCodeTypes(DevirtualisationContext context, IList<OpCodeInterfaceInfo> opcodeInterfaces)
        {
            // There are two types of opcodes: normal opcodes and vcall opcodes.
            // We do not know yet which of the interfaces is the IOpcode and IVcall interface yet. They have exactly
            // the same members, however the amount of types implementing the IVCall interface is significantly lower
            // than normal opcodes. We determine therefore which one is which by checking the counts.
            
            var mapping1 = new Dictionary<byte, TypeDefinition>();
            var mapping2 = new Dictionary<byte, TypeDefinition>();

            // Find all opcode and vcall classes.
            foreach (var opcodeType in context.RuntimeModule.Assembly.Modules[0].TopLevelTypes
                .Where(t => t.IsClass))
            {
                var opcodeInterface = opcodeInterfaces.FirstOrDefault(x =>
                    opcodeType.Interfaces.Any(i => i.Interface == x.InterfaceType));

                if (opcodeInterface != null)
                {
                    var getCode = opcodeType.Methods.First(x => x.Name == opcodeInterface.GetCodeMethod.Name);
                    var ldsfld = getCode.CilMethodBody.Instructions.First(x => x.OpCode.Code == CilCode.Ldsfld);
                    var rawOpCodeField = (FieldDefinition) ldsfld.Operand;

                    if (!context.Constants.ConstantFields.TryGetValue(rawOpCodeField, out byte opCodeValue))
                        continue;

                    if (opcodeInterface == opcodeInterfaces[0])
                        mapping1.Add(opCodeValue, opcodeType);
                    else
                        mapping2.Add(opCodeValue, opcodeType);
                }
            }

            // The biggest mapping is the one of the opcodes, the smallest is the vcalls.
            if (mapping1.Count < mapping2.Count)
                (mapping1, mapping2) = (mapping2, mapping1);

            // Map all opcodes.
            var opcodes = new Dictionary<byte, OpCodeInfo>();
            foreach (var entry in mapping1)
            {
                var opCode = context.Constants.OpCodes[entry.Key];

                if (context.Options.RenameSymbols)
                {
                    entry.Value.Namespace = "KoiVM.Runtime.OpCodes";
                    entry.Value.Name = opCode.ToString();
                }

                opcodes.Add(entry.Key, new OpCodeInfo(entry.Value, opCode));
            }

            // Map all vcalls.
            foreach (var entry in mapping2)
            {
                if (context.Options.RenameSymbols)
                {
                    var opCode = context.Constants.VMCalls[entry.Key];
                    entry.Value.Namespace = "KoiVM.Runtime.VCalls";
                    entry.Value.Name = opCode.ToString();
                }
            }

            return new OpCodeMapping(opcodes, mapping2);
        }

        
    }
}


================================================
File: src/OldRod.Pipeline/Stages/Recompiling/RecompilerStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.IO;
using AsmResolver.DotNet;
using AsmResolver.PE.DotNet.Cil;
using OldRod.Core.CodeGen;
using OldRod.Core.Ast.Cil;
using OldRod.Core.Recompiler;
using Rivers.Serialization.Dot;

namespace OldRod.Pipeline.Stages.Recompiling
{
    public class RecompilerStage : IStage
    {
        public const string Tag = "Recompiler";
        
        public string Name => "CIL Recompiler stage";

        public void Run(DevirtualisationContext context)
        {
            var flagHelper = VmHelperGenerator.ImportFlagHelper(context.TargetModule, context.Constants);
            foreach (var method in context.VirtualisedMethods)
            {
                try
                {
                    if (method.ILCompilationUnit == null 
                        || method.IsExport && !context.Options.SelectedExports.Contains(method.ExportId.Value))
                    {
                        continue;
                    }

                    RecompileToCilAst(context, method);
                    GenerateCil(context, method, flagHelper);
                }
                catch (Exception e) when (context.Options.EnableSalvageMode)
                {
                    context.Logger.Error(Tag, $"Failed to recompile function_{method.Function.EntrypointAddress:X4}. {e.Message}");
                }
            }
        }

        private static void RecompileToCilAst(DevirtualisationContext context, VirtualisedMethod method)
        {
            context.Logger.Debug(Tag, $"Recompiling function_{method.Function.EntrypointAddress:X4} to CIL AST...");

            var recompiler = new ILToCilRecompiler(method.CallerMethod.CilMethodBody, context.TargetModule, context)
            {
                Logger = context.Logger,
                InferParameterTypes = method.IsMethodSignatureInferred
            };

            // Subscribe to progress events if specified in the options.
            if (context.Options.OutputOptions.DumpAllControlFlowGraphs)
            {
                int step = 1;
                recompiler.InitialAstBuilt +=
                    (sender, args) =>
                    {
                        context.Logger.Debug2(Tag,
                            $"Dumping initial CIL AST of function_{method.Function.EntrypointAddress:X4}...");
                        method.CilCompilationUnit = args;
                        DumpCilAst(context, method, $" (0. Initial)");
                    };
                recompiler.TransformEnd +=
                    (sender, args) =>
                    {
                        context.Logger.Debug2(Tag,
                            $"Dumping tentative CIL AST of function_{method.Function.EntrypointAddress:X4}...");
                        method.CilCompilationUnit = args.Unit;
                        DumpCilAst(context, method, $" ({step++}. {args.Transform.Name})");
                    };
            }

            // Recompile!
            method.CilCompilationUnit = recompiler.Recompile(method.ILCompilationUnit);
            
            // Dump AST if specified in the options.
            if (context.Options.OutputOptions.DumpControlFlowGraphs)
            {
                context.Logger.Log(Tag, $"Dumping CIL AST of function_{method.Function.EntrypointAddress:X4}...");
                DumpCilAst(context, method);
                DumpCilAstTree(context, method);
            }
        }

        private static void DumpCilAst(DevirtualisationContext context, VirtualisedMethod method, string suffix = null)
        {
            using (var fs = File.CreateText(Path.Combine(context.Options.OutputOptions.CilAstDumpsDirectory, $"function_{method.Function.EntrypointAddress:X4}{suffix}.dot")))
            {
                WriteHeader(fs, method);
                var writer = new DotWriter(fs, new BasicBlockSerializer(method.CallerMethod.CilMethodBody));
                writer.Write(method.ControlFlowGraph.ConvertToGraphViz(CilAstBlock.AstBlockProperty));
            }
        }

        private static void DumpCilAstTree(DevirtualisationContext context, VirtualisedMethod method)
        {
            using (var fs = File.CreateText(Path.Combine(context.Options.OutputOptions.CilAstDumpsDirectory,
                $"function_{method.Function.EntrypointAddress:X4}_tree.dot")))
            {
                WriteHeader(fs, method);
                var writer = new DotWriter(fs, new BasicBlockSerializer());
                writer.Write(method.CilCompilationUnit.ConvertToGraphViz());
            }
        }

        private static void GenerateCil(DevirtualisationContext context, VirtualisedMethod method, TypeDefinition flagHelper)
        {
            // Generate final CIL code.
            context.Logger.Debug(Tag, $"Generating CIL for function_{method.Function.EntrypointAddress:X4}...");

            var generator = new CilMethodBodyGenerator(context.Constants, flagHelper)
            {
                EnableStackVerification = !context.Options.EnableSalvageMode,
                EnableExceptionHandlerValidation = !context.Options.EnableSalvageMode
            };
            
            method.CallerMethod.CilMethodBody = generator.Compile(method.CallerMethod, method.CilCompilationUnit);
            if (context.Options.OutputOptions.DumpRecompiledCil)
            {
                context.Logger.Log(Tag, $"Dumping CIL of function_{method.Function.EntrypointAddress:X4}...");
                DumpCil(context, method);
            }
        }

        private static void DumpCil(DevirtualisationContext context, VirtualisedMethod method)
        {
            var methodBody = method.CallerMethod.CilMethodBody;
            var formatter = new CilInstructionFormatter();
            
            using (var fs = File.CreateText(Path.Combine(context.Options.OutputOptions.CilDumpsDirectory, $"function_{method.Function.EntrypointAddress:X4}.il")))
            {
                WriteBasicInfo(fs, method);

                var variables = methodBody.LocalVariables;
                if (variables.Count > 0)
                {
                    fs.WriteLine("// Variables: ");
                    for (int i = 0; i < variables.Count; i++)
                        fs.WriteLine($"//    {i}: {variables[i].VariableType}");
                    fs.WriteLine();
                }

                // Dump EHs.
                if (methodBody.ExceptionHandlers.Count > 0)
                {
                    fs.WriteLine("// Exception handlers:");
                    for (int i = 0; i < methodBody.ExceptionHandlers.Count; i++)
                    {
                        var eh = methodBody.ExceptionHandlers[i];
                        fs.WriteLine(
                            "//    {0, 2}: EHType: {1, -10} TryStart: {2, -10} TryEnd: {3, -10} HandlerStart: {4, -10} HandlerEnd: {5, -10} FilterStart: {6, -10} CatchType: {7}",
                            i.ToString(),
                            eh.HandlerType,
                            eh.TryStart != null ? $"IL_{eh.TryStart.Offset:X4}" : "<null>",
                            eh.TryEnd != null ? $"IL_{eh.TryEnd.Offset:X4}" : "<null>",
                            eh.HandlerStart != null ? $"IL_{eh.HandlerStart.Offset:X4}" : "<null>",
                            eh.HandlerEnd != null ? $"IL_{eh.HandlerEnd.Offset:X4}" : "<null>",
                            eh.FilterStart != null ? $"IL_{eh.FilterStart.Offset:X4}" : "<null>",
                            eh.ExceptionType?.FullName ?? "<null>");
                    }

                    fs.WriteLine();
                }

                // Dump instructions.
                foreach (var instruction in methodBody.Instructions)
                    fs.WriteLine(formatter.FormatInstruction(instruction));
                
            }
        }

        private static void WriteHeader(TextWriter writer, VirtualisedMethod method)
        {   
            WriteBasicInfo(writer, method);

            writer.WriteLine("// Variables: ");
            
            foreach (var variable in method.CilCompilationUnit.Variables)
                writer.WriteLine($"//    {variable.Name}: {variable.VariableType} (assigned {variable.AssignedBy.Count}x, used {variable.UsedBy.Count}x)");
            
            writer.WriteLine();
        }

        private static void WriteBasicInfo(TextWriter writer, VirtualisedMethod method)
        {
            writer.WriteLine("// Export ID: " + (method.ExportId?.ToString() ?? "<none>"));

            var exportInfo = method.ExportInfo;
            if (exportInfo != null)
            {
                writer.WriteLine("// Raw function signature: ");
                writer.WriteLine("//    Flags: 0x{0:X2} (0b{1})",
                    exportInfo.Signature.Flags,
                    Convert.ToString(exportInfo.Signature.Flags, 2).PadLeft(8, '0'));
                writer.WriteLine($"//    Return Type: {exportInfo.Signature.ReturnToken}");
                writer.WriteLine($"//    Parameter Types: " + string.Join(", ", exportInfo.Signature.ParameterTokens));
            }

            writer.WriteLine("// Inferred method signature: " + method.MethodSignature);
            writer.WriteLine("// Physical method: " + method.CallerMethod);
            writer.WriteLine("// Entrypoint Offset: " + method.Function.EntrypointAddress.ToString("X4"));
            writer.WriteLine("// Entrypoint Key: " + method.Function.EntryKey.ToString("X8"));

            writer.WriteLine();
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/VMCodeRecovery/BasicSMCTrampolineDetector.cs
================================================
ï»¿using OldRod.Core.Architecture;
using OldRod.Core.Disassembly;
using OldRod.Core.Disassembly.DataFlow;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Pipeline.Stages.VMCodeRecovery 
{
    public sealed class BasicSMCTrampolineDetector : ISMCTrampolineDetector 
    {
        private readonly InstructionDecoder _instructionDecoder;
        
        public BasicSMCTrampolineDetector(VMConstants constants, KoiStream stream) 
        {
            _instructionDecoder = new InstructionDecoder(constants, stream.CreateReader());
        }
        
        public bool IsSMCTrampoline(ProgramState currentState, out byte smcKey, out ulong smcTrampolineEnd) 
        {
            smcKey = 0;
            smcTrampolineEnd = 0;
            
            // The first instruction of the SMC trampoline block is
            // preceeded by a single byte key used to decrypt it.
            
            // Make sure we can actually read the single byte key byte.
            if (currentState.IP < 1)
                return false;

            _instructionDecoder.ReaderOffset = (uint)(currentState.IP - 1);
            
            // We can't use the regular ReadByte() method as the key byte is not encrypted.
            smcKey = _instructionDecoder.ReadNonEncryptedByte();

            // If the previous byte is a 0, no additional processing is necessary as A xor 0 = A.
            // This check is also present in the code injected as part of the SMC decryption routine.
            if (smcKey == 0)
                return false;
            
            // Set correct decoder state. Setting SMCTrampolineKey causes the
            // deocder to decrypt the bytes it reads using the key read above.
            _instructionDecoder.SMCTrampolineKey = smcKey;
            _instructionDecoder.CurrentKey = currentState.Key;
            
            ulong smcTrampolineStart = _instructionDecoder.ReaderOffset;
            
            // The following code decides whether the current block is an SMC trampoline by
            // attempting to decrypt a couple of instructions using the key byte read before.
            // If trying to read instructions using the SMC key yields in garbage data, we
            // can safely assume that the current block is not an SMC trampoline.
            // The code relies on the assumption that the first non NOP instructions in the
            // SMC trampoline block are part of an XOR operation and that the SMC trampoline
            // ends in an uncoditional jump.
            
            ILInstruction currentInstr;
            // Vanilla KoiVM SMC trampolines start with a double NOP.
            do
            {
                if (!_instructionDecoder.TryReadNextInstruction(out currentInstr))
                    return false;
            }
            while (currentInstr.OpCode.Code == ILCode.NOP);

            // The next instructions are part of a XOR operation, try to match the first two to make sure our key is valid.
            if (currentInstr.OpCode.Code != ILCode.PUSHR_DWORD || (VMRegisters)currentInstr.Operand != VMRegisters.BP)
                return false;

            if (!_instructionDecoder.TryReadNextInstruction(out currentInstr) || currentInstr.OpCode.Code != ILCode.PUSHI_DWORD)
                return false;

            // A SMC trampoline always ends with a JMP instruction, try to decode instructions until we find it.
            // Second condition of the loop is here to prevent reading too much. The SMC trampoline block is 170 bytes
            // long in Vanilla KoiVM. We use a maximum of 200 to account for modified KoiVM versions which might add,
            // for example, extra NOPs.
            while (_instructionDecoder.TryReadNextInstruction(out currentInstr) && _instructionDecoder.ReaderOffset - smcTrampolineStart <= 200)
            {
                if (currentInstr.OpCode.Code != ILCode.JMP)
                    continue;
                smcTrampolineEnd = _instructionDecoder.ReaderOffset;
                break;
            }

            // If the loop above exited without finding a JMP instruction, smcTrampolineEnd will be 0.
            return smcTrampolineEnd != 0;
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/VMCodeRecovery/ExportsAwareFunctionFactory.cs
================================================
using System;
using System.Linq;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Pipeline.Stages.VMCodeRecovery
{
    public class ExportsAwareFunctionFactory : IVMFunctionFactory
    {
        private readonly DevirtualisationContext _context;

        public ExportsAwareFunctionFactory(DevirtualisationContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }
     
        public VMFunction CreateFunction(uint entryAddress, uint entryKey)
        {
            return _context.VirtualisedMethods
                       .FirstOrDefault(m => m.Function.EntrypointAddress == entryAddress)
                       ?.Function
                   ?? new VMFunction(entryAddress, entryKey);
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/VMCodeRecovery/SimpleExitKeyBruteForce.cs
================================================
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using AsmResolver;
using OldRod.Core;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Pipeline.Stages.VMCodeRecovery
{
    public class SimpleExitKeyBruteForce : IExitKeyResolver
    {
        public const string Tag = "ExitKeyBruteForce";
        public string Name => "Simple exit key brute-force";

        public uint? ResolveExitKey(ILogger logger, KoiStream koiStream, VMConstants constants, VMFunction function)
        {
            // Strategy:
            //
            // Find CALL references to the function, and try every possible key in the key space that 
            // decrypts the next instruction to either a PUSHR_xxxx R0 or a PUSHR_DWORD SP, as they
            // appear in the post-call to either store the return value, or adjust SP to clean up
            // the stack.
            
            // Since the actual decryption of the opcode only uses the 8 least significant bits, we can 
            // make an optimisation that shaves off around 8 bits of the key space. By attempting to 
            // decrypt the first byte using just the first 8 bits, and verifying whether this output
            // results to one of the instructions mentioned in the above, we can quickly rule out many
            // potential keys.
            
            var callReferences = function.References
                .Where(r => r.ReferenceType == FunctionReferenceType.Call)
                .ToArray();
            
            if (callReferences.Length == 0)
            {
                logger.Warning(Tag, $"Cannot brute-force the exit key of function_{function.EntrypointAddress:X4} as it has no recorded call references.");
                return null;
            }

            var reader = koiStream.Contents.CreateReader();
            
            byte[] encryptedOpCodes = new byte[3];
            var watch = new Stopwatch();
            
            // Find any call reference.
            for (int i = 0; i < callReferences.Length; i++)
            {
                var callReference = callReferences[i];
                logger.Debug(Tag, $"Started bruteforcing key for call reference {i.ToString()} ({callReference.ToString()}).");
                watch.Restart();

                var call = callReference.Caller.Instructions[callReference.Offset];
                long targetOffset = call.Offset + call.Size;

                reader.Offset = (uint) targetOffset;
                reader.ReadBytes(encryptedOpCodes, 0, encryptedOpCodes.Length);

                // Go over all possible LSBs.
                for (uint lsb = 0; lsb < byte.MaxValue; lsb++)
                {
                    // Check whether the LSB decodes to a PUSHR_xxxx.
                    if (IsPotentialLSB(constants, encryptedOpCodes[0], lsb))
                    {
                        // Go over all remaining 24 bits.
                        for (uint j = 0; j < 0x00FFFFFF; j++)
                        {
                            uint currentKey = (j << 8) | lsb;

                            // Try new key.
                            if (IsValidKey(constants, encryptedOpCodes, currentKey))
                            {
                                // We have found a key!
                                watch.Stop();
                                logger.Debug(Tag, $"Found key after {watch.Elapsed.TotalSeconds:0.00}s.");

                                return currentKey;
                            }
                        } // for all other 24 bits.
                    } // if potential LSB
                } // foreach LSB

                watch.Stop();
                logger.Debug(Tag, $"Exhausted key space after {watch.Elapsed.TotalSeconds:0.00}s without finding key.");
            }

            return null;
        }

        private static bool IsPotentialLSB(VMConstants constants, byte encryptedOpCode, uint lsb)
        {
            byte pushRDword = DecryptByte(encryptedOpCode, ref lsb, constants.KeyScalar);
            if (!constants.OpCodes.TryGetValue(pushRDword, out var opCode))
                return false;
            
            switch (opCode)
            {
                case ILCode.PUSHR_BYTE:
                case ILCode.PUSHR_WORD:
                case ILCode.PUSHR_DWORD:
                case ILCode.PUSHR_QWORD:
                case ILCode.PUSHR_OBJECT:
                    return true;
                
                default:
                    return false;
            }
        }

        private static bool IsValidKey(VMConstants constants, byte[] data, uint key)
        {
            // Opcode byte.
            byte pushRDword = DecryptByte(data[0], ref key, constants.KeyScalar);
            if (!constants.OpCodes.TryGetValue(pushRDword, out var opCode))
                return false;

            switch (opCode)
            {
                case ILCode.PUSHR_BYTE:
                case ILCode.PUSHR_WORD:
                case ILCode.PUSHR_DWORD:
                case ILCode.PUSHR_QWORD:
                case ILCode.PUSHR_OBJECT:
                    break;
                default:
                    return false;
            }

            // Fixup byte.
            byte fixup = DecryptByte(data[1], ref key, constants.KeyScalar);

            // Register operand.
            byte rawRegister = DecryptByte(data[2], ref key, constants.KeyScalar);
            if (!constants.Registers.TryGetValue(rawRegister, out var register))
                return false;
            
            switch (register)
            {
                case VMRegisters.R0:
                case VMRegisters.SP:
                    return true;
            }

            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static byte DecryptByte(byte encryptedByte, ref uint key, uint keyScalar)
        {
            byte b = (byte) (encryptedByte ^ key);
            key = key * keyScalar + b;
            return b;
        }
        
    }
}


================================================
File: src/OldRod.Pipeline/Stages/VMCodeRecovery/VMCodeRecoveryStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using OldRod.Core.Disassembly.ControlFlow;
using OldRod.Core.Disassembly.Inference;
using Rivers.Serialization.Dot;

namespace OldRod.Pipeline.Stages.VMCodeRecovery
{
    public class VMCodeRecoveryStage : IStage
    {
        public const string Tag = "VMCodeRecovery";

        public string Name => "VM code recovery stage";

        public void Run(DevirtualisationContext context)
        {
            var disassembler = new InferenceDisassembler(context.Constants, context.KoiStream)
            {
                Logger = context.Logger,
                FunctionFactory = new ExportsAwareFunctionFactory(context),
                SalvageCfgOnError = context.Options.EnableSalvageMode,
                ExitKeyResolver = new SimpleExitKeyBruteForce(),
                ResolveUnknownExitKeys = true,
                SMCTrampolineDetector = new BasicSMCTrampolineDetector(context.Constants, context.KoiStream)
            };

            // Register functions entry points.
            foreach (var method in context.VirtualisedMethods)
            {
                if (!method.ExportInfo.IsSignatureOnly
                    && (!method.IsExport || context.Options.SelectedExports.Contains(method.ExportId.Value)))
                {
                    disassembler.AddFunction(method.Function);
                }
            }

            // Listen for new explored functions.
            var newFunctions = new Dictionary<uint, VMFunction>();
            disassembler.FunctionInferred += (sender, args) =>
            {
                var method = context.ResolveMethod(args.Function.EntrypointAddress);
                if (method == null)
                    newFunctions.Add(args.Function.EntrypointAddress, args.Function);
            };

            // Disassemble!
            var controlFlowGraphs = disassembler.DisassembleFunctions();
                
            foreach (var entry in controlFlowGraphs)
            {
                VirtualisedMethod method;
                if (newFunctions.ContainsKey(entry.Key))
                {
                    context.Logger.Debug(Tag, $"Creating method for function_{entry.Key:X4}.");
                    method = new VirtualisedMethod(newFunctions[entry.Key]);
                    context.VirtualisedMethods.Add(method);
                }
                else
                {
                    method = context.VirtualisedMethods.First(x => x.Function.EntrypointAddress == entry.Key);
                }

                method.ControlFlowGraph = entry.Value;
                
                if (context.Options.OutputOptions.DumpDisassembledIL)
                {
                    context.Logger.Log(Tag, $"Dumping IL of function_{entry.Key:X4}...");
                    DumpDisassembledIL(context, method);
                }

                if (context.Options.OutputOptions.DumpControlFlowGraphs)
                {
                    context.Logger.Log(Tag, $"Dumping CFG of function_{entry.Key:X4}...");
                    DumpControlFlowGraph(context, method);
                }
            }
        }

        private static void DumpDisassembledIL(DevirtualisationContext context, VirtualisedMethod method)
        {
            using (var fs = File.CreateText(Path.Combine(
                context.Options.OutputOptions.ILDumpsDirectory, 
                $"function_{method.Function.EntrypointAddress:X4}.koi")))
            {
                // Write basic information about export:
                fs.WriteLine("; Export ID: " + (method.ExportId?.ToString() ?? "<none>"));

                var exportInfo = method.ExportInfo;
                if (exportInfo != null)
                {
                    fs.WriteLine("; Raw function signature: ");
                    fs.WriteLine(";    Flags: 0x{0:X2} (0b{1})",
                        exportInfo.Signature.Flags,
                        Convert.ToString(exportInfo.Signature.Flags, 2).PadLeft(8, '0'));
                    fs.WriteLine($";    Return Type: {exportInfo.Signature.ReturnToken}");
                    fs.WriteLine($";    Parameter Types: " + string.Join(", ", exportInfo.Signature.ParameterTokens));
                }

                fs.WriteLine("; Inferred method signature: " + method.MethodSignature);
                fs.WriteLine("; Physical method: " + method.CallerMethod);
                fs.WriteLine("; Entrypoint Offset: " + method.Function.EntrypointAddress.ToString("X4"));
                fs.WriteLine("; Entrypoint Key: " + method.Function.EntryKey.ToString("X8"));
                
                fs.WriteLine();

                // Write contents of nodes.
                int instructionLength = -1;
                int annotationLength = -1;
                int stackLength = -1;
                int registersLength = -1;
                
                foreach (var node in method.ControlFlowGraph.Nodes)
                {
                    node.UserData.TryGetValue(ILBasicBlock.BasicBlockProperty, out var b);
                    if (b != null)
                    {
                        var block = (ILBasicBlock) b;
                        foreach (var instruction in block.Instructions)
                        {
                            instructionLength = Math.Max(instruction.ToString().Length, instructionLength);
                            annotationLength = Math.Max(instruction.Annotation?.ToString().Length ?? 0, annotationLength);
                            stackLength = Math.Max(instruction.ProgramState.Stack.ToString().Length, stackLength);
                            registersLength = Math.Max(instruction.ProgramState.Registers.ToString().Length, registersLength);
                        }
                    }
                }

                const int separatorLength = 3;
                instructionLength += separatorLength;
                annotationLength += separatorLength;
                stackLength += separatorLength;
                registersLength += separatorLength;
                
                fs.Write("; Instruction".PadRight(instructionLength));
                fs.Write("   ");
                fs.Write("Annotation".PadRight(annotationLength));
                fs.Write(" ");
                fs.Write("Stack".PadRight(stackLength));
                fs.Write(" ");
                fs.Write("Registers".PadRight(registersLength));
                fs.WriteLine(" EH stack");

                foreach (var node in method.ControlFlowGraph.Nodes.OrderBy(x => x.Name))
                {
                    node.UserData.TryGetValue(ILBasicBlock.BasicBlockProperty, out var b);
                    if (b == null)
                    {
                        fs.WriteLine("; <<< unknown >>> ");
                        fs.WriteLine();
                    }
                    else
                    {
                        var block = (ILBasicBlock) b;
                        foreach (var instruction in block.Instructions)
                        {
                            fs.Write(instruction.ToString().PadRight(instructionLength));
                            fs.Write(" ; ");
                            fs.Write((instruction.Annotation?.ToString() ?? string.Empty).PadRight(annotationLength));
                            fs.Write(" ");
                            fs.Write(instruction.ProgramState.Stack.ToString().PadRight(stackLength));
                            fs.Write(" ");
                            fs.Write(instruction.ProgramState.Registers.ToString().PadRight(registersLength));
                            fs.Write(" ");
                            fs.WriteLine("{" + string.Join(", ", instruction.ProgramState.EHStack) + "}");
                        }

                        fs.WriteLine();
                    }
                }
            }
        }

        private static void DumpControlFlowGraph(DevirtualisationContext context, VirtualisedMethod method)
        {
            using (var fs = File.CreateText(Path.Combine(
                    context.Options.OutputOptions.ILDumpsDirectory, 
                    $"function_{method.Function.EntrypointAddress:X4}.dot")))
            {
                var writer = new DotWriter(fs, new BasicBlockSerializer());
                writer.Write(method.ControlFlowGraph.ConvertToGraphViz(ILBasicBlock.BasicBlockProperty));
            }
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/VMMethodDetection/VMEntryInfo.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using AsmResolver.DotNet;

namespace OldRod.Pipeline.Stages.VMMethodDetection
{
    public class VMEntryInfo
    {
        public TypeDefinition VMEntryType
        {
            get;
            set;
        }
        
        public MethodDefinition RunMethod1
        {
            get;
            set;
        }
        
        public MethodDefinition RunMethod2
        {
            get;
            set;
        }
    }
}


================================================
File: src/OldRod.Pipeline/Stages/VMMethodDetection/VMMethodDetectionStage.cs
================================================
// Project OldRod - A KoiVM devirtualisation utility.
// Copyright (C) 2019 Washi
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

using System.Collections.Generic;
using System.Linq;
using AsmResolver.DotNet;
using AsmResolver.DotNet.Code.Cil;
using AsmResolver.DotNet.Signatures;
using AsmResolver.PE.DotNet.Cil;
using AsmResolver.PE.DotNet.Metadata.Tables;
using OldRod.Core.Architecture;
using OldRod.Core.Disassembly.Inference;

namespace OldRod.Pipeline.Stages.VMMethodDetection
{
    public class VMMethodDetectionStage : IStage
    {
        private static readonly SignatureComparer Comparer = new SignatureComparer(SignatureComparisonFlags.VersionAgnostic);

        public const string Tag = "VMMethodDetection";
        
        public string Name => "Virtualised method detection stage";

        public void Run(DevirtualisationContext context)
        {
            // KoiVM defines a type VMEntry to bootstrap the virtual machine for a particular method.
            // Therefore, to detect virtualised methods, we therefore have to detect this type first so that we can 
            // look for references to one of the Run methods.

            if (!context.Options.NoExportMapping)
                context.VMEntryInfo = ExtractVMEntryInfo(context);
            
            ConvertFunctionSignatures(context);
            
            if (context.Options.NoExportMapping)
            {
                context.Logger.Debug(Tag, "Not mapping methods to physical methods.");
            }
            else
            {
                context.Logger.Debug(Tag, "Mapping methods to physical methods...");
                MapVMExportsToMethods(context);
            }

            if (context.Options.RenameSymbols)
            {
                context.VMEntryInfo.VMEntryType.Namespace = "KoiVM.Runtime";
                context.VMEntryInfo.VMEntryType.Name = "VMEntry";
                context.VMEntryInfo.RunMethod1.Name = "Run";
                context.VMEntryInfo.RunMethod2.Name = "Run";
            }
        }

        private VMEntryInfo ExtractVMEntryInfo(DevirtualisationContext context)
        {
            if (context.Options.OverrideVMEntryToken)
            {
                // Use user-defined VMEntry type token instead of detecting.
                
                context.Logger.Debug(Tag, $"Using token {context.Options.VMEntryToken} for VMEntry type.");
                var type = (TypeDefinition) context.RuntimeModule.LookupMember(context.Options.VMEntryToken.Value);
                var info = TryExtractVMEntryInfoFromType(context, type);
                if (info == null)
                {
                    throw new DevirtualisationException(
                        $"Type {type.MetadataToken} ({type}) does not match the signature of the VMEntry type.");
                }

                return info;
            }
            else
            {
                // Attempt to auto-detect the VMEntry type.
                
                context.Logger.Debug(Tag, "Searching for VMEntry type...");
                var info = SearchVMEntryType(context);
                
                if (info == null)
                    throw new DevirtualisationException("Could not detect VMEntry type.");
                
                context.Logger.Debug(Tag, $"Detected VMEntry type ({info.VMEntryType.MetadataToken})");
                return info;
            }
        }

        private VMEntryInfo SearchVMEntryType(DevirtualisationContext context)
        {
            foreach (var type in context.RuntimeModule.Assembly.Modules[0].TopLevelTypes)
            {
                // TODO: maybe a better matching criteria is required here.
                if (type.Methods.Count >= 5) 
                {
                    var info = TryExtractVMEntryInfoFromType(context, type);
                    if (info != null)
                        return info;
                }
            }

            return null;
        }

        private static bool HasParameterTypes(MethodDefinition method, ICollection<string> expectedTypes)
        {
            expectedTypes = new List<string>(expectedTypes);

            foreach (var parameter in method.Signature.ParameterTypes)
            {
                string typeFullName = parameter.FullName;
                
                if (!expectedTypes.Contains(typeFullName))
                    return false;
                
                expectedTypes.Remove(typeFullName);
            }

            return true;
        }

        private VMEntryInfo TryExtractVMEntryInfoFromType(DevirtualisationContext context, TypeDefinition type)
        {
            var info = new VMEntryInfo
            {
                VMEntryType = type
            };

            foreach (var method in type.Methods)
            {
                int count = method.Signature.ParameterTypes.Count;
                if (count == context.Options.Run1ExpectedTypes.Count)
                {
                    if (HasParameterTypes(method, context.Options.Run1ExpectedTypes))
                        info.RunMethod1 = method;
                }
                else if (count == context.Options.Run2ExpectedTypes.Count)
                {
                    if (HasParameterTypes(method, context.Options.Run2ExpectedTypes))
                        info.RunMethod2 = method;
                }
            }

            if (info.RunMethod1 == null || info.RunMethod2 == null)
                return null;
            
            return info;
        }

        private void ConvertFunctionSignatures(DevirtualisationContext context)
        {
            foreach (var entry in context.KoiStream.Exports.Where(x => !x.Value.IsSignatureOnly))
            {
                context.Logger.Debug(Tag, $"Converting VM signature of export {entry.Key} to method signature...");
                context.VirtualisedMethods.Add(
                    new VirtualisedMethod(new VMFunction(entry.Value.EntrypointAddress, entry.Value.EntryKey), entry.Key,
                        entry.Value)
                    {
                        MethodSignature = VMSignatureToMethodSignature(context, entry.Value.Signature)
                    });
            }
        }

        private void MapVMExportsToMethods(DevirtualisationContext context)
        {
            int matchedMethods = 0;
            
            // Go over all methods in the assembly and detect whether it is virtualised by looking for a call 
            // to the VMEntry.Run method. If it is, also detect the export ID associated to it to define a mapping
            // between VMExport and physical method. 
            foreach (var type in context.TargetModule.Assembly.Modules[0].GetAllTypes())
            {
                foreach (var method in type.Methods)
                {
                    if (!context.Options.SelectedMethods.Contains(method.MetadataToken.Rid))
                        continue;
                    
                    var matchingVmMethods = GetMatchingVirtualisedMethods(context, method);

                    if (matchingVmMethods.Count > 0
                        && method.CilMethodBody != null
                        && TryExtractExportTypeFromMethodBody(context, method.CilMethodBody, out int exportId))
                    {
                        context.Logger.Debug(Tag, $"Detected call to export {exportId} in {method}.");
                        var vmMethod = matchingVmMethods.FirstOrDefault(x => x.ExportId == exportId);
                        if (vmMethod != null)
                            vmMethod.CallerMethod = method;
                        else
                            context.Logger.Debug(Tag, $"Ignoring call to export {exportId} in {method}.");
                        matchedMethods++;
                    }
                }
            }
                
            // There could be more exports defined in the #Koi md stream than we were able to directly match
            // with methods in the target assembly. It is expected that the HELPER_INIT method is not matched to a
            // physical method definition, but it could also be that we missed one due to some other form of
            // obfuscation applied to it (maybe a fork of the vanilla version). 
            
            // These missing physical methods will later be added, together with the internal functions.
            
            // Warn if there are more than one method not directly mapped to a physical method definition.
            if (matchedMethods < context.VirtualisedMethods.Count - 1)
            {
                context.Logger.Warning(Tag, $"Not all VM exports were mapped to physical method definitions "
                                            + $"({matchedMethods} out of {context.VirtualisedMethods.Count} were mapped). "
                                            + "Dummies will be added to the assembly for the remaining exports.");
            }
        }

        private bool TryExtractExportTypeFromMethodBody(DevirtualisationContext context, CilMethodBody methodBody, out int exportId)
        {
            exportId = 0;

            var instructions = methodBody.Instructions;
            var runCall = instructions.FirstOrDefault(x =>
                x.OpCode.Code == CilCode.Call
                && x.Operand is IMethodDefOrRef methodOperand
                && (Comparer.Equals(context.VMEntryInfo.RunMethod1, methodOperand)
                    || Comparer.Equals(context.VMEntryInfo.RunMethod2, methodOperand)
                ));
            
            if (runCall != null)
            {   
                // Do a very minimal emulation of the method body, we are only interested in ldc.i4 values that push
                // the export ID. All other values on the stack will have a placeholder of -1.
                
                // Note that this strategy only works for variants of KoiVM that have exactly one constant integer
                // pushed on the stack upon calling the run method. It does NOT detect the export ID when the constant
                // is masked behind some obfuscation, or when there are multiple integer parameters pushed on the stack. 
                
                var stack = new Stack<int>();
                foreach (var instr in instructions)
                {
                    if (instr.Offset == runCall.Offset)
                    {
                        // We reached the call to the run method, obtain the integer value corresponding to the export id.
                        
                        int argCount = instr.GetStackPopCount(methodBody);
                        for (int i = 0; i < argCount; i++)
                        {
                            int value = stack.Pop();
                            if (value != -1)
                            {
                                exportId = value;
                                return true;
                            }
                        }
                        
                        return false;
                    }

                    if (instr.IsLdcI4())
                    {
                        // Push the ldc.i4 value if we reach one.
                        stack.Push(instr.GetLdcI4Constant());
                    }
                    else
                    {
                        // Pop the correct amount of values from the stack, and push placeholders.
                        for (int i = 0; i < instr.GetStackPopCount(methodBody); i++)
                            stack.Pop();
                        for (int i = 0; i < instr.GetStackPushCount(); i++)
                            stack.Push(-1);
                    }
                }
            }

            return false;
        }

        private ICollection<VirtualisedMethod> GetMatchingVirtualisedMethods(
            DevirtualisationContext context,
            MethodDefinition methodToMatch)
        {
            var matches = new List<VirtualisedMethod>();
            
            foreach (var vmMethod in context.VirtualisedMethods.Where(x => x.CallerMethod == null))
            {
                if (Comparer.Equals(methodToMatch.Signature, vmMethod.MethodSignature))
                    matches.Add(vmMethod);
            }

            return matches;
        }

        private MethodSignature VMSignatureToMethodSignature(DevirtualisationContext context, VMFunctionSignature signature)
        {
            var module = context.TargetModule;
            
            var returnType = ((ITypeDescriptor) module.LookupMember(signature.ReturnToken)).ToTypeSignature();
            var parameterTypes = signature.ParameterTokens
                .Select(x => ((ITypeDescriptor) module.LookupMember(x)).ToTypeSignature());

            var hasThis = (signature.Flags & context.Constants.FlagInstance) != 0;

            return new MethodSignature(
                hasThis ? CallingConventionAttributes.HasThis : 0,
                returnType,
                parameterTypes.Skip(hasThis ? 1 : 0));
        }
        

    }
}


================================================
File: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help improve the project
title: ''
labels: bug
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior (preferably including a download link to a sample binary).

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Additional context**
Add any other context about the problem here.



================================================
File: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: enhancement
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



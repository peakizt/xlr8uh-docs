Directory structure:
└── sunnamed434-bitmono/
    ├── README.md
    ├── BitMono.sln
    ├── BitMono.sln.DotSettings
    ├── CHANGELOG.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── LICENSE
    ├── build.md
    ├── troubleshooting.md
    ├── .editorconfig
    ├── .readthedocs.yaml
    ├── docs/
    │   ├── Dockerfile
    │   ├── Makefile
    │   ├── README.txt
    │   ├── docker-compose.yml
    │   ├── make.bat
    │   ├── requirements.txt
    │   ├── .env
    │   ├── .gitignore
    │   └── source/
    │       ├── conf.py
    │       ├── index.rst
    │       ├── bestpractices/
    │       │   ├── bitmono-combo.rst
    │       │   └── zero-risk-obfuscation.rst
    │       ├── configuration/
    │       │   ├── exclude-obfuscation.rst
    │       │   ├── protections.rst
    │       │   └── third-party-issues.rst
    │       ├── developers/
    │       │   ├── configuration.rst
    │       │   ├── do-not-resolve-members.rst
    │       │   ├── first-protection.rst
    │       │   ├── native-code.rst
    │       │   ├── obfuscate-build.rst
    │       │   ├── obfuscation-execution-order.rst
    │       │   ├── protection-runtime-moniker.rst
    │       │   └── which-base-protection-select.rst
    │       ├── faq/
    │       │   ├── costura-support.rst
    │       │   ├── disable-path-masking.rst
    │       │   ├── unable-to-reference-after-protect.rst
    │       │   └── when-and-why-use-bitmono.rst
    │       ├── obfuscationissues/
    │       │   ├── compatibility.rst
    │       │   ├── corlib-not-found.rst
    │       │   ├── intended-for.rst
    │       │   └── ready-to-run.rst
    │       ├── protection-list/
    │       │   ├── overview.rst
    │       │   └── unity.rst
    │       └── protections/
    │           ├── antide4dot.rst
    │           ├── antidebugbreakpoints.rst
    │           ├── antidecompiler.rst
    │           ├── antiildasm.rst
    │           ├── billionnops.rst
    │           ├── bitdecompiler.rst
    │           ├── bitdotnet.rst
    │           ├── bitmethoddotnet.rst
    │           ├── bitmono.rst
    │           ├── bittimedatestamp.rst
    │           ├── calltocalli.rst
    │           ├── dotnethook.rst
    │           ├── fullrenamer.rst
    │           ├── nonamespaces.rst
    │           ├── objectreturntype.rst
    │           ├── stringsencryption.rst
    │           └── unmanagedstring.rst
    ├── lib/
    │   ├── Echo.ControlFlow.deps.json
    │   ├── Echo.ControlFlow.xml
    │   ├── Echo.DataFlow.xml
    │   ├── Echo.Platforms.AsmResolver.deps.json
    │   ├── Echo.Platforms.AsmResolver.xml
    │   ├── Echo.deps.json
    │   └── Echo.xml
    ├── props/
    │   ├── SharedPackages.props
    │   ├── SharedProjectProps.props
    │   └── SharedTestProps.props
    ├── resources/
    │   ├── images/
    │   │   └── preview/
    │   └── logo/
    ├── src/
    │   ├── BitMono.API/
    │   │   ├── BitMono.API.csproj
    │   │   ├── FodyWeavers.xml
    │   │   ├── GlobalUsings.cs
    │   │   ├── Analyzing/
    │   │   │   └── ICriticalAnalyzer.cs
    │   │   ├── Configuration/
    │   │   │   ├── IBitMonoCriticalsConfiguration.cs
    │   │   │   ├── IBitMonoObfuscationConfiguration.cs
    │   │   │   ├── IBitMonoProtectionsConfiguration.cs
    │   │   │   ├── IConfigurationAccessor.cs
    │   │   │   └── JsonConfigurationAccessor.cs
    │   │   ├── Protections/
    │   │   │   ├── IPacker.cs
    │   │   │   ├── IPhaseProtection.cs
    │   │   │   ├── IPipelineProtection.cs
    │   │   │   ├── IProtection.cs
    │   │   │   └── ProtectionParameters.cs
    │   │   └── Resolvers/
    │   │       ├── CustomAttributeResolve.cs
    │   │       ├── IAttributeResolver.cs
    │   │       └── IMemberResolver.cs
    │   ├── BitMono.CLI/
    │   │   ├── BitMono.CLI.csproj
    │   │   ├── FodyWeavers.xml
    │   │   ├── GlobalUsings.cs
    │   │   ├── KnownReturnStatuses.cs
    │   │   ├── Program.cs
    │   │   └── Modules/
    │   │       ├── LoggerConfiguratorExtensions.cs
    │   │       ├── ObfuscationNeeds.cs
    │   │       ├── ObfuscationNeedsFactory.cs
    │   │       ├── Options.cs
    │   │       ├── OptionsObfuscationNeedsFactory.cs
    │   │       └── ReadlineObfuscationNeedsFactory.cs
    │   ├── BitMono.Core/
    │   │   ├── BitMono.Core.csproj
    │   │   ├── FodyWeavers.xml
    │   │   ├── GlobalUsings.cs
    │   │   ├── PackerProtection.cs
    │   │   ├── PhaseProtection.cs
    │   │   ├── PipelineProtection.cs
    │   │   ├── Protection.cs
    │   │   ├── ProtectionBase.cs
    │   │   ├── Analyzing/
    │   │   │   ├── CriticalBaseTypesCriticalAnalyzer.cs
    │   │   │   ├── CriticalInterfacesCriticalAnalyzer.cs
    │   │   │   ├── CriticalMethodsCriticalAnalyzer.cs
    │   │   │   ├── CriticalMethodsStartsWithAnalyzer.cs
    │   │   │   ├── ModelAttributeCriticalAnalyzer.cs
    │   │   │   ├── NameCriticalAnalyzer.cs
    │   │   │   ├── ReflectionCriticalAnalyzer.cs
    │   │   │   ├── RuntimeCriticalAnalyzer.cs
    │   │   │   ├── SerializableBitCriticalAnalyzer.cs
    │   │   │   └── SpecificNamespaceCriticalAnalyzer.cs
    │   │   ├── Attributes/
    │   │   │   ├── ConfigureForNativeCodeAttribute.cs
    │   │   │   ├── DoNotResolveAttribute.cs
    │   │   │   ├── KnownRuntimeMonikers.cs
    │   │   │   ├── MemberInclusionFlags.cs
    │   │   │   ├── ProtectionDescriptionAttribute.cs
    │   │   │   ├── ProtectionNameAttribute.cs
    │   │   │   ├── RuntimeMonikerAttribute.cs
    │   │   │   ├── RuntimeMonikerMonoAttribute.cs
    │   │   │   ├── RuntimeMonikerNETCore.cs
    │   │   │   └── RuntimeMonikerNETFramework.cs
    │   │   ├── Configuration/
    │   │   │   ├── JsonConfigurationExtensions.cs
    │   │   │   ├── JsonConfigurationProviderEx.cs
    │   │   │   └── JsonConfigurationSourceEx.cs
    │   │   ├── Contexts/
    │   │   │   ├── BitMonoContext.cs
    │   │   │   ├── ProtectionContext.cs
    │   │   │   └── StarterContext.cs
    │   │   ├── Extensions/
    │   │   │   ├── KeyValuePairsExtensions.cs
    │   │   │   └── ProtectionExtensions.cs
    │   │   ├── Factories/
    │   │   │   ├── ProtectionContextFactory.cs
    │   │   │   └── ProtectionParametersFactory.cs
    │   │   ├── Injection/
    │   │   │   ├── CustomInjector.cs
    │   │   │   ├── ModifyFlags.cs
    │   │   │   ├── ModifyInjectTypeClonerListener.cs
    │   │   │   └── MscrolibInjector.cs
    │   │   ├── Pipeline/
    │   │   │   └── InvokablePipeline.cs
    │   │   ├── Renaming/
    │   │   │   └── Renamer.cs
    │   │   ├── Resolvers/
    │   │   │   ├── AssemblyResolve.cs
    │   │   │   ├── AssemblyResolver.cs
    │   │   │   ├── AttemptAttributeResolver.cs
    │   │   │   ├── AttributeResolver.cs
    │   │   │   ├── CriticalAttributeResolver.cs
    │   │   │   ├── CustomAttributeResolver.cs
    │   │   │   ├── DoNotResolveMemberResolver.cs
    │   │   │   ├── MembersResolver.cs
    │   │   │   ├── NoInliningMethodMemberResolver.cs
    │   │   │   ├── ObfuscateAssemblyAttributeData.cs
    │   │   │   ├── ObfuscateAssemblyAttributeResolver.cs
    │   │   │   ├── ObfuscationAttributeData.cs
    │   │   │   ├── ObfuscationAttributeResolver.cs
    │   │   │   ├── ProtectionsResolve.cs
    │   │   │   ├── ProtectionsResolver.cs
    │   │   │   └── SafeToMakeChangesMemberResolver.cs
    │   │   └── Services/
    │   │       ├── EngineContextAccessor.cs
    │   │       ├── IEngineContextAccessor.cs
    │   │       ├── RandomNext.cs
    │   │       └── RandomService.cs
    │   ├── BitMono.GlobalTool/
    │   │   ├── BitMono.GlobalTool.csproj
    │   │   ├── FodyWeavers.xml
    │   │   ├── GlobalUsings.cs
    │   │   ├── Program.cs
    │   │   └── .config/
    │   │       └── dotnet-tools.json
    │   ├── BitMono.Host/
    │   │   ├── BitMono.Host.csproj
    │   │   ├── BitMonoApplication.cs
    │   │   ├── FodyWeavers.xml
    │   │   ├── GlobalUsings.cs
    │   │   ├── criticals.json
    │   │   ├── logging.json
    │   │   ├── obfuscation.json
    │   │   ├── protections.json
    │   │   ├── Configurations/
    │   │   │   ├── BitMonoCriticalsConfiguration.cs
    │   │   │   ├── BitMonoObfuscationConfiguration.cs
    │   │   │   └── BitMonoProtectionsConfiguration.cs
    │   │   ├── Extensions/
    │   │   │   ├── AutofacContainerBuilderExtensions.cs
    │   │   │   ├── IPathWrapper.cs
    │   │   │   ├── PathMaskingOperator.cs
    │   │   │   └── PathWrapper.cs
    │   │   ├── Ioc/
    │   │   │   └── IApplication.cs
    │   │   └── Modules/
    │   │       └── BitMonoModule.cs
    │   ├── BitMono.Obfuscation/
    │   │   ├── BitMono.Obfuscation.csproj
    │   │   ├── BitMonoObfuscator.cs
    │   │   ├── GlobalUsings.cs
    │   │   ├── Files/
    │   │   │   ├── CompleteFileInfo.cs
    │   │   │   ├── FileDataWriter.cs
    │   │   │   ├── FinalFileInfo.cs
    │   │   │   ├── IDataWriter.cs
    │   │   │   ├── IncompleteFileInfo.cs
    │   │   │   └── OutputFilePathFactory.cs
    │   │   ├── Logging/
    │   │   │   └── LogErrorListener.cs
    │   │   ├── Modules/
    │   │   │   ├── IModuleFactory.cs
    │   │   │   ├── ModuleFactory.cs
    │   │   │   └── ModuleFactoryResult.cs
    │   │   ├── Notifiers/
    │   │   │   ├── ObfuscationAttributesStripNotifier.cs
    │   │   │   ├── ProtectionExecutionNotifier.cs
    │   │   │   ├── ProtectionsConfigureForNativeCodeNotifier.cs
    │   │   │   ├── ProtectionsNotifier.cs
    │   │   │   └── ProtectionsRuntimeMonikerNotifier.cs
    │   │   ├── Protections/
    │   │   │   ├── ProtectionsSort.cs
    │   │   │   └── ProtectionsSorter.cs
    │   │   ├── Referencing/
    │   │   │   ├── AutomaticPathReferencesDataResolver.cs
    │   │   │   ├── AutomaticReferencesDataResolver.cs
    │   │   │   ├── CosturaReferencesDataResolver.cs
    │   │   │   ├── IReferencesDataResolver.cs
    │   │   │   └── ReferencesDataResolver.cs
    │   │   ├── Starter/
    │   │   │   ├── BitMonoContextFactory.cs
    │   │   │   ├── BitMonoStarter.cs
    │   │   │   └── StarterContextFactory.cs
    │   │   └── Stripping/
    │   │       ├── ObfuscationAttributesStrip.cs
    │   │       └── ObfuscationAttributesStripper.cs
    │   ├── BitMono.Protections/
    │   │   ├── AntiDe4dot.cs
    │   │   ├── AntiDebugBreakpoints.cs
    │   │   ├── AntiDecompiler.cs
    │   │   ├── AntiILdasm.cs
    │   │   ├── BillionNops.cs
    │   │   ├── BitDecompiler.cs
    │   │   ├── BitDotNet.cs
    │   │   ├── BitMethodDotnet.cs
    │   │   ├── BitMono.Protections.csproj
    │   │   ├── BitMono.cs
    │   │   ├── BitTimeDateStamp.cs
    │   │   ├── CallToCalli.cs
    │   │   ├── DotNetHook.cs
    │   │   ├── FodyWeavers.xml
    │   │   ├── FullRenamer.cs
    │   │   ├── GlobalUsings.cs
    │   │   ├── NoNamespaces.cs
    │   │   ├── ObjectReturnType.cs
    │   │   ├── StringsEncryption.cs
    │   │   └── UnmanagedString.cs
    │   ├── BitMono.Runtime/
    │   │   ├── AssemblyInfo.cs
    │   │   ├── BitMono.Runtime.csproj
    │   │   ├── Data.cs
    │   │   ├── Decryptor.cs
    │   │   ├── Encryptor.cs
    │   │   ├── GlobalUsings.cs
    │   │   └── Hooking.cs
    │   ├── BitMono.Shared/
    │   │   ├── BitMono.Shared.csproj
    │   │   ├── FodyWeavers.xml
    │   │   ├── GlobalUsings.cs
    │   │   └── Models/
    │   │       ├── CriticalAttribute.cs
    │   │       ├── CriticalsSettings.cs
    │   │       ├── ObfuscationSettings.cs
    │   │       ├── ProtectionSetting.cs
    │   │       └── ProtectionSettings.cs
    │   └── BitMono.Utilities/
    │       ├── BitMono.Utilities.csproj
    │       ├── FodyWeavers.xml
    │       ├── GlobalUsings.cs
    │       ├── AsmResolver/
    │       │   ├── CloneHelper.cs
    │       │   ├── GenericExtensions.cs
    │       │   ├── InstructionExtensions.cs
    │       │   ├── ManifestResourceExtensions.cs
    │       │   ├── MethodDefinitionExtensions.cs
    │       │   ├── ModuleDefinitionExtensions.cs
    │       │   ├── TypeDefinitionExtensions.cs
    │       │   └── TypeDescriptorExtensions.cs
    │       ├── Collections/
    │       │   └── CollectionExtensions.cs
    │       ├── Hex/
    │       │   └── ValueToHexExtensions.cs
    │       ├── Paths/
    │       │   ├── PathFormatterUtility.cs
    │       │   └── StringPathExtensions.cs
    │       ├── Runtime/
    │       │   ├── DotNetRuntimeInfoEx.cs
    │       │   └── EnvironmentRuntimeInformation.cs
    │       └── Time/
    │           └── StopwatchUtitilies.cs
    ├── test/
    │   ├── BitMono.Benchmarks/
    │   │   ├── BitMono.Benchmarks.csproj
    │   │   ├── GlobalUsings.cs
    │   │   ├── Program.cs
    │   │   └── RuntimeFrameworkInformationBenchmark.cs
    │   ├── BitMono.Core.Tests/
    │   │   ├── App.config
    │   │   ├── BitMono.Core.Tests.csproj
    │   │   ├── GlobalUsings.cs
    │   │   ├── Setup.cs
    │   │   ├── packages.config
    │   │   ├── Analyzing/
    │   │   │   ├── CriticalMethodsCriticalAnalyzerTest.cs
    │   │   │   ├── CriticalMethodsStartsWithCriticalAnalyzerTest.cs
    │   │   │   ├── ReflectionCriticalAnalyzerTest.cs
    │   │   │   └── SerializableBitCriticalAnalyzerTest.cs
    │   │   └── Resolvers/
    │   │       ├── NoInliningMethodMemberResolverTest.cs
    │   │       ├── ObfuscateAssemblyAttributeResolverTest.cs
    │   │       └── ObfuscationAttributeResolverTest.cs
    │   ├── BitMono.Obfuscation.Tests/
    │   │   ├── BitMono.Obfuscation.Tests.csproj
    │   │   ├── GlobalUsings.cs
    │   │   └── Referencing/
    │   │       └── CosturaReferencesDataResolverTest.cs
    │   ├── Sandbox/
    │   │   ├── Program.cs
    │   │   └── Sandbox.csproj
    │   └── TestBinaries/
    │       └── DotNet/
    │           ├── BitMono.Core.TestCases.CustomAttributes/
    │           │   ├── AssemblyInfo.cs
    │           │   ├── BitMono.Core.TestCases.CustomAttributes.csproj
    │           │   ├── CustomAttributesInstance.cs
    │           │   ├── GlobalUsings.cs
    │           │   ├── NoInliningMethods.cs
    │           │   ├── ObfuscationMethods.cs
    │           │   ├── ObfuscationTypes.cs
    │           │   └── SerializableTypes.cs
    │           ├── BitMono.Core.TestCases.Methods/
    │           │   ├── BitMono.Core.TestCases.Methods.csproj
    │           │   └── CriticalMethods.cs
    │           ├── BitMono.Core.TestCases.Reflection/
    │           │   ├── BitMono.Core.TestCases.Reflection.csproj
    │           │   ├── GlobalUsings.cs
    │           │   └── ReflectionMethods.cs
    │           ├── BitMono.Core.TestCases.Types/
    │           │   ├── BitMono.Core.TestCases.Types.csproj
    │           │   ├── EmptyType.cs
    │           │   ├── GlobalUsings.cs
    │           │   └── SerializableType.cs
    │           └── BitMono.Obfuscation.TestCases.CosturaDecompressor/
    │               ├── BitMono.Obfuscation.TestCases.CosturaDecompressor.csproj
    │               ├── FodyWeavers.xml
    │               ├── GlobalUsings.cs
    │               └── Program.cs
    └── .github/
        ├── dependabot.yml
        ├── actions/
        │   ├── nuget-pack/
        │   │   └── action.yaml
        │   └── project-build/
        │       ├── action.yaml
        │       └── run-command-for-every-tests-project.ps1
        └── workflows/
            ├── BitMono.API.yaml
            ├── BitMono.CLI.yaml
            ├── BitMono.Core.yaml
            ├── BitMono.GlobalTool.yaml
            ├── BitMono.Host.yaml
            ├── BitMono.Obfuscation.yaml
            ├── BitMono.Protections.yaml
            ├── BitMono.Runtime.yaml
            ├── BitMono.Shared.yaml
            └── BitMono.Utilities.yaml

================================================
File: README.md
================================================
<p align="center">
  <img src="https://raw.githubusercontent.com/sunnamed434/BitMono/main/resources/logo/BitMonoLogo.png" alt="BitMono logo" width="180" /><br>
  Free open-source obfuscator that targeting Mono and whole .NET<br>
</p>

## BitMono

[![MIT License][image_license]][license]
[![Documentation Status](https://readthedocs.org/projects/bitmono/badge/?version=latest)](https://bitmono.readthedocs.io/en/latest/?badge=latest)
[![Nuget feed][bitmono_nuget_shield]][bitmono_nuget_packages]
[![BitMono Discord][image_bitmono_discord]][bitmono_discord]

BitMono is a free, open-source C# obfuscator that was initially designed and intended mainly for Mono, however, now you're feel free to use it for any .NET app, but, be careful some protections work on .NET Framework, some on .NET, some on Mono, some on Unity only.

BitMono uses [AsmResolver][asmresolver] instead of [dnlib][dnlib] (which we used in the past) for handling assemblies. If you have questions or issues, please let us know [here][bitmono_issues]. Download the latest version of BitMono [here][bitmono_releases].

You can also use BitMono as an engine to build custom obfuscators. It is built using dependency injection (DI) using [Autofac][autofac_repo] and follows the latest C# best practices.

<p align="center">
<img src="https://raw.githubusercontent.com/sunnamed434/BitMono/main/resources/images/preview/before-after.png"
  alt="Before and after obfuscation preview by BitMono">
</p>

<p align="center">
<img src="https://raw.githubusercontent.com/sunnamed434/BitMono/main/resources/images/preview/before-after-2.png"
  alt="Before and after obfuscation preview by BitMono 2">
</p>

<p align="center">
<img src="https://raw.githubusercontent.com/sunnamed434/BitMono/main/resources/images/preview/CLI.png"
  alt="CLI">
</p>

<p align="center">
<img src="https://raw.githubusercontent.com/sunnamed434/BitMono/main/resources/images/preview/configuration.png"
  alt="Configuration">
</p>

## Usability

BitMono breaks the most popular tools using just one packer, such as:
- dnSpy;
- dnlib;
- AsmResolver;
- MonoCecil;
- ILSpy;
- PEBear;
- DetectItEasy;
- CFF Explorer
- Perhaps, some dumpers?
- and many, many more...

So, if you will add more protection to the file, I think it would seem like total magic. :D

## Documentation

Read the **[docs][bitmono_docs]** to read protection, functionality, and more.

## How your app will look since BitMono obfuscation - just in a few words
* Looks like C++ application but is an actual C# application;
* Crash of decompilers when analyzing types;
* Broken decompilers;
* Broken IL Code;
* Invisible types;
* No code

## Features

* StringsEncryption
* **[UnmanagedString][unmanagedstring_source]** (based on existing protection)
* **[BitDotNet][bitdotnet_source]** (based and improved on existing protection)
* **[BitMethodDotnet][bitmethoddotnet_source]** (based and improved on existing protection)
* **[DotNetHook][dotnethook_source]** (based on existing protection)
* CallToCalli
* ObjectReturnType
* NoNamespaces
* FullRenamer
* AntiDebugBreakpoints
* AntiDecompiler
* BitDecompiler (fixed version of BitDotNet for newer Unity Versions)
* BitDateTimeStamp
* BitMono
* BillionNops
* AntiDe4dot
* AntiILdasm
* and you can integrate existing/make own feature ;)

## Usage

### Download

To download the latest release of BitMono, follow these steps:

1. Go to the [Latest BitMono Release][bitmono_latest_release].
2. Select and download the archive file that matches the Target Framework of the application you want to protect. Here are some examples:

- **Targeting .NET 8**: If your target file is built for .NET 8, download:
  `BitMono-v0.25.3+e64e54d3-CLI-net8.0-win-x64.zip`

- **Targeting .NET Standard**: If your target file is built for .NET Standard, you can use either BitMono for .NET Framework or .NET 8:
  `BitMono-v0.25.3+e64e54d3-CLI-net8.0-win-x64.zip`

- **Targeting .NET Framework**: If your target file is built for .NET Framework, download:
  `BitMono-v0.25.3+e64e54d3-CLI-net462-win-x64.zip`

- **Targeting Mono or Unity Engine Runtime**: If your target file is built for .NET Framework and runs on Mono or Unity, use the .NET Framework version:
  `BitMono-v0.25.3+e64e54d3-CLI-net462-win-x64.zip`

> **Note:** Be sure to select the correct version of BitMono that matches your Target Framework. Using the wrong version could result in compatibility issues, however, if that works ok anyway or if you know what you're doing, you can ignore it.

### Pre-Require

Enable one of the protection in `protections.json` file: Set `Enabled` to `true`.

### Using CLI

`BitMono.CLI <path to file>/drag-and-drop`

Always drop dependencies in `libs` directory in the same path where `file` for obfuscation is located

Your obfuscation directory structure will look something like this:
```
specially_created_folder_for_obfuscation/
â”œâ”€ your_app.exe
â””â”€ libs/
  â”œâ”€ ImportantLibrary.dll
  â”œâ”€ SuperImportantLibrary.dll
  â””â”€ ...
```

Copy all libraries (.dll) from the building application folder and paste them into the `libs` directory (if it doesn't exist yet create it), or even create the libs directory yourself with a custom name for example - `myLibs`, and then specify it in BitMono, however, if you will use `libs` then by default BitMono looking for a `libs` directory, so it will save your time.

### Using CLI Commands

```console
  -f, --file         Required. Set file path.

  -l, --libraries    Set libraries path.

  -o, --output       Set output path.

  --help             Display this help screen.

  --version          Display version information.
```

Basic example
```console
$ BitMono.CLI -f C:\specially_created_folder_for_obfuscation/your_app.exe -l specially_created_folder_for_obfuscation/libs
```

In case when you already have a directory with the name `libs` (specially_created_folder_for_obfuscation\libs) BitMono will catch it automatically, so, you don't need to specify it anymore, but you can in case if you made another directory with `libs` somewhere on the disk or even just for "visibility".
```console
$ BitMono.CLI -f C:\specially_created_folder_for_obfuscation/your_app.exe
```

Specify custom `libs` directory
```console
$ BitMono.CLI -f C:\specially_created_folder_for_obfuscation/your_app.exe -l C:\mythings\obfuscation\superLibsDirectory
```

Specify file, libs and output. If output directory doesn't exist BitMono will create it automatically and even open it on the top of the screen, if you want you can disable opening of the directory on the of top of the screen in `obfuscation.json` - and set `OpenFileDestinationInFileExplorer` to false.
```console
$ BitMono.CLI -f C:\specially_created_folder_for_obfuscation/your_app.exe -l C:\mythings\obfuscation\superLibsDirectory -o C:\specially_created_folder_for_obfuscation/output
```

Want more? Simply read the **[docs][bitmono_docs]**.

### Troubleshooting

Having issues? Get more help **[here][troubleshooting]**.

### Building

If you want to build the BitMono by your own - [click here for detailed info][build_info]

### Supported Frameworks

Feel free to use BitMono on frameworks which described below. Be careful using some protections because some might work on .NET Framework only, some on .NET (Core) only, some on all frameworks, some on Mono only - if the protection is unique to its platform/framework you will get a notification about that.

| Framework      | Version |
|----------------|---------|
| .NET           | 9.0     |
| .NET           | 8.0     |
| .NET           | 7.0     |
| .NET           | 6.0     |
| .NET Framework | 462     |
| netstandard    | 2.0     |
| netstandard    | 2.1     |

Credits
-------

**[JetBrains][jetbrains_rider]** has kindly provided licenses for their JetBrains Rider IDE to the contributors of BitMono. This top-tier tool greatly facilitates and enhances the process of software development.

**[0x59R11][author_0x59r11]** for his acquaintance in big part of **[BitDotNet][bitdotnet_source]** that breaks files for mono executables!

**[Gazzi][author_gazzi]** for his help that [me][author_sunnamed434] asked a lot!

**[Elliesaur][author_ellisaur]** for her acquaintance in **[DotNetHook][dotnethook_source]** that hooks methods.

**[Weka][author_naweka]** for his advices, help and motivation.

**[MrakDev][author_mrakdev]** for the acquaintance in **[UnmanagedString][unmanagedstring_source]**.

**[ConfuserEx and their Forks][confuserex_source]** for most things that I watched for the architecture of BitMono and the obfuscator engine as an application and solving plenty of User solutions which I would be knew in the very long future after much fail usage of BitMono and reports by other Users. Day-by-day I'm looking for something interesting there to improve myself in knowledge and BitMono also.

**[OpenMod][openmod_source]** Definitely, openmod inspired this project a lot with services and clean code, extensive similar things to openmod.

**[Kao and his blogs][author_kao_blog]** thanks a lot of these blogs.

**[drakonia][author_drakonia]** for her **[costura decompressor][simple_costura_decompressor_source]**.

[license]: https://github.com/sunnamed434/BitMono/blob/main/LICENSE
[previews]: https://github.com/sunnamed434/BitMono/blob/main/PREVIEWS.md
[asmresolver]: https://github.com/Washi1337/AsmResolver
[dnlib]: https://github.com/0xd4d/dnlib
[bitmono_issues]: https://github.com/sunnamed434/BitMono/issues
[bitmono_releases]: https://github.com/sunnamed434/BitMono/releases
[bitmono_docs]: https://bitmono.readthedocs.io/en/latest/
[bitdotnet_source]: https://github.com/0x59R11/BitDotNet
[bitmethoddotnet_source]: https://github.com/sunnamed434/BitMethodDotnet
[dotnethook_source]: https://github.com/Elliesaur/DotNetHook
[openmod_source]: https://github.com/openmod/openmod
[confuserex_source]: https://github.com/yck1509/ConfuserEx
[simple_costura_decompressor_source]: https://github.com/dr4k0nia/Simple-Costura-Decompressor
[unmanagedstring_source]: https://github.com/MrakDev/UnmanagedString
[jetbrains_rider]: https://www.jetbrains.com/rider/
[author_0x59r11]: https://github.com/0x59R11
[author_gazzi]: https://github.com/GazziFX
[author_ellisaur]: https://github.com/Elliesaur
[author_naweka]: https://github.com/naweka
[author_mrakdev]: https://github.com/MrakDev
[author_kao_blog]: https://lifeinhex.com/
[author_drakonia]: https://github.com/dr4k0nia
[author_sunnamed434]: https://github.com/sunnamed434
[bitmono_latest_release]: https://github.com/sunnamed434/BitMono/releases/latest
[bitmono_discord]: https://discord.gg/sFDHd47St4
[bitmono_nuget_packages]: https://www.nuget.org/profiles/BitMono
[bitmono_nuget_shield]: https://img.shields.io/nuget/v/BitMono.Core.svg
[autofac_repo]: https://github.com/autofac/Autofac

[troubleshooting]: https://github.com/sunnamed434/BitMono/blob/main/troubleshooting.md
[build_info]: https://github.com/sunnamed434/BitMono/blob/main/build.md
[image_codefactor]: https://www.codefactor.io/repository/github/sunnamed434/bitmono/badge/main
[image_deepsource]: https://deepsource.io/gh/sunnamed434/BitMono.svg/?label=active+issues&show_trend=true&token=_FJf25YbtCpPyX7SRveXCaGd
[image_license]: https://img.shields.io/github/license/sunnamed434/bitmono
[image_bitmono_discord]: https://img.shields.io/discord/1086240163321106523?label=discord&logo=discord



================================================
File: BitMono.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32825.248
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{A2890DD6-805E-4952-9E84-3F001E1829C4}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		.gitignore = .gitignore
		CONTRIBUTING.md = CONTRIBUTING.md
		LICENSE = LICENSE
		README.md = README.md
		props\SharedProjectProps.props = props\SharedProjectProps.props
		props\SharedPackages.props = props\SharedPackages.props
		build.md = build.md
		CODE_OF_CONDUCT.md = CODE_OF_CONDUCT.md
		props\SharedTestProps.props = props\SharedTestProps.props
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{D87066C4-1144-4BD8-96E9-9F4676001397}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.API", "src\BitMono.API\BitMono.API.csproj", "{AF23CAB0-659E-4444-9D31-7F4D06BDA5C4}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.CLI", "src\BitMono.CLI\BitMono.CLI.csproj", "{BD0789BC-F351-44CC-B58C-F91DBE778D56}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.Core", "src\BitMono.Core\BitMono.Core.csproj", "{76B85164-08C4-4D79-B331-F220967529BD}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.Host", "src\BitMono.Host\BitMono.Host.csproj", "{41B9E388-392E-4AD3-8678-2A5AFF3A1F50}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.Obfuscation", "src\BitMono.Obfuscation\BitMono.Obfuscation.csproj", "{8D86C77B-40D5-4234-8DC0-FE129F730B7A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.Protections", "src\BitMono.Protections\BitMono.Protections.csproj", "{5B46A891-BF1A-487F-AF68-0AF045F8EC96}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.Runtime", "src\BitMono.Runtime\BitMono.Runtime.csproj", "{7A7E46BE-5210-4E0B-8FF6-71B82012E51A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.Shared", "src\BitMono.Shared\BitMono.Shared.csproj", "{40615C80-C80C-4C95-ABC3-3291C32197D8}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "BitMono.Utilities", "src\BitMono.Utilities\BitMono.Utilities.csproj", "{34C08A60-E141-4FAD-975F-F447317CDA79}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "test", "test", "{1EF50257-AFD3-48A3-9E22-03BDC25550A7}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BitMono.Core.Tests", "test\BitMono.Core.Tests\BitMono.Core.Tests.csproj", "{A48CF019-9079-4CC1-8DC6-8EB6252B2071}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BitMono.Benchmarks", "test\BitMono.Benchmarks\BitMono.Benchmarks.csproj", "{3BF83671-AB38-4B91-82F2-40EA193E10DA}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "TestBinaries", "TestBinaries", "{EB40D287-0103-4693-8C26-7C3BC7C203B5}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "DotNet", "DotNet", "{A431DCB4-6EF9-4BEF-8902-FA704D62624E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BitMono.Core.TestCases.CustomAttributes", "test\TestBinaries\DotNet\BitMono.Core.TestCases.CustomAttributes\BitMono.Core.TestCases.CustomAttributes.csproj", "{1D6B1BA7-496F-4F91-A115-EF5E5DC6E6C2}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BitMono.Core.TestCases.Methods", "test\TestBinaries\DotNet\BitMono.Core.TestCases.Methods\BitMono.Core.TestCases.Methods.csproj", "{4166AC73-6969-406A-ADD0-67CB70A76D9C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BitMono.Core.TestCases.Types", "test\TestBinaries\DotNet\BitMono.Core.TestCases.Types\BitMono.Core.TestCases.Types.csproj", "{5DC793B1-F82B-4BC7-99C9-FE8C1545E1F7}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BitMono.Core.TestCases.Reflection", "test\TestBinaries\DotNet\BitMono.Core.TestCases.Reflection\BitMono.Core.TestCases.Reflection.csproj", "{1683308C-36D4-49B1-8CCE-9DDE09336856}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BitMono.Obfuscation.Tests", "test\BitMono.Obfuscation.Tests\BitMono.Obfuscation.Tests.csproj", "{49E6076C-FEC8-4411-B7AE-4DB6112370C1}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BitMono.Obfuscation.TestCases.CosturaDecompressor", "test\TestBinaries\DotNet\BitMono.Obfuscation.TestCases.CosturaDecompressor\BitMono.Obfuscation.TestCases.CosturaDecompressor.csproj", "{E73C9803-971F-4F7D-A21B-9097C2EC1A80}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Sandbox", "test\Sandbox\Sandbox.csproj", "{C5BD413C-89AF-4480-870D-985AE6C44A38}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "src\BitMono.GlobalTool", "src\BitMono.GlobalTool\BitMono.GlobalTool.csproj", "{EFBBB7CA-39C7-42A7-A965-7A2F172B1707}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AF23CAB0-659E-4444-9D31-7F4D06BDA5C4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{AF23CAB0-659E-4444-9D31-7F4D06BDA5C4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{AF23CAB0-659E-4444-9D31-7F4D06BDA5C4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{AF23CAB0-659E-4444-9D31-7F4D06BDA5C4}.Release|Any CPU.Build.0 = Release|Any CPU
		{BD0789BC-F351-44CC-B58C-F91DBE778D56}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BD0789BC-F351-44CC-B58C-F91DBE778D56}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BD0789BC-F351-44CC-B58C-F91DBE778D56}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BD0789BC-F351-44CC-B58C-F91DBE778D56}.Release|Any CPU.Build.0 = Release|Any CPU
		{76B85164-08C4-4D79-B331-F220967529BD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{76B85164-08C4-4D79-B331-F220967529BD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{76B85164-08C4-4D79-B331-F220967529BD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{76B85164-08C4-4D79-B331-F220967529BD}.Release|Any CPU.Build.0 = Release|Any CPU
		{41B9E388-392E-4AD3-8678-2A5AFF3A1F50}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{41B9E388-392E-4AD3-8678-2A5AFF3A1F50}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{41B9E388-392E-4AD3-8678-2A5AFF3A1F50}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{41B9E388-392E-4AD3-8678-2A5AFF3A1F50}.Release|Any CPU.Build.0 = Release|Any CPU
		{8D86C77B-40D5-4234-8DC0-FE129F730B7A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8D86C77B-40D5-4234-8DC0-FE129F730B7A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8D86C77B-40D5-4234-8DC0-FE129F730B7A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8D86C77B-40D5-4234-8DC0-FE129F730B7A}.Release|Any CPU.Build.0 = Release|Any CPU
		{5B46A891-BF1A-487F-AF68-0AF045F8EC96}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5B46A891-BF1A-487F-AF68-0AF045F8EC96}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5B46A891-BF1A-487F-AF68-0AF045F8EC96}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5B46A891-BF1A-487F-AF68-0AF045F8EC96}.Release|Any CPU.Build.0 = Release|Any CPU
		{7A7E46BE-5210-4E0B-8FF6-71B82012E51A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7A7E46BE-5210-4E0B-8FF6-71B82012E51A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7A7E46BE-5210-4E0B-8FF6-71B82012E51A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7A7E46BE-5210-4E0B-8FF6-71B82012E51A}.Release|Any CPU.Build.0 = Release|Any CPU
		{40615C80-C80C-4C95-ABC3-3291C32197D8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{40615C80-C80C-4C95-ABC3-3291C32197D8}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{40615C80-C80C-4C95-ABC3-3291C32197D8}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{40615C80-C80C-4C95-ABC3-3291C32197D8}.Release|Any CPU.Build.0 = Release|Any CPU
		{34C08A60-E141-4FAD-975F-F447317CDA79}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{34C08A60-E141-4FAD-975F-F447317CDA79}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{34C08A60-E141-4FAD-975F-F447317CDA79}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{34C08A60-E141-4FAD-975F-F447317CDA79}.Release|Any CPU.Build.0 = Release|Any CPU
		{A48CF019-9079-4CC1-8DC6-8EB6252B2071}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A48CF019-9079-4CC1-8DC6-8EB6252B2071}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A48CF019-9079-4CC1-8DC6-8EB6252B2071}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A48CF019-9079-4CC1-8DC6-8EB6252B2071}.Release|Any CPU.Build.0 = Release|Any CPU
		{3BF83671-AB38-4B91-82F2-40EA193E10DA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3BF83671-AB38-4B91-82F2-40EA193E10DA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3BF83671-AB38-4B91-82F2-40EA193E10DA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3BF83671-AB38-4B91-82F2-40EA193E10DA}.Release|Any CPU.Build.0 = Release|Any CPU
		{1D6B1BA7-496F-4F91-A115-EF5E5DC6E6C2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1D6B1BA7-496F-4F91-A115-EF5E5DC6E6C2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1D6B1BA7-496F-4F91-A115-EF5E5DC6E6C2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1D6B1BA7-496F-4F91-A115-EF5E5DC6E6C2}.Release|Any CPU.Build.0 = Release|Any CPU
		{4166AC73-6969-406A-ADD0-67CB70A76D9C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4166AC73-6969-406A-ADD0-67CB70A76D9C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4166AC73-6969-406A-ADD0-67CB70A76D9C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4166AC73-6969-406A-ADD0-67CB70A76D9C}.Release|Any CPU.Build.0 = Release|Any CPU
		{5DC793B1-F82B-4BC7-99C9-FE8C1545E1F7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5DC793B1-F82B-4BC7-99C9-FE8C1545E1F7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5DC793B1-F82B-4BC7-99C9-FE8C1545E1F7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5DC793B1-F82B-4BC7-99C9-FE8C1545E1F7}.Release|Any CPU.Build.0 = Release|Any CPU
		{1683308C-36D4-49B1-8CCE-9DDE09336856}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1683308C-36D4-49B1-8CCE-9DDE09336856}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1683308C-36D4-49B1-8CCE-9DDE09336856}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1683308C-36D4-49B1-8CCE-9DDE09336856}.Release|Any CPU.Build.0 = Release|Any CPU
		{49E6076C-FEC8-4411-B7AE-4DB6112370C1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{49E6076C-FEC8-4411-B7AE-4DB6112370C1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{49E6076C-FEC8-4411-B7AE-4DB6112370C1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{49E6076C-FEC8-4411-B7AE-4DB6112370C1}.Release|Any CPU.Build.0 = Release|Any CPU
		{E73C9803-971F-4F7D-A21B-9097C2EC1A80}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E73C9803-971F-4F7D-A21B-9097C2EC1A80}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E73C9803-971F-4F7D-A21B-9097C2EC1A80}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E73C9803-971F-4F7D-A21B-9097C2EC1A80}.Release|Any CPU.Build.0 = Release|Any CPU
		{C5BD413C-89AF-4480-870D-985AE6C44A38}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C5BD413C-89AF-4480-870D-985AE6C44A38}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C5BD413C-89AF-4480-870D-985AE6C44A38}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C5BD413C-89AF-4480-870D-985AE6C44A38}.Release|Any CPU.Build.0 = Release|Any CPU
		{EFBBB7CA-39C7-42A7-A965-7A2F172B1707}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EFBBB7CA-39C7-42A7-A965-7A2F172B1707}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EFBBB7CA-39C7-42A7-A965-7A2F172B1707}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EFBBB7CA-39C7-42A7-A965-7A2F172B1707}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{AF23CAB0-659E-4444-9D31-7F4D06BDA5C4} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{BD0789BC-F351-44CC-B58C-F91DBE778D56} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{76B85164-08C4-4D79-B331-F220967529BD} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{41B9E388-392E-4AD3-8678-2A5AFF3A1F50} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{8D86C77B-40D5-4234-8DC0-FE129F730B7A} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{5B46A891-BF1A-487F-AF68-0AF045F8EC96} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{7A7E46BE-5210-4E0B-8FF6-71B82012E51A} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{40615C80-C80C-4C95-ABC3-3291C32197D8} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{34C08A60-E141-4FAD-975F-F447317CDA79} = {D87066C4-1144-4BD8-96E9-9F4676001397}
		{A48CF019-9079-4CC1-8DC6-8EB6252B2071} = {1EF50257-AFD3-48A3-9E22-03BDC25550A7}
		{3BF83671-AB38-4B91-82F2-40EA193E10DA} = {1EF50257-AFD3-48A3-9E22-03BDC25550A7}
		{EB40D287-0103-4693-8C26-7C3BC7C203B5} = {1EF50257-AFD3-48A3-9E22-03BDC25550A7}
		{A431DCB4-6EF9-4BEF-8902-FA704D62624E} = {EB40D287-0103-4693-8C26-7C3BC7C203B5}
		{1D6B1BA7-496F-4F91-A115-EF5E5DC6E6C2} = {A431DCB4-6EF9-4BEF-8902-FA704D62624E}
		{4166AC73-6969-406A-ADD0-67CB70A76D9C} = {A431DCB4-6EF9-4BEF-8902-FA704D62624E}
		{5DC793B1-F82B-4BC7-99C9-FE8C1545E1F7} = {A431DCB4-6EF9-4BEF-8902-FA704D62624E}
		{1683308C-36D4-49B1-8CCE-9DDE09336856} = {A431DCB4-6EF9-4BEF-8902-FA704D62624E}
		{49E6076C-FEC8-4411-B7AE-4DB6112370C1} = {1EF50257-AFD3-48A3-9E22-03BDC25550A7}
		{E73C9803-971F-4F7D-A21B-9097C2EC1A80} = {A431DCB4-6EF9-4BEF-8902-FA704D62624E}
		{C5BD413C-89AF-4480-870D-985AE6C44A38} = {1EF50257-AFD3-48A3-9E22-03BDC25550A7}
		{EFBBB7CA-39C7-42A7-A965-7A2F172B1707} = {D87066C4-1144-4BD8-96E9-9F4676001397}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7DA0BB43-C1D4-4688-BE43-A9ED2D6F78EE}
	EndGlobalSection
EndGlobal



================================================
File: BitMono.sln.DotSettings
================================================
ï»¿<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:Boolean x:Key="/Default/CodeEditing/SuppressUninitializedWarningFix/Enabled/@EntryValue">False</s:Boolean>
	<s:String x:Key="/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=ASCII/@EntryIndexedValue">ASCII</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=CLI/@EntryIndexedValue">CLI</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=JS/@EntryIndexedValue">JS</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=NET/@EntryIndexedValue">NET</s:String>
	<s:String x:Key="/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=PE/@EntryIndexedValue">PE</s:String>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=criticals/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=Decryptor/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=dnlib/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=Ldasm/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=mprotect/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=Nops/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=obfuscator/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=obfuscators/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/UserDictionary/Words/=renamer/@EntryIndexedValue">True</s:Boolean></wpf:ResourceDictionary>


================================================
File: CHANGELOG.md
================================================
# Changelog

NOTICE: No more we write a changelog here, all changes are now noted automatically by "Generate Release Notes" tool by GitHub on Release.

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

| Versions:                     |
|-------------------------------|
| [0.20.0-alpha](#0200-alpha35) |
| [0.19.0-alpha](#0190-alpha34) |
| [0.18.0-alpha](#0180-alpha33) |
| [0.16.2-alpha](#0162-alpha31) |
| [0.16.1-alpha](#0161-alpha30) |
| [0.16.0-alpha](#0160-alpha29) |
| [0.15.1-alpha](#0151-alpha28) |
| [0.15.0-alpha](#0150-alpha27) |
| [0.14.0-alpha](#0140-alpha26) |
| [0.13.1-alpha](#0131-alpha25) |
| [0.13.0-alpha](#0130-alpha24) |
| [0.12.2-alpha](#0122-alpha23) |
| [0.12.1-alpha](#0121-alpha22) |
| [0.12.0-alpha](#0120-alpha21) |
| [0.11.0-alpha](#0110-alpha20) |
| [0.10.0-alpha](#0100-alpha19) |
| [0.9.0-alpha](#090-alpha18)   |
| [0.8.0-alpha](#080-alpha17)   |
| [0.7.0-alpha](#070-alpha16)   |
| [0.6.0-alpha](#060-alpha15)   |
| [0.4.4-alpha](#044-alpha13)   |
| [0.4.3-alpha](#043-alpha12)   |

---

## 0.20.0-alpha.35
2023-10-21

### Added
- BillionNops protection.
- Information about BillionNops in docs.
- XML docs for RuntimeMonikerMonoAttribute.

### Fixed
- Annoying EndOfStreamException being thrown in AssemblyResolver when file doesn't exists or this is lib/file that at the end of the stream.
- Not being properly compiled docs.
- DotNetHook VirtualProtect will not work on linux [#37](https://github.com/sunnamed434/BitMono/issues/37)

## 0.19.0-alpha.34
2023-10-12

### Added
- Artifacts creation.
- Automatic release (CI).
- .netstandard2.1 Support.
- More information in `build.md` how to build BitMono.

### Changed
- Removed unused and broken GUI version of BitMono from solution.
- Bumped to the stablest versions of NuGet Packages to don't break the compability with the target framework.
- .csproj style.

### Fixed
- .NET 6.0 Support.

## 0.18.0-alpha.33
2023-09-02

### Added
- Add ForceObfuscation, ReferencesDirectoryName, OutputDirectoryName, and ClearCLI options in the obfuscation.json.
- More detailed info how to build the solution.
- .NET 6.0 Support.

### Fixed
- BitMono drag and drop exception [#135](https://github.com/sunnamed434/BitMono/issues/135).
- First line of the CLI shows working directory [#137](https://github.com/sunnamed434/BitMono/issues/137).
- .NET 5 exceptions [#138](https://github.com/sunnamed434/BitMono/issues/138).

## 0.16.2-alpha.31
2023-07-19

### Fixed

- Exception on the BitMono run [#132](https://github.com/sunnamed434/BitMono/issues/132).

### Changed

- The GitHub Issue Templates are removed now.

## 0.16.1-alpha.30
2023-07-17

### Added

- New docs.

### Fixed

- (UnmanagedString) Add unicode support, fix strings with null characters [#130](https://github.com/sunnamed434/BitMono/pull/130), by [GazziFX](https://github.com/GazziFX)
- Other minor bug fixes.

### Changed

- Bumped to the latest AsmResolver 5.4.0 version.
- Code refactoring and possible bug fixes.

## 0.16.0-alpha.29
2023-05-14

### Added

- New logging info about loaded module (version, PE time date stamp, token, culture and target framework)

### Fixed

- PE Image build errors output

### Changed

- Bumped to latest AsmResolver 5.3.0 version.

## 0.15.1-alpha.28
2023-04-28

### Added

- New logging info with count of enabled/disabled protections.
- New logging info before execution of the protections.

### Fixed

- Bug that caused BitMono.CLI to be crashed.
- UnmanagedString Protection.
- CallToCalli Protection.

### Changed

- RuntimeMonikerAttribute now allowed to be multiple.

## 0.15.0-alpha.27
2023-04-27

### Added

- UnmanagedString Protection.
- More docs.

### Fixed

- DotNetHook Protection.

### Changed

- Major improvements and changes in Engine APIs.
- Removed PreserveAll flag, now obfuscation should be more stable.

## 0.14.0-alpha.26
2023-04-24

### Added

- More docs for developers and users.
- New parameter in `criticals.json` which allows to ignore methods starts with name, i.e `CriticalMethodsStartsWith`.

### Changed

- Major changes in Protections APIs.

## 0.13.1-alpha.25
2023-04-15

### Fixed

- Assembly Resolve, which caused problems with PE build.

## 0.13.0-alpha.24
2023-04-05

### Added

- Return obfuscation success & failure status from BitMono.CLI (0 - Success, 1 - Failure), by [techei](https://github.com/techei)
- More docs and answers to the questions.

#### Fixed

- Assembly resolve [#113](https://github.com/sunnamed434/BitMono/issues/113), by [techei](https://github.com/techei)

### Changed

- Docs information about protections.

## 0.12.2-alpha.23
2023-03-08

### Fixed

- Error that caused issues with .NET 7.0 obfuscation (file not found, etc)

## 0.12.1-alpha.22
2023-03-06

### Added

- Test cases for costura decompressor.

### Fixed

- Costura decompressor.

## 0.12.0-alpha.21
2023-03-05

### Added

- [Costura-Fody](https://github.com/Fody/Costura) support, now references are resolved automatically, [#102](https://github.com/sunnamed434/BitMono/issues/102).
- Support when path contains quotes (for example: "path..."), [#104](https://github.com/sunnamed434/BitMono/issues/104).

### Fixed

- Hiding of the paths (before paths with .exe may cause an ignore).
- Now output directory path message shows normally (before ***\folder_before_output, now ***\output).

## 0.11.0-alpha.20
2023-02-016

### Added

- BitMono ASCII Art in CLI.
- Hiding of the path (file path, directory path, etc).
- Documentation.

### Fixed

- Error when use mono BitMono.CLI.exe [#93](https://github.com/sunnamed434/BitMono/issues/93)

### Changed

- Major changes in whole API of BitMono.

## 0.10.0-alpha.19
2023-02-013

### Added

- Command line arguments [#82](https://github.com/sunnamed434/BitMono/issues/82).

### Fixed

- DotNetHook protection.

## 0.9.0-alpha.18
2023-02-09

### Changed

- Bumped to the latest version of AsmResolver.

### Fixed

- Errors when launching the BitMono.CLI.
- Bug fixes and other minor improvements.

## 0.8.0-alpha.17
2023-01-27

### Added

- Reflection analysis such as in ConfuserEx [#41](https://github.com/sunnamed434/BitMono/issues/41).
- BitMono protection.

### Changed

- Moved new protections from BitDotNet to BitMono protection and added support for PE32 and PE32+.

### Fixed

- README text spelling [#54](https://github.com/sunnamed434/BitMono/pull/54), by [Gibsol](https://github.com/Gibsol).
- .gitignore [#81](https://github.com/sunnamed434/BitMono/pull/81), by [0x59R11](https://github.com/0x59R11).

### 0.7.0-alpha.16

#### Added

- Unit Tests.
- Benchmarks.
- Support of ObfuscateAssemblyAttribute.
- New properties in obfuscation.json config.
- Ignore members with specific attribute, eg, [SerializeField], it can be edited in criticals.json now.

#### Changed

- Obfuscation process.
- ObfuscationAttribute support.
- Moved from .NET Framework 461 to .NET Framework 462

#### Fixed

- [SerializableAttribute] support.
- [MethodImpl(MethodImplOptions.NoInlining)] support.

### 0.6.0-alpha.15

#### Added

- New protection AntiDecompiler.
- As more as possible errors logging.

#### Changed

- Migrate dnlib to AsmResolver or Mono.Cecil [#50](https://github.com/sunnamed434/BitMono/issues/50).

#### Fixed

- BitMethodDotnet Protection.
- StringsEncryption Protection.
- CallToCalli Protection.
- DotNetHook Protection.
- Load Runtime Module via file instead of typeof(SomeRuntime).Module [#55](https://github.com/sunnamed434/BitMono/issues/55).
- Rewrite Custom Attributes Resolve as less as a possible reflection [#57](https://github.com/sunnamed434/BitMono/issues/57).
- System.BadImageFormatException: Invalid DOS signature [#45](https://github.com/sunnamed434/BitMono/issues/45).
- Whole Protections execution process.
- Protections execution information.
- Obfuscation.
- Optimized file writing.
- Ignoring of targets with [ObfuscationAttribute] and [MethodImpl(MethodImplOptions.NoInlining)].
- Runtime injection and even became better.

### 0.5.0-alpha.14

#### Added

- Before obfuscation optimizes all method bodies (macros)

#### Fixed

- BitMethodDotnet Protection.
- StringsEncryption Protection.

### 0.4.4-alpha.13

#### Fixed

- DotNetHook Protection.
- StringsEncryption Protection.
- CallToCalli Protection.
- Obfuscation doesn't saves assembly information such as assembly attributes [#36](https://github.com/sunnamed434/BitMono/issues/36).
- No more module reloading (Module now loads once and writes once).

### 0.4.3-alpha.12

#### Changed

- Protections are looks more cleaner than before, no code duplication.
- Now BitDotNet is not an protection but packer.

#### Fixed

- Obfuscation process.
- Manipulations and saving of Module optimized, most of things store in memory then writes in file instead of every time writing in file and loading module.

*Other versions were removed due to invalid usage of Semantic Versioning.*


================================================
File: CODE_OF_CONDUCT.md
================================================

# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual
identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the overall
  community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or advances of
  any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email address,
  without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
our [Discord Server](https://discord.gg/sFDHd47St4) or our [Issue tracker](https://github.com/sunnamed434/BitMono/issues).
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series of
actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or permanent
ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the
community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

Community Impact Guidelines were inspired by
[Mozilla's code of conduct enforcement ladder][Mozilla CoC].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][FAQ]. Translations are available at
[https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
[Mozilla CoC]: https://github.com/mozilla/diversity
[FAQ]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations



================================================
File: CONTRIBUTING.md
================================================
# Special Thanks
For great [CONTIRUBITNG.md](https://github.com/Washi1337/AsmResolver/blob/master/CONTRIBUTING.md) file which was "pasted" from [AsmResolver](https://github.com/Washi1337/AsmResolver)

BitMono Coding Style and Licensing
======================================

## Aims

This guide is for developers who wish to contribute to the BitMono codebase. It will detail how to properly style and format code to fit this project.

Following this guide and formatting your code as detailed will likely get your pull request merged much faster than if you don't (assuming the written code has no mistakes in itself).

If you make any changes to BitMono, you are agreeing to the license conditions as specified in [LICENSE.md](LICENSE.md).


## General Workflow

The BitMono project generally follows the principles of [Git Flow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow), with a few variations. Below a summary:

- Prefer to create a branch based on `main`.
- Prefix your branch accordingly, depending on what kind of change you are trying to make.
  - For new features, use `feature/name-of-feature`.
  - For issues and/or bug fixes, use `issue/name-of-issue-or-bug`.
- Push your changes on this branch.
  - Make sure you are following the coding style guidelines as described in this document below.
- Open a [Pull Request](https://github.com/sunnamed434/BitMono/pulls), setting the `main` branch as a base branch to merge into.
- Wait for your pull request to be reviewed and accepted.
  - Pull requests into `main` will only be accepted if all unit tests succeed and follow the guidelines as described in this document.


## C# Coding Style

The general idea behind the coding style that is adopted in the BitMono project follows a few key points:

- Do not to be afraid to be verbose.
- Separate different parts of the code from each other wherever possible.

Furthermore:
- Use 4 spaces for indentation.
- Try to limit the number of characters on one line to 120 characters.
- Avoid preprocessor directives or `#region`s

For editors that support EditorConfig, there is an `.editorconfig` file for you to use in the root directory of the repository.


### General naming conventions

Below an overview of the naming conventions used within the project.

| Member type                 | Naming style                        |
|-----------------------------|-------------------------------------|
| Namespaces                  | `PascalCase`                        |
| Classes                     | `PascalCase`                        |
| Structs                     | `PascalCase`                        |
| Interfaces                  | `IPrefixedPascalCase`               |
| Private instance fields     | `_camelCaseWithUnderscore`          |
| Any other field             | `PascalCase`                        |
| Methods                     | `PascalCase`                        |
| Properties                  | `PascalCase`                        |
| Events                      | `PascalCase`                        |
| Parameters                  | `camelCase`                         |
| Local variables             | `camelCase`                         |
| Local constants             | `camelCase`                         |


### Prefer verbose names over abbreviations

Avoid truncating any words within the name of a member:

Do:
```csharp
public class ModuleDefinition
```

Don't:
```csharp
public class ModuleDef
```

In the case an abbreviation is still used, only capitalize all letters of the abbreviation if the abbreviation is at most two letters. Otherwise, only capitalize the first letter in the abbreviation.

Do:
```csharp
public class PEImage { ... }
public struct CilOpCode { ... }
```

Don't:
```csharp
public class PeImage { ... }
public struct CILOpCode { ... }
```

In the case of an interface name starting with an abbreviation, we do not count the prefix `I` when counting the letters of an abbreviation.

Do:
```
public interface IPEImage { ... }
```

Don't:
```
public interface IPeImage { ... }
public interface IpeImage { ... }
```

### Grouping of members

The general order of members within a single file is as followed:

1. Events
2. Fields
3. Constructors
4. Properties
5. Methods
6. Nested types

Prefer to mark the current `class` as `partial` over using `#region` directives when the file gets too large.

### General brace style

Always place opening and closing braces on a new line, and indent after.

Do:
```csharp
public namespace N
{
    public class T
    {
        public void Method()
        {
            Console.WriteLine("Hello, world!");
        }
    }
}
```

Don't:
```csharp
public namespace N {
    public class T {
        public void Method() {
            Console.WriteLine("Hello, world!");
        }
    }
}
```

### Embedded statement bracing

Arms of an `if` statement should always be wrapped using braces. The only place when it is acceptable to exclude braces is when __all__ arms only consist of one line of code. In such a case, the embedded statement should be on a new line, indented.

Do:
```csharp
if (x == y)
    MethodA();

if (x == y)
    MethodA();
else
    MethodB();

if (x == y)
{
    MethodA();
}
else
{
    MethodB();
    MethodC();
}
```

Don't:
```csharp
if (x == y) MethodA();

if (x == y)
    MethodA();
else
{
    MethodB();
    MethodC();
}
```

For loops, both including and excluding braces is acceptable, even if the embedded statement only spans one line. Similar to `if` statements, when braces are excluded, always place the embedded statement on a new indented line.

```csharp
foreach (var x in collection)
    Method(x);

foreach (var x in collection)
{
    Method(x);
}
```

### Local variable typing

Use `var` for anything that is not a primitive type for which a dedicated keyword exists.

Do:
```csharp
int x = 123;
string y = "Hello, world!";
byte[] z = new byte[10];

var instance = new MyClass(...);
```

Don't:
```csharp
var x = 123;
var y = "Hello, world!";
var array = new byte[10];

MyClass instance = new MyClass(...);
```

### Public method, field and property typing

Prefer to use the most general type of the returned object that still conveys the overal structure of the returned object, as much as possible. For instance, prefer using `IList<T>` over `List<T>` for mutable collection properties, or `IEnumerable<T>` over `List<T>` for methods that return a collection.

Do:
```csharp
public IList<MethodDefinition> Methods
{
    get;
}

public IEnumerable<TypeDefinition> GetAllTypes()
{
    // ...
}
```

Don't:
```csharp
public List<MethodDefinition> Methods
{
    get;
}

public List<TypeDefinition> GetAllTypes()
{
    // ...
}
```

For non-public members, using the more specific type is acceptable.

### The `this` keywords

Only use `this` when absolutely necessary. Prefer to omit it from any expression unless there is ambiguity or when `this` needs to be used as an argument.

Do:
```csharp
int x = _myField;
SomeMethod();
```

Don't:
```csharp
int x = this._myField;
this.SomeMethod();
```

### Ternary experssions

Prefer to place the arms of a ternary expression on separate lines:

Do:
```csharp
var temp = condition
    ? MethodA()
    : MethodB();
```

Don't:
```csharp
var temp = condition ? MethodA() : MethodB();
```

### Loops

Prefer `for` loops over `foreach` when heap allocated enumerators can be avoided. For example, if `GetEnumerator` returns a non-struct type enumerator, but accessing elements by index is possible, prefer to use a `for` loop with an indexer variable.

Do:
```csharp
var items = assembly.Modules;
for (int i = 0; i < items.Count; i++)
{
    // Use items[i]
}
```

Don't:
```csharp
var items = assembly.Modules;
foreach (var item in items) // IList<T>.GetEnumerator() returns a heap allocated enumerator
{
    // Use item
}
```

### Usage of LINQ and method chains

Using LINQ is acceptable, but prefer the method syntax over the query syntax. When multiple method calls are chained together, prefer to put them on separate lines:

Do:
```csharp
var allClassMethods = assembly.Modules
    .SelectMany(m => m.GetAllTypes())
    .Where(t => t.IsClass)
    .SelectMany(t => t.Methods)
    .ToArray();
```

Don't:
```csharp
var allClasses = assembly.Modules.SelectMany(m => m.GetAllTypes()).Where(t => t.IsClass).SelectMany(t => t.Methods).ToArray();
```

### XML documentation

Always provide at least the `<summary>` xml documentation tag for non-`private` and non-`internal` members.


================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2022 sunnamed434

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: build.md
================================================
## Binaries

If you just need the compiled binaries simply install them [from releases][releases] - open the dropdown button `Assets`, and select the preferred archive, these binaries were made automatically via CI/CD pipeline.

### Compiling

Recommended to install tools via Visual Studio installer, otherwise you can install those tools directly via provided links down below or just searching for it by yourself.

- [.NET Framework 462][net462]
- [Visual Studio 2022][vs2022]/[JetBrains Rider][rider] or newer to build the solution
- [.NET 9.0][net9]
- [.NET 8.0][net8]
- [.NET 7.0][net7]
- [.NET 6.0][net6]

To build the solution from command line, use:

```bash
$ dotnet build
```

Otherwise do that via IDE `Build` button if you have.

To run tests, use:

```bash
$ dotnet test
```

### Release On GitHub details

Archives examples (versions and/or naming can be a bit different):
- .NET 9.0: `BitMono-v0.24.2+7aaeceac-CLI-net9.0-linux-x64.zip`
- .NET 8.0: `BitMono-v0.24.2+7aaeceac-CLI-net8.0-linux-x64.zip`
- .NET 7.0: `BitMono-v0.24.2+7aaeceac-CLI-net7.0-win-x64.zip`
- .NET 6.0: `BitMono-v0.24.2+7aaeceac-CLI-net6.0-linux-x64.zip`
- .NET 462: `BitMono-v0.24.2+7aaeceac-CLI-net462-win-x64.zip`
- netstandard 2.1: `BitMono-v0.24.2+7aaeceac-CLI-netstandard2.1-linux-x64.zip`
- netstandard 2.0: `BitMono-v0.24.2+7aaeceac-CLI-netstandard2.0-win-x64.zip`

To be more clear:
- `v0.24.2` is the version and the value `+7aaeceac` after the version is the hash of the commit.
- `CLI` is the `command line interface` meaning, currently BitMono only have CLI for usage.
-  `net.9.0`, `net8.0`, `net7.0`, `net6.0`, `net462`, `netstandard2.1`, `netstandard2.0` is the target framework that BitMono was built on.

### Help

If you have any issues/questions freely, ask them [here][issues], or contact via:
- Email: sunnamed434 (at) proton.me

[net462]: https://dotnet.microsoft.com/en-us/download/dotnet-framework/net462
[vs2022]: https://visualstudio.microsoft.com/downloads
[rider]: https://www.jetbrains.com/rider/download
[net6]: https://dotnet.microsoft.com/en-us/download/dotnet/6.0
[net7]: https://dotnet.microsoft.com/en-us/download/dotnet/7.0
[net8]: https://dotnet.microsoft.com/en-us/download/dotnet/8.0
[net9]: https://dotnet.microsoft.com/en-us/download/dotnet/9.0
[releases]: https://github.com/sunnamed434/BitMono/releases
[issues]: https://github.com/sunnamed434/BitMono/issues


================================================
File: troubleshooting.md
================================================
### Troubleshooting

Here we describe most known issues and its solution, something like Faq.

#### Access Denied:

Try to set `OpenFileDestinationInFileExplorer` to `false` in `obfuscation.json`


================================================
File: .editorconfig
================================================
root = true

[*]
trim_trailing_whitespace = true
csharp_using_directive_placement = outside_namespace:silent
csharp_style_namespace_declarations = file_scoped:silent

[*.yml]
indent_size = 2
indent_style = space

[*.{proj,csproj,vbproj,props,targets,resx,vsixmanifest}]
indent_size = 2
indent_style = space

[*.cs]
# https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/style-rules/ide0290
csharp_style_prefer_primary_constructors = false
dotnet_diagnostic.IDE0290.severity = none

# https://www.jetbrains.com/help/rider/ConvertToPrimaryConstructor.html
resharper_convert_to_primary_constructor_highlighting = none 


================================================
File: .readthedocs.yaml
================================================
version: "2"

build:
  os: "ubuntu-22.04"
  tools:
    python: "3.10"

python:
  install:
    - requirements: docs/requirements.txt

sphinx:
  configuration: docs/source/conf.py

formats:
  - pdf
  - epub
  - htmlzip


================================================
File: docs/Dockerfile
================================================
# Use a base image with Python
FROM python:3.10-slim

# Set working directory
WORKDIR /docs

# Copy the documentation source into the container
COPY . /docs

# Install Sphinx and build the documentation
RUN pip install sphinx sphinx-rtd-theme
RUN sphinx-build -b html source build

# Expose the port the app runs on
EXPOSE 8000

# Command to run the HTTP server and output instructions
CMD echo "Documentation is available at http://localhost:8000" && \
    python -m http.server 8000 --directory build


================================================
File: docs/Makefile
================================================
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = source
BUILDDIR      = build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)


================================================
File: docs/README.txt
================================================
How to Run BitMono Docs Locally

Prerequisites:
- Ensure Docker is installed on your machine. If not, install Docker from https://docs.docker.com/get-docker/.

Running Locally:
1. Start Docker if itâ€™s not already running.
2. Open a terminal and navigate to the directory containing your docker-compose.yml file.
3. Execute the following command to build and start the container:
   docker-compose up --build
4. Open your browser and go to: http://localhost:8000 to view the documentation.

Restarting the Container:
1. To stop the container, press CTRL + C in the terminal where Docker is running, or close the terminal window.
2. To restart the container and apply any changes, execute:
   docker-compose up --build
3. Refresh the browser page at http://localhost:8000 to see the latest updates.

To edit/update docs:
Prerequisites:
- Use Visual Studio Code, or any other tool. https://code.visualstudio.com/

Go to `source` folder and do your magic!


================================================
File: docs/docker-compose.yml
================================================
services:
  docs:
    build:
      context: .
      dockerfile: Dockerfile
    image: bitmono-docs-image:latest
    ports:
      - "8000:8000"
    entrypoint: ["sh", "-c", "echo 'Documentation is available at http://localhost:8000' && python -m http.server 8000 --directory build"]


================================================
File: docs/make.bat
================================================
@ECHO OFF

pushd %~dp0

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set SOURCEDIR=source
set BUILDDIR=build

if "%1" == "" goto help

%SPHINXBUILD% >NUL 2>NUL
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%
goto end

:help
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%

:end
popd


================================================
File: docs/requirements.txt
================================================
sphinx==7.1.2
sphinx-rtd-theme==1.3.0rc1


================================================
File: docs/.env
================================================
COMPOSE_PROJECT_NAME=bitmono-docs-project


================================================
File: docs/.gitignore
================================================



================================================
File: docs/source/conf.py
================================================
# Configuration file for the Sphinx documentation builder.

# -- Project information

project = 'BitMono'
copyright = '2022-2024, BitMono'
author = 'sunnamed434'

release = '0.1'
version = '0.1.0'

# -- General configuration

extensions = [
    'sphinx.ext.duration',
    'sphinx.ext.doctest',
    'sphinx.ext.autodoc',
    'sphinx.ext.autosummary',
    'sphinx.ext.intersphinx',
]

intersphinx_mapping = {
    'python': ('https://docs.python.org/3/', None),
    'sphinx': ('https://www.sphinx-doc.org/en/master/', None),
}
intersphinx_disabled_domains = ['std']

templates_path = ['_templates']

# -- Options for HTML output

html_theme = 'sphinx_rtd_theme'

# -- Options for EPUB output
epub_show_urls = 'footnote'


================================================
File: docs/source/index.rst
================================================
BitMono
=======

This is the documentation of the BitMono project. BitMono is not only a tool that can be used for a two clicks to obfuscate your file, even for your own plugins and purposes - for example BitMono can be used as an Engine for your own obfuscation.

Most of the questions/problems in BitMono will be solved by just learning `AsmResolver docs <https://asmresolver.readthedocs.io>`_

Join our `Discord Server <https://discord.gg/sFDHd47St4>`_ you will find there help to your question(s) or just a nice talk!

Table of Contents:
------------------

.. toctree::
   :maxdepth: 1
   :caption: Protections
   :name: sec-protections

   protections/antiildasm
   protections/antide4dot
   protections/bitdotnet
   protections/bitdecompiler
   protections/bitmono
   protections/bittimedatestamp
   protections/bitmethoddotnet
   protections/antidecompiler
   protections/antidebugbreakpoints
   protections/calltocalli
   protections/dotnethook
   protections/fullrenamer
   protections/objectreturntype
   protections/stringsencryption
   protections/unmanagedstring
   protections/nonamespaces
   protections/billionnops

.. toctree::
   :maxdepth: 1
   :caption: Protection List
   :name: sec-protection-list

   protection-list/overview
   protection-list/unity


.. toctree::
   :maxdepth: 1
   :caption: Developers
   :name: sec-developers

   developers/first-protection
   developers/obfuscation-execution-order
   developers/which-base-protection-select
   developers/protection-runtime-moniker
   developers/native-code
   developers/do-not-resolve-members
   developers/configuration
   developers/obfuscate-build


.. toctree::
   :maxdepth: 1
   :caption: Obfuscation Issues
   :name: sec-obfuscationissues

   obfuscationissues/corlib-not-found
   obfuscationissues/intended-for
   obfuscationissues/compatibility
   obfuscationissues/ready-to-run


.. toctree::
   :maxdepth: 1
   :caption: Best Practices
   :name: sec-bestpractices

   bestpractices/bitmono-combo
   bestpractices/zero-risk-obfuscation


.. toctree::
   :maxdepth: 1
   :caption: Configuration
   :name: sec-configuration

   configuration/exclude-obfuscation
   configuration/third-party-issues
   configuration/protections


.. toctree::
   :maxdepth: 1
   :caption: Frequently Asked Questions
   :name: sec-faq

   faq/costura-support
   faq/disable-path-masking
   faq/unable-to-reference-after-protect
   faq/when-and-why-use-bitmono


================================================
File: docs/source/bestpractices/bitmono-combo.rst
================================================
BitMono Combo
=============

BitMono is not enough to just protect the application, but, its so good their Packers which prevents dnSpy and other popular tools being opened :D 
In this case you need another layer of protection with BitMono cannot provide yet, you can use ConfuserEx or other tools atop BitMono, but, recommend to obfuscate with BitMono at the end, i.e:

- Use ConfuserEx;
- Some other tools if you want and have;
- Then Use BitMono


================================================
File: docs/source/bestpractices/zero-risk-obfuscation.rst
================================================
Zero Risk of Obfuscation
========================

You may have a project which is really heavy and you don't want to loose any perfomance of it, so, well, you can't really have zero losses of perfomance but you can minimize it, due to BitMono is not really stable with all runtimes and this is very complex obfuscation, would really recommend to use this, as we call it `BitMono Starter Pack for Mono` - like in Fortnite :D
 
1. AntiDecompiler
2. BitMethodDotnet
3. BitTimeDateStamp
4. BitDotNet
5. BitMono
6. (Not optional) StringsEncryption, if you really-really need to encrypt strings, this may very-very-very harmful to the application's performance


`protections.json` will look like this:

.. code-block:: json

	{
	  "Protections": [
	    {
	      "Name": "AntiILdasm",
	      "Enabled": false
	    },
	    {
	      "Name": "AntiDe4dot",
	      "Enabled": false
	    },
	    {
	      "Name": "ObjectReturnType",
	      "Enabled": false
	    },
	    {
	      "Name": "NoNamespaces",
	      "Enabled": false
	    },
	    {
	      "Name": "FullRenamer",
	      "Enabled": false
	    },
	    {
	      "Name": "AntiDebugBreakpoints",
	      "Enabled": false
	    },
	    {
	      "Name": "StringsEncryption",
	      "Enabled": false
	    },
	    {
	      "Name": "UnmanagedString",
	      "Enabled": false
	    },
	    {
	      "Name": "DotNetHook",
	      "Enabled": false
	    },
	    {
	      "Name": "CallToCalli",
	      "Enabled": false
	    },
	    {
	      "Name": "AntiDecompiler",
	      "Enabled": true
	    },
	    {
	      "Name": "BitMethodDotnet",
	      "Enabled": true
	    },
	    {
	      "Name": "BitTimeDateStamp",
	      "Enabled": true
	    },
	    {
	      "Name": "BitDotNet",
	      "Enabled": true
	    },
	    {
	      "Name": "BitMono",
	      "Enabled": true
	    }
	  ]
	}


================================================
File: docs/source/configuration/exclude-obfuscation.rst
================================================
Exclude member from being obfuscated
====================================

Let's say you have something specific that you don't want to protect, in this case you can add an ``[ObfuscationAttribute]`` and specify there protection name.

.. note::

    Set to false the ``ObfuscationAttributeObfuscationExclude`` parameter in ``obfuscation.json``, to ignore these attributes.


.. code-block:: csharp

	using System;
	using System.Xml.Serialization;
	using System.Runtime.CompilerServices;
	using Newtonsoft.Json;
	
	[assembly: Obfuscation(Feature = "DotNetHook")] // Ignoring whole assembly or in the AssemblyInfo.cs (sometimes it would not exist in your project)
	[assembly: Obfuscation(Feature = "NoNamespaces")] // Ignoring whole assembly or in the AssemblyInfo.cs (sometimes it would not exist in your project)
	namespace Project
	{
	}
	
	// Enough to add attribute to whole class type to ignore obfuscation of concrete protection
	[Obfuscation(Feature = "FullRenamer")] // Add this attribute to ignore renaming of method
	class MyClass
	{
	    [MethodImpl(MethodImplOptions.NoInlining)] // Add this attribute to ignore renaming of method
	    void MyMethod()
	    {
	        // potential critical code used to be here
	    }
	
	    // Add this attribute to ignore renaming of method
	    [Obfuscation(Feature = "ObjectReturnType")]  // This attribute is won`t work in this case, because 'MyClass' has attribute with the same feature and `ApplyToMembers` set to true
	    [Obfuscation(Feature = "CallToCalli")] 
	    void MyAnotherMethod()
	    {
	        // potential critical code used to be here
	    }
	}
	
	// Obfuscation will be still applied to the inherted type
	[Obfuscation(Feature = "BitDotNet")] // Adding ObfuscationAttribute once is enough to ignore members
	public interface IInterface
	{
	    string Text { get; }
	
	    [Obfuscation(Feature = "FullRenamer")]
	    Task DoSomethingAsync();
	}
	
	// IInterface obfuscation attribute doesn`t work in implementation
	[Obfuscation(Feature = "FullRenamer")] // Adding ObfuscationAttribute once is enough to ignore members
	public class InterfaceImplementation : IInterface
	{
	    public string Text { get; }
	
	    [Obfuscation(Feature = "BitMethodDotnet")]
	    public Task DoSomethingAsync()
	    {
	        return Task.CompletedTask;
	    }
	}
	
	
	[Serializable] // Marking as serializable attribute is enough to ignore everything in this model
	class ProductModel
	{
	    [XmlAttribute("Product Name")] // Marking as Xml attribute
	    string Name { get; set; }
	    [JsonProperty("Product Description")] // Or marking as Json Property
	    string Description { get; set; }
	    [XmlAttribute("Product Price")]
	    double Price { get; set; }
	}


================================================
File: docs/source/configuration/protections.rst
================================================
Protections
===========

Let's say you want to execute the same protection twice or even execute protections in a different orders, etc.

Keep in mind:

- The order of execution is determined by the position of each protection in the ``protections.json`` file within the configuration file. For example, AntiILdasm is executed first (because this protection is first in configuration) and Packers always run last after all protections, even if you set this ``Packer`` protection as a first one in configuration it will anyway gonna be called last.

Use ``protections.json`` - by default all protections are configured as they should, if something works not as intentionally you always may disable something, enable and even remove.
Default config (it can be different with new updates, but just let's see how it looks like):


.. code-block:: json

	{
	  "Protections": [
	    {
	      "Name": "AntiILdasm", // This is going to be executed first
	      "Enabled": false
	    },
	    {
	      "Name": "AntiDe4dot",
	      "Enabled": false
	    },
	    {
	      "Name": "ObjectReturnType",
	      "Enabled": false
	    },
	    {
	      "Name": "NoNamespaces",
	      "Enabled": false
	    },
	    {
	      "Name": "FullRenamer",
	      "Enabled": true
	    },
	    {
	      "Name": "AntiDebugBreakpoints",
	      "Enabled": false
	    },
	    {
	      "Name": "StringsEncryption",
	      "Enabled": false
	    },
	    {
	      "Name": "DotNetHook",
	      "Enabled": false
	    },
	    {
	      "Name": "CallToCalli",
	      "Enabled": false
	    },
	    {
	      "Name": "AntiDecompiler",
	      "Enabled": false
	    },
	    {
	      "Name": "BitMethodDotnet",
	      "Enabled": false
	    },
	    {
	      "Name": "BitTimeDateStamp", // Packer
	      "Enabled": false
	    },
	    {
	      "Name": "BitDotNet", // Packer
	      "Enabled": true
	    },
	    {
	      "Name": "BitMono", // This is going to be executed last because its a Packer, even if you put this before AntiILdasm it going to be called last anyway.
	      "Enabled": true
	    }
	  ]
	}


================================================
File: docs/source/configuration/third-party-issues.rst
================================================
Excluding Having issues with third parties (API Libraries)
==========================================================

Let's say you have something specific that you don't want to protect, you can specify their constant "names".

In this case you've to use ``criticals.json``, add to ``CriticalMethods``, ``CriticalInterfaces``, ``CriticalBaseTypes`` etc, your potential critical things if you have them.

.. note::

    There is already supported all ``Unity`` methods and third-party frameworks such as ``RocketMod``, ``rust-oxide-umod``, ``OpenMod``.


.. code-block:: json

	{
	  // DO NOT write here all of your methods/things because if you rename them in VS/Rider/VS Code (eg, with hotkey CTRL + R + R/without hotkey, doesn't matter)
	  // whatever else, they're not will be changed here as well.
	  // This is not for complex things, just write here your critical things - it means: for example, imagine Unity there are a lot of methods
	  // which doesn't even have an 'override' i.e 'override void Update()' (which is called every tick) - just void Update(), in such cases these methods
	  // shouldn't be renamed because this is like const things for Unity, and they're very important, 
	  // for complex things use [ObfuscationAttribute(Feature = "ProtectionName")],
	  // but if you don't have plans with the mess in your code, and you don't really have plans in near future to rename these critical things it can be done 	then.
	  
	  // Exclude from obfuscation if the member has attribute
	  // Set to true indicates whether enabled
	  "UseCriticalAttributes": true,
	  "CriticalAttributes": [
	    // Unity
	    {
	      "Namespace": "UnityEngine",
	      "Name": "SerializeField"
	    },
	
	    // "Magic name" attributes, please use instead special library if you need to add features from newer C# versions in older
	    // eg add record types, or "magic name" attributes, etc
	    // special library: https://github.com/Sergio0694/PolySharp (In Mono works fine)
	    {
	      "Namespace": "System.Runtime.CompilerServices",
	      "Name": "ModuleInitializerAttribute"
	    }
	
	  ],
	  // Exclude from obfuscation if the Model (type, i.e class) has [Serializable]/[JsonProperty], etc, attributes
	  // Set to true indicates whether enabled
	  "UseCriticalModelAttributes": true,
	  "CriticalModelAttributes": [
	    {
	      "Namespace": "System",
	      "Name": "SerializableAttribute"
	    },
	    {
	      "Namespace": "System.Xml.Serialization",
	      "Name": "XmlAttributeAttribute"
	    },
	    {
	      "Namespace": "System.Xml.Serialization",
	      "Name": "XmlArrayItemAttribute"
	    },
	    {
	      "Namespace": "Newtonsoft.Json",
	      "Name": "JsonPropertyAttribute"
	    }
	    
	  ],
	  // Exclude from obfuscation if the type inherited specific interface
	  // Set to true indicates whether enabled
	  "UseCriticalInterfaces": true,
	  "CriticalInterfaces": [
	    // RocketMod
	    "IRocketPlugin",
	    "IRocketCommand",
	    "IRocketPluginConfiguration",
	    "IDefaultable",
	
	    // OpenMod
	    "IOpenModPlugin"
	
	  ],
	  // Exclude from obfuscation if the type inherited specific base type
	  // Set to true indicates whether enabled
	  "UseCriticalBaseTypes": true,
	  "CriticalBaseTypes": [
	    // RocketMod
	    "RocketPlugin",
	
	    // OpenMod
	    "OpenModUnturnedPlugin",
	    "OpenModUniversalPlugin",
	    "Command",
	
	    // rust-oxide-umod
	    "RustPlugin"
	
	  ],
	  // Exclude from obfuscation method by name
	  // Set to true indicates whether enabled
	  "UseCriticalMethods": true,
	  "CriticalMethods": [
	    // Unity
	    "Awake",
	    "OnEnable",
	    "Reset",
	    "Start",
	    "FixedUpdate",
	    "OnMouseUp",
	    "OnMouseEnter",
	    "OnMouseExit",
	    "OnMouseOver",
	    "OnMouseUpAsButton",
	    "OnMouseDown",
	    "OnMouseDrag",
	    "Update",
	    "LateUpdate",
	    "OnAnimatorIK",
	    "OnPreCull",
	    "OnWillRenderObject",
	    "OnBecameVisible",
	    "OnBecameInvisible",
	    "OnPreRender",
	    "OnRenderObject",
	    "OnDrawGizmos",
	    "OnGUI",
	    "OnTriggerEnter",
	    "OnTriggerStay",
	    "OnTriggerExit",
	    "OnTriggerEnter2D",
	    "OnTriggerStay2D",
	    "OnTriggerExit2D",
	    "OnCollisionEnter",
	    "OnCollisionStay",
	    "OnCollisionExit",
	    "OnCollisionEnter2D",
	    "OnCollisionStay2D",
	    "OnCollisionExit2D",
	    "WaitForEndOfFrame",
	    "OnApplicationPause",
	    "OnApplicationQuit",
	    "OnDisable",
	    "OnDestroy"
	
	  ]
	}


================================================
File: docs/source/developers/configuration.rst
================================================
Configuration
=============

Injecting Configuration(s) in Protection constructor.
BitMono have such configuartions and all of them you can inject in your protection constructor:

- ProtectionSettings
- CriticalsSettings
- ObfuscationSettings


Here's example how to do that:


.. code-block:: csharp

	public class MagicProtection : Protection
	{
		private readonly ProtectionSettings _protectionSettings;
		private readonly CriticalsSettings _criticalsSettings;
		private readonly ObfuscationSettings _obfuscationSettings;
	
		public MagicProtection(
			IOptions<ProtectionSettings> protectionSettings,
			IOptions<CriticalsSettings> criticalsSettings,
			IOptions<ObfuscationSettings> obfuscationSettings,
			IServiceProvider serviceProvider) : base(serviceProvider)
		{
			_protectionSettings = protectionSettings.Value;
			_criticalsSettings = criticalsSettings.Value;
			_obfuscationSettings = obfuscationSettings.Value;
		}	
	}


================================================
File: docs/source/developers/do-not-resolve-members.rst
================================================
Do Not Resolve Members
======================


.. warning::

    Be careful, because ``Context.Module`` (ModuleDefinition) doesn't affected by ``DoNotResolveAttribute``.


For comfort BitMono provides an API which able to do not pass specfic members inside of the protection for easier understanding and abstraction let's call ``members`` as - types/methods/fields/properties, etc.


.. code-block:: csharp
    
    public override Task ExecuteAsync()
    {
        Context.Parameters.Members
    }


Everything which is passed inside of the ``Context.Parameters.Members`` is all members which were found inside of the module and sorted by BitMono (skipped members with [ObfuscationAttribute] and [DoNotResolveAttribute], etc), and passed using ``IMetadataMember`` AsmResolver's APIs.


.. code-block:: csharp
    
    public List<IMetadataMember> Members { get; }


That's mean if you will specify attribute on your protection and say I want all members but please, I'm writing my own renamer and I don't want to get members which were used somewhere by reflection, right?
Add attribute ``[DoNotResolve(MemberInclusionFlags.Reflection)]`` with ``MemberInclusionFlags.Reflection`` parameter.


.. code-block:: csharp
    
	[DoNotResolve(MemberInclusionFlags.Reflection)]
	public class MagicProtection : Protection



You can specify multiple inclusion flags.


.. code-block:: csharp

    [DoNotResolve(MemberInclusionFlags.SpecialRuntime | MemberInclusionFlags.Reflection)]
    public class MagicProtection : Protection


THIS IS TOTALLY BAD AND WRONG! Sorting doesn't affects to the actual Module.


.. code-block:: csharp
    
    public override Task ExecuteAsync(ProtectionParameters parameters)
    {
        foreach (var type in Context.Module.GetAllTypes())
        {
    
        }
    }



Instead highly recommend to use this.


.. code-block:: csharp

    public override Task ExecuteAsync(ProtectionParameters parameters)
    {
        foreach (var type in parameters.Members.OfType<TypeDefinition>())
        {
    
        }
    }


This is also was wrong because if you will try to get access to the ``type.Methods``, etc, methods are not sorted, use specificly what you need, for example.


Need access to the types and methods? Then do this.


.. code-block:: csharp

    public override Task ExecuteAsync(ProtectionParameters parameters)
    {
        foreach (var type in parameters.Members.OfType<TypeDefinition>())
        {
    
        }
        foreach (var type in parameters.Members.OfType<MethodDefinition>())
        {
    
        }
    }


Need access to the methods? Then just iterrate through the methods.


.. code-block:: csharp

    public override Task ExecuteAsync(ProtectionParameters parameters)
    {
        foreach (var type in parameters.Members.OfType<MethodDefinition>())
        {
    
        }
    }


================================================
File: docs/source/developers/first-protection.rst
================================================
Creating your first Protection
==============================

.. warning::

    BitMono provides a lot of examples in source code with existing protection and maximum functional usage, you can find them in BitMono.Protections project.


Create your protection in the ``BitMono.Protections`` namespace.

- The Dependency Injection (DI) container will automatically register your protections.
- The BitMono Obfuscation Engine will invoke your protection based on its type and the order specified in the configuration file.
- The order of execution is determined by the position of each protection in the ``protections.json`` file within the configuration file. For example, AntiILdasm is executed first (because this protection is first in configuration) and Packers always run last after all protections, even if you set this ``Packer`` protection as a first one in configuration it will anyway gonna be called last.


.. code-block:: csharp
	
	public class StandardProtection : Protection
	{
	    // Inject services right here
	    public StandardProtection(IServiceProvider serviceProvider) : base(serviceProvider)
	    {
	    }
	
	    public override Task ExecuteAsync()
	    {
	        // All protection are intended to be async, so you can simply await your things, or if you don't have,
	        // then use Task.CompletedTask
	        return Task.CompletedTask;
	    }
	}


================================================
File: docs/source/developers/native-code.rst
================================================
Native Code
###########

If you want to use a native code in the protection you must do the following:


.. code-block:: csharp

    [ConfigureForNativeCode] // Add this attribute on top of the protection class
    public class CustomProtection : Protection


A good example is ``UnmanagedString`` protection. It uses native code to encrypt strings. You can find the source code in the ``UnmanagedString`` file.

This thing is so important to do, before actually it was automatically done before the obfuscation without any attributes, however we found that this might break an app, because it changes the architecture of the app, so we decided to make it optional.


================================================
File: docs/source/developers/obfuscate-build.rst
================================================
Automated Build and Obfuscation
===============================

You can make an automatic obfuscation of your build, for example, using ``MSBuild`` (i.e., your ``.csproj`` file) by implementing logic that runs BitMono on your output file before the build ``Task``. This process can be triggered whenever you execute ``dotnet build`` or simply press ``Build`` in your IDE.

BitMono already supports exit codes at the end of the obfuscation process, making it compatible with most tools, including ``MSBuild``. You can retrieve the exit code to determine if the obfuscation was successful or not.

- ``0`` - Obfuscation was successful.
- ``1`` - Obfuscation failed.


================================================
File: docs/source/developers/obfuscation-execution-order.rst
================================================
Obfuscation Engine Execution Order
==================================

BitMono uses its own obfuscation execution order which is good to be known, and it reminds ConfuserEx a lot, if you're familiar with it you can be easier with it.

1. Output Loaded Module Info
2. Output Information about BitMono (example, is it intended for .NET Core or Mono or .NET Framework, etc.) and running OS, etc.
3. Output Compatibility Issues in case of module is built for .NET Framework, but BitMono is running on .NET Core, or vice versa.
4. Sort Protections
5. Information about Protections
6. Configuration for Native Code
7. Elapsed time counter
8. Resolve References
9. Expand Macros
11. Run Protection, PipelineProtection and child pipeline protections


.. code-block:: csharp

	public class StandardProtection : Protection

	public class Pipeline : PipelineProtection


12. Optimize Macros
13. [ObfuscationAttribute] cleanup
14 Create PE Image
15. Write Module
16. Run Packers


.. code-block:: csharp

	public class Packer : PackerProtection


17. Output Elapsed Time since obfuscation 


================================================
File: docs/source/developers/protection-runtime-moniker.rst
================================================
Protection Runtime Moniker
==========================

You have protection that works only with specific runtime and you want to let it know to the user.
By default BitMono provides an opportunity to talk with the users, to warn them, like be careful, this protection working only with ``Mono``.

.. code-block:: csharp

	[RuntimeMonikerMono] // Add this Attribute which says this protections works only with Mono Runtime
	public class MonoPacker : Packer


If you will check what's going on under the hood, you will see that it simply specifies ``Mono`` inside of the constructor.


.. code-block:: csharp

	[AttributeUsage(AttributeTargets.Class, Inherited = false)]
	public class RuntimeMonikerMonoAttribute : RuntimeMonikerAttribute
	{
		// public const string Mono = "Mono";
	    public RuntimeMonikerMonoAttribute() : base(KnownRuntimeMonikers.Mono)
	    {
	    }
	}


If you will go further, you can see what's actually going on here, it says ``Intended for Mono runtime``, so that means to the endpoint user it will output this information and warn they.


.. code-block:: csharp

	[AttributeUsage(AttributeTargets.Class, Inherited = false)]
	[SuppressMessage("ReSharper", "MemberCanBePrivate.Global")]
	public abstract class RuntimeMonikerAttribute : Attribute
	{
	    protected RuntimeMonikerAttribute(string name)
	    {
	        Name = name;
	    }
	
	    public string Name { get; }
	
	    [SuppressMessage("ReSharper", "VirtualMemberNeverOverridden.Global")]
	    public virtual string GetMessage()
	    {
	        return $"Intended for {Name} runtime";
	    }
	}


Let's create your own Rust Runtime Moniker Attribute.


.. code-block:: csharp

	public class RuntimeMonikerRustAttribute : RuntimeMonikerAttribute
	{
	    public RuntimeMonikerRustAttribute() : base("Rust")
	    {
	    }
	}



Specify Rust Runtime Moniker Attribute.


.. code-block:: csharp

	[RuntimeMonikerRust] // Add this Attribute which says this protections works only with Rust Runtime
	public class RustPacker : Packer // or instead use Protection or PipelineProtection



After that user need to use the ``RustPacker`` and they will receive an message that the ``RustPacker`` "is intended for Rust runtime".



.. note::

	You don't need to make any services registration or instance creation for the ``RuntimeMonikerRust`` due to it will get the attribute automatically behind the hood using Reflection, and Protections Info Output in the Console/GUI (whatever is used, user will get a message notification about that). So, you don't need to care about ``RuntimeMonikerRust`` anymore, simply add it on top of the feature and have fun!


================================================
File: docs/source/developers/which-base-protection-select.rst
================================================
Which base Protection better to select and why?
===============================================

Since BitMono contains inside the heart 3 different types of protection, it's very necessary to understand what you're working on and what type of protection you need to select.

So, 3 different type of protections:

1. Protection
2. PipelineProtection
3. PackerProtection

First of all, you need to understand what kinda type of work your protection is going to do

- You need something for fast testing and access to the Module then simply use ``Protection``
- If you need access to the Module and you want to modify it you can use ``Protection``
- You want to split your protection into different layers with access to the Module, e.g, populating of child protection then you can use ``PipelineProtection``
- You don't need access to the Module, but, if you want to change the actual file structure i.e modify ``PE``, then ``PackerProtection`` is your choice, actually you can have an access to the Module, but you need to rewrite it again because at this point file is already written.


================================================
File: docs/source/faq/costura-support.rst
================================================
Does BitMono provide Costura-Fody Support by default?
=====================================================

Indeed, by default BitMono provides support for the Costura-Fody, resources will be resolved automatically, in this case, you don't need to have copies of your .DLLs or even set ``DisableCleanup`` to ``true`` in ``FodyWeavers.xml``.


================================================
File: docs/source/faq/disable-path-masking.rst
================================================
How to disable path masking?
============================

You're probably getting a message with the file/directory or just a path ``(***\things)``, and you might have the same folder twice somewhere, and you need to see the full path without masking if this is what you're looking for, all instructions how to do that are provided here.

Open-up ``logging.json`` in the root of the downloaded BitMono, edit this file, and remove this:

.. code-block:: json

	"Enrich": [
            {
                "Name": "WithSensitiveDataMasking",
                "Args": {
                    "options": {
                        "MaskValue": "***\\",
                        "MaskProperties": [ "path", "directory", "file" ],
                        "MaskingOperators": [ "BitMono.Host.Extensions.PathMaskingOperator, BitMono.Host" ]
                    }
                }
            },
        ],


So, after edit ``logging.json`` looks like this:

.. code-block:: json

	{
	    "Serilog": {
	        "Using": [
	            "Serilog",
	            "Serilog.Sinks.Console",
	            "Serilog.Sinks.File",
	            "Serilog.Sinks.Async",
	            "Serilog.Enrichers.Sensitive"
	        ],
	        "WriteTo": [
	            {
	                "Name": "Async",
	                "Args": {
	                    "configure": [
	                        {
	                            "Name": "File",
	                            "Args": {
	                                "path": "logs/bitmono-{{date}}.log",
	                                "outputTemplate": "[{Timestamp:yyyy-MM-dd HH:mm:ss} {Level:u3}][{SourceContext}] {Message:lj}{NewLine}{Exception}"
	                            }
	                        }
	                    ]
	                }
	            }
	        ],
	        "Enrich": [
	            "FromLogContext"
	        ],
	        "MinimumLevel": "Debug"
	    }
	}


================================================
File: docs/source/faq/unable-to-reference-after-protect.rst
================================================
Unable to Reference After Protection
====================================

If you're having trouble referencing your ``.dll`` file after protecting it with BitMono, follow these steps:

1. **Keep an Original Copy**: Always keep an original, unprotected copy of your ``.dll`` file. This will be used as a reference in your IDE or other tools.

2. **Protect the DLL**: Use BitMono to protect your ``.dll`` file.

3. **Set Up Output Folder**: In your output folder (e.g., ``Release\...``), place the protected version of your ``.dll`` file.

By following these steps, you can ensure that your project references the original ``.dll`` while deploying the protected version.


================================================
File: docs/source/faq/when-and-why-use-bitmono.rst
================================================
When and why use BitMono?
=========================

You know the answer, but let me open your eyes.

There are a lot of obfuscators/protectors, paid and free but most of them are out of support, more and more often I see new issues/pull-request, but it's just being ignored by the open-source maintainers, this is sad. I have no doubt that BitMono could have such a future too, but, at any moment BitMono can be easily forked and supported by anyone, because of its clean code, architecture, and AsmResolver as an assembly manipulator.

- Write your own protection, but you don't want to use ConfuserEx engine or writing your own.
- Protect your intelictual property against reversers, at least, let them spend more time on it.
- Protect yourself against skids.
- Protect game cheat against anti-cheats.
- Contribute to the BitMono.


================================================
File: docs/source/obfuscationissues/compatibility.rst
================================================
The module is built for ...
===========================

Understanding Compatibility
---------------------------

When using BitMono for obfuscation, it's critical to ensure that the version of BitMono matches the framework your application is built on. 

For example, if your application is built on .NET Core, you **must** use the version of BitMono that is also built for .NET Core. Using an incompatible version will result in your application not functioning after obfuscation.

.. note:: 
   A common error message you may encounter is:  
   ``The module is built for .NET (Core), but you're using a version of BitMono intended for .NET Framework.``
   This indicates a mismatch between your app's framework and BitMono's version.

Examples of Compatibility
--------------------------

Here are some examples of correct and incorrect configurations:

**✅ Good Configurations:**

- **BitMono for .NET Core** with an application built on **.NET Core**
- **BitMono for .NET Framework** with an application built on **.NET Framework**

**❌ Bad Configurations (These Won't Work!):**

- **BitMono for .NET Core** with an application built on **.NET Framework**
- **BitMono for .NET Framework** with an application built on **.NET Core**

Key Takeaways
-------------

- Always ensure that **BitMono's framework version** matches the **framework version** of your application.
- Incompatible configurations will break your app after obfuscation.
- Carefully check the framework version of both your app and the BitMono release you are using.

.. warning:: 
   Mixing framework versions (e.g., using BitMono for .NET Framework with a .NET Core app) will cause the app to fail after obfuscation.


================================================
File: docs/source/obfuscationissues/corlib-not-found.rst
================================================
CorLib not found
================

The problem
-----------
You're getting an error it says: `Could not load file or assembly CorLib Version=x.x.x.x, etc` 


Solution
--------
The thing that may cause this issue is that you're running on .NET Framework (the obfuscator project) and the actual obfuscator project is running on .NET Core (let's say - 6.0), and you're trying to run the obfuscated file on Mono, you might already catch the problem, you need to change the obfuscator project TargetFramework (i.e in this case to .NET Framework) to approximately the same version as target file for obfuscation.


================================================
File: docs/source/obfuscationissues/intended-for.rst
================================================
Intended for ... runtime
========================

`Intended for Mono runtime` and `Intended for .NET Core runtime` are normal messages, but normal if you know what you're doing.

`BitDecompiler` - `Intended for Mono runtime` - means the protection is only working on Mono runtime, in this case this protection only work with Mono because it uses a bugs of Mono to hide some stuff in decompilers, however if you run that app in default .NET it won't work.


================================================
File: docs/source/obfuscationissues/ready-to-run.rst
================================================
ReadyToRun
==========

If you're encountering an error from BitMono regarding ReadyToRun, or your application is built using ReadyToRun, it means that your application is "protected" by being compiled into native code. However, BitMono cannot obfuscate it because it requires "managed" code.

To solve this issue, you can do the following:

Disable ReadyToRun
------------------

Simply go to your `.csproj` file, add the `PublishReadyToRun` option and set it to `false`. This will look like the following:

.. code-block:: xml

    <Project Sdk="Microsoft.NET.Sdk">
        <PropertyGroup>
            <OutputType>Exe</OutputType>
            <TargetFramework>net8.0</TargetFramework>
            <ImplicitUsings>enable</ImplicitUsings>
            <Nullable>enable</Nullable>
            <PublishReadyToRun>false</PublishReadyToRun> <!-- Add this option and set to false -->
        </PropertyGroup>
    </Project>


Now, build the project and use `.dll` file that has a managed code, instead of native code.

For more information `see here <https://learn.microsoft.com/en-us/dotnet/core/deploying/ready-to-run>`_

Use .dll File with Managed Code Instead of .exe File
----------------------------------------------------

Usually, in the output folder of your project (if it's a `.exe`), there should be a `.dll` file with managed code. Use this `.dll` file for obfuscation instead, if there's no such file or it has a native code then use upper solution.

Didn't Help?
------------

If none of the solutions worked, it likely means your file is either protected or broken. If this isn't the case, please open an issue on the BitMono GitHub repository or reach out to us on Discord for further assistance.


================================================
File: docs/source/protection-list/overview.rst
================================================
What is a Protection List?
==========================

A protection list is a collection of stable security features designed to work with a specific framework or runtime environment, such as Unity, Mono, or .NET 8 or lower or higher.

Each list is tailored to the unique characteristics of these platforms, ensuring compatibility and reliable protection, so you don't need to find/test a list that fits your enviroment/runtime, we did it for you.

For sure, after reading through the list you can build a correct protections config that fits you!


================================================
File: docs/source/protection-list/unity.rst
================================================
Unity Protections
=================

This section lists various protections compatible with the `Unity Engine <https://unity.com/>`_. 

Unity Runtime is typically based on the .NET Framework 4.*, depending on the Unity version in use. However, it is primarily executed on `Mono <https://github.com/mono/mono>`_, with Unity using its `own fork of Mono <https://github.com/Unity-Technologies/mono>`_ specifically for Unity Runtime. 

You can also refer to this list for Mono runtime protections, but be aware that while Unity's Mono fork is similar to the standard Mono runtime, there may be differences that could impact compatibility.

Protection List
---------------

- **StringsEncryption**  
  Can significantly slow down your application.

- **BitDotNet**  
  Do not use with Unity versions higher than 2020.*. and instead use BitDecompiler

- **BitMethodDotnet**

- **DotNetHook**

- **CallToCalli**

- **ObjectReturnType**  
  Unstable.

- **NoNamespaces**  
  May cause issues if you rely heavily on Reflection.

- **FullRenamer**  
  May cause issues if you rely heavily on Reflection.

- **AntiDebugBreakpoints**  
  Unstable.

- **AntiDecompiler**

- **BitDecompiler**

- **BitDateTimeStamp**

- **BitMono**

- **BillionNops**

- **AntiDe4dot**

- **AntiILdasm**

Additional Considerations
-------------------------

- Some of these protections may not be suitable for all Unity versions or Mono runtimes.
- When using optional protections like `NoNamespaces` or `FullRenamer`, ensure to test thoroughly if your application uses extensive Reflection, as they might break functionality.


================================================
File: docs/source/protections/antide4dot.rst
================================================
AntiDe4dot
==========

How it works?
-------------

Protection adds multiple attributes of known obfuscators/protectors and as a result fools de4dot.

Protection Type
---------------

The protection type is `Protection`.


.. warning::

    Due to protection is not really powerful and widely known by most reversers and skids, on GitHub you may see a lot of solutions to destroy this protection.


================================================
File: docs/source/protections/antidebugbreakpoints.rst
================================================
AntiDebugBreakpoints
====================

How it works?
-------------

Protection adds things in method bodies that check if from the last execution passed more than the const value, then as a result the program will be crashed.

Protection Type
---------------

The protection type is `Protection`.


================================================
File: docs/source/protections/antidecompiler.rst
================================================
AntiDecompiler
==============

How it works?
-------------

Protection looks for a nested type in <Module> and sets non-public accessibility attributes, according to ECMA CIL standard nested types should always have one of them applied, but Mono doesn't care about this standard.

That means if someone will try to analyze the protected nested type, dnSpy will crash, however in a newer version, this exploit was fixed.

Protection Type
---------------

The protection type is `Packer`.


.. warning::

    This protection compatible only with Mono.


================================================
File: docs/source/protections/antiildasm.rst
================================================
AntiILdasm
==========

How it works?
-------------

Protection adds ``[SuppressIldasmAttribute]`` which prevents the Ildasm (IL Disassembler) from disassembling the protected file.

Protection Type
---------------

The protection type is `Protection`.


================================================
File: docs/source/protections/billionnops.rst
================================================
BillionNops
===========

History
-------

You might already know this protection because it's so popular and well known in many obfuscators, it is very simple protection but can cause a lot of headaches.

How it works?
-------------

Protection adds a new dummy method in the Module and then adds 100.000 nop instructions, and ret at the end.

As a result when someone will try to analyze this method will cause a crashed dnSpy, and it will lead a reverse engineer install old dnSpy or use a IDE/VS Code/LinqPad with installed AsmResolver or dnlib to remove this method.

Cons
----

Be careful because this protection will increase a file size a lot, and a bigger file size will cause more questions by users, most of us when see a big file size think that this file is obfuscated.

Protection Type
---------------

The protection type is `Protection`.


================================================
File: docs/source/protections/bitdecompiler.rst
================================================
BitDecompiler
=============

How it works?
-------------

This protection works the same as BitDotnet protection, but with some fixes. However, since after Unity 2021 and higher it stopped working correctly and since many of users asked to figure something out we made this protection as a solution =)

Protection Type
---------------

The protection type is `Packer`.


.. warning::

    This protection compatible only with Mono.


================================================
File: docs/source/protections/bitdotnet.rst
================================================
BitDotNet
=========

How it works?
-------------

The protection uses dnlib exploit and modifies the file metadata (PE) to make it unrecognizable for dnSpy, as the result, at first sight, it will look like not a .NET file, for example, a C++ file.

Mono doesn't care about the thing which dnlib care about, and because of that it does what it does

Protection Type
---------------

The protection type is `Packer`.


.. warning::

    This protection compatible only with Mono.


================================================
File: docs/source/protections/bitmethoddotnet.rst
================================================
BitMethodDotnet
===============

How it works?
-------------

Protection adds invalid IL code in the file, as the result in the old dnSpy version it's going to be harder to see the C# code of the method body.

Protection Type
---------------

The protection type is `Protection`.


.. warning::

    This protection compatible only with Mono, but, as far as is known this protection can be used in old versions of .NET Framework, but literally not with .NET Core, etc.


================================================
File: docs/source/protections/bitmono.rst
================================================
BitMono
=======

How it works?
-------------

Protection modifies the file metadata (PE) to make it unrecognizable for decompilers or other tools such as Detect It Easy, as the result most of the tools will be fooled to think that this is an MS-DOS Executable as Detect It Easy does, decompilers will just not be able to open it up.

Mono doesn't care about the things which decompilers/tools care about, and because of that it does what it does.

Protection Type
---------------

The protection type is `Packer`.


.. warning::

    This protection compatible only with Mono.


================================================
File: docs/source/protections/bittimedatestamp.rst
================================================
BitTimeDateStamp
================

How it works?
-------------

Protection modifies the file metadata (PE) and erases the TimeDateStamp, as the result no one will be able to know when this file was compiled.

Protection Type
---------------

The protection type is `Packer`.


================================================
File: docs/source/protections/calltocalli.rst
================================================
CallToCalli
===========

How it works?
-------------

Protection replaces call opcode to calli and calls method by its function pointer.

Protection Type
---------------

The protection type is `Protection`.


.. warning::

    This protection doesn't work the same way as ConfuserEx Bed's Mod, it works absolutely differently, as you may know in Confuser's mod their `CallToCalli` won't work on Mono, this version of protection works fine with both .NET and Mono.


================================================
File: docs/source/protections/dotnethook.rst
================================================
DotNetHook
==========

How it works?
-------------

Protection hooks methods, as a result, will call empty methods but, in fact, a completely different method will be called (the original one).

Protection Type
---------------

The protection type is `Protection`.


================================================
File: docs/source/protections/fullrenamer.rst
================================================
FullRenamer
===========

How it works?
-------------

Protection renames types/methods/fields, however, ignores things such as reflection, Unity Methods (Update/FixedUpdate/LateUpdate, i.e all of them), overrides from Thanking (OV_methodName), and the most popular frameworks for plugin development in Unturned and Rust on GitHub - RocketMod, OpenMod, and rust-oxide-umod, you even could specify your methods/types to ignore.

If you want you can easily configure `criticals.json` to ignore strings and lot of stuff. 

Be careful, because renamer is tricky protection, not always useful, and does not always work properly. But, if you configure BitMono correctly Renamer can be a great protection (I'm about big projects, not crackmes).

Protection Type
---------------

The protection type is `Protection`.


================================================
File: docs/source/protections/nonamespaces.rst
================================================
NoNamespaces
============

How it works?
-------------

Protection removes all namespaces.

Protection Type
---------------

The protection type is `Protection`.


================================================
File: docs/source/protections/objectreturntype.rst
================================================
ObjectReturnType
================

How it works?
-------------

Protection changes the nonvoid method return types to object return types.

Protection Type
---------------

The protection type is `Protection`.


================================================
File: docs/source/protections/stringsencryption.rst
================================================
StringsEncryption
=================

How it works?
-------------

Protection encrypts strings using basic AES encryption, but not everyone like it because it makes the worse performance of application, but can be used with AntiDecompiler to crash dnSpy while analyzing the used class, also makes the RVA of the byte[] 0

Protection Type
---------------

The protection type is `Protection`.


.. warning::

    This protection slows down the application a lot.


================================================
File: docs/source/protections/unmanagedstring.rst
================================================
UnmanagedString
===============

How it works?
-------------

Protection creates native method with assembly code and protects strings only that can be encoded with `Windows-1252` encoding. 

Protection Type
---------------

The protection type is `Protection`.


.. warning::

    This protection is only compatible with .NET Framework and .NET Core, and doens't work with Mono.


================================================
File: lib/Echo.ControlFlow.deps.json
================================================
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.0/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.0": {},
    ".NETStandard,Version=v2.0/": {
      "Echo.ControlFlow/0.9.0.1": {
        "dependencies": {
          "Echo": "0.9.0.1",
          "Echo.DataFlow": "0.9.0.1",
          "NETStandard.Library": "2.0.3",
          "System.Memory": "4.5.5"
        },
        "runtime": {
          "Echo.ControlFlow.dll": {}
        }
      },
      "Microsoft.NETCore.Platforms/1.1.0": {},
      "NETStandard.Library/2.0.3": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0"
        }
      },
      "System.Buffers/4.5.1": {
        "runtime": {
          "lib/netstandard2.0/System.Buffers.dll": {
            "assemblyVersion": "4.0.3.0",
            "fileVersion": "4.6.28619.1"
          }
        }
      },
      "System.Collections.Immutable/1.7.1": {
        "dependencies": {
          "System.Memory": "4.5.5"
        },
        "runtime": {
          "lib/netstandard2.0/System.Collections.Immutable.dll": {
            "assemblyVersion": "1.2.5.0",
            "fileVersion": "4.700.20.21406"
          }
        }
      },
      "System.Memory/4.5.5": {
        "dependencies": {
          "System.Buffers": "4.5.1",
          "System.Numerics.Vectors": "4.4.0",
          "System.Runtime.CompilerServices.Unsafe": "4.5.3"
        },
        "runtime": {
          "lib/netstandard2.0/System.Memory.dll": {
            "assemblyVersion": "4.0.1.2",
            "fileVersion": "4.6.31308.1"
          }
        }
      },
      "System.Numerics.Vectors/4.4.0": {
        "runtime": {
          "lib/netstandard2.0/System.Numerics.Vectors.dll": {
            "assemblyVersion": "4.1.3.0",
            "fileVersion": "4.6.25519.3"
          }
        }
      },
      "System.Runtime.CompilerServices.Unsafe/4.5.3": {
        "runtime": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "assemblyVersion": "4.0.4.1",
            "fileVersion": "4.6.28619.1"
          }
        }
      },
      "Echo/0.9.0.1": {
        "dependencies": {
          "System.Memory": "4.5.5"
        },
        "runtime": {
          "Echo.dll": {}
        }
      },
      "Echo.DataFlow/0.9.0.1": {
        "dependencies": {
          "Echo": "0.9.0.1",
          "System.Collections.Immutable": "1.7.1"
        },
        "runtime": {
          "Echo.DataFlow.dll": {}
        }
      }
    }
  },
  "libraries": {
    "Echo.ControlFlow/0.9.0.1": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Microsoft.NETCore.Platforms/1.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-kz0PEW2lhqygehI/d6XsPCQzD7ff7gUJaVGPVETX611eadGsA3A877GdSlU0LRVMCTH/+P3o2iDTak+S08V2+A==",
      "path": "microsoft.netcore.platforms/1.1.0",
      "hashPath": "microsoft.netcore.platforms.1.1.0.nupkg.sha512"
    },
    "NETStandard.Library/2.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-st47PosZSHrjECdjeIzZQbzivYBJFv6P2nv4cj2ypdI204DO+vZ7l5raGMiX4eXMJ53RfOIg+/s4DHVZ54Nu2A==",
      "path": "netstandard.library/2.0.3",
      "hashPath": "netstandard.library.2.0.3.nupkg.sha512"
    },
    "System.Buffers/4.5.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-Rw7ijyl1qqRS0YQD/WycNst8hUUMgrMH4FCn1nNm27M4VxchZ1js3fVjQaANHO5f3sN4isvP4a+Met9Y4YomAg==",
      "path": "system.buffers/4.5.1",
      "hashPath": "system.buffers.4.5.1.nupkg.sha512"
    },
    "System.Collections.Immutable/1.7.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-B43Zsz5EfMwyEbnObwRxW5u85fzJma3lrDeGcSAV1qkhSRTNY5uXAByTn9h9ddNdhM+4/YoLc/CI43umjwIl9Q==",
      "path": "system.collections.immutable/1.7.1",
      "hashPath": "system.collections.immutable.1.7.1.nupkg.sha512"
    },
    "System.Memory/4.5.5": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-XIWiDvKPXaTveaB7HVganDlOCRoj03l+jrwNvcge/t8vhGYKvqV+dMv6G4SAX2NoNmN0wZfVPTAlFwZcZvVOUw==",
      "path": "system.memory/4.5.5",
      "hashPath": "system.memory.4.5.5.nupkg.sha512"
    },
    "System.Numerics.Vectors/4.4.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-UiLzLW+Lw6HLed1Hcg+8jSRttrbuXv7DANVj0DkL9g6EnnzbL75EB7EWsw5uRbhxd/4YdG8li5XizGWepmG3PQ==",
      "path": "system.numerics.vectors/4.4.0",
      "hashPath": "system.numerics.vectors.4.4.0.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/4.5.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-3TIsJhD1EiiT0w2CcDMN/iSSwnNnsrnbzeVHSKkaEgV85txMprmuO+Yq2AdSbeVGcg28pdNDTPK87tJhX7VFHw==",
      "path": "system.runtime.compilerservices.unsafe/4.5.3",
      "hashPath": "system.runtime.compilerservices.unsafe.4.5.3.nupkg.sha512"
    },
    "Echo/0.9.0.1": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Echo.DataFlow/0.9.0.1": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    }
  }
}


================================================
File: lib/Echo.ControlFlow.xml
================================================
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Echo.ControlFlow</name>
    </assembly>
    <members>
        <member name="T:Echo.ControlFlow.Analysis.Domination.DominatorTree`1">
            <summary>
            Represents a dominator tree, where each tree node corresponds to one node in a graph, and each
            is immediately dominated by its parent.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.FromGraph(Echo.ControlFlow.ControlFlowGraph{`0})">
            <summary>
            Constructs a dominator tree from a control flow graph.
            </summary>
            <param name="graph">The control flow graph to turn into a dominator tree.</param>
            <returns>The constructed dominator tree.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.GetImmediateDominators(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Computes the dominator tree of a control flow graph, defined by its entrypoint.
            </summary>
            <param name="entrypoint">The entrypoint of the control flow graph.</param>
            <returns>A dictionary mapping all the nodes to their immediate dominator.</returns>
            <remarks>
            The algorithm used is based on the one engineered by Lengauer and Tarjan.
            https://www.cs.princeton.edu/courses/archive/fall03/cs528/handouts/a%20fast%20algorithm%20for%20finding.pdf
            https://www.cl.cam.ac.uk/~mr10/lengtarj.pdf
            </remarks> 
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.ConstructTreeNodes(System.Collections.Generic.IDictionary{Echo.ControlFlow.ControlFlowNode{`0},Echo.ControlFlow.ControlFlowNode{`0}},Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Constructs a dominator tree from the control flow graph.
            </summary>
            <returns>The constructed tree. Each node added to the tree is linked to a node in the original graph by
            its name.</returns>
        </member>
        <member name="P:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.Root">
            <summary>
            Gets the root of the dominator tree. That is, the tree node that corresponds to the entrypoint of the
            control flow graph.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.Item(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Gets the dominator tree node associated to the given control flow graph node.
            </summary>
            <param name="node">The control flow graph node to get the tree node from.</param>
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.Dominates(Echo.ControlFlow.ControlFlowNode{`0},Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Determines whether one control flow graph node dominates another node. That is, whether execution of the
            dominated node means the dominator node has to be executed.
            </summary>
            <param name="dominator">The node that dominates.</param>
            <param name="dominated">The node that is potentially dominated.</param>
            <returns>
            <c>True</c> if the node in <paramref name="dominator"/> indeed dominates the provided control flow
            node in <paramref name="dominated"/>, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.GetDominanceFrontier(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Determines the dominance frontier of a specific node. That is, the set of all nodes where the dominance of
            the specified node stops.
            </summary>
            <param name="node">The node to obtain the dominance frontier from.</param>
            <returns>A collection of nodes representing the dominance frontier.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.Echo#Graphing#ISubGraph#GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.GetSubGraphs">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTree`1.Echo#Graphing#IGraph#GetEdges">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Analysis.Domination.DominatorTreeNode`1">
            <summary>
            Represents a single node in a dominator tree of a graph. 
            </summary>
            <remarks>
            It stores the original control flow graph node from which this tree node was inferred, as well a reference to its
            immediate dominator, and the node it immediate dominates.
            </remarks>
        </member>
        <member name="P:Echo.ControlFlow.Analysis.Domination.DominatorTreeNode`1.Id">
            <inheritdoc/>
        </member>
        <member name="P:Echo.ControlFlow.Analysis.Domination.DominatorTreeNode`1.OriginalNode">
            <summary>
            Gets the node that this tree node was derived from. 
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Analysis.Domination.DominatorTreeNode`1.Children">
            <summary>
            Gets the children of the current node.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTreeNode`1.GetChildren">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTreeNode`1.GetDirectChildren">
            <summary>
            Gets a collection of children representing all nodes that were dominated by the original node, as well as an
            immediate successor of the original node.
            </summary>
            <returns>The children, represented by the dominator tree nodes.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTreeNode`1.GetIndirectChildren">
            <summary>
            Gets a collection of children representing all nodes that were dominated by the original node, but were not
            an immediate successor of the original node.
            </summary>
            <returns>The children, represented by the dominator tree nodes.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Analysis.Domination.DominatorTreeNode`1.GetDominatedNodes">
            <summary>
            Gets all the nodes that are dominated by this control flow graph node.
            </summary>
            <returns>The nodes that are dominated by this node.</returns>
            <remarks>
            Because of the nature of dominator analysis, this also includes the current node.
            </remarks>
        </member>
        <member name="T:Echo.ControlFlow.Blocks.BasicBlock`1">
            <summary>
            Represents one basic block in a control flow graph, consisting of a list of instructions (or statements).
            </summary>
            <typeparam name="TInstruction">The type of instructions that the basic block contains.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.#ctor">
            <summary>
            Creates a new, empty basic block.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.#ctor(System.Int64)">
            <summary>
            Creates a new, empty basic block, with the provided offset.
            </summary>
            <param name="offset">The offset to assign to the basic block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new basic block with the provided instructions. 
            </summary>
            <param name="instructions">The instructions to add to the basic block.</param>
            <exception cref="T:System.ArgumentNullException">Occurs when <paramref name="instructions"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.#ctor(System.Int64,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new basic block with the provided offset and list of instructions. 
            </summary>
            <param name="offset">The offset to assign to the basic block.</param>
            <param name="instructions">The instructions to add to the basic block.</param>
            <exception cref="T:System.ArgumentNullException">Occurs when <paramref name="instructions"/> is <c>null</c>.</exception>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.BasicBlock`1.Offset">
            <summary>
            Gets or sets the offset (or identifier) of this basic block.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.BasicBlock`1.Instructions">
            <summary>
            Gets a collection of instructions that are executed in sequence when this basic block is executed.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.BasicBlock`1.IsEmpty">
            <summary>
            Gets a value indicating whether the basic block contains any instruction.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.BasicBlock`1.Header">
            <summary>
            Gets the first instruction that is evaluated when this basic block is executed.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.BasicBlock`1.Footer">
            <summary>
            Gets the last instruction that is evaluated when this basic block is executed.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.GetFirstBlock">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.GetLastBlock">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.AcceptVisitor(Echo.ControlFlow.Blocks.IBlockVisitor{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BasicBlock`1.AcceptVisitor``2(Echo.ControlFlow.Blocks.IBlockVisitor{`0,``0,``1},``0)">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Blocks.BlockFormatter`1">
            <summary>
            Provides a mechanism for formatting a tree of blocks into an indented string representation.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the block.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.Format(Echo.ControlFlow.Blocks.IBlock{`0})">
            <summary>
            Formats a block into an indented string representation.
            </summary>
            <param name="block">The block to format.</param>
            <returns>The indented string.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.#ctor(System.String)">
            <summary>
            Creates a new block formatter.
            </summary>
            <param name="indentationString">The string to use when indenting a block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.GetOutput">
            <summary>
            Obtains the raw string output.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.VisitBasicBlock(Echo.ControlFlow.Blocks.BasicBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.EnterScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.ExitScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.EnterExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.ExitExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.EnterProtectedBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.ExitProtectedBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.EnterHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.ExitHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.EnterPrologueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.ExitPrologueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.EnterEpilogueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.ExitEpilogueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.EnterHandlerContents(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockFormatter`1.ExitHandlerContents(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Blocks.BlockListenerBase`1">
            <summary>
            Provides an empty base implementation for a block listener.
            </summary>
            <typeparam name="TInstruction">The type of instructions in the blocks.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.VisitBasicBlock(Echo.ControlFlow.Blocks.BasicBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.EnterScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.ExitScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.EnterExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.ExitExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.EnterProtectedBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.ExitProtectedBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.EnterHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.ExitHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.EnterPrologueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.ExitPrologueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.EnterEpilogueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.ExitEpilogueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.EnterHandlerContents(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockListenerBase`1.ExitHandlerContents(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Blocks.BlockWalker`1">
            <summary>
            Provides a mechanism for traversing a scoped block tree in order. 
            </summary>
            <typeparam name="TInstruction"></typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockWalker`1.#ctor(Echo.ControlFlow.Blocks.IBlockListener{`0})">
            <summary>
            Creates a new block walker.
            </summary>
            <param name="listener">The object that responds to traversal events.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockWalker`1.Walk(Echo.ControlFlow.Blocks.IBlock{`0})">
            <summary>
            Traverses a block tree and notifies the listener with traversal events.
            </summary>
            <param name="block">The root of the block tree to traverse.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockWalker`1.VisitBasicBlock(Echo.ControlFlow.Blocks.BasicBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockWalker`1.VisitScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockWalker`1.VisitExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.BlockWalker`1.VisitHandlerBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1">
            <summary>
            Represents a block of region that is protected by a set of exception handler blocks. 
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the blocks.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.ProtectedBlock">
            <summary>
            Gets the protected block.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.Handlers">
            <summary>
            Gets a collection of handler blocks.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.Tag">
            <summary>
            Gets or sets a user-defined tag that is assigned to this block. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.GetAllBlocks">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.GetFirstBlock">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.GetLastBlock">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.AcceptVisitor(Echo.ControlFlow.Blocks.IBlockVisitor{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.AcceptVisitor``2(Echo.ControlFlow.Blocks.IBlockVisitor{`0,``0,``1},``0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Blocks.HandlerBlock`1">
            <summary>
            Represents a single handler block in an <see cref="T:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1"/>.
            </summary>
            <typeparam name="TInstruction">The type of instructions that this block contains.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.HandlerBlock`1.Prologue">
            <summary>
            Gets or sets the prologue block that gets executed before the main handler block (if available).
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.HandlerBlock`1.Contents">
            <summary>
            Gets the main scope block that forms the code for the handler block.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.HandlerBlock`1.Epilogue">
            <summary>
            Gets or sets the epilogue block that gets executed after the main handler block (if available).
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.HandlerBlock`1.Tag">
            <summary>
            Gets or sets a user-defined tag that is assigned to this block. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.HandlerBlock`1.GetAllBlocks">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.HandlerBlock`1.GetFirstBlock">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.HandlerBlock`1.GetLastBlock">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.HandlerBlock`1.AcceptVisitor(Echo.ControlFlow.Blocks.IBlockVisitor{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.HandlerBlock`1.AcceptVisitor``2(Echo.ControlFlow.Blocks.IBlockVisitor{`0,``0,``1},``0)">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Blocks.IBlock`1">
            <summary>
            Represents a single block in structured program code. 
            </summary>
            <typeparam name="TInstruction">The type of instructions that this block contains.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlock`1.GetAllBlocks">
            <summary>
            Gets an ordered collection of all basic blocks that can be found in this block.
            </summary>
            <returns>The ordered basic blocks.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlock`1.GetFirstBlock">
            <summary>
            Gets the first basic block that appears in the ordered list of blocks. 
            </summary>
            <returns>The first basic block, or <c>null</c> if the block contains no basic blocks..</returns>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlock`1.GetLastBlock">
            <summary>
            Gets the last basic block that appears in the ordered list of blocks. 
            </summary>
            <returns>The last basic block, or <c>null</c> if the block contains no basic blocks..</returns>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlock`1.AcceptVisitor(Echo.ControlFlow.Blocks.IBlockVisitor{`0})">
            <summary>
            Visit the current block using the provided visitor.
            </summary>
            <param name="visitor">The visitor to accept.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlock`1.AcceptVisitor``2(Echo.ControlFlow.Blocks.IBlockVisitor{`0,``0,``1},``0)">
            <summary>
            Visit the current block using the provided visitor.
            </summary>
            <param name="visitor">The visitor to accept.</param>
            <param name="state">An argument to pass onto the visitor.</param>
        </member>
        <member name="T:Echo.ControlFlow.Blocks.IBlockListener`1">
            <summary>
            Provides members for listening to events raised by the <see cref="T:Echo.ControlFlow.Blocks.BlockWalker`1"/> class. 
            </summary>
            <typeparam name="TInstruction">The type of instructions in the blocks.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.VisitBasicBlock(Echo.ControlFlow.Blocks.BasicBlock{`0})">
            <summary>
            Visits a basic block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.EnterScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0})">
            <summary>
            Enters a scope block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.ExitScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0})">
            <summary>
            Exits a scope block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.EnterExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <summary>
            Enters an exception handler block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.ExitExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <summary>
            Exits an exception handler block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.EnterProtectedBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <summary>
            Enters the protected region of an exception handler block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.ExitProtectedBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <summary>
            Exits the protected region of an exception handler block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.EnterHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0},System.Int32)">
            <summary>
            Enters a handler region of an exception handler block.
            </summary>
            <param name="block">The block.</param>
            <param name="handlerIndex">The index of the handler that was entered.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.ExitHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0},System.Int32)">
            <summary>
            Exits a handler region of an exception handler block.
            </summary>
            <param name="block">The block.</param>
            <param name="handlerIndex">The index of the handler that was exit.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.EnterPrologueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <summary>
            Enters the prologue region of a handler block.
            </summary>
            <param name="block">The parent handler block this prologue is added to.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.ExitPrologueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <summary>
            Exits the prologue region of a handler block.
            </summary>
            <param name="block">The parent handler block this prologue is added to.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.EnterEpilogueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <summary>
            Enters the epilogue region of a handler block.
            </summary>
            <param name="block">The parent handler block this epilogue is added to.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.ExitEpilogueBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <summary>
            Exits the epilogue region of a handler block.
            </summary>
            <param name="block">The parent handler block this epilogue is added to.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.EnterHandlerContents(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <summary>
            Enters the main code of a handler block.
            </summary>
            <param name="block">The parent handler block this scope is added to.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockListener`1.ExitHandlerContents(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <summary>
            Exits the main code of a handler block.
            </summary>
            <param name="block">The parent handler block this scope is added to.</param>
        </member>
        <member name="T:Echo.ControlFlow.Blocks.IBlockVisitor`1">
            <summary>
            Provides members for visiting blocks in a scoped block tree. 
            </summary>
            <typeparam name="TInstruction">The type of instructions in the blocks.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockVisitor`1.VisitBasicBlock(Echo.ControlFlow.Blocks.BasicBlock{`0})">
            <summary>
            Visits a basic block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockVisitor`1.VisitScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0})">
            <summary>
            Visits a scope block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockVisitor`1.VisitExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0})">
            <summary>
            Visits an exception handler block.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockVisitor`1.VisitHandlerBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0})">
            <summary>
            Visits a handler block inside an <see cref="T:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1"/>.
            </summary>
            <param name="block">The block.</param>
        </member>
        <member name="T:Echo.ControlFlow.Blocks.IBlockVisitor`3">
            <summary>
            Provides members for visiting blocks in a scoped block tree. 
            </summary>
            <typeparam name="TInstruction">The type of instructions in the blocks.</typeparam>
            <typeparam name="TState">The type of state to pass onto the visitor.</typeparam>
            <typeparam name="TResult">The type of the result for every visited block.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockVisitor`3.VisitBasicBlock(Echo.ControlFlow.Blocks.BasicBlock{`0},`1)">
            <summary>
            Visits a basic block.
            </summary>
            <param name="block">The block.</param>
            <param name="state">The argument to pass along the visitor.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockVisitor`3.VisitScopeBlock(Echo.ControlFlow.Blocks.ScopeBlock{`0},`1)">
            <summary>
            Visits a scope block.
            </summary>
            <param name="block">The block.</param>
            <param name="state">The argument to pass along the visitor.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockVisitor`3.VisitExceptionHandlerBlock(Echo.ControlFlow.Blocks.ExceptionHandlerBlock{`0},`1)">
            <summary>
            Visits an exception handler block.
            </summary>
            <param name="block">The block.</param>
            <param name="state">The argument to pass along the visitor.</param>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.IBlockVisitor`3.VisitHandlerBlock(Echo.ControlFlow.Blocks.HandlerBlock{`0},`1)">
            <summary>
            Visits a handler block inside an <see cref="T:Echo.ControlFlow.Blocks.ExceptionHandlerBlock`1"/>.
            </summary>
            <param name="block">The block.</param>
            <param name="state">The argument to pass along the visitor.</param>
        </member>
        <member name="T:Echo.ControlFlow.Blocks.ScopeBlock`1">
            <summary>
            Represents a collection of blocks grouped together into one single block. 
            </summary>
            <typeparam name="TInstruction">The type of instructions that this block contains.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Blocks.ScopeBlock`1.Blocks">
            <summary>
            Gets an ordered, mutable collection of blocks that are present in this scope.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ScopeBlock`1.GetAllBlocks">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ScopeBlock`1.GetFirstBlock">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ScopeBlock`1.GetLastBlock">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ScopeBlock`1.AcceptVisitor(Echo.ControlFlow.Blocks.IBlockVisitor{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ScopeBlock`1.AcceptVisitor``2(Echo.ControlFlow.Blocks.IBlockVisitor{`0,``0,``1},``0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Blocks.ScopeBlock`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Collections.AdjacencyCollection`1">
            <summary>
            Represents a collection of edges originating from a single node.
            </summary>
            <typeparam name="TContents">The type of data that each node stores.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Collections.AdjacencyCollection`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Collections.AdjacencyCollection`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Collections.AdjacencyCollection`1.EdgeType">
            <summary>
            Gets the type of edges that are stored in this collection.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Collections.AdjacencyCollection`1.Owner">
            <summary>
            Gets the node that all edges are originating from.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Add(System.Int64)">
            <summary>
            Creates and adds a edge to the node with the provided address.
            </summary>
            <param name="neighbourAddress">The address of the new neighbouring node.</param>
            <returns>The created edge.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Add(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Creates and adds a edge to the provided node.
            </summary>
            <param name="neighbour">The new neighbouring node.</param>
            <returns>The created edge.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Add(Echo.ControlFlow.ControlFlowEdge{`0})">
            <summary>
            Adds an edge to the adjacency collection.
            </summary>
            <param name="edge">The edge to add.</param>
            <returns>The edge that was added.</returns>
            <exception cref="T:System.ArgumentException">
            Occurs when the provided edge cannot be added to this collection because of an invalid source node or edge type.
            </exception>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.System#Collections#Generic#ICollection{Echo#ControlFlow#ControlFlowEdge{TContents}}#Add(Echo.ControlFlow.ControlFlowEdge{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Contains(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Determines whether a node is a neighbour of the current node. That is, determines whether there exists
            at least one edge between the current node and the provided node.
            </summary>
            <param name="neighbour">The node to check.</param>
            <returns><c>True</c> if the provided node is a neighbour, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Contains(Echo.ControlFlow.ControlFlowEdge{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.CopyTo(Echo.ControlFlow.ControlFlowEdge{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Remove(System.Int64)">
            <summary>
            Removes all edges originating from the current node to the neighbour with the provided address.
            </summary>
            <param name="neighbourAddress">The address of the neighbour to cut ties with.</param>
            <returns><c>True</c> if at least one edge was removed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Remove(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Removes all edges originating from the current node to the provided neighbour.
            </summary>
            <param name="neighbour">The neighbour to cut ties with.</param>
            <returns><c>True</c> if at least one edge was removed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Remove(Echo.ControlFlow.ControlFlowEdge{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.GetEdgesToNeighbour(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Obtains all edges to the provided neighbour, if any.
            </summary>
            <param name="target">The neighbouring node.</param>
            <returns>The edges.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.GetEnumerator">
            <summary>
            Obtains an enumerator that enumerates all nodes in the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Echo.ControlFlow.Collections.AdjacencyCollection`1.Enumerator">
            <summary>
            Represents an enumerator that enumerates all nodes in a control flow graph.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Enumerator.#ctor(Echo.ControlFlow.Collections.AdjacencyCollection{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Collections.AdjacencyCollection`1.Enumerator"/> structure.
            </summary>
            <param name="collection">The collection to enumerate.</param>
        </member>
        <member name="P:Echo.ControlFlow.Collections.AdjacencyCollection`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.AdjacencyCollection`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Collections.NodeCollection`1">
            <summary>
            Represents a mutable collection of nodes present in a graph.
            </summary>
            <typeparam name="TContents">The type of data that is stored in each node.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Collections.NodeCollection`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Collections.NodeCollection`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Collections.NodeCollection`1.Item(System.Int64)">
            <summary>
            Gets a node by its offset.
            </summary>
            <param name="offset">The node offset.</param>
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Add(Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.AddRange(System.Collections.Generic.IEnumerable{Echo.ControlFlow.ControlFlowNode{`0}})">
            <summary>
            Adds a collection of nodes to the graph.
            </summary>
            <param name="items">The nodes to add.</param>
            <exception cref="T:System.ArgumentException">
            Occurs when at least one node in the provided collection is already added to another graph.
            </exception>
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Contains(System.Int64)">
            <summary>
            Determines whether a node with a specific offset was added to the collection.
            </summary>
            <param name="offset">The offset to the node.</param>
            <returns><c>true</c> if there exists a node with the provided offset, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Contains(Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.CopyTo(Echo.ControlFlow.ControlFlowNode{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Remove(System.Int64)">
            <summary>
            Removes a node by its offset.
            </summary>
            <param name="offset">The offset. of the node to remove.</param>
            <returns><c>true</c> if the collection contained a node with the provided offset., and the node was removed
            successfully, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Remove(Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.UpdateOffsets">
            <summary>
            Synchronizes all offsets of each node and basic blocks with the underlying instructions.
            </summary>
            <exception cref="T:System.InvalidOperationException">Occurs when one or more basic blocks referenced by the nodes
            are in a state that new offsets cannot be determined. This includes empty basic blocks and duplicated header
            offsets.</exception>
            <remarks>
            <para>
            Because updating offsets is a relatively expensive task, calls to this method should be delayed as much as
            possible.
            </para>
            <para>
            This method will invalidate any enumerators that are enumerating this collection of nodes.
            </para>
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.GetEnumerator">
            <summary>
            Obtains an enumerator that enumerates all nodes in the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Echo.ControlFlow.Collections.NodeCollection`1.Enumerator">
            <summary>
            Represents an enumerator that enumerates all nodes in a control flow graph.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Enumerator.#ctor(Echo.ControlFlow.Collections.NodeCollection{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Collections.NodeCollection`1.Enumerator"/> structure.
            </summary>
            <param name="collection">The collection to enumerate.</param>
        </member>
        <member name="P:Echo.ControlFlow.Collections.NodeCollection`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.NodeCollection`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Collections.RegionCollection`2">
            <summary>
            Represents a collection of regions found in a control flow graph.
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
            <typeparam name="TRegion">The type of the region to store.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionCollection`2.#ctor(Echo.ControlFlow.Regions.IControlFlowRegion{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Collections.RegionCollection`2"/> class.
            </summary>
            <param name="owner">The owner of the sub regions.</param>
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionCollection`2.InsertItem(System.Int32,`1)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionCollection`2.SetItem(System.Int32,`1)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionCollection`2.ClearItems">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionCollection`2.RemoveItem(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Collections.RegionNodeCollection`1">
            <summary>
            Represents a collection of nodes that are put into  a control flow region.
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionNodeCollection`1.#ctor(Echo.ControlFlow.Regions.IControlFlowRegion{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Collections.RegionNodeCollection`1"/> class.
            </summary>
            <param name="owner">The region owning the collection of nodes.</param>
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionNodeCollection`1.InsertItem(System.Int32,Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionNodeCollection`1.SetItem(System.Int32,Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionNodeCollection`1.RemoveItem(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionNodeCollection`1.ClearItems">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Collections.RegionNodeCollection`1.AddRange(System.Collections.Generic.IEnumerable{Echo.ControlFlow.ControlFlowNode{`0}})">
            <summary>
            Adds a collection of nodes to the node collection.
            </summary>
            <param name="items">The nodes to add.</param>
        </member>
        <member name="T:Echo.ControlFlow.Construction.FlowGraphBuilderBase`1">
            <summary>
            Provides a base for control flow graph builders that depend on a single traversal of the instructions.
            </summary>
            <typeparam name="TInstruction">The type of instructions to store in the control flow graph.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Construction.FlowGraphBuilderBase`1.Architecture">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.FlowGraphBuilderBase`1.ConstructFlowGraph(System.Int64,System.Collections.Generic.IEnumerable{System.Int64})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.FlowGraphBuilderBase`1.CollectInstructions(System.Int64,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Traverses the instructions and records block headers and successor information about each traversed instruction.
            </summary>
            <param name="entrypoint">The address of the first instruction to traverse.</param>
            <param name="knownBlockHeaders">A list of known block headers that should be included in the traversal.</param>
            <returns>An object containing the result of the traversal, including the block headers and successors of
            each instruction.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Construction.IFlowGraphBuilder`1">
            <summary>
            Provides members for building a control flow graph, starting at a specific entrypoint address.
            </summary>
            <typeparam name="TInstruction">The type of instructions that the control flow graph will contain.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Construction.IFlowGraphBuilder`1.Architecture">
            <summary>
            Gets the architecture of the instructions to graph.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.IFlowGraphBuilder`1.ConstructFlowGraph(System.Int64,System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Constructs a control flow graph, starting at the provided entrypoint address.
            </summary>
            <param name="entrypoint">The address of the first instruction to traverse.</param>
            <param name="knownBlockHeaders">A list of known block headers that should be included in the traversal.</param>
            <returns>
            The constructed control flow graph, with the entrypoint set to the node containing the entrypoint address
            provided in <paramref name="entrypoint"/>.
            </returns>
        </member>
        <member name="T:Echo.ControlFlow.Construction.FlowGraphBuilderExtensions">
            <summary>
            Provides extensions to control flow graph builder implementations.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.FlowGraphBuilderExtensions.ConstructFlowGraph``1(Echo.ControlFlow.Construction.IFlowGraphBuilder{``0},System.Int64)">
            <summary>
            Constructs a control flow graph, starting at the provided entrypoint address.
            </summary>
            <param name="self">The control flow graph builder to use.</param>
            <param name="entrypoint">The address of the first instruction to traverse.</param>
            <returns>
            The constructed control flow graph, with the entrypoint set to the node containing the entrypoint address
            provided in <paramref name="entrypoint"/>.
            </returns>
        </member>
        <member name="M:Echo.ControlFlow.Construction.FlowGraphBuilderExtensions.ConstructFlowGraph``1(Echo.ControlFlow.Construction.IFlowGraphBuilder{``0},System.Int64,System.Collections.Generic.IEnumerable{Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange})">
            <summary>
            Constructs a control flow graph from a collection of instructions, starting at the provided entrypoint address.
            </summary>
            <param name="self">The control flow graph builder to use.</param>
            <param name="entrypoint">The address of the first instruction to traverse.</param>
            <param name="exceptionHandlers">The set of exception handler ranges.</param>
            <returns>
            The constructed control flow graph, with the entrypoint set to the node containing the entrypoint address
            provided in <paramref name="entrypoint"/>.
            </returns>
        </member>
        <member name="T:Echo.ControlFlow.Construction.IInstructionTraversalResult`1">
            <summary>
            Provides members for describing a traversal of a collection of instructions.
            </summary>
            <typeparam name="TInstruction">The type of instructions that were traversed.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Construction.IInstructionTraversalResult`1.IsBlockHeader(System.Int64)">
            <summary>
            Determines whether an offset was marked as a block header during the traversal.
            </summary>
            <param name="offset">The offset to check.</param>
            <returns><c>true</c> if the offset was a block header, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Construction.IInstructionTraversalResult`1.ContainsInstruction(System.Int64)">
            <summary>
            Determines whether an offset was traversed and interpreted as an instruction.
            </summary>
            <param name="offset">The offset to check.</param>
            <returns><c>true</c> if the offset was traversed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Construction.IInstructionTraversalResult`1.GetAllInstructions">
            <summary>
            Obtains all instruction records that were collected during the traversal. 
            </summary>
            <returns>The instructions and their metadata.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Construction.IInstructionTraversalResult`1.GetSuccessorCount(System.Int64)">
            <summary>
            Obtains the number of successors of an instruction that were found during the traversal.
            </summary>
            <param name="offset">The offset of the instruction.</param>
            <returns>The number of successors.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Construction.IInstructionTraversalResult`1.GetSuccessors(System.Int64,System.Span{Echo.ControlFlow.Construction.SuccessorInfo})">
            <summary>
            Obtains the registered successors of an instruction.
            </summary>
            <param name="offset">The offset.</param>
            <param name="successorsBuffer">The buffer to write the successors into.</param>
            <returns>The number of successors.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Construction.InstructionTraversalResult`1">
            <summary>
            Provides a default implementation of the <see cref="T:Echo.ControlFlow.Construction.IInstructionTraversalResult`1"/> interface,
            using a dictionary and a set to store the instructions and block header offsets. 
            </summary>
            <typeparam name="TInstruction">The type of instructions that were traversed.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.#ctor(Echo.Code.IArchitecture{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Construction.InstructionTraversalResult`1"/> class.
            </summary>
            <param name="architecture">The architecture.</param>
        </member>
        <member name="P:Echo.ControlFlow.Construction.InstructionTraversalResult`1.Architecture">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Construction.InstructionTraversalResult`1.BlockHeaders">
            <summary>
            Gets a collection of recorded block headers.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.GetInstructionAtOffset(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.IsBlockHeader(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.ContainsInstruction(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.GetAllInstructions">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.AddInstruction(`0@)">
            <summary>
            Adds a single instruction to the traversal result.
            </summary>
            <param name="instruction">The instruction to add.</param>
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.GetSuccessorCount(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.GetSuccessors(System.Int64,System.Span{Echo.ControlFlow.Construction.SuccessorInfo})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.ClearSuccessors(`0@)">
            <summary>
            Clears all registered successors for the provided instruction.
            </summary>
            <param name="instruction">The instruction.</param>
        </member>
        <member name="M:Echo.ControlFlow.Construction.InstructionTraversalResult`1.RegisterSuccessor(`0@,Echo.ControlFlow.Construction.SuccessorInfo)">
            <summary>
            Registers a successor for the provided instruction.
            </summary>
            <param name="instruction">The instruction.</param>
            <param name="successorInfo">The successor information.</param>
        </member>
        <member name="T:Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver`1">
             <summary>
             Provides members for resolving the static successors of a single instruction. That is, resolve any successor
             that is encoded within an instruction either explicitly or implicitly.
             </summary>
             <typeparam name="TInstruction">The type of instruction to resolve the successors from.</typeparam>
             <remarks>
             <para>
             This interface is meant for components within the Echo project that require information about the successors
             of an individual instruction. These are typically control flow graph builders, such as the
             <see cref="T:Echo.ControlFlow.Construction.Static.StaticFlowGraphBuilder`1"/> class.
             </para>
            
             <para>
             Successors are either directly encoded within the instruction (e.g. as an operand),
             or implied by the default flow control of the provided instruction:
             <list type="bullet">
                 <item>
                     <description>
                         For a typical instruction, the method simply returns a collection with only a reference to the
                         fall through instruction that appears right after it in the sequence.
                     </description>
                 </item> 
                 <item>
                     <description>
                         For branching instructions, however, this method returns a collection of all branch targets,
                         as well as any potential fall through successors if the branching instruction is conditional.
                     </description>
                 </item>
             </list>
             </para>
            
             <para>
             This interface provides members for extracting these successors from the provided instruction.
             </para>
             </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver`1.GetSuccessorsCount(`0@)">
            <summary>
            Gets the number of successors of the provided instruction.
            </summary>
            <param name="instruction">The instruction to resolve the successors from.</param>
            <returns>The number of successors.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver`1.GetSuccessors(`0@,System.Span{Echo.ControlFlow.Construction.SuccessorInfo})">
            <summary>
            Gets a collection of references that represent the successors of the provided instruction.
            </summary>
            <param name="instruction">The instruction to resolve the successors from.</param>
            <param name="successorsBuffer">The buffer to write the successors into.</param>
            <returns>The extracted successor references.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Construction.Static.StaticFlowGraphBuilder`1">
            <summary>
            Provides an implementation of a control flow graph builder that traverses the instructions in a recursive manner,
            and determines for each instruction the successors by looking at the general flow control of each instruction.
            </summary>
            <typeparam name="TInstruction">The type of instructions to store in the control flow graph.</typeparam>
            <remarks>
            This flow graph builder does <strong>not</strong> do any emulation or data flow analysis. Therefore, this flow
            graph builder can only be reliably used when the instructions to graph do not contain any indirect branching
            instructions. For example, if we target x86, the instruction <c>jmp 12345678h</c> is possible to process using
            this graph builder, but <c>jmp eax</c> is not.
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Static.StaticFlowGraphBuilder`1.#ctor(Echo.Code.IArchitecture{`0},System.Collections.Generic.IEnumerable{`0},Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver{`0})">
            <summary>
            Creates a new static graph builder using the provided instruction successor resolver.
            </summary>
            <param name="architecture">The architecture of the instructions.</param>
            <param name="instructions">The instructions to traverse.</param>
            <param name="successorResolver">The object used to determine the successors of a single instruction.</param>
            <exception cref="T:System.ArgumentNullException">Occurs when any of the arguments is <c>null</c>.</exception>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Static.StaticFlowGraphBuilder`1.#ctor(Echo.Code.IStaticInstructionProvider{`0},Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver{`0})">
            <summary>
            Creates a new static graph builder using the provided instruction successor resolver.
            </summary>
            <param name="instructions">The instructions to traverse.</param>
            <param name="successorResolver">The object used to determine the successors of a single instruction.</param>
            <exception cref="T:System.ArgumentNullException">Occurs when any of the arguments is <c>null</c>.</exception>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Static.StaticFlowGraphBuilder`1.Instructions">
            <summary>
            Gets the instructions to traverse.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Static.StaticFlowGraphBuilder`1.Architecture">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Construction.Static.StaticFlowGraphBuilder`1.SuccessorResolver">
            <summary>
            Gets the object used to determine the successors of a single instruction.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Static.StaticFlowGraphBuilder`1.CollectInstructions(System.Int64,System.Collections.Generic.IEnumerable{System.Int64})">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Construction.SuccessorInfo">
            <summary>
            Represents a reference to an instruction that is the successor of another instruction. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.SuccessorInfo.#ctor(System.Int64,Echo.ControlFlow.ControlFlowEdgeType)">
            <summary>
            Creates a new successor reference.
            </summary>
            <param name="destinationAddress">The address of the successor instruction.</param>
            <param name="edgeType">The type of control flow transfer that has to be made to go to this successor.</param>
        </member>
        <member name="P:Echo.ControlFlow.Construction.SuccessorInfo.DestinationAddress">
            <summary>
            Gets the address of the successor instruction.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Construction.SuccessorInfo.EdgeType">
            <summary>
            Gets the type of edge that would be introduced if this control flow transfer was included in a
            control flow graph. 
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Construction.SuccessorInfo.IsRealEdge">
            <summary>
            Gets whether the edge is a real edge (not <see cref="F:Echo.ControlFlow.ControlFlowEdgeType.None"/>).
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.SuccessorInfo.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Construction.Symbolic.IStateTransitioner`1">
            <summary>
            Provides members for resolving the next possible states of a program after the execution of an instruction.
            </summary>
            <typeparam name="TInstruction">The type of instruction that is being executed.</typeparam>
            <remarks>
            <para>
            This interface is meant for components within the Echo project that require information about the transitions
            that an individual instruction might apply to a given program state. These are typically control flow graph
            builders, such as the <see cref="T:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1"/> class.
            </para>
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.IStateTransitioner`1.GetInitialState(System.Int64)">
            <summary>
            Gets the initial state of the program at a provided entry point address.
            </summary>
            <param name="entrypointAddress">The entry point address.</param>
            <returns>The object representing the initial state of the program.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.IStateTransitioner`1.GetTransitionCount(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@,`0@)">
            <summary>
            Gets the number of transitions the current program state might transition into.
            </summary>
            <param name="currentState">The current state of the program.</param>
            <param name="instruction">The instruction to evaluate.</param>
            <returns>The number of transitions that the provided instruction might apply.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.IStateTransitioner`1.GetTransitions(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@,`0@,System.Span{Echo.ControlFlow.Construction.Symbolic.StateTransition{`0}})">
            <summary>
            Resolves all possible program state transitions that the provided instruction can apply. 
            </summary>
            <param name="currentState">The current state of the program.</param>
            <param name="instruction">The instruction to evaluate.</param>
            <param name="transitionBuffer">The output buffer to write the transitions that the instruction might apply.</param>
            <returns>The number of transitions that were written into <paramref name="transitionBuffer"/>.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Construction.Symbolic.ISymbolicInstructionProvider`1">
            <summary>
            Provides members for obtaining instructions based on the current state of a program.
            </summary>
            <typeparam name="TInstruction">The type of instructions that this collection provides.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.ISymbolicInstructionProvider`1.Architecture">
            <summary>
            Gets the architecture describing the instructions exposed by this instruction provider.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.ISymbolicInstructionProvider`1.GetCurrentInstruction(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@)">
            <summary>
            Gets the current instruction to be evaluated; that is, the instruction at the current value
            of the program counter stored in the provided program state.
            </summary>
            <param name="currentState">The current state of the program.</param>
            <returns>The instruction.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Construction.Symbolic.StateTransition`1">
            <summary>
            Represents an object that encodes the transition from one program state to another after an instruction was executed.
            </summary>
            <typeparam name="TInstruction">The type of instruction that was executed.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StateTransition`1.#ctor(Echo.DataFlow.Emulation.SymbolicProgramState{`0},Echo.ControlFlow.ControlFlowEdgeType)">
            <summary>
            Creates a new program state transition.
            </summary>
            <param name="nextState">The new program state.</param>
            <param name="edgeType">The type of edge that was taken.</param>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.StateTransition`1.NextState">
            <summary>
            Gets the new program state after the instruction was executed.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.StateTransition`1.EdgeType">
            <summary>
            Gets the type of edge that was taken by the instruction.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.StateTransition`1.IsRealEdge">
            <summary>
            Gets whether the edge is a real edge (not <see cref="F:Echo.ControlFlow.ControlFlowEdgeType.None"/>).
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StateTransition`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1">
            <summary>
            Provides a base implementation for a state transition resolver, that maintains a data flow graph (DFG) for
            resolving each program state transition an instruction might apply.  
            </summary>
            <typeparam name="TInstruction">The type of instructions to evaluate.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1.#ctor(Echo.Code.IArchitecture{`0})">
            <summary>
            Initializes the base implementation of the state state transition resolver.
            </summary>
            <param name="architecture">The architecture that describes the instruction set.</param>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1.Architecture">
            <summary>
            Gets the architecture for which this transition resolver is built.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1.DataFlowGraph">
            <summary>
            Gets the data flow graph that was constructed during the resolution of all transitions. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1.GetInitialState(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1.GetTransitionCount(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@,`0@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1.GetTransitions(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@,`0@,System.Span{Echo.ControlFlow.Construction.Symbolic.StateTransition{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1.ApplyDefaultBehaviour(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@,`0)">
            <summary>
            Applies the default fallthrough transition on a symbolic program state. 
            </summary>
            <param name="currentState">The current program state to be transitioned.</param>
            <param name="instruction">The instruction invoking the state transition.</param>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StateTransitionerBase`1.GetOrCreateDataFlowNode(`0)">
            <summary>
            Gets or adds a new a data flow graph node in the current data flow graph (DFG) that is linked to the
            provided instruction.
            </summary>
            <param name="instruction">The instruction.</param>
            <returns>The data flow graph</returns>
        </member>
        <member name="T:Echo.ControlFlow.Construction.Symbolic.StaticToSymbolicAdapter`1">
            <summary>
            Provides an implementation of an adapter that maps a <see cref="T:Echo.Code.IStaticInstructionProvider`1"/>
            to a <see cref="T:Echo.ControlFlow.Construction.Symbolic.ISymbolicInstructionProvider`1"/>, by using the program counter stored in the
            program state as an offset to look up the current instruction.
            </summary>
            <typeparam name="TInstruction">The type of instructions that this collection provides.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StaticToSymbolicAdapter`1.#ctor(Echo.Code.IArchitecture{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Construction.Symbolic.StaticToSymbolicAdapter`1"/> adapter.
            </summary>
            <param name="architecture">The architecture of the instructions.</param>
            <param name="instructions">The instructions.</param>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StaticToSymbolicAdapter`1.#ctor(Echo.Code.IStaticInstructionProvider{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Construction.Symbolic.StaticToSymbolicAdapter`1"/> adapter.
            </summary>
            <param name="instructions">The instructions.</param>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.StaticToSymbolicAdapter`1.Instructions">
            <summary>
            Gets the underlying static instructions provider.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.StaticToSymbolicAdapter`1.Architecture">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.StaticToSymbolicAdapter`1.GetCurrentInstruction(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@)">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1">
            <summary>
            Provides an implementation of a control flow graph builder that traverses the instructions in a recursive manner,
            and maintains an symbolic program state to determine all possible branch targets of any indirect branching instruction.
            </summary>
            <typeparam name="TInstruction">The type of instructions to store in the control flow graph.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1.#ctor(Echo.Code.IArchitecture{`0},System.Collections.Generic.IEnumerable{`0},Echo.ControlFlow.Construction.Symbolic.IStateTransitioner{`0})">
            <summary>
            Creates a new symbolic control flow graph builder using the provided program state transition resolver.  
            </summary>
            <param name="architecture">The architecture of the instructions.</param>
            <param name="instructions">The instructions to traverse.</param>
            <param name="transitioner">The transition resolver to use for inferring branch targets.</param>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1.#ctor(Echo.Code.IStaticInstructionProvider{`0},Echo.ControlFlow.Construction.Symbolic.IStateTransitioner{`0})">
            <summary>
            Creates a new symbolic control flow graph builder using the provided program state transition resolver.  
            </summary>
            <param name="instructions">The instructions to traverse.</param>
            <param name="transitioner">The transition resolver to use for inferring branch targets.</param>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1.#ctor(Echo.ControlFlow.Construction.Symbolic.ISymbolicInstructionProvider{`0},Echo.ControlFlow.Construction.Symbolic.IStateTransitioner{`0})">
            <summary>
            Creates a new symbolic control flow graph builder using the provided program state transition resolver.  
            </summary>
            <param name="instructions">The instructions to traverse.</param>
            <param name="transitioner">The transition resolver to use for inferring branch targets.</param>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1.Instructions">
            <summary>
            Gets the instructions to traverse.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1.Architecture">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1.StateTransitioner">
            <summary>
            Gets the object responsible for resolving every transition in the program state that an instruction might introduce. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Construction.Symbolic.SymbolicFlowGraphBuilder`1.CollectInstructions(System.Int64,System.Collections.Generic.IEnumerable{System.Int64})">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.ControlFlowEdge`1">
            <summary>
            Provides an implementation for a single edge in a control flow graph, including the source and target node,
            and the type of edge.
            </summary>
            <remarks>
            If an edge is in between two nodes, it means that control might be transferred from the one node to the other
            during the execution of the program that is encoded by the control flow graph. 
            </remarks>
            <typeparam name="TContents">The type of contents that the connected nodes store.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowEdge`1.#ctor(Echo.ControlFlow.ControlFlowNode{`0},Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Creates a new fallthrough edge between two nodes.
            </summary>
            <param name="origin">The node to start the edge at.</param>
            <param name="target">The node to use as destination for the edge.</param>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowEdge`1.#ctor(Echo.ControlFlow.ControlFlowNode{`0},Echo.ControlFlow.ControlFlowNode{`0},Echo.ControlFlow.ControlFlowEdgeType)">
            <summary>
            Creates a new edge between two nodes.
            </summary>
            <param name="origin">The node to start the edge at.</param>
            <param name="target">The node to use as destination for the edge.</param>
            <param name="edgeType">The type of the edge to create.</param>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowEdge`1.ParentGraph">
            <summary>
            Gets the graph that contains this edge.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowEdge`1.Origin">
            <summary>
            Gets the node that this edge originates from.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowEdge`1.Target">
            <summary>
            Gets the node that this edge targets.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowEdge`1.Type">
            <summary>
            Gets the type of the edge.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowEdge`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.ControlFlowEdgeType">
            <summary>
            Provides all possible edge types that are supported in a control flow graph.
            </summary>
        </member>
        <member name="F:Echo.ControlFlow.ControlFlowEdgeType.None">
            <summary>
            Indicates the edge is not actually a real edge, but a new node was found at the target.
            </summary>
        </member>
        <member name="F:Echo.ControlFlow.ControlFlowEdgeType.FallThrough">
            <summary>
            Indicates the edge is the default fallthrough edge of a node, and is traversed when no other edge is traversed.
            </summary>
        </member>
        <member name="F:Echo.ControlFlow.ControlFlowEdgeType.Unconditional">
            <summary>
            Indicates the edge is traversed as a result from an unconditional jump instruction. 
            </summary>
        </member>
        <member name="F:Echo.ControlFlow.ControlFlowEdgeType.Conditional">
            <summary>
            Indicates the edge is only traversed when a specific condition is met.
            </summary>
        </member>
        <member name="F:Echo.ControlFlow.ControlFlowEdgeType.Abnormal">
            <summary>
            Indicates the edge is only traversed in abnormal circumstances, typically when an exception occurs.
            </summary>
        </member>
        <member name="T:Echo.ControlFlow.ControlFlowGraph`1">
            <summary>
            Provides a generic base implementation of a control flow graph that contains for each node a user predefined
            object in a type safe manner. 
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.#ctor(Echo.Code.IArchitecture{`0})">
            <summary>
            Creates a new empty graph.
            </summary>
            <param name="architecture">The architecture description of the instructions stored in the control flow graph.</param>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowGraph`1.EntryPoint">
            <summary>
            Gets or sets the node that is executed first in the control flow graph.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowGraph`1.Architecture">
            <summary>
            Gets the architecture of the instructions that are stored in the control flow graph.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowGraph`1.Nodes">
            <summary>
            Gets a collection of all basic blocks present in the graph.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowGraph`1.Regions">
            <summary>
            Gets a collection of top-level regions that this control flow graph defines. 
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowGraph`1.Echo#ControlFlow#Regions#IControlFlowRegion{TInstruction}#ParentGraph">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowGraph`1.Echo#ControlFlow#Regions#IControlFlowRegion{TInstruction}#ParentRegion">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.GetEdges">
            <summary>
            Gets a collection of all edges that transfer control from one block to the other in the graph.
            </summary>
            <returns>The edges.</returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.GetNodeByOffset(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.Echo#ControlFlow#Regions#IControlFlowRegion{TInstruction}#GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.Echo#Graphing#ISubGraph#GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.Echo#Graphing#ISubGraph#GetSubGraphs">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.Echo#ControlFlow#Regions#IControlFlowRegion{TInstruction}#GetSubRegions">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.Echo#ControlFlow#Regions#IControlFlowRegion{TInstruction}#RemoveNode(Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.Echo#ControlFlow#Regions#IControlFlowRegion{TInstruction}#GetSuccessors">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.ToDotGraph(System.IO.TextWriter)">
            <summary>
            Serializes the control flow graph to the provided output stream, in graphviz dot format.
            </summary>
            <param name="writer">The output stream.</param>
            <remarks>To customize the layout of the final graph, use the <see cref="T:Echo.Graphing.Serialization.Dot.DotWriter"/> class.</remarks>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowGraph`1.ToDotGraph(System.IO.TextWriter,Echo.ControlFlow.Serialization.Dot.IInstructionFormatter{`0})">
            <summary>
            Serializes the control flow graph to the provided output stream, in graphviz dot format.
            </summary>
            <param name="formatter">The instruction formatter.</param>
            <param name="writer">The output stream.</param>
            <remarks>To customize the layout of the final graph, use the <see cref="T:Echo.Graphing.Serialization.Dot.DotWriter"/> class.</remarks>
        </member>
        <member name="T:Echo.ControlFlow.ControlFlowNode`1">
            <summary>
            Represents a node in a control flow graph, containing a basic block of instructions that are to be executed
            in a sequence.
            </summary>
            <typeparam name="TInstruction">The type of data to store in the node.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.#ctor(System.Int64)">
            <summary>
            Creates a new control flow graph node with an empty basic block, to be added to the graph.
            </summary>
            <param name="offset">The offset of the node.</param>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.#ctor(System.Int64,`0[])">
            <summary>
            Creates a new control flow node containing the provided basic block of instructions, to be added to the graph.
            </summary>
            <param name="offset">The offset of the node.</param>
            <param name="instructions">The basic block to store in the node.</param>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.#ctor(System.Int64,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new control flow node containing the provided basic block of instructions, to be added to the graph.
            </summary>
            <param name="offset">The offset of the node.</param>
            <param name="instructions">The basic block to store in the node.</param>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.#ctor(System.Int64,Echo.ControlFlow.Blocks.BasicBlock{`0})">
            <summary>
            Creates a new control flow node containing the provided basic block of instructions, to be added to the graph.
            </summary>
            <param name="offset">The offset of the node.</param>
            <param name="basicBlock">The basic block to store in the node.</param>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.ParentGraph">
            <summary>
            Gets the graph that contains this node, or <c>null</c> if the node is not added to any graph yet.  
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.ParentRegion">
            <summary>
            Gets the graph region that contains this node, or <c>null</c> if the node is not added to any graph yet.  
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.Offset">
            <summary>
            Gets the offset of the node.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.Id">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.InDegree">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.OutDegree">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.Contents">
            <summary>
            Gets the user-defined contents of this node.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.UnconditionalNeighbour">
            <summary>
            Gets or sets the neighbour to which the control is transferred to after execution of this block and no
            other condition is met.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.UnconditionalEdge">
            <summary>
            Gets or sets the edge to the neighbour to which the control is transferred to after execution of this block
            and no other condition is met.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.ConditionalEdges">
            <summary>
            Gets a collection of conditional edges that originate from this source.
            </summary>
            <remarks>
            These edges are typically present when a node is a basic block encoding the header of an if statement
            or a loop. 
            </remarks>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.AbnormalEdges">
            <summary>
            Gets a collection of abnormal edges that originate from this source.
            </summary>
            <remarks>
            These edges are typically present when a node is part of a region of code protected by an exception handler.
            </remarks>
        </member>
        <member name="P:Echo.ControlFlow.ControlFlowNode`1.IncomingEdges">
            <summary>
            Provides a record of all incoming edges.
            </summary>
            <remarks>
            This property is automatically updated by the adjacency lists and the fall through edge property associated
            to all nodes that might connect themselves to the current node. Do not change it in this class.
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.ConnectWith(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Connects the node to the provided neighbour using a fallthrough edge. 
            </summary>
            <param name="neighbour">The node to connect to.</param>
            <returns>The edge that was used to connect the two nodes together.</returns>
            <exception cref="T:System.ArgumentNullException">Occurs when <paramref name="neighbour"/> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">Occurs when the node already contains a fallthrough edge to another node.</exception>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.ConnectWith(Echo.ControlFlow.ControlFlowNode{`0},Echo.ControlFlow.ControlFlowEdgeType)">
            <summary>
            Connects the node to the provided neighbour. 
            </summary>
            <param name="neighbour">The node to connect to.</param>
            <param name="edgeType">The type of edge to use for connecting to the other node.</param>
            <returns>The edge that was used to connect the two nodes together.</returns>
            <exception cref="T:System.ArgumentNullException">Occurs when <paramref name="neighbour"/> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">
                Occurs when <paramref name="edgeType"/> equals <see cref="F:Echo.ControlFlow.ControlFlowEdgeType.FallThrough"/>, and the node
                already contains a fallthrough edge to another node.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Occurs when an invalid edge type was provided.</exception>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.SplitAtIndex(System.Int32)">
            <summary>
            Splits the node and its embedded basic block in two nodes at the provided index, and connects the two
            resulting nodes with a fallthrough edge.
            </summary>
            <param name="index">The index of the instruction</param>
            <returns>The two resulting nodes.</returns>
            <exception cref="T:System.InvalidOperationException">Occurs when the node cannot be split any further.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Occurs when the provided index falls outside the range of the instructions in the embedded basic block.
            </exception>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.MergeWithPredecessor">
            <summary>
            Merges the current node with its fallthrough predecessor, by combining the two basic blocks together,
            connecting the predecessor with the successors of the current node. and finally removing the current node.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Occurs when the node could not be merged because it has no fallthrough predecessor, has multiple predecessors,
            or the predecessor has multiple successors which prohibit merging.
            </exception>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.MergeWithSuccessor">
            <summary>
            Merges the current node with its fallthrough neighbour, by combining the two basic blocks together,
            connecting the node with the successors of the neighbour. and finally removing the neighbour node.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Occurs when the node could not be merged because it has no fallthrough neighbour, or has multiple successors.
            </exception>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.GetIncomingEdges">
            <summary>
            Gets a collection of all edges that target this node.
            </summary>
            <returns>The incoming edges.</returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.GetOutgoingEdges">
            <summary>
            Gets a collection of all outgoing edges originating from this node.
            </summary>
            <returns>The outgoing edges.</returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.GetPredecessors">
            <summary>
            Gets a collection of nodes that precede this node. This includes any node that might transfer control to
            node this node in the complete control flow graph, regardless of edge type. 
            </summary>
            <returns>The predecessor nodes.</returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.GetSuccessors">
            <summary>
            Gets a collection of nodes that might be executed after this node. This includes any node that this node
            might transfer control to, regardless of edge type.
            </summary>
            <returns>The successor nodes.</returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.HasPredecessor(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Determines whether another node is a predecessor of this node.
            </summary>
            <param name="neighbour">The potential predecessor.</param>
            <returns><c>True</c> if the provided node is a predecessor, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Occurs when the provided predecessor is <c>null</c></exception>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.HasSuccessor(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Determines whether another node is a successor of this node.
            </summary>
            <param name="neighbour">The potential successor.</param>
            <returns><c>True</c> if the provided node is a successor, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Occurs when the provided successor is <c>null</c></exception>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.Disconnect">
            <summary>
            Removes all incident edges (both incoming and outgoing edges) from the node, effectively isolating the node
            in the graph. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.RemoveFromAnyRegion">
            <summary>
            Removes the node out of any sub region in the graph.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.MoveToRegion(Echo.ControlFlow.Regions.ScopeRegion{`0})">
            <summary>
            Moves the node from its current region (if any) into the provided sub region.
            </summary>
            <param name="region">The region to move the node to.</param>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.GetParentExceptionHandler">
            <summary>
            Obtains the parent exception handler region that this node resides in (if any).
            </summary>
            <returns>
            The parent exception handler region, or <c>null</c> if the node is not part of any exception handler.
            </returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.GetParentHandler">
            <summary>
            Obtains the parent handler region that this node resides in (if any).
            </summary>
            <returns>
            The parent handler region, or <c>null</c> if the node is not part of any handler.
            </returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.GetSituatedRegions">
            <summary>
            Traverses the region tree upwards and collects all regions this node is situated in. 
            </summary>
            <returns>The regions this node is situated in, starting with the inner-most regions.</returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.IsInRegion(Echo.ControlFlow.Regions.IControlFlowRegion{`0})">
            <summary>
            Gets a value indicating whether the node is in the provided region.
            </summary>
            <param name="region">The region.</param>
            <returns><c>true</c> if the node is within the region, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.ControlFlowNode`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Editing.AddEdgeAction`1">
            <summary>
            Represents an action that edits a control flow graph by adding an edge from one node to another.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Editing.AddEdgeAction`1.#ctor(System.Int64,System.Int64,Echo.ControlFlow.ControlFlowEdgeType)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Editing.AddEdgeAction`1"/> class.
            </summary>
            <param name="originOffset">The offset to the branching instruction that is the origin of the edge.</param>
            <param name="targetOffset">The offset to the neighbour that the new edge targets.</param>
            <param name="edgeType">The type of edge.</param>
            <exception cref="T:System.NotSupportedException">
            Occurs when <paramref name="edgeType"/> equals <see cref="F:Echo.ControlFlow.ControlFlowEdgeType.FallThrough"/>
            </exception>
        </member>
        <member name="M:Echo.ControlFlow.Editing.AddEdgeAction`1.OnApply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.AddEdgeAction`1.OnRevert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.AddEdgeAction`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1">
            <summary>
            Provides a workspace for editing a control flow graph.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.#ctor(Echo.ControlFlow.ControlFlowGraph{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1"/> class.
            </summary>
            <param name="graph">The graph to edit.</param>
        </member>
        <member name="P:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.Graph">
            <summary>
            Gets the graph to be edited.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.FlushNodeOffsetIndex">
            <summary>
            Rebuilds the index of nodes and their offsets.
            </summary>
            <remarks>
            This method is supposed to be called every time a node is manually added or removed from the
            control flow graph.
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.RemoveNodeFromIndex(System.Int64)">
            <summary>
            Removes a node from the index.
            </summary>
            <param name="offset">The node offset.</param>
            <exception cref="T:System.ArgumentException">
            Occurs when the provided offset does not exist in the current node index.
            </exception>
        </member>
        <member name="M:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.FindNode(System.Int64)">
            <summary>
            Finds the node that contains the provided instruction offset.
            </summary>
            <param name="offset">The offset of the instruction.</param>
            <returns>The node.</returns>
            <exception cref="T:System.ArgumentException">
            Occurs when there is no node in the graph containing an instruction with the provided offset.
            </exception>
            <remarks>
            <para>
            This method can only work properly if the node index is up-to-date. Consider calling <see cref="M:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.FlushNodeOffsetIndex"/>
            before using this method.
            </para>
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.FindNodeOrSplit(System.Int64,System.Boolean@)">
            <summary>
            Finds the node that contains the provided instruction offset, and splits the node into two halves if the
            instruction is not a header of the found node.
            </summary>
            <param name="offset">The offset of the instruction.</param>
            <param name="hasSplit">Indicates whether the node was split up or not.</param>
            <returns>The node.</returns>
            <exception cref="T:System.ArgumentException">
            Occurs when there is no node in the graph containing an instruction with the provided offset.
            </exception>
            <remarks>
            <para>
            This method can only work properly if the node index is up-to-date. Make sure that <see cref="M:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.FlushNodeOffsetIndex"/>
            was called before using this method.
            </para>
            <para>
            When this method splits a node, the node index is updated automatically, and it is not needed to call
            <see cref="M:Echo.ControlFlow.Editing.ControlFlowGraphEditContext`1.FlushNodeOffsetIndex"/> again.
            </para>
            </remarks>
        </member>
        <member name="T:Echo.ControlFlow.Editing.ControlFlowGraphEditTransaction`1">
            <summary>
            Represents a sequence of edits to be applied to a control flow graph.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Editing.ControlFlowGraphEditTransaction`1.Count">
            <summary>
            Gets the number of actions that will be performed.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Editing.ControlFlowGraphEditTransaction`1.IsCompleted">
            <summary>
            Gets a value indicating whether all the edits were applied successfully.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Editing.ControlFlowGraphEditTransaction`1.EnqueueAction(Echo.ControlFlow.Editing.IControlFlowGraphEditAction{`0})">
            <summary>
            Adds an edit action to the end of the sequence.
            </summary>
            <param name="action">The action to add.</param>
        </member>
        <member name="M:Echo.ControlFlow.Editing.ControlFlowGraphEditTransaction`1.Apply(Echo.ControlFlow.ControlFlowGraph{`0})">
            <summary>
            Applies all edits to the control flow graph.
            </summary>
            <param name="graph">The graph to apply the transaction on.</param>
            <exception cref="T:System.InvalidOperationException">Occurs when the transaction was already applied.</exception>
            <remarks>
            When an exception occurs within one of the edits, all edits previously applied will be reverted. 
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Editing.ControlFlowGraphEditTransaction`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Editing.IControlFlowGraphEditAction`1">
            <summary>
            Represents a reversible action that modifies a control flow graph. 
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Editing.IControlFlowGraphEditAction`1.Apply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <summary>
            Applies the edit.
            </summary>
            <param name="context">The workspace, including the graph to edit, to use.</param>
            <exception cref="T:System.InvalidOperationException">
            Occurs when the edit was already applied.
            </exception>
            <remarks>
            This method should only be called once. Calling this method a second time should happen after a call to
            <see cref="M:Echo.ControlFlow.Editing.IControlFlowGraphEditAction`1.Revert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})"/> was made.
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Editing.IControlFlowGraphEditAction`1.Revert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <summary>
            Reverts the edit.
            </summary>
            <param name="context">The workspace, including the graph to edit, to use.</param>
            <exception cref="T:System.InvalidOperationException">
            Occurs when the edit was not applied yet.
            </exception>
            <remarks>
            This method should only be called after the <see cref="M:Echo.ControlFlow.Editing.IControlFlowGraphEditAction`1.Apply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})"/> method was called.
            </remarks>
        </member>
        <member name="T:Echo.ControlFlow.Editing.RemoveEdgeAction`1">
            <summary>
            Represents an action that edits a control flow graph by removing an edge from one node to another.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Editing.RemoveEdgeAction`1.#ctor(System.Int64,System.Int64,Echo.ControlFlow.ControlFlowEdgeType)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Editing.RemoveEdgeAction`1"/> class.
            </summary>
            <param name="originOffset">The offset to the branching instruction that is the origin of the edge to remove.</param>
            <param name="targetOffset">The offset to the neighbour that the edge to remove targets.</param>
            <param name="edgeType">The type of edge.</param>
            <exception cref="T:System.NotSupportedException">
            Occurs when <paramref name="edgeType"/> equals <see cref="F:Echo.ControlFlow.ControlFlowEdgeType.FallThrough"/>
            </exception>
        </member>
        <member name="M:Echo.ControlFlow.Editing.RemoveEdgeAction`1.OnApply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.RemoveEdgeAction`1.OnRevert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.RemoveEdgeAction`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Editing.SplitNodeAction`1">
            <summary>
            Represents an action that edits a control flow graph by splitting a node into two halves.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Editing.SplitNodeAction`1.#ctor(System.Int64)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Editing.SplitNodeAction`1"/> class.
            </summary>
            <param name="splitOffset">The offset to split at.</param>
        </member>
        <member name="P:Echo.ControlFlow.Editing.SplitNodeAction`1.SplitOffset">
            <summary>
            Gets the offset to split the node at.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Editing.SplitNodeAction`1.Apply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.SplitNodeAction`1.Revert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.SplitNodeAction`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronization">
            <summary>
            Provides extensions for pulling updates from basic blocks into a control flow graph. This includes splitting
            and merging nodes where necessary, as well as adding or removing any edges. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronization.UpdateFlowControl``1(Echo.ControlFlow.ControlFlowNode{``0},Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver{``0})">
            <summary>
            Pulls any updates from the basic block embedded in the node, and updates the parent control flow graph
            accordingly. 
            </summary>
            <param name="node">The node to pull updates from.</param>
            <param name="successorResolver">The object to use for resolving successors of a single instruction.</param>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
            <returns><c>true</c> if any changes were made, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronization.UpdateFlowControl``1(Echo.ControlFlow.ControlFlowNode{``0},Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver{``0},Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizationFlags)">
            <summary>
            Pulls any updates from the basic block embedded in the node, and updates the parent control flow graph
            accordingly. 
            </summary>
            <param name="node">The node to pull updates from.</param>
            <param name="successorResolver">The object to use for resolving successors of a single instruction.</param>
            <param name="flags">Flags indicating several options for updating the control flow graph.</param>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
            <returns><c>true</c> if any changes were made, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronization.UpdateFlowControl``1(Echo.ControlFlow.ControlFlowGraph{``0},Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver{``0})">
            <summary>
            Traverses all nodes in the control flow graph, and synchronizes the structure of the graph with the contents
            of each basic block within the traversed nodes.
            </summary>
            <param name="graph">The graph to synchronize.</param>
            <param name="successorResolver">The object to use for resolving successors of a single instruction.</param>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
            <returns><c>true</c> if any changes were made, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronization.UpdateFlowControl``1(Echo.ControlFlow.ControlFlowGraph{``0},Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver{``0},Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizationFlags)">
            <summary>
            Traverses all nodes in the control flow graph, and synchronizes the structure of the graph with the contents
            of each basic block within the traversed nodes.
            </summary>
            <param name="graph">The graph to synchronize.</param>
            <param name="successorResolver">The object to use for resolving successors of a single instruction.</param>
            <param name="flags">Flags indicating several options for updating the control flow graph.</param>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
            <returns><c>true</c> if any changes were made, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizationFlags">
            <summary>
            Provides flags that dictate the strategy used for pulling updates of a basic block into a control flow graph.
            </summary>
        </member>
        <member name="F:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizationFlags.TraverseFootersOnly">
            <summary>
            Indicates the synchronizer should only look at changes in the footer of a node in a control flow graph.
            </summary>
        </member>
        <member name="F:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizationFlags.TraverseEntireBasicBlock">
            <summary>
            Indicates the synchronizer should traverse the entire basic block of a node in a control flow graph.
            </summary>
        </member>
        <member name="T:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizer`1">
            <summary>
            Provides a mechanism for pulling updates from basic blocks into a control flow graph. This includes splitting
            and merging nodes where necessary, as well as adding or removing any edges. 
            </summary>
            <typeparam name="TInstruction">The type of instructions the graph contains.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizer`1.#ctor(Echo.ControlFlow.ControlFlowGraph{`0},Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver{`0},Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizationFlags)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizer`1"/> class.
            </summary>
            <param name="cfg">The control flow graph to update.</param>
            <param name="successorResolver">The object responsible for resolving successors of a single instruction.</param>
            <param name="flags">The flags that dictate the strategy used for pulling basic block updates into a control flow graph.</param>
        </member>
        <member name="P:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizer`1.ControlFlowGraph">
            <summary>
            Gets the control flow graph that needs to be updated.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizer`1.SuccessorResolver">
            <summary>
            Gets the object responsible for resolving successors of a single instruction. 
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizer`1.Flags">
            <summary>
            Gets the flags that dictate the strategy used for pulling basic block updates into a control flow graph.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizer`1.UpdateFlowControl">
            <summary>
            Traverses all nodes in the control flow graph, and synchronizes the structure of the graph with the contents
            of each basic block within the traversed nodes.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Editing.Synchronization.FlowControlSynchronizer`1.UpdateFlowControl(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Pulls any updates from the provided node into the structure of the control flow graph.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="T:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1">
            <summary>
            Represents an action that edits a control flow graph by updating one of the adjacency collections of a single
            node.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.#ctor(System.Int64,System.Int64,Echo.ControlFlow.ControlFlowEdgeType)">
            <summary>
            Initializes the <see cref="T:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1"/> base class.
            </summary>
            <param name="originOffset">The offset of the branch instruction representing the origin of the edge.</param>
            <param name="targetOffset">The offset of the neighbour that the edge targets.</param>
            <param name="edgeType">The type of edge.</param>
        </member>
        <member name="P:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.OriginOffset">
            <summary>
            Gets the offset of the branching instruction representing the origin of the edge.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.TargetOffset">
            <summary>
            Gets the offset of the neighbour that the edge targets.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.EdgeType">
            <summary>
            Gets the type of edge.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.Apply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.OnApply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <summary>
            Applies the update to the adjacency list of the node.
            </summary>
            <param name="context">The editing context.</param>
            <remarks>
            This method is guaranteed to be called before <see cref="M:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.Revert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})"/>.
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.Revert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.OnRevert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <summary>
            Reverts the update to the adjacency list of the node.
            </summary>
            <param name="context">The editing context.</param>
            <remarks>
            This method is guaranteed to be called after <see cref="M:Echo.ControlFlow.Editing.UpdateAdjacencyAction`1.Apply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})"/>.
            </remarks>
        </member>
        <member name="T:Echo.ControlFlow.Editing.UpdateFallThroughAction`1">
            <summary>
            Represents an action that edits a control flow graph by updating the fallthrough edge of a single node.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateFallThroughAction`1.#ctor(System.Int64,System.Nullable{System.Int64})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Editing.UpdateFallThroughAction`1" /> class.
            </summary>
            <param name="branchOffset">The offset of the branching instruction.</param>
            <param name="newFallThroughOffset">The offset to the new fallthrough neighbour, or <c>null</c> to remove the fallthrough edge.</param>
        </member>
        <member name="P:Echo.ControlFlow.Editing.UpdateFallThroughAction`1.BranchOffset">
            <summary>
            Gets the offset to the branching instruction responsible for the fallthrough edge.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Editing.UpdateFallThroughAction`1.NewFallThroughOffset">
            <summary>
            Gets the offset to the new fallthrough neighbour. When this value is <c>null</c>, the removal of the
            fallthrough edge is indicated.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateFallThroughAction`1.Apply(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateFallThroughAction`1.Revert(Echo.ControlFlow.Editing.ControlFlowGraphEditContext{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Editing.UpdateFallThroughAction`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Regions.ControlFlowRegion`1">
            <summary>
            Provides a base implementation for a region in a control flow graph.
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Regions.ControlFlowRegion`1.ParentGraph">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Regions.ControlFlowRegion`1.ParentRegion">
            <inheritdoc />
        </member>
        <member name="P:Echo.ControlFlow.Regions.ControlFlowRegion`1.Tag">
            <summary>
            Gets or sets a user-defined tag that is assigned to this region. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegion`1.GetEntryPoint">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegion`1.GetNodeByOffset(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegion`1.GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegion`1.Echo#Graphing#ISubGraph#GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegion`1.GetSubRegions">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegion`1.Echo#Graphing#ISubGraph#GetSubGraphs">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegion`1.RemoveNode(Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegion`1.GetSuccessors">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange">
            <summary>
            Represents an address range of code that is protected from exceptions by a handler block.  
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.#ctor(Echo.AddressRange,Echo.AddressRange)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange"/> structure.
            </summary>
            <param name="protectedRange">The range indicating the code that is protected by the handler.</param>
            <param name="handlerRange">The range indicating the handler code.</param>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.#ctor(Echo.AddressRange,Echo.AddressRange,Echo.AddressRange)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange"/> structure.
            </summary>
            <param name="protectedRange">The range indicating the code that is protected by the handler.</param>
            <param name="prologueRange">The range indicating the prologue range that precedes the handler.</param>
            <param name="handlerRange">The range indicating the handler code.</param>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.#ctor(Echo.AddressRange,Echo.AddressRange,Echo.AddressRange,System.Object)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange"/> structure.
            </summary>
            <param name="protectedRange">The range indicating the code that is protected by the handler.</param>
            <param name="prologueRange">The range indicating the prologue range that precedes the handler.</param>
            <param name="handlerRange">The range indicating the handler code.</param>
            <param name="userData">A user defined tag that is added to the exception handler.</param>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.#ctor(Echo.AddressRange,Echo.AddressRange,Echo.AddressRange,Echo.AddressRange)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange"/> structure.
            </summary>
            <param name="protectedRange">The range indicating the code that is protected by the handler.</param>
            <param name="prologueRange">The range indicating the prologue range that precedes the handler.</param>
            <param name="handlerRange">The range indicating the handler code.</param>
            <param name="epilogueRange">The range indicating the epilogue range that proceeds the handler.</param>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.#ctor(Echo.AddressRange,Echo.AddressRange,Echo.AddressRange,Echo.AddressRange,System.Object)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange"/> structure.
            </summary>
            <param name="protectedRange">The range indicating the code that is protected by the handler.</param>
            <param name="prologueRange">The range indicating the prologue range that precedes the handler.</param>
            <param name="handlerRange">The range indicating the handler code.</param>
            <param name="epilogueRange">The range indicating the epilogue range that proceeds the handler.</param>
            <param name="userData">A user defined tag that is added to the exception handler.</param>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.#ctor(Echo.AddressRange,Echo.AddressRange,System.Object)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange"/> structure.
            </summary>
            <param name="protectedRange">The range indicating the code that is protected by the handler.</param>
            <param name="handlerRange">The range indicating the handler code.</param>
            <param name="userData">A user defined tag that is added to the exception handler.</param>
        </member>
        <member name="P:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.ProtectedRange">
            <summary>
            Gets the address range indicating the start and end of the code that is protected by a handler.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.PrologueRange">
            <summary>
            Gets the address range indicating the start and end of the code that is executed before transferring
            control to the <see cref="P:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.HandlerRange"/>.
            </summary>
            <remarks>A good example would be exception filters in CIL.</remarks>
        </member>
        <member name="P:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.HandlerRange">
            <summary>
            Gets the address range indicating the start and end of the handler code.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.EpilogueRange">
            <summary>
            Gets the address range indicating the start and end of the code that is
            executed after the <see cref="P:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.HandlerRange"/>.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.UserData">
            <summary>
            Gets a user defined tag that is added to the exception handler.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.Equals(Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange@)">
            <summary>
            Determines whether two exception handlers are considered equal.
            </summary>
            <param name="other">The other exception handler.</param>
            <returns><c>true</c> if the handler is equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.CompareTo(Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Regions.Detection.RangedEHRegionDetector">
            <summary>
            Provides methods for detecting exception handler regions in a control flow graph by providing address ranges
            indicating the protected and handler regions.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Regions.Detection.RangedEHRegionDetector.DetectExceptionHandlerRegions``1(Echo.ControlFlow.ControlFlowGraph{``0},System.Collections.Generic.IEnumerable{Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange})">
            <summary>
            Creates new exception handler regions in the provided control flow graph, based on a collection of address
            ranges indicating exception handlers.
            </summary>
            <param name="cfg">The control flow graph to create regions in.</param>
            <param name="ranges">The exception handler address ranges.</param>
            <typeparam name="TInstruction">The type of instructions stored in the control flow graph.</typeparam>
        </member>
        <member name="T:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1">
            <summary>
            Represents a region in a control flow graph that is protected by an exception handler block. 
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1"/> class.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1.ProtectedRegion">
            <summary>
            Gets the region of nodes that is protected by the exception handler. 
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1.Handlers">
            <summary>
            Gets the regions that form the handler blocks.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1.GetEntryPoint">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1.GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1.GetSubRegions">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ExceptionHandlerRegion`1.RemoveNode(Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Regions.HandlerRegion`1">
            <summary>
            Represents a single handler region in an exception handler block.
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Regions.HandlerRegion`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.HandlerRegion`1"/> class without
            an explicit prologue and epilogue set.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.HandlerRegion`1.Prologue">
            <summary>
            Gets the region of nodes that form the code that precedes the handler.
            </summary>
            <remarks>
            This region is often used for filter clauses of the exception handler.
            </remarks>
        </member>
        <member name="P:Echo.ControlFlow.Regions.HandlerRegion`1.Contents">
            <summary>
            Gets the region of nodes that form the code of the handler block.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.HandlerRegion`1.Epilogue">
            <summary>
            Gets the region of nodes that form the code that proceeds the handler.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Regions.HandlerRegion`1.GetEntryPoint">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.HandlerRegion`1.GetSubRegions">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.HandlerRegion`1.RemoveNode(Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.HandlerRegion`1.GetNodes">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Regions.IControlFlowRegion`1">
            <summary>
            Provides members for describing a region in a control flow graph.
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Regions.IControlFlowRegion`1.ParentGraph">
            <summary>
            Gets the parent graph this region is part of.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.IControlFlowRegion`1.ParentRegion">
            <summary>
            Gets the parent region that this region is part of. 
            </summary>
            <remarks>
            When this property is set to <c>null</c> this region is the root.
            </remarks>
        </member>
        <member name="M:Echo.ControlFlow.Regions.IControlFlowRegion`1.GetEntryPoint">
            <summary>
            Obtains the first node that is executed in the region (if available).
            </summary>
            <returns>The node, or <c>null</c> if no entrypoint was specified..</returns>
        </member>
        <member name="M:Echo.ControlFlow.Regions.IControlFlowRegion`1.GetSubRegions">
            <summary>
            Gets a collection of all nested regions defined in this region.
            </summary>
            <returns>The sub regions.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Regions.IControlFlowRegion`1.GetNodes">
            <summary>
            Gets a collection of all nodes in the control flow graph region. This includes all nodes in the nested
            regions. 
            </summary>
            <returns>The nodes.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Regions.IControlFlowRegion`1.GetNodeByOffset(System.Int64)">
            <summary>
            Searches for a node in the control flow graph with the provided offset or identifier.
            </summary>
            <param name="offset">The offset of the node to find.</param>
            <returns>The node.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Regions.IControlFlowRegion`1.RemoveNode(Echo.ControlFlow.ControlFlowNode{`0})">
            <summary>
            Removes the node from the region.
            </summary>
            <param name="node">The node to remove.</param>
            <returns><c>true</c> if the node was found and removed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.ControlFlow.Regions.IControlFlowRegion`1.GetSuccessors">
            <summary>
            Gets the nodes that are immediate successors of any node in this region.
            </summary>
            <returns>The nodes.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Regions.IScopeControlFlowRegion`1">
            <summary>
            Represents a scope of regions. 
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Regions.IScopeControlFlowRegion`1.Regions">
            <summary>
            Gets a collection of nested sub regions that this region defines.
            </summary>
        </member>
        <member name="T:Echo.ControlFlow.Regions.ControlFlowRegionExtensions">
            <summary>
            Provides extensions to the <see cref="T:Echo.ControlFlow.Regions.IControlFlowRegion`1"/> interface.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegionExtensions.GetParentExceptionHandler``1(Echo.ControlFlow.Regions.IControlFlowRegion{``0})">
            <summary>
            Obtains the parent exception handler region that this region resides in (if any).
            </summary>
            <returns>
            The parent exception handler region, or <c>null</c> if the region is not part of any exception handler.
            </returns>
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegionExtensions.GetParentHandler``1(Echo.ControlFlow.Regions.IControlFlowRegion{``0})">
            <summary>
            Obtains the parent handler region that this region resides in (if any).
            </summary>
            <returns>
            The parent exception handler region, or <c>null</c> if the region is not part of any exception handler.
            </returns>
        </member>
        <member name="M:Echo.ControlFlow.Regions.ControlFlowRegionExtensions.GetParentRegion``2(Echo.ControlFlow.Regions.IControlFlowRegion{``0})">
            <summary>
            Obtains the parent region of a specific type that this region resides in (if any).
            </summary>
            <returns>
            The parent region, or <c>null</c> if the region is not part of any region of type <typeparamref name="TRegion"/>.
            </returns>
        </member>
        <member name="T:Echo.ControlFlow.Regions.ScopeRegion`1">
            <summary>
            Represents a simple unordered region defining an inner scope in the control flow graph.
            </summary>
            <typeparam name="TInstruction">The type of data that each node in the graph stores.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Regions.ScopeRegion`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Regions.ScopeRegion`1"/> class.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.ScopeRegion`1.EntryPoint">
            <summary>
            Gets or sets the first node that is executed in the region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Regions.ScopeRegion`1.Nodes">
            <summary>
            Gets a collection of top-level nodes that this region consists of.
            </summary>
            <remarks>
            This collection does not include any nodes in the nested sub regions.
            </remarks>
        </member>
        <member name="P:Echo.ControlFlow.Regions.ScopeRegion`1.Regions">
            <summary>
            Gets a collection of nested sub regions that this region defines.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Regions.ScopeRegion`1.GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ScopeRegion`1.GetEntryPoint">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ScopeRegion`1.GetSubRegions">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Regions.ScopeRegion`1.RemoveNode(Echo.ControlFlow.ControlFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Blocks.BlockBuilder">
            <summary>
            Provides a mechanism for transforming a control flow graph into a tree of scopes and basic blocks.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Blocks.BlockBuilder.ConstructBlocks``1(Echo.ControlFlow.ControlFlowGraph{``0})">
            <summary>
            Constructs the tree of scopes and basic blocks based on the provided control flow graph. 
            </summary>
            <param name="cfg">The control flow graph .</param>
            <typeparam name="TInstruction">The type of instructions stored in the graph.</typeparam>
            <returns>The root scope.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Blocks.BlockOrderingException">
            <summary>
            Represents an exception that occurs during the sorting of nodes in a control flow graph.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Blocks.BlockOrderingException.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Serialization.Blocks.BlockOrderingException"/> class.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Blocks.BlockOrderingException.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Serialization.Blocks.BlockOrderingException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Blocks.BlockOrderingException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.ControlFlow.Serialization.Blocks.BlockOrderingException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner cause of the exception.</param>
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Blocks.BlockSorter">
            <summary>
            Provides a mechanism for ordering nodes in control flow graph, based on the outgoing edges of every node. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Blocks.BlockSorter.SortNodes``1(Echo.ControlFlow.ControlFlowGraph{``0})">
            <summary>
            Determines an ordering of nodes in the control flow graph in such a way that the basic blocks can be
            concatenated together in sequence, and still result in a valid execution of the original program. 
            </summary>
            <param name="cfg">The control flow graph to pull the nodes from.</param>
            <typeparam name="TInstruction">The type of instructions stored in the graph.</typeparam>
            <returns>The ordering.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Dot.ControlFlowEdgeAdorner`1">
            <summary>
            Represents an adorner that styles edges in a control flow graph.
            </summary>
            <typeparam name="TInstruction">The type of instructions the nodes contain.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowEdgeAdorner`1.FallthroughStyle">
            <summary>
            Gets or sets the edge style to use for normal fallthrough edges.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowEdgeAdorner`1.UnconditionalStyle">
            <summary>
            Gets or sets the edge style to use for unconditional branch edges.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowEdgeAdorner`1.FalseStyle">
            <summary>
            Gets or sets the edge style to use for any fallthrough edge originating from a branching node.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowEdgeAdorner`1.TrueStyle">
            <summary>
            Gets or sets the edge style to use for any conditional edge.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowEdgeAdorner`1.AbnormalStyle">
            <summary>
            Gets or sets the edge style to use for any abnormal edge.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.ControlFlowEdgeAdorner`1.GetEdgeAttributes(Echo.Graphing.IEdge,System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1">
            <summary>
            Represents an adorner that adds the string representation of the embedded instructions to a node in a graph.
            </summary>
            <typeparam name="TInstruction">The type of instructions the nodes contain.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1.#ctor">
            <summary>
            Creates a new <see cref="T:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1"/> with the default formatter.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1.#ctor(Echo.ControlFlow.Serialization.Dot.IInstructionFormatter{`0})">
            <summary>
            Creates a new <see cref="T:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1"/> with
            the specified <see cref="T:Echo.ControlFlow.Serialization.Dot.IInstructionFormatter`1"/>.
            </summary>
            <param name="formatter">The <see cref="T:Echo.ControlFlow.Serialization.Dot.IInstructionFormatter`1"/> to format instructions with.</param>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1.NodeShape">
            <summary>
            Gets or sets the shape of the node.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1.IncludeBlockHeaders">
            <summary>
            Gets or sets a value indicating whether the adorner should add block headers to every node.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1.IncludeInstructions">
            <summary>
            Gets or sets a value indicating whether the adorner should add the block instructions to every node.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1.BlockHeaderFormat">
            <summary>
            Gets or sets a value indicating the format of block headers. This is a format string with one
            parameter containing the value of <see cref="P:Echo.ControlFlow.ControlFlowNode`1.Offset"/>.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1.InstructionFormatter">
            <summary>
            Gets or sets the formatter that will be used to format the instructions.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1.GetNodeAttributes(Echo.Graphing.INode,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Dot.DefaultInstructionFormatter`1">
            <summary>
            Provides a default implementation for <see cref="T:Echo.ControlFlow.Serialization.Dot.IInstructionFormatter`1"/>.
            </summary>
            <typeparam name="TInstruction">The type of the instruction to create a formatter of.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.DefaultInstructionFormatter`1.Instance">
            <summary>
            Gets a singleton instance of the <see cref="T:Echo.ControlFlow.Serialization.Dot.DefaultInstructionFormatter`1"/> class.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.DefaultInstructionFormatter`1.Format(`0@)">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1">
            <summary>
            Represents an adorner that adds styles to regions in control flow graphs. 
            </summary>
            <typeparam name="TInstruction">The type of instructions the nodes contain.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.ExceptionHandlerStyle">
            <summary>
            Gets or sets the style of an enclosing exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.ExceptionHandlerLabel">
            <summary>
            Gets or sets the label of an enclosing exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.ProtectedStyle">
            <summary>
            Gets or sets the style of the protected region in an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.ProtectedLabel">
            <summary>
            Gets or sets the label of the protected region in an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.HandlerStyle">
            <summary>
            Gets or sets the style of a handler region in an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.HandlerLabel">
            <summary>
            Gets or sets the label of a handler region in an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.PrologueStyle">
            <summary>
            Gets or sets the style of a prologue region in an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.PrologueLabel">
            <summary>
            Gets or sets the label of the prologue region in an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.HandlerContentsStyle">
            <summary>
            Gets or sets the default style of a control flow region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.HandlerContentsLabel">
            <summary>
            Gets or sets the label of a contents region in a handler of an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.EpilogueStyle">
            <summary>
            Gets or sets the style of an epilogue region in an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.EpilogueLabel">
            <summary>
            Gets or sets the label of an epilogue region in an exception handler region.
            </summary>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.DefaultStyle">
            <summary>
            Gets or sets the default style of a control flow region.
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.GetSubGraphName(Echo.Graphing.ISubGraph)">
            <inheritdoc />
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.ExceptionHandlerAdorner`1.GetSubGraphAttributes(Echo.Graphing.ISubGraph)">
            <inheritdoc />
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Dot.IInstructionFormatter`1">
            <summary>
            Allows the user to format instructions in the <see cref="T:Echo.ControlFlow.Serialization.Dot.ControlFlowNodeAdorner`1"/>.
            </summary>
            <typeparam name="TInstruction">The type of instructions the nodes contain.</typeparam>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.IInstructionFormatter`1.Format(`0@)">
            <summary>
            Formats a given <typeparamref name="TInstruction"/>.
            </summary>
            <param name="instruction">The <typeparamref name="TInstruction"/> to format.</param>
            <returns>The formatted <paramref name="instruction"/>.</returns>
        </member>
        <member name="T:Echo.ControlFlow.Serialization.Dot.OffsetNodeIdentifier`1">
            <summary>
            Provides an implementation of the <see cref="T:Echo.Graphing.Serialization.Dot.INodeIdentifier"/> interface, that returns the offset of the basic
            block as unique identifiers.
            </summary>
            <typeparam name="TInstruction">The type of instructions stored in the basic block.</typeparam>
        </member>
        <member name="P:Echo.ControlFlow.Serialization.Dot.OffsetNodeIdentifier`1.Instance">
            <summary>
            Provides a default instance of the <see cref="T:Echo.ControlFlow.Serialization.Dot.OffsetNodeIdentifier`1"/> class. 
            </summary>
        </member>
        <member name="M:Echo.ControlFlow.Serialization.Dot.OffsetNodeIdentifier`1.GetIdentifier(Echo.Graphing.INode)">
            <inheritdoc />
        </member>
    </members>
</doc>



================================================
File: lib/Echo.DataFlow.xml
================================================
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Echo.DataFlow</name>
    </assembly>
    <members>
        <member name="T:Echo.DataFlow.Analysis.CyclicDependencyException">
            <summary>
            Represents the exception that occurs when a cyclic dependency was detected in a data flow graph.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Analysis.CyclicDependencyException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.DataFlow.Analysis.CyclicDependencyException"/> class.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Analysis.CyclicDependencyException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.DataFlow.Analysis.CyclicDependencyException"/> class, with the specified message.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Echo.DataFlow.Analysis.CyclicDependencyException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.DataFlow.Analysis.CyclicDependencyException"/> class, with the specified message
            and inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception that was the cause of this exception.</param>
        </member>
        <member name="T:Echo.DataFlow.Analysis.DependencyCollection">
            <summary>
            Provides members for collecting data dependencies in a data flow graph.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Analysis.DependencyCollection.GetOrderedDependencies``1(Echo.DataFlow.DataFlowNode{``0})">
            <summary>
            Collects all dependency nodes recursively, and sorts them in a topological order such that the final collection
            of nodes can be executed sequentially.
            </summary>
            <param name="node">The node to find all dependencies for.</param>
            <typeparam name="T">The type of contents that each node contains.</typeparam>
            <returns>The topological ordering of all dependencies of the node.</returns>
            <exception cref="T:Echo.DataFlow.Analysis.CyclicDependencyException">Occurs when there is a cyclic dependency in the graph.</exception>
        </member>
        <member name="M:Echo.DataFlow.Analysis.DependencyCollection.GetOrderedDependencies``1(Echo.DataFlow.DataFlowNode{``0},Echo.DataFlow.Analysis.DependencyCollectionFlags)">
            <summary>
            Collects all dependency nodes recursively, and sorts them in a topological order such that the final collection
            of nodes can be executed sequentially.
            </summary>
            <param name="node">The node to find all dependencies for.</param>
            <param name="flags">Flags that influence the behaviour of the algorithm.</param>
            <typeparam name="T">The type of contents that each node contains.</typeparam>
            <returns>The topological ordering of all dependencies of the node.</returns>
            <exception cref="T:Echo.DataFlow.Analysis.CyclicDependencyException">Occurs when there is a cyclic dependency in the graph.</exception>
        </member>
        <member name="T:Echo.DataFlow.Analysis.DependencyCollectionFlags">
            <summary>
            Provides flags that influence the behaviour of the <see cref="T:Echo.DataFlow.Analysis.DependencyCollection"/> class.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.Analysis.DependencyCollectionFlags.IncludeStackDependencies">
            <summary>
            Indicates stack dependency edges should be traversed during the collection.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.Analysis.DependencyCollectionFlags.IncludeVariableDependencies">
            <summary>
            Indicates variable dependency edges should be traversed during the collection.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.Analysis.DependencyCollectionFlags.IncludeAllDependencies">
            <summary>
            Indicates all edges should be traversed during the collection.
            </summary>
        </member>
        <member name="T:Echo.DataFlow.Collections.DataFlowNodeCollection`1">
            <summary>
            Represents a mutable collection of nodes present in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of data that is stored in each node.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.DataFlowNodeCollection`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Item(System.Int64)">
            <summary>
            Gets a node by its identifier.
            </summary>
            <param name="id">The node identifier.</param>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Add(System.Int64,`0)">
            <summary>
            Creates and adds a new node to the collection of data flow nodes.
            </summary>
            <param name="id">The unique identifier of the node.</param>
            <param name="contents">The contents of the node.</param>
            <returns>The created node.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Add(Echo.DataFlow.DataFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.AddRange(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataFlowNode{`0}})">
            <summary>
            Adds a collection of nodes to the graph.
            </summary>
            <param name="items">The nodes to add.</param>
            <exception cref="T:System.ArgumentException">
            Occurs when at least one node in the provided collection is already added to another graph.
            </exception>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Contains(System.Int64)">
            <summary>
            Determines whether a node with a specific offset was added to the collection.
            </summary>
            <param name="offset">The offset to the node.</param>
            <returns><c>true</c> if there exists a node with the provided offset, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Contains(Echo.DataFlow.DataFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.CopyTo(Echo.DataFlow.DataFlowNode{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Remove(System.Int64)">
            <summary>
            Removes a node by its offset.
            </summary>
            <param name="offset">The offset. of the node to remove.</param>
            <returns><c>true</c> if the collection contained a node with the provided offset., and the node was removed
            successfully, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.UpdateIndices">
            <summary>
            Synchronizes all offsets of each node with the underlying instructions.
            </summary>
            <exception cref="T:System.InvalidOperationException">Occurs when one or more nodes are in a state that new offsets
            cannot be determined. This includes duplicated offsets.</exception>
            <remarks>
            <para>
            Because updating offsets is a relatively expensive task, calls to this method should be delayed as much as
            possible.
            </para>
            <para>
            This method will invalidate any enumerators that are enumerating this collection of nodes.
            </para>
            </remarks>
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.Remove(Echo.DataFlow.DataFlowNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.DataFlowNodeCollection`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Collections.StackDependencyCollection`1">
            <summary>
            Represents a collection of dependencies allocated on a stack for a node in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of contents to put in each node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.#ctor(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Creates a new dependency collection for a node.
            </summary>
            <param name="owner">The owner node.</param>
        </member>
        <member name="P:Echo.DataFlow.Collections.StackDependencyCollection`1.EdgeCount">
            <summary>
            Gets the total number of edges that are stored in this dependency collection.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.SetCount(System.Int32)">
            <summary>
            Ensures the node has the provided amount of stack dependencies.
            </summary>
            <param name="count">The new amount of dependencies.</param>
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.InsertItem(System.Int32,Echo.DataFlow.StackDependency{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.SetItem(System.Int32,Echo.DataFlow.StackDependency{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.RemoveItem(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.ClearItems">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.GetEnumerator">
            <summary>
            Gets the enumerator for this stack dependency collection.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator">
            <summary>
            Represents an enumerator for a stack dependency collection.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.#ctor(Echo.DataFlow.Collections.StackDependencyCollection{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator"/> structure.
            </summary>
            <param name="collection">The collection to enumerate.</param>
        </member>
        <member name="P:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.StackDependencyCollection`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Collections.VariableDependencyCollection`1">
            <summary>
            Represents a collection of variables and their symbolic values that a node in a data flow graph depends on.
            </summary>
            <typeparam name="TContents">The type of contents to put in each node.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.Item(Echo.Code.IVariable)">
            <summary>
            Gets or sets the variable dependency assigned to the variable.
            </summary>
            <param name="variable">The variable</param>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Remove(Echo.DataFlow.VariableDependency{`0})">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.EdgeCount">
            <summary>
            Gets the total number of edges that are stored in this dependency collection.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.TryGetDependency(Echo.Code.IVariable,Echo.DataFlow.VariableDependency{`0}@)">
            <summary>
            Attempts to get the dependency assigned to the provided variable.
            </summary>
            <param name="variable">The variable.</param>
            <param name="dependency">When this function returns <c>true</c>, contains the dependency.</param>
            <returns><c>true</c> if the variable was registered as a dependency, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Add(Echo.DataFlow.VariableDependency{`0})">
            <summary>
            Adds a variable dependency to the node.
            </summary>
            <param name="dependency">The dependency to add.</param>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Contains(Echo.DataFlow.VariableDependency{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.ContainsVariable(Echo.Code.IVariable)">
            <summary>
            Determines whether the provided variable is registered as a dependency.
            </summary>
            <param name="variable">The dependency.</param>
            <returns></returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.CopyTo(Echo.DataFlow.VariableDependency{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Remove(Echo.Code.IVariable)">
            <summary>
            Unregisters a variable as a dependency. 
            </summary>
            <param name="variable">The variable to unregister.</param>
            <returns><c>true</c> if the variable was registered before and is now unregistered, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.GetRegisteredVariables">
            <summary>
            Obtains a collection of variables that are registered in the dependency. 
            </summary>
            <returns>The variables.</returns>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.GetEnumerator">
            <summary>
            Obtains an enumerator that enumerates all recorded variable dependencies in this collection. 
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator">
            <summary>
            Represents an enumerator that enumerates all entries in a variable dependencies collection.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.#ctor(Echo.DataFlow.Collections.VariableDependencyCollection{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator"/> class.
            </summary>
            <param name="collection">The collection to enumerate.</param>
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Collections.VariableDependencyCollection`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.DataDependency`2">
            <summary>
            Provides a base for data dependencies of a node in a data flow graph, which is a set of one or more data flow
            nodes where the owner node might pull data from.
            </summary>
            <typeparam name="TSource">The type of data source that this dependency uses.</typeparam>
            <typeparam name="TContents">The type of contents to put in a data flow node.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.DataDependency`2.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataDependency`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataDependency`2.HasKnownDataSources">
            <summary>
            Gets a value indicating whether the data dependency has any known data sources. 
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataDependency`2.Dependent">
            <summary>
            Gets the node that owns the dependency.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.System#Collections#Generic#ICollection{TSource}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.Remove(Echo.DataFlow.DataFlowNode{`1})">
            <summary>
            Removes all data sources that are incident with the provided node.
            </summary>
            <param name="node">The node.</param>
            <returns><c>true</c> if at least one edge was removed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.GetEdges">
            <summary>
            Gets a collection of data flow edges that encode the stored data sources.
            </summary>
            <returns>The edges.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataDependency`2.GetNodes">
            <summary>
            Gets a collection of nodes that are possible data sources for the dependency.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Echo.DataFlow.DataDependencyType">
            <summary>
            Provides members for describing types of dependencies between nodes in a data flow graph.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.DataDependencyType.Stack">
            <summary>
            Indicates the dependency is a stack dependency.
            </summary>
        </member>
        <member name="F:Echo.DataFlow.DataDependencyType.Variable">
            <summary>
            Indicates the dependency is a variable dependency.
            </summary>
        </member>
        <member name="T:Echo.DataFlow.DataFlowEdge`1">
            <summary>
            Represents an edge between two nodes in a data flow graph (DFG). The origin of the node represents the dependant,
            and the target of the node represents the dependency.
            </summary>
            <typeparam name="TContents">The type of information to store in each data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.DataFlowEdge`1.#ctor(Echo.DataFlow.DataFlowNode{`0},Echo.DataFlow.DataSource{`0})">
            <summary>
            Creates a new dependency edge between two nodes.
            </summary>
            <param name="dependent">The dependent node.</param>
            <param name="target">The dependency node.</param>
        </member>
        <member name="P:Echo.DataFlow.DataFlowEdge`1.Dependent">
            <summary>
            Gets node that depends on the data source. 
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowEdge`1.DataSource">
            <summary>
            Gets the data source this data flow edge points to.
            </summary>
        </member>
        <member name="T:Echo.DataFlow.DataFlowGraph`1">
            <summary>
            Represents a graph that encodes data dependencies between objects. An edge (A, B) indicates node A depends on
            the evaluation of node B.
            </summary>
            <typeparam name="TContents">The type of contents to store for each node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.#ctor(Echo.Code.IArchitecture{`0})">
            <summary>
            Creates a new data flow graph.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowGraph`1.Architecture">
            <summary>
            Gets the architecture of the instructions that are stored in the data flow graph.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowGraph`1.Nodes">
            <summary>
            Gets a collection of nodes that are present in the graph.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.Echo#Graphing#ISubGraph#GetNodes">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.Echo#Graphing#ISubGraph#GetSubGraphs">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.GetEdges">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataFlowGraph`1.ToDotGraph(System.IO.TextWriter)">
            <summary>
            Serializes the data flow graph to the provided output text writer using the dot file format.
            </summary>
            <param name="writer">The output stream.</param>
            <remarks>
            To customize the look of the resulting dot file graph, use the <see cref="T:Echo.Graphing.Serialization.Dot.DotWriter"/> class
            instead of this function.
            </remarks>
        </member>
        <member name="T:Echo.DataFlow.DataFlowNode`1">
            <summary>
            Represents a single node in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of contents to store in the node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.#ctor(System.Int64,`0)">
            <summary>
            Creates a new data flow graph node.
            </summary>
            <param name="id">A unique identifier for the node that can be used for indexing the node.</param>
            <param name="contents">The contents of the node.</param>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.ParentGraph">
            <summary>
            Gets the data flow graph this node is a part of.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.Id">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.InDegree">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.OutDegree">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.IsExternal">
            <summary>
            Gets a value indicating whether the data flow node represents an external data source.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.Contents">
            <summary>
            Gets the contents of the node.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.StackDependencies">
            <summary>
            Gets a collection of values allocated on a stack that this node depends on.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataFlowNode`1.VariableDependencies">
            <summary>
            Gets a collection of values that are assigned to variables that this node depends on.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.GetIncomingEdges">
            <summary>
            Obtains a collection of edges that refer to dependent nodes.
            </summary>
            <returns>The edges.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.GetOutgoingEdges">
            <summary>
            Obtains a collection of edges encoding all the dependencies that this node has.
            </summary>
            <returns>The edges.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.GetDependants">
            <summary>
            Obtains a collection of nodes that depend on this node.
            </summary>
            <returns>The dependant nodes.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.Disconnect">
            <summary>
            Removes all incident edges (both incoming and outgoing edges) from the node, effectively isolating the node
            in the graph. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataFlowNode`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.DataSource`1">
            <summary>
            Represents a data source in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of data stored in each data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.#ctor(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Creates a new data source.
            </summary>
            <param name="node">The node producing the data.</param>
        </member>
        <member name="P:Echo.DataFlow.DataSource`1.Node">
            <summary>
            Gets the data flow node that produced the data.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.DataSource`1.Type">
            <summary>
            Gets the type of data dependency that this data source encodes.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.Equals(Echo.DataFlow.DataSource{`0})">
            <summary>
            Determines whether the data sources are considered equal.
            </summary>
            <param name="other">The other data source.</param>
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.op_Equality(Echo.DataFlow.DataSource{`0},Echo.DataFlow.DataSource{`0})">
            <summary>
            Determines whether the data sources are considered equal.
            </summary>
            <param name="a">The first data source.</param>
            <param name="b">The second data source.</param>
            <returns><c>true</c> if they are considered equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.DataSource`1.op_Inequality(Echo.DataFlow.DataSource{`0},Echo.DataFlow.DataSource{`0})">
            <summary>
            Determines whether the data sources are not considered equal.
            </summary>
            <param name="a">The first data source.</param>
            <param name="b">The second data source.</param>
            <returns><c>true</c> if they are not considered equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Echo.DataFlow.Emulation.StackImbalanceException">
            <summary>
            The exception that is thrown when an inconsistency in the size of the stack was detected. Typically this
            exception occurs when two or more converging control flow paths have inconsistent stack sizes, or when
            either an insufficient or excessive amount of values were pushed onto the stack.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.StackImbalanceException.#ctor">
            <summary>
            Creates a new stack imbalance exception.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.StackImbalanceException.#ctor(System.Int64)">
            <summary>
            Creates a new stack imbalance exception.
            </summary>
            <param name="offset">The offset where the stack inconsistency was detected.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.StackImbalanceException.#ctor(System.String)">
            <summary>
            Creates a new stack imbalance exception.
            </summary>
            <param name="message">The message of the error that occured.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.StackImbalanceException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new stack imbalance exception.
            </summary>
            <param name="message">The message of the error that occured.</param>
            <param name="innerException">The inner cause of the exception.</param>
        </member>
        <member name="P:Echo.DataFlow.Emulation.StackImbalanceException.Offset">
            <summary>
            Gets the offset where the stack inconsistency was detected.
            </summary>
        </member>
        <member name="T:Echo.DataFlow.Emulation.SymbolicProgramState`1">
            <summary>
            Represents an immutable snapshot of a program state that is fully symbolic.  
            </summary>
            <typeparam name="T">The type of instructions.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicProgramState`1.Empty">
            <summary>
            Gets an empty program state.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.#ctor(System.Int64)">
            <summary>
            Creates a new empty program state, initialized at the provided program counter.
            </summary>
            <param name="programCounter">The initial program counter.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.#ctor(System.Int64,System.Collections.Immutable.ImmutableStack{Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Creates a new empty program state, initialized at the provided program counter.
            </summary>
            <param name="programCounter">The initial program counter.</param>
            <param name="stack">The initial stack state.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.#ctor(System.Int64,System.Collections.Immutable.ImmutableDictionary{Echo.Code.IVariable,Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Creates a new empty program state, initialized at the provided program counter.
            </summary>
            <param name="programCounter">The initial program counter.</param>
            <param name="variables">The initial state of the variables.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.#ctor(System.Int64,System.Collections.Immutable.ImmutableStack{Echo.DataFlow.Emulation.SymbolicValue{`0}},System.Collections.Immutable.ImmutableDictionary{Echo.Code.IVariable,Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Creates a new empty program state, initialized at the provided program counter.
            </summary>
            <param name="programCounter">The initial program counter.</param>
            <param name="stack">The initial stack state.</param>
            <param name="variables">The initial state of the variables.</param>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicProgramState`1.ProgramCounter">
            <summary>
            Gets the current value of the program counter that points to the instruction to be executed next.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicProgramState`1.Stack">
            <summary>
            Gets the current stack state of the program.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicProgramState`1.Variables">
            <summary>
            Gets the current variable state of the program.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.WithProgramCounter(System.Int64)">
            <summary>
            Copies the current state and moves the program counter of the copy to the provided address.
            </summary>
            <param name="programCounter">The new program counter.</param>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.WithStack(System.Collections.Immutable.ImmutableStack{Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Copies the current state and replaces the stack state with a new one.
            </summary>
            <param name="stack">The new stack state.</param>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.WithVariables(System.Collections.Immutable.ImmutableDictionary{Echo.Code.IVariable,Echo.DataFlow.Emulation.SymbolicValue{`0}})">
            <summary>
            Copies the current state and replaces the variables state with a new one.
            </summary>
            <param name="variables">The new variables state.</param>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.Push(Echo.DataFlow.Emulation.SymbolicValue{`0})">
            <summary>
            Copies the current state and pushes a new value onto the stack. 
            </summary>
            <param name="value">The new value.</param>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.Pop(Echo.DataFlow.Emulation.SymbolicValue{`0}@)">
            <summary>
            Copies the current state and pops the top value from the stack. 
            </summary>
            <param name="value">The popped value.</param>
            <exception cref="T:Echo.DataFlow.Emulation.StackImbalanceException">Occurs when the stack is empty.</exception>
            <returns>The new program state.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.MergeStates(Echo.DataFlow.Emulation.SymbolicProgramState{`0}@,Echo.DataFlow.Emulation.SymbolicProgramState{`0}@)">
            <summary>
            Merges two program states together, combining all data sources.
            </summary>
            <param name="otherState">The other program state to merge with.</param>
            <param name="newState">The newly created state.</param>
            <returns><c>true</c> if the state has changed, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the program counters do not match.</exception>
            <exception cref="T:Echo.DataFlow.Emulation.StackImbalanceException">Occurs when the stack heights do not match.</exception>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicProgramState`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Emulation.SymbolicValue`1">
            <summary>
            Represents a symbolic value that resides in memory. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.#ctor">
            <summary>
            Creates a new symbolic value with no data sources.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.#ctor(Echo.DataFlow.DataSource{`0})">
            <summary>
            Creates a new symbolic value with a single data source.
            </summary>
            <param name="dataSource">The data source of the symbolic value.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.#ctor(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <summary>
            Creates a new symbolic value with the provided data sources.
            </summary>
            <param name="dataSources">The data sources of the symbolic value.</param>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.#ctor(Echo.DataFlow.Emulation.SymbolicValue{`0},Echo.DataFlow.Emulation.SymbolicValue{`0})">
            <summary>
            Merges two data dependencies into one symbolic value.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.HasKnownDataSources">
            <summary>
            Gets a value indicating whether the data dependency has any known data sources. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.CreateStackValue(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Creates a new symbolic value referencing the first stack value produced by the provided node. 
            </summary>
            <param name="node">The node producing the value.</param>
            <returns>The symbolic value.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.CreateStackValue(Echo.DataFlow.DataFlowNode{`0},System.Int32)">
            <summary>
            Creates a new symbolic value referencing a stack value produced by the provided node. 
            </summary>
            <param name="node">The node producing the value.</param>
            <param name="slotIndex">The index of the stack value that was produced by the node.</param>
            <returns>The symbolic value.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.CreateVariableValue(Echo.DataFlow.DataFlowNode{`0},Echo.Code.IVariable)">
            <summary>
            Creates a new symbolic value referencing a variable value assigned by the provided node. 
            </summary>
            <param name="node">The node assigning the value.</param>
            <param name="variable">The variable that was assigned a value.</param>
            <returns>The symbolic value.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.AsStackValue">
            <summary>
            Interprets the symbolic value as a collection of stack data sources.
            </summary>
            <returns>The stack data sources.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.AsVariableValue">
            <summary>
            Interprets the symbolic value as a collection of variable data sources.
            </summary>
            <returns>The variable data sources.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Add(Echo.DataFlow.DataSource{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.ExceptWith(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IntersectWith(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IsSubsetOf(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.IsSupersetOf(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Overlaps(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.SetEquals(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.UnionWith(System.Collections.Generic.IEnumerable{Echo.DataFlow.DataSource{`0}})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Contains(Echo.DataFlow.DataSource{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.CopyTo(Echo.DataFlow.DataSource{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Remove(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Removes all data sources that are related to the specified node.
            </summary>
            <param name="node">The node to remove all data sources from.</param>
            <returns><c>true</c> if any data source was removed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Remove(Echo.DataFlow.DataSource{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.GetNodes">
            <summary>
            Gets a collection of nodes that were referenced by all data sources in this data dependency.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates over all data sources the data dependency defines.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator">
            <summary>
            Provides a mechanism for enumerating all data sources within a single symbolic value. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.#ctor(Echo.DataFlow.Emulation.SymbolicValue{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator"/> structure.
            </summary>
            <param name="collection">The data dependency to enumerate the data sources for.</param>
        </member>
        <member name="P:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.Emulation.SymbolicValue`1.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.ExternalDataSourceNode`1">
            <summary>
            Represents an external data source in a data flow graph. 
            </summary>
            <typeparam name="TContents">The type of contents to store in the node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.ExternalDataSourceNode`1.#ctor(System.Int64,System.String)">
            <summary>
            Creates a new external data source.
            </summary>
            <param name="id">The unique identifier of the data source. This should be a negative number.</param>
            <param name="name">The display name of the external data source.</param>
        </member>
        <member name="M:Echo.DataFlow.ExternalDataSourceNode`1.#ctor(System.Int64,System.String,`0)">
            <summary>
            Creates a new external data source.
            </summary>
            <param name="id">The unique identifier of the data source. This should be a negative number.</param>
            <param name="name">The display name of the external data source.</param>
            <param name="contents">The contents of the data flow node.</param>
        </member>
        <member name="P:Echo.DataFlow.ExternalDataSourceNode`1.Name">
            <summary>
            Gets the name of the auxiliary data flow node.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.ExternalDataSourceNode`1.IsExternal">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.ExternalDataSourceNode`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1">
            <summary>
            Represents an adorner that styles edges in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of contents the nodes contain.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.StackDependencyStyle">
            <summary>
            Gets or sets the edge style to use for edges representing stack dependencies.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.IncludeStackEdgeLabels">
            <summary>
            Gets or sets a value indicating whether edges representing stack dependencies should be annotated
            with the stack slot index. 
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.VariableDependencyStyle">
            <summary>
            Gets or sets the edge style to use for edges representing variable dependencies.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.IncludeVariableEdgeLabels">
            <summary>
            Gets or sets a value indicating whether edges representing variable dependencies should be annotated
            with the variable that was referenced. 
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Serialization.Dot.DataFlowEdgeAdorner`1.GetEdgeAttributes(Echo.Graphing.IEdge,System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.Serialization.Dot.DataFlowNodeAdorner`1">
            <summary>
            Represents an adorner that adds the string representation of the embedded instructions to a node in a graph.
            </summary>
            <typeparam name="TContents">The type of instructions the nodes contain.</typeparam>
        </member>
        <member name="P:Echo.DataFlow.Serialization.Dot.DataFlowNodeAdorner`1.NodeShape">
            <summary>
            Gets or sets the shape of the node.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.Serialization.Dot.DataFlowNodeAdorner`1.GetNodeAttributes(Echo.Graphing.INode,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.StackDataSource`1">
            <summary>
            Represents a data source that refers to a stack value produced by a node in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of data stored in each data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.#ctor(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Creates a new stack data source, referencing the first stack value produced by the provided node.
            </summary>
            <param name="node">The node producing the value.</param>
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.#ctor(Echo.DataFlow.DataFlowNode{`0},System.Int32)">
            <summary>
            Creates a new stack data source, referencing a stack value produced by the provided node.
            </summary>
            <param name="node">The node producing the value.</param>
            <param name="slotIndex">The index of the stack value that was produced by the node.</param>
        </member>
        <member name="P:Echo.DataFlow.StackDataSource`1.SlotIndex">
            <summary>
            Gets a value indicating the stack slot index that was pushed by the instruction referenced in <see cref="P:Echo.DataFlow.DataSource`1.Node"/>.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.StackDataSource`1.Type">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.Equals(Echo.DataFlow.DataSource{`0})">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.StackDataSource`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.StackDependency`1">
            <summary>
            Represents a collection of data sources for a single stack slot dependency of a node.
            </summary>
            <typeparam name="TContents">The type of contents to put in a data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.StackDependency`1.Add(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Adds a data source to the dependency, referencing the first stack value produced by the provided node.
            </summary>
            <param name="node">The node producing the value.</param>
            <returns>The stack data source.</returns>
        </member>
        <member name="M:Echo.DataFlow.StackDependency`1.Add(Echo.DataFlow.DataFlowNode{`0},System.Int32)">
            <summary>
            Adds a data source to the dependency, referencing a stack value produced by the provided node.
            </summary>
            <param name="node">The node producing the value.</param>
            <param name="slotIndex">The index of the stack value that was produced by the node.</param>
            <returns>The stack data source.</returns>
        </member>
        <member name="T:Echo.DataFlow.VariableDataSource`1">
            <summary>
            Represents a data source that refers to a variable value assigned by a node in a data flow graph.
            </summary>
            <typeparam name="TContents">The type of data stored in each data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.VariableDataSource`1.#ctor(Echo.DataFlow.DataFlowNode{`0},Echo.Code.IVariable)">
            <summary>
            Creates a new variable data source referencing a variable value assigned by the provided node. 
            </summary>
            <param name="node">The node assigning the value.</param>
            <param name="variable">The variable that was assigned a value.</param>
        </member>
        <member name="P:Echo.DataFlow.VariableDataSource`1.Variable">
            <summary>
            Gets the variable that was referenced by <see cref="P:Echo.DataFlow.DataSource`1.Node"/>.
            </summary>
        </member>
        <member name="P:Echo.DataFlow.VariableDataSource`1.Type">
            <inheritdoc />
        </member>
        <member name="M:Echo.DataFlow.VariableDataSource`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.DataFlow.VariableDependency`1">
            <summary>
            Represents a collection of data sources for a single variable dependency of a node.
            </summary>
            <typeparam name="TContents">The type of contents to put in a data flow node.</typeparam>
        </member>
        <member name="M:Echo.DataFlow.VariableDependency`1.#ctor(Echo.Code.IVariable)">
            <summary>
            Creates a new variable dependency.
            </summary>
            <param name="variable">The variable to depend on.</param>
        </member>
        <member name="P:Echo.DataFlow.VariableDependency`1.Variable">
            <summary>
            Gets the variable that is depended upon.
            </summary>
        </member>
        <member name="M:Echo.DataFlow.VariableDependency`1.Add(Echo.DataFlow.DataFlowNode{`0})">
            <summary>
            Adds a data source to the dependency, referencing a variable value assigned by the provided node. 
            </summary>
            <param name="node">The node assigning the value.</param>
            <returns>The variable data source.</returns>
        </member>
    </members>
</doc>



================================================
File: lib/Echo.Platforms.AsmResolver.deps.json
================================================
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.0/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.0": {},
    ".NETStandard,Version=v2.0/": {
      "Echo.Platforms.AsmResolver/0.9.0.1": {
        "dependencies": {
          "AsmResolver.DotNet": "6.0.0-beta.1",
          "Echo": "0.9.0.1",
          "Echo.ControlFlow": "0.9.0.1",
          "NETStandard.Library": "2.0.3",
          "Nullable": "1.3.1"
        },
        "runtime": {
          "Echo.Platforms.AsmResolver.dll": {}
        }
      },
      "AsmResolver/6.0.0-beta.1": {
        "runtime": {
          "lib/netstandard2.0/AsmResolver.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.0.0"
          }
        }
      },
      "AsmResolver.DotNet/6.0.0-beta.1": {
        "dependencies": {
          "AsmResolver.PE": "6.0.0-beta.1"
        },
        "runtime": {
          "lib/netstandard2.0/AsmResolver.DotNet.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.0.0"
          }
        }
      },
      "AsmResolver.PE/6.0.0-beta.1": {
        "dependencies": {
          "AsmResolver.PE.File": "6.0.0-beta.1"
        },
        "runtime": {
          "lib/netstandard2.0/AsmResolver.PE.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.0.0"
          }
        }
      },
      "AsmResolver.PE.File/6.0.0-beta.1": {
        "dependencies": {
          "AsmResolver": "6.0.0-beta.1"
        },
        "runtime": {
          "lib/netstandard2.0/AsmResolver.PE.File.dll": {
            "assemblyVersion": "6.0.0.0",
            "fileVersion": "6.0.0.0"
          }
        }
      },
      "Microsoft.NETCore.Platforms/1.1.0": {},
      "NETStandard.Library/2.0.3": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0"
        }
      },
      "Nullable/1.3.1": {},
      "System.Buffers/4.5.1": {
        "runtime": {
          "lib/netstandard2.0/System.Buffers.dll": {
            "assemblyVersion": "4.0.3.0",
            "fileVersion": "4.6.28619.1"
          }
        }
      },
      "System.Collections.Immutable/1.7.1": {
        "dependencies": {
          "System.Memory": "4.5.5"
        },
        "runtime": {
          "lib/netstandard2.0/System.Collections.Immutable.dll": {
            "assemblyVersion": "1.2.5.0",
            "fileVersion": "4.700.20.21406"
          }
        }
      },
      "System.Memory/4.5.5": {
        "dependencies": {
          "System.Buffers": "4.5.1",
          "System.Numerics.Vectors": "4.4.0",
          "System.Runtime.CompilerServices.Unsafe": "4.5.3"
        },
        "runtime": {
          "lib/netstandard2.0/System.Memory.dll": {
            "assemblyVersion": "4.0.1.2",
            "fileVersion": "4.6.31308.1"
          }
        }
      },
      "System.Numerics.Vectors/4.4.0": {
        "runtime": {
          "lib/netstandard2.0/System.Numerics.Vectors.dll": {
            "assemblyVersion": "4.1.3.0",
            "fileVersion": "4.6.25519.3"
          }
        }
      },
      "System.Runtime.CompilerServices.Unsafe/4.5.3": {
        "runtime": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "assemblyVersion": "4.0.4.1",
            "fileVersion": "4.6.28619.1"
          }
        }
      },
      "Echo/0.9.0.1": {
        "dependencies": {
          "System.Memory": "4.5.5"
        },
        "runtime": {
          "Echo.dll": {}
        }
      },
      "Echo.ControlFlow/0.9.0.1": {
        "dependencies": {
          "Echo": "0.9.0.1",
          "Echo.DataFlow": "0.9.0.1",
          "System.Memory": "4.5.5"
        },
        "runtime": {
          "Echo.ControlFlow.dll": {}
        }
      },
      "Echo.DataFlow/0.9.0.1": {
        "dependencies": {
          "Echo": "0.9.0.1",
          "System.Collections.Immutable": "1.7.1"
        },
        "runtime": {
          "Echo.DataFlow.dll": {}
        }
      }
    }
  },
  "libraries": {
    "Echo.Platforms.AsmResolver/0.9.0.1": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "AsmResolver/6.0.0-beta.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-M5btCR/rmrx32jZsoN6CLQ/VQk8lN8hvPb6lgojua7pjNoo7StAl92koMC8qz4vzZyH2CNqxLSDoswRvyyK/vA==",
      "path": "asmresolver/6.0.0-beta.1",
      "hashPath": "asmresolver.6.0.0-beta.1.nupkg.sha512"
    },
    "AsmResolver.DotNet/6.0.0-beta.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-PTq8nNQvhgTxF1iARCknffCsu7Iq9B0kN7TVC8iMaU7uEYog3xvVqH/0+TreY8GW74/+MqhZt/yEFsvS4oAduQ==",
      "path": "asmresolver.dotnet/6.0.0-beta.1",
      "hashPath": "asmresolver.dotnet.6.0.0-beta.1.nupkg.sha512"
    },
    "AsmResolver.PE/6.0.0-beta.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-KadLvx/zzFCJyF+E4jG6jPE1d0iJquzL6+hm8GBivBAs6nwHC8s6g4c857QwQCzXMWza6Vz5Q+3hFiNuOfKaWQ==",
      "path": "asmresolver.pe/6.0.0-beta.1",
      "hashPath": "asmresolver.pe.6.0.0-beta.1.nupkg.sha512"
    },
    "AsmResolver.PE.File/6.0.0-beta.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-+lusB9UMHevI5aQsu73NQ1ctPMLFvyHAsEf8vjaJ/py+kX1DkU0JkbERtBRmaf58/hBZ7cyrE7gFnjoo7Bbg7A==",
      "path": "asmresolver.pe.file/6.0.0-beta.1",
      "hashPath": "asmresolver.pe.file.6.0.0-beta.1.nupkg.sha512"
    },
    "Microsoft.NETCore.Platforms/1.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-kz0PEW2lhqygehI/d6XsPCQzD7ff7gUJaVGPVETX611eadGsA3A877GdSlU0LRVMCTH/+P3o2iDTak+S08V2+A==",
      "path": "microsoft.netcore.platforms/1.1.0",
      "hashPath": "microsoft.netcore.platforms.1.1.0.nupkg.sha512"
    },
    "NETStandard.Library/2.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-st47PosZSHrjECdjeIzZQbzivYBJFv6P2nv4cj2ypdI204DO+vZ7l5raGMiX4eXMJ53RfOIg+/s4DHVZ54Nu2A==",
      "path": "netstandard.library/2.0.3",
      "hashPath": "netstandard.library.2.0.3.nupkg.sha512"
    },
    "Nullable/1.3.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-Mk4ZVDfAORTjvckQprCSehi1XgOAAlk5ez06Va/acRYEloN9t6d6zpzJRn5MEq7+RnagyFIq9r+kbWzLGd+6QA==",
      "path": "nullable/1.3.1",
      "hashPath": "nullable.1.3.1.nupkg.sha512"
    },
    "System.Buffers/4.5.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-Rw7ijyl1qqRS0YQD/WycNst8hUUMgrMH4FCn1nNm27M4VxchZ1js3fVjQaANHO5f3sN4isvP4a+Met9Y4YomAg==",
      "path": "system.buffers/4.5.1",
      "hashPath": "system.buffers.4.5.1.nupkg.sha512"
    },
    "System.Collections.Immutable/1.7.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-B43Zsz5EfMwyEbnObwRxW5u85fzJma3lrDeGcSAV1qkhSRTNY5uXAByTn9h9ddNdhM+4/YoLc/CI43umjwIl9Q==",
      "path": "system.collections.immutable/1.7.1",
      "hashPath": "system.collections.immutable.1.7.1.nupkg.sha512"
    },
    "System.Memory/4.5.5": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-XIWiDvKPXaTveaB7HVganDlOCRoj03l+jrwNvcge/t8vhGYKvqV+dMv6G4SAX2NoNmN0wZfVPTAlFwZcZvVOUw==",
      "path": "system.memory/4.5.5",
      "hashPath": "system.memory.4.5.5.nupkg.sha512"
    },
    "System.Numerics.Vectors/4.4.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-UiLzLW+Lw6HLed1Hcg+8jSRttrbuXv7DANVj0DkL9g6EnnzbL75EB7EWsw5uRbhxd/4YdG8li5XizGWepmG3PQ==",
      "path": "system.numerics.vectors/4.4.0",
      "hashPath": "system.numerics.vectors.4.4.0.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/4.5.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-3TIsJhD1EiiT0w2CcDMN/iSSwnNnsrnbzeVHSKkaEgV85txMprmuO+Yq2AdSbeVGcg28pdNDTPK87tJhX7VFHw==",
      "path": "system.runtime.compilerservices.unsafe/4.5.3",
      "hashPath": "system.runtime.compilerservices.unsafe.4.5.3.nupkg.sha512"
    },
    "Echo/0.9.0.1": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Echo.ControlFlow/0.9.0.1": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Echo.DataFlow/0.9.0.1": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    }
  }
}


================================================
File: lib/Echo.Platforms.AsmResolver.xml
================================================
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Echo.Platforms.AsmResolver</name>
    </assembly>
    <members>
        <member name="T:Echo.Platforms.AsmResolver.AsmResolverExtensions">
            <summary>
            Provides extension methods to AsmResolver models.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.AsmResolverExtensions.ToEchoRange(AsmResolver.DotNet.Code.Cil.CilExceptionHandler)">
            <summary>
            Converts an instance of <see cref="T:AsmResolver.DotNet.Code.Cil.CilExceptionHandler"/> to an <see cref="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange"/>. 
            </summary>
            <param name="handler">The handler to convert.</param>
            <returns>The converted handler.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.AsmResolverExtensions.ToEchoRanges(System.Collections.Generic.IEnumerable{AsmResolver.DotNet.Code.Cil.CilExceptionHandler})">
            <summary>
            Converts a collection of <see cref="T:AsmResolver.DotNet.Code.Cil.CilExceptionHandler"/> instances to a collection of
            <see cref="T:Echo.ControlFlow.Regions.Detection.ExceptionHandlerRange"/> instances. 
            </summary>
            <param name="handlers">The handlers to convert.</param>
            <returns>The converted handlers.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.AsmResolverExtensions.ConstructStaticFlowGraph(AsmResolver.DotNet.Code.Cil.CilMethodBody)">
            <summary>
            Constructs a control flow graph from a CIL method body.
            </summary>
            <param name="self">The method body.</param>
            <returns>The control flow graph.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.AsmResolverExtensions.ConstructSymbolicFlowGraph(AsmResolver.DotNet.Code.Cil.CilMethodBody,Echo.DataFlow.DataFlowGraph{AsmResolver.PE.DotNet.Cil.CilInstruction}@)">
            <summary>
            Constructs a control flow graph and a data flow graph from a CIL method body.
            </summary>
            <param name="self">The method body.</param>
            <param name="dataFlowGraph">The constructed data flow graph.</param>
            <returns>The control flow graph.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.CilArchitecture">
            <summary>
            Provides a description of the CIL instruction set architecture (ISA) that is modelled by AsmResolver.   
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.#ctor(AsmResolver.DotNet.Code.Cil.CilMethodBody)">
            <summary>
            Creates a new CIL architecture description based on a CIL method body.
            </summary>
            <param name="parentBody">The method body.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilArchitecture.MethodBody">
            <summary>
            Gets the method body that was encapsulated.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilArchitecture.SuccessorResolver">
            <summary>
            Gets the default static successor resolution engine for this architecture.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetLocal(AsmResolver.DotNet.Code.Cil.CilLocalVariable)">
            <summary>
            Gets the Echo symbol for the provided <see cref="T:AsmResolver.DotNet.Code.Cil.CilLocalVariable"/> instance.
            </summary>
            <param name="variable">The local variable.</param>
            <returns>The Echo symbol representing the local variable.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetParameter(AsmResolver.DotNet.Collections.Parameter)">
            <summary>
            Gets the Echo symbol for the provided <see cref="T:AsmResolver.DotNet.Collections.Parameter"/> instance.
            </summary>
            <param name="variable">The parameter.</param>
            <returns>The Echo symbol representing the parameter.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetOffset(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetSize(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetFlowControl(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetStackPushCount(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetStackPopCount(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetReadVariablesCount(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetReadVariables(AsmResolver.PE.DotNet.Cil.CilInstruction@,System.Span{Echo.Code.IVariable})">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetWrittenVariablesCount(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilArchitecture.GetWrittenVariables(AsmResolver.PE.DotNet.Cil.CilInstruction@,System.Span{Echo.Code.IVariable})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.CilInstructionFormatterAdapter">
            <summary>
            Provides a custom formatter for <see cref="T:AsmResolver.PE.DotNet.Cil.CilInstruction"/>s.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilInstructionFormatterAdapter.Format(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.CilParameter">
            <summary>
            Represents a parameter that is declared and can be referenced within a CIL method.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilParameter.#ctor(AsmResolver.DotNet.Collections.Parameter)">
            <summary>
            Creates a new CIL parameter.
            </summary>
            <param name="parameter">The underlying parameter</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilParameter.Parameter">
            <summary>
            Gets the underlying parameter object.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilParameter.Name">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilParameter.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.CilPurityClassifier">
            <summary>
            Provides an implementation for the <see cref="T:Echo.Code.IPurityClassifier`1"/> interface that determines
            whether CIL instructions are considered pure or have side effects.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilPurityClassifier.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Echo.Platforms.AsmResolver.CilPurityClassifier"/> class.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.LocalWritePurity">
            <summary>
            Gets or sets a value indicating whether writes to local variables should be considered pure or not.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.ArrayWritePurity">
            <summary>
            Gets or sets a value indicating whether writes to arrays should be considered pure or not.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.PointerWritePurity">
            <summary>
            Gets or sets a value indicating whether writes to pointers should be considered pure or not.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.DefaultFieldAccessPurity">
            <summary>
            Gets or sets a value indicating whether field read accesses should be considered pure or not by default.  
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.DefaultFieldWritePurity">
            <summary>
            Gets or sets a value indicating whether writes to field should be considered pure or not by default.  
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.DefaultMethodAccessPurity">
            <summary>
            Gets or sets a value indicating whether method accesses (e.g. reading method pointers) should be
            considered pure or not by default.  
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.DefaultMethodCallPurity">
            <summary>
            Gets or sets a value indicating whether method calls should be considered pure or not by default.  
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.DefaultIndirectCallPurity">
            <summary>
            Gets or sets a value indicating whether indirect method calls should be considered pure or not by default.  
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.DefaultTypeAccessPurity">
            <summary>
            Gets or sets a value indicating whether type access (e.g. pushing type tokens) should be considered pure
            or not by default.  
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.KnownPureMethods">
            <summary>
            Gets a mutable collection of known methods that should be considered pure.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilPurityClassifier.KnownImpureMethods">
            <summary>
            Gets a mutable collection of known methods that should be considered impure and guaranteed have side-effects.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilPurityClassifier.IsPure(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.CilStateTransitioner">
            <summary>
            Provides an implementation of a state transition resolver for the CIL instruction set.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilStateTransitioner.#ctor(Echo.Platforms.AsmResolver.CilArchitecture)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.Platforms.AsmResolver.CilStateTransitioner"/> class.
            </summary>
            <param name="architecture">The CIL architecture variant to compute state transitions for.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilStateTransitioner.GetInitialState(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilStateTransitioner.GetTransitionCount(Echo.DataFlow.Emulation.SymbolicProgramState{AsmResolver.PE.DotNet.Cil.CilInstruction}@,AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilStateTransitioner.GetTransitions(Echo.DataFlow.Emulation.SymbolicProgramState{AsmResolver.PE.DotNet.Cil.CilInstruction}@,AsmResolver.PE.DotNet.Cil.CilInstruction@,System.Span{Echo.ControlFlow.Construction.Symbolic.StateTransition{AsmResolver.PE.DotNet.Cil.CilInstruction}})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.CilStaticSuccessorResolver">
            <summary>
            Provides an implementation of <see cref="T:Echo.ControlFlow.Construction.Static.IStaticSuccessorResolver`1"/>
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilStaticSuccessorResolver.Instance">
            <summary>
            Gets a reusable singleton instance of the static successor resolver for the CIL architecture.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilStaticSuccessorResolver.GetSuccessorsCount(AsmResolver.PE.DotNet.Cil.CilInstruction@)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilStaticSuccessorResolver.GetSuccessors(AsmResolver.PE.DotNet.Cil.CilInstruction@,System.Span{Echo.ControlFlow.Construction.SuccessorInfo})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.CilVariable">
            <summary>
            Represents a variable that is declared and can be referenced within a CIL method body.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilVariable.#ctor(AsmResolver.DotNet.Code.Cil.CilLocalVariable)">
            <summary>
            Creates a new CIL variable.
            </summary>
            <param name="variable">The underlying variable object.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilVariable.Variable">
            <summary>
            Gets the underlying local variable object.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.CilVariable.Name">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.CilVariable.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.CilEmulatorException">
            <summary>
            The exception that occurs when a <see cref="T:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine"/> encounters an internal error.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilEmulatorException.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.CilEmulatorException"/> class.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilEmulatorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.CilEmulatorException"/> class.
            </summary>
            <param name="message">The error message.</param>
            <param name="inner">The inner cause of the error.</param>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.CilThread">
            <summary>
            Represents a single execution thread in a virtualized .NET process.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilThread.Machine">
            <summary>
            Gets the parent machine the thread is running in.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilThread.CallStack">
            <summary>
            Gets the current state of the call stack.
            </summary>
            <remarks>
            The call stack is also addressable from <see cref="N:Echo.Memory"/>.
            </remarks>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilThread.IsAlive">
            <summary>
            Gets a value indicating whether the thread is alive and present in the parent machine.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.Run">
            <summary>
            Runs the virtual machine until it halts.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.Run(System.Threading.CancellationToken)">
            <summary>
            Runs the virtual machine until it halts.
            </summary>
            <param name="cancellationToken">A token that can be used for canceling the emulation.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.Call(AsmResolver.DotNet.IMethodDescriptor,System.Object[])">
            <summary>
            Calls the provided method in the context of the virtual machine.
            </summary>
            <param name="method">The method to call.</param>
            <param name="arguments">The arguments.</param>
            <returns>The return value, or <c>null</c> if the provided method does not return a value.</returns>
            <remarks>
            This method is blocking until the emulation of the call completes.
            </remarks>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.Call(AsmResolver.DotNet.IMethodDescriptor,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Calls the provided method in the context of the virtual machine.
            </summary>
            <param name="method">The method to call.</param>
            <param name="cancellationToken">A token that can be used for canceling the emulation.</param>
            <param name="arguments">The arguments.</param>
            <returns>The return value, or <c>null</c> if the provided method does not return a value.</returns>
            <remarks>
            This method is blocking until the emulation of the call completes.
            </remarks>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.Call(AsmResolver.DotNet.IMethodDescriptor,Echo.Memory.BitVector[])">
            <summary>
            Calls the provided method in the context of the virtual machine.
            </summary>
            <param name="method">The method to call.</param>
            <param name="arguments">The arguments.</param>
            <returns>The return value, or <c>null</c> if the provided method does not return a value.</returns>
            <remarks>
            This method is blocking until the emulation of the call completes.
            </remarks>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.Call(AsmResolver.DotNet.IMethodDescriptor,System.Threading.CancellationToken,Echo.Memory.BitVector[])">
            <summary>
            Calls the provided method in the context of the virtual machine.
            </summary>
            <param name="method">The method to call.</param>
            <param name="cancellationToken">A token that can be used for canceling the emulation.</param>
            <param name="arguments">The arguments.</param>
            <returns>The return value, or <c>null</c> if the provided method does not return a value.</returns>
            <remarks>
            This method is blocking until the emulation of the call completes or the emulation is canceled.
            </remarks>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.StepWhile(System.Threading.CancellationToken,System.Predicate{Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext})">
            <summary>
            Continues execution of the virtual machine while the provided predicate returns <c>true</c>.
            </summary>
            <param name="cancellationToken">A token that can be used for canceling the emulation.</param>
            <param name="condition">
            A predicate that is evaluated on every step of the emulation, determining whether execution should continue.
            </param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.StepOver">
            <summary>
            Performs a single step in the virtual machine. If the current instruction performs a call, the emulation
            is treated as a single instruction.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.StepOver(System.Threading.CancellationToken)">
            <summary>
            Performs a single step in the virtual machine. If the current instruction performs a call, the emulation
            is treated as a single instruction.
            </summary>
            <param name="cancellationToken">A token that can be used for canceling the emulation.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.StepOut">
            <summary>
            Continues execution of the virtual machine until the current call frame is popped from the stack. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.StepOut(System.Threading.CancellationToken)">
            <summary>
            Continues execution of the virtual machine until the current call frame is popped from the stack. 
            </summary>
            <param name="cancellationToken">A token that can be used for canceling the emulation.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.Step">
            <summary>
            Performs a single step in the virtual machine.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilThread.Step(System.Threading.CancellationToken)">
            <summary>
            Performs a single step in the virtual machine.
            </summary>
            <param name="cancellationToken">A token that can be used for canceling the emulation.</param>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine">
            <summary>
            Represents a machine that executes CIL instructions in a virtual environment. 
            </summary>
        </member>
        <member name="E:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.ThreadCreated">
            <summary>
            Fires when a new thread was created.
            </summary>
        </member>
        <member name="E:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.ThreadDestroyed">
            <summary>
            Fires when a thread was destroyed.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.#ctor(AsmResolver.DotNet.ModuleDefinition,System.Boolean)">
            <summary>
            Creates a new CIL virtual machine.
            </summary>
            <param name="contextModule">The main module to base the context on.</param>
            <param name="is32Bit">Indicates whether the virtual machine runs in 32-bit mode or 64-bit mode.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Is32Bit">
            <summary>
            Gets a value indicating whether the environment is a 32-bit or 64-bit system.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Memory">
            <summary>
            Gets the main memory interface of the virtual machine.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Heap">
            <summary>
            Gets the heap used for storing managed objects. 
            </summary>
            <remarks>
            The heap is also addressable from <see cref="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Memory"/>.
            </remarks>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.StaticFields">
            <summary>
            Gets the memory chunk responsible for storing static fields.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.ObjectMapMemory">
            <summary>
            Gets the memory manager that embeds managed objects into virtual memory.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.ValueFactory">
            <summary>
            Gets the service that is responsible for managing types in the virtual machine.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.ContextModule">
            <summary>
            Gets the main module the emulator is executing instructions for.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Loader">
            <summary>
            Gets the service that is responsible for mapping executable files in memory.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Dispatcher">
            <summary>
            Gets the service that is responsible for dispatching individual instructions to their respective handlers.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Allocator">
            <summary>
            Gets the service that is responsible for allocating new objects.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Invoker">
            <summary>
            Gets the service that is responsible for invoking external functions or methods.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.TypeManager">
            <summary>
            Gets the service that is responsible for the initialization and management of runtime types residing in
            the virtual machine.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.UnknownResolver">
            <summary>
            Gets or sets the service that is responsible for resolving unknown values on the stack in critical moments.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.ObjectMarshaller">
            <summary>
            Gets or sets the service for marshalling managed objects into bitvectors and back.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.Threads">
            <summary>
            Gets a collection of threads that are currently active in the machine.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.CreateThread(System.UInt32)">
            <summary>
            Creates a new thread in the machine.
            </summary>
            <param name="stackSize">The amount of memory to allocate for the thread's stack.</param>
            <returns>The created thread.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine.DestroyThread(Echo.Platforms.AsmResolver.Emulation.CilThread)">
            <summary>
            Removes a thread and its stack from the machine. 
            </summary>
            <param name="thread">The thread to remove.</param>
            <remarks>
            This does not gracefully terminate a thread. Any code that is still running will remain executing, and may
            have unwanted side-effects. Therefore, be sure to only call this method only when it is certain that no code
            is running. 
            </remarks>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.CliMarshaller">
            <summary>
            Provides a mechanism for marshalling values in and out of the evaluation stack.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CliMarshaller.#ctor(Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.CliMarshaller"/> class.
            </summary>
            <param name="valueFactory">The factory that is used to create new objects with.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CliMarshaller.ToCliValue(Echo.Memory.BitVector,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Marshals the provided value to a value that can be pushed onto the stack. 
            </summary>
            <param name="value">The value to marshal.</param>
            <param name="originalType">The type to push the value as.</param>
            <returns>The marshalled stack slot.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.CliMarshaller.FromCliValue(Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Marshals the provided stack slot back to a normal bit vector that is to be used outside of the stack.
            </summary>
            <param name="value">The stack value.</param>
            <param name="targetType">The type to marshal to.</param>
            <returns>The marshalled value.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.AddHandler">
            <summary>
            Implements a CIL instruction handler for <c>add</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.AddHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.AddHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.AddHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.AndHandler">
            <summary>
            Implements a CIL instruction handler for <c>and</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.AndHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.AndHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.AndHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.BinaryOperatorHandlerBase">
            <summary>
            Provides a base for binary operator instruction handlers.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.BinaryOperatorHandlerBase.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.BinaryOperatorHandlerBase.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <summary>
            Gets a value indicating whether the instruction always pushes a 32-bit value.
            </summary>
            <param name="instruction">The instruction to classify.</param>
            <returns><c>true</c> if a 32-bit value is always pushed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.BinaryOperatorHandlerBase.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <summary>
            Gets a value indicating whether the instruction is a signed operation or not.
            </summary>
            <param name="instruction">The instruction to classify.</param>
            <returns><c>true</c> if signed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.BinaryOperatorHandlerBase.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Evaluates the binary operation on two arguments. 
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="instruction">The instruction to dispatch and evaluate.</param>
            <param name="argument1">The first argument that also receives the output.</param>
            <param name="argument2">The second argument.</param>
            <returns>A value indicating whether the dispatch was successful or caused an error.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CeqHandler">
            <summary>
            Implements a CIL instruction handler for <c>ceq</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CeqHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CeqHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CeqHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CgtHandler">
            <summary>
            Implements a CIL instruction handler for <c>cgt</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CgtHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CgtHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CgtHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CltHandler">
            <summary>
            Implements a CIL instruction handler for <c>clt</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CltHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CltHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.CltHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.DivHandler">
            <summary>
            Implements a CIL instruction handler for <c>div</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.DivHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.DivHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.DivHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.MulHandler">
            <summary>
            Implements a CIL instruction handler for <c>mul</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.MulHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.MulHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.MulHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.NegHandler">
            <summary>
            Implements a CIL instruction handler for <c>neg</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.NegHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.NotHandler">
            <summary>
            Implements a CIL instruction handler for <c>not</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.NotHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.OrHandler">
            <summary>
            Implements a CIL instruction handler for <c>pr</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.OrHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.OrHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.OrHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.RemHandler">
            <summary>
            Implements a CIL instruction handler for <c>rem</c> operations and it derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.RemHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.RemHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.RemHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.ShlHandler">
            <summary>
            Implements a CIL instruction handler for <c>shl</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.ShlHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.ShlHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.ShlHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.ShrHandler">
            <summary>
            Implements a CIL instruction handler for <c>shr</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.ShrHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.ShrHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.ShrHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.SubHandler">
            <summary>
            Implements a CIL instruction handler for <c>sub</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.SubHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.SubHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.SubHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.UnaryOperatorHandlerBase">
            <summary>
            Provides a base for unary operator instruction handlers.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.UnaryOperatorHandlerBase.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.UnaryOperatorHandlerBase.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Evaluates the unary operation on an argument.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="instruction">The instruction to dispatch and evaluate.</param>
            <param name="argument">The argument that also receives the output.</param>
            <returns>A value indicating whether the dispatch was successful or caused an error.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.XorHandler">
            <summary>
            Implements a CIL instruction handler for <c>xpr</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.XorHandler.Force32BitResult(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.XorHandler.IsSignedOperation(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arithmetic.XorHandler.Evaluate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.LdElemaHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldelema</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.LdElemaHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.LdElemHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldelem</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.LdElemHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.LdLenHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldlen</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.LdLenHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.NewArrHandler">
            <summary>
            Implements a CIL instruction handler for <c>newarr</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.NewArrHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.StElemHandler">
            <summary>
            Implements a CIL instruction handler for <c>stelem</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Arrays.StElemHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher">
            <summary>
            Provides a mechanism for dispatching instructions to their respective handlers.
            </summary>
        </member>
        <member name="E:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher.BeforeInstructionDispatch">
            <summary>
            Fires before an instruction gets dispatched.
            </summary>
        </member>
        <member name="E:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher.AfterInstructionDispatch">
            <summary>
            Fires after an instruction gets dispatched.
            </summary> 
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher.DispatcherTable">
            <summary>
            Gets the table that is used for dispatching instructions by their mnemonic. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <summary>
            Dispatches and evaluates a single instruction.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="instruction">The instruction to dispatch and evaluate.</param>
            <returns>A value indicating whether the dispatch was successful or caused an error.</returns>
            <exception cref="T:System.NotSupportedException">Occurs when an operation was not supported by the dispatcher.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher.OnBeforeInstructionDispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchEventArgs)">
            <summary>
            Fires the <see cref="E:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher.BeforeInstructionDispatch" /> event.
            </summary>
            <param name="e">The event arguments.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher.OnAfterInstructionDispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchEventArgs)">
            <summary>
            Fires the <see cref="E:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher.AfterInstructionDispatch" /> event.
            </summary>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchEventArgs">
            <summary>
            Provides arguments for CIL instruction dispatch events. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchEventArgs.Context">
            <summary>
            Gets the context that the instruction is evaluated in.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchEventArgs.Instruction">
            <summary>
            Gets the instruction that is being dispatched.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchEventArgs.IsHandled">
            <summary>
            Gets or sets a value indicating whether the instruction was handled or not.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchEventArgs.Result">
            <summary>
            Gest or sets the dispatch result.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult">
            <summary>
            Provides information about the result of an instruction dispatch.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.IsSuccess">
            <summary>
            Gets a value indicating whether the dispatch and evaluation of the instruction was successful. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.ExceptionObject">
            <summary>
            When <see cref="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.IsSuccess"/> is <c>false</c>, gets the o that represents the pointer to the exception
            that was thrown during the evaluation of the instruction.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.Success">
            <summary>
            Creates a new dispatch result indicating the dispatch was successful.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.Exception(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Creates a new dispatch result indicating the dispatch failed with an exception.
            </summary>
            <param name="exceptionObject">The handle to the exception object that was thrown.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.Exception(Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine,AsmResolver.DotNet.ITypeDescriptor)">
            <summary>
            Creates a new dispatch result indicating the dispatch failed with an exception.
            </summary>
            <param name="machine">The machine to allocate the exception in.</param>
            <param name="type">The type of exception to allocate.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.InvalidProgram(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext)">
            <summary>
            Creates a new dispatch result indicating the dispatch failed due to an invalid program.
            </summary>
            <param name="context">The context the instruction was evaluated in.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.NullReference(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext)">
            <summary>
            Creates a new dispatch result indicating the dispatch failed due to a null reference.
            </summary>
            <param name="context">The context the instruction was evaluated in.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.IndexOutOfRange(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext)">
            <summary>
            Creates a new dispatch result indicating the dispatch failed due to an index being out of range.
            </summary>
            <param name="context">The context the instruction was evaluated in.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.StackOverflow(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext)">
            <summary>
            Creates a new dispatch result indicating the dispatch failed due to a stack overflow.
            </summary>
            <param name="context">The context the instruction was evaluated in.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.Overflow(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext)">
            <summary>
            Creates a new dispatch result indicating the dispatch failed due to an integer overflow.
            </summary>
            <param name="context">The context the instruction was evaluated in.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.InvalidCast(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.Signatures.TypeSignature,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Creates a new dispatch result indicating the dispatch failed due to a stack overflow.
            </summary>
            <param name="context">The context the instruction was evaluated in.</param>
            <param name="originalType">The original object type.</param>
            <param name="targetType">The type that the object was attempted to be casted to.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.Equals(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext">
            <summary>
            Provides a context for evaluating CIL instructions.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext.#ctor(Echo.Platforms.AsmResolver.Emulation.CilThread,System.Threading.CancellationToken)">
            <summary>
            Creates a new execution context for CIL instructions.
            </summary>
            <param name="thread">The parent thread the instruction is executed on.</param>
            <param name="cancellationToken">A token used for canceling the emulation.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext.Thread">
            <summary>
            Gets the parent thread the instruction is executed on.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext.Machine">
            <summary>
            Gets the parent machine the instruction is executed on.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext.CurrentFrame">
            <summary>
            Gets the current active stack frame.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext.CancellationToken">
            <summary>
            Gets a token used for canceling the emulation.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdcI4Handler">
            <summary>
            Implements a CIL instruction handler for <c>ldc.i4</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdcI4Handler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdcI8Handler">
            <summary>
            Implements a CIL instruction handler for <c>ldc.i8</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdcI8Handler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdcR4Handler">
            <summary>
            Implements a CIL instruction handler for <c>ldc.r4</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdcR4Handler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdcR8Handler">
            <summary>
            Implements a CIL instruction handler for <c>ldc.r8</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdcR8Handler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdNullHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldnull</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdNullHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdStrHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldstr</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Constants.LdStrHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BeqHandler">
            <summary>
            Implements a CIL instruction handler for <c>beq</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BeqHandler.IsSignedCondition(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BeqHandler.EvaluateCondition(AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BgeHandler">
            <summary>
            Implements a CIL instruction handler for <c>bge</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BgeHandler.IsSignedCondition(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BgeHandler.EvaluateCondition(AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BgtHandler">
            <summary>
            Implements a CIL instruction handler for <c>bgt</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BgtHandler.IsSignedCondition(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BgtHandler.EvaluateCondition(AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BinaryBranchHandlerBase">
            <summary>
            Provides a base for branch instructions that evaluate a condition using a binary operator.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BinaryBranchHandlerBase.EvaluateCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BinaryBranchHandlerBase.IsSignedCondition(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <summary>
            Gets a value indicating whether the instruction is a signed operation or not.
            </summary>
            <param name="instruction">The instruction to classify.</param>
            <returns><c>true</c> if signed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BinaryBranchHandlerBase.EvaluateCondition(AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Evaluates the binary condition on the provided stack arguments.
            </summary>
            <param name="instruction">The instruction containing the operator to evaluate.</param>
            <param name="argument1">The left hand side of the binary operator.</param>
            <param name="argument2">The right hand side of the binary operator.</param>
            <returns>The result of the evaluation, or <c>null</c> if the evaluation failed due to an invalid program.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BleHandler">
            <summary>
            Implements a CIL instruction handler for <c>ble</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BleHandler.IsSignedCondition(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BleHandler.EvaluateCondition(AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BltHandler">
            <summary>
            Implements a CIL instruction handler for <c>blt</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BltHandler.IsSignedCondition(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BltHandler.EvaluateCondition(AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BneUnHandler">
            <summary>
            Implements a CIL instruction handler for <c>bne.un</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BneUnHandler.IsSignedCondition(AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BneUnHandler.EvaluateCondition(AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BranchHandlerBase">
            <summary>
            Provides a base for branching instruction handlers.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BranchHandlerBase.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BranchHandlerBase.EvaluateCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <summary>
            Evaluates the condition for the branching instruction.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="instruction">The instruction to dispatch and evaluate.</param>
            <returns><c>true</c> if the branch should be taken, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BrFalseHandler">
            <summary>
            Implements a CIL instruction handler for <c>brfalse</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BrFalseHandler.EvaluateCondition(Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BrHandler">
            <summary>
            Implements a CIL instruction handler for <c>br</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BrHandler.EvaluateCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BrTrueHandler">
            <summary>
            Implements a CIL instruction handler for <c>brtrue</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.BrTrueHandler.EvaluateCondition(Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.RetHandler">
            <summary>
            Implements a CIL instruction handler for <c>ret</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.RetHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.SwitchHandler">
            <summary>
            Implements a CIL instruction handler for <c>switch</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.SwitchHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.UnaryBranchHandlerBase">
            <summary>
            Provides a base for branch instructions that evaluate a condition using a unary operator.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.UnaryBranchHandlerBase.EvaluateCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ControlFlow.UnaryBranchHandlerBase.EvaluateCondition(Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Evaluates the unary condition on the provided stack slot.
            </summary>
            <param name="argument">The stack slot.</param>
            <returns>The result of the evaluation, or <c>null</c> if the evaluation failed due to an invalid program.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.DispatcherTableEntryAttribute">
            <summary>
            Marks the class as a default operation code handler for a <see cref="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher"/>. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.DispatcherTableEntryAttribute.#ctor(AsmResolver.PE.DotNet.Cil.CilCode[])">
            <summary>
            Marks the class as a default handler for a <see cref="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatcher"/> for the provided operation codes.
            </summary>
            <param name="opCodes">The opcodes the class handles.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.DispatcherTableEntryAttribute.OpCodes">
            <summary>
            Gets a collection of opcodes this class handles.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.EndFilterHandler">
            <summary>
            Implements a CIL instruction handler for <c>endfilter</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.EndFilterHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.EndFinallyHandler">
            <summary>
            Implements a CIL instruction handler for <c>endfinally</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.EndFinallyHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.LeaveHandler">
            <summary>
            Implements a CIL instruction handler for <c>leave</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.LeaveHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.RethrowHandler">
            <summary>
            Implements a CIL instruction handler for <c>rethrow</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.RethrowHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.ThrowHandler">
            <summary>
            Implements a CIL instruction handler for <c>throw</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Exceptions.ThrowHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.FallThroughOpCodeHandler">
            <summary>
            Provides a base for instruction handlers that finalize evaluation by increasing the program counter by the
            instruction's size. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.FallThroughOpCodeHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.FallThroughOpCodeHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <summary>
            Evaluates a CIL instruction in the provided execution context, without increasing the program counter.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="instruction">The instruction to dispatch and evaluate.</param>
            <returns>A value indicating whether the dispatch was successful or caused an error.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ICilOpCodeHandler">
            <summary>
            Provides members for evaluating an instruction.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ICilOpCodeHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <summary>
            Evaluates a CIL instruction in the provided execution context.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="instruction">The instruction to dispatch and evaluate.</param>
            <returns>A value indicating whether the dispatch was successful or caused an error.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Misc.ConvHandler">
            <summary>
            Implements a CIL instruction handler for conversion operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Misc.ConvHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Misc.DupHandler">
            <summary>
            Implements a CIL instruction handler for <c>dup</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Misc.DupHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Misc.NopHandler">
            <summary>
            Implements a CIL instruction handler for <c>nop</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Misc.NopHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Misc.PopHandler">
            <summary>
            Implements a CIL instruction handler for <c>pop</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Misc.PopHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.BoxHandler">
            <summary>
            Implements a CIL instruction handler for <c>box</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.BoxHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallHandler">
            <summary>
            Implements a CIL instruction handler for <c>call</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallHandler.DevirtualizeMethodInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallHandlerBase">
            <summary>
            Provides a base implementation for operation codes that call functions or methods.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallHandlerBase.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallHandlerBase.ShouldPopInstanceObject(AsmResolver.DotNet.IMethodDescriptor)">
            <summary>
            Determines whether the instance object should be popped from the stack for the provided method.
            </summary>
            <param name="method">The method to test.</param>
            <returns><c>true</c> if the instance object should be popped, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallHandlerBase.HandleCall(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <summary>
            Handles the actual calling mechanism of the instruction.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="instruction">The instruction to dispatch and evaluate.</param>
            <param name="method">The method that is called.</param>
            <param name="arguments">The arguments to call the method with.</param>
            <returns>The dispatching result.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallHandlerBase.GetArguments(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor)">
            <summary>
            Pops the required arguments for a method call from the stack.
            </summary>
            <param name="context">The context to evaluate the method call in.</param>
            <param name="method">The method to pop arguments for.</param>
            <returns>The list of marshalled arguments.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallHandlerBase.DevirtualizeMethodInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <summary>
            Devirtualizes and resolves the method that is referenced by the provided instruction.
            </summary>
            <param name="context">The execution context the instruction is evaluated in.</param>
            <param name="method">The method that is being devirtualized.</param>
            <param name="arguments">The arguments pushed onto the stack.</param>
            <returns>The result of the devirtualization.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallVirtHandler">
            <summary>
            Implements a CIL instruction handler for <c>callvirt</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CallVirtHandler.DevirtualizeMethodInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CastClassHandler">
            <summary>
            Implements a CIL instruction handler for <c>castclass</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CastClassHandler.HandleSuccessfulCast(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,Echo.Platforms.AsmResolver.Emulation.ObjectHandle,AsmResolver.DotNet.Signatures.TypeSignature)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CastOpCodeHandlerBase">
            <summary>
            Provides a base for instructions implementing type-casting and boxing behavior.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CastOpCodeHandlerBase.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CastOpCodeHandlerBase.HandleNull(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Handles the case when the pushed value is <c>null</c>.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="targetType">The type to convert the null reference to.</param>
            <returns>The final dispatcher result.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CastOpCodeHandlerBase.HandleFailedCast(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.Signatures.TypeSignature,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Handles the case when the pushed value is incompatible with the type specified in the instruction.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="originalType">The type of the pushed object.</param>
            <param name="targetType">The type that the object was attempted to be converted to.</param>
            <returns>The final dispatcher result.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.CastOpCodeHandlerBase.HandleSuccessfulCast(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,Echo.Platforms.AsmResolver.Emulation.ObjectHandle,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Handles the case when the pushed value is compatible with the type specified in the instruction.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="handle">The address of the object.</param>
            <param name="targetType">The type to convert the object to to.</param>
            <returns>The final dispatcher result.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.ConstrainedHandler">
            <summary>
            Implements a CIL instruction handler for <c>constrained</c> prefix operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.ConstrainedHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.FieldOpCodeHandler">
            <summary>
            Represents a handler that handles opcodes related to field access.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.FieldOpCodeHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.FieldOpCodeHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Handles the actual operation on the field.
            </summary>
            <param name="context">The context to evaluate the instruction in.</param>
            <param name="instruction">The instruction to dispatch and evaluate.</param>
            <param name="field">The field to perform the operation on.</param>
            <returns>The dispatching result.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.IsInstHandler">
            <summary>
            Implements a CIL instruction handler for <c>isinst</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.IsInstHandler.HandleFailedCast(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.Signatures.TypeSignature,AsmResolver.DotNet.Signatures.TypeSignature)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.IsInstHandler.HandleSuccessfulCast(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,Echo.Platforms.AsmResolver.Emulation.ObjectHandle,AsmResolver.DotNet.Signatures.TypeSignature)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdFldaHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldflda</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdFldaHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,AsmResolver.DotNet.IFieldDescriptor)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdFldHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldfld</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdFldHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,AsmResolver.DotNet.IFieldDescriptor)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdftnHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldftn</c> instruction.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdftnHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc/>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdsFldaHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldsflda</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdsFldaHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,AsmResolver.DotNet.IFieldDescriptor)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdsFldHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldsfld</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdsFldHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,AsmResolver.DotNet.IFieldDescriptor)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdTokenHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldtoken</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.LdTokenHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.MethodDevirtualizationResult">
            <summary>
            Provides information about the result of a method devirtualization process.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.MethodDevirtualizationResult.ResultingMethod">
            <summary>
            When successful, gets the resulting devirtualized method.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.MethodDevirtualizationResult.ExceptionObject">
            <summary>
            When unsuccessful, gets the exception thrown during the devirtualization process. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.MethodDevirtualizationResult.IsSuccess">
            <summary>
            Gets a value indicating whether the devirtualization process of the referenced method was successful.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.MethodDevirtualizationResult.IsUnknown">
            <summary>
            Gets a value indicating whether the devirtualization process could not be completed due to an unknown
            object that was dereferenced.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.MethodDevirtualizationResult.Success(AsmResolver.DotNet.IMethodDescriptor)">
            <summary>
            Creates a new successful method devirtualization result. 
            </summary>
            <param name="method">The resolved method.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.MethodDevirtualizationResult.Exception(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Creates a new unsuccessful method devirtualization result.
            </summary>
            <param name="exceptionObject">
            The handle to the exception that occurred during the method devirtualization.
            </param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.MethodDevirtualizationResult.Unknown">
            <summary>
            Creates a new unknown method devirtualization result.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.NewObjHandler">
            <summary>
            Implements a CIL instruction handler for <c>newobj</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.NewObjHandler.Dispatch(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.NewObjHandler.ShouldPopInstanceObject(AsmResolver.DotNet.IMethodDescriptor)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.NewObjHandler.DevirtualizeMethodInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.SizeOfHandler">
            <summary>
            Implements a CIL instruction handler for <c>sizeof</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.SizeOfHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.StFldHandler">
            <summary>
            Implements a CIL instruction handler for <c>stfld</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.StFldHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,AsmResolver.DotNet.IFieldDescriptor)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.StsFldHandler">
            <summary>
            Implements a CIL instruction handler for <c>stsfld</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.StsFldHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,AsmResolver.DotNet.IFieldDescriptor)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxAnyHandler">
            <summary>
            Implements a CIL instruction handler for <c>unbox.any</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxAnyHandler.HandleNull(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.Signatures.TypeSignature)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxAnyHandler.GetReturnValue(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,Echo.Platforms.AsmResolver.Emulation.ObjectHandle,AsmResolver.DotNet.Signatures.TypeSignature)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxHandler">
            <summary>
            Implements a CIL instruction handler for <c>unbox</c> operations.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxHandler.HandleNull(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.Signatures.TypeSignature)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxHandler.GetReturnValue(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,Echo.Platforms.AsmResolver.Emulation.ObjectHandle,AsmResolver.DotNet.Signatures.TypeSignature)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxHandlerBase">
            <summary>
            Provides a base for instructions implementing unboxing behavior.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxHandlerBase.HandleSuccessfulCast(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,Echo.Platforms.AsmResolver.Emulation.ObjectHandle,AsmResolver.DotNet.Signatures.TypeSignature)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.ObjectModel.UnboxHandlerBase.GetReturnValue(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,Echo.Platforms.AsmResolver.Emulation.ObjectHandle,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Transforms the resolved data address into a value to be pushed onto the stack.
            </summary>
            <param name="context">The context in which the instruction is emulated in.</param>
            <param name="handle">The address.</param>
            <param name="targetType">The data type of the value at the address.</param>
            <returns>The return value.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.CpBlkHandler">
            <summary>
            Implements a CIL instruction handler for <c>cpblk</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.CpBlkHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.CpObjHandler">
            <summary>
            Implements a CIL instruction handler for <c>cpobj</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.CpObjHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.InitBlkHandler">
            <summary>
            Implements a CIL instruction handler for <c>initblk</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.InitBlkHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.InitObjHandler">
            <summary>
            Implements a CIL instruction handler for <c>initobj</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.InitObjHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.LdIndHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldind</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.LdIndHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.LocAllocHandler">
            <summary>
            Implements a CIL instruction handler for <c>localloc</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.LocAllocHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.StIndHandler">
            <summary>
            Implements a CIL instruction handler for <c>stind</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.StIndHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.UnalignedHandler">
            <summary>
            Implements a CIL instruction handler for <c>unaligned</c> prefix instructions.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.UnalignedHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.VolatileHandler">
            <summary>
            Implements a CIL instruction handler for <c>volatile</c> prefix instructions.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Pointers.VolatileHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.LdArgaHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldarga</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.LdArgaHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.LdArgHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldarg</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.LdArgHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.LdLocaHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldloca</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.LdLocaHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.LdLocHandler">
            <summary>
            Implements a CIL instruction handler for <c>ldloc</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.LdLocHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.StArgHandler">
            <summary>
            Implements a CIL instruction handler for <c>starg</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.StArgHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.StLocHandler">
            <summary>
            Implements a CIL instruction handler for <c>stloc</c> operations and its derivatives.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Dispatch.Variables.StLocHandler.DispatchInternal(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions">
            <summary>
            Provides methods for manipulating bit vectors that represent managed objects. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.AsObjectHandle(Echo.Memory.BitVector,Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Interprets a bit vector as a reference to an object.
            </summary>
            <param name="objectPointer">The bit vector containing the reference.</param>
            <param name="machine">The machine the address is valid in.</param>
            <returns>The object handle.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the bit vector does not contain a fully known address.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.AsObjectHandle(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Interprets a bit vector as a reference to an object.
            </summary>
            <param name="objectPointer">The bit vector containing the reference.</param>
            <param name="machine">The machine the address is valid in.</param>
            <returns>The object handle.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the bit vector does not contain a fully known address.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.AsObjectHandle(System.Int64,Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Interprets an integer as a reference to an object.
            </summary>
            <param name="objectPointer">The integer containing the reference.</param>
            <param name="machine">The machine the address is valid in.</param>
            <returns>The object handle.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.AsStructHandle(Echo.Memory.BitVector,Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Interprets a bit vector as a reference to a structure.
            </summary>
            <param name="objectPointer">The integer containing the reference.</param>
            <param name="machine">The machine the address is valid in.</param>
            <returns>The structure handle.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the bit vector does not contain a fully known address.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.AsStructHandle(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Interprets a bit vector as a reference to a structure.
            </summary>
            <param name="objectPointer">The integer containing the reference.</param>
            <param name="machine">The machine the address is valid in.</param>
            <returns>The structure handle.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the bit vector does not contain a fully known address.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.AsStructHandle(System.Int64,Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Interprets an integer as a reference to a structure.
            </summary>
            <param name="objectPointer">The integer containing the reference.</param>
            <param name="machine">The machine the address is valid in.</param>
            <returns>The structure handle.</returns>=
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceObjectMethodTable(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Interprets the bit vector as the contents of a managed object, and carves out the object's method table
            pointer.
            </summary>
            <param name="span">The bit vector representing the entire managed object.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <returns>The slice that contains the pointer to the object's method table.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceObjectData(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Interprets the bit vector as the contents of a managed object, and carves out the actual object data.
            </summary>
            <param name="span">The bit vector representing the entire managed object.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <returns>The slice that contains just the object data.</returns>
            <remarks>
            This method effectively strips away the header of an object.
            </remarks>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceObjectField(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory,AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Interprets the bit vector as object data (including the object header), and carves out a single field from it.
            </summary>
            <param name="span">The bit vector representing the entire object.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <param name="field">The field to carve out.</param>
            <returns>The slice that contains the raw data of the field.</returns>
            <exception cref="T:System.ArgumentException">
            Occurs when the provided field has no valid declaring type or could not be resolved.
            </exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceArrayLength(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Interprets the bit vector as the contents of a managed array, and carves out the length field.
            </summary>
            <param name="span">The bit vector representing the entire managed array.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <returns>The slice that contains the length of the array.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceArrayData(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Interprets the bit vector as the contents of a managed array, and carves out the raw data of all elements.
            </summary>
            <param name="span">The bit vector representing the entire managed array.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <returns>The slice that contains the raw data of the elements of the array.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceArrayElement(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory,AsmResolver.DotNet.Signatures.TypeSignature,System.Int32)">
            <summary>
            Interprets the bit vector as the contents of a managed array, and carves out a single element.
            </summary>
            <param name="span">The bit vector representing the entire managed array.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <param name="elementType">The type of elements stored in the array.</param>
            <param name="index">The index of the element to carve out.</param>
            <returns>The slice that contains the raw data of the requested element.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceStringLength(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Interprets the bit vector as a string object, and carves out the length field.
            </summary>
            <param name="span">The bit vector representing the entire managed string object.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <returns>The slice that contains the length of the string.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceStringData(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Interprets the bit vector as a string object, and carves out the characters of the string.
            </summary>
            <param name="span">The bit vector representing the entire managed string object.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <returns>The slice that contains the raw characters of the string.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceStructField(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory,AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Interprets the bit vector as a structure, and carves out a single field from it.
            </summary>
            <param name="span">The bit vector representing the entire structure.</param>
            <param name="factory">The object responsible for managing type layouts.</param>
            <param name="field">The field to carve out.</param>
            <returns>The slice that contains the raw data of the field.</returns>
            <remarks>
            When applying this on structures, this function can be used as is. When applying this on objects, make sure
            the input bit vector does <strong>not</strong> contain the object header. This header can be stripped away
            by using e.g. <see cref="M:Echo.Platforms.AsmResolver.Emulation.DotNetBitVectorExtensions.SliceObjectData(Echo.Memory.BitVectorSpan,Echo.Platforms.AsmResolver.Emulation.ValueFactory)"/> first.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Occurs when the provided field has no valid declaring type or could not be resolved.
            </exception>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver">
            <summary>
            Provides an implementation of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver"/> that reports back to the emulator that
            it should treat every unknown pointer or array access as an operation that is successful.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.Instance">
            <summary>
            Gets the default instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveBranchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveBranchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveSwitchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveSourcePointer(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveDestinationPointer(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveBlockSize(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveArrayIndex(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,System.Int64,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveMethod(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmptyUnknownResolver.ResolveExceptionFilter(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.EmulatedException">
            <summary>
            Describes an exception that was thrown by emulated CIL code.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.EmulatedException.#ctor(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Wraps the provided virtual exception object into an <see cref="T:Echo.Platforms.AsmResolver.Emulation.EmulatedException"/> instance.
            </summary>
            <param name="exceptionObject">The handle to the virtual exception object.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.EmulatedException.ExceptionObject">
            <summary>
            Gets the handle to the virtual exception object that was thrown by the emulated CIL code.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap">
            <summary>
            Represents a heap of managed objects.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.#ctor(System.Int32,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Creates a new empty heap for managed objects.
            </summary>
            <param name="size">The maximum size the heap can grow.</param>
            <param name="factory">The object responsible for managing type information.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.#ctor(Echo.Memory.Heap.IHeap,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Creates a new empty heap for managed objects.
            </summary>
            <param name="backingHeap">The backing heap to use for allocating raw memory.</param>
            <param name="factory">The object responsible for managing type information.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.AllocateFlat(System.UInt32,System.Boolean)">
            <summary>
            Allocates flat unmanaged memory in the heap (i.e., without any object header).
            </summary>
            <param name="size">The size in bytes of the memory region to allocate.</param>
            <param name="initialize">A value indicating whether the object should be initialized with zeroes.</param>
            <returns>The address of the memory that was allocated.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.AllocateObject(AsmResolver.DotNet.ITypeDescriptor,System.Boolean)">
            <summary>
            Allocates a managed object of the provided type in the heap.
            </summary>
            <param name="type">The type of object to allocate.</param>
            <param name="initialize">A value indicating whether the object should be initialized with zeroes.</param>
            <returns>The address of the object that was allocated.</returns>
            <exception cref="T:System.InvalidOperationException">
            Occurs when the provided type's size is unknown (e.g. when the type is an array or string type).
            </exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.AllocateSzArray(AsmResolver.DotNet.Signatures.TypeSignature,System.Int32,System.Boolean)">
            <summary>
            Allocates a single dimension, zero-based array on the heap.
            </summary>
            <param name="elementType">The type of elements the array stores.</param>
            <param name="elementCount">The number of elements in the array.</param>
            <param name="initialize">A value indicating whether the elements should be initialized with zeroes.</param>
            <returns>The address of the array that was allocated.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.AllocateString(System.String)">
            <summary>
            Allocates a string into the virtual managed heap.
            </summary>
            <param name="value">The string literal.</param> 
            <returns>The address of the string that was allocated.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.AllocateString(System.Int32,System.Boolean)">
            <summary>
            Allocates a string into the virtual managed heap.
            </summary>
            <param name="length">The number of characters in the string.</param>
            <param name="initialize">A value indicating whether all characters should be initialized with zeroes.</param>
            <returns>The address of the string that was allocated.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.AllocateString(Echo.Memory.BitVector)">
            <summary>
            Allocates a string into the virtual managed heap.
            </summary>
            <param name="contents">The string data.</param>
            <returns>The address of the string that was allocated.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.GetInternedString(System.String)">
            <summary>
            Gets the address to an interned string in the virtual managed heap.
            </summary>
            <param name="value">The string.</param>
            <returns>The address of the interned string.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.GetObjectSize(System.Int64)">
            <summary>
            Gets the size of the object at the provided address.
            </summary>
            <param name="address">The address of the object.</param>
            <returns>The size in bytes.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.GetObjectSpan(Echo.Memory.BitVectorSpan)">
            <summary>
            Gets a bit vector slice that spans the contents of the object at the provided address. 
            </summary>
            <param name="address">The address of the object.</param>
            <returns>The object slice.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.GetObjectSpan(System.Int64)">
            <summary>
            Gets a bit vector slice that spans the contents of the object at the provided address. 
            </summary>
            <param name="address">The address of the object.</param>
            <returns>The object slice.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.GetObjectRanges">
            <summary>
            Obtains a collection of address ranges of all managed objects currently in the heap.
            </summary>
            <returns>The ranges.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.Free(System.Int64)">
            <summary>
            Releases an object from the heap.
            </summary>
            <param name="address">The address of the object.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ManagedObjectHeap.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject">
            <summary>
            Embeds a managed object into the memory of a virtual machine, providing HLE access to the object.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject.#ctor(System.Object,AsmResolver.DotNet.Memory.TypeMemoryLayout,Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Creates a new managed object embedding.
            </summary>
            <param name="o">The object to embed.</param>
            <param name="virtualLayout">The memory layout of the object.</param>
            <param name="machine">The machine the object is valid in.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject.Object">
            <summary>
            Gets the embedded object.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject.AddressRange">
            <summary>
            Gets the virtual memory layout of the object's contents.
            </summary>
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory">
            <summary>
            Provides a memory space for hosting managed objects within memory of a virtual machine. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.#ctor(Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine,System.Int64)">
            <summary>
            Creates a new object mapping host memory space.
            </summary>
            <param name="machine">The machine the memory is associated with.</param>
            <param name="size">The maximum size of the memory.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.GetOrCreateMapping(System.Object)">
            <summary>
            Gets or creates a new address mapping for the provided object.
            </summary>
            <param name="value">The object to embed into the machine.</param>
            <returns>The mapped object.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.TryGetObject(System.Int64,Echo.Platforms.AsmResolver.Emulation.Heap.MappedObject@)">
            <summary>
            Attempts to obtain the managed object mapping by its address.
            </summary>
            <param name="address">The address of the mapped object.</param>
            <param name="map">The obtained mapped object.</param>
            <returns><c>true</c> if the object was found, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.Unmap(System.Object)">
            <summary>
            Unmaps a registered object from the host memory.
            </summary>
            <param name="value">The object to unmap.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory.Clear">
            <summary>
            Unmaps all registered objects from the host memory.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult">
            <summary>
            Describes the result of an allocation of an object. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.ResultType">
            <summary>
            Gets the type of result this object contains. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.IsInconclusive">
            <summary>
            Gets a value indicating whether the invocation was inconclusive and not handled yet.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.IsSuccess">
            <summary>
            Determines whether the invocation was successful.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.Address">
            <summary>
            When <see cref="P:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.ResultType"/> is <see cref="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.StepOver"/>, gets the address of the object
            that was allocated or constructed.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.ExceptionObject">
            <summary>
            When <see cref="P:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.ResultType"/> is <see cref="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.Exception"/>, gets the handle to the
            exception object that was thrown.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.Inconclusive">
            <summary>
            Constructs a new inconclusive allocation result, where the allocation was not handled yet.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.Allocated(Echo.Memory.BitVector)">
            <summary>
            Constructs a new conclusive allocation result, where the object was successfully allocated but not yet
            initialized yet.
            </summary>
            <param name="address">The address of the allocated object.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.FullyConstructed(Echo.Memory.BitVector)">
            <summary>
            Constructs a new conclusive allocation result, where the object was successfully allocated and is also fully
            initialized by a constructor.
            </summary>
            <param name="address">The address of the allocated object.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResult.Exception(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Constructs a new failed allocation result with the provided pointer to an exception object describing the
            error that occurred.
            </summary>
            <param name="exceptionObject">The handle to the exception object that was thrown.</param>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResultType">
            <summary>
            Provides members describing the different types of allocation results that can be produced during an object
            allocation in a CIL virtual machine.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResultType.Inconclusive">
            <summary>
            Indicates the allocation was not handled yet.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResultType.Allocated">
            <summary>
            Indicates the object was allocated but not initialized yet and a constructor should be called.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResultType.FullyConstructed">
            <summary>
            Indicates the object was allocated and also initialized.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.AllocationResultType.Exception">
            <summary>
            Indicates the allocation failed with an exception.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodHandler">
            <summary>
            Defines a method that is able to handle an emulated method invocation.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.CallbackMethodInvoker">
            <summary>
            Wraps a <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodHandler"/> delegate into a <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker"/>.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.CallbackMethodInvoker.#ctor(Echo.Platforms.AsmResolver.Emulation.Invocation.MethodHandler)">
            <summary>
            Wraps a <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodHandler"/> delegate into a <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker"/>.
            </summary>
            <param name="handler">The delegate to wrap.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.CallbackMethodInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultAllocators">
            <summary>
            Provides methods for constructing object allocators using a set of default allocators implementations. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultAllocators.UnknownAddress">
            <summary>
            Gets an object allocator that returns unknown addresses. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultAllocators.VirtualHeap">
            <summary>
            Gets an allocator that allocates objects in the virtualalized heap of the underlying virtual machine.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultAllocators.String">
            <summary>
            Gets an allocator that handles System.String constructors.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultAllocators.WithFallback(Echo.Platforms.AsmResolver.Emulation.Invocation.IObjectAllocator,Echo.Platforms.AsmResolver.Emulation.Invocation.IObjectAllocator)">
            <summary>
            Chains the first object allocator with the provided object allocator in such a way that if the result of the
            first allocator is inconclusive, the second allocator will be used as a fallback allocator.  
            </summary>
            <param name="self">The first object allocator</param>
            <param name="other">The fallback object allocator</param>
            <returns>The constructed allocator chain.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers">
            <summary>
            Provides methods for constructing method invokers using a set of default invoker implementations. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.StepIn">
            <summary>
            Gets the method invoker that always lets the emulator step into the requested method, effectively letting
            the emulator emulate all called methods recursively.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.ReturnUnknown">
            <summary>
            Gets the method invoker that always steps over the requested method and produces an unknown result
            according to the method's return type.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.ReturnDefault">
            <summary>
            Gets the method invoker that always steps over the requested method and produces the default result
            according to the method's return type.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.ReturnUnknownForExternal">
            <summary>
            Gets the method invoker that steps over any method that is not within the resolution scope of the current
            stack frame. That is, any method that is defined in an external assembly will be emulated as a step-over
            method with an unknown result. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.ReturnUnknownForNative">
            <summary>
            Gets the method invoker that steps over any method that does not have a CIL method body assigned by
            returning an unknown result, and otherwise leaves the invocation result inconclusive.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.ReflectionInvoke">
            <summary>
            Gets the method invoker that steps over any method by invoking it via System.Reflection. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.StringShim">
            <summary>
            Gets the default shim for the <see cref="T:System.String"/> type.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.UnsafeShim">
            <summary>
            Gets the default shim for the <see cref="T:System.Runtime.CompilerServices.Unsafe"/> class.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.DelegateShim">
            <summary>
            Gets the default shim for the <see cref="T:System.Delegate"/> class.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.RuntimeHelpersShim">
            <summary>
            Gets the default shim for the <see cref="T:System.Runtime.CompilerServices.RuntimeHelpers"/> class.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.IntrinsicsShim">
            <summary>
            Gets the default shim for methods found in the <c>System.Runtime.Intrinsics</c> namespace of the BCL. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.MemoryMarshalShim">
            <summary>
            Gets the default shim for the <see cref="T:System.Runtime.InteropServices.MemoryMarshal"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.HandleExternalWith(Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker)">
            <summary>
            Gets the method invoker that forwards any method that is not within the resolution scope of the current
            stack frame to the provided method invoker, and otherwise leaves the invocation result inconclusive.
            </summary>
            <param name="baseInvoker">The invoker to use for producing a result when stepping over a method.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.HandleNativeWith(Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker)">
            <summary>
            Gets the method invoker that forwards any method that does not have a CIL method body assigned to the
            provided method invoker, and otherwise leaves the invocation result inconclusive.
            </summary>
            <param name="baseInvoker">The invoker to use for producing a result when stepping over a method.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.CreateShim">
            <summary>
            Creates a new method shim invoker that multiplexes a set of methods to individual handlers.  
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.CreateDefaultShims">
            <summary>
            Creates a method invoker that provides default shim implementations for various base class library methods
            that are implemented by the runtime.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.DefaultInvokers.WithFallback(Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker,Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker)">
            <summary>
            Chains the first method invoker with the provided method invoker in such a way that if the result of the
            first invoker is inconclusive, the second invoker will be used as a fallback invoker.  
            </summary>
            <param name="self">The first method invoker</param>
            <param name="other">The fallback method invoker</param>
            <returns>The constructed invoker chain.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.DelegateInvoker">
            <summary>
            Wrapper for Delegates
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.DelegateInvoker.Instance">
            <summary>
            Instance
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.DelegateInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.ExternalMethodInvoker">
            <summary>
            Implements a method invoker that steps over any method that is defined outside of the current method's
            resolution scope.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.ExternalMethodInvoker.#ctor(Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker,AsmResolver.DotNet.Signatures.SignatureComparer)">
            <summary>
            Creates a new step-over external method invoker.
            </summary>
            <param name="baseInvoker">The invoker to use when stepping over.</param>
            <param name="comparer"></param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.ExternalMethodInvoker.BaseInvoker">
            <summary>
            Gets the invoker that is used when invoking an external method.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.ExternalMethodInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker">
            <summary>
            Provides members for emulating invocations of external methods.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <summary>
            Invokes or emulates an external method.
            </summary>
            <param name="context">The execution context the call originates from.</param>
            <param name="method">The method to invoke.</param>
            <param name="arguments">The arguments to invoke the method with.</param>
            <returns>The result</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.IntrinsicsInvoker">
            <summary>
            Implements a method invoker that shims methods in the <c>System.Runtime.Intrinsics</c> namespace.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.IntrinsicsInvoker.Instance">
            <summary>
            Gets the singleton instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.IntrinsicsInvoker"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.IntrinsicsInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult">
            <summary>
            Describes the result of an invocation of an external method. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.ResultType">
            <summary>
            Gets the type of result this object contains. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.IsInconclusive">
            <summary>
            Gets a value indicating whether the invocation was inconclusive and not handled yet.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.IsSuccess">
            <summary>
            Determines whether the invocation was successful.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.Value">
            <summary>
            When <see cref="P:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.ResultType"/> is <see cref="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.StepOver"/>, gets the value that the
            method returned (if available).
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.ExceptionObject">
            <summary>
            When <see cref="P:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.ResultType"/> is <see cref="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.Exception"/>, gets the handle to the
            exception object that was thrown.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.Inconclusive">
            <summary>
            Constructs a new inconclusive invocation result, where the invocation was not handled yet.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.StepIn">
            <summary>
            Constructs a new conclusive invocation result, where the invocation was handled as a step-in action.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.StepOver(Echo.Memory.BitVector)">
            <summary>
            Constructs a new conclusive invocation result, where the invocation was fully handled by the invoker and
            a result was produced.
            </summary>
            <param name="value">
            The result that was produced by the method, or <c>null</c> if the method does not return a value.
            </param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.FullyHandled">
            <summary>
            Constructs a new conclusive invocation result, where the invocation was fully emulated by the invoker.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResult.Exception(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Constructs a new failed invocation result with the provided pointer to an exception object describing the
            error that occurred.
            </summary>
            <param name="exceptionObject">The handle to the exception object that was thrown.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType">
            <summary>
            Provides members describing the different types of invocation results that can be produced during a method
            invocation in a CIL virtual machine.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.Inconclusive">
            <summary>
            Indicates the invocation was not handled yet.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.StepIn">
            <summary>
            Indicates the invocation is handled as a step-in action.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.StepOver">
            <summary>
            Indicates the invocation is handled fully by the invoker.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.FullyHandled">
            <summary>
            Indicates the invocation is fully emulated by the invoker.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Invocation.InvocationResultType.Exception">
            <summary>
            Indicates the invocation resulted in an error.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.IObjectAllocator">
            <summary>
            Provides members for emulating object allocation.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.IObjectAllocator.Allocate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <summary>
            Allocates a new object with the provided constructor and arguments.
            </summary>
            <param name="context">The execution context the call originates from.</param>
            <param name="ctor">The constructor to invoke after allocation.</param>
            <param name="arguments">The arguments to invoke the constructor with.</param>
            <returns>The result</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.MemoryMarshalInvoker">
            <summary>
            Implements a method invoker that shims methods in the <see cref="T:System.Runtime.InteropServices.MemoryMarshal"/> class.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.MemoryMarshalInvoker.Instance">
            <summary>
            Gets the singleton instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.MemoryMarshalInvoker"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MemoryMarshalInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodInvokerChain">
            <summary>
            Represents a chain of method invokers that are invoked in sequence until one of the invokers produces a
            conclusive result.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodInvokerChain.Invokers">
            <summary>
            Gets the list of invokers to be called.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodInvokerChain.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodShimInvoker">
            <summary>
            Provides an implementation that handles invocations on a per-method basis.  
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodShimInvoker.#ctor">
            <summary>
            Creates a new method shim invoker.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodShimInvoker.#ctor(AsmResolver.DotNet.Signatures.SignatureComparer)">
            <summary>
            Creates a new method shim invoker.
            </summary>
            <param name="comparer">The comparer object to use when comparing methods.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodShimInvoker.Map(AsmResolver.DotNet.IMethodDescriptor,Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker)">
            <summary>
            Assigns a method invoker to a specific method.
            </summary>
            <param name="method">The method to handle.</param>
            <param name="handler">The invoker that will handle the method.</param>
            <returns>The current method shim invoker.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodShimInvoker.Map(AsmResolver.DotNet.IMethodDescriptor,Echo.Platforms.AsmResolver.Emulation.Invocation.MethodHandler)">
            <summary>
            Assigns a method invoker to a specific method.
            </summary>
            <param name="method">The method to handle.</param>
            <param name="handler">The invoker that will handle the method.</param>
            <returns>The current method shim invoker.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodShimInvoker.MapMany(System.Collections.Generic.IEnumerable{AsmResolver.DotNet.IMethodDescriptor},Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker)">
            <summary>
            Assigns a methods invoker to multiple methods.
            </summary>
            <param name="methods">The methods to handle.</param>
            <param name="handler">The invoker that will handle the method.</param>
            <returns>The current method shim invoker.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodShimInvoker.MapMany(System.Collections.Generic.IEnumerable{AsmResolver.DotNet.IMethodDescriptor},Echo.Platforms.AsmResolver.Emulation.Invocation.MethodHandler)">
            <summary>
            Assigns a methods invoker to multiple methods.
            </summary>
            <param name="methods">The methods to handle.</param>
            <param name="handler">The invoker that will handle the method.</param>
            <returns>The current method shim invoker.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.MethodShimInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.NativeMethodInvoker">
            <summary>
            Implements a method invoker that steps over any method that does not have a CIL method body assigned.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.NativeMethodInvoker.#ctor(Echo.Platforms.AsmResolver.Emulation.Invocation.IMethodInvoker)">
            <summary>
            Creates a new native method invoker.
            </summary>
            <param name="baseInvoker">The invoker that is used when invoking a non-CIL method.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.NativeMethodInvoker.BaseInvoker">
            <summary>
            Gets the invoker that is used when invoking a non-CIL method.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.NativeMethodInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.ObjectAllocatorChain">
            <summary>
            Represents a chain of object allocators that are invoked in sequence until one of the allocators produces a
            conclusive result.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.ObjectAllocatorChain.Allocators">
            <summary>
            Gets the list of invokers to be called.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.ObjectAllocatorChain.Allocate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.ReflectionInvoker">
            <summary>
            Provides an implementation of a method invoker that steps over any method by invoking it via System.Reflection. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.ReflectionInvoker.Instance">
            <summary>
            Gets the default instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.ReflectionInvoker"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.ReflectionInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.ReturnDefaultInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.RuntimeHelpersInvoker">
            <summary>
            Implements a method invoker that shims methods from the <see cref="T:System.Runtime.CompilerServices.RuntimeHelpers"/> class.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.RuntimeHelpersInvoker.Instance">
            <summary>
            Gets the singleton instance for the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.RuntimeHelpersInvoker"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.RuntimeHelpersInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.StringAllocator">
            <summary>
            Provides a shim allocator that handles System.String constructors. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.StringAllocator.Instance">
            <summary>
            Gets the singleton instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.StringAllocator"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.StringAllocator.Allocate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.StringInvoker">
            <summary>
            Implements a method invoker that shims methods from the <see cref="T:System.String"/> class.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.StringInvoker.Instance">
            <summary>
            Gets the singleton instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.StringInvoker"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.StringInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.UnknownAddressAllocator">
            <summary>
            Provides an implementation of an allocator that always returns unknown addresses for object allocation requests. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.UnknownAddressAllocator.Instance">
            <summary>
            Gets the singleton instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.UnknownAddressAllocator"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.UnknownAddressAllocator.Allocate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.UnsafeInvoker">
            <summary>
            Implements a method invoker that shims methods from the <see cref="T:System.Runtime.CompilerServices.Unsafe"/> class.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.UnsafeInvoker.Instance">
            <summary>
            Gets the singleton instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.UnsafeInvoker"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.UnsafeInvoker.Invoke(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Invocation.VirtualHeapAllocator">
            <summary>
            Provides an implementation of an allocator that allocates new objects in the virtualized heap of the underlying
            virtual machine. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Invocation.VirtualHeapAllocator.Instance">
            <summary>
            Gets the singleton instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Invocation.VirtualHeapAllocator"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Invocation.VirtualHeapAllocator.Allocate(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.DotNet.IMethodDescriptor,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.IObjectMarshaller">
            <summary>
            Provides methods for marshalling managed objects into bit vectors and back.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.IObjectMarshaller.Machine">
            <summary>
            Gets the machine the marshaller is targeting.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IObjectMarshaller.ToBitVector(System.Object)">
            <summary>
            Constructs a bit vector that represents the provided object.
            </summary>
            <param name="obj">The object.</param>
            <returns>The bitvector containing the address to the object.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IObjectMarshaller.ToObject(Echo.Memory.BitVectorSpan,System.Type)">
            <summary>
            Interprets the provided bit vector as an object of the provided type.
            </summary>
            <param name="vector">The vector.</param>
            <param name="targetType">The type to marshal to.</param>
            <returns>The marshalled object.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver">
            <summary>
            Provides methods for resolving unknown values in critical points of the emulation process.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveBranchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Resolves an unknown condition value of a unary conditional branch instruction.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The branch instruction that is being executed.</param>
            <param name="argument">The condition to be resolved.</param>
            <returns><c>true</c> if the branch should be taken, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveBranchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Resolves an unknown condition value of a binary conditional branch instruction.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The branch instruction that is being executed.</param>
            <param name="argument1">The first argument.</param>
            <param name="argument2">The second argument.</param>
            <returns><c>true</c> if the branch should be taken, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveSwitchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Resolves an unknown index value of a switch instruction.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The switch instruction that is being executed.</param>
            <param name="argument">The switch index to resolve.</param>
            <returns>The resolved index to jump to, or <c>null</c> to skip the switch instruction.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveSourcePointer(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Resolves an unknown source address to a memory block or object to read data from.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The instruction that is being executed.</param>
            <param name="address">The address to resolve.</param>
            <returns>The resolved address, or <c>null</c> to treat it as an unknown value that is processed successfully.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveDestinationPointer(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Resolves an unknown destination address to a memory block or object to write data to.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The instruction that is being executed.</param>
            <param name="address">The address to resolve.</param>
            <returns>The resolved address, or <c>null</c> to treat it as an unknown value that is processed successfully.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveBlockSize(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Resolves an unknown size for a memory block.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The instruction that is being executed.</param>
            <param name="size">The size to resolve.</param>
            <returns>The resolved size, or <c>null</c> to treat it as an unknown value that is processed successfully.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveArrayIndex(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,System.Int64,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Resolves an unknown index of an element within an array.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The switch instruction that is being executed.</param>
            <param name="arrayAddress">The address of the array.</param>
            <param name="index">The index to resolve.</param>
            <returns>The resolved index, or <c>null</c> to treat it as an unknown value that is processed successfully.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveMethod(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <summary>
            Resolves a method devirtualization on an unknown object instance.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The instruction that is being executed.</param>
            <param name="arguments"></param>
            <returns>
            The resolved method, or <c>null</c> if devirtualization should be ignored and the default implementation of
            the method should be used.
            </returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver.ResolveExceptionFilter(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <summary>
            Resolves an unknown conclusion for an exception filter.
            </summary>
            <param name="context">The context in which the instruction is executed in.</param>
            <param name="instruction">The instruction that is being executed.</param>
            <param name="conclusion">The unknown conclusion value.</param>
            <returns><c>true</c> if the exception should be handled, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.ObjectHandle">
            <summary>
            Represents an address to an object (including its object header) within a CIL virtual machine. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.#ctor(Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine,System.Int64)">
            <summary>
            Creates a new object handle from the provided address.
            </summary>
            <param name="machine">The machine the address is valid in.</param>
            <param name="address">The address.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.Machine">
            <summary>
            Gets the machine the object lives in.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.Address">
            <summary>
            Gets the address to the beginning of the object.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.IsNull">
            <summary>
            Gets a value indicating whether this handle represents the <c>null</c> reference.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.Contents">
            <summary>
            Gets the address to the beginning of the object's data.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.GetObjectType">
            <summary>
            Gets the object's type (or method table).
            </summary>
            <returns>The type.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.GetMemoryLayout">
            <summary>
            Obtains the object's data memory layout.
            </summary>
            <returns>The memory layout.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.GetFieldAddress(AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Obtains the absolute address of a field within the object.
            </summary>
            <param name="field">The field to obtain the address for.</param>
            <returns>The address.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadField(AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Copies the value of a field into a new bit vector.
            </summary>
            <param name="field">The field to obtain the value for.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadField(AsmResolver.DotNet.IFieldDescriptor,Echo.Memory.BitVectorSpan)">
            <summary>
            Copies the value of a field into a bit vector.
            </summary>
            <param name="field">The field to obtain the value for.</param>
            <param name="buffer">The buffer to copy the value into.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.WriteField(AsmResolver.DotNet.IFieldDescriptor,Echo.Memory.BitVectorSpan)">
            <summary>
            Copies the provided bit vector into a field of the object. 
            </summary>
            <param name="field">The field to write to.</param>
            <param name="buffer">The bits to write.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadStringLength">
            <summary>
            Interprets the handle as a string handle, and obtains the length of the contained string.
            </summary>
            <returns>The length.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadStringLength(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the handle as a string handle, and obtains the length of the contained string.
            </summary>
            <param name="buffer">The buffer to copy the length bits into.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadStringData">
            <summary>
            Interprets the handle as a string handle, and obtains the bits that make up the characters of the string.
            </summary>
            <returns>The bit vector containing the string's characters.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the string has an unknown length.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayLength">
            <summary>
            Interprets the handle as an array reference, and obtains the length of the contained array.
            </summary>
            <returns>The bits representing the length of the array.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayLength(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the handle as an array reference, and obtains the length of the contained array.
            </summary>
            <param name="buffer">The buffer to copy the length bits into.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayData">
            <summary>
            Interprets the handle as an array reference, and obtains all elements of the array as one continuous buffer
            of bytes.
            </summary>
            <returns>The raw array data.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the array has an unknown length.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayData(System.Int32,System.Int32)">
            <summary>
            Interprets the handle as an array reference, and obtains all elements of the array as one continuous buffer
            of bytes.
            </summary>
            <param name="startIndex">The index to start reading from.</param>
            <param name="length">The number of elements to read.</param>
            <returns>The raw array data.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the array has an unknown length.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayData(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the handle as an array reference, and obtains all elements of the array as one continuous buffer
            of bytes.
            </summary>
            <param name="buffer">The buffer to copy the array data into.</param>
            <returns>The raw array data.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayData(Echo.Memory.BitVectorSpan,System.Int32)">
            <summary>
            Interprets the handle as an array reference, and obtains all elements of the array as one continuous buffer
            of bytes.
            </summary>
            <param name="buffer">The buffer to copy the array data into.</param>
            <param name="startIndex">The start index to read from.</param>
            <returns>The raw array data.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayData(Echo.Memory.BitVectorSpan,System.Int32,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Interprets the handle as an array reference, and obtains all elements of the array as one continuous buffer
            of bytes.
            </summary>
            <param name="buffer">The buffer to copy the array data into.</param>
            <param name="startIndex">The start index to read from.</param>
            <param name="elementType">The element type to assume.</param>
            <returns>The raw array data.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.WriteArrayData(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the handle as an array reference, and writes elements to the array's data as one continuous buffer
            of bytes.
            </summary>
            <param name="buffer">The buffer to copy the array data from.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.WriteArrayData(System.ReadOnlySpan{System.Byte})">
            <summary>
            Interprets the handle as an array reference, and writes elements to the array's data as one continuous buffer
            of bytes.
            </summary>
            <param name="buffer">The buffer to copy the array data from.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.GetArrayElementAddress(AsmResolver.DotNet.Signatures.TypeSignature,System.Int64)">
            <summary>
            Interprets the handle as an array reference, and obtains the address of the provided element by its index.
            </summary>
            <param name="elementType">The type of elements the array stores.</param>
            <param name="index">The index of the element.</param>
            <returns>The address of the element.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayElement(AsmResolver.DotNet.Signatures.TypeSignature,System.Int64)">
            <summary>
            Interprets the handle as an array reference, and reads an element by its index.
            </summary>
            <param name="elementType">The type of elements the array stores.</param>
            <param name="index">The index of the element.</param>
            <returns>The bits of the element.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadArrayElement(AsmResolver.DotNet.Signatures.TypeSignature,System.Int64,Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the handle as an array reference, and reads an element by its index.
            </summary>
            <param name="elementType">The type of elements the array stores.</param>
            <param name="index">The index of the element.</param>
            <param name="buffer">The buffer to write the bits of the element into.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.WriteArrayElement(AsmResolver.DotNet.Signatures.TypeSignature,System.Int64,Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the handle as an array reference, and writes a value to an element by its index.
            </summary>
            <param name="elementType">The type of elements the array stores.</param>
            <param name="index">The index of the element.</param>
            <param name="buffer">The bits of the element to write to the element.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadObjectData">
            <summary>
            Reads the data stored in the object (excluding the object header), and stores it in a bit vector.
            </summary>
            <returns>The object's data.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadObjectData(AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Reads the data stored in the object (excluding the object header), and stores it in a bit vector.
            </summary>
            <param name="type">The type to interpret the object as.</param>
            <returns>The object's data.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ReadObjectData(Echo.Memory.BitVectorSpan)">
            <summary>
            Reads the data stored in the object (excluding the object header), and stores it in a bit vector.
            </summary>
            <param name="buffer">The buffer to write the data to.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.Equals(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectHandle.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.ObjectMarshaller">
            <summary>
            Provides an implementation of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.IObjectMarshaller"/>, that embeds managed objects into the
            <see cref="T:Echo.Platforms.AsmResolver.Emulation.Heap.ObjectMapMemory"/> of the virtual machine. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectMarshaller.#ctor(Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Creates a new marshaller for the provided virtual machine.
            </summary>
            <param name="machine">The machine.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ObjectMarshaller.Machine">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectMarshaller.ToBitVector(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectMarshaller.ToObject(Echo.Memory.BitVectorSpan,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectMarshaller.DeserializeStructure(Echo.Memory.BitVectorSpan,System.Type)">
            <summary>
            Deserialize the provided bit vector to a structure of the provided type.
            </summary>
            <param name="data">The raw data of the structure</param>
            <param name="targetType">The type of object to deserialize.</param>
            <returns>The deserialized object.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectMarshaller.DeserializeObject(System.Int64,System.Type)">
            <summary>
            Deserialize the provided object address to an object of the provided type.
            </summary>
            <param name="pointer">The pointer to the beginning of the object.</param>
            <param name="targetType">The type of object to deserialize.</param>
            <returns>The deserialized object.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.ObjectMarshallerExtensions">
            <summary>
            Provides extension methods to object marshalling services.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectMarshallerExtensions.ToObjectHandle(Echo.Platforms.AsmResolver.Emulation.IObjectMarshaller,System.Object)">
            <summary>
            Constructs an object handle that represents the provided object.
            </summary>
            <param name="self">The marshaller service.</param>
            <param name="obj">The object.</param>
            <returns>The handle containing the address to the marshalled object.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectMarshallerExtensions.ToObject``1(Echo.Platforms.AsmResolver.Emulation.IObjectMarshaller,Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the provided bit vector as an object of the provided type.
            </summary>
            <param name="self">The marshaller service.</param>
            <param name="vector">The vector.</param>
            <typeparam name="T">The type to marshal to.</typeparam>
            <returns>The marshalled object.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ObjectMarshallerExtensions.ToObject``1(Echo.Platforms.AsmResolver.Emulation.IObjectMarshaller,Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Interprets the provided object handle as an object of the provided type.
            </summary>
            <param name="self">The marshaller service.</param>
            <param name="handle">The address.</param>
            <typeparam name="T">The type to marshal to.</typeparam>
            <returns>The marshalled object.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.PELoader">
            <summary>
            Provides a mechanism for mapping portable executable files into virtual memory.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.PELoader.#ctor(Echo.Memory.VirtualMemory)">
            <summary>
            Creates a new instance of a PE loader.
            </summary>
            <param name="memory">The virtual memory to map the executables into.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.PELoader.MapModule(AsmResolver.DotNet.ModuleDefinition)">
            <summary>
            Maps a module into memory.
            </summary>
            <param name="module">The module to map.</param>
            <returns>The new base address of the PE file.</returns>
            <exception cref="T:System.ArgumentException">
            Occurs when the module does not have an underlying PE image or file.
            </exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.PELoader.MapPE(AsmResolver.PE.File.PEFile)">
            <summary>
            Maps all sections of the provided PE file into memory.
            </summary>
            <param name="file">The file to map.</param>
            <returns>The new base address of the PE file.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory">
            <summary>
            Provides a block of memory that contains mock data modelling CLR specific data structures.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory"/> block.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.AddressRange">
            <inheritdoc />
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.MethodTables">
            <summary>
            Gets the memory assigned for method table structures (types).
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.Methods">
            <summary>
            Gets the memory assigned for method descriptor structures.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.MethodEntryPoints">
            <summary>
            Gets the memory assigned for method entry points
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.Fields">
            <summary>
            Gets the memory assigned for field descriptor structures.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.ClrMockMemory.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Runtime.RuntimeTypeManager">
            <summary>
            Provides a mechanism for initialization and management of types residing in a virtual machine.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.RuntimeTypeManager.#ctor(Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine)">
            <summary>
            Creates a new runtime type manager.
            </summary>
            <param name="machine">The machine the type is made for.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.RuntimeTypeManager.RegisterInitializationException(AsmResolver.DotNet.ITypeDescriptor,Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Registers the event that a type has failed to initialize. 
            </summary>
            <param name="type">The type that failed to initialize.</param>
            <param name="innerException">The exception object that describes the failure.</param>
            <returns>The resulting TypeInitializationException instance.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.RuntimeTypeManager.HandleInitialization(Echo.Platforms.AsmResolver.Emulation.CilThread,AsmResolver.DotNet.ITypeDescriptor)">
            <summary>
            Handles the type initialization on the provided thread.
            </summary>
            <param name="thread">The thread the initialization is to be called on.</param>
            <param name="type">The type to initialize.</param>
            <returns>The initialization result.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage">
            <summary>
            Represents a chunk of memory designated for storing static fields in a .NET process.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.#ctor(Echo.Platforms.AsmResolver.Emulation.ValueFactory,System.Int32)">
            <summary>
            Creates a new empty static field storage.
            </summary>
            <param name="valueFactory">The value factory responsible for measuring and constructing new values.</param>
            <param name="size">The maximum size of the storage.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.#ctor(Echo.Platforms.AsmResolver.Emulation.ValueFactory,Echo.Memory.Heap.IHeap)">
            <summary>
            Creates a new empty static field storage.
            </summary>
            <param name="valueFactory">The value factory responsible for measuring and constructing new values.</param>
            <param name="heap">The virtual heap to use for storing the field values.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.GetFieldAddress(AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Gets the address of the provided field.
            </summary>
            <param name="field">The field.</param>
            <returns>The address.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.GetFieldSpan(AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Obtains a writable bitvector slice that spans the value of the provided field. 
            </summary>
            <param name="field">The field.</param>
            <returns>The slice.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.StaticFieldStorage.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Runtime.TypeInitializerResult">
            <summary>
            Describes a result of a type initialization.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.TypeInitializerResult.IsNoAction">
            <summary>
            Gets a value indicating whether the type initialization does not require any further action.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.TypeInitializerResult.IsRedirectedToConstructor">
            <summary>
            Gets a value indicating whether control was redirected to the class constructor of a type.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Runtime.TypeInitializerResult.ExceptionObject">
            <summary>
            Gets the exception that was thrown when initialization the type, if any.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.TypeInitializerResult.NoAction">
            <summary>
            Creates a result that indicates no further action was taken.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.TypeInitializerResult.Redirected">
            <summary>
            Creates a result that indicates control was redirected to a class constructor.
            </summary>
            <returns>The result.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.TypeInitializerResult.Exception(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Creates a result that throws a type initialization exception. 
            </summary>
            <param name="exception">The exception that was thrown.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Runtime.TypeInitializerResult.ToDispatchResult">
            <summary>
            Transforms the type initialization result into a <see cref="T:Echo.Platforms.AsmResolver.Emulation.Dispatch.CilDispatchResult"/>.
            </summary>
            <returns>The new dispatcher result.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.CallEventArgs">
            <summary>
            Provides a description of events related to a frame in a call stack. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallEventArgs.Frame">
            <summary>
            Gets the call frame related to the event.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame">
            <summary>
            Represents a single frame in a virtual stack.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.#ctor(AsmResolver.DotNet.IMethodDescriptor,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Constructs a new call stack frame.
            </summary>
            <param name="method">The method that this frame is associated with.</param>
            <param name="factory">A factory used for measuring the size of the frame.</param>
            <exception cref="T:System.ArgumentException">
            Occurs when the provided method is invalid or contains invalid metadata that could not be dealt with.
            </exception>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.IsRoot">
            <summary>
            Gets a value indicating the frame is the root frame of the call stack.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.IsTrampoline">
            <summary>
            Gets a value indicating that the frame is a trampoline, and that it immediately returns the value of the next method on the stack
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.Method">
            <summary>
            Gets the method which this frame was associated with.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.Body">
            <summary>
            Gets the managed body of the method that this frame is associated with (if available).
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.LocalsCount">
            <summary>
            Gets the number of locals stored in the frame.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ProgramCounter">
            <summary>
            Gets the offset within the method body of the next instruction to evaluate.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.EvaluationStack">
            <summary>
            Gets a virtual evaluation stack associated stored the frame.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ExceptionHandlers">
            <summary>
            Gets a collection of exception handler frames present in the method body.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ExceptionHandlerStack">
            <summary>
            Gets the stack of currently active exception handler frames in the method.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.Size">
            <summary>
            Gets the number of bytes (excluding the evaluation stack) the stack frame spans.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.CanAllocateMemory">
            <summary>
            Gets a value indicating whether the frame can be extended with extra stack memory.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ConstrainedType">
            <summary>
            Gets or sets the current type that the following call instruction is constrained by, if any.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.Allocate(System.Int32)">
            <summary>
            Allocates local stack memory in the stack frame.
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.GetLocalAddress(System.Int32)">
            <summary>
            Gets the address (relative to the start of the frame) to a local variable in the frame. 
            </summary>
            <param name="index">The index of the local variable to get the address for.</param>
            <returns>The address</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Occurs when the local index is invalid.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ReadLocal(System.Int32)">
            <summary>
            Reads the value of a local variable into a buffer. 
            </summary>
            <param name="index">The index of the variable.</param>
            <returns>A bit vector with the current data of the local variable.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ReadLocal(System.Int32,Echo.Memory.BitVectorSpan)">
            <summary>
            Reads the value of a local variable into a buffer. 
            </summary>
            <param name="index">The index of the variable.</param>
            <param name="buffer">The buffer to write the data into.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.WriteLocal(System.Int32,Echo.Memory.BitVectorSpan)">
            <summary>
            Assigns a new value to a local variable. 
            </summary>
            <param name="index">The index of the variable.</param>
            <param name="buffer">The buffer containing the new data.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.GetArgumentAddress(System.Int32)">
            <summary>
            Gets the address (relative to the start of the frame) to an argument in the frame. 
            </summary>
            <param name="index">The index of the argument to get the address for.</param>
            <returns>The address</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Occurs when the argument index is invalid.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ReadArgument(System.Int32)">
            <summary>
            Reads the value of a local variable into a buffer. 
            </summary>
            <param name="index">The index of the variable.</param>
            <returns>A bit vector with the current data of the argument.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ReadArgument(System.Int32,Echo.Memory.BitVectorSpan)">
            <summary>
            Reads the value of an argument into a buffer. 
            </summary>
            <param name="index">The index of the argument to read.</param>
            <param name="buffer">The buffer to write the data into.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.WriteArgument(System.Int32,Echo.Memory.BitVectorSpan)">
            <summary>
            Assigns a new value to an argument. 
            </summary>
            <param name="index">The index of the argument.</param>
            <param name="buffer">The buffer containing the new data.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack">
            <summary>
            Represents a call stack consisting of frames, representing the current state of the program.
            </summary>
        </member>
        <member name="E:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Called">
            <summary>
            Occurs when a new call frame is pushed onto the stack.
            </summary>
        </member>
        <member name="E:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Returned">
            <summary>
            Occurs when a call frame was popped from the stack. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.#ctor(System.UInt32,Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Creates a new virtual call stack.
            </summary>
            <param name="maxSize">The maximum number of bytes the stack can hold.</param>
            <param name="factory">The service responsible for managing types.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.AddressRange">
            <inheritdoc />
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.StackPointer">
            <summary>
            Gets the current value of the stack pointer.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.GetFrameAddress(System.Int32)">
            <summary>
            Gets the address of a single frame in the stack.
            </summary>
            <param name="index">The index of the stack frame.</param>
            <returns>The address.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Push(AsmResolver.DotNet.IMethodDescriptor)">
            <summary>
            Creates a new call stack frame for the provided method and pushes it onto the top of the call stack.
            </summary>
            <param name="method">The method to create a frame for.</param>
            <returns>The created call stack frame.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Push(Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame)">
            <summary>
            Pushes a call frame onto the stack.
            </summary>
            <param name="frame">The frame to push.</param>
            <exception cref="T:System.StackOverflowException">Occurs when the stack reached its maximum size.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Pop">
            <summary>
            Pops the top-most frame from the stack.
            </summary>
            <returns>The popped frame.</returns>
            <exception cref="T:System.InvalidOperationException">Occurs when the stack is empty.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.OnCalled(Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame)">
            <summary>
            Fires the <see cref="E:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Called"/> event.
            </summary>
            <param name="frame">The frame that was pushed.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.OnReturned(Echo.Platforms.AsmResolver.Emulation.Stack.CallFrame)">
            <summary>
            Fires the <see cref="E:Echo.Platforms.AsmResolver.Emulation.Stack.CallStack.Returned"/> event.
            </summary>
            <param name="frame">The frame that was popped.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.CallStackMemory.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStackMemory.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStackMemory.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStackMemory.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStackMemory.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.CallStackMemory.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.EvaluationStack">
            <summary>
            Represents an evaluation stack during the execution of a managed method body.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.EvaluationStack.#ctor(Echo.Platforms.AsmResolver.Emulation.ValueFactory)">
            <summary>
            Creates a new evaluation stack.
            </summary>
            <param name="factory">The value factory to use.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.EvaluationStack.Push(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Puts the address of the provided object handle into a pointer-sized bit vector, and pushes it onto the stack.
            </summary>
            <param name="value">The handle to push.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.EvaluationStack.Push(Echo.Memory.BitVectorSpan,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Marshals the provided bitvector into a stack slot, and pushes it onto the stack.
            </summary>
            <param name="value">The value to push.</param>
            <param name="originalType">The type of the value to push.</param>
            <returns>The stack slot that was created.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.EvaluationStack.Push(Echo.Memory.BitVector,AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Marshals the provided bitvector into a stack slot, and pushes it onto the stack.
            </summary>
            <param name="value">The value to push.</param>
            <param name="originalType">The type of the value to push.</param>
            <returns>The stack slot that was created.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.EvaluationStack.Push(Echo.Memory.BitVector,AsmResolver.DotNet.Signatures.TypeSignature,System.Boolean)">
            <summary>
            Marshals the provided bitvector into a stack slot, and pushes it onto the stack.
            </summary>
            <param name="value">The value to push.</param>
            <param name="originalType">The type of the value to push.</param>
            <param name="releaseBitVector">
            <c>true</c> if <paramref name="value"/> should be returned to the bit vector pool, <c>false</c> if the caller
            should remain the owner of the bit vector.
            </param>
            <returns>The stack slot that was created.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.EvaluationStack.Pop(AsmResolver.DotNet.Signatures.TypeSignature)">
            <summary>
            Pops the top-most value from the stack, and reinterprets it according to the provided target type.
            </summary>
            <param name="targetType">The type of the value to pop.</param>
            <returns>The popped and marshalled value.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.EvaluationStack.Clear">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame">
            <summary>
            Provides a mechanism for implementing exception handling for a single protected range within a single method body.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.#ctor(Echo.AddressRange)">
            <summary>
            Creates a new exception handler frame.
            </summary>
            <param name="protectedRange">The IL offset range the exception handler is protecting.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.ProtectedRange">
            <summary>
            Gets the IL offset range the exception handler is protecting.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.Handlers">
            <summary>
            Gets a list of handlers that are associated to the protected range.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.HasFinalizer">
            <summary>
            Gets a value indicating whether the exception handler has a finalizer block.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.CurrentHandler">
            <summary>
            Gets the current active exception handler (if available).
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.NextOffset">
            <summary>
            Gets the offset to jump to after a finalizer has exited (if available).
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.ExceptionObject">
            <summary>
            Gets the current exception object that was thrown within the protected range. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.IsProtecting">
            <summary>
            Gets a value indicating whether the frame is currently protecting the current instruction pointer.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.IsHandlingException">
            <summary>
            Gets a value indicating whether the exception handler is currently handling the exception referenced
            by <see cref="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.ExceptionObject"/>.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.ContainsOffset(System.Int32)">
            <summary>
            Determines whether the provided offset falls within the protected offset range or any of the handlers. 
            </summary>
            <param name="offset">The offset.</param>
            <returns><c>true</c> if the offset is within the frame, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.Reset">
            <summary>
            Resets the exception handler to its initial state.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.Enter">
            <summary>
            Attempts to enter the protected range.
            </summary>
            <returns><c>true</c> if the frame was entered, <c>false</c> if the frame was already entered before.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.RegisterException(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Registers the occurrence of an exception, and determines the next offset to jump to that will attempt
            to handle the exception or finalize the code block.
            </summary>
            <param name="exceptionObject">The exception object.</param>
            <returns></returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.Leave(System.Int32)">
            <summary>
            Leaves either a protected range or an exception handler while marking the exception as handled successfully.
            </summary>
            <param name="leaveTargetOffset">The target offset to jump to.</param>
            <returns>The offset to jump to.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.EndFinally">
            <summary>
            Exits a finally block, and determines the next offset to jump to.
            </summary>
            <returns>The offset to jump to.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerFrame.EndFilter(System.Boolean)">
            <summary>
            Exits a filter clause, and determines the next offset to jump to.
            </summary>
            <param name="result">
            <c>true</c> if the exception should be handled by the current handler, <c>false</c> otherwise.
            </param>
            <returns>The offset to jump to.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerResult">
            <summary>
            Provides a discriminated union describing the result of an exception handler operation, containing either the
            next offset to jump to, or a handle to an unhandled exception object.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerResult.NextOffset">
            <summary>
            When <see cref="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerResult.IsSuccess"/> is <c>true</c>, contains the next IL offset to jump to within the current method. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerResult.ExceptionObject">
            <summary>
            When <see cref="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerResult.IsSuccess"/> is <c>false</c>, contains the handle to the unhandled exception that was thrown.   
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerResult.IsSuccess">
            <summary>
            Gets a value indicating whether the handler operation was successful.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerResult.Success(System.Int32)">
            <summary>
            Constructs a new successful exception handler result.
            </summary>
            <param name="offset">The next IL offset to jump to.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerResult.Exception(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Constructs a new unsuccessful exception handler result.
            </summary>
            <param name="exceptionObject">The handle to the unhandled exception that was thrown.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerStack">
            <summary>
            Implements the exception handling mechanism within a single managed method.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerStack.RegisterException(Echo.Platforms.AsmResolver.Emulation.ObjectHandle)">
            <summary>
            Registers an exception, unwinds the exception handler stack and determines where to jump to within the
            current method.
            </summary>
            <param name="exceptionObject">The handle to the exception that was thrown.</param>
            <returns>
            The offset to jump to next within the method, or the exception object if the exception was not handled
            by the method.
            </returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerStack.Leave(System.Int32)">
            <summary>
            Safely leaves one or more exception handlers that are currently on the stack.
            </summary>
            <param name="targetOffset">The offset as indicated by the leave instruction.</param>
            <returns>The offset to jump to next.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerStack.EndFilter(System.Boolean)">
            <summary>
            Exits a filter clause with the provided result, and unwinds the exception handler stack if necessary.
            </summary>
            <param name="result">The result of the filter expression.</param>
            <returns>
            The offset to jump to next within the method, or the exception object if the exception was not handled
            by the method.
            </returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.ExceptionHandlerStack.EndFinally">
            <summary>
            Exits a finally clause, and unwinds the exception handler stack if necessary.
            </summary>
            <returns>
            The offset to jump to next within the method, or the exception object if the exception was not handled
            by the method.
            </returns>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot">
            <summary>
            Represents a single slot in the evaluation stack.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot.#ctor(Echo.Memory.BitVector,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlotTypeHint)">
            <summary>
            Creates a new stack slot.
            </summary>
            <param name="contents">The value stored in the slot.</param>
            <param name="typeHint">A type hint indicating how this value was pushed.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot.Contents">
            <summary>
            Gets the value stored in the slot.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot.TypeHint">
            <summary>
            Gets a type hint indicating how this value was pushed.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlotTypeHint">
            <summary>
            Provides type hints indicating how a value was pushed onto the stack.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlotTypeHint.Integer">
            <summary>
            Indicates the value was pushed as an integer.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlotTypeHint.Float">
            <summary>
            Indicates the value was pushed as a floating point number.
            </summary>
        </member>
        <member name="F:Echo.Platforms.AsmResolver.Emulation.Stack.StackSlotTypeHint.Structure">
            <summary>
            Indicates the value was pushed as a custom structure.
            </summary>
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.StructHandle">
            <summary>
            Represents an address to a structure within a CIL virtual machine. 
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.#ctor(Echo.Platforms.AsmResolver.Emulation.CilVirtualMachine,System.Int64)">
            <summary>
            Creates a new struct handle from the provided address.
            </summary>
            <param name="machine">The machine the address is valid in.</param>
            <param name="address">The address.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.StructHandle.Machine">
            <summary>
            Gets the machine the structures lives in.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.StructHandle.Address">
            <summary>
            Gets the address to the beginning of the object.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.GetFieldAddress(AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Obtains the absolute address of a field within the structure.
            </summary>
            <param name="field">The field to obtain the address for.</param>
            <returns>The address.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.ReadField(AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Copies the value of a field into a new bit vector.
            </summary>
            <param name="field">The field to obtain the value for.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.ReadField(AsmResolver.DotNet.IFieldDescriptor,Echo.Memory.BitVectorSpan)">
            <summary>
            Copies the value of a field into a bit vector.
            </summary>
            <param name="field">The field to obtain the value for.</param>
            <param name="buffer">The buffer to copy the value into.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.WriteField(AsmResolver.DotNet.IFieldDescriptor,Echo.Memory.BitVectorSpan)">
            <summary>
            Copies the provided bit vector into a field of the object. 
            </summary>
            <param name="field">The field to write to.</param>
            <param name="buffer">The bits to write.</param>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.Equals(Echo.Platforms.AsmResolver.Emulation.StructHandle)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.StructHandle.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver">
            <summary>
            Provides an implementation of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.IUnknownResolver"/> that throws upon resolving an unknown value. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.Instance">
            <summary>
            Gets the default instance of the <see cref="T:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver"/> class.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveBranchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveBranchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveSwitchCondition(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveSourcePointer(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveDestinationPointer(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveBlockSize(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveArrayIndex(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,System.Int64,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveMethod(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,System.Collections.Generic.IList{Echo.Memory.BitVector})">
            <inheritdoc />
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ThrowUnknownResolver.ResolveExceptionFilter(Echo.Platforms.AsmResolver.Emulation.Dispatch.CilExecutionContext,AsmResolver.PE.DotNet.Cil.CilInstruction,Echo.Platforms.AsmResolver.Emulation.Stack.StackSlot)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Platforms.AsmResolver.Emulation.ValueFactory">
            <summary>
            Provides a service for querying information about- and constructing new values.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.#ctor(AsmResolver.DotNet.ModuleDefinition,System.Boolean)">
            <summary>
            Creates a new value factory.
            </summary>
            <param name="contextModule">The manifest module to use for context.</param>
            <param name="is32Bit">A value indicating whether the environment is a 32-bit or 64-bit system.</param>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.ContextModule">
            <summary>
            Gets the manifest module to use for context.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.Is32Bit">
            <summary>
            Gets a value indicating whether the environment is a 32-bit or 64-bit system.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.PointerSize">
            <summary>
            Gets the size in bytes of a pointer in the current environment.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.ClrMockMemory">
            <summary>
            Gets the CLR mock memory used for managing method tables (types).
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.DecimalType">
            <summary>
            Gets a reference to the <see cref="T:System.Decimal"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.DelegateType">
            <summary>
            Gets a reference to the <see cref="T:System.Delegate"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.DelegateTargetField">
            <summary>
            Get a reference to the <see cref="T:System.Delegate"/> _target field.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.DelegateMethodPtrField">
            <summary>
            Get a reference to the <see cref="T:System.Delegate"/> _methodPtr field.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.InvalidProgramExceptionType">
            <summary>
            Gets a reference to the <see cref="T:System.InvalidProgramException"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.TypeInitializationExceptionType">
            <summary>
            Gets a reference to the <see cref="T:System.TypeInitializationException"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.NullReferenceExceptionType">
            <summary>
            Gets a reference to the <see cref="T:System.NullReferenceException"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.IndexOutOfRangeExceptionType">
            <summary>
            Gets a reference to the <see cref="T:System.IndexOutOfRangeException"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.StackOverflowExceptionType">
            <summary>
            Gets a reference to the <see cref="T:System.StackOverflowException"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.MissingMethodExceptionType">
            <summary>
            Gets a reference to the <see cref="T:System.MissingMethodException"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.InvalidCastExceptionType">
            <summary>
            Gets a reference to the <see cref="T:System.InvalidCastException"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.OverflowExceptionType">
            <summary>
            Gets a reference to the <see cref="T:System.OverflowException"/> type. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.BitVectorPool">
            <summary>
            Gets the bitvector pool that this factory uses for creating and reusing bit vectors. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.Marshaller">
            <summary>
            Gets the service responsible for marshalling values into stack slots and back. 
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.ObjectHeaderSize">
            <summary>
            Gets the size of an object header.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.ArrayHeaderSize">
            <summary>
            Gets the number of bytes prepended to the data of the array.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.ArrayLengthOffset">
            <summary>
            Gets the offset within an array object that indexes the start of the Length field.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.StringHeaderSize">
            <summary>
            Gets the number of bytes prepended to the characters of the string.
            </summary>
        </member>
        <member name="P:Echo.Platforms.AsmResolver.Emulation.ValueFactory.StringLengthOffset">
            <summary>
            Gets the offset within an string object that indexes the start of the Length field.
            </summary>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.GetArrayObjectSize(AsmResolver.DotNet.ITypeDescriptor,System.Int32)">
            <summary>
            Computes the total size of an array object.
            </summary>
            <param name="elementType">The type of elements the array stores.</param>
            <param name="elementCount">The number of elements.</param>
            <returns>The total size in bytes.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.GetStringObjectSize(System.Int32)">
            <summary>
            Computes the total size of a string object.
            </summary>
            <param name="length">The number of characters in the string.</param>
            <returns>The total size in bytes.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.GetObjectSize(AsmResolver.DotNet.ITypeDescriptor)">
            <summary>
            Computes the total size of an object.
            </summary>
            <param name="type">The type of object to measure.</param>
            <returns>The total size in bytes.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.CreateNull">
            <summary>
            Creates a new native integer bit vector containing the null reference.
            </summary>
            <returns>The constructed bit vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.CreateNativeInteger(System.Boolean)">
            <summary>
            Creates a new native integer bit vector.
            </summary>
            <param name="initialize">
            <c>true</c> if the value should be set to 0, <c>false</c> if the integer should remain unknown.
            </param>
            <returns>The constructed bit vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.CreateNativeInteger(System.Int64)">
            <summary>
            Creates a new native integer bit vector.
            </summary>
            <param name="value">The value to initialize the integer with.</param>
            <returns>The constructed bit vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.CreateBoolean(Echo.Trilean)">
            <summary>
            Creates a new 32-bit vector from the bit vector pool containing the boolean value.
            </summary>
            <param name="value">The value.</param>
            <returns>The vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.RentNull">
            <summary>
            Rents a new native integer bit vector containing the null reference.
            </summary>
            <returns>The constructed bit vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.RentNativeInteger(System.Boolean)">
            <summary>
            Rents a native integer bit vector from the bit vector pool.
            </summary>
            <param name="initialize">
            <c>true</c> if the value should be set to 0, <c>false</c> if the integer should remain unknown.
            </param>
            <returns>The rented bit vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.RentNativeInteger(System.Int64)">
            <summary>
            Rents a native integer bit vector from the bit vector pool.
            </summary>
            <param name="value">The value to initialize the integer with.</param>
            <returns>The rented bit vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.RentBoolean(Echo.Trilean)">
            <summary>
            Rents a 32-bit vector from the bit vector pool containing the boolean value.
            </summary>
            <param name="value">The value.</param>
            <returns>The vector</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.CreateValue(AsmResolver.DotNet.Signatures.TypeSignature,System.Boolean)">
            <summary>
            Creates a new bit vector that can be used to represent an instance of the provided type.
            </summary>
            <param name="type">The type to represent.</param>
            <param name="initialize">
            <c>true</c> if the value should be set to 0, <c>false</c> if the value should remain unknown.
            </param>
            <returns>The constructed bit vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.RentValue(AsmResolver.DotNet.Signatures.TypeSignature,System.Boolean)">
            <summary>
            Rents a bit vector from the pool that can be used to represent an instance of the provided type.
            </summary>
            <param name="type">The type to represent.</param>
            <param name="initialize">
            <c>true</c> if the value should be set to 0, <c>false</c> if the value should remain unknown.
            </param>
            <returns>The rented bit vector.</returns>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.GetTypeValueMemoryLayout(AsmResolver.DotNet.ITypeDescriptor)">
            <summary>
            Obtains the memory layout of a type in the current environment. If the provided type is a reference type,
            then it will measure the object reference itself, and not the contents behind the reference.
            </summary>
            <param name="type">The type to measure.</param>
            <returns>The measured layout.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Occurs when the type could not be measured.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.GetTypeContentsMemoryLayout(AsmResolver.DotNet.ITypeDescriptor)">
            <summary>
            Obtains the memory layout of a type in the current environment. If the provided type is a reference type,
            then it will measure the size of the contents behind the object reference. 
            </summary>
            <param name="type">The type to measure.</param>
            <returns>The measured layout.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Occurs when the type could not be measured.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.GetFieldMemoryLayout(AsmResolver.DotNet.IFieldDescriptor)">
            <summary>
            Obtains memory layout information of a field.
            </summary>
            <param name="field">The field.</param>
            <returns>The memory layout information.</returns>
            <exception cref="T:System.ArgumentException">Occurs when the field could not be resolved.</exception>
        </member>
        <member name="M:Echo.Platforms.AsmResolver.Emulation.ValueFactory.GetArrayElementOffset(AsmResolver.DotNet.Signatures.TypeSignature,System.Int64)">
            <summary>
            Calculates the offset to the element within an array. 
            </summary>
            <param name="elementType">The element type.</param>
            <param name="index">The element's index.</param>
            <returns>The offset, relative to the start of an array object.</returns>
        </member>
    </members>
</doc>



================================================
File: lib/Echo.deps.json
================================================
{
  "runtimeTarget": {
    "name": ".NETStandard,Version=v2.0/",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETStandard,Version=v2.0": {},
    ".NETStandard,Version=v2.0/": {
      "Echo/0.9.0.1": {
        "dependencies": {
          "NETStandard.Library": "2.0.3",
          "System.Memory": "4.5.5"
        },
        "runtime": {
          "Echo.dll": {}
        }
      },
      "Microsoft.NETCore.Platforms/1.1.0": {},
      "NETStandard.Library/2.0.3": {
        "dependencies": {
          "Microsoft.NETCore.Platforms": "1.1.0"
        }
      },
      "System.Buffers/4.5.1": {
        "runtime": {
          "lib/netstandard2.0/System.Buffers.dll": {
            "assemblyVersion": "4.0.3.0",
            "fileVersion": "4.6.28619.1"
          }
        }
      },
      "System.Memory/4.5.5": {
        "dependencies": {
          "System.Buffers": "4.5.1",
          "System.Numerics.Vectors": "4.4.0",
          "System.Runtime.CompilerServices.Unsafe": "4.5.3"
        },
        "runtime": {
          "lib/netstandard2.0/System.Memory.dll": {
            "assemblyVersion": "4.0.1.2",
            "fileVersion": "4.6.31308.1"
          }
        }
      },
      "System.Numerics.Vectors/4.4.0": {
        "runtime": {
          "lib/netstandard2.0/System.Numerics.Vectors.dll": {
            "assemblyVersion": "4.1.3.0",
            "fileVersion": "4.6.25519.3"
          }
        }
      },
      "System.Runtime.CompilerServices.Unsafe/4.5.3": {
        "runtime": {
          "lib/netstandard2.0/System.Runtime.CompilerServices.Unsafe.dll": {
            "assemblyVersion": "4.0.4.1",
            "fileVersion": "4.6.28619.1"
          }
        }
      }
    }
  },
  "libraries": {
    "Echo/0.9.0.1": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "Microsoft.NETCore.Platforms/1.1.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-kz0PEW2lhqygehI/d6XsPCQzD7ff7gUJaVGPVETX611eadGsA3A877GdSlU0LRVMCTH/+P3o2iDTak+S08V2+A==",
      "path": "microsoft.netcore.platforms/1.1.0",
      "hashPath": "microsoft.netcore.platforms.1.1.0.nupkg.sha512"
    },
    "NETStandard.Library/2.0.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-st47PosZSHrjECdjeIzZQbzivYBJFv6P2nv4cj2ypdI204DO+vZ7l5raGMiX4eXMJ53RfOIg+/s4DHVZ54Nu2A==",
      "path": "netstandard.library/2.0.3",
      "hashPath": "netstandard.library.2.0.3.nupkg.sha512"
    },
    "System.Buffers/4.5.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-Rw7ijyl1qqRS0YQD/WycNst8hUUMgrMH4FCn1nNm27M4VxchZ1js3fVjQaANHO5f3sN4isvP4a+Met9Y4YomAg==",
      "path": "system.buffers/4.5.1",
      "hashPath": "system.buffers.4.5.1.nupkg.sha512"
    },
    "System.Memory/4.5.5": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-XIWiDvKPXaTveaB7HVganDlOCRoj03l+jrwNvcge/t8vhGYKvqV+dMv6G4SAX2NoNmN0wZfVPTAlFwZcZvVOUw==",
      "path": "system.memory/4.5.5",
      "hashPath": "system.memory.4.5.5.nupkg.sha512"
    },
    "System.Numerics.Vectors/4.4.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-UiLzLW+Lw6HLed1Hcg+8jSRttrbuXv7DANVj0DkL9g6EnnzbL75EB7EWsw5uRbhxd/4YdG8li5XizGWepmG3PQ==",
      "path": "system.numerics.vectors/4.4.0",
      "hashPath": "system.numerics.vectors.4.4.0.nupkg.sha512"
    },
    "System.Runtime.CompilerServices.Unsafe/4.5.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-3TIsJhD1EiiT0w2CcDMN/iSSwnNnsrnbzeVHSKkaEgV85txMprmuO+Yq2AdSbeVGcg28pdNDTPK87tJhX7VFHw==",
      "path": "system.runtime.compilerservices.unsafe/4.5.3",
      "hashPath": "system.runtime.compilerservices.unsafe.4.5.3.nupkg.sha512"
    }
  }
}


================================================
File: lib/Echo.xml
================================================
<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Echo</name>
    </assembly>
    <members>
        <member name="T:Echo.AddressRange">
            <summary>
            Represents an address range in memory.
            </summary>
        </member>
        <member name="F:Echo.AddressRange.NilRange">
            <summary>
            A range that starts and ends at index 0.
            </summary>
        </member>
        <member name="M:Echo.AddressRange.op_Equality(Echo.AddressRange,Echo.AddressRange)">
            <summary>
            Determines whether two address ranges are considered equal.
            </summary>
            <param name="a">The first range.</param>
            <param name="b">The second range.</param>
            <returns><c>true</c> if the ranges are considered equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.AddressRange.op_Inequality(Echo.AddressRange,Echo.AddressRange)">
            <summary>
            Determines whether two address ranges are not considered equal.
            </summary>
            <param name="a">The first range.</param>
            <param name="b">The second range.</param>
            <returns><c>true</c> if the ranges are not considered equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.AddressRange.#ctor(System.Int64,System.Int64)">
            <summary>
            Creates a new address range.
            </summary>
            <param name="start">The starting address.</param>
            <param name="end">The exclusive ending address.</param>
        </member>
        <member name="P:Echo.AddressRange.Start">
            <summary>
            Gets the address of the first byte in the address range.
            </summary>
        </member>
        <member name="P:Echo.AddressRange.End">
            <summary>
            Gets the address where this address range stops. This address is exclusive. 
            </summary>
        </member>
        <member name="P:Echo.AddressRange.Length">
            <summary>
            Gets the total length of the address range.
            </summary>
        </member>
        <member name="M:Echo.AddressRange.Contains(System.Int64)">
            <summary>
            Determines whether the provided address falls within the address range.
            </summary>
            <param name="address">The address.</param>
            <returns><c>true</c> if the address falls within the range, <c>false otherwise</c>.</returns>
        </member>
        <member name="M:Echo.AddressRange.Contains(Echo.AddressRange)">
            <summary>
            Determines whether the address range contains the provided sub range.
            </summary>
            <param name="range">The address range.</param>
            <returns><c>true</c> if the sub range falls within the range, <c>false otherwise</c>.</returns>
        </member>
        <member name="M:Echo.AddressRange.Expand(System.Int64)">
            <summary>
            Expands the address range such that the provided offset is included in the range.
            </summary>
            <param name="offset">The offset to include.</param>
            <returns>The new expanded range.</returns>
        </member>
        <member name="M:Echo.AddressRange.Expand(Echo.AddressRange)">
            <summary>
            Expands the address range such that the provided address range is included in the total range.
            </summary>
            <param name="other">The other address range to include.</param>
            <returns>The new expanded range.</returns>
        </member>
        <member name="M:Echo.AddressRange.Equals(Echo.AddressRange@)">
            <summary>
            Determines whether the range is considered equal with the provided range.
            </summary>
            <param name="other">The other range.</param>
            <returns><c>true</c> if the ranges are considered equal, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.AddressRange.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.AddressRange.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.AddressRange.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Code.IArchitecture`1">
            <summary>
            Provides members for describing an instruction set.
            </summary>
            <typeparam name="TInstruction">The type of the instruction model this architecture describes.</typeparam>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetOffset(`0@)">
            <summary>
            Gets the offset of an instruction.
            </summary>
            <param name="instruction">The instruction to get the offset from.</param>
            <returns>The offset.</returns>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetSize(`0@)">
            <summary>
            Gets the size in bytes of an instruction.
            </summary>
            <param name="instruction">The instruction to measure.</param>
            <returns>The size.</returns>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetFlowControl(`0@)">
            <summary>
            Gets attributes associated to the flow control behaviour of the provided instruction.
            </summary>
            <param name="instruction">The instruction to get the attributes from.</param>
            <returns>The flow control attributes.</returns>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetStackPushCount(`0@)">
            <summary>
            Gets a value indicating the number of values an instruction pushes on the stack.
            </summary>
            <param name="instruction">The instruction to get the stack push count from.</param>
            <returns>The number of stack slots the instruction pushes.</returns>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetStackPopCount(`0@)">
            <summary>
            Gets a value indicating the number of values an instruction pops from the stack.
            </summary>
            <param name="instruction">The instruction to get the stack pop count from.</param>
            <returns>The number of stack slots the instruction pops.</returns>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetReadVariablesCount(`0@)">
            <summary>
            Gets the number of variables that the provided instruction reads from.
            </summary>
            <param name="instruction">The instruction to get the number of read variables from.</param>
            <returns>The number of variables.</returns>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetReadVariables(`0@,System.Span{Echo.Code.IVariable})">
            <summary>
            Gets a collection of variables that an instruction reads from.
            </summary>
            <param name="instruction">The instruction to get the variables from.</param>
            <param name="variablesBuffer">The output buffer to write the read variables into.</param>
            <returns>The number of variables that were written into <paramref name="variablesBuffer"/>.</returns>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetWrittenVariablesCount(`0@)">
            <summary>
            Gets the number of variables that the provided instruction writes to.
            </summary>
            <param name="instruction">The instruction to get the number of written variables from.</param>
            <returns>The number of variables.</returns>
        </member>
        <member name="M:Echo.Code.IArchitecture`1.GetWrittenVariables(`0@,System.Span{Echo.Code.IVariable})">
            <summary>
            Gets a collection of variables that an instruction writes to.
            </summary>
            <param name="instruction">The instruction to get the variables from.</param>
            <param name="variablesBuffer">The output buffer to write the written variables into.</param>
            <returns>The number of variables that were written into <paramref name="variablesBuffer"/>.</returns>
        </member>
        <member name="T:Echo.Code.InstructionFlowControl">
            <summary>
            Provides members for describing various flow control properties of an instruction. 
            </summary>
        </member>
        <member name="F:Echo.Code.InstructionFlowControl.Fallthrough">
            <summary>
            Indicates the instruction does not have any specific attributes assigned to it.
            </summary>
        </member>
        <member name="F:Echo.Code.InstructionFlowControl.CanBranch">
            <summary>
            Indicates the instruction might branch out from the normal control flow to a different instruction. 
            </summary>
        </member>
        <member name="F:Echo.Code.InstructionFlowControl.IsTerminator">
            <summary>
            Indicates the instruction terminates the current execution path.
            </summary>
        </member>
        <member name="T:Echo.Code.IPurityClassifier`1">
            <summary>
            Provides members for describing the purity of instructions.
            </summary>
            <typeparam name="TInstruction">The type of instructions.</typeparam>
        </member>
        <member name="M:Echo.Code.IPurityClassifier`1.IsPure(`0@)">
            <summary>
            Gets a value indicating whether a particular instruction is considered pure, that is, has no side effects.
            </summary>
            <param name="instruction">The instruction to classify.</param>
            <returns><c>true</c> if the instruction is pure, <c>false</c> if not, and <see cref="F:Echo.Trilean.Unknown"/> if
            this could not be determined.</returns>
        </member>
        <member name="T:Echo.Code.IStaticInstructionProvider`1">
            <summary>
            Represents a collection of instructions that can be accessed by their offset.
            </summary>
            <typeparam name="TInstruction">The type of instructions that this collection provides.</typeparam>
        </member>
        <member name="P:Echo.Code.IStaticInstructionProvider`1.Architecture">
            <summary>
            Gets the architecture describing the instructions exposed by this instruction provider.
            </summary>
        </member>
        <member name="M:Echo.Code.IStaticInstructionProvider`1.GetInstructionAtOffset(System.Int64)">
            <summary>
            Gets the instruction at the provided address.
            </summary>
            <param name="offset">The address of the instruction to get.</param>
            <returns>The instruction at the provided address.</returns>
        </member>
        <member name="T:Echo.Code.IVariable">
            <summary>
            Represents a single variable in a virtual machine.
            </summary>
        </member>
        <member name="P:Echo.Code.IVariable.Name">
            <summary>
            Gets the name of the variable.
            </summary>
        </member>
        <member name="T:Echo.Code.ListInstructionProvider`1">
            <summary>
            Wraps a simple collection of instructions in a basic implementation of an <see cref="T:Echo.Code.IStaticInstructionProvider`1"/>.
            </summary>
            <typeparam name="TInstruction">The type of instructions to store.</typeparam>
        </member>
        <member name="M:Echo.Code.ListInstructionProvider`1.#ctor(Echo.Code.IArchitecture{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new wrapper for a sequence of instructions.
            </summary>
            <param name="architecture">The instruction architecture.</param>
            <param name="instructions">The instructions to put into the wrapper.</param>
            <exception cref="T:System.ArgumentException">Occurs when there are multiple instructions with the same offset.</exception>
            <exception cref="T:System.ArgumentNullException">Occurs when the provided instruction sequence is <c>null</c>.</exception>
        </member>
        <member name="P:Echo.Code.ListInstructionProvider`1.Architecture">
            <inheritdoc />
        </member>
        <member name="M:Echo.Code.ListInstructionProvider`1.GetInstructionAtOffset(System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Graphing.Analysis.Connectivity.ComponentDetector">
            <summary>
            Provides utility members for finding connected components within a graph.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Connectivity.ComponentDetector.FindStronglyConnectedComponents(Echo.Graphing.IGraph)">
            <summary>
            Finds all strongly connected components in the provided graph.
            </summary>
            <param name="graph">The graph to get the components from.</param>
            <returns>A collection of sets representing the strongly connected components.</returns>
        </member>
        <member name="T:Echo.Graphing.Analysis.CycleDetectedException">
            <summary>
            Represents the error that occurs when a cycle was found in a graph that is supposed to be acyclic. 
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.CycleDetectedException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.Graphing.Analysis.CycleDetectedException"/> class.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.CycleDetectedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.Graphing.Analysis.CycleDetectedException"/> class.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Echo.Graphing.Analysis.CycleDetectedException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Echo.Graphing.Analysis.CycleDetectedException"/> class.
            </summary>
            <param name="message">The error message.</param>
            <param name="innerException">The inner exception that was the cause of this exception.</param>
        </member>
        <member name="T:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1">
            <summary>
            Provides a mechanism for sorting nodes in a graph, such that for every edge from node A to node B in the graph we
            have that node A comes before node B in the final ordering, also known as a topological sorting of the graph.
            </summary>
            <typeparam name="TNode">The type of nodes to sort.</typeparam>
        </member>
        <member name="T:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1.ChildrenLister">
            <summary>
            Represents the method that obtains an ordered list of children of a node in a graph. 
            </summary>
            <param name="node">The node to list the children for.</param>
        </member>
        <member name="M:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1.#ctor(Echo.Graphing.Analysis.Sorting.TopologicalSorter{`0}.ChildrenLister)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1"/> class.
            </summary>
            <param name="childrenLister">The method to call when obtaining an ordered list of children of a node.</param>
        </member>
        <member name="M:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1.#ctor(Echo.Graphing.Analysis.Sorting.TopologicalSorter{`0}.ChildrenLister,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1"/> class.
            </summary>
            <param name="childrenLister">The method to call when obtaining an ordered list of children of a node.</param>
            <param name="ignoreCycles">Determines whether the algorithm should ignore any back-edges.</param>
        </member>
        <member name="P:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1.TopologicalChildrenLister">
            <summary>
            Gets the method to call when obtaining an ordered list of children of a node.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1.IgnoreCycles">
            <summary>
            Gets or sets a value indicating whether the algorithm should ignore any back-edges.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1.GetTopologicalSorting(`0)">
            <summary>
            Obtains the topological sorting of a graph, using the provided node as the root.
            </summary>
            <param name="root">The root of the graph.</param>
            <returns>An ordered list of nodes, such that any node A appears before any other node B if the edge A to B
            exists in the graph.</returns>
            <exception cref="T:Echo.Graphing.Analysis.CycleDetectedException">Occurs when there was a cycle detected in the graph, and
            <see cref="P:Echo.Graphing.Analysis.Sorting.TopologicalSorter`1.IgnoreCycles"/> is set to <c>false</c>.</exception>
        </member>
        <member name="T:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal">
            <summary>
            Represents a depth-first node traversal of a graph.
            </summary>
        </member>
        <member name="E:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal.NodeDiscovered">
            <inheritdoc />
        </member>
        <member name="E:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal.TraversalCompleted">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal.#ctor">
            <summary>
            Creates a new depth first traversal.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal.#ctor(System.Boolean)">
            <summary>
            Creates a new depth first traversal.
            </summary>
            <param name="reverseTraversal">
            <c>True</c> if the traversal should traverse the graph in a reversed manner.
            That is, whether the traversal should treat each edge as if it was reversed.
            </param>
        </member>
        <member name="P:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal.ReverseTraversal">
            <summary>
            Gets a value indicating the traversal algorithm should traverse either outgoing or incoming edges. 
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal.Run(Echo.Graphing.INode)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal.OnNodeDiscovered(Echo.Graphing.Analysis.Traversal.NodeDiscoveryEventArgs)">
            <summary>
            Fires and handles the node discovered event.
            </summary>
            <param name="e">The event arguments.</param>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.DepthFirstTraversal.OnTraversalCompleted">
            <summary>
            Fires and handles the traversal completed event.
            </summary>
        </member>
        <member name="T:Echo.Graphing.Analysis.Traversal.DiscoveryEventArgs">
            <summary>
            Provides a base for a discovery event that occurs while traversing a graph.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Analysis.Traversal.DiscoveryEventArgs.ContinueExploring">
            <summary>
            Gets or sets a value indicating whether the traversal should continue exploring the current path.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Analysis.Traversal.DiscoveryEventArgs.Abort">
            <summary>
            Gets or sets a value indicating whether the traversal should be aborted or not.
            </summary>
        </member>
        <member name="T:Echo.Graphing.Analysis.Traversal.ITraversal">
            <summary>
            Provides members for traversing a graph.
            </summary>
        </member>
        <member name="E:Echo.Graphing.Analysis.Traversal.ITraversal.NodeDiscovered">
            <summary>
            Fires when a node is about to be traversed by the traversal.
            </summary>
        </member>
        <member name="E:Echo.Graphing.Analysis.Traversal.ITraversal.TraversalCompleted">
            <summary>
            Fires when the traversal is completed.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.ITraversal.Run(Echo.Graphing.INode)">
            <summary>
            Performs the traversal algorithm.
            </summary>
            <param name="entrypoint">The starting node.</param>
        </member>
        <member name="T:Echo.Graphing.Analysis.Traversal.NodeDiscoveryEventArgs">
            <summary>
            Provides information about a node discovery during a traversal of a graph.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.NodeDiscoveryEventArgs.#ctor(Echo.Graphing.INode,Echo.Graphing.IEdge)">
            <summary>
            Creates a new node discovery event.
            </summary>
            <param name="newNode">The node that was discovered.</param>
            <param name="origin">The edge that was traversed to discover the node.</param>
        </member>
        <member name="P:Echo.Graphing.Analysis.Traversal.NodeDiscoveryEventArgs.NewNode">
            <summary>
            Gets the node that was discovered.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Analysis.Traversal.NodeDiscoveryEventArgs.Origin">
            <summary>
            Gets the edge that was traversed that resulted in the node to be discovered.
            </summary>
        </member>
        <member name="T:Echo.Graphing.Analysis.Traversal.ParentRecorder">
            <summary>
            Provides a mechanism to record all parent nodes during a traversal.
            </summary>
            <remarks>
            A node is a parent of another node if it is the parent in the search tree. 
            </remarks>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.ParentRecorder.#ctor(Echo.Graphing.Analysis.Traversal.ITraversal)">
            <summary>
            Creates a new parent recorder.
            </summary>
            <param name="traversal">The traversal to hook into.</param>
            <exception cref="T:System.ArgumentNullException">Occurs when the provided traversal is <c>null</c>.</exception>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.ParentRecorder.GetParentEdge(Echo.Graphing.INode)">
            <summary>
            Gets the edge that was traversed when discovering the provided node.
            </summary>
            <param name="node">The node to get the edge to its parent from.</param>
            <returns>The edge originating from the parent node, or <c>null</c> if the node was the first node to be discovered.</returns>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.ParentRecorder.GetParent(Echo.Graphing.INode)">
            <summary>
            Gets the parent of the provided node in the search tree that was recorded.
            </summary>
            <param name="node">The node to get the parent node from.</param>
            <returns>The parent node in the search tree, or <c>null</c> if the node was the first node to be discovered.</returns>
        </member>
        <member name="T:Echo.Graphing.Analysis.Traversal.PostOrderRecorder">
            <summary>
            Provides a mechanism for recording a post traversal order.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.PostOrderRecorder.#ctor(Echo.Graphing.Analysis.Traversal.ITraversal)">
            <summary>
            Creates a new post traversal order and hooks into the provided traversal object.
            </summary>
            <param name="traversal">The traversal object to hook into.</param>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.PostOrderRecorder.GetOrder">
            <summary>
            Gets the final post-order of nodes that was recorded.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Echo.Graphing.Analysis.Traversal.TraversalOrderRecorder">
            <summary>
            Provides a mechanism to record the order in which each node in the graph was traversed by a traversal algorithm.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.TraversalOrderRecorder.#ctor(Echo.Graphing.Analysis.Traversal.ITraversal)">
            <summary>
            Creates a new traversal order recorder and hooks into the provided traversal object.
            </summary>
            <param name="traversal">The traversal object to hook into.</param>
        </member>
        <member name="P:Echo.Graphing.Analysis.Traversal.TraversalOrderRecorder.TraversedNodes">
            <summary>
            Gets a collection of all the nodes that were discovered during the traversal.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.TraversalOrderRecorder.GetIndex(Echo.Graphing.INode)">
            <summary>
            Gets the index of the node during the traversal. 
            </summary>
            <param name="node">The node to get the index from.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:Echo.Graphing.Analysis.Traversal.TraversalOrderRecorder.GetTraversal">
            <summary>
            Gets the full traversal as an ordered list of nodes.
            </summary>
            <returns>The traversal.</returns>
        </member>
        <member name="T:Echo.Graphing.Edge">
            <summary>
            Provides a basic implementation of an edge in a graph.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Edge.#ctor(Echo.Graphing.INode,Echo.Graphing.INode)">
            <summary>
            Creates a new edge in a graph.
            </summary>
            <param name="origin">The node that this edge starts at in the directed graph.</param>
            <param name="target">The node that this edge points to in the directed graph.</param>
        </member>
        <member name="P:Echo.Graphing.Edge.Origin">
            <inheritdoc />
        </member>
        <member name="P:Echo.Graphing.Edge.Target">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.Edge.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.Graphing.IEdge">
            <summary>
            Represents a single edge that connects two nodes together in a directed graph.
            </summary>
        </member>
        <member name="P:Echo.Graphing.IEdge.Origin">
            <summary>
            Gets the node that this edge starts at in the directed graph.
            </summary>
        </member>
        <member name="P:Echo.Graphing.IEdge.Target">
            <summary>
            Gets the node that this edge points to in the directed graph.
            </summary>
        </member>
        <member name="T:Echo.Graphing.GraphExtensions">
            <summary>
            Provides utility methods that further extend the graph model classes.
            </summary>
        </member>
        <member name="M:Echo.Graphing.GraphExtensions.GetOtherNode(Echo.Graphing.IEdge,Echo.Graphing.INode)">
            <summary>
            Given an edge and one of the nodes that this edge connects with, gets the other end of the edge.
            </summary>
            <param name="edge">The edge.</param>
            <param name="node">One of the nodes of the edge.</param>
            <returns>The other end of the edge.</returns>
        </member>
        <member name="T:Echo.Graphing.IGraph">
            <summary>
            Provides members to model a directed graph-like structure.
            </summary>
        </member>
        <member name="M:Echo.Graphing.IGraph.GetEdges">
            <summary>
            Gets a collection of all directed edges (or arcs) that connect nodes in the directed graph.
            </summary>
            <returns>The edges.</returns>
        </member>
        <member name="T:Echo.Graphing.IIdentifiedNode">
            <summary>
            Represents a node that is tagged with an identification number.
            </summary>
        </member>
        <member name="P:Echo.Graphing.IIdentifiedNode.Id">
            <summary>
            Gets the unique identifier of the node.
            </summary>
        </member>
        <member name="T:Echo.Graphing.INode">
            <summary>
            Represents a single node in a generic directed graph.
            </summary>
        </member>
        <member name="P:Echo.Graphing.INode.InDegree">
            <summary>
            Gets a value indicating the number of incoming edges that this node is incident to.
            </summary>
        </member>
        <member name="P:Echo.Graphing.INode.OutDegree">
            <summary>
            Gets a value indicating the number of outgoing edges that this node is incident to.
            </summary>
        </member>
        <member name="M:Echo.Graphing.INode.GetIncomingEdges">
            <summary>
            Gets a collection of all edges that target this node.
            </summary>
            <returns>The incoming edges.</returns>
        </member>
        <member name="M:Echo.Graphing.INode.GetOutgoingEdges">
            <summary>
            Gets a collection of all outgoing edges originating from this node.
            </summary>
            <returns>The outgoing edges.</returns>
        </member>
        <member name="M:Echo.Graphing.INode.GetPredecessors">
            <summary>
            Gets a collection of nodes that precede this node.
            </summary>
            <returns>The predecessor nodes.</returns>
        </member>
        <member name="M:Echo.Graphing.INode.GetSuccessors">
            <summary>
            Gets a collection of nodes that can be reached from this node by following one of the incident edges.
            </summary>
            <returns>The successor nodes.</returns>
        </member>
        <member name="M:Echo.Graphing.INode.HasPredecessor(Echo.Graphing.INode)">
            <summary>
            Determines whether the provided node precedes the current node. 
            </summary>
            <param name="node">The node to check.</param>
            <returns><c>True</c> if the node is a predecessor, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Graphing.INode.HasSuccessor(Echo.Graphing.INode)">
            <summary>
            Determines whether the provided node can be reached from this node by following one of the incident edges.
            </summary>
            <param name="node">The node to check.</param>
            <returns><c>True</c> if the node is a successor, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Echo.Graphing.ISubGraph">
            <summary>
            Represents a region of a graph, comprising of a subset of nodes of the full graph.
            </summary>
        </member>
        <member name="M:Echo.Graphing.ISubGraph.GetNodes">
            <summary>
            Gets a collection of nodes that this segment contains.
            </summary>
            <returns>The nodes.</returns>
        </member>
        <member name="M:Echo.Graphing.ISubGraph.GetSubGraphs">
            <summary>
            Gets a collection of sub graphs that this segment contains (if any).
            </summary>
            <returns>The sub graphs.</returns>
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.DotEntityStyle">
            <summary>
            Defines a tuple of style properties for an entity in a control flow graph. 
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotEntityStyle.#ctor(System.String,System.String)">
            <summary>
            Creates a new style for an entity.
            </summary>
            <param name="color">The color of the entity.</param>
            <param name="style">The line drawing style of the entity.</param>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotEntityStyle.Color">
            <summary>
            Gets the color of the entity.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotEntityStyle.Style">
            <summary>
            Gets the line drawing style of the entity.
            </summary>
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.DotWriter">
            <summary>
            Provides a mechanism for writing graphs to a character stream using the dot file format.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.#ctor(System.IO.TextWriter)">
            <summary>
            Creates a new dot writer. 
            </summary>
            <param name="writer">The writer responsible for writing the output.</param>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotWriter.Writer">
            <summary>
            Gets the writer that is used to write textual data to the output stream.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotWriter.SeparateNodesAndEdges">
            <summary>
            Gets or sets a value indicating whether nodes in the output file should be explicitly defined before the
            edges are defined.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotWriter.IncludeSemicolons">
            <summary>
            Gets or sets a value indicating whether statements in the output file should be separated by semicolons.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotWriter.NodeIdentifier">
            <summary>
            Gets or sets the object responsible for assigning unique identifiers to nodes in a graph.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotWriter.NodeAdorner">
            <summary>
            Gets or sets the adorner to use for adorning the nodes in the final output.
            </summary>
            <remarks>
            When this property is set to <c>null</c>, no adornments will be added.
            </remarks>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotWriter.EdgeAdorner">
            <summary>
            Gets or sets the adorner to use for adorning the edges in the final output.
            </summary>
            <remarks>
            When this property is set to <c>null</c>, no adornments will be added.
            </remarks>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.DotWriter.SubGraphAdorner">
            <summary>
            Gets or sets the adorner to use for adorning the sub graphs in the final output.
            </summary>
            <remarks>
            When this property is set to <c>null</c>, no adornments will be added.
            </remarks>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.Write(Echo.Graphing.IGraph)">
            <summary>
            Writes a graph to the character stream.
            </summary>
            <param name="graph">The graph to write.</param>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.WriteHeader(System.String,System.String)">
            <summary>
            Appends the header of a new graph to the output stream.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.WriteFooter">
            <summary>
            Appends the footer of a graph to the output stream.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.WriteNode(Echo.Graphing.INode)">
            <summary>
            Appends a single node definition to the output stream.
            </summary>
            <param name="node">The node to append.</param>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.WriteEdge(Echo.Graphing.IEdge)">
            <summary>
            Appends an edge to the output stream.
            </summary>
            <param name="edge">The edge to append.</param>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.WriteIdentifier(System.String)">
            <summary>
            Appends a single identifier to the output stream.
            </summary>
            <param name="text">The identifier to write.</param>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.WriteSemicolon">
            <summary>
            Appends a semicolon to the output stream, depending on the value of <see cref="P:Echo.Graphing.Serialization.Dot.DotWriter.IncludeSemicolons"/>.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.NeedsEscaping(System.String)">
            <summary>
            Determines whether an identifier requires escaping.
            </summary>
            <param name="text">The identifier to test.</param>
            <returns><c>True</c> if the identifier needs escaping, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.DotWriter.WriteEscapedCharacter(System.Char)">
            <summary>
            Appends a single character to the output stream, and escapes it when necessary.
            </summary>
            <param name="c">The character to write.</param>
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.HashCodeNodeIdentifier">
            <summary>
            Provides an implementation of the <see cref="T:Echo.Graphing.Serialization.Dot.INodeIdentifier"/> interface, that returns the hash code of the
            node object as unique identifiers.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.HashCodeNodeIdentifier.Instance">
            <summary>
            Provides a default instance of the <see cref="T:Echo.Graphing.Serialization.Dot.HashCodeNodeIdentifier"/> class. 
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.HashCodeNodeIdentifier.GetIdentifier(Echo.Graphing.INode)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.HexLabelNodeAdorner">
            <summary>
            Represents a node adorner that adds a label to a node containing the hexadecimal representation of the
            <see cref="P:Echo.Graphing.IIdentifiedNode.Id"/> property.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.HexLabelNodeAdorner.Prefix">
            <summary>
            Gets or sets the string to prepend to the identifier of the node.  
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.HexLabelNodeAdorner.Suffix">
            <summary>
            Gets or sets the string to append to the identifier of the node.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.HexLabelNodeAdorner.PaddingZeroes">
            <summary>
            Gets or sets the minimal number of digits to use in the label.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.HexLabelNodeAdorner.GetNodeAttributes(Echo.Graphing.INode,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.IdentifiedNodeIdentifier">
            <summary>
            Provides an implementation of the <see cref="T:Echo.Graphing.Serialization.Dot.INodeIdentifier"/> interface, that returns the value of
            <see cref="P:Echo.Graphing.IIdentifiedNode.Id"/>.
            </summary>
        </member>
        <member name="P:Echo.Graphing.Serialization.Dot.IdentifiedNodeIdentifier.Instance">
            <summary>
            Provides a default instance of the <see cref="T:Echo.Graphing.Serialization.Dot.IdentifiedNodeIdentifier"/> class. 
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.IdentifiedNodeIdentifier.GetIdentifier(Echo.Graphing.INode)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.IDotEdgeAdorner">
            <summary>
            Provides members for adorning an edge in a graph.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.IDotEdgeAdorner.GetEdgeAttributes(Echo.Graphing.IEdge,System.Int64,System.Int64)">
            <summary>
            Obtains the adornments that should be added to the edge. 
            </summary>
            <param name="edge">The edge to adorn.</param>
            <param name="sourceId">The identifier assigned to the source node.</param>
            <param name="targetId">The identifier assigned to the target node.</param>
            <returns>The adornments.</returns>
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.IDotNodeAdorner">
            <summary>
            Provides members for adorning a node in a graph.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.IDotNodeAdorner.GetNodeAttributes(Echo.Graphing.INode,System.Int64)">
            <summary>
            Obtains the adornments that should be added to the node. 
            </summary>
            <param name="node">The node to adorn.</param>
            <param name="id">The identifier assigned to the node.</param>
            <returns>The adornments.</returns>
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.IDotSubGraphAdorner">
            <summary>
            Provides members for adorning a sub graph.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.IDotSubGraphAdorner.GetSubGraphName(Echo.Graphing.ISubGraph)">
            <summary>
            Determines the name of the provided sub graph.
            </summary>
            <param name="subGraph">The sub graph.</param>
            <returns></returns>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.IDotSubGraphAdorner.GetSubGraphAttributes(Echo.Graphing.ISubGraph)">
            <summary>
            Obtains the adornments that should be added to the sub graph. 
            </summary>
            <param name="subGraph">The sub graph to adorn.</param>
            <returns>The adornments.</returns>
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.IncrementingNodeIdentifier">
            <summary>
            Provides an implementation of the <see cref="T:Echo.Graphing.Serialization.Dot.INodeIdentifier"/> interface, that maintains a counter
            that is increased every time a new node is assigned an identifier.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.IncrementingNodeIdentifier.GetIdentifier(Echo.Graphing.INode)">
            <inheritdoc />
        </member>
        <member name="T:Echo.Graphing.Serialization.Dot.INodeIdentifier">
            <summary>
            Provides members for obtaining unique identifiers to a node.
            </summary>
        </member>
        <member name="M:Echo.Graphing.Serialization.Dot.INodeIdentifier.GetIdentifier(Echo.Graphing.INode)">
            <summary>
            Gets the identifier assigned to the node.
            </summary>
            <param name="node">The node.</param>
            <returns>The identifier.</returns>
        </member>
        <member name="T:Echo.Graphing.TreeNodeBase">
            <summary>
            Provides a base contract for nodes that will be used in a tree.
            </summary>
        </member>
        <member name="P:Echo.Graphing.TreeNodeBase.Parent">
            <summary>
            The parent of this <see cref="T:Echo.Graphing.TreeNodeBase"/>
            </summary>
        </member>
        <member name="P:Echo.Graphing.TreeNodeBase.InDegree">
            <inheritdoc />
        </member>
        <member name="P:Echo.Graphing.TreeNodeBase.OutDegree">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.GetChildren">
            <summary>
            Gets the children of the current <see cref="T:Echo.Graphing.TreeNodeBase"/>.
            </summary>
            <returns>The children.</returns>
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.GetIncomingEdges">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.GetOutgoingEdges">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.GetPredecessors">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.GetSuccessors">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.HasPredecessor(Echo.Graphing.INode)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.HasSuccessor(Echo.Graphing.INode)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.UpdateChildNotNull``1(``0@,``0)">
            <summary>
            Updates the value and the parent of the <paramref name="child"/> node, ensuring that the new value is not
            <c>null</c>.
            </summary>
            <param name="child">The child element to update.</param>
            <param name="value">The new value to assign to the <paramref name="child"/>.</param>
            <exception cref="T:System.ArgumentNullException">When the new node is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">When the node already has a parent.</exception>
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.UpdateChild``1(``0@,``0)">
            <summary>
            Updates the value and the parent of the <paramref name="child"/> node.
            </summary>
            <param name="child">The child element to update.</param>
            <param name="value">The new value to assign to the <paramref name="child"/>.</param>
            <exception cref="T:System.InvalidOperationException">When the node already has a parent.</exception>
        </member>
        <member name="M:Echo.Graphing.TreeNodeBase.OnParentChanged(Echo.Graphing.TreeNodeBase)">
            <summary>
            Called when the parent of the tree node changes.
            </summary>
            <param name="old">The original tree node parent.</param>
        </member>
        <member name="T:Echo.Graphing.TreeNodeCollection`2">
            <summary>
            Represents a collection of tree node children
            </summary>
            <typeparam name="TParent">The type of the parent</typeparam>
            <typeparam name="TChild">The node to create a collection of</typeparam>
        </member>
        <member name="M:Echo.Graphing.TreeNodeCollection`2.#ctor(`0)">
            <summary>
            Creates a new tree node collection with the specified <paramref name="owner"/>
            </summary>
            <param name="owner">The owner whose children this collection represents</param>
        </member>
        <member name="M:Echo.Graphing.TreeNodeCollection`2.AssertNoParent(`1)">
            <summary>
            Asserts that the provided node is not already added to another tree node.
            </summary>
            <param name="node">The node to verify.</param>
            <exception cref="T:System.ArgumentException">Occurs if the node is already added to another node.</exception>
        </member>
        <member name="M:Echo.Graphing.TreeNodeCollection`2.SetItem(System.Int32,`1)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeCollection`2.ClearItems">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeCollection`2.RemoveItem(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Graphing.TreeNodeCollection`2.InsertItem(System.Int32,`1)">
            <inheritdoc />
        </member>
        <member name="T:Echo.IndexableStack`1">
            <summary>
            Provides an implementation of a stack of which the elements can be accessed by index.
            </summary>
            <typeparam name="T">The type of elements in the stack.</typeparam>
        </member>
        <member name="P:Echo.IndexableStack`1.Count">
            <inheritdoc />
        </member>
        <member name="P:Echo.IndexableStack`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Echo.IndexableStack`1.Peek">
            <summary>
            Returns the top element of the stack.
            </summary>
            <returns>The top element.</returns>
        </member>
        <member name="M:Echo.IndexableStack`1.Peek(System.Int32)">
            <summary>
            Returns the n-th top-most element of the stack.
            </summary>
            <returns>The element.</returns>
        </member>
        <member name="M:Echo.IndexableStack`1.Pop">
            <summary>
            Pops a single element from the stack.
            </summary>
            <returns>The popped element.</returns>
        </member>
        <member name="M:Echo.IndexableStack`1.Push(`0)">
            <summary>
            Pushes a single element onto the stack.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Echo.IndexableStack`1.Clear">
            <summary>
            Removes all elements from the stack.
            </summary>
        </member>
        <member name="M:Echo.IndexableStack`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Echo.Memory.BasicMemorySpace">
            <summary>
            Provides a basic implementation of a <see cref="T:Echo.Memory.IMemorySpace"/>, where memory is one continuous block of data
            that is fully accessible.
            </summary>
        </member>
        <member name="M:Echo.Memory.BasicMemorySpace.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new memory space.
            </summary>
            <param name="size">The number of bytes to store in the space.</param>
            <param name="initialize">Indicates whether the space should be initialized with zeroes.</param>
        </member>
        <member name="M:Echo.Memory.BasicMemorySpace.#ctor(System.Byte[])">
            <summary>
            Wraps a byte array into a memory space.
            </summary>
            <param name="backBuffer">The data of the memory space.</param>
        </member>
        <member name="M:Echo.Memory.BasicMemorySpace.#ctor(Echo.Memory.BitVector)">
            <summary>
            Wraps a bit vector into a memory space.
            </summary>
            <param name="backBuffer">The data of the memory space.</param>
        </member>
        <member name="P:Echo.Memory.BasicMemorySpace.BackBuffer">
            <summary>
            Gets the back buffer behind the memory space that stores the raw data.
            </summary>
        </member>
        <member name="P:Echo.Memory.BasicMemorySpace.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.BasicMemorySpace.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.BasicMemorySpace.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.BasicMemorySpace.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.BasicMemorySpace.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.BasicMemorySpace.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Memory.BitVector">
            <summary>
            Represents an array of bits for which the concrete may be known or unknown, and can be reinterpreted as
            different value types, and operated on using the different semantics of these types.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new bit vector of the provided size.
            </summary>
            <param name="count">The number of bits in the vector.</param>
            <param name="initialize">Indicates the bitvector should be initialized with zeroes.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Occurs when <paramref name="count"/> is not a multiple of 8.
            </exception>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Byte[])">
            <summary>
            Wraps a byte array into a fully known bit vector.
            </summary>
            <param name="bits">The raw bits to wrap.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Wraps a pair of byte arrays into a partially known bit vector.
            </summary>
            <param name="bits">The raw bits to wrap.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(Echo.Memory.BitVectorSpan)">
            <summary>
            Copies a span into a new bit vector.
            </summary>
            <param name="span">The span to copy.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.SByte)">
            <summary>
            Creates a new fully known 8-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.SByte,System.Byte)">
            <summary>
            Creates a new partially known 8-wide bit vector. 
            </summary>
            <param name="bits">The bits.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Byte)">
            <summary>
            Creates a new fully known 8-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Byte,System.Byte)">
            <summary>
            Creates a new partially known 8-wide bit vector. 
            </summary>
            <param name="bits">The bits.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Int16)">
            <summary>
            Creates a new fully known 16-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Int16,System.UInt16)">
            <summary>
            Creates a new partially known 16-wide bit vector. 
            </summary>
            <param name="bits">The bits.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.UInt16)">
            <summary>
            Creates a new fully known 16-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.UInt16,System.UInt16)">
            <summary>
            Creates a new partially known 16-wide bit vector. 
            </summary>
            <param name="bits">The bits.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Int32)">
            <summary>
            Creates a new fully known 32-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Int32,System.UInt32)">
            <summary>
            Creates a new partially known 32-wide bit vector. 
            </summary>
            <param name="bits">The bits.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.UInt32)">
            <summary>
            Creates a new fully known 32-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates a new partially known 32-wide bit vector. 
            </summary>
            <param name="bits">The bits.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Int64)">
            <summary>
            Creates a new fully known 64-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Int64,System.UInt64)">
            <summary>
            Creates a new partially known 64-wide bit vector. 
            </summary>
            <param name="bits">The bits.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.UInt64)">
            <summary>
            Creates a new fully known 64-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Creates a new partially known 64-wide bit vector. 
            </summary>
            <param name="bits">The bits.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Single)">
            <summary>
            Creates a new fully known 32-wide bit vector based on a floating point number. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.#ctor(System.Double)">
            <summary>
            Creates a new fully known 64-wide bit vector based on a floating point number. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="P:Echo.Memory.BitVector.Bits">
            <summary>
            Gets the raw bits stored in this bit vector.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVector.KnownMask">
            <summary>
            Gets a bit mask indicating which bits in <see cref="P:Echo.Memory.BitVector.Bits"/> are known.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVector.Count">
            <summary>
            Gets the number of bits stored in the bit vector.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVector.ByteCount">
            <summary>
            Gets the number of bytes stored in the bit vector.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVector.IsFullyKnown">
            <summary>
            Gets a value indicating whether all bits in the vector are known. 
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVector.AsSpan">
            <summary>
            Creates a new span of the entire bit vector.
            </summary>
            <returns>The constructed span.</returns>
        </member>
        <member name="M:Echo.Memory.BitVector.AsSpan(System.Int32)">
            <summary>
            Creates a new span of a portion of the bit vector that starts at a provided bit index. 
            </summary>
            <param name="bitIndex">The index to start the span at.</param>
            <returns>The constructed span.</returns>
        </member>
        <member name="M:Echo.Memory.BitVector.AsSpan(System.Int32,System.Int32)">
            <summary>
            Creates a new span of a portion of the bit vector that starts at a provided bit index and has a provided length.
            </summary>
            <param name="bitIndex">The index to start the span at.</param>
            <param name="length">The number of bits in the slice.</param>
            <returns>The constructed span.</returns>
        </member>
        <member name="M:Echo.Memory.BitVector.ParseBinary(System.String)">
            <summary>
            Parses a binary string, where the least significant bit is at the end of the string, into a bit vector.
            </summary>
            <param name="binaryString">The binary string to parse. This string may contain unknown bits (<c>?</c>).</param>
            <returns>The parsed bit vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVector.Clone">
            <summary>
            Deep copies the bit vector.
            </summary>
            <returns>The copied bit vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVector.Clone(Echo.Memory.BitVectorPool)">
            <summary>
            Deep copies the bit vector.
            </summary>
            <param name="pool">The pool to rent the cloned bitvector from.</param>
            <returns>The copied bit vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVector.Resize(System.Int32,System.Boolean)">
            <summary>
            Allocates a new bit vector that contains the same data, but is extended or truncated to a new size.
            </summary>
            <param name="newSize">The new size.</param>
            <param name="signExtend">When <paramref name="newSize"/> is larger than the original size, a value
            indicating whether the vector should be sign extended or not.</param>
            <returns>The new vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVector.Resize(System.Int32,System.Boolean,Echo.Memory.BitVectorPool)">
            <summary>
            Rents a bit vector from a pool that contains the same data, but is extended or truncated to a new size.
            </summary>
            <param name="newSize">The new size.</param>
            <param name="signExtend">When <paramref name="newSize"/> is larger than the original size, a value
            indicating whether the vector should be sign extended or not.</param>
            <param name="pool">The pool to rent the new vector from.</param>
            <returns>The new vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVector.ToString">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.SByte)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 8-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.Byte)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 8-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.Int16)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 16-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.UInt16)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 16-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.Int32)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 32-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.UInt32)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 32-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.Int64)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 64-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.UInt64)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 64-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.Single)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 32-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="M:Echo.Memory.BitVector.op_Implicit(System.Double)~Echo.Memory.BitVector">
            <summary>
            Creates a new fully known 64-wide bit vector. 
            </summary>
            <param name="value">The bits.</param>
        </member>
        <member name="T:Echo.Memory.BitVectorPool">
            <summary>
            Provides a mechanism for reusing instances of <see cref="T:Echo.Memory.BitVector"/>.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorPool.Rent(System.Int32,System.Boolean)">
            <summary>
            Rents a single bit vector of the provided size.
            </summary>
            <param name="size">The number of bits in the vector to rent.</param>
            <param name="initialize">A value indicating whether the bits should be cleared out or marked unknown.</param>
            <returns>The bit vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorPool.RentNativeInteger(System.Boolean,System.Boolean)">
            <summary>
            Rents a native integer bit vector.
            </summary>
            <param name="is32Bit">A value indicating the vector should be 32 or 64 bits long.</param>
            <param name="initialize">A value indicating whether the bits should be cleared out or marked unknown.</param>
            <returns>The bit vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorPool.Return(Echo.Memory.BitVector)">
            <summary>
            Returns the bit vector to the pool.
            </summary>
            <param name="vector">The vector.</param>
            <returns><c>true</c> if the bitvector was an instance of the pool, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Echo.Memory.BitVectorSpan">
            <summary>
            Represents a slice of an array of bits for which the concrete may be known or unknown, and can be
            reinterpreted as different value types, and operated on using the different semantics of these types.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Not">
            <summary>
            Inverts all the bits in the vector.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.And(Echo.Memory.BitVectorSpan)">
            <summary>
            Performs a bitwise AND operation with another bit vector.
            </summary>
            <param name="other">The other bit vector.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Or(Echo.Memory.BitVectorSpan)">
            <summary>
            Performs a bitwise OR operation with another bit vector.
            </summary>
            <param name="other">The other bit vector.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Xor(Echo.Memory.BitVectorSpan)">
            <summary>
            Performs a bitwise XOR operation with another bit vector.
            </summary>
            <param name="other">The other bit vector.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.ShiftLeft(System.Int32)">
            <summary>
            Shift all bits in the vector to the left, filling the least significant bits with zeroes.
            </summary>
            <param name="count">The number of bits to shift with.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.ShiftRight(System.Int32,System.Boolean)">
            <summary>
            Shift all bits in the vector to the right, and either sign- or zero-extends the value.
            </summary>
            <param name="count">The number of bits to shift with.</param>
            <param name="signExtend">Gets a value indicating whether the bits should be sign- or zero-extended.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.#ctor(Echo.Memory.BitVector)">
            <summary>
            Creates a new span around an existing bitvector.
            </summary>
            <param name="vector">The vector to span.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.#ctor(System.Span{System.Byte},System.Span{System.Byte})">
            <summary>
            Creates a new span around a pair of bits and a known bit mask.
            </summary>
            <param name="bits">The concrete bits stored in the bit vector.</param>
            <param name="knownMask">The bitmask indicating which bits in <paramref name="bits"/> are known.</param>
            <exception cref="T:System.ArgumentException">
            Occurs when the length of <paramref name="bits"/> and <paramref name="knownMask"/> do not match up.
            </exception>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.Item(System.Int32)">
            <summary>
            Gets or sets a single bit in the bit vector span.
            </summary>
            <param name="index">The index of the bit to get.</param>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.Bits">
            <summary>
            Gets the raw bits stored in this bit vector span.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.KnownMask">
            <summary>
            Gets a bit mask indicating which bits in <see cref="P:Echo.Memory.BitVectorSpan.Bits"/> are known.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.Count">
            <summary>
            Gets the number of bits stored in the bit vector.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.ByteCount">
            <summary>
            Gets the number of bytes stored in the bit vector.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.IsFullyKnown">
            <summary>
            Gets a value indicating whether all bits in the vector are known. 
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.IsZero">
            <summary>
            Gets a value indicating whether all bits in the vector are set to zero.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Slice(System.Int32)">
            <summary>
            Forms a slice of a bit vector that starts at a provided bit index.
            </summary>
            <param name="bitIndex">The bit index to start the slice at.</param>
            <returns>The constructed slice.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Occurs when the bit index is not a multiple of 8.</exception>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Slice(System.Int32,System.Int32)">
            <summary>
            Forms a slice of a bit vector that starts at a provided bit index and has a provided length.
            </summary>
            <param name="bitIndex">The bit index to start the slice at.</param>
            <param name="length">The number of bits in the slice.</param>
            <returns>The constructed slice.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Occurs when the bit index is not a multiple of 8.</exception>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.CopyTo(Echo.Memory.BitVectorSpan)">
            <summary>
            Copies all bits and known bit mask to the provided bit vector. 
            </summary>
            <param name="buffer">The bit buffer to copy the bits to.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Clear">
            <summary>
            Clears the bit vector with zeroes.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.MarkFullyKnown">
            <summary>
            Marks the entire bit vector fully known, treating all bits in <see cref="P:Echo.Memory.BitVectorSpan.Bits"/> as actual data.
            </summary>
            <remarks>
            This is effectively setting all bits in <see cref="P:Echo.Memory.BitVectorSpan.KnownMask"/>.
            </remarks>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.MarkFullyUnknown">
            <summary>
            Marks the entire bit vector fully unknown.
            </summary>
            <remarks>
            This is effectively clearing all bits in <see cref="P:Echo.Memory.BitVectorSpan.KnownMask"/>. It does not change the value of <see cref="P:Echo.Memory.BitVectorSpan.Bits"/>.
            </remarks>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.ReadNativeInteger(System.Boolean)">
            <summary>
            Reads a native integer from the vector.
            </summary>
            <param name="is32Bit">A value indicating whether the native integer is 32 or 64 bits wide.</param>
            <returns>The read integer.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes fully known bytes into the bit vector. 
            </summary>
            <param name="data">The data to write.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes data into the bit vector. 
            </summary>
            <param name="data">The data to write.</param>
            <param name="knownMask">The mask indicating which bits in <paramref name="data"/> are known.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Occurs when the length of <paramref name="data"/> and <paramref name="knownMask"/> do not match.
            </exception>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(Echo.Memory.BitVectorSpan)">
            <summary>
            Writes data into the bit vector. 
            </summary>
            <param name="data">The data to write.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Fill(System.Byte)">
            <summary>
            Fills the bit vector with the repetition of a byte.
            </summary>
            <param name="value">The value to fill the bit vector with.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Fill(System.Byte,System.Byte)">
            <summary>
            Fills the bit vector with the repetition of a partially known byte.
            </summary>
            <param name="value">The value to fill the bit vector with.</param>
            <param name="knownMask">The mask indicating which bits in <paramref name="value"/> are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.WriteBinaryString(System.String)">
            <summary>
            Writes a (partially known) bit string, where the least significant bit is at the end of the string, into
            the bit vector at the provided bit index.
            </summary>
            <param name="binaryString">The binary string to write. This string may contain unknown bits (<c>?</c>).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Occurs when the bit index is not a multiple of 8.</exception>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.ToBitString">
            <summary>
            Constructs a binary string that represents the binary number stored in the bit vector.  
            </summary>
            <returns>The binary string.</returns>
            <remarks>
            When a bit is marked as unknown, its digit is replaced with a question mark (<c>?</c>). 
            </remarks>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.ToHexString">
            <summary>
            Constructs a string that represents the raw data stored in the bit vector as a hexadecimal byte string.  
            </summary>
            <returns>The byte string.</returns>
            <remarks>
            When any bit in a nibble is marked as unknown, its digit is replaced with a question mark (<c>?</c>). 
            </remarks>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.ToVector">
            <summary>
            Copies the span into a new bit vector.
            </summary>
            <returns>The vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.ToVector(Echo.Memory.BitVectorPool)">
            <summary>
            Copies the span into a new bit vector that is rented from the provided pool.
            </summary>
            <param name="pool">The pool to rent the vector from.</param>
            <returns>The vector.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IsEqualTo(Echo.Memory.BitVectorSpan)">
            <summary>
            Determines whether the current bit vector is equal to another bit vector.
            </summary>
            <param name="other">The other bit vector.</param>
            <returns>
            <see cref="F:Echo.Trilean.True"/> if the bit vector are equal, <see cref="F:Echo.Trilean.False"/> if not, and
            <see cref="F:Echo.Trilean.Unknown"/> if the conclusion of the comparison is not certain.
            </returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Equals(Echo.Memory.BitVectorSpan)">
            <summary>
            Compares two <see cref="T:Echo.Memory.BitVectorSpan"/>'s
            </summary>
            <remarks>
            This overload exists to avoid boxing allocations.
            </remarks>
            <param name="other">The <see cref="T:Echo.Memory.BitVectorSpan"/> to compare to</param>
            <returns>Whether the two <see cref="T:Echo.Memory.BitVectorSpan"/>'s are equal</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.op_Implicit(Echo.Memory.BitVector)~Echo.Memory.BitVectorSpan">
            <summary>
            Creates a span for the provided bit vector. 
            </summary>
            <param name="vector">The vector.</param>
            <returns>The span.</returns>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.F32">
            <summary>
            Interprets the bit vector as a 32 bit floating point number, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.F64">
            <summary>
            Interprets the bit vector as a 64 bit floating point number, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Single)">
            <summary>
            Interprets the bit vector as a 32 bit floating point number, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Double)">
            <summary>
            Interprets the bit vector as a 64 bit floating point number, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.FloatNegate">
            <summary>
            Interprets the bitvector as a floating point number, and negates it.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.FloatAdd(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bitvector as a floating point number, and adds another floating point number to it.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.FloatSubtract(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bitvector as a floating point number, and subtracts another floating point number to it.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.FloatMultiply(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bitvector as a floating point number, and multiplies it with another floating point number.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.FloatDivide(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bitvector as a floating point number, and divides it with another floating point number.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.FloatRemainder(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bitvector as a floating point number, divides it with another floating point number and
            stores the remainder of the division.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.FloatIsLessThan(Echo.Memory.BitVectorSpan,System.Boolean)">
            <summary>
            interprets the bitvector as a floating point number, and determines whether it is smaller than the provided
            floating point bitvector.
            </summary>
            <param name="other">The other floating point number.</param>
            <param name="ordered">A value indicating whether the comparison should be an ordered comparison or not.</param>
            <returns>
            <see cref="F:Echo.Trilean.True"/> if the current number is less than the provided number,
            <see cref="F:Echo.Trilean.False"/> if not, and <see cref="F:Echo.Trilean.Unknown"/> if the conclusion of the comparison
            is not certain.
            </returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.FloatIsGreaterThan(Echo.Memory.BitVectorSpan,System.Boolean)">
            <summary>
            interprets the bitvector as a floating point number, and determines whether it is greater than the provided
            floating point bitvector.
            </summary>
            <param name="other">The other floating point number.</param>
            <param name="ordered">A value indicating whether the comparison should be an ordered comparison or not.</param>
            <returns>
            <see cref="F:Echo.Trilean.True"/> if the current number is greater than the provided number,
            <see cref="F:Echo.Trilean.False"/> if not, and <see cref="F:Echo.Trilean.Unknown"/> if the conclusion of the comparison
            is not certain.
            </returns>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.I8">
            <summary>
            Interprets the bit vector as a signed 8 bit integer, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.U8">
            <summary>
            Interprets the bit vector as an unsigned 8 bit integer, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.I16">
            <summary>
            Interprets the bit vector as a signed 16 bit integer, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.U16">
            <summary>
            Interprets the bit vector as an unsigned 16 bit integer, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.I32">
            <summary>
            Interprets the bit vector as a signed 32 bit integer, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.U32">
            <summary>
            Interprets the bit vector as an unsigned 32 bit integer, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.I64">
            <summary>
            Interprets the bit vector as a signed 64 bit integer, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="P:Echo.Memory.BitVectorSpan.U64">
            <summary>
            Interprets the bit vector as an unsigned 64 bit integer, and gets or sets the immediate value for it.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Byte)">
            <summary>
            Interprets the bit vector as an unsigned 8 bit integer, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Byte,System.Byte)">
            <summary>
            Interprets the bit vector as an unsigned 8 bit integer, and writes a partially known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
            <param name="knownMask">The mask indicating which bits are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.SByte)">
            <summary>
            Interprets the bit vector as a signed 8 bit integer, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.SByte,System.Byte)">
            <summary>
            Interprets the bit vector as a signed 8 bit integer, and writes a partially known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
            <param name="knownMask">The mask indicating which bits are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.UInt16)">
            <summary>
            Interprets the bit vector as an unsigned 16 bit integer, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.UInt16,System.UInt16)">
            <summary>
            Interprets the bit vector as an unsigned 16 bit integer, and writes a partially known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
            <param name="knownMask">The mask indicating which bits are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Int16)">
            <summary>
            Interprets the bit vector as a signed 16 bit integer, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Int16,System.UInt16)">
            <summary>
            Interprets the bit vector as a signed 16 bit integer, and writes a partially known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
            <param name="knownMask">The mask indicating which bits are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.UInt32)">
            <summary>
            Interprets the bit vector as an unsigned 32 bit integer, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.UInt32,System.UInt32)">
            <summary>
            Interprets the bit vector as an unsigned 32 bit integer, and writes a partially known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
            <param name="knownMask">The mask indicating which bits are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Int32)">
            <summary>
            Interprets the bit vector as a signed 32 bit integer, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Int32,System.UInt32)">
            <summary>
            Interprets the bit vector as a signed 32 bit integer, and writes a partially known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
            <param name="knownMask">The mask indicating which bits are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.UInt64)">
            <summary>
            Interprets the bit vector as an unsigned 64 bit integer, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.UInt64,System.UInt64)">
            <summary>
            Interprets the bit vector as an unsigned 64 bit integer, and writes a partially known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
            <param name="knownMask">The mask indicating which bits are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Int64)">
            <summary>
            Interprets the bit vector as a signed 64 bit integer, and writes a fully known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.Write(System.Int64,System.UInt64)">
            <summary>
            Interprets the bit vector as an signed 64 bit integer, and writes a partially known immediate value to it. 
            </summary>
            <param name="value">The value.</param>
            <param name="knownMask">The mask indicating which bits are known.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.WriteNativeInteger(System.Int64,System.Boolean)">
            <summary>
            Writes a fully known native integer into the bit vector at the provided bit index.
            </summary>
            <param name="value">The native integer to write.</param>
            <param name="is32Bit">A value indicating whether the native integer is 32 or 64 bits wide.</param>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.GetMsb">
            <summary>
            Interprets the bit vector as an integer, and obtains the most significant bit (MSB) of the bit vector.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerAdd(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bit vector as an integer and adds a second integer to it. 
            </summary>
            <param name="other">The integer to add.</param>
            <exception cref="T:System.ArgumentException">Occurs when the sizes of the integers do not match in bit length.</exception>
            <returns>The value of the carry bit after the addition completed.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerIncrement">
            <summary>
            Interprets the bit vector as an integer and increments it by one. 
            </summary>
            <returns>The value of the carry bit after the increment operation completed.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerNegate">
            <summary>
            Interprets the bit vector as an integer and negates it according to the two's complement semantics.
            </summary>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerSubtract(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bit vector as an integer and subtracts a second integer from it.
            </summary>
            <param name="other">The integer to subtract.</param>
            <exception cref="T:System.ArgumentException">Occurs when the sizes of the integers do not match in bit length.</exception>
            <returns>The value of the borrow bit after the subtraction completed.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerDecrement">
            <summary>
            Interprets the bit vector as an integer and decrements it by one. 
            </summary>
            <returns>The value of the carry bit after the decrement operation completed.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerMultiply(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bit vector as an integer and multiplies it by a second integer.
            </summary>
            <param name="other">The integer to multiply the current integer with.</param>
            <exception cref="T:System.ArgumentException">Occurs when the sizes of the integers do not match in bit length.</exception>
            <returns>A value indicating whether the result was truncated.</returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerDivide(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bit vector as an integer and divides it by a second integer.
            </summary>
            <param name="other">The integer to divide the current integer by.</param>
            <exception cref="T:System.ArgumentException">Occurs when the sizes of the integers do not match in bit length.</exception>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerRemainder(Echo.Memory.BitVectorSpan)">
            <summary>
            Interprets the bit vector as an integer, divides it by a second integer and produces the remainder.
            </summary>
            <param name="other">The integer to divide the current integer by.</param>
            <exception cref="T:System.ArgumentException">Occurs when the sizes of the integers do not match in bit length.</exception>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerIsGreaterThan(Echo.Memory.BitVectorSpan,System.Boolean)">
            <summary>
            Interprets the bit vector as an integer, and determines whether the integer is greater than another integer.
            </summary>
            <param name="other">The other integer.</param>
            <param name="signed">Indicates the integers should be interpreted as signed or unsigned integers.</param>
            <returns>
            <see cref="F:Echo.Trilean.True"/> if the current integer is greater than the provided integer,
            <see cref="F:Echo.Trilean.False"/> if not, and <see cref="F:Echo.Trilean.Unknown"/> if the conclusion of the comparison
            is not certain.
            </returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerIsGreaterThanOrEqual(Echo.Memory.BitVectorSpan,System.Boolean)">
            <summary>
            Interprets the bit vector as an integer, and determines whether the integer is greater than or equal to
            another integer.
            </summary>
            <param name="other">The other integer.</param>
            <param name="signed">Indicates the integers should be interpreted as signed or unsigned integers.</param>
            <returns>
            <see cref="F:Echo.Trilean.True"/> if the current integer is greater than or equal to the provided integer,
            <see cref="F:Echo.Trilean.False"/> if not, and <see cref="F:Echo.Trilean.Unknown"/> if the conclusion of the comparison
            is not certain.
            </returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerIsLessThan(Echo.Memory.BitVectorSpan,System.Boolean)">
            <summary>
            Interprets the bit vector as an integer, and determines whether the integer is less than another integer.
            </summary>
            <param name="other">The other integer.</param>
            <param name="signed">Indicates the integers should be interpreted as signed or unsigned integers.</param>
            <returns>
            <see cref="F:Echo.Trilean.True"/> if the current integer is less than the provided integer,
            <see cref="F:Echo.Trilean.False"/> if not, and <see cref="F:Echo.Trilean.Unknown"/> if the conclusion of the comparison
            is not certain.
            </returns>
        </member>
        <member name="M:Echo.Memory.BitVectorSpan.IntegerIsLessThanOrEqual(Echo.Memory.BitVectorSpan,System.Boolean)">
            <summary>
            Interprets the bit vector as an integer, and determines whether the integer is less than or equal to
            another integer.
            </summary>
            <param name="other">The other integer.</param>
            <param name="signed">Indicates the integers should be interpreted as signed or unsigned integers.</param>
            <returns>
            <see cref="F:Echo.Trilean.True"/> if the current integer is greater than or equal to the provided integer,
            <see cref="F:Echo.Trilean.False"/> if not, and <see cref="F:Echo.Trilean.Unknown"/> if the conclusion of the comparison
            is not certain.
            </returns>
        </member>
        <member name="T:Echo.Memory.GenericMockMemory`1">
            <summary>
            Provides a semi high-level mapping between addresses and objects that live outside of the sandbox. 
            </summary>
            <typeparam name="T">The type of objects to store.</typeparam>
            <remarks>
            Reading from this memory chunk always results in reading unknown memory.
            </remarks>
        </member>
        <member name="M:Echo.Memory.GenericMockMemory`1.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new generic mock memory chunk.
            </summary>
            <param name="size">The size in bytes of the memory.</param>
            <param name="itemSize">The size in bytes of a single element.</param>
            <param name="comparer">The equality comparer to use for comparing elements for uniqueness.</param>
        </member>
        <member name="M:Echo.Memory.GenericMockMemory`1.GetAddress(`0)">
            <summary>
            Gets the address or assigns a new address to the provided object. 
            </summary>
            <param name="item">The object.</param>
            <returns>The address.</returns>
        </member>
        <member name="M:Echo.Memory.GenericMockMemory`1.TryGetObject(System.Int64,`0@)">
            <summary>
            Attempts to get the object at the provided address.
            </summary>
            <param name="address">The address.</param>
            <param name="value">The object.</param>
            <returns><c>true</c> if the address maps to an object, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Memory.GenericMockMemory`1.GetObject(System.Int64)">
            <summary>
            Gets the object at the provided address.
            </summary>
            <param name="address">The address.</param>
            <returns>The object.</returns>
        </member>
        <member name="T:Echo.Memory.Heap.BasicHeap">
            <summary>
            Provides a basic implementation of a heap.
            </summary>
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.#ctor(System.Int32)">
            <summary>
            Creates a new empty heap.
            </summary>
            <param name="size">The maximum size of the heap.</param>
        </member>
        <member name="P:Echo.Memory.Heap.BasicHeap.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.Allocate(System.UInt32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.Free(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.GetChunkSize(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.GetChunkSpan(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.GetAllocatedChunks">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.Heap.BasicHeap.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Memory.Heap.IHeap">
            <summary>
            Provides members for allocating and freeing chunks of memory.
            </summary>
        </member>
        <member name="M:Echo.Memory.Heap.IHeap.Allocate(System.UInt32,System.Boolean)">
            <summary>
            Allocates a chunk of uninitialized memory in the heap.
            </summary>
            <param name="size">The size of the chunk in bytes.</param>
            <param name="initialize">A value indicating whether the chunk of memory should be cleared out with zeroes.</param>
            <returns>The address of the allocated chunk.</returns>
        </member>
        <member name="M:Echo.Memory.Heap.IHeap.Free(System.Int64)">
            <summary>
            Releases a chunk of memory in the heap.
            </summary>
            <param name="address">The address of the chunk to free.</param>
        </member>
        <member name="M:Echo.Memory.Heap.IHeap.GetChunkSize(System.Int64)">
            <summary>
            Gets the size of the chunk that was allocated at the provided address.
            </summary>
            <param name="address">The address of the chunk.</param>
            <returns>The size in bytes.</returns>
        </member>
        <member name="M:Echo.Memory.Heap.IHeap.GetChunkSpan(System.Int64)">
            <summary>
            Obtains a writable bit vector slice that spans the entire chunk at a provided address.
            </summary>
            <param name="address">The address of the chunk</param>
            <returns>The chunk slice.</returns>
        </member>
        <member name="M:Echo.Memory.Heap.IHeap.GetAllocatedChunks">
            <summary>
            Gets a collection of all chunk address ranges within the heap that are currently allocated. 
            </summary>
            <returns>The ranges.</returns>
        </member>
        <member name="T:Echo.Memory.IMemorySpace">
            <summary>
            Provides members for accessing and writing (partially known) memory.
            </summary>
        </member>
        <member name="P:Echo.Memory.IMemorySpace.AddressRange">
            <summary>
            Gets the range that this memory space spans.
            </summary>
        </member>
        <member name="M:Echo.Memory.IMemorySpace.IsValidAddress(System.Int64)">
            <summary>
            Gets a value indicating whether the provided address is a valid address, and can be used to read
            and/or write to.
            </summary>
            <param name="address">The address to query.</param>
            <returns><c>true</c> if the address was valid, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Memory.IMemorySpace.Rebase(System.Int64)">
            <summary>
            Relocates the memory to a new base address.
            </summary>
            <param name="baseAddress">The new base address.</param>
        </member>
        <member name="M:Echo.Memory.IMemorySpace.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <summary>
            Copies data at the provided address into the provided buffer. 
            </summary>
            <param name="address">The address to start reading at.</param>
            <param name="buffer">The buffer to write into.</param>
        </member>
        <member name="M:Echo.Memory.IMemorySpace.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <summary>
            Writes the provided buffer of data at the provided address. 
            </summary>
            <param name="address">The address to start writing at.</param>
            <param name="buffer">The data to write.</param>
        </member>
        <member name="M:Echo.Memory.IMemorySpace.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes the provided buffer of data at the provided address. 
            </summary>
            <param name="address">The address to start writing at.</param>
            <param name="buffer">The data to write.</param>
        </member>
        <member name="T:Echo.Memory.UninitializedMemorySpace">
            <summary>
            Represents a chunk of uninitialized (unknown) memory. Writing to this memory space does not change the contents.
            </summary>
        </member>
        <member name="M:Echo.Memory.UninitializedMemorySpace.#ctor(System.Int32)">
            <summary>
            Creates a new uninitialized memory space.
            </summary>
            <param name="size">The number of bytes to store in the space.</param>
        </member>
        <member name="P:Echo.Memory.UninitializedMemorySpace.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.UninitializedMemorySpace.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.UninitializedMemorySpace.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.UninitializedMemorySpace.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.UninitializedMemorySpace.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.UninitializedMemorySpace.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Memory.VirtualMemory">
            <summary>
            Represents an addressable region of memory that maps a collection of memory spaces to virtual addresses.
            </summary>
            <remarks>
            This class can be compared to the entire memory space of a running process.
            </remarks>
        </member>
        <member name="F:Echo.Memory.VirtualMemory._spaces">
            <summary>
            Memory spaces, sorted by their address range.
            </summary>
        </member>
        <member name="M:Echo.Memory.VirtualMemory.#ctor">
            <summary>
            Creates new uninitialized virtual memory.
            </summary>
        </member>
        <member name="M:Echo.Memory.VirtualMemory.#ctor(System.Int64)">
            <summary>
            Creates new uninitialized virtual memory with the provided size.
            </summary>
        </member>
        <member name="P:Echo.Memory.VirtualMemory.AddressRange">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.VirtualMemory.Map(System.Int64,Echo.Memory.IMemorySpace)">
            <summary>
            Maps a memory space at the provided virtual memory address.
            </summary>
            <param name="address">The address to map the data at.</param>
            <param name="space">The data to map.</param>
            <exception cref="T:System.ArgumentException">Occurs when the address was already in use.</exception>
        </member>
        <member name="M:Echo.Memory.VirtualMemory.Unmap(System.Int64)">
            <summary>
            Unmaps a memory space that was mapped at the provided address.
            </summary>
            <param name="address">The address of the memory space to unmap.</param>
        </member>
        <member name="M:Echo.Memory.VirtualMemory.GetMappedRanges">
            <summary>
            Gets a collection of all ranges that were mapped into this virtual memory.
            </summary>
            <returns>The address ranges within the memory.</returns>
        </member>
        <member name="M:Echo.Memory.VirtualMemory.IsValidAddress(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.VirtualMemory.Rebase(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.VirtualMemory.Read(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.VirtualMemory.Write(System.Int64,Echo.Memory.BitVectorSpan)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Memory.VirtualMemory.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="T:Echo.Trilean">
            <summary>
            Represents a ternary boolean (true, false or unknown) value. 
            </summary>
        </member>
        <member name="F:Echo.Trilean.True">
            <summary>
            Represents the true value.
            </summary>
        </member>
        <member name="F:Echo.Trilean.False">
            <summary>
            Represents the false value.
            </summary>
        </member>
        <member name="F:Echo.Trilean.Unknown">
            <summary>
            Represents the unknown value.
            </summary>
        </member>
        <member name="M:Echo.Trilean.#ctor(System.Boolean)">
            <summary>
            Creates a new trilean.
            </summary>
            <param name="value">The boolean value.</param>
        </member>
        <member name="M:Echo.Trilean.#ctor(Echo.TrileanValue)">
            <summary>
            Creates a new trilean.
            </summary>
            <param name="value">The trilean value.</param>
        </member>
        <member name="M:Echo.Trilean.#ctor(System.Nullable{System.Boolean})">
            <summary>
            Creates a new trilean.
            </summary>
            <param name="value">
            The nullable boolean value. If the value is <c>null</c>, <see cref="F:Echo.TrileanValue.Unknown"/> will be assumed.
            </param>
        </member>
        <member name="P:Echo.Trilean.Value">
            <summary>
            Gets the raw integer representation of the trilean value.
            </summary>
        </member>
        <member name="P:Echo.Trilean.IsKnown">
            <summary>
            Gets a value indicating whether the value is known (either true or false).
            </summary>
        </member>
        <member name="P:Echo.Trilean.IsUnknown">
            <summary>
            Gets a value indicating whether the value is unknown.
            </summary>
        </member>
        <member name="M:Echo.Trilean.ToBoolean">
            <summary>
            When the trilean value is known, obtains the boolean value.
            </summary>
            <returns>The boolean value.</returns>
        </member>
        <member name="M:Echo.Trilean.ToBooleanOrFalse">
            <summary>
            When the trilean value is known, obtains the boolean value, otherwise returns <c>false</c>.
            </summary>
            <returns>The boolean value.</returns>
        </member>
        <member name="M:Echo.Trilean.ToNullableBoolean">
            <summary>
            Converts the trilean to a nullable boolean, where null indicates the unknown state.
            </summary>
            <returns>The nullable boolean.</returns>
        </member>
        <member name="M:Echo.Trilean.op_Implicit(System.Boolean)~Echo.Trilean">
            <summary>
            Creates a new trilean.
            </summary>
            <param name="value">The boolean value.</param>
        </member>
        <member name="M:Echo.Trilean.op_Implicit(Echo.TrileanValue)~Echo.Trilean">
            <summary>
            Creates a new trilean.
            </summary>
            <param name="value">The trilean value.</param>
        </member>
        <member name="M:Echo.Trilean.op_Implicit(System.Nullable{System.Boolean})~Echo.Trilean">
            <summary>
            Creates a new trilean.
            </summary>
            <param name="value">The trilean value.</param>
        </member>
        <member name="M:Echo.Trilean.op_True(Echo.Trilean)">
            <summary>
            Determines whether the trilean is <c>true</c>.
            </summary>
            <param name="value">The trilean.</param>
            <returns><c>true</c> if the <see cref="P:Echo.Trilean.Value"/> property is <see cref="F:Echo.TrileanValue.True"/>, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Trilean.op_False(Echo.Trilean)">
            <summary>
            Determines whether the trilean is <c>false</c>.
            </summary>
            <param name="value">The trilean.</param>
            <returns><c>false</c> if the <see cref="P:Echo.Trilean.Value"/> property is <see cref="F:Echo.TrileanValue.False"/>, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Echo.Trilean.op_Equality(Echo.Trilean,Echo.Trilean)">
            <summary>
            Determines whether this trilean is exactly equal to the specified trilean.
            </summary>
            <param name="a">The left hand side of the comparison.</param>
            <param name="b">The right hand side of the comparison.</param>
            <returns>
            <c>true</c> if the <see cref="P:Echo.Trilean.Value"/> property of both trileans are equal, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Echo.Trilean.op_Inequality(Echo.Trilean,Echo.Trilean)">
            <summary>
            Determines whether this trilean is not equal to the specified trilean.
            </summary>
            <param name="a">The left hand side of the comparison.</param>
            <param name="b">The right hand side of the comparison.</param>
            <returns>
            <c>true</c> if the <see cref="P:Echo.Trilean.Value"/> property of both trileans are different, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Echo.Trilean.Equals(Echo.Trilean)">
            <summary>
            Determines whether this trilean is exactly equal to the specified trilean.
            </summary>
            <param name="other">The other trilean.</param>
            <returns>
            <c>true</c> if the <see cref="P:Echo.Trilean.Value"/> property of both trileans are equal, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Echo.Trilean.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Echo.Trilean.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Echo.Trilean.op_LogicalNot(Echo.Trilean)">
            <summary>
            Inverts the trilean value.
            </summary>
            <param name="value">The value to invert.</param>
            <returns>
            Returns true if the value is false, and vice versa. If unknown, the return value is also unknown.
            </returns>
        </member>
        <member name="M:Echo.Trilean.Not">
            <summary>
            Inverts the trilean value.
            </summary>
            <returns>
            Returns true if the value is false, and vice versa. If unknown, the return value is also unknown.
            </returns>
        </member>
        <member name="M:Echo.Trilean.GetLookupTableIndex(Echo.TrileanValue,Echo.TrileanValue)">
            <summary>
            Calculates the index within a binary operator lookup table.
            </summary>
            <param name="row">The row.</param>
            <param name="column">The column.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:Echo.Trilean.op_BitwiseAnd(Echo.Trilean,Echo.Trilean)">
            <summary>
            Computes the and between two trilean values.
            </summary>
            <param name="a">The left hand side of the binary operator.</param>
            <param name="b">The right hand side of the binary operator.</param>
            <returns>Returns true if both values are true. If not, returns unknown if at
            least one is true or unknown and the other is unknown, and false otherwise.</returns>
        </member>
        <member name="M:Echo.Trilean.And(Echo.Trilean)">
            <summary>
            Computes the and between two trilean values.
            </summary>
            <param name="other">The other trilean value.</param>
            <returns>Returns true if both values are true. If not, returns unknown if at
            least one is true or unknown and the other is unknown, and false otherwise.</returns>
        </member>
        <member name="M:Echo.Trilean.op_BitwiseOr(Echo.Trilean,Echo.Trilean)">
            <summary>
            Computes the inclusive or between two trilean values.
            </summary>
            <param name="a">The left hand side of the binary operator.</param>
            <param name="b">The right hand side of the binary operator.</param>
            <returns>Returns true if at least one of the values is true. If neither are true, returns unknown if at
            least one is unknown, and false otherwise.</returns>
        </member>
        <member name="M:Echo.Trilean.Or(Echo.Trilean)">
            <summary>
            Computes the inclusive or between two trilean values.
            </summary>
            <param name="other">The other trilean value.</param>
            <returns>Returns true if at least one of the values is true. If neither are true, returns unknown if at
            least one is unknown, and false otherwise.</returns>
        </member>
        <member name="M:Echo.Trilean.op_ExclusiveOr(Echo.Trilean,Echo.Trilean)">
            <summary>
            Computes the exclusive or between two trilean values.
            </summary>
            <param name="a">The left hand side of the binary operator.</param>
            <param name="b">The right hand side of the binary operator.</param>
            <returns>Returns true if the two trilean values are different. If at least one is unknown,
            the result is unknown.</returns>
        </member>
        <member name="M:Echo.Trilean.Xor(Echo.Trilean)">
            <summary>
            Computes the exclusive or between two trilean values.
            </summary>
            <param name="other">The other trilean value.</param>
            <returns>Returns true if the two trilean values are different. If at least one is unknown,
            the result is unknown.</returns>
        </member>
        <member name="M:Echo.Trilean.FromChar(System.Char)">
            <summary>
            Obtains the trilean value that is associated to the provided character.
            </summary>
            <param name="c">The character to parse.</param>
            <returns>The trilean value.</returns>
            <exception cref="T:System.FormatException">Occurs when the character is not a valid trilean digit.</exception>
        </member>
        <member name="M:Echo.Trilean.ToChar">
            <summary>
            Returns the raw value of the trilean as a single character (either '0', '1' or '?').
            </summary>
            <returns>The character.</returns>
        </member>
        <member name="M:Echo.Trilean.ToString">
            <inheritdoc />
        </member>
        <member name="T:Echo.TrileanValue">
            <summary>
            Provides members for all possible values in a ternary number system.
            </summary>
        </member>
        <member name="F:Echo.TrileanValue.False">
            <summary>
            Indicates the true value.
            </summary>
        </member>
        <member name="F:Echo.TrileanValue.True">
            <summary>
            Indicates the false value.
            </summary>
        </member>
        <member name="F:Echo.TrileanValue.Unknown">
            <summary>
            Indicates the unknown value.
            </summary>
        </member>
    </members>
</doc>



================================================
File: props/SharedPackages.props
================================================
ï»¿<Project>

  <ItemGroup>
    <PackageReference Include="AsmResolver" Version="6.0.0-beta.3" />
    <PackageReference Include="AsmResolver.DotNet" Version="6.0.0-beta.3" />
    <PackageReference Include="AsmResolver.PE" Version="6.0.0-beta.3" />
    <PackageReference Include="JetBrains.Annotations" Version="2024.3.0" />
  </ItemGroup>

</Project>


================================================
File: props/SharedProjectProps.props
================================================
<Project>

  <PropertyGroup>
    <PackageId>$(AssemblyName)</PackageId>
    <PackageRequireLicenseAcceptance>true</PackageRequireLicenseAcceptance>
    <PackageTags>BitMono Obfuscator Dotnet Unity Mono Bit AsmResolver dnlib Protector Mono-Obfuscator Dotnet-Protector</PackageTags>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageProjectUrl>https://github.com/sunnamed434/BitMono</PackageProjectUrl>
    <PackageOwners>sunnamed434</PackageOwners>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <BitMonoVersion>0.0.0</BitMonoVersion>
    <PackageVersion>$(BitMonoVersion)</PackageVersion>
    <Version>$(BitMonoVersion)</Version>
    <InformationalVersion>$(BitMonoVersion)</InformationalVersion>
    <RepositoryUrl>https://github.com/sunnamed434/BitMono</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <Authors>sunnamed434</Authors>
    <Company>BitMono</Company>
    <Copyright>sunnamed434</Copyright>
    <LangVersion>preview</LangVersion>
    <PublishRepositoryUrl>true</PublishRepositoryUrl>
    <EmbedUntrackedSources>true</EmbedUntrackedSources>
    <IncludeSymbols>false</IncludeSymbols>
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
    <Nullable>enable</Nullable>
    <NoWarn>$(NoWarn);NU1701;NU1702;CS0436;CS1591</NoWarn>
    <AllowedOutputExtensionsInPackageBuildOutputFolder>$(AllowedOutputExtensionsInPackageBuildOutputFolder);.pdb</AllowedOutputExtensionsInPackageBuildOutputFolder>
  </PropertyGroup>

  <ItemGroup>
    <None Include="$(MSBuildThisFileDirectory)..\README.md" Pack="true" PackagePath="\"/>
  </ItemGroup>

  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
  </PropertyGroup>

  <ItemGroup Condition=" '$(TargetFramework)' == 'net462' ">
    <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.3" PrivateAssets="All" />
    <PackageReference Include="Microsoft.SourceLink.GitHub" Version="8.0.0" PrivateAssets="All"/>
  </ItemGroup>

</Project>


================================================
File: props/SharedTestProps.props
================================================
<Project>

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <LangVersion>preview</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0"/>
    <PackageReference Include="FluentAssertions" Version="7.0.0"/>
    <PackageReference Include="xunit" Version="2.9.3"/>
    <PackageReference Include="xunit.runner.visualstudio" Version="3.0.1"/>
    <PackageReference Include="coverlet.collector" Version="6.0.3"/>
  </ItemGroup>

</Project>




================================================
File: src/BitMono.API/BitMono.API.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props" />
  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedPackages.props" />

  <ItemGroup>
    <ProjectReference Include="..\BitMono.Shared\BitMono.Shared.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="NullGuard.Fody" Version="3.1.1" PrivateAssets="All" />
  </ItemGroup>

</Project>



================================================
File: src/BitMono.API/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <NullGuard />
</Weavers>


================================================
File: src/BitMono.API/GlobalUsings.cs
================================================
ï»¿global using AsmResolver.DotNet;
global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using NullGuard;
global using System;
global using System.Collections.Generic;
global using System.Diagnostics.CodeAnalysis;
global using System.Threading.Tasks;
global using BitMono.API.Protections;
global using JetBrains.Annotations;
global using IModule = Autofac.Core.IModule;


================================================
File: src/BitMono.API/Analyzing/ICriticalAnalyzer.cs
================================================
ï»¿namespace BitMono.API.Analyzing;

[UsedImplicitly(ImplicitUseTargetFlags.WithInheritors)]
public interface ICriticalAnalyzer<in TObject>
{
    bool NotCriticalToMakeChanges(TObject @object);
}


================================================
File: src/BitMono.API/Configuration/IBitMonoCriticalsConfiguration.cs
================================================
ï»¿namespace BitMono.API.Configuration;

public interface IBitMonoCriticalsConfiguration : IConfigurationAccessor
{
}


================================================
File: src/BitMono.API/Configuration/IBitMonoObfuscationConfiguration.cs
================================================
ï»¿namespace BitMono.API.Configuration;

public interface IBitMonoObfuscationConfiguration : IConfigurationAccessor
{
}


================================================
File: src/BitMono.API/Configuration/IBitMonoProtectionsConfiguration.cs
================================================
ï»¿namespace BitMono.API.Configuration;

public interface IBitMonoProtectionsConfiguration : IConfigurationAccessor
{
}


================================================
File: src/BitMono.API/Configuration/IConfigurationAccessor.cs
================================================
ï»¿namespace BitMono.API.Configuration;

public interface IConfigurationAccessor
{
    IConfiguration Configuration { get; }
}


================================================
File: src/BitMono.API/Configuration/JsonConfigurationAccessor.cs
================================================
ï»¿namespace BitMono.API.Configuration;

public class JsonConfigurationAccessor : IConfigurationAccessor
{
    protected JsonConfigurationAccessor(string file)
    {
        Configuration = new ConfigurationBuilder()
            .AddJsonFile(file, false, true)
            .Build();
    }

    public IConfiguration Configuration { get; }
}


================================================
File: src/BitMono.API/Protections/IPacker.cs
================================================
ï»¿namespace BitMono.API.Protections;

public interface IPacker : IProtection;


================================================
File: src/BitMono.API/Protections/IPhaseProtection.cs
================================================
ï»¿namespace BitMono.API.Protections;

public interface IPhaseProtection : IProtection;


================================================
File: src/BitMono.API/Protections/IPipelineProtection.cs
================================================
ï»¿namespace BitMono.API.Protections;

public interface IPipelineProtection : IProtection
{
    IEnumerable<IPhaseProtection> PopulatePipeline();
}


================================================
File: src/BitMono.API/Protections/IProtection.cs
================================================
ï»¿namespace BitMono.API.Protections;

[UsedImplicitly(ImplicitUseTargetFlags.WithInheritors)]
public interface IProtection
{
    Task ExecuteAsync();
}


================================================
File: src/BitMono.API/Protections/ProtectionParameters.cs
================================================
ï»¿namespace BitMono.API.Protections;

public class ProtectionParameters
{
    public ProtectionParameters(List<IMetadataMember> members)
    {
        Members = members;
    }

    public List<IMetadataMember> Members { get; }
}


================================================
File: src/BitMono.API/Resolvers/CustomAttributeResolve.cs
================================================
ï»¿namespace BitMono.API.Resolvers;

public class CustomAttributeResolve
{
    [NullGuard.AllowNull]
    public Dictionary<string, object>? NamedValues { get; set; }
    [NullGuard.AllowNull]
    public List<object>? FixedValues { get; set; }
    public CustomAttribute? Attribute { get; set; }
}


================================================
File: src/BitMono.API/Resolvers/IAttributeResolver.cs
================================================
ï»¿namespace BitMono.API.Resolvers;

[UsedImplicitly(ImplicitUseTargetFlags.WithInheritors)]
public interface IAttributeResolver<TModel> where TModel : class
{
    bool Resolve(string? featureName, IHasCustomAttribute from, [NotNullWhen(true)] out TModel? model);
    bool Resolve(string? featureName, IHasCustomAttribute from);
    bool Resolve(IHasCustomAttribute from);
    bool Resolve(Type featureType, IHasCustomAttribute from);
    bool Resolve<TFeature>(IHasCustomAttribute from) where TFeature : IProtection;
}


================================================
File: src/BitMono.API/Resolvers/IMemberResolver.cs
================================================
ï»¿namespace BitMono.API.Resolvers;

[UsedImplicitly(ImplicitUseTargetFlags.WithInheritors)]
public interface IMemberResolver
{
    bool Resolve(IProtection protection, IMetadataMember member);
}


================================================
File: src/BitMono.CLI/BitMono.CLI.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
    <ApplicationIcon>BitMonoLogo.ico</ApplicationIcon>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props"/>

  <ItemGroup>
    <ProjectReference Include="..\BitMono.API\BitMono.API.csproj"/>
    <ProjectReference Include="..\BitMono.Host\BitMono.Host.csproj"/>
    <ProjectReference Include="..\BitMono.Obfuscation\BitMono.Obfuscation.csproj"/>
    <ProjectReference Include="..\BitMono.Protections\BitMono.Protections.csproj"/>
    <ProjectReference Include="..\BitMono.Runtime\BitMono.Runtime.csproj"/>
    <ProjectReference Include="..\BitMono.Shared\BitMono.Shared.csproj"/>
    <ProjectReference Include="..\BitMono.Utilities\BitMono.Utilities.csproj"/>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="CommandLineParser" Version="2.9.1"/>
    <PackageReference Include="Costura.Fody" Version="6.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="NullGuard.Fody" Version="3.1.1"/>
  </ItemGroup>

</Project>


================================================
File: src/BitMono.CLI/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <NullGuard />
  <Costura>
    <ExcludeAssemblies>
      BitMono.*
    </ExcludeAssemblies>
  </Costura>
</Weavers>


================================================
File: src/BitMono.CLI/GlobalUsings.cs
================================================
ï»¿global using Autofac;
global using BitMono.CLI.Modules;
global using BitMono.Host;
global using BitMono.Host.Modules;
global using BitMono.Obfuscation;
global using System;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.IO;
global using System.Threading;
global using System.Threading.Tasks;
global using BitMono.Host.Extensions;
global using BitMono.Obfuscation.Files;
global using BitMono.Obfuscation.Starter;
global using BitMono.Shared.Models;
global using BitMono.Utilities.Paths;
global using CommandLine;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Options;
global using Pocket.Extensions;
global using Serilog;
global using Serilog.Configuration;
global using ILogger = Serilog.ILogger;


================================================
File: src/BitMono.CLI/KnownReturnStatuses.cs
================================================
ï»¿namespace BitMono.CLI;

internal static class KnownReturnStatuses
{
    public const int Success = 0;
    public const int Failure = 1;
}


================================================
File: src/BitMono.CLI/Program.cs
================================================
namespace BitMono.CLI;

internal class Program
{
    private static readonly CancellationTokenSource CancellationTokenSource = new();
    private static CancellationToken CancellationToken => CancellationTokenSource.Token;
    private static readonly string BitMonoFileVersionText =
        $"BitMono v{FileVersionInfo.GetVersionInfo(typeof(Program).Assembly.Location).FileVersion}";
    private static readonly string AsciiArt = $"""

                                                      ___  _ __  __  ___
                                                     / _ )(_) /_/  |/  /__  ___  ___
                                                    / _  / / __/ /|_/ / _ \/ _ \/ _ \
                                                   /____/_/\__/_/  /_/\___/_//_/\___/
                                                   https://github.com/sunnamed434/BitMono
                                                   {BitMonoFileVersionText}
                                               """;

    private static async Task<int> Main(string[] args)
    {
        Console.CancelKeyPress += OnCancelKeyPress;
        var statusCode = KnownReturnStatuses.Success;
        ObfuscationNeeds? needs = null;
        try
        {
            Console.Title = BitMonoFileVersionText;
            var module = new BitMonoModule(
                configureContainer => configureContainer.AddProtections(),
                configureServices => configureServices.AddConfigurations(),
                configureLogger => configureLogger.WriteTo.AddConsoleLogger());

            var app = new BitMonoApplication().RegisterModule(module);
            await using var serviceProvider = await app.BuildAsync(CancellationToken);

            var obfuscation = serviceProvider.GetRequiredService<IOptions<ObfuscationSettings>>().Value;
            var logger = serviceProvider
                .GetRequiredService<ILogger>()
                .ForContext<Program>();
            needs = new ObfuscationNeedsFactory(args, obfuscation, logger).Create(CancellationToken);
            if (needs == null)
            {
                statusCode = KnownReturnStatuses.Failure;
                return statusCode;
            }

            CancellationToken.ThrowIfCancellationRequested();

            if (obfuscation.ClearCLI)
            {
                Console.Clear();
            }
            logger.Information("File: {0}", needs.FileName);
            logger.Information("Dependencies (libs): {0}", needs.ReferencesDirectoryName);
            logger.Information("Everything is seems to be ok, starting obfuscation..");
            logger.Information(AsciiArt);

            var info = new IncompleteFileInfo(needs.FileName, needs.ReferencesDirectoryName, needs.OutputPath);
            var engine = new BitMonoStarter(serviceProvider);
            var succeed = await engine.StartAsync(info, CancellationToken);
            if (!succeed)
            {
                logger.Fatal("Engine has fatal issues, unable to continue!");
                if (needs.Way == ObfuscationNeedsWay.Readline)
                {
                    Console.WriteLine("Enter anything to exit!");
                    Console.ReadLine();
                }
                statusCode = KnownReturnStatuses.Failure;
                return statusCode;
            }

            if (obfuscation.OpenFileDestinationInFileExplorer)
            {
                try
                {
                    Process.Start(needs.OutputPath);
                }
                catch (Exception ex)
                {
                    logger.Error(ex, "An error occured while opening the destination file in explorer!");
                }
            }
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("Obfuscation Canceled!");
            statusCode = KnownReturnStatuses.Failure;
        }
        catch (Exception ex)
        {
            Console.WriteLine("Something went wrong! " + ex);
            statusCode = KnownReturnStatuses.Failure;
        }

        Console.CancelKeyPress -= OnCancelKeyPress;

        if (needs?.Way == ObfuscationNeedsWay.Readline)
        {
            Console.WriteLine("Enter anything to exit!");
            Console.ReadLine();
        }
        return statusCode;
    }

    private static void OnCancelKeyPress(object? sender, ConsoleCancelEventArgs e)
    {
        CancellationTokenSource.Cancel();
        e.Cancel = true;
    }
}


================================================
File: src/BitMono.CLI/Modules/LoggerConfiguratorExtensions.cs
================================================
namespace BitMono.CLI.Modules;

internal static class LoggerConfiguratorExtensions
{
    private const string OutputTemplate =
        "[{Timestamp:yyyy-MM-dd HH:mm:ss} {Level:u3}][{SourceContext}] {Message:lj}{NewLine}{Exception}";
    public static LoggerConfiguration AddConsoleLogger(this LoggerSinkConfiguration source)
    {
        return source.Async(configure => configure.Console(outputTemplate: OutputTemplate));
    }
}


================================================
File: src/BitMono.CLI/Modules/ObfuscationNeeds.cs
================================================
ï»¿namespace BitMono.CLI.Modules;

internal class ObfuscationNeeds
{
#pragma warning disable CS8618
    public string FileName { get; set; }
    public string FileBaseDirectory { get; set; }
    public string ReferencesDirectoryName { get; set; }
    public string OutputPath { get; set; }
    public ObfuscationNeedsWay Way { get; set; }
#pragma warning restore CS8618
}

/// <summary>
/// The way <see cref="ObfuscationNeeds"/> was created.
/// </summary>
public enum ObfuscationNeedsWay
{
    Unknown,
    Readline,
    Options,
    Other,
}


================================================
File: src/BitMono.CLI/Modules/ObfuscationNeedsFactory.cs
================================================
namespace BitMono.CLI.Modules;

internal class ObfuscationNeedsFactory
{
    private readonly string[] _args;
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly ILogger _logger;

    public ObfuscationNeedsFactory(string[] args,
        ObfuscationSettings obfuscationSettings, ILogger logger)
    {
        _args = args;
        _obfuscationSettings = obfuscationSettings;
        _logger = logger;
    }

    public ObfuscationNeeds? Create(CancellationToken cancellationToken)
    {
        return _args.IsEmpty()
            ? new ReadlineObfuscationNeedsFactory(_args, _obfuscationSettings, _logger).Create(cancellationToken)
            : new OptionsObfuscationNeedsFactory(_args, _obfuscationSettings, _logger).Create(cancellationToken);
    }
}


================================================
File: src/BitMono.CLI/Modules/Options.cs
================================================
namespace BitMono.CLI.Modules;

internal class Options
{
    [Option('f', "file", Required = true, HelpText = "Set file path.")]
    public string? File { get; set; }

    [Option('l', "libraries", Required = false, HelpText = "Set libraries path.")]
    public string? Libraries { get; set; }

    [Option('o', "output", Required = false, HelpText = "Set output path.")]
    public string? Output { get; set; }
}


================================================
File: src/BitMono.CLI/Modules/OptionsObfuscationNeedsFactory.cs
================================================
namespace BitMono.CLI.Modules;

internal class OptionsObfuscationNeedsFactory
{
    private readonly string[] _args;
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly ILogger _logger;

    public OptionsObfuscationNeedsFactory(string[] args,
        ObfuscationSettings obfuscationSettings, ILogger logger)
    {
        _args = args;
        _obfuscationSettings = obfuscationSettings;
        _logger = logger.ForContext<OptionsObfuscationNeedsFactory>();
    }

    [SuppressMessage("ReSharper", "AssignNullToNotNullAttribute")]
    public ObfuscationNeeds? Create(CancellationToken cancellationToken)
    {
        var parser = new Parser(with =>
        {
            with.EnableDashDash = true;
            with.HelpWriter = Console.Error;
        });
        var parserResult = parser.ParseArguments<Options>(_args);
        if (parserResult.Errors.IsEmpty() == false)
        {
            return null;
        }
        var options = parserResult.Value;
        var filePath = PathFormatterUtility.Format(options.File!);
        if (File.Exists(filePath) == false)
        {
            _logger.Fatal($"File {filePath} cannot be found, please, try again!");
            return null;
        }
        ObfuscationNeeds needs;
        var fileBaseDirectory = Path.GetDirectoryName(filePath);
        if (_obfuscationSettings.ForceObfuscation)
        {
            needs = new ObfuscationNeeds
            {
                FileName = filePath,
                FileBaseDirectory = fileBaseDirectory,
                ReferencesDirectoryName = fileBaseDirectory,
                OutputPath = fileBaseDirectory,
                Way = ObfuscationNeedsWay.Options
            };
        }
        else
        {
            needs = new ObfuscationNeeds
            {
                FileName = filePath,
                FileBaseDirectory = fileBaseDirectory,
                ReferencesDirectoryName = options.Libraries?.IsNullOrEmpty() == false
                    ? options.Libraries
                    : Path.Combine(fileBaseDirectory, _obfuscationSettings.ReferencesDirectoryName),
                OutputPath = options.Output?.IsNullOrEmpty() == false
                    ? options.Output
                    : Path.Combine(fileBaseDirectory, _obfuscationSettings.OutputDirectoryName),
                Way = ObfuscationNeedsWay.Options
            };
        }

        Directory.CreateDirectory(needs.OutputPath);
        Directory.CreateDirectory(needs.ReferencesDirectoryName);
        return needs;
    }
}


================================================
File: src/BitMono.CLI/Modules/ReadlineObfuscationNeedsFactory.cs
================================================
ï»¿namespace BitMono.CLI.Modules;

internal class ReadlineObfuscationNeedsFactory
{
    private readonly string[] _args;
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly ILogger _logger;

    public ReadlineObfuscationNeedsFactory(string[] args, ObfuscationSettings obfuscationSettings, ILogger logger)
    {
        _args = args;
        _obfuscationSettings = obfuscationSettings;
        _logger = logger.ForContext<ReadlineObfuscationNeedsFactory>();
    }

    public ObfuscationNeeds Create(CancellationToken cancellationToken)
    {
        var fileName = GetFileName(_args);
        while (true)
        {
            try
            {
                cancellationToken.ThrowIfCancellationRequested();

                _logger.Information("Please, specify file or drag-and-drop in BitMono CLI");

                fileName = PathFormatterUtility.Format(Console.ReadLine());
                cancellationToken.ThrowIfCancellationRequested();
                if (!string.IsNullOrWhiteSpace(fileName))
                {
                    if (File.Exists(fileName))
                    {
                        _logger.Information("File successfully specified: {0}", fileName);
                        break;
                    }

                    _logger.Warning("File cannot be found, please, try again!");
                }
                else
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    _logger.Warning("Unable to specify empty null or whitespace file, please, try again!");
                }
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Something went wrong while specifying the file");
            }
        }

        string dependenciesDirectoryName;
        string outputDirectoryName;
        var fileBaseDirectory = Path.GetDirectoryName(fileName);
        if (_obfuscationSettings.ForceObfuscation)
        {
            dependenciesDirectoryName = fileBaseDirectory;
            outputDirectoryName = fileBaseDirectory;
        }
        else
        {
            outputDirectoryName = Path.Combine(fileBaseDirectory, _obfuscationSettings.OutputDirectoryName);
            dependenciesDirectoryName = Path.Combine(fileBaseDirectory, _obfuscationSettings.ReferencesDirectoryName);
            if (!Directory.Exists(dependenciesDirectoryName))
            {
                while (true)
                {
                    try
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        if (Directory.Exists(dependenciesDirectoryName))
                        {
                            _logger.Information("Dependencies (libs) successfully found automatically: {0}!",
                                dependenciesDirectoryName);
                            break;
                        }

                        _logger.Information("Please, specify dependencies (libs) path: ");
                        var newDependenciesDirectoryName = PathFormatterUtility.Format(Console.ReadLine());
                        if (!string.IsNullOrWhiteSpace(newDependenciesDirectoryName))
                        {
                            if (Directory.Exists(newDependenciesDirectoryName))
                            {
                                dependenciesDirectoryName = newDependenciesDirectoryName;
                                _logger.Information("Dependencies (libs) successfully specified: {0}!",
                                    newDependenciesDirectoryName);
                                break;
                            }
                            else
                            {
                                _logger.Information("Libs directory doesn't exist, please, try again!");
                            }
                        }
                        else
                        {
                            _logger.Information("Unable to specify empty (libs), please, try again!");
                        }
                    }
                    catch (OperationCanceledException)
                    {
                        throw;
                    }
                    catch (Exception ex)
                    {
                        _logger.Error(ex, "Something went wrong while specifying the dependencies (libs) path");
                    }
                }
            }
            else
            {
                _logger.Information("Dependencies (libs) directory was automatically found in: {0}!",
                    dependenciesDirectoryName);
            }
        }

        Directory.CreateDirectory(outputDirectoryName);
        Directory.CreateDirectory(dependenciesDirectoryName);
        return new ObfuscationNeeds
        {
            FileName = fileName,
            FileBaseDirectory = fileBaseDirectory,
            ReferencesDirectoryName = dependenciesDirectoryName,
            OutputPath = outputDirectoryName,
            Way = ObfuscationNeedsWay.Readline
        };
    }

    private string GetFileName(string[] args)
    {
        string? file = null;
        if (!args.IsEmpty())
        {
            file = PathFormatterUtility.Format(args[0]);
        }
        return file;
    }
}


================================================
File: src/BitMono.Core/BitMono.Core.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props" />

  <ItemGroup>
    <ProjectReference Include="..\BitMono.API\BitMono.API.csproj" />
    <ProjectReference Include="..\BitMono.Utilities\BitMono.Utilities.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Reference Include="Echo">
      <HintPath>..\..\lib\Echo.dll</HintPath>
    </Reference>
    <Reference Include="Echo.ControlFlow">
      <HintPath>..\..\lib\Echo.ControlFlow.dll</HintPath>
    </Reference>
    <Reference Include="Echo.DataFlow">
      <HintPath>..\..\lib\Echo.DataFlow.dll</HintPath>
    </Reference>
    <Reference Include="Echo.Platforms.AsmResolver">
      <HintPath>..\..\lib\Echo.Platforms.AsmResolver.dll</HintPath>
    </Reference>
  </ItemGroup>

</Project>


================================================
File: src/BitMono.Core/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <NullGuard />
</Weavers>


================================================
File: src/BitMono.Core/GlobalUsings.cs
================================================
ï»¿global using AsmResolver;
global using AsmResolver.DotNet;
global using AsmResolver.DotNet.Cloning;
global using AsmResolver.DotNet.Signatures;
global using AsmResolver.PE.DotNet.Cil;
global using BitMono.Core.Extensions;
global using BitMono.Shared.Models;
global using System;
global using System.Collections.Generic;
global using System.Diagnostics.CodeAnalysis;
global using System.IO;
global using System.Linq;
global using System.Reflection;
global using System.Runtime.CompilerServices;
global using System.Threading;
global using System.Threading.Tasks;
global using AsmResolver.DotNet.Builder;
global using AsmResolver.DotNet.Code.Cil;
global using AsmResolver.DotNet.Serialized;
global using AsmResolver.PE.File;
global using BitMono.API;
global using BitMono.API.Analyzing;
global using BitMono.API.Protections;
global using BitMono.API.Resolvers;
global using BitMono.Core.Analyzing;
global using BitMono.Core.Attributes;
global using BitMono.Core.Contexts;
global using BitMono.Core.Factories;
global using BitMono.Core.Renaming;
global using BitMono.Core.Resolvers;
global using BitMono.Core.Services;
global using BitMono.Utilities.AsmResolver;
global using Echo.DataFlow.Analysis;
global using Echo.Platforms.AsmResolver;
global using JetBrains.Annotations;
global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.Configuration.Json;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Options;
global using Newtonsoft.Json;
global using Pocket.Extensions;
global using FieldAttributes = AsmResolver.PE.DotNet.Metadata.Tables.FieldAttributes;
global using TypeAttributes = AsmResolver.PE.DotNet.Metadata.Tables.TypeAttributes;


================================================
File: src/BitMono.Core/PackerProtection.cs
================================================
namespace BitMono.Core;

public abstract class PackerProtection : ProtectionBase, IPacker
{
    protected PackerProtection(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }
}


================================================
File: src/BitMono.Core/PhaseProtection.cs
================================================
namespace BitMono.Core;

public abstract class PhaseProtection : ProtectionBase, IPhaseProtection
{
    protected PhaseProtection(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }
}


================================================
File: src/BitMono.Core/PipelineProtection.cs
================================================
namespace BitMono.Core;

public abstract class PipelineProtection : ProtectionBase, IPipelineProtection
{
    protected PipelineProtection(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public abstract IEnumerable<IPhaseProtection> PopulatePipeline();
}


================================================
File: src/BitMono.Core/Protection.cs
================================================
namespace BitMono.Core;

public abstract class Protection : ProtectionBase
{
    protected Protection(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }
}


================================================
File: src/BitMono.Core/ProtectionBase.cs
================================================
namespace BitMono.Core;

public abstract class ProtectionBase : IProtection
{
    protected ProtectionContext Context { get; }
    protected IServiceProvider ServiceProvider { get; }

    protected ProtectionBase(IServiceProvider serviceProvider)
    {
        ServiceProvider = serviceProvider;
        Context = ServiceProvider
            .GetRequiredService<ProtectionContextFactory>()
            .Create(this);
    }

    public abstract Task ExecuteAsync();
}


================================================
File: src/BitMono.Core/Analyzing/CriticalBaseTypesCriticalAnalyzer.cs
================================================
ï»¿namespace BitMono.Core.Analyzing;

[SuppressMessage("ReSharper", "InvertIf")]
public class CriticalBaseTypesCriticalAnalyzer : ICriticalAnalyzer<TypeDefinition>
{
    private readonly CriticalsSettings _criticalsSettings;

    public CriticalBaseTypesCriticalAnalyzer(IOptions<CriticalsSettings> criticals)
    {
        _criticalsSettings = criticals.Value;
    }

    public bool NotCriticalToMakeChanges(TypeDefinition type)
    {
        if (_criticalsSettings.UseCriticalBaseTypes == false)
        {
            return true;
        }
        if (type.HasBaseType())
        {
            var criticalBaseTypes = _criticalsSettings.CriticalBaseTypes!;
            var typeBaseTypeName = type.BaseType?.Name?.Value.Split('`')[0] ?? string.Empty;
            if (criticalBaseTypes.FirstOrDefault(c => c.StartsWith(typeBaseTypeName)) != null)
            {
                return false;
            }
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Analyzing/CriticalInterfacesCriticalAnalyzer.cs
================================================
ï»¿namespace BitMono.Core.Analyzing;

public class CriticalInterfacesCriticalAnalyzer : ICriticalAnalyzer<TypeDefinition>
{
    private readonly CriticalsSettings _criticalsSettings;

    public CriticalInterfacesCriticalAnalyzer(IOptions<CriticalsSettings> criticals)
    {
        _criticalsSettings = criticals.Value;
    }

    public bool NotCriticalToMakeChanges(TypeDefinition type)
    {
        if (_criticalsSettings.UseCriticalInterfaces == false)
        {
            return true;
        }
        var criticalInterfaces = _criticalsSettings.CriticalInterfaces;
        if (type.Interfaces.Any(x => criticalInterfaces.FirstOrDefault(xx => xx.Equals(x.Interface?.Name)) != null))
        {
            return false;
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Analyzing/CriticalMethodsCriticalAnalyzer.cs
================================================
ï»¿namespace BitMono.Core.Analyzing;

public class CriticalMethodsCriticalAnalyzer : ICriticalAnalyzer<MethodDefinition>
{
    private readonly CriticalsSettings _criticalsSettings;

    public CriticalMethodsCriticalAnalyzer(IOptions<CriticalsSettings> criticals)
    {
        _criticalsSettings = criticals.Value;
    }

    public bool NotCriticalToMakeChanges(MethodDefinition method)
    {
        if (_criticalsSettings.UseCriticalMethods == false)
        {
            return true;
        }
        var criticalMethodNames = _criticalsSettings.CriticalMethods;
        return criticalMethodNames.Any(x => x.Equals(method.Name)) == false;
    }
}


================================================
File: src/BitMono.Core/Analyzing/CriticalMethodsStartsWithAnalyzer.cs
================================================
ï»¿namespace BitMono.Core.Analyzing;

public class CriticalMethodsStartsWithAnalyzer : ICriticalAnalyzer<MethodDefinition>
{
    private readonly CriticalsSettings _criticalsSettings;

    public CriticalMethodsStartsWithAnalyzer(IOptions<CriticalsSettings> criticals)
    {
        _criticalsSettings = criticals.Value;
    }

    public bool NotCriticalToMakeChanges(MethodDefinition method)
    {
        if (_criticalsSettings.UseCriticalMethodsStartsWith == false)
        {
            return true;
        }

        var criticalMethodsStartWith = _criticalsSettings.CriticalMethodsStartsWith;
        return criticalMethodsStartWith.Any(c => c.StartsWith(method.Name)) == false;
    }
}


================================================
File: src/BitMono.Core/Analyzing/ModelAttributeCriticalAnalyzer.cs
================================================
ï»¿namespace BitMono.Core.Analyzing;

[SuppressMessage("ReSharper", "ForCanBeConvertedToForeach")]
[SuppressMessage("ReSharper", "LoopCanBeConvertedToQuery")]
public class ModelAttributeCriticalAnalyzer : ICriticalAnalyzer<IHasCustomAttribute>
{
    private readonly CriticalsSettings _criticalsSettings;

    public ModelAttributeCriticalAnalyzer(IOptions<CriticalsSettings> criticals)
    {
        _criticalsSettings = criticals.Value;
    }

    public bool NotCriticalToMakeChanges(IHasCustomAttribute customAttribute)
    {
        if (_criticalsSettings.UseCriticalModelAttributes == false)
        {
            return true;
        }
        var criticalAttributes = _criticalsSettings.CriticalModelAttributes;
        for (var i = 0; i < criticalAttributes.Count; i++)
        {
            var attribute = criticalAttributes[i];
            if (AttemptAttributeResolver.TryResolve(customAttribute, attribute.Namespace, attribute.Name))
            {
                return false;
            }
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Analyzing/NameCriticalAnalyzer.cs
================================================
ï»¿namespace BitMono.Core.Analyzing;

[SuppressMessage("ReSharper", "ConvertIfStatementToReturnStatement")]
public class NameCriticalAnalyzer :
    ICriticalAnalyzer<TypeDefinition>,
    ICriticalAnalyzer<MethodDefinition>
{
    private readonly CriticalInterfacesCriticalAnalyzer _criticalInterfacesCriticalAnalyzer;
    private readonly CriticalBaseTypesCriticalAnalyzer _criticalBaseTypesCriticalAnalyzer;
    private readonly CriticalMethodsCriticalAnalyzer _criticalMethodsCriticalAnalyzer;
    private readonly CriticalMethodsStartsWithAnalyzer _criticalMethodsStartsWithAnalyzer;

    public NameCriticalAnalyzer(
        CriticalInterfacesCriticalAnalyzer criticalInterfacesCriticalAnalyzer,
        CriticalBaseTypesCriticalAnalyzer criticalBaseTypesCriticalAnalyzer,
        CriticalMethodsCriticalAnalyzer criticalMethodsCriticalAnalyzer,
        CriticalMethodsStartsWithAnalyzer criticalMethodsStartsWithAnalyzer)
    {
        _criticalInterfacesCriticalAnalyzer = criticalInterfacesCriticalAnalyzer;
        _criticalBaseTypesCriticalAnalyzer = criticalBaseTypesCriticalAnalyzer;
        _criticalMethodsCriticalAnalyzer = criticalMethodsCriticalAnalyzer;
        _criticalMethodsStartsWithAnalyzer = criticalMethodsStartsWithAnalyzer;
    }

    public bool NotCriticalToMakeChanges(TypeDefinition type)
    {
        if (_criticalInterfacesCriticalAnalyzer.NotCriticalToMakeChanges(type) == false)
        {
            return false;
        }
        if (_criticalBaseTypesCriticalAnalyzer.NotCriticalToMakeChanges(type) == false)
        {
            return false;
        }
        return true;
    }
    public bool NotCriticalToMakeChanges(MethodDefinition method)
    {
        if (_criticalMethodsCriticalAnalyzer.NotCriticalToMakeChanges(method) == false)
        {
            return false;
        }
        if (_criticalMethodsStartsWithAnalyzer.NotCriticalToMakeChanges(method) == false)
        {
            return false;
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Analyzing/ReflectionCriticalAnalyzer.cs
================================================
namespace BitMono.Core.Analyzing;

[SuppressMessage("ReSharper", "InvertIf")]
public class ReflectionCriticalAnalyzer : ICriticalAnalyzer<MethodDefinition>
{
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly List<MethodDefinition> _cachedMethods;
    private static readonly string[] ReflectionMethods =
    [
        nameof(Type.GetMethod),
        nameof(Type.GetField),
        nameof(Type.GetProperty),
        nameof(Type.GetEvent),
        nameof(Type.GetMember)
    ];

    public ReflectionCriticalAnalyzer(IOptions<ObfuscationSettings> obfuscation)
    {
        _obfuscationSettings = obfuscation.Value;
        _cachedMethods = [];
    }

    public IReadOnlyList<MethodDefinition> CachedMethods => _cachedMethods.AsReadOnly();

    public bool NotCriticalToMakeChanges(MethodDefinition method)
    {
        if (_obfuscationSettings.ReflectionMembersObfuscationExclude == false)
        {
            return true;
        }
        if (_cachedMethods.FirstOrDefault(x => x.Name.Equals(method.Name)) != null)
        {
            return false;
        }
        if (method.CilMethodBody is { } body)
        {
            body.ConstructSymbolicFlowGraph(out var dataFlowGraph);
            foreach (var node in dataFlowGraph.Nodes)
            {
                var orderedDependencies =
                    node.GetOrderedDependencies(DependencyCollectionFlags.IncludeStackDependencies);
                foreach (var order in orderedDependencies)
                {
                    var instruction = order.Contents;
                    if (instruction?.OpCode.Code == CilCode.Call && instruction.Operand is IMethodDefOrRef calledMethod)
                    {
                        if (IsReflection(calledMethod))
                        {
                            var traceArgument = TraceLdstrArgument(body, instruction);
                            if (traceArgument?.Operand is string traceMethodName)
                            {
                                foreach (var possibleMethod in method.Module
                                             .FindMembers()
                                             .OfType<MethodDefinition>()
                                             .Where(x => x.Name.Equals(traceMethodName)))
                                {
                                    _cachedMethods.Add(possibleMethod);
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return true;
    }

    private static bool IsReflection(IMethodDefOrRef calledMethod)
    {
        return calledMethod.DeclaringType.IsSystemType() &&
               ReflectionMethods.Contains(calledMethod.Name.Value);
    }
    private static CilInstruction? TraceLdstrArgument(CilMethodBody body, CilInstruction instruction)
    {
        for (var i = body.Instructions.IndexOf(instruction); i > 0 && body.Instructions.Count.IsLess(i) == false; i--)
        {
            var previousInstruction = body.Instructions[i];
            if (previousInstruction.OpCode == CilOpCodes.Ldstr)
            {
                return previousInstruction;
            }
        }
        return null;
    }
}


================================================
File: src/BitMono.Core/Analyzing/RuntimeCriticalAnalyzer.cs
================================================
ï»¿namespace BitMono.Core.Analyzing;

[SuppressMessage("ReSharper", "MergeIntoPattern")]
public class RuntimeCriticalAnalyzer : ICriticalAnalyzer<IMetadataMember>
{
    public bool NotCriticalToMakeChanges(IMetadataMember member)
    {
        if (member is TypeDefinition type)
        {
            return type.IsRuntimeSpecialName == false;
        }
        if (member is FieldDefinition field)
        {
            return field.IsRuntimeSpecialName == false
                && field.IsLiteral == false
                && field.DeclaringType?.IsEnum == false;
        }
        if (member is MethodDefinition method)
        {
            return method.IsRuntimeSpecialName == false || method.DeclaringType?.IsForwarder == false;
        }
        if (member is EventDefinition @event)
        {
            return @event.IsRuntimeSpecialName == false;
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Analyzing/SerializableBitCriticalAnalyzer.cs
================================================
namespace BitMono.Core.Analyzing;

[SuppressMessage("ReSharper", "ConvertIfStatementToReturnStatement")]
public class SerializableBitCriticalAnalyzer : ICriticalAnalyzer<TypeDefinition>
{
    private readonly ObfuscationSettings _obfuscationSettings;

    public SerializableBitCriticalAnalyzer(IOptions<ObfuscationSettings> obfuscation)
    {
        _obfuscationSettings = obfuscation.Value;
    }

    public bool NotCriticalToMakeChanges(TypeDefinition type)
    {
        if (_obfuscationSettings.SerializableBitObfuscationExclude == false)
        {
            return true;
        }
        if (type.IsSerializable)
        {
            return false;
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Analyzing/SpecificNamespaceCriticalAnalyzer.cs
================================================
ï»¿namespace BitMono.Core.Analyzing;

[SuppressMessage("ReSharper", "ConvertIfStatementToSwitchStatement")]
public class SpecificNamespaceCriticalAnalyzer : ICriticalAnalyzer<IMetadataMember>
{
    private readonly ObfuscationSettings _obfuscationSettings;

    public SpecificNamespaceCriticalAnalyzer(IOptions<ObfuscationSettings> obfuscation)
    {
        _obfuscationSettings = obfuscation.Value;
    }

    public bool NotCriticalToMakeChanges(IMetadataMember member)
    {
        if (_obfuscationSettings.SpecificNamespacesObfuscationOnly == false)
        {
            return true;
        }

        var specificNamespaces = _obfuscationSettings.SpecificNamespaces!;
        if (member is TypeDefinition type && type.HasNamespace())
        {
            if (specificNamespaces.Any(s => s.Equals(type.Namespace?.Value)) == false)
            {
                return false;
            }
        }
        if (member is MethodDefinition method && method.DeclaringType?.HasNamespace() == true)
        {
            if (specificNamespaces.Any(s => s.Equals(method.DeclaringType.Namespace?.Value)) == false)
            {
                return false;
            }
        }
        if (member is FieldDefinition field && field.DeclaringType?.HasNamespace() == true)
        {
            if (specificNamespaces.Any(s => s.Equals(field.DeclaringType.Namespace?.Value)) == false)
            {
                return false;
            }
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Attributes/ConfigureForNativeCodeAttribute.cs
================================================
ï»¿namespace BitMono.Core.Attributes;

/// <summary>
/// This is necessary to make native code work inside the assembly.
/// See more here: https://docs.washi.dev/asmresolver/guides/dotnet/unmanaged-method-bodies.html
/// However, sometimes it causes issues with the assembly like <see cref="BadImageFormatException"/>,
/// that's why you need to manually mark your <see cref="Protection"/> with <see cref="ConfigureForNativeCodeAttribute"/>.
/// </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class ConfigureForNativeCodeAttribute : Attribute;


================================================
File: src/BitMono.Core/Attributes/DoNotResolveAttribute.cs
================================================
ï»¿namespace BitMono.Core.Attributes;

/// <summary>
/// Represents a sort logic which doesn't include specified <see cref="MemberInclusionFlags"/> in <see cref="Protection"/> <see cref="ProtectionParameters.Members"/>.
/// </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class DoNotResolveAttribute : Attribute
{
    public DoNotResolveAttribute(MemberInclusionFlags memberInclusion)
    {
        MemberInclusion = memberInclusion;
    }

    public MemberInclusionFlags MemberInclusion { get; }
}


================================================
File: src/BitMono.Core/Attributes/KnownRuntimeMonikers.cs
================================================
namespace BitMono.Core.Attributes;

public static class KnownRuntimeMonikers
{
    public const string Mono = "Mono";
    public const string NETCore = ".NET Core";
    public const string NETFramework = ".NET Framework";
}


================================================
File: src/BitMono.Core/Attributes/MemberInclusionFlags.cs
================================================
ï»¿namespace BitMono.Core.Attributes;

[Flags]
public enum MemberInclusionFlags
{
    SpecialRuntime = 0x1,
    Model = 0x2,
    Reflection = 0x4,
}


================================================
File: src/BitMono.Core/Attributes/ProtectionDescriptionAttribute.cs
================================================
ï»¿namespace BitMono.Core.Attributes;

[AttributeUsage(AttributeTargets.Class)]
public class ProtectionDescriptionAttribute : Attribute
{
    public ProtectionDescriptionAttribute(string description)
    {
        Description = description;
    }

    public string Description { get; }
}


================================================
File: src/BitMono.Core/Attributes/ProtectionNameAttribute.cs
================================================
ï»¿namespace BitMono.Core.Attributes;

[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class ProtectionNameAttribute : Attribute
{
    public ProtectionNameAttribute(string name)
    {
        Name = name;
    }

    public string Name { get; }
}


================================================
File: src/BitMono.Core/Attributes/RuntimeMonikerAttribute.cs
================================================
namespace BitMono.Core.Attributes;

/// <summary>
/// Represents a mechanism that specifies the runtime moniker of the protection.
/// <remarks>i.e. if you see this attribute on protection, then only specified attributes are the supported runtime monikers for the protection.
/// If you don't see any of the attributes, then it works everywhere, also, users will get a message via <see cref="GetMessage"/></remarks>
/// </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
public abstract class RuntimeMonikerAttribute : Attribute
{
    protected RuntimeMonikerAttribute(string name)
    {
        Name = name;
    }

    /// <summary>
    /// Gets the name of the runtime moniker.
    /// </summary>
    public string Name { get; }

    [SuppressMessage("ReSharper", "VirtualMemberNeverOverridden.Global")]
    public virtual string GetMessage()
    {
        return $"Intended for {Name} runtime";
    }
}


================================================
File: src/BitMono.Core/Attributes/RuntimeMonikerMonoAttribute.cs
================================================
namespace BitMono.Core.Attributes;

/// <summary>
/// Represents a mechanism that specifies the runtime moniker of the protection as a <b>Mono</b>.
/// <remarks>i.e if you see this attribute on protection then only specified attributes are the supported runtime monikers for the protection.
/// If you don't see any of the attributes then it works everywhere, also, users will get a message via <see cref="RuntimeMonikerAttribute.GetMessage"/></remarks>
/// </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public class RuntimeMonikerMonoAttribute : RuntimeMonikerAttribute
{
    public RuntimeMonikerMonoAttribute() : base(KnownRuntimeMonikers.Mono)
    {
    }
}


================================================
File: src/BitMono.Core/Attributes/RuntimeMonikerNETCore.cs
================================================
ï»¿namespace BitMono.Core.Attributes;

[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public class RuntimeMonikerNETCore : RuntimeMonikerAttribute
{
    public RuntimeMonikerNETCore() : base(KnownRuntimeMonikers.NETCore)
    {
    }
}


================================================
File: src/BitMono.Core/Attributes/RuntimeMonikerNETFramework.cs
================================================
ï»¿namespace BitMono.Core.Attributes;

[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public class RuntimeMonikerNETFramework : RuntimeMonikerAttribute
{
    public RuntimeMonikerNETFramework() : base(KnownRuntimeMonikers.NETFramework)
    {
    }
}


================================================
File: src/BitMono.Core/Configuration/JsonConfigurationExtensions.cs
================================================
namespace BitMono.Core.Configuration;

public static class JsonConfigurationExtensions
{
    public static IConfigurationBuilder AddJsonFileEx(this IConfigurationBuilder builder,
        Action<JsonConfigurationSourceEx> configure)
    {
        return builder.Add(configure);
    }
}


================================================
File: src/BitMono.Core/Configuration/JsonConfigurationProviderEx.cs
================================================
namespace BitMono.Core.Configuration;

public class JsonConfigurationProviderEx : FileConfigurationProvider
{
    private readonly JsonConfigurationSourceEx _source;
    private const string ParseMethodName = "Parse";
    private const string ParserTypeName = "Microsoft.Extensions.Configuration.Json.JsonConfigurationFileParser";
    private static readonly Type ParserType = typeof(JsonConfigurationProvider).Assembly.GetType(ParserTypeName);
    private static readonly MethodInfo ParseMethodInfo = ParserType.GetMethod(ParseMethodName,
        BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

    public JsonConfigurationProviderEx(JsonConfigurationSourceEx source) : base(source)
    {
        _source = source;
    }

    public override void Load(Stream stream)
    {
        using var streamReader = new StreamReader(stream, true);
        var text = streamReader.ReadToEnd();
        PreProcessJson(ref text);
        using var memoryStream = new MemoryStream();
        using var streamWriter = new StreamWriter(memoryStream, streamReader.CurrentEncoding);
        streamWriter.Write(text);
        streamWriter.Flush();
        memoryStream.Seek(0L, SeekOrigin.Begin);
        try
        {
            var parseMethod = (Func<MemoryStream, IDictionary<string, string>>)Delegate.CreateDelegate(
                typeof(Func<MemoryStream, IDictionary<string, string>>), ParseMethodInfo);
            Data = parseMethod.Invoke(memoryStream);
        }
        catch (JsonException ex)
        {
            throw new FormatException("Could not parse the JSON file", ex);
        }
    }
    private void PreProcessJson(ref string json)
    {
        if (_source.Variables == null)
        {
            return;
        }
        json = _source.Variables.Aggregate(json,
            (current, keyValuePair) => current.Replace("{{" + keyValuePair.Key + "}}", keyValuePair.Value));
    }
}


================================================
File: src/BitMono.Core/Configuration/JsonConfigurationSourceEx.cs
================================================
namespace BitMono.Core.Configuration;

public class JsonConfigurationSourceEx : FileConfigurationSource
{
    public IDictionary<string, string>? Variables { get; set; }

    public override IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        EnsureDefaults(builder);
        return new JsonConfigurationProviderEx(this);
    }
}


================================================
File: src/BitMono.Core/Contexts/BitMonoContext.cs
================================================
ï»¿namespace BitMono.Core.Contexts;

public class BitMonoContext
{
#pragma warning disable CS8618
    public string FileName { get; set; }
    public string OutputDirectoryName { get; set; }
    public string OutputFile { get; set; }
    public List<byte[]> ReferencesData { get; set; }
    public bool Watermark { get; set; }
#pragma warning restore CS8618
}



================================================
File: src/BitMono.Core/Contexts/ProtectionContext.cs
================================================
ï»¿namespace BitMono.Core.Contexts;

public class ProtectionContext
{
    public ProtectionContext(ModuleDefinition module, ModuleDefinition runtimeModule, BitMonoContext bitMonoContext,
        ProtectionParameters parameters, CancellationToken cancellationToken)
    {
        Module = module;
        RuntimeModule = runtimeModule;
        BitMonoContext = bitMonoContext;
        Parameters = parameters;
        CancellationToken = cancellationToken;
    }

    public ModuleDefinition Module { get; }
    public ModuleDefinition RuntimeModule { get; }
    public BitMonoContext BitMonoContext { get; }
    public ProtectionParameters Parameters { get; }
    public CancellationToken CancellationToken { get; }

    public ReferenceImporter ModuleImporter => Module.DefaultImporter;
    public ReferenceImporter RuntimeImporter => Module.DefaultImporter;
    public bool X86 => Module.MachineType == MachineType.I386;

    public void ThrowIfCancellationTokenRequested()
    {
        CancellationToken.ThrowIfCancellationRequested();
    }
}


================================================
File: src/BitMono.Core/Contexts/StarterContext.cs
================================================
ï»¿namespace BitMono.Core.Contexts;

public class StarterContext
{
#pragma warning disable CS8618
    public ModuleDefinition Module { get; set; }
    public ModuleReaderParameters ModuleReaderParameters { get; set; }
    public IPEImageBuilder PEImageBuilder { get; set; }
    public ModuleDefinition RuntimeModule { get; set; }
    public ReferenceImporter RuntimeImporter { get; set; }
    public BitMonoContext BitMonoContext { get; set; }
    public CancellationToken CancellationToken { get; set; }

    public IAssemblyResolver AssemblyResolver => Module.MetadataResolver.AssemblyResolver;
#pragma warning restore CS8618

    public void ThrowIfCancellationRequested()
    {
        CancellationToken.ThrowIfCancellationRequested();
    }
}


================================================
File: src/BitMono.Core/Extensions/KeyValuePairsExtensions.cs
================================================
ï»¿namespace BitMono.Core.Extensions;

public static class KeyValuePairsExtensions
{
    public static bool GetValueOrDefault(this Dictionary<string, object> source, string key, bool defaultValue = false)
    {
        var value = defaultValue;
        if (source.TryGetTypedValue(key, out bool valueValue))
        {
            value = valueValue;
        }
        return value;
    }
    public static bool TryGetTypedValue<TKey, TValue, TActual>(this IDictionary<TKey, TValue> source, TKey key, [NotNullWhen(true)] out TActual? value)
        where TActual : TValue
    {
        if (source.TryGetValue(key, out var tempValue))
        {
            value = (TActual?)tempValue;
            return true;
        }
        value = default;
        return false;
    }
}


================================================
File: src/BitMono.Core/Extensions/ProtectionExtensions.cs
================================================
ï»¿namespace BitMono.Core.Extensions;

public static class ProtectionExtensions
{
    public static bool TryGetDoNotResolveAttribute(this Type source, out DoNotResolveAttribute? attribute, bool inherit = false)
    {
        attribute = source.GetCustomAttribute<DoNotResolveAttribute>(inherit);
        if (attribute == null)
        {
            return false;
        }
        return true;
    }
    public static bool TryGetDoNotResolveAttribute(this IProtection source, out DoNotResolveAttribute? attribute)
    {
        return source.GetType().TryGetDoNotResolveAttribute(out attribute);
    }
    public static bool TryGetDoNotResolveAttribute(this IPacker source, out DoNotResolveAttribute? attribute)
    {
        return source.GetType().TryGetDoNotResolveAttribute(out attribute);
    }
    public static bool TryGetDoNotResolveAttribute<TProtection>(out DoNotResolveAttribute? attribute) where TProtection : IProtection
    {
        return typeof(TProtection).TryGetDoNotResolveAttribute(out attribute);
    }
    public static RuntimeMonikerAttribute[] GetRuntimeMonikerAttributes(this Type source, bool inherit = false)
    {
        return source
            .GetCustomAttributes<RuntimeMonikerAttribute>(inherit)
            .ToArray();
    }
    public static RuntimeMonikerAttribute[] GetRuntimeMonikerAttributes(this IProtection source)
    {
        return source
            .GetType()
            .GetRuntimeMonikerAttributes();
    }
    public static ConfigureForNativeCodeAttribute? GetConfigureForNativeCodeAttribute(this Type source, bool inherit = false)
    {
        return source.GetCustomAttribute<ConfigureForNativeCodeAttribute>(inherit);
    }
    public static ConfigureForNativeCodeAttribute? GetConfigureForNativeCodeAttribute(this IProtection source)
    {
        return source
            .GetType()
            .GetConfigureForNativeCodeAttribute();
    }
    public static bool TryGetObsoleteAttribute(this Type source, out ObsoleteAttribute? attribute, bool inherit = false)
    {
        attribute = source.GetCustomAttribute<ObsoleteAttribute>(inherit);
        if (attribute == null)
        {
            return false;
        }
        return true;
    }
    public static bool TryGetObsoleteAttribute(this IProtection source, out ObsoleteAttribute? attribute)
    {
        return source.GetType().TryGetObsoleteAttribute(out attribute);
    }
    public static string GetName(this Type source, bool inherit = false)
    {
        var protectionNameAttribute = source.GetCustomAttribute<ProtectionNameAttribute>(inherit);
        if (protectionNameAttribute != null)
        {
            return string.IsNullOrWhiteSpace(protectionNameAttribute.Name) == false
                ? protectionNameAttribute.Name
                : source.Name;
        }
        return source.Name;
    }
    public static string GetName(this IProtection source)
    {
        return source.GetType().GetName(inherit: false);
    }
    public static string GetName(this IPipelineProtection source)
    {
        return source.GetType().GetName(inherit: false);
    }
    public static string GetName(this IPacker source)
    {
        return source.GetType().GetName(inherit: false);
    }
    public static string GetName<TProtection>() where TProtection : IProtection
    {
        return typeof(TProtection).GetName(inherit: false);
    }
}


================================================
File: src/BitMono.Core/Factories/ProtectionContextFactory.cs
================================================
namespace BitMono.Core.Factories;

public class ProtectionContextFactory
{
    private readonly IEngineContextAccessor _engineContextAccessor;
    private readonly ProtectionParametersFactory _protectionParametersFactory;

    public ProtectionContextFactory(
        IEngineContextAccessor engineContextAccessor,
        ProtectionParametersFactory protectionParametersFactory)
    {
        _engineContextAccessor = engineContextAccessor;
        _protectionParametersFactory = protectionParametersFactory;
    }

    public ProtectionContext Create(IProtection target)
    {
        var engineContext = _engineContextAccessor.Instance;
        var protectionParameters = _protectionParametersFactory.Create(target, engineContext.Module);
        return new ProtectionContext(engineContext.Module, engineContext.RuntimeModule, engineContext.BitMonoContext,
            protectionParameters, engineContext.CancellationToken);
    }
}


================================================
File: src/BitMono.Core/Factories/ProtectionParametersFactory.cs
================================================
ï»¿namespace BitMono.Core.Factories;

public class ProtectionParametersFactory
{
    private readonly ICollection<IMemberResolver> _memberResolvers;

    public ProtectionParametersFactory(ICollection<IMemberResolver> memberResolvers)
    {
        _memberResolvers = memberResolvers;
    }

    public ProtectionParameters Create(IProtection protection, ModuleDefinition module)
    {
        var definitions = module.FindMembers();
        var targets = MembersResolver.Resolve(protection, definitions, _memberResolvers).ToList();
        foreach (var method in targets.OfType<MethodDefinition>())
        {
            if (method.CilMethodBody is { } body)
            {
                body.Instructions.CalculateOffsets();
            }
        }
        return new ProtectionParameters(targets);
    }
}


================================================
File: src/BitMono.Core/Injection/CustomInjector.cs
================================================
ï»¿namespace BitMono.Core.Injection;

public class CustomInjector
{
    public static CustomAttribute InjectAttribute(ModuleDefinition module, string @namespace, string name)
    {
        var factory = module.CorLibTypeFactory;
        var attributeReference = new TypeReference(module, module, @namespace, name);
        var signature = MethodSignature.CreateInstance(factory.Void);
        var attributeCtor = new MemberReference(attributeReference, ".ctor", signature);
        var attribute = new CustomAttribute(attributeCtor);
        module.CustomAttributes.Add(attribute);
        return attribute;
    }
    public static CustomAttribute InjectAttribute(ModuleDefinition module, string @namespace, string name, string content)
    {
        var factory = module.CorLibTypeFactory;
        var attributeReference = new TypeReference(module, module, @namespace, name);
        var signature = MethodSignature.CreateInstance(factory.Void, factory.String);
        var attributeCtor = new MemberReference(attributeReference, ".ctor", signature);
        var customAttribute = new CustomAttribute(attributeCtor);
#pragma warning disable CS8602
        customAttribute.Signature.FixedArguments.Add(new CustomAttributeArgument(factory.String, content));
#pragma warning restore CS8602
        module.CustomAttributes.Add(customAttribute);
        return customAttribute;
    }
}


================================================
File: src/BitMono.Core/Injection/ModifyFlags.cs
================================================
ï»¿namespace BitMono.Core.Injection;

[Flags]
public enum ModifyFlags
{
    Rename = 0x1,
    RemoveNamespace = 0x2,
    EmptyMethodParameterName = 0x4,
    All = Rename | RemoveNamespace | EmptyMethodParameterName
}


================================================
File: src/BitMono.Core/Injection/ModifyInjectTypeClonerListener.cs
================================================
ï»¿namespace BitMono.Core.Injection;

public class ModifyInjectTypeClonerListener : InjectTypeClonerListener
{
    public ModifyInjectTypeClonerListener(ModifyFlags modify, Renamer renamer, ModuleDefinition targetModule) : base(targetModule)
    {
        Modify = modify;
        Renamer = renamer;
    }

    public ModifyFlags Modify { get; }
    public Renamer Renamer { get; }

    public override void OnClonedMember(IMemberDefinition original, IMemberDefinition cloned)
    {
        if (Modify.HasFlag(ModifyFlags.Rename))
        {
            Renamer.Rename(cloned);
        }
        if (Modify.HasFlag(ModifyFlags.RemoveNamespace))
        {
            Renamer.RemoveNamespace(cloned);
        }
        if (Modify.HasFlag(ModifyFlags.EmptyMethodParameterName))
        {
            if (cloned is MethodDefinition method)
            {
                var parameterDefinitions = method.ParameterDefinitions;
                foreach (var parameter in parameterDefinitions)
                {
                    parameter.Name = string.Empty;
                }
            }
        }
        base.OnClonedMember(original, cloned);
    }
}


================================================
File: src/BitMono.Core/Injection/MscrolibInjector.cs
================================================
ï»¿#pragma warning disable CS8602
namespace BitMono.Core.Injection;

public class MscorlibInjector
{
    public static FieldDefinition InjectCompilerGeneratedArray(ModuleDefinition module, TypeDefinition type, byte[] data, string name)
    {
        var importer = module.DefaultImporter;
        var valueType = importer.ImportType(typeof(ValueType));
        var classWithLayout = new TypeDefinition(null, "<>c", TypeAttributes.NestedAssembly | TypeAttributes.Sealed | TypeAttributes.ExplicitLayout, valueType)
        {
            ClassLayout = new ClassLayout(0, (uint)data.Length),
        };
        InjectCompilerGeneratedAttribute(module, classWithLayout);
        type.NestedTypes.Add(classWithLayout);

        var fieldWithRVA = new FieldDefinition("<>c", FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.HasFieldRva, new FieldSignature(classWithLayout.ToTypeSignature()));
        fieldWithRVA.FieldRva = new DataSegment(data);
        classWithLayout.Fields.Add(fieldWithRVA);

        var systemByte = importer.ImportType(module.CorLibTypeFactory.Byte.ToTypeDefOrRef());
        var fieldInjectedArray = new FieldDefinition(name, FieldAttributes.Public | FieldAttributes.Static, new FieldSignature(systemByte.MakeSzArrayType()));
        classWithLayout.Fields.Add(fieldInjectedArray);

        var initializeArrayMethod = importer.ImportMethod(typeof(RuntimeHelpers).GetMethod(nameof(RuntimeHelpers.InitializeArray), new Type[]
        {
            typeof(Array),
            typeof(RuntimeFieldHandle)
        }));

        var cctor = classWithLayout.GetOrCreateStaticConstructor();
        var instructions = cctor.CilMethodBody.Instructions;
        instructions.InsertRange(0, new CilInstruction[]
        {
            new(CilOpCodes.Ldc_I4, data.Length),
            new(CilOpCodes.Newarr, systemByte),
            new(CilOpCodes.Dup),
            new(CilOpCodes.Ldtoken, fieldWithRVA),
            new(CilOpCodes.Call, initializeArrayMethod),
            new(CilOpCodes.Stsfld, fieldInjectedArray),
        });
        return fieldInjectedArray;
    }
    public static TypeDefinition InjectCompilerGeneratedValueType(ModuleDefinition module, TypeDefinition type, string? name = null)
    {
        var result = CreateCompilerGeneratedValueType(module, name);
        type.NestedTypes.Add(result);
        return result;
    }
    public static CustomAttribute InjectCompilerGeneratedAttribute(ModuleDefinition module, IHasCustomAttribute @in)
    {
        var attribute = CreateCompilerGeneratedAttribute(module);
        @in.CustomAttributes.Add(attribute);
        return attribute;
    }
    public static CustomAttribute InjectAttribute(ModuleDefinition module, string @namespace, string name, IHasCustomAttribute @in)
    {
        var attribute = CreateAttribute(module, @namespace, name);
        @in.CustomAttributes.Add(attribute);
        return attribute;
    }
    public static TypeDefinition CreateCompilerGeneratedType(ModuleDefinition module, string? name = null)
    {
        var @object = module.CorLibTypeFactory.Object.ToTypeDefOrRef();
        var invisibleType = new TypeDefinition(null, name ?? "<PrivateImplementationDetails>", TypeAttributes.Public, @object);
        InjectCompilerGeneratedAttribute(module, invisibleType);
        return invisibleType;
    }
    public static TypeDefinition CreateCompilerGeneratedValueType(ModuleDefinition module, string? name = null)
    {
        var valueType = module.DefaultImporter.ImportType(typeof(ValueType));
        var invisibleValueType = new TypeDefinition(null, name ?? "<PrivateImplementationDetails>", TypeAttributes.NestedPublic, valueType);
        InjectCompilerGeneratedAttribute(module, invisibleValueType);
        return invisibleValueType;
    }
    public static CustomAttribute CreateCompilerGeneratedAttribute(ModuleDefinition module)
    {
        var attribute = CreateAttribute(module, typeof(CompilerGeneratedAttribute).Namespace, nameof(CompilerGeneratedAttribute));
        return attribute;
    }
    public static CustomAttribute CreateAttributeWithContent(ModuleDefinition module, string @namespace, string name, string content)
    {
        var factory = module.CorLibTypeFactory;
        var ctor = factory.CorLibScope
            .CreateTypeReference(@namespace, name)
            .CreateMemberReference(".ctor", MethodSignature.CreateInstance(factory.Void, factory.String)
            .ImportWith(module.DefaultImporter));

        var attribute = new CustomAttribute(ctor);
        attribute.Signature.FixedArguments.Add(new CustomAttributeArgument(factory.String, content));
        return attribute;
    }
    public static CustomAttribute CreateAttribute(ModuleDefinition module, string @namespace, string name)
    {
        var factory = module.CorLibTypeFactory;
        var ctor = factory.CorLibScope
            .CreateTypeReference(@namespace, name)
            .CreateMemberReference(".ctor", MethodSignature.CreateInstance(factory.Void))
            .ImportWith(module.DefaultImporter);

        return new CustomAttribute(ctor);
    }
}


================================================
File: src/BitMono.Core/Pipeline/InvokablePipeline.cs
================================================
ï»¿namespace BitMono.Core.Pipeline;

public class InvokablePipeline
{
    public bool Succeed { get; private set; } = true;
    public Func<Task>? OnFail { get; set; }

    public Task InvokeAsync(Action invokeMethod)
    {
        return InvokeInternalAsync(invokeMethod);
    }
    public Task InvokeAsync(Func<bool> invokeMethod)
    {
        return InvokeInternalAsync(invokeMethod);
    }
    public Task InvokeAsync(Func<Task<bool>> invokeMethod)
    {
        return InvokeInternalAsync(invokeMethod);
    }
    public Task InvokeAsync(Func<Task> invokeMethod)
    {
        return InvokeInternalAsync(invokeMethod);
    }

    private async Task InvokeInternalAsync(Delegate invokeMethod)
    {
        if (Succeed == false)
        {
            return;
        }

        Succeed = await InvokeMethodAsync(invokeMethod);
        if (Succeed == false && OnFail != null)
        {
            await OnFail();
        }
    }
    private static async Task<bool> InvokeMethodAsync(Delegate invokeMethod)
    {
        switch (invokeMethod)
        {
            case Action invoke:
                invoke();
                return true;
            case Func<Task<bool>> invoke:
                return await invoke();
            case Func<Task> invoke:
                await invoke();
                return true;
            case Func<bool> invoke:
                return invoke();
            default:
                throw new ArgumentOutOfRangeException(nameof(invokeMethod));
        }
    }
}


================================================
File: src/BitMono.Core/Renaming/Renamer.cs
================================================
ï»¿namespace BitMono.Core.Renaming;

[SuppressMessage("ReSharper", "InvertIf")]
public class Renamer
{
    private readonly NameCriticalAnalyzer _nameCriticalAnalyzer;
    private readonly SpecificNamespaceCriticalAnalyzer _specificNamespaceCriticalAnalyzer;
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly RandomNext _randomNext;

    public Renamer(
        NameCriticalAnalyzer nameCriticalAnalyzer,
        SpecificNamespaceCriticalAnalyzer specificNamespaceCriticalAnalyzer,
        IOptions<ObfuscationSettings> configuration,
        RandomNext randomNext)
    {
        _nameCriticalAnalyzer = nameCriticalAnalyzer;
        _specificNamespaceCriticalAnalyzer = specificNamespaceCriticalAnalyzer;
        _obfuscationSettings = configuration.Value;
        _randomNext = randomNext;
    }

    public string RenameUnsafely()
    {
        var strings = _obfuscationSettings.RandomStrings!;
        var randomStringOne = strings[_randomNext(0, strings.Length - 1)] + " " + strings[_randomNext(0, strings.Length - 1)];
        var randomStringTwo = strings[_randomNext(0, strings.Length - 1)];
        var randomStringThree = strings[_randomNext(0, strings.Length - 1)];
        return $"{randomStringTwo} {randomStringOne}.{randomStringThree}";
    }
    public void Rename(IMetadataMember member)
    {
        if (member is TypeDefinition type)
        {
            if (_nameCriticalAnalyzer.NotCriticalToMakeChanges(type))
            {
                type.Name = RenameUnsafely();
            }
        }
        if (member is MethodDefinition method)
        {
            if (_nameCriticalAnalyzer.NotCriticalToMakeChanges(method))
            {
                method.Name = RenameUnsafely();
            }
        }
        if (member is FieldDefinition field)
        {
            field.Name = RenameUnsafely();
        }
        if (member is ParameterDefinition parameter)
        {
            parameter.Name = RenameUnsafely();
        }
    }
    public void Rename(params IMetadataMember[] members)
    {
        for (var i = 0; i < members.Length; i++)
        {
            Rename(members[i]);
        }
    }
    public void RemoveNamespace(IMetadataMember member)
    {
        if (member is TypeDefinition type)
        {
            if (_specificNamespaceCriticalAnalyzer.NotCriticalToMakeChanges(type))
            {
                type.Namespace = string.Empty;
            }
        }
        if (member is MethodDefinition method)
        {
            if (_nameCriticalAnalyzer.NotCriticalToMakeChanges(method))
            {
                if (method.DeclaringType != null)
                {
                    method.DeclaringType.Namespace = string.Empty;
                }
            }
        }
        if (member is FieldDefinition field)
        {
            if (field.DeclaringType != null)
            {
                field.DeclaringType.Namespace = string.Empty;
            }
        }
    }
    public void RemoveNamespace(params IMetadataMember[] members)
    {
        members.ForEach(RemoveNamespace);
    }
}


================================================
File: src/BitMono.Core/Resolvers/AssemblyResolve.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class AssemblyResolve
{
#pragma warning disable CS8618
    public List<AssemblyReference> ResolvedReferences { get; set; }
    public List<AssemblyReference> FailedToResolveReferences { get; set; }
#pragma warning restore CS8618
    public bool Succeed { get; set; }
}


================================================
File: src/BitMono.Core/Resolvers/AssemblyResolver.cs
================================================
ï»¿#pragma warning disable CS8602
namespace BitMono.Core.Resolvers;

[SuppressMessage("ReSharper", "InvertIf")]
public static class AssemblyResolver
{
    public static AssemblyResolve Resolve(IEnumerable<byte[]> dependenciesData, StarterContext context)
    {
        context.ThrowIfCancellationRequested();

        var resolvedReferences = new List<AssemblyReference>();
        var failedToResolveReferences = new List<AssemblyReference>();
        var signatureComparer = new SignatureComparer(SignatureComparisonFlags.AcceptNewerVersions);

        foreach (var originalReference in context.Module.AssemblyReferences)
        {
            context.ThrowIfCancellationRequested();

            var resolved = false;
            if (context.AssemblyResolver.HasCached(originalReference))
            {
                resolvedReferences.Add(originalReference);
                continue;
            }
            if (failedToResolveReferences.Contains(originalReference) || resolvedReferences.Contains(originalReference))
            {
                continue;
            }

            foreach (var data in dependenciesData)
            {
                context.ThrowIfCancellationRequested();

                try
                {
                    var definition = AssemblyDefinition.FromBytes(data);
                    if (signatureComparer.Equals(originalReference, definition))
                    {
                        context.AssemblyResolver.Resolve(definition);
                        resolvedReferences.Add(originalReference);
                        resolved = true;
                        break;
                    }
                }
                catch (BadImageFormatException)
                {
                    // ignored
                }
                catch (EndOfStreamException)
                {
                    // ignored
                }
            }

            if (resolved == false)
            {
                failedToResolveReferences.Add(originalReference);
            }
        }

        var succeed = failedToResolveReferences.Count == 0;
        return new AssemblyResolve
        {
            ResolvedReferences = resolvedReferences,
            FailedToResolveReferences = failedToResolveReferences,
            Succeed = succeed
        };
    }
}


================================================
File: src/BitMono.Core/Resolvers/AttemptAttributeResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public static class AttemptAttributeResolver
{
    public static bool TryResolve(IHasCustomAttribute from, string @namespace, string name,
        [NotNullWhen(true)] out List<CustomAttributeResolve>? attributesResolve)
    {
        attributesResolve = CustomAttributeResolver.Resolve(from, @namespace, name);
        return attributesResolve.IsNullOrEmpty() == false;
    }
    public static bool TryResolve(IHasCustomAttribute from, string @namespace, string name)
    {
        return TryResolve(from, @namespace, name, out _);
    }
}


================================================
File: src/BitMono.Core/Resolvers/AttributeResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class AttributeResolver<TModel> : IAttributeResolver<TModel> where TModel : class
{
    public virtual bool Resolve(string? featureName, IHasCustomAttribute from, [NotNullWhen(true)] out TModel? model)
    {
        model = default;
        return false;
    }
    public virtual bool Resolve(string? featureName, IHasCustomAttribute from)
    {
        return Resolve(featureName, from, out _);
    }
    public virtual bool Resolve(IHasCustomAttribute from)
    {
        return Resolve(featureName: null, from);
    }
    public virtual bool Resolve(Type featureType, IHasCustomAttribute from)
    {
        return Resolve(featureType.GetName(), from);
    }
    public virtual bool Resolve<TFeature>(IHasCustomAttribute from) where TFeature : IProtection
    {
        return Resolve(typeof(TFeature), from);
    }
}


================================================
File: src/BitMono.Core/Resolvers/CriticalAttributeResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class CriticalAttributeResolver : AttributeResolver<CustomAttributeResolve>
{
    private readonly CriticalsSettings _criticalsSettings;

    public CriticalAttributeResolver(IOptions<CriticalsSettings> criticals)
    {
        _criticalsSettings = criticals.Value;
    }

    public override bool Resolve(string? feature, IHasCustomAttribute from,
        [NotNullWhen(true)] out CustomAttributeResolve? attributeResolve)
    {
        attributeResolve = null;
        if (_criticalsSettings.UseCriticalAttributes == false)
        {
            return false;
        }

        var criticalAttributes = _criticalsSettings.CriticalAttributes;
        foreach (var criticalAttribute in criticalAttributes)
        {
            if (AttemptAttributeResolver.TryResolve(from, criticalAttribute.Namespace, criticalAttribute.Name,
                    out var attributesResolve) == false)
            {
                continue;
            }

            attributeResolve = attributesResolve.First();
            return true;
        }
        return false;
    }
}


================================================
File: src/BitMono.Core/Resolvers/CustomAttributeResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

[SuppressMessage("ReSharper", "ForCanBeConvertedToForeach")]
[SuppressMessage("ReSharper", "InvertIf")]
public static class CustomAttributeResolver
{
    [SuppressMessage("ReSharper", "ReturnTypeCanBeEnumerable.Global")]
    public static List<CustomAttributeResolve> Resolve(IHasCustomAttribute from, string @namespace, string name)
    {
        var attributes = new List<CustomAttributeResolve>();
        var customAttributes = from.CustomAttributes;
        for (var i = 0; i < customAttributes.Count; i++)
        {
            var customAttribute = customAttributes[i];
            if (customAttribute.Constructor?.DeclaringType?.IsTypeOf(@namespace, name) == true)
            {
                if (customAttribute.Signature != null)
                {
                    var namedValues = new Dictionary<string, object>();
                    var fixedValues = new List<object>();
                    var namedArguments = customAttribute.Signature.NamedArguments;
                    for (var j = 0; j < namedArguments.Count; j++)
                    {
                        var namedArgument = namedArguments[j];
                        if (string.IsNullOrWhiteSpace(namedArgument.MemberName?.Value) == false)
                        {
                            if (namedArgument.Argument.Element is Utf8String utf8String)
                            {
                                namedValues.Add(namedArgument.MemberName!.Value, utf8String.Value);
                            }
                            else
                            {
                                if (namedArgument.Argument.Element != null)
                                {
                                    namedValues.Add(namedArgument.MemberName!.Value, namedArgument.Argument.Element);
                                }
                            }
                        }
                    }
                    var fixedArguments = customAttribute.Signature!.FixedArguments;
                    for (var k = 0; k < fixedArguments.Count; k++)
                    {
                        var fixedArgument = fixedArguments[k];
                        if (fixedArgument.Element is Utf8String utf8String)
                        {
                            fixedValues.Add(utf8String.Value);
                        }
                        else
                        {
                            if (fixedArgument.Element != null)
                            {
                                fixedValues.Add(fixedArgument.Element);
                            }
                        }
                    }

                    attributes.Add(new CustomAttributeResolve
                    {
                        NamedValues = namedValues,
                        FixedValues = fixedValues,
                        Attribute = customAttribute
                    });
                }
            }
        }
        return attributes;
    }
}


================================================
File: src/BitMono.Core/Resolvers/DoNotResolveMemberResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class DoNotResolveMemberResolver : IMemberResolver
{
    private readonly RuntimeCriticalAnalyzer _runtimeCriticalAnalyzer;
    private readonly ModelAttributeCriticalAnalyzer _modelAttributeCriticalAnalyzer;
    private readonly ReflectionCriticalAnalyzer _reflectionCriticalAnalyzer;

    public DoNotResolveMemberResolver(
        RuntimeCriticalAnalyzer runtimeCriticalAnalyzer,
        ModelAttributeCriticalAnalyzer modelAttributeCriticalAnalyzer,
        ReflectionCriticalAnalyzer reflectionCriticalAnalyzer)
    {
        _runtimeCriticalAnalyzer = runtimeCriticalAnalyzer;
        _modelAttributeCriticalAnalyzer = modelAttributeCriticalAnalyzer;
        _reflectionCriticalAnalyzer = reflectionCriticalAnalyzer;
    }

    public bool Resolve(IProtection protection, IMetadataMember member)
    {
        if (protection.TryGetDoNotResolveAttribute(out var doNotResolveAttribute) == false)
        {
            return true;
        }
        if (doNotResolveAttribute!.MemberInclusion.HasFlag(MemberInclusionFlags.SpecialRuntime))
        {
            if (_runtimeCriticalAnalyzer.NotCriticalToMakeChanges(member) == false)
            {
                return false;
            }
        }
        if (member is IHasCustomAttribute customAttribute)
        {
            if (doNotResolveAttribute.MemberInclusion.HasFlag(MemberInclusionFlags.Model))
            {
                if (_modelAttributeCriticalAnalyzer.NotCriticalToMakeChanges(customAttribute) == false)
                {
                    return false;
                }
            }
        }
        if (member is MethodDefinition method)
        {
            if (doNotResolveAttribute.MemberInclusion.HasFlag(MemberInclusionFlags.Reflection))
            {
                if (_reflectionCriticalAnalyzer.NotCriticalToMakeChanges(method) == false)
                {
                    return false;
                }
            }
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Resolvers/MembersResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public static class MembersResolver
{
    public static IEnumerable<IMetadataMember> Resolve(IProtection protection, IEnumerable<IMetadataMember> members,
        IEnumerable<IMemberResolver> resolvers)
    {
        return members.Where(member => CanBeResolved(protection, member, resolvers));
    }
    private static bool CanBeResolved(IProtection protection, IMetadataMember member,
        IEnumerable<IMemberResolver> resolvers)
    {
        return resolvers.All(m => m.Resolve(protection, member));
    }
}


================================================
File: src/BitMono.Core/Resolvers/NoInliningMethodMemberResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class NoInliningMethodMemberResolver : IMemberResolver
{
    private readonly ObfuscationSettings _obfuscationSettings;

    public NoInliningMethodMemberResolver(IOptions<ObfuscationSettings> obfuscation)
    {
        _obfuscationSettings = obfuscation.Value;
    }

    public bool Resolve(IProtection? protection, IMetadataMember member)
    {
        if (_obfuscationSettings.NoInliningMethodObfuscationExclude == false)
        {
            return true;
        }
        if (member is MethodDefinition method)
        {
            if (method.NoInlining)
            {
                return false;
            }
        }
        return true;
    }
}



================================================
File: src/BitMono.Core/Resolvers/ObfuscateAssemblyAttributeData.cs
================================================
namespace BitMono.Core.Resolvers;

public class ObfuscateAssemblyAttributeData
{
    public ObfuscateAssemblyAttributeData()
    {
    }
    public ObfuscateAssemblyAttributeData(bool assemblyIsPrivate, bool stripAfterObfuscation,
        CustomAttribute? customAttribute)
    {
        AssemblyIsPrivate = assemblyIsPrivate;
        StripAfterObfuscation = stripAfterObfuscation;
        CustomAttribute = customAttribute;
    }

    public bool AssemblyIsPrivate { get; set; }
    public bool StripAfterObfuscation { get; set; }
    public CustomAttribute? CustomAttribute { get; set; }
}


================================================
File: src/BitMono.Core/Resolvers/ObfuscateAssemblyAttributeResolver.cs
================================================
namespace BitMono.Core.Resolvers;

public class ObfuscateAssemblyAttributeResolver : AttributeResolver<ObfuscateAssemblyAttributeData>
{
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly string _attributeNamespace;
    private readonly string _attributeName;

    public ObfuscateAssemblyAttributeResolver(IOptions<ObfuscationSettings> configuration)
    {
        _obfuscationSettings = configuration.Value;
        _attributeNamespace = typeof(ObfuscateAssemblyAttribute).Namespace!;
        _attributeName = nameof(ObfuscateAssemblyAttribute);
    }

    public override bool Resolve(string? feature, IHasCustomAttribute from, [NotNullWhen(true)] out ObfuscateAssemblyAttributeData? model)
    {
        model = null;
        if (_obfuscationSettings.ObfuscateAssemblyAttributeObfuscationExclude == false)
        {
            return false;
        }
        if (AttemptAttributeResolver.TryResolve(from, _attributeNamespace,
                _attributeName, out var attributesResolve) == false)
        {
            return false;
        }
        var attribute = attributesResolve.First();
        var namedValues = attribute.NamedValues;
        if (namedValues == null)
        {
            return false;
        }
        var fixedValues = attribute.FixedValues;
        if (fixedValues == null || fixedValues.Count == 0)
        {
            return false;
        }
        if (fixedValues.ElementAtOrDefault(0) is not bool assemblyIsPrivate)
        {
            return false;
        }

        var stripAfterObfuscation =
            namedValues.GetValueOrDefault(nameof(ObfuscateAssemblyAttribute.StripAfterObfuscation),
                defaultValue: true);
        model = new ObfuscateAssemblyAttributeData(assemblyIsPrivate, stripAfterObfuscation, attribute.Attribute);
        return true;
    }
}


================================================
File: src/BitMono.Core/Resolvers/ObfuscationAttributeData.cs
================================================
namespace BitMono.Core.Resolvers;

public class ObfuscationAttributeData
{
    public bool ApplyToMembers { get; set; }
    public bool Exclude { get; set; }
    public bool StripAfterObfuscation { get; set; }
    public string Feature { get; set; }
    public CustomAttribute? CustomAttribute { get; set; }
}


================================================
File: src/BitMono.Core/Resolvers/ObfuscationAttributeResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class ObfuscationAttributeResolver : AttributeResolver<IReadOnlyList<ObfuscationAttributeData>>
{
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly string _attributeNamespace;
    private readonly string _attributeName;

    public ObfuscationAttributeResolver(IOptions<ObfuscationSettings> configuration)
    {
        _obfuscationSettings = configuration.Value;
        _attributeNamespace = typeof(ObfuscationAttribute).Namespace!;
        _attributeName = nameof(ObfuscationAttribute);
    }

    public override bool Resolve(string? featureName, IHasCustomAttribute from, [NotNullWhen(true)] out IReadOnlyList<ObfuscationAttributeData>? model)
    {
        model = null;
        if (_obfuscationSettings.ObfuscationAttributeObfuscationExclude == false)
        {
            return false;
        }
        if (AttemptAttributeResolver.TryResolve(from, _attributeNamespace, _attributeName,
                out var attributesResolve) == false)
        {
            return false;
        }

        var attributes = new List<ObfuscationAttributeData>();
        foreach (var attribute in attributesResolve)
        {
            var namedValues = attribute.NamedValues;
            if (namedValues == null)
            {
                continue;
            }
            if (namedValues.TryGetTypedValue(nameof(ObfuscationAttribute.Feature), out string? feature) == false)
            {
                continue;
            }
            if (feature.Equals(featureName, StringComparison.OrdinalIgnoreCase) == false)
            {
                continue;
            }

            var exclude =
                namedValues.GetValueOrDefault(nameof(ObfuscationAttribute.Exclude),
                    defaultValue: true);
            var applyToMembers =
                namedValues.GetValueOrDefault(nameof(ObfuscationAttribute.Exclude),
                    defaultValue: true);
            var stripAfterObfuscation =
                namedValues.GetValueOrDefault(nameof(ObfuscationAttribute.StripAfterObfuscation),
                    defaultValue: true);

            attributes.Add(new ObfuscationAttributeData
            {
                Exclude = exclude,
                ApplyToMembers = applyToMembers,
                StripAfterObfuscation = stripAfterObfuscation,
                Feature = feature,
                CustomAttribute = attribute.Attribute
            });
        }
        model = attributes;
        return true;
    }
}


================================================
File: src/BitMono.Core/Resolvers/ProtectionsResolve.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class ProtectionsResolve
{
#pragma warning disable CS8618
    public List<IProtection> FoundProtections { get; set; }
    public List<string> DisabledProtections { get; set; }
    public List<string> UnknownProtections { get; set; }
#pragma warning restore CS8618
}


================================================
File: src/BitMono.Core/Resolvers/ProtectionsResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class ProtectionsResolver
{
    private readonly List<IProtection> _protections;
    private readonly IEnumerable<ProtectionSetting> _protectionSettings;

    public ProtectionsResolver(List<IProtection> protections, IEnumerable<ProtectionSetting> protectionSettings)
    {
        _protections = protections;
        _protectionSettings = protectionSettings;
    }

    public ProtectionsResolve Sort()
    {
        var foundProtections = new List<IProtection>();
        var cachedProtections = _protections.ToArray().ToList();
        var unknownProtections = new List<string>();
        foreach (var protectionSettings in _protectionSettings.Where(x => x.Enabled))
        {
            var protection = cachedProtections.FirstOrDefault(x =>
                x.GetName().Equals(protectionSettings.Name, StringComparison.OrdinalIgnoreCase));
            if (protection != null)
            {
                foundProtections.Add(protection);
                cachedProtections.Remove(protection);
            }
            else
            {
                unknownProtections.Add(protectionSettings.Name);
            }
        }
        var disabledProtections = cachedProtections
            .Select(x => x.GetName())
            .ToList();
        return new ProtectionsResolve
        {
            FoundProtections = foundProtections,
            DisabledProtections = disabledProtections,
            UnknownProtections = unknownProtections
        };
    }
}


================================================
File: src/BitMono.Core/Resolvers/SafeToMakeChangesMemberResolver.cs
================================================
ï»¿namespace BitMono.Core.Resolvers;

public class SafeToMakeChangesMemberResolver : IMemberResolver
{
    private readonly ObfuscationAttributeResolver _obfuscationAttributeResolver;
    private readonly ObfuscateAssemblyAttributeResolver _obfuscateAssemblyAttributeResolver;
    private readonly CriticalAttributeResolver _criticalAttributeResolver;
    private readonly SerializableBitCriticalAnalyzer _serializableBitCriticalAnalyzer;
    private readonly SpecificNamespaceCriticalAnalyzer _specificNamespaceCriticalAnalyzer;

    public SafeToMakeChangesMemberResolver(
        ObfuscationAttributeResolver obfuscationAttributeResolver,
        ObfuscateAssemblyAttributeResolver obfuscateAssemblyAttributeResolver,
        CriticalAttributeResolver criticalAttributeResolver,
        SerializableBitCriticalAnalyzer serializableBitCriticalAnalyzer,
        SpecificNamespaceCriticalAnalyzer specificNamespaceCriticalAnalyzer)
    {
        _obfuscationAttributeResolver = obfuscationAttributeResolver;
        _obfuscateAssemblyAttributeResolver = obfuscateAssemblyAttributeResolver;
        _criticalAttributeResolver = criticalAttributeResolver;
        _serializableBitCriticalAnalyzer = serializableBitCriticalAnalyzer;
        _specificNamespaceCriticalAnalyzer = specificNamespaceCriticalAnalyzer;
    }

    public bool Resolve(IProtection protection, IMetadataMember member)
    {
        if (member is IHasCustomAttribute customAttribute)
        {
            var feature = protection.GetName();
            if (_obfuscationAttributeResolver.Resolve(feature, customAttribute, out var obfuscationAttributes)
                && obfuscationAttributes.Any(x => x.Exclude))
            {
                return false;
            }
            if (_obfuscateAssemblyAttributeResolver.Resolve(null, customAttribute, out var obfuscateAssemblyAttributeData)
                && obfuscateAssemblyAttributeData!.AssemblyIsPrivate)
            {
                return false;
            }
            if (_criticalAttributeResolver.Resolve(feature, customAttribute))
            {
                return false;
            }
        }
        if (member is TypeDefinition type)
        {
            if (_serializableBitCriticalAnalyzer.NotCriticalToMakeChanges(type) == false)
            {
                return false;
            }
        }
        if (_specificNamespaceCriticalAnalyzer.NotCriticalToMakeChanges(member) == false)
        {
            return false;
        }
        return true;
    }
}


================================================
File: src/BitMono.Core/Services/EngineContextAccessor.cs
================================================
ï»¿namespace BitMono.Core.Services;

public class EngineContextAccessor : IEngineContextAccessor
{
    public StarterContext Instance { get; set; }
}


================================================
File: src/BitMono.Core/Services/IEngineContextAccessor.cs
================================================
namespace BitMono.Core.Services;

public interface IEngineContextAccessor
{
    StarterContext Instance { get; set; }
}


================================================
File: src/BitMono.Core/Services/RandomNext.cs
================================================
namespace BitMono.Core.Services;

public delegate int RandomNext(int minValue, int maxValue);


================================================
File: src/BitMono.Core/Services/RandomService.cs
================================================
namespace BitMono.Core.Services;

public static class RandomService
{
    private static readonly Random Random = new Random();

    public static int RandomNext(int minValue, int maxValue)
    {
        return Random.Next(minValue, maxValue);
    }
}


================================================
File: src/BitMono.GlobalTool/BitMono.GlobalTool.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0</TargetFrameworks>
    <PackAsTool>true</PackAsTool>
    <ToolCommandName>bitmono.console</ToolCommandName>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props"/>

  <ItemGroup>
    <Compile Include="..\BitMono.CLI\Modules\Options.cs">
      <Link>Modules/Options.cs</Link>
    </Compile>
    <Compile Include="..\BitMono.CLI\Modules\ObfuscationNeeds.cs">
      <Link>Modules/ObfuscationNeeds.cs</Link>
    </Compile>
    <Compile Include="..\BitMono.CLI\Modules\LoggerConfiguratorExtensions.cs">
      <Link>Modules\LoggerConfiguratorExtensions.cs</Link>
    </Compile>
    <Compile Include="..\BitMono.CLI\Modules\OptionsObfuscationNeedsFactory.cs">
      <Link>Modules\OptionsObfuscationNeedsFactory.cs</Link>
    </Compile>
    <Compile Include="..\BitMono.CLI\KnownReturnStatuses.cs">
      <Link>KnownReturnStatuses.cs</Link>
    </Compile>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\BitMono.API\BitMono.API.csproj"/>
    <ProjectReference Include="..\BitMono.Host\BitMono.Host.csproj"/>
    <ProjectReference Include="..\BitMono.Obfuscation\BitMono.Obfuscation.csproj"/>
    <ProjectReference Include="..\BitMono.Protections\BitMono.Protections.csproj"/>
    <ProjectReference Include="..\BitMono.Runtime\BitMono.Runtime.csproj"/>
    <ProjectReference Include="..\BitMono.Shared\BitMono.Shared.csproj"/>
    <ProjectReference Include="..\BitMono.Utilities\BitMono.Utilities.csproj"/>
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="CommandLineParser" Version="2.9.1"/>
    <PackageReference Include="Costura.Fody" Version="6.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="NullGuard.Fody" Version="3.1.1"/>
  </ItemGroup>

</Project>


================================================
File: src/BitMono.GlobalTool/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <NullGuard />
  <Costura />
</Weavers>


================================================
File: src/BitMono.GlobalTool/GlobalUsings.cs
================================================
ï»¿global using Autofac;
global using BitMono.CLI.Modules;
global using BitMono.Host;
global using BitMono.CLI;
global using BitMono.Host.Modules;
global using BitMono.Obfuscation;
global using System;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.IO;
global using System.Threading;
global using System.Threading.Tasks;
global using BitMono.Host.Extensions;
global using BitMono.Obfuscation.Files;
global using BitMono.Obfuscation.Starter;
global using BitMono.Shared.Models;
global using BitMono.Utilities.Paths;
global using CommandLine;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Options;
global using Pocket.Extensions;
global using Serilog;
global using Serilog.Configuration;
global using ILogger = Serilog.ILogger;


================================================
File: src/BitMono.GlobalTool/Program.cs
================================================
ï»¿namespace BitMono.GlobalTool;

internal class Program
{
    private static readonly CancellationTokenSource CancellationTokenSource = new();
    private static CancellationToken CancellationToken => CancellationTokenSource.Token;
    private static readonly string BitMonoFileVersionText =
        $"BitMono v{FileVersionInfo.GetVersionInfo(typeof(Program).Assembly.Location).FileVersion}";
    private static readonly string AsciiArt = $"""

                                                      ___  _ __  __  ___
                                                     / _ )(_) /_/  |/  /__  ___  ___
                                                    / _  / / __/ /|_/ / _ \/ _ \/ _ \
                                                   /____/_/\__/_/  /_/\___/_//_/\___/
                                                   https://github.com/sunnamed434/BitMono
                                                   {BitMonoFileVersionText}
                                               """;

    private static async Task<int> Main(string[] args)
    {
        Console.CancelKeyPress += OnCancelKeyPress;
        var statusCode = KnownReturnStatuses.Success;
        try
        {
            Console.Title = BitMonoFileVersionText;
            var module = new BitMonoModule(
                configureContainer => configureContainer.AddProtections(),
                configureServices => configureServices.AddConfigurations(),
                configureLogger => configureLogger.WriteTo.AddConsoleLogger());

            var app = new BitMonoApplication().RegisterModule(module);
            await using var serviceProvider = await app.BuildAsync(CancellationToken);

            var obfuscation = serviceProvider.GetRequiredService<IOptions<ObfuscationSettings>>().Value;
            var logger = serviceProvider
                .GetRequiredService<ILogger>()
                .ForContext<Program>();
            var needs = new OptionsObfuscationNeedsFactory(args, obfuscation, logger).Create(CancellationToken);
            if (needs == null)
            {
                statusCode = KnownReturnStatuses.Failure;
                return statusCode;
            }

            CancellationToken.ThrowIfCancellationRequested();

            if (obfuscation.ClearCLI)
            {
                Console.Clear();
            }
            logger.Information("File: {0}", needs.FileName);
            logger.Information("Dependencies (libs): {0}", needs.ReferencesDirectoryName);
            logger.Information("Everything is seems to be ok, starting obfuscation..");
            logger.Information(AsciiArt);

            var info = new IncompleteFileInfo(needs.FileName, needs.ReferencesDirectoryName, needs.OutputPath);
            var engine = new BitMonoStarter(serviceProvider);
            var succeed = await engine.StartAsync(info, CancellationToken);
            if (!succeed)
            {
                logger.Fatal("Engine has fatal issues, unable to continue!");
                statusCode = KnownReturnStatuses.Failure;
                return statusCode;
            }

            if (obfuscation.OpenFileDestinationInFileExplorer)
            {
                try
                {
                    Process.Start(needs.OutputPath);
                }
                catch (Exception ex)
                {
                    logger.Error(ex, "An error occured while opening the destination file in explorer!");
                }
            }
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("Obfuscation Canceled!");
            statusCode = KnownReturnStatuses.Failure;
        }
        catch (Exception ex)
        {
            Console.WriteLine("Something went wrong! " + ex);
            statusCode = KnownReturnStatuses.Failure;
        }

        Console.CancelKeyPress -= OnCancelKeyPress;

        return statusCode;
    }

    private static void OnCancelKeyPress(object? sender, ConsoleCancelEventArgs e)
    {
        CancellationTokenSource.Cancel();
        e.Cancel = true;
    }
}


================================================
File: src/BitMono.GlobalTool/.config/dotnet-tools.json
================================================
{
  "version": 1,
  "isRoot": true,
  "tools": {}
}


================================================
File: src/BitMono.Host/BitMono.Host.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props" />

  <ItemGroup>
    <ProjectReference Include="..\BitMono.API\BitMono.API.csproj" />
    <ProjectReference Include="..\BitMono.Core\BitMono.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="NullGuard.Fody" Version="3.1.1" PrivateAssets="All" />
  </ItemGroup>

  <ItemGroup>
    <None Update="criticals.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Update="obfuscation.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Update="protections.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Update="logging.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>


================================================
File: src/BitMono.Host/BitMonoApplication.cs
================================================
ï»¿namespace BitMono.Host;

public class BitMonoApplication : IApplication
{
    private readonly ContainerBuilder _containerBuilder;
    private readonly List<IModule> _modules;

    public BitMonoApplication()
    {
        _containerBuilder = new ContainerBuilder();
        _modules = [];
    }

    public IApplication Populate(IEnumerable<ServiceDescriptor> descriptors)
    {
        _containerBuilder.Populate(descriptors);
        return this;
    }
    public IApplication RegisterModule(IModule module)
    {
        _modules.Add(module);
        return this;
    }
    public Task<AutofacServiceProvider> BuildAsync(CancellationToken cancellationToken)
    {
        foreach (var module in _modules)
        {
            cancellationToken.ThrowIfCancellationRequested();

            _containerBuilder.RegisterModule(module);
        }
        var container = _containerBuilder.Build();
        var provider = new AutofacServiceProvider(container.Resolve<ILifetimeScope>());
        return Task.FromResult(provider);
    }
}


================================================
File: src/BitMono.Host/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <NullGuard />
</Weavers>


================================================
File: src/BitMono.Host/GlobalUsings.cs
================================================
ï»¿global using Autofac;
global using Autofac.Core;
global using Autofac.Extensions.DependencyInjection;
global using BitMono.API.Configuration;
global using BitMono.Host.Configurations;
global using Microsoft.Extensions.Configuration;
global using Microsoft.Extensions.DependencyInjection;
global using Serilog;
global using System;
global using System.Collections.Generic;
global using System.Diagnostics.CodeAnalysis;
global using System.IO;
global using System.Reflection;
global using System.Text.RegularExpressions;
global using System.Threading;
global using System.Threading.Tasks;
global using BitMono.API;
global using BitMono.API.Analyzing;
global using BitMono.API.Protections;
global using BitMono.API.Resolvers;
global using BitMono.Core.Configuration;
global using BitMono.Core.Factories;
global using BitMono.Core.Renaming;
global using BitMono.Core.Resolvers;
global using BitMono.Core.Services;
global using BitMono.Host.Ioc;
global using BitMono.Shared.Models;
global using Serilog.Enrichers.Sensitive;
global using Module = Autofac.Module;


================================================
File: src/BitMono.Host/criticals.json
================================================
ï»¿{
  // DO NOT write here all of your methods/things because if you rename them in VS/Rider/VS Code (eg, with hotkey CTRL + R + R/without hotkey, doesn't matter)
  // whatever else, they're not will be changed here as well.
  // This is not for complex things, just write here your critical things - it means: for example, imagine Unity there are a lot of methods
  // which doesn't even have an 'override' i.e 'override void Update()' (which is called every tick) - just void Update(), in such cases these methods
  // shouldn't be renamed because this is like const things for Unity, and they're very important,
  // for complex things use [ObfuscationAttribute(Feature = "ProtectionName")],
  // but if you don't have plans with the mess in your code, and you don't really have plans in near future to rename these critical things it can be done then.

  // Exclude from obfuscation if the member has attribute
  // Set to true indicates whether enabled
  "UseCriticalAttributes": true,
  "CriticalAttributes": [
    // Unity
    {
      "Namespace": "UnityEngine",
      "Name": "SerializeField"
    },

    // "Magic name" attributes, please use instead special library if you need to add features from newer C# versions in older
    // eg add record types, or "magic name" attributes, etc
    // special library: https://github.com/Sergio0694/PolySharp (In Mono works fine)
    {
      "Namespace": "System.Runtime.CompilerServices",
      "Name": "ModuleInitializerAttribute"
    }

  ],

  // Exclude from obfuscation if the Model (type, i.e class) has [Serializable]/[JsonProperty], etc, attributes
  // Set to true indicates whether enabled
  "UseCriticalModelAttributes": true,
  "CriticalModelAttributes": [
    {
      "Namespace": "System",
      "Name": "SerializableAttribute"
    },
    {
      "Namespace": "System.Xml.Serialization",
      "Name": "XmlAttributeAttribute"
    },
    {
      "Namespace": "System.Xml.Serialization",
      "Name": "XmlArrayItemAttribute"
    },
    {
      "Namespace": "Newtonsoft.Json",
      "Name": "JsonPropertyAttribute"
    }

  ],

  // Exclude from obfuscation if the type inherited specific interface
  // Set to true indicates whether enabled
  "UseCriticalInterfaces": true,
  "CriticalInterfaces": [
    // RocketMod
    "IRocketPlugin",
    "IRocketCommand",
    "IRocketPluginConfiguration",
    "IDefaultable",

    // OpenMod
    "IOpenModPlugin"

  ],

  // Exclude from obfuscation if the type inherited specific base type
  // Set to true indicates whether enabled
  "UseCriticalBaseTypes": true,
  "CriticalBaseTypes": [
    // RocketMod
    "RocketPlugin",

    // OpenMod
    "OpenModUnturnedPlugin",
    "OpenModUniversalPlugin",
    "Command",

    // rust-oxide-umod
    "RustPlugin"

  ],

  // Exclude from obfuscation if the member starts with string
  // Set to true indicates whether enabled
  "UseCriticalMethodsStartsWith": true,
  "CriticalMethodsStartsWith": [
    // More known and used in Thanking cheats for Unturned, "overrides"
    "OV_",
  ],

  // Exclude from obfuscation method by name
  // Set to true indicates whether enabled
  "UseCriticalMethods": true,
  "CriticalMethods": [
    // Unity
    "Awake",
    "OnEnable",
    "Reset",
    "Start",
    "FixedUpdate",
    "OnMouseUp",
    "OnMouseEnter",
    "OnMouseExit",
    "OnMouseOver",
    "OnMouseUpAsButton",
    "OnMouseDown",
    "OnMouseDrag",
    "Update",
    "LateUpdate",
    "OnAnimatorIK",
    "OnPreCull",
    "OnWillRenderObject",
    "OnBecameVisible",
    "OnBecameInvisible",
    "OnPreRender",
    "OnRenderObject",
    "OnDrawGizmos",
    "OnGUI",
    "OnTriggerEnter",
    "OnTriggerStay",
    "OnTriggerExit",
    "OnTriggerEnter2D",
    "OnTriggerStay2D",
    "OnTriggerExit2D",
    "OnCollisionEnter",
    "OnCollisionStay",
    "OnCollisionExit",
    "OnCollisionEnter2D",
    "OnCollisionStay2D",
    "OnCollisionExit2D",
    "WaitForEndOfFrame",
    "OnApplicationPause",
    "OnApplicationQuit",
    "OnDisable",
    "OnDestroy"

  ]
}


================================================
File: src/BitMono.Host/logging.json
================================================
{
    "Serilog": {
        "Using": [
            "Serilog",
            "Serilog.Sinks.Console",
            "Serilog.Sinks.File",
            "Serilog.Sinks.Async",
            "Serilog.Enrichers.Sensitive"
        ],
        "WriteTo": [
            {
                "Name": "Async",
                "Args": {
                    "configure": [
                        {
                            "Name": "File",
                            "Args": {
                                "path": "logs/bitmono-{{date}}.log",
                                "outputTemplate": "[{Timestamp:yyyy-MM-dd HH:mm:ss} {Level:u3}][{SourceContext}] {Message:lj}{NewLine}{Exception}"
                            }
                        }
                    ]
                }
            }
        ],
        "Enrich": [
            {
                "Name": "WithSensitiveDataMasking",
                "Args": {
                    "options": {
                        "MaskValue": "***\\",
                        "MaskProperties": [ "path", "directory", "file" ],
                        "MaskingOperators": [ "BitMono.Host.Extensions.PathMaskingOperator, BitMono.Host" ]
                    }
                }
            },

            "FromLogContext"
        ],
        "MinimumLevel": "Debug"
    }
}


================================================
File: src/BitMono.Host/obfuscation.json
================================================
{
  // Adds visible things that show you have been using BitMono
  // Set to true indicates whether enabled
  "Watermark": true,

  // Clear the CLI on obfuscation start or not
  // Set to true indicates whether enabled
  "ClearCLI": false,

  // Don't ask the Output directory, and take the references folder as folder where specified file for obfuscation is located.
  // In simple words, the BitMono will use File Base Directory for output/references, etc
  // Set to true indicates whether enabled
  "ForceObfuscation": false,

  // Name of the references directory
  "ReferencesDirectoryName": "libs",

  // Name of the output directory
  "OutputDirectoryName": "output",

  // Outputs information about protections (Enabled protections, disabled, deprecated, unknown, etc)
  // Set to true indicates whether enabled
  "NotifyProtections": true,

  // Exclude from obfuscation if method has [MethodImpl(MethodImplOptions.NoInlining)] attribute or NoInlining bit
  // Set to true indicates whether enabled
  "NoInliningMethodObfuscationExclude": true,

  // Exclude from obfuscation if type/method has [ObfuscationAttribute(..)]
  // should have an [Obfuscation(Feature = "Name")] attribute with Protection name known as Feature
  // Set to true indicates whether enabled
  "ObfuscationAttributeObfuscationExclude": true,

  // Exclude from obfuscation if assembly has [ObfuscateAssemblyAttribute(true)]
  // Set to true indicates whether enabled
  "ObfuscateAssemblyAttributeObfuscationExclude": true,

  // Exclude from obfuscation if member name used by:
  // Type.GetMethod, Type.GetField, Type.GetProperty, Type.GetEvent, Type.GetMember
  // Set to true indicates whether enabled
  "ReflectionMembersObfuscationExclude": true,

  // Strip attribute after obfuscation if assembly has [ObfuscateAssemblyAttribute(true, StripAfterObfuscation = true)]
  // or member has [Obfuscation(Feature = "Some_BitMono_Feature", StripAfterObfuscation = true]
  // By default, you could just specify [Obfuscation(Feature = "Some_BitMono_Feature"] - and this will strip it
  // (StripAfterObfuscation is true by default in dotnet sources), the same with ObfuscateAssemblyAttribute
  // Set to true indicates whether enabled
  "StripObfuscationAttributes": true,

  // Output errors that were registered while building the PE image. BitMono feature is that
  // being used vulnerabilities of decompilers and Mono and this is the most powerful of them,
  // decompilers and other tools could think that this is cannot work fine and because of that some weird errors
  // can be outputted
  // Set to true indicates whether enabled
  "OutputPEImageBuildErrors": true,

  // Sometimes when you don't have needed dependency for your app, a tons of reasons could be for that,
  // if you got an error that says you don't have needed dependency first of all at least try to add this dependency
  // otherwise if this is deprecated - you can set this as false to ignore error and continue obfuscation
  // NB! but be aware of kind a weird errors and issues that breaking you app, and it stops working after that
  // If this is Unity go to your game path (eg, steam), open-up the directory and search for Managed directory xxx_Data\Managed,
  // Copy asked libraries from there and feed them to BitMono
  // Stay it true to stay enabled if this is possible!
  "FailOnNoRequiredDependency": false,

  // Output warnings saying that protection is intended for specific runtime
  // Set to true indicates whether enabled
  "OutputRuntimeMonikerWarnings": true,

  // Output warnings saying that protection is requires native code configuration
  // Set to true indicates whether enabled
  "OutputConfigureForNativeCodeWarnings": true,

  // Opens directory with protected file in file explorer in top of the screen, if set to true
  "OpenFileDestinationInFileExplorer": false,

  // Set to true to enable, in cases when you want to obfuscate only the specific namespace(s)
  "SpecificNamespacesObfuscationOnly": false,
  "SpecificNamespaces": [
    "Scripts.API",
    "Utilities"
  ],

  // Random strings for Renamer or for such other things
  "RandomStrings": [
    "HasPermission",
    "HasPermissions",
    "GetPermissions",
    "GetOpenWindows",
    "EnumWindows",
    "GetWindowText",
    "GetWindowTextLength",
    "IsWindowVisible",
    "GetShellWindow",
    "Awake",
    "FixedUpdate",
    "add_OnRockedInitialized",
    "remove_OnRockedInitialized",
    "Awake",
    "Initialize",
    "Translate",
    "Reload",
    "<Initialize>b__13_0",
    "Initialize",
    "FixedUpdate",
    "Start",
    "checkTimerRestart",
    "QueueOnMainThread",
    "QueueOnMainThread",
    "RunAsync",
    "RunAction",
    "Awake",
    "FixedUpdate",
    "IsUri",
    "GetTypes",
    "GetTypesFromParentClass",
    "GetTypesFromParentClass",
    "GetTypesFromInterface",
    "GetTypesFromInterface",
    "get_Timeout",
    "set_Timeout",
    "GetWebRequest",
    "get_SteamID64",
    "set_SteamID64",
    "get_SteamID",
    "set_SteamID",
    "get_OnlineState",
    "set_OnlineState",
    "get_StateMessage",
    "set_StateMessage",
    "get_PrivacyState",
    "set_PrivacyState",
    "get_VisibilityState",
    "set_VisibilityState",
    "get_AvatarIcon",
    "set_AvatarIcon",
    "get_AvatarMedium",
    "set_AvatarMedium",
    "get_AvatarFull",
    "set_AvatarFull",
    "get_IsVacBanned",
    "set_IsVacBanned",
    "get_TradeBanState",
    "set_TradeBanState",
    "get_IsLimitedAccount",
    "set_IsLimitedAccount",
    "get_CustomURL",
    "set_CustomURL",
    "get_MemberSince",
    "set_MemberSince",
    "get_HoursPlayedLastTwoWeeks",
    "set_HoursPlayedLastTwoWeeks",
    "get_Headline",
    "set_Headline",
    "get_Location",
    "set_Location",
    "get_RealName",
    "set_RealName",
    "get_Summary",
    "set_Summary",
    "get_MostPlayedGames",
    "set_MostPlayedGames",
    "get_Groups",
    "set_Groups",
    "Reload",
    "ParseString",
    "ParseDateTime",
    "ParseDouble",
    "ParseUInt16",
    "ParseUInt32",
    "ParseUInt64",
    "ParseBool",
    "ParseUri",
    "IsValidCSteamID",
    "LoadDefaults",
    "LoadDefaults",
    "get_Clients",
    "Awake",
    "handleConnection",
    "FixedUpdate",
    "Broadcast",
    "OnDestroy",
    "Read",
    "Send",
    "<Awake>b__8_0",
    "get_InstanceID",
    "set_InstanceID",
    "get_ConnectedTime",
    "set_ConnectedTime",
    "Send",
    "Read",
    "Close",
    "get_Address",
    "get_Instance",
    "set_Instance",
    "Save",
    "Load",
    "Unload",
    "Load",
    "Save",
    "Load",
    "get_Configuration",
    "LoadPlugin",
    "<.ctor>b__3_0",
    "<LoadPlugin>b__4_0",
    "add_OnPluginUnloading",
    "remove_OnPluginUnloading",
    "add_OnPluginLoading",
    "remove_OnPluginLoading",
    "get_Translations",
    "get_State",
    "get_Assembly",
    "set_Assembly",
    "get_Directory",
    "set_Directory",
    "get_Name",
    "set_Name",
    "get_DefaultTranslations",
    "IsDependencyLoaded",
    "ExecuteDependencyCode",
    "Translate",
    "ReloadPlugin",
    "LoadPlugin",
    "UnloadPlugin",
    "OnEnable",
    "OnDisable",
    "Load",
    "Unload",
    "TryAddComponent",
    "TryRemoveComponent",
    "add_OnPluginsLoaded",
    "remove_OnPluginsLoaded",
    "get_Plugins",
    "GetPlugins",
    "GetPlugin",
    "GetPlugin",
    "Awake",
    "Start",
    "GetMainTypeFromAssembly",
    "loadPlugins",
    "unloadPlugins",
    "Reload",
    "GetAssembliesFromDirectory",
    "LoadAssembliesFromDirectory",
    "<Awake>b__12_0",
    "GetGroupsByIds",
    "GetParentGroups",
    "HasPermission",
    "GetGroup",
    "RemovePlayerFromGroup",
    "AddPlayerToGroup",
    "DeleteGroup",
    "SaveGroup",
    "AddGroup",
    "GetGroups",
    "GetPermissions",
    "GetPermissions",
    "<GetGroups>b__11_3",
    "Start",
    "FixedUpdate",
    "Reload",
    "HasPermission",
    "GetGroups",
    "GetPermissions",
    "GetPermissions",
    "AddPlayerToGroup",
    "RemovePlayerFromGroup",
    "GetGroup",
    "SaveGroup",
    "AddGroup",
    "DeleteGroup",
    "DeleteGroup",
    "<FixedUpdate>b__4_0",
    "Enqueue",
    "_Logger_DoWork",
    "processLog",
    "Log",
    "Log",
    "var_dump",
    "LogWarning",
    "LogError",
    "LogError",
    "Log",
    "LogException",
    "ProcessInternalLog",
    "logRCON",
    "writeToConsole",
    "ProcessLog",
    "ExternalLog",
    "Invoke",
    "_invoke",
    "TryInvoke",
    "get_Aliases",
    "get_AllowedCaller",
    "get_Help",
    "get_Name",
    "get_Permissions",
    "get_Syntax",
    "Execute",
    "get_Aliases",
    "get_AllowedCaller",
    "get_Help",
    "get_Name",
    "get_Permissions",
    "get_Syntax",
    "Execute",
    "get_Aliases",
    "get_AllowedCaller",
    "get_Help",
    "get_Name",
    "get_Permissions",
    "get_Syntax",
    "Execute",
    "get_Name",
    "set_Name",
    "get_Name",
    "set_Name",
    "get_Name",
    "get_Help",
    "get_Syntax",
    "get_AllowedCaller",
    "get_Commands",
    "set_Commands",
    "add_OnExecuteCommand",
    "remove_OnExecuteCommand",
    "Reload",
    "Awake",
    "checkCommandMappings",
    "checkDuplicateCommandMappings",
    "Plugins_OnPluginsLoaded",
    "GetCommand",
    "GetCommand",
    "getCommandIdentity",
    "getCommandType",
    "Register",
    "Register",
    "Register",
    "DeregisterFromAssembly",
    "GetCooldown",
    "SetCooldown",
    "Execute",
    "RegisterFromAssembly",
    "Assembly.Load",
    "AppDomain.Current.Load",
    "ExternalLoad",
    "ExternalAssemblyLoad",
    "MethodInvokableCallback",
    "FireEventCallback",
    "RegisterAssemblyFromNative",
    "Memory",
    "Plugin",
    "External",
    "Logger.log",
    "Logging.log",
    "Logs"
  ]
}


================================================
File: src/BitMono.Host/protections.json
================================================
ï»¿{
  "Protections": [
    {
      "Name": "AntiILdasm",
      "Enabled": false
    },
    {
      "Name": "AntiDe4dot",
      "Enabled": false
    },
    {
      "Name": "ObjectReturnType",
      "Enabled": false
    },
    {
      "Name": "NoNamespaces",
      "Enabled": false
    },
    {
      "Name": "FullRenamer",
      "Enabled": false
    },
    {
      "Name": "AntiDebugBreakpoints",
      "Enabled": false
    },
    {
      "Name": "BillionNops",
      "Enabled": false
    },
    {
      "Name": "StringsEncryption",
      "Enabled": false
    },
    {
      "Name": "UnmanagedString",
      "Enabled": false
    },
    {
      "Name": "DotNetHook",
      "Enabled": false
    },
    {
      "Name": "CallToCalli",
      "Enabled": false
    },
    {
      "Name": "AntiDecompiler",
      "Enabled": false
    },
    {
      "Name": "BitMethodDotnet",
      "Enabled": false
    },
    {
      "Name": "BitDecompiler",
      "Enabled": false
    },
    {
      "Name": "BitTimeDateStamp",
      "Enabled": false
    },
    {
      "Name": "BitDotNet",
      "Enabled": false
    },
    {
      "Name": "BitMono",
      "Enabled": false
    }
  ]
}


================================================
File: src/BitMono.Host/Configurations/BitMonoCriticalsConfiguration.cs
================================================
ï»¿namespace BitMono.Host.Configurations;

public class BitMonoCriticalsConfiguration : JsonConfigurationAccessor, IBitMonoCriticalsConfiguration
{
    public BitMonoCriticalsConfiguration(string? file = null) : base(file ?? "criticals.json")
    {
    }
}


================================================
File: src/BitMono.Host/Configurations/BitMonoObfuscationConfiguration.cs
================================================
ï»¿namespace BitMono.Host.Configurations;

public class BitMonoObfuscationConfiguration : JsonConfigurationAccessor, IBitMonoObfuscationConfiguration
{
    public BitMonoObfuscationConfiguration(string? file = null) : base(file ?? "obfuscation.json")
    {
    }
}


================================================
File: src/BitMono.Host/Configurations/BitMonoProtectionsConfiguration.cs
================================================
ï»¿namespace BitMono.Host.Configurations;

public class BitMonoProtectionsConfiguration : JsonConfigurationAccessor, IBitMonoProtectionsConfiguration
{
    public BitMonoProtectionsConfiguration(string? file = null) : base(file ?? "protections.json")
    {
    }
}


================================================
File: src/BitMono.Host/Extensions/AutofacContainerBuilderExtensions.cs
================================================
namespace BitMono.Host.Extensions;

[SuppressMessage("ReSharper", "UnusedMethodReturnValue.Global")]
[SuppressMessage("ReSharper", "IdentifierTypo")]
public static class AutofacContainerBuilderExtensions
{
    private const string ProtectionsFileName = "BitMono.Protections.dll";

    public static ContainerBuilder AddProtections(this ContainerBuilder source, string? file = null)
    {
        var workingDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        var protectionsFilePath = Path.Combine(workingDirectory!, ProtectionsFileName);
        var rawData = File.ReadAllBytes(file ?? protectionsFilePath);
        Assembly.Load(rawData);

        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        source.RegisterAssemblyTypes(assemblies)
            .PublicOnly()
            .Where(x => x.GetInterface(nameof(IPhaseProtection)) == null && x.GetInterface(nameof(IProtection)) != null)
            .OwnedByLifetimeScope()
            .AsImplementedInterfaces()
            .SingleInstance();
        return source;
    }
    public static ServiceCollection AddConfigurations(this ServiceCollection source,
        string? protectionsFile = null, string? criticalsFile = null, string? obfuscationFile = null)
    {
        var protections = new BitMonoProtectionsConfiguration(protectionsFile);
        var criticals = new BitMonoCriticalsConfiguration(criticalsFile);
        var obfuscation = new BitMonoObfuscationConfiguration(obfuscationFile);
        source.AddOptions()
            .Configure<ProtectionSettings>(protections.Configuration)
            .Configure<CriticalsSettings>(criticals.Configuration)
            .Configure<ObfuscationSettings>(obfuscation.Configuration);
        return source;
    }
}


================================================
File: src/BitMono.Host/Extensions/IPathWrapper.cs
================================================
namespace BitMono.Host.Extensions;

public interface IPathWrapper
{
    bool IsDirectory(string path);
    string GetFileName(string path);
    string GetDirectoryName(string path);
}


================================================
File: src/BitMono.Host/Extensions/PathMaskingOperator.cs
================================================
namespace BitMono.Host.Extensions;

public class PathMaskingOperator : RegexMaskingOperator
{
    private readonly IPathWrapper _pathWrapper;
    private readonly bool _combineMaskWithPath;
    private const string PathPattern =
        @"^(?:[a-zA-Z]\:|\\\\[\w-]+\\[\w-]+\$?|[\/][^\/\0]+)+(\\[^\\/:*?""<>|]*)*(\\?)?$";

    public PathMaskingOperator(IPathWrapper pathWrapper, bool combineMaskWithPath = true) : base(PathPattern)
    {
        _pathWrapper = pathWrapper;
        _combineMaskWithPath = combineMaskWithPath;
    }
    public PathMaskingOperator(bool combineMaskWithPath = true) : this(new PathWrapper(), combineMaskWithPath)
    {
    }
    public PathMaskingOperator() : this(combineMaskWithPath: true)
    {
    }

    [SuppressMessage("ReSharper", "InvertIf")]
    protected override string PreprocessMask(string mask, Match match)
    {
        if (_combineMaskWithPath)
        {
            var value = match.Value;
            return _pathWrapper.IsDirectory(value)
                ? mask + _pathWrapper.GetDirectoryName(value)
                : mask + _pathWrapper.GetFileName(value);
        }
        return mask;
    }
}


================================================
File: src/BitMono.Host/Extensions/PathWrapper.cs
================================================
namespace BitMono.Host.Extensions;

public class PathWrapper : IPathWrapper
{
    public bool IsDirectory(string path)
    {
        return Path.GetExtension(path) == string.Empty;
    }
    public string GetFileName(string path)
    {
        return Path.GetFileName(path);
    }
    public string GetDirectoryName(string path)
    {
        return new DirectoryInfo(path).Name;
    }
}


================================================
File: src/BitMono.Host/Ioc/IApplication.cs
================================================
ï»¿namespace BitMono.Host.Ioc;

public interface IApplication
{
    IApplication Populate(IEnumerable<ServiceDescriptor> descriptors);
    IApplication RegisterModule(IModule module);
    Task<AutofacServiceProvider> BuildAsync(CancellationToken cancellationToken);
}


================================================
File: src/BitMono.Host/Modules/BitMonoModule.cs
================================================
ï»¿namespace BitMono.Host.Modules;

public class BitMonoModule : Module
{
    private const string LoggingFileName = "logging.json";
    private const string DateVariableName = "date";
    private const string DateTimeFormat = "yyyy-MM-dd-HH-mm-ss";
    private readonly Action<ContainerBuilder>? _configureContainer;
    private readonly Action<ServiceCollection>? _configureServices;
    private readonly Action<LoggerConfiguration>? _configureLogger;

    public BitMonoModule(
        Action<ContainerBuilder>? configureContainer = null,
        Action<ServiceCollection>? configureServices = null,
        Action<LoggerConfiguration>? configureLogger = null)
    {
        _configureContainer = configureContainer;
        _configureServices = configureServices;
        _configureLogger = configureLogger;
    }

    [SuppressMessage("ReSharper", "IdentifierTypo")]
    protected override void Load(ContainerBuilder containerBuilder)
    {
        _configureContainer?.Invoke(containerBuilder);

        var loggingConfigurationRoot = new ConfigurationBuilder().AddJsonFileEx(configure =>
        {
            configure.Path = LoggingFileName;
            configure.Optional = false;
            configure.Variables = new Dictionary<string, string>
            {
                {
                    DateVariableName,
                    DateTime.Now.ToString(DateTimeFormat)
                }
            };
            configure.ResolveFileProvider();
        }).Build();

        var loggerConfiguration = new LoggerConfiguration()
            .ReadFrom.Configuration(loggingConfigurationRoot);

        _configureLogger?.Invoke(loggerConfiguration);

        var logger = loggerConfiguration.CreateLogger();
        containerBuilder.Register<ILogger>(_ => logger);

        var serviceCollection = new ServiceCollection();
        _configureServices?.Invoke(serviceCollection);

        containerBuilder.RegisterType<EngineContextAccessor>()
            .As<IEngineContextAccessor>()
            .OwnedByLifetimeScope()
            .SingleInstance();

        containerBuilder.RegisterType<ProtectionContextFactory>()
            .AsSelf()
            .OwnedByLifetimeScope()
            .SingleInstance();

        containerBuilder.RegisterType<ProtectionParametersFactory>()
            .AsSelf()
            .OwnedByLifetimeScope()
            .SingleInstance();

        containerBuilder.Register<RandomNext>(_ => RandomService.RandomNext)
            .OwnedByLifetimeScope()
            .SingleInstance();

        containerBuilder.RegisterType<Renamer>()
            .OwnedByLifetimeScope()
            .SingleInstance();

        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        containerBuilder.RegisterAssemblyTypes(assemblies)
            .PublicOnly()
            .Where(t => t.GetInterface(nameof(IMemberResolver)) != null)
            .AsImplementedInterfaces()
            .OwnedByLifetimeScope()
            .SingleInstance();

        containerBuilder.RegisterAssemblyTypes(assemblies)
            .PublicOnly()
            .AsClosedTypesOf(typeof(ICriticalAnalyzer<>))
            .OwnedByLifetimeScope()
            .SingleInstance();

        containerBuilder.RegisterAssemblyTypes(assemblies)
            .PublicOnly()
            .AsClosedTypesOf(typeof(IAttributeResolver<>))
            .OwnedByLifetimeScope()
            .SingleInstance();

        containerBuilder.Populate(serviceCollection);
    }
}


================================================
File: src/BitMono.Obfuscation/BitMono.Obfuscation.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props" />

  <ItemGroup>
    <ProjectReference Include="..\BitMono.API\BitMono.API.csproj" />
    <ProjectReference Include="..\BitMono.Core\BitMono.Core.csproj" />
    <ProjectReference Include="..\BitMono.Host\BitMono.Host.csproj" />
    <ProjectReference Include="..\BitMono.Runtime\BitMono.Runtime.csproj" />
    <ProjectReference Include="..\BitMono.Shared\BitMono.Shared.csproj" />
  </ItemGroup>

</Project>


================================================
File: src/BitMono.Obfuscation/BitMonoObfuscator.cs
================================================
ï»¿namespace BitMono.Obfuscation;

public class BitMonoObfuscator
{
    private readonly IServiceProvider _serviceProvider;
    private readonly StarterContext _context;
    private readonly IDataWriter _dataWriter;
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly InvokablePipeline _pipeline;
    private readonly ObfuscationAttributeResolver _obfuscationAttributeResolver;
    private readonly ObfuscationAttributesStripper _obfuscationAttributesStripper;
    private readonly ObfuscationAttributesStripNotifier _obfuscationAttributesStripNotifier;
    private readonly ProtectionsNotifier _protectionsNotifier;
    private readonly ProtectionsConfigureForNativeCodeNotifier _protectionsConfigureForNativeCodeNotifier;
    private readonly ProtectionExecutionNotifier _protectionExecutionNotifier;
    private readonly ILogger _logger;
    private ProtectionsSort? _protectionsSort;
    private PEImageBuildResult? _imageBuild;
    private long _startTime;

    public BitMonoObfuscator(
        IServiceProvider serviceProvider,
        StarterContext context,
        IDataWriter dataWriter,
        ObfuscationSettings obfuscationSettings,
        ILogger logger)
    {
        _serviceProvider = serviceProvider;
        _context = context;
        _dataWriter = dataWriter;
        _obfuscationSettings = obfuscationSettings;
        _pipeline = new InvokablePipeline();
        _obfuscationAttributeResolver = _serviceProvider.GetRequiredService<ObfuscationAttributeResolver>();
        var obfuscateAssemblyAttributeResolver = _serviceProvider.GetRequiredService<ObfuscateAssemblyAttributeResolver>();
        _obfuscationAttributesStripper = new ObfuscationAttributesStripper(
            _obfuscationAttributeResolver, obfuscateAssemblyAttributeResolver);
        _logger = logger.ForContext<BitMonoObfuscator>();
        _obfuscationAttributesStripNotifier = new ObfuscationAttributesStripNotifier(_logger);
        _protectionsNotifier = new ProtectionsNotifier(_obfuscationSettings, _logger);
        _protectionsConfigureForNativeCodeNotifier = new ProtectionsConfigureForNativeCodeNotifier(_obfuscationSettings, _logger);
        _protectionExecutionNotifier = new ProtectionExecutionNotifier(_logger);
    }

    public async Task ProtectAsync()
    {
        _context.ThrowIfCancellationRequested();

        _pipeline.OnFail += OnFailHandleAsync;

        await _pipeline.InvokeAsync(OutputLoadedModule);
        await _pipeline.InvokeAsync(OutputBitMonoInfo);
        await _pipeline.InvokeAsync(OutputCompatibilityIssues);
        await _pipeline.InvokeAsync(SortProtections);
        await _pipeline.InvokeAsync(OutputProtectionsAsync);
        await _pipeline.InvokeAsync(ConfigureForNativeCode);
        await _pipeline.InvokeAsync(StartTimeCounter);
        await _pipeline.InvokeAsync(ResolveDependencies);
        await _pipeline.InvokeAsync(ExpandMacros);
        await _pipeline.InvokeAsync(RunProtectionsAsync);
        await _pipeline.InvokeAsync(OptimizeMacros);
        await _pipeline.InvokeAsync(StripObfuscationAttributes);
        await _pipeline.InvokeAsync(CreatePEImage);
        await _pipeline.InvokeAsync(WriteModuleAsync);
        await _pipeline.InvokeAsync(PackAsync);
        await _pipeline.InvokeAsync(OutputElapsedTime);
    }

    private void OutputLoadedModule()
    {
        var targetFrameworkText = "unknown";
        var module = _context.Module;
        var assembly = module.Assembly;
        if (assembly!.TryGetTargetFramework(out var info))
        {
            targetFrameworkText = $"{info.Name} {info.Version}";
        }

        var assemblyInfo = assembly.ToString();
        var culture = assembly.Culture?.ToString() ?? "unknown";
        var timeDateStamp = module.ToPEImage().TimeDateStamp;
        _logger.Information("Module {0}", assemblyInfo);
        _logger.Information("Module Target Framework: {0}", targetFrameworkText);
        _logger.Information("Module PE TimeDateStamp: {0}", timeDateStamp);
        _logger.Information("Module culture: {0}", culture);
    }
    private void OutputBitMonoInfo()
    {
        _logger.Information(EnvironmentRuntimeInformation.Create().ToString());
    }
    /// <summary>
    /// Outputs information in case of module is built for .NET Framework,
    /// but BitMono is running on .NET Core, or vice versa.
    /// See more info: https://bitmono.readthedocs.io/en/latest/obfuscationissues/corlib-not-found.html
    /// </summary>
    private void OutputCompatibilityIssues()
    {
        if (!_context.Module.Assembly!.TryGetTargetFramework(out var targetAssemblyRuntime))
        {
            return;
        }
        if (targetAssemblyRuntime.IsNetCoreApp && DotNetRuntimeInfoEx.IsNetFramework())
        {
            _logger.Warning(
                "The module is built for .NET (Core), but you're using a version of BitMono intended for .NET Framework." +
                " To avoid potential issues, ensure the target framework matches the BitMono framework, " +
                "or switch to a .NET Core build of BitMono.");
            return;
        }
        if (targetAssemblyRuntime.IsNetFramework && DotNetRuntimeInfoEx.IsNetCoreOrLater())
        {
            _logger.Warning(
                "The module is built for .NET Framework, but you're using a version of BitMono intended for .NET (Core)." +
                " To avoid potential issues, ensure the target framework matches the BitMono framework, " +
                "or switch to a .NET Framework build of BitMono.");
            return;
        }
    }
    private void SortProtections()
    {
        var protectionSettings = _serviceProvider.GetRequiredService<IOptions<ProtectionSettings>>().Value.Protections!;
        var protections = _serviceProvider
            .GetRequiredService<ICollection<IProtection>>()
            .ToList();
        var protectionsSorter = new ProtectionsSorter(_obfuscationAttributeResolver, _context.Module.Assembly!);
        _protectionsSort = protectionsSorter.Sort(protections, protectionSettings);
        if (!_protectionsSort.HasProtections)
        {
            throw new Exception("No protections were detected. Please specify or enable them in `protections.json` file.");
        }
    }
    private bool OutputProtectionsAsync()
    {
        if (_protectionsSort == null)
        {
            _logger.Fatal("Unable to output protections without sorted protections!");
            return false;
        }
        _protectionsNotifier.Notify(_protectionsSort, _context.CancellationToken);
        return true;
    }
    private void ConfigureForNativeCode()
    {
        if (!_protectionsSort!.ConfigureForNativeCodeProtections.Any())
        {
            return;
        }

        _protectionsConfigureForNativeCodeNotifier.Notify(_protectionsSort, _context.CancellationToken);

        var module = _context.Module;
        module.IsILOnly = false;
        var x64 = module.MachineType == MachineType.Amd64;
        if (x64)
        {
            module.PEKind = OptionalHeaderMagic.PE32Plus;
            module.MachineType = MachineType.Amd64;
            module.IsBit32Required = false;
        }
        else
        {
            module.PEKind = OptionalHeaderMagic.PE32;
            module.MachineType = MachineType.I386;
            module.IsBit32Required = true;
        }
    }
    private void StartTimeCounter()
    {
        _startTime = Stopwatch.GetTimestamp();
    }
    private bool ResolveDependencies()
    {
        _logger.Information("Starting resolving dependencies...");
        var assemblyResolve = AssemblyResolver.Resolve(_context.BitMonoContext.ReferencesData, _context);
        foreach (var reference in assemblyResolve.ResolvedReferences)
        {
            _context.ThrowIfCancellationRequested();

            _logger.Information("Successfully resolved dependency: {0}", reference.FullName);
        }
        foreach (var reference in assemblyResolve.FailedToResolveReferences)
        {
            _context.ThrowIfCancellationRequested();

            _logger.Warning("Failed to resolve dependency: {0}", reference.FullName);
        }
        _logger.Information("References resolve have been completed!");
        if (assemblyResolve.Succeed == false)
        {
            if (_obfuscationSettings.FailOnNoRequiredDependency)
            {
                _logger.Fatal("Please, specify needed dependencies, or set in {0} {1} to false",
                    "obfuscation.json", nameof(ObfuscationSettings.FailOnNoRequiredDependency));
                _logger.Warning(
                    "Unresolved dependencies aren't a major issue, but keep in mind they can cause problems or might result in some parts being missed during obfuscation.");
                return false;
            }
        }
        return true;
    }
    private void ExpandMacros()
    {
        foreach (var method in _context.Module.FindMembers().OfType<MethodDefinition>())
        {
            _context.ThrowIfCancellationRequested();

            if (method.CilMethodBody is not { } body)
            {
                continue;
            }

            body.Instructions.ExpandMacros();
        }
    }
    private async Task RunProtectionsAsync()
    {
        _logger.Information("Executing Protections... this could take for a while...");
        if (_protectionsSort == null)
        {
            throw new InvalidOperationException($"{nameof(_protectionsSort)} was null!");
        }
        foreach (var protection in _protectionsSort.SortedProtections)
        {
            _context.ThrowIfCancellationRequested();

            await protection.ExecuteAsync();
            _protectionExecutionNotifier.Notify(protection);
        }
        foreach (var pipeline in _protectionsSort.Pipelines)
        {
            _context.ThrowIfCancellationRequested();

            await pipeline.ExecuteAsync();
            _protectionExecutionNotifier.Notify(pipeline);

            foreach (var phase in pipeline.PopulatePipeline())
            {
                _context.ThrowIfCancellationRequested();

                await phase.ExecuteAsync();
                _protectionExecutionNotifier.Notify(phase);
            }
        }
    }
    private void OptimizeMacros()
    {
        foreach (var method in _context.Module.FindMembers().OfType<MethodDefinition>())
        {
            _context.ThrowIfCancellationRequested();

            if (method.CilMethodBody is not { } body)
            {
                continue;
            }

            body.Instructions.OptimizeMacros();
        }
    }
    private void StripObfuscationAttributes()
    {
        if (_obfuscationSettings.StripObfuscationAttributes == false)
        {
            return;
        }
        var obfuscationAttributesStrip = _obfuscationAttributesStripper.Strip(_context, _protectionsSort!);
        _obfuscationAttributesStripNotifier.Notify(obfuscationAttributesStrip);
    }
    private bool CreatePEImage()
    {
        _imageBuild = _context.PEImageBuilder.CreateImage(_context.Module);
        if (_imageBuild == null || _imageBuild.HasFailed)
        {
            _logger.Fatal("Unable to construct the PE image!");
            return false;
        }
        return true;
    }
    private async Task<bool> WriteModuleAsync()
    {
        try
        {
            using var memoryStream = new MemoryStream();
            var fileBuilder = new ManagedPEFileBuilder();
            fileBuilder
                .CreateFile(_imageBuild!.ConstructedImage!)
                .Write(memoryStream);
            await _dataWriter.WriteAsync(_context.BitMonoContext.OutputFile, memoryStream.ToArray());
            _logger.Information("The protected module was saved in {0}", _context.BitMonoContext.OutputDirectoryName);
        }
        catch (Exception ex)
        {
            _logger.Fatal(ex, "An error occured while writing the module!");
            return false;
        }
        return true;
    }
    private async Task PackAsync()
    {
        foreach (var packer in _protectionsSort!.Packers)
        {
            _context.ThrowIfCancellationRequested();

            await packer.ExecuteAsync();
            _protectionExecutionNotifier.Notify(packer);
        }
        _logger.Information("Protections have been executed!");
    }
    private void OutputElapsedTime()
    {
        var elapsedTime = StopwatchUtilities.GetElapsedTime(_startTime, Stopwatch.GetTimestamp());
        _logger.Information("Since obfuscation elapsed: {0}", elapsedTime.ToString());
    }
    private Task OnFailHandleAsync()
    {
        _logger.Fatal("Obfuscation stopped! Something went wrong!");
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Obfuscation/GlobalUsings.cs
================================================
ï»¿global using AsmResolver;
global using AsmResolver.DotNet;
global using AsmResolver.DotNet.Builder;
global using AsmResolver.DotNet.Serialized;
global using BitMono.Core.Extensions;
global using BitMono.Shared.Models;
global using System;
global using System.Collections.Generic;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.IO;
global using System.IO.Compression;
global using System.Linq;
global using System.Text;
global using System.Threading;
global using System.Threading.Tasks;
global using AsmResolver.PE;
global using AsmResolver.PE.Builder;
global using AsmResolver.PE.DotNet;
global using AsmResolver.PE.DotNet.ReadyToRun;
global using AsmResolver.PE.File;
global using BitMono.API;
global using BitMono.API.Protections;
global using BitMono.Core.Attributes;
global using BitMono.Core.Contexts;
global using BitMono.Core.Pipeline;
global using BitMono.Core.Resolvers;
global using BitMono.Core.Services;
global using BitMono.Obfuscation.Files;
global using BitMono.Obfuscation.Logging;
global using BitMono.Obfuscation.Modules;
global using BitMono.Obfuscation.Notifiers;
global using BitMono.Obfuscation.Protections;
global using BitMono.Obfuscation.Referencing;
global using BitMono.Obfuscation.Stripping;
global using BitMono.Utilities.AsmResolver;
global using BitMono.Utilities.Runtime;
global using BitMono.Utilities.Time;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Options;
global using Pocket.Extensions;
global using ILogger = Serilog.ILogger;


================================================
File: src/BitMono.Obfuscation/Files/CompleteFileInfo.cs
================================================
ï»¿namespace BitMono.Obfuscation.Files;

public class CompleteFileInfo
{
    public CompleteFileInfo(string fileName, byte[] fileData, List<byte[]> fileReferences, string outputDirectoryPath)
    {
        FileName = fileName;
        FileData = fileData;
        FileReferences = fileReferences;
        OutputDirectoryPath = outputDirectoryPath;
    }

    public string FileName { get; set; }
    public byte[] FileData { get; set; }
    public List<byte[]> FileReferences { get; set; }
    public string OutputDirectoryPath { get; set; }
}


================================================
File: src/BitMono.Obfuscation/Files/FileDataWriter.cs
================================================
ï»¿namespace BitMono.Obfuscation.Files;

public class FileDataWriter : IDataWriter
{
    public Task WriteAsync(string outputFile, byte[] outputBuffer)
    {
        File.WriteAllBytes(outputFile, outputBuffer);
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Obfuscation/Files/FinalFileInfo.cs
================================================
ï»¿namespace BitMono.Obfuscation.Files;

public class FinalFileInfo
{
    public FinalFileInfo(string filePath, string outputDirectoryPath)
    {
        FilePath = filePath;
        OutputDirectoryPath = outputDirectoryPath;
    }

    public string FilePath { get; set; }
    public string OutputDirectoryPath { get; set; }
}


================================================
File: src/BitMono.Obfuscation/Files/IDataWriter.cs
================================================
ï»¿namespace BitMono.Obfuscation.Files;

public interface IDataWriter
{
    Task WriteAsync(string outputFile, byte[] outputBuffer);
}


================================================
File: src/BitMono.Obfuscation/Files/IncompleteFileInfo.cs
================================================
ï»¿namespace BitMono.Obfuscation.Files;

public class IncompleteFileInfo
{
    public IncompleteFileInfo(string filePath, string referencesDirectoryPath, string outputDirectoryPath)
    {
        FilePath = filePath;
        ReferencesDirectoryPath = referencesDirectoryPath;
        OutputDirectoryPath = outputDirectoryPath;
    }

    public string FilePath { get; set; }
    public string ReferencesDirectoryPath { get; set; }
    public string OutputDirectoryPath { get; set; }
}


================================================
File: src/BitMono.Obfuscation/Files/OutputFilePathFactory.cs
================================================
ï»¿namespace BitMono.Obfuscation.Files;

public static class OutputFilePathFactory
{
    private const string WatermarkText = "_bitmono";

    public static string Create(BitMonoContext context)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.Append(Path.GetFileNameWithoutExtension(context.FileName));
        if (context.Watermark)
        {
            stringBuilder.Append(WatermarkText);
        }
        stringBuilder.Append(Path.GetExtension(context.FileName));
        return Path.Combine(context.OutputDirectoryName, stringBuilder.ToString());
    }
}


================================================
File: src/BitMono.Obfuscation/Logging/LogErrorListener.cs
================================================
ï»¿namespace BitMono.Obfuscation.Logging;

internal class LogErrorListener : IErrorListener
{
    private readonly ILogger _logger;
    private readonly ObfuscationSettings _obfuscationSettings;

    public LogErrorListener(ILogger logger, ObfuscationSettings obfuscationSettings)
    {
        _logger = logger;
        _obfuscationSettings = obfuscationSettings;
    }

    public void MarkAsFatal()
    {
        if (_obfuscationSettings.OutputPEImageBuildErrors)
        {
            _logger.Fatal("An fatal error just occured!");
        }
    }
    public void RegisterException(Exception exception)
    {
        if (_obfuscationSettings.OutputPEImageBuildErrors)
        {
            _logger.Error(exception, "Registered error!");
        }
    }
}


================================================
File: src/BitMono.Obfuscation/Modules/IModuleFactory.cs
================================================
ï»¿namespace BitMono.Obfuscation.Modules;

public interface IModuleFactory
{
    ModuleFactoryResult Create();
}


================================================
File: src/BitMono.Obfuscation/Modules/ModuleFactory.cs
================================================
ï»¿namespace BitMono.Obfuscation.Modules;

public class ModuleFactory : IModuleFactory
{
    private readonly byte[] _bytes;
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly IErrorListener _errorListener;
    private readonly ILogger _logger;
    private readonly MetadataBuilderFlags _metadataBuilderFlags;

    public ModuleFactory(
        byte[] bytes, ObfuscationSettings obfuscationSettings,
        IErrorListener errorListener, ILogger logger,
        MetadataBuilderFlags metadataBuilderFlags = MetadataBuilderFlags.None)
    {
        _bytes = bytes;
        _obfuscationSettings = obfuscationSettings;
        _errorListener = errorListener;
        _logger = logger.ForContext<ModuleFactory>();
        _metadataBuilderFlags = metadataBuilderFlags;
    }

    public ModuleFactoryResult Create()
    {
        var moduleReaderParameters = new ModuleReaderParameters(_errorListener)
        {
            PEReaderParameters = new PEReaderParameters(_errorListener)
        };

        ModuleDefinition module;
        try
        {

            module = ModuleDefinition.FromBytes(_bytes, moduleReaderParameters);
        }
        catch (BadImageFormatException)
        {
            _logger.Error(
                "The file appears to be using native code (ReadyToRun). " +
                "Ensure you're using a `.dll` file with non-native (managed) code. " +
                "If the file is using ReadyToRun, you can disable it by adding `<PublishReadyToRun>false</PublishReadyToRun>` to your `.csproj` file. " +
                "For more information, visit: https://bitmono.readthedocs.io/en/latest/obfuscationissues/ready-to-run.html " +
                "Alternatively, the file might be broken, protected, or obfuscated. " +
                "If neither of these cases apply, please contact us for support."
            );
            throw;
        }

        var managedPEImageBuilder =
            new ManagedPEImageBuilder(new DotNetDirectoryFactory(_metadataBuilderFlags), _errorListener);

        return new ModuleFactoryResult
        {
            Module = module,
            ModuleReaderParameters = moduleReaderParameters,
            PEImageBuilder = managedPEImageBuilder,
        };
    }
}


================================================
File: src/BitMono.Obfuscation/Modules/ModuleFactoryResult.cs
================================================
ï»¿namespace BitMono.Obfuscation.Modules;

public class ModuleFactoryResult
{
#pragma warning disable CS8618
    public ModuleDefinition Module { get; set; }
    public ModuleReaderParameters ModuleReaderParameters { get; set; }
    public IPEImageBuilder PEImageBuilder { get; set; }
#pragma warning restore CS8618
}


================================================
File: src/BitMono.Obfuscation/Notifiers/ObfuscationAttributesStripNotifier.cs
================================================
namespace BitMono.Obfuscation.Notifiers;

public class ObfuscationAttributesStripNotifier
{
    private readonly ILogger _logger;

    public ObfuscationAttributesStripNotifier(ILogger logger)
    {
        _logger = logger.ForContext<ObfuscationAttributesStripNotifier>();
    }

    public void Notify(ObfuscationAttributesStrip obfuscationAttributesStrip)
    {
        if (obfuscationAttributesStrip.ObfuscationAttributesSuccessStrip.IsEmpty() == false)
        {
            _logger.Information("Successfully stripped {0} obfuscation attribute(s)",
                obfuscationAttributesStrip.ObfuscationAttributesSuccessStrip.Count);
        }
        if (obfuscationAttributesStrip.ObfuscateAssemblyAttributesSuccessStrip.IsEmpty() == false)
        {
            _logger.Information("Successfully stripped {0} assembly obfuscation attribute(s)",
                obfuscationAttributesStrip.ObfuscateAssemblyAttributesSuccessStrip.Count);
        }
        if (obfuscationAttributesStrip.ObfuscationAttributesFailStrip.IsEmpty() == false)
        {
            _logger.Information("Failed to strip {0} assembly obfuscation attribute(s)",
                obfuscationAttributesStrip.ObfuscationAttributesFailStrip.Count);
        }
        if (obfuscationAttributesStrip.ObfuscateAssemblyAttributesFailStrip.IsEmpty() == false)
        {
            _logger.Information("Failed to strip {0} obfuscation attribute(s)",
                obfuscationAttributesStrip.ObfuscateAssemblyAttributesFailStrip.Count);
        }
    }
}


================================================
File: src/BitMono.Obfuscation/Notifiers/ProtectionExecutionNotifier.cs
================================================
ï»¿namespace BitMono.Obfuscation.Notifiers;

public class ProtectionExecutionNotifier
{
    private readonly ILogger _logger;

    public ProtectionExecutionNotifier(ILogger logger)
    {
        _logger = logger;
    }

    public void Notify(IProtection protection)
    {
        _logger.Information("{0} -> OK", protection.GetName());
    }
}


================================================
File: src/BitMono.Obfuscation/Notifiers/ProtectionsConfigureForNativeCodeNotifier.cs
================================================
namespace BitMono.Obfuscation.Notifiers;

public class ProtectionsConfigureForNativeCodeNotifier
{
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly ILogger _logger;

    public ProtectionsConfigureForNativeCodeNotifier(ObfuscationSettings obfuscationSettings, ILogger logger)
    {
        _obfuscationSettings = obfuscationSettings;
        _logger = logger.ForContext<ProtectionsConfigureForNativeCodeNotifier>();
    }

    public void Notify(ProtectionsSort protectionsSort, CancellationToken cancellationToken)
    {
        if (_obfuscationSettings.OutputConfigureForNativeCodeWarnings == false)
        {
            return;
        }
        var configureForNativeCodeProtections = protectionsSort.ConfigureForNativeCodeProtections;
        if (configureForNativeCodeProtections.Any() == false)
        {
            return;
        }

        _logger.Warning(
            "Enabled protections may create native code configurations, which can sometimes break the app. Proceed with caution. If issues arise, disable the following protections.");
        foreach (var protection in configureForNativeCodeProtections)
        {
            cancellationToken.ThrowIfCancellationRequested();

            _logger.Warning("{Name} - is using Native Code.", protection.GetName());
        }
    }
}


================================================
File: src/BitMono.Obfuscation/Notifiers/ProtectionsNotifier.cs
================================================
ï»¿namespace BitMono.Obfuscation.Notifiers;

public class ProtectionsNotifier
{
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly ILogger _logger;

    public ProtectionsNotifier(ObfuscationSettings obfuscationSettings, ILogger logger)
    {
        _obfuscationSettings = obfuscationSettings;
        _logger = logger.ForContext<ProtectionsNotifier>();
    }

    public void Notify(ProtectionsSort protectionsSort, CancellationToken cancellationToken)
    {
        if (_obfuscationSettings.NotifyProtections == false)
        {
            return;
        }
        if (protectionsSort.HasProtections == false)
        {
            return;
        }

        var stringBuilder = new StringBuilder();
        stringBuilder.Append(string.Join(", ", protectionsSort.SortedProtections.Select(x => x.GetName())));
        if (protectionsSort.Pipelines.Any())
        {
            stringBuilder.Append(", ");
            stringBuilder.Append(string.Join(", ", protectionsSort.Pipelines.Select(x => x.GetName())));
        }
        if (protectionsSort.Packers.Any())
        {
            stringBuilder.Append(", ");
            stringBuilder.Append(string.Join(", ", protectionsSort.Packers.Select(x => x.GetName())));
        }
        var enabledProtectionsCount = protectionsSort.SortedProtections.Count
                                      + protectionsSort.Pipelines.Count
                                      + protectionsSort.Packers.Count;
        _logger.Information("({0}) Enabled protection(s): {1}", enabledProtectionsCount, stringBuilder.ToString());
        var runtimeMonikerNotifier = new ProtectionsRuntimeMonikerNotifier(_obfuscationSettings, _logger);
        runtimeMonikerNotifier.Notify(protectionsSort, cancellationToken);
        if (protectionsSort.DeprecatedProtections.Any())
        {
            _logger.Warning("Skip deprecated protection(s): {0}", string.Join(", ", protectionsSort.DeprecatedProtections.Select(p => p?.GetName())));
        }
        if (protectionsSort.ProtectionsResolve.DisabledProtections.Any())
        {
            var disabledProtectionsCount = protectionsSort.ProtectionsResolve.DisabledProtections.Count;
            _logger.Information("({0}) Disabled protection(s): {1}", disabledProtectionsCount, string.Join(", ", protectionsSort.ProtectionsResolve.DisabledProtections.Select(p => p ?? "Unnamed Protection")));
        }
        if (protectionsSort.ProtectionsResolve.UnknownProtections.Any())
        {
            _logger.Warning("Unknown protection(s): {0}", string.Join(", ", protectionsSort.ProtectionsResolve.UnknownProtections.Select(p => p ?? "Unnamed Protection")));
        }
        if (protectionsSort.ObfuscationAttributeExcludeProtections.Any())
        {
            _logger.Information("Skip protection(s) with obfuscation attribute: {0}", string.Join(", ", protectionsSort.ObfuscationAttributeExcludeProtections.Select(p => p?.GetName())));
        }
    }
}


================================================
File: src/BitMono.Obfuscation/Notifiers/ProtectionsRuntimeMonikerNotifier.cs
================================================
namespace BitMono.Obfuscation.Notifiers;

public class ProtectionsRuntimeMonikerNotifier
{
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly ILogger _logger;

    public ProtectionsRuntimeMonikerNotifier(ObfuscationSettings obfuscationSettings, ILogger logger)
    {
        _obfuscationSettings = obfuscationSettings;
        _logger = logger.ForContext<ProtectionsRuntimeMonikerNotifier>();
    }

    public void Notify(ProtectionsSort protectionsSort, CancellationToken cancellationToken)
    {
        if (_obfuscationSettings.OutputRuntimeMonikerWarnings == false)
        {
            return;
        }
        var runtimeMonikerProtections = protectionsSort.RuntimeMonikerProtections;
        if (runtimeMonikerProtections.Count == 0)
        {
            return;
        }

        _logger.Warning(
            "Protections marked as \"Intended for ...\" are designed for specific runtimes. Using them with other runtimes may cause crashes or other issues. Proceed with caution.");

        foreach (var (protection, attributes) in runtimeMonikerProtections)
        {
            cancellationToken.ThrowIfCancellationRequested();

            foreach (var runtimeMonikerAttribute in attributes)
            {
                cancellationToken.ThrowIfCancellationRequested();

                _logger.Warning("[!!!] {Name} - " + runtimeMonikerAttribute.GetMessage(), protection.GetName());
            }
        }
    }
}


================================================
File: src/BitMono.Obfuscation/Protections/ProtectionsSort.cs
================================================
ï»¿namespace BitMono.Obfuscation.Protections;

public class ProtectionsSort
{
    public ProtectionsSort(
        ProtectionsResolve protectionsResolve,
        IReadOnlyCollection<IProtection> allProtections,
        IReadOnlyCollection<IProtection> sortedProtections,
        IReadOnlyCollection<IPipelineProtection> pipelines,
        IReadOnlyCollection<IPacker> packers,
        IReadOnlyCollection<IProtection> deprecatedProtections,
        IReadOnlyCollection<IProtection> obfuscationAttributeExcludeProtections,
        IReadOnlyCollection<IProtection> configureForNativeCodeProtections,
        IReadOnlyCollection<(IProtection, RuntimeMonikerAttribute[])> runtimeMonikerProtections,
        bool hasProtections)
    {
        ProtectionsResolve = protectionsResolve;
        AllProtections = allProtections;
        SortedProtections = sortedProtections;
        Pipelines = pipelines;
        Packers = packers;
        DeprecatedProtections = deprecatedProtections;
        ObfuscationAttributeExcludeProtections = obfuscationAttributeExcludeProtections;
        ConfigureForNativeCodeProtections = configureForNativeCodeProtections;
        RuntimeMonikerProtections = runtimeMonikerProtections;
        HasProtections = hasProtections;
    }

#pragma warning disable CS8618
    public ProtectionsResolve ProtectionsResolve { get; }
    /// <summary>
    /// Gets a collection of <see cref="IProtection"/>, <see cref="IPipelineProtection"/>, and <see cref="IPacker"/>.
    /// </summary>
    public IReadOnlyCollection<IProtection> AllProtections { get; }
    public IReadOnlyCollection<IProtection> SortedProtections { get; }
    public IReadOnlyCollection<IPipelineProtection> Pipelines { get; }
    public IReadOnlyCollection<IPacker> Packers { get; }
    public IReadOnlyCollection<IProtection> DeprecatedProtections { get; }
    public IReadOnlyCollection<IProtection> ObfuscationAttributeExcludeProtections { get; }
    public IReadOnlyCollection<IProtection> ConfigureForNativeCodeProtections { get; }
    public IReadOnlyCollection<(IProtection, RuntimeMonikerAttribute[])> RuntimeMonikerProtections { get; }
    public bool HasProtections { get; }
#pragma warning restore CS8618
}


================================================
File: src/BitMono.Obfuscation/Protections/ProtectionsSorter.cs
================================================
ï»¿namespace BitMono.Obfuscation.Protections;

public class ProtectionsSorter
{
    private readonly ObfuscationAttributeResolver _obfuscationAttributeResolver;
    private readonly AssemblyDefinition _assemblyDefinition;

    public ProtectionsSorter(ObfuscationAttributeResolver obfuscationAttributeResolver, AssemblyDefinition assemblyDefinition)
    {
        _obfuscationAttributeResolver = obfuscationAttributeResolver;
        _assemblyDefinition = assemblyDefinition;
    }

    [SuppressMessage("ReSharper", "PossibleMultipleEnumeration")]
    public ProtectionsSort Sort(List<IProtection> protections, IEnumerable<ProtectionSetting> protectionSettings)
    {
        var protectionsResolve = new ProtectionsResolver(protections, protectionSettings).Sort();
        var obfuscationAttributeProtections =
            protectionsResolve.FoundProtections.Where(x =>
                _obfuscationAttributeResolver.Resolve(x.GetName(), _assemblyDefinition));
        var deprecatedProtections =
            protectionsResolve.FoundProtections.Where(x => x.TryGetObsoleteAttribute(out _));
        var sortedProtections = protectionsResolve.FoundProtections
            .Except(obfuscationAttributeProtections)
            .Except(deprecatedProtections);
        var pipelineProtections = sortedProtections
            .Where(x => x is IPipelineProtection)
            .Cast<IPipelineProtection>();
        var packers = sortedProtections
            .Where(x => x is IPacker)
            .Cast<IPacker>();
        sortedProtections = sortedProtections
            .Except(packers)
            .Except(pipelineProtections);
        var allProtections = sortedProtections.Concat(pipelineProtections).Concat(packers);

        var configureForNativeCodeProtections = allProtections.Where(
            x => x.GetConfigureForNativeCodeAttribute() != null);
        var runtimeMonikerProtections = allProtections
            .Select(x => (x, x.GetRuntimeMonikerAttributes()))
            .Where(x => x.Item2.Any());

        var hasProtections = sortedProtections.IsEmpty() == false || packers.IsEmpty() == false;

        return new ProtectionsSort(
            protectionsResolve,
            allProtections.ToList(),
            sortedProtections.ToList(),
            pipelineProtections.ToList(),
            packers.ToList(),
            obfuscationAttributeProtections.ToList(),
            deprecatedProtections.ToList(),
            configureForNativeCodeProtections.ToList(),
            runtimeMonikerProtections.ToList(),
            hasProtections);
    }
}


================================================
File: src/BitMono.Obfuscation/Referencing/AutomaticPathReferencesDataResolver.cs
================================================
namespace BitMono.Obfuscation.Referencing;

public class AutomaticPathReferencesDataResolver : IReferencesDataResolver
{
    private readonly ReferencesDataResolver _referencesDataResolver;
    private readonly CosturaReferencesDataResolver _costuraReferencesDataResolver;

    public AutomaticPathReferencesDataResolver(string referencesDirectoryPath)
    {
        _referencesDataResolver = new ReferencesDataResolver(referencesDirectoryPath);
        _costuraReferencesDataResolver = new CosturaReferencesDataResolver();
    }

    public List<byte[]> Resolve(ModuleDefinition module, CancellationToken cancellationToken)
    {
        var referencesData = _referencesDataResolver.Resolve(module, cancellationToken);
        var costuraReferencesData = _costuraReferencesDataResolver.Resolve(module, cancellationToken);
        if (costuraReferencesData.IsEmpty() == false)
        {
            referencesData.AddRange(costuraReferencesData);
        }
        return referencesData;
    }
}


================================================
File: src/BitMono.Obfuscation/Referencing/AutomaticReferencesDataResolver.cs
================================================
ï»¿namespace BitMono.Obfuscation.Referencing;

public class AutomaticReferencesDataResolver : IReferencesDataResolver
{
    private readonly List<byte[]> _referencesData;
    private readonly CosturaReferencesDataResolver _costuraReferencesDataResolver;

    public AutomaticReferencesDataResolver(List<byte[]> referencesData)
    {
        _referencesData = referencesData;
        _costuraReferencesDataResolver = new CosturaReferencesDataResolver();
    }

    public List<byte[]> Resolve(ModuleDefinition module, CancellationToken cancellationToken)
    {
        var costuraReferencesData = _costuraReferencesDataResolver.Resolve(module, cancellationToken);
        costuraReferencesData.AddRange(_referencesData);
        return costuraReferencesData;
    }
}


================================================
File: src/BitMono.Obfuscation/Referencing/CosturaReferencesDataResolver.cs
================================================
namespace BitMono.Obfuscation.Referencing;

public class CosturaReferencesDataResolver : IReferencesDataResolver
{
    public List<byte[]> Resolve(ModuleDefinition module, CancellationToken cancellationToken)
    {
        var result = new List<byte[]>();
        var resources = module.Resources;

        foreach (var resource in resources)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (resource.IsEmbeddedCosturaResource() == false)
            {
                continue;
            }
            var rawData = resource.GetData();
            if (rawData == null)
            {
                continue;
            }

            result.Add(Decompress(rawData));
        }
        return result;
    }

    private static byte[] Decompress(byte[] data)
    {
        using var input = new MemoryStream(data);
        using var output = new MemoryStream();
        using var deflateStream = new DeflateStream(input, CompressionMode.Decompress);
        deflateStream.CopyTo(output);
        return output.ToArray();
    }
}


================================================
File: src/BitMono.Obfuscation/Referencing/IReferencesDataResolver.cs
================================================
ï»¿namespace BitMono.Obfuscation.Referencing;

public interface IReferencesDataResolver
{
    List<byte[]> Resolve(ModuleDefinition module, CancellationToken cancellationToken);
}


================================================
File: src/BitMono.Obfuscation/Referencing/ReferencesDataResolver.cs
================================================
ï»¿namespace BitMono.Obfuscation.Referencing;

public class ReferencesDataResolver : IReferencesDataResolver
{
    private readonly string _referencesDirectoryName;

    public ReferencesDataResolver(string referencesDirectoryName)
    {
        _referencesDirectoryName = referencesDirectoryName;
    }

    public List<byte[]> Resolve(ModuleDefinition module, CancellationToken cancellationToken)
    {
        var result = new List<byte[]>();
        var references = Directory.GetFiles(_referencesDirectoryName);
        foreach (var reference in references)
        {
            result.Add(File.ReadAllBytes(reference));
        }
        return result;
    }
}


================================================
File: src/BitMono.Obfuscation/Starter/BitMonoContextFactory.cs
================================================
ï»¿namespace BitMono.Obfuscation.Starter;

public class BitMonoContextFactory
{
    private readonly ModuleDefinition _module;
    private readonly IReferencesDataResolver _referencesDataResolver;
    private readonly ObfuscationSettings _obfuscationSettings;

    public BitMonoContextFactory(ModuleDefinition module, IReferencesDataResolver referencesDataResolver,
        ObfuscationSettings obfuscationSettings)
    {
        _module = module;
        _referencesDataResolver = referencesDataResolver;
        _obfuscationSettings = obfuscationSettings;
    }

    public BitMonoContext Create(string filePath, string outputDirectoryName, CancellationToken cancellationToken)
    {
        var referencesData = _referencesDataResolver.Resolve(_module, cancellationToken);
        var fileName = Path.GetFileName(filePath);
        return new BitMonoContext
        {
            OutputDirectoryName = outputDirectoryName,
            ReferencesData = referencesData,
            Watermark = _obfuscationSettings.Watermark,
            FileName = fileName
        };
    }
}


================================================
File: src/BitMono.Obfuscation/Starter/BitMonoStarter.cs
================================================
ï»¿namespace BitMono.Obfuscation.Starter;

public class BitMonoStarter
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ObfuscationSettings _obfuscationSettings;
    private readonly IEngineContextAccessor _engineContextAccessor;
    private readonly ILogger _logger;

    public BitMonoStarter(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
        _obfuscationSettings = serviceProvider.GetRequiredService<IOptions<ObfuscationSettings>>().Value;
        _engineContextAccessor = serviceProvider.GetRequiredService<IEngineContextAccessor>();
        _logger = serviceProvider
            .GetRequiredService<ILogger>()
            .ForContext<BitMonoStarter>();
    }

    private async Task<bool> StartAsync(StarterContext context, IDataWriter dataWriter)
    {
        context.ThrowIfCancellationRequested();

        var obfuscator = new BitMonoObfuscator(_serviceProvider, context, dataWriter, _obfuscationSettings, _logger);
        await obfuscator.ProtectAsync();
        return true;
    }
    public Task<bool> StartAsync(FinalFileInfo info, IModuleFactory moduleFactory, IDataWriter dataWriter,
        IReferencesDataResolver referencesDataResolver,
        CancellationToken cancellationToken)
    {
        var runtimeModule = ModuleDefinition.FromFile(typeof(Runtime.Data).Assembly.Location);
        var moduleFactoryResult = moduleFactory.Create();
        var bitMonoContextFactory = new BitMonoContextFactory(moduleFactoryResult.Module, referencesDataResolver, _obfuscationSettings);
        var bitMonoContext = bitMonoContextFactory.Create(info.FilePath, info.OutputDirectoryPath, cancellationToken);
        var engineContextFactory = new StarterContextFactory(moduleFactoryResult, runtimeModule, bitMonoContext, cancellationToken);
        var engineContext = engineContextFactory.Create();
        _engineContextAccessor.Instance = engineContext;
        bitMonoContext.OutputFile = OutputFilePathFactory.Create(bitMonoContext);
        return StartAsync(engineContext, dataWriter);
    }
    public Task<bool> StartAsync(CompleteFileInfo info, CancellationToken cancellationToken)
    {
        return StartAsync(new FinalFileInfo(info.FileName, info.OutputDirectoryPath),
            new ModuleFactory(info.FileData, _obfuscationSettings, new LogErrorListener(_logger, _obfuscationSettings), _logger),
            new FileDataWriter(), new AutomaticReferencesDataResolver(info.FileReferences), cancellationToken);
    }
    public Task<bool> StartAsync(IncompleteFileInfo info, CancellationToken cancellationToken)
    {
        return StartAsync(new FinalFileInfo(info.FilePath, info.OutputDirectoryPath),
            new ModuleFactory(File.ReadAllBytes(info.FilePath), _obfuscationSettings, new LogErrorListener(_logger, _obfuscationSettings), _logger),
            new FileDataWriter(), new AutomaticPathReferencesDataResolver(info.ReferencesDirectoryPath), cancellationToken);
    }
}


================================================
File: src/BitMono.Obfuscation/Starter/StarterContextFactory.cs
================================================
ï»¿namespace BitMono.Obfuscation.Starter;

public class StarterContextFactory
{
    private readonly ModuleFactoryResult _moduleFactoryResult;
    private readonly ModuleDefinition _runtimeModule;
    private readonly BitMonoContext _context;
    private readonly CancellationToken _cancellationToken;

    public StarterContextFactory(ModuleFactoryResult moduleFactoryResult, ModuleDefinition runtimeModule,
        BitMonoContext context, CancellationToken cancellationToken)
    {
        _moduleFactoryResult = moduleFactoryResult;
        _runtimeModule = runtimeModule;
        _context = context;
        _cancellationToken = cancellationToken;
    }

    public StarterContext Create()
    {
        return new StarterContext
        {
            Module = _moduleFactoryResult.Module,
            RuntimeModule = _runtimeModule,
            ModuleReaderParameters = _moduleFactoryResult.ModuleReaderParameters,
            PEImageBuilder = _moduleFactoryResult.PEImageBuilder,
            RuntimeImporter = _runtimeModule.DefaultImporter,
            BitMonoContext = _context,
            CancellationToken = _cancellationToken,
        };
    }
}


================================================
File: src/BitMono.Obfuscation/Stripping/ObfuscationAttributesStrip.cs
================================================
namespace BitMono.Obfuscation.Stripping;

public class ObfuscationAttributesStrip
{
#pragma warning disable CS8618
    public List<CustomAttribute> ObfuscationAttributesSuccessStrip { get; set; }
    public List<CustomAttribute> ObfuscationAttributesFailStrip { get; set; }
    public List<CustomAttribute> ObfuscateAssemblyAttributesSuccessStrip { get; set; }
    public List<CustomAttribute> ObfuscateAssemblyAttributesFailStrip { get; set; }
#pragma warning restore CS8618
}



================================================
File: src/BitMono.Obfuscation/Stripping/ObfuscationAttributesStripper.cs
================================================
namespace BitMono.Obfuscation.Stripping;

public class ObfuscationAttributesStripper
{
    private readonly ObfuscationAttributeResolver _obfuscationAttributeResolver;
    private readonly ObfuscateAssemblyAttributeResolver _obfuscateAssemblyAttributeResolver;

    public ObfuscationAttributesStripper(
        ObfuscationAttributeResolver obfuscationAttributeResolver,
        ObfuscateAssemblyAttributeResolver obfuscateAssemblyAttributeResolver)
    {
        _obfuscationAttributeResolver = obfuscationAttributeResolver;
        _obfuscateAssemblyAttributeResolver = obfuscateAssemblyAttributeResolver;
    }

    public ObfuscationAttributesStrip Strip(StarterContext context, ProtectionsSort protectionsSort)
    {
        var obfuscationAttributesSuccessStrip = new List<CustomAttribute>();
        var obfuscationAttributesFailStrip = new List<CustomAttribute>();
        var obfuscateAssemblyAttributesSuccessStrip = new List<CustomAttribute>();
        var obfuscateAssemblyAttributesFailStrip = new List<CustomAttribute>();
        var protectionNames = protectionsSort.ProtectionsResolve.FoundProtections
            .Select(x => x.GetName())
            .ToList()
            .AsReadOnly();
        foreach (var customAttribute in context.Module.FindMembers().OfType<IHasCustomAttribute>())
        {
            context.ThrowIfCancellationRequested();

            StripAssemblyObfuscationAttribute(customAttribute, obfuscateAssemblyAttributesSuccessStrip, obfuscateAssemblyAttributesFailStrip);

            foreach (var protectionName in protectionNames)
            {
                context.ThrowIfCancellationRequested();

                StripObfuscationAttribute(protectionName, customAttribute, obfuscationAttributesSuccessStrip, obfuscationAttributesFailStrip,
                    context.CancellationToken);
            }
        }

        return new ObfuscationAttributesStrip
        {
            ObfuscationAttributesSuccessStrip = obfuscationAttributesSuccessStrip,
            ObfuscationAttributesFailStrip = obfuscationAttributesFailStrip,
            ObfuscateAssemblyAttributesSuccessStrip = obfuscateAssemblyAttributesSuccessStrip,
            ObfuscateAssemblyAttributesFailStrip = obfuscateAssemblyAttributesFailStrip
        };
    }

    private void StripAssemblyObfuscationAttribute(IHasCustomAttribute customAttribute,
        List<CustomAttribute> obfuscateAssemblyAttributesSuccessStrip, List<CustomAttribute> obfuscateAssemblyAttributesFailStrip)
    {
        if (_obfuscateAssemblyAttributeResolver.Resolve(null, customAttribute, out var obfuscateAssemblyAttributeData) == false)
        {
            return;
        }
        if (obfuscateAssemblyAttributeData.StripAfterObfuscation == false)
        {
            return;
        }

        var attribute = obfuscateAssemblyAttributeData.CustomAttribute;
        if (customAttribute.CustomAttributes.Remove(attribute))
        {
            obfuscateAssemblyAttributesSuccessStrip.Add(attribute);
        }
        else
        {
            obfuscateAssemblyAttributesFailStrip.Add(attribute);
        }
    }
    private void StripObfuscationAttribute(string protectionName, IHasCustomAttribute customAttribute,
        List<CustomAttribute> obfuscationAttributesSuccessStrip, List<CustomAttribute> obfuscationAttributesFailStrip,
        CancellationToken cancellationToken)
    {
        if (_obfuscationAttributeResolver.Resolve(protectionName, customAttribute, out var obfuscationAttributeData) == false)
        {
            return;
        }
        foreach (var attributeData in obfuscationAttributeData)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (attributeData.StripAfterObfuscation == false)
            {
                continue;
            }

            var attribute = attributeData.CustomAttribute;
            if (customAttribute.CustomAttributes.Remove(attribute))
            {
                obfuscationAttributesSuccessStrip.Add(attribute);
            }
            else
            {
                obfuscationAttributesFailStrip.Add(attribute);
            }
        }
    }
}


================================================
File: src/BitMono.Protections/AntiDe4dot.cs
================================================
ï»¿namespace BitMono.Protections;

public class AntiDe4dot : Protection
{
    public AntiDe4dot(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        var module = Context.Module;
        CustomInjector.InjectAttribute(module, "SmartAssembly.Attributes", "PoweredBy", string.Empty);
        CustomInjector.InjectAttribute(module, "Xenocode.Client.Attributes.AssemblyAttributes", "PoweredBy", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "ObfuscatedByGoliath", string.Empty);
        CustomInjector.InjectAttribute(module, "SecureTeam.Attributes", "ObfuscatedByAgileDotNet", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "TrinityObfuscator", string.Empty);
        CustomInjector.InjectAttribute(module, "SecureTeam.Attributes", "ObfuscatedByCliSecure", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "ZYXDNGuarder", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "BabelObfuscator", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "BabelObfuscator", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "Dotfuscator", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "Centos", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "ConfusedBy", string.Empty);
        CustomInjector.InjectAttribute(module, "NineRays.Obfuscator", "Evaluation", string.Empty);
        CustomInjector.InjectAttribute(module, "CryptoObfuscator", "ProtectedWithCryptoObfuscator", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "();\u0009", string.Empty);
        CustomInjector.InjectAttribute(module, string.Empty, "EMyPID_8234_", string.Empty);
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/AntiDebugBreakpoints.cs
================================================
ï»¿namespace BitMono.Protections;

[DoNotResolve(MemberInclusionFlags.SpecialRuntime)]
public class AntiDebugBreakpoints : Protection
{
    public AntiDebugBreakpoints(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    [SuppressMessage("ReSharper", "AssignNullToNotNullAttribute")]
    [SuppressMessage("ReSharper", "InvertIf")]
    public override Task ExecuteAsync()
    {
        var importer = Context.ModuleImporter;
        var threadSleepMethods = new List<IMethodDescriptor>
        {
            importer.ImportMethod(typeof(Thread).GetMethod(nameof(Thread.Sleep), new[]
            {
                typeof(int)
            })),
            importer.ImportMethod(typeof(Thread).GetMethod(nameof(Thread.Sleep), new[]
            {
                typeof(TimeSpan)
            })),
            importer.ImportMethod(typeof(Task).GetMethod(nameof(Task.Delay), new[]
            {
                typeof(int)
            })),
            importer.ImportMethod(typeof(Task).GetMethod(nameof(Task.Delay), new[]
            {
                typeof(TimeSpan)
            })),
            importer.ImportMethod(typeof(Task).GetMethod(nameof(Task.Delay), new[]
            {
                typeof(int),
                typeof(CancellationToken),
            })),
            importer.ImportMethod(typeof(Task).GetMethod(nameof(Task.Delay), new[]
            {
                typeof(TimeSpan),
                typeof(CancellationToken),
            })),
        };
        var dateTimeUtcNowMethod =
            importer.ImportMethod(typeof(DateTime).GetProperty(nameof(DateTime.UtcNow)).GetMethod);
        var dateTimeSubtractionMethod = importer.ImportMethod(typeof(DateTime).GetMethod("op_Subtraction", new[]
        {
            typeof(DateTime),
            typeof(DateTime)
        }));
        var timeSpanTotalMillisecondsMethod =
            importer.ImportMethod(typeof(TimeSpan).GetProperty(nameof(TimeSpan.TotalMilliseconds))
                .GetMethod);
        var dateTime = importer.ImportType(typeof(DateTime)).ToTypeSignature(isValueType: true);
        var timeSpan = importer.ImportType(typeof(TimeSpan)).ToTypeSignature(isValueType: true);
        var @int = importer.ImportType(typeof(int)).ToTypeSignature(isValueType: true);

        var signatureComparer = new SignatureComparer();
        foreach (var method in Context.Parameters.Members.OfType<MethodDefinition>())
        {
            if (method.IsConstructor)
            {
                continue;
            }
            if (method.IsGetMethod || method.IsSetMethod)
            {
                continue;
            }
            if (method.CilMethodBody is not { } body)
            {
                continue;
            }
            if (body.Instructions.Count < 5)
            {
                continue;
            }

            var startIndex = 0;
            var endIndex = body.Instructions.Count - 1;
            var methodShouldBeIgnored = false;

            for (var i = startIndex; i < endIndex; i++)
            {
                var instruction = body.Instructions[i];
                if (instruction.OpCode != CilOpCodes.Call)
                {
                    continue;
                }
                if (instruction.Operand is not MemberReference member)
                {
                    continue;
                }
                if (threadSleepMethods.Any(x => signatureComparer.Equals(member, x)) == false)
                {
                    continue;
                }

                methodShouldBeIgnored = true;
                break;
            }

            if (methodShouldBeIgnored)
            {
                continue;
            }

            var dateTimeLocal = new CilLocalVariable(dateTime);
            var timeSpanLocal = new CilLocalVariable(timeSpan);
            var intLocal = new CilLocalVariable(@int);

            body.LocalVariables.Add(dateTimeLocal);
            body.LocalVariables.Add(timeSpanLocal);
            body.LocalVariables.Add(intLocal);

            body.Instructions.InsertRange(startIndex,
            [
                new CilInstruction(CilOpCodes.Call, dateTimeUtcNowMethod),
                new CilInstruction(CilOpCodes.Stloc_S, dateTimeLocal)
            ]);

            var nopInstruction = new CilInstruction(CilOpCodes.Nop);
            var nopLabel = nopInstruction.CreateLabel();
            body.Instructions.InsertRange(endIndex,
            [
                new CilInstruction(CilOpCodes.Call, dateTimeUtcNowMethod),
                new CilInstruction(CilOpCodes.Ldloc_S, dateTimeLocal),
                new CilInstruction(CilOpCodes.Call, dateTimeSubtractionMethod),
                new CilInstruction(CilOpCodes.Stloc_S, timeSpanLocal),
                new CilInstruction(CilOpCodes.Ldloca_S, timeSpanLocal),
                new CilInstruction(CilOpCodes.Call, timeSpanTotalMillisecondsMethod),
                new CilInstruction(CilOpCodes.Ldc_R8, 5000.0),
                new CilInstruction(CilOpCodes.Ble_Un_S, nopLabel),
                new CilInstruction(CilOpCodes.Ldc_I4_1),
                new CilInstruction(CilOpCodes.Ldc_I4_0),
                new CilInstruction(CilOpCodes.Stloc_S, intLocal),
                new CilInstruction(CilOpCodes.Ldloc_S, intLocal),
                new CilInstruction(CilOpCodes.Div),
                new CilInstruction(CilOpCodes.Pop),
                nopInstruction
            ]);
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/AntiDecompiler.cs
================================================
ï»¿namespace BitMono.Protections;

[RuntimeMonikerMono]
public class AntiDecompiler : PipelineProtection
{
    public AntiDecompiler(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        return Task.CompletedTask;
    }
    public override IEnumerable<IPhaseProtection> PopulatePipeline()
    {
        yield return new AntiDnSpyAnalyzer(ServiceProvider);
    }
}
[ProtectionName(nameof(AntiDnSpyAnalyzer))]
public class AntiDnSpyAnalyzer : PhaseProtection
{
    public AntiDnSpyAnalyzer(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        foreach (var type in Context.Parameters.Members.OfType<TypeDefinition>())
        {
            if (type.IsModuleType && type.IsNested)
            {
                type.Attributes = TypeAttributes.Sealed | TypeAttributes.ExplicitLayout;
            }
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/AntiILdasm.cs
================================================
ï»¿namespace BitMono.Protections;

public class AntiILdasm : Protection
{
    public AntiILdasm(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        MscorlibInjector.InjectAttribute(Context.Module, typeof(SuppressIldasmAttribute).Namespace!,
            nameof(SuppressIldasmAttribute), Context.Module);
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/BillionNops.cs
================================================
namespace BitMono.Protections;

public class BillionNops : Protection
{
    private readonly Renamer _renamer;

    public BillionNops(Renamer renamer, IServiceProvider serviceProvider) : base(serviceProvider)
    {
        _renamer = renamer;
    }

    public override Task ExecuteAsync()
    {
        var module = Context.Module;
        var moduleType = module.GetOrCreateModuleType();
        var factory = module.CorLibTypeFactory;
        var method = new MethodDefinition(_renamer.RenameUnsafely(), MethodAttributes.Public | MethodAttributes.Static,
            MethodSignature.CreateStatic(factory.Void));
        moduleType.Methods.Add(method);
        var body = method.CilMethodBody = new CilMethodBody(method);
        for (var i = 0; i < 100000; i++)
        {
            Context.ThrowIfCancellationTokenRequested();

            body.Instructions.Insert(0, new CilInstruction(CilOpCodes.Nop));
        }
        body.Instructions.Add(new CilInstruction(CilOpCodes.Ret));
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/BitDecompiler.cs
================================================
namespace BitMono.Protections;

[RuntimeMonikerMono]
public class BitDecompiler : PackerProtection
{
    public BitDecompiler(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        using (var stream = File.Open(Context.BitMonoContext.OutputFile, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))
        using (var reader = new BinaryReader(stream))
        using (var writer = new BinaryWriter(stream))
        {
            stream.Position = 0x3C;
            var peHeader = reader.ReadUInt32();
            stream.Position = peHeader;

            stream.Position += 0x6;
            var numberOfSections = reader.ReadUInt16();

            stream.Position += 0x10;
            var x64PEOptionsHeader = reader.ReadUInt16() == 0x20B;

            stream.Position += x64PEOptionsHeader ? 0x38 : 0x28 + 0xA6;
            var dotNetVirtualAddress = reader.ReadUInt32();

            uint dotNetPointerRaw = 0;
            stream.Position += 0xC;
            for (var i = 0; i < numberOfSections; i++)
            {
                stream.Position += 0xC;
                var virtualAddress = reader.ReadUInt32();
                var sizeOfRawData = reader.ReadUInt32();
                var pointerToRawData = reader.ReadUInt32();
                stream.Position += 0x10;

                if (dotNetVirtualAddress >= virtualAddress && dotNetVirtualAddress < virtualAddress + sizeOfRawData && dotNetPointerRaw == 0)
                {
                    dotNetPointerRaw = dotNetVirtualAddress + pointerToRawData - virtualAddress;
                }
            }

            stream.Position = dotNetPointerRaw;
            writer.Write(0);
            writer.Write(0);
            stream.Position += 0x4;
            writer.Write(0);
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/BitDotNet.cs
================================================
ï»¿namespace BitMono.Protections;

[RuntimeMonikerMono]
public class BitDotNet : PackerProtection
{
    private const int PEHeaderWithExtraByteHex = 0x00014550;

    public BitDotNet(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        using (var stream = File.Open(Context.BitMonoContext.OutputFile, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))
        using (var reader = new BinaryReader(stream))
        using (var writer = new BinaryWriter(stream))
        {
            stream.Position = 0x3C;
            var peHeader = reader.ReadUInt32();
            stream.Position = peHeader;
            writer.Write(PEHeaderWithExtraByteHex);

            stream.Position += 0x2;
            var numberOfSections = reader.ReadUInt16();

            stream.Position += 0x10;
            var x64PEOptionsHeader = reader.ReadUInt16() == 0x20B;

            stream.Position += x64PEOptionsHeader ? 0x38 : 0x28 + 0xA6;
            var dotNetVirtualAddress = reader.ReadUInt32();

            uint dotNetPointerRaw = 0;
            stream.Position += 0xC;
            for (var i = 0; i < numberOfSections; i++)
            {
                stream.Position += 0xC;
                var virtualAddress = reader.ReadUInt32();
                var sizeOfRawData = reader.ReadUInt32();
                var pointerToRawData = reader.ReadUInt32();
                stream.Position += 0x10;

                if (dotNetVirtualAddress >= virtualAddress && dotNetVirtualAddress < virtualAddress + sizeOfRawData && dotNetPointerRaw == 0)
                {
                    dotNetPointerRaw = dotNetVirtualAddress + pointerToRawData - virtualAddress;
                }
            }

            stream.Position = dotNetPointerRaw;
            writer.Write(0);
            writer.Write(0);
            stream.Position += 0x4;
            writer.Write(0);
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/BitMethodDotnet.cs
================================================
ï»¿namespace BitMono.Protections;

[DoNotResolve(MemberInclusionFlags.SpecialRuntime)]
public class BitMethodDotnet : Protection
{
    private readonly RandomNext _randomNext;

    public BitMethodDotnet(RandomNext randomNext, IServiceProvider serviceProvider) : base(serviceProvider)
    {
        _randomNext = randomNext;
    }

    public override Task ExecuteAsync()
    {
        foreach (var method in Context.Parameters.Members.OfType<MethodDefinition>())
        {
            if (method.CilMethodBody is not { } body)
            {
                continue;
            }
            if (method.IsConstructor)
            {
                continue;
            }

            const int firstInstruction = 0;
            var instruction = GetRandomInstruction();
            var label = body.Instructions[firstInstruction].CreateLabel();
            body.Instructions.Insert(firstInstruction, new CilInstruction(CilOpCodes.Br_S));
            body.Instructions.Insert(firstInstruction + 1, instruction);
            body.Instructions[firstInstruction].Operand = label;
        }
        return Task.CompletedTask;
    }

    /// <summary>
    /// Get the random instruction that breaks the decompiler method.
    /// </summary>
    private CilInstruction GetRandomInstruction()
    {
        var randomValue = _randomNext(0, 3);
        var randomOpCode = randomValue switch
        {
            0 => CilOpCodes.Readonly,
            1 => CilOpCodes.Unaligned,
            2 => CilOpCodes.Volatile,
            3 => CilOpCodes.Constrained,
            _ => throw new ArgumentOutOfRangeException($"Random value {randomValue} cannot be selected as Random CilOpCode"),
        };
        return randomOpCode == CilOpCodes.Unaligned
            ? new CilInstruction(randomOpCode, (sbyte)0)
            : new CilInstruction(randomOpCode);
    }
}


================================================
File: src/BitMono.Protections/BitMono.Protections.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props" />

  <ItemGroup>
    <ProjectReference Include="..\BitMono.API\BitMono.API.csproj" />
    <ProjectReference Include="..\BitMono.Core\BitMono.Core.csproj" />
    <ProjectReference Include="..\BitMono.Runtime\BitMono.Runtime.csproj" />
    <ProjectReference Include="..\BitMono.Utilities\BitMono.Utilities.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="NullGuard.Fody" Version="3.1.1" PrivateAssets="All" />
  </ItemGroup>

</Project>


================================================
File: src/BitMono.Protections/BitMono.cs
================================================
namespace BitMono.Protections;

[RuntimeMonikerMono]
public class BitMono : PackerProtection
{
    public BitMono(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        using (var stream = File.Open(Context.BitMonoContext.OutputFile, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))
        using (var reader = new BinaryReader(stream))
        using (var writer = new BinaryWriter(stream))
        {
            stream.Position = 0x3C;
            var peHeader = reader.ReadUInt32();
            stream.Position = peHeader;

            stream.Position += 0x18;
            var x64PEOptionsHeader = reader.ReadUInt16() == 0x20B;

            stream.Position += x64PEOptionsHeader ? 0x6A : 0x5A;
            writer.Write(0x00013); // NumberOfRvaAndSizes

            stream.Position += 0xC;
            writer.Write(0); // Import.Size

            stream.Position += 0x20;
            writer.Write(0); // Debug.VirtualAddress
            writer.Write(0); // Debug.Size

            stream.Position += 0x3C;
            writer.Write(0); // .NET.Size
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/BitTimeDateStamp.cs
================================================
ï»¿namespace BitMono.Protections;

public class BitTimeDateStamp : PackerProtection
{
    public BitTimeDateStamp(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        using (var stream = File.Open(Context.BitMonoContext.OutputFile, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))
        using (var reader = new BinaryReader(stream))
        using (var writer = new BinaryWriter(stream))
        {
            stream.Position = 0x3C;
            var peHeader = reader.ReadUInt32();
            stream.Position = peHeader;
            var timeDateStamp = stream.Position + 0x8;
            stream.Position = timeDateStamp;
            writer.Write(0);
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/CallToCalli.cs
================================================
ï»¿namespace BitMono.Protections;

[DoNotResolve(MemberInclusionFlags.SpecialRuntime)]
public class CallToCalli : Protection
{
    public CallToCalli(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    [SuppressMessage("ReSharper", "AssignNullToNotNullAttribute")]
    [SuppressMessage("ReSharper", "PossibleNullReferenceException")]
    [SuppressMessage("ReSharper", "InvertIf")]
    public override Task ExecuteAsync()
    {
        var importer = Context.ModuleImporter;
        var runtimeMethodHandle = importer.ImportType(typeof(RuntimeMethodHandle)).ToTypeSignature(isValueType: true);
        var getTypeFromHandleMethod = importer.ImportMethod(typeof(Type).GetMethod(nameof(Type.GetTypeFromHandle), new[]
        {
            typeof(RuntimeTypeHandle)
        }));
        var getModuleMethod = importer.ImportMethod(typeof(Type).GetProperty(nameof(Type.Module)).GetMethod);
        var resolveMethodMethod = importer.ImportMethod(typeof(Module).GetMethod(nameof(Module.ResolveMethod), new[]
        {
            typeof(int)
        }));
        var getMethodHandleMethod = importer.ImportMethod(typeof(MethodBase).GetProperty(nameof(MethodBase.MethodHandle)).GetMethod);
        var getFunctionPointerMethod = importer.ImportMethod(typeof(RuntimeMethodHandle).GetMethod(nameof(RuntimeMethodHandle.GetFunctionPointer)));

        var module = Context.Module;
        var moduleType = module.GetOrCreateModuleType();
        foreach (var method in Context.Parameters.Members.OfType<MethodDefinition>())
        {
            if (method is not { CilMethodBody: { } body, DeclaringType.IsModuleType: false })
            {
                continue;
            }

            for (var i = 0; i < body.Instructions.Count; i++)
            {
                var instruction = body.Instructions[i];
                if (instruction.OpCode != CilOpCodes.Call)
                {
                    continue;
                }
                if (instruction.Operand is not IMethodDescriptor methodDescriptor)
                {
                    continue;
                }
                var callingMethod = methodDescriptor.Resolve();
                if (callingMethod?.Signature == null)
                {
                    continue;
                }
                if (module.TryLookupMember(callingMethod.MetadataToken, out var callingMethodMetadata) == false)
                {
                    continue;
                }

                var runtimeMethodHandleLocal = new CilLocalVariable(runtimeMethodHandle);
                body.LocalVariables.Add(runtimeMethodHandleLocal);
                instruction.ReplaceWith(CilOpCodes.Ldtoken, moduleType);
                body.Instructions.InsertRange(i + 1,
                [
                    new CilInstruction(CilOpCodes.Call, getTypeFromHandleMethod),
                    new CilInstruction(CilOpCodes.Callvirt, getModuleMethod),
                    new CilInstruction(CilOpCodes.Ldc_I4, callingMethodMetadata.MetadataToken.ToInt32()),
                    new CilInstruction(CilOpCodes.Call, resolveMethodMethod),
                    new CilInstruction(CilOpCodes.Callvirt, getMethodHandleMethod),
                    new CilInstruction(CilOpCodes.Stloc, runtimeMethodHandleLocal),
                    new CilInstruction(CilOpCodes.Ldloca, runtimeMethodHandleLocal),
                    new CilInstruction(CilOpCodes.Call, getFunctionPointerMethod),
                    new CilInstruction(CilOpCodes.Calli, callingMethod.Signature.MakeStandAloneSignature())
                ]);
            }
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/DotNetHook.cs
================================================
ï»¿namespace BitMono.Protections;

public class DotNetHook : Protection
{
    private readonly Renamer _renamer;
    private readonly RandomNext _randomNext;

    public DotNetHook(Renamer renamer, RandomNext randomNext, IServiceProvider serviceProvider) : base(serviceProvider)
    {
        _renamer = renamer;
        _randomNext = randomNext;
    }

    public override Task ExecuteAsync()
    {
        var module = Context.Module;
        var runtimeModule = Context.RuntimeModule;
        var runtimeHookingType = runtimeModule.ResolveOrThrow<TypeDefinition>(typeof(Hooking));
        var runtimeRedirectStubMethod = runtimeHookingType.Methods.Single(x => x.Name!.Equals(nameof(Hooking.RedirectStub)));
        var listener = new ModifyInjectTypeClonerListener(ModifyFlags.All, _renamer, module);
        var memberCloneResult = new MemberCloner(module, listener)
            .Include(runtimeHookingType)
            .CloneSafely(module, runtimeModule);
        var redirectStubMethod = memberCloneResult.GetClonedMember(runtimeRedirectStubMethod);

        var factory = module.CorLibTypeFactory;
        var systemVoid = factory.Void;

        var moduleType = module.GetOrCreateModuleType();
        var moduleCctor = moduleType.GetOrCreateStaticConstructor();
        foreach (var method in Context.Parameters.Members.OfType<MethodDefinition>())
        {
            if (method.CilMethodBody is not { } body)
            {
                continue;
            }

            for (var i = 0; i < body.Instructions.Count; i++)
            {
                var instruction = body.Instructions[i];
                if (instruction.OpCode.FlowControl != CilFlowControl.Call)
                {
                    continue;
                }
                if (instruction.Operand is not IMethodDescriptor callingOperandMethod)
                {
                    continue;
                }
                var callingMethod = callingOperandMethod.Resolve();
                if (callingMethod == null)
                {
                    continue;
                }
                if (callingMethod.CilMethodBody == null || callingMethod.Signature == null || callingMethod.Managed == false)
                {
                    continue;
                }
                if (callingMethod.ParameterDefinitions.Any(p => p.IsIn || p.IsOut))
                {
                    continue;
                }
                if (module.TryLookupMember(callingMethod.MetadataToken, out var callingMethodMetadata) == false)
                {
                    continue;
                }

                var dummyMethod = new MethodDefinition(_renamer.RenameUnsafely(), callingMethod.Attributes, callingMethod.Signature)
                {
                    IsAssembly = true,
                    IsStatic = true
                }.AssignNextAvailableToken(module);
                moduleType.Methods.Add(dummyMethod);
                foreach (var actualParameter in callingMethod.ParameterDefinitions)
                {
                    var parameter = new ParameterDefinition(actualParameter.Sequence,
                        actualParameter.Name, actualParameter.Attributes);
                    dummyMethod.ParameterDefinitions.Add(parameter);
                }
                var dummyMethodBody = dummyMethod.CilMethodBody = new CilMethodBody(dummyMethod);
                if (callingMethod.Signature.ReturnsValue)
                {
                    dummyMethodBody.Instructions.Add(new CilInstruction(CilOpCodes.Ldnull));
                }
                dummyMethodBody.Instructions.Add(new CilInstruction(CilOpCodes.Ret));
                var signature = MethodSignature.CreateStatic(systemVoid);
                var initializationMethod = new MethodDefinition(
                    _renamer.RenameUnsafely(),
                    MethodAttributes.Assembly | MethodAttributes.Static,
                    signature);
                initializationMethod.CilMethodBody = new CilMethodBody(initializationMethod)
                {
                    Instructions =
                    {
                        new CilInstruction(CilOpCodes.Ldc_I4, dummyMethod.MetadataToken.ToInt32()),
                        new CilInstruction(CilOpCodes.Ldc_I4, callingMethodMetadata.MetadataToken.ToInt32()),
                        new CilInstruction(CilOpCodes.Call, redirectStubMethod),
                        new CilInstruction(CilOpCodes.Ret)
                    }
                };
                moduleType.Methods.Add(initializationMethod);

                instruction.Operand = dummyMethod;
                var randomIndex = _randomNext(0, moduleCctor.CilMethodBody!.Instructions.CountWithoutRet());
                moduleCctor.CilMethodBody.Instructions.Insert(randomIndex,
                    new CilInstruction(CilOpCodes.Call, initializationMethod));
            }
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <NullGuard />
</Weavers>


================================================
File: src/BitMono.Protections/FullRenamer.cs
================================================
ï»¿namespace BitMono.Protections;

[DoNotResolve(MemberInclusionFlags.SpecialRuntime | MemberInclusionFlags.Model | MemberInclusionFlags.Reflection)]
public class FullRenamer : Protection
{
    private readonly Renamer _renamer;

    public FullRenamer(Renamer renamer, IServiceProvider serviceProvider) : base(serviceProvider)
    {
        _renamer = renamer;
    }

    public override Task ExecuteAsync()
    {
        foreach (var method in Context.Parameters.Members.OfType<MethodDefinition>())
        {
            if (method.DeclaringType?.IsModuleType == true)
            {
                continue;
            }
            if (method.IsConstructor || method.IsVirtual)
            {
                continue;
            }
            if (method.IsCompilerGenerated())
            {
                continue;
            }
            _renamer.Rename(method);
            if (!method.HasParameters())
            {
                continue;
            }
            foreach (var parameter in method.Parameters)
            {
                if (parameter.Definition == null)
                {
                    continue;
                }
                _renamer.Rename(parameter.Definition);
            }
        }
        foreach (var type in Context.Parameters.Members.OfType<TypeDefinition>())
        {
            if (type.IsModuleType)
            {
                continue;
            }
            if (type.IsCompilerGenerated())
            {
                continue;
            }
            _renamer.Rename(type);
        }
        foreach (var field in Context.Parameters.Members.OfType<FieldDefinition>())
        {
            if (field.DeclaringType?.IsModuleType == true)
            {
                continue;
            }
            if (field.IsCompilerGenerated())
            {
                continue;
            }
            _renamer.Rename(field);
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/GlobalUsings.cs
================================================
ï»¿global using AsmResolver.DotNet;
global using AsmResolver.DotNet.Cloning;
global using AsmResolver.DotNet.Code.Cil;
global using AsmResolver.DotNet.Signatures;
global using AsmResolver.PE.DotNet.Cil;
global using BitMono.Runtime;
global using System;
global using System.Collections.Generic;
global using System.Diagnostics.CodeAnalysis;
global using System.IO;
global using System.Linq;
global using System.Reflection;
global using System.Runtime.CompilerServices;
global using System.Text;
global using System.Threading;
global using System.Threading.Tasks;
global using AsmResolver.DotNet.Code.Native;
global using AsmResolver.PE.File;
global using BitMono.API.Protections;
global using BitMono.Core;
global using BitMono.Core.Attributes;
global using BitMono.Core.Injection;
global using BitMono.Core.Renaming;
global using BitMono.Core.Services;
global using BitMono.Utilities.AsmResolver;
global using JetBrains.Annotations;
global using MethodAttributes = AsmResolver.PE.DotNet.Metadata.Tables.MethodAttributes;
global using MethodImplAttributes = AsmResolver.PE.DotNet.Metadata.Tables.MethodImplAttributes;
global using TypeAttributes = AsmResolver.PE.DotNet.Metadata.Tables.TypeAttributes;


================================================
File: src/BitMono.Protections/NoNamespaces.cs
================================================
ï»¿namespace BitMono.Protections;

[DoNotResolve(MemberInclusionFlags.SpecialRuntime)]
public class NoNamespaces : Protection
{
    public NoNamespaces(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        foreach (var type in Context.Parameters.Members.OfType<TypeDefinition>())
        {
            if (type.HasNamespace() == false)
            {
                continue;
            }

            type.Namespace = string.Empty;
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/ObjectReturnType.cs
================================================
ï»¿namespace BitMono.Protections;

[DoNotResolve(MemberInclusionFlags.SpecialRuntime)]
public class ObjectReturnType : Protection
{
    public ObjectReturnType(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        var factory = Context.Module.CorLibTypeFactory;
        var systemBoolean = factory.Boolean;
        var systemObject = factory.Object;
        foreach (var method in Context.Parameters.Members.OfType<MethodDefinition>())
        {
            if (method.Signature == null)
            {
                continue;
            }
            if (method.Signature.Returns(systemBoolean) == false)
            {
                continue;
            }
            if (method.IsConstructor || method.IsVirtual || method.IsSetMethod || method.IsGetMethod || method.IsAsync())
            {
                continue;
            }
            if (method.ParameterDefinitions.Any(p => p.IsOut || p.IsIn))
            {
                continue;
            }

            method.Signature.ReturnType = systemObject;
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/StringsEncryption.cs
================================================
ï»¿namespace BitMono.Protections;

[DoNotResolve(MemberInclusionFlags.SpecialRuntime)]
public class StringsEncryption : Protection
{
    private readonly Renamer _renamer;

    public StringsEncryption(Renamer renamer, IServiceProvider serviceProvider) : base(serviceProvider)
    {
        _renamer = renamer;
    }

    public override Task ExecuteAsync()
    {
        var module = Context.Module;
        var globalModuleType = module.GetOrCreateModuleType();
        MscorlibInjector.InjectCompilerGeneratedValueType(module, globalModuleType, _renamer.RenameUnsafely());
        var cryptKeyField = MscorlibInjector.InjectCompilerGeneratedArray(module, globalModuleType, Data.CryptKeyBytes, _renamer.RenameUnsafely());
        var saltBytesField = MscorlibInjector.InjectCompilerGeneratedArray(module, globalModuleType, Data.SaltBytes, _renamer.RenameUnsafely());

        var runtimeModule = Context.RuntimeModule;
        var runtimeDecryptorType = runtimeModule.ResolveOrThrow<TypeDefinition>(typeof(Decryptor));
        var runtimeDecryptMethod = runtimeDecryptorType.Methods.Single(x => x.Name!.Equals(nameof(Decryptor.Decrypt)));
        var listener = new ModifyInjectTypeClonerListener(ModifyFlags.All, _renamer, module);
        var memberCloneResult = new MemberCloner(module, listener)
            .Include(runtimeDecryptorType)
            .CloneSafely(module, runtimeModule);

        var decryptMethod = memberCloneResult.GetClonedMember(runtimeDecryptMethod);

        foreach (var method in Context.Parameters.Members.OfType<MethodDefinition>())
        {
            if (method.CilMethodBody is not { } body)
            {
                continue;
            }

            var instructions = body.Instructions;
            for (var i = 0; i < instructions.Count; i++)
            {
                var instruction = instructions[i];
                if (instruction.OpCode.Equals(CilOpCodes.Ldstr) == false)
                {
                    continue;
                }
                if (instruction.Operand is not string content)
                {
                    continue;
                }

                var data = Encryptor.EncryptContent(content, Data.SaltBytes, Data.CryptKeyBytes);
                var arrayName = _renamer.RenameUnsafely();
                var encryptedDataFieldDef = MscorlibInjector.InjectCompilerGeneratedArray(module, globalModuleType, data, arrayName);

                instruction.ReplaceWith(CilOpCodes.Ldsfld, encryptedDataFieldDef);
                instructions.InsertRange(i + 1,
                [
                    new CilInstruction(CilOpCodes.Ldsfld, saltBytesField),
                    new CilInstruction(CilOpCodes.Ldsfld, cryptKeyField),
                    new CilInstruction(CilOpCodes.Call, decryptMethod)
                ]);
            }
        }
        return Task.CompletedTask;
    }
}


================================================
File: src/BitMono.Protections/UnmanagedString.cs
================================================
ï»¿namespace BitMono.Protections;

[ConfigureForNativeCode]
[RuntimeMonikerNETCore]
[RuntimeMonikerNETFramework]
public class UnmanagedString : Protection
{
    public UnmanagedString(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    public override Task ExecuteAsync()
    {
        var moduleImporter = Context.ModuleImporter;
        var stringSbytePointerCtor =
            moduleImporter.ImportMethod(typeof(string).GetConstructor([typeof(sbyte*)])!);
        var stringCharPointerCtor =
            moduleImporter.ImportMethod(typeof(string).GetConstructor([typeof(char*)])!);
        var stringSbytePointerWithLengthCtor =
            moduleImporter.ImportMethod(typeof(string).GetConstructor([typeof(sbyte*), typeof(int), typeof(int)])!);
        var stringCharPointerWithLengthCtor =
            moduleImporter.ImportMethod(typeof(string).GetConstructor([typeof(char*), typeof(int), typeof(int)])!);
        var encodedStrings = new Dictionary<string, MethodDefinition>();
        foreach (var method in Context.Parameters.Members.OfType<MethodDefinition>())
        {
            if (method is { CilMethodBody: { } body })
            {
                var instructions = body.Instructions;
                for (var i = 0; i < instructions.Count; i++)
                {
                    var instruction = instructions[i];
                    if (instruction.OpCode == CilOpCodes.Ldstr && instruction.Operand is string content && content.Length > 0) // skip empty string
                    {
                        var useUnicode = !CanBeEncodedIn7BitASCII(content);
                        var addNullTerminator = !HasNullCharacter(content);

                        if (encodedStrings.TryGetValue(content, out var nativeMethod) == false) // reuse encoded strings
                        {
                            nativeMethod = CreateNativeMethod(content, Context.Module, Context.X86, useUnicode, addNullTerminator);
                            encodedStrings.Add(content, nativeMethod);
                        }

                        if (nativeMethod != null)
                        {
                            instruction.ReplaceWith(CilOpCodes.Call, nativeMethod);

                            if (addNullTerminator)
                            {
                                method.CilMethodBody.Instructions.Insert(++i,
                                    new CilInstruction(CilOpCodes.Newobj, useUnicode ? stringCharPointerCtor : stringSbytePointerCtor));
                            }
                            else
                            {
                                method.CilMethodBody.Instructions.Insert(++i,
                                    CilInstruction.CreateLdcI4(0));
                                method.CilMethodBody.Instructions.Insert(++i,
                                    CilInstruction.CreateLdcI4(content.Length));
                                method.CilMethodBody.Instructions.Insert(++i,
                                    new CilInstruction(CilOpCodes.Newobj, useUnicode ? stringCharPointerWithLengthCtor : stringSbytePointerWithLengthCtor));
                            }
                        }
                    }
                }

            }
        }
        return Task.CompletedTask;
    }

    private static MethodDefinition CreateNativeMethod(string content, ModuleDefinition module,
        bool x86, bool useUnicode, bool addNullTerminator)
    {
        var methodName = Guid.NewGuid().ToString();
        var factory = module.CorLibTypeFactory;
        var method = new MethodDefinition(methodName, MethodAttributes.Public | MethodAttributes.Static,
            MethodSignature.CreateStatic(factory.SByte.MakePointerType()));

        method.ImplAttributes |= MethodImplAttributes.Native | MethodImplAttributes.Unmanaged |
                                 MethodImplAttributes.PreserveSig;
        method.Attributes |= MethodAttributes.PInvokeImpl;

        module.GetOrCreateModuleType().Methods.Add(method);

        if (addNullTerminator)
        {
            content += "\0"; // not adding on byte level as it has encoding-dependent size
        }

        var stringBytes = useUnicode
            ? Encoding.Unicode.GetBytes(content)
            : Encoding.ASCII.GetBytes(content);

        IEnumerable<byte> code;
        if (x86)
        {
            code = new byte[]
            {
                0x55, // push ebp
                0x89, 0xE5, // mov ebp, esp
                0xE8, 0x05, 0x00, 0x00, 0x00, // call <jump1>
                0x83, 0xC0, 0x01, // add eax, 1
                // <jump2>:
                0x5D, // pop ebp
                0xC3, // ret
                // <jump1>:
                0x58, // pop eax
                0x83, 0xC0, 0x0B, // add eax, 0xb
                0xEB, 0xF8 // jmp <jump2>
            };
        }
        else
        {
            code = new byte[]
            {
                0x48, 0x8D, 0x05, 0x01, 0x00, 0x00, 0x00, // lea rax, [rip + 0x1]
                0xC3 // ret
            };
        }
        code = code.Concat(stringBytes);

        var body = new NativeMethodBody(method)
        {
            Code = code.ToArray()
        };
        method.NativeMethodBody = body;
        return method;
    }
    private static bool CanBeEncodedIn7BitASCII(string text)
    {
        for (var i = 0; i < text.Length; i++)
        {
            if (text[i] > '\x7f')
            {
                return false;
            }
        }
        return true;
    }
    private static bool HasNullCharacter(string text)
    {
        for (var i = 0; i < text.Length; i++)
        {
            if (text[i] == '\0')
            {
                return true;
            }
        }
        return false;
    }
}


================================================
File: src/BitMono.Runtime/AssemblyInfo.cs
================================================
ï»¿[assembly: InternalsVisibleTo("BitMono.CLI", AllInternalsVisible = true)]
[assembly: InternalsVisibleTo("BitMono.GUI", AllInternalsVisible = true)]
[assembly: InternalsVisibleTo("BitMono.Protections", AllInternalsVisible = true)]


================================================
File: src/BitMono.Runtime/BitMono.Runtime.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props" />

</Project>


================================================
File: src/BitMono.Runtime/Data.cs
================================================
ï»¿namespace BitMono.Runtime;

public struct Data
{
    internal static readonly byte[] CryptKeyBytes = new byte[8];
    internal static readonly byte[] SaltBytes = new byte[8];
    
    static Data()
    {
        CryptKeyBytes = new byte[8];
        SaltBytes = new byte[8];
    }
}


================================================
File: src/BitMono.Runtime/Decryptor.cs
================================================
ï»¿namespace BitMono.Runtime;

public struct Decryptor
{
    internal static string Decrypt(byte[] bytes, byte[] saltBytes, byte[] cryptKeyBytes)
    {
        byte[]? decryptedBytes = null;
        using (var memoryStream = new MemoryStream())
        {
            using (var aes = new RijndaelManaged())
            {
                aes.KeySize = 256;
                aes.BlockSize = 128;
                var key = new Rfc2898DeriveBytes(cryptKeyBytes, saltBytes, 1000);
                aes.Key = key.GetBytes(aes.KeySize / 8);
                aes.IV = key.GetBytes(aes.BlockSize / 8);
                aes.Mode = CipherMode.CBC;

                using (var cryptoStream = new CryptoStream(memoryStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    cryptoStream.Write(bytes, 0, bytes.Length);
                    cryptoStream.Close();
                }
                decryptedBytes = memoryStream.ToArray();
                key.Dispose();
            }
        }
        return Encoding.UTF8.GetString(decryptedBytes);
    }
}


================================================
File: src/BitMono.Runtime/Encryptor.cs
================================================
ï»¿namespace BitMono.Runtime;

public struct Encryptor
{
    internal static byte[] EncryptContent(string text, byte[] saltBytes, byte[] cryptKeyBytes)
    {
        var decryptBytes = Encoding.UTF8.GetBytes(text);
        byte[]? encryptedBytes = null;
        using (var memoryStream = new MemoryStream())
        {
            using (var aes = new RijndaelManaged())
            {
                aes.KeySize = 256;
                aes.BlockSize = 128;
                var key = new Rfc2898DeriveBytes(saltBytes, cryptKeyBytes, 1000);
                aes.Key = key.GetBytes(aes.KeySize / 8);
                aes.IV = key.GetBytes(aes.BlockSize / 8);
                aes.Mode = CipherMode.CBC;

                using (var cryptoStream = new CryptoStream(memoryStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    cryptoStream.Write(decryptBytes, 0, decryptBytes.Length);
                    cryptoStream.Close();
                }
                encryptedBytes = memoryStream.ToArray();
                key.Dispose();
            }
        }
        return encryptedBytes;
    }
}


================================================
File: src/BitMono.Runtime/GlobalUsings.cs
================================================
ï»¿global using System;
global using System.IO;
global using System.Runtime.CompilerServices;
global using System.Runtime.InteropServices;
global using System.Security.Cryptography;
global using System.Text;


================================================
File: src/BitMono.Runtime/Hooking.cs
================================================
ï»¿namespace BitMono.Runtime;

internal struct Hooking
{
    internal static void RedirectStub(int from, int to)
    {
        var fromMethodHandle = typeof(Hooking).Module.ResolveMethod(from).MethodHandle;
        var toMethodHandle = typeof(Hooking).Module.ResolveMethod(to).MethodHandle;
        RuntimeHelpers.PrepareMethod(fromMethodHandle);
        RuntimeHelpers.PrepareMethod(toMethodHandle);

        var fromPtr = fromMethodHandle.GetFunctionPointer();
        var toPtr = toMethodHandle.GetFunctionPointer();

        if (Environment.OSVersion.Platform is PlatformID.Unix or PlatformID.MacOSX)
        {
            const int PROT_EXEC = 0x04;
            const int PROT_READ = 0x01;
            const int PROT_WRITE = 0x02;

            mprotect(fromPtr, 5, PROT_READ | PROT_WRITE);

            MakeHook(fromPtr, toPtr);

            mprotect(fromPtr, 5, PROT_READ | PROT_EXEC);
        }
        else
        {
            VirtualProtect(fromPtr, (IntPtr)5, 0x40, out var oldProtect);

            MakeHook(fromPtr, toPtr);

            VirtualProtect(fromPtr, (IntPtr)5, oldProtect, out _);
        }
    }

    private static void MakeHook(IntPtr fromPtr, IntPtr toPtr)
    {
        const int x64BitProcess = 8;
        const int x32BitProcess = 4;
        if (IntPtr.Size == x64BitProcess)
        {
            Marshal.WriteByte(fromPtr, 0, 0x49);
            Marshal.WriteByte(fromPtr, 1, 0xBB);
            Marshal.WriteInt64(fromPtr, 2, toPtr.ToInt64());
            Marshal.WriteByte(fromPtr, 10, 0x41);
            Marshal.WriteByte(fromPtr, 11, 0xFF);
            Marshal.WriteByte(fromPtr, 12, 0xE3);
        }
        else if (IntPtr.Size == x32BitProcess)
        {
            Marshal.WriteByte(fromPtr, 0, 0xE9);
            Marshal.WriteInt32(fromPtr, 1, toPtr.ToInt32() - fromPtr.ToInt32() - 5);
            Marshal.WriteByte(fromPtr, 5, 0xC3);
        }
    }

    [DllImport("libc.so.6", EntryPoint = nameof(mprotect))]
    internal static extern int mprotect(IntPtr start, ulong len, int prot);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Winapi, EntryPoint = nameof(VirtualProtect))]
    internal static extern bool VirtualProtect(IntPtr address, IntPtr size, uint newProtect, out uint oldProtect);
}


================================================
File: src/BitMono.Shared/BitMono.Shared.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props" />

  <!-- Common Packages for all frameworks -->
  <ItemGroup>
    <PackageReference Include="NullGuard.Fody" Version="3.1.1" PrivateAssets="All" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    <PackageReference Include="Pocket" Version="0.0.3" />
    <PackageReference Include="morelinq" Version="4.4.0" />
    <PackageReference Include="Serilog" Version="4.0.0" />
    <PackageReference Include="Serilog.Enrichers.Sensitive" Version="1.7.3" />
    <PackageReference Include="Serilog.Enrichers.WithCaller" Version="1.2.0" />
    <PackageReference Include="Serilog.Extensions.Logging.File" Version="3.0.0" />
    <PackageReference Include="Serilog.Settings.Configuration" Version="7.0.1" />
    <PackageReference Include="Serilog.Sinks.Console" Version="4.1.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
    <PackageReference Include="Serilog.Sinks.Map" Version="2.0.0" />
    <PackageReference Include="Serilog.Extensions.Autofac.DependencyInjection" Version="5.0.0" />
  </ItemGroup>

  <!-- Packages specific to .NET 9.0 -->
  <ItemGroup Condition=" '$(TargetFramework)' == 'net9.0' ">
    <PackageReference Include="Autofac" Version="8.2.0" />
    <PackageReference Include="Autofac.Configuration" Version="7.0.0" />
    <PackageReference Include="Autofac.Extensions.DependencyInjection" Version="10.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.0" />
  </ItemGroup>

  <!-- Packages specific to .NET 8.0 -->
  <ItemGroup Condition=" '$(TargetFramework)' == 'net8.0' ">
    <PackageReference Include="Autofac" Version="8.2.0" />
    <PackageReference Include="Autofac.Configuration" Version="7.0.0" />
    <PackageReference Include="Autofac.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
  </ItemGroup>

  <!-- Packages specific to .NET 7.0 -->
  <ItemGroup Condition=" '$(TargetFramework)' == 'net7.0' ">
    <PackageReference Include="Autofac" Version="8.2.0" />
    <PackageReference Include="Autofac.Configuration" Version="7.0.0" />
    <PackageReference Include="Autofac.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
  </ItemGroup>

  <!-- Packages specific to .NET 6.0 -->
  <ItemGroup Condition=" '$(TargetFramework)' == 'net6.0' ">
    <PackageReference Include="Autofac" Version="7.1.0" />
    <PackageReference Include="Autofac.Configuration" Version="6.0.0" />
    <PackageReference Include="Autofac.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="7.0.4" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="7.0.0" />
  </ItemGroup>

  <!-- Packages specific to .NET Framework 4.6.2 -->
  <ItemGroup Condition=" '$(TargetFramework)' == 'net462' ">
    <PackageReference Include="System.Collections.Immutable" Version="1.7.1"/>
    <PackageReference Include="Autofac.Configuration" Version="6.0.0" />
    <PackageReference Include="Autofac.Extensions.DependencyInjection" Version="7.2.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="7.0.4" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="7.0.0" />
    <PackageReference Include="PolySharp" Version="1.15.0" />
  </ItemGroup>

  <!-- Packages specific to .NET Standard 2.1 -->
  <ItemGroup Condition=" '$(TargetFramework)' == 'netstandard2.1' ">
    <PackageReference Include="Autofac" Version="8.2.0" />
    <PackageReference Include="Autofac.Configuration" Version="7.0.0" />
    <PackageReference Include="Autofac.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
  </ItemGroup>

  <!-- Packages specific to .NET Standard 2.0 -->
  <ItemGroup Condition=" '$(TargetFramework)' == 'netstandard2.0' ">
    <PackageReference Include="System.Collections.Immutable" Version="1.7.1"/>
    <PackageReference Include="Autofac.Configuration" Version="6.0.0" />
    <PackageReference Include="Autofac.Extensions.DependencyInjection" Version="7.2.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="7.0.4" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="7.0.0" />
    <PackageReference Include="PolySharp" Version="1.15.0" />
  </ItemGroup>

</Project>


================================================
File: src/BitMono.Shared/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <NullGuard />
</Weavers>


================================================
File: src/BitMono.Shared/GlobalUsings.cs
================================================
ï»¿global using Newtonsoft.Json;
global using System.Collections.Generic;
global using NullGuard;


================================================
File: src/BitMono.Shared/Models/CriticalAttribute.cs
================================================
ï»¿namespace BitMono.Shared.Models;

public class CriticalAttribute
{
    public string Namespace { get; set; }
    public string Name { get; set; }
}


================================================
File: src/BitMono.Shared/Models/CriticalsSettings.cs
================================================
namespace BitMono.Shared.Models;

[NullGuard(ValidationFlags.NonPublic)]
public class CriticalsSettings
{
    public bool UseCriticalAttributes { get; set; }
    public bool UseCriticalModelAttributes { get; set; }
    public bool UseCriticalInterfaces { get; set; }
    public bool UseCriticalBaseTypes { get; set; }
    public bool UseCriticalMethodsStartsWith { get; set; }
    public bool UseCriticalMethods { get; set; }
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    public List<CriticalAttribute> CriticalAttributes { get; set; }
    public List<CriticalAttribute> CriticalModelAttributes { get; set; }
    public List<string> CriticalInterfaces { get; set; }
    public List<string> CriticalBaseTypes { get; set; }
    public List<string> CriticalMethodsStartsWith { get; set; }
    public List<string> CriticalMethods { get; set; }
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
}



================================================
File: src/BitMono.Shared/Models/ObfuscationSettings.cs
================================================
ï»¿namespace BitMono.Shared.Models;

public class ObfuscationSettings
{
    public bool Watermark { get; set; }
    public bool ClearCLI { get; set; }
    public bool ForceObfuscation { get; set; }
    public string ReferencesDirectoryName { get; set; }
    public string OutputDirectoryName { get; set; }
    public bool NotifyProtections { get; set; }
    public bool NoInliningMethodObfuscationExclude { get; set; }
    public bool SerializableBitObfuscationExclude { get; set; }
    public bool ObfuscationAttributeObfuscationExclude { get; set; }
    public bool ObfuscateAssemblyAttributeObfuscationExclude { get; set; }
    public bool ReflectionMembersObfuscationExclude { get; set; }
    public bool StripObfuscationAttributes { get; set; }
    public bool OutputPEImageBuildErrors { get; set; }
    public bool FailOnNoRequiredDependency { get; set; }
    public bool OutputRuntimeMonikerWarnings { get; set; }
    public bool OutputConfigureForNativeCodeWarnings { get; set; }
    public bool OpenFileDestinationInFileExplorer { get; set; }
    public bool SpecificNamespacesObfuscationOnly { get; set; }
    public string[]? SpecificNamespaces { get; set; }
    public string[]? RandomStrings { get; set; }
}


================================================
File: src/BitMono.Shared/Models/ProtectionSetting.cs
================================================
ï»¿namespace BitMono.Shared.Models;

public class ProtectionSetting
{
    [JsonRequired] public string Name { get; set; }
    public bool Enabled { get; set; }
    [JsonIgnore] public bool Disabled => Enabled == false;

    public void Enable()
    {
        Enabled = true;
    }
    public void Disable()
    {
        Enabled = false;
    }
}


================================================
File: src/BitMono.Shared/Models/ProtectionSettings.cs
================================================
namespace BitMono.Shared.Models;

public class ProtectionSettings
{
    public List<ProtectionSetting>? Protections { get; set; }
}


================================================
File: src/BitMono.Utilities/BitMono.Utilities.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>net9.0;net8.0;net7.0;net6.0;net462;netstandard2.1;netstandard2.0;</TargetFrameworks>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedProjectProps.props" />

  <ItemGroup>
    <PackageReference Include="NullGuard.Fody" Version="3.1.0" PrivateAssets="All" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\BitMono.API\BitMono.API.csproj" />
  </ItemGroup>

</Project>


================================================
File: src/BitMono.Utilities/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <NullGuard />
</Weavers>


================================================
File: src/BitMono.Utilities/GlobalUsings.cs
================================================
ï»¿global using AsmResolver;
global using AsmResolver.DotNet;
global using AsmResolver.DotNet.Code.Cil;
global using AsmResolver.PE.DotNet.Cil;
global using AsmResolver.PE.DotNet.Metadata.Tables;
global using MoreLinq;
global using NullGuard;
global using System;
global using System.Collections.Generic;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.IO;
global using System.Linq;
global using System.Reflection;
global using System.Runtime.CompilerServices;
global using System.Runtime.InteropServices;
global using System.Runtime.Versioning;
global using System.Text;
global using AsmResolver.DotNet.Cloning;
global using AsmResolver.DotNet.Signatures;
global using AsmResolver.DotNet.Signatures.Parsing;
global using TypeAttributes = AsmResolver.PE.DotNet.Metadata.Tables.TypeAttributes;


================================================
File: src/BitMono.Utilities/AsmResolver/CloneHelper.cs
================================================
namespace BitMono.Utilities.AsmResolver;

public static class CloneHelper
{
    /// <summary>
    /// Clones via AsmResolver's API,
    /// but removes the <see cref="cloningModule"/> assembly reference from <see cref="sourceModule"/>.
    /// This is needed as a workaround, because sometimes AsmResolver adds
    /// a reference of the included item to a <see cref="sourceModule"/>.
    /// See here more details about that problem: https://github.com/sunnamed434/BitMono/issues/207
    /// </summary>
    /// <param name="cloner">The cloner.</param>
    /// <param name="sourceModule">The source module.</param>
    /// <param name="cloningModule">The cloning module.</param>
    /// <returns>The clone result.</returns>
    public static MemberCloneResult CloneSafely(this MemberCloner cloner,
        ModuleDefinition sourceModule, ModuleDefinition cloningModule)
    {
        var cloningModuleAssembly = cloningModule.Assembly
                                    ?? throw new InvalidOperationException($"{nameof(cloningModule)} assembly was null");

        var result = cloner.Clone();

        var fullName = cloningModuleAssembly.FullName;
        if (sourceModule.AssemblyReferences.FirstOrDefault(
                x => x.FullName == fullName) is { } assembly)
        {
            sourceModule.AssemblyReferences.Remove(assembly);
        }

        return result;
    }
}


================================================
File: src/BitMono.Utilities/AsmResolver/GenericExtensions.cs
================================================
ï»¿namespace BitMono.Utilities.AsmResolver;

public static class GenericExtensions
{
    public static TMetadataMember AssignNextAvailableToken<TMetadataMember>(this TMetadataMember source, ModuleDefinition moduleDefinition)
        where TMetadataMember : MetadataMember
    {
        moduleDefinition.TokenAllocator.AssignNextAvailableToken(source);
        return source;
    }
}


================================================
File: src/BitMono.Utilities/AsmResolver/InstructionExtensions.cs
================================================
ï»¿namespace BitMono.Utilities.AsmResolver;

public static class InstructionExtensions
{
    public static int CountWithoutRet(this CilInstructionCollection source)
    {
        const int instructionCount = 1;
        if (source[source.Count - instructionCount].OpCode == CilOpCodes.Ret)
        {
            return source.Count - instructionCount;
        }
        throw new IndexOutOfRangeException();
    }
}


================================================
File: src/BitMono.Utilities/AsmResolver/ManifestResourceExtensions.cs
================================================
ï»¿namespace BitMono.Utilities.AsmResolver;

[SuppressMessage("ReSharper", "InvertIf")]
public static class ManifestResourceExtensions
{
    private const string CosturaResourceNameStart = "costura.";
    private const string CosturaResourceNameEnd = ".dll.compressed";
    private const int MinCosturaResourceNameCharactersLenght = 19;

    public static bool IsEmbeddedCosturaResource(this ManifestResource source)
    {
        if (Utf8String.IsNullOrEmpty(source.Name) == false)
        {
            if (source.IsEmbedded)
            {
                var name = source.Name.Value;
                if (name.Length > MinCosturaResourceNameCharactersLenght
                    && name.StartsWith(CosturaResourceNameStart)
                    && name.EndsWith(CosturaResourceNameEnd))
                {
                    return true;
                }
            }
        }
        return false;
    }
}


================================================
File: src/BitMono.Utilities/AsmResolver/MethodDefinitionExtensions.cs
================================================
ï»¿namespace BitMono.Utilities.AsmResolver;

public static class MethodDefinitionExtensions
{
    public static bool IsAsync(this MethodDefinition source)
    {
        foreach (var type in source.Module.GetAllTypes())
        {
            foreach (var nestedType in type.NestedTypes.Where(x => x.Name.StartsWith("<")))
            {
                if (nestedType.IsValueType
                    && nestedType.Attributes == TypeAttributes.AutoLayout
                    && nestedType.Interfaces.Any(x => x.Interface.Name.Equals(nameof(IAsyncStateMachine)))
                    && nestedType.Name.Contains(source.Name))
                {
                    return true;
                }
            }
        }
        return false;
    }
    public static bool NotAsync(this MethodDefinition source)
    {
        return source.IsAsync() == false;
    }
    public static bool HasParameters(this MethodDefinition source)
    {
        return source.Parameters.Any();
    }
    public static bool Returns(this MethodSignature source, TypeSignature typeSignature)
    {
        return source.ReturnType.Equals(typeSignature);
    }
}


================================================
File: src/BitMono.Utilities/AsmResolver/ModuleDefinitionExtensions.cs
================================================
ï»¿namespace BitMono.Utilities.AsmResolver;

public static class ModuleDefinitionExtensions
{
    [return: NullGuard.AllowNull]
    public static TMember ResolveOrThrow<TMember>(this ModuleDefinition source, Type type)
        where TMember : class, IMetadataMember
    {
        if (source.TryLookupMember(new MetadataToken((uint)type.MetadataToken), out TMember? member))
        {
            return member;
        }
        throw new ArgumentException($"Unable to resolve member {type.FullName}");
    }
    [SuppressMessage("ReSharper", "UseObjectOrCollectionInitializer")]
    public static List<IMetadataMember> FindMembers(this ModuleDefinition source)
    {
        var members = new List<IMetadataMember>();
        members.Add(source);
        if (source.Assembly != null)
        {
            members.Add(source.Assembly);
        }
        foreach (var type in source.GetAllTypes())
        {
            members.Add(type);
            members.AddRange(type.Methods);
            members.AddRange(type.Fields);
            members.AddRange(type.Properties);
            members.AddRange(type.Events);
        }
        return members;
    }
}


================================================
File: src/BitMono.Utilities/AsmResolver/TypeDefinitionExtensions.cs
================================================
ï»¿namespace BitMono.Utilities.AsmResolver;

public static class TypeDefinitionExtensions
{
    public static bool HasBaseType(this TypeDefinition source)
    {
        return source.BaseType != null;
    }
    public static bool HasNamespace(this TypeDefinition source)
    {
        return Utf8String.IsNullOrEmpty(source.Namespace) == false;
    }
}


================================================
File: src/BitMono.Utilities/AsmResolver/TypeDescriptorExtensions.cs
================================================
namespace BitMono.Utilities.AsmResolver;

public static class TypeDescriptorExtensions
{
    private static readonly string SystemTypeNamespace = typeof(Type).Namespace;
    private static readonly string SystemTypeName = nameof(Type);
    
    public static bool IsSystemType(this ITypeDefOrRef source)
    {
        return source.IsTypeOf(SystemTypeNamespace, SystemTypeName);
    }
}


================================================
File: src/BitMono.Utilities/Collections/CollectionExtensions.cs
================================================
ï»¿namespace BitMono.Utilities.Collections;

public static class CollectionExtensions
{
    public static List<T> Swap<T>(this List<T> source, int index1, int index2)
    {
        (source[index1], source[index2]) = (source[index2], source[index1]);
        return source;
    }
}


================================================
File: src/BitMono.Utilities/Hex/ValueToHexExtensions.cs
================================================
ï»¿namespace BitMono.Utilities.Hex;

public static class ValueToHexExtensions
{
    public static string ToHexString(this int source)
    {
        return string.Format("0x{0:X}", source);
    }
    public static string ToHexString(this long source)
    {
        return string.Format("0x{0:X}", source);
    }
}


================================================
File: src/BitMono.Utilities/Paths/PathFormatterUtility.cs
================================================
namespace BitMono.Utilities.Paths;

public static class PathFormatterUtility
{
    private const string QuotesValue = "\"";

    [return: NullGuard.AllowNull]
    public static string? Format(string? path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return null;
        }
        return path.Replace(QuotesValue, string.Empty);
    }
}


================================================
File: src/BitMono.Utilities/Paths/StringPathExtensions.cs
================================================
namespace BitMono.Utilities.Paths;

public static class StringPathExtensions
{
    public static string ReplaceDirectorySeparatorToAlt(this string source)
    {
        return source.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
    }
    public static string[] SplitToDirectorySeparators(this string source)
    {
        return source.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
    }
}


================================================
File: src/BitMono.Utilities/Runtime/DotNetRuntimeInfoEx.cs
================================================
namespace BitMono.Utilities.Runtime;

public static class DotNetRuntimeInfoEx
{
    /// <summary>
    /// Retrieves the description of the .NET runtime (e.g., ".NET Core 3.1", ".NET 5.0").
    /// </summary>
    public static string GetFrameworkDescription()
    {
        return RuntimeInformation.FrameworkDescription;
    }
    /// <summary>
    /// Try to get the .NET Framework version (only works if running on .NET Framework).
    /// </summary>
    public static Version? GetNetFrameworkVersion()
    {
        if (Type.GetType("System.Runtime.Versioning.TargetFrameworkAttribute") == null)
        {
            return null;
        }
        var targetFrameworkAttribute = (TargetFrameworkAttribute)Assembly
            .GetEntryAssembly()
            ?.GetCustomAttribute(typeof(TargetFrameworkAttribute));
        if (targetFrameworkAttribute == null)
        {
            return null;
        }
        var version = targetFrameworkAttribute.FrameworkName;
        if (version.Contains('v') == false)
        {
            return null;
        }
        return new Version(version.Substring(version.IndexOf('v') + 1));
    }
    /// <summary>
    /// Checks if Runtime is .NET (Core).
    /// </summary>
    public static bool IsNetCoreOrLater()
    {
        var frameworkDescription = GetFrameworkDescription();
        return frameworkDescription.StartsWith(".NET Core") ||
               frameworkDescription.StartsWith(".NET ") && char.IsDigit(frameworkDescription[5]);
    }
    /// <summary>
    /// Checks if Runtime is .NET Framework.
    /// </summary>
    public static bool IsNetFramework()
    {
        var frameworkDescription = GetFrameworkDescription();
        return frameworkDescription.StartsWith(".NET Framework");
    }
    /// <summary>
    /// Checks if the application is running on Mono.
    /// </summary>
    public static bool IsRunningOnMono()
    {
        return Type.GetType("Mono.Runtime") != null;
    }
    public static string? GetMonoDisplayName()
    {
        if (IsRunningOnMono() == false)
        {
            return null;
        }
        var monoType = Type.GetType("Mono.Runtime");
        if (monoType == null)
        {
            return null;
        }
        var displayNameMethod = monoType.GetMethod("GetDisplayName", BindingFlags.NonPublic | BindingFlags.Static);
        if (displayNameMethod == null)
        {
            return null;
        }
        return displayNameMethod.Invoke(null, null)?.ToString();
    }
    public static int GetArchitectureBits()
    {
        return IntPtr.Size * 8;
    }
    public static OperatingSystem GetOperatingSystem()
    {
        return Environment.OSVersion;
    }
}


================================================
File: src/BitMono.Utilities/Runtime/EnvironmentRuntimeInformation.cs
================================================
ï»¿namespace BitMono.Utilities.Runtime;

public class EnvironmentRuntimeInformation
{
    public Version? NetFrameworkVersion { get; set; }
    public OperatingSystem? OperatingSystem { get; set; }
    public int? Bits { get; set; }
    public bool HasMono { get; set; }
    public string? MonoDisplayName { get; set; }

    public static EnvironmentRuntimeInformation Create()
    {
        return new EnvironmentRuntimeInformation
        {
            NetFrameworkVersion = DotNetRuntimeInfoEx.GetNetFrameworkVersion(),
            OperatingSystem = DotNetRuntimeInfoEx.GetOperatingSystem(),
            Bits = DotNetRuntimeInfoEx.GetArchitectureBits(),
            HasMono = DotNetRuntimeInfoEx.IsRunningOnMono(),
            MonoDisplayName = DotNetRuntimeInfoEx.GetMonoDisplayName()
        };
    }
    /// <summary>
    /// Retrieves detailed information about BitMono runtime, like running OS, .NET Framework/.NET Core version, etc.
    /// </summary>
    /// <returns></returns>
    public override string ToString()
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.Append("BitMono running on: ");
        stringBuilder.Append($"OS: {OperatingSystem}, ");
        if (HasMono)
        {
            stringBuilder.Append($"{MonoDisplayName} ");
        }
        else
        {
            stringBuilder.Append($"{DotNetRuntimeInfoEx.GetFrameworkDescription()} v{NetFrameworkVersion}, ");
        }
        stringBuilder.Append($"x{Bits} bits");
        return stringBuilder.ToString();
    }
}


================================================
File: src/BitMono.Utilities/Time/StopwatchUtitilies.cs
================================================
namespace BitMono.Utilities.Time;

public static class StopwatchUtilities
{
    private const long TicksPerMillisecond = 10000;
    private const long TicksPerSecond = TicksPerMillisecond * 1000;
    
    public static TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp)
    {
        var tickFrequency = (double)TicksPerSecond / Stopwatch.Frequency;
        return new TimeSpan((long)((endingTimestamp - startingTimestamp) * tickFrequency));
    }
}


================================================
File: test/BitMono.Benchmarks/BitMono.Benchmarks.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <LangVersion>preview</LangVersion>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="BenchmarkDotNet" Version="0.13.4"/>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\BitMono.Core\BitMono.Core.csproj"/>
  </ItemGroup>

</Project>



================================================
File: test/BitMono.Benchmarks/GlobalUsings.cs
================================================
global using BenchmarkDotNet.Attributes;
global using BenchmarkDotNet.Running;
global using BitMono.Utilities.Runtime;


================================================
File: test/BitMono.Benchmarks/Program.cs
================================================
namespace BitMono.Benchmarks;

internal static class Program
{
    private static void Main(string[] args)
    {
        BenchmarkRunner.Run(typeof(Program).Assembly);
    }
}


================================================
File: test/BitMono.Benchmarks/RuntimeFrameworkInformationBenchmark.cs
================================================
namespace BitMono.Benchmarks;

[MemoryDiagnoser]
public class RuntimeFrameworkInformationBenchmark
{
    [Benchmark]
    public void RuntimeInformation()
    {
        EnvironmentRuntimeInformation.Create();
    }
}


================================================
File: test/BitMono.Core.Tests/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?><configuration>
  <runtime>
  </runtime>
</configuration>


================================================
File: test/BitMono.Core.Tests/BitMono.Core.Tests.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedTestProps.props"/>

  <ItemGroup>
    <ProjectReference Include="..\..\src\BitMono.API\BitMono.API.csproj" />
    <ProjectReference Include="..\..\src\BitMono.Core\BitMono.Core.csproj" />
    <ProjectReference Include="..\..\src\BitMono.Protections\BitMono.Protections.csproj" />
    <ProjectReference Include="..\TestBinaries\DotNet\BitMono.Core.TestCases.CustomAttributes\BitMono.Core.TestCases.CustomAttributes.csproj" />
    <ProjectReference Include="..\TestBinaries\DotNet\BitMono.Core.TestCases.Methods\BitMono.Core.TestCases.Methods.csproj" />
    <ProjectReference Include="..\TestBinaries\DotNet\BitMono.Core.TestCases.Reflection\BitMono.Core.TestCases.Reflection.csproj" />
    <ProjectReference Include="..\TestBinaries\DotNet\BitMono.Core.TestCases.Types\BitMono.Core.TestCases.Types.csproj" />
  </ItemGroup>

</Project>


================================================
File: test/BitMono.Core.Tests/GlobalUsings.cs
================================================
global using System.Collections;
global using System.Collections.Generic;
global using System.Diagnostics.CodeAnalysis;
global using System.Linq;
global using AsmResolver.DotNet;
global using BitMono.Core.Analyzing;
global using BitMono.Core.Resolvers;
global using BitMono.Core.TestCases.CustomAttributes;
global using BitMono.Core.TestCases.Methods;
global using BitMono.Core.TestCases.Reflection;
global using BitMono.Shared.Models;
global using FluentAssertions;
global using Xunit;
global using BitMono.Protections;
global using Microsoft.Extensions.Options;


================================================
File: test/BitMono.Core.Tests/Setup.cs
================================================
namespace BitMono.Core.Tests;

public static class Setup
{
    public static ModelAttributeCriticalAnalyzer ModelAttributeCriticalAnalyzer(IOptions<CriticalsSettings> criticals)
    {
        return new ModelAttributeCriticalAnalyzer(criticals);
    }
    public static CriticalMethodsCriticalAnalyzer CriticalMethodsCriticalAnalyzer(IOptions<CriticalsSettings> criticals)
    {
        return new CriticalMethodsCriticalAnalyzer(criticals);
    }
    public static CriticalMethodsStartsWithAnalyzer CriticalMethodsStartsWithCriticalAnalyzer(IOptions<CriticalsSettings> criticals)
    {
        return new CriticalMethodsStartsWithAnalyzer(criticals);
    }
    public static NoInliningMethodMemberResolver NoInliningMethodMemberResolver(IOptions<ObfuscationSettings> obfuscation)
    {
        return new NoInliningMethodMemberResolver(obfuscation);
    }
    public static ObfuscationAttributeResolver ObfuscationAttributeResolver(IOptions<ObfuscationSettings> obfuscation)
    {
        return new ObfuscationAttributeResolver(obfuscation);
    }
    public static ObfuscateAssemblyAttributeResolver ObfuscateAssemblyAttributeResolver(
        IOptions<ObfuscationSettings> obfuscation)
    {
        return new ObfuscateAssemblyAttributeResolver(obfuscation);
    }
    public static SerializableBitCriticalAnalyzer SerializableBitCriticalAnalyzer(IOptions<ObfuscationSettings> obfuscation)
    {
        return new SerializableBitCriticalAnalyzer(obfuscation);
    }
}


================================================
File: test/BitMono.Core.Tests/packages.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<packages>
</packages>


================================================
File: test/BitMono.Core.Tests/Analyzing/CriticalMethodsCriticalAnalyzerTest.cs
================================================
namespace BitMono.Core.Tests.Analyzing;

public class MethodsData : IEnumerable<object[]>
{
    public IEnumerator<object[]> GetEnumerator()
    {
        yield return new object[] { nameof(CriticalMethods.Update) };
        yield return new object[] { nameof(CriticalMethods.LateUpdate) };
        yield return new object[] { nameof(CriticalMethods.FixedUpdate) };
        yield return new object[] { nameof(CriticalMethods.OnDrawGizmos) };
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}

public class CriticalMethodsCriticalAnalyzerTest
{
    [Theory]
    [ClassData(typeof(MethodsData))]
    public void WhenMethodCriticalAnalyzing_AndMethodIsCritical_ThenShouldBeFalse(string methodName)
    {
        var criticals = new CriticalsSettings
        {
            UseCriticalMethods = true,
            CriticalMethods = new List<string>
            {
                methodName
            }
        };
        var options = Options.Create(criticals);
        var criticalAnalyzer = Setup.CriticalMethodsCriticalAnalyzer(options);
        var module = ModuleDefinition.FromFile(typeof(CriticalMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(t => t.Name == nameof(CriticalMethods));
        var method = type.Methods.First(m => m.Name == methodName);

        var result = criticalAnalyzer.NotCriticalToMakeChanges(method);

        result
            .Should()
            .BeFalse();
    }
    [Theory]
    [ClassData(typeof(MethodsData))]
    public void WhenMethodCriticalAnalyzing_AndMethodIsNotCritical_ThenShouldBeTrue(string methodName)
    {
        var criticals = new CriticalsSettings
        {
            UseCriticalMethods = true,
            CriticalMethods = new List<string>
            {
                methodName
            }
        };
        var options = Options.Create(criticals);
        var criticalAnalyzer = Setup.CriticalMethodsCriticalAnalyzer(options);
        var module = ModuleDefinition.FromFile(typeof(CriticalMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(t => t.Name == nameof(CriticalMethods));
        var method = type.Methods.First(m => m.Name == nameof(CriticalMethods.VoidMethod));

        var result = criticalAnalyzer.NotCriticalToMakeChanges(method);

        result
            .Should()
            .BeTrue();
    }
}


================================================
File: test/BitMono.Core.Tests/Analyzing/CriticalMethodsStartsWithCriticalAnalyzerTest.cs
================================================
ï»¿namespace BitMono.Core.Tests.Analyzing;

public class MethodsStartsWithData : IEnumerable<object[]>
{
    public IEnumerator<object[]> GetEnumerator()
    {
        yield return new object[] { nameof(CriticalMethods.OV_method) };
        yield return new object[] { nameof(CriticalMethods.OV_override) };
        yield return new object[] { nameof(CriticalMethods.OV_) };
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}

public class CriticalMethodsStartsWithCriticalAnalyzerTest
{
    [Theory]
    [ClassData(typeof(MethodsStartsWithData))]
    public void WhenMethodCriticalAnalyzing_AndMethodIsCritical_ThenShouldBeFalse(string methodName)
    {
        var criticals = new CriticalsSettings
        {
            UseCriticalMethodsStartsWith = true,
            CriticalMethodsStartsWith = new List<string>
            {
                methodName
            }
        };
        var options = Options.Create(criticals);
        var criticalAnalyzer = Setup.CriticalMethodsStartsWithCriticalAnalyzer(options);
        var module = ModuleDefinition.FromFile(typeof(CriticalMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(t => t.Name == nameof(CriticalMethods));
        var method = type.Methods.First(m => m.Name == methodName);

        var result = criticalAnalyzer.NotCriticalToMakeChanges(method);

        result
            .Should()
            .BeFalse();
    }
    [Theory]
    [ClassData(typeof(MethodsStartsWithData))]
    public void WhenMethodCriticalAnalyzing_AndMethodIsNotCritical_ThenShouldBeTrue(string methodName)
    {
        var criticals = new CriticalsSettings
        {
            UseCriticalMethodsStartsWith = true,
            CriticalMethodsStartsWith = new List<string>
            {
                methodName
            }
        };
        var options = Options.Create(criticals);
        var criticalAnalyzer = Setup.CriticalMethodsStartsWithCriticalAnalyzer(options);
        var module = ModuleDefinition.FromFile(typeof(CriticalMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(t => t.Name == nameof(CriticalMethods));
        var method = type.Methods.First(m => m.Name == nameof(CriticalMethods.VoidMethod));

        var result = criticalAnalyzer.NotCriticalToMakeChanges(method);

        result
            .Should()
            .BeTrue();
    }
}


================================================
File: test/BitMono.Core.Tests/Analyzing/ReflectionCriticalAnalyzerTest.cs
================================================
namespace BitMono.Core.Tests.Analyzing;

public class ReflectionCriticalAnalyzerTest
{
    [Fact]
    public void WhenReflectionCriticalAnalyzing_AndMethodUsesReflectionOfItSelf_ThenShouldBeFalse()
    {
        var module = ModuleDefinition.FromFile(typeof(ReflectionMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(t => t.Name == nameof(ReflectionMethods));
        var method = type.Methods.First(m => m.Name == nameof(ReflectionMethods.UsesReflectionOnItSelf));
        var obfuscation = new ObfuscationSettings
        {
            ReflectionMembersObfuscationExclude = true
        };
        var criticalAnalyzer = new ReflectionCriticalAnalyzer(Options.Create(obfuscation));

        var result = criticalAnalyzer.NotCriticalToMakeChanges(method);

        result
            .Should()
            .BeFalse();
    }
    [Fact]
    [SuppressMessage("ReSharper", "PossibleNullReferenceException")]
    public void WhenReflectionCriticalAnalyzing_AndMethodUses2DifferentReflectionAnd1OnItSelf_ThenShouldBeFalseAndCountOfCachedMethodsShouldBe1AndMethodNameShouldBeEqualToSelf()
    {
        var module = ModuleDefinition.FromFile(typeof(ReflectionMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(t => t.Name == nameof(ReflectionMethods));
        var method = type.Methods.First(m => m.Name == nameof(ReflectionMethods.Uses3Reflection));
        var obfuscation = new ObfuscationSettings
        {
            ReflectionMembersObfuscationExclude = true
        };
        var criticalAnalyzer = new ReflectionCriticalAnalyzer(Options.Create(obfuscation));

        var result = criticalAnalyzer.NotCriticalToMakeChanges(method);

        result
            .Should()
            .BeFalse();
        criticalAnalyzer.CachedMethods.Count
            .Should()
            .Be(1);
        criticalAnalyzer.CachedMethods.First().Name.Value
            .Should()
            .Be(method.Name);
    }
}


================================================
File: test/BitMono.Core.Tests/Analyzing/SerializableBitCriticalAnalyzerTest.cs
================================================
namespace BitMono.Core.Tests.Analyzing;

public class SerializableBitCriticalAnalyzerTest
{
    [Fact]
    public void WhenTypeSerializableBitCriticalAnalyzing_AndTypeHasSerializableBit_ThenShouldBeFalse()
    {
        var obfuscation = new ObfuscationSettings
        {
            SerializableBitObfuscationExclude = true
        };
        var criticalAnalyzer = Setup.SerializableBitCriticalAnalyzer(Options.Create(obfuscation));
        var module = ModuleDefinition.FromFile(typeof(SerializableTypes).Assembly.Location);
        var types = module.TopLevelTypes.First(t => t.Name == nameof(SerializableTypes));
        var type = types.NestedTypes.First(n => n.Name == nameof(SerializableTypes.SerializableBit));

        var result = criticalAnalyzer.NotCriticalToMakeChanges(type);

        result.Should().BeFalse();
    }
    [Fact]
    public void WhenTypeSerializableBitCriticalAnalyzing_AndTypeHasNoSerializableBit_ThenShouldBeTrue()
    {
        var obfuscation = new ObfuscationSettings
        {
            SerializableBitObfuscationExclude = true
        };
        var criticalAnalyzer = Setup.SerializableBitCriticalAnalyzer(Options.Create(obfuscation));
        var module = ModuleDefinition.FromFile(typeof(SerializableTypes).Assembly.Location);
        var types = module.TopLevelTypes.First(t => t.Name == nameof(SerializableTypes));
        var type = types.NestedTypes.First(n => n.Name == nameof(SerializableTypes.NoSerializableBit));
        
        var result = criticalAnalyzer.NotCriticalToMakeChanges(type);

        result.Should().BeTrue();
    }
}


================================================
File: test/BitMono.Core.Tests/Resolvers/NoInliningMethodMemberResolverTest.cs
================================================
namespace BitMono.Core.Tests.Resolvers;

public class NoInliningMethodMemberResolverTest
{
    [Fact]
    public void WhenNoInliningMethodResolving_AndMethodHasInliningBit_ThenShouldBeFalse()
    {
        var obfuscation = new ObfuscationSettings
        {
            NoInliningMethodObfuscationExclude = true,
        };
        var options = Options.Create(obfuscation);
        var resolver = Setup.NoInliningMethodMemberResolver(options);
        var module = ModuleDefinition.FromFile(typeof(NoInliningMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(t => t.Name == nameof(NoInliningMethods));
        var method = type.Methods.First(m => m.Name == nameof(NoInliningMethods.NoInliningMethod));

        var result = resolver.Resolve(null, method);

        result
            .Should()
            .BeFalse();
    }
    [Fact]
    public void WhenNoInliningMethodResolving_AndMethodHasNoInliningBit_ThenShouldBeTrue()
    {
        var obfuscation = new ObfuscationSettings
        {
            NoInliningMethodObfuscationExclude = true,
        };
        var options = Options.Create(obfuscation);
        var resolver = Setup.NoInliningMethodMemberResolver(options);
        var module = ModuleDefinition.FromFile(typeof(NoInliningMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(t => t.Name == nameof(NoInliningMethods));
        var method = type.Methods.First(m => m.Name == nameof(NoInliningMethods.VoidMethod));

        var result = resolver.Resolve(null, method);

        result
            .Should()
            .BeTrue();
    }
}


================================================
File: test/BitMono.Core.Tests/Resolvers/ObfuscateAssemblyAttributeResolverTest.cs
================================================
namespace BitMono.Core.Tests.Resolvers;

public class ObfuscateAssemblyAttributeResolverTest
{
    [Fact]
    public void WhenObfuscateAssemblyAttributeResolving_AndAssemblyHasObfuscateAssemblyAttributeIsPrivateTrue_ThenShouldBeTrue()
    {
        var obfuscation = new ObfuscationSettings
        {
            ObfuscateAssemblyAttributeObfuscationExclude = true,
        };
        var options = Options.Create(obfuscation);
        var resolver = Setup.ObfuscateAssemblyAttributeResolver(options);
        var module = ModuleDefinition.FromFile(typeof(CustomAttributesInstance).Assembly.Location);

        var result = resolver.Resolve(module.Assembly);

        result
            .Should()
            .BeTrue();
    }
}


================================================
File: test/BitMono.Core.Tests/Resolvers/ObfuscationAttributeResolverTest.cs
================================================
namespace BitMono.Core.Tests.Resolvers;

public class ObfuscationAttributeResolverTest
{
    [Theory]
    [InlineData(nameof(CallToCalli))]
    public void WhenObfuscationAttributeResolving_AndTypeHasComplexObfuscationAttributeWithExcludeFalse_ThenShouldBeFalse(string feature)
    {
        var obfuscation = new ObfuscationSettings
        {
            ObfuscationAttributeObfuscationExclude = true,
        };
        var options = Options.Create(obfuscation);
        var resolver = Setup.ObfuscationAttributeResolver(options);
        var module = ModuleDefinition.FromFile(typeof(ObfuscationTypes).Assembly.Location);
        var types = module.TopLevelTypes.First(t => t.Name == nameof(ObfuscationTypes));
        var type = types.NestedTypes.First(n =>
            n.Name == nameof(ObfuscationTypes.ObfuscationAttributeCallToCalliWithExcludeFalse));

        var result = resolver.Resolve(feature, type);

        result
            .Should()
            .BeFalse();
    }
    [Theory]
    [InlineData(nameof(CallToCalli))]
    public void WhenObfuscationAttributeResolving_AndTypeHasObfuscationAttributeCallToCalli_ThenShouldBeTrue(string feature)
    {
        var obfuscation = new ObfuscationSettings
        {
            ObfuscationAttributeObfuscationExclude = true,
        };
        var options = Options.Create(obfuscation);
        var resolver = Setup.ObfuscationAttributeResolver(options);
        var module = ModuleDefinition.FromFile(typeof(ObfuscationTypes).Assembly.Location);
        var types = module.TopLevelTypes.First(t => t.Name == nameof(ObfuscationTypes));
        var type = types.NestedTypes.First(n => n.Name == nameof(ObfuscationTypes.ObfuscationAttributeCallToCalli));

        var result = resolver.Resolve(feature, type);

        result
            .Should()
            .BeTrue();
    }
    [Fact]
    public void WhenObfuscationAttributeResolving_AndTypeHasVoidObfuscationAttribute_ThenShouldBeFalse()
    {
        var obfuscation = new ObfuscationSettings
        {
            ObfuscationAttributeObfuscationExclude = true,
        };
        var options = Options.Create(obfuscation);
        var resolver = Setup.ObfuscationAttributeResolver(options);
        var module = ModuleDefinition.FromFile(typeof(ObfuscationTypes).Assembly.Location);
        var types = module.TopLevelTypes.First(t => t.Name == nameof(ObfuscationTypes));
        var type = types.NestedTypes.First(n => n.Name == nameof(ObfuscationTypes.VoidObfuscationAttribute));

        var result = resolver.Resolve(string.Empty, type);

        result
            .Should()
            .BeFalse();
    }
    [Fact]
    public void WhenObfuscationAttributeResolving_AndMethodHasVoidObfuscationAttribute_ThenShouldBeFalse()
    {
        var obfuscation = new ObfuscationSettings
        {
            ObfuscationAttributeObfuscationExclude = true,
        };
        var options = Options.Create(obfuscation);
        var resolver = Setup.ObfuscationAttributeResolver(options);
        var module = ModuleDefinition.FromFile(typeof(ObfuscationMethods).Assembly.Location);
        var type = module.TopLevelTypes.First(n => n.Name == nameof(ObfuscationMethods));
        var method = type.Methods.First(m => m.Name == nameof(ObfuscationMethods.VoidObfuscationAttribute));

        var result = resolver.Resolve(string.Empty, method);

        result
            .Should()
            .BeFalse();
    }
}


================================================
File: test/BitMono.Obfuscation.Tests/BitMono.Obfuscation.Tests.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <Import Project="$(MSBuildThisFileDirectory)..\..\props\SharedTestProps.props"/>

  <ItemGroup>
    <ProjectReference Include="..\..\src\BitMono.Obfuscation\BitMono.Obfuscation.csproj" />
    <ProjectReference Include="..\TestBinaries\DotNet\BitMono.Obfuscation.TestCases.CosturaDecompressor\BitMono.Obfuscation.TestCases.CosturaDecompressor.csproj" />
  </ItemGroup>

</Project>


================================================
File: test/BitMono.Obfuscation.Tests/GlobalUsings.cs
================================================
ï»¿global using System.Linq;
global using System.Threading;
global using AsmResolver.DotNet;
global using BitMono.Obfuscation.Referencing;
global using BitMono.Utilities.AsmResolver;
global using FluentAssertions;
global using Xunit;


================================================
File: test/BitMono.Obfuscation.Tests/Referencing/CosturaReferencesDataResolverTest.cs
================================================
ï»¿namespace BitMono.Obfuscation.Tests.Referencing;

public class CosturaReferencesDataResolverTest
{
    [Fact]
    public void CheckSameAmountOfCostura()
    {
        var resolver = new CosturaReferencesDataResolver();
        var module = ModuleDefinition.FromFile(typeof(TestCases.CosturaDecompressor.Program).Assembly.Location);
        var countOfEmbeddedCosturaResources = module.Resources.Count(x => x.IsEmbeddedCosturaResource());

        var result = resolver.Resolve(module, CancellationToken.None);

        result
            .Should()
            .NotBeEmpty().And
            .HaveCount(countOfEmbeddedCosturaResources);
    }
    [Theory]
    [InlineData("costura.asmresolver.dll.compressed")]
    [InlineData("costura.asmresolver.pe.dll.compressed")]
    [InlineData("costura.asmresolver.pe.file.dll.compressed")]
    [InlineData("costura.microsoft.entityframeworkcore.dll.compressed")]
    [InlineData("costura.microsoft.entityframeworkcore.abstractions.dll.compressed")]
    [InlineData("costura.microsoft.extensions.caching.abstractions.dll.compressed")]
    [InlineData("costura.microsoft.extensions.caching.memory.dll.compressed")]
    [InlineData("costura.microsoft.extensions.dependencyinjection.abstractions.dll.compressed")]
    [InlineData("costura.microsoft.extensions.dependencyinjection.dll.compressed")]
    [InlineData("costura.microsoft.extensions.logging.abstractions.dll.compressed")]
    [InlineData("costura.microsoft.extensions.logging.dll.compressed")]
    [InlineData("costura.microsoft.extensions.options.dll.compressed")]
    [InlineData("costura.microsoft.extensions.primitives.dll.compressed")]
    public void FindCosturaResource(string costuraResourceName)
    {
        var module = ModuleDefinition.FromFile(typeof(TestCases.CosturaDecompressor.Program).Assembly.Location);

        var result = module.Resources.First(x => x.Name.Value.Equals(costuraResourceName));

        result
            .IsEmbeddedCosturaResource()
            .Should()
            .BeTrue();
    }
}


================================================
File: test/Sandbox/Program.cs
================================================
ï»¿Console.WriteLine("Hello, World!");


================================================
File: test/Sandbox/Sandbox.csproj
================================================
ï»¿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>



================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.CustomAttributes/AssemblyInfo.cs
================================================
[assembly: ObfuscateAssembly(true, StripAfterObfuscation = true)]


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.CustomAttributes/BitMono.Core.TestCases.CustomAttributes.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
      <TargetFramework>netstandard2.0</TargetFramework>
      <LangVersion>10</LangVersion>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
      <DebugType>none</DebugType>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
      <DebugType>none</DebugType>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\..\..\src\BitMono.Protections\BitMono.Protections.csproj" />
    </ItemGroup>

</Project>



================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.CustomAttributes/CustomAttributesInstance.cs
================================================
namespace BitMono.Core.TestCases.CustomAttributes;

public static class CustomAttributesInstance
{
}


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.CustomAttributes/GlobalUsings.cs
================================================
global using System;
global using System.Reflection;
global using System.Runtime.CompilerServices;
global using BitMono.Protections;


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.CustomAttributes/NoInliningMethods.cs
================================================
namespace BitMono.Core.TestCases.CustomAttributes;

public class NoInliningMethods
{
    public void VoidMethod()
    {
    }
    [MethodImpl(MethodImplOptions.NoInlining)]
    public void NoInliningMethod()
    {
    }
}


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.CustomAttributes/ObfuscationMethods.cs
================================================
namespace BitMono.Core.TestCases.CustomAttributes;

public class ObfuscationMethods
{
    public void NoObfuscationAttribute()
    {
    }
    [Obfuscation]
    public void VoidObfuscationAttribute()
    {
    }
    [Obfuscation(Feature = nameof(CallToCalli))]
    public void ObfuscationAttributeFeatureCallToCalli()
    {
    }
    [Obfuscation(Feature = nameof(CallToCalli), Exclude = true)]
    public void ObfuscationAttributeFeatureCallToCalliExcludeTrue()
    {
    }
    [Obfuscation(Feature = nameof(CallToCalli), Exclude = true)]
    public void ObfuscationAttributeFeatureCallToCalliExcludeFalse()
    {
    }   
}


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.CustomAttributes/ObfuscationTypes.cs
================================================
namespace BitMono.Core.TestCases.CustomAttributes;

public class ObfuscationTypes
{
    public class NoObfuscationAttribute
    {
    }
    [Obfuscation]
    public class VoidObfuscationAttribute
    {
    }
    [Obfuscation(Feature = nameof(CallToCalli))]
    public class ObfuscationAttributeCallToCalli
    {
    }
    [Obfuscation(Feature = nameof(CallToCalli), Exclude = true)]
    public class ObfuscationAttributeCallToCalliWithExcludeTrue
    {
    }
    [Obfuscation(Feature = nameof(CallToCalli), Exclude = false)]
    public class ObfuscationAttributeCallToCalliWithExcludeFalse
    {
    }
}


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.CustomAttributes/SerializableTypes.cs
================================================
namespace BitMono.Core.TestCases.CustomAttributes;

public class SerializableTypes
{
    public class NoSerializableBit
    {
    }
    [Serializable]
    public class SerializableBit
    {
    }
}


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Methods/BitMono.Core.TestCases.Methods.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>netstandard2.0</TargetFramework>
        <LangVersion>10</LangVersion>
    </PropertyGroup>

</Project>



================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Methods/CriticalMethods.cs
================================================
namespace BitMono.Core.TestCases.Methods;

public class CriticalMethods
{
    public void VoidMethod()
    {
    }
    public void Update()
    {
    }
    public void LateUpdate()
    {
    }
    public void FixedUpdate()
    {
    }
    public void OnDrawGizmos()
    {
    }
    public void OV_method()
    {
    }
    public void OV_override()
    {
    }
    public void OV_()
    {
    }
}


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Reflection/BitMono.Core.TestCases.Reflection.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>netstandard2.0</TargetFramework>
        <LangVersion>10</LangVersion>
    </PropertyGroup>

</Project>



================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Reflection/GlobalUsings.cs
================================================
global using System.Reflection;


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Reflection/ReflectionMethods.cs
================================================
namespace BitMono.Core.TestCases.Reflection;

public class ReflectionMethods
{
    public static void VoidMethod(string text)
    {
    }
    public void UsesReflectionOnItSelf()
    {
        typeof(ReflectionMethods).GetMethod(nameof(UsesReflectionOnItSelf));
    }
    public void Uses3Reflection()
    {
        typeof(ReflectionMethods).GetMethod(nameof(Uses3Reflection));
        typeof(ReflectionMethods).GetMethod(nameof(UsesReflectionOnItSelf));
        typeof(ReflectionMethods).GetMethod(nameof(VoidMethod), BindingFlags.Public | BindingFlags.Static);
    }
}


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Types/BitMono.Core.TestCases.Types.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
      <TargetFramework>netstandard2.0</TargetFramework>
      <LangVersion>10</LangVersion>
    </PropertyGroup>

</Project>


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Types/EmptyType.cs
================================================
namespace BitMono.Core.TestCases.Types;

public class EmptyType
{
}


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Types/GlobalUsings.cs
================================================
global using System;


================================================
File: test/TestBinaries/DotNet/BitMono.Core.TestCases.Types/SerializableType.cs
================================================
namespace BitMono.Core.TestCases.Types;

[Serializable]
public class SerializableType
{
}


================================================
File: test/TestBinaries/DotNet/BitMono.Obfuscation.TestCases.CosturaDecompressor/BitMono.Obfuscation.TestCases.CosturaDecompressor.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)..\..\..\..\props\SharedPackages.props" />

  <ItemGroup>
    <PackageReference Include="Costura.Fody" Version="6.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="6.0.0" />
  </ItemGroup>

</Project>


================================================
File: test/TestBinaries/DotNet/BitMono.Obfuscation.TestCases.CosturaDecompressor/FodyWeavers.xml
================================================
ï»¿<Weavers xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FodyWeavers.xsd">
  <Costura />
</Weavers>


================================================
File: test/TestBinaries/DotNet/BitMono.Obfuscation.TestCases.CosturaDecompressor/GlobalUsings.cs
================================================
ï»¿global using Microsoft.EntityFrameworkCore.Infrastructure;


================================================
File: test/TestBinaries/DotNet/BitMono.Obfuscation.TestCases.CosturaDecompressor/Program.cs
================================================
ï»¿namespace BitMono.Obfuscation.TestCases.CosturaDecompressor;

public class Program
{
    private static void Main()
    {
        // Don't try to run, it will cause errors, it just for test cases

        // Just to suppress compiler optimizations
        EntityFrameworkServicesBuilder.CoreServices.Add(default!);
    }
}


================================================
File: .github/dependabot.yml
================================================
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for all configuration options:
# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates

version: 2
updates:
  - package-ecosystem: "nuget"
    directory: "/"
    schedule:
      interval: "daily"
    target-branch: "master"
    ignore:
      - dependency-name: "Microsoft.Build.Tasks.Core"
        versions: ["16.*"]
    labels:
      - "dependencies"
    reviewers:
      - "sunnamed434"



================================================
File: .github/actions/nuget-pack/action.yaml
================================================
name: 'NuGet Pack'
description: 'Packs BitMono NuGet packages'
inputs:
  nuspec_path:
    description: 'Path to .nuspec'
    required: true
  nuget_push:
    description: 'Push to NuGet?'
    required: false
    default: false
  nuget_key:
    description: 'NuGet deploy key'
    required: false
runs:
  using: "composite"
  steps:
    - name: Pack
      run: nuget pack ${{ inputs.nuspec_path }}
      shell: bash
    - name: Push to NuGet (Release)
      run: if ${{ inputs.nuget_push == 'true' }}; then
        dotnet nuget push *.nupkg --skip-duplicate --api-key ${{ inputs.nuget_key }} --source https://api.nuget.org/v3/index.json;
        fi
      shell: bash


================================================
File: .github/actions/project-build/action.yaml
================================================
name: 'Project Build'
description: 'Builds BitMono projects'
inputs:
  project_path:
    description: 'Path to project folder'
    required: true
  target_framework:
    description: 'The target framework to build on'
    required: true
  use_runtime:
    description: 'Include runtime flag? Set to true for self-contained builds, false (default) for global tools.'
    required: false
    default: true
  runtime_version:
    description: 'Build runtime version (default linux-x64) if using a runtime flag'
    required: false
    default: 'linux-x64'
  nuget_push:
    description: 'Push to NuGet on release?'
    required: false
    default: false
  nuget_key:
    description: 'NuGet deploy key'
    required: false
  github_token:
    description: 'GitHub token'
    required: false
outputs:
  version:
    description: "Generated version (SemVersion compatible)"
    value: ${{ steps.get-version.outputs.version }}
  is_prerelease:
    description: 'Gets if the version is a prerelease'
    value: ${{ steps.check-prerelease.outputs.is_prerelease }}
runs:
  using: "composite"
  steps:
    # Generate semver compatible version from current tag and commit hash
    - name: Create version
      id: get-version
      run: echo "version=$(git describe --tags `git rev-list --tags --max-count=1`)+$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
      shell: bash

    - name: Check Prerelease
      id: check-prerelease
      run: "if ${{ contains(steps.get-version.outputs.version, '-') }}; then
              echo is_prerelease=true >> $GITHUB_OUTPUT;
            else
              echo is_prerelease=false >> $GITHUB_OUTPUT;
            fi"
      shell: bash

    # Determine whether to include the --runtime flag.
    - name: Set runtime flag
      id: set-runtime-flag
      run: |
        if [ "${{ inputs.use_runtime }}" = "true" ]; then
          echo "runtime=--runtime ${{ inputs.runtime_version }}" >> $GITHUB_OUTPUT
        else
          echo "runtime=" >> $GITHUB_OUTPUT
        fi
      shell: bash

    # Commands that are used multiple times.
    - name: Common commands
      id: common-commands
      run: |
        echo "dotnet-restore=dotnet restore \$PROJECT_PATH ${{ steps.set-runtime-flag.outputs.runtime }} -p:Configuration=Release -p:TargetFramework=${{ inputs.target_framework }}" >> $GITHUB_OUTPUT
        echo "dotnet-build=dotnet build \$PROJECT_PATH --configuration Release --no-restore ${{ steps.set-runtime-flag.outputs.runtime }} -p:TargetFramework=${{ inputs.target_framework }} -p:BitMonoVersion=${{ steps.get-version.outputs.version }}" >> $GITHUB_OUTPUT
        echo "dotnet-test=dotnet test \$PROJECT_PATH --configuration Release --no-restore --no-build ${{ steps.set-runtime-flag.outputs.runtime }} -p:TargetFramework=${{ inputs.target_framework }}" >> $GITHUB_OUTPUT
      shell: bash

    # Install dependencies (separate step for caching)
    - name: Install dependencies
      run: |
        ${{ steps.common-commands.outputs.dotnet-restore }}
        pwsh -File .github/actions/project-build/run-command-for-every-tests-project.ps1 "$GITHUB_WORKSPACE/tests" '${{ steps.common-commands.outputs.dotnet-restore }}'
      env:
        PROJECT_PATH: ${{ inputs.project_path }}
      shell: bash

    # Build project
    - name: Build
      run: |
        ${{ steps.common-commands.outputs.dotnet-build }}
        pwsh -File .github/actions/project-build/run-command-for-every-tests-project.ps1 "$GITHUB_WORKSPACE/tests" '${{ steps.common-commands.outputs.dotnet-build }}'
      env:
        PROJECT_PATH: ${{ inputs.project_path }}
      shell: bash

    # Test project
    - name: Test
      run: |
        pwsh -File .github/actions/project-build/run-command-for-every-tests-project.ps1 "$GITHUB_WORKSPACE/tests" '${{ steps.common-commands.outputs.dotnet-test }}'
      env:
        PROJECT_PATH: ${{ inputs.project_path }}
      shell: bash

    # Push to GitHub packages on each commit and release (Nightly)
    - name: Push to NuGet (Nightly)
      run: if ${{ inputs.nuget_push == 'true' && (github.event_name == 'push' || (github.event_name == 'create' && github.event.ref_type == 'tag')) }}; then
        dotnet nuget push ${{ inputs.project_path }}/bin/Release/*.nupkg --api-key ${{ inputs.github_token }} --skip-duplicate --source https://nuget.pkg.github.com/sunnamed434/index.json;
        fi
      shell: bash

    # Push to NuGet on each tag, but only if not a pre-release version (Release)
    - name: Push to NuGet (Release)
      run: if ${{ inputs.nuget_push == 'true' && github.event_name == 'create' && github.event.ref_type == 'tag' && steps.check-prerelease.outputs.is_prerelease == 'false' }}; then
        dotnet nuget push ${{ inputs.project_path }}/bin/Release/*.nupkg --api-key ${{ inputs.nuget_key }} --skip-duplicate --source https://api.nuget.org/v3/index.json;
        fi
      shell: bash



================================================
File: .github/actions/project-build/run-command-for-every-tests-project.ps1
================================================
#
# Finds all tests projects matching 'BitMono.*.Tests' for a project passed as the first argument
# and runs a command passed as the second argument for every tests project found.
# Also sets PROJECT_PATH environment variables with the value of the tests project folder path.
# Exits with a non-zero status if any command fails.
#
# Example usage:
# pwsh -f .github/actions/project-build/run-command-for-every-tests-project.ps1 "src/BitMono.Core" "echo \$PROJECT_PATH"
#
# Example output:
# Tests project found: /home/runner/work/BitMono/BitMono/tests/BitMono.Core.Tests. Executing a command: ...
# Assumes the first argument is already the path to the tests directory.

$testsFolderPath = $args[0]
$commandToExecute = $args[1]
$global:exitCode = 0

Get-ChildItem -Path $testsFolderPath -Directory -Recurse `
| Where-Object { $_.Name -match "^BitMono\..*\.Tests$" } `
| ForEach-Object {
    $testsProjectPath = $_.FullName
    Write-Output "Tests project found: $testsProjectPath. Executing a command: $commandToExecute"
    bash -c "PROJECT_PATH=$testsProjectPath && $commandToExecute"
    if ($LASTEXITCODE -ne 0) {
        $global:exitCode = $LASTEXITCODE
    }
}

if ($global:exitCode -ne 0) {
    exit $global:exitCode
}


================================================
File: .github/workflows/BitMono.API.yaml
================================================
name: BitMono.API

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.API.yaml'
      - 'src/BitMono.API/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.API.yaml'
      - 'src/BitMono.API/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.API Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.API
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true


================================================
File: .github/workflows/BitMono.CLI.yaml
================================================
name: BitMono.CLI
on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.CLI.yaml'
      - 'src/**'
      - 'test/**'
  pull_request:
    paths:
      - '.github/workflows/BitMono.CLI.yaml'
      - 'src/**'
      - 'test/**'
jobs:
  Build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target-framework: [net9.0, net8.0, net7.0, net6.0, net462, netstandard2.1, netstandard2.0]
        runtime: [linux-x64, win-x64, linux-arm64, win-arm64, osx-x64, osx-arm64, win-x86]
        exclude:
          # Exclude win-x86 builds for .NET Standard as they're architecture-independent
          - runtime: win-x86
            target-framework: netstandard2.0
          - runtime: win-x86
            target-framework: netstandard2.1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.x
      
      - name: Build Project
        uses: ./.github/actions/project-build
        id: project-build
        with:
          project_path: src/BitMono.CLI/BitMono.CLI.csproj
          nuget_push: false
          target_framework: ${{ matrix.target-framework }}
          runtime_version: ${{ matrix.runtime }}
          github_token: ${{ secrets.PAT }}
      
      - name: Install zip (for Linux/macOS)
        run: |
          if [[ "${{ matrix.runtime }}" =~ ^linux ]]; then
            sudo apt-get install -y zip
          elif [[ "${{ matrix.runtime }}" =~ ^osx ]]; then
            if ! command -v zip &> /dev/null; then
              echo "zip is not available on this macOS runner, and it should be pre-installed."
              exit 1
            fi
          fi
      
      - name: Zip artifacts
        run: |
          cd ./src/BitMono.CLI/bin/Release/${{ matrix.target-framework }}/${{ matrix.runtime }} && \
          zip -qq -r ./BitMono-v${{ steps.project-build.outputs.version }}-CLI-${{ matrix.target-framework }}-${{ matrix.runtime }}.zip *
      
      - name: Upload build
        uses: actions/upload-artifact@v4
        with:
          name: BitMono-v${{ steps.project-build.outputs.version }}-CLI-${{ matrix.target-framework }}-${{ matrix.runtime }}
          path: "./src/BitMono.CLI/bin/Release/${{ matrix.target-framework }}/${{ matrix.runtime }}/BitMono-v${{ steps.project-build.outputs.version }}-CLI-${{ matrix.target-framework }}-${{ matrix.runtime }}.zip"
          if-no-files-found: error
      
      - name: Create Release
        if: github.event_name == 'create' && github.event.ref_type == 'tag'
        uses: ncipollo/release-action@v1
        with:
          name: BitMono Release v${{ steps.project-build.outputs.version }}
          tag: ${{ steps.project-build.outputs.version }}
          artifacts: "./src/BitMono.CLI/bin/Release/${{ matrix.target-framework }}/${{ matrix.runtime }}/BitMono-v${{ steps.project-build.outputs.version }}-CLI-${{ matrix.target-framework }}-${{ matrix.runtime }}.zip"
          token: ${{ secrets.PAT }}
          prerelease: ${{ steps.project-build.outputs.is_prerelease }}
          allowUpdates: true
          draft: true
          


================================================
File: .github/workflows/BitMono.Core.yaml
================================================
name: BitMono.Core

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Core.yaml'
      - 'src/BitMono.Core/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Core.yaml'
      - 'src/BitMono.Core/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.Core Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.Core
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true
        


================================================
File: .github/workflows/BitMono.GlobalTool.yaml
================================================
name: BitMono.GlobalTool

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.GlobalTool.yaml'
      - 'src/BitMono.GlobalTool/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.GlobalTool.yaml'
      - 'src/BitMono.GlobalTool/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.GlobalTool Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.GlobalTool
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true
        use_runtime: false  # Because this is a dotnet tool.
        


================================================
File: .github/workflows/BitMono.Host.yaml
================================================
name: BitMono.Host

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Host.yaml'
      - 'src/BitMono.Host/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Host.yaml'
      - 'src/BitMono.Host/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.Host Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.Host
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true


================================================
File: .github/workflows/BitMono.Obfuscation.yaml
================================================
name: BitMono.Obfuscation

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Obfuscation.yaml'
      - 'src/BitMono.Obfuscation/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Obfuscation.yaml'
      - 'src/BitMono.Obfuscation/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.Obfuscation Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.Obfuscation
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true


================================================
File: .github/workflows/BitMono.Protections.yaml
================================================
name: BitMono.Protections

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Protections.yaml'
      - 'src/BitMono.Protections/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Protections.yaml'
      - 'src/BitMono.Protections/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.Protections Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.Protections
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true


================================================
File: .github/workflows/BitMono.Runtime.yaml
================================================
name: BitMono.Runtime

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Runtime.yaml'
      - 'src/BitMono.Runtime/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Runtime.yaml'
      - 'src/BitMono.Runtime/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.Runtime Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.Runtime
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true


================================================
File: .github/workflows/BitMono.Shared.yaml
================================================
name: BitMono.Shared

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Shared.yaml'
      - 'src/BitMono.Shared/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Shared.yaml'
      - 'src/BitMono.Shared/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.Shared Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.Shared
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true



================================================
File: .github/workflows/BitMono.Utilities.yaml
================================================
name: BitMono.Utilities

on:
  create:
    tags:
      - "*"
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Utilities.yaml'
      - 'src/BitMono.Utilities/**'
      - 'src/props/**'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/BitMono.Utilities.yaml'
      - 'src/BitMono.Utilities/**'
      - 'src/props/**'

jobs:
  build:
    name: "BitMono.Utilities Build"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-dotnet@v4
      name: Setup .NET
      with:
        dotnet-version: 9.x
        
    - uses: ./.github/actions/project-build
      id: project-build
      with:
        project_path: src/BitMono.Utilities
        github_token: ${{ secrets.PAT }}
        nuget_key: ${{ secrets.NUGET_DEPLOY_KEY }}
        nuget_push: true


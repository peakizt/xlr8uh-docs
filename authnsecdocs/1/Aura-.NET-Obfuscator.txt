Directory structure:
└── loomisntreal-aura-.net-obfuscator/
    ├── README.md
    ├── LICENSE
    └── Aura/
        ├── Aura.sln
        └── Aura/
            ├── App.config
            ├── App.xaml
            ├── App.xaml.cs
            ├── Aura.csproj
            ├── GlobalSuppressions.cs
            ├── MainWindow.xaml
            ├── MainWindow.xaml.cs
            ├── Properties/
            │   ├── AssemblyInfo.cs
            │   ├── Resources.Designer.cs
            │   ├── Resources.resx
            │   ├── Settings.Designer.cs
            │   └── Settings.settings
            ├── Protection/
            │   ├── Control Flow/
            │   │   ├── Block.cs
            │   │   ├── BlockParser.cs
            │   │   ├── ControlFlowObfuscation.cs
            │   │   └── JumpCFlow.cs
            │   ├── Integer Confusion/
            │   │   └── AddIntPhase.cs
            │   ├── Invalid Metadata/
            │   │   ├── InvalidMDPhase.cs
            │   │   └── MindLated.png.cs
            │   ├── Local Fields/
            │   │   ├── L2F.cs
            │   │   └── L2FV2.cs
            │   ├── Math/
            │   │   ├── Arithmetic.cs
            │   │   ├── ArithmeticEmulator.cs
            │   │   ├── ArithmeticTypes.cs
            │   │   ├── ArithmeticVT.cs
            │   │   ├── Token.cs
            │   │   ├── Value.cs
            │   │   ├── iFunction.cs
            │   │   ├── Functions/
            │   │   │   ├── Add.cs
            │   │   │   ├── Div.cs
            │   │   │   ├── Mul.cs
            │   │   │   ├── Sub.cs
            │   │   │   ├── Xor.cs
            │   │   │   └── Maths/
            │   │   │       ├── Abs.cs
            │   │   │       ├── Ceiling.cs
            │   │   │       ├── Cos.cs
            │   │   │       ├── Floor.cs
            │   │   │       ├── Log.cs
            │   │   │       ├── Log10.cs
            │   │   │       ├── Round.cs
            │   │   │       ├── Sin.cs
            │   │   │       ├── Sqrt.cs
            │   │   │       ├── Tan.cs
            │   │   │       ├── Tanh.cs
            │   │   │       └── Truncate.cs
            │   │   ├── Generator/
            │   │   │   └── Generator.cs
            │   │   └── Utils/
            │   │       └── ArithmeticUtils.cs
            │   ├── Online Strings/
            │   │   ├── Decoder.php
            │   │   ├── OnlinePhase.cs
            │   │   └── OnlineStringClass.cs
            │   ├── Proxy/
            │   │   ├── ProxyINT.cs
            │   │   ├── ProxyMeth.cs
            │   │   └── ProxyString.cs
            │   ├── Renamer/
            │   │   └── RenamerPhase.cs
            │   ├── Software/
            │   │   ├── AntiDebug.cs
            │   │   ├── AntiDecompile.cs
            │   │   ├── AntiDump.cs
            │   │   ├── AntiTamper.cs
            │   │   └── Runtime/
            │   │       ├── AntiDebugHandler.cs
            │   │       ├── AntiDumpHandler.cs
            │   │       └── AntiTamperHandler.cs
            │   ├── Stack-Calli Conversion/
            │   │   ├── Calli.cs
            │   │   └── StackUnfConfusion.cs
            │   └── Strings/
            │       ├── EncryptionHelper.cs
            │       └── StringEncPhase.cs
            ├── Services/
            │   └── InjectHelper.cs
            └── obj/
                ├── Aura.csproj.nuget.dgspec.json
                ├── Aura.csproj.nuget.g.props
                ├── Aura.csproj.nuget.g.targets
                └── Debug/
                    ├── App.baml
                    ├── App.g.cs
                    └── App.g.i.cs

================================================
File: README.md
================================================
<p align="center"><img width=60% src="https://i.vgy.me/2q0t5S.png"></p>
<p align="center"><b>"Keep decompilers at bay, forever"</b></p>

<br>

![Build Status](https://github.com/aura-systems/Aura-Operating-System/workflows/.NET%20Core/badge.svg)
[![Issues](https://img.shields.io/github/issues/loomisntreal/Aura-.NET-Obfuscator.svg)](https://github.com/loomisntreal/Aura-.NET-Obfuscator/issues)
[![Pull requests](https://img.shields.io/github/issues-pr/loomisntreal/Aura-.NET-Obfuscator.svg)](https://github.com/loomisntreal/Aura-.NET-Obfuscator/pulls)

A secure based .NET Obfuscator developed in C# made by loom (loomisntreal).

## Current Features

* String Encryption (encodes strings in the program)
* Online Decryption (decrypts the encrypted strings (string encryption must checked true for this to work) from the online method inside of the source-code)
* Control Flow (mangles with the methods inside of the code so decompilers cannot decompile the methods)
* Integer Confusion (this will add calculations inside of all integers)
* Math Calculations (this adds arithmetic inside of all constants)
* Constant Fields (converts all constants to fields with randomly selected names)
* Local Fields (converts all locals to fields with randomly selected names)
* Calli Conversion (converts all calls & calculations to calli calculations)
* Proxy Strings (hides string references that were referenced to a type, method, or field)
* Proxy Constants (hides constant references that were referenced to a type, method, or field)
* Proxy Methods (hides references that were referenced to a type, method, or field)
* Index Fields (indexes types/methods/fields)
* Flow Conversion (floods decompilers)
* Anti-Debug (prevents the assembly from being debugged or profiled)
* Anti-Dump (prevents the assembly from being dumped from memory)
* Anti-Tamper (ensures the integrity of the application)
* Anti-Decompile (prevents decompilers from working)
* Invalid Metadata (adds invalid metadata to modules to prevent disassemblers/decompilers from opening the application)
* Stack Conversion (adds a piece of code in front of all methods and converts them to a stack)
* Resource Conversion (converts all resources in the application to fields)

## Screenshots

<p align="center"><img width=60% src="https://i.vgy.me/Svxjzm.png"></p>

<p align="center"><img width=60% src="https://i.vgy.me/Qxn6xi.png"></p>

## FAQ

* Q: Is there a binary available? A: No, you have to build it yourself.
* Q: Will this project still be updated? A: Yes, if any decompilers are made for this obfuscator, minor & major bugs, or even a new feature, we will update this repository.

## Contribution
Do you want to add awesome features to Aura? Here's how:

- Fork Aura-.NET-Obfuscator repository
- Commit & push a new feature to the forked repository
- Open a pull request from your fork to Aura .NET Obfuscator
- We will review it and merge it



================================================
File: LICENSE
================================================
BSD 3-Clause License

Copyright (c) 2020, loom
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



================================================
File: Aura/Aura.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30114.105
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Aura", "Aura\Aura.csproj", "{92C502A6-BC06-45F6-BBE9-83F54ABDA05B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{92C502A6-BC06-45F6-BBE9-83F54ABDA05B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{92C502A6-BC06-45F6-BBE9-83F54ABDA05B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{92C502A6-BC06-45F6-BBE9-83F54ABDA05B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{92C502A6-BC06-45F6-BBE9-83F54ABDA05B}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {327B7BE7-7353-4FC8-A5A8-6F22174A0866}
	EndGlobalSection
EndGlobal



================================================
File: Aura/Aura/App.config
================================================
<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<startup>
		<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
	</startup>
</configuration>



================================================
File: Aura/Aura/App.xaml
================================================
ï»¿<Application x:Class="Aura.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <!-- MahApps.Metro resource dictionaries. Make sure that all file names are Case Sensitive! -->
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Controls.xaml" />
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Fonts.xaml" />

                <!-- Theme setting -->
                <ResourceDictionary Source="pack://application:,,,/MahApps.Metro;component/Styles/Themes/Light.Blue.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>


================================================
File: Aura/Aura/App.xaml.cs
================================================
ï»¿using System.Windows;

namespace Aura
{
    /// <summary>
    /// Logique d'interaction pour App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}


================================================
File: Aura/Aura/Aura.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{92C502A6-BC06-45F6-BBE9-83F54ABDA05B}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>Aura</RootNamespace>
    <AssemblyName>Aura</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
    <TargetFrameworkProfile />
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup>
    <NoWin32Manifest>true</NoWin32Manifest>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>Aura.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Web" />
    <Reference Include="System.Web.Extensions" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Compile Include="GlobalSuppressions.cs" />
    <Compile Include="Protection\Proxy\ProxyINT.cs" />
    <Compile Include="Protection\Proxy\ProxyMeth.cs" />
    <Compile Include="Protection\Proxy\ProxyString.cs" />
    <Compile Include="Protection\Renamer\RenamerPhase.cs" />
    <Compile Include="Protection\Strings\EncryptionHelper.cs" />
    <Compile Include="Protection\Online Strings\OnlinePhase.cs" />
    <Compile Include="Protection\Online Strings\OnlineStringClass.cs" />
    <Compile Include="Protection\Strings\StringEncPhase.cs" />
    <Compile Include="Services\InjectHelper.cs" />
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Protection\Math\Arithmetic.cs" />
    <Compile Include="Protection\Math\ArithmeticEmulator.cs" />
    <Compile Include="Protection\Math\ArithmeticTypes.cs" />
    <Compile Include="Protection\Math\ArithmeticVT.cs" />
    <Compile Include="Protection\Math\Functions\Add.cs" />
    <Compile Include="Protection\Math\Functions\Div.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Abs.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Ceiling.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Cos.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Floor.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Log.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Log10.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Round.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Sin.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Sqrt.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Tan.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Tanh.cs" />
    <Compile Include="Protection\Math\Functions\Maths\Truncate.cs" />
    <Compile Include="Protection\Math\Functions\Mul.cs" />
    <Compile Include="Protection\Math\Functions\Sub.cs" />
    <Compile Include="Protection\Math\Functions\Xor.cs" />
    <Compile Include="Protection\Math\Generator\Generator.cs" />
    <Compile Include="Protection\Math\IFunction.cs" />
    <Compile Include="Protection\Math\Token.cs" />
    <Compile Include="Protection\Math\Utils\ArithmeticUtils.cs" />
    <Compile Include="Protection\Math\Value.cs" />
    <Compile Include="Protection\Stack-Calli Conversion\Calli.cs" />
    <Compile Include="Protection\Control Flow\Block.cs" />
    <Compile Include="Protection\Control Flow\BlockParser.cs" />
    <Compile Include="Protection\Control Flow\ControlFlowObfuscation.cs" />
    <Compile Include="Protection\Control Flow\JumpCFlow.cs" />
    <Compile Include="Protection\Integer Confusion\AddIntPhase.cs" />
    <Compile Include="Protection\Invalid Metadata\InvalidMDPhase.cs" />
    <Compile Include="Protection\Invalid Metadata\MindLated.png.cs" />
    <Compile Include="Protection\Local Fields\L2F.cs" />
    <Compile Include="Protection\Local Fields\L2FV2.cs" />
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Protection\Software\AntiDebug.cs" />
    <Compile Include="Protection\Software\AntiDump.cs" />
    <Compile Include="Protection\Software\AntiTamper.cs" />
    <Compile Include="Protection\Software\AntiDecompile.cs" />
    <Compile Include="Protection\Software\Runtime\AntiDebugHandler.cs" />
    <Compile Include="Protection\Software\Runtime\AntiDumpHandler.cs" />
    <Compile Include="Protection\Software\Runtime\AntiTamperHandler.cs" />
    <Compile Include="Protection\Stack-Calli Conversion\StackUnfConfusion.cs" />
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <None Include="Protection\Online Strings\Decoder.php" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <Resource Include="Aura.ico" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.7.2">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET FrameworkÂ 4.7.2 %28x86 et x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="ControlzEx">
      <Version>4.4.0</Version>
    </PackageReference>
    <PackageReference Include="dnlib">
      <Version>3.3.2</Version>
    </PackageReference>
    <PackageReference Include="MahApps.Metro">
      <Version>2.4.0</Version>
    </PackageReference>
    <PackageReference Include="MahApps.Metro.IconPacks.Modern">
      <Version>4.8.0</Version>
    </PackageReference>
    <PackageReference Include="Microsoft.Xaml.Behaviors.Wpf">
      <Version>1.1.19</Version>
    </PackageReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>Ce projet fait rÃ©fÃ©rence Ã  des packages NuGet qui sont manquants sur cet ordinateur. Utilisez l'option de restauration des packages NuGet pour les tÃ©lÃ©charger. Pour plus d'informations, consultez http://go.microsoft.com/fwlink/?LinkID=322105. Le fichier manquant est : {0}.</ErrorText>
    </PropertyGroup>
  </Target>
</Project>


================================================
File: Aura/Aura/GlobalSuppressions.cs
================================================
ï»¿// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.

using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Style", "IDE0060:Supprimer le paramÃ¨tre inutilisÃ©", Justification = "<En attente>", Scope = "member", Target = "~M:Aura.Protection.Anti.Runtime.AntiDumpRun.InitBlock(System.Void*,System.Byte,System.UInt32)")]
[assembly: SuppressMessage("Style", "IDE0060:Supprimer le paramÃ¨tre inutilisÃ©", Justification = "<En attente>", Scope = "member", Target = "~M:Aura.Protection.Anti.Runtime.AntiDumpRun.CopyBlock(System.Void*,System.Void*,System.UInt32)")]
[assembly: SuppressMessage("CodeQuality", "IDE0051:Supprimer les membres privÃ©s non utilisÃ©s", Justification = "<En attente>", Scope = "member", Target = "~M:Aura.Protection.Anti.Runtime.AntiDebugSafe.Initialize")]
[assembly: SuppressMessage("CodeQuality", "IDE0051:Supprimer les membres privÃ©s non utilisÃ©s", Justification = "<En attente>", Scope = "member", Target = "~M:Aura.Protection.Anti.Runtime.EOFAntitamp.Initializer")]
[assembly: SuppressMessage("Style", "IDE1006:Styles d'affectation de noms", Justification = "<En attente>", Scope = "type", Target = "~T:Aura.Protection.Arithmetic.iFunction")]
[assembly: SuppressMessage("CodeQuality", "IDE0051:Supprimer les membres privÃ©s non utilisÃ©s", Justification = "<En attente>", Scope = "member", Target = "~M:Aura.Protection.Anti.Runtime.EOFAntiTamper.Initializer")]


================================================
File: Aura/Aura/MainWindow.xaml
================================================
ï»¿<mah:MetroWindow x:Class="Aura.MainWindow"
                 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                 xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
                 xmlns:mah="clr-namespace:MahApps.Metro.Controls;assembly=MahApps.Metro"
                 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:iconPacks="http://metro.mahapps.com/winfx/xaml/iconpacks"
                 
                 ResizeMode="CanMinimize"
                 TitleCharacterCasing="Normal"
                 Title="Aura"
                 Width="622"
                 Height="305"
                 WindowStartupLocation="CenterScreen"

                 mc:Ignorable="d">

    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="41*"/>
            <ColumnDefinition Width="214*"/>
            <ColumnDefinition Width="53*"/>
        </Grid.ColumnDefinitions>
        <mah:MetroAnimatedTabControl HorizontalAlignment="Left" Width="614" Grid.ColumnSpan="3">
            <mah:MetroTabItem Header="General" Margin="3,-1,-3,1">
                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="45*"/>
                        <ColumnDefinition Width="262*"/>
                    </Grid.ColumnDefinitions>
                    <Button
                        Style="{DynamicResource MahApps.Styles.Button.Circle}" ToolTip="Build Executable" Margin="0,193,108,0" HorizontalAlignment="Right" Width="33" Height="33" VerticalAlignment="Top" Click="Button_Click" Grid.Column="1">
                        <iconPacks:PackIconModern Width="23" Height="23" Kind="ArrowRight" />
                    </Button>
                    <Image Margin="397,10,20,80" Source="Aura.ico" Grid.Column="1" HorizontalAlignment="Stretch" Width="Auto" />
                    <TextBox x:Name="ConsoleLog" HorizontalAlignment="Left" Height="227" TextWrapping="Wrap" VerticalAlignment="Top" Width="462" Margin="5,0,0,0" Grid.ColumnSpan="2" />
                    <Label Content="Start Obfuscation" HorizontalAlignment="Left" Margin="419,196,0,0" VerticalAlignment="Top" FontSize="11" Grid.Column="1" Height="27" />
                </Grid>
            </mah:MetroTabItem>
            <mah:MetroTabItem Header="Settings" Margin="2,-1,-2,1">
                <Grid ForceCursor="True">
                    <TextBox x:Name="Program" ToolTip="Drop your program here" HorizontalAlignment="Left" Height="22" Margin="32,18,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Width="543" DragEnter="LoadBox_DragEnter" Drop="LoadBox_Drop" AllowDrop="True" PreviewDragOver="LoadBox_PreviewDragOver" />
                    <CheckBox x:Name="String_Encryption" Content="String Encryption" HorizontalAlignment="Left" Margin="53,68,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Online_Decryption" Content="Online Decryption" HorizontalAlignment="Left" Margin="53,91,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Cflow" Content="Control Flow" HorizontalAlignment="Left" Margin="53,114,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="IntConf" Content="Integer Confusion" HorizontalAlignment="Left" Margin="53,137,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Ahri" Content="Math Calculations" HorizontalAlignment="Left" Margin="53,160,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="LF" Content="Constant Fields" HorizontalAlignment="Left" Margin="178,68,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="LFV2" Content="Local Fields" HorizontalAlignment="Left" Margin="178,91,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Calli_" Content="Calli Conversion" HorizontalAlignment="Left" Margin="178,114,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Proxy_String" Content="Proxy Strings" HorizontalAlignment="Left" Margin="178,137,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="ProxyConstants" Content="Proxy Constants" HorizontalAlignment="Left" Margin="178,160,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Proxy_Meth" Content="Proxy Methods" HorizontalAlignment="Left" Margin="303,68,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Index_Fields" Content="Index Fields" HorizontalAlignment="Left" Margin="303,91,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="JumpCflow" Content="Flow Conversion" HorizontalAlignment="Left" Margin="303,114,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="AntiDebug" Content="Anti-Debug" HorizontalAlignment="Left" Margin="303,137,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Anti_Dump" Content="Anti-Dump" HorizontalAlignment="Left" Margin="303,160,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="AntiTamper" Content="Anti-Tamper" HorizontalAlignment="Left" Margin="428,68,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="Anti_De4dot" Content="Anti-Decompile" HorizontalAlignment="Left" Margin="428,91,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="InvalidMD" Content="Invalid Metadata" HorizontalAlignment="Left" Margin="428,114,0,0" VerticalAlignment="Top" Width="120" />
                    <CheckBox x:Name="SUC" Content="Stack Conversion" HorizontalAlignment="Left" Margin="428,137,0,0" VerticalAlignment="Top" Width="133" />
                    <CheckBox x:Name="RES" Content="Resource Conversion" HorizontalAlignment="Left" Margin="428,160,0,0" VerticalAlignment="Top" Width="147" />
                </Grid>
            </mah:MetroTabItem>
        </mah:MetroAnimatedTabControl>
    </Grid>
</mah:MetroWindow>



================================================
File: Aura/Aura/MainWindow.xaml.cs
================================================
ï»¿using ControlzEx.Theming;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using Aura.Protection.Software;
using Aura.Protection.Arithmetic;
using Aura.Protection.CtrlFlow;
using Aura.Protection.INT;
using Aura.Protection.InvalidMD;
using Aura.Protection.LocalF;
using Aura.Protection.Other;
using Aura.Protection.Proxy;
using Aura.Protection.Renamer;
using Aura.Protection.String;
using Aura.Protection.StringOnline;
using System;
using System.Diagnostics;
using System.IO;
using System.Windows;
using Brushes = System.Windows.Media.Brushes;

namespace Aura
{
    /// <summary>
    /// Logique d'interaction pour MainWindow.xaml
    /// </summary>
    public partial class MainWindow
    {
        public static MethodDef Init;
        public static MethodDef Init2;

        public string DirectoryName = string.Empty;

        public MainWindow() 
        {
            InitializeComponent();
            ThemeManager.Current.ThemeSyncMode = ThemeSyncMode.DoNotSync;
            ThemeManager.Current.SyncTheme();
        }

        public byte MaxValue = byte.MaxValue;

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            var time = DateTime.Now.ToString("hh:mm:ss");
            ModuleContext modCtx = ModuleDef.CreateModuleContext();
            var module = ModuleDefMD.Load(Program.Text, modCtx);

            ConsoleLog.Foreground = Brushes.Black;
            ConsoleLog.AppendText($"{time} Starting obfuscation{Environment.NewLine}");

            if (String_Encryption.IsChecked == true)
            {
                StringEncPhase.Execute(module);
                ConsoleLog.AppendText($"{time} Processing string encryption{Environment.NewLine}");
            }

            if (Online_Decryption.IsChecked == true)
            {
                OnlinePhase.Execute(module);
                ConsoleLog.AppendText($"{time} Processing online decryption{Environment.NewLine}");
            }

            if (Cflow.IsChecked == true)
            {
                ControlFlowObfuscation.Execute(module);
                ConsoleLog.AppendText($"{time} Processing control flow{Environment.NewLine}");
            }

            if (IntConf.IsChecked == true)
            {
                AddIntPhase.Execute2(module);
                ConsoleLog.AppendText($"{time} Processing integer confusion{Environment.NewLine}");
            }

            if (SUC.IsChecked == true)
            {
                StackUnfConfusion.Execute(module);
                ConsoleLog.AppendText($"{time} Processing stack confusion{Environment.NewLine}");
            }

            if (Ahri.IsChecked == true)
            {
                Arithmetic.Execute(module);
                ConsoleLog.AppendText($"{time} Processing math calculations{Environment.NewLine}");
            }

            if (LF.IsChecked == true)
            {
                L2F.Execute(module);
                ConsoleLog.AppendText($"{time} Processing constant fields{Environment.NewLine}");
            }

            if (LFV2.IsChecked == true)
            {
                L2FV2.Execute(module);
                ConsoleLog.AppendText($"{time} Processing local fields{Environment.NewLine}");
            }

            if (Calli_.IsChecked == true)
            {
                Calli.Execute(module);
                ConsoleLog.AppendText($"{time} Processing calli conversion{Environment.NewLine}");
            }

            if (Proxy_String.IsChecked == true)
            {
                ProxyString.Execute(module);
                ConsoleLog.AppendText($"{time} Processing proxy strings{Environment.NewLine}");
            }

            if (ProxyConstants.IsChecked == true)
            {
                ProxyINT.Execute(module);
                ConsoleLog.AppendText($"{time} Processing proxy constants{Environment.NewLine}");
            }

            if (Proxy_Meth.IsChecked == true)
            {
                ProxyMeth.Execute(module);
                ConsoleLog.AppendText($"{time} Processing proxy methods{Environment.NewLine}");
            }

            if (Anti_De4dot.IsChecked == true)
            {
                AntiDecompile.Execute(module.Assembly);
                ConsoleLog.AppendText($"{time} Processing anti-decompile{Environment.NewLine}");
            }

            if (JumpCflow.IsChecked == true)
            {
                JumpCFlow.Execute(module);
                ConsoleLog.AppendText($"{time} Processing flow conversion{Environment.NewLine}");
            }

            if (AntiDebug.IsChecked == true)
            {
                Anti_Debug.Execute(module);
                ConsoleLog.AppendText($"{time} Processing anti-debug{Environment.NewLine}");
            }

            if (Anti_Dump.IsChecked == true)
            {
                AntiDump.Execute(module);
                ConsoleLog.AppendText($"{time} Processing anti-dump{Environment.NewLine}");
            }

            if (AntiTamper.IsChecked == true)
            {
                Protection.Software.AntiTamper.Execute(module);
                ConsoleLog.AppendText($"{time} Processing anti-tamper{Environment.NewLine}");
            }

            if (InvalidMD.IsChecked == true)
            {
                InvalidMDPhase.Execute(module.Assembly);
                ConsoleLog.AppendText($"{time} Processing invalid metadata{Environment.NewLine}");
            }

            var text2 = Path.GetDirectoryName(Program.Text);
            if (text2 != null && !text2.EndsWith("\\"))
            {
                text2 += "\\";
            }

            var path = $"{text2}{Path.GetFileNameWithoutExtension(Program.Text)}_protected{Path.GetExtension(Program.Text)}";

            module.Write(path,
                         new ModuleWriterOptions(module)
                         { PEHeadersOptions = { NumberOfRvaAndSizes = 13 }, Logger = DummyLogger.NoThrowInstance });

            ConsoleLog.AppendText($"{time} File: {path}{Environment.NewLine}{Environment.NewLine}");

            if (AntiTamper.IsChecked == true)
            {
                Protection.Software.AntiTamper.Sha256(path);
            }
        }

        private void LoadBox_DragEnter(object sender, DragEventArgs e)
        { e.Effects = e.Data.GetDataPresent(DataFormats.FileDrop) ? DragDropEffects.Copy : DragDropEffects.None; }

        private void LoadBox_Drop(object sender, DragEventArgs e)
        {
            try
            {
                var array = (Array)e.Data.GetData(DataFormats.FileDrop);
                if (array == null)
                    return;
                var text = array.GetValue(0).ToString();
                var num = text.LastIndexOf(".", StringComparison.Ordinal);
                if (num == -1)
                    return;
                var text2 = text.Substring(num);
                text2 = text2.ToLower();
                if (string.Compare(text2, ".exe", StringComparison.Ordinal) != 0 && string.Compare(text2, ".dll", StringComparison.Ordinal) != 0)
                {
                    return;
                }

                Activate();
                Program.Text = text;
                var num2 = text.LastIndexOf("\\", StringComparison.Ordinal);
                if (num2 != -1)
                {
                    DirectoryName = text.Remove(num2, text.Length - num2);
                }

                if (DirectoryName.Length == 2)
                {
                    DirectoryName += "\\";
                }
            }
            catch
            {
                /* ignored */
            }
        }

        private void LoadBox_PreviewDragOver(object sender, DragEventArgs e) { e.Handled = true; }
    }
}



================================================
File: Aura/Aura/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows;

[assembly: AssemblyTitle("Aura")]
[assembly: AssemblyDescription("https://github.com/Sato-Isolated/Aura")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Aura Services")]
[assembly: AssemblyProduct("Aura")]
[assembly: AssemblyCopyright("Copyright Â© 2020")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: ComVisible(true)]
[assembly: ThemeInfo(ResourceDictionaryLocation.None, ResourceDictionaryLocation.SourceAssembly)]
[assembly: AssemblyVersion("1.0.0")]
[assembly: AssemblyFileVersion("1.0.0")]
[assembly: Guid("20180FD2-96D4-478B-BA67-C72FB46CCFD4")]


================================================
File: Aura/Aura/Properties/Resources.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Aura.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Aura.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}



================================================
File: Aura/Aura/Properties/Resources.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
File: Aura/Aura/Properties/Settings.Designer.cs
================================================
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Aura.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "16.7.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}



================================================
File: Aura/Aura/Properties/Settings.settings
================================================
ï»¿<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>


================================================
File: Aura/Aura/Protection/Control Flow/Block.cs
================================================
ï»¿using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Aura.Protection.CtrlFlow
{
    public class Block
    {
        public Block()
        {
            Instructions = new List<Instruction>();
        }

        public List<Instruction> Instructions { get; set; }

        public int Number { get; set; }
    }
}


================================================
File: Aura/Aura/Protection/Control Flow/BlockParser.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Aura.Protection.CtrlFlow
{
    public class BlockParser
    {
        public static List<Block> ParseMethod(MethodDef method)
        {
            var blocks = new List<Block>();
            var block = new Block();
            var Id = 0;
            var usage = 0;
            block.Number = Id;
            block.Instructions.Add(Instruction.Create(OpCodes.Nop));
            blocks.Add(block);
            block = new Block();
            var handlers = new Stack<ExceptionHandler>();
            foreach (var instruction in method.Body.Instructions)
            {
                foreach (var eh in method.Body.ExceptionHandlers)
                {
                    if (eh.HandlerStart == instruction || eh.TryStart == instruction || eh.FilterStart == instruction)
                        handlers.Push(eh);
                }
                foreach (var eh in method.Body.ExceptionHandlers)
                {
                    if (eh.HandlerEnd == instruction || eh.TryEnd == instruction)
                        handlers.Pop();
                }

                instruction.CalculateStackUsage(out var stacks, out var pops);
                block.Instructions.Add(instruction);
                usage += stacks - pops;
                if (stacks == 0)
                {
                    if (instruction.OpCode != OpCodes.Nop)
                    {
                        if ((usage == 0 || instruction.OpCode == OpCodes.Ret) && handlers.Count == 0)
                        {
                            block.Number = ++Id;
                            blocks.Add(block);
                            block = new Block();
                        }
                    }
                }
            }
            return blocks;
        }
    }
}


================================================
File: Aura/Aura/Protection/Control Flow/ControlFlowObfuscation.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.CtrlFlow
{
    internal class ControlFlowObfuscation
    {
        public static void Execute(ModuleDefMD md)
        {
            foreach (var tDef in md.Types)
            {
                if (tDef == md.GlobalType) continue;
                foreach (var mDef in tDef.Methods)
                {
                    if (mDef.Name.StartsWith("get_") || mDef.Name.StartsWith("set_")) continue;
                    if (!mDef.HasBody || mDef.IsConstructor) continue;
                    mDef.Body.SimplifyBranches();
                    ExecuteMethod(mDef);
                }
            }
        }

        public static void ExecuteMethod(MethodDef method)
        {
            method.Body.SimplifyMacros(method.Parameters);
            var blocks = BlockParser.ParseMethod(method);
            blocks = Randomize(blocks);
            method.Body.Instructions.Clear();
            var local = new Local(method.Module.CorLibTypes.Int32);
            method.Body.Variables.Add(local);
            var target = Instruction.Create(OpCodes.Nop);
            var instr = Instruction.Create(OpCodes.Br, target);
            foreach (var instruction in Calc(0))
                method.Body.Instructions.Add(instruction);
            method.Body.Instructions.Add(Instruction.Create(OpCodes.Stloc, local));
            method.Body.Instructions.Add(Instruction.Create(OpCodes.Br, instr));
            method.Body.Instructions.Add(target);
            foreach (var block in blocks.Where(block => block != blocks.Single(x => x.Number == blocks.Count - 1)))
            {
                method.Body.Instructions.Add(Instruction.Create(OpCodes.Ldloc, local));
                foreach (var instruction in Calc(block.Number))
                    method.Body.Instructions.Add(instruction);
                method.Body.Instructions.Add(Instruction.Create(OpCodes.Ceq));
                var instruction4 = Instruction.Create(OpCodes.Nop);
                method.Body.Instructions.Add(Instruction.Create(OpCodes.Brfalse, instruction4));

                foreach (var instruction in block.Instructions)
                    method.Body.Instructions.Add(instruction);

                foreach (var instruction in Calc(block.Number + 1))
                    method.Body.Instructions.Add(instruction);

                method.Body.Instructions.Add(Instruction.Create(OpCodes.Stloc, local));
                method.Body.Instructions.Add(instruction4);
            }
            method.Body.Instructions.Add(Instruction.Create(OpCodes.Ldloc, local));
            foreach (var instruction in Calc(blocks.Count - 1))
                method.Body.Instructions.Add(instruction);
            method.Body.Instructions.Add(Instruction.Create(OpCodes.Ceq));
            method.Body.Instructions.Add(Instruction.Create(OpCodes.Brfalse, instr));
            method.Body.Instructions.Add(Instruction.Create(OpCodes.Br, blocks.Single(x => x.Number == blocks.Count - 1).Instructions[0]));
            method.Body.Instructions.Add(instr);

            foreach (var lastBlock in blocks.Single(x => x.Number == blocks.Count - 1).Instructions)
                method.Body.Instructions.Add(lastBlock);
        }

        public static Random rnd = new Random();

        public static List<Block> Randomize(List<Block> input)
        {
            var ret = new List<Block>();
            foreach (var group in input)
                ret.Insert(rnd.Next(0, ret.Count), group);
            return ret;
        }

        public static List<Instruction> Calc(int value)
        {
            var instructions = new List<Instruction> { Instruction.Create(OpCodes.Ldc_I4, value) };
            return instructions;
        }

        public void AddJump(IList<Instruction> instrs, Instruction target)
        {
            instrs.Add(Instruction.Create(OpCodes.Br, target));
        }
    }
}


================================================
File: Aura/Aura/Protection/Control Flow/JumpCFlow.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Linq;

namespace Aura.Protection.CtrlFlow
{
    public static class JumpCFlow
    {
        public static void Execute(ModuleDefMD module)
        {
            foreach (var type in module.Types)
            {
                foreach (var method in type.Methods.ToArray())
                {
                    if (!method.HasBody || !method.Body.HasInstructions || method.Body.HasExceptionHandlers) continue;
                    for (var i = 0; i < method.Body.Instructions.Count - 2; i++)
                    {
                        var inst = method.Body.Instructions[i + 1];
                        method.Body.Instructions.Insert(i + 1, Instruction.Create(OpCodes.Ldstr, "Aura.jpg"));
                        method.Body.Instructions.Insert(i + 1, Instruction.Create(OpCodes.Br_S, inst));
                        i += 2;
                    }
                }
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Integer Confusion/AddIntPhase.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;

namespace Aura.Protection.INT
{
    public static class AddIntPhase
    {
        /*public static void Execute(ModuleDef module)
        {
            foreach (var type in module.GetTypes())
            {
                if (type.IsGlobalModuleType) continue;
                foreach (var methodDef2 in type.Methods)
                {
                    if (!methodDef2.HasBody) continue;
                    var instr = methodDef2.Body.Instructions;
                    for (var i = 0; i < instr.Count; i++)
                    {
                        if (!methodDef2.Body.Instructions[i].IsLdcI4()) continue;
                        var rnd = new Random();
                        var randomuint = rnd.Next(2147483647);
                        methodDef2.Body.Instructions.Insert(i + 1, Instruction.Create(OpCodes.Sizeof, methodDef2.Module.Import(typeof(bool))));
                        methodDef2.Body.Instructions.Insert(i + 2, Instruction.Create(OpCodes.Add));
                        methodDef2.Body.Instructions.Insert(i + 3, Instruction.Create(OpCodes.Ldc_R8, Math.PI / 2));
                        methodDef2.Body.Instructions.Insert(i + 4, Instruction.Create(OpCodes.Call, methodDef2.Module.Import(typeof(Math).GetMethod("Sin", new Type[] { typeof(double) }))));
                        methodDef2.Body.Instructions.Insert(i + 5, Instruction.Create(OpCodes.Conv_I4));
                        methodDef2.Body.Instructions.Insert(i + 6, Instruction.Create(OpCodes.Sub));
                        methodDef2.Body.Instructions.Insert(i + 7, Instruction.Create(OpCodes.Sizeof, methodDef2.Module.Import(typeof(bool))));
                        methodDef2.Body.Instructions.Insert(i + 8, Instruction.Create(OpCodes.Add));
                        methodDef2.Body.Instructions.Insert(i + 9, Instruction.Create(OpCodes.Ldc_R8, Math.PI / randomuint));
                        methodDef2.Body.Instructions.Insert(i + 10, Instruction.Create(OpCodes.Call, methodDef2.Module.Import(typeof(Math).GetMethod("Cos", new Type[] { typeof(double) }))));
                        methodDef2.Body.Instructions.Insert(i + 11, Instruction.Create(OpCodes.Conv_I4));
                        methodDef2.Body.Instructions.Insert(i + 12, Instruction.Create(OpCodes.Sub));
                    }
                }
            }
        }*/

        public static void Execute2(ModuleDef md)
        {
            foreach (var type in md.GetTypes())
            {
                if (type.IsGlobalModuleType) continue;
                foreach (var method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    {
                        for (var i = 0; i < method.Body.Instructions.Count; i++)
                        {
                            if (!method.Body.Instructions[i].IsLdcI4()) continue;
                            var numorig = new Random(Guid.NewGuid().GetHashCode()).Next();
                            var div = new Random(Guid.NewGuid().GetHashCode()).Next();
                            var num = numorig ^ div;

                            var nop = OpCodes.Nop.ToInstruction();

                            var local = new Local(method.Module.ImportAsTypeSig(typeof(int)));
                            method.Body.Variables.Add(local);

                            method.Body.Instructions.Insert(i + 1, OpCodes.Stloc.ToInstruction(local));
                            method.Body.Instructions.Insert(i + 2, Instruction.Create(OpCodes.Ldc_I4, method.Body.Instructions[i].GetLdcI4Value() - sizeof(float)));
                            method.Body.Instructions.Insert(i + 3, Instruction.Create(OpCodes.Ldc_I4, num));
                            method.Body.Instructions.Insert(i + 4, Instruction.Create(OpCodes.Ldc_I4, div));
                            method.Body.Instructions.Insert(i + 5, Instruction.Create(OpCodes.Xor));
                            method.Body.Instructions.Insert(i + 6, Instruction.Create(OpCodes.Ldc_I4, numorig));
                            method.Body.Instructions.Insert(i + 7, Instruction.Create(OpCodes.Bne_Un, nop));
                            method.Body.Instructions.Insert(i + 8, Instruction.Create(OpCodes.Ldc_I4, 2));
                            method.Body.Instructions.Insert(i + 9, OpCodes.Stloc.ToInstruction(local));
                            method.Body.Instructions.Insert(i + 10, Instruction.Create(OpCodes.Sizeof, method.Module.Import(typeof(float))));
                            method.Body.Instructions.Insert(i + 11, Instruction.Create(OpCodes.Add));
                            method.Body.Instructions.Insert(i + 12, nop);
                            i += 12;
                        }
                        method.Body.SimplifyBranches();
                    }
                }
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Invalid Metadata/InvalidMDPhase.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Renamer;
using System;

namespace Aura.Protection.InvalidMD
{
    internal class InvalidMDPhase
    {
        public static void Execute(AssemblyDef asm)
        {
            var manifestModule = asm.ManifestModule;
            manifestModule.Mvid = null;
            manifestModule.Name = RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal);
            asm.ManifestModule.Import(new FieldDefUser(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal)));
            foreach (var typeDef in manifestModule.Types)
            {
                TypeDef typeDef2 = new TypeDefUser(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal));
                typeDef2.Methods.Add(new MethodDefUser());
                typeDef2.NestedTypes.Add(new TypeDefUser(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal)));
                MethodDef item = new MethodDefUser();
                typeDef2.Methods.Add(item);
                typeDef.NestedTypes.Add(typeDef2);
                typeDef.Events.Add(new EventDefUser());
                foreach (var methodDef2 in typeDef.Methods)
                {
                    if (methodDef2.Body == null) continue;
                    methodDef2.Body.SimplifyBranches();
                    if (string.Compare(methodDef2.ReturnType.FullName, "System.Void", StringComparison.Ordinal) != 0 || !methodDef2.HasBody ||
                        methodDef2.Body.Instructions.Count == 0) continue;
                    var typeSig = asm.ManifestModule.Import(typeof(int)).ToTypeSig();
                    var local = new Local(typeSig);
                    var typeSig2 = asm.ManifestModule.Import(typeof(bool)).ToTypeSig();
                    var local2 = new Local(typeSig2);
                    methodDef2.Body.Variables.Add(local);
                    methodDef2.Body.Variables.Add(local2);
                    var operand = methodDef2.Body.Instructions[methodDef2.Body.Instructions.Count - 1];
                    var instruction = new Instruction(OpCodes.Ret);
                    var instruction2 = new Instruction(OpCodes.Ldc_I4_1);
                    methodDef2.Body.Instructions.Insert(0, new Instruction(OpCodes.Ldc_I4_0));
                    methodDef2.Body.Instructions.Insert(1, new Instruction(OpCodes.Stloc, local));
                    methodDef2.Body.Instructions.Insert(2, new Instruction(OpCodes.Br, instruction2));
                    var instruction3 = new Instruction(OpCodes.Ldloc, local);
                    methodDef2.Body.Instructions.Insert(3, instruction3);
                    methodDef2.Body.Instructions.Insert(4, new Instruction(OpCodes.Ldc_I4_0));
                    methodDef2.Body.Instructions.Insert(5, new Instruction(OpCodes.Ceq));
                    methodDef2.Body.Instructions.Insert(6, new Instruction(OpCodes.Ldc_I4_1));
                    methodDef2.Body.Instructions.Insert(7, new Instruction(OpCodes.Ceq));
                    methodDef2.Body.Instructions.Insert(8, new Instruction(OpCodes.Stloc, local2));
                    methodDef2.Body.Instructions.Insert(9, new Instruction(OpCodes.Ldloc, local2));
                    methodDef2.Body.Instructions.Insert(10, new Instruction(OpCodes.Brtrue, methodDef2.Body.Instructions[10]));
                    methodDef2.Body.Instructions.Insert(11, new Instruction(OpCodes.Ret));
                    methodDef2.Body.Instructions.Insert(12, new Instruction(OpCodes.Calli));
                    methodDef2.Body.Instructions.Insert(13, new Instruction(OpCodes.Sizeof, operand));
                    methodDef2.Body.Instructions.Insert(methodDef2.Body.Instructions.Count, instruction2);
                    methodDef2.Body.Instructions.Insert(methodDef2.Body.Instructions.Count, new Instruction(OpCodes.Stloc, local2));
                    methodDef2.Body.Instructions.Insert(methodDef2.Body.Instructions.Count, new Instruction(OpCodes.Br, instruction3));
                    methodDef2.Body.Instructions.Insert(methodDef2.Body.Instructions.Count, instruction);
                    var exceptionHandler = new ExceptionHandler(ExceptionHandlerType.Finally)
                    {
                        HandlerStart = methodDef2.Body.Instructions[10],
                        HandlerEnd = methodDef2.Body.Instructions[11],
                        TryEnd = methodDef2.Body.Instructions[14],
                        TryStart = methodDef2.Body.Instructions[12]
                    };
                    if (!methodDef2.Body.HasExceptionHandlers)
                    {
                        methodDef2.Body.ExceptionHandlers.Add(exceptionHandler);
                    }
                    methodDef2.Body.OptimizeBranches();
                    methodDef2.Body.OptimizeMacros();
                }
            }
            TypeDef typeDef3 = new TypeDefUser(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal));
            FieldDef item2 = new FieldDefUser(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal), new FieldSig(manifestModule.Import(typeof(MindLated_png)).ToTypeSig()));
            typeDef3.Fields.Add(item2);
            typeDef3.BaseType = manifestModule.Import(typeof(MindLated_png));
            manifestModule.Types.Add(typeDef3);
            TypeDef typeDef4 = new TypeDefUser(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal))
            {
                IsInterface = true,
                IsSealed = true
            };
            manifestModule.Types.Add(typeDef4);
            manifestModule.TablesHeaderVersion = 257;
        }
    }
}


================================================
File: Aura/Aura/Protection/Invalid Metadata/MindLated.png.cs
================================================
ï»¿namespace Aura.Protection.InvalidMD
{
    public static class MindLated_png
    {
    }
}


================================================
File: Aura/Aura/Protection/Local Fields/L2F.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Renamer;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.LocalF
{
    internal class L2F
    {
        private static Dictionary<Local, FieldDef> convertedLocals = new Dictionary<Local, FieldDef>();

        public static void Execute(ModuleDef Module)
        {
            foreach (var type in Module.Types.Where(x => x != Module.GlobalType))
            {
                foreach (var method2 in type.Methods.Where(x => x.HasBody && x.Body.HasInstructions && !x.IsConstructor))
                {
                    convertedLocals = new Dictionary<Local, FieldDef>();
                    Process(Module, method2);
                }
            }
        }

        public static void Process(ModuleDef module, MethodDef method)
        {
            var instructions = method.Body.Instructions;
            foreach (var t in instructions)
            {
                if (!(t.Operand is Local local)) continue;
                FieldDef def;
                if (!convertedLocals.ContainsKey(local))
                {
                    def = new FieldDefUser(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal), new FieldSig(local.Type), FieldAttributes.Public | FieldAttributes.Static);
                    module.GlobalType.Fields.Add(def);
                    convertedLocals.Add(local, def);
                }
                else
                    def = convertedLocals[local];

                OpCode eq = null;
                switch (t.OpCode.Code)
                {
                    case Code.Ldloc:
                    case Code.Ldloc_S:
                    case Code.Ldloc_0:
                    case Code.Ldloc_1:
                    case Code.Ldloc_2:
                    case Code.Ldloc_3:
                        eq = OpCodes.Ldsfld;
                        break;

                    case Code.Ldloca:
                    case Code.Ldloca_S:
                        eq = OpCodes.Ldsflda;
                        break;

                    case Code.Stloc:
                    case Code.Stloc_0:
                    case Code.Stloc_1:
                    case Code.Stloc_2:
                    case Code.Stloc_3:
                    case Code.Stloc_S:
                        eq = OpCodes.Stsfld;
                        break;
                }
                t.OpCode = eq;
                t.Operand = def;
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Local Fields/L2FV2.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Renamer;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.LocalF
{
    internal class L2FV2
    {
        private static Dictionary<Local, FieldDef> convertedLocals = new Dictionary<Local, FieldDef>();

        public static void Execute(ModuleDef Module)
        {
            foreach (var type in Module.Types.Where(x => x != Module.GlobalType))
            {
                foreach (var method2 in type.Methods.Where(x => x.HasBody && x.Body.HasInstructions && !x.IsConstructor))
                {
                    convertedLocals = new Dictionary<Local, FieldDef>();
                    Process(Module, method2);
                }
            }
        }

        public static void Process(ModuleDef Module, MethodDef method)
        {
            method.Body.SimplifyMacros(method.Parameters);
            var instructions = method.Body.Instructions;
            foreach (var t in instructions)
            {
                if (!(t.Operand is Local local)) continue;
                FieldDef def = null;
                if (!convertedLocals.ContainsKey(local))
                {
                    def = new FieldDefUser(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal), new FieldSig(local.Type), FieldAttributes.Public | FieldAttributes.Static);
                    Module.GlobalType.Fields.Add(def);
                    convertedLocals.Add(local, def);
                }
                else
                    def = convertedLocals[local];

                OpCode eq = null;
                switch (t.OpCode.Code)
                {
                    case Code.Ldloc:
                        eq = OpCodes.Ldsfld;
                        break;

                    case Code.Ldloca:
                        eq = OpCodes.Ldsflda;
                        break;

                    case Code.Stloc:
                        eq = OpCodes.Stsfld;
                        break;
                }
                t.OpCode = eq;
                t.Operand = def;
            }
            convertedLocals.ToList().ForEach(x => method.Body.Variables.Remove(x.Key));
            convertedLocals = new Dictionary<Local, FieldDef>();
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Arithmetic.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Functions;
using Aura.Protection.Arithmetic.Utils;
using System;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic
{
    public class Arithmetic
    {
        public static ModuleDef moduleDef1;

        public static List<iFunction> Tasks = new List<iFunction>()
        {
            new Add(),
            new Sub(),
            new Div(),
            new Mul(),
            new Xor(),
            new Functions.Maths.Abs(),
            new Functions.Maths.Log(),
            new Functions.Maths.Log10(),
            new Functions.Maths.Sin(),
            new Functions.Maths.Cos(),
            new Functions.Maths.Floor(),
            new Functions.Maths.Round(),
            new Functions.Maths.Tan(),
            new Functions.Maths.Tanh(),
            new Functions.Maths.Sqrt(),
            new Functions.Maths.Ceiling(),
            new Functions.Maths.Truncate()
        };

        public static void Execute(ModuleDef moduleDef)
        {
            moduleDef1 = moduleDef;
            var generator = new Generator.Generator();
            foreach (var tDef in moduleDef.Types)
            {
                foreach (var mDef in tDef.Methods)
                {
                    if (!mDef.HasBody) continue;
                    if (mDef.DeclaringType.IsGlobalModuleType) continue;
                    for (var i = 0; i < mDef.Body.Instructions.Count; i++)
                    {
                        if (!ArithmeticUtils.CheckArithmetic(mDef.Body.Instructions[i])) continue;
                        if (mDef.Body.Instructions[i].GetLdcI4Value() < 0)
                        {
                            var iFunction = Tasks[generator.Next(5)];
                            var lstInstr = GenerateBody(iFunction.Arithmetic(mDef.Body.Instructions[i], moduleDef));
                            if (lstInstr == null) continue;
                            mDef.Body.Instructions[i].OpCode = OpCodes.Nop;
                            foreach (var instr in lstInstr)
                            {
                                mDef.Body.Instructions.Insert(i + 1, instr);
                                i++;
                            }
                        }
                        else
                        {
                            var iFunction = Tasks[generator.Next(Tasks.Count)];
                            var lstInstr = GenerateBody(iFunction.Arithmetic(mDef.Body.Instructions[i], moduleDef));
                            if (lstInstr == null) continue;
                            mDef.Body.Instructions[i].OpCode = OpCodes.Nop;
                            foreach (var instr in lstInstr)
                            {
                                mDef.Body.Instructions.Insert(i + 1, instr);
                                i++;
                            }
                        }
                    }
                }
            }
        }

        private static List<Instruction> GenerateBody(ArithmeticVT arithmeticVTs)
        {
            var instructions = new List<Instruction>();
            if (IsArithmetic(arithmeticVTs.GetArithmetic()))
            {
                instructions.Add(new Instruction(OpCodes.Ldc_R8, arithmeticVTs.GetValue().GetX()));
                instructions.Add(new Instruction(OpCodes.Ldc_R8, arithmeticVTs.GetValue().GetY()));

                if (arithmeticVTs.GetToken().GetOperand() != null)
                {
                    instructions.Add(new Instruction(OpCodes.Call, arithmeticVTs.GetToken().GetOperand()));
                }
                instructions.Add(new Instruction(arithmeticVTs.GetToken().GetOpCode()));
                instructions.Add(new Instruction(OpCodes.Call, moduleDef1.Import(typeof(Convert).GetMethod("ToInt32", new Type[] { typeof(double) }))));
                //instructions.Add(new Instruction(OpCodes.Conv_I4));
            }
            else if (IsXor(arithmeticVTs.GetArithmetic()))
            {
                instructions.Add(new Instruction(OpCodes.Ldc_I4, (int)arithmeticVTs.GetValue().GetX()));
                instructions.Add(new Instruction(OpCodes.Ldc_I4, (int)arithmeticVTs.GetValue().GetY()));
                instructions.Add(new Instruction(arithmeticVTs.GetToken().GetOpCode()));
                instructions.Add(new Instruction(OpCodes.Conv_I4));
            }
            return instructions;
        }

        private static bool IsArithmetic(ArithmeticTypes arithmetic)
        {
            return arithmetic == ArithmeticTypes.Add || arithmetic == ArithmeticTypes.Sub || arithmetic == ArithmeticTypes.Div || arithmetic == ArithmeticTypes.Mul ||
                arithmetic == ArithmeticTypes.Abs || arithmetic == ArithmeticTypes.Log || arithmetic == ArithmeticTypes.Log10 || arithmetic == ArithmeticTypes.Truncate ||
                arithmetic == ArithmeticTypes.Sin || arithmetic == ArithmeticTypes.Cos || arithmetic == ArithmeticTypes.Floor || arithmetic == ArithmeticTypes.Round ||
                arithmetic == ArithmeticTypes.Tan || arithmetic == ArithmeticTypes.Tanh || arithmetic == ArithmeticTypes.Sqrt || arithmetic == ArithmeticTypes.Ceiling;
        }

        private static bool IsXor(ArithmeticTypes arithmetic)
        {
            return arithmetic == ArithmeticTypes.Xor;
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/ArithmeticEmulator.cs
================================================
ï»¿using System;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic
{
    public class ArithmeticEmulator
    {
        private readonly double x;
        private readonly double y;
        private readonly ArithmeticTypes arithmeticTypes;
        public new ArithmeticTypes GetType { get; private set; }

        public ArithmeticEmulator(double x, double y, ArithmeticTypes arithmeticTypes)
        {
            this.x = x;
            this.y = y;
            this.arithmeticTypes = arithmeticTypes;
        }

        public double GetValue()
        {
            switch (arithmeticTypes)
            {
                case ArithmeticTypes.Add:
                    return x - y;

                case ArithmeticTypes.Sub:
                    return x + y;

                case ArithmeticTypes.Div:
                    return x * y;

                case ArithmeticTypes.Mul:
                    return x / y;

                case ArithmeticTypes.Xor:
                    return ((int)x ^ (int)y);
            }
            return -1;
        }

        public double GetValue(List<ArithmeticTypes> arithmetics)
        {
            var generator = new Generator.Generator();
            var arithmetic = arithmetics[generator.Next(arithmetics.Count)];
            GetType = arithmetic;
            switch (arithmeticTypes)
            {
                case ArithmeticTypes.Abs:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x + (Math.Abs(y) * -1);

                        case ArithmeticTypes.Sub:
                            return x - (Math.Abs(y) * -1);
                    }
                    return -1;

                case ArithmeticTypes.Log:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Log(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Log(y));
                    }
                    return -1;

                case ArithmeticTypes.Log10:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Log10(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Log10(y));
                    }
                    return -1;

                case ArithmeticTypes.Sin:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Sin(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Sin(y));
                    }
                    return -1;

                case ArithmeticTypes.Cos:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Cos(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Cos(y));
                    }
                    return -1;

                case ArithmeticTypes.Floor:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Floor(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Floor(y));
                    }
                    return -1;

                case ArithmeticTypes.Round:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Round(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Round(y));
                    }
                    return -1;

                case ArithmeticTypes.Tan:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Tan(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Tan(y));
                    }
                    return -1;

                case ArithmeticTypes.Tanh:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Tanh(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Tanh(y));
                    }
                    return -1;

                case ArithmeticTypes.Sqrt:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Sqrt(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Sqrt(y));
                    }
                    return -1;

                case ArithmeticTypes.Ceiling:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Ceiling(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Ceiling(y));
                    }
                    return -1;

                case ArithmeticTypes.Truncate:
                    switch (arithmetic)
                    {
                        case ArithmeticTypes.Add:
                            return x - (Math.Truncate(y));

                        case ArithmeticTypes.Sub:
                            return x + (Math.Truncate(y));
                    }
                    return -1;
            }
            return -1;
        }

        public double GetY() => y;
    }
}


================================================
File: Aura/Aura/Protection/Math/ArithmeticTypes.cs
================================================
ï»¿namespace Aura.Protection.Arithmetic
{
    public enum ArithmeticTypes
    {
        Add, // +
        Sub, // -
        Div, // /
        Mul, // *
        Xor, // ^
        Abs, // -1
        Log, //
        Log10,
        Sin,
        Cos,
        Round,
        Sqrt,
        Ceiling,
        Floor,
        Tan,
        Tanh,
        Truncate
    }
}


================================================
File: Aura/Aura/Protection/Math/ArithmeticVT.cs
================================================
ï»¿namespace Aura.Protection.Arithmetic
{
    public class ArithmeticVT
    {
        private readonly Value value;
        private readonly Token token;
        private readonly ArithmeticTypes arithmeticTypes;

        public ArithmeticVT(Value value, Token token, ArithmeticTypes arithmeticTypes)
        {
            this.value = value;
            this.token = token;
            this.arithmeticTypes = arithmeticTypes;
        }

        public Value GetValue() => value;

        public Token GetToken() => token;

        public ArithmeticTypes GetArithmetic() => arithmeticTypes;
    }
}


================================================
File: Aura/Aura/Protection/Math/Token.cs
================================================
ï»¿using dnlib.DotNet.Emit;

namespace Aura.Protection.Arithmetic
{
    public class Token
    {
        private readonly OpCode opCode;
        private readonly object Operand;

        public Token(OpCode opCode, object Operand)
        {
            this.opCode = opCode;
            this.Operand = Operand;
        }

        public Token(OpCode opCode)
        {
            this.opCode = opCode;
            this.Operand = null;
        }

        public OpCode GetOpCode() => opCode;

        public object GetOperand() => Operand;
    }
}


================================================
File: Aura/Aura/Protection/Math/Value.cs
================================================
ï»¿namespace Aura.Protection.Arithmetic
{
    public class Value
    {
        private readonly double x;
        private readonly double y;

        public Value(double x, double y)
        {
            this.x = x;
            this.y = y;
        }

        public double GetX() => x;

        public double GetY() => y;
    }
}


================================================
File: Aura/Aura/Protection/Math/iFunction.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Aura.Protection.Arithmetic
{
    public abstract class iFunction
    {
        public abstract ArithmeticTypes ArithmeticTypes { get; }

        public abstract ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module);
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Add.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;

namespace Aura.Protection.Arithmetic.Functions
{
    public class Add : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Add;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(), arithmeticEmulator.GetY()), new Token(OpCodes.Add), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Div.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;

namespace Aura.Protection.Arithmetic.Functions
{
    public class Div : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Div;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(), arithmeticEmulator.GetY()), new Token(OpCodes.Div), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Mul.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;

namespace Aura.Protection.Arithmetic.Functions
{
    public class Mul : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Mul;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(), arithmeticEmulator.GetY()), new Token(OpCodes.Mul), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Sub.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;

namespace Aura.Protection.Arithmetic.Functions
{
    public class Sub : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Sub;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(), arithmeticEmulator.GetY()), new Token(OpCodes.Sub), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Xor.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;

namespace Aura.Protection.Arithmetic.Functions
{
    public class Xor : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Xor;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            var generator = new Generator.Generator();
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), generator.Next(), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(), arithmeticEmulator.GetY()), new Token(OpCodes.Xor), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Abs.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Abs : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Abs;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Ceiling.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Ceiling : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Ceiling;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Cos.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Cos : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Cos;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Floor.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Floor : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Floor;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Log.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Log : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Log;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Log10.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Log10 : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Log10;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Round.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Round : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Round;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Sin.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Sin : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Sin;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Sqrt.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Sqrt : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Sqrt;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Tan.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Tan : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Tan;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Tanh.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Tanh : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Tanh;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Functions/Maths/Truncate.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Arithmetic.Utils;
using System.Collections.Generic;

namespace Aura.Protection.Arithmetic.Functions.Maths
{
    public class Truncate : iFunction
    {
        public override ArithmeticTypes ArithmeticTypes => ArithmeticTypes.Truncate;

        public override ArithmeticVT Arithmetic(Instruction instruction, ModuleDef module)
        {
            if (!ArithmeticUtils.CheckArithmetic(instruction)) return null;
            var arithmeticTypes = new List<ArithmeticTypes> { ArithmeticTypes.Add, ArithmeticTypes.Sub };
            var arithmeticEmulator = new ArithmeticEmulator(instruction.GetLdcI4Value(), ArithmeticUtils.GetY(instruction.GetLdcI4Value()), ArithmeticTypes);
            return (new ArithmeticVT(new Value(arithmeticEmulator.GetValue(arithmeticTypes), arithmeticEmulator.GetY()), new Token(ArithmeticUtils.GetOpCode(arithmeticEmulator.GetType), module.Import(ArithmeticUtils.GetMethod(ArithmeticTypes))), ArithmeticTypes));
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Generator/Generator.cs
================================================
ï»¿using System;

namespace Aura.Protection.Arithmetic.Generator
{
    public class Generator
    {
        private readonly Random random;

        public Generator()
        {
            random = new Random(Guid.NewGuid().GetHashCode());
        }

        public int Next()
        {
            return random.Next(int.MaxValue);
        }

        public int Next(int value)
        {
            return random.Next(value);
        }

        public int Next(int min, int max)
        {
            return random.Next(min, max);
        }
    }
}


================================================
File: Aura/Aura/Protection/Math/Utils/ArithmeticUtils.cs
================================================
ï»¿using dnlib.DotNet.Emit;
using System;

namespace Aura.Protection.Arithmetic.Utils
{
    public class ArithmeticUtils
    {
        public static bool CheckArithmetic(Instruction instruction)
        {
            if (!instruction.IsLdcI4())
                return false;
            if (instruction.GetLdcI4Value() == 1)
                return false;
            return instruction.GetLdcI4Value() != 0;
        }

        public static double GetY(double x) => (x / 2);

        public static System.Reflection.MethodInfo GetMethod(ArithmeticTypes mathType)
        {
            switch (mathType)
            {
                case ArithmeticTypes.Abs:
                    return ((typeof(Math).GetMethod("Abs", new Type[] { typeof(double) })));

                case ArithmeticTypes.Round:
                    return ((typeof(Math).GetMethod("Round", new Type[] { typeof(double) })));

                case ArithmeticTypes.Sin:
                    return ((typeof(Math).GetMethod("Sin", new Type[] { typeof(double) })));

                case ArithmeticTypes.Cos:
                    return ((typeof(Math).GetMethod("Cos", new Type[] { typeof(double) })));

                case ArithmeticTypes.Log:
                    return ((typeof(Math).GetMethod("Log", new Type[] { typeof(double) })));

                case ArithmeticTypes.Log10:
                    return ((typeof(Math).GetMethod("Log10", new Type[] { typeof(double) })));

                case ArithmeticTypes.Sqrt:
                    return ((typeof(Math).GetMethod("Sqrt", new Type[] { typeof(double) })));

                case ArithmeticTypes.Ceiling:
                    return ((typeof(Math).GetMethod("Ceiling", new Type[] { typeof(double) })));

                case ArithmeticTypes.Floor:
                    return ((typeof(Math).GetMethod("Floor", new Type[] { typeof(double) })));

                case ArithmeticTypes.Tan:
                    return ((typeof(Math).GetMethod("Tan", new Type[] { typeof(double) })));

                case ArithmeticTypes.Tanh:
                    return ((typeof(Math).GetMethod("Tanh", new Type[] { typeof(double) })));

                case ArithmeticTypes.Truncate:
                    return ((typeof(Math).GetMethod("Truncate", new Type[] { typeof(double) })));
            }
            return null;
        }

        public static OpCode GetOpCode(ArithmeticTypes arithmetic)
        {
            switch (arithmetic)
            {
                case ArithmeticTypes.Add:
                    return OpCodes.Add;

                case ArithmeticTypes.Sub:
                    return OpCodes.Sub;
            }
            return null;
        }
    }
}


================================================
File: Aura/Aura/Protection/Online Strings/Decoder.php
================================================
<?php
$hex = $_GET['string'];
function hexToStr($hex){
    $string='';
    for ($i=0; $i < strlen($hex)-1; $i+=2){
        $string .= chr(hexdec($hex[$i].$hex[$i+1]));
    }
    return $string;
}
$str = hexToStr($hex);
echo "{$str}\n";



================================================
File: Aura/Aura/Protection/Online Strings/OnlinePhase.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Services;
using System;
using System.Linq;

namespace Aura.Protection.StringOnline
{
    public static class OnlinePhase
    {
        public static void Execute(ModuleDef module)
        {
            InjectClass1(module);
            foreach (var type in module.GetTypes())
            {
                if (type.IsGlobalModuleType) continue;
                foreach (var methodDef2 in type.Methods)
                {
                    if (!methodDef2.HasBody || !methodDef2.Body.HasInstructions) continue;
                    if (methodDef2.Name.Contains("Decoder")) continue;
                    for (var i = 0; i < methodDef2.Body.Instructions.Count; i++)
                    {
                        if (methodDef2.Body.Instructions[i].OpCode != OpCodes.Ldstr) continue;
                        var plainText = methodDef2.Body.Instructions[i].Operand.ToString();
                        var operand = ConvertStringToHex(plainText);
                        methodDef2.Body.Instructions[i].Operand = operand;
                        methodDef2.Body.Instructions.Insert(i + 1, Instruction.Create(OpCodes.Call, MainWindow.Init));
                    }
                    methodDef2.Body.SimplifyBranches();
                }
            }
        }

        public static string ConvertStringToHex(string asciiString)
        {
            var hex = string.Empty;
            foreach (var c in asciiString)
            {
                int tmp = c;
                hex += $"{Convert.ToUInt32(tmp.ToString()):x2}";
            }
            return hex;
        }

        public static void InjectClass1(ModuleDef module)
        {
            var typeModule = ModuleDefMD.Load(typeof(OnlineString).Module);
            var typeDef = typeModule.ResolveTypeDef(MDToken.ToRID(typeof(OnlineString).MetadataToken));
            var members = InjectHelper.Inject(typeDef, module.GlobalType, module);
            MainWindow.Init = (MethodDef)members.Single(method => method.Name == "Decoder");
            foreach (var md in module.GlobalType.Methods)
            {
                if (md.Name != ".ctor") continue;
                module.GlobalType.Remove(md);
                break;
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Online Strings/OnlineStringClass.cs
================================================
ï»¿using System.Net;
using System.Reflection;

namespace Aura.Protection.StringOnline
{
    internal class OnlineString
    {
        public static string Decoder(string encrypted)
        {
            if (Assembly.GetExecutingAssembly() != Assembly.GetCallingAssembly()) return "Aura.png";
            var webClient = new WebClient();
            return webClient.DownloadString($"https://liria.club/encryption/Decoder.php?string={encrypted}");
        }
    }
}



================================================
File: Aura/Aura/Protection/Proxy/ProxyINT.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;

namespace Aura.Protection.Proxy
{
    public static class ProxyINT
    {
        public static Random rand = new Random();

        public static void Execute(ModuleDef module)
        {
            foreach (var type in module.GetTypes())
            {
                if (type.IsGlobalModuleType) continue;
                foreach (var method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    var instr = method.Body.Instructions;
                    for (var i = 0; i < instr.Count; i++)
                    {
                        if (method.Body.Instructions[i].IsLdcI4())
                        {
                            var methImplFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
                            var methFlags = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
                            var meth1 = new MethodDefUser(Renamer.RenamerPhase.GenerateString(Renamer.RenamerPhase.RenameMode.Normal),
                                        MethodSig.CreateStatic(module.CorLibTypes.Int32),
                                        methImplFlags, methFlags);
                            module.GlobalType.Methods.Add(meth1);
                            meth1.Body = new CilBody();
                            meth1.Body.Variables.Add(new Local(module.CorLibTypes.Int32));
                            meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Ldc_I4, instr[i].GetLdcI4Value()));
                            meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
                            instr[i].OpCode = OpCodes.Call;
                            instr[i].Operand = meth1;
                        }
                        else if (method.Body.Instructions[i].OpCode == OpCodes.Ldc_R4)
                        {
                            var methImplFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
                            var methFlags = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
                            var meth1 = new MethodDefUser(Renamer.RenamerPhase.GenerateString(Renamer.RenamerPhase.RenameMode.Normal),
                                        MethodSig.CreateStatic(module.CorLibTypes.Double),
                                        methImplFlags, methFlags);
                            module.GlobalType.Methods.Add(meth1);
                            meth1.Body = new CilBody();
                            meth1.Body.Variables.Add(new Local(module.CorLibTypes.Double));
                            meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Ldc_R4, (float)method.Body.Instructions[i].Operand));
                            meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
                            instr[i].OpCode = OpCodes.Call;
                            instr[i].Operand = meth1;
                        }
                    }
                }
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Proxy/ProxyMeth.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.Proxy
{
    public static class ProxyMeth
    {
        public static Random rand = new Random();
        public static List<MemberRef> MemberRefList = new List<MemberRef>();

        //Scan de toutes les MemberRef
        public static void ScanMemberRef(ModuleDef module)
        {
            foreach (var type in module.Types)
            {
                foreach (var method in type.Methods)
                {
                    if (!method.HasBody || !method.Body.HasInstructions) continue;
                    for (var i = 0; i < method.Body.Instructions.Count - 1; i++)
                    {
                        if (method.Body.Instructions[i].OpCode != OpCodes.Call) continue;
                        try
                        {
                            var original = (MemberRef)method.Body.Instructions[i].Operand;
                            if (!original.HasThis)
                            {
                                MemberRefList.Add(original);
                            }
                        }
                        catch
                        {
                            // ignored
                        }
                    }
                }
            }
        }

        public static MethodDef GenerateSwitch(MemberRef original, ModuleDef md)
        {
            try
            {
                var type = original.MethodSig.Params.ToList();
                type.Add(md.CorLibTypes.Int32);
                var methImplFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
                var methFlags = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
                MethodDef meth = new MethodDefUser($"{(rand.Next(0, int.MaxValue))}", MethodSig.CreateStatic(original.MethodSig.RetType, type.ToArray()), methImplFlags, methFlags)
                {
                    Body = new CilBody()
                };
                meth.Body.Variables.Add(new Local(md.CorLibTypes.Int32));
                meth.Body.Variables.Add(new Local(md.CorLibTypes.Int32));
                meth.Body.Instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
                var lst = new List<Instruction>();
                var switchs = new Instruction(OpCodes.Switch);
                meth.Body.Instructions.Add(switchs);
                var br_s = new Instruction(OpCodes.Br_S);
                meth.Body.Instructions.Add(br_s);
                for (var i = 0; i < 5; i++)
                {
                    for (var ia = 0; ia <= original.MethodSig.Params.Count - 1; ia++)
                    {
                        meth.Body.Instructions.Add(Instruction.Create(OpCodes.Ldarg, meth.Parameters[ia]));
                        if (ia == 0)
                        {
                            lst.Add(Instruction.Create(OpCodes.Ldarg, meth.Parameters[ia]));
                        }
                    }
                    var ldstr = Instruction.Create(OpCodes.Ldc_I4, i);
                    meth.Body.Instructions.Add(ldstr);
                    meth.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
                }

                var ldnull = Instruction.Create(OpCodes.Ldnull);
                meth.Body.Instructions.Add(ldnull);
                meth.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
                br_s.Operand = ldnull;
                switchs.Operand = lst;
                return meth;
            }
            catch
            {
                return null;
            }
        }

        public static IEnumerable<T> Randomize<T>(IEnumerable<T> source)
        {
            var rnd = new Random();
            return source.OrderBy<T, int>((item) => rnd.Next());
        }

        public static void Execute(ModuleDef module)
        {
            ScanMemberRef(module);
            foreach (var type in module.GetTypes())
            {
                if (type.IsGlobalModuleType) continue;
                foreach (var method in type.Methods.ToArray())
                {
                    if (!method.HasBody || method.Name.Contains("Proxy")) continue;
                    var instr = method.Body.Instructions;
                    for (var i = 0; i < instr.Count; i++)
                    {
                        if (method.Body.Instructions[i].OpCode != OpCodes.Call) continue;
                        try
                        {
                            var original = (MemberRef)method.Body.Instructions[i].Operand;
                            if (!original.HasThis)
                            {
                                var proxy = GenerateSwitch(original, module);
                                method.DeclaringType.Methods.Add(proxy);
                                instr[i].OpCode = OpCodes.Call;
                                instr[i].Operand = proxy;
                                var random = rand.Next(0, 5);
                                for (var b = 0; b < proxy.Body.Instructions.Count - 1; b++)
                                {
                                    if (proxy.Body.Instructions[b].OpCode == OpCodes.Ldc_I4)
                                    {
                                        if (string.Compare(proxy.Body.Instructions[b].Operand.ToString(), random.ToString(), StringComparison.Ordinal) != 0)
                                        {
                                            proxy.Body.Instructions[b].OpCode = OpCodes.Call;
                                            proxy.Body.Instructions[b].Operand = MemberRefList.Where(m => m.MethodSig.Params.Count == original.MethodSig.Params.Count).ToList().Random();
                                        }
                                        else
                                        {
                                            proxy.Body.Instructions[b].OpCode = OpCodes.Call;
                                            proxy.Body.Instructions[b].Operand = original;
                                        }
                                    }
                                }

                                method.Body.Instructions.Insert(i, Instruction.CreateLdcI4(random));

                                /*        MethodSig originalsignature = original.MethodSig;
                                            var methImplFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
                                            var methFlags = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
                                            var meth1 = new MethodDefUser("AuraProxyMethods" + rand.Next(0, int.MaxValue).ToString(),
                                                       originalsignature,
                                                        methImplFlags, methFlags);
                                            module.GlobalType.Methods.Add(meth1);
                                            meth1.Body = new CilBody();
                                            for (int ia = 0; ia <= originalsignature.Params.Count - 1; ia++)
                                            {
                                                meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Ldarg, meth1.Parameters[ia]));
                                            }
                                            meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Call, original));
                                            meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));
                                            instr[i].OpCode = OpCodes.Call;
                                            instr[i].Operand = meth1;*/
                            }
                        }
                        catch
                        {
                            // ignored
                        }
                    }
                }
            }
        }
    }

    public static class EnumerableHelper
    {
        private static readonly Random r;

        static EnumerableHelper()
        {
            r = new Random();
        }

        public static E Random<E>(IEnumerable<E> input)
        {
            var enumerable = input as E[] ?? input.ToArray();
            return enumerable.ElementAt(r.Next(enumerable.Length));
        }
    }

    public static class EnumerableExtensions
    {
        public static T Random<T>(this IEnumerable<T> input)
        {
            return EnumerableHelper.Random(input);
        }
    }
}


================================================
File: Aura/Aura/Protection/Proxy/ProxyString.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;

namespace Aura.Protection.Proxy
{
    internal class ProxyString
    {
        public static Random rand = new Random();

        public static void Execute(ModuleDef module)
        {
            foreach (var type in module.GetTypes())
            {
                if (type.IsGlobalModuleType) continue;
                foreach (var method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    var instr = method.Body.Instructions;
                    foreach (var t in instr)
                    {
                        if (t.OpCode != OpCodes.Ldstr) continue;
                        var methImplFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
                        var methFlags = MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot;
                        var meth1 = new MethodDefUser(Renamer.RenamerPhase.GenerateString(Renamer.RenamerPhase.RenameMode.Normal),
                            MethodSig.CreateStatic(module.CorLibTypes.String),
                            methImplFlags, methFlags);
                        module.GlobalType.Methods.Add(meth1);
                        meth1.Body = new CilBody();
                        meth1.Body.Variables.Add(new Local(module.CorLibTypes.String));
                        meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Ldstr, t.Operand.ToString()));
                        meth1.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

                        t.OpCode = OpCodes.Call;
                        t.Operand = meth1;
                    }
                }
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Renamer/RenamerPhase.cs
================================================
ï»¿using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.Renamer
{
    public class RenamerPhase
    {
        private static readonly Dictionary<TypeDef, bool> TypeRename = new Dictionary<TypeDef, bool>();
        private static readonly List<string> TypeNewName = new List<string>();
        private static readonly Dictionary<MethodDef, bool> MethodRename = new Dictionary<MethodDef, bool>();
        private static readonly List<string> MethodNewName = new List<string>();
        private static readonly Dictionary<FieldDef, bool> FieldRename = new Dictionary<FieldDef, bool>();
        private static readonly List<string> FieldNewName = new List<string>();
        public static bool IsObfuscationActive = true;

        public static void Execute(ModuleDefMD module)
        {
            if (IsObfuscationActive)
            {
                //                var namespaceNewName = GenerateString(RenameMode.Normal);
                foreach (var type in module.Types)
                {
                    if (TypeRename.TryGetValue(type, out var canRenameType))
                    {
                        if (canRenameType && type.IsSerializable)
                            InternalRename(type);
                    }
                    else
                        InternalRename(type);
                    foreach (var method in type.Methods)
                    {
                        if (MethodRename.TryGetValue(method, out var canRenameMethod))
                        {
                            if (canRenameMethod && !method.IsConstructor && !method.IsSpecialName)
                                InternalRename(method);
                        }
                        else
                            InternalRename(method);
                    }
                    MethodNewName.Clear();
                    foreach (var field in type.Fields)
                    {
                        if (FieldRename.TryGetValue(field, out var canRenameField))
                        {
                            if (canRenameField)
                                InternalRename(field);
                        }
                        else
                            InternalRename(field);
                    }
                    FieldNewName.Clear();
                }
            }
            else
            {
                foreach (var typeItem in TypeRename.Where(typeItem => typeItem.Value))
                {
                    InternalRename(typeItem.Key);
                }
                foreach (var methodItem in MethodRename.Where(methodItem => methodItem.Value))
                {
                    InternalRename(methodItem.Key);
                }
                foreach (var fieldItem in FieldRename.Where(fieldItem => fieldItem.Value))
                {
                    InternalRename(fieldItem.Key);
                }
            }
        }

        private static void InternalRename(TypeDef type)
        {
            var randString = GenerateString(RenameMode.Normal);
            while (TypeNewName.Contains(randString))
                randString = GenerateString(RenameMode.Normal);
            TypeNewName.Add(randString);
            type.Name = randString;
        }

        private static void InternalRename(MethodDef method)
        {
            var randString = GenerateString(RenameMode.Normal);
            while (MethodNewName.Contains(randString))
                randString = GenerateString(RenameMode.Normal);
            MethodNewName.Add(randString);
            method.Name = randString;
        }

        private static void InternalRename(FieldDef field)
        {
            var randString = GenerateString(RenameMode.Normal);
            while (FieldNewName.Contains(randString))
                randString = GenerateString(RenameMode.Normal);
            FieldNewName.Add(randString);
            field.Name = randString;
        }

        public static Random Random = new Random();

        private static string RandomString(int length)
        {
            string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()-_+=[{}]|;:',<.>/?";
            return new string(Enumerable.Repeat(chars, length).Select(s => s[Random.Next(s.Length)]).ToArray());
        }

        public enum RenameMode
        {
            Ascii,
            Normal
        }

        public static string[] NormalNameStrings = {
            RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString(), RandomString(10).ToString()
        };

        public static string GetRandomName()
        {
            return NormalNameStrings[Random.Next(NormalNameStrings.Length)];
        }

        public static string Ascii = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()-_+=[{}]|;:',<.>/?";

        public static string GenerateString(RenameMode mode)
        {
            switch (mode)
            {
                case RenameMode.Ascii:
                    return GetRandomName();

                case RenameMode.Normal:
                    return GetRandomName();

                default:
                    throw new ArgumentOutOfRangeException(nameof(mode), mode, null);
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Software/AntiDebug.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Software.Runtime;
using Aura.Services;
using System.Linq;

namespace Aura.Protection.Software
{
    public static class Anti_Debug
    {
        public static void Execute(ModuleDef module)
        {
            var typeModule = ModuleDefMD.Load(typeof(AntiDebugSafe).Module);
            var cctor = module.GlobalType.FindOrCreateStaticConstructor();
            var typeDef = typeModule.ResolveTypeDef(MDToken.ToRID(typeof(AntiDebugSafe).MetadataToken));
            var members = InjectHelper.Inject(typeDef, module.GlobalType, module);
            var init = (MethodDef)members.Single(method => method.Name == "Initialize");
            cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init));
            foreach (var md in module.GlobalType.Methods)
            {
                if (md.Name != ".ctor") continue;
                module.GlobalType.Remove(md);
                break;
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Software/AntiDecompile.cs
================================================
ï»¿using dnlib.DotNet;

namespace Aura.Protection.Software
{
    internal class AntiDecompile
    {
        public static void Execute(AssemblyDef mod)
        {
            foreach (var module in mod.Modules)
            {
                var interfaceM = new InterfaceImplUser(module.GlobalType);
                for (var i = 0; i < 1; i++)
                {
                    var typeDef1 = new TypeDefUser(string.Empty, $"Form{i}", module.CorLibTypes.GetTypeRef("System", "Attribute"));
                    var interface1 = new InterfaceImplUser(typeDef1);
                    module.Types.Add(typeDef1);
                    typeDef1.Interfaces.Add(interface1);
                    typeDef1.Interfaces.Add(interfaceM);
                }
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Software/AntiDump.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Software.Runtime;
using Aura.Services;
using System.Linq;

namespace Aura.Protection.Software
{
    internal class AntiDump
    {
        public static void Execute(ModuleDef mod)
        {
            var typeModule = ModuleDefMD.Load(typeof(AntiDumpHandler).Module);
            var cctor = mod.GlobalType.FindOrCreateStaticConstructor();
            var typeDef = typeModule.ResolveTypeDef(MDToken.ToRID(typeof(AntiDumpHandler).MetadataToken));
            var members = InjectHelper.Inject(typeDef, mod.GlobalType, mod);
            var init = (MethodDef)members.Single(method => method.Name == "Initialize");
            cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init));
            foreach (var md in mod.GlobalType.Methods)
            {
                if (md.Name != ".ctor") continue;
                mod.GlobalType.Remove(md);
                break;
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Software/AntiTamper.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Protection.Software.Runtime;
using Aura.Services;
using System.IO;
using System.Linq;
using System.Security.Cryptography;

namespace Aura.Protection.Software
{
    public static class AntiTamper
    {
        public static void Sha256(string filePath)
        {
            var sha256Bytes = SHA256.Create().ComputeHash(File.ReadAllBytes(filePath));
            using (var stream = new FileStream(filePath, FileMode.Append))
            {
                stream.Write(sha256Bytes, 0, sha256Bytes.Length);
            }
        }

        public static void Execute(ModuleDef module)
        {
            var typeModule = ModuleDefMD.Load(typeof(AntiTamperHandler).Module);
            var cctor = module.GlobalType.FindOrCreateStaticConstructor();
            var typeDef = typeModule.ResolveTypeDef(MDToken.ToRID(typeof(AntiTamperHandler).MetadataToken));
            var members = InjectHelper.Inject(typeDef, module.GlobalType, module);
            var init = (MethodDef)members.Single(method => method.Name == "Initializer");
            cctor.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Call, init));
            foreach (var md in module.GlobalType.Methods)
            {
                if (md.Name != ".ctor") continue;
                module.GlobalType.Remove(md);
                break;
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Software/Runtime/AntiDebugHandler.cs
================================================
ï»¿using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Aura.Protection.Software.Runtime
{
    internal static class AntiDebugSafe
    {
        [DllImport("ntdll.dll", CharSet = CharSet.Auto)]
        public static extern int NtQueryInformationProcess(IntPtr test, int test2, int[] test3, int test4, ref int test5);

        private static void Initialize()
        {
            if (Debugger.IsLogging())
            { Environment.Exit(0); }
            if (Debugger.IsAttached)
            { Environment.Exit(0); }
            if (Environment.GetEnvironmentVariable("complus_profapi_profilercompatibilitysetting") != null)
            { Environment.Exit(0); }
            if (string.Compare(Environment.GetEnvironmentVariable("COR_ENABLE_PROFILING"), "1", StringComparison.Ordinal) == 0)
            { Environment.Exit(0); }

            if (Environment.OSVersion.Platform != PlatformID.Win32NT) return;
            var array = new int[6];
            var num = 0;
            var intPtr = Process.GetCurrentProcess().Handle;
            if (NtQueryInformationProcess(intPtr, 31, array, 4, ref num) == 0 && array[0] != 1)
            {
                Environment.Exit(0);
            }
            if (NtQueryInformationProcess(intPtr, 30, array, 4, ref num) == 0 && array[0] != 0)
            {
                Environment.Exit(0);
            }

            if (NtQueryInformationProcess(intPtr, 0, array, 24, ref num) != 0) return;
            intPtr = Marshal.ReadIntPtr(Marshal.ReadIntPtr((IntPtr)array[1], 12), 12);
            Marshal.WriteInt32(intPtr, 32, 0);
            var intPtr2 = Marshal.ReadIntPtr(intPtr, 0);
            var ptr = intPtr2;
            do
            {
                ptr = Marshal.ReadIntPtr(ptr, 0);
                if (Marshal.ReadInt32(ptr, 44) != 1572886 ||
                    Marshal.ReadInt32(Marshal.ReadIntPtr(ptr, 48), 0) != 7536749) continue;
                var intPtr3 = Marshal.ReadIntPtr(ptr, 8);
                var intPtr4 = Marshal.ReadIntPtr(ptr, 12);
                Marshal.WriteInt32(intPtr4, 0, (int)intPtr3);
                Marshal.WriteInt32(intPtr3, 4, (int)intPtr4);
            }
            while (!ptr.Equals(intPtr2));
        }
    }
}


================================================
File: Aura/Aura/Protection/Software/Runtime/AntiDumpHandler.cs
================================================
ï»¿using System;
using System.Runtime.InteropServices;

namespace Aura.Protection.Software.Runtime
{
    internal class AntiDumpHandler
    {
        internal enum MemoryProtection
        {
            ExecuteReadWrite = 0x40,
        }

        public static unsafe void CopyBlock(void* destination, void* source, uint byteCount)
        {
        }

        public static unsafe void InitBlock(void* startAddress, byte value, uint byteCount)
        {
        }

        [DllImport("kernel32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool VirtualProtect(
            IntPtr lpAddress,
            uint dwSize,
            [MarshalAs(UnmanagedType.U4)] MemoryProtection flNewProtect,
            [MarshalAs(UnmanagedType.U4)] out MemoryProtection lpflOldProtect);

        private static unsafe void Initialize()
        {
            var module = typeof(AntiDumpHandler).Module;
            var bas = (byte*)Marshal.GetHINSTANCE(module);
            var ptr = bas + 0x3c;
            ptr = bas + *(uint*)ptr;
            ptr += 0x6;
            var sectNum = *(ushort*)ptr;
            ptr += 14;
            var optSize = *(ushort*)ptr;
            ptr = ptr + 0x4 + optSize;
            var @new = stackalloc byte[11];
            if (module.FullyQualifiedName[0] != '<')
            {
                var mdDir = bas + *(uint*)(ptr - 16);
                if (*(uint*)(ptr - 0x78) != 0)
                {
                    var importDir = bas + *(uint*)(ptr - 0x78);
                    var oftMod = bas + *(uint*)importDir;
                    var modName = bas + *(uint*)(importDir + 12);
                    var funcName = bas + *(uint*)oftMod + 2;
                    VirtualProtect(new IntPtr(modName), 11, MemoryProtection.ExecuteReadWrite, out _);
                    *(uint*)@new = 0x6c64746e;
                    *((uint*)@new + 1) = 0x6c642e6c;
                    *((ushort*)@new + 4) = 0x006c;
                    *(@new + 10) = 0;
                    CopyBlock(modName, @new, 11);
                    VirtualProtect(new IntPtr(funcName), 11, MemoryProtection.ExecuteReadWrite, out _);
                    *(uint*)@new = 0x6f43744e;
                    *((uint*)@new + 1) = 0x6e69746e;
                    *((ushort*)@new + 4) = 0x6575;
                    *(@new + 10) = 0;
                    CopyBlock(funcName, @new, 11);
                }

                for (var i = 0; i < sectNum; i++)
                {
                    VirtualProtect(new IntPtr(ptr), 8, MemoryProtection.ExecuteReadWrite, out _);
                    InitBlock(ptr, 0, 8);
                    ptr += 0x28;
                }

                VirtualProtect(new IntPtr(mdDir), 0x48, MemoryProtection.ExecuteReadWrite, out _);
                var mdHdr = bas + *(uint*)(mdDir + 8);
                InitBlock(mdDir, 0, 16);
                VirtualProtect(new IntPtr(mdHdr), 4, MemoryProtection.ExecuteReadWrite, out _);
                *(uint*)mdHdr = 0;
                mdHdr += 12;
                mdHdr += *(uint*)mdHdr;
                mdHdr = (byte*)(((ulong)mdHdr + 7) & ~3UL);
                mdHdr += 2;
                ushort numOfStream = *mdHdr;
                mdHdr += 2;
                for (var i = 0; i < numOfStream; i++)
                {
                    VirtualProtect(new IntPtr(mdHdr), 8, MemoryProtection.ExecuteReadWrite, out _);
                    mdHdr += 4;
                    mdHdr += 4;
                    for (var ii = 0; ii < 8; ii++)
                    {
                        VirtualProtect(new IntPtr(mdHdr), 4, MemoryProtection.ExecuteReadWrite, out _);
                        *mdHdr = 0;
                        mdHdr++;
                        if (*mdHdr == 0)
                        {
                            mdHdr += 3;
                            break;
                        }
                        *mdHdr = 0;
                        mdHdr++;
                        if (*mdHdr == 0)
                        {
                            mdHdr += 2;
                            break;
                        }
                        *mdHdr = 0;
                        mdHdr++;
                        if (*mdHdr == 0)
                        {
                            mdHdr += 1;
                            break;
                        }
                        *mdHdr = 0;
                        mdHdr++;
                    }
                }
            }
            else
            {
                var mdDir = *(uint*)(ptr - 16);
                var importDir = *(uint*)(ptr - 0x78);

                var vAdrs = new uint[sectNum];
                var vSizes = new uint[sectNum];
                var rAdrs = new uint[sectNum];
                for (var i = 0; i < sectNum; i++)
                {
                    VirtualProtect(new IntPtr(ptr), 8, MemoryProtection.ExecuteReadWrite, out _);
                    Marshal.Copy(new byte[8], 0, (IntPtr)ptr, 8);
                    vAdrs[i] = *(uint*)(ptr + 12);
                    vSizes[i] = *(uint*)(ptr + 8);
                    rAdrs[i] = *(uint*)(ptr + 20);
                    ptr += 0x28;
                }

                if (importDir != 0)
                {
                    for (var i = 0; i < sectNum; i++)
                        if (vAdrs[i] <= importDir && importDir < vAdrs[i] + vSizes[i])
                        {
                            importDir = importDir - vAdrs[i] + rAdrs[i];
                            break;
                        }

                    var importDirPtr = bas + importDir;
                    var oftMod = *(uint*)importDirPtr;
                    for (var i = 0; i < sectNum; i++)
                        if (vAdrs[i] <= oftMod && oftMod < vAdrs[i] + vSizes[i])
                        {
                            oftMod = oftMod - vAdrs[i] + rAdrs[i];
                            break;
                        }

                    var oftModPtr = bas + oftMod;
                    var modName = *(uint*)(importDirPtr + 12);
                    for (var i = 0; i < sectNum; i++)
                        if (vAdrs[i] <= modName && modName < vAdrs[i] + vSizes[i])
                        {
                            modName = modName - vAdrs[i] + rAdrs[i];
                            break;
                        }

                    var funcName = *(uint*)oftModPtr + 2;
                    for (var i = 0; i < sectNum; i++)
                        if (vAdrs[i] <= funcName && funcName < vAdrs[i] + vSizes[i])
                        {
                            funcName = funcName - vAdrs[i] + rAdrs[i];
                            break;
                        }

                    VirtualProtect(new IntPtr(bas + modName), 11, MemoryProtection.ExecuteReadWrite, out _);

                    *(uint*)@new = 0x6c64746e;
                    *((uint*)@new + 1) = 0x6c642e6c;
                    *((ushort*)@new + 4) = 0x006c;
                    *(@new + 10) = 0;

                    CopyBlock(bas + modName, @new, 11);

                    VirtualProtect(new IntPtr(bas + funcName), 11, MemoryProtection.ExecuteReadWrite, out _);

                    *(uint*)@new = 0x6f43744e;
                    *((uint*)@new + 1) = 0x6e69746e;
                    *((ushort*)@new + 4) = 0x6575;
                    *(@new + 10) = 0;

                    CopyBlock(bas + funcName, @new, 11);
                }

                for (var i = 0; i < sectNum; i++)
                    if (vAdrs[i] <= mdDir && mdDir < vAdrs[i] + vSizes[i])
                    {
                        mdDir = mdDir - vAdrs[i] + rAdrs[i];
                        break;
                    }

                var mdDirPtr = bas + mdDir;
                VirtualProtect(new IntPtr(mdDirPtr), 0x48, MemoryProtection.ExecuteReadWrite, out _);
                var mdHdr = *(uint*)(mdDirPtr + 8);
                for (var i = 0; i < sectNum; i++)
                    if (vAdrs[i] <= mdHdr && mdHdr < vAdrs[i] + vSizes[i])
                    {
                        mdHdr = mdHdr - vAdrs[i] + rAdrs[i];
                        break;
                    }

                InitBlock(mdDirPtr, 0, 16);

                var mdHdrPtr = bas + mdHdr;
                VirtualProtect(new IntPtr(mdHdrPtr), 4, MemoryProtection.ExecuteReadWrite, out _);
                *(uint*)mdHdrPtr = 0;
                mdHdrPtr += 12;
                mdHdrPtr += *(uint*)mdHdrPtr;
                mdHdrPtr = (byte*)(((ulong)mdHdrPtr + 7) & ~3UL);
                mdHdrPtr += 2;
                ushort numOfStream = *mdHdrPtr;
                mdHdrPtr += 2;
                for (var i = 0; i < numOfStream; i++)
                {
                    VirtualProtect(new IntPtr(mdHdrPtr), 8, MemoryProtection.ExecuteReadWrite, out _);
                    mdHdrPtr += 4;
                    mdHdrPtr += 4;
                    for (var ii = 0; ii < 8; ii++)
                    {
                        VirtualProtect(new IntPtr(mdHdrPtr), 4, MemoryProtection.ExecuteReadWrite, out _);
                        *mdHdrPtr = 0;
                        mdHdrPtr++;
                        if (*mdHdrPtr == 0)
                        {
                            mdHdrPtr += 3;
                            break;
                        }

                        *mdHdrPtr = 0;
                        mdHdrPtr++;
                        if (*mdHdrPtr == 0)
                        {
                            mdHdrPtr += 2;
                            break;
                        }

                        *mdHdrPtr = 0;
                        mdHdrPtr++;
                        if (*mdHdrPtr == 0)
                        {
                            mdHdrPtr += 1;
                            break;
                        }

                        *mdHdrPtr = 0;
                        mdHdrPtr++;
                    }
                }
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Software/Runtime/AntiTamperHandler.cs
================================================
ï»¿using System;
using System.IO;
using System.Security.Cryptography;

namespace Aura.Protection.Software.Runtime
{
    internal class AntiTamperHandler
    {
        private static void Initializer()
        {
            var assemblyLocation = System.Reflection.Assembly.GetExecutingAssembly().Location;

            var stream = new StreamReader(assemblyLocation).BaseStream;
            var reader = new BinaryReader(stream);
            stream.Seek(-32, SeekOrigin.End);
            var realSha256 = BitConverter.ToString(reader.ReadBytes(32));
            if (string.Compare(BitConverter.ToString(SHA256.Create().ComputeHash(reader.ReadBytes(File.ReadAllBytes(assemblyLocation).Length - 32))), realSha256, StringComparison.Ordinal) != 0)
                throw new BadImageFormatException();
        }
    }
}


================================================
File: Aura/Aura/Protection/Stack-Calli Conversion/Calli.cs
================================================
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Linq;

namespace Aura.Protection.Other
{
    internal class Calli
    {
        public static void Execute(ModuleDef module)
        {
            foreach (var type in module.Types.ToArray())
            {
                foreach (var method in type.Methods.ToArray())
                {
                    if (!method.HasBody) continue;
                    if (!method.Body.HasInstructions) continue;
                    if (method.FullName.Contains("My.")) continue;
                    if (method.FullName.Contains(".My")) continue;
                    if (method.FullName.Contains("Costura")) continue;
                    if (method.IsConstructor) continue;
                    if (method.DeclaringType.IsGlobalModuleType) continue;
                    for (var i = 0; i < method.Body.Instructions.Count - 1; i++)
                    {
                        try
                        {
                            if (method.Body.Instructions[i].ToString().Contains("ISupportInitialize") || (method.Body.Instructions[i].OpCode != OpCodes.Call &&
                                method.Body.Instructions[i].OpCode != OpCodes.Callvirt &&
                                method.Body.Instructions[i].OpCode != OpCodes.Ldloc_S)) continue;

                            if (method.Body.Instructions[i].ToString().Contains("Object") || (method.Body.Instructions[i].OpCode != OpCodes.Call &&
                                method.Body.Instructions[i].OpCode != OpCodes.Callvirt &&
                                method.Body.Instructions[i].OpCode != OpCodes.Ldloc_S)) continue;

                            try
                            {
                                var membertocalli = (MemberRef)method.Body.Instructions[i].Operand;
                                method.Body.Instructions[i].OpCode = OpCodes.Calli;
                                method.Body.Instructions[i].Operand = membertocalli.MethodSig;
                                method.Body.Instructions.Insert(i, Instruction.Create(OpCodes.Ldftn, membertocalli));
                            }
                            catch (Exception)
                            {
                                // ignored
                            }
                        }
                        catch (Exception)
                        {
                            // ignored
                        }
                    }
                }
                foreach (var md in module.GlobalType.Methods)
                {
                    if (md.Name != ".ctor") continue;
                    module.GlobalType.Remove(md);
                    break;
                }
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Stack-Calli Conversion/StackUnfConfusion.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;

namespace Aura.Protection.Other
{
    internal class StackUnfConfusion
    {
        public static void Execute(ModuleDef mod)
        {
            foreach (var type in mod.Types)
            {
                foreach (var dnlibDef in type.Methods)
                {
                    var def = dnlibDef;
                    if (def != null && !def.HasBody)
                    {
                        break;
                    }

                    var body = def.Body;
                    var target = body.Instructions[0];
                    var item = Instruction.Create(OpCodes.Br_S, target);
                    var instruction3 = Instruction.Create(OpCodes.Pop);
                    var random = new Random();
                    Instruction instruction4;
                    switch (random.Next(0, 5))
                    {
                        case 0:
                            instruction4 = Instruction.Create(OpCodes.Ldnull);
                            break;

                        case 1:
                            instruction4 = Instruction.Create(OpCodes.Ldc_I4_0);
                            break;

                        case 2:
                            instruction4 = Instruction.Create(OpCodes.Ldstr, "Isolator");
                            break;

                        case 3:
                            instruction4 = Instruction.Create(OpCodes.Ldc_I8, (uint)random.Next());
                            break;

                        default:
                            instruction4 = Instruction.Create(OpCodes.Ldc_I8, (long)random.Next());
                            break;
                    }

                    body.Instructions.Insert(0, instruction4);
                    body.Instructions.Insert(1, instruction3);
                    body.Instructions.Insert(2, item);
                    foreach (var handler in body.ExceptionHandlers)
                    {
                        if (handler.TryStart == target)
                        {
                            handler.TryStart = item;
                        }
                        else if (handler.HandlerStart == target)
                        {
                            handler.HandlerStart = item;
                        }
                        else if (handler.FilterStart == target)
                        {
                            handler.FilterStart = item;
                        }
                    }
                }
            }
        }
    }
}


================================================
File: Aura/Aura/Protection/Strings/EncryptionHelper.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

namespace Aura.Protection.String
{
    internal class EncryptionHelper
    {

        private const string PasswordHash = "p7K95451qB88sZ7J";
        private const string SaltKey = "2GM23j301t60Z96T";
        private const string VIKey = "IzTdhG6S8uwg141S";

        private static List<string> _list = new List<string>();
        public static void Generate()
        {
            using (var manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Aura.zero"))
            {
                using (var streamReader = new StreamReader(new MemoryStream(UnHush(Read(manifestResourceStream)))))
                {
                    _list = streamReader.ReadToEnd().Split(new[]
                    {
                        Environment.NewLine
                    }, StringSplitOptions.None).ToList();
                }
            }
        }

        public static string Search(int key)
        {
            return _list.ElementAt(key);
        }

        private static byte[] Read(Stream input)
        {
            using (var memoryStream = new MemoryStream())
            {
                input.CopyTo(memoryStream);
                return memoryStream.ToArray();
            }
        }

        public static byte[] UnHush(byte[] text)
        {
            var key = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
            var xor = new byte[text.Length];
            for (var i = 0; i < text.Length; i++)
            {
                xor[i] = (byte)(text[i] ^ key[i % key.Length]);
            }
            return xor;
        }

        public static string Decrypt(string encryptedText)
        {
            if (Assembly.GetExecutingAssembly() != Assembly.GetCallingAssembly()) return "Aura.png";
            var cipherTextBytes = Convert.FromBase64String(encryptedText);
            var keyBytes = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
            var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.PKCS7 };

            var decryptor = symmetricKey.CreateDecryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));
            var memoryStream = new MemoryStream(cipherTextBytes);
            var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
            var plainTextBytes = new byte[cipherTextBytes.Length];

            var decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
            memoryStream.Close();
            cryptoStream.Close();
            return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount).TrimEnd("\0".ToCharArray());
        }
    }
}


================================================
File: Aura/Aura/Protection/Strings/StringEncPhase.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using Aura.Services;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Aura.Protection.String
{
    public static class StringEncPhase
    {
        private const string PasswordHash = "p7K95451qB88sZ7J";
        private const string SaltKey = "2GM23j301t60Z96T";
        private const string VIKey = "IzTdhG6S8uwg141S";

        public static void InjectClass(ModuleDef module)
        {
            var typeModule = ModuleDefMD.Load(typeof(EncryptionHelper).Module);
            var typeDef = typeModule.ResolveTypeDef(MDToken.ToRID(typeof(EncryptionHelper).MetadataToken));
            var members = InjectHelper.Inject(typeDef, module.GlobalType, module);
            MainWindow.Init = (MethodDef)members.Single(method => method.Name == "Decrypt");
            var cctor = module.GlobalType.FindStaticConstructor();
            MainWindow.Init2 = (MethodDef)members.Single(method => method.Name == "Search");
            var init = (MethodDef)members.Single(method => method.Name == "Generate");
            cctor.Body.Instructions.Insert(cctor.Body.Instructions.Count - 1, Instruction.Create(OpCodes.Call, init));
            foreach (var md in module.GlobalType.Methods)
            {
                if (md.Name == ".ctor")
                {
                    module.GlobalType.Remove(md);
                    break;
                }
            }
        }

        public static List<string> Str = new List<string>();

        public static void Execute(ModuleDef module)
        {
            InjectClass(module);
            foreach (var type in module.GetTypes())
            {
                if (type.IsGlobalModuleType) continue;
                foreach (var method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    var instr = method.Body.Instructions;
                    for (var i = 0; i < instr.Count; i++)
                    {
                        if (instr[i].OpCode == OpCodes.Ldstr)
                        {
                            var originalStr = instr[i].Operand as string;
                            var encodedStr = Encrypt(originalStr);
                            instr[i].Operand = encodedStr;
                            Str.Add(encodedStr);
                            instr.Insert(i + 1, Instruction.Create(OpCodes.Ldc_I4, Str.LastIndexOf(encodedStr)));
                            instr.Insert(i + 2, Instruction.Create(OpCodes.Call, MainWindow.Init2));
                            instr.Insert(i + 3, Instruction.Create(OpCodes.Call, MainWindow.Init));
                            instr.RemoveAt(i);
                        }
                    }
                    method.Body.SimplifyBranches();
                }
            }
            File.WriteAllLines($"{Path.GetTempPath()}List.txt", Str);
            var bytes = File.ReadAllBytes($"{Path.GetTempPath()}List.txt");
            module.Resources.Add(new EmbeddedResource("Aura.zero", Hush(bytes), ManifestResourceAttributes.Public));
            File.Delete($"{Path.GetTempPath()}List.txt");
        }

        public static byte[] Hush(byte[] text)
        {
            var key = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
            var xor = new byte[text.Length];
            for (var i = 0; i < text.Length; i++)
            {
                xor[i] = (byte)(text[i] ^ key[i % key.Length]);
            }
            return xor;
        }

        public static string Encrypt(string plainText)
        {
            var plainTextBytes = Encoding.UTF8.GetBytes(plainText);
            var keyBytes = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
            var symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC, Padding = PaddingMode.PKCS7 };
            var encryptor = symmetricKey.CreateEncryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));
            byte[] cipherTextBytes;
            using (var memoryStream = new MemoryStream())
            {
                using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
                {
                    cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
                    cryptoStream.FlushFinalBlock();
                    cipherTextBytes = memoryStream.ToArray();
                    cryptoStream.Close();
                }
                memoryStream.Close();
            }
            return Convert.ToBase64String(cipherTextBytes);
        }
    }
}


================================================
File: Aura/Aura/Services/InjectHelper.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Services
{
    public static class InjectHelper
    {
        private static TypeDefUser Clone(TypeDef origin)
        {
            var ret = new TypeDefUser(origin.Namespace, origin.Name)
            {
                Attributes = origin.Attributes
            };

            if (origin.ClassLayout != null)
                ret.ClassLayout = new ClassLayoutUser(origin.ClassLayout.PackingSize, origin.ClassSize);

            foreach (var genericParam in origin.GenericParameters)
                ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

            return ret;
        }

        private static MethodDefUser Clone(MethodDef origin)
        {
            var ret = new MethodDefUser(origin.Name, null, origin.ImplAttributes, origin.Attributes);

            foreach (var genericParam in origin.GenericParameters)
                ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

            return ret;
        }

        private static FieldDefUser Clone(FieldDef origin)
        {
            var ret = new FieldDefUser(origin.Name, null, origin.Attributes);
            return ret;
        }

        private static TypeDef PopulateContext(TypeDef typeDef, InjectContext ctx)
        {
            TypeDef ret;
            if (!ctx.map.TryGetValue(typeDef, out var existing))
            {
                ret = Clone(typeDef);
                ctx.map[typeDef] = ret;
            }
            else
                ret = (TypeDef)existing;

            foreach (var nestedType in typeDef.NestedTypes)
                ret.NestedTypes.Add(PopulateContext(nestedType, ctx));

            foreach (var method in typeDef.Methods)
                ret.Methods.Add((MethodDef)(ctx.map[method] = Clone(method)));

            foreach (var field in typeDef.Fields)
                ret.Fields.Add((FieldDef)(ctx.map[field] = Clone(field)));

            return ret;
        }

        private static void CopyTypeDef(TypeDef typeDef, InjectContext ctx)
        {
            var newTypeDef = (TypeDef)ctx.map[typeDef];

            newTypeDef.BaseType = ctx.Importer.Import(typeDef.BaseType);

            foreach (var iface in typeDef.Interfaces)
                newTypeDef.Interfaces.Add(new InterfaceImplUser(ctx.Importer.Import(iface.Interface)));
        }

        private static void CopyMethodDef(MethodDef methodDef, InjectContext ctx)
        {
            var newMethodDef = (MethodDef)ctx.map[methodDef];

            newMethodDef.Signature = ctx.Importer.Import(methodDef.Signature);
            newMethodDef.Parameters.UpdateParameterTypes();

            if (methodDef.ImplMap != null)
                newMethodDef.ImplMap = new ImplMapUser(new ModuleRefUser(ctx.TargetModule, methodDef.ImplMap.Module.Name), methodDef.ImplMap.Name, methodDef.ImplMap.Attributes);

            foreach (var ca in methodDef.CustomAttributes)
                newMethodDef.CustomAttributes.Add(new CustomAttribute((ICustomAttributeType)ctx.Importer.Import(ca.Constructor)));

            if (!methodDef.HasBody)
                return;
            newMethodDef.Body = new CilBody(methodDef.Body.InitLocals, new List<Instruction>(),
                new List<ExceptionHandler>(), new List<Local>())
            { MaxStack = methodDef.Body.MaxStack };

            var bodyMap = new Dictionary<object, object>();

            foreach (var local in methodDef.Body.Variables)
            {
                var newLocal = new Local(ctx.Importer.Import(local.Type));
                newMethodDef.Body.Variables.Add(newLocal);
                newLocal.Name = local.Name;
                newLocal.Attributes = local.Attributes;

                bodyMap[local] = newLocal;
            }

            foreach (var instr in methodDef.Body.Instructions)
            {
                var newInstr = new Instruction(instr.OpCode, instr.Operand)
                {
                    SequencePoint = instr.SequencePoint
                };

                switch (newInstr.Operand)
                {
                    case IType type:
                        newInstr.Operand = ctx.Importer.Import(type);
                        break;

                    case IMethod method:
                        newInstr.Operand = ctx.Importer.Import(method);
                        break;

                    case IField field:
                        newInstr.Operand = ctx.Importer.Import(field);
                        break;
                }

                newMethodDef.Body.Instructions.Add(newInstr);
                bodyMap[instr] = newInstr;
            }

            foreach (var instr in newMethodDef.Body.Instructions)
            {
                if (instr.Operand != null && bodyMap.ContainsKey(instr.Operand))
                    instr.Operand = bodyMap[instr.Operand];
                else if (instr.Operand is Instruction[] v)
                    instr.Operand = v.Select(target => (Instruction)bodyMap[target]).ToArray();
            }

            foreach (var eh in methodDef.Body.ExceptionHandlers)
                newMethodDef.Body.ExceptionHandlers.Add(new ExceptionHandler(eh.HandlerType)
                {
                    CatchType = eh.CatchType == null ? null : ctx.Importer.Import(eh.CatchType),
                    TryStart = (Instruction)bodyMap[eh.TryStart],
                    TryEnd = (Instruction)bodyMap[eh.TryEnd],
                    HandlerStart = (Instruction)bodyMap[eh.HandlerStart],
                    HandlerEnd = (Instruction)bodyMap[eh.HandlerEnd],
                    FilterStart = eh.FilterStart == null ? null : (Instruction)bodyMap[eh.FilterStart]
                });

            newMethodDef.Body.SimplifyMacros(newMethodDef.Parameters);
        }

        private static void CopyFieldDef(FieldDef fieldDef, InjectContext ctx)
        {
            var newFieldDef = (FieldDef)ctx.map[fieldDef];

            newFieldDef.Signature = ctx.Importer.Import(fieldDef.Signature);
        }

        private static void Copy(TypeDef typeDef, InjectContext ctx, bool copySelf)
        {
            if (copySelf)
                CopyTypeDef(typeDef, ctx);

            foreach (var nestedType in typeDef.NestedTypes)
                Copy(nestedType, ctx, true);

            foreach (var method in typeDef.Methods)
                CopyMethodDef(method, ctx);

            foreach (var field in typeDef.Fields)
                CopyFieldDef(field, ctx);
        }

        public static TypeDef Inject(TypeDef typeDef, ModuleDef target)
        {
            var ctx = new InjectContext(typeDef.Module, target);
            PopulateContext(typeDef, ctx);
            Copy(typeDef, ctx, true);
            return (TypeDef)ctx.map[typeDef];
        }

        public static MethodDef Inject(MethodDef methodDef, ModuleDef target)
        {
            var ctx = new InjectContext(methodDef.Module, target);
            ctx.map[methodDef] = Clone(methodDef);
            CopyMethodDef(methodDef, ctx);
            return (MethodDef)ctx.map[methodDef];
        }

        public static IEnumerable<IDnlibDef> Inject(TypeDef typeDef, TypeDef newType, ModuleDef target)
        {
            var ctx = new InjectContext(typeDef.Module, target);
            ctx.map[typeDef] = newType;
            PopulateContext(typeDef, ctx);
            Copy(typeDef, ctx, false);
            return ctx.map.Values.Except(new[] { newType });
        }

        private class InjectContext : ImportMapper
        {
            public readonly Dictionary<IDnlibDef, IDnlibDef> map = new Dictionary<IDnlibDef, IDnlibDef>();

            public readonly ModuleDef OriginModule;

            public readonly ModuleDef TargetModule;

            public readonly Importer importer;

            public InjectContext(ModuleDef module, ModuleDef target)
            {
                OriginModule = module;
                TargetModule = target;
                importer = new Importer(target, ImporterOptions.TryToUseTypeDefs, new GenericParamContext(), this);
            }

            public Importer Importer => importer;

            public override ITypeDefOrRef Map(ITypeDefOrRef typeDefOrRef)
            {
                return typeDefOrRef is TypeDef typeDef && map.ContainsKey(typeDef) ? (TypeDef)map[typeDef] : null;
            }

            public override IMethod Map(MethodDef methodDef)
            {
                return map.ContainsKey(methodDef) ? (MethodDef)map[methodDef] : null;
            }

            public override IField Map(FieldDef fieldDef)
            {
                return map.ContainsKey(fieldDef) ? (FieldDef)map[fieldDef] : null;
            }
        }
    }
}


================================================
File: Aura/Aura/obj/Aura.csproj.nuget.dgspec.json
================================================
{
  "format": 1,
  "restore": {
    "C:\\Users\\evers\\Desktop\\Aura\\Aura\\Aura.csproj": {}
  },
  "projects": {
    "C:\\Users\\evers\\Desktop\\Aura\\Aura\\Aura.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "C:\\Users\\evers\\Desktop\\Aura\\Aura\\Aura.csproj",
        "projectName": "Aura",
        "projectPath": "C:\\Users\\evers\\Desktop\\Aura\\Aura\\Aura.csproj",
        "packagesPath": "C:\\Users\\evers\\.nuget\\packages\\",
        "outputPath": "C:\\Users\\evers\\Desktop\\Aura\\Aura\\obj\\",
        "projectStyle": "PackageReference",
        "skipContentFileWrite": true,
        "configFilePaths": [
          "C:\\Users\\evers\\AppData\\Roaming\\NuGet\\NuGet.Config",
          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
        ],
        "originalTargetFrameworks": [
          "net472"
        ],
        "sources": {
          "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net472": {
            "projectReferences": {}
          }
        }
      },
      "frameworks": {
        "net472": {
          "dependencies": {
            "ControlzEx": {
              "target": "Package",
              "version": "[4.4.0, )"
            },
            "MahApps.Metro": {
              "target": "Package",
              "version": "[2.4.0, )"
            },
            "MahApps.Metro.IconPacks.Modern": {
              "target": "Package",
              "version": "[4.8.0, )"
            },
            "Microsoft.Xaml.Behaviors.Wpf": {
              "target": "Package",
              "version": "[1.1.19, )"
            },
            "dnlib": {
              "target": "Package",
              "version": "[3.3.2, )"
            }
          }
        }
      },
      "runtimes": {
        "win": {
          "#import": []
        },
        "win-x64": {
          "#import": []
        },
        "win-x86": {
          "#import": []
        }
      }
    }
  }
}


================================================
File: Aura/Aura/obj/Aura.csproj.nuget.g.props
================================================
ï»¿<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">$(UserProfile)\.nuget\packages\</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">C:\Users\evers\.nuget\packages\</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">5.7.0</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <SourceRoot Include="$([MSBuild]::EnsureTrailingSlash($(NuGetPackageFolders)))" />
  </ItemGroup>
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <PkgMicrosoft_Xaml_Behaviors_Wpf Condition=" '$(PkgMicrosoft_Xaml_Behaviors_Wpf)' == '' ">C:\Users\evers\.nuget\packages\microsoft.xaml.behaviors.wpf\1.1.19</PkgMicrosoft_Xaml_Behaviors_Wpf>
    <PkgMahApps_Metro Condition=" '$(PkgMahApps_Metro)' == '' ">C:\Users\evers\.nuget\packages\mahapps.metro\2.4.0</PkgMahApps_Metro>
  </PropertyGroup>
</Project>


================================================
File: Aura/Aura/obj/Aura.csproj.nuget.g.targets
================================================
ï»¿<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
</Project>


================================================
File: Aura/Aura/obj/Debug/App.baml
================================================
[Non-text file]


================================================
File: Aura/Aura/obj/Debug/App.g.cs
================================================
ï»¿#pragma checksum "..\..\App.xaml" "{8829d00f-11b8-4213-878b-770e8597ac16}" "8606E0C9C234FE983FDD71CBAA92DDF88258D37FE8E88A148FC580D8AE76196C"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace Aura {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            
            #line 4 "..\..\App.xaml"
            this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
            System.Uri resourceLocater = new System.Uri("/Aura;component/app.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\App.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public static void Main() {
            Aura.App app = new Aura.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}




================================================
File: Aura/Aura/obj/Debug/App.g.i.cs
================================================
ï»¿#pragma checksum "..\..\App.xaml" "{8829d00f-11b8-4213-878b-770e8597ac16}" "8606E0C9C234FE983FDD71CBAA92DDF88258D37FE8E88A148FC580D8AE76196C"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Shell;


namespace Aura {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            
            #line 4 "..\..\App.xaml"
            this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
            System.Uri resourceLocater = new System.Uri("/Aura;component/app.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\App.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
        public static void Main() {
            Aura.App app = new Aura.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}




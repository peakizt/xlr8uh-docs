Directory structure:
└── mrfearless-apiinfo-plugin-x86/
    ├── README.md
    ├── APIInfo-readme.txt
    ├── APIInfo.Asm
    ├── APIInfo.Def
    ├── APIInfo.Inc
    ├── APIInfo.dlg
    ├── APIInfo.rap
    ├── APIInfo.rc
    ├── APIInfo.xml
    ├── api-definitions/
    │   ├── advapi32.api
    │   ├── comctl32.api
    │   ├── comdlg32.api
    │   ├── gdi32.api
    │   ├── gdiplus.api
    │   ├── kernel32.api
    │   ├── ntdll.api
    │   ├── psapi.api
    │   ├── shell32.api
    │   └── user32.api
    ├── images/
    ├── release/
    │   ├── APIInfo-readme.txt
    │   └── APIInfo.dp32
    └── res/
        ├── APIInfoDlg.rc
        ├── APIInfoRes.rc
        └── APIInfoVer.rc

================================================
File: README.md
================================================
# APIInfo Plugin (x86) - A Plugin For x64dbg

![](https://github.com/mrfearless/APIInfo-Plugin-x86/blob/master/images/APIInfo.png) [Current version: 1.0.0.3 - Last updated: 26/06/2016](https://github.com/mrfearless/APIInfo-Plugin-x86/releases/latest) There is no x64 version of this plugin currently.

## Overview

A plugin to populate the comments with windows api calls

**Note:** APIInfo plugin has been superseded by ThunderCls's xAnalyzer plugin.

xAnalyzer supports both x86 and x64 versions of x64dbg.

For more information, please visit: https://github.com/ThunderCls/xAnalyzer


## Features

* Add windows api function definition information to the comments

## How to install

* If x32dbg (x64dbg 32bit) is currently running, stop and exit.
* Copy the `APIInfo.dp32` to your `x64dbg\x32\plugins` folder.
* Extract `APIInfo-API-Definitions.zip` which contains the `.api` definition files to the `x64dbg\x32\plugins` folder.
* Start x32dbg

## How to use

* Set the required detail level in the APIInfo options dialog (from the plugins menu, APIInfo Options)
* Select Generate API Information from the plugins menu (or from the right click context menu in the CPU View)
* Wait till the information has been generated - hopefully you should see some API definitions show up in the comments now

## Notes

The API defintion files are created with a utility called ApiCreator (currently unreleased) which takes a selected windows sdk header file and parses it, outputting the function definitions into a file which uses a standard .ini format

Each function name is the stored as a section name, the key values for parameters, parameter count and full definition (key '@') are stored under this section name for easy retrieval with standard win32 api calls: [GetPrivateProfileString](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724353(v=vs.85).aspx) & [GetPrivateProfileInt](https://msdn.microsoft.com/en-us/library/windows/desktop/ms724345(v=vs.85).aspx)
Some of the definition files have to be manually fixed up afterwards, so there may be errors or omissions. If you require a specific api file generated, feel free to contact me.

The comments where APIInfo thinks there is a parameter may be incorrect in some cases.

There isnt an x64 version of the plugin at this time due to the differences in calling conventions for 64bit, and would require considerable more time than i can spare to look into ways of maybe generating this info.

## Information

* Written by [fearless](https://github.com/mrfearless)  - [www.LetTheLight.in](http://www.LetTheLight.in)
* Created with the [x64dbg Plugin SDK For x86 Assembler](https://github.com/mrfearless/x64dbg-Plugin-SDK-For-x86-Assembler)
* A RadASM project (.rap) is used to manage and compile the plugin. The RadASM IDE can be downloaded [here](http://www.softpedia.com/get/Programming/File-Editors/RadASM.shtml)
* Some plugins make use of the MASM32 SDK found [here](http://www.masm32.com/masmdl.htm)

## x64dbg
* [x64dbg website](http://x64dbg.com)
* [x64dbg github](https://github.com/x64dbg/x64dbg)
* [x64dbg gitter](https://gitter.im/x64dbg/x64dbg)


================================================
File: APIInfo-readme.txt
================================================
;=====================================================================================
;
; APIInfo-readme.txt
;
; v1.0.0.3 - Last updated: 26/06/2016 
;
;-------------------------------------------------------------------------------------

NOTE
----

APIInfo plugin has been superseded by ThunderCls's xAnalyzer plugin.

xAnalyzer supports both x86 and x64 versions of x64dbg.

For more information, please visit: https://github.com/ThunderCls/xAnalyzer




About
-----

APIInfo Plugin (x86) For x64dbg (32bit plugin)
by fearless - www.LetTheLight.in

Created with the x64dbg Plugin SDK For x86 Assembler
https://github.com/mrfearless/x64dbg-Plugin-SDK-For-x86-Assembler


Overview
--------

A plugin to populate the comments with windows api calls


Features
--------

- Add windows api function definition information to the comments


Installation
------------

Copy APIInfo.dp32 to x32\plugins folder of x64dbg
Extract APIInfo-API-Definitions.zip which contains the api definition files to the same 
plugins folder


How to use
----------

 - Set the required detail level in the APIInfo options dialog (from the plugins menu, 
   APIInfo Options)
 - Select Generate API Information from the plugins menu (or from the right click context
   menu in the CPU View)
 - Wait till the information has been generated - hopefully you should see some API
   definitions show up in the comments now

 
Notes
-----

The API defintion files are created with a utility called ApiCreator (currently unreleased)
which takes a selected windows sdk header file and parses it, outputting the function
definitions into a file which uses a standard .ini format

Each function name is the stored as a section name, the key values for parameters, 
parameter count and full definition (key '@') are stored under this section name for easy 
retrieval with standard win32 api calls: GetPrivateProfileString & GetPrivateProfileInt
Some of the definition files have to be manually fixed up afterwards, so there may be 
errors or omissions. If you require a specific api file generated, feel free to contact me.

The comments where APIInfo thinks there is a parameter may be incorrect in some cases.

There isnt an x64 version of the plugin at this time due to the differences in calling 
conventions for 64bit, and would require considerable more time than i can spare to look
into ways of maybe generating this info.



- 26/06/2016 updated plugin to use ico, added definitions with plugin
- 01/03/2016 Updated x64dbg SDK for masm to version 1.0.0.2 and recompiled plugin.
- Added function APIInfoLoadMenuIcon to load png resource image as raw bytes 
- Added menu icon for plugin (uses _plugin_menuseticon)
- Added menu entry icons for options and gen api (uses _plugin_menuentryseticon)



================================================
File: APIInfo.Asm
================================================
;=====================================================================================
; x64dbg plugin SDK for Masm - fearless 2016 - www.LetTheLight.in
;
; APIInfo.asm
; 
; v1.0.0.2 - Last updated: 01/03/2016 
;
; - Added function APIInfoLoadMenuIcon to load png resource image as raw bytes 
; - Added menu icon for plugin (uses _plugin_menuseticon)
; - Added menu entry icons for options and gen api (uses _plugin_menuentryseticon) 
;
;-------------------------------------------------------------------------------------

.686
.MMX
.XMM
.model flat,stdcall
option casemap:none

;DEBUG32 EQU 1

IFDEF DEBUG32
    PRESERVEXMMREGS equ 1
    includelib M:\Masm32\lib\Debug32.lib
    DBG32LIB equ 1
    DEBUGEXE textequ <'M:\Masm32\DbgWin.exe'>
    include M:\Masm32\include\debug32.inc
ENDIF

;**************************************************************************
; MOD Macro
;**************************************************************************
_mod MACRO val1:REQ, val2:REQ
    push ecx
    mov  eax,val1
    mov  ecx,val2
    xor  edx,edx
    div  ecx  
    pop ecx
    exitm <edx>
endm


Include x64dbgpluginsdk.inc               ; Main x64dbg Plugin SDK for your program, and prototypes for the main exports 

Include APIInfo.inc                       ; plugin's include file

pluginit	        PROTO C :DWORD        ; Required prototype and export for x64dbg plugin SDK
plugstop            PROTO C               ; Required prototype and export for x64dbg plugin SDK
plugsetup           PROTO C :DWORD        ; Required prototype and export for x64dbg plugin SDK
;=====================================================================================


.CONST
PLUGIN_VERSION      EQU 1

.DATA
PLUGIN_NAME         DB "APIInfo",0

.DATA?
;-------------------------------------------------------------------------------------
; GLOBAL Plugin SDK variables
;-------------------------------------------------------------------------------------
PUBLIC              pluginHandle
PUBLIC              hwndDlg
PUBLIC              hMenu
PUBLIC              hMenuDisasm
PUBLIC              hMenuDump
PUBLIC              hMenuStack

pluginHandle        DD ?
hwndDlg             DD ?
hMenu               DD ?
hMenuDisasm         DD ?
hMenuDump           DD ?
hMenuStack          DD ?
;-------------------------------------------------------------------------------------


.CODE

;=====================================================================================
; Main entry function for a DLL file  - required.
;-------------------------------------------------------------------------------------
DllEntry PROC hInst:HINSTANCE, reason:DWORD, reserved:DWORD
    .IF reason == DLL_PROCESS_ATTACH
        mov eax, hInst
        mov hInstance, eax
    .ENDIF
    mov eax,TRUE
    ret
DllEntry Endp


;=====================================================================================
; pluginit - Called by debugger when plugin.dp32 is loaded - needs to be EXPORTED
; 
; Arguments: initStruct - a pointer to a PLUG_INITSTRUCT structure
;
; Notes:     you must fill in the pluginVersion, sdkVersion and pluginName members. 
;            The pluginHandle is obtained from the same structure - it may be needed in
;            other function calls.
;
;            you can call your own setup routine from within this function to setup 
;            menus and commands, and pass the initStruct parameter to this function.
;
;-------------------------------------------------------------------------------------
pluginit PROC C PUBLIC USES EBX initStruct:DWORD
    mov ebx, initStruct

    ; Fill in required information of initStruct, which is a pointer to a PLUG_INITSTRUCT structure
    mov eax, PLUGIN_VERSION
    mov [ebx].PLUG_INITSTRUCT.pluginVersion, eax
    mov eax, PLUG_SDKVERSION
    mov [ebx].PLUG_INITSTRUCT.sdkVersion, eax
    Invoke lstrcpy, Addr [ebx].PLUG_INITSTRUCT.pluginName, Addr PLUGIN_NAME
    
    mov ebx, initStruct
    mov eax, [ebx].PLUG_INITSTRUCT.pluginHandle
    mov pluginHandle, eax
    
    ; Do any other initialization here
    ; Construct plugin's .ini file from module filename
    Invoke GetModuleFileName, hInstance, Addr APIInfoIni, SIZEOF APIInfoIni
    Invoke lstrlen, Addr APIInfoIni
    lea ebx, APIInfoIni
    add ebx, eax
    sub ebx, 4 ; move back past 'dp32' extention
    mov byte ptr [ebx], 0 ; null so we can use lstrcat
    Invoke lstrcat, ebx, Addr szIni ; add 'ini' to end of string instead

    Invoke GetCurrentDirectory, MAX_PATH, Addr szCurrentDirectory
    Invoke lstrcat, Addr szCurrentDirectory, Addr szBackslash
    
    Invoke lstrcpy, Addr szFindApiFiles, Addr szCurrentDirectory
    Invoke lstrcat, Addr szFindApiFiles, Addr szStarApi

    Invoke LoadIcon, hInstance, ICO_APIINFO
    mov hIcoAPIInfo, eax

	mov eax, TRUE
	ret
pluginit endp


;=====================================================================================
; plugstop - Called by debugger when the plugin.dp32 is unloaded - needs to be EXPORTED
;
; Arguments: none
; 
; Notes:     perform cleanup operations here, clearing menus and other housekeeping
;
;-------------------------------------------------------------------------------------
plugstop PROC C PUBLIC 
    
    ; remove any menus, unregister any callbacks etc
    Invoke _plugin_menuclear, hMenu
    Invoke GuiAddLogMessage, Addr szPluginUnloaded
    
    mov eax, TRUE
    ret
plugstop endp


;=====================================================================================
; plugsetup - Called by debugger to initialize your plugins setup - needs to be EXPORTED
;
; Arguments: setupStruct - a pointer to a PLUG_SETUPSTRUCT structure
; 
; Notes:     setupStruct contains useful handles for use within x64_dbg, mainly Qt 
;            menu handles (which are not supported with win32 api) and the main window
;            handle with this information you can add your own menus and menu items 
;            to an existing menu, or one of the predefined supported right click 
;            context menus: hMenuDisam, hMenuDump & hMenuStack
;            
;            plugsetup is called after pluginit. 
;-------------------------------------------------------------------------------------
plugsetup PROC C PUBLIC USES EBX setupStruct:DWORD
    LOCAL hIconData:ICONDATA
    
    mov ebx, setupStruct

    ; Extract handles from setupStruct which is a pointer to a PLUG_SETUPSTRUCT structure  
    mov eax, [ebx].PLUG_SETUPSTRUCT.hwndDlg
    mov hwndDlg, eax
    mov eax, [ebx].PLUG_SETUPSTRUCT.hMenu
    mov hMenu, eax
    ;PrintText 'APIInfo'
    ;PrintDec hMenu
    mov eax, [ebx].PLUG_SETUPSTRUCT.hMenuDisasm
    mov hMenuDisasm, eax
    mov eax, [ebx].PLUG_SETUPSTRUCT.hMenuDump
    mov hMenuDump, eax
    mov eax, [ebx].PLUG_SETUPSTRUCT.hMenuStack
    mov hMenuStack, eax
    
    ; Do any setup here: add menus, menu items, callback and commands etc
    
    Invoke _plugin_menuaddentry, hMenu, MENU_APIINFOGENAPI1, Addr szMenuAPIInfo
    Invoke _plugin_menuaddentry, hMenu, MENU_APIINFOOPTIONS1, Addr szMenuAPIOptions
    Invoke _plugin_menuaddentry, hMenuDisasm, MENU_APIINFOGENAPI2, Addr szMenuAPIInfo
    Invoke _plugin_menuaddentry, hMenuDisasm, MENU_APIINFOOPTIONS2, Addr szMenuAPIOptions
    
    
    Invoke APIInfoLoadMenuIcon, IMG_APIINFO, Addr hIconData
    .IF eax == TRUE
        Invoke _plugin_menuseticon, hMenu, Addr hIconData
        Invoke _plugin_menuseticon, hMenuDisasm, Addr hIconData
    .ENDIF    

    Invoke APIInfoLoadMenuIcon, IMG_APIINFOOPTIONS, Addr hIconData
    .IF eax == TRUE
        Invoke _plugin_menuentryseticon, pluginHandle, MENU_APIINFOOPTIONS1, Addr hIconData
        Invoke _plugin_menuentryseticon, pluginHandle, MENU_APIINFOOPTIONS2, Addr hIconData
    .ENDIF
    
    Invoke APIInfoLoadMenuIcon, IMG_APIINFOGENAPI, Addr hIconData
    .IF eax == TRUE
        Invoke _plugin_menuentryseticon, pluginHandle, MENU_APIINFOGENAPI1, Addr hIconData
        Invoke _plugin_menuentryseticon, pluginHandle, MENU_APIINFOGENAPI2, Addr hIconData
    .ENDIF    

    
    Invoke GuiAddLogMessage, Addr szAPIInfoInfo

    Invoke GuiGetWindowHandle
    mov hwndDlg, eax    
    
    Invoke APIInfoLoadIniSettings
    
    mov eax, TRUE
    ret
plugsetup endp


;=====================================================================================
; CBMENUENTRY - Called by debugger when a menu item is clicked - needs to be EXPORTED
;
; Arguments: cbType
;            cbInfo - a pointer to a PLUG_CB_MENUENTRY structure. The hEntry contains 
;            the resource id of menu item identifiers
;  
; Notes:     hEntry can be used to determine if the user has clicked on your plugins
;            menu item(s) and to do something in response to it.
;            Needs to be PROC C type procedure call to be compatible with debugger
;-------------------------------------------------------------------------------------
CBMENUENTRY PROC C PUBLIC USES EBX cbType:DWORD, cbInfo:DWORD
    mov ebx, cbInfo
    mov eax, [ebx].PLUG_CB_MENUENTRY.hEntry
    
    .IF eax == MENU_APIINFOGENAPI1 || eax == MENU_APIINFOGENAPI2
        Invoke DbgIsDebugging
        .IF eax == FALSE
            Invoke GuiAddStatusBarMessage, Addr szDebuggingRequired
            Invoke GuiAddLogMessage, Addr szDebuggingRequired
        .ELSE
            Invoke GenAPIInfo
        .ENDIF
    .ELSEIF eax == MENU_APIINFOOPTIONS1 || eax == MENU_APIINFOOPTIONS2
        Invoke DialogBoxParam, hInstance, IDD_APIInfoOptionsDlg, hwndDlg, OFFSET APIInfoOptionsDlgProc, NULL
    .ENDIF
    mov eax, TRUE
    ret

CBMENUENTRY endp


;=====================================================================================
; Plugin Dialog Procedure
;-------------------------------------------------------------------------------------
APIInfoOptionsDlgProc PROC USES EBX ECX hWin:HWND,iMsg:DWORD,wParam:WPARAM, lParam:LPARAM
    LOCAL nItem:DWORD
    
    mov eax, iMsg
    .IF eax == WM_INITDIALOG
        ; Any initialization here
        
        Invoke SendMessage, hWin, WM_SETICON, ICON_SMALL, hIcoAPIInfo
        
        mov InitDlg, 0
        mov gOptionsChanged, FALSE
        
        Invoke GetDlgItem, hWin, IDC_LV_APIFILES
        mov hLVApiFiles, eax
        Invoke InitLVApiFiles, hLVApiFiles
        Invoke LoadLVApiFiles, hLVApiFiles
        Invoke APIInfoLoadIniSettings
        
        .IF gIniDisplayOptions == 0
            Invoke SendDlgItemMessage, hWin, IDC_RbDisplayNothing, BM_SETCHECK, BST_CHECKED, 0
        .ELSEIF gIniDisplayOptions == 1
            Invoke SendDlgItemMessage, hWin, IDC_RbDisplayModuleOnly, BM_SETCHECK, BST_CHECKED, 0
        .ELSEIF gIniDisplayOptions == 2
            Invoke SendDlgItemMessage, hWin, IDC_RbDisplayFunctionOnly, BM_SETCHECK, BST_CHECKED, 0
        .ELSEIF gIniDisplayOptions == 3
            Invoke SendDlgItemMessage, hWin, IDC_RbDisplayModuleAndFunction, BM_SETCHECK, BST_CHECKED, 0
        .ELSEIF gIniDisplayOptions == 4
            Invoke SendDlgItemMessage, hWin, IDC_RbDisplayFunctionDef, BM_SETCHECK, BST_CHECKED, 0
        .ELSEIF gIniDisplayOptions == 5
            Invoke SendDlgItemMessage, hWin, IDC_RbDisplayFunctionDefParams, BM_SETCHECK, BST_CHECKED, 0
        .ENDIF
        
        .IF gIniAutoLoadAtEntry == 0
            Invoke SendDlgItemMessage, hWin, IDC_ChkAutoLoad, BM_SETCHECK, BST_UNCHECKED, 0
        .ELSE
            Invoke SendDlgItemMessage, hWin, IDC_ChkAutoLoad, BM_SETCHECK, BST_CHECKED, 0
        .ENDIF
        
        .IF gIniPreserveExistingComments == 0
            Invoke SendDlgItemMessage, hWin, IDC_ChkPreserveExistingComments, BM_SETCHECK, BST_UNCHECKED, 0
        .ELSE
            Invoke SendDlgItemMessage, hWin, IDC_ChkPreserveExistingComments, BM_SETCHECK, BST_CHECKED, 0
        .ENDIF
        
        mov InitDlg, 1
        
        
	.ELSEIF eax == WM_CLOSE
        Invoke EndDialog, hWin, NULL
        
	.ELSEIF eax == WM_COMMAND
        mov eax, wParam
        and eax, 0FFFFh
        .IF eax == IDC_BtnAPIInfoOptionsOk
            .IF gOptionsChanged == TRUE
    
                Invoke SendDlgItemMessage, hWin, IDC_ChkAutoLoad, BM_GETCHECK, 0, 0
                .IF eax == BST_CHECKED
                    mov gNewIniAutoLoadAtEntry, 1
                .ELSE
                    mov gNewIniAutoLoadAtEntry, 0
                .ENDIF    
                mov eax, gNewIniAutoLoadAtEntry
                mov gIniAutoLoadAtEntry, eax
                
                Invoke SendDlgItemMessage, hWin, IDC_ChkPreserveExistingComments, BM_GETCHECK, 0, 0
                .IF eax == BST_CHECKED
                    mov gNewIniPreserveExistingComments, 1  
                .ELSE
                    mov gNewIniPreserveExistingComments, 0
                .ENDIF
                mov eax, gNewIniPreserveExistingComments
                mov gIniPreserveExistingComments, eax
                
                Invoke SendDlgItemMessage, hWin, IDC_RbDisplayNothing, BM_GETCHECK, 0, 0
                .IF eax == BST_CHECKED
                    mov gNewIniDisplayOptions, 0
                .ENDIF
                Invoke SendDlgItemMessage, hWin, IDC_RbDisplayModuleOnly, BM_GETCHECK, 0, 0
                .IF eax == BST_CHECKED
                    mov gNewIniDisplayOptions, 1
                .ENDIF
                Invoke SendDlgItemMessage, hWin, IDC_RbDisplayFunctionOnly, BM_GETCHECK, 0, 0
                .IF eax == BST_CHECKED
                    mov gNewIniDisplayOptions, 2
                .ENDIF
                Invoke SendDlgItemMessage, hWin, IDC_RbDisplayModuleAndFunction, BM_GETCHECK, 0, 0
                .IF eax == BST_CHECKED
                    mov gNewIniDisplayOptions, 3
                .ENDIF
                Invoke SendDlgItemMessage, hWin, IDC_RbDisplayFunctionDef, BM_GETCHECK, 0, 0
                .IF eax == BST_CHECKED
                    mov gNewIniDisplayOptions, 4
                .ENDIF
                Invoke SendDlgItemMessage, hWin, IDC_RbDisplayFunctionDefParams, BM_GETCHECK, 0, 0
                .IF eax == BST_CHECKED
                    mov gNewIniDisplayOptions, 5
                .ENDIF
                mov eax, gNewIniDisplayOptions
                mov gIniDisplayOptions, eax
                                
                ;PrintDec gNewIniDisplayOptions
                ;PrintDec gNewIniAutoLoadAtEntry
                ;PrintDec gIniDisplayOptions
                ;PrintDec gIniAutoLoadAtEntry
                ;PrintDec gIniPreserveExistingComments
                
                Invoke APIInfoSaveIniSettings
            .ENDIF
            Invoke SendMessage, hWin, WM_CLOSE, NULL, NULL
        
        .ELSEIF eax == IDC_BtnAPIInfoOptionsCancel
            Invoke SendMessage, hWin, WM_CLOSE, NULL, NULL
       
        .ELSEIF eax == IDC_RbDisplayNothing
            mov gOptionsChanged, TRUE
            ;mov gNewIniDisplayOptions, 0

        .ELSEIF eax == IDC_RbDisplayModuleOnly
            mov gOptionsChanged, TRUE
            ;mov gNewIniDisplayOptions, 1

        .ELSEIF eax == IDC_RbDisplayFunctionOnly
            mov gOptionsChanged, TRUE
            ;mov gNewIniDisplayOptions, 2

        .ELSEIF eax == IDC_RbDisplayModuleAndFunction
            mov gOptionsChanged, TRUE
            ;mov gNewIniDisplayOptions, 3

        .ELSEIF eax == IDC_RbDisplayFunctionDef
            mov gOptionsChanged, TRUE
            ;mov gNewIniDisplayOptions, 4

        .ELSEIF eax == IDC_RbDisplayFunctionDefParams
            mov gOptionsChanged, TRUE
            ;mov gNewIniDisplayOptions, 5

        .ELSEIF eax == IDC_ChkAutoLoad
            mov gOptionsChanged, TRUE
            ;Invoke SendDlgItemMessage, hWin, IDC_ChkAutoLoad, BM_GETCHECK, 0, 0
            ;.IF eax == BST_CHECKED
            ;    mov gNewIniAutoLoadAtEntry, 1
            ;.ELSE
            ;    mov gNewIniAutoLoadAtEntry, 0
            ;.ENDIF
            
        .ELSEIF eax == IDC_ChkPreserveExistingComments
            mov gOptionsChanged, TRUE
            ;Invoke SendDlgItemMessage, hWin, IDC_ChkPreserveExistingComments, BM_GETCHECK, 0, 0
            ;.IF eax == BST_CHECKED
            ;    mov gNewIniPreserveExistingComments, 1
            ;.ELSE
            ;    mov gNewIniPreserveExistingComments, 0
            ;.ENDIF

        .ENDIF
        
	.ELSEIF eax==WM_NOTIFY
		mov ecx, lParam
		mov eax, ( [ecx].NMHDR.code)
		mov ebx, ( [ecx].NMHDR.hwndFrom)
        .IF ebx == hLVApiFiles
    		.IF eax == NM_DBLCLK        
                mov gOptionsChanged, TRUE
        
            .ELSEIF eax == NM_CLICK
                mov gOptionsChanged, TRUE

            .ELSEIF eax == NM_CUSTOMDRAW
                mov ecx, lParam
                mov eax, (NMLVCUSTOMDRAW ptr[ecx]).nmcd.dwDrawStage
                .IF eax == CDDS_PREPAINT
                    mov eax, CDRF_NOTIFYITEMDRAW
                    invoke SetWindowLong,hWin,DWL_MSGRESULT,eax
                    mov eax, TRUE
                    ret
                     
                .ELSEIF eax == CDDS_ITEMPREPAINT
                    mov eax, CDRF_NOTIFYSUBITEMDRAW
                    invoke SetWindowLong,hWin,DWL_MSGRESULT,eax
                    mov eax, TRUE
                    ret
                    
                .ELSEIF eax == CDDS_ITEMPREPAINT or CDDS_SUBITEM
                    mov ecx, lParam
                    ;mov eax, (NMLVCUSTOMDRAW ptr[ecx]).iSubItem
                    ;mov nSubItem, eax
                    mov eax, (NMLVCUSTOMDRAW ptr[ecx]).nmcd.dwItemSpec      ; item
                    mov nItem, eax
                    
                	.IF  _mod(nItem,2) == 1                                 ; Calc mod of item to see if the background should be applied
                		mov (NMLVCUSTOMDRAW ptr[ecx]).clrTextBk, 00FFF3F2h        ;00F9F9F9h; 00F9F9F9h ; Light Grey | 00FFF3F2h Light Blue | 00FFF0E6h; 00FFE4D0h ; 00A6F7F0h ;Background text = light yellow
                		mov (NMLVCUSTOMDRAW ptr[ecx]).clrText,00000000h     ; text color = red
                	.ELSE
                		mov (NMLVCUSTOMDRAW ptr[ecx]).clrTextBk,0FFFFFFh    ;Background text = white
                		mov (NMLVCUSTOMDRAW ptr[ecx]).clrText,00h           ; text color = black
                		
                	.ENDIF    	            
                    mov eax, CDRF_NOTIFYSUBITEMDRAW ;CDRF_DODEFAULT
                    invoke SetWindowLong,hWin,DWL_MSGRESULT,eax
                    mov eax, TRUE	            
                    ret
                    
                .ELSE
                    mov eax, CDRF_DODEFAULT
                    invoke SetWindowLong,hWin,DWL_MSGRESULT,eax
                    mov eax, TRUE
                    ret
                .ENDIF


                
		    .ELSEIF eax == LVN_ITEMCHANGED ; maybe create a ListViewCompareStates
                .IF InitDlg == 1
                    mov ecx, lParam
                    mov eax, (NM_LISTVIEW Ptr [ecx]).uChanged
                    .IF eax == LVIF_STATE
                        mov eax, (NM_LISTVIEW Ptr [ecx]).uNewState
                        mov ebx, (NM_LISTVIEW Ptr [ecx]).uOldState
                        .IF (eax == 8192d && ebx == 4096d) || (eax == 4096d && ebx == 8192d) 
                            ;PrintText 'Changes'
                            mov gOptionsChanged, TRUE
                        .ENDIF
                    .ENDIF
                .ENDIF  
            .ENDIF
        .ENDIF
            
    .ELSE
        mov eax, FALSE
        ret
	.ENDIF
    mov eax, TRUE
    ret
APIInfoOptionsDlgProc endp


;=====================================================================================
; Init Listivew
;-------------------------------------------------------------------------------------
InitLVApiFiles PROC hListview:DWORD
    LOCAL LVC:LV_COLUMN
    
    mov eax, LVS_EX_CHECKBOXES + LVS_EX_FULLROWSELECT + LVS_EX_GRIDLINES + LVS_EX_DOUBLEBUFFER
    Invoke SendMessage, hListview, LVM_SETEXTENDEDLISTVIEWSTYLE, eax, eax
    
	mov LVC.imask, LVCF_FMT or LVCF_TEXT ;or LVCF_WIDTH  ;or LVCFMT_COL_HAS_IMAGES
    mov LVC.fmt, LVCFMT_LEFT ; defaults to LVCFMT_LEFT
    lea ebx, szLVApiFilesColumnText	
	mov LVC.pszText, ebx
	;mov LVC.lx, 150d
	Invoke SendMessage, hListview, LVM_INSERTCOLUMN, 0, Addr LVC
    Invoke SendMessage, hListview, LVM_SETCOLUMNWIDTH, 0, LVSCW_AUTOSIZE_USEHEADER
    ret

InitLVApiFiles endp


;=====================================================================================
; Load listview with api files
;-------------------------------------------------------------------------------------
LoadLVApiFiles PROC USES EBX hListview:DWORD
	LOCAL LVItem:LV_ITEM
	LOCAL nItemIndex:DWORD
	LOCAL wfd:WIN32_FIND_DATA
	LOCAL hFind:DWORD
    LOCAL dwCheckedState:DWORD
    
	mov nItemIndex, 0
	
    mov LVItem.imask, LVIF_TEXT + LVIF_STATE
	;mov LVItem.iItem, eax	
	mov LVItem.iSubItem, 0
	mov LVItem.stateMask, LVIS_STATEIMAGEMASK

    ;PrintString szFindApiFiles
    Invoke FindFirstFile, Addr szFindApiFiles, Addr wfd
    .IF eax == INVALID_HANDLE_VALUE
        ;PrintText 'FindFirstFile Fail'
        mov eax, FALSE
        ret
    .ENDIF
    mov hFind, eax
    ;PrintDec hFind
    mov eax, TRUE
    .WHILE eax == TRUE
        Invoke FindNextFile, hFind, Addr wfd
        .IF eax != 0
            mov eax, nItemIndex
	        mov LVItem.iItem, eax	        
            lea ebx, wfd.cFileName
            ;mov DbgVar, ebx
            ;PrintStringByAddr DbgVar
            lea ebx, wfd.cFileName
            mov LVItem.pszText, ebx

            Invoke GetPrivateProfileInt, Addr szAPIFilesToExclude, ebx, 1, Addr APIInfoIni
            mov dwCheckedState, eax



            invoke SendMessage, hListview, LVM_INSERTITEM, 0, Addr LVItem
            .IF eax == -1
                ;PrintText 'Failed to add'
            .endif
            
        	xor eax, eax
        	.IF dwCheckedState == 1
        	    mov eax, 2      ; set check
        	.ELSE               ; 0 
        	    mov eax, 1      ; set uncheck
        	.ENDIF        
        	shl eax,12	
        	mov LVItem.state, eax            
            
	        mov LVItem.state, eax
	        Invoke SendMessage, hListview, LVM_SETITEMSTATE, nItemIndex, addr LVItem            
            
            inc nItemIndex
            ;PrintDec nItemIndex
            mov eax, TRUE
        .ELSE
            mov eax, FALSE
        .ENDIF
    .ENDW

    ret

LoadLVApiFiles endp


;=====================================================================================
; GenAPIInfo Procedure
;-------------------------------------------------------------------------------------
GenAPIInfo PROC USES EBX ECX
    LOCAL CurrentAddress:DWORD
    LOCAL CallDestination:DWORD
    LOCAL JmpDestination:DWORD
    LOCAL bii:BASIC_INSTRUCTION_INFO ; basic 
    LOCAL cbii:BASIC_INSTRUCTION_INFO ; call destination
    LOCAL dwEntry:DWORD
    LOCAL dwExit:DWORD    
    LOCAL iscounter:DWORD
    LOCAL ParamCount:DWORD
    LOCAL CurrentParam:DWORD
    LOCAL CurrentISIndex:DWORD
    LOCAL ParamAddress:DWORD
    
    Invoke DbgIsDebugging
    .IF eax == FALSE
        Invoke GuiAddLogMessage, Addr szDebuggingRequired
        ret
    .ENDIF

    .IF gIniDisplayOptions == 0
        Invoke GuiAddStatusBarMessage, Addr szSetToDisplayNothing
        mov eax, FALSE
        ret
    .ENDIF

    Invoke GuiAddStatusBarMessage, Addr szStartAddAPIInfo

    Invoke DbgGetEntryExitPoints, Addr dwEntry, Addr dwExit
    
    Invoke DbgClearAutoCommentRange, dwEntry, dwExit
    ;Invoke DbgClearCommentRange, dwEntry, dwExit
    Invoke GuiUpdateDisassemblyView
    mov eax, dwEntry
    mov CurrentAddress, eax
    
    mov ISCOUNT, 0
    mov iscounter, 0
    
    
    .WHILE eax < dwExit ;ExitPoint
        Invoke DbgDisasmFastAt, CurrentAddress, Addr bii
        movzx eax, byte ptr bii.call_
        movzx ebx, byte ptr bii.branch
        .IF eax == 1 && ebx == 1 ; we have call statement
            Invoke GuiGetDisassembly, CurrentAddress, Addr szDisasmText
            Invoke Strip_x64dbg_calls, Addr szDisasmText, Addr szAPIFunction ; Addr szDisasmText
            .IF eax == TRUE
                
                .IF gIniDisplayOptions == 2 ; just function name
                    ;Invoke DbgSetAutoCommentAt, CurrentAddress, Addr szAPIFunction
                    Invoke SetAutoCommentIfCommentIsEmpty, CurrentAddress, Addr szAPIFunction
                .ELSE
                    mov eax, bii.address
                    mov CallDestination, eax
                    Invoke DbgDisasmFastAt, CallDestination, Addr cbii
                    
                    movzx eax, byte ptr cbii.branch
                    .IF eax == 1 ; jmp
                        Invoke DbgGetBranchDestination, CallDestination
                        mov JmpDestination, eax
                        .IF gIniDisplayOptions == 1
                            _DbgFunctions ModNameFromAddr, JmpDestination, ADDR szAPIModuleName, TRUE ; show .dll
                        .ELSE
                            _DbgFunctions ModNameFromAddr, JmpDestination, ADDR szAPIModuleName, FALSE; for other options we just need the module name without the .dll ext
                        .ENDIF
                        
                        ;PrintString szAPIModuleName
                        ;PrintString szAPIFunction
                        .IF gIniDisplayOptions == 1 ; just module name
                            ;Invoke DbgSetAutoCommentAt, CurrentAddress, Addr szAPIModuleName
                            Invoke SetAutoCommentIfCommentIsEmpty, CurrentAddress, Addr szAPIModuleName
                        .ELSEIF gIniDisplayOptions == 3 ; module:function
                            Invoke lstrcpy, Addr szAPIComment, Addr szAPIModuleName
                            invoke lstrcat, Addr szAPIComment, Addr szColon
                            invoke lstrcat, Addr szAPIComment, Addr szAPIFunction
                            ;Invoke DbgSetAutoCommentAt, CurrentAddress, Addr szAPIComment
                            Invoke SetAutoCommentIfCommentIsEmpty, CurrentAddress, Addr szAPIComment
                        .ELSE
                            Invoke SearchApiFileForDefinition, Addr szAPIModuleName, Addr szAPIFunction, Addr szAPIDefinition
                            .IF eax == FALSE
                                Invoke lstrcpy, Addr szAPIComment, Addr szAPIModuleName
                                invoke lstrcat, Addr szAPIComment, Addr szColon
                                invoke lstrcat, Addr szAPIComment, Addr szAPIFunction
                                ;Invoke DbgSetAutoCommentAt, CurrentAddress, Addr szAPIComment
                                Invoke SetAutoCommentIfCommentIsEmpty, CurrentAddress, Addr szAPIComment
                            .ELSE
                                ;Invoke DbgSetAutoCommentAt, CurrentAddress, Addr szAPIDefinition
                                Invoke SetAutoCommentIfCommentIsEmpty, CurrentAddress, Addr szAPIDefinition
                            .ENDIF
                            
                            .IF gIniDisplayOptions == 5 ; do parameters as well as definition
                                Invoke GetFunctionParamCount, Addr szAPIModuleName, Addr szAPIFunction
                                mov ParamCount, eax
                                .IF eax != -1 && eax != 0 ; make sure we are only checked for functions that are succesfully found in api file and have 1 or more parameters
                                    .IF eax <= ISCOUNT ; make sure we have enough in our stack to check for parameters
                                        ;PrintString szAPIFunction
                                        ;PrintDec ParamCount
                                        ;PrintDec CurrentAddress
                                        ;PrintDec ISCOUNT
                                        
                                        mov eax, ISCOUNT
                                        mov CurrentISIndex, eax
                                        mov CurrentParam, 1
                                        .WHILE eax != 0
                                            ;PrintDec CurrentParam
                                            mov ecx, CurrentISIndex
                                            dec ecx ; for 0 based index
                                            lea ebx, IS
                                            mov eax, [ebx+ecx*4] ; eax contains address of last param to get
                                            mov ParamAddress, eax
                                            
                                            Invoke GetFunctionParam, Addr szAPIModuleName, Addr szAPIFunction, CurrentParam, Addr szAPIFunctionParameter
                                            .IF eax == TRUE
                                                Invoke SetAutoCommentIfCommentIsEmpty, ParamAddress, Addr szAPIFunctionParameter
                                            .ENDIF
                                            inc CurrentParam
                                            dec CurrentISIndex
                                            mov eax, CurrentISIndex
                                        .ENDW 
                                        
                                    .ENDIF
                                .ENDIF
                                mov ISCOUNT, 0 ; reset instruction stack
                            .ENDIF
                            
                            
                        .ENDIF
                    .ELSE ; internal function call
                        Invoke lstrcpy, Addr szAPIComment, Addr szDashSpace
                        Invoke DbgGetLabelAt, CurrentAddress, SEG_DEFAULT, Addr szAPIFunction
                        Invoke lstrcat, Addr szAPIComment, Addr szAPIFunction
                        ;Invoke DbgSetAutoCommentAt, CurrentAddress, Addr szAPIComment
                        Invoke SetAutoCommentIfCommentIsEmpty, CurrentAddress, Addr szAPIComment
                        mov ISCOUNT, 0 ; reset instruction stack
                        ;PrintText '-----------------------------------'
                        ;PrintString szAPIFunction
                        ;Invoke InternalTest, CurrentAddress, Addr szAPIFunction
                    .ENDIF
                .ENDIF
            .ENDIF
        .ELSE
            .IF gIniDisplayOptions == 5 
                movzx eax, byte ptr bii.branch
                .IF eax != 1 ; jmp instruction
                
                    lea ebx, bii.instruction
                    mov eax, [ebx]
                    mov ecx, [ebx+4]
                    mov ebx, [ebx+1]
                     
                    .IF eax == "hsup" && ebx == " hsu" && ecx != "pbe " ; save to our instruction stack - only push instruction
                        mov eax, ISCOUNT
                        .IF eax < INSTRUCTIONSTACK_MAXSIZE
                            lea ebx, IS
                            mov eax, CurrentAddress
                            mov ecx, ISCOUNT
                            mov [ebx+ecx*4] , eax
                            inc ISCOUNT
                            ;PrintDec CurrentAddress
                            ;lea ebx, bii.instruction
                            ;mov DbgVar, ebx
                            ;PrintStringByAddr DbgVar
                        .ELSE
                            IFDEF DEBUG32
                            PrintText 'Stack too full!'
                            PrintDec ISCOUNT
                            PrintDec CurrentAddress
                            ENDIF
                        .ENDIF
                    .ELSEIF eax == " ter" ;|| eax == " ter"
                        mov ISCOUNT, 0 ; reset stack
                    .ENDIF
                .ENDIF
            .ENDIF
            ;Invoke SetAutoCommentIfCommentIsEmpty, CurrentAddress, Addr szSpace ;DbgClearAutoCommentRange, CurrentAddress, CurrentAddress ; SetAutoCommentIfCommentIsEmpty, CurrentAddress, Addr szNull
        .ENDIF
        mov eax, bii.size_ 
        add CurrentAddress, eax        
        mov eax, CurrentAddress
    .ENDW
    
    Invoke GuiAddStatusBarMessage, Addr szFinishAddAPIInfo
    Invoke GuiUpdateDisassemblyView
    
    ret

GenAPIInfo endp


;=====================================================================================
; Set Auto Comment only if a comment isnt already set 
; 
;-------------------------------------------------------------------------------------
SetAutoCommentIfCommentIsEmpty PROC CommentAddress:DWORD, CommentString:DWORD
    ;PrintDec gIniPreserveExistingComments
    .IF gIniPreserveExistingComments == 1
        Invoke RtlZeroMemory, Addr szComment, SIZEOF szComment
        Invoke DbgGetCommentAt, CommentAddress, Addr szComment
        .IF eax == TRUE
            Invoke lstrlen, Addr szComment
            .IF eax != 0
                mov eax, FALSE
                ret
            .ENDIF
        .ENDIF
    .ENDIF
    ;Invoke DbgSetAutoCommentAt, CommentAddress, CommentString
    Invoke DbgSetCommentAt, CommentAddress, CommentString
    mov eax, TRUE
    ret

SetAutoCommentIfCommentIsEmpty endp


;-------------------------------------------------------------------------------------
; TEST FUNCTION - NOT IN USE
;-------------------------------------------------------------------------------------
InternalTest PROC USES EDI functionAddress:DWORD, functionName:DWORD
    LOCAL entry:DWORD
    LOCAL base:DWORD
    LOCAL modname[MAX_MODULE_SIZE]:BYTE
    LOCAL hProcess:DWORD
    LOCAL isf:IMAGEHLP_STACK_FRAME
    LOCAL qfuncaddr[2]:DWORD
    
    ;PrintText 'InternalTest'

    Invoke GetContextData, UE_CIP
    mov entry, eax
   
    Invoke DbgGetModuleAt, entry, Addr modname
    Invoke DbgModBaseFromName, Addr modname
    mov base, eax

    
    Invoke TitanGetProcessInformation 
    mov eax, [eax].PROCESS_INFORMATION.hProcess
    mov hProcess, eax     

    ;lea edi, dword ptr isf.InstructionOffset
    mov eax, functionAddress
    add dword ptr isf.InstructionOffset, eax
    adc dword ptr isf.InstructionOffset+4, 0

    ;mov eax, functionAddress
    ;mov dword ptr isf.InstructionOffset, eax ; InstructionOffset = functionAddress
    
    Invoke SymSetContext, hProcess, Addr isf, NULL

     
    Invoke SymEnumSymbols, hProcess, base, 0, functionName, Offset InternalTestCallback, NULL
    ;Invoke SymEnumTypesByName, hProcess, base, 0, Addr modname, Offset InternalTestCallback, NULL
    ;Invoke SymEnumSymbolsForAddr, hProcess, functionAddress, 0, Offset InternalTestCallback, NULL
    ;.IF eax == FALSE
    ;    Invoke GetLastError
    ;    PrintDec eax
    ;.endif
    ret

InternalTest endp


;-------------------------------------------------------------------------------------
; TEST FUNCTION - NOT IN USE
;-------------------------------------------------------------------------------------
InternalTestCallback PROC USES EBX EDX pSymInfo:DWORD, SymbolSize:ULONG, UserContext:PVOID
    LOCAL nNameLen:DWORD
    LOCAL nMaxNameLen:DWORD
    LOCAL nFlags:DWORD
    LOCAL nValue:DWORD
    LOCAL nTag:DWORD
    LOCAL nAddress:DWORD
    ;PrintText 'InternalTestCallback'

    mov ebx, pSymInfo
    ;lea eax, [ebx].SYMBOL_INFO.Name_
    mov eax, [ebx].SYMBOL_INFO.NameLen
    mov nNameLen, eax
    mov eax, [ebx].SYMBOL_INFO.MaxNameLen
    mov nMaxNameLen, eax
    mov eax, [ebx].SYMBOL_INFO.Flags
    mov nFlags, eax
    mov eax, [ebx].SYMBOL_INFO.Tag
    mov nTag, eax    
    mov eax, dword ptr [ebx].SYMBOL_INFO.Address
    mov nAddress, eax
    ;mov edx, dword ptr [ebx+4].SYMBOL_INFO.Address
    
    ;PrintDec eax
    ;PrintDec edx
    
    ;PrintDec nNameLen
    ;PrintDec nMaxNameLen
    ;PrintDec nFlags
    ;PrintDec nTag
    
    mov ebx, pSymInfo
    lea eax, [ebx].SYMBOL_INFO.Name_
    Invoke lstrcpyn, Addr szSymbolName, eax, nMaxNameLen
    IFDEF DEBUG32
    PrintString szSymbolName
    PrintDec nAddress
    ENDIF
    ;add ebx, 88d
    ;DbgDump ebx, 10
    ;mov eax, DbgVar
    ;PrintStringByAddr DbgVar
    ;DbgDump [ebx].SYMBOL_INFO.Name_, [ebx].SYMBOL_INFO.NameLen
    
    ;DbgDump ebx, 90d
    ;PrintDec [ebx].SYMBOL_INFO.NameLen
    ;PrintDec [ebx].SYMBOL_INFO.TypeIndex
    ;PrintDec [ebx].SYMBOL_INFO.MaxNameLen
    ;mov eax, [ebx].SYMBOL_INFO.Name_
    ;PrintDec eax
    ;mov DbgVar, eax
    ;PrintStringByAddr DbgVar
    ;mov eax, [ebx].SYMBOL_INFO.Name_
    ;mov eax, [eax]
    ;mov DbgVar, eax
    ;PrintStringByAddr DbgVar
    
    ret
InternalTestCallback ENDP


;=====================================================================================
; Search the .api file (.ini) - based on the module name, for the section that
; describes the api function, and return the definition value
; eg. Module = kernel32, api filename will be 'kernel32.api'
;-------------------------------------------------------------------------------------
SearchApiFileForDefinition PROC lpszApiModule:DWORD, lpszApiFunction:DWORD, lpszApiDefinition:DWORD
    .IF lpszApiModule == NULL && lpszApiFunction == NULL
        mov ebx, lpszApiDefinition
        mov byte ptr [ebx], 0    
        mov eax, FALSE
        ret
    .ENDIF
    
    Invoke lstrcpy, Addr szApiFile, Addr szCurrentDirectory
    Invoke lstrcat, Addr szApiFile, lpszApiModule
    Invoke lstrcat, Addr szApiFile, Addr szApi
    
    ;PrintString szApiFile
    ;PrintString szAPIFunction
    
    Invoke GetPrivateProfileString, lpszApiFunction, Addr szAt, Addr szColon, lpszApiDefinition, MAX_COMMENT_SIZE, Addr szApiFile
    ;PrintDec eax
    .IF eax == 0 || eax == 1 ; just got nothing or the colon and nothing else
        mov ebx, lpszApiDefinition
        mov byte ptr [ebx], 0
        mov eax, FALSE
    .ELSE
        ;PrintString szAPIDefinition
        mov eax, TRUE
    .ENDIF
    ret

SearchApiFileForDefinition endp


;=====================================================================================
; Returns parameters for function in .api file, or -1 if not found
;-------------------------------------------------------------------------------------
GetFunctionParamCount PROC lpszApiModule:DWORD, lpszApiFunction:DWORD
    .IF lpszApiModule == NULL && lpszApiFunction == NULL
        mov eax, -1
        ret
    .ENDIF
    
    Invoke lstrcpy, Addr szApiFile, Addr szCurrentDirectory
    Invoke lstrcat, Addr szApiFile, lpszApiModule
    Invoke lstrcat, Addr szApiFile, Addr szApi
    
    Invoke GetPrivateProfileInt, lpszApiFunction, Addr szIniParamCount, 0, Addr szApiFile

    ret

GetFunctionParamCount endp


;=====================================================================================
; Returns parameter type and name for a specified parameter of a function in a api file 
;-------------------------------------------------------------------------------------
GetFunctionParam PROC lpszApiModule:DWORD, lpszApiFunction:DWORD, dwParamNo:DWORD, lpszApiFunctionParameter:DWORD
    .IF lpszApiModule == NULL && lpszApiFunction == NULL
        mov ebx, lpszApiFunctionParameter
        mov byte ptr [ebx], 0    
        mov eax, FALSE
        ret
    .ENDIF
    
    Invoke lstrcpy, Addr szApiFile, Addr szCurrentDirectory
    Invoke lstrcat, Addr szApiFile, lpszApiModule
    Invoke lstrcat, Addr szApiFile, Addr szApi
    
    mov eax, dwParamNo
    .IF eax == 1
        lea ebx, szOne
    
    .ELSEIF eax == 2
        lea ebx, szTwo
    
    .ELSEIF eax == 3
        lea ebx, szThree
    
    .ELSEIF eax == 4
        lea ebx, szFour
    
    .ELSEIF eax == 5
        lea ebx, szFive
    
    .ELSEIF eax == 6
        lea ebx, szSix
    
    .ELSEIF eax == 7
        lea ebx, szSeven
    
    .ELSEIF eax == 8
        lea ebx, szEight
    
    .ELSEIF eax == 9
        lea ebx, szNine
    
    .ELSEIF eax == 10
        lea ebx, szTen
    
    .ELSEIF eax == 11
        lea ebx, szEleven
    
    .ELSEIF eax == 12
        lea ebx, szTwelve
    
    .ELSEIF eax == 13
        lea ebx, szThirteen
    
    .ELSEIF eax == 14
        lea ebx, szFourteen
    
    .ELSEIF eax == 15
        lea ebx, szFifthteen
    
    .ELSEIF eax == 16
        lea ebx, szSixteen
    
    .ELSEIF eax == 17
        lea ebx, szSeventeen
    
    .ELSEIF eax == 18
        lea ebx, szEighteen
    
    .ELSEIF eax == 19
        lea ebx, szNineteen
    
    .ELSEIF eax == 20
        lea ebx, szTwenty
    
    .ELSEIF eax == 21
        lea ebx, szTwentyOne
    
    .ELSEIF eax == 22
        lea ebx, szTwentyTwo
    
    .ELSEIF eax == 23
        lea ebx, szTwentyThree
    
    .ELSEIF eax == 24
        lea ebx, szTwentyFour
    
    .ELSE ; something > 24 params - gone wrong somewhere then
        mov ebx, lpszApiFunctionParameter
        mov byte ptr [ebx], 0    
        mov eax, FALSE
        ret
    .ENDIF
    
    Invoke GetPrivateProfileString, lpszApiFunction, ebx, Addr szColon, lpszApiFunctionParameter, MAX_COMMENT_SIZE, Addr szApiFile
    .IF eax == 0 || eax == 1 ; just got nothing or the colon and nothing else
        mov ebx, lpszApiFunctionParameter
        mov byte ptr [ebx], 0
        mov eax, FALSE
    .ELSE
        ;PrintString szAPIDefinition
        mov eax, TRUE
    .ENDIF
    ret
    
    ret
GetFunctionParam ENDP


;=====================================================================================
; Strips out the brackets, underscores, full stops and @ symbols from calls: call <winbif._GetModuleHandleA@4> and returns just the api call: GetModuleHandle
; Returns true if succesful and lpszAPIFunction will contain the stripped api function name, otherwise false and lpszAPIFunction will be a null string
;-------------------------------------------------------------------------------------
Strip_x64dbg_calls PROC USES EBX EDI ESI lpszCallText:DWORD, lpszAPIFunction:DWORD

    mov esi, lpszCallText
    mov edi, lpszAPIFunction
    
    movzx eax, byte ptr [esi]
    .WHILE al != '.' && al != '&' ; 64bit have & in the api calls, so to check for that as well
        .IF al == 0h
            mov edi, lpszAPIFunction
            mov byte ptr [edi], 0h ; null out string
            mov eax, FALSE
            ret
        .ENDIF
        inc esi
        movzx eax, byte ptr [esi]
    .ENDW

    inc esi ; jump over the . and the first _ if its there
    movzx eax, byte ptr [esi]
    .IF al == '_'
        inc esi
    .ENDIF

    movzx eax, byte ptr [esi]
    .WHILE al != '@' && al != '>'
        .IF al == 0h
            mov edi, lpszAPIFunction
            mov byte ptr [edi], 0h ; null out string
            mov eax, FALSE
            ret
        .ENDIF
        mov byte ptr [edi], al
        inc edi
        inc esi
        movzx eax, byte ptr [esi]
    .ENDW
    mov byte ptr [edi], 0h ; null out string
    
    ; check if 2nd last byte was lowercase, if so if the last byte is 'A' or 'W' we strip that off - ansi/unicode part
;    dec edi
;    dec edi
;    movzx eax, byte ptr [edi]
;    .IF al >= 'a' && al <= 'z'
;        inc edi
;        movzx eax, byte ptr [edi]
;        .IF al == 'A' || al == 'W'
;            mov byte ptr [edi], 0h ; null out string
;        .ENDIF
;    .ENDIF 
    mov eax, TRUE
    ret

Strip_x64dbg_calls endp


;=====================================================================================
; Gets entry point and exit point
;-------------------------------------------------------------------------------------
DbgGetEntryExitPoints PROC USES EBX lpdwEntry:DWORD, lpdwExit:DWORD
    LOCAL entry:DWORD
    LOCAL base:DWORD
    LOCAL modname[MAX_MODULE_SIZE]:BYTE
    LOCAL modbasename[MAX_MODULE_SIZE]:BYTE
    LOCAL dwModSize:DWORD
    LOCAL hProcess:DWORD
    LOCAL hModule:DWORD
    LOCAL modinfo:MODULEINFO
    LOCAL ExitPoint:DWORD
    LOCAL baseaddress:DWORD
    
    Invoke GetContextData, UE_CIP
    mov entry, eax
   
    Invoke DbgGetModuleAt, entry, Addr modname
    Invoke DbgModBaseFromName, Addr modname
    mov base, eax

    Invoke TitanGetProcessInformation 
    mov eax, [eax].PROCESS_INFORMATION.hProcess
    mov hProcess, eax    
    Invoke GetModuleBaseNameA, hProcess, base, Addr modbasename, MAX_MODULE_SIZE
    Invoke GetModuleHandle, Addr modbasename
    mov hModule, eax
    
    Invoke GetModuleInformation, hProcess, hModule, Addr modinfo, SIZEOF MODULEINFO
    Invoke DbgMemFindBaseAddr, modinfo.EntryPoint , Addr dwModSize
    mov baseaddress, eax
    
    mov eax, dwModSize
    mov ebx, baseaddress
    add eax, ebx
    sub eax, 2d
    mov ExitPoint, eax
    
    mov ebx, lpdwEntry
    mov eax, modinfo.EntryPoint
    mov [ebx], eax
    
    mov ebx, lpdwExit
    mov eax, ExitPoint
    mov [ebx], eax
    
    xor eax, eax
    ret

DbgGetEntryExitPoints endp


;=====================================================================================
; Loads setting from ini file for options dialog
;-------------------------------------------------------------------------------------
APIInfoLoadIniSettings PROC USES EBX
    
    Invoke GetPrivateProfileInt, Addr APIInfo, Addr szIniDisplayOptions, 4, Addr APIInfoIni
    mov gIniDisplayOptions, eax
    
    Invoke GetPrivateProfileInt, Addr APIInfo, Addr szIniAutoLoadAtEntry, 0, Addr APIInfoIni
    mov gIniAutoLoadAtEntry, eax
    
    Invoke GetPrivateProfileInt, Addr APIInfo, Addr szIniPreserveExistingComments, 1, Addr APIInfoIni
    mov gIniPreserveExistingComments, eax
    ret

APIInfoLoadIniSettings endp


;=====================================================================================
; Saves setting from options dialog to ini file 
;-------------------------------------------------------------------------------------
APIInfoSaveIniSettings PROC USES EBX
    LOCAL LVItem:LV_ITEM
    LOCAL nItemIndex:DWORD
    LOCAL nTotalItemCount:DWORD
    LOCAL szItemText[MAX_PATH]:BYTE
    
    .IF gIniAutoLoadAtEntry == 0
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniAutoLoadAtEntry, Addr szZero, Addr APIInfoIni
    .ELSE
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniAutoLoadAtEntry, Addr szOne, Addr APIInfoIni
    .ENDIF
    
    .IF gIniPreserveExistingComments == 0
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniPreserveExistingComments, Addr szZero, Addr APIInfoIni
    .ELSE
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniPreserveExistingComments, Addr szOne, Addr APIInfoIni
    .ENDIF
    
    
    .IF gIniDisplayOptions == 0 ; display nothing
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniDisplayOptions, Addr szZero, Addr APIInfoIni
       
    .ELSEIF gIniDisplayOptions == 1 ; Display Module Only
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniDisplayOptions, Addr szOne, Addr APIInfoIni
        
    .ELSEIF gIniDisplayOptions == 2 ; Display Function Name Only
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniDisplayOptions, Addr szTwo, Addr APIInfoIni
        
    .ELSEIF gIniDisplayOptions == 3 ; Display Module & Function Name
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniDisplayOptions, Addr szThree, Addr APIInfoIni
    
    .ELSEIF gIniDisplayOptions == 4 ; Display Definition from .api file @=
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniDisplayOptions, Addr szFour, Addr APIInfoIni
    
    .ELSEIF gIniDisplayOptions == 5 ; Display Definition and params
        Invoke WritePrivateProfileString, Addr APIInfo, Addr szIniDisplayOptions, Addr szFive, Addr APIInfoIni
    
    ;.ELSEIF gIniDisplayOptions == 6
    
    ;.ELSEIF gIniDisplayOptions == 7
    
    .ENDIF
    
    ; loop through listview, getting checked boxes to see if any are to be excluded
    mov LVItem.imask, LVIF_TEXT
	mov LVItem.iSubItem, 0
	lea ebx, szItemText
    mov LVItem.pszText, ebx
    mov eax, MAX_PATH
    mov LVItem.cchTextMax, eax
    
    Invoke SendMessage, hLVApiFiles, LVM_GETITEMCOUNT, 0, 0
    mov nTotalItemCount, eax
    mov nItemIndex, 0
    mov eax, 0
    .WHILE eax < nTotalItemCount ; loop through all till total count is reached
        mov eax, nItemIndex
	    mov LVItem.iItem, eax	        
        Invoke SendMessage, hLVApiFiles, LVM_GETITEMTEXT, nItemIndex, Addr LVItem
        Invoke SendMessage, hLVApiFiles, LVM_GETITEMSTATE, nItemIndex, LVIS_STATEIMAGEMASK
        and eax, (3 SHL 12)
        .IF (eax == (2 SHL 12)) ; unchecked
            Invoke WritePrivateProfileString, Addr szAPIFilesToExclude, Addr szItemText, 0, Addr APIInfoIni
        .ELSE
            Invoke WritePrivateProfileString, Addr szAPIFilesToExclude, Addr szItemText, Addr szZero, Addr APIInfoIni
        .ENDIF
        inc nItemIndex
        mov eax, nItemIndex
    .ENDW
    ret

APIInfoSaveIniSettings endp


;=====================================================================================
; APIInfoLoadMenuIcon - Loads RT_RCDATA png resource and assigns it to ICONDATA
; Returns TRUE in eax if succesful or FALSE otherwise.
;-------------------------------------------------------------------------------------
APIInfoLoadMenuIcon PROC USES EBX dwImageResourceID:DWORD, lpIconData:DWORD
    LOCAL hRes:DWORD
    
    ; Load image for our menu item
    Invoke FindResource, hInstance, dwImageResourceID, RT_RCDATA ; load png image as raw data
    .IF eax != NULL
        mov hRes, eax
        Invoke SizeofResource, hInstance, hRes
        .IF eax != 0
            mov ebx, lpIconData
            mov [ebx].ICONDATA.size_, eax
            Invoke LoadResource, hInstance, hRes
            .IF eax != NULL
                Invoke LockResource, eax
                .IF eax != NULL
                    mov ebx, lpIconData
                    mov [ebx].ICONDATA.data, eax
                    mov eax, TRUE
                .ELSE
                    ;PrintText 'Failed to lock resource'
                    mov eax, FALSE
                .ENDIF
            .ELSE
                ;PrintText 'Failed to load resource'
                mov eax, FALSE
            .ENDIF
        .ELSE
            ;PrintText 'Failed to get resource size'
            mov eax, FALSE
        .ENDIF
    .ELSE
        ;PrintText 'Failed to find resource'
        mov eax, FALSE
    .ENDIF    
    ret

APIInfoLoadMenuIcon ENDP


;=====================================================================================
; CBINITDEBUG - Called by debugger when a program is debugged - needs to be EXPORTED
;
; Arguments: cbType
;            cbInfo - a pointer to a PLUG_CB_INITDEBUG structure. 
;            The szFileName item contains name of file being debugged. 
;  
; Notes:     
;            
;            Needs to be PROC C type procedure call to be compatible with debugger
;-------------------------------------------------------------------------------------
CBINITDEBUG PROC C PUBLIC USES EBX cbType:DWORD, cbInfo:DWORD
    ;PrintText 'CBINITDEBUG'
    Invoke DbgClearAutoCommentRange, 0, 0FFFFFFFEh
    ;Invoke DbgClearCommentRange, 0, 0FFFFFFFEh
    mov eax, TRUE
    ret
CBINITDEBUG endp


;=====================================================================================
; CBSTOPDEBUG - Called by debugger when debugging stopped - needs to be EXPORTED
;
; Arguments: cbType
;            cbInfo - reserved 
;            
;  
; Notes:     
;            
;            Needs to be PROC C type procedure call to be compatible with debugger
;-------------------------------------------------------------------------------------
CBSTOPDEBUG PROC C PUBLIC USES EBX cbType:DWORD, cbInfo:DWORD
    ;PrintText 'CBSTOPDEBUG'
    Invoke DbgClearAutoCommentRange, 0, 0FFFFFFFEh
    ;Invoke DbgClearCommentRange, 0, 0FFFFFFFEh
    mov eax, TRUE
    ret
CBSTOPDEBUG endp 


;=====================================================================================
; CBSYSTEMBREAKPOINT - Called by debugger at system breakpoint - needs to be EXPORTED
;
; Arguments: cbType
;            cbInfo - reserved 
;            
;  
; Notes:     
;            
;            Needs to be PROC C type procedure call to be compatible with debugger
;-------------------------------------------------------------------------------------
CBSYSTEMBREAKPOINT PROC C PUBLIC cbType:DWORD, cbInfo:DWORD
    ;PrintText 'CBSYSTEMBREAKPOINT'
    Invoke DbgClearAutoCommentRange, 0, 0FFFFFFFEh   
    ;Invoke DbgClearCommentRange, 0, 0FFFFFFFEh 
    mov eax, TRUE
    ret
CBSYSTEMBREAKPOINT ENDP

END DllEntry



















================================================
File: APIInfo.Def
================================================
;--------------------------------------------------------------------------------------------------------
; x64_dbg plugin SDK for Masm32 - fearless 2015
;
; Export definition file for your plugin
;--------------------------------------------------------------------------------------------------------

LIBRARY APIInfo
EXPORTS ; Main plugin exports - only pluginit is required, but others can be included for ease of use.
        ;
        pluginit
        plugstop
        plugsetup
        ;
        ; Plugin callbacks - only export (uncomment) the callbacks you are using in your plugin, comment out the others.
        ;
        CBINITDEBUG
        CBSTOPDEBUG
        ;CBCREATEPROCESS
        ;CBEXITPROCESS
        ;CBCREATETHREAD
        ;CBEXITTHREAD
        CBSYSTEMBREAKPOINT
        ;CBLOADDLL
        ;CBUNLOADDLL
        ;CBOUTPUTDEBUGSTRING
        ;CBEXCEPTION
        ;CBBREAKPOINT
        ;CBPAUSEDEBUG
        ;CBRESUMEDEBUG
        ;CBSTEPPED
        ;CBATTACH
        ;CBDETACH
        ;CBDEBUGEVENT
        CBMENUENTRY
        ;CBWINEVENT
        ;CBWINEVENTGLOBAL



================================================
File: APIInfo.Inc
================================================
;=====================================================================================
; x64dbg plugin SDK for Masm - fearless 2016 - www.LetTheLight.in
;
; APIInfo.inc
;
;-------------------------------------------------------------------------------------
include windows.inc
include user32.inc
include kernel32.inc
includelib user32.lib
includelib kernel32.lib

APIInfoOptionsDlgProc           PROTO :DWORD, :DWORD, :DWORD, :DWORD
DbgGetEntryExitPoints           PROTO :DWORD, :DWORD
Strip_x64dbg_calls              PROTO :DWORD, :DWORD
GenAPIInfo                      PROTO 
SearchApiFileForDefinition      PROTO :DWORD, :DWORD, :DWORD
APIInfoLoadIniSettings          PROTO
APIInfoSaveIniSettings          PROTO
InitLVApiFiles                  PROTO :DWORD
LoadLVApiFiles                  PROTO :DWORD
InternalTest                    PROTO :DWORD, :DWORD
InternalTestCallback            PROTO :DWORD, :DWORD, :DWORD
SetAutoCommentIfCommentIsEmpty  PROTO :DWORD, :DWORD
GetFunctionParamCount           PROTO :DWORD, :DWORD
GetFunctionParam                PROTO :DWORD, :DWORD, :DWORD, :DWORD
APIInfoLoadMenuIcon             PROTO :DWORD, :DWORD

INSTRUCTIONSTACK                STRUCT
    Address                     DD ?
INSTRUCTIONSTACK                ENDS

INSTRUCTIONSTACK_MAXSIZE        EQU 24

.CONST
CRLF                            TEXTEQU <13,10,0,0> ; carriage return and linefeed for strings that require them (GuiAddLogMessage for example) 

ICO_APIINFO                     EQU 100
IMG_APIINFO                     EQU 101
IMG_APIINFOOPTIONS              EQU 102 ; PNG image for plugin menu icon
IMG_APIINFOGENAPI               EQU 103 ; PNG image for plugin menu icon



MENU_APIINFOGENAPI1             EQU 5
MENU_APIINFOGENAPI2             EQU 6
MENU_APIINFOOPTIONS1            EQU 7
MENU_APIINFOOPTIONS2            EQU 8


;APIInfo.dlg
IDD_APIInfoOptionsDlg			equ 1000
IDC_GrpAPIFilesToInclude		equ 1001
IDC_LV_APIFILES					equ 1002
IDC_GrpAPIDisplayOptions		equ 1003
IDC_RbDisplayNothing			equ 1004
IDC_RbDisplayModuleOnly			equ 1005
IDC_RbDisplayFunctionOnly		equ 1006
IDC_RbDisplayModuleAndFunction	equ 1007
IDC_RbDisplayFunctionDef		equ 1008
IDC_RbDisplayFunctionDefParams	equ 1009
IDC_GRP1						equ 1010
IDC_ChkAutoLoad					equ 1011
IDC_ChkPreserveExistingComments	equ 1012
IDC_BtnAPIInfoOptionsCancel	equ 1013
IDC_BtnAPIInfoOptionsOk		equ 1014

.DATA
APIInfo                         DB "APIInfo",0
APIInfoIni                      DB MAX_PATH DUP (0)
szCurrentDirectory              DB MAX_PATH DUP (0)
szApiFile                       DB MAX_PATH DUP (0)
szFindApiFiles                  DB MAX_PATH DUP (0)
szSymbolName                    DB MAX_PATH DUP (0)
szMenuPlugin1                   DB "APIInfo",0
szPluginLoaded                  DB "APIInfo loaded.",CRLF
szPluginUnloaded                DB "APIInfo unloaded.",CRLF
szMenuAPIInfo                   DB "Generate API Information",0
szMenuAPIOptions                DB "APIInfo Options...",0
szComment                       DB MAX_COMMENT_SIZE DUP (0)

szAPIInfoInfo                   DB 13,10         
                                DB "APIInfo x32dbg plugin by fearless 2016 - www.LetTheLight.in",13,10
                                DB 13,10
                                DB "APIInfo Features & Usage:",13,10
                                DB " - Add windows api function definition information to the comments",13,10  
                                DB 13,10,0

szAPIFunction                   DB MAX_PATH DUP (0)
szAPIModuleName                 DB MAX_PATH DUP (0)
szAPIComment                    DB MAX_COMMENT_SIZE DUP (0)
szAPIDefinition                 DB MAX_COMMENT_SIZE DUP (0)
szAPIFunctionParameter          DB MAX_COMMENT_SIZE DUP (0)
szDisasmText                    DB GUI_MAX_DISASSEMBLY_SIZE DUP (0)

szStartAddAPIInfo               DB "APIInfo: adding API information, please wait...",CRLF
szFinishAddAPIInfo              DB "APIInfo: finshed adding API information, ready to continue.",CRLF
szDebuggingRequired             DB "APIInfo: you need to be debugging to use this option.",CRLF
szSetToDisplayNothing           DB "APIInfo: currently set to display nothing. If you wish to see api information change this setting in the options dialog.",CRLF


szLVApiFilesColumnText          DB "API Files",0
szStarApi                       DB "*.api",0
szIni                           DB "ini",0
szApi                           DB ".api",0
szColon                         DB ":",0
szQuote                         DB 22h,0
szZero                          DB "0",0
szOne                           DB "1",0
szTwo                           DB "2",0
szThree                         DB "3",0
szFour                          DB "4",0
szFive                          DB "5",0
szSix                           DB "6",0
szSeven                         DB "7",0
szEight                         DB "8",0
szNine                          DB "9",0
szTen                           DB "10",0
szEleven                        DB "11",0
szTwelve                        DB "12",0
szThirteen                      DB "13",0
szFourteen                      DB "14",0
szFifthteen                     DB "15",0
szSixteen                       DB "16",0
szSeventeen                     DB "17",0
szEighteen                      DB "18",0
szNineteen                      DB "19",0
szTwenty                        DB "20",0
szTwentyOne                     DB "21",0
szTwentyTwo                     DB "22",0
szTwentyThree                   DB "23",0
szTwentyFour                    DB "24",0


szQ                             DB "?",0
szSpace                         DB " ",0
szBackslash                     DB "\",0
szAt                            DB "@",0
szDashSpace                     DB "- ",0
szCRLF                          DB 13,10,0
szNull                          DB 0,0,0,0

szIniDisplayOptions             DB "DisplayOptions",0
szIniAutoLoadAtEntry            DB "AutoLoadAtEntry",0
szAPIFilesToExclude             DB "APIFilesToExclude",0 ;section has entry for each file = 1 (true) or 0 (false), no entry = 1 (true) 
szIniPreserveExistingComments   DB "PreserveExistingComments",0
szIniParamCount                 DB "ParamCount",0

gIniDisplayOptions              DD 4
gNewIniDisplayOptions           DD 0
gIniAutoLoadAtEntry             DD 0
gNewIniAutoLoadAtEntry          DD 0
gIniPreserveExistingComments    DD 1
gNewIniPreserveExistingComments DD 0
gOptionsChanged                 DD 0
InitDlg                         DD 0

pIS                             DD 0
IS                              INSTRUCTIONSTACK INSTRUCTIONSTACK_MAXSIZE DUP (<>)

ISCOUNT                         DD 0

.DATA?
hInstance                       DD ?
IFDEF DEBUG32
DbgVar                          DD ?
ENDIF
hLVApiFiles                     DD ?
hIcoAPIInfo                     DD ?



================================================
File: APIInfo.dlg
================================================
[Non-text file]


================================================
File: APIInfo.rap
================================================
[Project]
Assembler=masm
Type=Dll Project
Description=APIInfo
Backup=$P\Bak\
Group=1
GroupExpand=1
Res.rc=1
Debug=0
Ver.rc=1
[Files]
1=APIInfo.Asm
2=APIInfo.Inc
3=APIInfo.Def
4=APIInfo.rc
5=APIInfo.dlg
6=APIInfo-readme.txt
7=Notes.txt
[MakeFiles]
0=APIInfo.rap
1=APIInfo.rc
2=APIInfo.asm
3=APIInfo.obj
4=APIInfo.res
5=APIInfo.exe
6=APIInfo.def
7=APIInfo.dll
8=APIInfo.txt
9=APIInfo.lib
10=APIInfo.mak
11=APIInfo.hla
12=APIInfo.com
13=APIInfo.ocx
14=APIInfo.idl
15=APIInfo.tlb
16=APIInfo.sys
17=APIInfo.dp32
18=APIInfo.pdb
[MakeDef]
Menu=1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0
1=4,O,$B\RC.EXE /v,1
2=3,O,$B\ML.EXE /c /coff /Cp /nologo /I"$I",2
3=7,O,$B\LINK.EXE /SUBSYSTEM:WINDOWS /RELEASE /DLL /DEF:$6  /LIBPATH:"$L" /OUT:"$17",3,4
4=0,0,,5
5=rsrc.obj,O,$B\CVTRES.EXE,rsrc.res
6=*.obj,O,$B\ML.EXE /c /coff /Cp /nologo /I"$I",*.asm
7=0,0,"$E\OllyDbg",5
11=4,O,$B\RC.EXE /v,1
12=3,O,$B\ML.EXE /c /coff /Cp /Zi /Zd /nologo /I"$I",2
13=7,O,$B\LINK.EXE /SUBSYSTEM:WINDOWS /DEBUG /DEBUGTYPE:CV /PDB:"$18" /DLL /DEF:$6 /LIBPATH:"$L" /OUT:"$17",3,4
14=0,0,,5
15=rsrc.obj,O,$B\CVTRES.EXE,rsrc.res
16=*.obj,O,$B\ML.EXE /c /coff /Cp /Zi /Zd /nologo /I"$I",*.asm
17=0,0,"$E\OllyDbg",5
[Resource]
1=,1,8,APIInfo.xml
2=,101,7,Images\APIInfo.png
3=,102,7,Images\APIInfoOptions.png
4=,103,7,Images\APIInfoGenAPI.png
5=,100,2,Images\APIInfo.ico
[StringTable]
[Accel]
[VerInf]
Nme=VERINF1
ID=1
FV=1.0.0.3
PV=1.0.0.3
VerOS=0x00000004
VerFT=0x00000002
VerLNG=0x00000409
VerCHS=0x000004B0
ProductVersion=1.0.0.3
ProductName=APIInfo
OriginalFilename=APIInfo.dp32
LegalTrademarks=fearless (C) 2016 www.LetTheLight.in
LegalCopyright=fearless (C) 2016 www.LetTheLight.in
InternalName=APIInfo.dll
FileDescription=APIInfo plugin for x32dbg
FileVersion=1.0.0.3
CompanyName=fearless @ www.LetTheLight.in
[Group]
Group=Assembly,Resources,Misc
1=1
2=1
3=1
4=2
5=2
6=3
7=3
8=
9=
10=
11=
[AutoLoad]
AutoLoad=1,2,5,3,6
[RADebugBP]
2=
1=
3=
0=
[VersionControl]
Settings=1279
Milestones=129
MilestoneEvery=10
MilestoneEveryCurrent=5
MilestoneOnBuild=0.0.0.0
MilestoneOnTime=2
MilestoneOnDate=0
MilestoneOnDateWhen=1
MilestoneOnDateStatus=0
MilestoneOnDateDate=29
MilestoneOnDateTimeYear=2015
MilestoneOnDateTimeMonth=4
MilestoneOnDateTimeDate=27
MilestoneOnDateTimeHour=18
MilestoneOnDateTimeMin=45
MilestoneOnDateTimeSec=5
MilestoneOnDateTimeStatus=0
BackupLocation=M:\radasm\Masm\Projects\VCBackups\
CompressionLevel=0
DefaultComment=Project $N, $Z, Backup Created On $D At $T.
ExcludeExt1=\
ExcludeExt2=\
ExcludeExt3=\
ExcludeExt4=\
FileVerLength=4
FileVer2Range=0
FileVer3Range=0
FileVer4Range=0
ProductVerLength=4
ProductVer2Range=0
ProductVer3Range=0
ProductVer4Range=0
[PTimer]
PTimer=120665415
[Collapse]
1=171499649,33554467,114923930,11
3=
2=
6=
7=
[Size]
1=0,0,0,0,50876
3=0,0,0,0,998
2=0,0,0,0,3028
6=0,0,0,0,1119
7=0,0,0,0,1986
5=0,0,0,0
[GroupExpand]
GroupExpand=1,1,1,0
[BookMark]
0=
1=
2=
3=
4=
5=
6=
7=
8=
9=
[BreakPoint]
0=
[Find]
1="SELECTIONDATA"
2="GuiSelectionGet"
3="szAPIInfoInfo"
4="IDD_APIInfoOptionsDlg"
5="APIComments"
6="APICommentsIni"
7="APIHelper"



================================================
File: APIInfo.rc
================================================
#include "Res/APIInfoDlg.rc"
#include "Res/APIInfoRes.rc"
#include "Res/APIInfoVer.rc"



================================================
File: APIInfo.xml
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly
    xmlns="urn:schemas-microsoft-com:asm.v1"
    manifestVersion="1.0">
    <assemblyIdentity
        version="1.0.0.0"
        processorArchitecture="X86"
        name="Company.Product.Application"
        type="Win32"
    />
    <description>APIInfo</description>
    <dependency>
        <dependentAssembly>
            <assemblyIdentity
                type="win32"
                name="Microsoft.Windows.Common-Controls"
                version="6.0.0.0"
                processorArchitecture="X86"
                publicKeyToken="6595b64144ccf1df"
                language="*"
            />
        </dependentAssembly>
    </dependency>
</assembly>



================================================
File: api-definitions/advapi32.api
================================================
[RegCloseKey]
1=HKEY hKey
ParamCount=1
@=RegCloseKey(HKEY hKey);
[RegOverridePredefKey]
1=HKEY hKey
2=HKEY hNewHKey
ParamCount=2
@=RegOverridePredefKey(HKEY hKey, HKEY hNewHKey);
[RegOpenUserClassesRoot]
1=HANDLE hToken
2=DWORD dwOptions
3=REGSAM samDesired
4=PHKEY phkResult
ParamCount=4
@=RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult);
[RegOpenCurrentUser]
1=REGSAM samDesired
2=PHKEY phkResult
ParamCount=2
@=RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult);
[RegDisablePredefinedCache]
ParamCount=0
@=RegDisablePredefinedCache();
[RegDisablePredefinedCacheEx]
ParamCount=0
@=RegDisablePredefinedCacheEx();
[RegConnectRegistryA]
1=LPCSTR lpMachineName
2=HKEY hKey
3=PHKEY phkResult
ParamCount=3
@=RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult);
[RegConnectRegistryW]
1=LPCWSTR lpMachineName
2=HKEY hKey
3=PHKEY phkResult
ParamCount=3
@=RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult);
[RegConnectRegistryExA]
1=LPCSTR lpMachineName
2=HKEY hKey
3=ULONG Flags
4=PHKEY phkResult
ParamCount=4
@=RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult);
[RegConnectRegistryExW]
1=LPCWSTR lpMachineName
2=HKEY hKey
3=ULONG Flags
4=PHKEY phkResult
ParamCount=4
@=RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult);
[RegCreateKeyA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=PHKEY phkResult
ParamCount=3
@=RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
[RegCreateKeyW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=PHKEY phkResult
ParamCount=3
@=RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
[RegCreateKeyExA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=DWORD Reserved
4=LPSTR lpClass
5=DWORD dwOptions
6=REGSAM samDesired
7=LPSECURITY_ATTRIBUTES lpSecurityAttributes
8=PHKEY phkResult
9=LPDWORD lpdwDisposition
ParamCount=9
@=RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
[RegCreateKeyExW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=DWORD Reserved
4=LPWSTR lpClass
5=DWORD dwOptions
6=REGSAM samDesired
7=LPSECURITY_ATTRIBUTES lpSecurityAttributes
8=PHKEY phkResult
9=LPDWORD lpdwDisposition
ParamCount=9
@=RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
[RegCreateKeyTransactedA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=DWORD Reserved
4=LPSTR lpClass
5=DWORD dwOptions
6=REGSAM samDesired
7=LPSECURITY_ATTRIBUTES lpSecurityAttributes
8=PHKEY phkResult
9=LPDWORD lpdwDisposition
10=HANDLE hTransaction
11=PVOID pExtendedParemeter
ParamCount=11
@=RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter);
[RegCreateKeyTransactedW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=DWORD Reserved
4=LPWSTR lpClass
5=DWORD dwOptions
6=REGSAM samDesired
7=LPSECURITY_ATTRIBUTES lpSecurityAttributes
8=PHKEY phkResult
9=LPDWORD lpdwDisposition
10=HANDLE hTransaction
11=PVOID pExtendedParemeter
ParamCount=11
@=RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter);
[RegDeleteKeyA]
1=HKEY hKey
2=LPCSTR lpSubKey
ParamCount=2
@=RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey);
[RegDeleteKeyW]
1=HKEY hKey
2=LPCWSTR lpSubKey
ParamCount=2
@=RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey);
[RegDeleteKeyExA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=REGSAM samDesired
4=DWORD Reserved
ParamCount=4
@=RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved);
[RegDeleteKeyExW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=REGSAM samDesired
4=DWORD Reserved
ParamCount=4
@=RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved);
[RegDeleteKeyTransactedA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=REGSAM samDesired
4=DWORD Reserved
5=HANDLE hTransaction
6=PVOID pExtendedParameter
ParamCount=6
@=RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter);
[RegDeleteKeyTransactedW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=REGSAM samDesired
4=DWORD Reserved
5=HANDLE hTransaction
6=PVOID pExtendedParameter
ParamCount=6
@=RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter);
[RegDisableReflectionKey]
1=HKEY hBase
ParamCount=1
@=RegDisableReflectionKey(HKEY hBase);
[RegEnableReflectionKey]
1=HKEY hBase
ParamCount=1
@=RegEnableReflectionKey(HKEY hBase);
[RegQueryReflectionKey]
1=HKEY hBase
2=BOOL *bIsReflectionDisabled
ParamCount=2
@=RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled);
[RegDeleteValueA]
1=HKEY hKey
2=LPCSTR lpValueName
ParamCount=2
@=RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);
[RegDeleteValueW]
1=HKEY hKey
2=LPCWSTR lpValueName
ParamCount=2
@=RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName);
[RegEnumKeyA]
1=HKEY hKey
2=DWORD dwIndex
3=LPSTR lpName
4=DWORD cchName
ParamCount=4
@=RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName);
[RegEnumKeyW]
1=HKEY hKey
2=DWORD dwIndex
3=LPWSTR lpName
4=DWORD cchName
ParamCount=4
@=RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName);
[RegEnumKeyExA]
1=HKEY hKey
2=DWORD dwIndex
3=LPSTR lpName
4=LPDWORD lpcchName
5=LPDWORD lpReserved
6=LPSTR lpClass
7=LPDWORD lpcchClass
8=PFILETIME lpftLastWriteTime
ParamCount=8
@=RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
[RegEnumKeyExW]
1=HKEY hKey
2=DWORD dwIndex
3=LPWSTR lpName
4=LPDWORD lpcchName
5=LPDWORD lpReserved
6=LPWSTR lpClass
7=LPDWORD lpcchClass
8=PFILETIME lpftLastWriteTime
ParamCount=8
@=RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
[RegEnumValueA]
1=HKEY hKey
2=DWORD dwIndex
3=LPSTR lpValueName
4=LPDWORD lpcchValueName
5=LPDWORD lpReserved
6=LPDWORD lpType
7=LPBYTE lpData
8=LPDWORD lpcbData
ParamCount=8
@=RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
[RegEnumValueW]
1=HKEY hKey
2=DWORD dwIndex
3=LPWSTR lpValueName
4=LPDWORD lpcchValueName
5=LPDWORD lpReserved
6=LPDWORD lpType
7=LPBYTE lpData
8=LPDWORD lpcbData
ParamCount=8
@=RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
[RegFlushKey]
1=HKEY hKey
ParamCount=1
@=RegFlushKey(HKEY hKey);
[RegGetKeySecurity]
1=HKEY hKey
2=SECURITY_INFORMATION SecurityInformation
3=PSECURITY_DESCRIPTOR pSecurityDescriptor
4=LPDWORD lpcbSecurityDescriptor
ParamCount=4
@=RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor);
[RegLoadKeyA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=LPCSTR lpFile
ParamCount=3
@=RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile);
[RegLoadKeyW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=LPCWSTR lpFile
ParamCount=3
@=RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile);
[RegNotifyChangeKeyValue]
1=HKEY hKey
2=BOOL bWatchSubtree
3=DWORD dwNotifyFilter
4=HANDLE hEvent
5=BOOL fAsynchronous
ParamCount=5
@=RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous);
[RegOpenKeyA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=PHKEY phkResult
ParamCount=3
@=RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
[RegOpenKeyW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=PHKEY phkResult
ParamCount=3
@=RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
[RegOpenKeyExA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=DWORD ulOptions
4=REGSAM samDesired
5=PHKEY phkResult
ParamCount=5
@=RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
[RegOpenKeyExW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=DWORD ulOptions
4=REGSAM samDesired
5=PHKEY phkResult
ParamCount=5
@=RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
[RegOpenKeyTransactedA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=DWORD ulOptions
4=REGSAM samDesired
5=PHKEY phkResult
6=HANDLE hTransaction
7=PVOID pExtendedParemeter
ParamCount=7
@=RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter);
[RegOpenKeyTransactedW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=DWORD ulOptions
4=REGSAM samDesired
5=PHKEY phkResult
6=HANDLE hTransaction
7=PVOID pExtendedParemeter
ParamCount=7
@=RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter);
[RegQueryInfoKeyA]
1=HKEY hKey
2=LPSTR lpClass
3=LPDWORD lpcchClass
4=LPDWORD lpReserved
5=LPDWORD lpcSubKeys
6=LPDWORD lpcbMaxSubKeyLen
7=LPDWORD lpcbMaxClassLen
8=LPDWORD lpcValues
9=LPDWORD lpcbMaxValueNameLen
10=LPDWORD lpcbMaxValueLen
11=LPDWORD lpcbSecurityDescriptor
12=PFILETIME lpftLastWriteTime
ParamCount=12
@=RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
[RegQueryInfoKeyW]
1=HKEY hKey
2=LPWSTR lpClass
3=LPDWORD lpcchClass
4=LPDWORD lpReserved
5=LPDWORD lpcSubKeys
6=LPDWORD lpcbMaxSubKeyLen
7=LPDWORD lpcbMaxClassLen
8=LPDWORD lpcValues
9=LPDWORD lpcbMaxValueNameLen
10=LPDWORD lpcbMaxValueLen
11=LPDWORD lpcbSecurityDescriptor
12=PFILETIME lpftLastWriteTime
ParamCount=12
@=RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
[RegQueryValueA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=LPSTR lpData
4=PLONG lpcbData
ParamCount=4
@=RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData);
[RegQueryValueW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=LPWSTR lpData
4=PLONG lpcbData
ParamCount=4
@=RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData);
[RegQueryMultipleValuesA]
1=HKEY hKey
2=PVALENTA val_list
3=DWORD num_vals
4=LPSTR lpValueBuf
5=LPDWORD ldwTotsize
ParamCount=5
@=RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize);
[RegQueryMultipleValuesW]
1=HKEY hKey
2=PVALENTW val_list
3=DWORD num_vals
4=LPWSTR lpValueBuf
5=LPDWORD ldwTotsize
ParamCount=5
@=RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize);
[RegQueryValueExA]
1=HKEY hKey
2=LPCSTR lpValueName
3=LPDWORD lpReserved
4=LPDWORD lpType
5=LPBYTE lpData
6=== NULL
7=_When_(lpData !=NULL
8=LPDWORD lpcbData
ParamCount=8
@=RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, == NULL, _When_(lpData !=NULL, LPDWORD lpcbData);
[RegQueryValueExW]
1=HKEY hKey
2=LPCWSTR lpValueName
3=LPDWORD lpReserved
4=LPDWORD lpType
5=LPBYTE lpData
6=== NULL
7=_When_(lpData !=NULL
8=LPDWORD lpcbData
ParamCount=8
@=RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, == NULL, _When_(lpData !=NULL, LPDWORD lpcbData);
[RegReplaceKeyA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=LPCSTR lpNewFile
4=LPCSTR lpOldFile
ParamCount=4
@=RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile);
[RegReplaceKeyW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=LPCWSTR lpNewFile
4=LPCWSTR lpOldFile
ParamCount=4
@=RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile);
[RegRestoreKeyA]
1=HKEY hKey
2=LPCSTR lpFile
3=DWORD dwFlags
ParamCount=3
@=RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags);
[RegRestoreKeyW]
1=HKEY hKey
2=LPCWSTR lpFile
3=DWORD dwFlags
ParamCount=3
@=RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags);
[RegRenameKey]
1=HKEY hKey
2=LPCWSTR lpSubKeyName
3=LPCWSTR lpNewKeyName
ParamCount=3
@=RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName);
[RegSaveKeyA]
1=HKEY hKey
2=LPCSTR lpFile
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=3
@=RegSaveKeyA(HKEY hKey, LPCSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[RegSaveKeyW]
1=HKEY hKey
2=LPCWSTR lpFile
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=3
@=RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[RegSetKeySecurity]
1=HKEY hKey
2=SECURITY_INFORMATION SecurityInformation
3=PSECURITY_DESCRIPTOR pSecurityDescriptor
ParamCount=3
@=RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
[RegSetValueA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=DWORD dwType
4=LPCSTR lpData
5=DWORD cbData
ParamCount=5
@=RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData);
[RegSetValueW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=DWORD dwType
4=LPCWSTR lpData
5=DWORD cbData
ParamCount=5
@=RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
[RegSetValueExA]
1=HKEY hKey
2=LPCSTR lpValueName
3=DWORD Reserved
4=DWORD dwType
5=BYTE *lpData
6=DWORD cbData
ParamCount=6
@=RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, BYTE *lpData, DWORD cbData);
[RegSetValueExW]
1=HKEY hKey
2=LPCWSTR lpValueName
3=DWORD Reserved
4=DWORD dwType
5=BYTE *lpData
6=DWORD cbData
ParamCount=6
@=RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, BYTE *lpData, DWORD cbData);
[RegUnLoadKeyA]
1=HKEY hKey
2=LPCSTR lpSubKey
ParamCount=2
@=RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey);
[RegUnLoadKeyW]
1=HKEY hKey
2=LPCWSTR lpSubKey
ParamCount=2
@=RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey);
[RegDeleteKeyValueA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=LPCSTR lpValueName
ParamCount=3
@=RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName);
[RegDeleteKeyValueW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=LPCWSTR lpValueName
ParamCount=3
@=RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName);
[RegSetKeyValueA]
1=HKEY hKey
2=LPCSTR lpSubKey
3=LPCSTR lpValueName
4=DWORD dwType
5=LPCVOID lpData
6=DWORD cbData
ParamCount=6
@=RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData);
[RegSetKeyValueW]
1=HKEY hKey
2=LPCWSTR lpSubKey
3=LPCWSTR lpValueName
4=DWORD dwType
5=LPCVOID lpData
6=DWORD cbData
ParamCount=6
@=RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData);
[RegDeleteTreeA]
1=HKEY hKey
2=LPCSTR lpSubKey
ParamCount=2
@=RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey);
[RegDeleteTreeW]
1=HKEY hKey
2=LPCWSTR lpSubKey
ParamCount=2
@=RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey);
[RegCopyTreeA]
1=HKEY hKeySrc
2=LPCSTR lpSubKey
3=HKEY hKeyDest
ParamCount=3
@=RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest);
[RegGetValueA]
1=HKEY hkey
2=LPCSTR lpSubKey
3=LPCSTR lpValue
4=DWORD dwFlags
5=LPDWORD pdwType
6=PVOID pvData
7=LPDWORD pcbData
ParamCount=7
@=RegGetValueA(HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData);
[RegGetValueW]
1=HKEY hkey
2=LPCWSTR lpSubKey
3=LPCWSTR lpValue
4=DWORD dwFlags
5=LPDWORD pdwType
6=PVOID pvData
7=LPDWORD pcbData
ParamCount=7
@=RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData);
[RegCopyTreeW]
1=HKEY hKeySrc
2=LPCWSTR lpSubKey
3=HKEY hKeyDest
ParamCount=3
@=RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest);
[RegLoadMUIStringA]
1=HKEY hKey
2=LPCSTR pszValue
3=LPSTR pszOutBuf
4=DWORD cbOutBuf
5=LPDWORD pcbData
6=DWORD Flags
7=LPCSTR pszDirectory
ParamCount=7
@=RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory);
[RegLoadMUIStringW]
1=HKEY hKey
2=LPCWSTR pszValue
3=LPWSTR pszOutBuf
4=DWORD cbOutBuf
5=LPDWORD pcbData
6=DWORD Flags
7=LPCWSTR pszDirectory
ParamCount=7
@=RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory);
[RegLoadAppKeyA]
1=LPCSTR lpFile
2=PHKEY phkResult
3=REGSAM samDesired
4=DWORD dwOptions
5=DWORD Reserved
ParamCount=5
@=RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved);
[RegLoadAppKeyW]
1=LPCWSTR lpFile
2=PHKEY phkResult
3=REGSAM samDesired
4=DWORD dwOptions
5=DWORD Reserved
ParamCount=5
@=RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved);
[InitiateSystemShutdownA]
1=LPSTR lpMachineName
2=LPSTR lpMessage
3=DWORD dwTimeout
4=BOOL bForceAppsClosed
5=BOOL bRebootAfterShutdown
ParamCount=5
@=InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown);
[InitiateSystemShutdownW]
1=LPWSTR lpMachineName
2=LPWSTR lpMessage
3=DWORD dwTimeout
4=BOOL bForceAppsClosed
5=BOOL bRebootAfterShutdown
ParamCount=5
@=InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown);
[AbortSystemShutdownA]
1=LPSTR lpMachineName
ParamCount=1
@=AbortSystemShutdownA(LPSTR lpMachineName);
[AbortSystemShutdownW]
1=LPWSTR lpMachineName
ParamCount=1
@=AbortSystemShutdownW(LPWSTR lpMachineName);
[InitiateSystemShutdownExA]
1=LPSTR lpMachineName
2=LPSTR lpMessage
3=DWORD dwTimeout
4=BOOL bForceAppsClosed
5=BOOL bRebootAfterShutdown
6=DWORD dwReason
ParamCount=6
@=InitiateSystemShutdownExA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason);
[InitiateSystemShutdownExW]
1=LPWSTR lpMachineName
2=LPWSTR lpMessage
3=DWORD dwTimeout
4=BOOL bForceAppsClosed
5=BOOL bRebootAfterShutdown
6=DWORD dwReason
ParamCount=6
@=InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason);
[InitiateShutdownA]
1=LPSTR lpMachineName
2=LPSTR lpMessage
3=DWORD dwGracePeriod
4=DWORD dwShutdownFlags
5=DWORD dwReason
ParamCount=5
@=InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason);
[InitiateShutdownW]
1=LPWSTR lpMachineName
2=LPWSTR lpMessage
3=DWORD dwGracePeriod
4=DWORD dwShutdownFlags
5=DWORD dwReason
ParamCount=5
@=InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason);
[CheckForHiberboot]
1=PBOOLEAN pHiberboot
2=BOOLEAN bClearFlag
ParamCount=2
@=CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag);
[RegSaveKeyExA]
1=HKEY hKey
2=LPCSTR lpFile
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
4=DWORD Flags
ParamCount=4
@=RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);
[RegSaveKeyExW]
1=HKEY hKey
2=LPCWSTR lpFile
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
4=DWORD Flags
ParamCount=4
@=RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);
[SERVICE_MAIN_FUNCTIONW]
1=DWORD dwNumServicesArgs
2=LPWSTR *lpServiceArgVectors
ParamCount=2
@=SERVICE_MAIN_FUNCTIONW(DWORD dwNumServicesArgs, LPWSTR *lpServiceArgVectors);
[SERVICE_MAIN_FUNCTIONA]
1=DWORD dwNumServicesArgs
2=LPTSTR *lpServiceArgVectors
ParamCount=2
@=SERVICE_MAIN_FUNCTIONA(DWORD dwNumServicesArgs, LPTSTR *lpServiceArgVectors);
[HANDLER_FUNCTION]
1=DWORD dwControl
ParamCount=1
@=HANDLER_FUNCTION(DWORD dwControl);
[HANDLER_FUNCTION_EX]
1=DWORD dwControl
2=DWORD dwEventType
3=LPVOID lpEventData
4=LPVOID lpContext
ParamCount=4
@=HANDLER_FUNCTION_EX(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
[ChangeServiceConfigA]
1=SC_HANDLE hService
2=DWORD dwServiceType
3=DWORD dwStartType
4=DWORD dwErrorControl
5=LPCSTR lpBinaryPathName
6=LPCSTR lpLoadOrderGroup
7=LPDWORD lpdwTagId
8=LPCSTR lpDependencies
9=LPCSTR lpServiceStartName
10=LPCSTR lpPassword
11=LPCSTR lpDisplayName
ParamCount=11
@=ChangeServiceConfigA(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName);
[ChangeServiceConfigW]
1=SC_HANDLE hService
2=DWORD dwServiceType
3=DWORD dwStartType
4=DWORD dwErrorControl
5=LPCWSTR lpBinaryPathName
6=LPCWSTR lpLoadOrderGroup
7=LPDWORD lpdwTagId
8=LPCWSTR lpDependencies
9=LPCWSTR lpServiceStartName
10=LPCWSTR lpPassword
11=LPCWSTR lpDisplayName
ParamCount=11
@=ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName);
[ChangeServiceConfig2A]
1=SC_HANDLE hService
2=DWORD dwInfoLevel
3=LPVOID lpInfo
ParamCount=3
@=ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo);
[ChangeServiceConfig2W]
1=SC_HANDLE hService
2=DWORD dwInfoLevel
3=LPVOID lpInfo
ParamCount=3
@=ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo);
[CloseServiceHandle]
1=SC_HANDLE hSCObject
ParamCount=1
@=CloseServiceHandle(SC_HANDLE hSCObject);
[ControlService]
1=SC_HANDLE hService
2=DWORD dwControl
3=LPSERVICE_STATUS lpServiceStatus
ParamCount=3
@=ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
[CreateServiceA]
1=SC_HANDLE hSCManager
2=LPCSTR lpServiceName
3=LPCSTR lpDisplayName
4=DWORD dwDesiredAccess
5=DWORD dwServiceType
6=DWORD dwStartType
7=DWORD dwErrorControl
8=LPCSTR lpBinaryPathName
9=LPCSTR lpLoadOrderGroup
10=LPDWORD lpdwTagId
11=LPCSTR lpDependencies
12=LPCSTR lpServiceStartName
13=LPCSTR lpPassword
ParamCount=13
@=CreateServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword);
[CreateServiceW]
1=SC_HANDLE hSCManager
2=LPCWSTR lpServiceName
3=LPCWSTR lpDisplayName
4=DWORD dwDesiredAccess
5=DWORD dwServiceType
6=DWORD dwStartType
7=DWORD dwErrorControl
8=LPCWSTR lpBinaryPathName
9=LPCWSTR lpLoadOrderGroup
10=LPDWORD lpdwTagId
11=LPCWSTR lpDependencies
12=LPCWSTR lpServiceStartName
13=LPCWSTR lpPassword
ParamCount=13
@=CreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword);
[DeleteService]
1=SC_HANDLE hService
ParamCount=1
@=DeleteService(SC_HANDLE hService);
[EnumDependentServicesA]
1=SC_HANDLE hService
2=DWORD dwServiceState
3=LPENUM_SERVICE_STATUSA lpServices
4=DWORD cbBufSize
5=LPDWORD pcbBytesNeeded
6=LPDWORD lpServicesReturned
ParamCount=6
@=EnumDependentServicesA(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
[EnumDependentServicesW]
1=SC_HANDLE hService
2=DWORD dwServiceState
3=LPENUM_SERVICE_STATUSW lpServices
4=DWORD cbBufSize
5=LPDWORD pcbBytesNeeded
6=LPDWORD lpServicesReturned
ParamCount=6
@=EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
[EnumServicesStatusA]
1=SC_HANDLE hSCManager
2=DWORD dwServiceType
3=DWORD dwServiceState
4=LPENUM_SERVICE_STATUSA lpServices
5=DWORD cbBufSize
6=LPDWORD pcbBytesNeeded
7=LPDWORD lpServicesReturned
8=LPDWORD lpResumeHandle
ParamCount=8
@=EnumServicesStatusA(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle);
[EnumServicesStatusW]
1=SC_HANDLE hSCManager
2=DWORD dwServiceType
3=DWORD dwServiceState
4=LPENUM_SERVICE_STATUSW lpServices
5=DWORD cbBufSize
6=LPDWORD pcbBytesNeeded
7=LPDWORD lpServicesReturned
8=LPDWORD lpResumeHandle
ParamCount=8
@=EnumServicesStatusW(SC_HANDLE hSCManager, DWORD dwServiceType, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle);
[EnumServicesStatusExA]
1=SC_HANDLE hSCManager
2=SC_ENUM_TYPE InfoLevel
3=DWORD dwServiceType
4=DWORD dwServiceState
5=LPBYTE lpServices
6=DWORD cbBufSize
7=LPDWORD pcbBytesNeeded
8=LPDWORD lpServicesReturned
9=LPDWORD lpResumeHandle
10=LPCSTR pszGroupName
ParamCount=10
@=EnumServicesStatusExA(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName);
[EnumServicesStatusExW]
1=SC_HANDLE hSCManager
2=SC_ENUM_TYPE InfoLevel
3=DWORD dwServiceType
4=DWORD dwServiceState
5=LPBYTE lpServices
6=DWORD cbBufSize
7=LPDWORD pcbBytesNeeded
8=LPDWORD lpServicesReturned
9=LPDWORD lpResumeHandle
10=LPCWSTR pszGroupName
ParamCount=10
@=EnumServicesStatusExW(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCWSTR pszGroupName);
[GetServiceKeyNameA]
1=SC_HANDLE hSCManager
2=LPCSTR lpDisplayName
3=LPSTR lpServiceName
4=LPDWORD lpcchBuffer
ParamCount=4
@=GetServiceKeyNameA(SC_HANDLE hSCManager, LPCSTR lpDisplayName, LPSTR lpServiceName, LPDWORD lpcchBuffer);
[GetServiceKeyNameW]
1=SC_HANDLE hSCManager
2=LPCWSTR lpDisplayName
3=LPWSTR lpServiceName
4=LPDWORD lpcchBuffer
ParamCount=4
@=GetServiceKeyNameW(SC_HANDLE hSCManager, LPCWSTR lpDisplayName, LPWSTR lpServiceName, LPDWORD lpcchBuffer);
[GetServiceDisplayNameA]
1=SC_HANDLE hSCManager
2=LPCSTR lpServiceName
3=LPSTR lpDisplayName
4=LPDWORD lpcchBuffer
ParamCount=4
@=GetServiceDisplayNameA(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPSTR lpDisplayName, LPDWORD lpcchBuffer);
[GetServiceDisplayNameW]
1=SC_HANDLE hSCManager
2=LPCWSTR lpServiceName
3=LPWSTR lpDisplayName
4=LPDWORD lpcchBuffer
ParamCount=4
@=GetServiceDisplayNameW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPWSTR lpDisplayName, LPDWORD lpcchBuffer);
[LockServiceDatabase]
1=SC_HANDLE hSCManager
ParamCount=1
@=LockServiceDatabase(SC_HANDLE hSCManager);
[NotifyBootConfigStatus]
1=BOOL BootAcceptable
ParamCount=1
@=NotifyBootConfigStatus(BOOL BootAcceptable);
[OpenSCManagerA]
1=LPCSTR lpMachineName
2=LPCSTR lpDatabaseName
3=DWORD dwDesiredAccess
ParamCount=3
@=OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
[OpenSCManagerW]
1=LPCWSTR lpMachineName
2=LPCWSTR lpDatabaseName
3=DWORD dwDesiredAccess
ParamCount=3
@=OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
[OpenServiceA]
1=SC_HANDLE hSCManager
2=LPCSTR lpServiceName
3=DWORD dwDesiredAccess
ParamCount=3
@=OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
[OpenServiceW]
1=SC_HANDLE hSCManager
2=LPCWSTR lpServiceName
3=DWORD dwDesiredAccess
ParamCount=3
@=OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
[QueryServiceConfigA]
1=SC_HANDLE hService
2=LPQUERY_SERVICE_CONFIGA lpServiceConfig
3=DWORD cbBufSize
4=LPDWORD pcbBytesNeeded
ParamCount=4
@=QueryServiceConfigA(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[QueryServiceConfigW]
1=SC_HANDLE hService
2=LPQUERY_SERVICE_CONFIGW lpServiceConfig
3=DWORD cbBufSize
4=LPDWORD pcbBytesNeeded
ParamCount=4
@=QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[QueryServiceConfig2A]
1=SC_HANDLE hService
2=DWORD dwInfoLevel
3=LPBYTE lpBuffer
4=DWORD cbBufSize
5=LPDWORD pcbBytesNeeded
ParamCount=5
@=QueryServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[QueryServiceConfig2W]
1=SC_HANDLE hService
2=DWORD dwInfoLevel
3=LPBYTE lpBuffer
4=DWORD cbBufSize
5=LPDWORD pcbBytesNeeded
ParamCount=5
@=QueryServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[QueryServiceLockStatusA]
1=SC_HANDLE hSCManager
2=LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus
3=DWORD cbBufSize
4=LPDWORD pcbBytesNeeded
ParamCount=4
@=QueryServiceLockStatusA(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[QueryServiceLockStatusW]
1=SC_HANDLE hSCManager
2=LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus
3=DWORD cbBufSize
4=LPDWORD pcbBytesNeeded
ParamCount=4
@=QueryServiceLockStatusW(SC_HANDLE hSCManager, LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[QueryServiceObjectSecurity]
1=SC_HANDLE hService
2=SECURITY_INFORMATION dwSecurityInformation
3=PSECURITY_DESCRIPTOR lpSecurityDescriptor
4=DWORD cbBufSize
5=LPDWORD pcbBytesNeeded
ParamCount=5
@=QueryServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[QueryServiceStatus]
1=SC_HANDLE hService
2=LPSERVICE_STATUS lpServiceStatus
ParamCount=2
@=QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
[QueryServiceStatusEx]
1=SC_HANDLE hService
2=SC_STATUS_TYPE InfoLevel
3=LPBYTE lpBuffer
4=DWORD cbBufSize
5=LPDWORD pcbBytesNeeded
ParamCount=5
@=QueryServiceStatusEx(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[RegisterServiceCtrlHandlerA]
1=LPCSTR lpServiceName
2=LPHANDLER_FUNCTION lpHandlerProc
ParamCount=2
@=RegisterServiceCtrlHandlerA(LPCSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc);
[RegisterServiceCtrlHandlerW]
1=LPCWSTR lpServiceName
2=LPHANDLER_FUNCTION lpHandlerProc
ParamCount=2
@=RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION lpHandlerProc);
[RegisterServiceCtrlHandlerExA]
1=LPCSTR lpServiceName
2=LPHANDLER_FUNCTION_EX lpHandlerProc
3=LPVOID lpContext
ParamCount=3
@=RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext);
[RegisterServiceCtrlHandlerExW]
1=LPCWSTR lpServiceName
2=LPHANDLER_FUNCTION_EX lpHandlerProc
3=LPVOID lpContext
ParamCount=3
@=RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext);
[SetServiceObjectSecurity]
1=SC_HANDLE hService
2=SECURITY_INFORMATION dwSecurityInformation
3=PSECURITY_DESCRIPTOR lpSecurityDescriptor
ParamCount=3
@=SetServiceObjectSecurity(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor);
[SetServiceStatus]
1=SERVICE_STATUS_HANDLE hServiceStatus
2=LPSERVICE_STATUS lpServiceStatus
ParamCount=2
@=SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus);
[StartServiceCtrlDispatcherA]
1=SERVICE_TABLE_ENTRYA *lpServiceStartTable
ParamCount=1
@=StartServiceCtrlDispatcherA(SERVICE_TABLE_ENTRYA *lpServiceStartTable);
[StartServiceCtrlDispatcherW]
1=SERVICE_TABLE_ENTRYW *lpServiceStartTable
ParamCount=1
@=StartServiceCtrlDispatcherW(SERVICE_TABLE_ENTRYW *lpServiceStartTable);
[StartServiceA]
1=SC_HANDLE hService
2=DWORD dwNumServiceArgs
3=LPCSTR *lpServiceArgVectors
ParamCount=3
@=StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);
[StartServiceW]
1=SC_HANDLE hService
2=DWORD dwNumServiceArgs
3=LPCWSTR *lpServiceArgVectors
ParamCount=3
@=StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors);
[UnlockServiceDatabase]
1=SC_LOCK ScLock
ParamCount=1
@=UnlockServiceDatabase(SC_LOCK ScLock);
[NotifyServiceStatusChangeA]
1=SC_HANDLE hService
2=DWORD dwNotifyMask
3=PSERVICE_NOTIFYA pNotifyBuffer
ParamCount=3
@=NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer);
[NotifyServiceStatusChangeW]
1=SC_HANDLE hService
2=DWORD dwNotifyMask
3=PSERVICE_NOTIFYW pNotifyBuffer
ParamCount=3
@=NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer);
[ControlServiceExA]
1=SC_HANDLE hService
2=DWORD dwControl
3=DWORD dwInfoLevel
4=PVOID pControlParams
ParamCount=4
@=ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams);
[ControlServiceExW]
1=SC_HANDLE hService
2=DWORD dwControl
3=DWORD dwInfoLevel
4=PVOID pControlParams
ParamCount=4
@=ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams);
[QueryServiceDynamicInformation]
1=SERVICE_STATUS_HANDLE hServiceStatus
2=DWORD dwInfoLevel
3=PVOID *ppDynamicInfo
ParamCount=3
@=QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID *ppDynamicInfo);



================================================
File: api-definitions/comctl32.api
================================================
[InitCommonControls]
ParamCount=0
@=InitCommonControls();
[InitCommonControlsEx]
1=INITCOMMONCONTROLSEX *picce
ParamCount=1
@=InitCommonControlsEx(INITCOMMONCONTROLSEX *picce);
[ImageList_Create]
1=int cx
2=int cy
3=UINT flags
4=int cInitial
5=int cGrow
ParamCount=5
@=ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
[ImageList_Destroy]
1=HIMAGELIST himl
ParamCount=1
@=ImageList_Destroy(HIMAGELIST himl);
[ImageList_GetImageCount]
1=HIMAGELIST himl
ParamCount=1
@=ImageList_GetImageCount(HIMAGELIST himl);
[ImageList_SetImageCount]
1=HIMAGELIST himl
2=UINT uNewCount
ParamCount=2
@=ImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount);
[ImageList_Add]
1=HIMAGELIST himl
2=HBITMAP hbmImage
3=HBITMAP hbmMask
ParamCount=3
@=ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
[ImageList_AddIcon]
1=HIMAGELIST himl
2=HICON hicon
ParamCount=2
@=ImageList_AddIcon(HIMAGELIST himl, HICON hicon);
[ImageList_ReplaceIcon]
1=HIMAGELIST himl
2=int i
3=HICON hicon
ParamCount=2
@=ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
[ImageList_SetBkColor]
1=HIMAGELIST himl
2=COLORREF clrBk
ParamCount=2
@=ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
[ImageList_GetBkColor]
1=HIMAGELIST himl
ParamCount=1
@=ImageList_GetBkColor(HIMAGELIST himl);
[ImageList_SetOverlayImage]
1=HIMAGELIST himl
2=int iImage
3=int iOverlay
ParamCount=3
@=ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);
[ImageList_Draw]
1=HIMAGELIST himl
2=int i
3=HDC hdcDst
4=int x
5=int y
6=UINT fStyle
ParamCount=6
@=ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle);
[ImageList_Replace]
1=HIMAGELIST himl
2=int i
3=HBITMAP hbmImage
4=HBITMAP hbmMask
ParamCount=4
@=ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask);
[ImageList_AddMasked]
1=HIMAGELIST himl
2=HBITMAP hbmImage
3=COLORREF crMask
ParamCount=3
@=ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask);
[ImageList_DrawEx]
1=HIMAGELIST himl
2=int i
3=HDC hdcDst
4=int x
5=int y
6=int dx
7=int dy
8=COLORREF rgbBk
9=COLORREF rgbFg
10=UINT fStyle
ParamCount=10
@=ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
[ImageList_DrawIndirect]
1=IMAGELISTDRAWPARAMS* pimldp
ParamCount=1
@=ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp);
[ImageList_Remove]
1=HIMAGELIST himl
2=int i
ParamCount=2
@=ImageList_Remove(HIMAGELIST himl, int i);
[ImageList_GetIcon]
1=HIMAGELIST himl
2=int i
3=UINT flags
ParamCount=3
@=ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags);
[ImageList_LoadImageA]
1=HINSTANCE hi
2=LPCSTR lpbmp
3=int cx
4=int cGrow
5=COLORREF crMask
6=UINT uType
7=UINT uFlags
ParamCount=7
@=ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
[ImageList_LoadImageW]
1=HINSTANCE hi
2=LPCWSTR lpbmp
3=int cx
4=int cGrow
5=COLORREF crMask
6=UINT uType
7=UINT uFlags
ParamCount=7
@=ImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
[ImageList_Copy]
1=HIMAGELIST himlDst
2=int iDst
3=HIMAGELIST himlSrc
4=int iSrc
5=UINT uFlags
ParamCount=5
@=ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags);
[ImageList_BeginDrag]
1=HIMAGELIST himlTrack
2=int iTrack
3=int dxHotspot
4=int dyHotspot
ParamCount=4
@=ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot);
[ImageList_EndDrag]
ParamCount=0
@=ImageList_EndDrag();
[ImageList_DragEnter]
1=HWND hwndLock
2=int x
3=int y
ParamCount=3
@=ImageList_DragEnter(HWND hwndLock, int x, int y);
[ImageList_DragLeave]
1=HWND hwndLock
ParamCount=1
@=ImageList_DragLeave(HWND hwndLock);
[ImageList_DragMove]
1=int x
2=int y
ParamCount=2
@=ImageList_DragMove(int x, int y);
[ImageList_SetDragCursorImage]
1=HIMAGELIST himlDrag
2=int iDrag
3=int dxHotspot
4=int dyHotspot
ParamCount=4
@=ImageList_SetDragCursorImage(HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot);
[ImageList_DragShowNolock]
1=BOOL fShow
ParamCount=1
@=ImageList_DragShowNolock(BOOL fShow);
[ImageList_GetDragImage]
1=POINT *ppt
2=POINT *pptHotspot
ParamCount=2
@=ImageList_GetDragImage(POINT *ppt, POINT *pptHotspot);
[ImageList_Read]
1=IStream *pstm
ParamCount=1
@=ImageList_Read(IStream *pstm);
[ImageList_Write]
1=HIMAGELIST himl
2=IStream *pstm
ParamCount=2
@=ImageList_Write(HIMAGELIST himl, IStream *pstm);
[ImageList_ReadEx]
1=DWORD dwFlags
2=IStream *pstm
3=REFIID riid
4=PVOID* ppv
ParamCount=4
@=ImageList_ReadEx(DWORD dwFlags, IStream *pstm, REFIID riid, PVOID* ppv);
[ImageList_WriteEx]
1=HIMAGELIST himl
2=DWORD dwFlags
3=IStream *pstm
ParamCount=3
@=ImageList_WriteEx(HIMAGELIST himl, DWORD dwFlags, IStream *pstm);
[ImageList_GetIconSize]
1=HIMAGELIST himl
2=int *cx
3=int *cy
ParamCount=3
@=ImageList_GetIconSize(HIMAGELIST himl, int *cx, int *cy);
[ImageList_SetIconSize]
1=HIMAGELIST himl
2=int cx
3=int cy
ParamCount=3
@=ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy);
[ImageList_GetImageInfo]
1=HIMAGELIST himl
2=int i
3=IMAGEINFO *pImageInfo
ParamCount=3
@=ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO *pImageInfo);
[ImageList_Merge]
1=HIMAGELIST himl1
2=int i1
3=HIMAGELIST himl2
4=int i2
5=int dx
6=int dy
ParamCount=6
@=ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy);
[ImageList_Duplicate]
1=HIMAGELIST himl
ParamCount=1
@=ImageList_Duplicate(HIMAGELIST himl);
[HIMAGELIST_QueryInterface]
1=HIMAGELIST himl
2=REFIID riid
3=void** ppv
ParamCount=3
@=HIMAGELIST_QueryInterface(HIMAGELIST himl, REFIID riid, void** ppv);
[CreateToolbarEx]
1=HWND hwnd
2=DWORD ws
3=UINT wID
4=int nBitmaps
5=HINSTANCE hBMInst
6=wBMID
7=LPCTBBUTTON lpButtons
8=int iNumButtons
9=int dxButton
10=int dyButton
11=int dxBitmap
12=int dyBitmap
13=UINT uStructSize
ParamCount=13
@=CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, wBMID, LPCTBBUTTON lpButtons, int iNumButtons, int dxButton, int dyButton, int dxBitmap, int dyBitmap, UINT uStructSize);
[CreateMappedBitmap]
1=HINSTANCE hInstance
2=idBitmap
3=UINT wFlags
4=LPCOLORMAP lpColorMap
5=int iNumMaps
ParamCount=5
@=CreateMappedBitmap(HINSTANCE hInstance, idBitmap, UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps);
[DrawStatusTextA]
1=HDC hDC
2=LPCRECT lprc
3=LPCSTR pszText
4=UINT uFlags
ParamCount=4
@=DrawStatusTextA(HDC hDC, LPCRECT lprc, LPCSTR pszText, UINT uFlags);
[DrawStatusTextW]
1=HDC hDC
2=LPCRECT lprc
3=LPCWSTR pszText
4=UINT uFlags
ParamCount=4
@=DrawStatusTextW(HDC hDC, LPCRECT lprc, LPCWSTR pszText, UINT uFlags);
[CreateStatusWindowA]
1=LONG style
2=LPCSTR lpszText
3=HWND hwndParent
4=UINT wID
ParamCount=4
@=CreateStatusWindowA(LONG style, LPCSTR lpszText, HWND hwndParent, UINT wID);
[CreateStatusWindowW]
1=LONG style
2=LPCWSTR lpszText
3=HWND hwndParent
4=UINT wID
ParamCount=4
@=CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);
[MenuHelp]
1=UINT uMsg
2=WPARAM wParam
3=LPARAM lParam
4=HMENU hMainMenu
5=HINSTANCE hInst
6=HWND hwndStatus
7=UINT *lpwIDs
ParamCount=7
@=MenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT *lpwIDs);
[ShowHideMenuCtl]
1=HWND hWnd
2=UINT_PTR uFlags
3=UINT_PTR LPINTlpInfo
ParamCount=3
@=ShowHideMenuCtl(HWND hWnd, UINT_PTR uFlags, UINT_PTR LPINTlpInfo);
[GetEffectiveClientRect]
1=HWND hWnd
2=LPRECT lprc
3=LPRECT constINT*lpInfo
ParamCount=3
@=GetEffectiveClientRect(HWND hWnd, LPRECT lprc, LPRECT constINT*lpInfo);
[MakeDragList]
1=HWND hLB
ParamCount=1
@=MakeDragList(HWND hLB);
[DrawInsert]
1=HWND handParent
2=HWND hLB
3=int nItem
ParamCount=3
@=DrawInsert(HWND handParent, HWND hLB, int nItem);
[LBItemFromPt]
1=HWND hLB
2=POINT pt
3=BOOL bAutoScroll
ParamCount=3
@=LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll);
[CreateUpDownControl]
1=DWORD dwStyle
2=int x
3=int y
4=int cx
5=int cy
6=HWND hParent
7=int nID
8=HINSTANCE hInst
9=HWND hBuddy
10=int nUpper
11=int nLower
12=int nPos
ParamCount=12
@=CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy, HWND hParent, int nID, HINSTANCE hInst, HWND hBuddy, int nUpper, int nLower, int nPos);
[TaskDialogIndirect]
1=TASKDIALOGCONFIG *pTaskConfig
2=int *pnButton
3=int *pnRadioButton
4=BOOL *pfVerificationFlagChecked
ParamCount=4
@=TaskDialogIndirect(TASKDIALOGCONFIG *pTaskConfig, int *pnButton, int *pnRadioButton, BOOL *pfVerificationFlagChecked);
[TaskDialog]
1=HWND hwndParent
2=HINSTANCE hInstance
3=PCWSTR pszWindowTitle
4=PCWSTR pszMainInstruction
5=PCWSTR pszContent
6=dwCommonButtons
7=PCWSTR pszIcon
8=int *pnButton
ParamCount=8
@=TaskDialog(HWND hwndParent, HINSTANCE hInstance, PCWSTR pszWindowTitle, PCWSTR pszMainInstruction, PCWSTR pszContent, dwCommonButtons, PCWSTR pszIcon, int *pnButton);
[InitMUILanguage]
1=LANGID uiLang
ParamCount=1
@=InitMUILanguage(LANGID uiLang);
[GetMUILanguage]
ParamCount=0
@=GetMUILanguage();
[DSA_Create]
1=int cbItem
2=int cItemGrow
ParamCount=2
@=DSA_Create(int cbItem, int cItemGrow);
[DSA_Destroy]
1=HDSA hdsa
ParamCount=1
@=DSA_Destroy(HDSA hdsa);
[DSA_DestroyCallback]
1=HDSA hdsa
2=PFNDAENUMCALLBACK pfnCB
3=void *pData
ParamCount=3
@=DSA_DestroyCallback(HDSA hdsa, PFNDAENUMCALLBACK pfnCB, void *pData);
[DSA_DeleteItem]
1=HDSA hdsa
2=int i
ParamCount=2
@=DSA_DeleteItem(HDSA hdsa, int i);
[DSA_DeleteAllItems]
1=HDSA hdsa
ParamCount=1
@=DSA_DeleteAllItems(HDSA hdsa);
[DSA_EnumCallback]
1=HDSA hdsa
2=PFNDAENUMCALLBACK pfnCB
3=void *pData
ParamCount=3
@=DSA_EnumCallback(HDSA hdsa, PFNDAENUMCALLBACK pfnCB, void *pData);
[DSA_InsertItem]
1=HDSA hdsa
2=int i
3=void *pitem
ParamCount=3
@=DSA_InsertItem(HDSA hdsa, int i, void *pitem);
[DSA_GetItemPtr]
1=HDSA hdsa
2=int i
ParamCount=2
@=DSA_GetItemPtr(HDSA hdsa, int i);
[DSA_GetItem]
1=HDSA hdsa
2=int i
3=void *pitem
ParamCount=3
@=DSA_GetItem(HDSA hdsa, int i, void *pitem);
[DSA_SetItem]
1=HDSA hdsa
2=int i
3=void *pitem
ParamCount=3
@=DSA_SetItem(HDSA hdsa, int i, void *pitem);
[DSA_Clone]
1=HDSA hdsa
ParamCount=1
@=DSA_Clone(HDSA hdsa);
[DSA_GetSize]
1=HDSA hdsa
ParamCount=1
@=DSA_GetSize(HDSA hdsa);
[DSA_Sort]
1=HDSA pdsa
2=PFNDACOMPARE pfnCompare
3=LPARAM lParam
ParamCount=3
@=DSA_Sort(HDSA pdsa, PFNDACOMPARE pfnCompare, LPARAM lParam);
[DPA_Create]
1=int cItemGrow
ParamCount=1
@=DPA_Create(int cItemGrow);
[DPA_CreateEx]
1=int cpGrow
2=HANDLE hheap
ParamCount=2
@=DPA_CreateEx(int cpGrow, HANDLE hheap);
[DPA_Clone]
1=HDPA hdpa
2=HDPA hdpaNew
ParamCount=2
@=DPA_Clone(HDPA hdpa, HDPA hdpaNew);
[DPA_Destroy]
1=HDPA hdpa
ParamCount=1
@=DPA_Destroy(HDPA hdpa);
[DPA_DestroyCallback]
1=HDPA hdpa
2=PFNDAENUMCALLBACK pfnCB
3=void *pData
ParamCount=3
@=DPA_DestroyCallback(HDPA hdpa, PFNDAENUMCALLBACK pfnCB, void *pData);
[DPA_DeletePtr]
1=HDPA hdpa
2=int i
ParamCount=2
@=DPA_DeletePtr(HDPA hdpa, int i);
[DPA_DeleteAllPtrs]
1=HDPA hdpa
ParamCount=1
@=DPA_DeleteAllPtrs(HDPA hdpa);
[DPA_EnumCallback]
1=HDPA hdpa
2=PFNDAENUMCALLBACK pfnCB
3=void *pData
ParamCount=3
@=DPA_EnumCallback(HDPA hdpa, PFNDAENUMCALLBACK pfnCB, void *pData);
[DPA_Grow]
1=HDPA pdpa
2=int cp
ParamCount=2
@=DPA_Grow(HDPA pdpa, int cp);
[DPA_InsertPtr]
1=HDPA hdpa
2=int i
3=void *p
ParamCount=3
@=DPA_InsertPtr(HDPA hdpa, int i, void *p);
[DPA_SetPtr]
1=HDPA hdpa
2=int i
3=void *p
ParamCount=3
@=DPA_SetPtr(HDPA hdpa, int i, void *p);
[DPA_GetPtr]
1=HDPA hdpa
2=INT_PTR i
ParamCount=2
@=DPA_GetPtr(HDPA hdpa, INT_PTR i);
[DPA_GetPtrIndex]
1=HDPA hdpa
2=void *p
ParamCount=2
@=DPA_GetPtrIndex(HDPA hdpa, void *p);
[DPA_GetSize]
1=HDPA hdpa
ParamCount=1
@=DPA_GetSize(HDPA hdpa);
[DPA_Sort]
1=HDPA hdpa
2=PFNDACOMPARE pfnCompare
3=LPARAM lParam
ParamCount=3
@=DPA_Sort(HDPA hdpa, PFNDACOMPARE pfnCompare, LPARAM lParam);
[DPA_LoadStream]
1=HDPA *phdpa
2=PFNDPASTREAM pfn
3=IStream *pstream
4=void *pvInstData
ParamCount=4
@=DPA_LoadStream(HDPA *phdpa, PFNDPASTREAM pfn, IStream *pstream, void *pvInstData);
[DPA_SaveStream]
1=HDPA hdpa
2=PFNDPASTREAM pfn
3=IStream *pstream
4=void *pvInstData
ParamCount=4
@=DPA_SaveStream(HDPA hdpa, PFNDPASTREAM pfn, IStream *pstream, void *pvInstData);
[DPA_Merge]
1=HDPA hdpaDest
2=HDPA hdpaSrc
3=DWORD dwFlags
4=PFNDACOMPARE pfnCompare
5=PFNDPAMERGE pfnMerge
6=LPARAM lParam
ParamCount=6
@=DPA_Merge(HDPA hdpaDest, HDPA hdpaSrc, DWORD dwFlags, PFNDACOMPARE pfnCompare, PFNDPAMERGE pfnMerge, LPARAM lParam);
[DPA_Search]
1=HDPA hdpa
2=void *pFind
3=int iStart
4=PFNDACOMPARE pfnCompare
5=LPARAM lParam
6=UINT options
ParamCount=6
@=DPA_Search(HDPA hdpa, void *pFind, int iStart, PFNDACOMPARE pfnCompare, LPARAM lParam, UINT options);
[Str_SetPtrW]
1=LPWSTR *ppsz
2=LPCWSTR psz
ParamCount=2
@=Str_SetPtrW(LPWSTR *ppsz, LPCWSTR psz);
[_TrackMouseEvent]
1=LPTRACKMOUSEEVENT lpEventTrack
ParamCount=1
@=_TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack);
[FlatSB_EnableScrollBar]
1=HWND
2=int
3=UINT
ParamCount=3
@=FlatSB_EnableScrollBar(HWND, int, UINT);
[FlatSB_ShowScrollBar]
1=HWND
2=int code
3=BOOL
ParamCount=3
@=FlatSB_ShowScrollBar(HWND, int code, BOOL);
[FlatSB_GetScrollRange]
1=HWND
2=int code
3=LPINT
4=LPINT
ParamCount=4
@=FlatSB_GetScrollRange(HWND, int code, LPINT, LPINT);
[FlatSB_GetScrollInfo]
1=HWND
2=int code
3=LPSCROLLINFO
ParamCount=3
@=FlatSB_GetScrollInfo(HWND, int code, LPSCROLLINFO);
[FlatSB_GetScrollPos]
1=HWND
2=int code
ParamCount=2
@=FlatSB_GetScrollPos(HWND, int code);
[FlatSB_GetScrollProp]
1=HWND
2=int propIndex
3=LPINT
ParamCount=3
@=FlatSB_GetScrollProp(HWND, int propIndex, LPINT);
[FlatSB_GetScrollPropPtr]
1=HWND
2=int propIndex
3=FlatSB_GetScrollPropPtr FlatSB_GetScrollProp#endifWINCOMMCTRLAPIintWINAPIFlatSB_SetScrollPos(HWND
4=int code
5=int pos
6=BOOL fRedraw
ParamCount=6
@=FlatSB_GetScrollPropPtr(HWND, int propIndex, FlatSB_GetScrollPropPtr FlatSB_GetScrollProp#endifWINCOMMCTRLAPIintWINAPIFlatSB_SetScrollPos(HWND, int code, int pos, BOOL fRedraw);
[FlatSB_SetScrollInfo]
1=HWND
2=int code
3=LPSCROLLINFO psi
4=BOOL fRedraw
ParamCount=4
@=FlatSB_SetScrollInfo(HWND, int code, LPSCROLLINFO psi, BOOL fRedraw);
[FlatSB_SetScrollRange]
1=HWND
2=int code
3=int min
4=int max
5=BOOL fRedraw
ParamCount=5
@=FlatSB_SetScrollRange(HWND, int code, int min, int max, BOOL fRedraw);
[FlatSB_SetScrollProp]
1=HWND
2=UINT index
3=newValue
4=BOOL
ParamCount=4
@=FlatSB_SetScrollProp(HWND, UINT index, newValue, BOOL);
[InitializeFlatSB]
1=HWND
ParamCount=1
@=InitializeFlatSB(HWND);
[UninitializeFlatSB]
1=HWND
ParamCount=1
@=UninitializeFlatSB(HWND);
[SetWindowSubclass]
1=HWND hWnd
2=SUBCLASSPROC pfnSubclass
3=UINT_PTR uIdSubclass
4=DWORD_PTR dwRefData
ParamCount=4
@=SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
[GetWindowSubclass]
1=HWND hWnd
2=SUBCLASSPROC pfnSubclass
3=UINT_PTR uIdSubclass
4=DWORD_PTR *pdwRefData
ParamCount=4
@=GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR *pdwRefData);
[RemoveWindowSubclass]
1=HWND hWnd
2=SUBCLASSPROC pfnSubclass
3=UINT_PTR uIdSubclass
ParamCount=3
@=RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass);
[DefSubclassProc]
1=HWND hWnd
2=UINT uMsg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
[LoadIconMetric]
1=HINSTANCE hinst
2=PCWSTR pszName
3=int lims
4=HICON *phico
ParamCount=4
@=LoadIconMetric(HINSTANCE hinst, PCWSTR pszName, int lims, HICON *phico);
[LoadIconWithScaleDown]
1=HINSTANCE hinst
2=PCWSTR pszName
3=int cx
4=int cy
5=HICON *phico
ParamCount=5
@=LoadIconWithScaleDown(HINSTANCE hinst, PCWSTR pszName, int cx, int cy, HICON *phico);
[DrawShadowText]
1=HDC hdc
2=LPCWSTR pszText
3=UINT cch
4=RECT* prc
5=DWORD dwFlags
6=COLORREF crText
7=COLORREF crShadow
8=int ixOffset
9=int iyOffset
ParamCount=9
@=DrawShadowText(HDC hdc, LPCWSTR pszText, UINT cch, RECT* prc, DWORD dwFlags, COLORREF crText, COLORREF crShadow, int ixOffset, int iyOffset);



================================================
File: api-definitions/comdlg32.api
================================================
[GetOpenFileNameA]
1=LPOPENFILENAMEA
ParamCount=1
@=GetOpenFileNameA(LPOPENFILENAMEA);
[GetOpenFileNameW]
1=LPOPENFILENAMEW
ParamCount=1
@=GetOpenFileNameW(LPOPENFILENAMEW);
[GetSaveFileNameA]
1=LPOPENFILENAMEA
ParamCount=1
@=GetSaveFileNameA(LPOPENFILENAMEA);
[GetSaveFileNameW]
1=LPOPENFILENAMEW
ParamCount=1
@=GetSaveFileNameW(LPOPENFILENAMEW);
[GetFileTitleA]
1=LPCSTR
2=LPSTR Buf
3=WORD cchSize
ParamCount=3
@=GetFileTitleA(LPCSTR, LPSTR Buf, WORD cchSize);
[GetFileTitleW]
1=LPCWSTR
2=LPWSTR Buf
3=WORD cchSize
ParamCount=3
@=GetFileTitleW(LPCWSTR, LPWSTR Buf, WORD cchSize);
[ChooseColorA]
1=LPCHOOSECOLORA
ParamCount=1
@=ChooseColorA(LPCHOOSECOLORA);
[ChooseColorW]
1=LPCHOOSECOLORW
ParamCount=1
@=ChooseColorW(LPCHOOSECOLORW);
[FindTextA]
1=LPFINDREPLACEA
ParamCount=1
@=FindTextA(LPFINDREPLACEA);
[FindTextW]
1=LPFINDREPLACEW
ParamCount=1
@=FindTextW(LPFINDREPLACEW);
[ReplaceTextA]
1=LPFINDREPLACEA
ParamCount=1
@=ReplaceTextA(LPFINDREPLACEA);
[ReplaceTextW]
1=LPFINDREPLACEW
ParamCount=1
@=ReplaceTextW(LPFINDREPLACEW);
[AfxReplaceTextA]
1=LPFINDREPLACEA
ParamCount=1
@=AfxReplaceTextA(LPFINDREPLACEA);
[AfxReplaceTextW]
1=LPFINDREPLACEW
ParamCount=1
@=AfxReplaceTextW(LPFINDREPLACEW);
[ChooseFontA]
1=LPCHOOSEFONTA
ParamCount=1
@=ChooseFontA(LPCHOOSEFONTA);
[ChooseFontW]
1=LPCHOOSEFONTW
ParamCount=1
@=ChooseFontW(LPCHOOSEFONTW);
[PrintDlgA]
1=LPPRINTDLGA pPD
ParamCount=1
@=PrintDlgA(LPPRINTDLGA pPD);
[PrintDlgW]
1=LPPRINTDLGW pPD
ParamCount=1
@=PrintDlgW(LPPRINTDLGW pPD);
[PrintDlgExA]
1=LPPRINTDLGEXA pPD
ParamCount=1
@=PrintDlgExA(LPPRINTDLGEXA pPD);
[PrintDlgExW]
1=LPPRINTDLGEXW pPD
ParamCount=1
@=PrintDlgExW(LPPRINTDLGEXW pPD);
[CommDlgExtendedError]
ParamCount=0
@=CommDlgExtendedError();
[PageSetupDlgA]
1=LPPAGESETUPDLGA
ParamCount=1
@=PageSetupDlgA(LPPAGESETUPDLGA);
[PageSetupDlgW]
1=LPPAGESETUPDLGW
ParamCount=1
@=PageSetupDlgW(LPPAGESETUPDLGW);



================================================
File: api-definitions/gdi32.api
================================================
[AddFontResourceA]
1=LPCSTR
ParamCount=1
@=AddFontResourceA(LPCSTR);
[AddFontResourceW]
1=LPCWSTR
ParamCount=1
@=AddFontResourceW(LPCWSTR);
[AnimatePalette]
1=HPALETTE hPal
2=UINT iStartIndex
3=UINT cEntries
4=PALETTEENTRY *ppe
ParamCount=4
@=AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, PALETTEENTRY *ppe);
[Arc]
1=HDC hdc
2=int x1
3=int y1
4=int x2
5=int y2
6=int x3
7=int y3
8=int x4
9=int y4
ParamCount=9
@=Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
[BitBlt]
1=HDC hdc
2=int x
3=int y
4=int cx
5=int cy
6=HDC hdcSrc
7=int x1
8=int y1
9=DWORD rop
ParamCount=9
@=BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
[CancelDC]
1=HDC hdc
ParamCount=1
@=CancelDC(HDC hdc);
[Chord]
1=HDC hdc
2=int x1
3=int y1
4=int x2
5=int y2
6=int x3
7=int y3
8=int x4
9=int y4
ParamCount=9
@=Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
[ChoosePixelFormat]
1=HDC hdc
2=PIXELFORMATDESCRIPTOR *ppfd
ParamCount=2
@=ChoosePixelFormat(HDC hdc, PIXELFORMATDESCRIPTOR *ppfd);
[CloseMetaFile]
1=HDC hdc
ParamCount=1
@=CloseMetaFile(HDC hdc);
[CombineRgn]
1=HRGN hrgnDst
2=HRGN hrgnSrc1
3=HRGN hrgnSrc2
4=int iMode
ParamCount=4
@=CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode);
[CopyMetaFileA]
1=HMETAFILE
2=LPCSTR
ParamCount=2
@=CopyMetaFileA(HMETAFILE, LPCSTR);
[CopyMetaFileW]
1=HMETAFILE
2=LPCWSTR
ParamCount=2
@=CopyMetaFileW(HMETAFILE, LPCWSTR);
[CreateBitmap]
1=int nWidth
2=int nHeight
3=UINT nPlanes
4=UINT nBitCount
5=VOID *lpBits
ParamCount=5
@=CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, VOID *lpBits);
[CreateBitmapIndirect]
1=BITMAP *pbm
ParamCount=1
@=CreateBitmapIndirect(BITMAP *pbm);
[CreateBrushIndirect]
1=LOGBRUSH *plbrush
ParamCount=1
@=CreateBrushIndirect(LOGBRUSH *plbrush);
[CreateCompatibleBitmap]
1=HDC hdc
2=int cx
3=int cy
ParamCount=3
@=CreateCompatibleBitmap(HDC hdc, int cx, int cy);
[CreateDiscardableBitmap]
1=HDC hdc
2=int cx
3=int cy
ParamCount=3
@=CreateDiscardableBitmap(HDC hdc, int cx, int cy);
[CreateCompatibleDC]
1=HDC hdc
ParamCount=1
@=CreateCompatibleDC(HDC hdc);
[CreateDCA]
1=LPCSTR pwszDriver
2=LPCSTR pwszDevice
3=LPCSTR pszPort
4=DEVMODEA *pdm
ParamCount=4
@=CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, DEVMODEA *pdm);
[CreateDCW]
1=LPCWSTR pwszDriver
2=LPCWSTR pwszDevice
3=LPCWSTR pszPort
4=DEVMODEW *pdm
ParamCount=4
@=CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, DEVMODEW *pdm);
[CreateDIBitmap]
1=HDC hdc
2=BITMAPINFOHEADER *pbmih
3=DWORD flInit
4=VOID *pjBits
5=BITMAPINFO *pbmi
6=UINT iUsage
ParamCount=6
@=CreateDIBitmap(HDC hdc, BITMAPINFOHEADER *pbmih, DWORD flInit, VOID *pjBits, BITMAPINFO *pbmi, UINT iUsage);
[CreateDIBPatternBrush]
1=HGLOBAL h
2=UINT iUsage
ParamCount=2
@=CreateDIBPatternBrush(HGLOBAL h, UINT iUsage);
[CreateDIBPatternBrushPt]
1=VOID *lpPackedDIB
2=UINT iUsage
ParamCount=2
@=CreateDIBPatternBrushPt(VOID *lpPackedDIB, UINT iUsage);
[CreateEllipticRgn]
1=int x1
2=int y1
3=int x2
4=int y2
ParamCount=4
@=CreateEllipticRgn(int x1, int y1, int x2, int y2);
[CreateEllipticRgnIndirect]
1=RECT *lprect
ParamCount=1
@=CreateEllipticRgnIndirect(RECT *lprect);
[CreateFontIndirectA]
1=LOGFONTA *lplf
ParamCount=1
@=CreateFontIndirectA(LOGFONTA *lplf);
[CreateFontIndirectW]
1=LOGFONTW *lplf
ParamCount=1
@=CreateFontIndirectW(LOGFONTW *lplf);
[CreateFontA]
1=int cHeight
2=int cWidth
3=int cEscapement
4=int cOrientation
5=int cWeight
6=DWORD bItalic
7=DWORD bUnderline
8=DWORD bStrikeOut
9=DWORD iCharSet
10=DWORD iOutPrecision
11=DWORD iClipPrecision
12=DWORD iQuality
13=DWORD iPitchAndFamily
14=LPCSTR pszFaceName
ParamCount=14
@=CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
[CreateFontW]
1=int cHeight
2=int cWidth
3=int cEscapement
4=int cOrientation
5=int cWeight
6=DWORD bItalic
7=DWORD bUnderline
8=DWORD bStrikeOut
9=DWORD iCharSet
10=DWORD iOutPrecision
11=DWORD iClipPrecision
12=DWORD iQuality
13=DWORD iPitchAndFamily
14=LPCWSTR pszFaceName
ParamCount=14
@=CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);
[CreateHatchBrush]
1=int iHatch
2=COLORREF color
ParamCount=2
@=CreateHatchBrush(int iHatch, COLORREF color);
[CreateICA]
1=LPCSTR pszDriver
2=LPCSTR pszDevice
3=LPCSTR pszPort
4=DEVMODEA *pdm
ParamCount=4
@=CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, DEVMODEA *pdm);
[CreateICW]
1=LPCWSTR pszDriver
2=LPCWSTR pszDevice
3=LPCWSTR pszPort
4=DEVMODEW *pdm
ParamCount=4
@=CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, DEVMODEW *pdm);
[CreateMetaFileA]
1=LPCSTR pszFile
ParamCount=1
@=CreateMetaFileA(LPCSTR pszFile);
[CreateMetaFileW]
1=LPCWSTR pszFile
ParamCount=1
@=CreateMetaFileW(LPCWSTR pszFile);
[CreatePalette]
1=LOGPALETTE *plpal
ParamCount=1
@=CreatePalette(LOGPALETTE *plpal);
[CreatePen]
1=int iStyle
2=int cWidth
3=COLORREF color
ParamCount=3
@=CreatePen(int iStyle, int cWidth, COLORREF color);
[CreatePenIndirect]
1=LOGPEN *plpen
ParamCount=1
@=CreatePenIndirect(LOGPEN *plpen);
[CreatePolyPolygonRgn]
1=POINT *pptl
2=INT *pc
3=int cPoly
4=int iMode
ParamCount=4
@=CreatePolyPolygonRgn(POINT *pptl, INT *pc, int cPoly, int iMode);
[CreatePatternBrush]
1=HBITMAP hbm
ParamCount=1
@=CreatePatternBrush(HBITMAP hbm);
[CreateRectRgn]
1=int x1
2=int y1
3=int x2
4=int y2
ParamCount=4
@=CreateRectRgn(int x1, int y1, int x2, int y2);
[CreateRectRgnIndirect]
1=RECT *lprect
ParamCount=1
@=CreateRectRgnIndirect(RECT *lprect);
[CreateRoundRectRgn]
1=int x1
2=int y1
3=int x2
4=int y2
5=int w
6=int h
ParamCount=6
@=CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h);
[CreateScalableFontResourceA]
1=DWORD fdwHidden
2=LPCSTR lpszFont
3=LPCSTR lpszFile
4=LPCSTR lpszPath
ParamCount=4
@=CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath);
[CreateScalableFontResourceW]
1=DWORD fdwHidden
2=LPCWSTR lpszFont
3=LPCWSTR lpszFile
4=LPCWSTR lpszPath
ParamCount=4
@=CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath);
[CreateSolidBrush]
1=COLORREF color
ParamCount=1
@=CreateSolidBrush(COLORREF color);
[DeleteDC]
1=HDC hdc
ParamCount=1
@=DeleteDC(HDC hdc);
[DeleteMetaFile]
1=HMETAFILE hmf
ParamCount=1
@=DeleteMetaFile(HMETAFILE hmf);
[DeleteObject]
1=HGDIOBJ ho
ParamCount=1
@=DeleteObject(HGDIOBJ ho);
[DescribePixelFormat]
1=HDC hdc
2=int iPixelFormat
3=UINT nBytes
4=LPPIXELFORMATDESCRIPTOR ppfd
ParamCount=4
@=DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd);
[DeviceCapabilitiesA]
1=LPCSTR pDevice
2=LPCSTR pPort
3=WORD fwCapability
4=LPSTR pOutput
5=DEVMODEA *pDevMode
ParamCount=5
@=DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, DEVMODEA *pDevMode);
[DeviceCapabilitiesW]
1=LPCWSTR pDevice
2=LPCWSTR pPort
3=WORD fwCapability
4=LPWSTR pOutput
5=DEVMODEW *pDevMode
ParamCount=5
@=DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, DEVMODEW *pDevMode);
[DrawEscape]
1=HDC hdc
2=int iEscape
3=int cjIn
4=LPCSTR lpIn
ParamCount=4
@=DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn);
[Ellipse]
1=HDC hdc
2=int left
3=int top
4=int right
5=int bottom
ParamCount=5
@=Ellipse(HDC hdc, int left, int top, int right, int bottom);
[EnumFontFamiliesExA]
1=HDC hdc
2=LPLOGFONTA lpLogfont
3=FONTENUMPROCA lpProc
4=LPARAM lParam
5=DWORD dwFlags
ParamCount=5
@=EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags);
[EnumFontFamiliesExW]
1=HDC hdc
2=LPLOGFONTW lpLogfont
3=FONTENUMPROCW lpProc
4=LPARAM lParam
5=DWORD dwFlags
ParamCount=5
@=EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags);
[EnumFontFamiliesA]
1=HDC hdc
2=LPCSTR lpLogfont
3=FONTENUMPROCA lpProc
4=LPARAM lParam
ParamCount=4
@=EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
[EnumFontFamiliesW]
1=HDC hdc
2=LPCWSTR lpLogfont
3=FONTENUMPROCW lpProc
4=LPARAM lParam
ParamCount=4
@=EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);
[EnumFontsA]
1=HDC hdc
2=LPCSTR lpLogfont
3=FONTENUMPROCA lpProc
4=LPARAM lParam
ParamCount=4
@=EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
[EnumFontsW]
1=HDC hdc
2=LPCWSTR lpLogfont
3=FONTENUMPROCW lpProc
4=LPARAM lParam
ParamCount=4
@=EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);
[EnumObjects]
1=HDC hdc
2=int nType
3=GOBJENUMPROC lpFunc
4=LPVOID lParam
ParamCount=4
@=EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPVOID lParam);
[EqualRgn]
1=HRGN hrgn1
2=HRGN hrgn2
ParamCount=2
@=EqualRgn(HRGN hrgn1, HRGN hrgn2);
[Escape]
1=HDC hdc
2=int iEscape
3=int cjIn
4=LPCSTR pvIn
5=LPVOID pvOut
ParamCount=5
@=Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut);
[ExtEscape]
1=HDC hdc
2=int iEscape
3=int cjInput
4=LPCSTR lpInData
5=int cjOutput
6=LPSTR lpOutData
ParamCount=6
@=ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData);
[ExcludeClipRect]
1=HDC hdc
2=int left
3=int top
4=int right
5=int bottom
ParamCount=5
@=ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom);
[ExtCreateRegion]
1=XFORM *lpx
2=DWORD nCount
3=RGNDATA *lpData
ParamCount=3
@=ExtCreateRegion(XFORM *lpx, DWORD nCount, RGNDATA *lpData);
[ExtFloodFill]
1=HDC hdc
2=int x
3=int y
4=COLORREF color
5=UINT type
ParamCount=5
@=ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type);
[FillRgn]
1=HDC hdc
2=HRGN hrgn
3=HBRUSH hbr
ParamCount=3
@=FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr);
[FloodFill]
1=HDC hdc
2=int x
3=int y
4=COLORREF color
ParamCount=4
@=FloodFill(HDC hdc, int x, int y, COLORREF color);
[FrameRgn]
1=HDC hdc
2=HRGN hrgn
3=HBRUSH hbr
4=int w
5=int h
ParamCount=5
@=FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h);
[GetROP2]
1=HDC hdc
ParamCount=1
@=GetROP2(HDC hdc);
[GetAspectRatioFilterEx]
1=HDC hdc
2=LPSIZE lpsize
ParamCount=2
@=GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize);
[GetBkColor]
1=HDC hdc
ParamCount=1
@=GetBkColor(HDC hdc);
[GetDCBrushColor]
1=HDC hdc
ParamCount=1
@=GetDCBrushColor(HDC hdc);
[GetDCPenColor]
1=HDC hdc
ParamCount=1
@=GetDCPenColor(HDC hdc);
[GetBkMode]
1=HDC hdc
ParamCount=1
@=GetBkMode(HDC hdc);
[GetBitmapBits]
1=HBITMAP hbit
2=LONG cb
3=LPVOID lpvBits
ParamCount=3
@=GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits);
[GetBitmapDimensionEx]
1=HBITMAP hbit
2=LPSIZE lpsize
ParamCount=2
@=GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize);
[GetBoundsRect]
1=HDC hdc
2=LPRECT lprect
3=UINT flags
ParamCount=3
@=GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags);
[GetBrushOrgEx]
1=HDC hdc
2=LPPOINT lppt
ParamCount=2
@=GetBrushOrgEx(HDC hdc, LPPOINT lppt);
[GetCharWidthA]
1=HDC hdc
2=UINT iFirst
3=UINT iLast
4=LPINT lpBuffer
ParamCount=4
@=GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
[GetCharWidthW]
1=HDC hdc
2=UINT iFirst
3=UINT iLast
4=LPINT lpBuffer
ParamCount=4
@=GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
[GetCharWidth32A]
1=HDC hdc
2=UINT iFirst
3=UINT iLast
4=LPINT lpBuffer
ParamCount=4
@=GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
[GetCharWidth32W]
1=HDC hdc
2=UINT iFirst
3=UINT iLast
4=LPINT lpBuffer
ParamCount=4
@=GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
[GetCharWidthFloatA]
1=HDC hdc
2=UINT iFirst
3=UINT iLast
4=PFLOAT lpBuffer
ParamCount=4
@=GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
[GetCharWidthFloatW]
1=HDC hdc
2=UINT iFirst
3=UINT iLast
4=PFLOAT lpBuffer
ParamCount=4
@=GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
[GetCharABCWidthsA]
1=HDC hdc
2=UINT wFirst
3=UINT wLast
4=LPABC lpABC
ParamCount=4
@=GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC);
[GetCharABCWidthsW]
1=HDC hdc
2=UINT wFirst
3=UINT wLast
4=LPABC lpABC
ParamCount=4
@=GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC);
[GetCharABCWidthsFloatA]
1=HDC hdc
2=UINT iFirst
3=UINT iLast
4=LPABCFLOAT lpABC
ParamCount=4
@=GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
[GetCharABCWidthsFloatW]
1=HDC hdc
2=UINT iFirst
3=UINT iLast
4=LPABCFLOAT lpABC
ParamCount=4
@=GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
[GetClipBox]
1=HDC hdc
2=LPRECT lprect
ParamCount=2
@=GetClipBox(HDC hdc, LPRECT lprect);
[GetClipRgn]
1=HDC hdc
2=HRGN hrgn
ParamCount=2
@=GetClipRgn(HDC hdc, HRGN hrgn);
[GetMetaRgn]
1=HDC hdc
2=HRGN hrgn
ParamCount=2
@=GetMetaRgn(HDC hdc, HRGN hrgn);
[GetCurrentObject]
1=HDC hdc
2=UINT type
ParamCount=2
@=GetCurrentObject(HDC hdc, UINT type);
[GetCurrentPositionEx]
1=HDC hdc
2=LPPOINT lppt
ParamCount=2
@=GetCurrentPositionEx(HDC hdc, LPPOINT lppt);
[GetDeviceCaps]
1=HDC hdc
2=int index
ParamCount=2
@=GetDeviceCaps(HDC hdc, int index);
[GetDIBits]
1=HDC hdc
2=HBITMAP hbm
3=UINT start
4=UINT cLines
5=LPVOID lpvBits
6=LPBITMAPINFO lpbmi
7=UINT usage
ParamCount=7
@=GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);
[GetFontData]
1=HDC hdc
2=DWORD dwTable
3=DWORD dwOffset
4=PVOID pvBuffer
5=DWORD cjBuffer
ParamCount=5
@=GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer);
[GetGlyphOutlineA]
1=HDC hdc
2=UINT uChar
3=UINT fuFormat
4=LPGLYPHMETRICS lpgm
5=DWORD cjBuffer
6=LPVOID pvBuffer
7=MAT2 *lpmat2
ParamCount=7
@=GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, MAT2 *lpmat2);
[GetGlyphOutlineW]
1=HDC hdc
2=UINT uChar
3=UINT fuFormat
4=LPGLYPHMETRICS lpgm
5=DWORD cjBuffer
6=LPVOID pvBuffer
7=MAT2 *lpmat2
ParamCount=7
@=GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, MAT2 *lpmat2);
[GetGraphicsMode]
1=HDC hdc
ParamCount=1
@=GetGraphicsMode(HDC hdc);
[GetMapMode]
1=HDC hdc
ParamCount=1
@=GetMapMode(HDC hdc);
[GetMetaFileBitsEx]
1=HMETAFILE hMF
2=UINT cbBuffer
3=LPVOID lpData
ParamCount=3
@=GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData);
[GetMetaFileA]
1=LPCSTR lpName
ParamCount=1
@=GetMetaFileA(LPCSTR lpName);
[GetMetaFileW]
1=LPCWSTR lpName
ParamCount=1
@=GetMetaFileW(LPCWSTR lpName);
[GetNearestColor]
1=HDC hdc
2=COLORREF color
ParamCount=2
@=GetNearestColor(HDC hdc, COLORREF color);
[GetNearestPaletteIndex]
1=HPALETTE h
2=COLORREF color
ParamCount=2
@=GetNearestPaletteIndex(HPALETTE h, COLORREF color);
[GetObjectType]
1=HGDIOBJ h
ParamCount=1
@=GetObjectType(HGDIOBJ h);
[GetOutlineTextMetricsA]
1=HDC hdc
2=UINT cjCopy
3=LPOUTLINETEXTMETRICA potm
ParamCount=3
@=GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm);
[GetOutlineTextMetricsW]
1=HDC hdc
2=UINT cjCopy
3=LPOUTLINETEXTMETRICW potm
ParamCount=3
@=GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm);
[GetPaletteEntries]
1=HPALETTE hpal
2=UINT iStart
3=UINT cEntries
4=LPPALETTEENTRY pPalEntries
ParamCount=4
@=GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries);
[GetPixel]
1=HDC hdc
2=int x
3=int y
ParamCount=3
@=GetPixel(HDC hdc, int x, int y);
[GetPixelFormat]
1=HDC hdc
ParamCount=1
@=GetPixelFormat(HDC hdc);
[GetPolyFillMode]
1=HDC hdc
ParamCount=1
@=GetPolyFillMode(HDC hdc);
[GetRasterizerCaps]
1=LPRASTERIZER_STATUS lpraststat
2=UINT cjBytes
ParamCount=2
@=GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes);
[GetRandomRgn]
1=HDC hdc
2=HRGN hrgn
3=INT i
ParamCount=3
@=GetRandomRgn(HDC hdc, HRGN hrgn, INT i);
[GetRegionData]
1=HRGN hrgn
2=DWORD nCount
3=LPRGNDATA lpRgnData
ParamCount=3
@=GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData);
[GetRgnBox]
1=HRGN hrgn
2=LPRECT lprc
ParamCount=2
@=GetRgnBox(HRGN hrgn, LPRECT lprc);
[GetStockObject]
1=int i
ParamCount=1
@=GetStockObject(int i);
[GetStretchBltMode]
1=HDC hdc
ParamCount=1
@=GetStretchBltMode(HDC hdc);
[GetSystemPaletteEntries]
1=HDC hdc
2=UINT iStart
3=UINT cEntries
4=LPPALETTEENTRY pPalEntries
ParamCount=4
@=GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries);
[GetSystemPaletteUse]
1=HDC hdc
ParamCount=1
@=GetSystemPaletteUse(HDC hdc);
[GetTextCharacterExtra]
1=HDC hdc
ParamCount=1
@=GetTextCharacterExtra(HDC hdc);
[GetTextAlign]
1=HDC hdc
ParamCount=1
@=GetTextAlign(HDC hdc);
[GetTextColor]
1=HDC hdc
ParamCount=1
@=GetTextColor(HDC hdc);
[GetTextExtentPointA]
1=HDC hdc
2=LPCSTR lpString
3=int c
4=LPSIZE lpsz
ParamCount=4
@=GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz);
[GetTextExtentPointW]
1=HDC hdc
2=LPCWSTR lpString
3=int c
4=LPSIZE lpsz
ParamCount=4
@=GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz);
[GetTextExtentPoint32A]
1=HDC hdc
2=LPCSTR lpString
3=int c
4=LPSIZE psizl
ParamCount=4
@=GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl);
[GetTextExtentPoint32W]
1=HDC hdc
2=LPCWSTR lpString
3=int c
4=LPSIZE psizl
ParamCount=4
@=GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
[GetTextExtentExPointA]
1=HDC hdc
2=LPCSTR lpszString
3=int cchString
4=int nMaxExtent
5=LPINT lpnFit
6=LPINT lpnDx
7=LPSIZE lpSize
ParamCount=7
@=GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize);
[GetTextExtentExPointW]
1=HDC hdc
2=LPCWSTR lpszString
3=int cchString
4=int nMaxExtent
5=LPINT lpnFit
6=LPINT lpnDx
7=LPSIZE lpSize
ParamCount=7
@=GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize);
[GetTextCharset]
1=HDC hdc
ParamCount=1
@=GetTextCharset(HDC hdc);
[GetTextCharsetInfo]
1=HDC hdc
2=LPFONTSIGNATURE lpSig
3=DWORD dwFlags
ParamCount=3
@=GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
[TranslateCharsetInfo]
1=DWORD *lpSrc
2=LPCHARSETINFO lpCs
3=DWORD dwFlags
ParamCount=3
@=TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
[GetFontLanguageInfo]
1=HDC hdc
ParamCount=1
@=GetFontLanguageInfo(HDC hdc);
[GetCharacterPlacementA]
1=HDC hdc
2=LPCSTR lpString
3=int nCount
4=int nMexExtent
5=LPGCP_RESULTSA lpResults
6=DWORD dwFlags
ParamCount=6
@=GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags);
[GetCharacterPlacementW]
1=HDC hdc
2=LPCWSTR lpString
3=int nCount
4=int nMexExtent
5=LPGCP_RESULTSW lpResults
6=DWORD dwFlags
ParamCount=6
@=GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags);
[GetFontUnicodeRanges]
1=HDC hdc
2=LPGLYPHSET lpgs
ParamCount=2
@=GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs);
[GetGlyphIndicesA]
1=HDC hdc
2=LPCSTR lpstr
3=int c
4=LPWORD pgi
5=DWORD fl
ParamCount=5
@=GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl);
[GetGlyphIndicesW]
1=HDC hdc
2=LPCWSTR lpstr
3=int c
4=LPWORD pgi
5=DWORD fl
ParamCount=5
@=GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl);
[GetTextExtentPointI]
1=HDC hdc
2=LPWORD pgiIn
3=int cgi
4=LPSIZE psize
ParamCount=4
@=GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize);
[GetTextExtentExPointI]
1=HDC hdc
2=LPWORD lpwszString
3=int cwchString
4=int nMaxExtent
5=LPINT lpnFit
6=LPINT lpnDx
7=LPSIZE lpSize
ParamCount=7
@=GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize);
[GetCharWidthI]
1=HDC hdc
2=UINT giFirst
3=UINT cgi
4=LPWORD pgi
5=LPINT piWidths
ParamCount=5
@=GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths);
[GetCharABCWidthsI]
1=HDC hdc
2=UINT giFirst
3=UINT cgi
4=LPWORD pgi
5=LPABC pabc
ParamCount=5
@=GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc);
[AddFontResourceExA]
1=LPCSTR name
2=DWORD fl
3=PVOID res
ParamCount=3
@=AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res);
[AddFontResourceExW]
1=LPCWSTR name
2=DWORD fl
3=PVOID res
ParamCount=3
@=AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res);
[RemoveFontResourceExA]
1=LPCSTR name
2=DWORD fl
3=PVOID pdv
ParamCount=3
@=RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv);
[RemoveFontResourceExW]
1=LPCWSTR name
2=DWORD fl
3=PVOID pdv
ParamCount=3
@=RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv);
[AddFontMemResourceEx]
1=PVOID pFileView
2=DWORD cjSize
3=PVOID pvResrved
4=DWORD* pNumFonts
ParamCount=4
@=AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD* pNumFonts);
[RemoveFontMemResourceEx]
1=HANDLE h
ParamCount=1
@=RemoveFontMemResourceEx(HANDLE h);
[CreateFontIndirectExA]
1=ENUMLOGFONTEXDVA *
ParamCount=1
@=CreateFontIndirectExA(ENUMLOGFONTEXDVA *);
[CreateFontIndirectExW]
1=ENUMLOGFONTEXDVW *
ParamCount=1
@=CreateFontIndirectExW(ENUMLOGFONTEXDVW *);
[GetViewportExtEx]
1=HDC hdc
2=LPSIZE lpsize
ParamCount=2
@=GetViewportExtEx(HDC hdc, LPSIZE lpsize);
[GetViewportOrgEx]
1=HDC hdc
2=LPPOINT lppoint
ParamCount=2
@=GetViewportOrgEx(HDC hdc, LPPOINT lppoint);
[GetWindowExtEx]
1=HDC hdc
2=LPSIZE lpsize
ParamCount=2
@=GetWindowExtEx(HDC hdc, LPSIZE lpsize);
[GetWindowOrgEx]
1=HDC hdc
2=LPPOINT lppoint
ParamCount=2
@=GetWindowOrgEx(HDC hdc, LPPOINT lppoint);
[IntersectClipRect]
1=HDC hdc
2=int left
3=int top
4=int right
5=int bottom
ParamCount=5
@=IntersectClipRect(HDC hdc, int left, int top, int right, int bottom);
[InvertRgn]
1=HDC hdc
2=HRGN hrgn
ParamCount=2
@=InvertRgn(HDC hdc, HRGN hrgn);
[LineDDA]
1=int xStart
2=int yStart
3=int xEnd
4=int yEnd
5=LINEDDAPROC lpProc
6=LPARAM data
ParamCount=6
@=LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data);
[LineTo]
1=HDC hdc
2=int x
3=int y
ParamCount=3
@=LineTo(HDC hdc, int x, int y);
[MaskBlt]
1=HDC hdcDest
2=int xDest
3=int yDest
4=int width
5=int height
6=HDC hdcSrc
7=int xSrc
8=int ySrc
9=HBITMAP hbmMask
10=int xMask
11=int yMask
12=DWORD rop
ParamCount=12
@=MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop);
[PlgBlt]
1=HDC hdcDest
2=POINT *lpPoint
3=HDC hdcSrc
4=int xSrc
5=int ySrc
6=int width
7=int height
8=HBITMAP hbmMask
9=int xMask
10=int yMask
ParamCount=10
@=PlgBlt(HDC hdcDest, POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask);
[OffsetClipRgn]
1=HDC hdc
2=int x
3=int y
ParamCount=3
@=OffsetClipRgn(HDC hdc, int x, int y);
[OffsetRgn]
1=HRGN hrgn
2=int x
3=int y
ParamCount=3
@=OffsetRgn(HRGN hrgn, int x, int y);
[PatBlt]
1=HDC hdc
2=int x
3=int y
4=int w
5=int h
6=DWORD rop
ParamCount=6
@=PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop);
[Pie]
1=HDC hdc
2=int left
3=int top
4=int right
5=int bottom
6=int xr1
7=int yr1
8=int xr2
9=int yr2
ParamCount=9
@=Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
[PlayMetaFile]
1=HDC hdc
2=HMETAFILE hmf
ParamCount=2
@=PlayMetaFile(HDC hdc, HMETAFILE hmf);
[PaintRgn]
1=HDC hdc
2=HRGN hrgn
ParamCount=2
@=PaintRgn(HDC hdc, HRGN hrgn);
[PolyPolygon]
1=HDC hdc
2=POINT *apt
3=INT *asz
4=int csz
ParamCount=4
@=PolyPolygon(HDC hdc, POINT *apt, INT *asz, int csz);
[PtInRegion]
1=HRGN hrgn
2=int x
3=int y
ParamCount=3
@=PtInRegion(HRGN hrgn, int x, int y);
[PtVisible]
1=HDC hdc
2=int x
3=int y
ParamCount=3
@=PtVisible(HDC hdc, int x, int y);
[RectInRegion]
1=HRGN hrgn
2=RECT *lprect
ParamCount=2
@=RectInRegion(HRGN hrgn, RECT *lprect);
[RectVisible]
1=HDC hdc
2=RECT *lprect
ParamCount=2
@=RectVisible(HDC hdc, RECT *lprect);
[Rectangle]
1=HDC hdc
2=int left
3=int top
4=int right
5=int bottom
ParamCount=5
@=Rectangle(HDC hdc, int left, int top, int right, int bottom);
[RestoreDC]
1=HDC hdc
2=int nSavedDC
ParamCount=2
@=RestoreDC(HDC hdc, int nSavedDC);
[ResetDCA]
1=HDC hdc
2=DEVMODEA *lpdm
ParamCount=2
@=ResetDCA(HDC hdc, DEVMODEA *lpdm);
[ResetDCW]
1=HDC hdc
2=DEVMODEW *lpdm
ParamCount=2
@=ResetDCW(HDC hdc, DEVMODEW *lpdm);
[RealizePalette]
1=HDC hdc
ParamCount=1
@=RealizePalette(HDC hdc);
[RemoveFontResourceA]
1=LPCSTR lpFileName
ParamCount=1
@=RemoveFontResourceA(LPCSTR lpFileName);
[RemoveFontResourceW]
1=LPCWSTR lpFileName
ParamCount=1
@=RemoveFontResourceW(LPCWSTR lpFileName);
[RoundRect]
1=HDC hdc
2=int left
3=int top
4=int right
5=int bottom
6=int width
7=int height
ParamCount=7
@=RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height);
[ResizePalette]
1=HPALETTE hpal
2=UINT n
ParamCount=2
@=ResizePalette(HPALETTE hpal, UINT n);
[SaveDC]
1=HDC hdc
ParamCount=1
@=SaveDC(HDC hdc);
[SelectClipRgn]
1=HDC hdc
2=HRGN hrgn
ParamCount=2
@=SelectClipRgn(HDC hdc, HRGN hrgn);
[ExtSelectClipRgn]
1=HDC hdc
2=HRGN hrgn
3=int mode
ParamCount=3
@=ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode);
[SetMetaRgn]
1=HDC hdc
ParamCount=1
@=SetMetaRgn(HDC hdc);
[SelectObject]
1=HDC hdc
2=HGDIOBJ h
ParamCount=2
@=SelectObject(HDC hdc, HGDIOBJ h);
[SelectPalette]
1=HDC hdc
2=HPALETTE hPal
3=BOOL bForceBkgd
ParamCount=3
@=SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd);
[SetBkColor]
1=HDC hdc
2=COLORREF color
ParamCount=2
@=SetBkColor(HDC hdc, COLORREF color);
[SetDCBrushColor]
1=HDC hdc
2=COLORREF color
ParamCount=2
@=SetDCBrushColor(HDC hdc, COLORREF color);
[SetDCPenColor]
1=HDC hdc
2=COLORREF color
ParamCount=2
@=SetDCPenColor(HDC hdc, COLORREF color);
[SetBkMode]
1=HDC hdc
2=int mode
ParamCount=2
@=SetBkMode(HDC hdc, int mode);
[SetBoundsRect]
1=HDC hdc
2=RECT *lprect
3=UINT flags
ParamCount=3
@=SetBoundsRect(HDC hdc, RECT *lprect, UINT flags);
[SetDIBits]
1=HDC hdc
2=HBITMAP hbm
3=UINT start
4=UINT cLines
5=VOID *lpBits
6=BITMAPINFO *lpbmi
7=UINT ColorUse
ParamCount=7
@=SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, VOID *lpBits, BITMAPINFO *lpbmi, UINT ColorUse);
[SetDIBitsToDevice]
1=HDC hdc
2=int xDest
3=int yDest
4=DWORD w
5=DWORD h
6=int xSrc
7=int ySrc
8=UINT StartScan
9=UINT cLines
10=VOID *lpvBits
11=BITMAPINFO *lpbmi
12=UINT ColorUse
ParamCount=12
@=SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, VOID *lpvBits, BITMAPINFO *lpbmi, UINT ColorUse);
[SetMapperFlags]
1=HDC hdc
2=DWORD flags
ParamCount=2
@=SetMapperFlags(HDC hdc, DWORD flags);
[SetGraphicsMode]
1=HDC hdc
2=int iMode
ParamCount=2
@=SetGraphicsMode(HDC hdc, int iMode);
[SetMapMode]
1=HDC hdc
2=int iMode
ParamCount=2
@=SetMapMode(HDC hdc, int iMode);
[SetLayout]
1=HDC hdc
2=DWORD l
ParamCount=2
@=SetLayout(HDC hdc, DWORD l);
[GetLayout]
1=HDC hdc
ParamCount=1
@=GetLayout(HDC hdc);
[SetMetaFileBitsEx]
1=UINT cbBuffer
2=BYTE *lpData
ParamCount=2
@=SetMetaFileBitsEx(UINT cbBuffer, BYTE *lpData);
[SetPaletteEntries]
1=HPALETTE hpal
2=UINT iStart
3=UINT cEntries
4=PALETTEENTRY *pPalEntries
ParamCount=4
@=SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, PALETTEENTRY *pPalEntries);
[SetPixel]
1=HDC hdc
2=int x
3=int y
4=COLORREF color
ParamCount=4
@=SetPixel(HDC hdc, int x, int y, COLORREF color);
[SetPixelV]
1=HDC hdc
2=int x
3=int y
4=COLORREF color
ParamCount=4
@=SetPixelV(HDC hdc, int x, int y, COLORREF color);
[SetPixelFormat]
1=HDC hdc
2=int format
3=PIXELFORMATDESCRIPTOR *ppfd
ParamCount=3
@=SetPixelFormat(HDC hdc, int format, PIXELFORMATDESCRIPTOR *ppfd);
[SetPolyFillMode]
1=HDC hdc
2=int mode
ParamCount=2
@=SetPolyFillMode(HDC hdc, int mode);
[StretchBlt]
1=HDC hdcDest
2=int xDest
3=int yDest
4=int wDest
5=int hDest
6=HDC hdcSrc
7=int xSrc
8=int ySrc
9=int wSrc
10=int hSrc
11=DWORD rop
ParamCount=11
@=StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
[SetRectRgn]
1=HRGN hrgn
2=int left
3=int top
4=int right
5=int bottom
ParamCount=5
@=SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom);
[StretchDIBits]
1=HDC hdc
2=int xDest
3=int yDest
4=int DestWidth
5=int DestHeight
6=int xSrc
7=int ySrc
8=int SrcWidth
9=int SrcHeight
10=VOID *lpBits
11=BITMAPINFO *lpbmi
12=UINT iUsage
13=DWORD rop
ParamCount=13
@=StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, VOID *lpBits, BITMAPINFO *lpbmi, UINT iUsage, DWORD rop);
[SetROP2]
1=HDC hdc
2=int rop2
ParamCount=2
@=SetROP2(HDC hdc, int rop2);
[SetStretchBltMode]
1=HDC hdc
2=int mode
ParamCount=2
@=SetStretchBltMode(HDC hdc, int mode);
[SetSystemPaletteUse]
1=HDC hdc
2=UINT use
ParamCount=2
@=SetSystemPaletteUse(HDC hdc, UINT use);
[SetTextCharacterExtra]
1=HDC hdc
2=int extra
ParamCount=2
@=SetTextCharacterExtra(HDC hdc, int extra);
[SetTextColor]
1=HDC hdc
2=COLORREF color
ParamCount=2
@=SetTextColor(HDC hdc, COLORREF color);
[SetTextAlign]
1=HDC hdc
2=UINT align
ParamCount=2
@=SetTextAlign(HDC hdc, UINT align);
[SetTextJustification]
1=HDC hdc
2=int extra
3=int count
ParamCount=3
@=SetTextJustification(HDC hdc, int extra, int count);
[UpdateColors]
1=HDC hdc
ParamCount=1
@=UpdateColors(HDC hdc);
[GdiRegisterDdraw]
1=PGDIREGISTERDDRAWPACKET pPacket
2=GDIMARSHALLOC *ppfnGdiAlloc
ParamCount=2
@=GdiRegisterDdraw(PGDIREGISTERDDRAWPACKET pPacket, GDIMARSHALLOC *ppfnGdiAlloc);
[GdiMarshalSize]
ParamCount=0
@=GdiMarshalSize();
[GdiMarshal]
1=DWORD dwProcessIdTo
2=HGDIOBJ hGdiObj
3=PVOID pData
4=ULONG ulFlags
ParamCount=4
@=GdiMarshal(DWORD dwProcessIdTo, HGDIOBJ hGdiObj, PVOID pData, ULONG ulFlags);
[GdiUnmarshal]
1=PVOID pData
2=ULONG ulFlags
ParamCount=2
@=GdiUnmarshal(PVOID pData, ULONG ulFlags);
[AlphaBlend]
1=HDC hdcDest
2=int xoriginDest
3=int yoriginDest
4=int wDest
5=int hDest
6=HDC hdcSrc
7=int xoriginSrc
8=int yoriginSrc
9=int wSrc
10=int hSrc
11=BLENDFUNCTION ftn
ParamCount=11
@=AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);
[TransparentBlt]
1=HDC hdcDest
2=int xoriginDest
3=int yoriginDest
4=int wDest
5=int hDest
6=HDC hdcSrc
7=int xoriginSrc
8=int yoriginSrc
9=int wSrc
10=int hSrc
11=UINT crTransparent
ParamCount=11
@=TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent);
[GradientFill]
1=HDC hdc
2=PTRIVERTEX pVertex
3=ULONG nVertex
4=PVOID pMesh
5=ULONG nMesh
6=ULONG ulMode
ParamCount=6
@=GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode);
[GdiAlphaBlend]
1=HDC hdcDest
2=int xoriginDest
3=int yoriginDest
4=int wDest
5=int hDest
6=HDC hdcSrc
7=int xoriginSrc
8=int yoriginSrc
9=int wSrc
10=int hSrc
11=BLENDFUNCTION ftn
ParamCount=11
@=GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);
[GdiTransparentBlt]
1=HDC hdcDest
2=int xoriginDest
3=int yoriginDest
4=int wDest
5=int hDest
6=HDC hdcSrc
7=int xoriginSrc
8=int yoriginSrc
9=int wSrc
10=int hSrc
11=UINT crTransparent
ParamCount=11
@=GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent);
[GdiGradientFill]
1=HDC hdc
2=PTRIVERTEX pVertex
3=ULONG nVertex
4=PVOID pMesh
5=ULONG nCount
6=ULONG ulMode
ParamCount=6
@=GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode);
[PlayMetaFileRecord]
1=HDC hdc
2=LPHANDLETABLE lpHandleTable
3=LPMETARECORD lpMR
4=UINT noObjs
ParamCount=4
@=PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs);
[EnumMetaFile]
1=HDC hdc
2=HMETAFILE hmf
3=MFENUMPROC proc
4=LPARAM param
ParamCount=4
@=EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param);
[CloseEnhMetaFile]
1=HDC hdc
ParamCount=1
@=CloseEnhMetaFile(HDC hdc);
[CopyEnhMetaFileA]
1=HENHMETAFILE hEnh
2=LPCSTR lpFileName
ParamCount=2
@=CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName);
[CopyEnhMetaFileW]
1=HENHMETAFILE hEnh
2=LPCWSTR lpFileName
ParamCount=2
@=CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName);
[CreateEnhMetaFileA]
1=HDC hdc
2=LPCSTR lpFilename
3=RECT *lprc
4=LPCSTR lpDesc
ParamCount=4
@=CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, RECT *lprc, LPCSTR lpDesc);
[CreateEnhMetaFileW]
1=HDC hdc
2=LPCWSTR lpFilename
3=RECT *lprc
4=LPCWSTR lpDesc
ParamCount=4
@=CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, RECT *lprc, LPCWSTR lpDesc);
[DeleteEnhMetaFile]
1=HENHMETAFILE hmf
ParamCount=1
@=DeleteEnhMetaFile(HENHMETAFILE hmf);
[EnumEnhMetaFile]
1=HDC hdc
2=HENHMETAFILE hmf
3=ENHMFENUMPROC proc
4=LPVOID param
5=RECT *lpRect
ParamCount=5
@=EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, RECT *lpRect);
[GetEnhMetaFileA]
1=LPCSTR lpName
ParamCount=1
@=GetEnhMetaFileA(LPCSTR lpName);
[GetEnhMetaFileW]
1=LPCWSTR lpName
ParamCount=1
@=GetEnhMetaFileW(LPCWSTR lpName);
[GetEnhMetaFileBits]
1=HENHMETAFILE hEMF
2=UINT nSize
3=LPBYTE lpData
ParamCount=3
@=GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData);
[GetEnhMetaFileDescriptionA]
1=HENHMETAFILE hemf
2=UINT cchBuffer
3=LPSTR lpDescription
ParamCount=3
@=GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription);
[GetEnhMetaFileDescriptionW]
1=HENHMETAFILE hemf
2=UINT cchBuffer
3=LPWSTR lpDescription
ParamCount=3
@=GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription);
[GetEnhMetaFileHeader]
1=HENHMETAFILE hemf
2=UINT nSize
3=LPENHMETAHEADER lpEnhMetaHeader
ParamCount=3
@=GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader);
[GetEnhMetaFilePaletteEntries]
1=HENHMETAFILE hemf
2=UINT nNumEntries
3=LPPALETTEENTRY lpPaletteEntries
ParamCount=3
@=GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries);
[GetEnhMetaFilePixelFormat]
1=HENHMETAFILE hemf
2=UINT cbBuffer
3=PIXELFORMATDESCRIPTOR *ppfd
ParamCount=3
@=GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd);
[GetWinMetaFileBits]
1=HENHMETAFILE hemf
2=UINT cbData16
3=LPBYTE pData16
4=INT iMapMode
5=HDC hdcRef
ParamCount=5
@=GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef);
[PlayEnhMetaFile]
1=HDC hdc
2=HENHMETAFILE hmf
3=RECT *lprect
ParamCount=3
@=PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, RECT *lprect);
[PlayEnhMetaFileRecord]
1=HDC hdc
2=LPHANDLETABLE pht
3=ENHMETARECORD *pmr
4=UINT cht
ParamCount=4
@=PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, ENHMETARECORD *pmr, UINT cht);
[SetEnhMetaFileBits]
1=UINT nSize
2=BYTE *pb
ParamCount=2
@=SetEnhMetaFileBits(UINT nSize, BYTE *pb);
[SetWinMetaFileBits]
1=UINT nSize
2=BYTE *lpMeta16Data
3=HDC hdcRef
4=METAFILEPICT *lpMFP
ParamCount=4
@=SetWinMetaFileBits(UINT nSize, BYTE *lpMeta16Data, HDC hdcRef, METAFILEPICT *lpMFP);
[GdiComment]
1=HDC hdc
2=UINT nSize
3=BYTE *lpData
ParamCount=3
@=GdiComment(HDC hdc, UINT nSize, BYTE *lpData);
[GetTextMetricsA]
1=HDC hdc
2=LPTEXTMETRICA lptm
ParamCount=2
@=GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm);
[GetTextMetricsW]
1=HDC hdc
2=LPTEXTMETRICW lptm
ParamCount=2
@=GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);
[AngleArc]
1=HDC hdc
2=int x
3=int y
4=DWORD r
5=FLOAT StartAngle
6=FLOAT SweepAngle
ParamCount=6
@=AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle);
[PolyPolyline]
1=HDC hdc
2=POINT *apt
3=DWORD *asz
4=DWORD csz
ParamCount=4
@=PolyPolyline(HDC hdc, POINT *apt, DWORD *asz, DWORD csz);
[GetWorldTransform]
1=HDC hdc
2=LPXFORM lpxf
ParamCount=2
@=GetWorldTransform(HDC hdc, LPXFORM lpxf);
[SetWorldTransform]
1=HDC hdc
2=XFORM *lpxf
ParamCount=2
@=SetWorldTransform(HDC hdc, XFORM *lpxf);
[ModifyWorldTransform]
1=HDC hdc
2=XFORM *lpxf
3=DWORD mode
ParamCount=3
@=ModifyWorldTransform(HDC hdc, XFORM *lpxf, DWORD mode);
[CombineTransform]
1=LPXFORM lpxfOut
2=XFORM *lpxf1
3=XFORM *lpxf2
ParamCount=3
@=CombineTransform(LPXFORM lpxfOut, XFORM *lpxf1, XFORM *lpxf2);
[CreateDIBSection]
1=HDC hdc
2=BITMAPINFO *lpbmi
3=UINT usage
4=VOID **ppvBits
5=HANDLE hSection
6=DWORD offset
ParamCount=6
@=CreateDIBSection(HDC hdc, BITMAPINFO *lpbmi, UINT usage, VOID **ppvBits, HANDLE hSection, DWORD offset);
[GetDIBColorTable]
1=HDC hdc
2=UINT iStart
3=UINT cEntries
4=RGBQUAD *prgbq
ParamCount=4
@=GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq);
[SetDIBColorTable]
1=HDC hdc
2=UINT iStart
3=UINT cEntries
4=RGBQUAD *prgbq
ParamCount=4
@=SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq);
[SetColorAdjustment]
1=HDC hdc
2=COLORADJUSTMENT *lpca
ParamCount=2
@=SetColorAdjustment(HDC hdc, COLORADJUSTMENT *lpca);
[GetColorAdjustment]
1=HDC hdc
2=LPCOLORADJUSTMENT lpca
ParamCount=2
@=GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca);
[CreateHalftonePalette]
1=HDC hdc
ParamCount=1
@=CreateHalftonePalette(HDC hdc);
[StartDocA]
1=HDC hdc
2=DOCINFOA *lpdi
ParamCount=2
@=StartDocA(HDC hdc, DOCINFOA *lpdi);
[StartDocW]
1=HDC hdc
2=DOCINFOW *lpdi
ParamCount=2
@=StartDocW(HDC hdc, DOCINFOW *lpdi);
[EndDoc]
1=HDC hdc
ParamCount=1
@=EndDoc(HDC hdc);
[StartPage]
1=HDC hdc
ParamCount=1
@=StartPage(HDC hdc);
[EndPage]
1=HDC hdc
ParamCount=1
@=EndPage(HDC hdc);
[AbortDoc]
1=HDC hdc
ParamCount=1
@=AbortDoc(HDC hdc);
[SetAbortProc]
1=HDC hdc
2=ABORTPROC proc
ParamCount=2
@=SetAbortProc(HDC hdc, ABORTPROC proc);
[AbortPath]
1=HDC hdc
ParamCount=1
@=AbortPath(HDC hdc);
[ArcTo]
1=HDC hdc
2=int left
3=int top
4=int right
5=int bottom
6=int xr1
7=int yr1
8=int xr2
9=int yr2
ParamCount=9
@=ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
[BeginPath]
1=HDC hdc
ParamCount=1
@=BeginPath(HDC hdc);
[CloseFigure]
1=HDC hdc
ParamCount=1
@=CloseFigure(HDC hdc);
[EndPath]
1=HDC hdc
ParamCount=1
@=EndPath(HDC hdc);
[FillPath]
1=HDC hdc
ParamCount=1
@=FillPath(HDC hdc);
[FlattenPath]
1=HDC hdc
ParamCount=1
@=FlattenPath(HDC hdc);
[GetPath]
1=HDC hdc
2=LPPOINT apt
3=LPBYTE aj
4=int cpt
ParamCount=4
@=GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt);
[PathToRegion]
1=HDC hdc
ParamCount=1
@=PathToRegion(HDC hdc);
[PolyDraw]
1=HDC hdc
2=POINT *apt
3=BYTE *aj
4=int cpt
ParamCount=4
@=PolyDraw(HDC hdc, POINT *apt, BYTE *aj, int cpt);
[SelectClipPath]
1=HDC hdc
2=int mode
ParamCount=2
@=SelectClipPath(HDC hdc, int mode);
[SetArcDirection]
1=HDC hdc
2=int dir
ParamCount=2
@=SetArcDirection(HDC hdc, int dir);
[SetMiterLimit]
1=HDC hdc
2=FLOAT limit
3=PFLOAT old
ParamCount=3
@=SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old);
[StrokeAndFillPath]
1=HDC hdc
ParamCount=1
@=StrokeAndFillPath(HDC hdc);
[StrokePath]
1=HDC hdc
ParamCount=1
@=StrokePath(HDC hdc);
[WidenPath]
1=HDC hdc
ParamCount=1
@=WidenPath(HDC hdc);
[ExtCreatePen]
1=DWORD iPenStyle
2=DWORD cWidth
3=LOGBRUSH *plbrush
4=DWORD cStyle
5=DWORD *pstyle
ParamCount=5
@=ExtCreatePen(DWORD iPenStyle, DWORD cWidth, LOGBRUSH *plbrush, DWORD cStyle, DWORD *pstyle);
[GetMiterLimit]
1=HDC hdc
2=PFLOAT plimit
ParamCount=2
@=GetMiterLimit(HDC hdc, PFLOAT plimit);
[GetArcDirection]
1=HDC hdc
ParamCount=1
@=GetArcDirection(HDC hdc);
[GetObjectA]
1=HANDLE h
2=int c
3=LPVOID pv
ParamCount=3
@=GetObjectA(HANDLE h, int c, LPVOID pv);
[GetObjectW]
1=HANDLE h
2=int c
3=LPVOID pv
ParamCount=3
@=GetObjectW(HANDLE h, int c, LPVOID pv);
[MoveToEx]
1=HDC hdc
2=int x
3=int y
4=LPPOINT lppt
ParamCount=4
@=MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
[TextOutA]
1=HDC hdc
2=int x
3=int y
4=LPCSTR lpString
5=int c
ParamCount=5
@=TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c);
[TextOutW]
1=HDC hdc
2=int x
3=int y
4=LPCWSTR lpString
5=int c
ParamCount=5
@=TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c);
[ExtTextOutA]
1=HDC hdc
2=int x
3=int y
4=UINT options
5=RECT *lprect
6=LPCSTR lpString
7=UINT c
8=INT *lpDx
ParamCount=8
@=ExtTextOutA(HDC hdc, int x, int y, UINT options, RECT *lprect, LPCSTR lpString, UINT c, INT *lpDx);
[ExtTextOutW]
1=HDC hdc
2=int x
3=int y
4=UINT options
5=RECT *lprect
6=LPCWSTR lpString
7=UINT c
8=INT *lpDx
ParamCount=8
@=ExtTextOutW(HDC hdc, int x, int y, UINT options, RECT *lprect, LPCWSTR lpString, UINT c, INT *lpDx);
[PolyTextOutA]
1=HDC hdc
2=POLYTEXTA *ppt
3=int nstrings
ParamCount=3
@=PolyTextOutA(HDC hdc, POLYTEXTA *ppt, int nstrings);
[PolyTextOutW]
1=HDC hdc
2=POLYTEXTW *ppt
3=int nstrings
ParamCount=3
@=PolyTextOutW(HDC hdc, POLYTEXTW *ppt, int nstrings);
[CreatePolygonRgn]
1=POINT *pptl
2=int cPoint
3=int iMode
ParamCount=3
@=CreatePolygonRgn(POINT *pptl, int cPoint, int iMode);
[DPtoLP]
1=HDC hdc
2=LPPOINT lppt
3=int c
ParamCount=3
@=DPtoLP(HDC hdc, LPPOINT lppt, int c);
[LPtoDP]
1=HDC hdc
2=LPPOINT lppt
3=int c
ParamCount=3
@=LPtoDP(HDC hdc, LPPOINT lppt, int c);
[Polygon]
1=HDC hdc
2=POINT *apt
3=int cpt
ParamCount=3
@=Polygon(HDC hdc, POINT *apt, int cpt);
[Polyline]
1=HDC hdc
2=POINT *apt
3=int cpt
ParamCount=3
@=Polyline(HDC hdc, POINT *apt, int cpt);
[PolyBezier]
1=HDC hdc
2=POINT *apt
3=DWORD cpt
ParamCount=3
@=PolyBezier(HDC hdc, POINT *apt, DWORD cpt);
[PolyBezierTo]
1=HDC hdc
2=POINT *apt
3=DWORD cpt
ParamCount=3
@=PolyBezierTo(HDC hdc, POINT *apt, DWORD cpt);
[PolylineTo]
1=HDC hdc
2=POINT *apt
3=DWORD cpt
ParamCount=3
@=PolylineTo(HDC hdc, POINT *apt, DWORD cpt);
[SetViewportExtEx]
1=HDC hdc
2=int x
3=int y
4=LPSIZE lpsz
ParamCount=4
@=SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz);
[SetViewportOrgEx]
1=HDC hdc
2=int x
3=int y
4=LPPOINT lppt
ParamCount=4
@=SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
[SetWindowExtEx]
1=HDC hdc
2=int x
3=int y
4=LPSIZE lpsz
ParamCount=4
@=SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz);
[SetWindowOrgEx]
1=HDC hdc
2=int x
3=int y
4=LPPOINT lppt
ParamCount=4
@=SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
[OffsetViewportOrgEx]
1=HDC hdc
2=int x
3=int y
4=LPPOINT lppt
ParamCount=4
@=OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
[OffsetWindowOrgEx]
1=HDC hdc
2=int x
3=int y
4=LPPOINT lppt
ParamCount=4
@=OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
[ScaleViewportExtEx]
1=HDC hdc
2=int xn
3=int dx
4=int yn
5=int yd
6=LPSIZE lpsz
ParamCount=6
@=ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz);
[ScaleWindowExtEx]
1=HDC hdc
2=int xn
3=int xd
4=int yn
5=int yd
6=LPSIZE lpsz
ParamCount=6
@=ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz);
[SetBitmapDimensionEx]
1=HBITMAP hbm
2=int w
3=int h
4=LPSIZE lpsz
ParamCount=4
@=SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz);
[SetBrushOrgEx]
1=HDC hdc
2=int x
3=int y
4=LPPOINT lppt
ParamCount=4
@=SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
[GetTextFaceA]
1=HDC hdc
2=int c
3= LPSTRlpName
ParamCount=3
@=GetTextFaceA(HDC hdc, int c,  LPSTRlpName);
[GetTextFaceW]
1=HDC hdc
2=int c
3= LPWSTRlpName
ParamCount=3
@=GetTextFaceW(HDC hdc, int c,  LPWSTRlpName);
[GetKerningPairsA]
1=HDC hdc
2=DWORD nPairs
3=LPKERNINGPAIR lpKernPair
ParamCount=3
@=GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair);
[GetKerningPairsW]
1=HDC hdc
2=DWORD nPairs
3=LPKERNINGPAIR lpKernPair
ParamCount=3
@=GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair);
[GetDCOrgEx]
1=HDC hdc
2=LPPOINT lppt
ParamCount=2
@=GetDCOrgEx(HDC hdc, LPPOINT lppt);
[FixBrushOrgEx]
1=HDC hdc
2=int x
3=int y
4=LPPOINT ptl
ParamCount=4
@=FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl);
[UnrealizeObject]
1=HGDIOBJ h
ParamCount=1
@=UnrealizeObject(HGDIOBJ h);
[GdiFlush]
ParamCount=0
@=GdiFlush();
[GdiSetBatchLimit]
1=DWORD dw
ParamCount=1
@=GdiSetBatchLimit(DWORD dw);
[GdiGetBatchLimit]
ParamCount=0
@=GdiGetBatchLimit();
[SetICMMode]
1=HDC hdc
2=int mode
ParamCount=2
@=SetICMMode(HDC hdc, int mode);
[CheckColorsInGamut]
1=HDC hdc
2=LPRGBTRIPLE lpRGBTriple
3=LPVOID dlpBuffer
4=DWORD nCount
ParamCount=4
@=CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount);
[GetColorSpace]
1=HDC hdc
ParamCount=1
@=GetColorSpace(HDC hdc);
[GetLogColorSpaceA]
1=HCOLORSPACE hColorSpace
2=LPLOGCOLORSPACEA lpBuffer
3=DWORD nSize
ParamCount=3
@=GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize);
[GetLogColorSpaceW]
1=HCOLORSPACE hColorSpace
2=LPLOGCOLORSPACEW lpBuffer
3=DWORD nSize
ParamCount=3
@=GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize);
[CreateColorSpaceA]
1=LPLOGCOLORSPACEA lplcs
ParamCount=1
@=CreateColorSpaceA(LPLOGCOLORSPACEA lplcs);
[CreateColorSpaceW]
1=LPLOGCOLORSPACEW lplcs
ParamCount=1
@=CreateColorSpaceW(LPLOGCOLORSPACEW lplcs);
[SetColorSpace]
1=HDC hdc
2=HCOLORSPACE hcs
ParamCount=2
@=SetColorSpace(HDC hdc, HCOLORSPACE hcs);
[DeleteColorSpace]
1=HCOLORSPACE hcs
ParamCount=1
@=DeleteColorSpace(HCOLORSPACE hcs);
[GetICMProfileA]
1=HDC hdc
2=LPDWORD pBufSize
3=LPSTR pszFilename
ParamCount=3
@=GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename);
[GetICMProfileW]
1=HDC hdc
2=LPDWORD pBufSize
3=LPWSTR pszFilename
ParamCount=3
@=GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename);
[SetICMProfileA]
1=HDC hdc
2=LPSTR lpFileName
ParamCount=2
@=SetICMProfileA(HDC hdc, LPSTR lpFileName);
[SetICMProfileW]
1=HDC hdc
2=LPWSTR lpFileName
ParamCount=2
@=SetICMProfileW(HDC hdc, LPWSTR lpFileName);
[GetDeviceGammaRamp]
1=HDC hdc
2=LPVOID lpRamp
ParamCount=2
@=GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp);
[SetDeviceGammaRamp]
1=HDC hdc
2=LPVOID lpRamp
ParamCount=2
@=SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp);
[ColorMatchToTarget]
1=HDC hdc
2=HDC hdcTarget
3=DWORD action
ParamCount=3
@=ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action);
[EnumICMProfilesA]
1=HDC hdc
2=ICMENUMPROCA proc
3=LPARAM param
ParamCount=3
@=EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param);
[EnumICMProfilesW]
1=HDC hdc
2=ICMENUMPROCW proc
3=LPARAM param
ParamCount=3
@=EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param);
[UpdateICMRegKeyA]
1=DWORD reserved
2=LPSTR lpszCMID
3=LPSTR lpszFileName
4=UINT command
ParamCount=4
@=UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command);
[UpdateICMRegKeyW]
1=DWORD reserved
2=LPWSTR lpszCMID
3=LPWSTR lpszFileName
4=UINT command
ParamCount=4
@=UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command);
[ColorCorrectPalette]
1=HDC hdc
2=HPALETTE hPal
3=DWORD deFirst
4=DWORD num
ParamCount=4
@=ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num);
[wglCopyContext]
1=HGLRC
2=HGLRC
3=UINT
ParamCount=3
@=wglCopyContext(HGLRC, HGLRC, UINT);
[wglCreateContext]
1=HDC
ParamCount=1
@=wglCreateContext(HDC);
[wglCreateLayerContext]
1=HDC
2=int
ParamCount=2
@=wglCreateLayerContext(HDC, int);
[wglDeleteContext]
1=HGLRC
ParamCount=1
@=wglDeleteContext(HGLRC);
[wglGetCurrentContext]
ParamCount=0
@=wglGetCurrentContext();
[wglGetCurrentDC]
ParamCount=0
@=wglGetCurrentDC();
[wglGetProcAddress]
1=LPCSTR
ParamCount=1
@=wglGetProcAddress(LPCSTR);
[wglMakeCurrent]
1=HDC
2=HGLRC
ParamCount=2
@=wglMakeCurrent(HDC, HGLRC);
[wglShareLists]
1=HGLRC
2=HGLRC
ParamCount=2
@=wglShareLists(HGLRC, HGLRC);
[wglUseFontBitmapsA]
1=HDC
2=DWORD
3=DWORD
4=DWORD
ParamCount=4
@=wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
[wglUseFontBitmapsW]
1=HDC
2=DWORD
3=DWORD
4=DWORD
ParamCount=4
@=wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);
[SwapBuffers]
1=HDC
ParamCount=1
@=SwapBuffers(HDC);
[wglUseFontOutlinesA]
1=HDC
2=DWORD
3=DWORD
4=DWORD
5=FLOAT
6=FLOAT
7=int
8=LPGLYPHMETRICSFLOAT
ParamCount=8
@=wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT);
[wglUseFontOutlinesW]
1=HDC
2=DWORD
3=DWORD
4=DWORD
5=FLOAT
6=FLOAT
7=int
8=LPGLYPHMETRICSFLOAT
ParamCount=8
@=wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT);
[wglDescribeLayerPlane]
1=HDC
2=int
3=int
4=UINT
5=LPLAYERPLANEDESCRIPTOR
ParamCount=5
@=wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR);
[wglSetLayerPaletteEntries]
1=HDC
2=int
3=int
4=int
5=CONST COLORREF*
ParamCount=5
@=wglSetLayerPaletteEntries(HDC, int, int, int, CONST COLORREF*);
[wglGetLayerPaletteEntries]
1=HDC
2=int
3=int
4=int
5=COLORREF *
ParamCount=5
@=wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *);
[wglRealizeLayerPalette]
1=HDC
2=int
3=BOOL
ParamCount=3
@=wglRealizeLayerPalette(HDC, int, BOOL);
[wglSwapLayerBuffers]
1=HDC
2=UINT
ParamCount=2
@=wglSwapLayerBuffers(HDC, UINT);
[wglSwapMultipleBuffers]
1=UINT
2=CONST WGLSWAP*
ParamCount=2
@=wglSwapMultipleBuffers(UINT, CONST WGLSWAP*);



================================================
File: api-definitions/gdiplus.api
================================================
[GdipCreatePath]
1=GpFillMode brushMode
2=GpPath **path
ParamCount=2
@=GdipCreatePath(GpFillMode brushMode, GpPath **path);
[GdipCreatePath2]
1=GDIPCONST GpPointF*
2=GDIPCONST BYTE*
3=INT
4=GpFillMode
5=GpPath **path
ParamCount=5
@=GdipCreatePath2(GDIPCONST GpPointF*, GDIPCONST BYTE*, INT, GpFillMode, GpPath **path);
[GdipCreatePath2I]
1=GDIPCONST GpPoint*
2=GDIPCONST BYTE*
3=INT
4=GpFillMode
5=GpPath **path
ParamCount=5
@=GdipCreatePath2I(GDIPCONST GpPoint*, GDIPCONST BYTE*, INT, GpFillMode, GpPath **path);
[GdipClonePath]
1=GpPath *path
2=GpPath **clonePath
ParamCount=2
@=GdipClonePath(GpPath* path, GpPath **clonePath);
[GdipDeletePath]
1=GpPath *path
ParamCount=1
@=GdipDeletePath(GpPath *path);
[GdipResetPath]
1=GpPath *path
ParamCount=1
@=GdipResetPath(GpPath *path);
[GdipGetPointCount]
1=GpPath *path
2=INT* count
ParamCount=2
@=GdipGetPointCount(GpPath *path, INT* count);
[GdipGetPathTypes]
1=GpPath *path
2=BYTE* types
3=INT count
ParamCount=3
@=GdipGetPathTypes(GpPath *path, BYTE* types, INT count);
[GdipGetPathPoints]
1=GpPath *path
2=GpPointF *points
3=INT count
ParamCount=3
@=GdipGetPathPoints(GpPath *path, GpPointF *points, INT count);
[GdipGetPathPointsI]
1=GpPath *path
2=GpPoint *points
3=INT count
ParamCount=3
@=GdipGetPathPointsI(GpPath *path, GpPoint *points, INT count);
[GdipGetPathFillMode]
1=GpPath *path
2=GpFillMode *fillmode
ParamCount=2
@=GdipGetPathFillMode(GpPath *path, GpFillMode *fillmode);
[GdipSetPathFillMode]
1=GpPath *path
2=GpFillMode fillmode
ParamCount=2
@=GdipSetPathFillMode(GpPath *path, GpFillMode fillmode);
[GdipGetPathData]
1=GpPath *path
2=GpPathData *pathData
ParamCount=2
@=GdipGetPathData(GpPath *path, GpPathData *pathData);
[GdipStartPathFigure]
1=GpPath *path
ParamCount=1
@=GdipStartPathFigure(GpPath *path);
[GdipClosePathFigure]
1=GpPath *path
ParamCount=1
@=GdipClosePathFigure(GpPath *path);
[GdipClosePathFigures]
1=GpPath *path
ParamCount=1
@=GdipClosePathFigures(GpPath *path);
[GdipSetPathMarker]
1=GpPath *path
ParamCount=1
@=GdipSetPathMarker(GpPath *path);
[GdipClearPathMarkers]
1=GpPath *path
ParamCount=1
@=GdipClearPathMarkers(GpPath *path);
[GdipReversePath]
1=GpPath* path
ParamCount=1
@=GdipReversePath(GpPath *path);
[GdipGetPathLastPoint]
1=GpPath *path
2=GpPointF *lastPoint
ParamCount=2
@=GdipGetPathLastPoint(GpPath *path, GpPointF *lastPoint);
[GdipAddPathLine]
1=GpPath *path
2=REAL x1
3=REAL y1
4=REAL x2
5=REAL y2
ParamCount=5
@=GdipAddPathLine(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2);
[GdipAddPathLine2]
1=GpPath *path
2=GDIPCONST GpPointF *points
3=INT count
ParamCount=3
@=GdipAddPathLine2(GpPath *path, GDIPCONST GpPointF *points, INT count);
[GdipAddPathArc]
1=GpPath *path
2=REAL x
3=REAL y
4=REAL width
5=REAL height
6=REAL startAngle
7=REAL sweepAngle
ParamCount=7
@=GdipAddPathArc(GpPath *path, REAL x, REAL y, REAL width, REAL height, REAL startAngle, REAL sweepAngle);
[GdipAddPathBezier]
1=GpPath *path
2=REAL x1
3=REAL y1
4=REAL x2
5=REAL y2
6=REAL x3
7=REAL y3
8=REAL x4
9=REAL y4
ParamCount=9
@=GdipAddPathBezier(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2, REAL x3, REAL y3, REAL x4, REAL y4);
[GdipAddPathBeziers]
1=GpPath *path
2=GDIPCONST GpPointF *points
3=INT count
ParamCount=3
@=GdipAddPathBeziers(GpPath *path, GDIPCONST GpPointF *points, INT count);
[GdipAddPathCurve]
1=GpPath *path
2=GDIPCONST GpPointF *points
3=INT count
ParamCount=3
@=GdipAddPathCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);
[GdipAddPathCurve2]
1=GpPath *path
2=GDIPCONST GpPointF *points
3=INT count
4=REAL tension
ParamCount=4
@=GdipAddPathCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count, REAL tension);
[GdipAddPathCurve3]
1=GpPath *path
2=GDIPCONST GpPointF *points
3=INT count
4=INT offset
5=INT numberOfSegments
6=REAL tension
ParamCount=6
@=GdipAddPathCurve3(GpPath *path, GDIPCONST GpPointF *points, INT count, INT offset, INT numberOfSegments, REAL tension);
[GdipAddPathClosedCurve]
1=GpPath *path
2=GDIPCONST GpPointF *points
3=INT count
ParamCount=3
@=GdipAddPathClosedCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);
[GdipAddPathClosedCurve2]
1=GpPath *path
2=GDIPCONST GpPointF *points
3=INT count
4=REAL tension
ParamCount=4
@=GdipAddPathClosedCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count, REAL tension);
[GdipAddPathRectangle]
1=GpPath *path
2=REAL x
3=REAL y
4=REAL width
5=REAL height
ParamCount=5
@=GdipAddPathRectangle(GpPath *path, REAL x, REAL y, REAL width, REAL height);
[GdipAddPathRectangles]
1=GpPath *path
2=GDIPCONST GpRectF *rects
3=INT count
ParamCount=3
@=GdipAddPathRectangles(GpPath *path, GDIPCONST GpRectF *rects, INT count);
[GdipAddPathEllipse]
1=GpPath *path
2=REAL x
3=REAL y
4=REAL width
5=REAL height
ParamCount=5
@=GdipAddPathEllipse(GpPath *path, REAL x, REAL y, REAL width, REAL height);
[GdipAddPathPie]
1=GpPath *path
2=REAL x
3=REAL y
4=REAL width
5=REAL height
6=REAL startAngle
7=REAL sweepAngle
ParamCount=7
@=GdipAddPathPie(GpPath *path, REAL x, REAL y, REAL width, REAL height, REAL startAngle, REAL sweepAngle);
[GdipAddPathPolygon]
1=GpPath *path
2=GDIPCONST GpPointF *points
3=INT count
ParamCount=3
@=GdipAddPathPolygon(GpPath *path, GDIPCONST GpPointF *points, INT count);
[GdipAddPathPath]
1=GpPath *path
2=GDIPCONST GpPath *addingPath
3=BOOL connect
ParamCount=3
@=GdipAddPathPath(GpPath *path, GDIPCONST GpPath *addingPath, BOOL connect);
[GdipAddPathString]
1=GpPath *path
2=GDIPCONST WCHAR *string
3=INT length
4=GDIPCONST GpFontFamily *family
5=INT style
6=REAL emSize
7=GDIPCONST RectF *layoutRect
8=GDIPCONST GpStringFormat *format
ParamCount=8
@=GdipAddPathString(GpPath *path, GDIPCONST WCHAR *string, INT length, GDIPCONST GpFontFamily *family, INT style, REAL emSize, GDIPCONST RectF *layoutRect, GDIPCONST GpStringFormat *format);
[GdipAddPathStringI]
1=GpPath *path
2=GDIPCONST WCHAR *string
3=INT length
4=GDIPCONST GpFontFamily *family
5=INT style
6=REAL emSize
7=GDIPCONST Rect *layoutRect
8=GDIPCONST GpStringFormat *format
ParamCount=8
@=GdipAddPathStringI(GpPath *path, GDIPCONST WCHAR *string, INT length, GDIPCONST GpFontFamily *family, INT style, REAL emSize, GDIPCONST Rect *layoutRect, GDIPCONST GpStringFormat *format);
[GdipAddPathLineI]
1=GpPath *path
2=INT x1
3=INT y1
4=INT x2
5=INT y2
ParamCount=5
@=GdipAddPathLineI(GpPath *path, INT x1, INT y1, INT x2, INT y2);
[GdipAddPathLine2I]
1=GpPath *path
2=GDIPCONST GpPoint *points
3=INT count
ParamCount=3
@=GdipAddPathLine2I(GpPath *path, GDIPCONST GpPoint *points, INT count);
[GdipAddPathArcI]
1=GpPath *path
2=INT x
3=INT y
4=INT width
5=INT height
6=REAL startAngle
7=REAL sweepAngle
ParamCount=7
@=GdipAddPathArcI(GpPath *path, INT x, INT y, INT width, INT height, REAL startAngle, REAL sweepAngle);
[GdipAddPathBezierI]
1=GpPath *path
2=INT x1
3=INT y1
4=INT x2
5=INT y2
6=INT x3
7=INT y3
8=INT x4
9=INT y4
ParamCount=9
@=GdipAddPathBezierI(GpPath *path, INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);
[GdipAddPathBeziersI]
1=GpPath *path
2=GDIPCONST GpPoint *points
3=INT count
ParamCount=3
@=GdipAddPathBeziersI(GpPath *path, GDIPCONST GpPoint *points, INT count);
[GdipAddPathCurveI]
1=GpPath *path
2=GDIPCONST GpPoint *points
3=INT count
ParamCount=3
@=GdipAddPathCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);
[GdipAddPathCurve2I]
1=GpPath *path
2=GDIPCONST GpPoint *points
3=INT count
4=REAL tension
ParamCount=4
@=GdipAddPathCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count, REAL tension);
[GdipAddPathCurve3I]
1=GpPath *path
2=GDIPCONST GpPoint *points
3=INT count
4=INT offset
5=INT numberOfSegments
6=REAL tension
ParamCount=6
@=GdipAddPathCurve3I(GpPath *path, GDIPCONST GpPoint *points, INT count, INT offset, INT numberOfSegments, REAL tension);
[GdipAddPathClosedCurveI]
1=GpPath *path
2=GDIPCONST GpPoint *points
3=INT count
ParamCount=3
@=GdipAddPathClosedCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);
[GdipAddPathClosedCurve2I]
1=GpPath *path
2=GDIPCONST GpPoint *points
3=INT count
4=REAL tension
ParamCount=4
@=GdipAddPathClosedCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count, REAL tension);
[GdipAddPathRectangleI]
1=GpPath *path
2=INT x
3=INT y
4=INT width
5=INT height
ParamCount=5
@=GdipAddPathRectangleI(GpPath *path, INT x, INT y, INT width, INT height);
[GdipAddPathRectanglesI]
1=GpPath *path
2=GDIPCONST GpRect *rects
3=INT count
ParamCount=3
@=GdipAddPathRectanglesI(GpPath *path, GDIPCONST GpRect *rects, INT count);
[GdipAddPathEllipseI]
1=GpPath *path
2=INT x
3=INT y
4=INT width
5=INT height
ParamCount=5
@=GdipAddPathEllipseI(GpPath *path, INT x, INT y, INT width, INT height);
[GdipAddPathPieI]
1=GpPath *path
2=INT x
3=INT y
4=INT width
5=INT height
6=REAL startAngle
7=REAL sweepAngle
ParamCount=7
@=GdipAddPathPieI(GpPath *path, INT x, INT y, INT width, INT height, REAL startAngle, REAL sweepAngle);
[GdipAddPathPolygonI]
1=GpPath *path
2=GDIPCONST GpPoint *points
3=INT count
ParamCount=3
@=GdipAddPathPolygonI(GpPath *path, GDIPCONST GpPoint *points, INT count);
[GdipFlattenPath]
1=GpPath *path
2=GpMatrix *matrix
3=REAL flatness
ParamCount=3
@=GdipFlattenPath(GpPath *path, GpMatrix *matrix, REAL flatness);
[GdipWindingModeOutline]
1=GpPath *path
2=GpMatrix *matrix
3=REAL flatness
ParamCount=3
@=GdipWindingModeOutline(GpPath *path, GpMatrix *matrix, REAL flatness);
[GdipWidenPath]
1=GpPath *nativePath
2=GpPen *pen
3=GpMatrix *matrix
4=REAL flatness
ParamCount=4
@=GdipWidenPath(GpPath *nativePath, GpPen *pen, GpMatrix *matrix, REAL flatness);
[GdipWarpPath]
1=GpPath *path
2=GpMatrix *matrix
3=GDIPCONST GpPointF *points
4=INT count
5=REAL srcx
6=REAL srcy
7=REAL srcwidth
8=REAL srcheight
9=WarpMode warpMode
10=REAL flatness
ParamCount=10
@=GdipWarpPath(GpPath *path, GpMatrix *matrix, GDIPCONST GpPointF *points, INT count, REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight, WarpMode warpMode, REAL flatness);
[GdipTransformPath]
1=GpPath *path
2=GpMatrix *matrix
ParamCount=2
@=GdipTransformPath(GpPath *path, GpMatrix *matrix);
[GdipGetPathWorldBounds]
1=GpPath *path
2=GpRectF *bounds
3=GDIPCONST GpMatrix *matrix
4=GDIPCONST GpPen *pen
ParamCount=4
@=GdipGetPathWorldBounds(GpPath *path, GpRectF *bounds, GDIPCONST GpMatrix *matrix, GDIPCONST GpPen *pen);
[GdipGetPathWorldBoundsI]
1=GpPath *path
2=GpRect *bounds
3=GDIPCONST GpMatrix *matrix
4=GDIPCONST GpPen *pen
ParamCount=4
@=GdipGetPathWorldBoundsI(GpPath *path, GpRect *bounds, GDIPCONST GpMatrix *matrix, GDIPCONST GpPen *pen);
[GdipIsVisiblePathPoint]
1=GpPath *path
2=REAL x
3=REAL y
4=GpGraphics *graphics
5=BOOL *result
ParamCount=5
@=GdipIsVisiblePathPoint(GpPath *path, REAL x, REAL y, GpGraphics *graphics, BOOL *result);
[GdipIsVisiblePathPointI]
1=GpPath* path
2=INT x
3=INT y
4=GpGraphics *graphics
5=BOOL *result
ParamCount=5
@=GdipIsVisiblePathPointI(GpPath* path, INT x, INT y, GpGraphics *graphics, BOOL *result);
[GdipIsOutlineVisiblePathPoint]
1=GpPath *path
2=REAL x
3=REAL y
4=GpPen *pen
5=GpGraphics *graphics
6=BOOL *result
ParamCount=6
@=GdipIsOutlineVisiblePathPoint(GpPath *path, REAL x, REAL y, GpPen *pen, GpGraphics *graphics, BOOL *result);
[GdipIsOutlineVisiblePathPointI]
1=GpPath *path
2=INT x
3=INT y
4=GpPen *pen
5=GpGraphics *graphics
6=BOOL *result
ParamCount=6
@=GdipIsOutlineVisiblePathPointI(GpPath *path, INT x, INT y, GpPen *pen, GpGraphics *graphics, BOOL *result);
[GdipCreatePathIter]
1=GpPathIterator **iterator
2=GpPath *path
ParamCount=2
@=GdipCreatePathIter(GpPathIterator **iterator, GpPath *path);
[GdipDeletePathIter]
1=GpPathIterator *iterator
ParamCount=1
@=GdipDeletePathIter(GpPathIterator *iterator);
[GdipPathIterNextSubpath]
1=GpPathIterator *iterator
2=INT *resultCount
3=INT *startIndex
4=INT *endIndex
5=BOOL *isClosed
ParamCount=5
@=GdipPathIterNextSubpath(GpPathIterator *iterator, INT *resultCount, INT *startIndex, INT *endIndex, BOOL *isClosed);
[GdipPathIterNextSubpathPath]
1=GpPathIterator *iterator
2=INT *resultCount
3=GpPath *path
4=BOOL *isClosed
ParamCount=4
@=GdipPathIterNextSubpathPath(GpPathIterator *iterator, INT *resultCount, GpPath *path, BOOL *isClosed);
[GdipPathIterNextPathType]
1=GpPathIterator *iterator
2=INT *resultCount
3=BYTE *pathType
4=INT *startIndex
5=INT *endIndex
ParamCount=5
@=GdipPathIterNextPathType(GpPathIterator *iterator, INT *resultCount, BYTE *pathType, INT *startIndex, INT *endIndex);
[GdipPathIterNextMarker]
1=GpPathIterator *iterator
2=INT *resultCount
3=INT *startIndex
4=INT *endIndex
ParamCount=4
@=GdipPathIterNextMarker(GpPathIterator *iterator, INT *resultCount, INT *startIndex, INT *endIndex);
[GdipPathIterNextMarkerPath]
1=GpPathIterator *iterator
2=INT *resultCount
3=GpPath *path
ParamCount=3
@=GdipPathIterNextMarkerPath(GpPathIterator *iterator, INT *resultCount, GpPath *path);
[GdipPathIterGetCount]
1=GpPathIterator *iterator
2=INT *count
ParamCount=2
@=GdipPathIterGetCount(GpPathIterator *iterator, INT *count);
[GdipPathIterGetSubpathCount]
1=GpPathIterator *iterator
2=INT *count
ParamCount=2
@=GdipPathIterGetSubpathCount(GpPathIterator *iterator, INT *count);
[GdipPathIterIsValid]
1=GpPathIterator *iterator
2=BOOL *valid
ParamCount=2
@=GdipPathIterIsValid(GpPathIterator *iterator, BOOL *valid);
[GdipPathIterHasCurve]
1=GpPathIterator *iterator
2=BOOL *hasCurve
ParamCount=2
@=GdipPathIterHasCurve(GpPathIterator *iterator, BOOL *hasCurve);
[GdipPathIterRewind]
1=GpPathIterator *iterator
ParamCount=1
@=GdipPathIterRewind(GpPathIterator *iterator);
[GdipPathIterEnumerate]
1=GpPathIterator *iterator
2=INT *resultCount
3=GpPointF *points
4=BYTE *types
5=INT count
ParamCount=5
@=GdipPathIterEnumerate(GpPathIterator *iterator, INT *resultCount, GpPointF *points, BYTE *types, INT count);
[GdipPathIterCopyData]
1=GpPathIterator *iterator
2=INT *resultCount
3=GpPointF *points
4=BYTE *types
5=INT startIndex
6=INT endIndex
ParamCount=6
@=GdipPathIterCopyData(GpPathIterator *iterator, INT *resultCount, GpPointF *points, BYTE *types, INT startIndex, INT endIndex);
[GdipCreateMatrix]
1=GpMatrix **matrix
ParamCount=1
@=GdipCreateMatrix(GpMatrix **matrix);
[GdipCreateMatrix2]
1=REAL m11
2=REAL m12
3=REAL m21
4=REAL m22
5=REAL dx
6=REAL dy
7=GpMatrix **matrix
ParamCount=7
@=GdipCreateMatrix2(REAL m11, REAL m12, REAL m21, REAL m22, REAL dx, REAL dy, GpMatrix **matrix);
[GdipCreateMatrix3]
1=GDIPCONST GpRectF *rect
2=GDIPCONST GpPointF *dstplg
3=GpMatrix **matrix
ParamCount=3
@=GdipCreateMatrix3(GDIPCONST GpRectF *rect, GDIPCONST GpPointF *dstplg, GpMatrix **matrix);
[GdipCreateMatrix3I]
1=GDIPCONST GpRect *rect
2=GDIPCONST GpPoint *dstplg
3=GpMatrix **matrix
ParamCount=3
@=GdipCreateMatrix3I(GDIPCONST GpRect *rect, GDIPCONST GpPoint *dstplg, GpMatrix **matrix);
[GdipCloneMatrix]
1=GpMatrix *matrix
2=GpMatrix **cloneMatrix
ParamCount=2
@=GdipCloneMatrix(GpMatrix *matrix, GpMatrix **cloneMatrix);
[GdipDeleteMatrix]
1=GpMatrix *matrix
ParamCount=1
@=GdipDeleteMatrix(GpMatrix *matrix);
[GdipSetMatrixElements]
1=GpMatrix *matrix
2=REAL m11
3=REAL m12
4=REAL m21
5=REAL m22
6=REAL dx
7=REAL dy
ParamCount=7
@=GdipSetMatrixElements(GpMatrix *matrix, REAL m11, REAL m12, REAL m21, REAL m22, REAL dx, REAL dy);
[GdipMultiplyMatrix]
1=GpMatrix *matrix
2=GpMatrix* matrix2
3=GpMatrixOrder order
ParamCount=3
@=GdipMultiplyMatrix(GpMatrix *matrix, GpMatrix* matrix2, GpMatrixOrder order);
[GdipTranslateMatrix]
1=GpMatrix *matrix
2=REAL offsetX
3=REAL offsetY
4=GpMatrixOrder order
ParamCount=4
@=GdipTranslateMatrix(GpMatrix *matrix, REAL offsetX, REAL offsetY, GpMatrixOrder order);
[GdipScaleMatrix]
1=GpMatrix *matrix
2=REAL scaleX
3=REAL scaleY
4=GpMatrixOrder order
ParamCount=4
@=GdipScaleMatrix(GpMatrix *matrix, REAL scaleX, REAL scaleY, GpMatrixOrder order);
[GdipRotateMatrix]
1=GpMatrix *matrix
2=REAL angle
3=GpMatrixOrder order
ParamCount=3
@=GdipRotateMatrix(GpMatrix *matrix, REAL angle, GpMatrixOrder order);
[GdipShearMatrix]
1=GpMatrix *matrix
2=REAL shearX
3=REAL shearY
4=GpMatrixOrder order
ParamCount=4
@=GdipShearMatrix(GpMatrix *matrix, REAL shearX, REAL shearY, GpMatrixOrder order);
[GdipInvertMatrix]
1=GpMatrix *matrix
ParamCount=1
@=GdipInvertMatrix(GpMatrix *matrix);
[GdipTransformMatrixPoints]
1=GpMatrix *matrix
2=GpPointF *pts
3=INT count
ParamCount=3
@=GdipTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts, INT count);
[GdipTransformMatrixPointsI]
1=GpMatrix *matrix
2=GpPoint *pts
3=INT count
ParamCount=3
@=GdipTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts, INT count);
[GdipVectorTransformMatrixPoints]
1=GpMatrix *matrix
2=GpPointF *pts
3=INT count
ParamCount=3
@=GdipVectorTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts, INT count);
[GdipVectorTransformMatrixPointsI]
1=GpMatrix *matrix
2=GpPoint *pts
3=INT count
ParamCount=3
@=GdipVectorTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts, INT count);
[GdipGetMatrixElements]
1=GDIPCONST GpMatrix *matrix
2=REAL *matrixOut
ParamCount=2
@=GdipGetMatrixElements(GDIPCONST GpMatrix *matrix, REAL *matrixOut);
[GdipIsMatrixInvertible]
1=GDIPCONST GpMatrix *matrix
2=BOOL *result
ParamCount=2
@=GdipIsMatrixInvertible(GDIPCONST GpMatrix *matrix, BOOL *result);
[GdipIsMatrixIdentity]
1=GDIPCONST GpMatrix *matrix
2=BOOL *result
ParamCount=2
@=GdipIsMatrixIdentity(GDIPCONST GpMatrix *matrix, BOOL *result);
[GdipIsMatrixEqual]
1=GDIPCONST GpMatrix *matrix
2=GDIPCONST GpMatrix *matrix2
3=BOOL *result
ParamCount=3
@=GdipIsMatrixEqual(GDIPCONST GpMatrix *matrix, GDIPCONST GpMatrix *matrix2,  BOOL *result);
[GdipCreateRegion]
1=GpRegion **region
ParamCount=1
@=GdipCreateRegion(GpRegion **region);
[GdipCreateRegionRect]
1=GDIPCONST GpRectF *rect
2=GpRegion **region
ParamCount=2
@=GdipCreateRegionRect(GDIPCONST GpRectF *rect, GpRegion **region);
[GdipCreateRegionRectI]
1=GDIPCONST GpRect *rect
2=GpRegion **region
ParamCount=2
@=GdipCreateRegionRectI(GDIPCONST GpRect *rect, GpRegion **region);
[GdipCreateRegionPath]
1=GpPath *path
2=GpRegion **region
ParamCount=2
@=GdipCreateRegionPath(GpPath *path, GpRegion **region);
[GdipCreateRegionRgnData]
1=GDIPCONST BYTE *regionData
2=INT size
3=GpRegion **region
ParamCount=3
@=GdipCreateRegionRgnData(GDIPCONST BYTE *regionData, INT size, GpRegion **region);
[GdipCreateRegionHrgn]
1=HRGN hRgn
2=GpRegion **region
ParamCount=2
@=GdipCreateRegionHrgn(HRGN hRgn, GpRegion **region);
[GdipCloneRegion]
1=GpRegion *region
2=GpRegion **cloneRegion
ParamCount=2
@=GdipCloneRegion(GpRegion *region, GpRegion **cloneRegion);
[GdipDeleteRegion]
1=GpRegion *region
ParamCount=1
@=GdipDeleteRegion(GpRegion *region);
[GdipSetInfinite]
1=GpRegion *region
ParamCount=1
@=GdipSetInfinite(GpRegion *region);
[GdipSetEmpty]
1=GpRegion *region
ParamCount=1
@=GdipSetEmpty(GpRegion *region);
[GdipCombineRegionRect]
1=GpRegion *region
2=GDIPCONST GpRectF *rect
3=CombineMode combineMode
ParamCount=3
@=GdipCombineRegionRect(GpRegion *region, GDIPCONST GpRectF *rect, CombineMode combineMode);
[GdipCombineRegionRectI]
1=GpRegion *region
2=GDIPCONST GpRect *rect
3=CombineMode combineMode
ParamCount=3
@=GdipCombineRegionRectI(GpRegion *region, GDIPCONST GpRect *rect, CombineMode combineMode);
[GdipCombineRegionPath]
1=GpRegion *region
2=GpPath *path
3=CombineMode combineMode
ParamCount=3
@=GdipCombineRegionPath(GpRegion *region, GpPath *path, CombineMode combineMode);
[GdipCombineRegionRegion]
1=GpRegion *region
2=GpRegion *region2
3=CombineMode combineMode
ParamCount=3
@=GdipCombineRegionRegion(GpRegion *region, GpRegion *region2, CombineMode combineMode);
[GdipTranslateRegion]
1=GpRegion *region
2=REAL dx
3=REAL dy
ParamCount=3
@=GdipTranslateRegion(GpRegion *region, REAL dx, REAL dy);
[GdipTranslateRegionI]
1=GpRegion *region
2=INT dx
3=INT dy
ParamCount=3
@=GdipTranslateRegionI(GpRegion *region, INT dx, INT dy);
[GdipTransformRegion]
1=GpRegion *region
2=GpMatrix *matrix
ParamCount=2
@=GdipTransformRegion(GpRegion *region, GpMatrix *matrix);
[GdipGetRegionBounds]
1=GpRegion *region
2=GpGraphics *graphics
3=GpRectF *rect
ParamCount=3
@=GdipGetRegionBounds(GpRegion *region, GpGraphics *graphics, GpRectF *rect);
[GdipGetRegionBoundsI]
1=GpRegion *region
2=GpGraphics *graphics
3=GpRect *rect
ParamCount=3
@=GdipGetRegionBoundsI(GpRegion *region, GpGraphics *graphics, GpRect *rect);
[GdipGetRegionHRgn]
1=GpRegion *region
2=GpGraphics *graphics
3=HRGN *hRgn
ParamCount=3
@=GdipGetRegionHRgn(GpRegion *region, GpGraphics *graphics, HRGN *hRgn);
[GdipIsEmptyRegion]
1=GpRegion *region
2=GpGraphics *graphics
3=BOOL *result
ParamCount=3
@=GdipIsEmptyRegion(GpRegion *region, GpGraphics *graphics, BOOL *result);
[GdipIsInfiniteRegion]
1=GpRegion *region
2=GpGraphics *graphics
3=BOOL *result
ParamCount=3
@=GdipIsInfiniteRegion(GpRegion *region, GpGraphics *graphics, BOOL *result);
[GdipIsEqualRegion]
1=GpRegion *region
2=GpRegion *region2
3=GpGraphics *graphics
4=BOOL *result
ParamCount=4
@=GdipIsEqualRegion(GpRegion *region, GpRegion *region2, GpGraphics *graphics, BOOL *result);
[GdipGetRegionDataSize]
1=GpRegion *region
2=UINT *bufferSize
ParamCount=2
@=GdipGetRegionDataSize(GpRegion *region, UINT *bufferSize);
[GdipGetRegionData]
1=GpRegion *region
2=BYTE *buffer
3=UINT bufferSize
4=UINT *sizeFilled
ParamCount=4
@=GdipGetRegionData(GpRegion *region, BYTE *buffer, UINT bufferSize, UINT *sizeFilled);
[GdipIsVisibleRegionPoint]
1=GpRegion *region
2=REAL x
3=REAL y
4=GpGraphics *graphics
5=BOOL *result
ParamCount=5
@=GdipIsVisibleRegionPoint(GpRegion *region, REAL x, REAL y, GpGraphics *graphics, BOOL *result);
[GdipIsVisibleRegionPointI]
1=GpRegion *region
2=INT x
3=INT y
4=GpGraphics *graphics
5=BOOL *result
ParamCount=5
@=GdipIsVisibleRegionPointI(GpRegion *region, INT x, INT y, GpGraphics *graphics, BOOL *result);
[GdipIsVisibleRegionRect]
1=GpRegion *region
2=REAL x
3=REAL y
4=REAL width
5=REAL height
6=GpGraphics *graphics
7=BOOL *result
ParamCount=7
@=GdipIsVisibleRegionRect(GpRegion *region, REAL x, REAL y, REAL width, REAL height, GpGraphics *graphics, BOOL *result);
[GdipIsVisibleRegionRectI]
1=GpRegion *region
2=INT x
3=INT y
4=INT width
5=INT height
6=GpGraphics *graphics
7=BOOL *result
ParamCount=7
@=GdipIsVisibleRegionRectI(GpRegion *region, INT x, INT y, INT width, INT height, GpGraphics *graphics, BOOL *result);
[GdipGetRegionScansCount]
1=GpRegion *region
2=UINT *count
3=GpMatrix *matrix
ParamCount=3
@=GdipGetRegionScansCount(GpRegion *region, UINT *count, GpMatrix *matrix);
[GdipGetRegionScans]
1=GpRegion *region
2=GpRectF *rects
3=INT *count
4=GpMatrix *matrix
ParamCount=4
@=GdipGetRegionScans(GpRegion *region, GpRectF* rects, INT* count, GpMatrix*matrix);
[GdipGetRegionScansI]
1=GpRegion *region
2=GpRect *rects
3=INT *count
4=GpMatrix *matrix
ParamCount=4
@=GdipGetRegionScansI(GpRegion *region, GpRect *rects, INT *count, GpMatrix *matrix);
[GdipCloneBrush]
1=GpBrush *brush
2=GpBrush **cloneBrush
ParamCount=2
@=GdipCloneBrush(GpBrush *brush, GpBrush **cloneBrush);
[GdipDeleteBrush]
1=GpBrush *brush
ParamCount=1
@=GdipDeleteBrush(GpBrush *brush);
[GdipGetBrushType]
1=GpBrush *brush
2=GpBrushType *type
ParamCount=2
@=GdipGetBrushType(GpBrush *brush, GpBrushType *type);
[GdipCreateHatchBrush]
1=GpHatchStyle hatchstyle
2=ARGB forecol
3=ARGB backcol
4=GpHatch **brush
ParamCount=4
@=GdipCreateHatchBrush(GpHatchStyle hatchstyle, ARGB forecol, ARGB backcol, GpHatch **brush);
[GdipGetHatchStyle]
1=GpHatch *brush
2=GpHatchStyle *hatchstyle
ParamCount=2
@=GdipGetHatchStyle(GpHatch *brush, GpHatchStyle *hatchstyle);
[GdipGetHatchForegroundColor]
1=GpHatch *brush
2=ARGB *forecol
ParamCount=2
@=GdipGetHatchForegroundColor(GpHatch *brush, ARGB *forecol);
[GdipGetHatchBackgroundColor]
1=GpHatch *brush
2=ARGB *backcol
ParamCount=2
@=GdipGetHatchBackgroundColor(GpHatch *brush, ARGB *backcol);
[GdipCreateTexture]
1=GpImage *image
2=GpWrapMode wrapmode
3=GpTexture **texture
ParamCount=3
@=GdipCreateTexture(GpImage *image, GpWrapMode wrapmode, GpTexture **texture);
[GdipCreateTexture2]
1=GpImage *image
2=GpWrapMode wrapmode
3=REAL x
4=REAL y
5=REAL width
6=REAL height
7=GpTexture **texture
ParamCount=7
@=GdipCreateTexture2(GpImage *image, GpWrapMode wrapmode, REAL x, REAL y, REAL width, REAL height, GpTexture **texture);
[GdipCreateTextureIA]
1=GpImage *image
2=GDIPCONST GpImageAttributes*imageAttributes
3=REAL x
4=REAL y
5=REAL width
6=REAL height
7=GpTexture **texture
ParamCount=7
@=GdipCreateTextureIA(GpImage *image, GDIPCONST GpImageAttributes*imageAttributes, REAL x, REAL y, REAL width, REAL height, GpTexture **texture);
[GdipCreateTexture2I]
1=GpImage *image
2=GpWrapMode wrapmode
3=INT x
4=INT y
5=INT width
6=INT height
7=GpTexture **texture
ParamCount=7
@=GdipCreateTexture2I(GpImage *image, GpWrapMode wrapmode, INT x, INT y, INT width, INT height, GpTexture **texture);
[GdipCreateTextureIAI]
1=GpImage *image
2=GDIPCONST GpImageAttributes *imageAttributes
3=INT x
4=INT y
5=INT width
6=INT height
7=GpTexture **texture
ParamCount=7
@=GdipCreateTextureIAI(GpImage *image, GDIPCONST GpImageAttributes *imageAttributes, INT x, INT y, INT width, INT height, GpTexture **texture);
[GdipGetTextureTransform]
1=GpTexture *brush
2=GpMatrix *matrix
ParamCount=2
@=GdipGetTextureTransform(GpTexture *brush, GpMatrix *matrix);
[GdipSetTextureTransform]
1=GpTexture *brush
2=GDIPCONST GpMatrix *matrix
ParamCount=2
@=GdipSetTextureTransform(GpTexture *brush, GDIPCONST GpMatrix *matrix);
[GdipResetTextureTransform]
1=GpTexture *brush
ParamCount=1
@=GdipResetTextureTransform(GpTexture *brush);
[GdipMultiplyTextureTransform]
1=GpTexture *brush
2=GDIPCONST GpMatrix *matrix
3=GpMatrixOrder order
ParamCount=3
@=GdipMultiplyTextureTransform(GpTexture *brush, GDIPCONST GpMatrix *matrix, GpMatrixOrder order);
[GdipTranslateTextureTransform]
1=GpTexture *brush
2=REAL dx
3=REAL dy
4=GpMatrixOrder order
ParamCount=4
@=GdipTranslateTextureTransform(GpTexture *brush, REAL dx, REAL dy, GpMatrixOrder order);
[GdipScaleTextureTransform]
1=GpTexture *brush
2=REAL sx
3=REAL sy
4=GpMatrixOrder order
ParamCount=4
@=GdipScaleTextureTransform(GpTexture *brush, REAL sx, REAL sy, GpMatrixOrder order);
[GdipRotateTextureTransform]
1=GpTexture *brush
2=REAL angle
3=GpMatrixOrder order
ParamCount=3
@=GdipRotateTextureTransform(GpTexture *brush, REAL angle, GpMatrixOrder order);
[GdipSetTextureWrapMode]
1=GpTexture *brush
2=GpWrapMode wrapmode
ParamCount=2
@=GdipSetTextureWrapMode(GpTexture *brush, GpWrapMode wrapmode);
[GdipGetTextureWrapMode]
1=GpTexture *brush
2=GpWrapMode *wrapmode
ParamCount=2
@=GdipGetTextureWrapMode(GpTexture *brush, GpWrapMode *wrapmode);
[GdipGetTextureImage]
1=GpTexture *brush
2=GpImage **image
ParamCount=2
@=GdipGetTextureImage(GpTexture *brush, GpImage **image);
[GdipCreateSolidFill]
1=ARGB color
2=GpSolidFill **brush
ParamCount=2
@=GdipCreateSolidFill(ARGB color, GpSolidFill **brush);
[GdipSetSolidFillColor]
1=GpSolidFill *brush
2=ARGB color
ParamCount=2
@=GdipSetSolidFillColor(GpSolidFill *brush, ARGB color);
[GdipGetSolidFillColor]
1=GpSolidFill *brush
2=ARGB *color
ParamCount=2
@=GdipGetSolidFillColor(GpSolidFill *brush, ARGB *color);
[GdipCreateLineBrush]
1=GDIPCONST GpPointF *point1
2=GDIPCONST GpPointF *point2
3=ARGB color1
4=ARGB color2
5=GpWrapMode wrapMode
6=GpLineGradient **lineGradient
ParamCount=6
@=GdipCreateLineBrush(GDIPCONST GpPointF *point1, GDIPCONST GpPointF *point2, ARGB color1, ARGB color2, GpWrapMode wrapMode, GpLineGradient **lineGradient);
[GdipCreateLineBrushI]
1=GDIPCONST GpPoint *point1
2=GDIPCONST GpPoint *point2
3=ARGB color1
4=ARGB color2
5=GpWrapMode wrapMode
6=GpLineGradient **lineGradient
ParamCount=6
@=GdipCreateLineBrushI(GDIPCONST GpPoint *point1, GDIPCONST GpPoint *point2, ARGB color1, ARGB color2, GpWrapMode wrapMode, GpLineGradient **lineGradient);
[GdipCreateLineBrushFromRect]
1=GDIPCONST GpRectF *rect
2=ARGB color1
3=ARGB color2
4=LinearGradientMode mode
5=GpWrapMode wrapMode
6=GpLineGradient **lineGradient
ParamCount=6
@=GdipCreateLineBrushFromRect(GDIPCONST GpRectF *rect, ARGB color1, ARGB color2, LinearGradientMode mode, GpWrapMode wrapMode, GpLineGradient **lineGradient);
[GdipCreateLineBrushFromRectI]
1=GDIPCONST GpRect *rect
2=ARGB color1
3=ARGB color2
4=LinearGradientMode mode
5=GpWrapMode wrapMode
6=GpLineGradient **lineGradient
ParamCount=6
@=GdipCreateLineBrushFromRectI(GDIPCONST GpRect *rect, ARGB color1, ARGB color2, LinearGradientMode mode, GpWrapMode wrapMode, GpLineGradient **lineGradient);
[GdipCreateLineBrushFromRectWithAngle]
1=GDIPCONST GpRectF *rect
2=ARGB color1
3=ARGB color2
4=REAL angle
5=BOOL isAngleScalable
6=GpWrapMode wrapMode
7=GpLineGradient **lineGradient
ParamCount=7
@=GdipCreateLineBrushFromRectWithAngle(GDIPCONST GpRectF *rect, ARGB color1, ARGB color2, REAL angle, BOOL isAngleScalable, GpWrapMode wrapMode, GpLineGradient **lineGradient);
[GdipCreateLineBrushFromRectWithAngleI]
1=GDIPCONST GpRect *rect
2=ARGB color1
3=ARGB color2
4=REAL angle
5=BOOL isAngleScalable
6=GpWrapMode wrapMode
7=GpLineGradient **lineGradient
ParamCount=7
@=GdipCreateLineBrushFromRectWithAngleI(GDIPCONST GpRect *rect, ARGB color1, ARGB color2, REAL angle, BOOL isAngleScalable, GpWrapMode wrapMode, GpLineGradient **lineGradient);
[GdipSetLineColors]
1=GpLineGradient *brush
2=ARGB color1
3=ARGB color2
ParamCount=3
@=GdipSetLineColors(GpLineGradient *brush, ARGB color1, ARGB color2);
[GdipGetLineColors]
1=GpLineGradient *brush
2=ARGB *colors
ParamCount=2
@=GdipGetLineColors(GpLineGradient *brush, ARGB *colors);
[GdipGetLineRect]
1=GpLineGradient *brush
2=GpRectF *rect
ParamCount=2
@=GdipGetLineRect(GpLineGradient *brush, GpRectF *rect);
[GdipGetLineRectI]
1=GpLineGradient *brush
2=GpRect *rect
ParamCount=2
@=GdipGetLineRectI(GpLineGradient *brush, GpRect *rect);
[GdipSetLineGammaCorrection]
1=GpLineGradient *brush
2=BOOL useGammaCorrection
ParamCount=2
@=GdipSetLineGammaCorrection(GpLineGradient *brush, BOOL useGammaCorrection);
[GdipGetLineGammaCorrection]
1=GpLineGradient *brush
2=BOOL *useGammaCorrection
ParamCount=2
@=GdipGetLineGammaCorrection(GpLineGradient *brush, BOOL *useGammaCorrection);
[GdipGetLineBlendCount]
1=GpLineGradient *brush
2=INT *count
ParamCount=2
@=GdipGetLineBlendCount(GpLineGradient *brush, INT *count);
[GdipGetLineBlend]
1=GpLineGradient *brush
2=REAL *blend
3=REAL *positions
4=INT count
ParamCount=4
@=GdipGetLineBlend(GpLineGradient *brush, REAL *blend, REAL *positions, INT count);
[GdipSetLineBlend]
1=GpLineGradient *brush
2=GDIPCONST REAL *blend
3=GDIPCONST REAL *positions
4=INT count
ParamCount=4
@=GdipSetLineBlend(GpLineGradient *brush, GDIPCONST REAL *blend, GDIPCONST REAL *positions, INT count);
[GdipGetLinePresetBlendCount]
1=GpLineGradient *brush
2=INT *count
ParamCount=2
@=GdipGetLinePresetBlendCount(GpLineGradient *brush, INT *count);
[GdipGetLinePresetBlend]
1=GpLineGradient *brush
2=ARGB *blend
3=REAL* positions
4=INT count
ParamCount=4
@=GdipGetLinePresetBlend(GpLineGradient *brush, ARGB *blend, REAL* positions, INT count);
[GdipSetLinePresetBlend]
1=GpLineGradient *brush
2=GDIPCONST ARGB *blend
3=GDIPCONST REAL *positions
4=INT count
ParamCount=4
@=GdipSetLinePresetBlend(GpLineGradient *brush, GDIPCONST ARGB *blend, GDIPCONST REAL *positions, INT count);
[GdipSetLineSigmaBlend]
1=GpLineGradient *brush
2=REAL focus
3=REAL scale
ParamCount=3
@=GdipSetLineSigmaBlend(GpLineGradient *brush, REAL focus, REAL scale);
[GdipSetLineLinearBlend]
1=GpLineGradient *brush
2=REAL focus
3=REAL scale
ParamCount=3
@=GdipSetLineLinearBlend(GpLineGradient *brush, REAL focus, REAL scale);
[GdipSetLineWrapMode]
1=GpLineGradient *brush
2=GpWrapMode wrapmode
ParamCount=2
@=GdipSetLineWrapMode(GpLineGradient *brush, GpWrapMode wrapmode);
[GdipGetLineWrapMode]
1=GpLineGradient *brush
2=GpWrapMode *wrapmode
ParamCount=2
@=GdipGetLineWrapMode(GpLineGradient *brush, GpWrapMode *wrapmode);
[GdipGetLineTransform]
1=GpLineGradient *brush
2=GpMatrix *matrix
ParamCount=2
@=GdipGetLineTransform(GpLineGradient *brush, GpMatrix *matrix);
[GdipSetLineTransform]
1=GpLineGradient *brush
2=GDIPCONST GpMatrix *matrix
ParamCount=2
@=GdipSetLineTransform(GpLineGradient *brush, GDIPCONST GpMatrix *matrix);
[GdipResetLineTransform]
1=GpLineGradient *brush
ParamCount=1
@=GdipResetLineTransform(GpLineGradient *brush);
[GdipMultiplyLineTransform]
1=GpLineGradient *brush
2=GDIPCONST GpMatrix *matrix
3=GpMatrixOrder order
ParamCount=3
@=GdipMultiplyLineTransform(GpLineGradient *brush, GDIPCONST GpMatrix *matrix, GpMatrixOrder order);
[GdipTranslateLineTransform]
1=GpLineGradient *brush
2=REAL dx
3=REAL dy
4=GpMatrixOrder order
ParamCount=4
@=GdipTranslateLineTransform(GpLineGradient *brush, REAL dx, REAL dy, GpMatrixOrder order);
[GdipScaleLineTransform]
1=GpLineGradient *brush
2=REAL sx
3=REAL sy
4=GpMatrixOrder order
ParamCount=4
@=GdipScaleLineTransform(GpLineGradient *brush, REAL sx, REAL sy, GpMatrixOrder order);
[GdipRotateLineTransform]
1=GpLineGradient *brush
2=REAL angle
3=GpMatrixOrder order
ParamCount=3
@=GdipRotateLineTransform(GpLineGradient *brush, REAL angle, GpMatrixOrder order);
[GdipCreatePathGradient]
1=GDIPCONST GpPointF *points
2=INT count
3=GpWrapMode wrapMode
4=GpPathGradient **polyGradient
ParamCount=4
@=GdipCreatePathGradient(GDIPCONST GpPointF *points, INT count, GpWrapMode wrapMode, GpPathGradient **polyGradient);
[GdipCreatePathGradientI]
1=GDIPCONST GpPoint *points
2=INT count
3=GpWrapMode wrapMode
4=GpPathGradient **polyGradient
ParamCount=4
@=GdipCreatePathGradientI(GDIPCONST GpPoint *points, INT count, GpWrapMode wrapMode, GpPathGradient **polyGradient);
[GdipCreatePathGradientFromPath]
1=GDIPCONST GpPath *path
2=GpPathGradient **polyGradient
ParamCount=2
@=GdipCreatePathGradientFromPath(GDIPCONST GpPath *path, GpPathGradient **polyGradient);
[GdipGetPathGradientCenterColor]
1=GpPathGradient *brush
2=ARGB *colors
ParamCount=2
@=GdipGetPathGradientCenterColor(GpPathGradient *brush, ARGB *colors);
[GdipSetPathGradientCenterColor]
1=GpPathGradient *brush
2=ARGB colors
ParamCount=2
@=GdipSetPathGradientCenterColor(GpPathGradient *brush, ARGB colors);
[GdipGetPathGradientSurroundColorsWithCount]
1=GpPathGradient *brush
2=ARGB *color
3=INT *count
ParamCount=3
@=GdipGetPathGradientSurroundColorsWithCount(GpPathGradient *brush, ARGB *color, INT *count);
[GdipSetPathGradientSurroundColorsWithCount]
1=GpPathGradient *brush
2=GDIPCONST ARGB *color
3=INT *count
ParamCount=3
@=GdipSetPathGradientSurroundColorsWithCount(GpPathGradient *brush, GDIPCONST ARGB *color, INT *count);
[GdipGetPathGradientPath]
1=GpPathGradient *brush
2=GpPath *path
ParamCount=2
@=GdipGetPathGradientPath(GpPathGradient *brush, GpPath *path);
[GdipSetPathGradientPath]
1=GpPathGradient *brush
2=GDIPCONST GpPath *path
ParamCount=2
@=GdipSetPathGradientPath(GpPathGradient *brush, GDIPCONST GpPath *path);
[GdipGetPathGradientCenterPoint]
1=GpPathGradient *brush
2=GpPointF* points
ParamCount=2
@=GdipGetPathGradientCenterPoint(GpPathGradient *brush, GpPointF* points);
[GdipGetPathGradientCenterPointI]
1=GpPathGradient *brush
2=GpPoint *points
ParamCount=2
@=GdipGetPathGradientCenterPointI(GpPathGradient *brush, GpPoint *points);
[GdipSetPathGradientCenterPoint]
1=GpPathGradient *brush
2=GDIPCONST GpPointF *points
ParamCount=2
@=GdipSetPathGradientCenterPoint(GpPathGradient *brush, GDIPCONST GpPointF *points);
[GdipSetPathGradientCenterPointI]
1=GpPathGradient *brush
2=GDIPCONST GpPoint *points
ParamCount=2
@=GdipSetPathGradientCenterPointI(GpPathGradient *brush, GDIPCONST GpPoint *points);
[GdipGetPathGradientRect]
1=GpPathGradient *brush
2=GpRectF *rect
ParamCount=2
@=GdipGetPathGradientRect(GpPathGradient *brush, GpRectF *rect);
[GdipGetPathGradientRectI]
1=GpPathGradient *brush
2=GpRect *rect
ParamCount=2
@=GdipGetPathGradientRectI(GpPathGradient *brush, GpRect *rect);
[GdipGetPathGradientPointCount]
1=GpPathGradient *brush
2=INT* count
ParamCount=2
@=GdipGetPathGradientPointCount(GpPathGradient *brush, INT* count);
[GdipGetPathGradientSurroundColorCount]
1=GpPathGradient *brush
2=INT* count
ParamCount=2
@=GdipGetPathGradientSurroundColorCount(GpPathGradient *brush, INT* count);
[GdipSetPathGradientGammaCorrection]
1=GpPathGradient *brush
2=BOOL useGammaCorrection
ParamCount=2
@=GdipSetPathGradientGammaCorrection(GpPathGradient *brush, BOOL useGammaCorrection);
[GdipGetPathGradientGammaCorrection]
1=GpPathGradient *brush
2=BOOL *useGammaCorrection
ParamCount=2
@=GdipGetPathGradientGammaCorrection(GpPathGradient *brush, BOOL *useGammaCorrection);
[GdipGetPathGradientBlendCount]
1=GpPathGradient *brush
2=INT *count
ParamCount=2
@=GdipGetPathGradientBlendCount(GpPathGradient *brush, INT *count);
[GdipGetPathGradientBlend]
1=GpPathGradient *brush
2=REAL *blend
3=REAL *positions
4=INT count
ParamCount=4
@=GdipGetPathGradientBlend(GpPathGradient *brush, REAL *blend, REAL *positions, INT count);
[GdipSetPathGradientBlend]
1=GpPathGradient *brush
2=GDIPCONST REAL *blend
3=GDIPCONST REAL *positions
4=INT count
ParamCount=4
@=GdipSetPathGradientBlend(GpPathGradient *brush, GDIPCONST REAL *blend, GDIPCONST REAL *positions, INT count);
[GdipGetPathGradientPresetBlendCount]
1=GpPathGradient *brush
2=INT *count
ParamCount=2
@=GdipGetPathGradientPresetBlendCount(GpPathGradient *brush, INT *count);
[GdipGetPathGradientPresetBlend]
1=GpPathGradient *brush
2=ARGB *blend
3=REAL *positions
4=INT count
ParamCount=4
@=GdipGetPathGradientPresetBlend(GpPathGradient *brush, ARGB *blend, REAL *positions, INT count);
[GdipSetPathGradientPresetBlend]
1=GpPathGradient *brush
2=GDIPCONST ARGB *blend
3=GDIPCONST REAL *positions
4=INT count
ParamCount=4
@=GdipSetPathGradientPresetBlend(GpPathGradient *brush, GDIPCONST ARGB *blend, GDIPCONST REAL *positions, INT count);
[GdipSetPathGradientSigmaBlend]
1=GpPathGradient *brush
2=REAL focus
3=REAL scale
ParamCount=3
@=GdipSetPathGradientSigmaBlend(GpPathGradient *brush, REAL focus, REAL scale);
[GdipSetPathGradientLinearBlend]
1=GpPathGradient *brush
2=REAL focus
3=REAL scale
ParamCount=3
@=GdipSetPathGradientLinearBlend(GpPathGradient *brush, REAL focus, REAL scale);
[GdipGetPathGradientWrapMode]
1=GpPathGradient *brush
2=GpWrapMode *wrapmode
ParamCount=2
@=GdipGetPathGradientWrapMode(GpPathGradient *brush, GpWrapMode *wrapmode);
[GdipSetPathGradientWrapMode]
1=GpPathGradient *brush
2=GpWrapMode wrapmode
ParamCount=2
@=GdipSetPathGradientWrapMode(GpPathGradient *brush, GpWrapMode wrapmode);
[GdipGetPathGradientTransform]
1=GpPathGradient *brush
2=GpMatrix *matrix
ParamCount=2
@=GdipGetPathGradientTransform(GpPathGradient *brush, GpMatrix *matrix);
[GdipSetPathGradientTransform]
1=GpPathGradient *brush
2=GpMatrix *matrix
ParamCount=2
@=GdipSetPathGradientTransform(GpPathGradient *brush, GpMatrix *matrix);
[GdipResetPathGradientTransform]
1=GpPathGradient* brush
ParamCount=1
@=GdipResetPathGradientTransform(GpPathGradient *brush);
[GdipMultiplyPathGradientTransform]
1=GpPathGradient *brush
2=GDIPCONST GpMatrix *matrix
3=GpMatrixOrder order
ParamCount=3
@=GdipMultiplyPathGradientTransform(GpPathGradient *brush, GDIPCONST GpMatrix *matrix, GpMatrixOrder order);
[GdipTranslatePathGradientTransform]
1=GpPathGradient *brush
2=REAL dx
3=REAL dy
4=GpMatrixOrder order
ParamCount=4
@=GdipTranslatePathGradientTransform(GpPathGradient *brush, REAL dx, REAL dy, GpMatrixOrder order);
[GdipScalePathGradientTransform]
1=GpPathGradient *brush
2=REAL sx
3=REAL sy
4=GpMatrixOrder order
ParamCount=4
@=GdipScalePathGradientTransform(GpPathGradient *brush, REAL sx, REAL sy, GpMatrixOrder order);
[GdipRotatePathGradientTransform]
1=GpPathGradient *brush
2=REAL angle
3=GpMatrixOrder order
ParamCount=3
@=GdipRotatePathGradientTransform(GpPathGradient *brush, REAL angle, GpMatrixOrder order);
[GdipGetPathGradientFocusScales]
1=GpPathGradient *brush
2=REAL* xScale
3= REAL*yScale
ParamCount=3
@=GdipGetPathGradientFocusScales(GpPathGradient *brush, REAL* xScale,  REAL*yScale);
[GdipSetPathGradientFocusScales]
1=GpPathGradient *brush
2=REAL xScale
3= REALyScale
ParamCount=3
@=GdipSetPathGradientFocusScales(GpPathGradient *brush, REAL xScale,  REALyScale);
[GdipCreatePen1]
1=ARGB color
2=REAL width
3=GpUnit unit
4=GpPen **pen
ParamCount=4
@=GdipCreatePen1(ARGB color, REAL width, GpUnit unit, GpPen **pen);
[GdipCreatePen2]
1=GpBrush *brush
2=REAL width
3=GpUnit unit
4=GpPen **pen
ParamCount=4
@=GdipCreatePen2(GpBrush *brush, REAL width, GpUnit unit, GpPen **pen);
[GdipClonePen]
1=GpPen *pen
2=GpPen **clonepen
ParamCount=2
@=GdipClonePen(GpPen *pen, GpPen **clonepen);
[GdipDeletePen]
1=GpPen *pen
ParamCount=1
@=GdipDeletePen(GpPen *pen);
[GdipSetPenWidth]
1=GpPen *pen
2=REAL width
ParamCount=2
@=GdipSetPenWidth(GpPen *pen, REAL width);
[GdipGetPenWidth]
1=GpPen *pen
2=REAL *width
ParamCount=2
@=GdipGetPenWidth(GpPen *pen, REAL *width);
[GdipSetPenUnit]
1=GpPen *pen
2=GpUnit unit
ParamCount=2
@=GdipSetPenUnit(GpPen *pen, GpUnit unit);
[GdipGetPenUnit]
1=GpPen *pen
2=GpUnit *unit
ParamCount=2
@=GdipGetPenUnit(GpPen *pen, GpUnit *unit);
[GdipSetPenLineCap197819]
1=GpPen *pen
2=GpLineCap startCap
3=GpLineCap endCap
4=GpDashCap dashCap
ParamCount=4
@=GdipSetPenLineCap197819(GpPen *pen, GpLineCap startCap, GpLineCap endCap, GpDashCap dashCap);
[GdipSetPenStartCap]
1=GpPen *pen
2=GpLineCap startCap
ParamCount=2
@=GdipSetPenStartCap(GpPen *pen, GpLineCap startCap);
[GdipSetPenEndCap]
1=GpPen *pen
2=GpLineCap endCap
ParamCount=2
@=GdipSetPenEndCap(GpPen *pen, GpLineCap endCap);
[GdipSetPenDashCap197819]
1=GpPen *pen
2=GpDashCap dashCap
ParamCount=2
@=GdipSetPenDashCap197819(GpPen *pen, GpDashCap dashCap);
[GdipGetPenStartCap]
1=GpPen *pen
2=GpLineCap *startCap
ParamCount=2
@=GdipGetPenStartCap(GpPen *pen, GpLineCap *startCap);
[GdipGetPenEndCap]
1=GpPen *pen
2=GpLineCap *endCap
ParamCount=2
@=GdipGetPenEndCap(GpPen *pen, GpLineCap *endCap);
[GdipGetPenDashCap197819]
1=GpPen *pen
2=GpDashCap *dashCap
ParamCount=2
@=GdipGetPenDashCap197819(GpPen *pen, GpDashCap *dashCap);
[GdipSetPenLineJoin]
1=GpPen *pen
2=GpLineJoin lineJoin
ParamCount=2
@=GdipSetPenLineJoin(GpPen *pen, GpLineJoin lineJoin);
[GdipGetPenLineJoin]
1=GpPen *pen
2=GpLineJoin *lineJoin
ParamCount=2
@=GdipGetPenLineJoin(GpPen *pen, GpLineJoin *lineJoin);
[GdipSetPenCustomStartCap]
1=GpPen *pen
2=GpCustomLineCap* customCap
ParamCount=2
@=GdipSetPenCustomStartCap(GpPen *pen, GpCustomLineCap* customCap);
[GdipGetPenCustomStartCap]
1=GpPen *pen
2=GpCustomLineCap** customCap
ParamCount=2
@=GdipGetPenCustomStartCap(GpPen *pen, GpCustomLineCap** customCap);
[GdipSetPenCustomEndCap]
1=GpPen *pen
2=GpCustomLineCap* customCap
ParamCount=2
@=GdipSetPenCustomEndCap(GpPen *pen, GpCustomLineCap* customCap);
[GdipGetPenCustomEndCap]
1=GpPen *pen
2=GpCustomLineCap** customCap
ParamCount=2
@=GdipGetPenCustomEndCap(GpPen *pen, GpCustomLineCap** customCap);
[GdipSetPenMiterLimit]
1=GpPen *pen
2=REAL miterLimit
ParamCount=2
@=GdipSetPenMiterLimit(GpPen *pen, REAL miterLimit);
[GdipGetPenMiterLimit]
1=GpPen *pen
2=REAL *miterLimit
ParamCount=2
@=GdipGetPenMiterLimit(GpPen *pen, REAL *miterLimit);
[GdipSetPenMode]
1=GpPen *pen
2=GpPenAlignment penMode
ParamCount=2
@=GdipSetPenMode(GpPen *pen, GpPenAlignment penMode);
[GdipGetPenMode]
1=GpPen *pen
2=GpPenAlignment *penMode
ParamCount=2
@=GdipGetPenMode(GpPen *pen, GpPenAlignment *penMode);
[GdipSetPenTransform]
1=GpPen *pen
2=GpMatrix *matrix
ParamCount=2
@=GdipSetPenTransform(GpPen *pen, GpMatrix *matrix);
[GdipGetPenTransform]
1=GpPen *pen
2=GpMatrix *matrix
ParamCount=2
@=GdipGetPenTransform(GpPen *pen, GpMatrix *matrix);
[GdipResetPenTransform]
1=GpPen *pen
ParamCount=1
@=GdipResetPenTransform(GpPen *pen);
[GdipMultiplyPenTransform]
1=GpPen *pen
2=GDIPCONST GpMatrix *matrix
3=GpMatrixOrder order
ParamCount=3
@=GdipMultiplyPenTransform(GpPen *pen, GDIPCONST GpMatrix *matrix, GpMatrixOrder order);
[GdipTranslatePenTransform]
1=GpPen *pen
2=REAL dx
3=REAL dy
4=GpMatrixOrder order
ParamCount=4
@=GdipTranslatePenTransform(GpPen *pen, REAL dx, REAL dy, GpMatrixOrder order);
[GdipScalePenTransform]
1=GpPen *pen
2=REAL sx
3=REAL sy
4=GpMatrixOrder order
ParamCount=4
@=GdipScalePenTransform(GpPen *pen, REAL sx, REAL sy, GpMatrixOrder order);
[GdipRotatePenTransform]
1=GpPen *pen
2=REAL angle
3=GpMatrixOrder order
ParamCount=3
@=GdipRotatePenTransform(GpPen *pen, REAL angle, GpMatrixOrder order);
[GdipSetPenColor]
1=GpPen *pen
2=ARGB argb
ParamCount=2
@=GdipSetPenColor(GpPen *pen, ARGB argb);
[GdipGetPenColor]
1=GpPen *pen
2=ARGB *argb
ParamCount=2
@=GdipGetPenColor(GpPen *pen, ARGB *argb);
[GdipSetPenBrushFill]
1=GpPen *pen
2=GpBrush *brush
ParamCount=2
@=GdipSetPenBrushFill(GpPen *pen, GpBrush *brush);
[GdipGetPenBrushFill]
1=GpPen *pen
2=GpBrush **brush
ParamCount=2
@=GdipGetPenBrushFill(GpPen *pen, GpBrush **brush);
[GdipGetPenFillType]
1=GpPen *pen
2=GpPenType *type
ParamCount=2
@=GdipGetPenFillType(GpPen *pen, GpPenType *type);
[GdipGetPenDashStyle]
1=GpPen *pen
2=GpDashStyle *dashstyle
ParamCount=2
@=GdipGetPenDashStyle(GpPen *pen, GpDashStyle *dashstyle);
[GdipSetPenDashStyle]
1=GpPen *pen
2=GpDashStyle dashstyle
ParamCount=2
@=GdipSetPenDashStyle(GpPen *pen, GpDashStyle dashstyle);
[GdipGetPenDashOffset]
1=GpPen *pen
2=REAL *offset
ParamCount=2
@=GdipGetPenDashOffset(GpPen *pen, REAL *offset);
[GdipSetPenDashOffset]
1=GpPen *pen
2=REAL offset
ParamCount=2
@=GdipSetPenDashOffset(GpPen *pen, REAL offset);
[GdipGetPenDashCount]
1=GpPen *pen
2=INT *count
ParamCount=2
@=GdipGetPenDashCount(GpPen *pen, INT *count);
[GdipSetPenDashArray]
1=GpPen *pen
2=GDIPCONST REAL *dash
3=INT count
ParamCount=3
@=GdipSetPenDashArray(GpPen *pen, GDIPCONST REAL *dash, INT count);
[GdipGetPenDashArray]
1=GpPen *pen
2=REAL *dash
3=INT count
ParamCount=3
@=GdipGetPenDashArray(GpPen *pen, REAL *dash, INT count);
[GdipGetPenCompoundCount]
1=GpPen *pen
2=INT *count
ParamCount=2
@=GdipGetPenCompoundCount(GpPen *pen, INT *count);
[GdipSetPenCompoundArray]
1=GpPen *pen
2=GDIPCONST REAL *dash
3=INT count
ParamCount=3
@=GdipSetPenCompoundArray(GpPen *pen, GDIPCONST REAL *dash, INT count);
[GdipGetPenCompoundArray]
1=GpPen *pen
2=REAL *dash
3=INT count
ParamCount=3
@=GdipGetPenCompoundArray(GpPen *pen, REAL *dash, INT count);
[GdipCreateCustomLineCap]
1=GpPath *fillPath
2=GpPath *strokePath
3=GpLineCap baseCap
4=REAL baseInset
5=GpCustomLineCap **customCap
ParamCount=5
@=GdipCreateCustomLineCap(GpPath *fillPath, GpPath *strokePath, GpLineCap baseCap, REAL baseInset, GpCustomLineCap **customCap);
[GdipDeleteCustomLineCap]
1=GpCustomLineCap *customCap
ParamCount=1
@=GdipDeleteCustomLineCap(GpCustomLineCap *customCap);
[GdipCloneCustomLineCap]
1=GpCustomLineCap *customCap
2=GpCustomLineCap **clonedCap
ParamCount=2
@=GdipCloneCustomLineCap(GpCustomLineCap *customCap, GpCustomLineCap **clonedCap);
[GdipGetCustomLineCapType]
1=GpCustomLineCap *customCap
2=CustomLineCapType *capType
ParamCount=2
@=GdipGetCustomLineCapType(GpCustomLineCap  *customCap, CustomLineCapType *capType);
[GdipSetCustomLineCapStrokeCaps]
1=GpCustomLineCap *customCap
2=GpLineCap startCap
3=GpLineCap endCap
ParamCount=3
@=GdipSetCustomLineCapStrokeCaps(GpCustomLineCap *customCap, GpLineCap startCap, GpLineCap endCap);
[GdipGetCustomLineCapStrokeCaps]
1=GpCustomLineCap *customCap
2=GpLineCap *startCap
3=GpLineCap *endCap
ParamCount=3
@=GdipGetCustomLineCapStrokeCaps(GpCustomLineCap *customCap, GpLineCap *startCap, GpLineCap *endCap);
[GdipSetCustomLineCapStrokeJoin]
1=GpCustomLineCap *customCap
2=GpLineJoin lineJoin
ParamCount=2
@=GdipSetCustomLineCapStrokeJoin(GpCustomLineCap *customCap, GpLineJoin lineJoin);
[GdipGetCustomLineCapStrokeJoin]
1=GpCustomLineCap *customCap
2=GpLineJoin *lineJoin
ParamCount=2
@=GdipGetCustomLineCapStrokeJoin(GpCustomLineCap *customCap, GpLineJoin *lineJoin);
[GdipSetCustomLineCapBaseCap]
1=GpCustomLineCap* customCap
2=GpLineCap baseCap
ParamCount=2
@=GdipSetCustomLineCapBaseCap(GpCustomLineCap *customCap, GpLineCap baseCap);
[GdipGetCustomLineCapBaseCap]
1=GpCustomLineCap *customCap
2=GpLineCap *baseCap
ParamCount=2
@=GdipGetCustomLineCapBaseCap(GpCustomLineCap *customCap, GpLineCap *baseCap);
[GdipSetCustomLineCapBaseInset]
1=GpCustomLineCap *customCap
2=REAL inset
ParamCount=2
@=GdipSetCustomLineCapBaseInset(GpCustomLineCap *customCap, REAL inset);
[GdipGetCustomLineCapBaseInset]
1=GpCustomLineCap *customCap
2=REAL *inset
ParamCount=2
@=GdipGetCustomLineCapBaseInset(GpCustomLineCap *customCap, REAL *inset);
[GdipSetCustomLineCapWidthScale]
1=GpCustomLineCap *customCap
2=REAL widthScale
ParamCount=2
@=GdipSetCustomLineCapWidthScale(GpCustomLineCap *customCap, REAL widthScale);
[GdipGetCustomLineCapWidthScale]
1=GpCustomLineCap *customCap
2=REAL *widthScale
ParamCount=2
@=GdipGetCustomLineCapWidthScale(GpCustomLineCap *customCap, REAL *widthScale);
[GdipCreateAdjustableArrowCap]
1=REAL height
2=REAL width
3=BOOL isFilled
4=GpAdjustableArrowCap **cap
ParamCount=4
@=GdipCreateAdjustableArrowCap(REAL height, REAL width, BOOL isFilled, GpAdjustableArrowCap **cap);
[GdipSetAdjustableArrowCapHeight]
1=GpAdjustableArrowCap *cap
2=REAL height
ParamCount=2
@=GdipSetAdjustableArrowCapHeight(GpAdjustableArrowCap *cap, REAL height);
[GdipGetAdjustableArrowCapHeight]
1=GpAdjustableArrowCap *cap
2=REAL *height
ParamCount=2
@=GdipGetAdjustableArrowCapHeight(GpAdjustableArrowCap *cap, REAL *height);
[GdipSetAdjustableArrowCapWidth]
1=GpAdjustableArrowCap *cap
2=REAL width
ParamCount=2
@=GdipSetAdjustableArrowCapWidth(GpAdjustableArrowCap *cap, REAL width);
[GdipGetAdjustableArrowCapWidth]
1=GpAdjustableArrowCap *cap
2=REAL *width
ParamCount=2
@=GdipGetAdjustableArrowCapWidth(GpAdjustableArrowCap *cap, REAL *width);
[GdipSetAdjustableArrowCapMiddleInset]
1=GpAdjustableArrowCap *cap
2=REALmiddleInset
ParamCount=2
@=GdipSetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap *cap, REAL middleInset);
[GdipGetAdjustableArrowCapMiddleInset]
1=GpAdjustableArrowCap *cap
2=REAL *middleInset
ParamCount=2
@=GdipGetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap *cap, REAL *middleInset);
[GdipSetAdjustableArrowCapFillState]
1=GpAdjustableArrowCap *cap
2=BOOL fillState
ParamCount=2
@=GdipSetAdjustableArrowCapFillState(GpAdjustableArrowCap *cap, BOOL fillState);
[GdipGetAdjustableArrowCapFillState]
1=GpAdjustableArrowCap *cap
2=BOOL *fillState
ParamCount=2
@=GdipGetAdjustableArrowCapFillState(GpAdjustableArrowCap *cap, BOOL *fillState);
[GdipLoadImageFromStream]
1=IStream *stream
2=GpImage **image
ParamCount=2
@=GdipLoadImageFromStream(IStream *stream, GpImage **image);
[GdipLoadImageFromFile]
1=GDIPCONST WCHAR *filename
2=GpImage **image
ParamCount=2
@=GdipLoadImageFromFile(GDIPCONST WCHAR *filename, GpImage **image);
[GdipLoadImageFromStreamICM]
1=IStream *stream
2=GpImage **image
ParamCount=2
@=GdipLoadImageFromStreamICM(IStream *stream, GpImage **image);
[GdipLoadImageFromFileICM]
1=GDIPCONST WCHAR *filename
2=GpImage **image
ParamCount=2
@=GdipLoadImageFromFileICM(GDIPCONST WCHAR *filename, GpImage **image);
[GdipCloneImage]
1=GpImage *image
2=GpImage **cloneImage
ParamCount=2
@=GdipCloneImage(GpImage *image, GpImage **cloneImage);
[GdipDisposeImage]
1=GpImage *image
ParamCount=1
@=GdipDisposeImage(GpImage *image);
[GdipSaveImageToFile]
1=GpImage *image
2=GDIPCONST WCHAR *filename
3=GDIPCONST CLSID *clsidEncoder
4= GDIPCONSTEncoderParameters*encoderParams
ParamCount=4
@=GdipSaveImageToFile(GpImage *image, GDIPCONST WCHAR *filename, GDIPCONST CLSID *clsidEncoder,  GDIPCONSTEncoderParameters *encoderParams);
[GdipSaveImageToStream]
1=GpImage *image
2=IStream *stream
3=GDIPCONST CLSID *clsidEncoder
4=GDIPCONST EncoderParameters *encoderParams
ParamCount=4
@=GdipSaveImageToStream(GpImage *image, IStream *stream, GDIPCONST CLSID *clsidEncoder, GDIPCONST EncoderParameters *encoderParams);
[GdipSaveAdd]
1=GpImage *image
2=GDIPCONST EncoderParameters *encoderParams
ParamCount=2
@=GdipSaveAdd(GpImage *image, GDIPCONST EncoderParameters *encoderParams);
[GdipSaveAddImage]
1=GpImage *image
2=GpImage *newImage
3=GDIPCONST EncoderParameters *encoderParams
ParamCount=3
@=GdipSaveAddImage(GpImage *image, GpImage *newImage, GDIPCONST EncoderParameters *encoderParams);
[GdipGetImageGraphicsContext]
1=GpImage *image
2=GpGraphics **graphics
ParamCount=2
@=GdipGetImageGraphicsContext(GpImage *image, GpGraphics **graphics);
[GdipGetImageBounds]
1=GpImage *image
2=GpRectF *srcRect
3=GpUnit *srcUnit
ParamCount=3
@=GdipGetImageBounds(GpImage *image, GpRectF *srcRect, GpUnit *srcUnit);
[GdipGetImageDimension]
1=GpImage *image
2=REAL *width
3=REAL *height
ParamCount=3
@=GdipGetImageDimension(GpImage *image, REAL *width, REAL *height);
[GdipGetImageType]
1=GpImage *image
2=ImageType *type
ParamCount=2
@=GdipGetImageType(GpImage *image, ImageType *type);
[GdipGetImageWidth]
1=GpImage *image
2=UINT *width
ParamCount=2
@=GdipGetImageWidth(GpImage *image, UINT *width);
[GdipGetImageHeight]
1=GpImage *image
2=UINT *height
ParamCount=2
@=GdipGetImageHeight(GpImage *image, UINT *height);
[GdipGetImageHorizontalResolution]
1=GpImage *image
2=REAL *resolution
ParamCount=2
@=GdipGetImageHorizontalResolution(GpImage *image, REAL *resolution);
[GdipGetImageVerticalResolution]
1=GpImage *image
2=REAL *resolution
ParamCount=2
@=GdipGetImageVerticalResolution(GpImage *image, REAL *resolution);
[GdipGetImageFlags]
1=GpImage *image
2=UINT *flags
ParamCount=2
@=GdipGetImageFlags(GpImage *image, UINT *flags);
[GdipGetImageRawFormat]
1=GpImage *image
2=GUID *format
ParamCount=2
@=GdipGetImageRawFormat(GpImage *image, GUID *format);
[GdipGetImagePixelFormat]
1=GpImage *image
2=PixelFormat *format
ParamCount=2
@=GdipGetImagePixelFormat(GpImage *image, PixelFormat *format);
[GdipGetImageThumbnail]
1=GpImage *image
2=UINT thumbWidth
3=UINT thumbHeight
4=GpImage **thumbImage
5=GetThumbnailImageAbort callback
6=VOID *callbackData
ParamCount=6
@=GdipGetImageThumbnail(GpImage *image, UINT thumbWidth, UINT thumbHeight, GpImage **thumbImage, GetThumbnailImageAbort callback, VOID *callbackData);
[GdipGetEncoderParameterListSize]
1=GpImage *image
2=GDIPCONST CLSID *clsidEncoder
3=UINT *size
ParamCount=3
@=GdipGetEncoderParameterListSize(GpImage *image, GDIPCONST CLSID *clsidEncoder, UINT *size);
[GdipGetEncoderParameterList]
1=GpImage *image
2=GDIPCONST CLSID *clsidEncoder
3=UINT size
4=EncoderParameters *buffer
ParamCount=4
@=GdipGetEncoderParameterList(GpImage *image, GDIPCONST CLSID *clsidEncoder, UINT size, EncoderParameters *buffer);
[GdipImageGetFrameDimensionsCount]
1=GpImage *image
2=UINT *count
ParamCount=2
@=GdipImageGetFrameDimensionsCount(GpImage *image, UINT *count);
[GdipImageGetFrameDimensionsList]
1=GpImage *image
2=GUID *dimensionIDs
3=UINT count
ParamCount=3
@=GdipImageGetFrameDimensionsList(GpImage *image, GUID* dimensionIDs, UINT count);
[GdipImageGetFrameCount]
1=GpImage *image
2=GDIPCONST GUID *dimensionID
3=UINT *count
ParamCount=3
@=GdipImageGetFrameCount(GpImage *image, GDIPCONST GUID *dimensionID, UINT *count);
[GdipImageSelectActiveFrame]
1=GpImage *image
2=GDIPCONST GUID *dimensionID
3=UINT frameIndex
ParamCount=3
@=GdipImageSelectActiveFrame(GpImage *image, GDIPCONST GUID *dimensionID, UINT frameIndex);
[GdipImageRotateFlip]
1=GpImage *image
2=RotateFlipType rfType
ParamCount=2
@=GdipImageRotateFlip(GpImage *image, RotateFlipType rfType);
[GdipGetImagePalette]
1=GpImage *image
2=ColorPalette *palette
3=INT size
ParamCount=3
@=GdipGetImagePalette(GpImage *image, ColorPalette *palette, INT size);
[GdipSetImagePalette]
1=GpImage *image
2=GDIPCONST ColorPalette *palette
ParamCount=2
@=GdipSetImagePalette(GpImage *image, GDIPCONST ColorPalette *palette);
[GdipGetImagePaletteSize]
1=GpImage *image
2=INT *size
ParamCount=2
@=GdipGetImagePaletteSize(GpImage *image, INT *size);
[GdipGetPropertyCount]
1=GpImage *image
2=UINT *numOfProperty
ParamCount=2
@=GdipGetPropertyCount(GpImage *image, UINT *numOfProperty);
[GdipGetPropertyIdList]
1=GpImage *image
2=UINT numOfProperty
3=PROPID *list
ParamCount=3
@=GdipGetPropertyIdList(GpImage *image, UINT numOfProperty, PROPID *list);
[GdipGetPropertyItemSize]
1=GpImage *image
2=PROPID propId
3=UINT *size
ParamCount=3
@=GdipGetPropertyItemSize(GpImage *image, PROPID propId, UINT *size);
[GdipGetPropertyItem]
1=GpImage *image
2=PROPID propId
3=INT propSize
4=PropertyItem *buffer
ParamCount=4
@=GdipGetPropertyItem(GpImage *image, PROPID propId, INT propSize, PropertyItem *buffer);
[GdipGetPropertySize]
1=GpImage *image
2=UINT *totalBufferSize
3=UINT *numProperties
ParamCount=3
@=GdipGetPropertySize(GpImage *image, UINT *totalBufferSize, UINT *numProperties);
[GdipGetAllPropertyItems]
1=GpImage *image
2=UINT totalBufferSize
3=UINT numProperties
4=PropertyItem *allItems
ParamCount=4
@=GdipGetAllPropertyItems(GpImage *image, UINT totalBufferSize, UINT numProperties, PropertyItem *allItems);
[GdipRemovePropertyItem]
1=GpImage *image
2=PROPID propId
ParamCount=2
@=GdipRemovePropertyItem(GpImage *image, PROPID propId);
[GdipSetPropertyItem]
1=GpImage *image
2=GDIPCONST PropertyItem *item
ParamCount=2
@=GdipSetPropertyItem(GpImage *image, GDIPCONST PropertyItem *item);
[GdipFindFirstImageItem]
1=GpImage *image
2=ImageItemData *item
ParamCount=2
@=GdipFindFirstImageItem(GpImage *image, ImageItemData *item);
[GdipFindNextImageItem]
1=GpImage *image
2=ImageItemData *item
ParamCount=2
@=GdipFindNextImageItem(GpImage *image, ImageItemData *item);
[GdipGetImageItemData]
1=GpImage *image
2=ImageItemData *item
ParamCount=2
@=GdipGetImageItemData(GpImage *image, ImageItemData *item);
[GdipImageForceValidation]
1=GpImage *image
ParamCount=1
@=GdipImageForceValidation(GpImage *image);
[GdipCreateBitmapFromStream]
1=IStream *stream
2=GpBitmap **bitmap
ParamCount=2
@=GdipCreateBitmapFromStream(IStream *stream, GpBitmap **bitmap);
[GdipCreateBitmapFromFile]
1=GDIPCONST WCHAR *filename
2=GpBitmap **bitmap
ParamCount=2
@=GdipCreateBitmapFromFile(GDIPCONST WCHAR *filename, GpBitmap **bitmap);
[GdipCreateBitmapFromStreamICM]
1=IStream *stream
2=GpBitmap **bitmap
ParamCount=2
@=GdipCreateBitmapFromStreamICM(IStream *stream, GpBitmap **bitmap);
[GdipCreateBitmapFromFileICM]
1=GDIPCONST WCHAR *filename
2=GpBitmap **bitmap
ParamCount=2
@=GdipCreateBitmapFromFileICM(GDIPCONST WCHAR *filename, GpBitmap **bitmap);
[GdipCreateBitmapFromScan0]
1=INT width
2=INT height
3=INT stride
4=PixelFormat format
5=BYTE *scan0
6=GpBitmap **bitmap
ParamCount=6
@=GdipCreateBitmapFromScan0(INT width, INT height, INT stride, PixelFormat format,  BYTE *scan0, GpBitmap **bitmap);
[GdipCreateBitmapFromGraphics]
1=INT width
2=INT height
3=GpGraphics *target
4=GpBitmap **bitmap
ParamCount=4
@=GdipCreateBitmapFromGraphics(INT width, INT height, GpGraphics *target, GpBitmap **bitmap);
[GdipCreateBitmapFromDirectDrawSurface]
1=IDirectDrawSurface7 *surface
2=GpBitmap **bitmap
ParamCount=2
@=GdipCreateBitmapFromDirectDrawSurface(IDirectDrawSurface7 *surface, GpBitmap **bitmap);
[GdipCreateBitmapFromGdiDib]
1=GDIPCONST BITMAPINFO *gdiBitmapInfo
2=VOID *gdiBitmapData
3=GpBitmap **bitmap
ParamCount=3
@=GdipCreateBitmapFromGdiDib(GDIPCONST BITMAPINFO *gdiBitmapInfo, VOID *gdiBitmapData, GpBitmap **bitmap);
[GdipCreateBitmapFromHBITMAP]
1=HBITMAP hbm
2=HPALETTE hpal
3=GpBitmap **bitmap
ParamCount=3
@=GdipCreateBitmapFromHBITMAP(HBITMAP hbm, HPALETTE hpal, GpBitmap **bitmap);
[GdipCreateHBITMAPFromBitmap]
1=GpBitmap *bitmap
2=HBITMAP *hbmReturn
3=ARGB background
ParamCount=3
@=GdipCreateHBITMAPFromBitmap(GpBitmap *bitmap, HBITMAP *hbmReturn, ARGB background);
[GdipCreateBitmapFromHICON]
1=HICON hicon
2=GpBitmap **bitmap
ParamCount=2
@=GdipCreateBitmapFromHICON(HICON hicon, GpBitmap **bitmap);
[GdipCreateHICONFromBitmap]
1=GpBitmap *bitmap
2=HICON *hbmReturn
ParamCount=2
@=GdipCreateHICONFromBitmap(GpBitmap *bitmap, HICON *hbmReturn);
[GdipCreateBitmapFromResource]
1=HINSTANCE hInstance
2=GDIPCONST WCHAR *lpBitmapName
3=GpBitmap **bitmap
ParamCount=3
@=GdipCreateBitmapFromResource(HINSTANCE hInstance, GDIPCONST WCHAR *lpBitmapName, GpBitmap **bitmap);
[GdipCloneBitmapArea]
1=REAL x
2=REAL y
3=REAL width
4=REAL height
5=PixelFormat format
6=GpBitmap *srcBitmap
7=GpBitmap **dstBitmap
ParamCount=7
@=GdipCloneBitmapArea(REAL x, REAL y, REAL width, REAL height, PixelFormat format, GpBitmap *srcBitmap, GpBitmap **dstBitmap);
[GdipCloneBitmapAreaI]
1=INT x
2=INT y
3=INT width
4=INT height
5=PixelFormat format
6=GpBitmap *srcBitmap
7=GpBitmap **dstBitmap
ParamCount=7
@=GdipCloneBitmapAreaI(INT x, INT y, INT width, INT height, PixelFormat format, GpBitmap *srcBitmap, GpBitmap **dstBitmap);
[GdipBitmapLockBits]
1=GpBitmap *bitmap
2=GDIPCONST GpRect *rect
3=UINT flags
4=PixelFormat format
5=BitmapData *lockedBitmapData
ParamCount=5
@=GdipBitmapLockBits(GpBitmap *bitmap, GDIPCONST GpRect *rect, UINT flags, PixelFormat format, BitmapData *lockedBitmapData);
[GdipBitmapUnlockBits]
1=GpBitmap *bitmap
2=BitmapData *lockedBitmapData
ParamCount=2
@=GdipBitmapUnlockBits(GpBitmap *bitmap, BitmapData *lockedBitmapData);
[GdipBitmapGetPixel]
1=GpBitmap *bitmap
2=INT x
3=INT y
4=ARGB *color
ParamCount=4
@=GdipBitmapGetPixel(GpBitmap *bitmap, INT x, INT y, ARGB *color);
[GdipBitmapSetPixel]
1=GpBitmap *bitmap
2=INT x
3=INT y
4=ARGB color
ParamCount=4
@=GdipBitmapSetPixel(GpBitmap *bitmap, INT x, INT y, ARGB color);
[dipImageSetAbort]
1=GpImage *pImage
2=GdiplusAbort *pIAbort
ParamCount=2
@=dipImageSetAbort(GpImage *pImage, GdiplusAbort *pIAbort);
[dipGraphicsSetAbort]
1=GpGraphics *pGraphics
2=GdiplusAbort *pIAbort
ParamCount=2
@=dipGraphicsSetAbort(GpGraphics *pGraphics, GdiplusAbort *pIAbort);
[GdipBitmapConvertFormat]
1=GpBitmap *pInputBitmap
2=PixelFormat format
3=DitherType dithertype
4=PaletteType palettetype
5=ColorPalette *palette
6=REAL alphaThresholdPercent
ParamCount=6
@=GdipBitmapConvertFormat(GpBitmap *pInputBitmap, PixelFormat format, DitherType dithertype, PaletteType palettetype, ColorPalette *palette, REAL alphaThresholdPercent);
[GdipInitializePalette]
1=ColorPalette *palette
2=PaletteType palettetype
3=INT optimalColors
4=BOOL useTransparentColor
5=GpBitmap *bitmap
ParamCount=5
@=GdipInitializePalette(ColorPalette*palette, PaletteType palettetype, INT optimalColors, BOOL useTransparentColor, GpBitmap *bitmap);
[GdipBitmapApplyEffect]
1=GpBitmap *bitmap
2=CGpEffect *effect
3=RECT *roi
4=BOOL useAuxData
5=VOID **auxData
6=INT *auxDataSize
ParamCount=6
@=GdipBitmapApplyEffect(GpBitmap *bitmap, CGpEffect *effect, RECT *roi, BOOL useAuxData, VOID **auxData, INT *auxDataSize);
[GdipBitmapCreateApplyEffect]
1=GpBitmap **inputBitmaps
2=INT numInputs
3=CGpEffect *effect
4=RECT *roi
5=RECT *outputRect
6=GpBitmap **outputBitmap
7=BOOL useAuxData
8=VOID **auxData
9=INT *auxDataSize
ParamCount=9
@=GdipBitmapCreateApplyEffect(GpBitmap **inputBitmaps, INT numInputs, CGpEffect *effect, RECT *roi, RECT *outputRect, GpBitmap **outputBitmap, BOOL useAuxData, VOID **auxData, INT *auxDataSize);
[GdipBitmapGetHistogram]
1=GpBitmap *bitmap
2=HistogramFormat format
3=UINT NumberOfEntries
4=UINT *channel0
5=UINT *channel1
6=UINT *channel2
7=UINT *channel3
ParamCount=7
@=GdipBitmapGetHistogram(GpBitmap *bitmap, HistogramFormat format, UINT NumberOfEntries, UINT *channel0, UINT *channel1, UINT *channel2, UINT *channel3);
[GdipBitmapGetHistogramSize]
1=HistogramFormat format
2=UINT *NumberOfEntries
ParamCount=2
@=GdipBitmapGetHistogramSize(HistogramFormat format, UINT *NumberOfEntries);
[GdipBitmapSetResolution]
1=GpBitmap *bitmap
2=REAL xdpi
3=REAL ydpi
ParamCount=3
@=GdipBitmapSetResolution(GpBitmap *bitmap, REAL xdpi, REAL ydpi);
[GdipCreateImageAttributes]
1=GpImageAttributes **imageattr
ParamCount=1
@=GdipCreateImageAttributes(GpImageAttributes **imageattr);
[GdipCloneImageAttributes]
1=GDIPCONST GpImageAttributes*imageattr
2=GpImageAttributes **cloneImageattr
ParamCount=2
@=GdipCloneImageAttributes(GDIPCONST GpImageAttributes*imageattr, GpImageAttributes **cloneImageattr);
[GdipDisposeImageAttributes]
1=GpImageAttributes *imageattr
ParamCount=1
@=GdipDisposeImageAttributes(GpImageAttributes *imageattr);
[GdipSetImageAttributesToIdentity]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
ParamCount=2
@=GdipSetImageAttributesToIdentity(GpImageAttributes *imageattr, ColorAdjustType type);
[GdipResetImageAttributes]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
ParamCount=2
@=GdipResetImageAttributes(GpImageAttributes *imageattr, ColorAdjustType type);
[GdipSetImageAttributesColorMatrix]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
3=BOOL enableFlag
4=GDIPCONST ColorMatrix *colorMatrix
5=GDIPCONST ColorMatrix *grayMatrix
6=ColorMatrixFlags flags
ParamCount=6
@=GdipSetImageAttributesColorMatrix(GpImageAttributes *imageattr, ColorAdjustType type, BOOL enableFlag, GDIPCONST ColorMatrix *colorMatrix, GDIPCONST ColorMatrix *grayMatrix, ColorMatrixFlags flags);
[GdipSetImageAttributesThreshold]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
3=BOOL enableFlag
4=REAL threshold
ParamCount=4
@=GdipSetImageAttributesThreshold(GpImageAttributes *imageattr, ColorAdjustType type, BOOL enableFlag, REAL threshold);
[GdipSetImageAttributesGamma]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
3=BOOL enableFlag
4=REAL gamma
ParamCount=4
@=GdipSetImageAttributesGamma(GpImageAttributes *imageattr, ColorAdjustType type, BOOL enableFlag, REAL gamma);
[GdipSetImageAttributesNoOp]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
3=BOOL enableFlag
ParamCount=3
@=GdipSetImageAttributesNoOp(GpImageAttributes *imageattr, ColorAdjustType type, BOOL enableFlag);
[GdipSetImageAttributesColorKeys]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
3=BOOL enableFlag
4=ARGB colorLow
5=ARGB colorHigh
ParamCount=5
@=GdipSetImageAttributesColorKeys(GpImageAttributes *imageattr, ColorAdjustType type, BOOL enableFlag, ARGB colorLow, ARGB colorHigh);
[GdipSetImageAttributesOutputChannel]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
3=BOOL enableFlag
4=ColorChannelFlags channelFlags
ParamCount=4
@=GdipSetImageAttributesOutputChannel(GpImageAttributes *imageattr, ColorAdjustType type, BOOL enableFlag, ColorChannelFlags channelFlags);
[GdipSetImageAttributesOutputChannelColorProfile]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
3=BOOL enableFlag
4=GDIPCONST WCHAR*colorProfileFilename
ParamCount=4
@=GdipSetImageAttributesOutputChannelColorProfile(GpImageAttributes *imageattr, ColorAdjustType type, BOOL enableFlag, GDIPCONST WCHAR*colorProfileFilename);
[GdipSetImageAttributesRemapTable]
1=GpImageAttributes *imageattr
2=ColorAdjustType type
3=BOOL enableFlag
4=UINT mapSize
5=GDIPCONST ColorMap *map
ParamCount=5
@=GdipSetImageAttributesRemapTable(GpImageAttributes *imageattr, ColorAdjustType type, BOOL enableFlag, UINT mapSize, GDIPCONST ColorMap *map);
[GdipSetImageAttributesWrapMode]
1=GpImageAttributes *imageAttr
2=WrapMode wrap
3=ARGB argb
4=BOOL clamp
ParamCount=4
@=GdipSetImageAttributesWrapMode(GpImageAttributes *imageAttr, WrapMode wrap, ARGB argb, BOOL clamp);
[GdipSetImageAttributesICMMode]
1=GpImageAttributes *imageAttr
2=BOOL on
ParamCount=2
@=GdipSetImageAttributesICMMode(GpImageAttributes *imageAttr, BOOL on);
[GdipGetImageAttributesAdjustedPalette]
1=GpImageAttributes *imageAttr
2=ColorPalette *colorPalette
3=ColorAdjustType colorAdjustType
ParamCount=3
@=GdipGetImageAttributesAdjustedPalette(GpImageAttributes *imageAttr, ColorPalette *colorPalette, ColorAdjustType colorAdjustType);
[GdipFlush]
1=GpGraphics *graphics
2=GpFlushIntention intention
ParamCount=2
@=GdipFlush(GpGraphics *graphics, GpFlushIntention intention);
[GdipCreateFromHDC]
1=HDC hdc
2=GpGraphics **graphics
ParamCount=2
@=GdipCreateFromHDC(HDC hdc, GpGraphics **graphics);
[GdipCreateFromHDC2]
1=HDC hdc
2=HANDLE hDevice
3=GpGraphics **graphics
ParamCount=3
@=GdipCreateFromHDC2(HDC hdc, HANDLE hDevice, GpGraphics **graphics);
[GdipCreateFromHWND]
1=HWND hwnd
2=GpGraphics **graphics
ParamCount=2
@=GdipCreateFromHWND(HWND hwnd, GpGraphics **graphics);
[GdipCreateFromHWNDICM]
1=HWND hwnd
2=GpGraphics **graphics
ParamCount=2
@=GdipCreateFromHWNDICM(HWND hwnd, GpGraphics **graphics);
[GdipDeleteGraphics]
1=GpGraphics *graphics
ParamCount=1
@=GdipDeleteGraphics(GpGraphics *graphics);
[GdipGetDC]
1=GpGraphics* graphics
2=HDC *hdc
ParamCount=2
@=GdipGetDC(GpGraphics* graphics, HDC *hdc);
[GdipReleaseDC]
1=GpGraphics* graphics
2=HDC hdc
ParamCount=2
@=GdipReleaseDC(GpGraphics* graphics, HDC hdc);
[GdipSetCompositingMode]
1=GpGraphics *graphics
2=CompositingMode compositingMode
ParamCount=2
@=GdipSetCompositingMode(GpGraphics *graphics, CompositingMode compositingMode);
[GdipGetCompositingMode]
1=GpGraphics *graphics
2=CompositingMode *compositingMode
ParamCount=2
@=GdipGetCompositingMode(GpGraphics *graphics, CompositingMode *compositingMode);
[GdipSetRenderingOrigin]
1=GpGraphics *graphics
2=INT x
3=INT y
ParamCount=3
@=GdipSetRenderingOrigin(GpGraphics *graphics, INT x, INT y);
[GdipGetRenderingOrigin]
1=GpGraphics *graphics
2=INT *x
3=INT *y
ParamCount=3
@=GdipGetRenderingOrigin(GpGraphics *graphics, INT *x, INT *y);
[GdipSetCompositingQuality]
1=GpGraphics *graphics
2=CompositingQuality compositingQuality
ParamCount=2
@=GdipSetCompositingQuality(GpGraphics *graphics, CompositingQuality compositingQuality);
[GdipGetCompositingQuality]
1=GpGraphics *graphics
2=CompositingQuality *compositingQuality
ParamCount=2
@=GdipGetCompositingQuality(GpGraphics *graphics, CompositingQuality *compositingQuality);
[GdipSetSmoothingMode]
1=GpGraphics *graphics
2=SmoothingMode smoothingMode
ParamCount=2
@=GdipSetSmoothingMode(GpGraphics *graphics, SmoothingMode smoothingMode);
[GdipGetSmoothingMode]
1=GpGraphics *graphics
2=SmoothingMode *smoothingMode
ParamCount=2
@=GdipGetSmoothingMode(GpGraphics *graphics, SmoothingMode *smoothingMode);
[GdipSetPixelOffsetMode]
1=GpGraphics* graphics
2=PixelOffsetMode pixelOffsetMode
ParamCount=2
@=GdipSetPixelOffsetMode(GpGraphics* graphics, PixelOffsetMode pixelOffsetMode);
[GdipGetPixelOffsetMode]
1=GpGraphics *graphics
2=PixelOffsetMode *pixelOffsetMode
ParamCount=2
@=GdipGetPixelOffsetMode(GpGraphics *graphics, PixelOffsetMode *pixelOffsetMode);
[GdipSetTextRenderingHint]
1=GpGraphics *graphics
2=TextRenderingHint mode
ParamCount=2
@=GdipSetTextRenderingHint(GpGraphics *graphics, TextRenderingHint mode);
[GdipGetTextRenderingHint]
1=GpGraphics *graphics
2=TextRenderingHint *mode
ParamCount=2
@=GdipGetTextRenderingHint(GpGraphics *graphics, TextRenderingHint *mode);
[GdipSetTextContrast]
1=GpGraphics *graphics
2=UINT contrast
ParamCount=2
@=GdipSetTextContrast(GpGraphics *graphics, UINT contrast);
[GdipGetTextContrast]
1=GpGraphics *graphics
2=UINT *contrast
ParamCount=2
@=GdipGetTextContrast(GpGraphics *graphics, UINT *contrast);
[GdipSetInterpolationMode]
1=GpGraphics *graphics
2=InterpolationMode interpolationMode
ParamCount=2
@=GdipSetInterpolationMode(GpGraphics *graphics, InterpolationMode interpolationMode);
[GdipGetInterpolationMode]
1=GpGraphics *graphics
2=InterpolationMode*interpolationMode
ParamCount=2
@=GdipGetInterpolationMode(GpGraphics *graphics, InterpolationMode *interpolationMode);
[GdipSetWorldTransform]
1=GpGraphics *graphics
2=GpMatrix *matrix
ParamCount=2
@=GdipSetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);
[GdipResetWorldTransform]
1=GpGraphics *graphics
ParamCount=1
@=GdipResetWorldTransform(GpGraphics *graphics);
[GdipMultiplyWorldTransform]
1=GpGraphics *graphics
2=GDIPCONST GpMatrix *matrix
3=GpMatrixOrder order
ParamCount=3
@=GdipMultiplyWorldTransform(GpGraphics *graphics, GDIPCONST GpMatrix *matrix, GpMatrixOrder order);
[GdipTranslateWorldTransform]
1=GpGraphics *graphics
2=REAL dx
3=REAL dy
4=GpMatrixOrder order
ParamCount=4
@=GdipTranslateWorldTransform(GpGraphics *graphics, REAL dx, REAL dy, GpMatrixOrder order);
[GdipScaleWorldTransform]
1=GpGraphics *graphics
2=REAL sx
3=REAL sy
4=GpMatrixOrder order
ParamCount=4
@=GdipScaleWorldTransform(GpGraphics *graphics, REAL sx, REAL sy, GpMatrixOrder order);
[GdipRotateWorldTransform]
1=GpGraphics *graphics
2=REAL angle
3= GpMatrixOrderorder
ParamCount=3
@=GdipRotateWorldTransform(GpGraphics *graphics, REAL angle,  GpMatrixOrderorder);
[GdipGetWorldTransform]
1=GpGraphics *graphics
2=GpMatrix *matrix
ParamCount=2
@=GdipGetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);
[GdipResetPageTransform]
1=GpGraphics *graphics
ParamCount=1
@=GdipResetPageTransform(GpGraphics *graphics);
[GdipGetPageUnit]
1=GpGraphics *graphics
2=GpUnit *unit
ParamCount=2
@=GdipGetPageUnit(GpGraphics *graphics, GpUnit *unit);
[GdipGetPageScale]
1=GpGraphics *graphics
2=REAL *scale
ParamCount=2
@=GdipGetPageScale(GpGraphics *graphics, REAL *scale);
[GdipSetPageUnit]
1=GpGraphics *graphics
2=GpUnit unit
ParamCount=2
@=GdipSetPageUnit(GpGraphics *graphics, GpUnit unit);
[GdipSetPageScale]
1=GpGraphics *graphics
2=REAL scale
ParamCount=2
@=GdipSetPageScale(GpGraphics *graphics, REAL scale);
[GdipGetDpiX]
1=GpGraphics *graphics
2=REAL* dpi
ParamCount=2
@=GdipGetDpiX(GpGraphics *graphics, REAL* dpi);
[GdipGetDpiY]
1=GpGraphics *graphics
2=REAL* dpi
ParamCount=2
@=GdipGetDpiY(GpGraphics *graphics, REAL* dpi);
[GdipTransformPoints]
1=GpGraphics *graphics
2=GpCoordinateSpace destSpace
3=GpCoordinateSpace srcSpace
4=GpPointF *points
5=INT count
ParamCount=5
@=GdipTransformPoints(GpGraphics *graphics, GpCoordinateSpace destSpace, GpCoordinateSpace srcSpace, GpPointF *points, INT count);
[GdipTransformPointsI]
1=GpGraphics *graphics
2=GpCoordinateSpace destSpace
3=GpCoordinateSpace srcSpace
4=GpPoint *points
5=INT count
ParamCount=5
@=GdipTransformPointsI(GpGraphics *graphics, GpCoordinateSpace destSpace, GpCoordinateSpace srcSpace, GpPoint *points, INT count);
[GdipGetNearestColor]
1=GpGraphics *graphics
2=ARGB *argb
ParamCount=2
@=GdipGetNearestColor(GpGraphics *graphics, ARGB *argb);
[GdipDrawLine]
1=GpGraphics *graphics
2=GpPen *pen
3=REAL x1
4=REAL y1
5=REAL x2
6=REAL y2
ParamCount=6
@=GdipDrawLine(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1, REAL x2, REAL y2);
[GdipDrawLineI]
1=GpGraphics *graphics
2=GpPen *pen
3=INT x1
4=INT y1
5=INT x2
6=INT y2
ParamCount=6
@=GdipDrawLineI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1, INT x2, INT y2);
[GdipDrawLines]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPointF *points
4=INT count
ParamCount=4
@=GdipDrawLines(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points, INT count);
[GdipDrawLinesI]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPoint *points
4=INT count
ParamCount=4
@=GdipDrawLinesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count);
[GdipDrawArc]
1=GpGraphics *graphics
2=GpPen *pen
3=REAL x
4=REAL y
5=REAL width
6=REAL height
7=REAL startAngle
8=REAL sweepAngle
ParamCount=8
@=GdipDrawArc(GpGraphics *graphics, GpPen *pen, REAL x, REAL y, REAL width, REAL height, REAL startAngle, REAL sweepAngle);
[GdipDrawArcI]
1=GpGraphics *graphics
2=GpPen *pen
3=INT x
4=INT y
5=INT width
6=INT height
7=REAL startAngle
8=REAL sweepAngle
ParamCount=8
@=GdipDrawArcI(GpGraphics *graphics, GpPen *pen, INT x, INT y, INT width, INT height, REAL startAngle, REAL sweepAngle);
[GdipDrawBezier]
1=GpGraphics *graphics
2=GpPen *pen
3=REAL x1
4=REAL y1
5=REAL x2
6=REAL y2
7=REAL x3
8=REAL y3
9=REAL x4
10=REAL y4
ParamCount=10
@=GdipDrawBezier(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1, REAL x2, REAL y2, REAL x3, REAL y3, REAL x4, REAL y4);
[GdipDrawBezierI]
1=GpGraphics *graphics
2=GpPen *pen
3=INT x1
4=INT y1
5=INT x2
6=INT y2
7=INT x3
8=INT y3
9=INT x4
10=INT y4
ParamCount=10
@=GdipDrawBezierI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);
[GdipDrawBeziers]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPointF *points
4=INT count
ParamCount=4
@=GdipDrawBeziers(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points, INT count);
[GdipDrawBeziersI]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPoint *points
4=INT count
ParamCount=4
@=GdipDrawBeziersI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count);
[GdipDrawRectangle]
1=GpGraphics *graphics
2=GpPen *pen
3=REAL x
4=REAL y
5=REAL width
6=REAL height
ParamCount=6
@=GdipDrawRectangle(GpGraphics *graphics, GpPen *pen, REAL x, REAL y, REAL width, REAL height);
[GdipDrawRectangleI]
1=GpGraphics *graphics
2=GpPen *pen
3=INT x
4=INT y
5=INT width
6=INT height
ParamCount=6
@=GdipDrawRectangleI(GpGraphics *graphics, GpPen *pen, INT x, INT y, INT width, INT height);
[GdipDrawRectangles]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpRectF *rects
4=INT count
ParamCount=4
@=GdipDrawRectangles(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRectF *rects, INT count);
[GdipDrawRectanglesI]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpRect *rects
4=INT count
ParamCount=4
@=GdipDrawRectanglesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRect *rects, INT count);
[GdipDrawEllipse]
1=GpGraphics *graphics
2=GpPen *pen
3=REAL x
4=REAL y
5=REAL width
6=REAL height
ParamCount=6
@=GdipDrawEllipse(GpGraphics *graphics, GpPen *pen, REAL x, REAL y, REAL width, REAL height);
[GdipDrawEllipseI]
1=GpGraphics *graphics
2=GpPen *pen
3=INT x
4=INT y
5=INT width
6=INT height
ParamCount=6
@=GdipDrawEllipseI(GpGraphics *graphics, GpPen *pen, INT x, INT y, INT width, INT height);
[GdipDrawPie]
1=GpGraphics *graphics
2=GpPen *pen
3=REAL x
4=REAL y
5=REAL width
6=REAL height
7=REAL startAngle
8=REAL sweepAngle
ParamCount=8
@=GdipDrawPie(GpGraphics *graphics, GpPen *pen, REAL x, REAL y, REAL width, REAL height, REAL startAngle, REAL sweepAngle);
[GdipDrawPieI]
1=GpGraphics *graphics
2=GpPen *pen
3=INT x
4=INT y
5=INT width
6=INT height
7=REAL startAngle
8=REAL sweepAngle
ParamCount=8
@=GdipDrawPieI(GpGraphics *graphics, GpPen *pen, INT x, INT y, INT width, INT height, REAL startAngle, REAL sweepAngle);
[GdipDrawPolygon]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPointF *points
4=INT count
ParamCount=4
@=GdipDrawPolygon(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points, INT count);
[GdipDrawPolygonI]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPoint *points
4=INT count
ParamCount=4
@=GdipDrawPolygonI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count);
[GdipDrawPath]
1=GpGraphics *graphics
2=GpPen *pen
3=GpPath *path
ParamCount=3
@=GdipDrawPath(GpGraphics *graphics, GpPen *pen, GpPath *path);
[GdipDrawCurve]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPointF*points
4=INT count
ParamCount=4
@=GdipDrawCurve(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points, INT count);
[GdipDrawCurveI]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPoint *points
4=INT count
ParamCount=4
@=GdipDrawCurveI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count);
[GdipDrawCurve2]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPointF *points
4=INT count
5=REAL tension
ParamCount=5
@=GdipDrawCurve2(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points, INT count, REAL tension);
[GdipDrawCurve2I]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPoint *points
4=INT count
5=REAL tension
ParamCount=5
@=GdipDrawCurve2I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count, REAL tension);
[GdipDrawCurve3]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPointF *points
4=INT count
5=INT offset
6=INT numberOfSegments
7=REAL tension
ParamCount=7
@=GdipDrawCurve3(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points, INT count, INT offset, INT numberOfSegments, REAL tension);
[GdipDrawCurve3I]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPoint *points
4=INT count
5=INT offset
6=INT numberOfSegments
7=REAL tension
ParamCount=7
@=GdipDrawCurve3I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count, INT offset, INT numberOfSegments, REAL tension);
[GdipDrawClosedCurve]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPointF *points
4=INT count
ParamCount=4
@=GdipDrawClosedCurve(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points, INT count);
[GdipDrawClosedCurveI]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPoint *points
4=INT count
ParamCount=4
@=GdipDrawClosedCurveI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count);
[GdipDrawClosedCurve2]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPointF *points
4=INT count
5=REAL tension
ParamCount=5
@=GdipDrawClosedCurve2(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points, INT count, REAL tension);
[GdipDrawClosedCurve2I]
1=GpGraphics *graphics
2=GpPen *pen
3=GDIPCONST GpPoint *points
4=INT count
5=REAL tension
ParamCount=5
@=GdipDrawClosedCurve2I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count, REAL tension);
[GdipGraphicsClear]
1=GpGraphics *graphics
2=ARGB color
ParamCount=2
@=GdipGraphicsClear(GpGraphics *graphics, ARGB color);
[GdipFillRectangle]
1=GpGraphics *graphics
2=GpBrush *brush
3=REAL x
4=REAL y
5=REAL width
6=REAL height
ParamCount=6
@=GdipFillRectangle(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y, REAL width, REAL height);
[GdipFillRectangleI]
1=GpGraphics *graphics
2=GpBrush *brush
3=INT x
4=INT y
5=INT width
6=INT height
ParamCount=6
@=GdipFillRectangleI(GpGraphics *graphics, GpBrush *brush, INT x, INT y, INT width, INT height);
[GdipFillRectangles]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpRectF *rects
4=INT count
ParamCount=4
@=GdipFillRectangles(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpRectF *rects, INT count);
[GdipFillRectanglesI]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpRect *rects
4=INT count
ParamCount=4
@=GdipFillRectanglesI(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpRect *rects, INT count);
[GdipFillPolygon]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpPointF *points
4=INT count
5=GpFillMode fillMode
ParamCount=5
@=GdipFillPolygon(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPointF *points, INT count, GpFillMode fillMode);
[GdipFillPolygonI]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpPoint *points
4=INT count
5=GpFillMode fillMode
ParamCount=5
@=GdipFillPolygonI(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPoint *points, INT count, GpFillMode fillMode);
[GdipFillPolygon2]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpPointF *points
4=INT count
ParamCount=4
@=GdipFillPolygon2(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPointF *points, INT count);
[GdipFillPolygon2I]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpPoint *points
4=INT count
ParamCount=4
@=GdipFillPolygon2I(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPoint *points, INT count);
[GdipFillEllipse]
1=GpGraphics *graphics
2=GpBrush *brush
3=REAL x
4=REAL y
5=REAL width
6=REAL height
ParamCount=6
@=GdipFillEllipse(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y, REAL width, REAL height);
[GdipFillEllipseI]
1=GpGraphics *graphics
2=GpBrush *brush
3=INT x
4=INT y
5=INT width
6=INT height
ParamCount=6
@=GdipFillEllipseI(GpGraphics *graphics, GpBrush *brush, INT x, INT y, INT width, INT height);
[GdipFillPie]
1=GpGraphics *graphics
2=GpBrush *brush
3=REAL x
4=REAL y
5=REAL width
6=REAL height
7=REAL startAngle
8=REAL sweepAngle
ParamCount=8
@=GdipFillPie(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y, REAL width, REAL height, REAL startAngle, REAL sweepAngle);
[GdipFillPieI]
1=GpGraphics *graphics
2=GpBrush *brush
3=INT x
4=INT y
5=INT width
6=INT height
7=REAL startAngle
8=REAL sweepAngle
ParamCount=8
@=GdipFillPieI(GpGraphics *graphics, GpBrush *brush, INT x, INT y, INT width, INT height, REAL startAngle, REAL sweepAngle);
[GdipFillPath]
1=GpGraphics *graphics
2=GpBrush *brush
3=GpPath *path
ParamCount=3
@=GdipFillPath(GpGraphics *graphics, GpBrush *brush, GpPath *path);
[GdipFillClosedCurve]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpPointF *points
4=INT count
ParamCount=4
@=GdipFillClosedCurve(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPointF *points, INT count);
[GdipFillClosedCurveI]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpPoint *points
4=INT count
ParamCount=4
@=GdipFillClosedCurveI(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPoint *points, INT count);
[GdipFillClosedCurve2]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpPointF *points
4=INT count
5=REAL tension
6=GpFillMode fillMode
ParamCount=6
@=GdipFillClosedCurve2(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPointF *points, INT count, REAL tension, GpFillMode fillMode);
[GdipFillClosedCurve2I]
1=GpGraphics *graphics
2=GpBrush *brush
3=GDIPCONST GpPoint *points
4=INT count
5=REAL tension
6=GpFillMode fillMode
ParamCount=6
@=GdipFillClosedCurve2I(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPoint *points, INT count, REAL tension, GpFillMode fillMode);
[GdipFillRegion]
1=GpGraphics *graphics
2=GpBrush *brush
3=GpRegion *region
ParamCount=3
@=GdipFillRegion(GpGraphics *graphics, GpBrush *brush, GpRegion *region);
[GdipDrawImageFX]
1=GpGraphics *graphics
2=GpImage *image
3=GpRectF *source
4=GpMatrix *xForm
5=CGpEffect *effect
6=GpImageAttributes *imageAttributes
7=GpUnit srcUnit
ParamCount=7
@=GdipDrawImageFX(GpGraphics *graphics, GpImage *image, GpRectF *source, GpMatrix *xForm, CGpEffect *effect, GpImageAttributes *imageAttributes, GpUnit srcUnit);
[GdipDrawImage]
1=GpGraphics *graphics
2=GpImage *image
3=REAL x
4=REAL y
ParamCount=4
@=GdipDrawImage(GpGraphics *graphics, GpImage *image, REAL x, REAL y);
[GdipDrawImageI]
1=GpGraphics *graphics
2=GpImage *image
3=INT x
4=INT y
ParamCount=4
@=GdipDrawImageI(GpGraphics *graphics, GpImage *image, INT x, INT y);
[GdipDrawImageRect]
1=GpGraphics *graphics
2=GpImage *image
3=REAL x
4=REAL y
5=REAL width
6=REAL height
ParamCount=6
@=GdipDrawImageRect(GpGraphics *graphics, GpImage *image, REAL x, REAL y, REAL width, REAL height);
[GdipDrawImageRectI]
1=GpGraphics *graphics
2=GpImage *image
3=INT x
4=INT y
5=INT width
6=INT height
ParamCount=6
@=GdipDrawImageRectI(GpGraphics *graphics, GpImage *image, INT x, INT y, INT width, INT height);
[GdipDrawImagePoints]
1=GpGraphics *graphics
2=GpImage *image
3=GDIPCONST GpPointF *dstpoints
4=INT count
ParamCount=4
@=GdipDrawImagePoints(GpGraphics *graphics, GpImage *image, GDIPCONST GpPointF *dstpoints, INT count);
[GdipDrawImagePointsI]
1=GpGraphics *graphics
2=GpImage *image
3=GDIPCONST GpPoint *dstpoints
4=INT count
ParamCount=4
@=GdipDrawImagePointsI(GpGraphics *graphics, GpImage *image, GDIPCONST GpPoint *dstpoints, INT count);
[GdipDrawImagePointRect]
1=GpGraphics *graphics
2=GpImage *image
3=REAL x
4=REAL y
5=REAL srcx
6=REAL srcy
7=REAL srcwidth
8=REAL srcheight
9=GpUnit srcUnit
ParamCount=9
@=GdipDrawImagePointRect(GpGraphics *graphics, GpImage *image, REAL x, REAL y, REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight, GpUnit srcUnit);
[GdipDrawImagePointRectI]
1=GpGraphics *graphics
2=GpImage *image
3=INT x
4=INT y
5=INT srcx
6=INT srcy
7=INT srcwidth
8=INT srcheight
9=GpUnit srcUnit
ParamCount=9
@=GdipDrawImagePointRectI(GpGraphics *graphics, GpImage *image, INT x, INT y, INT srcx, INT srcy, INT srcwidth, INT srcheight, GpUnit srcUnit);
[GdipDrawImageRectRect]
1=GpGraphics *graphics
2=GpImage *image
3=REAL dstx
4=REAL dsty
5=REAL dstwidth
6=REAL dstheight
7=REAL srcx
8=REAL srcy
9=REAL srcwidth
10=REAL srcheight
11=GpUnit srcUnit
12=GDIPCONST GpImageAttributes *imageAttributes
13=DrawImageAbort callback
14=VOID *callbackData
ParamCount=14
@=GdipDrawImageRectRect(GpGraphics *graphics, GpImage *image, REAL dstx, REAL dsty, REAL dstwidth, REAL dstheight, REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight, GpUnit srcUnit, GDIPCONST GpImageAttributes *imageAttributes, DrawImageAbort callback, VOID *callbackData);
[GdipDrawImageRectRectI]
1=GpGraphics *graphics
2=GpImage *image
3=INT dstx
4=INT dsty
5=INT dstwidth
6=INT dstheight
7=INT srcx
8=INT srcy
9=INT srcwidth
10=INT srcheight
11=GpUnit srcUnit
12=GDIPCONST GpImageAttributes *imageAttributes
13=DrawImageAbort callback
14=VOID *callbackData
ParamCount=14
@=GdipDrawImageRectRectI(GpGraphics *graphics, GpImage *image, INT dstx, INT dsty, INT dstwidth, INT dstheight, INT srcx, INT srcy, INT srcwidth, INT srcheight, GpUnit srcUnit, GDIPCONST GpImageAttributes *imageAttributes, DrawImageAbort callback, VOID *callbackData);
[GdipDrawImagePointsRect]
1=GpGraphics *graphics
2=GpImage *image
3=GDIPCONST GpPointF *points
4=INT count
5=REAL srcx
6=REAL srcy
7=REAL srcwidth
8=REAL srcheight
9=GpUnit srcUnit
10=GDIPCONST GpImageAttributes*imageAttributes
11=DrawImageAbort callback
12=VOID *callbackData
ParamCount=12
@=GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image, GDIPCONST GpPointF *points, INT count, REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight, GpUnit srcUnit, GDIPCONST GpImageAttributes*imageAttributes, DrawImageAbort callback, VOID *callbackData);
[GdipDrawImagePointsRectI]
1=GpGraphics *graphics
2=GpImage *image
3=GDIPCONST GpPoint *points
4=INT count
5=INT srcx
6=INT srcy
7=INT srcwidth
8=INT srcheight
9=GpUnit srcUnit
10=GDIPCONST GpImageAttributes *imageAttributes
11=DrawImageAbort callback
12=VOID *callbackData
ParamCount=12
@=GdipDrawImagePointsRectI(GpGraphics *graphics, GpImage *image, GDIPCONST GpPoint *points, INT count, INT srcx, INT srcy, INT srcwidth, INT srcheight, GpUnit srcUnit, GDIPCONST GpImageAttributes *imageAttributes, DrawImageAbort callback, VOID *callbackData);
[GdipEnumerateMetafileDestPoint]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST PointF &destPoint
4=EnumerateMetafileProc callback
5=VOID *callbackData
6=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=6
@=GdipEnumerateMetafileDestPoint(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST PointF &destPoint, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileDestPointI]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST Point &destPoint
4=EnumerateMetafileProc callback
5=VOID *callbackData
6=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=6
@=GdipEnumerateMetafileDestPointI(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST Point &destPoint, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileDestRect]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST RectF &destRect
4=EnumerateMetafileProc callback
5=VOID *callbackData
6=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=6
@=GdipEnumerateMetafileDestRect(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST RectF &destRect, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileDestRectI]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST Rect &destRect
4=EnumerateMetafileProc callback
5=VOID *callbackData
6=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=6
@=GdipEnumerateMetafileDestRectI(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST Rect &destRect, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileDestPoints]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST PointF *destPoints
4=INT count
5=EnumerateMetafileProc callback
6=VOID *callbackData
7=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=7
@=GdipEnumerateMetafileDestPoints(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST PointF *destPoints, INT count, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileDestPointsI]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST Point *destPoints
4=INT count
5=EnumerateMetafileProc callback
6=VOID *callbackData
7=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=7
@=GdipEnumerateMetafileDestPointsI(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST Point *destPoints, INT count, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileSrcRectDestPoint]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST PointF &destPoint
4=GDIPCONST RectF &srcRect
5=Unit srcUnit
6=EnumerateMetafileProc callback
7=VOID *callbackData
8=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=8
@=GdipEnumerateMetafileSrcRectDestPoint(GpGraphics *graphics, GDIPCONST GpMetafile*metafile, GDIPCONST PointF &destPoint, GDIPCONST RectF &srcRect, Unit srcUnit, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileSrcRectDestPointI]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST Point &destPoint
4=GDIPCONST Rect &srcRect
5=Unit srcUnit
6=EnumerateMetafileProc callback
7=VOID *callbackData
8=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=8
@=GdipEnumerateMetafileSrcRectDestPointI(GpGraphics *graphics, GDIPCONST GpMetafile*metafile, GDIPCONST Point &destPoint, GDIPCONST Rect &srcRect, Unit srcUnit, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileSrcRectDestRect]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST RectF &destRect
4=GDIPCONST RectF &srcRect
5=Unit srcUnit
6=EnumerateMetafileProc callback
7=VOID *callbackData
8=GDIPCONST GpImageAttributes *imageAttributes
ParamCount=8
@=GdipEnumerateMetafileSrcRectDestRect(GpGraphics *graphics, GDIPCONST GpMetafile*metafile, GDIPCONST RectF &destRect, GDIPCONST RectF &srcRect, Unit srcUnit, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileSrcRectDestRectI]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST Rect &destRect
4=GDIPCONST Rect &srcRect
5=Unit srcUnit
6=EnumerateMetafileProc callback
7=VOID *callbackData
8=GDIPCONST GpImageAttributes*imageAttributes
ParamCount=8
@=GdipEnumerateMetafileSrcRectDestRectI(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST Rect &destRect, GDIPCONST Rect &srcRect, Unit srcUnit, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileSrcRectDestPoints]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST PointF *destPoints
4=INT count
5=GDIPCONST RectF &srcRect
6=Unit srcUnit
7=EnumerateMetafileProc callback
8=VOID *callbackData
9=GDIPCONST GpImageAttributes*imageAttributes
ParamCount=9
@=GdipEnumerateMetafileSrcRectDestPoints(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST PointF *destPoints, INT count, GDIPCONST RectF &srcRect, Unit srcUnit, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipEnumerateMetafileSrcRectDestPointsI]
1=GpGraphics *graphics
2=GDIPCONST GpMetafile *metafile
3=GDIPCONST Point*destPoints
4=INT count
5=GDIPCONST Rect &srcRect
6=Unit srcUnit
7=EnumerateMetafileProc callback
8=VOID *callbackData
9=GDIPCONST GpImageAttributes*imageAttributes
ParamCount=9
@=GdipEnumerateMetafileSrcRectDestPointsI(GpGraphics *graphics, GDIPCONST GpMetafile *metafile, GDIPCONST Point *destPoints, INT count, GDIPCONST Rect &srcRect, Unit srcUnit, EnumerateMetafileProc callback, VOID *callbackData, GDIPCONST GpImageAttributes *imageAttributes);
[GdipPlayMetafileRecord]
1=GDIPCONST GpMetafile *metafile
2=EmfPlusRecordType recordType
3=UINT flags
4=UINT dataSize
5=GDIPCONST BYTE *data
ParamCount=5
@=GdipPlayMetafileRecord(GDIPCONST GpMetafile *metafile, EmfPlusRecordType recordType, UINT flags, UINT dataSize, GDIPCONST BYTE *data);
[GdipSetClipGraphics]
1=GpGraphics *graphics
2=GpGraphics *srcgraphics
3=CombineMode combineMode
ParamCount=3
@=GdipSetClipGraphics(GpGraphics *graphics, GpGraphics *srcgraphics, CombineMode combineMode);
[GdipSetClipRect]
1=GpGraphics *graphics
2=REAL x
3=REAL y
4=REAL width
5=REAL height
6=CombineMode combineMode
ParamCount=6
@=GdipSetClipRect(GpGraphics *graphics, REAL x, REAL y, REAL width, REAL height, CombineMode combineMode);
[GdipSetClipRectI]
1=GpGraphics *graphics
2=INT x
3=INT y
4=INT width
5=INT height
6=CombineMode combineMode
ParamCount=6
@=GdipSetClipRectI(GpGraphics *graphics, INT x, INT y, INT width, INT height, CombineMode combineMode);
[GdipSetClipPath]
1=GpGraphics *graphics
2=GpPath *path
3=CombineMode combineMode
ParamCount=3
@=GdipSetClipPath(GpGraphics *graphics, GpPath *path, CombineMode combineMode);
[GdipSetClipRegion]
1=GpGraphics *graphics
2=GpRegion *region
3=CombineMode combineMode
ParamCount=3
@=GdipSetClipRegion(GpGraphics *graphics, GpRegion *region, CombineMode combineMode);
[GdipSetClipHrgn]
1=GpGraphics *graphics
2=HRGN hRgn
3=CombineMode combineMode
ParamCount=3
@=GdipSetClipHrgn(GpGraphics *graphics, HRGN hRgn, CombineMode combineMode);
[GdipResetClip]
1=GpGraphics *graphics
ParamCount=1
@=GdipResetClip(GpGraphics *graphics);
[GdipTranslateClip]
1=GpGraphics *graphics
2=REAL dx
3=REAL dy
ParamCount=3
@=GdipTranslateClip(GpGraphics *graphics, REAL dx, REAL dy);
[GdipTranslateClipI]
1=GpGraphics *graphics
2=INT dx
3=INT dy
ParamCount=3
@=GdipTranslateClipI(GpGraphics *graphics, INT dx, INT dy);
[GdipGetClip]
1=GpGraphics *graphics
2=GpRegion *region
ParamCount=2
@=GdipGetClip(GpGraphics *graphics, GpRegion *region);
[GdipGetClipBounds]
1=GpGraphics *graphics
2=GpRectF *rect
ParamCount=2
@=GdipGetClipBounds(GpGraphics *graphics, GpRectF *rect);
[GdipGetClipBoundsI]
1=GpGraphics *graphics
2=GpRect *rect
ParamCount=2
@=GdipGetClipBoundsI(GpGraphics *graphics, GpRect *rect);
[GdipIsClipEmpty]
1=GpGraphics *graphics
2=BOOL *result
ParamCount=2
@=GdipIsClipEmpty(GpGraphics *graphics, BOOL *result);
[GdipGetVisibleClipBounds]
1=GpGraphics *graphics
2=GpRectF *rect
ParamCount=2
@=GdipGetVisibleClipBounds(GpGraphics *graphics, GpRectF *rect);
[GdipGetVisibleClipBoundsI]
1=GpGraphics *graphics
2=GpRect *rect
ParamCount=2
@=GdipGetVisibleClipBoundsI(GpGraphics *graphics, GpRect *rect);
[GdipIsVisibleClipEmpty]
1=GpGraphics *graphics
2=BOOL *result
ParamCount=2
@=GdipIsVisibleClipEmpty(GpGraphics *graphics, BOOL *result);
[GdipIsVisiblePoint]
1=GpGraphics *graphics
2=REAL x
3=REAL y
4=BOOL *result
ParamCount=4
@=GdipIsVisiblePoint(GpGraphics *graphics, REAL x, REAL y, BOOL *result);
[GdipIsVisiblePointI]
1=GpGraphics *graphics
2=INT x
3=INT y
4=BOOL *result
ParamCount=4
@=GdipIsVisiblePointI(GpGraphics *graphics, INT x, INT y, BOOL *result);
[GdipIsVisibleRect]
1=GpGraphics *graphics
2=REAL x
3=REAL y
4=REAL width
5=REAL height
6=BOOL *result
ParamCount=6
@=GdipIsVisibleRect(GpGraphics *graphics, REAL x, REAL y, REAL width, REAL height, BOOL *result);
[GdipIsVisibleRectI]
1=GpGraphics *graphics
2=INT x
3=INT y
4=INT width
5=INT height
6=BOOL *result
ParamCount=6
@=GdipIsVisibleRectI(GpGraphics *graphics, INT x, INT y, INT width, INT height, BOOL *result);
[GdipSaveGraphics]
1=GpGraphics *graphics
2=GraphicsState *state
ParamCount=2
@=GdipSaveGraphics(GpGraphics *graphics, GraphicsState *state);
[GdipRestoreGraphics]
1=GpGraphics *graphics
2=GraphicsState state
ParamCount=2
@=GdipRestoreGraphics(GpGraphics *graphics, GraphicsState state);
[GdipBeginContainer]
1=GpGraphics *graphics
2=GDIPCONST GpRectF *dstrect
3=GDIPCONST GpRectF *srcrect
4=GpUnit unit
5= GraphicsContainer*state
ParamCount=5
@=GdipBeginContainer(GpGraphics *graphics, GDIPCONST GpRectF *dstrect, GDIPCONST GpRectF *srcrect, GpUnit unit,  GraphicsContainer*state);
[GdipBeginContainerI]
1=GpGraphics *graphics
2=GDIPCONST GpRect *dstrect
3=GDIPCONST GpRect *srcrect
4=GpUnit unit
5= GraphicsContainer*state
ParamCount=5
@=GdipBeginContainerI(GpGraphics *graphics, GDIPCONST GpRect *dstrect, GDIPCONST GpRect *srcrect, GpUnit unit,  GraphicsContainer*state);
[GdipBeginContainer2]
1=GpGraphics *graphics
2=GraphicsContainer* state
ParamCount=2
@=GdipBeginContainer2(GpGraphics *graphics, GraphicsContainer* state);
[GdipEndContainer]
1=GpGraphics *graphics
2=GraphicsContainer state
ParamCount=2
@=GdipEndContainer(GpGraphics *graphics, GraphicsContainer state);
[fileHeaderFromWmf]
1=HMETAFILE hWmf
2=GDIPCONST WmfPlaceableFileHeader*wmfPlaceableFileHeader
3=MetafileHeader *header
ParamCount=3
@=fileHeaderFromWmf(HMETAFILE hWmf, GDIPCONST WmfPlaceableFileHeader*wmfPlaceableFileHeader, MetafileHeader *header);
[GdipGetMetafileHeaderFromEmf]
1=HENHMETAFILE hEmf
2=MetafileHeader *header
ParamCount=2
@=GdipGetMetafileHeaderFromEmf(HENHMETAFILE hEmf, MetafileHeader *header);
[GdipGetMetafileHeaderFromFile]
1=GDIPCONST WCHAR *filename
2=MetafileHeader *header
ParamCount=2
@=GdipGetMetafileHeaderFromFile(GDIPCONST WCHAR *filename, MetafileHeader *header);
[GdipGetMetafileHeaderFromStream]
1=IStream *stream
2=MetafileHeader *header
ParamCount=2
@=GdipGetMetafileHeaderFromStream(IStream *stream, MetafileHeader *header);
[GdipGetMetafileHeaderFromMetafile]
1=GpMetafile *metafile
2=MetafileHeader *header
ParamCount=2
@=GdipGetMetafileHeaderFromMetafile(GpMetafile *metafile, MetafileHeader *header);
[GdipGetHemfFromMetafile]
1=GpMetafile *metafile
2=HENHMETAFILE *hEmf
ParamCount=2
@=GdipGetHemfFromMetafile(GpMetafile *metafile, HENHMETAFILE *hEmf);
[GdipCreateStreamOnFile]
1=GDIPCONST WCHAR *filename
2=UINT access
3=IStream **stream
ParamCount=3
@=GdipCreateStreamOnFile(GDIPCONST WCHAR *filename, UINT access, IStream **stream);
[GdipCreateMetafileFromWmf]
1=HMETAFILE hWmf
2=BOOL deleteWmf
3=GDIPCONST WmfPlaceableFileHeader *wmfPlaceableFileHeader
4=GpMetafile **metafile
ParamCount=4
@=GdipCreateMetafileFromWmf(HMETAFILE hWmf, BOOL deleteWmf, GDIPCONST WmfPlaceableFileHeader *wmfPlaceableFileHeader, GpMetafile **metafile);
[GdipCreateMetafileFromEmf]
1=HENHMETAFILE hEmf
2=BOOL deleteEmf
3=GpMetafile **metafile
ParamCount=3
@=GdipCreateMetafileFromEmf(HENHMETAFILE hEmf, BOOL deleteEmf, GpMetafile **metafile);
[GdipCreateMetafileFromFile]
1=GDIPCONST WCHAR *file
2=GpMetafile **metafile
ParamCount=2
@=GdipCreateMetafileFromFile(GDIPCONST WCHAR *file, GpMetafile **metafile);
[GdipCreateMetafileFromWmfFile]
1=GDIPCONST WCHAR *file
2=GDIPCONST WmfPlaceableFileHeader *wmfPlaceableFileHeader
3= GpMetafile **metafile
ParamCount=3
@=GdipCreateMetafileFromWmfFile(GDIPCONST WCHAR *file, GDIPCONST WmfPlaceableFileHeader *wmfPlaceableFileHeader,  GpMetafile **metafile);
[GdipCreateMetafileFromStream]
1=IStream *stream
2=GpMetafile **metafile
ParamCount=2
@=GdipCreateMetafileFromStream(IStream *stream, GpMetafile **metafile);
[GdipRecordMetafile]
1=HDC referenceHdc
2=EmfType type
3=GDIPCONST GpRectF *frameRect
4=MetafileFrameUnit frameUnit
5=GDIPCONST WCHAR *description
6=GpMetafile **metafile
ParamCount=6
@=GdipRecordMetafile(HDC referenceHdc, EmfType type, GDIPCONST GpRectF *frameRect, MetafileFrameUnit frameUnit, GDIPCONST WCHAR *description, GpMetafile **metafile);
[GdipRecordMetafileI]
1=HDC referenceHdc
2=EmfType type
3=GDIPCONST GpRect *frameRect
4=MetafileFrameUnit frameUnit
5=GDIPCONST WCHAR *description
6=GpMetafile **metafile
ParamCount=6
@=GdipRecordMetafileI(HDC referenceHdc, EmfType type, GDIPCONST GpRect *frameRect, MetafileFrameUnit frameUnit, GDIPCONST WCHAR *description, GpMetafile **metafile);
[GdipRecordMetafileFileName]
1=GDIPCONST WCHAR *fileName
2=HDC referenceHdc
3=EmfType type
4=GDIPCONST GpRectF *frameRect
5=MetafileFrameUnit frameUnit
6=GDIPCONST WCHAR *description
7=GpMetafile **metafile
ParamCount=7
@=GdipRecordMetafileFileName(GDIPCONST WCHAR *fileName, HDC referenceHdc, EmfType type, GDIPCONST GpRectF *frameRect, MetafileFrameUnit frameUnit, GDIPCONST WCHAR *description, GpMetafile **metafile);
[GdipRecordMetafileFileNameI]
1=GDIPCONST WCHAR *fileName
2=HDC referenceHdc
3=EmfType type
4=GDIPCONST GpRect *frameRect
5=MetafileFrameUnit frameUnit
6=GDIPCONST WCHAR *description
7=GpMetafile **metafile
ParamCount=7
@=GdipRecordMetafileFileNameI(GDIPCONST WCHAR *fileName, HDC referenceHdc, EmfType type, GDIPCONST GpRect *frameRect, MetafileFrameUnit frameUnit, GDIPCONST WCHAR *description, GpMetafile **metafile);
[GdipRecordMetafileStream]
1=IStream *stream
2=HDC referenceHdc
3=EmfType type
4=GDIPCONST GpRectF *frameRect
5=MetafileFrameUnit frameUnit
6=GDIPCONST WCHAR *description
7=GpMetafile **metafile
ParamCount=7
@=GdipRecordMetafileStream(IStream *stream, HDC referenceHdc, EmfType type, GDIPCONST GpRectF *frameRect, MetafileFrameUnit frameUnit, GDIPCONST WCHAR *description, GpMetafile **metafile);
[GdipRecordMetafileStreamI]
1=IStream *stream
2=HDC referenceHdc
3=EmfType type
4=GDIPCONST GpRect *frameRect
5=MetafileFrameUnit frameUnit
6=GDIPCONST WCHAR *description
7=GpMetafile **metafile
ParamCount=7
@=GdipRecordMetafileStreamI(IStream *stream, HDC referenceHdc, EmfType type, GDIPCONST GpRect*frameRect, MetafileFrameUnit frameUnit, GDIPCONST WCHAR *description, GpMetafile **metafile);
[GdipSetMetafileDownLevelRasterizationLimit]
1=GpMetafile *metafile
2=UINT metafileRasterizationLimitDpi
ParamCount=2
@=GdipSetMetafileDownLevelRasterizationLimit(GpMetafile *metafile, UINT metafileRasterizationLimitDpi);
[GdipGetMetafileDownLevelRasterizationLimit]
1=GDIPCONST GpMetafile *metafile
2=UINT *metafileRasterizationLimitDpi
ParamCount=2
@=GdipGetMetafileDownLevelRasterizationLimit(GDIPCONST GpMetafile *metafile, UINT *metafileRasterizationLimitDpi);
[GdipGetImageDecodersSize]
1=UINT *numDecoders
2=UINT *size
ParamCount=2
@=GdipGetImageDecodersSize(UINT *numDecoders, UINT *size);
[GdipGetImageDecoders]
1=UINT numDecoders
2=UINT size
3=ImageCodecInfo *decoders
ParamCount=3
@=GdipGetImageDecoders(UINT numDecoders, UINT size, ImageCodecInfo *decoders);
[GdipGetImageEncodersSize]
1=UINT *numEncoders
2=UINT *size
ParamCount=2
@=GdipGetImageEncodersSize(UINT *numEncoders, UINT *size);
[GdipGetImageEncoders]
1=UINT numEncoders
2=UINT size
3=ImageCodecInfo *encoders
ParamCount=3
@=GdipGetImageEncoders(UINT numEncoders, UINT size, ImageCodecInfo *encoders);
[GdipComment]
1=GpGraphics* graphics
2=UINT sizeData
3=GDIPCONST BYTE *data
ParamCount=3
@=GdipComment(GpGraphics* graphics, UINT sizeData, GDIPCONST BYTE *data);
[GdipCreateFontFamilyFromName]
1=GDIPCONST WCHAR *name
2=GpFontCollection *fontCollection
3=GpFontFamily **fontFamily
ParamCount=3
@=GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name, GpFontCollection *fontCollection, GpFontFamily **fontFamily);
[GdipDeleteFontFamily]
1=GpFontFamily *fontFamily
ParamCount=1
@=GdipDeleteFontFamily(GpFontFamily *fontFamily);
[GdipCloneFontFamily]
1=GpFontFamily *fontFamily
2=GpFontFamily **clonedFontFamily
ParamCount=2
@=GdipCloneFontFamily(GpFontFamily *fontFamily, GpFontFamily **clonedFontFamily);
[GdipGetGenericFontFamilySansSerif]
1=GpFontFamily **nativeFamily
ParamCount=1
@=GdipGetGenericFontFamilySansSerif(GpFontFamily **nativeFamily);
[GdipGetGenericFontFamilySerif]
1=GpFontFamily **nativeFamily
ParamCount=1
@=GdipGetGenericFontFamilySerif(GpFontFamily **nativeFamily);
[GdipGetGenericFontFamilyMonospace]
1=GpFontFamily **nativeFamily
ParamCount=1
@=GdipGetGenericFontFamilyMonospace(GpFontFamily **nativeFamily);
[GdipGetFamilyName]
1=GDIPCONST GpFontFamily *family
2=LPWSTR name
3=LANGID language
ParamCount=3
@=GdipGetFamilyName(GDIPCONST GpFontFamily *family, LPWSTR name, LANGID language);
[GdipIsStyleAvailable]
1=GDIPCONST GpFontFamily *family
2=INT style
3=BOOL *IsStyleAvailable
ParamCount=3
@=GdipIsStyleAvailable(GDIPCONST GpFontFamily *family, INT style,  BOOL *IsStyleAvailable);
[GdipFontCollectionEnumerable]
1=GpFontCollection *fontCollection
2=GpGraphics *graphics
3=INT *numFound
ParamCount=3
@=GdipFontCollectionEnumerable(GpFontCollection *fontCollection, GpGraphics *graphics, INT *numFound);
[dipFontCollectionEnumerate]
1=GpFontCollection *fontCollection
2=INT numSought
3=GpFontFamily *gpfamilies[]
4=INT *numFound
5=GpGraphics *graphics
ParamCount=5
@=dipFontCollectionEnumerate(GpFontCollection *fontCollection, INT numSought, GpFontFamily *gpfamilies[], INT *numFound, GpGraphics *graphics);
[GdipGetEmHeight]
1=GDIPCONST GpFontFamily *family
2=INT style
3=UINT16 *EmHeight
ParamCount=3
@=GdipGetEmHeight(GDIPCONST GpFontFamily *family, INT style, UINT16 *EmHeight);
[GdipGetCellAscent]
1=GDIPCONST GpFontFamily *family
2=INT style
3=UINT16 *CellAscent
ParamCount=3
@=GdipGetCellAscent(GDIPCONST GpFontFamily *family, INT style, UINT16 *CellAscent);
[GdipGetCellDescent]
1=GDIPCONST GpFontFamily *family
2=INT style
3=UINT16 *CellDescent
ParamCount=3
@=GdipGetCellDescent(GDIPCONST GpFontFamily *family, INT style, UINT16 *CellDescent);
[GdipGetLineSpacing]
1=GDIPCONST GpFontFamily *family
2=INT style
3=UINT16 *LineSpacing
ParamCount=3
@=GdipGetLineSpacing(GDIPCONST GpFontFamily *family, INT style, UINT16 *LineSpacing);
[GdipCreateFontFromDC]
1=HDC hdc
2=GpFont **font
ParamCount=2
@=GdipCreateFontFromDC(HDC hdc, GpFont **font);
[GdipCreateFontFromLogfontA]
1=HDC hdc
2=GDIPCONST LOGFONTA*logfont
3=GpFont **font
ParamCount=3
@=GdipCreateFontFromLogfontA(HDC hdc, GDIPCONST LOGFONTA*logfont, GpFont **font);
[GdipCreateFontFromLogfontW]
1=HDC hdc
2=GDIPCONST LOGFONTW *logfont
3=GpFont **font
ParamCount=3
@=GdipCreateFontFromLogfontW(HDC hdc, GDIPCONST LOGFONTW *logfont, GpFont **font);
[GdipCreateFont]
1=GDIPCONST GpFontFamily *fontFamily
2=REAL emSize
3=INT style
4=Unit unit
5=GpFont **font
ParamCount=5
@=GdipCreateFont(GDIPCONST GpFontFamily *fontFamily, REAL emSize, INT style, Unit unit, GpFont **font);
[GdipCloneFont]
1=GpFont* font
2=GpFont** cloneFont
ParamCount=2
@=GdipCloneFont(GpFont* font, GpFont** cloneFont);
[GdipDeleteFont]
1=GpFont* font
ParamCount=1
@=GdipDeleteFont(GpFont* font);
[GdipGetFamily]
1=GpFont *font
2=GpFontFamily **family
ParamCount=2
@=GdipGetFamily(GpFont *font, GpFontFamily **family);
[GdipGetFontStyle]
1=GpFont *font
2=INT *style
ParamCount=2
@=GdipGetFontStyle(GpFont *font, INT *style);
[GdipGetFontSize]
1=GpFont *font
2=REAL *size
ParamCount=2
@=GdipGetFontSize(GpFont *font, REAL *size);
[GdipGetFontUnit]
1=GpFont *font
2=Unit *unit
ParamCount=2
@=GdipGetFontUnit(GpFont *font, Unit *unit);
[GdipGetFontHeight]
1=GDIPCONST GpFont *font
2=GDIPCONST GpGraphics *graphics
3=REAL *height
ParamCount=3
@=GdipGetFontHeight(GDIPCONST GpFont *font, GDIPCONST GpGraphics *graphics, REAL *height);
[GdipGetFontHeightGivenDPI]
1=GDIPCONST GpFont *font
2=REAL dpi
3=REAL *height
ParamCount=3
@=GdipGetFontHeightGivenDPI(GDIPCONST GpFont *font, REAL dpi, REAL *height);
[GdipGetLogFontA]
1=GpFont *font
2=GpGraphics *graphics
3=LOGFONTA *logfontA
ParamCount=3
@=GdipGetLogFontA(GpFont *font, GpGraphics *graphics, LOGFONTA *logfontA);
[GdipGetLogFontW]
1=GpFont *font
2=GpGraphics *graphics
3=LOGFONTW *logfontW
ParamCount=3
@=GdipGetLogFontW(GpFont *font, GpGraphics *graphics, LOGFONTW *logfontW);
[GdipNewInstalledFontCollection]
1=GpFontCollection **fontCollection
ParamCount=1
@=GdipNewInstalledFontCollection(GpFontCollection **fontCollection);
[GdipNewPrivateFontCollection]
1=GpFontCollection **fontCollection
ParamCount=1
@=GdipNewPrivateFontCollection(GpFontCollection **fontCollection);
[GdipDeletePrivateFontCollection]
1=GpFontCollection **fontCollection
ParamCount=1
@=GdipDeletePrivateFontCollection(GpFontCollection **fontCollection);
[GdipGetFontCollectionFamilyCount]
1=GpFontCollection *fontCollection
2=INT *numFound
ParamCount=2
@=GdipGetFontCollectionFamilyCount(GpFontCollection *fontCollection, INT *numFound);
[GdipGetFontCollectionFamilyList]
1=GpFontCollection *fontCollection
2=INT numSought
3=GpFontFamily *gpfamilies[]
4=INT *numFound
ParamCount=4
@=GdipGetFontCollectionFamilyList(GpFontCollection *fontCollection, INT numSought, GpFontFamily *gpfamilies[], INT *numFound);
[GdipPrivateAddFontFile]
1=GpFontCollection *fontCollection
2=GDIPCONST WCHAR *filename
ParamCount=2
@=GdipPrivateAddFontFile(GpFontCollection *fontCollection, GDIPCONST WCHAR *filename);
[GdipPrivateAddMemoryFont]
1=GpFontCollection *fontCollection
2=GDIPCONST void *memory
3=INT length
ParamCount=3
@=GdipPrivateAddMemoryFont(GpFontCollection *fontCollection, GDIPCONST void *memory, INT length);
[GdipDrawString]
1=GpGraphics *graphics
2=GDIPCONST WCHAR *string
3=INT length
4=GDIPCONST GpFont *font
5=GDIPCONST RectF *layoutRect
6=GDIPCONST GpStringFormat *stringFormat
7=GDIPCONST GpBrush *brush
ParamCount=7
@=GdipDrawString(GpGraphics *graphics, GDIPCONST WCHAR *string, INT length, GDIPCONST GpFont *font, GDIPCONST RectF *layoutRect, GDIPCONST GpStringFormat *stringFormat, GDIPCONST GpBrush *brush);
[GdipMeasureString]
1=GpGraphics *graphics
2=GDIPCONST WCHAR *string
3=INT length
4=GDIPCONST GpFont *font
5=GDIPCONST RectF *layoutRect
6=GDIPCONST GpStringFormat *stringFormat
7=RectF *boundingBox
8=INT *codepointsFitted
9=INT *linesFilled
ParamCount=9
@=GdipMeasureString(GpGraphics *graphics, GDIPCONST WCHAR *string, INT length, GDIPCONST GpFont *font, GDIPCONST RectF *layoutRect, GDIPCONST GpStringFormat *stringFormat, RectF *boundingBox, INT *codepointsFitted, INT *linesFilled);
[GdipMeasureCharacterRanges]
1=GpGraphics *graphics
2=GDIPCONST WCHAR *string
3=INT length
4=GDIPCONST GpFont *font
5=GDIPCONST RectF &layoutRect
6=GDIPCONST GpStringFormat *stringFormat
7=INT regionCount
8=GpRegion **regions
ParamCount=8
@=GdipMeasureCharacterRanges(GpGraphics *graphics, GDIPCONST WCHAR *string, INT length, GDIPCONST GpFont *font, GDIPCONST RectF &layoutRect, GDIPCONST GpStringFormat *stringFormat, INT regionCount, GpRegion **regions);
[GdipDrawDriverString]
1=GpGraphics *graphics
2=GDIPCONST UINT16 *text
3=INT length
4=GDIPCONST GpFont font
5=GDIPCONST GpBrush *brush
6=GDIPCONST PointF *positions
7=INT flags
8=GDIPCONST GpMatrix *matrix
ParamCount=8
@=GdipDrawDriverString(GpGraphics *graphics, GDIPCONST UINT16 *text, INT length, GDIPCONST GpFont *font, GDIPCONST GpBrush *brush, GDIPCONST PointF *positions, INT flags, GDIPCONST GpMatrix *matrix);
[GdipMeasureDriverString]
1=GpGraphics *graphics
2=GDIPCONST UINT16 *text
3=INT length
4=GDIPCONST GpFont *font
5=GDIPCONST PointF *positions
6=INT flags
7=GDIPCONST GpMatrix *matrix
8=RectF *boundingBox
ParamCount=8
@=GdipMeasureDriverString(GpGraphics *graphics, GDIPCONST UINT16 *text, INT length, GDIPCONST GpFont *font, GDIPCONST PointF *positions, INT flags, GDIPCONST GpMatrix *matrix, RectF *boundingBox);
[GdipCreateStringFormat]
1=INT formatAttributes
2=LANGID language
3=GpStringFormat **format
ParamCount=3
@=GdipCreateStringFormat(INT formatAttributes, LANGID language, GpStringFormat **format);
[GdipStringFormatGetGenericDefault]
1=GpStringFormat **format
ParamCount=1
@=GdipStringFormatGetGenericDefault(GpStringFormat **format);
[GdipStringFormatGetGenericTypographic]
1=GpStringFormat **format
ParamCount=1
@=GdipStringFormatGetGenericTypographic(GpStringFormat **format);
[GdipDeleteStringFormat]
1=GpStringFormat *format
ParamCount=1
@=GdipDeleteStringFormat(GpStringFormat *format);
[GdipCloneStringFormat]
1=GDIPCONST GpStringFormat *format
2=GpStringFormat **newFormat
ParamCount=2
@=GdipCloneStringFormat(GDIPCONST GpStringFormat *format, GpStringFormat **newFormat);
[GdipSetStringFormatFlags]
1=GpStringFormat *format
2=INT flags
ParamCount=2
@=GdipSetStringFormatFlags(GpStringFormat *format, INT flags);
[dipGetStringFormatFlags]
1=GDIPCONST GpStringFormat *format
2=INT *flags
ParamCount=2
@=dipGetStringFormatFlags(GDIPCONST GpStringFormat *format, INT *flags);
[GdipSetStringFormatAlign]
1=GpStringFormat *format
2=StringAlignment align
ParamCount=2
@=GdipSetStringFormatAlign(GpStringFormat *format, StringAlignment align);
[GdipGetStringFormatAlign]
1=GDIPCONST GpStringFormat*format
2=StringAlignment *align
ParamCount=2
@=GdipGetStringFormatAlign(GDIPCONST GpStringFormat*format, StringAlignment *align);
[GdipSetStringFormatLineAlign]
1=GpStringFormat *format
2=StringAlignment align
ParamCount=2
@=GdipSetStringFormatLineAlign(GpStringFormat *format, StringAlignment align);
[GdipGetStringFormatLineAlign]
1=GDIPCONST GpStringFormat*format
2=StringAlignment *align
ParamCount=2
@=GdipGetStringFormatLineAlign(GDIPCONST GpStringFormat*format, StringAlignment *align);
[GdipSetStringFormatTrimming]
1=GpStringFormat *format
2=StringTrimming trimming
ParamCount=2
@=GdipSetStringFormatTrimming(GpStringFormat *format, StringTrimming trimming);
[GdipGetStringFormatTrimming]
1=GDIPCONST GpStringFormat*format
2=StringTrimming *trimming
ParamCount=2
@=GdipGetStringFormatTrimming(GDIPCONST GpStringFormat *format, StringTrimming *trimming);
[GdipSetStringFormatHotkeyPrefix]
1=GpStringFormat *format
2=INT hotkeyPrefix
ParamCount=2
@=GdipSetStringFormatHotkeyPrefix(GpStringFormat *format, INT hotkeyPrefix);
[GdipGetStringFormatHotkeyPrefix]
1=GDIPCONST GpStringFormat *format
2=INT *hotkeyPrefix
ParamCount=2
@=GdipGetStringFormatHotkeyPrefix(GDIPCONST GpStringFormat *format, INT *hotkeyPrefix);
[GdipSetStringFormatTabStops]
1=GpStringFormat *format
2=REAL firstTabOffset
3=INT count
4=GDIPCONST REAL *tabStops
ParamCount=4
@=GdipSetStringFormatTabStops(GpStringFormat *format, REAL firstTabOffset, INT count, GDIPCONST REAL *tabStops);
[GdipGetStringFormatTabStops]
1=GDIPCONST GpStringFormat *format
2=INT count
3=REAL *firstTabOffset
4=REAL *tabStops
ParamCount=4
@=GdipGetStringFormatTabStops(GDIPCONST GpStringFormat *format, INT count, REAL *firstTabOffset, REAL *tabStops);
[GdipGetStringFormatTabStopCount]
1=GDIPCONST GpStringFormat *format
2=INT *count
ParamCount=2
@=GdipGetStringFormatTabStopCount(GDIPCONST GpStringFormat *format, INT *count);
[GdipSetStringFormatDigitSubstitution]
1=GpStringFormat *format
2=LANGID language
3=StringDigitSubstitute substitute
ParamCount=3
@=GdipSetStringFormatDigitSubstitution(GpStringFormat *format, LANGID language, StringDigitSubstitute substitute);
[GdipGetStringFormatDigitSubstitution]
1=GDIPCONST GpStringFormat *format
2=LANGID *language
3=StringDigitSubstitute *substitute
ParamCount=3
@=GdipGetStringFormatDigitSubstitution(GDIPCONST GpStringFormat*format, LANGID *language, StringDigitSubstitute *substitute);
[GdipGetStringFormatMeasurableCharacterRangeCount]
1=GDIPCONST GpStringFormat *format
2=INT *count
ParamCount=2
@=GdipGetStringFormatMeasurableCharacterRangeCount(GDIPCONST GpStringFormat *format, INT *count);
[GdipSetStringFormatMeasurableCharacterRanges]
1=GpStringFormat *format
2=INT rangeCount
3=GDIPCONST CharacterRange *ranges
ParamCount=3
@=GdipSetStringFormatMeasurableCharacterRanges(GpStringFormat *format, INT rangeCount, GDIPCONST CharacterRange *ranges);
[GdipCreateCachedBitmap]
1=GpBitmap *bitmap
2=GpGraphics *graphics
3=GpCachedBitmap **cachedBitmap
ParamCount=3
@=GdipCreateCachedBitmap(GpBitmap *bitmap, GpGraphics *graphics, GpCachedBitmap **cachedBitmap);
[GdipDeleteCachedBitmap]
1=GpCachedBitmap *cachedBitmap
ParamCount=1
@=GdipDeleteCachedBitmap(GpCachedBitmap *cachedBitmap);
[GdipDrawCachedBitmap]
1=GpGraphics *graphics
2=GpCachedBitmap *cachedBitmap
3=INT x
4=INT y
ParamCount=4
@=GdipDrawCachedBitmap(GpGraphics *graphics, GpCachedBitmap *cachedBitmap, INT x, INT y);
[GdipSetImageAttributesCachedBackground]
1=GpImageAttributes *imageattr
2=BOOL enableFlag
ParamCount=2
@=GdipSetImageAttributesCachedBackground(GpImageAttributes *imageattr, BOOL enableFlag);
[GdipTestControl]
1=GpTestControlEnum control
2=void *param
ParamCount=2
@=GdipTestControl(GpTestControlEnum control, void *param);
[GdiplusNotificationHook]
1=ULONG_PTR *token
ParamCount=1
@=GdiplusNotificationHook(ULONG_PTR *token);
[GdiplusNotificationUnhook]
1=ULONG_PTR token
ParamCount=1
@=GdiplusNotificationUnhook(ULONG_PTR token);
[GdipConvertToEmfPlus]
1=GpGraphics *refGraphics
2=GpMetafile *metafile
3=INT *conversionFailureFlag
4=EmfType emfType
5=WCHAR *description
6=GpMetafile **out_metafile
ParamCount=6
@=GdipConvertToEmfPlus(GpGraphics *refGraphics, GpMetafile *metafile, INT *conversionFailureFlag, EmfType emfType, WCHAR *description, GpMetafile **out_metafile);
[GdipConvertToEmfPlusToFile]
1=GpGraphics *refGraphics
2=GpMetafile *metafile
3=INT *conversionFailureFlag
4=WCHAR *filename
5=EmfType emfType
6=WCHAR *description
7=GpMetafile **out_metafile
ParamCount=7
@=GdipConvertToEmfPlusToFile(GpGraphics *refGraphics, GpMetafile *metafile, INT *conversionFailureFlag, WCHAR *filename, EmfType emfType, WCHAR *description, GpMetafile **out_metafile);
[GdipConvertToEmfPlusToStream]
1=GpGraphics *refGraphics
2=GpMetafile *metafile
3=INT *conversionFailureFlag
4=IStream *stream
5=EmfType emfType
6=WCHAR *description
7=GpMetafile **out_metafile
ParamCount=7
@=GdipConvertToEmfPlusToStream(GpGraphics *refGraphics, GpMetafile *metafile, INT *conversionFailureFlag, IStream *stream, EmfType emfType, WCHAR *description, GpMetafile **out_metafile);




================================================
File: api-definitions/kernel32.api
================================================
[InitOnceInitialize]
1=PINIT_ONCE InitOnce
ParamCount=1
@=InitOnceInitialize(PINIT_ONCE InitOnce);
[InitOnceExecuteOnce]
1=PINIT_ONCE InitOnce
2=PINIT_ONCE PINIT_ONCE_FNInitFn
3=PVOID Parameter
4=LPVOID *Context
ParamCount=4
@=InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE PINIT_ONCE_FNInitFn, PVOID Parameter, LPVOID *Context);
[InitOnceBeginInitialize]
1=LPINIT_ONCE lpInitOnce
2=DWORD dwFlags
3=PBOOL fPending
4=LPVOID *lpContext
ParamCount=4
@=InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext);
[InitOnceComplete]
1=LPINIT_ONCE lpInitOnce
2=DWORD dwFlags
3=LPVOID lpContext
ParamCount=3
@=InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext);
[InitializeSRWLock]
1=PSRWLOCK SRWLock
ParamCount=1
@=InitializeSRWLock(PSRWLOCK SRWLock);
[ReleaseSRWLockExclusive]
1=PSRWLOCK SRWLock
ParamCount=1
@=ReleaseSRWLockExclusive(PSRWLOCK SRWLock);
[ReleaseSRWLockShared]
1=PSRWLOCK SRWLock
ParamCount=1
@=ReleaseSRWLockShared(PSRWLOCK SRWLock);
[AcquireSRWLockExclusive]
1=PSRWLOCK SRWLock
ParamCount=1
@=AcquireSRWLockExclusive(PSRWLOCK SRWLock);
[AcquireSRWLockShared]
1=PSRWLOCK SRWLock
ParamCount=1
@=AcquireSRWLockShared(PSRWLOCK SRWLock);
[TryAcquireSRWLockExclusive]
1=PSRWLOCK SRWLock
ParamCount=1
@=TryAcquireSRWLockExclusive(PSRWLOCK SRWLock);
[TryAcquireSRWLockShared]
1=PSRWLOCK SRWLock
ParamCount=1
@=TryAcquireSRWLockShared(PSRWLOCK SRWLock);
[InitializeConditionVariable]
1=PCONDITION_VARIABLE ConditionVariable
ParamCount=1
@=InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable);
[WakeConditionVariable]
1=PCONDITION_VARIABLE ConditionVariable
ParamCount=1
@=WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable);
[WakeAllConditionVariable]
1=PCONDITION_VARIABLE ConditionVariable
ParamCount=1
@=WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable);
[SleepConditionVariableCS]
1=PCONDITION_VARIABLE ConditionVariable
2=PCRITICAL_SECTION CriticalSection
3=DWORD dwMilliseconds
ParamCount=3
@=SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds);
[SleepConditionVariableSRW]
1=PCONDITION_VARIABLE ConditionVariable
2=PSRWLOCK SRWLock
3=DWORD dwMilliseconds
4=ULONG Flags
ParamCount=4
@=SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags);
[EncodePointer]
1=PVOID Ptr
ParamCount=1
@=EncodePointer(PVOID Ptr);
[DecodePointer]
1=PVOID Ptr
ParamCount=1
@=DecodePointer(PVOID Ptr);
[EncodeSystemPointer]
1=PVOID Ptr
ParamCount=1
@=EncodeSystemPointer(PVOID Ptr);
[DecodeSystemPointer]
1=PVOID Ptr
ParamCount=1
@=DecodeSystemPointer(PVOID Ptr);
[GetFreeSpace]
1=UINT
ParamCount=1
@=GetFreeSpace(UINT);
[InterlockedIncrement]
1=LONG volatile*lpAddend
ParamCount=1
@=InterlockedIncrement(LONG volatile*lpAddend);
[InterlockedDecrement]
1=LONG volatile*lpAddend
ParamCount=1
@=InterlockedDecrement(LONG volatile*lpAddend);
[InterlockedExchange]
1=LONG volatile*Target
2=LONG Value
ParamCount=2
@=InterlockedExchange(LONG volatile*Target, LONG Value);
[InterlockedExchangeAdd]
1=LONG volatile*Addend
2=LONG Value
ParamCount=2
@=InterlockedExchangeAdd(LONG volatile*Addend, LONG Value);
[InterlockedCompareExchange]
1=LONG volatile*Destination
2=LONG Exchange
3=LONG Comperand
ParamCount=3
@=InterlockedCompareExchange(LONG volatile*Destination, LONG Exchange, LONG Comperand);
[InterlockedCompareExchange64]
1=LONGLONG volatile*Destination
2=LONGLONG Exchange
3=LONGLONG Comperand
ParamCount=3
@=InterlockedCompareExchange64(LONGLONG volatile*Destination, LONGLONG Exchange, LONGLONG Comperand);
[InitializeSListHead]
1=PSLIST_HEADER ListHead
ParamCount=1
@=InitializeSListHead(PSLIST_HEADER ListHead);
[InterlockedPopEntrySList]
1=PSLIST_HEADER ListHead
ParamCount=1
@=InterlockedPopEntrySList(PSLIST_HEADER ListHead);
[InterlockedPushEntrySList]
1=PSLIST_HEADER ListHead
2=PSLIST_ENTRY ListEntry
ParamCount=2
@=InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
[InterlockedFlushSList]
1=PSLIST_HEADER ListHead
ParamCount=1
@=InterlockedFlushSList(PSLIST_HEADER ListHead);
[QueryDepthSList]
1=PSLIST_HEADER ListHead
ParamCount=1
@=QueryDepthSList(PSLIST_HEADER ListHead);
[FreeResource]
1=HGLOBAL hResData
ParamCount=1
@=FreeResource(HGLOBAL hResData);
[LockResource]
1=HGLOBAL hResData
ParamCount=1
@=LockResource(HGLOBAL hResData);
[WinMain]
1=HINSTANCE hInstance
2=HINSTANCE hPrevInstance
3=LPSTR lpCmdLine
4=int nShowCmd
ParamCount=4
@=WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
[wWinMain]
1=HINSTANCE hInstance
2=HINSTANCE hPrevInstance
3=LPWSTR lpCmdLine
4=int nShowCmd
ParamCount=4
@=wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);
[FreeLibrary]
1=HMODULE hLibModule
ParamCount=1
@=FreeLibrary(HMODULE hLibModule);
[FreeLibraryAndExitThread]
1=HMODULE hLibModule
2=DWORD dwExitCode
ParamCount=2
@=FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode);
[DisableThreadLibraryCalls]
1=HMODULE hLibModule
ParamCount=1
@=DisableThreadLibraryCalls(HMODULE hLibModule);
[GetProcAddress]
1=HMODULE hModule
2=LPCSTR lpProcName
ParamCount=2
@=GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
[GetVersion]
ParamCount=0
@=GetVersion();
[GlobalAlloc]
1=UINT uFlags
2=SIZE_T dwBytes
ParamCount=2
@=GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
[GlobalReAlloc]
1=HGLOBAL hMem
2=SIZE_T dwBytes
3=UINT uFlags
ParamCount=3
@=GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);
[GlobalSize]
1=HGLOBAL hMem
ParamCount=1
@=GlobalSize(HGLOBAL hMem);
[GlobalFlags]
1=HGLOBAL hMem
ParamCount=1
@=GlobalFlags(HGLOBAL hMem);
[GlobalLock]
1=HGLOBAL hMem
ParamCount=1
@=GlobalLock(HGLOBAL hMem);
[GlobalHandle]
1=LPCVOID pMem
ParamCount=1
@=GlobalHandle(LPCVOID pMem);
[GlobalUnlock]
1=HGLOBAL hMem
ParamCount=1
@=GlobalUnlock(HGLOBAL hMem);
[GlobalFree]
1=HGLOBAL hMem
ParamCount=1
@=GlobalFree(HGLOBAL hMem);
[GlobalCompact]
1=DWORD dwMinFree
ParamCount=1
@=GlobalCompact(DWORD dwMinFree);
[GlobalFix]
1=HGLOBAL hMem
ParamCount=1
@=GlobalFix(HGLOBAL hMem);
[GlobalUnfix]
1=HGLOBAL hMem
ParamCount=1
@=GlobalUnfix(HGLOBAL hMem);
[GlobalWire]
1=HGLOBAL hMem
ParamCount=1
@=GlobalWire(HGLOBAL hMem);
[GlobalUnWire]
1=HGLOBAL hMem
ParamCount=1
@=GlobalUnWire(HGLOBAL hMem);
[GlobalMemoryStatus]
1=LPMEMORYSTATUS lpBuffer
ParamCount=1
@=GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer);
[GlobalMemoryStatusEx]
1=LPMEMORYSTATUSEX lpBuffer
ParamCount=1
@=GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer);
[LocalAlloc]
1=UINT uFlags
2=SIZE_T uBytes
ParamCount=2
@=LocalAlloc(UINT uFlags, SIZE_T uBytes);
[LocalReAlloc]
1=HLOCAL hMem
2=SIZE_T uBytes
3=UINT uFlags
ParamCount=3
@=LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags);
[LocalLock]
1=HLOCAL hMem
ParamCount=1
@=LocalLock(HLOCAL hMem);
[LocalHandle]
1=LPCVOID pMem
ParamCount=1
@=LocalHandle(LPCVOID pMem);
[LocalUnlock]
1=HLOCAL hMem
ParamCount=1
@=LocalUnlock(HLOCAL hMem);
[LocalSize]
1=HLOCAL hMem
ParamCount=1
@=LocalSize(HLOCAL hMem);
[LocalFlags]
1=HLOCAL hMem
ParamCount=1
@=LocalFlags(HLOCAL hMem);
[LocalFree]
1=HLOCAL hMem
ParamCount=1
@=LocalFree(HLOCAL hMem);
[LocalShrink]
1=HLOCAL hMem
2=UINT cbNewSize
ParamCount=2
@=LocalShrink(HLOCAL hMem, UINT cbNewSize);
[LocalCompact]
1=UINT uMinFree
ParamCount=1
@=LocalCompact(UINT uMinFree);
[FlushInstructionCache]
1=HANDLE hProcess
2=LPCVOID lpBaseAddress
3=SIZE_T dwSize
ParamCount=3
@=FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize);
[FlushProcessWriteBuffers]
ParamCount=0
@=FlushProcessWriteBuffers();
[QueryThreadCycleTime]
1=HANDLE ThreadHandle
2=PULONG64 CycleTime
ParamCount=2
@=QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime);
[QueryProcessCycleTime]
1=HANDLE ProcessHandle
2=PULONG64 CycleTime
ParamCount=2
@=QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime);
[QueryIdleProcessorCycleTime]
1=PULONG BufferLength
2=PULONG64 ProcessorIdleCycleTime
ParamCount=2
@=QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime);
[QueryIdleProcessorCycleTimeEx]
1=USHORT Group
2=PULONG BufferLength
3=PULONG64 ProcessorIdleCycleTime
ParamCount=3
@=QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime);
[QueryUnbiasedInterruptTime]
1=PULONGLONG UnbiasedTime
ParamCount=1
@=QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime);
[GetProcessorSystemCycleTime]
1=USHORT Group
2=PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer
3=PDWORD ReturnedLength
ParamCount=3
@=GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength);
[VirtualAlloc]
1=LPVOID lpAddress
2=SIZE_T dwSize
3=DWORD flAllocationType
4=DWORD flProtect
ParamCount=4
@=VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
[VirtualFree]
1=LPVOID lpAddress
2=SIZE_T dwSize
3=DWORD dwFreeType
ParamCount=3
@=VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
[VirtualProtect]
1=LPVOID lpAddress
2=SIZE_T dwSize
3=DWORD flNewProtect
4=PDWORD lpflOldProtect
ParamCount=4
@=VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
[VirtualQuery]
1=LPCVOID lpAddress
2=PMEMORY_BASIC_INFORMATION lpBuffer
3=SIZE_T dwLength
ParamCount=3
@=VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
[VirtualAllocEx]
1=HANDLE hProcess
2=LPVOID lpAddress
3=SIZE_T dwSize
4=DWORD flAllocationType
5=DWORD flProtect
ParamCount=5
@=VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
[VirtualAllocExNuma]
1=HANDLE hProcess
2=LPVOID lpAddress
3=SIZE_T dwSize
4=DWORD flAllocationType
5=DWORD flProtect
6=DWORD nndPreferred
ParamCount=6
@=VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred);
[GetWriteWatch]
1=DWORD dwFlags
2=PVOID lpBaseAddress
3=SIZE_T dwRegionSize
4=PVOID *lpAddresses
5=ULONG_PTR *lpdwCount
6=PULONG lpdwGranularity
ParamCount=6
@=GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, PULONG lpdwGranularity);
[ResetWriteWatch]
1=LPVOID lpBaseAddress
2=SIZE_T dwRegionSize
ParamCount=2
@=ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize);
[GetLargePageMinimum]
ParamCount=0
@=GetLargePageMinimum();
[EnumSystemFirmwareTables]
1=DWORD FirmwareTableProviderSignature
2=PVOID pFirmwareTableEnumBuffer
3=DWORD BufferSize
ParamCount=3
@=EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize);
[GetSystemFirmwareTable]
1=DWORD FirmwareTableProviderSignature
2=DWORD FirmwareTableID
3=PVOID pFirmwareTableBuffer
4=DWORD BufferSize
ParamCount=4
@=GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize);
[GetPhysicallyInstalledSystemMemory]
1=PULONGLONG TotalMemoryInKilobytes
ParamCount=1
@=GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes);
[VirtualFreeEx]
1=HANDLE hProcess
2=LPVOID lpAddress
3=SIZE_T dwSize
4=DWORD dwFreeType
ParamCount=4
@=VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
[VirtualProtectEx]
1=HANDLE hProcess
2=LPVOID lpAddress
3=SIZE_T dwSize
4=DWORD flNewProtect
5=PDWORD lpflOldProtect
ParamCount=5
@=VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
[VirtualQueryEx]
1=HANDLE hProcess
2=LPCVOID lpAddress
3=PMEMORY_BASIC_INFORMATION lpBuffer
4=SIZE_T dwLength
ParamCount=4
@=VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
[HeapCreate]
1=DWORD flOptions
2=SIZE_T dwInitialSize
3=SIZE_T dwMaximumSize
ParamCount=3
@=HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
[HeapDestroy]
1=HANDLE hHeap
ParamCount=1
@=HeapDestroy(HANDLE hHeap);
[HeapAlloc]
1=HANDLE hHeap
2=DWORD dwFlags
3=SIZE_T dwBytes
ParamCount=3
@=HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
[HeapReAlloc]
1=HANDLE hHeap
2=DWORD dwFlags
3=LPVOID lpMem
4=SIZE_T dwBytes
ParamCount=4
@=HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
[HeapFree]
1=HANDLE hHeap
2=DWORD dwFlags
3=DWORD LPVOIDlpMem
ParamCount=3
@=HeapFree(HANDLE hHeap, DWORD dwFlags, DWORD LPVOIDlpMem);
[HeapSize]
1=HANDLE hHeap
2=DWORD dwFlags
3=LPCVOID lpMem
ParamCount=3
@=HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
[HeapValidate]
1=HANDLE hHeap
2=DWORD dwFlags
3=LPCVOID lpMem
ParamCount=3
@=HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
[HeapCompact]
1=HANDLE hHeap
2=DWORD dwFlags
ParamCount=2
@=HeapCompact(HANDLE hHeap, DWORD dwFlags);
[GetProcessHeap]
ParamCount=0
@=GetProcessHeap();
[GetProcessHeaps]
1=DWORD NumberOfHeaps
2=PHANDLE ProcessHeaps
ParamCount=2
@=GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps);
[HeapLock]
1=HANDLE hHeap
ParamCount=1
@=HeapLock(HANDLE hHeap);
[HeapUnlock]
1=HANDLE hHeap
ParamCount=1
@=HeapUnlock(HANDLE hHeap);
[HeapWalk]
1=HANDLE hHeap
2=LPPROCESS_HEAP_ENTRY lpEntry
ParamCount=2
@=HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry);
[HeapSetInformation]
1=HANDLE HeapHandle
2=HEAP_INFORMATION_CLASS HeapInformationClass
3=PVOID HeapInformation
4=SIZE_T HeapInformationLength
ParamCount=4
@=HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength);
[HeapQueryInformation]
1=HANDLE HeapHandle
2=HEAP_INFORMATION_CLASS HeapInformationClass
3=PVOID HeapInformation
4=SIZE_T HeapInformationLength
5=PSIZE_T ReturnLength
ParamCount=5
@=HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength);
[GetBinaryTypeA]
1=LPCSTR lpApplicationName
2=LPDWORD lpBinaryType
ParamCount=2
@=GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType);
[GetBinaryTypeW]
1=LPCWSTR lpApplicationName
2=LPDWORD lpBinaryType
ParamCount=2
@=GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType);
[GetShortPathNameA]
1=LPCSTR lpszLongPath
2=LPSTR lpszShortPath
3=DWORD cchBuffer
ParamCount=3
@=GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
[GetShortPathNameW]
1=LPCWSTR lpszLongPath
2=LPWSTR lpszShortPath
3=DWORD cchBuffer
ParamCount=3
@=GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer);
[GetLongPathNameA]
1=LPCSTR lpszShortPath
2=LPSTR lpszLongPath
3=DWORD cchBuffer
ParamCount=3
@=GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer);
[GetLongPathNameW]
1=LPCWSTR lpszShortPath
2=LPWSTR lpszLongPath
3=DWORD cchBuffer
ParamCount=3
@=GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer);
[GetLongPathNameTransactedA]
1=LPCSTR lpszShortPath
2=LPSTR lpszLongPath
3=DWORD cchBuffer
4=HANDLE hTransaction
ParamCount=4
@=GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction);
[GetLongPathNameTransactedW]
1=LPCWSTR lpszShortPath
2=LPWSTR lpszLongPath
3=DWORD cchBuffer
4=HANDLE hTransaction
ParamCount=4
@=GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction);
[GetProcessAffinityMask]
1=HANDLE hProcess
2=PDWORD_PTR lpProcessAffinityMask
3=PDWORD_PTR lpSystemAffinityMask
ParamCount=3
@=GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
[SetProcessAffinityMask]
1=HANDLE hProcess
2=DWORD_PTR dwProcessAffinityMask
ParamCount=2
@=SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask);
[GetProcessGroupAffinity]
1=HANDLE hProcess
2=PUSHORT GroupCount
3=PUSHORT GroupArray
ParamCount=3
@=GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray);
[GetProcessHandleCount]
1=HANDLE hProcess
2=PDWORD pdwHandleCount
ParamCount=2
@=GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount);
[GetProcessTimes]
1=HANDLE hProcess
2=LPFILETIME lpCreationTime
3=LPFILETIME lpExitTime
4=LPFILETIME lpKernelTime
5=LPFILETIME lpUserTime
ParamCount=5
@=GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
[GetProcessIoCounters]
1=HANDLE hProcess
2=PIO_COUNTERS lpIoCounters
ParamCount=2
@=GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters);
[GetProcessWorkingSetSize]
1=HANDLE hProcess
2=PSIZE_T lpMinimumWorkingSetSize
3=PSIZE_T lpMaximumWorkingSetSize
ParamCount=3
@=GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize);
[GetProcessWorkingSetSizeEx]
1=HANDLE hProcess
2=PSIZE_T lpMinimumWorkingSetSize
3=PSIZE_T lpMaximumWorkingSetSize
4=PDWORD Flags
ParamCount=4
@=GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags);
[SetProcessWorkingSetSize]
1=HANDLE hProcess
2=SIZE_T dwMinimumWorkingSetSize
3=SIZE_T dwMaximumWorkingSetSize
ParamCount=3
@=SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize);
[SetProcessWorkingSetSizeEx]
1=HANDLE hProcess
2=SIZE_T dwMinimumWorkingSetSize
3=SIZE_T dwMaximumWorkingSetSize
4=DWORD Flags
ParamCount=4
@=SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags);
[SetProcessAffinityUpdateMode]
1=HANDLE hProcess
2=DWORD dwFlags
ParamCount=2
@=SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags);
[QueryProcessAffinityUpdateMode]
1=HANDLE hProcess
2=LPDWORD lpdwFlags
ParamCount=2
@=QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags);
[OpenProcess]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=DWORD dwProcessId
ParamCount=3
@=OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
[GetCurrentProcess]
ParamCount=0
@=GetCurrentProcess();
[GetCurrentProcessId]
ParamCount=0
@=GetCurrentProcessId();
[ExitProcess]
1=UINT uExitCode
ParamCount=1
@=ExitProcess(UINT uExitCode);
[TerminateProcess]
1=HANDLE hProcess
2=UINT uExitCode
ParamCount=2
@=TerminateProcess(HANDLE hProcess, UINT uExitCode);
[GetExitCodeProcess]
1=HANDLE hProcess
2=LPDWORD lpExitCode
ParamCount=2
@=GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
[FatalExit]
1=int ExitCode
ParamCount=1
@=FatalExit(int ExitCode);
[GetEnvironmentStrings]
ParamCount=0
@=GetEnvironmentStrings();
[GetEnvironmentStringsW]
ParamCount=0
@=GetEnvironmentStringsW();
[SetEnvironmentStringsA]
1=VOID LPCHNewEnvironment
ParamCount=1
@=SetEnvironmentStringsA(VOID LPCHNewEnvironment);
[SetEnvironmentStringsW]
1=VOID LPWCHNewEnvironment
ParamCount=1
@=SetEnvironmentStringsW(VOID LPWCHNewEnvironment);
[FreeEnvironmentStringsA]
1=VOID LPCH
ParamCount=1
@=FreeEnvironmentStringsA(VOID LPCH);
[FreeEnvironmentStringsW]
1=VOID LPWCH
ParamCount=1
@=FreeEnvironmentStringsW(VOID LPWCH);
[RaiseException]
1=DWORD dwExceptionCode
2=DWORD dwExceptionFlags
3=DWORD nNumberOfArguments
4=ULONG_PTR *lpArguments
ParamCount=4
@=RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, ULONG_PTR *lpArguments);
[RaiseFailFastException]
1=PEXCEPTION_RECORD pExceptionRecord
2=PCONTEXT pContextRecord
3=DWORD dwFlags
ParamCount=3
@=RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags);
[UnhandledExceptionFilter]
1=_EXCEPTION_POINTERS *ExceptionInfo
ParamCount=1
@=UnhandledExceptionFilter(_EXCEPTION_POINTERS *ExceptionInfo);
[SetUnhandledExceptionFilter]
1=LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
ParamCount=1
@=SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
[CreateFiber]
1=SIZE_T dwStackSize
2=LPFIBER_START_ROUTINE lpStartAddress
3=LPVOID lpParameter
ParamCount=3
@=CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter);
[CreateFiberEx]
1=SIZE_T dwStackCommitSize
2=SIZE_T dwStackReserveSize
3=DWORD dwFlags
4=LPFIBER_START_ROUTINE lpStartAddress
5=LPVOID lpParameter
ParamCount=5
@=CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter);
[DeleteFiber]
1=LPVOID lpFiber
ParamCount=1
@=DeleteFiber(LPVOID lpFiber);
[ConvertThreadToFiber]
1=LPVOID lpParameter
ParamCount=1
@=ConvertThreadToFiber(LPVOID lpParameter);
[ConvertThreadToFiberEx]
1=LPVOID lpParameter
2=DWORD dwFlags
ParamCount=2
@=ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags);
[ConvertFiberToThread]
ParamCount=0
@=ConvertFiberToThread();
[IsThreadAFiber]
ParamCount=0
@=IsThreadAFiber();
[SwitchToFiber]
1=LPVOID lpFiber
ParamCount=1
@=SwitchToFiber(LPVOID lpFiber);
[SwitchToThread]
ParamCount=0
@=SwitchToThread();
[CreateUmsCompletionList]
1=PUMS_COMPLETION_LIST* UmsCompletionList
ParamCount=1
@=CreateUmsCompletionList(PUMS_COMPLETION_LIST* UmsCompletionList);
[DequeueUmsCompletionListItems]
1=PUMS_COMPLETION_LIST UmsCompletionList
2=DWORD WaitTimeOut
3=PUMS_CONTEXT* UmsThreadList
ParamCount=3
@=DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT* UmsThreadList);
[GetUmsCompletionListEvent]
1=PUMS_COMPLETION_LIST UmsCompletionList
2=PHANDLE UmsCompletionEvent
ParamCount=2
@=GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent);
[ExecuteUmsThread]
1=PUMS_CONTEXT UmsThread
ParamCount=1
@=ExecuteUmsThread(PUMS_CONTEXT UmsThread);
[UmsThreadYield]
1=PVOID SchedulerParam
ParamCount=1
@=UmsThreadYield(PVOID SchedulerParam);
[DeleteUmsCompletionList]
1=PUMS_COMPLETION_LIST UmsCompletionList
ParamCount=1
@=DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList);
[GetCurrentUmsThread]
ParamCount=0
@=GetCurrentUmsThread();
[GetNextUmsListItem]
1=PUMS_CONTEXT UmsContext
ParamCount=1
@=GetNextUmsListItem(PUMS_CONTEXT UmsContext);
[QueryUmsThreadInformation]
1=PUMS_CONTEXT UmsThread
2=UMS_THREAD_INFO_CLASS UmsThreadInfoClass
3=PVOID UmsThreadInformation
4=ULONG UmsThreadInformationLength
5=PULONG ReturnLength
ParamCount=5
@=QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength);
[SetUmsThreadInformation]
1=PUMS_CONTEXT UmsThread
2=UMS_THREAD_INFO_CLASS UmsThreadInfoClass
3=PVOID UmsThreadInformation
4=ULONG UmsThreadInformationLength
ParamCount=4
@=SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength);
[DeleteUmsThreadContext]
1=PUMS_CONTEXT UmsThread
ParamCount=1
@=DeleteUmsThreadContext(PUMS_CONTEXT UmsThread);
[CreateUmsThreadContext]
1=PUMS_CONTEXT *lpUmsThread
ParamCount=1
@=CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread);
[EnterUmsSchedulingMode]
1=PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo
ParamCount=1
@=EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo);
[CreateThread]
1=LPSECURITY_ATTRIBUTES lpThreadAttributes
2=SIZE_T dwStackSize
3=LPTHREAD_START_ROUTINE lpStartAddress
4=LPTHREAD_START_ROUTINE LPVOIDlpParameter
5=DWORD dwCreationFlags
6=LPDWORD lpThreadId
ParamCount=6
@=CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPTHREAD_START_ROUTINE LPVOIDlpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
[CreateRemoteThread]
1=HANDLE hProcess
2=LPSECURITY_ATTRIBUTES lpThreadAttributes
3=SIZE_T dwStackSize
4=LPTHREAD_START_ROUTINE lpStartAddress
5=LPVOID lpParameter
6=DWORD dwCreationFlags
7=LPDWORD lpThreadId
ParamCount=7
@=CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
[CreateRemoteThreadEx]
1=HANDLE hProcess
2=LPSECURITY_ATTRIBUTES lpThreadAttributes
3=SIZE_T dwStackSize
4=LPTHREAD_START_ROUTINE lpStartAddress
5=LPVOID lpParameter
6=DWORD dwCreationFlags
7=LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
8=LPDWORD lpThreadId
ParamCount=8
@=CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId);
[GetCurrentThread]
ParamCount=0
@=GetCurrentThread();
[GetCurrentThreadId]
ParamCount=0
@=GetCurrentThreadId();
[SetThreadStackGuarantee]
1=PULONG StackSizeInBytes
ParamCount=1
@=SetThreadStackGuarantee(PULONG StackSizeInBytes);
[GetProcessIdOfThread]
1=HANDLE Thread
ParamCount=1
@=GetProcessIdOfThread(HANDLE Thread);
[GetThreadId]
1=HANDLE Thread
ParamCount=1
@=GetThreadId(HANDLE Thread);
[GetProcessId]
1=HANDLE Process
ParamCount=1
@=GetProcessId(HANDLE Process);
[GetCurrentProcessorNumber]
ParamCount=0
@=GetCurrentProcessorNumber();
[GetCurrentProcessorNumberEx]
1=PPROCESSOR_NUMBER ProcNumber
ParamCount=1
@=GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber);
[GetThreadGroupAffinity]
1=HANDLE hThread
2=PGROUP_AFFINITY GroupAffinity
ParamCount=2
@=GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity);
[SetThreadAffinityMask]
1=HANDLE hThread
2=DWORD_PTR dwThreadAffinityMask
ParamCount=2
@=SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
[SetThreadGroupAffinity]
1=HANDLE hThread
2=GROUP_AFFINITY *GroupAffinity
3=PGROUP_AFFINITY PreviousGroupAffinity
ParamCount=3
@=SetThreadGroupAffinity(HANDLE hThread, GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity);
[SetThreadIdealProcessorEx]
1=HANDLE hThread
2=PPROCESSOR_NUMBER lpIdealProcessor
3=PPROCESSOR_NUMBER lpPreviousIdealProcessor
ParamCount=3
@=SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor);
[GetThreadIdealProcessorEx]
1=HANDLE hThread
2=PPROCESSOR_NUMBER lpIdealProcessor
ParamCount=2
@=GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor);
[SetThreadIdealProcessor]
1=HANDLE hThread
2=DWORD dwIdealProcessor
ParamCount=2
@=SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor);
[SetProcessDEPPolicy]
1=DWORD dwFlags
ParamCount=1
@=SetProcessDEPPolicy(DWORD dwFlags);
[GetProcessDEPPolicy]
1=HANDLE hProcess
2=LPDWORD lpFlags
3=PBOOL lpPermanent
ParamCount=3
@=GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent);
[SetProcessPriorityBoost]
1=HANDLE hProcess
2=BOOL bDisablePriorityBoost
ParamCount=2
@=SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost);
[GetProcessPriorityBoost]
1=HANDLE hProcess
2=PBOOL pDisablePriorityBoost
ParamCount=2
@=GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost);
[RequestWakeupLatency]
1=LATENCY_TIME latency
ParamCount=1
@=RequestWakeupLatency(LATENCY_TIME latency);
[IsSystemResumeAutomatic]
ParamCount=0
@=IsSystemResumeAutomatic();
[OpenThread]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=DWORD dwThreadId
ParamCount=3
@=OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
[SetThreadPriority]
1=HANDLE hThread
2=int nPriority
ParamCount=2
@=SetThreadPriority(HANDLE hThread, int nPriority);
[SetThreadPriorityBoost]
1=HANDLE hThread
2=BOOL bDisablePriorityBoost
ParamCount=2
@=SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost);
[GetThreadPriorityBoost]
1=HANDLE hThread
2=PBOOL pDisablePriorityBoost
ParamCount=2
@=GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost);
[GetThreadPriority]
1=HANDLE hThread
ParamCount=1
@=GetThreadPriority(HANDLE hThread);
[GetThreadTimes]
1=HANDLE hThread
2=LPFILETIME lpCreationTime
3=LPFILETIME lpExitTime
4=LPFILETIME lpKernelTime
5=LPFILETIME lpUserTime
ParamCount=5
@=GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
[GetThreadIOPendingFlag]
1=HANDLE hThread
2=PBOOL lpIOIsPending
ParamCount=2
@=GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending);
[ExitThread]
1=DWORD dwExitCode
ParamCount=1
@=ExitThread(DWORD dwExitCode);
[TerminateThread]
1=HANDLE hThread
2=DWORD dwExitCode
ParamCount=2
@=TerminateThread(HANDLE hThread, DWORD dwExitCode);
[GetExitCodeThread]
1=HANDLE hThread
2=LPDWORD lpExitCode
ParamCount=2
@=GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);
[GetThreadSelectorEntry]
1=HANDLE hThread
2=DWORD dwSelector
3=LPLDT_ENTRY lpSelectorEntry
ParamCount=3
@=GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry);
[SetThreadExecutionState]
1=EXECUTION_STATE esFlags
ParamCount=1
@=SetThreadExecutionState(EXECUTION_STATE esFlags);
[PowerCreateRequest]
1=PREASON_CONTEXT Context
ParamCount=1
@=PowerCreateRequest(PREASON_CONTEXT Context);
[PowerSetRequest]
1=HANDLE PowerRequest
2=POWER_REQUEST_TYPE RequestType
ParamCount=2
@=PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);
[PowerClearRequest]
1=HANDLE PowerRequest
2=POWER_REQUEST_TYPE RequestType
ParamCount=2
@=PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);
[GetLastError]
ParamCount=0
@=GetLastError();
[SetLastError]
1=DWORD dwErrCode
ParamCount=1
@=SetLastError(DWORD dwErrCode);
[RestoreLastError]
1=DWORD dwErrCode
ParamCount=1
@=RestoreLastError(DWORD dwErrCode);
[GetOverlappedResult]
1=HANDLE hFile
2=LPOVERLAPPED lpOverlapped
3=LPDWORD lpNumberOfBytesTransferred
4=BOOL bWait
ParamCount=4
@=GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
[CreateIoCompletionPort]
1=HANDLE FileHandle
2=HANDLE ExistingCompletionPort
3=ULONG_PTR CompletionKey
4=DWORD NumberOfConcurrentThreads
ParamCount=4
@=CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
[GetQueuedCompletionStatus]
1=HANDLE CompletionPort
2=LPDWORD lpNumberOfBytesTransferred
3=PULONG_PTR lpCompletionKey
4=LPOVERLAPPED *lpOverlapped
5=DWORD dwMilliseconds
ParamCount=5
@=GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);
[GetQueuedCompletionStatusEx]
1=HANDLE CompletionPort
2=LPOVERLAPPED_ENTRY lpCompletionPortEntries
3=ULONG ulCount
4=PULONG ulNumEntriesRemoved
5=DWORD dwMilliseconds
6=BOOL fAlertable
ParamCount=6
@=GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable);
[PostQueuedCompletionStatus]
1=HANDLE CompletionPort
2=DWORD dwNumberOfBytesTransferred
3=ULONG_PTR dwCompletionKey
4=LPOVERLAPPED lpOverlapped
ParamCount=4
@=PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped);
[SetFileCompletionNotificationModes]
1=HANDLE FileHandle
2=UCHAR Flags
ParamCount=2
@=SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags);
[SetFileIoOverlappedRange]
1=HANDLE FileHandle
2=PUCHAR OverlappedRangeStart
3=ULONG Length
ParamCount=3
@=SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length);
[GetErrorMode]
ParamCount=0
@=GetErrorMode();
[SetErrorMode]
1=UINT uMode
ParamCount=1
@=SetErrorMode(UINT uMode);
[GetThreadErrorMode]
ParamCount=0
@=GetThreadErrorMode();
[SetThreadErrorMode]
1=DWORD dwNewMode
2=LPDWORD lpOldMode
ParamCount=2
@=SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode);
[ReadProcessMemory]
1=HANDLE hProcess
2=LPCVOID lpBaseAddress
3=LPVOID lpBuffer
4=SIZE_T nSize
5=SIZE_T *lpNumberOfBytesRead
ParamCount=5
@=ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
[WriteProcessMemory]
1=HANDLE hProcess
2=LPVOID lpBaseAddress
3=LPCVOID lpBuffer
4=SIZE_T nSize
5=SIZE_T *lpNumberOfBytesWritten
ParamCount=5
@=WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
[GetThreadContext]
1=HANDLE hThread
2=LPCONTEXT lpContext
ParamCount=2
@=GetThreadContext(HANDLE hThread, LPCONTEXT lpContext);
[SetThreadContext]
1=HANDLE hThread
2=CONTEXT *lpContext
ParamCount=2
@=SetThreadContext(HANDLE hThread, CONTEXT *lpContext);
[Wow64GetThreadContext]
1=HANDLE hThread
2=PWOW64_CONTEXT lpContext
ParamCount=2
@=Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext);
[Wow64GetThreadSelectorEntry]
1=HANDLE hThread
2=DWORD dwSelector
3=PWOW64_LDT_ENTRY lpSelectorEntry
ParamCount=3
@=Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry);
[Wow64SetThreadContext]
1=HANDLE hThread
2=WOW64_CONTEXT *lpContext
ParamCount=2
@=Wow64SetThreadContext(HANDLE hThread, WOW64_CONTEXT *lpContext);
[SuspendThread]
1=HANDLE hThread
ParamCount=1
@=SuspendThread(HANDLE hThread);
[Wow64SuspendThread]
1=HANDLE hThread
ParamCount=1
@=Wow64SuspendThread(HANDLE hThread);
[ResumeThread]
1=HANDLE hThread
ParamCount=1
@=ResumeThread(HANDLE hThread);
[QueueUserAPC]
1=PAPCFUNC pfnAPC
2=HANDLE hThread
3=ULONG_PTR dwData
ParamCount=3
@=QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);
[IsDebuggerPresent]
ParamCount=0
@=IsDebuggerPresent();
[CheckRemoteDebuggerPresent]
1=HANDLE hProcess
2=PBOOL pbDebuggerPresent
ParamCount=2
@=CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent);
[DebugBreak]
ParamCount=0
@=DebugBreak();
[WaitForDebugEvent]
1=LPDEBUG_EVENT lpDebugEvent
2=DWORD dwMilliseconds
ParamCount=2
@=WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds);
[ContinueDebugEvent]
1=DWORD dwProcessId
2=DWORD dwThreadId
3=DWORD dwContinueStatus
ParamCount=3
@=ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus);
[DebugActiveProcess]
1=DWORD dwProcessId
ParamCount=1
@=DebugActiveProcess(DWORD dwProcessId);
[DebugActiveProcessStop]
1=DWORD dwProcessId
ParamCount=1
@=DebugActiveProcessStop(DWORD dwProcessId);
[DebugSetProcessKillOnExit]
1=BOOL KillOnExit
ParamCount=1
@=DebugSetProcessKillOnExit(BOOL KillOnExit);
[DebugBreakProcess]
1=HANDLE Process
ParamCount=1
@=DebugBreakProcess(HANDLE Process);
[InitializeCriticalSection]
1=LPCRITICAL_SECTION lpCriticalSection
ParamCount=1
@=InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
[EnterCriticalSection]
1=LPCRITICAL_SECTION lpCriticalSection
ParamCount=1
@=EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
[LeaveCriticalSection]
1=LPCRITICAL_SECTION lpCriticalSection
ParamCount=1
@=LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
[InitializeCriticalSectionAndSpinCount]
1=LPCRITICAL_SECTION lpCriticalSection
2=DWORD dwSpinCount
ParamCount=2
@=InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
[InitializeCriticalSectionEx]
1=LPCRITICAL_SECTION lpCriticalSection
2=DWORD dwSpinCount
3=DWORD Flags
ParamCount=3
@=InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags);
[SetCriticalSectionSpinCount]
1=LPCRITICAL_SECTION lpCriticalSection
2=DWORD dwSpinCount
ParamCount=2
@=SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
[TryEnterCriticalSection]
1=LPCRITICAL_SECTION lpCriticalSection
ParamCount=1
@=TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
[DeleteCriticalSection]
1=LPCRITICAL_SECTION lpCriticalSection
ParamCount=1
@=DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
[SetEvent]
1=HANDLE hEvent
ParamCount=1
@=SetEvent(HANDLE hEvent);
[ResetEvent]
1=HANDLE hEvent
ParamCount=1
@=ResetEvent(HANDLE hEvent);
[PulseEvent]
1=HANDLE hEvent
ParamCount=1
@=PulseEvent(HANDLE hEvent);
[ReleaseSemaphore]
1=HANDLE hSemaphore
2=LONG lReleaseCount
3=LPLONG lpPreviousCount
ParamCount=3
@=ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
[ReleaseMutex]
1=HANDLE hMutex
ParamCount=1
@=ReleaseMutex(HANDLE hMutex);
[WaitForSingleObject]
1=HANDLE hHandle
2=DWORD dwMilliseconds
ParamCount=2
@=WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
[WaitForMultipleObjects]
1=DWORD nCount
2=HANDLE *lpHandles
3=BOOL bWaitAll
4=DWORD dwMilliseconds
ParamCount=4
@=WaitForMultipleObjects(DWORD nCount, HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
[Sleep]
1=DWORD dwMilliseconds
ParamCount=1
@=Sleep(DWORD dwMilliseconds);
[LoadResource]
1=HMODULE hModule
2=HRSRC hResInfo
ParamCount=2
@=LoadResource(HMODULE hModule, HRSRC hResInfo);
[SizeofResource]
1=HMODULE hModule
2=HRSRC hResInfo
ParamCount=2
@=SizeofResource(HMODULE hModule, HRSRC hResInfo);
[GlobalDeleteAtom]
1=ATOM nAtom
ParamCount=1
@=GlobalDeleteAtom(ATOM nAtom);
[InitAtomTable]
1=DWORD nSize
ParamCount=1
@=InitAtomTable(DWORD nSize);
[DeleteAtom]
1=ATOM nAtom
ParamCount=1
@=DeleteAtom(ATOM nAtom);
[SetHandleCount]
1=UINT uNumber
ParamCount=1
@=SetHandleCount(UINT uNumber);
[GetLogicalDrives]
ParamCount=0
@=GetLogicalDrives();
[LockFile]
1=HANDLE hFile
2=DWORD dwFileOffsetLow
3=DWORD dwFileOffsetHigh
4=DWORD nNumberOfBytesToLockLow
5=DWORD nNumberOfBytesToLockHigh
ParamCount=5
@=LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
[UnlockFile]
1=HANDLE hFile
2=DWORD dwFileOffsetLow
3=DWORD dwFileOffsetHigh
4=DWORD nNumberOfBytesToUnlockLow
5=DWORD nNumberOfBytesToUnlockHigh
ParamCount=5
@=UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh);
[LockFileEx]
1=HANDLE hFile
2=DWORD dwFlags
3=DWORD dwReserved
4=DWORD nNumberOfBytesToLockLow
5=DWORD nNumberOfBytesToLockHigh
6=LPOVERLAPPED lpOverlapped
ParamCount=6
@=LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped);
[UnlockFileEx]
1=HANDLE hFile
2=DWORD dwReserved
3=DWORD nNumberOfBytesToUnlockLow
4=DWORD nNumberOfBytesToUnlockHigh
5=LPOVERLAPPED lpOverlapped
ParamCount=5
@=UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped);
[GetFileInformationByHandle]
1=HANDLE hFile
2=LPBY_HANDLE_FILE_INFORMATION lpFileInformation
ParamCount=2
@=GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
[GetFileType]
1=HANDLE hFile
ParamCount=1
@=GetFileType(HANDLE hFile);
[GetFileSize]
1=HANDLE hFile
2=LPDWORD lpFileSizeHigh
ParamCount=2
@=GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
[GetFileSizeEx]
1=HANDLE hFile
2=PLARGE_INTEGER lpFileSize
ParamCount=2
@=GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize);
[GetStdHandle]
1=DWORD nStdHandle
ParamCount=1
@=GetStdHandle(DWORD nStdHandle);
[SetStdHandle]
1=DWORD nStdHandle
2=HANDLE hHandle
ParamCount=2
@=SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
[SetStdHandleEx]
1=DWORD nStdHandle
2=HANDLE hHandle
3=PHANDLE phPrevValue
ParamCount=3
@=SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue);
[WriteFile]
1=HANDLE hFile
2=LPCVOID lpBuffer
3=DWORD nNumberOfBytesToWrite
4=LPDWORD lpNumberOfBytesWritten
5=LPOVERLAPPED lpOverlapped
ParamCount=5
@=WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
[ReadFile]
1=HANDLE hFile
2=LPVOID lpBuffer
3=DWORD nNumberOfBytesToRead
4=LPDWORD lpNumberOfBytesRead
5=LPOVERLAPPED lpOverlapped
ParamCount=5
@=ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
[FlushFileBuffers]
1=HANDLE hFile
ParamCount=1
@=FlushFileBuffers(HANDLE hFile);
[DeviceIoControl]
1=HANDLE hDevice
2=DWORD dwIoControlCode
3=LPVOID lpInBuffer
4=DWORD nInBufferSize
5=LPVOID lpOutBuffer
6=DWORD nOutBufferSize
7=LPDWORD lpBytesReturned
8=LPOVERLAPPED lpOverlapped
ParamCount=8
@=DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
[RequestDeviceWakeup]
1=HANDLE hDevice
ParamCount=1
@=RequestDeviceWakeup(HANDLE hDevice);
[CancelDeviceWakeupRequest]
1=HANDLE hDevice
ParamCount=1
@=CancelDeviceWakeupRequest(HANDLE hDevice);
[GetDevicePowerState]
1=HANDLE hDevice
2=BOOL *pfOn
ParamCount=2
@=GetDevicePowerState(HANDLE hDevice, BOOL *pfOn);
[SetMessageWaitingIndicator]
1=HANDLE hMsgIndicator
2=ULONG ulMsgCount
ParamCount=2
@=SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount);
[SetEndOfFile]
1=HANDLE hFile
ParamCount=1
@=SetEndOfFile(HANDLE hFile);
[SetFilePointer]
1=HANDLE hFile
2=LONG lDistanceToMove
3=PLONG lpDistanceToMoveHigh
4=DWORD dwMoveMethod
ParamCount=4
@=SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
[SetFilePointerEx]
1=HANDLE hFile
2=LARGE_INTEGER liDistanceToMove
3=PLARGE_INTEGER lpNewFilePointer
4=DWORD dwMoveMethod
ParamCount=4
@=SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
[FindClose]
1=HANDLE hFindFile
ParamCount=1
@=FindClose(HANDLE hFindFile);
[GetFileTime]
1=HANDLE hFile
2=LPFILETIME lpCreationTime
3=LPFILETIME lpLastAccessTime
4=LPFILETIME lpLastWriteTime
ParamCount=4
@=GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
[SetFileTime]
1=HANDLE hFile
2=FILETIME *lpCreationTime
3=FILETIME *lpLastAccessTime
4=FILETIME *lpLastWriteTime
ParamCount=4
@=SetFileTime(HANDLE hFile, FILETIME *lpCreationTime, FILETIME *lpLastAccessTime, FILETIME *lpLastWriteTime);
[SetFileValidData]
1=HANDLE hFile
2=LONGLONG ValidDataLength
ParamCount=2
@=SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength);
[SetFileShortNameA]
1=HANDLE hFile
2=LPCSTR lpShortName
ParamCount=2
@=SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName);
[SetFileShortNameW]
1=HANDLE hFile
2=LPCWSTR lpShortName
ParamCount=2
@=SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName);
[CloseHandle]
1=HANDLE hObject
ParamCount=1
@=CloseHandle(HANDLE hObject);
[DuplicateHandle]
1=HANDLE hSourceProcessHandle
2=HANDLE hSourceHandle
3=HANDLE hTargetProcessHandle
4=LPHANDLE lpTargetHandle
5=DWORD dwDesiredAccess
6=BOOL bInheritHandle
7=DWORD dwOptions
ParamCount=7
@=DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
[GetHandleInformation]
1=HANDLE hObject
2=LPDWORD lpdwFlags
ParamCount=2
@=GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags);
[SetHandleInformation]
1=HANDLE hObject
2=DWORD dwMask
3=DWORD dwFlags
ParamCount=3
@=SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags);
[LoadModule]
1=LPCSTR lpModuleName
2=LPVOID lpParameterBlock
ParamCount=2
@=LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock);
[WinExec]
1=LPCSTR lpCmdLine
2=UINT uCmdShow
ParamCount=2
@=WinExec(LPCSTR lpCmdLine, UINT uCmdShow);
[ClearCommBreak]
1=HANDLE hFile
ParamCount=1
@=ClearCommBreak(HANDLE hFile);
[ClearCommError]
1=HANDLE hFile
2=LPDWORD lpErrors
3=LPCOMSTAT lpStat
ParamCount=3
@=ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat);
[SetupComm]
1=HANDLE hFile
2=DWORD dwInQueue
3=DWORD dwOutQueue
ParamCount=3
@=SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue);
[EscapeCommFunction]
1=HANDLE hFile
2=DWORD dwFunc
ParamCount=2
@=EscapeCommFunction(HANDLE hFile, DWORD dwFunc);
[GetCommConfig]
1=HANDLE hCommDev
2=LPCOMMCONFIG lpCC
3=LPDWORD lpdwSize
ParamCount=3
@=GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
[GetCommMask]
1=HANDLE hFile
2=LPDWORD lpEvtMask
ParamCount=2
@=GetCommMask(HANDLE hFile, LPDWORD lpEvtMask);
[GetCommProperties]
1=HANDLE hFile
2=LPCOMMPROP lpCommProp
ParamCount=2
@=GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp);
[GetCommModemStatus]
1=HANDLE hFile
2=LPDWORD lpModemStat
ParamCount=2
@=GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat);
[GetCommState]
1=HANDLE hFile
2=LPDCB lpDCB
ParamCount=2
@=GetCommState(HANDLE hFile, LPDCB lpDCB);
[GetCommTimeouts]
1=HANDLE hFile
2=LPCOMMTIMEOUTS lpCommTimeouts
ParamCount=2
@=GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
[PurgeComm]
1=HANDLE hFile
2=DWORD dwFlags
ParamCount=2
@=PurgeComm(HANDLE hFile, DWORD dwFlags);
[SetCommBreak]
1=HANDLE hFile
ParamCount=1
@=SetCommBreak(HANDLE hFile);
[SetCommConfig]
1=HANDLE hCommDev
2=LPCOMMCONFIG lpCC
3=DWORD dwSize
ParamCount=3
@=SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize);
[SetCommMask]
1=HANDLE hFile
2=DWORD dwEvtMask
ParamCount=2
@=SetCommMask(HANDLE hFile, DWORD dwEvtMask);
[SetCommState]
1=HANDLE hFile
2=LPDCB lpDCB
ParamCount=2
@=SetCommState(HANDLE hFile, LPDCB lpDCB);
[SetCommTimeouts]
1=HANDLE hFile
2=LPCOMMTIMEOUTS lpCommTimeouts
ParamCount=2
@=SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
[TransmitCommChar]
1=HANDLE hFile
2=char cChar
ParamCount=2
@=TransmitCommChar(HANDLE hFile, char cChar);
[WaitCommEvent]
1=HANDLE hFile
2=LPDWORD lpEvtMask
3=LPOVERLAPPED lpOverlapped
ParamCount=3
@=WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped);
[SetTapePosition]
1=HANDLE hDevice
2=DWORD dwPositionMethod
3=DWORD dwPartition
4=DWORD dwOffsetLow
5=DWORD dwOffsetHigh
6=BOOL bImmediate
ParamCount=6
@=SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate);
[GetTapePosition]
1=HANDLE hDevice
2=DWORD dwPositionType
3=LPDWORD lpdwPartition
4=LPDWORD lpdwOffsetLow
5=LPDWORD lpdwOffsetHigh
ParamCount=5
@=GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh);
[PrepareTape]
1=HANDLE hDevice
2=DWORD dwOperation
3=BOOL bImmediate
ParamCount=3
@=PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate);
[EraseTape]
1=HANDLE hDevice
2=DWORD dwEraseType
3=BOOL bImmediate
ParamCount=3
@=EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate);
[CreateTapePartition]
1=HANDLE hDevice
2=DWORD dwPartitionMethod
3=DWORD dwCount
4=DWORD dwSize
ParamCount=4
@=CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize);
[WriteTapemark]
1=HANDLE hDevice
2=DWORD dwTapemarkType
3=DWORD dwTapemarkCount
4=BOOL bImmediate
ParamCount=4
@=WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate);
[GetTapeStatus]
1=HANDLE hDevice
ParamCount=1
@=GetTapeStatus(HANDLE hDevice);
[GetTapeParameters]
1=HANDLE hDevice
2=DWORD dwOperation
3=LPDWORD lpdwSize
4=LPVOID lpTapeInformation
ParamCount=4
@=GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation);
[SetTapeParameters]
1=HANDLE hDevice
2=DWORD dwOperation
3=LPVOID lpTapeInformation
ParamCount=3
@=SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation);
[Beep]
1=DWORD dwFreq
2=DWORD dwDuration
ParamCount=2
@=Beep(DWORD dwFreq, DWORD dwDuration);
[MulDiv]
1=int nNumber
2=int nNumerator
3=int nDenominator
ParamCount=3
@=MulDiv(int nNumber, int nNumerator, int nDenominator);
[GetSystemTime]
1=LPSYSTEMTIME lpSystemTime
ParamCount=1
@=GetSystemTime(LPSYSTEMTIME lpSystemTime);
[GetSystemTimeAsFileTime]
1=LPFILETIME lpSystemTimeAsFileTime
ParamCount=1
@=GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
[SetSystemTime]
1=SYSTEMTIME *lpSystemTime
ParamCount=1
@=SetSystemTime(SYSTEMTIME *lpSystemTime);
[GetLocalTime]
1=LPSYSTEMTIME lpSystemTime
ParamCount=1
@=GetLocalTime(LPSYSTEMTIME lpSystemTime);
[SetLocalTime]
1=SYSTEMTIME *lpSystemTime
ParamCount=1
@=SetLocalTime(SYSTEMTIME *lpSystemTime);
[GetSystemInfo]
1=LPSYSTEM_INFO lpSystemInfo
ParamCount=1
@=GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
[GetSystemDEPPolicy]
ParamCount=0
@=GetSystemDEPPolicy();
[SetSystemFileCacheSize]
1=SIZE_T MinimumFileCacheSize
2=SIZE_T MaximumFileCacheSize
3=DWORD Flags
ParamCount=3
@=SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags);
[GetSystemFileCacheSize]
1=PSIZE_T lpMinimumFileCacheSize
2=PSIZE_T lpMaximumFileCacheSize
3=PDWORD lpFlags
ParamCount=3
@=GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags);
[GetSystemRegistryQuota]
1=PDWORD pdwQuotaAllowed
2=PDWORD pdwQuotaUsed
ParamCount=2
@=GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed);
[GetSystemTimes]
1=LPFILETIME lpIdleTime
2=LPFILETIME lpKernelTime
3=LPFILETIME lpUserTime
ParamCount=3
@=GetSystemTimes(LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
[GetNativeSystemInfo]
1=LPSYSTEM_INFO lpSystemInfo
ParamCount=1
@=GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo);
[IsProcessorFeaturePresent]
1=DWORD ProcessorFeature
ParamCount=1
@=IsProcessorFeaturePresent(DWORD ProcessorFeature);
[SystemTimeToTzSpecificLocalTime]
1=TIME_ZONE_INFORMATION *lpTimeZoneInformation
2=SYSTEMTIME *lpUniversalTime
3=LPSYSTEMTIME lpLocalTime
ParamCount=3
@=SystemTimeToTzSpecificLocalTime(TIME_ZONE_INFORMATION *lpTimeZoneInformation, SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime);
[TzSpecificLocalTimeToSystemTime]
1=TIME_ZONE_INFORMATION *lpTimeZoneInformation
2=SYSTEMTIME *lpLocalTime
3=LPSYSTEMTIME lpUniversalTime
ParamCount=3
@=TzSpecificLocalTimeToSystemTime(TIME_ZONE_INFORMATION *lpTimeZoneInformation, SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime);
[GetTimeZoneInformationForYear]
1=USHORT wYear
2=PDYNAMIC_TIME_ZONE_INFORMATION pdtzi
3=LPTIME_ZONE_INFORMATION ptzi
ParamCount=3
@=GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi);
[GetTimeZoneInformation]
1=LPTIME_ZONE_INFORMATION lpTimeZoneInformation
ParamCount=1
@=GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
[SetTimeZoneInformation]
1=TIME_ZONE_INFORMATION *lpTimeZoneInformation
ParamCount=1
@=SetTimeZoneInformation(TIME_ZONE_INFORMATION *lpTimeZoneInformation);
[GetDynamicTimeZoneInformation]
1=PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
ParamCount=1
@=GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);
[SetDynamicTimeZoneInformation]
1=DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation
ParamCount=1
@=SetDynamicTimeZoneInformation(DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation);
[SystemTimeToFileTime]
1=SYSTEMTIME *lpSystemTime
2=LPFILETIME lpFileTime
ParamCount=2
@=SystemTimeToFileTime(SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
[FileTimeToLocalFileTime]
1=FILETIME *lpFileTime
2=LPFILETIME lpLocalFileTime
ParamCount=2
@=FileTimeToLocalFileTime(FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
[LocalFileTimeToFileTime]
1=FILETIME *lpLocalFileTime
2=LPFILETIME lpFileTime
ParamCount=2
@=LocalFileTimeToFileTime(FILETIME *lpLocalFileTime, LPFILETIME lpFileTime);
[FileTimeToSystemTime]
1=FILETIME *lpFileTime
2=LPSYSTEMTIME lpSystemTime
ParamCount=2
@=FileTimeToSystemTime(FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
[CompareFileTime]
1=FILETIME *lpFileTime1
2=FILETIME *lpFileTime2
ParamCount=2
@=CompareFileTime(FILETIME *lpFileTime1, FILETIME *lpFileTime2);
[FileTimeToDosDateTime]
1=FILETIME *lpFileTime
2=LPWORD lpFatDate
3=LPWORD lpFatTime
ParamCount=3
@=FileTimeToDosDateTime(FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime);
[DosDateTimeToFileTime]
1=WORD wFatDate
2=WORD wFatTime
3=LPFILETIME lpFileTime
ParamCount=3
@=DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime);
[GetTickCount]
ParamCount=0
@=GetTickCount();
[GetTickCount64]
ParamCount=0
@=GetTickCount64();
[SetSystemTimeAdjustment]
1=DWORD dwTimeAdjustment
2=BOOL bTimeAdjustmentDisabled
ParamCount=2
@=SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled);
[GetSystemTimeAdjustment]
1=PDWORD lpTimeAdjustment
2=PDWORD lpTimeIncrement
3=PBOOL lpTimeAdjustmentDisabled
ParamCount=3
@=GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled);
[FormatMessageA]
1=DWORD dwFlags
2=LPCVOID lpSource
3=DWORD dwMessageId
4=DWORD dwLanguageId
5=LPSTR lpBuffer
6=DWORD nSize
7=va_list *Arguments
ParamCount=7
@=FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
[FormatMessageW]
1=DWORD dwFlags
2=LPCVOID lpSource
3=DWORD dwMessageId
4=DWORD dwLanguageId
5=LPWSTR lpBuffer
6=DWORD nSize
7=va_list *Arguments
ParamCount=7
@=FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
[CreatePipe]
1=PHANDLE hReadPipe
2=PHANDLE hWritePipe
3=LPSECURITY_ATTRIBUTES lpPipeAttributes
4=DWORD nSize
ParamCount=4
@=CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
[ConnectNamedPipe]
1=HANDLE hNamedPipe
2=LPOVERLAPPED lpOverlapped
ParamCount=2
@=ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped);
[DisconnectNamedPipe]
1=HANDLE hNamedPipe
ParamCount=1
@=DisconnectNamedPipe(HANDLE hNamedPipe);
[SetNamedPipeHandleState]
1=HANDLE hNamedPipe
2=LPDWORD lpMode
3=LPDWORD lpMaxCollectionCount
4=LPDWORD lpCollectDataTimeout
ParamCount=4
@=SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout);
[GetNamedPipeInfo]
1=HANDLE hNamedPipe
2=LPDWORD lpFlags
3=LPDWORD lpOutBufferSize
4=LPDWORD lpInBufferSize
5=LPDWORD lpMaxInstances
ParamCount=5
@=GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances);
[PeekNamedPipe]
1=HANDLE hNamedPipe
2=LPVOID lpBuffer
3=DWORD nBufferSize
4=LPDWORD lpBytesRead
5=LPDWORD lpTotalBytesAvail
6=LPDWORD lpBytesLeftThisMessage
ParamCount=6
@=PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);
[TransactNamedPipe]
1=HANDLE hNamedPipe
2=LPVOID lpInBuffer
3=DWORD nInBufferSize
4=LPVOID lpOutBuffer
5=DWORD nOutBufferSize
6=LPDWORD lpBytesRead
7=LPOVERLAPPED lpOverlapped
ParamCount=7
@=TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped);
[CreateMailslotA]
1=LPCSTR lpName
2=DWORD nMaxMessageSize
3=DWORD lReadTimeout
4=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=4
@=CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[CreateMailslotW]
1=LPCWSTR lpName
2=DWORD nMaxMessageSize
3=DWORD lReadTimeout
4=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=4
@=CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[GetMailslotInfo]
1=HANDLE hMailslot
2=LPDWORD lpMaxMessageSize
3=LPDWORD lpNextSize
4=LPDWORD lpMessageCount
5=LPDWORD lpReadTimeout
ParamCount=5
@=GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout);
[SetMailslotInfo]
1=HANDLE hMailslot
2=DWORD lReadTimeout
ParamCount=2
@=SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout);
[MapViewOfFile]
1=HANDLE hFileMappingObject
2=DWORD dwDesiredAccess
3=DWORD dwFileOffsetHigh
4=DWORD dwFileOffsetLow
5=SIZE_T dwNumberOfBytesToMap
ParamCount=5
@=MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
[FlushViewOfFile]
1=LPCVOID lpBaseAddress
2=SIZE_T dwNumberOfBytesToFlush
ParamCount=2
@=FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush);
[UnmapViewOfFile]
1=LPCVOID lpBaseAddress
ParamCount=1
@=UnmapViewOfFile(LPCVOID lpBaseAddress);
[EncryptFileA]
1=LPCSTR lpFileName
ParamCount=1
@=EncryptFileA(LPCSTR lpFileName);
[EncryptFileW]
1=LPCWSTR lpFileName
ParamCount=1
@=EncryptFileW(LPCWSTR lpFileName);
[DecryptFileA]
1=LPCSTR lpFileName
2=DWORD dwReserved
ParamCount=2
@=DecryptFileA(LPCSTR lpFileName, DWORD dwReserved);
[DecryptFileW]
1=LPCWSTR lpFileName
2=DWORD dwReserved
ParamCount=2
@=DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved);
[FileEncryptionStatusA]
1=LPCSTR lpFileName
2=LPDWORD lpStatus
ParamCount=2
@=FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus);
[FileEncryptionStatusW]
1=LPCWSTR lpFileName
2=LPDWORD lpStatus
ParamCount=2
@=FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus);
[OpenEncryptedFileRawA]
1=LPCSTR lpFileName
2=ULONG ulFlags
3=PVOID *pvContext
ParamCount=3
@=OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext);
[OpenEncryptedFileRawW]
1=LPCWSTR lpFileName
2=ULONG ulFlags
3=PVOID *pvContext
ParamCount=3
@=OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext);
[ReadEncryptedFileRaw]
1=PFE_EXPORT_FUNC pfExportCallback
2=PVOID pvCallbackContext
3=PVOID pvContext
ParamCount=3
@=ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext);
[WriteEncryptedFileRaw]
1=PFE_IMPORT_FUNC pfImportCallback
2=PVOID pvCallbackContext
3=PVOID pvContext
ParamCount=3
@=WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext);
[CloseEncryptedFileRaw]
1=PVOID pvContext
ParamCount=1
@=CloseEncryptedFileRaw(PVOID pvContext);
[lstrcmpA]
1=LPCSTR lpString1
2=LPCSTR lpString2
ParamCount=2
@=lstrcmpA(LPCSTR lpString1, LPCSTR lpString2);
[lstrcmpW]
1=LPCWSTR lpString1
2=LPCWSTR lpString2
ParamCount=2
@=lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
[lstrcmpiA]
1=LPCSTR lpString1
2=LPCSTR lpString2
ParamCount=2
@=lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2);
[lstrcmpiW]
1=LPCWSTR lpString1
2=LPCWSTR lpString2
ParamCount=2
@=lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
[lstrcpynA]
1=LPSTR lpString1
2=LPCSTR lpString2
3=int iMaxLength
ParamCount=3
@=lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
[lstrcpynW]
1=LPWSTR lpString1
2=LPCWSTR lpString2
3=int iMaxLength
ParamCount=3
@=lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
[lstrcpyA]
1=LPSTR lpString1
2=LPCSTR lpString2
ParamCount=2
@=lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
[lstrcpyW]
1=LPWSTR lpString1
2=LPCWSTR lpString2
ParamCount=2
@=lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
[lstrcatA]
1=LPSTR lpString1
2=LPCSTR lpString2
ParamCount=2
@=lstrcatA(LPSTR lpString1, LPCSTR lpString2);
[lstrcatW]
1=LPWSTR lpString1
2=LPCWSTR lpString2
ParamCount=2
@=lstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
[lstrlenA]
1=LPCSTR lpString
ParamCount=1
@=lstrlenA(LPCSTR lpString);
[lstrlenW]
1=LPCWSTR lpString
ParamCount=1
@=lstrlenW(LPCWSTR lpString);
[OpenFile]
1=LPCSTR lpFileName
2=LPOFSTRUCT lpReOpenBuff
3=UINT uStyle
ParamCount=3
@=OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);
[_lopen]
1=LPCSTR lpPathName
2=int iReadWrite
ParamCount=2
@=_lopen(LPCSTR lpPathName, int iReadWrite);
[_lcreat]
1=LPCSTR lpPathName
2=int iAttribute
ParamCount=2
@=_lcreat(LPCSTR lpPathName, int iAttribute);
[_lread]
1=HFILE hFile
2=LPVOID lpBuffer
3=UINT uBytes
ParamCount=3
@=_lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes);
[_lwrite]
1=HFILE hFile
2=LPCCH lpBuffer
3=UINT uBytes
ParamCount=3
@=_lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes);
[_hread]
1=HFILE hFile
2=LPVOID lpBuffer
3=long lBytes
ParamCount=3
@=_hread(HFILE hFile, LPVOID lpBuffer, long lBytes);
[_hwrite]
1=HFILE hFile
2=LPCCH lpBuffer
3=long lBytes
ParamCount=3
@=_hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes);
[_lclose]
1=HFILE hFile
ParamCount=1
@=_lclose(HFILE hFile);
[_llseek]
1=HFILE hFile
2=LONG lOffset
3=int iOrigin
ParamCount=3
@=_llseek(HFILE hFile, LONG lOffset, int iOrigin);
[IsTextUnicode]
1=VOID* lpv
2=int iSize
3=LPINT lpiResult
ParamCount=3
@=IsTextUnicode(VOID* lpv, int iSize, LPINT lpiResult);
[FlsAlloc]
1=PFLS_CALLBACK_FUNCTION lpCallback
ParamCount=1
@=FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback);
[FlsGetValue]
1=DWORD dwFlsIndex
ParamCount=1
@=FlsGetValue(DWORD dwFlsIndex);
[FlsSetValue]
1=DWORD dwFlsIndex
2=PVOID lpFlsData
ParamCount=2
@=FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData);
[FlsFree]
1=DWORD dwFlsIndex
ParamCount=1
@=FlsFree(DWORD dwFlsIndex);
[TlsAlloc]
ParamCount=0
@=TlsAlloc();
[TlsGetValue]
1=DWORD dwTlsIndex
ParamCount=1
@=TlsGetValue(DWORD dwTlsIndex);
[TlsSetValue]
1=DWORD dwTlsIndex
2=LPVOID lpTlsValue
ParamCount=2
@=TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
[TlsFree]
1=DWORD dwTlsIndex
ParamCount=1
@=TlsFree(DWORD dwTlsIndex);
[SleepEx]
1=DWORD dwMilliseconds
2=BOOL bAlertable
ParamCount=2
@=SleepEx(DWORD dwMilliseconds, BOOL bAlertable);
[WaitForSingleObjectEx]
1=HANDLE hHandle
2=DWORD dwMilliseconds
3=BOOL bAlertable
ParamCount=3
@=WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
[WaitForMultipleObjectsEx]
1=DWORD nCount
2=HANDLE *lpHandles
3=BOOL bWaitAll
4=DWORD dwMilliseconds
5=BOOL bAlertable
ParamCount=5
@=WaitForMultipleObjectsEx(DWORD nCount, HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
[SignalObjectAndWait]
1=HANDLE hObjectToSignal
2=HANDLE hObjectToWaitOn
3=DWORD dwMilliseconds
4=BOOL bAlertable
ParamCount=4
@=SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
[ReadFileEx]
1=HANDLE hFile
2=HANDLE LPVOIDlpBuffer
3=DWORD nNumberOfBytesToRead
4=LPOVERLAPPED lpOverlapped
5=LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
ParamCount=5
@=ReadFileEx(HANDLE hFile, HANDLE LPVOIDlpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
[WriteFileEx]
1=HANDLE hFile
2=LPCVOID lpBuffer
3=DWORD nNumberOfBytesToWrite
4=LPOVERLAPPED lpOverlapped
5=LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
ParamCount=5
@=WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
[BackupRead]
1=HANDLE hFile
2=LPBYTE lpBuffer
3=DWORD nNumberOfBytesToRead
4=LPDWORD lpNumberOfBytesRead
5=BOOL bAbort
6=BOOL bProcessSecurity
7=LPVOID *lpContext
ParamCount=7
@=BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext);
[BackupSeek]
1=HANDLE hFile
2=DWORD dwLowBytesToSeek
3=DWORD dwHighBytesToSeek
4=LPDWORD lpdwLowByteSeeked
5=LPDWORD lpdwHighByteSeeked
6=LPVOID *lpContext
ParamCount=6
@=BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext);
[BackupWrite]
1=HANDLE hFile
2=LPBYTE lpBuffer
3=DWORD nNumberOfBytesToWrite
4=LPDWORD lpNumberOfBytesWritten
5=BOOL bAbort
6=BOOL bProcessSecurity
7=LPVOID *lpContext
ParamCount=7
@=BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext);
[ReadFileScatter]
1=HANDLE hFile
2=FILE_SEGMENT_ELEMENT aSegmentArray[]
3=DWORD nNumberOfBytesToRead
4=LPDWORD lpReserved
5=LPOVERLAPPED lpOverlapped
ParamCount=5
@=ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
[WriteFileGather]
1=HANDLE hFile
2=FILE_SEGMENT_ELEMENT aSegmentArray[]
3=DWORD nNumberOfBytesToWrite
4=LPDWORD lpReserved
5=LPOVERLAPPED lpOverlapped
ParamCount=5
@=WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
[CreateMutexA]
1=LPSECURITY_ATTRIBUTES lpMutexAttributes
2=BOOL bInitialOwner
3=LPCSTR lpName
ParamCount=3
@=CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
[CreateMutexW]
1=LPSECURITY_ATTRIBUTES lpMutexAttributes
2=BOOL bInitialOwner
3=LPCWSTR lpName
ParamCount=3
@=CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
[OpenMutexA]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCSTR lpName
ParamCount=3
@=OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
[OpenMutexW]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCWSTR lpName
ParamCount=3
@=OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
[CreateEventA]
1=LPSECURITY_ATTRIBUTES lpEventAttributes
2=BOOL bManualReset
3=BOOL bInitialState
4=LPCSTR lpName
ParamCount=4
@=CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
[CreateEventW]
1=LPSECURITY_ATTRIBUTES lpEventAttributes
2=BOOL bManualReset
3=BOOL bInitialState
4=LPCWSTR lpName
ParamCount=4
@=CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
[OpenEventA]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCSTR lpName
ParamCount=3
@=OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
[OpenEventW]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCWSTR lpName
ParamCount=3
@=OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
[CreateSemaphoreA]
1=LPSECURITY_ATTRIBUTES lpSemaphoreAttributes
2=LONG lInitialCount
3=LONG lMaximumCount
4=LPCSTR lpName
ParamCount=4
@=CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
[CreateSemaphoreW]
1=LPSECURITY_ATTRIBUTES lpSemaphoreAttributes
2=LONG lInitialCount
3=LONG lMaximumCount
4=LPCWSTR lpName
ParamCount=4
@=CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
[OpenSemaphoreA]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCSTR lpName
ParamCount=3
@=OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
[OpenSemaphoreW]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCWSTR lpName
ParamCount=3
@=OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
[*PTIMERAPCROUTINE)]
1=LPVOID lpArgToCompletionRoutine
2=DWORD dwTimerLowValue
3=DWORD dwTimerHighValue
ParamCount=3
@=*PTIMERAPCROUTINE)(LPVOID lpArgToCompletionRoutine, DWORD dwTimerLowValue, DWORD dwTimerHighValue);
[CreateWaitableTimerA]
1=LPSECURITY_ATTRIBUTES lpTimerAttributes
2=BOOL bManualReset
3=LPCSTR lpTimerName
ParamCount=3
@=CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName);
[CreateWaitableTimerW]
1=LPSECURITY_ATTRIBUTES lpTimerAttributes
2=BOOL bManualReset
3=LPCWSTR lpTimerName
ParamCount=3
@=CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName);
[OpenWaitableTimerA]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCSTR lpTimerName
ParamCount=3
@=OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName);
[OpenWaitableTimerW]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCWSTR lpTimerName
ParamCount=3
@=OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName);
[SetWaitableTimerEx]
1=HANDLE hTimer
2=LARGE_INTEGER *lpDueTime
3=LONG lPeriod
4=PTIMERAPCROUTINE pfnCompletionRoutine
5=LPVOID lpArgToCompletionRoutine
6=PREASON_CONTEXT WakeContext
7=ULONG TolerableDelay
ParamCount=7
@=SetWaitableTimerEx(HANDLE hTimer, LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay);
[SetWaitableTimer]
1=HANDLE hTimer
2=LARGE_INTEGER *lpDueTime
3=LONG lPeriod
4=PTIMERAPCROUTINE pfnCompletionRoutine
5=LPVOID lpArgToCompletionRoutine
6=BOOL fResume
ParamCount=6
@=SetWaitableTimer(HANDLE hTimer, LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume);
[CancelWaitableTimer]
1=HANDLE hTimer
ParamCount=1
@=CancelWaitableTimer(HANDLE hTimer);
[CreateMutexExA]
1=LPSECURITY_ATTRIBUTES lpMutexAttributes
2=LPCSTR lpName
3=DWORD dwFlags
4=DWORD dwDesiredAccess
ParamCount=4
@=CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
[CreateMutexExW]
1=LPSECURITY_ATTRIBUTES lpMutexAttributes
2=LPCWSTR lpName
3=DWORD dwFlags
4=DWORD dwDesiredAccess
ParamCount=4
@=CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
[CreateEventExA]
1=LPSECURITY_ATTRIBUTES lpEventAttributes
2=LPCSTR lpName
3=DWORD dwFlags
4=DWORD dwDesiredAccess
ParamCount=4
@=CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
[CreateEventExW]
1=LPSECURITY_ATTRIBUTES lpEventAttributes
2=LPCWSTR lpName
3=DWORD dwFlags
4=DWORD dwDesiredAccess
ParamCount=4
@=CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
[CreateSemaphoreExA]
1=LPSECURITY_ATTRIBUTES lpSemaphoreAttributes
2=LONG lInitialCount
3=LONG lMaximumCount
4=LPCSTR lpName
5=DWORD dwFlags
6=DWORD dwDesiredAccess
ParamCount=6
@=CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
[CreateSemaphoreExW]
1=LPSECURITY_ATTRIBUTES lpSemaphoreAttributes
2=LONG lInitialCount
3=LONG lMaximumCount
4=LPCWSTR lpName
5=DWORD dwFlags
6=DWORD dwDesiredAccess
ParamCount=6
@=CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
[CreateWaitableTimerExA]
1=LPSECURITY_ATTRIBUTES lpTimerAttributes
2=LPCSTR lpTimerName
3=DWORD dwFlags
4=DWORD dwDesiredAccess
ParamCount=4
@=CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);
[CreateWaitableTimerExW]
1=LPSECURITY_ATTRIBUTES lpTimerAttributes
2=LPCWSTR lpTimerName
3=DWORD dwFlags
4=DWORD dwDesiredAccess
ParamCount=4
@=CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);
[CreateFileMappingA]
1=HANDLE hFile
2=LPSECURITY_ATTRIBUTES lpFileMappingAttributes
3=DWORD flProtect
4=DWORD dwMaximumSizeHigh
5=DWORD dwMaximumSizeLow
6=LPCSTR lpName
ParamCount=6
@=CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
[CreateFileMappingW]
1=HANDLE hFile
2=LPSECURITY_ATTRIBUTES lpFileMappingAttributes
3=DWORD flProtect
4=DWORD dwMaximumSizeHigh
5=DWORD dwMaximumSizeLow
6=LPCWSTR lpName
ParamCount=6
@=CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
[CreateFileMappingNumaA]
1=HANDLE hFile
2=LPSECURITY_ATTRIBUTES lpFileMappingAttributes
3=DWORD flProtect
4=DWORD dwMaximumSizeHigh
5=DWORD dwMaximumSizeLow
6=LPCSTR lpName
7=DWORD nndPreferred
ParamCount=7
@=CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred);
[CreateFileMappingNumaW]
1=HANDLE hFile
2=LPSECURITY_ATTRIBUTES lpFileMappingAttributes
3=DWORD flProtect
4=DWORD dwMaximumSizeHigh
5=DWORD dwMaximumSizeLow
6=LPCWSTR lpName
7=DWORD nndPreferred
ParamCount=7
@=CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred);
[OpenFileMappingA]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCSTR lpName
ParamCount=3
@=OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
[OpenFileMappingW]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCWSTR lpName
ParamCount=3
@=OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
[GetLogicalDriveStringsA]
1=DWORD nBufferLength
2=LPSTR lpBuffer
ParamCount=2
@=GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer);
[GetLogicalDriveStringsW]
1=DWORD nBufferLength
2=LPWSTR lpBuffer
ParamCount=2
@=GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer);
[CreateMemoryResourceNotification]
1=MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
ParamCount=1
@=CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);
[QueryMemoryResourceNotification]
1=HANDLE ResourceNotificationHandle
2=PBOOL ResourceState
ParamCount=2
@=QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState);
[LoadLibraryA]
1=LPCSTR lpLibFileName
ParamCount=1
@=LoadLibraryA(LPCSTR lpLibFileName);
[LoadLibraryW]
1=LPCWSTR lpLibFileName
ParamCount=1
@=LoadLibraryW(LPCWSTR lpLibFileName);
[LoadLibraryExA]
1=LPCSTR lpLibFileName
2=HANDLE hFile
3=DWORD dwFlags
ParamCount=3
@=LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
[LoadLibraryExW]
1=LPCWSTR lpLibFileName
2=HANDLE hFile
3=DWORD dwFlags
ParamCount=3
@=LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
[GetModuleFileNameA]
1=HMODULE hModule
2=LPSTR lpFilename
3=DWORD nSize
ParamCount=3
@=GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
[GetModuleFileNameW]
1=HMODULE hModule
2=LPWSTR lpFilename
3=DWORD nSize
ParamCount=3
@=GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
[GetModuleHandleA]
1=LPCSTR lpModuleName
ParamCount=1
@=GetModuleHandleA(LPCSTR lpModuleName);
[GetModuleHandleW]
1=LPCWSTR lpModuleName
ParamCount=1
@=GetModuleHandleW(LPCWSTR lpModuleName);
[GetModuleHandleExA]
1=DWORD dwFlags
2=LPCSTR lpModuleName
3=HMODULE* phModule
ParamCount=3
@=GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE* phModule);
[GetModuleHandleExW]
1=DWORD dwFlags
2=LPCWSTR lpModuleName
3=HMODULE* phModule
ParamCount=3
@=GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE* phModule);
[NeedCurrentDirectoryForExePathA]
1=LPCSTR ExeName
ParamCount=1
@=NeedCurrentDirectoryForExePathA(LPCSTR ExeName);
[NeedCurrentDirectoryForExePathW]
1=LPCWSTR ExeName
ParamCount=1
@=NeedCurrentDirectoryForExePathW(LPCWSTR ExeName);
[QueryFullProcessImageNameA]
1=HANDLE hProcess
2=DWORD dwFlags
3=LPSTR lpExeName
4=PDWORD lpdwSize
ParamCount=4
@=QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize);
[QueryFullProcessImageNameW]
1=HANDLE hProcess
2=DWORD dwFlags
3=LPWSTR lpExeName
4=PDWORD lpdwSize
ParamCount=4
@=QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize);
[InitializeProcThreadAttributeList]
1=LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
2=DWORD dwAttributeCount
3=DWORD dwFlags
4=PSIZE_T lpSize
ParamCount=4
@=InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize);
[DeleteProcThreadAttributeList]
1=LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
ParamCount=1
@=DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList);
[UpdateProcThreadAttribute]
1=LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
2=DWORD dwFlags
3=DWORD_PTR Attribute
4=PVOID lpValue
5=SIZE_T cbSize
6=PVOID lpPreviousValue
7=PSIZE_T lpReturnSize
ParamCount=7
@=UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize);
[CreateProcessA]
1=LPCSTR lpApplicationName
2=LPSTR lpCommandLine
3=LPSECURITY_ATTRIBUTES lpProcessAttributes
4=LPSECURITY_ATTRIBUTES lpThreadAttributes
5=BOOL bInheritHandles
6=DWORD dwCreationFlags
7=LPVOID lpEnvironment
8=LPCSTR lpCurrentDirectory
9=LPSTARTUPINFOA lpStartupInfo
10=LPPROCESS_INFORMATION lpProcessInformation
ParamCount=10
@=CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
[CreateProcessW]
1=LPCWSTR lpApplicationName
2=LPWSTR lpCommandLine
3=LPSECURITY_ATTRIBUTES lpProcessAttributes
4=LPSECURITY_ATTRIBUTES lpThreadAttributes
5=BOOL bInheritHandles
6=DWORD dwCreationFlags
7=LPVOID lpEnvironment
8=LPCWSTR lpCurrentDirectory
9=LPSTARTUPINFOW lpStartupInfo
10=LPPROCESS_INFORMATION lpProcessInformation
ParamCount=10
@=CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
[SetProcessShutdownParameters]
1=DWORD dwLevel
2=DWORD dwFlags
ParamCount=2
@=SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags);
[GetProcessShutdownParameters]
1=LPDWORD lpdwLevel
2=LPDWORD lpdwFlags
ParamCount=2
@=GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags);
[GetProcessVersion]
1=DWORD ProcessId
ParamCount=1
@=GetProcessVersion(DWORD ProcessId);
[FatalAppExitA]
1=UINT uAction
2=LPCSTR lpMessageText
ParamCount=2
@=FatalAppExitA(UINT uAction, LPCSTR lpMessageText);
[FatalAppExitW]
1=UINT uAction
2=LPCWSTR lpMessageText
ParamCount=2
@=FatalAppExitW(UINT uAction, LPCWSTR lpMessageText);
[GetStartupInfoA]
1=LPSTARTUPINFOA lpStartupInfo
ParamCount=1
@=GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
[GetStartupInfoW]
1=LPSTARTUPINFOW lpStartupInfo
ParamCount=1
@=GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
[GetCommandLineA]
ParamCount=0
@=GetCommandLineA();
[GetCommandLineW]
ParamCount=0
@=GetCommandLineW();
[GetEnvironmentVariableA]
1=LPCSTR lpName
2=LPSTR lpBuffer
3=DWORD nSize
ParamCount=3
@=GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
[GetEnvironmentVariableW]
1=LPCWSTR lpName
2=LPWSTR lpBuffer
3=DWORD nSize
ParamCount=3
@=GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
[SetEnvironmentVariableA]
1=LPCSTR lpName
2=LPCSTR lpValue
ParamCount=2
@=SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue);
[SetEnvironmentVariableW]
1=LPCWSTR lpName
2=LPCWSTR lpValue
ParamCount=2
@=SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue);
[ExpandEnvironmentStringsA]
1=LPCSTR lpSrc
2=LPSTR lpDst
3=DWORD nSize
ParamCount=3
@=ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
[ExpandEnvironmentStringsW]
1=LPCWSTR lpSrc
2=LPWSTR lpDst
3=DWORD nSize
ParamCount=3
@=ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
[GetFirmwareEnvironmentVariableA]
1=LPCSTR lpName
2=LPCSTR lpGuid
3=PVOID pBuffer
4=DWORD nSize
ParamCount=4
@=GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize);
[GetFirmwareEnvironmentVariableW]
1=LPCWSTR lpName
2=LPCWSTR lpGuid
3=PVOID pBuffer
4=DWORD nSize
ParamCount=4
@=GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize);
[SetFirmwareEnvironmentVariableA]
1=LPCSTR lpName
2=LPCSTR lpGuid
3=PVOID pValue
4=DWORD nSize
ParamCount=4
@=SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize);
[SetFirmwareEnvironmentVariableW]
1=LPCWSTR lpName
2=LPCWSTR lpGuid
3=PVOID pValue
4=DWORD nSize
ParamCount=4
@=SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize);
[OutputDebugStringA]
1=LPCSTR lpOutputString
ParamCount=1
@=OutputDebugStringA(LPCSTR lpOutputString);
[OutputDebugStringW]
1=LPCWSTR lpOutputString
ParamCount=1
@=OutputDebugStringW(LPCWSTR lpOutputString);
[FindResourceA]
1=HMODULE hModule
2=LPCSTR lpName
3=LPCSTR lpType
ParamCount=3
@=FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
[FindResourceW]
1=HMODULE hModule
2=LPCWSTR lpName
3=LPCWSTR lpType
ParamCount=3
@=FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
[FindResourceExA]
1=HMODULE hModule
2=LPCSTR lpType
3=LPCSTR lpName
4=WORD wLanguage
ParamCount=4
@=FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage);
[FindResourceExW]
1=HMODULE hModule
2=LPCWSTR lpType
3=LPCWSTR lpName
4=WORD wLanguage
ParamCount=4
@=FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
[EnumResourceTypesA]
1=HMODULE hModule
2=ENUMRESTYPEPROCA lpEnumFunc
3=LONG_PTR lParam
ParamCount=3
@=EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam);
[EnumResourceTypesW]
1=HMODULE hModule
2=ENUMRESTYPEPROCW lpEnumFunc
3=LONG_PTR lParam
ParamCount=3
@=EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam);
[EnumResourceNamesA]
1=HMODULE hModule
2=LPCSTR lpType
3=ENUMRESNAMEPROCA lpEnumFunc
4=LONG_PTR lParam
ParamCount=4
@=EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam);
[EnumResourceNamesW]
1=HMODULE hModule
2=LPCWSTR lpType
3=ENUMRESNAMEPROCW lpEnumFunc
4=LONG_PTR lParam
ParamCount=4
@=EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam);
[EnumResourceLanguagesA]
1=HMODULE hModule
2=LPCSTR lpType
3=LPCSTR lpName
4=ENUMRESLANGPROCA lpEnumFunc
5=LONG_PTR lParam
ParamCount=5
@=EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam);
[EnumResourceLanguagesW]
1=HMODULE hModule
2=LPCWSTR lpType
3=LPCWSTR lpName
4=ENUMRESLANGPROCW lpEnumFunc
5=LONG_PTR lParam
ParamCount=5
@=EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam);
[EnumResourceTypesExA]
1=HMODULE hModule
2=ENUMRESTYPEPROCA lpEnumFunc
3=LONG_PTR lParam
4=DWORD dwFlags
5=LANGID LangId
ParamCount=5
@=EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
[EnumResourceTypesExW]
1=HMODULE hModule
2=ENUMRESTYPEPROCW lpEnumFunc
3=LONG_PTR lParam
4=DWORD dwFlags
5=LANGID LangId
ParamCount=5
@=EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
[EnumResourceNamesExA]
1=HMODULE hModule
2=LPCSTR lpType
3=ENUMRESNAMEPROCA lpEnumFunc
4=LONG_PTR lParam
5=DWORD dwFlags
6=LANGID LangId
ParamCount=6
@=EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
[EnumResourceNamesExW]
1=HMODULE hModule
2=LPCWSTR lpType
3=ENUMRESNAMEPROCW lpEnumFunc
4=LONG_PTR lParam
5=DWORD dwFlags
6=LANGID LangId
ParamCount=6
@=EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
[EnumResourceLanguagesExA]
1=HMODULE hModule
2=LPCSTR lpType
3=LPCSTR lpName
4=ENUMRESLANGPROCA lpEnumFunc
5=LONG_PTR lParam
6=DWORD dwFlags
7=LANGID LangId
ParamCount=7
@=EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
[EnumResourceLanguagesExW]
1=HMODULE hModule
2=LPCWSTR lpType
3=LPCWSTR lpName
4=ENUMRESLANGPROCW lpEnumFunc
5=LONG_PTR lParam
6=DWORD dwFlags
7=LANGID LangId
ParamCount=7
@=EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
[BeginUpdateResourceA]
1=LPCSTR pFileName
2=BOOL bDeleteExistingResources
ParamCount=2
@=BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources);
[BeginUpdateResourceW]
1=LPCWSTR pFileName
2=BOOL bDeleteExistingResources
ParamCount=2
@=BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources);
[UpdateResourceA]
1=HANDLE hUpdate
2=LPCSTR lpType
3=LPCSTR lpName
4=WORD wLanguage
5=LPVOID lpData
6=DWORD cb
ParamCount=6
@=UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb);
[UpdateResourceW]
1=HANDLE hUpdate
2=LPCWSTR lpType
3=LPCWSTR lpName
4=WORD wLanguage
5=LPVOID lpData
6=DWORD cb
ParamCount=6
@=UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb);
[EndUpdateResourceA]
1=HANDLE hUpdate
2=BOOL fDiscard
ParamCount=2
@=EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard);
[EndUpdateResourceW]
1=HANDLE hUpdate
2=BOOL fDiscard
ParamCount=2
@=EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard);
[GlobalAddAtomA]
1=LPCSTR lpString
ParamCount=1
@=GlobalAddAtomA(LPCSTR lpString);
[GlobalAddAtomW]
1=LPCWSTR lpString
ParamCount=1
@=GlobalAddAtomW(LPCWSTR lpString);
[GlobalFindAtomA]
1=LPCSTR lpString
ParamCount=1
@=GlobalFindAtomA(LPCSTR lpString);
[GlobalFindAtomW]
1=LPCWSTR lpString
ParamCount=1
@=GlobalFindAtomW(LPCWSTR lpString);
[GlobalGetAtomNameA]
1=ATOM nAtom
2=LPSTR lpBuffer
3=int nSize
ParamCount=3
@=GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize);
[GlobalGetAtomNameW]
1=ATOM nAtom
2=LPWSTR lpBuffer
3=int nSize
ParamCount=3
@=GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
[AddAtomA]
1=LPCSTR lpString
ParamCount=1
@=AddAtomA(LPCSTR lpString);
[AddAtomW]
1=LPCWSTR lpString
ParamCount=1
@=AddAtomW(LPCWSTR lpString);
[FindAtomA]
1=LPCSTR lpString
ParamCount=1
@=FindAtomA(LPCSTR lpString);
[FindAtomW]
1=LPCWSTR lpString
ParamCount=1
@=FindAtomW(LPCWSTR lpString);
[GetAtomNameA]
1=ATOM nAtom
2=LPSTR lpBuffer
3=int nSize
ParamCount=3
@=GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize);
[GetAtomNameW]
1=ATOM nAtom
2=LPWSTR lpBuffer
3=int nSize
ParamCount=3
@=GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
[GetProfileIntA]
1=LPCSTR lpAppName
2=LPCSTR lpKeyName
3=INT nDefault
ParamCount=3
@=GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault);
[GetProfileIntW]
1=LPCWSTR lpAppName
2=LPCWSTR lpKeyName
3=INT nDefault
ParamCount=3
@=GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);
[GetProfileStringA]
1=LPCSTR lpAppName
2=LPCSTR lpKeyName
3=LPCSTR lpDefault
4=LPSTR lpReturnedString
5=DWORD nSize
ParamCount=5
@=GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize);
[GetProfileStringW]
1=LPCWSTR lpAppName
2=LPCWSTR lpKeyName
3=LPCWSTR lpDefault
4=LPWSTR lpReturnedString
5=DWORD nSize
ParamCount=5
@=GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize);
[WriteProfileStringA]
1=LPCSTR lpAppName
2=LPCSTR lpKeyName
3=LPCSTR lpString
ParamCount=3
@=WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString);
[WriteProfileStringW]
1=LPCWSTR lpAppName
2=LPCWSTR lpKeyName
3=LPCWSTR lpString
ParamCount=3
@=WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString);
[GetProfileSectionA]
1=LPCSTR lpAppName
2=LPSTR lpReturnedString
3=DWORD nSize
ParamCount=3
@=GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize);
[GetProfileSectionW]
1=LPCWSTR lpAppName
2=LPWSTR lpReturnedString
3=DWORD nSize
ParamCount=3
@=GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize);
[WriteProfileSectionA]
1=LPCSTR lpAppName
2=LPCSTR lpString
ParamCount=2
@=WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString);
[WriteProfileSectionW]
1=LPCWSTR lpAppName
2=LPCWSTR lpString
ParamCount=2
@=WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString);
[GetPrivateProfileIntA]
1=LPCSTR lpAppName
2=LPCSTR lpKeyName
3=INT nDefault
4=LPCSTR lpFileName
ParamCount=4
@=GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
[GetPrivateProfileIntW]
1=LPCWSTR lpAppName
2=LPCWSTR lpKeyName
3=INT nDefault
4=LPCWSTR lpFileName
ParamCount=4
@=GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
[GetPrivateProfileStringA]
1=LPCSTR lpAppName
2=LPCSTR lpKeyName
3=LPCSTR lpDefault
4=LPSTR lpReturnedString
5=DWORD nSize
6=LPCSTR lpFileName
ParamCount=6
@=GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
[GetPrivateProfileStringW]
1=LPCWSTR lpAppName
2=LPCWSTR lpKeyName
3=LPCWSTR lpDefault
4=LPWSTR lpReturnedString
5=DWORD nSize
6=LPCWSTR lpFileName
ParamCount=6
@=GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
[WritePrivateProfileStringA]
1=LPCSTR lpAppName
2=LPCSTR lpKeyName
3=LPCSTR lpString
4=LPCSTR lpFileName
ParamCount=4
@=WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
[WritePrivateProfileStringW]
1=LPCWSTR lpAppName
2=LPCWSTR lpKeyName
3=LPCWSTR lpString
4=LPCWSTR lpFileName
ParamCount=4
@=WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
[GetPrivateProfileSectionA]
1=LPCSTR lpAppName
2=LPSTR lpReturnedString
3=DWORD nSize
4=LPCSTR lpFileName
ParamCount=4
@=GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
[GetPrivateProfileSectionW]
1=LPCWSTR lpAppName
2=LPWSTR lpReturnedString
3=DWORD nSize
4=LPCWSTR lpFileName
ParamCount=4
@=GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
[WritePrivateProfileSectionA]
1=LPCSTR lpAppName
2=LPCSTR lpString
3=LPCSTR lpFileName
ParamCount=3
@=WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);
[WritePrivateProfileSectionW]
1=LPCWSTR lpAppName
2=LPCWSTR lpString
3=LPCWSTR lpFileName
ParamCount=3
@=WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
[GetPrivateProfileSectionNamesA]
1=LPSTR lpszReturnBuffer
2=DWORD nSize
3=LPCSTR lpFileName
ParamCount=3
@=GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName);
[GetPrivateProfileSectionNamesW]
1=LPWSTR lpszReturnBuffer
2=DWORD nSize
3=LPCWSTR lpFileName
ParamCount=3
@=GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);
[GetPrivateProfileStructA]
1=LPCSTR lpszSection
2=LPCSTR lpszKey
3=LPVOID lpStruct
4=UINT uSizeStruct
5=LPCSTR szFile
ParamCount=5
@=GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile);
[GetPrivateProfileStructW]
1=LPCWSTR lpszSection
2=LPCWSTR lpszKey
3=LPVOID lpStruct
4=UINT uSizeStruct
5=LPCWSTR szFile
ParamCount=5
@=GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);
[WritePrivateProfileStructA]
1=LPCSTR lpszSection
2=LPCSTR lpszKey
3=LPVOID lpStruct
4=UINT uSizeStruct
5=LPCSTR szFile
ParamCount=5
@=WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile);
[WritePrivateProfileStructW]
1=LPCWSTR lpszSection
2=LPCWSTR lpszKey
3=LPVOID lpStruct
4=UINT uSizeStruct
5=LPCWSTR szFile
ParamCount=5
@=WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);
[GetDriveTypeA]
1=LPCSTR lpRootPathName
ParamCount=1
@=GetDriveTypeA(LPCSTR lpRootPathName);
[GetDriveTypeW]
1=LPCWSTR lpRootPathName
ParamCount=1
@=GetDriveTypeW(LPCWSTR lpRootPathName);
[GetSystemDirectoryA]
1=LPSTR lpBuffer
2=UINT uSize
ParamCount=2
@=GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
[GetSystemDirectoryW]
1=LPWSTR lpBuffer
2=UINT uSize
ParamCount=2
@=GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize);
[GetTempPathA]
1=DWORD nBufferLength
2=LPSTR lpBuffer
ParamCount=2
@=GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer);
[GetTempPathW]
1=DWORD nBufferLength
2=LPWSTR lpBuffer
ParamCount=2
@=GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
[GetTempFileNameA]
1=LPCSTR lpPathName
2=LPCSTR lpPrefixString
3=UINT uUnique
4=LPSTR lpTempFileName
ParamCount=4
@=GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
[GetTempFileNameW]
1=LPCWSTR lpPathName
2=LPCWSTR lpPrefixString
3=UINT uUnique
4=LPWSTR lpTempFileName
ParamCount=4
@=GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
[GetWindowsDirectoryA]
1=LPSTR lpBuffer
2=UINT uSize
ParamCount=2
@=GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
[GetWindowsDirectoryW]
1=LPWSTR lpBuffer
2=UINT uSize
ParamCount=2
@=GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
[GetSystemWindowsDirectoryA]
1=LPSTR lpBuffer
2=UINT uSize
ParamCount=2
@=GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
[GetSystemWindowsDirectoryW]
1=LPWSTR lpBuffer
2=UINT uSize
ParamCount=2
@=GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
[GetSystemWow64DirectoryA]
1=LPSTR lpBuffer
2=UINT uSize
ParamCount=2
@=GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize);
[GetSystemWow64DirectoryW]
1=LPWSTR lpBuffer
2=UINT uSize
ParamCount=2
@=GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize);
[Wow64EnableWow64FsRedirection]
1=BOOLEAN Wow64FsEnableRedirection
ParamCount=1
@=Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection);
[Wow64DisableWow64FsRedirection]
1=PVOID *OldValue
ParamCount=1
@=Wow64DisableWow64FsRedirection(PVOID *OldValue);
[Wow64RevertWow64FsRedirection]
1=PVOID OlValue
ParamCount=1
@=Wow64RevertWow64FsRedirection(PVOID OlValue);
[SetCurrentDirectoryA]
1=LPCSTR lpPathName
ParamCount=1
@=SetCurrentDirectoryA(LPCSTR lpPathName);
[SetCurrentDirectoryW]
1=LPCWSTR lpPathName
ParamCount=1
@=SetCurrentDirectoryW(LPCWSTR lpPathName);
[GetCurrentDirectoryA]
1=DWORD nBufferLength
2=LPSTR lpBuffer
ParamCount=2
@=GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
[GetCurrentDirectoryW]
1=DWORD nBufferLength
2=LPWSTR lpBuffer
ParamCount=2
@=GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
[SetDllDirectoryA]
1=LPCSTR lpPathName
ParamCount=1
@=SetDllDirectoryA(LPCSTR lpPathName);
[SetDllDirectoryW]
1=LPCWSTR lpPathName
ParamCount=1
@=SetDllDirectoryW(LPCWSTR lpPathName);
[GetDllDirectoryA]
1=DWORD nBufferLength
2=LPSTR lpBuffer
ParamCount=2
@=GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
[GetDllDirectoryW]
1=DWORD nBufferLength
2=LPWSTR lpBuffer
ParamCount=2
@=GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
[SetSearchPathMode]
1=DWORD Flags
ParamCount=1
@=SetSearchPathMode(DWORD Flags);
[GetDiskFreeSpaceA]
1=LPCSTR lpRootPathName
2=LPDWORD lpSectorsPerCluster
3=LPDWORD lpBytesPerSector
4=LPDWORD lpNumberOfFreeClusters
5=LPDWORD lpTotalNumberOfClusters
ParamCount=5
@=GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
[GetDiskFreeSpaceW]
1=LPCWSTR lpRootPathName
2=LPDWORD lpSectorsPerCluster
3=LPDWORD lpBytesPerSector
4=LPDWORD lpNumberOfFreeClusters
5=LPDWORD lpTotalNumberOfClusters
ParamCount=5
@=GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
[GetDiskFreeSpaceExA]
1=LPCSTR lpDirectoryName
2=PULARGE_INTEGER lpFreeBytesAvailableToCaller
3=PULARGE_INTEGER lpTotalNumberOfBytes
4=PULARGE_INTEGER lpTotalNumberOfFreeBytes
ParamCount=4
@=GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
[GetDiskFreeSpaceExW]
1=LPCWSTR lpDirectoryName
2=PULARGE_INTEGER lpFreeBytesAvailableToCaller
3=PULARGE_INTEGER lpTotalNumberOfBytes
4=PULARGE_INTEGER lpTotalNumberOfFreeBytes
ParamCount=4
@=GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
[CreateDirectoryA]
1=LPCSTR lpPathName
2=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=2
@=CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[CreateDirectoryW]
1=LPCWSTR lpPathName
2=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=2
@=CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[CreateDirectoryExA]
1=LPCSTR lpTemplateDirectory
2=LPCSTR lpNewDirectory
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=3
@=CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[CreateDirectoryExW]
1=LPCWSTR lpTemplateDirectory
2=LPCWSTR lpNewDirectory
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=3
@=CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[CreateDirectoryTransactedA]
1=LPCSTR lpTemplateDirectory
2=LPCSTR lpNewDirectory
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
4=HANDLE hTransaction
ParamCount=4
@=CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction);
[CreateDirectoryTransactedW]
1=LPCWSTR lpTemplateDirectory
2=LPCWSTR lpNewDirectory
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
4=HANDLE hTransaction
ParamCount=4
@=CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction);
[RemoveDirectoryA]
1=LPCSTR lpPathName
ParamCount=1
@=RemoveDirectoryA(LPCSTR lpPathName);
[RemoveDirectoryW]
1=LPCWSTR lpPathName
ParamCount=1
@=RemoveDirectoryW(LPCWSTR lpPathName);
[RemoveDirectoryTransactedA]
1=LPCSTR lpPathName
2=HANDLE hTransaction
ParamCount=2
@=RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction);
[RemoveDirectoryTransactedW]
1=LPCWSTR lpPathName
2=HANDLE hTransaction
ParamCount=2
@=RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction);
[GetFullPathNameA]
1=LPCSTR lpFileName
2=DWORD nBufferLength
3=LPSTR lpBuffer
4=LPSTR *lpFilePart
ParamCount=4
@=GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
[GetFullPathNameW]
1=LPCWSTR lpFileName
2=DWORD nBufferLength
3=LPWSTR lpBuffer
4=LPWSTR *lpFilePart
ParamCount=4
@=GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
[GetFullPathNameTransactedA]
1=LPCSTR lpFileName
2=DWORD nBufferLength
3=LPSTR lpBuffer
4=LPSTR *lpFilePart
5=HANDLE hTransaction
ParamCount=5
@=GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction);
[GetFullPathNameTransactedW]
1=LPCWSTR lpFileName
2=DWORD nBufferLength
3=LPWSTR lpBuffer
4=LPWSTR *lpFilePart
5=HANDLE hTransaction
ParamCount=5
@=GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction);
[DefineDosDeviceA]
1=DWORD dwFlags
2=LPCSTR lpDeviceName
3=LPCSTR lpTargetPath
ParamCount=3
@=DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath);
[DefineDosDeviceW]
1=DWORD dwFlags
2=LPCWSTR lpDeviceName
3=LPCWSTR lpTargetPath
ParamCount=3
@=DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath);
[QueryDosDeviceA]
1=LPCSTR lpDeviceName
2=LPSTR lpTargetPath
3=DWORD ucchMax
ParamCount=3
@=QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax);
[QueryDosDeviceW]
1=LPCWSTR lpDeviceName
2=LPWSTR lpTargetPath
3=DWORD ucchMax
ParamCount=3
@=QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax);
[CreateFileA]
1=LPCSTR lpFileName
2=DWORD dwDesiredAccess
3=DWORD dwShareMode
4=LPSECURITY_ATTRIBUTES lpSecurityAttributes
5=DWORD dwCreationDisposition
6=DWORD dwFlagsAndAttributes
7=HANDLE hTemplateFile
ParamCount=7
@=CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
[CreateFileW]
1=LPCWSTR lpFileName
2=DWORD dwDesiredAccess
3=DWORD dwShareMode
4=LPSECURITY_ATTRIBUTES lpSecurityAttributes
5=DWORD dwCreationDisposition
6=DWORD dwFlagsAndAttributes
7=HANDLE hTemplateFile
ParamCount=7
@=CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
[CreateFileTransactedA]
1=LPCSTR lpFileName
2=DWORD dwDesiredAccess
3=DWORD dwShareMode
4=LPSECURITY_ATTRIBUTES lpSecurityAttributes
5=DWORD dwCreationDisposition
6=DWORD dwFlagsAndAttributes
7=HANDLE hTemplateFile
8=HANDLE hTransaction
9=PUSHORT pusMiniVersion
10=PVOID lpExtendedParameter
ParamCount=10
@=CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter);
[CreateFileTransactedW]
1=LPCWSTR lpFileName
2=DWORD dwDesiredAccess
3=DWORD dwShareMode
4=LPSECURITY_ATTRIBUTES lpSecurityAttributes
5=DWORD dwCreationDisposition
6=DWORD dwFlagsAndAttributes
7=HANDLE hTemplateFile
8=HANDLE hTransaction
9=PUSHORT pusMiniVersion
10=PVOID lpExtendedParameter
ParamCount=10
@=CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter);
[ReOpenFile]
1=HANDLE hOriginalFile
2=DWORD dwDesiredAccess
3=DWORD dwShareMode
4=DWORD dwFlagsAndAttributes
ParamCount=4
@=ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes);
[SetFileAttributesA]
1=LPCSTR lpFileName
2=DWORD dwFileAttributes
ParamCount=2
@=SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes);
[SetFileAttributesW]
1=LPCWSTR lpFileName
2=DWORD dwFileAttributes
ParamCount=2
@=SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
[GetFileAttributesA]
1=LPCSTR lpFileName
ParamCount=1
@=GetFileAttributesA(LPCSTR lpFileName);
[GetFileAttributesW]
1=LPCWSTR lpFileName
ParamCount=1
@=GetFileAttributesW(LPCWSTR lpFileName);
[SetFileAttributesTransactedA]
1=LPCSTR lpFileName
2=DWORD dwFileAttributes
3=HANDLE hTransaction
ParamCount=3
@=SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction);
[SetFileAttributesTransactedW]
1=LPCWSTR lpFileName
2=DWORD dwFileAttributes
3=HANDLE hTransaction
ParamCount=3
@=SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction);
[GetFileAttributesTransactedA]
1=LPCSTR lpFileName
2=GET_FILEEX_INFO_LEVELS fInfoLevelId
3=LPVOID lpFileInformation
4=HANDLE hTransaction
ParamCount=4
@=GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction);
[GetFileAttributesTransactedW]
1=LPCWSTR lpFileName
2=GET_FILEEX_INFO_LEVELS fInfoLevelId
3=LPVOID lpFileInformation
4=HANDLE hTransaction
ParamCount=4
@=GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction);
[GetFileAttributesExA]
1=LPCSTR lpFileName
2=GET_FILEEX_INFO_LEVELS fInfoLevelId
3=LPVOID lpFileInformation
ParamCount=3
@=GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
[GetFileAttributesExW]
1=LPCWSTR lpFileName
2=GET_FILEEX_INFO_LEVELS fInfoLevelId
3=LPVOID lpFileInformation
ParamCount=3
@=GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
[GetCompressedFileSizeA]
1=LPCSTR lpFileName
2=LPDWORD lpFileSizeHigh
ParamCount=2
@=GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh);
[GetCompressedFileSizeW]
1=LPCWSTR lpFileName
2=LPDWORD lpFileSizeHigh
ParamCount=2
@=GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh);
[GetCompressedFileSizeTransactedA]
1=LPCSTR lpFileName
2=LPDWORD lpFileSizeHigh
3=HANDLE hTransaction
ParamCount=3
@=GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction);
[GetCompressedFileSizeTransactedW]
1=LPCWSTR lpFileName
2=LPDWORD lpFileSizeHigh
3=HANDLE hTransaction
ParamCount=3
@=GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction);
[DeleteFileA]
1=LPCSTR lpFileName
ParamCount=1
@=DeleteFileA(LPCSTR lpFileName);
[DeleteFileW]
1=LPCWSTR lpFileName
ParamCount=1
@=DeleteFileW(LPCWSTR lpFileName);
[DeleteFileTransactedA]
1=LPCSTR lpFileName
2=HANDLE hTransaction
ParamCount=2
@=DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction);
[DeleteFileTransactedW]
1=LPCWSTR lpFileName
2=HANDLE hTransaction
ParamCount=2
@=DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction);
[CheckNameLegalDOS8Dot3A]
1=LPCSTR lpName
2=LPSTR lpOemName
3=DWORD OemNameSize
4=PBOOL pbNameContainsSpacesOPTIONAL
5=PBOOL pbNameLegal
ParamCount=5
@=CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpacesOPTIONAL, PBOOL pbNameLegal);
[CheckNameLegalDOS8Dot3W]
1=LPCWSTR lpName
2=LPSTR lpOemName
3=DWORD OemNameSize
4=PBOOL pbNameContainsSpacesOPTIONAL
5=PBOOL pbNameLegal
ParamCount=5
@=CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpacesOPTIONAL, PBOOL pbNameLegal);
[FindFirstFileExA]
1=LPCSTR lpFileName
2=FINDEX_INFO_LEVELS fInfoLevelId
3=LPVOID lpFindFileData
4=FINDEX_SEARCH_OPS fSearchOp
5=LPVOID lpSearchFilter
6=DWORD dwAdditionalFlags
ParamCount=6
@=FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
[FindFirstFileExW]
1=LPCWSTR lpFileName
2=FINDEX_INFO_LEVELS fInfoLevelId
3=LPVOID lpFindFileData
4=FINDEX_SEARCH_OPS fSearchOp
5=LPVOID lpSearchFilter
6=DWORD dwAdditionalFlags
ParamCount=6
@=FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
[FindFirstFileTransactedA]
1=LPCSTR lpFileName
2=FINDEX_INFO_LEVELS fInfoLevelId
3=LPVOID lpFindFileData
4=FINDEX_SEARCH_OPS fSearchOp
5=LPVOID lpSearchFilter
6=DWORD dwAdditionalFlags
7=HANDLE hTransaction
ParamCount=7
@=FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction);
[FindFirstFileTransactedW]
1=LPCWSTR lpFileName
2=FINDEX_INFO_LEVELS fInfoLevelId
3=LPVOID lpFindFileData
4=FINDEX_SEARCH_OPS fSearchOp
5=LPVOID lpSearchFilter
6=DWORD dwAdditionalFlags
7=HANDLE hTransaction
ParamCount=7
@=FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction);
[FindFirstFileA]
1=LPCSTR lpFileName
2=LPWIN32_FIND_DATAA lpFindFileData
ParamCount=2
@=FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
[FindFirstFileW]
1=LPCWSTR lpFileName
2=LPWIN32_FIND_DATAW lpFindFileData
ParamCount=2
@=FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
[FindNextFileA]
1=HANDLE hFindFile
2=LPWIN32_FIND_DATAA lpFindFileData
ParamCount=2
@=FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
[FindNextFileW]
1=HANDLE hFindFile
2=LPWIN32_FIND_DATAW lpFindFileData
ParamCount=2
@=FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
[SearchPathA]
1=LPCSTR lpPath
2=LPCSTR lpFileName
3=LPCSTR lpExtension
4=DWORD nBufferLength
5=LPSTR lpBuffer
6=LPSTR *lpFilePart
ParamCount=6
@=SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
[SearchPathW]
1=LPCWSTR lpPath
2=LPCWSTR lpFileName
3=LPCWSTR lpExtension
4=DWORD nBufferLength
5=LPWSTR lpBuffer
6=LPWSTR *lpFilePart
ParamCount=6
@=SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
[CopyFileA]
1=LPCSTR lpExistingFileName
2=LPCSTR lpNewFileName
3=BOOL bFailIfExists
ParamCount=3
@=CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
[CopyFileW]
1=LPCWSTR lpExistingFileName
2=LPCWSTR lpNewFileName
3=BOOL bFailIfExists
ParamCount=3
@=CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
[CopyFileExA]
1=LPCSTR lpExistingFileName
2=LPCSTR lpNewFileName
3=LPPROGRESS_ROUTINE lpProgressRoutine
4=LPVOID lpData
5=LPBOOL pbCancel
6=DWORD dwCopyFlags
ParamCount=6
@=CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags);
[CopyFileExW]
1=LPCWSTR lpExistingFileName
2=LPCWSTR lpNewFileName
3=LPPROGRESS_ROUTINE lpProgressRoutine
4=LPVOID lpData
5=LPBOOL pbCancel
6=DWORD dwCopyFlags
ParamCount=6
@=CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags);
[CopyFileTransactedA]
1=LPCSTR lpExistingFileName
2=LPCSTR lpNewFileName
3=LPPROGRESS_ROUTINE lpProgressRoutine
4=LPVOID lpData
5=LPBOOL pbCancel
6=DWORD dwCopyFlags
7=HANDLE hTransaction
ParamCount=7
@=CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction);
[CopyFileTransactedW]
1=LPCWSTR lpExistingFileName
2=LPCWSTR lpNewFileName
3=LPPROGRESS_ROUTINE lpProgressRoutine
4=LPVOID lpData
5=LPBOOL pbCancel
6=DWORD dwCopyFlags
7=HANDLE hTransaction
ParamCount=7
@=CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction);
[MoveFileA]
1=LPCSTR lpExistingFileName
2=LPCSTR lpNewFileName
ParamCount=2
@=MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
[MoveFileW]
1=LPCWSTR lpExistingFileName
2=LPCWSTR lpNewFileName
ParamCount=2
@=MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
[MoveFileExA]
1=LPCSTR lpExistingFileName
2=LPCSTR lpNewFileName
3=DWORD dwFlags
ParamCount=3
@=MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags);
[MoveFileExW]
1=LPCWSTR lpExistingFileName
2=LPCWSTR lpNewFileName
3=DWORD dwFlags
ParamCount=3
@=MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
[MoveFileWithProgressA]
1=LPCSTR lpExistingFileName
2=LPCSTR lpNewFileName
3=LPPROGRESS_ROUTINE lpProgressRoutine
4=LPVOID lpData
5=DWORD dwFlags
ParamCount=5
@=MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
[MoveFileWithProgressW]
1=LPCWSTR lpExistingFileName
2=LPCWSTR lpNewFileName
3=LPPROGRESS_ROUTINE lpProgressRoutine
4=LPVOID lpData
5=DWORD dwFlags
ParamCount=5
@=MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
[MoveFileTransactedA]
1=LPCSTR lpExistingFileName
2=LPCSTR lpNewFileName
3=LPPROGRESS_ROUTINE lpProgressRoutine
4=LPVOID lpData
5=DWORD dwFlags
6=HANDLE hTransaction
ParamCount=6
@=MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction);
[MoveFileTransactedW]
1=LPCWSTR lpExistingFileName
2=LPCWSTR lpNewFileName
3=LPPROGRESS_ROUTINE lpProgressRoutine
4=LPVOID lpData
5=DWORD dwFlags
6=HANDLE hTransaction
ParamCount=6
@=MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction);
[ReplaceFileA]
1=LPCSTR lpReplacedFileName
2=LPCSTR lpReplacementFileName
3=LPCSTR lpBackupFileName
4=DWORD dwReplaceFlags
5=LPVOID lpExclude
6=LPVOID lpReserved
ParamCount=6
@=ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
[ReplaceFileW]
1=LPCWSTR lpReplacedFileName
2=LPCWSTR lpReplacementFileName
3=LPCWSTR lpBackupFileName
4=DWORD dwReplaceFlags
5=LPVOID lpExclude
6=LPVOID lpReserved
ParamCount=6
@=ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
[CreateHardLinkA]
1=LPCSTR lpFileName
2=LPCSTR lpExistingFileName
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=3
@=CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[CreateHardLinkW]
1=LPCWSTR lpFileName
2=LPCWSTR lpExistingFileName
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=3
@=CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[CreateHardLinkTransactedA]
1=LPCSTR lpFileName
2=LPCSTR lpExistingFileName
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
4=HANDLE hTransaction
ParamCount=4
@=CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction);
[CreateHardLinkTransactedW]
1=LPCWSTR lpFileName
2=LPCWSTR lpExistingFileName
3=LPSECURITY_ATTRIBUTES lpSecurityAttributes
4=HANDLE hTransaction
ParamCount=4
@=CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction);
[FindFirstStreamW]
1=LPCWSTR lpFileName
2=STREAM_INFO_LEVELS InfoLevel
3=LPVOID lpFindStreamData
4=DWORD dwFlags
ParamCount=4
@=FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags);
[FindFirstStreamTransactedW]
1=LPCWSTR lpFileName
2=STREAM_INFO_LEVELS InfoLevel
3=LPVOID lpFindStreamData
4=DWORD dwFlags
5=HANDLE hTransaction
ParamCount=5
@=FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction);
[FindNextStreamW]
1=HANDLE hFindStream
2=LPVOID lpFindStreamData
ParamCount=2
@=FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData);
[FindFirstFileNameW]
1=LPCWSTR lpFileName
2=DWORD dwFlags
3=LPDWORD StringLength
4=PWCHAR LinkName
ParamCount=4
@=FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName);
[FindNextFileNameW]
1=HANDLE hFindStream
2=LPDWORD StringLength
3=PWCHAR LinkName
ParamCount=3
@=FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWCHAR LinkName);
[FindFirstFileNameTransactedW]
1=LPCWSTR lpFileName
2=DWORD dwFlags
3=LPDWORD StringLength
4=PWCHAR LinkName
5=HANDLE hTransaction
ParamCount=5
@=FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName, HANDLE hTransaction);
[CreateNamedPipeA]
1=LPCSTR lpName
2=DWORD dwOpenMode
3=DWORD dwPipeMode
4=DWORD nMaxInstances
5=DWORD nOutBufferSize
6=DWORD nInBufferSize
7=DWORD nDefaultTimeOut
8=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=8
@=CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[CreateNamedPipeW]
1=LPCWSTR lpName
2=DWORD dwOpenMode
3=DWORD dwPipeMode
4=DWORD nMaxInstances
5=DWORD nOutBufferSize
6=DWORD nInBufferSize
7=DWORD nDefaultTimeOut
8=LPSECURITY_ATTRIBUTES lpSecurityAttributes
ParamCount=8
@=CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
[GetNamedPipeHandleStateA]
1=HANDLE hNamedPipe
2=LPDWORD lpState
3=LPDWORD lpCurInstances
4=LPDWORD lpMaxCollectionCount
5=LPDWORD lpCollectDataTimeout
6=LPSTR lpUserName
7=DWORD nMaxUserNameSize
ParamCount=7
@=GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize);
[GetNamedPipeHandleStateW]
1=HANDLE hNamedPipe
2=LPDWORD lpState
3=LPDWORD lpCurInstances
4=LPDWORD lpMaxCollectionCount
5=LPDWORD lpCollectDataTimeout
6=LPWSTR lpUserName
7=DWORD nMaxUserNameSize
ParamCount=7
@=GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize);
[CallNamedPipeA]
1=LPCSTR lpNamedPipeName
2=LPVOID lpInBuffer
3=DWORD nInBufferSize
4=LPVOID lpOutBuffer
5=DWORD nOutBufferSize
6=LPDWORD lpBytesRead
7=DWORD nTimeOut
ParamCount=7
@=CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut);
[CallNamedPipeW]
1=LPCWSTR lpNamedPipeName
2=LPVOID lpInBuffer
3=DWORD nInBufferSize
4=LPVOID lpOutBuffer
5=DWORD nOutBufferSize
6=LPDWORD lpBytesRead
7=DWORD nTimeOut
ParamCount=7
@=CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut);
[WaitNamedPipeA]
1=LPCSTR lpNamedPipeName
2=DWORD nTimeOut
ParamCount=2
@=WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut);
[WaitNamedPipeW]
1=LPCWSTR lpNamedPipeName
2=DWORD nTimeOut
ParamCount=2
@=WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut);
[GetNamedPipeAttribute]
1=HANDLE Pipe
2=PIPE_ATTRIBUTE_TYPE AttributeType
3=PSTR AttributeName
4=PVOID AttributeValue
5=PSIZE_T AttributeValueLength
ParamCount=5
@=GetNamedPipeAttribute(HANDLE Pipe, PIPE_ATTRIBUTE_TYPE AttributeType, PSTR AttributeName, PVOID AttributeValue, PSIZE_T AttributeValueLength);
[SetNamedPipeAttribute]
1=HANDLE Pipe
2=PIPE_ATTRIBUTE_TYPE AttributeType
3=PSTR AttributeName
4=PVOID AttributeValue
5=SIZE_T AttributeValueLength
ParamCount=5
@=SetNamedPipeAttribute(HANDLE Pipe, PIPE_ATTRIBUTE_TYPE AttributeType, PSTR AttributeName, PVOID AttributeValue, SIZE_T AttributeValueLength);
[GetNamedPipeClientComputerNameA]
1=HANDLE Pipe
2=LPSTR ClientComputerName
3=ULONG ClientComputerNameLength
ParamCount=3
@=GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength);
[GetNamedPipeClientComputerNameW]
1=HANDLE Pipe
2=LPWSTR ClientComputerName
3=ULONG ClientComputerNameLength
ParamCount=3
@=GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength);
[GetNamedPipeClientProcessId]
1=HANDLE Pipe
2=PULONG ClientProcessId
ParamCount=2
@=GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId);
[GetNamedPipeClientSessionId]
1=HANDLE Pipe
2=PULONG ClientSessionId
ParamCount=2
@=GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId);
[GetNamedPipeServerProcessId]
1=HANDLE Pipe
2=PULONG ServerProcessId
ParamCount=2
@=GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId);
[GetNamedPipeServerSessionId]
1=HANDLE Pipe
2=PULONG ServerSessionId
ParamCount=2
@=GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId);
[SetVolumeLabelA]
1=LPCSTR lpRootPathName
2=LPCSTR lpVolumeName
ParamCount=2
@=SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName);
[SetVolumeLabelW]
1=LPCWSTR lpRootPathName
2=LPCWSTR lpVolumeName
ParamCount=2
@=SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName);
[SetFileApisToOEM]
ParamCount=0
@=SetFileApisToOEM();
[SetFileApisToANSI]
ParamCount=0
@=SetFileApisToANSI();
[AreFileApisANSI]
ParamCount=0
@=AreFileApisANSI();
[GetVolumeInformationA]
1=LPCSTR lpRootPathName
2=LPSTR lpVolumeNameBuffer
3=DWORD nVolumeNameSize
4=LPDWORD lpVolumeSerialNumber
5=LPDWORD lpMaximumComponentLength
6=LPDWORD lpFileSystemFlags
7=LPSTR lpFileSystemNameBuffer
8=DWORD nFileSystemNameSize
ParamCount=8
@=GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
[GetVolumeInformationW]
1=LPCWSTR lpRootPathName
2=LPWSTR lpVolumeNameBuffer
3=DWORD nVolumeNameSize
4=LPDWORD lpVolumeSerialNumber
5=LPDWORD lpMaximumComponentLength
6=LPDWORD lpFileSystemFlags
7=LPWSTR lpFileSystemNameBuffer
8=DWORD nFileSystemNameSize
ParamCount=8
@=GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
[GetVolumeInformationByHandleW]
1=HANDLE hFile
2=LPWSTR lpVolumeNameBuffer
3=DWORD nVolumeNameSize
4=LPDWORD lpVolumeSerialNumber
5=LPDWORD lpMaximumComponentLength
6=LPDWORD lpFileSystemFlags
7=LPWSTR lpFileSystemNameBuffer
8=DWORD nFileSystemNameSize
ParamCount=8
@=GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
[CancelSynchronousIo]
1=HANDLE hThread
ParamCount=1
@=CancelSynchronousIo(HANDLE hThread);
[CancelIoEx]
1=HANDLE hFile
2=LPOVERLAPPED lpOverlapped
ParamCount=2
@=CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped);
[CancelIo]
1=HANDLE hFile
ParamCount=1
@=CancelIo(HANDLE hFile);
[SetFileBandwidthReservation]
1=HANDLE hFile
2=DWORD nPeriodMilliseconds
3=DWORD nBytesPerPeriod
4=BOOL bDiscardable
5=LPDWORD lpTransferSize
6=LPDWORD lpNumOutstandingRequests
ParamCount=6
@=SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests);
[GetFileBandwidthReservation]
1=HANDLE hFile
2=LPDWORD lpPeriodMilliseconds
3=LPDWORD lpBytesPerPeriod
4=LPBOOL pDiscardable
5=LPDWORD lpTransferSize
6=LPDWORD lpNumOutstandingRequests
ParamCount=6
@=GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests);
[ClearEventLogA]
1=HANDLE hEventLog
2=LPCSTR lpBackupFileName
ParamCount=2
@=ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName);
[ClearEventLogW]
1=HANDLE hEventLog
2=LPCWSTR lpBackupFileName
ParamCount=2
@=ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName);
[BackupEventLogA]
1=HANDLE hEventLog
2=LPCSTR lpBackupFileName
ParamCount=2
@=BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName);
[BackupEventLogW]
1=HANDLE hEventLog
2=LPCWSTR lpBackupFileName
ParamCount=2
@=BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName);
[CloseEventLog]
1=HANDLE hEventLog
ParamCount=1
@=CloseEventLog(HANDLE hEventLog);
[DeregisterEventSource]
1=HANDLE hEventLog
ParamCount=1
@=DeregisterEventSource(HANDLE hEventLog);
[NotifyChangeEventLog]
1=HANDLE hEventLog
2=HANDLE hEvent
ParamCount=2
@=NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent);
[GetNumberOfEventLogRecords]
1=HANDLE hEventLog
2=PDWORD NumberOfRecords
ParamCount=2
@=GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords);
[GetOldestEventLogRecord]
1=HANDLE hEventLog
2=PDWORD OldestRecord
ParamCount=2
@=GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord);
[OpenEventLogA]
1=LPCSTR lpUNCServerName
2=LPCSTR lpSourceName
ParamCount=2
@=OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName);
[OpenEventLogW]
1=LPCWSTR lpUNCServerName
2=LPCWSTR lpSourceName
ParamCount=2
@=OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName);
[RegisterEventSourceA]
1=LPCSTR lpUNCServerName
2=LPCSTR lpSourceName
ParamCount=2
@=RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName);
[RegisterEventSourceW]
1=LPCWSTR lpUNCServerName
2=LPCWSTR lpSourceName
ParamCount=2
@=RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName);
[OpenBackupEventLogA]
1=LPCSTR lpUNCServerName
2=LPCSTR lpFileName
ParamCount=2
@=OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName);
[OpenBackupEventLogW]
1=LPCWSTR lpUNCServerName
2=LPCWSTR lpFileName
ParamCount=2
@=OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName);
[ReadEventLogA]
1=HANDLE hEventLog
2=DWORD dwReadFlags
3=DWORD dwRecordOffset
4=LPVOID lpBuffer
5=DWORD nNumberOfBytesToRead
6=DWORD *pnBytesRead
7=DWORD *pnMinNumberOfBytesNeeded
ParamCount=7
@=ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded);
[ReadEventLogW]
1=HANDLE hEventLog
2=DWORD dwReadFlags
3=DWORD dwRecordOffset
4=LPVOID lpBuffer
5=DWORD nNumberOfBytesToRead
6=DWORD *pnBytesRead
7=DWORD *pnMinNumberOfBytesNeeded
ParamCount=7
@=ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded);
[ReportEventA]
1=HANDLE hEventLog
2=WORD wType
3=WORD wCategory
4=DWORD dwEventID
5=PSID lpUserSid
6=WORD wNumStrings
7=DWORD dwDataSize
8=LPCSTR *lpStrings
9=LPVOID lpRawData
ParamCount=9
@=ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData);
[ReportEventW]
1=HANDLE hEventLog
2=WORD wType
3=WORD wCategory
4=DWORD dwEventID
5=PSID lpUserSid
6=WORD wNumStrings
7=DWORD dwDataSize
8=LPCWSTR *lpStrings
9=LPVOID lpRawData
ParamCount=9
@=ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData);
[GetEventLogInformation]
1=HANDLE hEventLog
2=DWORD dwInfoLevel
3=LPVOID lpBuffer
4=DWORD cbBufSize
5=LPDWORD pcbBytesNeeded
ParamCount=5
@=GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
[DuplicateToken]
1=HANDLE ExistingTokenHandle
2=SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
3=PHANDLE DuplicateTokenHandle
ParamCount=3
@=DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle);
[GetKernelObjectSecurity]
1=HANDLE Handle
2=SECURITY_INFORMATION RequestedInformation
3=PSECURITY_DESCRIPTOR pSecurityDescriptor
4=DWORD nLength
5=LPDWORD lpnLengthNeeded
ParamCount=5
@=GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded);
[ImpersonateNamedPipeClient]
1=HANDLE hNamedPipe
ParamCount=1
@=ImpersonateNamedPipeClient(HANDLE hNamedPipe);
[ImpersonateSelf]
1=SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
ParamCount=1
@=ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);
[RevertToSelf]
ParamCount=0
@=RevertToSelf();
[SetThreadToken]
1=PHANDLE Thread
2=HANDLE Token
ParamCount=2
@=SetThreadToken(PHANDLE Thread, HANDLE Token);
[AccessCheck]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=HANDLE ClientToken
3=DWORD DesiredAccess
4=PGENERIC_MAPPING GenericMapping
5=PPRIVILEGE_SET PrivilegeSet
6=LPDWORD PrivilegeSetLength
7=LPDWORD GrantedAccess
8=LPBOOL AccessStatus
ParamCount=8
@=AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus);
[AccessCheckByType]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=PSID PrincipalSelfSid
3=HANDLE ClientToken
4=DWORD DesiredAccess
5=POBJECT_TYPE_LIST ObjectTypeList
6=DWORD ObjectTypeListLength
7=PGENERIC_MAPPING GenericMapping
8=PPRIVILEGE_SET PrivilegeSet
9=LPDWORD PrivilegeSetLength
10=LPDWORD GrantedAccess
11=LPBOOL AccessStatus
ParamCount=11
@=AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus);
[AccessCheckByTypeResultList]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=PSID PrincipalSelfSid
3=HANDLE ClientToken
4=DWORD DesiredAccess
5=POBJECT_TYPE_LIST ObjectTypeList
6=DWORD ObjectTypeListLength
7=PGENERIC_MAPPING GenericMapping
8=PPRIVILEGE_SET PrivilegeSet
9=LPDWORD PrivilegeSetLength
10=LPDWORD GrantedAccessList
11=LPDWORD AccessStatusList
ParamCount=11
@=AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList);
[OpenProcessToken]
1=HANDLE ProcessHandle
2=DWORD DesiredAccess
3=PHANDLE TokenHandle
ParamCount=3
@=OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
[OpenThreadToken]
1=HANDLE ThreadHandle
2=DWORD DesiredAccess
3=BOOL OpenAsSelf
4=PHANDLE TokenHandle
ParamCount=4
@=OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);
[GetTokenInformation]
1=HANDLE TokenHandle
2=TOKEN_INFORMATION_CLASS TokenInformationClass
3=LPVOID TokenInformation
4=DWORD TokenInformationLength
5=PDWORD ReturnLength
ParamCount=5
@=GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
[SetTokenInformation]
1=HANDLE TokenHandle
2=TOKEN_INFORMATION_CLASS TokenInformationClass
3=LPVOID TokenInformation
4=DWORD TokenInformationLength
ParamCount=4
@=SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength);
[AdjustTokenPrivileges]
1=HANDLE TokenHandle
2=BOOL DisableAllPrivileges
3=PTOKEN_PRIVILEGES NewState
4=DWORD BufferLength
5=PTOKEN_PRIVILEGES PreviousState
6=PDWORD ReturnLength
ParamCount=6
@=AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
[AdjustTokenGroups]
1=HANDLE TokenHandle
2=BOOL ResetToDefault
3=PTOKEN_GROUPS NewState
4=DWORD BufferLength
5=PTOKEN_GROUPS PreviousState
6=PDWORD ReturnLength
ParamCount=6
@=AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength);
[PrivilegeCheck]
1=HANDLE ClientToken
2=PPRIVILEGE_SET RequiredPrivileges
3=LPBOOL pfResult
ParamCount=3
@=PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult);
[AccessCheckAndAuditAlarmA]
1=LPCSTR SubsystemName
2=LPVOID HandleId
3=LPSTR ObjectTypeName
4=LPSTR ObjectName
5=PSECURITY_DESCRIPTOR SecurityDescriptor
6=DWORD DesiredAccess
7=PGENERIC_MAPPING GenericMapping
8=BOOL ObjectCreation
9=LPDWORD GrantedAccess
10=LPBOOL AccessStatus
11=LPBOOL pfGenerateOnClose
ParamCount=11
@=AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose);
[AccessCheckAndAuditAlarmW]
1=LPCWSTR SubsystemName
2=LPVOID HandleId
3=LPWSTR ObjectTypeName
4=LPWSTR ObjectName
5=PSECURITY_DESCRIPTOR SecurityDescriptor
6=DWORD DesiredAccess
7=PGENERIC_MAPPING GenericMapping
8=BOOL ObjectCreation
9=LPDWORD GrantedAccess
10=LPBOOL AccessStatus
11=LPBOOL pfGenerateOnClose
ParamCount=11
@=AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose);
[AccessCheckByTypeAndAuditAlarmA]
1=LPCSTR SubsystemName
2=LPVOID HandleId
3=LPCSTR ObjectTypeName
4=LPCSTR ObjectName
5=PSECURITY_DESCRIPTOR SecurityDescriptor
6=PSID PrincipalSelfSid
7=DWORD DesiredAccess
8=AUDIT_EVENT_TYPE AuditType
9=DWORD Flags
10=POBJECT_TYPE_LIST ObjectTypeList
11=DWORD ObjectTypeListLength
12=PGENERIC_MAPPING GenericMapping
13=BOOL ObjectCreation
14=LPDWORD GrantedAccess
15=LPBOOL AccessStatus
16=LPBOOL pfGenerateOnClose
ParamCount=16
@=AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose);
[AccessCheckByTypeAndAuditAlarmW]
1=LPCWSTR SubsystemName
2=LPVOID HandleId
3=LPCWSTR ObjectTypeName
4=LPCWSTR ObjectName
5=PSECURITY_DESCRIPTOR SecurityDescriptor
6=PSID PrincipalSelfSid
7=DWORD DesiredAccess
8=AUDIT_EVENT_TYPE AuditType
9=DWORD Flags
10=POBJECT_TYPE_LIST ObjectTypeList
11=DWORD ObjectTypeListLength
12=PGENERIC_MAPPING GenericMapping
13=BOOL ObjectCreation
14=LPDWORD GrantedAccess
15=LPBOOL AccessStatus
16=LPBOOL pfGenerateOnClose
ParamCount=16
@=AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose);
[AccessCheckByTypeResultListAndAuditAlarmA]
1=LPCSTR SubsystemName
2=LPVOID HandleId
3=LPCSTR ObjectTypeName
4=LPCSTR ObjectName
5=PSECURITY_DESCRIPTOR SecurityDescriptor
6=PSID PrincipalSelfSid
7=DWORD DesiredAccess
8=AUDIT_EVENT_TYPE AuditType
9=DWORD Flags
10=POBJECT_TYPE_LIST ObjectTypeList
11=DWORD ObjectTypeListLength
12=PGENERIC_MAPPING GenericMapping
13=BOOL ObjectCreation
14=LPDWORD GrantedAccess
15=LPDWORD AccessStatusList
16=LPBOOL pfGenerateOnClose
ParamCount=16
@=AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose);
[AccessCheckByTypeResultListAndAuditAlarmW]
1=LPCWSTR SubsystemName
2=LPVOID HandleId
3=LPCWSTR ObjectTypeName
4=LPCWSTR ObjectName
5=PSECURITY_DESCRIPTOR SecurityDescriptor
6=PSID PrincipalSelfSid
7=DWORD DesiredAccess
8=AUDIT_EVENT_TYPE AuditType
9=DWORD Flags
10=POBJECT_TYPE_LIST ObjectTypeList
11=DWORD ObjectTypeListLength
12=PGENERIC_MAPPING GenericMapping
13=BOOL ObjectCreation
14=LPDWORD GrantedAccess
15=LPDWORD AccessStatusList
16=LPBOOL pfGenerateOnClose
ParamCount=16
@=AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose);
[AccessCheckByTypeResultListAndAuditAlarmByHandleA]
1=LPCSTR SubsystemName
2=LPVOID HandleId
3=HANDLE ClientToken
4=LPCSTR ObjectTypeName
5=LPCSTR ObjectName
6=PSECURITY_DESCRIPTOR SecurityDescriptor
7=PSID PrincipalSelfSid
8=DWORD DesiredAccess
9=AUDIT_EVENT_TYPE AuditType
10=DWORD Flags
11=POBJECT_TYPE_LIST ObjectTypeList
12=DWORD ObjectTypeListLength
13=PGENERIC_MAPPING GenericMapping
14=BOOL ObjectCreation
15=LPDWORD GrantedAccess
16=LPDWORD AccessStatusList
17=LPBOOL pfGenerateOnClose
ParamCount=17
@=AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose);
[AccessCheckByTypeResultListAndAuditAlarmByHandleW]
1=LPCWSTR SubsystemName
2=LPVOID HandleId
3=HANDLE ClientToken
4=LPCWSTR ObjectTypeName
5=LPCWSTR ObjectName
6=PSECURITY_DESCRIPTOR SecurityDescriptor
7=PSID PrincipalSelfSid
8=DWORD DesiredAccess
9=AUDIT_EVENT_TYPE AuditType
10=DWORD Flags
11=POBJECT_TYPE_LIST ObjectTypeList
12=DWORD ObjectTypeListLength
13=PGENERIC_MAPPING GenericMapping
14=BOOL ObjectCreation
15=LPDWORD GrantedAccess
16=LPDWORD AccessStatusList
17=LPBOOL pfGenerateOnClose
ParamCount=17
@=AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose);
[ObjectOpenAuditAlarmA]
1=LPCSTR SubsystemName
2=LPVOID HandleId
3=LPSTR ObjectTypeName
4=LPSTR ObjectName
5=PSECURITY_DESCRIPTOR pSecurityDescriptor
6=HANDLE ClientToken
7=DWORD DesiredAccess
8=DWORD GrantedAccess
9=PPRIVILEGE_SET Privileges
10=BOOL ObjectCreation
11=BOOL AccessGranted
12=LPBOOL GenerateOnClose
ParamCount=12
@=ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose);
[ObjectOpenAuditAlarmW]
1=LPCWSTR SubsystemName
2=LPVOID HandleId
3=LPWSTR ObjectTypeName
4=LPWSTR ObjectName
5=PSECURITY_DESCRIPTOR pSecurityDescriptor
6=HANDLE ClientToken
7=DWORD DesiredAccess
8=DWORD GrantedAccess
9=PPRIVILEGE_SET Privileges
10=BOOL ObjectCreation
11=BOOL AccessGranted
12=LPBOOL GenerateOnClose
ParamCount=12
@=ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose);
[ObjectPrivilegeAuditAlarmA]
1=LPCSTR SubsystemName
2=LPVOID HandleId
3=HANDLE ClientToken
4=DWORD DesiredAccess
5=PPRIVILEGE_SET Privileges
6=BOOL AccessGranted
ParamCount=6
@=ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted);
[ObjectPrivilegeAuditAlarmW]
1=LPCWSTR SubsystemName
2=LPVOID HandleId
3=HANDLE ClientToken
4=DWORD DesiredAccess
5=PPRIVILEGE_SET Privileges
6=BOOL AccessGranted
ParamCount=6
@=ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted);
[ObjectCloseAuditAlarmA]
1=LPCSTR SubsystemName
2=LPVOID HandleId
3=BOOL GenerateOnClose
ParamCount=3
@=ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose);
[ObjectCloseAuditAlarmW]
1=LPCWSTR SubsystemName
2=LPVOID HandleId
3=BOOL GenerateOnClose
ParamCount=3
@=ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose);
[ObjectDeleteAuditAlarmA]
1=LPCSTR SubsystemName
2=LPVOID HandleId
3=BOOL GenerateOnClose
ParamCount=3
@=ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose);
[ObjectDeleteAuditAlarmW]
1=LPCWSTR SubsystemName
2=LPVOID HandleId
3=BOOL GenerateOnClose
ParamCount=3
@=ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose);
[PrivilegedServiceAuditAlarmA]
1=LPCSTR SubsystemName
2=LPCSTR ServiceName
3=HANDLE ClientToken
4=PPRIVILEGE_SET Privileges
5=BOOL AccessGranted
ParamCount=5
@=PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted);
[PrivilegedServiceAuditAlarmW]
1=LPCWSTR SubsystemName
2=LPCWSTR ServiceName
3=HANDLE ClientToken
4=PPRIVILEGE_SET Privileges
5=BOOL AccessGranted
ParamCount=5
@=PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted);
[IsWellKnownSid]
1=PSID pSid
2=WELL_KNOWN_SID_TYPE WellKnownSidType
ParamCount=2
@=IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType);
[CreateWellKnownSid]
1=WELL_KNOWN_SID_TYPE WellKnownSidType
2=PSID DomainSid
3=PSID pSid
4=DWORD *cbSid
ParamCount=4
@=CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid);
[EqualDomainSid]
1=PSID pSid1
2=PSID pSid2
3=BOOL *pfEqual
ParamCount=3
@=EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual);
[GetWindowsAccountDomainSid]
1=PSID pSid
2=PSID pDomainSid
3=DWORD* cbDomainSid
ParamCount=3
@=GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD* cbDomainSid);
[IsValidSid]
1=PSID pSid
ParamCount=1
@=IsValidSid(PSID pSid);
[EqualSid]
1=PSID pSid1
2=PSID pSid2
ParamCount=2
@=EqualSid(PSID pSid1, PSID pSid2);
[EqualPrefixSid]
1=PSID pSid1
2=PSID pSid2
ParamCount=2
@=EqualPrefixSid(PSID pSid1, PSID pSid2);
[GetSidLengthRequired]
1=UCHAR nSubAuthorityCount
ParamCount=1
@=GetSidLengthRequired(UCHAR nSubAuthorityCount);
[AllocateAndInitializeSid]
1=PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority
2=BYTE nSubAuthorityCount
3=DWORD nSubAuthority0
4=DWORD nSubAuthority1
5=DWORD nSubAuthority2
6=DWORD nSubAuthority3
7=DWORD nSubAuthority4
8=DWORD nSubAuthority5
9=DWORD nSubAuthority6
10=DWORD nSubAuthority7
11=PSID *pSid
ParamCount=11
@=AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
[FreeSid]
1=PSID pSid
ParamCount=1
@=FreeSid(PSID pSid);
[InitializeSid]
1=PSID Sid
2=PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority
3=BYTE nSubAuthorityCount
ParamCount=3
@=InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount);
[GetSidIdentifierAuthority]
1=PSID pSid
ParamCount=1
@=GetSidIdentifierAuthority(PSID pSid);
[GetSidSubAuthority]
1=PSID pSid
2=DWORD nSubAuthority
ParamCount=2
@=GetSidSubAuthority(PSID pSid, DWORD nSubAuthority);
[GetSidSubAuthorityCount]
1=PSID pSid
ParamCount=1
@=GetSidSubAuthorityCount(PSID pSid);
[GetLengthSid]
1=PSID pSid
ParamCount=1
@=GetLengthSid(PSID pSid);
[CopySid]
1=DWORD nDestinationSidLength
2=PSID pDestinationSid
3=PSID pSourceSid
ParamCount=3
@=CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid);
[AreAllAccessesGranted]
1=DWORD GrantedAccess
2=DWORD DesiredAccess
ParamCount=2
@=AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess);
[AreAnyAccessesGranted]
1=DWORD GrantedAccess
2=DWORD DesiredAccess
ParamCount=2
@=AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess);
[MapGenericMask]
1=PDWORD AccessMask
2=PGENERIC_MAPPING GenericMapping
ParamCount=2
@=MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping);
[IsValidAcl]
1=PACL pAcl
ParamCount=1
@=IsValidAcl(PACL pAcl);
[InitializeAcl]
1=PACL pAcl
2=DWORD nAclLength
3=DWORD dwAclRevision
ParamCount=3
@=InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);
[GetAclInformation]
1=PACL pAcl
2=LPVOID pAclInformation
3=DWORD nAclInformationLength
4=ACL_INFORMATION_CLASS dwAclInformationClass
ParamCount=4
@=GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass);
[SetAclInformation]
1=PACL pAcl
2=LPVOID pAclInformation
3=DWORD nAclInformationLength
4=ACL_INFORMATION_CLASS dwAclInformationClass
ParamCount=4
@=SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass);
[AddAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD dwStartingAceIndex
4=LPVOID pAceList
5=DWORD nAceListLength
ParamCount=5
@=AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength);
[DeleteAce]
1=PACL pAcl
2=DWORD dwAceIndex
ParamCount=2
@=DeleteAce(PACL pAcl, DWORD dwAceIndex);
[GetAce]
1=PACL pAcl
2=DWORD dwAceIndex
3=LPVOID *pAce
ParamCount=3
@=GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce);
[AddAccessAllowedAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AccessMask
4=PSID pSid
ParamCount=4
@=AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);
[AddAccessAllowedAceEx]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AceFlags
4=DWORD AccessMask
5=PSID pSid
ParamCount=5
@=AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid);
[AddMandatoryAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AceFlags
4=DWORD MandatoryPolicy
5=PSID pLabelSid
ParamCount=5
@=AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid);
[AddConditionalAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AceFlags
4=UCHAR AceType
5=DWORD AccessMask
6=PSID pSid
7=PWCHAR ConditionStr
8=DWORD *ReturnLength
ParamCount=8
@=AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength);
[AddAccessDeniedAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AccessMask
4=PSID pSid
ParamCount=4
@=AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);
[AddAccessDeniedAceEx]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AceFlags
4=DWORD AccessMask
5=PSID pSid
ParamCount=5
@=AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid);
[AddAuditAccessAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD dwAccessMask
4=PSID pSid
5=BOOL bAuditSuccess
6=BOOL bAuditFailure
ParamCount=6
@=AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure);
[AddAuditAccessAceEx]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AceFlags
4=DWORD dwAccessMask
5=PSID pSid
6=BOOL bAuditSuccess
7=BOOL bAuditFailure
ParamCount=7
@=AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure);
[AddAccessAllowedObjectAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AceFlags
4=DWORD AccessMask
5=GUID *ObjectTypeGuid
6=GUID *InheritedObjectTypeGuid
7=PSID pSid
ParamCount=7
@=AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid);
[AddAccessDeniedObjectAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AceFlags
4=DWORD AccessMask
5=GUID *ObjectTypeGuid
6=GUID *InheritedObjectTypeGuid
7=PSID pSid
ParamCount=7
@=AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid);
[AddAuditAccessObjectAce]
1=PACL pAcl
2=DWORD dwAceRevision
3=DWORD AceFlags
4=DWORD AccessMask
5=GUID *ObjectTypeGuid
6=GUID *InheritedObjectTypeGuid
7=PSID pSid
8=BOOL bAuditSuccess
9=BOOL bAuditFailure
ParamCount=9
@=AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure);
[FindFirstFreeAce]
1=PACL pAcl
2=LPVOID *pAce
ParamCount=2
@=FindFirstFreeAce(PACL pAcl, LPVOID *pAce);
[InitializeSecurityDescriptor]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=DWORD dwRevision
ParamCount=2
@=InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
[IsValidSecurityDescriptor]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
ParamCount=1
@=IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor);
[IsValidRelativeSecurityDescriptor]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=ULONG SecurityDescriptorLength
3=SECURITY_INFORMATION RequiredInformation
ParamCount=3
@=IsValidRelativeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, ULONG SecurityDescriptorLength, SECURITY_INFORMATION RequiredInformation);
[GetSecurityDescriptorLength]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
ParamCount=1
@=GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor);
[GetSecurityDescriptorControl]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=PSECURITY_DESCRIPTOR_CONTROL pControl
3=LPDWORD lpdwRevision
ParamCount=3
@=GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision);
[SetSecurityDescriptorControl]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest
3=SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
ParamCount=3
@=SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet);
[SetSecurityDescriptorDacl]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=BOOL bDaclPresent
3=PACL pDacl
4=BOOL bDaclDefaulted
ParamCount=4
@=SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted);
[GetSecurityDescriptorDacl]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=LPBOOL lpbDaclPresent
3=PACL *pDacl
4=LPBOOL lpbDaclDefaulted
ParamCount=4
@=GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted);
[SetSecurityDescriptorSacl]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=BOOL bSaclPresent
3=PACL pSacl
4=BOOL bSaclDefaulted
ParamCount=4
@=SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted);
[GetSecurityDescriptorSacl]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=LPBOOL lpbSaclPresent
3=PACL *pSacl
4=LPBOOL lpbSaclDefaulted
ParamCount=4
@=GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted);
[SetSecurityDescriptorOwner]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=PSID pOwner
3=BOOL bOwnerDefaulted
ParamCount=3
@=SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted);
[GetSecurityDescriptorOwner]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=PSID *pOwner
3=LPBOOL lpbOwnerDefaulted
ParamCount=3
@=GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted);
[SetSecurityDescriptorGroup]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=PSID pGroup
3=BOOL bGroupDefaulted
ParamCount=3
@=SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted);
[GetSecurityDescriptorGroup]
1=PSECURITY_DESCRIPTOR pSecurityDescriptor
2=PSID *pGroup
3=LPBOOL lpbGroupDefaulted
ParamCount=3
@=GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted);
[SetSecurityDescriptorRMControl]
1=PSECURITY_DESCRIPTOR SecurityDescriptor
2=PUCHAR RMControl
ParamCount=2
@=SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl);
[GetSecurityDescriptorRMControl]
1=PSECURITY_DESCRIPTOR SecurityDescriptor
2=PUCHAR RMControl
ParamCount=2
@=GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl);
[CreatePrivateObjectSecurity]
1=PSECURITY_DESCRIPTOR ParentDescriptor
2=PSECURITY_DESCRIPTOR CreatorDescriptor
3=PSECURITY_DESCRIPTOR *NewDescriptor
4=BOOL IsDirectoryObject
5=HANDLE Token
6=PGENERIC_MAPPING GenericMapping
ParamCount=6
@=CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping);
[ConvertToAutoInheritPrivateObjectSecurity]
1=PSECURITY_DESCRIPTOR ParentDescriptor
2=PSECURITY_DESCRIPTOR CurrentSecurityDescriptor
3=PSECURITY_DESCRIPTOR *NewSecurityDescriptor
4=GUID *ObjectType
5=BOOLEAN IsDirectoryObject
6=PGENERIC_MAPPING GenericMapping
ParamCount=6
@=ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping);
[CreatePrivateObjectSecurityEx]
1=PSECURITY_DESCRIPTOR ParentDescriptor
2=PSECURITY_DESCRIPTOR CreatorDescriptor
3=PSECURITY_DESCRIPTOR *NewDescriptor
4=GUID *ObjectType
5=BOOL IsContainerObject
6=ULONG AutoInheritFlags
7=HANDLE Token
8=PGENERIC_MAPPING GenericMapping
ParamCount=8
@=CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping);
[CreatePrivateObjectSecurityWithMultipleInheritance]
1=PSECURITY_DESCRIPTOR ParentDescriptor
2=PSECURITY_DESCRIPTOR CreatorDescriptor
3=PSECURITY_DESCRIPTOR *NewDescriptor
4=GUID **ObjectTypes
5=ULONG GuidCount
6=BOOL IsContainerObject
7=ULONG AutoInheritFlags
8=HANDLE Token
9=PGENERIC_MAPPING GenericMapping
ParamCount=9
@=CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping);
[SetPrivateObjectSecurity]
1=SECURITY_INFORMATION SecurityInformation
2=PSECURITY_DESCRIPTOR ModificationDescriptor
3=PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
4=PGENERIC_MAPPING GenericMapping
5=HANDLE Token
ParamCount=5
@=SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token);
[SetPrivateObjectSecurityEx]
1=SECURITY_INFORMATION SecurityInformation
2=PSECURITY_DESCRIPTOR ModificationDescriptor
3=PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
4=ULONG AutoInheritFlags
5=PGENERIC_MAPPING GenericMapping
6=HANDLE Token
ParamCount=6
@=SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token);
[GetPrivateObjectSecurity]
1=PSECURITY_DESCRIPTOR ObjectDescriptor
2=SECURITY_INFORMATION SecurityInformation
3=PSECURITY_DESCRIPTOR ResultantDescriptor
4=DWORD DescriptorLength
5=PDWORD ReturnLength
ParamCount=5
@=GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength);
[DestroyPrivateObjectSecurity]
1=PSECURITY_DESCRIPTOR *ObjectDescriptor
ParamCount=1
@=DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor);
[MakeSelfRelativeSD]
1=PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor
2=PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor
3=LPDWORD lpdwBufferLength
ParamCount=3
@=MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength);
[MakeAbsoluteSD]
1=PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor
2=PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor
3=LPDWORD lpdwAbsoluteSecurityDescriptorSize
4=PACL pDacl
5=LPDWORD lpdwDaclSize
6=PACL pSacl
7=LPDWORD lpdwSaclSize
8=PSID pOwner
9=LPDWORD lpdwOwnerSize
10=PSID pPrimaryGroup
11=LPDWORD lpdwPrimaryGroupSize
ParamCount=11
@=MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize);
[MakeAbsoluteSD2]
1=PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor
2=LPDWORD lpdwBufferSize
ParamCount=2
@=MakeAbsoluteSD2(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferSize);
[QuerySecurityAccessMask]
1=SECURITY_INFORMATION SecurityInformation
2=LPDWORD DesiredAccess
ParamCount=2
@=QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess);
[SetSecurityAccessMask]
1=SECURITY_INFORMATION SecurityInformation
2=LPDWORD DesiredAccess
ParamCount=2
@=SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess);
[SetFileSecurityA]
1=LPCSTR lpFileName
2=SECURITY_INFORMATION SecurityInformation
3=PSECURITY_DESCRIPTOR pSecurityDescriptor
ParamCount=3
@=SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
[SetFileSecurityW]
1=LPCWSTR lpFileName
2=SECURITY_INFORMATION SecurityInformation
3=PSECURITY_DESCRIPTOR pSecurityDescriptor
ParamCount=3
@=SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
[GetFileSecurityA]
1=LPCSTR lpFileName
2=SECURITY_INFORMATION RequestedInformation
3=PSECURITY_DESCRIPTOR pSecurityDescriptor
4=DWORD nLength
5=LPDWORD lpnLengthNeeded
ParamCount=5
@=GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded);
[GetFileSecurityW]
1=LPCWSTR lpFileName
2=SECURITY_INFORMATION RequestedInformation
3=PSECURITY_DESCRIPTOR pSecurityDescriptor
4=DWORD nLength
5=LPDWORD lpnLengthNeeded
ParamCount=5
@=GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded);
[SetKernelObjectSecurity]
1=HANDLE Handle
2=SECURITY_INFORMATION SecurityInformation
3=PSECURITY_DESCRIPTOR SecurityDescriptor
ParamCount=3
@=SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);
[FindFirstChangeNotificationA]
1=LPCSTR lpPathName
2=BOOL bWatchSubtree
3=DWORD dwNotifyFilter
ParamCount=3
@=FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
[FindFirstChangeNotificationW]
1=LPCWSTR lpPathName
2=BOOL bWatchSubtree
3=DWORD dwNotifyFilter
ParamCount=3
@=FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
[FindNextChangeNotification]
1=HANDLE hChangeHandle
ParamCount=1
@=FindNextChangeNotification(HANDLE hChangeHandle);
[FindCloseChangeNotification]
1=HANDLE hChangeHandle
ParamCount=1
@=FindCloseChangeNotification(HANDLE hChangeHandle);
[ReadDirectoryChangesW]
1=HANDLE hDirectory
2=LPVOID lpBuffer
3=DWORD nBufferLength
4=BOOL bWatchSubtree
5=DWORD dwNotifyFilter
6=LPDWORD lpBytesReturned
7=LPOVERLAPPED lpOverlapped
8=LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
ParamCount=8
@=ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
[VirtualLock]
1=LPVOID lpAddress
2=SIZE_T dwSize
ParamCount=2
@=VirtualLock(LPVOID lpAddress, SIZE_T dwSize);
[VirtualUnlock]
1=LPVOID lpAddress
2=SIZE_T dwSize
ParamCount=2
@=VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize);
[MapViewOfFileEx]
1=HANDLE hFileMappingObject
2=DWORD dwDesiredAccess
3=DWORD dwFileOffsetHigh
4=DWORD dwFileOffsetLow
5=SIZE_T dwNumberOfBytesToMap
6=LPVOID lpBaseAddress
ParamCount=6
@=MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
[MapViewOfFileExNuma]
1=HANDLE hFileMappingObject
2=DWORD dwDesiredAccess
3=DWORD dwFileOffsetHigh
4=DWORD dwFileOffsetLow
5=SIZE_T dwNumberOfBytesToMap
6=LPVOID lpBaseAddress
7=DWORD nndPreferred
ParamCount=7
@=MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred);
[SetPriorityClass]
1=HANDLE hProcess
2=DWORD dwPriorityClass
ParamCount=2
@=SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass);
[GetPriorityClass]
1=HANDLE hProcess
ParamCount=1
@=GetPriorityClass(HANDLE hProcess);
[IsBadReadPtr]
1=VOID *lp
2=UINT_PTR ucb
ParamCount=2
@=IsBadReadPtr(VOID *lp, UINT_PTR ucb);
[IsBadWritePtr]
1=LPVOID lp
2=UINT_PTR ucb
ParamCount=2
@=IsBadWritePtr(LPVOID lp, UINT_PTR ucb);
[IsBadHugeReadPtr]
1=VOID *lp
2=UINT_PTR ucb
ParamCount=2
@=IsBadHugeReadPtr(VOID *lp, UINT_PTR ucb);
[IsBadHugeWritePtr]
1=LPVOID lp
2=UINT_PTR ucb
ParamCount=2
@=IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb);
[IsBadCodePtr]
1=FARPROC lpfn
ParamCount=1
@=IsBadCodePtr(FARPROC lpfn);
[IsBadStringPtrA]
1=LPCSTR lpsz
2=UINT_PTR ucchMax
ParamCount=2
@=IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax);
[IsBadStringPtrW]
1=LPCWSTR lpsz
2=UINT_PTR ucchMax
ParamCount=2
@=IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax);
[LookupAccountSidA]
1=LPCSTR lpSystemName
2=PSID Sid
3=LPSTR Name
4=LPDWORD cchName
5=LPSTR ReferencedDomainName
6=LPDWORD cchReferencedDomainName
7=PSID_NAME_USE peUse
ParamCount=7
@=LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
[LookupAccountSidW]
1=LPCWSTR lpSystemName
2=PSID Sid
3=LPWSTR Name
4=LPDWORD cchName
5=LPWSTR ReferencedDomainName
6=LPDWORD cchReferencedDomainName
7=PSID_NAME_USE peUse
ParamCount=7
@=LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
[LookupAccountSidLocalA]
1=PSID Sid
2=LPSTR Name
3=LPDWORD cchName
4=LPSTR ReferencedDomainName
5=LPDWORD cchReferencedDomainName
6=PSID_NAME_USE peUse
ParamCount=6
@=LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
[LookupAccountSidLocalW]
1=PSID Sid
2=LPWSTR Name
3=LPDWORD cchName
4=LPWSTR ReferencedDomainName
5=LPDWORD cchReferencedDomainName
6=PSID_NAME_USE peUse
ParamCount=6
@=LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
[LookupAccountNameA]
1=LPCSTR lpSystemName
2=LPCSTR lpAccountName
3=PSID Sid
4=LPDWORD cbSid
5=LPSTR ReferencedDomainName
6=LPDWORD cchReferencedDomainName
7=PSID_NAME_USE peUse
ParamCount=7
@=LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
[LookupAccountNameW]
1=LPCWSTR lpSystemName
2=LPCWSTR lpAccountName
3=PSID Sid
4=LPDWORD cbSid
5=LPWSTR ReferencedDomainName
6=LPDWORD cchReferencedDomainName
7=PSID_NAME_USE peUse
ParamCount=7
@=LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
[LookupAccountNameLocalA]
1=LPCSTR lpAccountName
2=PSID Sid
3=LPDWORD cbSid
4=LPSTR ReferencedDomainName
5=LPDWORD cchReferencedDomainName
6=PSID_NAME_USE peUse
ParamCount=6
@=LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
[LookupAccountNameLocalW]
1=LPCWSTR lpAccountName
2=PSID Sid
3=LPDWORD cbSid
4=LPWSTR ReferencedDomainName
5=LPDWORD cchReferencedDomainName
6=PSID_NAME_USE peUse
ParamCount=6
@=LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
[LookupPrivilegeValueA]
1=LPCSTR lpSystemName
2=LPCSTR lpName
3=PLUID lpLuid
ParamCount=3
@=LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
[LookupPrivilegeValueW]
1=LPCWSTR lpSystemName
2=LPCWSTR lpName
3=PLUID lpLuid
ParamCount=3
@=LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
[LookupPrivilegeNameA]
1=LPCSTR lpSystemName
2=PLUID lpLuid
3=LPSTR lpName
4=LPDWORD cchName
ParamCount=4
@=LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName);
[LookupPrivilegeNameW]
1=LPCWSTR lpSystemName
2=PLUID lpLuid
3=LPWSTR lpName
4=LPDWORD cchName
ParamCount=4
@=LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName);
[LookupPrivilegeDisplayNameA]
1=LPCSTR lpSystemName
2=LPCSTR lpName
3=LPSTR lpDisplayName
4=LPDWORD cchDisplayName
5=LPDWORD lpLanguageId
ParamCount=5
@=LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId);
[LookupPrivilegeDisplayNameW]
1=LPCWSTR lpSystemName
2=LPCWSTR lpName
3=LPWSTR lpDisplayName
4=LPDWORD cchDisplayName
5=LPDWORD lpLanguageId
ParamCount=5
@=LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId);
[AllocateLocallyUniqueId]
1=PLUID Luid
ParamCount=1
@=AllocateLocallyUniqueId(PLUID Luid);
[BuildCommDCBA]
1=LPCSTR lpDef
2=LPDCB lpDCB
ParamCount=2
@=BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB);
[BuildCommDCBW]
1=LPCWSTR lpDef
2=LPDCB lpDCB
ParamCount=2
@=BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB);
[BuildCommDCBAndTimeoutsA]
1=LPCSTR lpDef
2=LPDCB lpDCB
3=LPCOMMTIMEOUTS lpCommTimeouts
ParamCount=3
@=BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts);
[BuildCommDCBAndTimeoutsW]
1=LPCWSTR lpDef
2=LPDCB lpDCB
3=LPCOMMTIMEOUTS lpCommTimeouts
ParamCount=3
@=BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts);
[CommConfigDialogA]
1=LPCSTR lpszName
2=HWND hWnd
3=LPCOMMCONFIG lpCC
ParamCount=3
@=CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC);
[CommConfigDialogW]
1=LPCWSTR lpszName
2=HWND hWnd
3=LPCOMMCONFIG lpCC
ParamCount=3
@=CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC);
[GetDefaultCommConfigA]
1=LPCSTR lpszName
2=LPCOMMCONFIG lpCC
3=LPDWORD lpdwSize
ParamCount=3
@=GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
[GetDefaultCommConfigW]
1=LPCWSTR lpszName
2=LPCOMMCONFIG lpCC
3=LPDWORD lpdwSize
ParamCount=3
@=GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
[SetDefaultCommConfigA]
1=LPCSTR lpszName
2=LPCOMMCONFIG lpCC
3=DWORD dwSize
ParamCount=3
@=SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize);
[SetDefaultCommConfigW]
1=LPCWSTR lpszName
2=LPCOMMCONFIG lpCC
3=DWORD dwSize
ParamCount=3
@=SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize);
[GetComputerNameA]
1=LPSTR lpBuffer
2=LPDWORD nSize
ParamCount=2
@=GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize);
[GetComputerNameW]
1=LPWSTR lpBuffer
2=LPDWORD nSize
ParamCount=2
@=GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize);
[SetComputerNameA]
1=LPCSTR lpComputerName
ParamCount=1
@=SetComputerNameA(LPCSTR lpComputerName);
[SetComputerNameW]
1=LPCWSTR lpComputerName
ParamCount=1
@=SetComputerNameW(LPCWSTR lpComputerName);
[GetComputerNameExA]
1=COMPUTER_NAME_FORMAT NameType
2=LPSTR lpBuffer
3=LPDWORD nSize
ParamCount=3
@=GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize);
[GetComputerNameExW]
1=COMPUTER_NAME_FORMAT NameType
2=LPWSTR lpBuffer
3=LPDWORD nSize
ParamCount=3
@=GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize);
[SetComputerNameExA]
1=COMPUTER_NAME_FORMAT NameType
2=LPCSTR lpBuffer
ParamCount=2
@=SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer);
[SetComputerNameExW]
1=COMPUTER_NAME_FORMAT NameType
2=LPCWSTR lpBuffer
ParamCount=2
@=SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer);
[DnsHostnameToComputerNameA]
1=LPCSTR Hostname
2=LPSTR ComputerName
3=LPDWORD nSize
ParamCount=3
@=DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize);
[DnsHostnameToComputerNameW]
1=LPCWSTR Hostname
2=LPWSTR ComputerName
3=LPDWORD nSize
ParamCount=3
@=DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize);
[GetUserNameA]
1=LPSTR lpBuffer
2=LPDWORD pcbBuffer
ParamCount=2
@=GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer);
[GetUserNameW]
1=LPWSTR lpBuffer
2=LPDWORD pcbBuffer
ParamCount=2
@=GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer);
[LogonUserA]
1=LPCSTR lpszUsername
2=LPCSTR lpszDomain
3=LPCSTR lpszPassword
4=DWORD dwLogonType
5=DWORD dwLogonProvider
6=PHANDLE phToken
ParamCount=6
@=LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken);
[LogonUserW]
1=LPCWSTR lpszUsername
2=LPCWSTR lpszDomain
3=LPCWSTR lpszPassword
4=DWORD dwLogonType
5=DWORD dwLogonProvider
6=PHANDLE phToken
ParamCount=6
@=LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken);
[LogonUserExA]
1=LPCSTR lpszUsername
2=LPCSTR lpszDomain
3=LPCSTR lpszPassword
4=DWORD dwLogonType
5=DWORD dwLogonProvider
6=PHANDLE phToken
7=PSID *ppLogonSid
8=PVOID *ppProfileBuffer
9=LPDWORD pdwProfileLength
10=PQUOTA_LIMITS pQuotaLimits
ParamCount=10
@=LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits);
[LogonUserExW]
1=LPCWSTR lpszUsername
2=LPCWSTR lpszDomain
3=LPCWSTR lpszPassword
4=DWORD dwLogonType
5=DWORD dwLogonProvider
6=PHANDLE phToken
7=PSID *ppLogonSid
8=PVOID *ppProfileBuffer
9=LPDWORD pdwProfileLength
10=PQUOTA_LIMITS pQuotaLimits
ParamCount=10
@=LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits);
[ImpersonateLoggedOnUser]
1=HANDLE hToken
ParamCount=1
@=ImpersonateLoggedOnUser(HANDLE hToken);
[CreateProcessAsUserA]
1=HANDLE hToken
2=LPCSTR lpApplicationName
3=LPSTR lpCommandLine
4=LPSECURITY_ATTRIBUTES lpProcessAttributes
5=LPSECURITY_ATTRIBUTES lpThreadAttributes
6=BOOL bInheritHandles
7=DWORD dwCreationFlags
8=LPVOID lpEnvironment
9=LPCSTR lpCurrentDirectory
10=LPSTARTUPINFOA lpStartupInfo
11=LPPROCESS_INFORMATION lpProcessInformation
ParamCount=11
@=CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
[CreateProcessAsUserW]
1=HANDLE hToken
2=LPCWSTR lpApplicationName
3=LPWSTR lpCommandLine
4=LPSECURITY_ATTRIBUTES lpProcessAttributes
5=LPSECURITY_ATTRIBUTES lpThreadAttributes
6=BOOL bInheritHandles
7=DWORD dwCreationFlags
8=LPVOID lpEnvironment
9=LPCWSTR lpCurrentDirectory
10=LPSTARTUPINFOW lpStartupInfo
11=LPPROCESS_INFORMATION lpProcessInformation
ParamCount=11
@=CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
[CreateProcessWithLogonW]
1=LPCWSTR lpUsername
2=LPCWSTR lpDomain
3=LPCWSTR lpPassword
4=DWORD dwLogonFlags
5=LPCWSTR lpApplicationName
6=LPWSTR lpCommandLine
7=DWORD dwCreationFlags
8=LPVOID lpEnvironment
9=LPCWSTR lpCurrentDirectory
10=LPSTARTUPINFOW lpStartupInfo
11=LPPROCESS_INFORMATION lpProcessInformation
ParamCount=11
@=CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
[CreateProcessWithTokenW]
1=HANDLE hToken
2=DWORD dwLogonFlags
3=LPCWSTR lpApplicationName
4=LPWSTR lpCommandLine
5=DWORD dwCreationFlags
6=LPVOID lpEnvironment
7=LPCWSTR lpCurrentDirectory
8=LPSTARTUPINFOW lpStartupInfo
9=LPPROCESS_INFORMATION lpProcessInformation
ParamCount=9
@=CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
[ImpersonateAnonymousToken]
1=HANDLE ThreadHandle
ParamCount=1
@=ImpersonateAnonymousToken(HANDLE ThreadHandle);
[DuplicateTokenEx]
1=HANDLE hExistingToken
2=DWORD dwDesiredAccess
3=LPSECURITY_ATTRIBUTES lpTokenAttributes
4=SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
5=TOKEN_TYPE TokenType
6=PHANDLE phNewToken
ParamCount=6
@=DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken);
[CreateRestrictedToken]
1=HANDLE ExistingTokenHandle
2=DWORD Flags
3=DWORD DisableSidCount
4=PSID_AND_ATTRIBUTES SidsToDisable
5=DWORD DeletePrivilegeCount
6=PLUID_AND_ATTRIBUTES PrivilegesToDelete
7=DWORD RestrictedSidCount
8=PSID_AND_ATTRIBUTES SidsToRestrict
9=PHANDLE NewTokenHandle
ParamCount=9
@=CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle);
[IsTokenRestricted]
1=HANDLE TokenHandle
ParamCount=1
@=IsTokenRestricted(HANDLE TokenHandle);
[IsTokenUntrusted]
1=HANDLE TokenHandle
ParamCount=1
@=IsTokenUntrusted(HANDLE TokenHandle);
[CheckTokenMembership]
1=HANDLE TokenHandle
2=PSID SidToCheck
3=PBOOL IsMember
ParamCount=3
@=CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
[RegisterWaitForSingleObject]
1=PHANDLE phNewWaitObject
2=HANDLE hObject
3=WAITORTIMERCALLBACK Callback
4=PVOID Context
5=ULONG dwMilliseconds
6=ULONG dwFlags
ParamCount=6
@=RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
[RegisterWaitForSingleObjectEx]
1=HANDLE hObject
2=WAITORTIMERCALLBACK Callback
3=PVOID Context
4=ULONG dwMilliseconds
5=ULONG dwFlags
ParamCount=5
@=RegisterWaitForSingleObjectEx(HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
[UnregisterWait]
1=HANDLE WaitHandle
ParamCount=1
@=UnregisterWait(HANDLE WaitHandle);
[UnregisterWaitEx]
1=HANDLE WaitHandle
2=HANDLE CompletionEvent
ParamCount=2
@=UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent);
[QueueUserWorkItem]
1=LPTHREAD_START_ROUTINE Function
2=PVOID Context
3=ULONG Flags
ParamCount=3
@=QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags);
[BindIoCompletionCallback]
1=HANDLE FileHandle
2=LPOVERLAPPED_COMPLETION_ROUTINE Function
3=ULONG Flags
ParamCount=3
@=BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags);
[CreateTimerQueue]
ParamCount=0
@=CreateTimerQueue();
[CreateTimerQueueTimer]
1=PHANDLE phNewTimer
2=HANDLE TimerQueue
3=WAITORTIMERCALLBACK Callback
4=PVOID Parameter
5=DWORD DueTime
6=DWORD Period
7=ULONG Flags
ParamCount=7
@=CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
[ChangeTimerQueueTimer]
1=HANDLE TimerQueue
2=HANDLE Timer
3=ULONG DueTime
4=ULONG Period
ParamCount=4
@=ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
[DeleteTimerQueueTimer]
1=HANDLE TimerQueue
2=HANDLE Timer
3=HANDLE CompletionEvent
ParamCount=3
@=DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
[DeleteTimerQueueEx]
1=HANDLE TimerQueue
2=HANDLE CompletionEvent
ParamCount=2
@=DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent);
[SetTimerQueueTimer]
1=HANDLE TimerQueue
2=WAITORTIMERCALLBACK Callback
3=PVOID Parameter
4=DWORD DueTime
5=DWORD Period
6=BOOL PreferIo
ParamCount=6
@=SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo);
[CancelTimerQueueTimer]
1=HANDLE TimerQueue
2=HANDLE Timer
ParamCount=2
@=CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer);
[DeleteTimerQueue]
1=HANDLE TimerQueue
ParamCount=1
@=DeleteTimerQueue(HANDLE TimerQueue);
[CreateThreadpool]
1=PVOID reserved
ParamCount=1
@=CreateThreadpool(PVOID reserved);
[SetThreadpoolThreadMaximum]
1=PTP_POOL ptpp
2=DWORD cthrdMost
ParamCount=2
@=SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost);
[SetThreadpoolThreadMinimum]
1=PTP_POOL ptpp
2=DWORD cthrdMic
ParamCount=2
@=SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic);
[SetThreadpoolStackInformation]
1=PTP_POOL ptpp
2=PTP_POOL_STACK_INFORMATION ptpsi
ParamCount=2
@=SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);
[QueryThreadpoolStackInformation]
1=PTP_POOL ptpp
2=PTP_POOL_STACK_INFORMATION ptpsi
ParamCount=2
@=QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);
[CloseThreadpool]
1=PTP_POOL ptpp
ParamCount=1
@=CloseThreadpool(PTP_POOL ptpp);
[CreateThreadpoolCleanupGroup]
ParamCount=0
@=CreateThreadpoolCleanupGroup();
[CloseThreadpoolCleanupGroupMembers]
1=PTP_CLEANUP_GROUP ptpcg
2=BOOL fCancelPendingCallbacks
3=PVOID pvCleanupContext
ParamCount=3
@=CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext);
[CloseThreadpoolCleanupGroup]
1=PTP_CLEANUP_GROUP ptpcg
ParamCount=1
@=CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg);
[SetEventWhenCallbackReturns]
1=PTP_CALLBACK_INSTANCE pci
2=HANDLE evt
ParamCount=2
@=SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt);
[ReleaseSemaphoreWhenCallbackReturns]
1=PTP_CALLBACK_INSTANCE pci
2=HANDLE sem
3=DWORD crel
ParamCount=3
@=ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel);
[ReleaseMutexWhenCallbackReturns]
1=PTP_CALLBACK_INSTANCE pci
2=HANDLE mut
ParamCount=2
@=ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut);
[LeaveCriticalSectionWhenCallbackReturns]
1=PTP_CALLBACK_INSTANCE pci
2=PCRITICAL_SECTION pcs
ParamCount=2
@=LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs);
[FreeLibraryWhenCallbackReturns]
1=PTP_CALLBACK_INSTANCE pci
2=HMODULE mod
ParamCount=2
@=FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod);
[CallbackMayRunLong]
1=PTP_CALLBACK_INSTANCE pci
ParamCount=1
@=CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci);
[DisassociateCurrentThreadFromCallback]
1=PTP_CALLBACK_INSTANCE pci
ParamCount=1
@=DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci);
[TrySubmitThreadpoolCallback]
1=PTP_SIMPLE_CALLBACK pfns
2=PVOID pv
3=PTP_CALLBACK_ENVIRON pcbe
ParamCount=3
@=TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
[CreateThreadpoolWork]
1=PTP_WORK_CALLBACK pfnwk
2=PVOID pv
3=PTP_CALLBACK_ENVIRON pcbe
ParamCount=3
@=CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
[SubmitThreadpoolWork]
1=PTP_WORK pwk
ParamCount=1
@=SubmitThreadpoolWork(PTP_WORK pwk);
[WaitForThreadpoolWorkCallbacks]
1=PTP_WORK pwk
2=BOOL fCancelPendingCallbacks
ParamCount=2
@=WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks);
[CloseThreadpoolWork]
1=PTP_WORK pwk
ParamCount=1
@=CloseThreadpoolWork(PTP_WORK pwk);
[CreateThreadpoolTimer]
1=PTP_TIMER_CALLBACK pfnti
2=PVOID pv
3=PTP_CALLBACK_ENVIRON pcbe
ParamCount=3
@=CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
[SetThreadpoolTimer]
1=PTP_TIMER pti
2=PFILETIME pftDueTime
3=DWORD msPeriod
4=DWORD msWindowLength
ParamCount=4
@=SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength);
[IsThreadpoolTimerSet]
1=PTP_TIMER pti
ParamCount=1
@=IsThreadpoolTimerSet(PTP_TIMER pti);
[WaitForThreadpoolTimerCallbacks]
1=PTP_TIMER pti
2=BOOL fCancelPendingCallbacks
ParamCount=2
@=WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks);
[CloseThreadpoolTimer]
1=PTP_TIMER pti
ParamCount=1
@=CloseThreadpoolTimer(PTP_TIMER pti);
[CreateThreadpoolWait]
1=PTP_WAIT_CALLBACK pfnwa
2=PVOID pv
3=PTP_CALLBACK_ENVIRON pcbe
ParamCount=3
@=CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
[SetThreadpoolWait]
1=PTP_WAIT pwa
2=HANDLE h
3=PFILETIME pftTimeout
ParamCount=3
@=SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout);
[WaitForThreadpoolWaitCallbacks]
1=PTP_WAIT pwa
2=BOOL fCancelPendingCallbacks
ParamCount=2
@=WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks);
[CloseThreadpoolWait]
1=PTP_WAIT pwa
ParamCount=1
@=CloseThreadpoolWait(PTP_WAIT pwa);
[CreateThreadpoolIo]
1=HANDLE fl
2=PTP_WIN32_IO_CALLBACK pfnio
3=PVOID pv
4=PTP_CALLBACK_ENVIRON pcbe
ParamCount=4
@=CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
[StartThreadpoolIo]
1=PTP_IO pio
ParamCount=1
@=StartThreadpoolIo(PTP_IO pio);
[CancelThreadpoolIo]
1=PTP_IO pio
ParamCount=1
@=CancelThreadpoolIo(PTP_IO pio);
[WaitForThreadpoolIoCallbacks]
1=PTP_IO pio
2=BOOL fCancelPendingCallbacks
ParamCount=2
@=WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks);
[CloseThreadpoolIo]
1=PTP_IO pio
ParamCount=1
@=CloseThreadpoolIo(PTP_IO pio);
[CreatePrivateNamespaceA]
1=LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes
2=LPVOID lpBoundaryDescriptor
3=LPCSTR lpAliasPrefix
ParamCount=3
@=CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix);
[CreatePrivateNamespaceW]
1=LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes
2=LPVOID lpBoundaryDescriptor
3=LPCWSTR lpAliasPrefix
ParamCount=3
@=CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix);
[OpenPrivateNamespaceA]
1=LPVOID lpBoundaryDescriptor
2=LPCSTR lpAliasPrefix
ParamCount=2
@=OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix);
[OpenPrivateNamespaceW]
1=LPVOID lpBoundaryDescriptor
2=LPCWSTR lpAliasPrefix
ParamCount=2
@=OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix);
[ClosePrivateNamespace]
1=HANDLE Handle
2=ULONG Flags
ParamCount=2
@=ClosePrivateNamespace(HANDLE Handle, ULONG Flags);
[CreateBoundaryDescriptorA]
1=LPCSTR Name
2=ULONG Flags
ParamCount=2
@=CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags);
[CreateBoundaryDescriptorW]
1=LPCWSTR Name
2=ULONG Flags
ParamCount=2
@=CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags);
[AddSIDToBoundaryDescriptor]
1=HANDLE *BoundaryDescriptor
2=PSID RequiredSid
ParamCount=2
@=AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid);
[AddIntegrityLabelToBoundaryDescriptor]
1=HANDLE *BoundaryDescriptor
2=PSID IntegrityLabel
ParamCount=2
@=AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel);
[DeleteBoundaryDescriptor]
1=HANDLE BoundaryDescriptor
ParamCount=1
@=DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor);
[GetCurrentHwProfileA]
1=LPHW_PROFILE_INFOA lpHwProfileInfo
ParamCount=1
@=GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo);
[GetCurrentHwProfileW]
1=LPHW_PROFILE_INFOW lpHwProfileInfo
ParamCount=1
@=GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo);
[QueryPerformanceCounter]
1=LARGE_INTEGER *lpPerformanceCount
ParamCount=1
@=QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
[QueryPerformanceFrequency]
1=LARGE_INTEGER *lpFrequency
ParamCount=1
@=QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);
[GetVersionExA]
1=LPOSVERSIONINFOA lpVersionInformation
ParamCount=1
@=GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
[GetVersionExW]
1=LPOSVERSIONINFOW lpVersionInformation
ParamCount=1
@=GetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
[VerifyVersionInfoA]
1=LPOSVERSIONINFOEXA lpVersionInformation
2=DWORD dwTypeMask
3=DWORDLONG dwlConditionMask
ParamCount=3
@=VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
[VerifyVersionInfoW]
1=LPOSVERSIONINFOEXW lpVersionInformation
2=DWORD dwTypeMask
3=DWORDLONG dwlConditionMask
ParamCount=3
@=VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
[GetProductInfo]
1=DWORD dwOSMajorVersion
2=DWORD dwOSMinorVersion
3=DWORD dwSpMajorVersion
4=DWORD dwSpMinorVersion
5=PDWORD pdwReturnedProductType
ParamCount=5
@=GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType);
[GetSystemPowerStatus]
1=LPSYSTEM_POWER_STATUS lpSystemPowerStatus
ParamCount=1
@=GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus);
[SetSystemPowerState]
1=BOOL fSuspend
2=BOOL fForce
ParamCount=2
@=SetSystemPowerState(BOOL fSuspend, BOOL fForce);
[AllocateUserPhysicalPages]
1=HANDLE hProcess
2=PULONG_PTR NumberOfPages
3=PULONG_PTR PageArray
ParamCount=3
@=AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray);
[AllocateUserPhysicalPagesNuma]
1=HANDLE hProcess
2=PULONG_PTR NumberOfPages
3=PULONG_PTR PageArray
4=DWORD nndPreferred
ParamCount=4
@=AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred);
[FreeUserPhysicalPages]
1=HANDLE hProcess
2=PULONG_PTR NumberOfPages
3=PULONG_PTR PageArray
ParamCount=3
@=FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray);
[MapUserPhysicalPages]
1=PVOID VirtualAddress
2=ULONG_PTR NumberOfPages
3=PULONG_PTR PageArray
ParamCount=3
@=MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray);
[MapUserPhysicalPagesScatter]
1=PVOID *VirtualAddresses
2=ULONG_PTR NumberOfPages
3=PULONG_PTR PageArray
ParamCount=3
@=MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray);
[CreateJobObjectA]
1=LPSECURITY_ATTRIBUTES lpJobAttributes
2=LPCSTR lpName
ParamCount=2
@=CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName);
[CreateJobObjectW]
1=LPSECURITY_ATTRIBUTES lpJobAttributes
2=LPCWSTR lpName
ParamCount=2
@=CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName);
[OpenJobObjectA]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCSTR lpName
ParamCount=3
@=OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
[OpenJobObjectW]
1=DWORD dwDesiredAccess
2=BOOL bInheritHandle
3=LPCWSTR lpName
ParamCount=3
@=OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
[AssignProcessToJobObject]
1=HANDLE hJob
2=HANDLE hProcess
ParamCount=2
@=AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess);
[TerminateJobObject]
1=HANDLE hJob
2=UINT uExitCode
ParamCount=2
@=TerminateJobObject(HANDLE hJob, UINT uExitCode);
[QueryInformationJobObject]
1=HANDLE hJob
2=JOBOBJECTINFOCLASS JobObjectInformationClass
3=LPVOID lpJobObjectInformation
4=DWORD cbJobObjectInformationLength
5=LPDWORD lpReturnLength
ParamCount=5
@=QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength);
[SetInformationJobObject]
1=HANDLE hJob
2=JOBOBJECTINFOCLASS JobObjectInformationClass
3=LPVOID lpJobObjectInformation
4=DWORD cbJobObjectInformationLength
ParamCount=4
@=SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength);
[IsProcessInJob]
1=HANDLE ProcessHandle
2=HANDLE JobHandle
3=PBOOL Result
ParamCount=3
@=IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result);
[CreateJobSet]
1=ULONG NumJob
2=PJOB_SET_ARRAY UserJobSet
3=ULONG Flags
ParamCount=3
@=CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);
[AddVectoredExceptionHandler]
1=ULONG First
2=PVECTORED_EXCEPTION_HANDLER Handler
ParamCount=2
@=AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);
[RemoveVectoredExceptionHandler]
1=PVOID Handle
ParamCount=1
@=RemoveVectoredExceptionHandler(PVOID Handle);
[AddVectoredContinueHandler]
1=ULONG First
2=PVECTORED_EXCEPTION_HANDLER Handler
ParamCount=2
@=AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);
[RemoveVectoredContinueHandler]
1=PVOID Handle
ParamCount=1
@=RemoveVectoredContinueHandler(PVOID Handle);
[FindFirstVolumeA]
1=LPSTR lpszVolumeName
2=DWORD cchBufferLength
ParamCount=2
@=FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength);
[FindFirstVolumeW]
1=LPWSTR lpszVolumeName
2=DWORD cchBufferLength
ParamCount=2
@=FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength);
[FindNextVolumeA]
1=HANDLE hFindVolume
2=LPSTR lpszVolumeName
3=DWORD cchBufferLength
ParamCount=3
@=FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength);
[FindNextVolumeW]
1=HANDLE hFindVolume
2=LPWSTR lpszVolumeName
3=DWORD cchBufferLength
ParamCount=3
@=FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
[FindVolumeClose]
1=HANDLE hFindVolume
ParamCount=1
@=FindVolumeClose(HANDLE hFindVolume);
[FindFirstVolumeMountPointA]
1=LPCSTR lpszRootPathName
2=LPSTR lpszVolumeMountPoint
3=DWORD cchBufferLength
ParamCount=3
@=FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength);
[FindFirstVolumeMountPointW]
1=LPCWSTR lpszRootPathName
2=LPWSTR lpszVolumeMountPoint
3=DWORD cchBufferLength
ParamCount=3
@=FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength);
[FindNextVolumeMountPointA]
1=HANDLE hFindVolumeMountPoint
2=LPSTR lpszVolumeMountPoint
3=DWORD cchBufferLength
ParamCount=3
@=FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength);
[FindNextVolumeMountPointW]
1=HANDLE hFindVolumeMountPoint
2=LPWSTR lpszVolumeMountPoint
3=DWORD cchBufferLength
ParamCount=3
@=FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength);
[FindVolumeMountPointClose]
1=HANDLE hFindVolumeMountPoint
ParamCount=1
@=FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint);
[SetVolumeMountPointA]
1=LPCSTR lpszVolumeMountPoint
2=LPCSTR lpszVolumeName
ParamCount=2
@=SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName);
[SetVolumeMountPointW]
1=LPCWSTR lpszVolumeMountPoint
2=LPCWSTR lpszVolumeName
ParamCount=2
@=SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);
[DeleteVolumeMountPointA]
1=LPCSTR lpszVolumeMountPoint
ParamCount=1
@=DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint);
[DeleteVolumeMountPointW]
1=LPCWSTR lpszVolumeMountPoint
ParamCount=1
@=DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint);
[GetVolumeNameForVolumeMountPointA]
1=LPCSTR lpszVolumeMountPoint
2=LPSTR lpszVolumeName
3=DWORD cchBufferLength
ParamCount=3
@=GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength);
[GetVolumeNameForVolumeMountPointW]
1=LPCWSTR lpszVolumeMountPoint
2=LPWSTR lpszVolumeName
3=DWORD cchBufferLength
ParamCount=3
@=GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength);
[GetVolumePathNameA]
1=LPCSTR lpszFileName
2=LPSTR lpszVolumePathName
3=DWORD cchBufferLength
ParamCount=3
@=GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength);
[GetVolumePathNameW]
1=LPCWSTR lpszFileName
2=LPWSTR lpszVolumePathName
3=DWORD cchBufferLength
ParamCount=3
@=GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength);
[GetVolumePathNamesForVolumeNameA]
1=LPCSTR lpszVolumeName
2=LPCH lpszVolumePathNames
3=DWORD cchBufferLength
4=PDWORD lpcchReturnLength
ParamCount=4
@=GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
[GetVolumePathNamesForVolumeNameW]
1=LPCWSTR lpszVolumeName
2=LPWCH lpszVolumePathNames
3=DWORD cchBufferLength
4=PDWORD lpcchReturnLength
ParamCount=4
@=GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
[CreateActCtxA]
1=PCACTCTXA pActCtx
ParamCount=1
@=CreateActCtxA(PCACTCTXA pActCtx);
[CreateActCtxW]
1=PCACTCTXW pActCtx
ParamCount=1
@=CreateActCtxW(PCACTCTXW pActCtx);
[AddRefActCtx]
1=HANDLE hActCtx
ParamCount=1
@=AddRefActCtx(HANDLE hActCtx);
[ReleaseActCtx]
1=HANDLE hActCtx
ParamCount=1
@=ReleaseActCtx(HANDLE hActCtx);
[ZombifyActCtx]
1=HANDLE hActCtx
ParamCount=1
@=ZombifyActCtx(HANDLE hActCtx);
[ActivateActCtx]
1=HANDLE hActCtx
2=ULONG_PTR *lpCookie
ParamCount=2
@=ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie);
[DeactivateActCtx]
1=DWORD dwFlags
2=ULONG_PTR ulCookie
ParamCount=2
@=DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);
[GetCurrentActCtx]
1=HANDLE *lphActCtx
ParamCount=1
@=GetCurrentActCtx(HANDLE *lphActCtx);
[FindActCtxSectionStringA]
1=DWORD dwFlags
2=GUID *lpExtensionGuid
3=ULONG ulSectionId
4=LPCSTR lpStringToFind
5=PACTCTX_SECTION_KEYED_DATA ReturnedData
ParamCount=5
@=FindActCtxSectionStringA(DWORD dwFlags, GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
[FindActCtxSectionStringW]
1=DWORD dwFlags
2=GUID *lpExtensionGuid
3=ULONG ulSectionId
4=LPCWSTR lpStringToFind
5=PACTCTX_SECTION_KEYED_DATA ReturnedData
ParamCount=5
@=FindActCtxSectionStringW(DWORD dwFlags, GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
[FindActCtxSectionGuid]
1=DWORD dwFlags
2=GUID *lpExtensionGuid
3=ULONG ulSectionId
4=GUID *lpGuidToFind
5=PACTCTX_SECTION_KEYED_DATA ReturnedData
ParamCount=5
@=FindActCtxSectionGuid(DWORD dwFlags, GUID *lpExtensionGuid, ULONG ulSectionId, GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
[QueryActCtxW]
1=DWORD dwFlags
2=HANDLE hActCtx
3=PVOID pvSubInstance
4=ULONG ulInfoClass
5=PVOID pvBuffer
6=SIZE_T cbBuffer
7=SIZE_T *pcbWrittenOrRequired
ParamCount=7
@=QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired);
[ProcessIdToSessionId]
1=DWORD dwProcessId
2=DWORD *pSessionId
ParamCount=2
@=ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId);
[WTSGetActiveConsoleSessionId]
ParamCount=0
@=WTSGetActiveConsoleSessionId();
[IsWow64Process]
1=HANDLE hProcess
2=PBOOL Wow64Process
ParamCount=2
@=IsWow64Process(HANDLE hProcess, PBOOL Wow64Process);
[GetLogicalProcessorInformation]
1=PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer
2=PDWORD ReturnedLength
ParamCount=2
@=GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength);
[GetLogicalProcessorInformationEx]
1=LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType
2=PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer
3=PDWORD ReturnedLength
ParamCount=3
@=GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength);
[GetActiveProcessorGroupCount]
ParamCount=0
@=GetActiveProcessorGroupCount();
[GetMaximumProcessorGroupCount]
ParamCount=0
@=GetMaximumProcessorGroupCount();
[GetActiveProcessorCount]
1=WORD GroupNumber
ParamCount=1
@=GetActiveProcessorCount(WORD GroupNumber);
[GetMaximumProcessorCount]
1=WORD GroupNumber
ParamCount=1
@=GetMaximumProcessorCount(WORD GroupNumber);
[GetNumaHighestNodeNumber]
1=PULONG HighestNodeNumber
ParamCount=1
@=GetNumaHighestNodeNumber(PULONG HighestNodeNumber);
[GetNumaProcessorNode]
1=UCHAR Processor
2=PUCHAR NodeNumber
ParamCount=2
@=GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber);
[GetNumaNodeNumberFromHandle]
1=HANDLE hFile
2=PUSHORT NodeNumber
ParamCount=2
@=GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber);
[GetNumaProcessorNodeEx]
1=PPROCESSOR_NUMBER Processor
2=PUSHORT NodeNumber
ParamCount=2
@=GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber);
[GetNumaNodeProcessorMask]
1=UCHAR Node
2=PULONGLONG ProcessorMask
ParamCount=2
@=GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask);
[GetNumaNodeProcessorMaskEx]
1=USHORT Node
2=PGROUP_AFFINITY ProcessorMask
ParamCount=2
@=GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask);
[GetNumaAvailableMemoryNode]
1=UCHAR Node
2=PULONGLONG AvailableBytes
ParamCount=2
@=GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes);
[GetNumaAvailableMemoryNodeEx]
1=USHORT Node
2=PULONGLONG AvailableBytes
ParamCount=2
@=GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes);
[GetNumaProximityNode]
1=ULONG ProximityId
2=PUCHAR NodeNumber
ParamCount=2
@=GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber);
[GetNumaProximityNodeEx]
1=ULONG ProximityId
2=PUSHORT NodeNumber
ParamCount=2
@=GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber);
[RegisterApplicationRecoveryCallback]
1=APPLICATION_RECOVERY_CALLBACK pRecoveyCallback
2=PVOID pvParameter
3=DWORD dwPingInterval
4=DWORD dwFlags
ParamCount=4
@=RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags);
[UnregisterApplicationRecoveryCallback]
ParamCount=0
@=UnregisterApplicationRecoveryCallback();
[RegisterApplicationRestart]
1=PCWSTR pwzCommandline
2=DWORD dwFlags
ParamCount=2
@=RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags);
[UnregisterApplicationRestart]
ParamCount=0
@=UnregisterApplicationRestart();
[GetApplicationRecoveryCallback]
1=HANDLE hProcess
2=APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback
3=PVOID* ppvParameter
4=PDWORD pdwPingInterval
5=PDWORD pdwFlags
ParamCount=5
@=GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback, PVOID* ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags);
[GetApplicationRestartSettings]
1=HANDLE hProcess
2=PWSTR pwzCommandline
3=PDWORD pcchSize
4=PDWORD pdwFlags
ParamCount=4
@=GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags);
[ApplicationRecoveryInProgress]
1=PBOOL pbCancelled
ParamCount=1
@=ApplicationRecoveryInProgress(PBOOL pbCancelled);
[ApplicationRecoveryFinished]
1=BOOL bSuccess
ParamCount=1
@=ApplicationRecoveryFinished(BOOL bSuccess);
[SetFileInformationByHandle]
1=HANDLE hFile
2=FILE_INFO_BY_HANDLE_CLASS FileInformationClass
3=LPVOID lpFileInformation
4=DWORD dwBufferSize
ParamCount=4
@=SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
[GetFileInformationByHandleEx]
1=HANDLE hFile
2=FILE_INFO_BY_HANDLE_CLASS FileInformationClass
3=LPVOID lpFileInformation
4=DWORD dwBufferSize
ParamCount=4
@=GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
[OpenFileById]
1=HANDLE hVolumeHint
2=LPFILE_ID_DESCRIPTOR lpFileId
3=DWORD dwDesiredAccess
4=DWORD dwShareMode
5=LPSECURITY_ATTRIBUTES lpSecurityAttributes
6=DWORD dwFlagsAndAttributes
ParamCount=6
@=OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes);
[CreateSymbolicLinkA]
1=LPCSTR lpSymlinkFileName
2=LPCSTR lpTargetFileName
3=DWORD dwFlags
ParamCount=3
@=CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags);
[CreateSymbolicLinkW]
1=LPCWSTR lpSymlinkFileName
2=LPCWSTR lpTargetFileName
3=DWORD dwFlags
ParamCount=3
@=CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags);
[CreateSymbolicLinkTransactedA]
1=LPCSTR lpSymlinkFileName
2=LPCSTR lpTargetFileName
3=DWORD dwFlags
4=HANDLE hTransaction
ParamCount=4
@=CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction);
[CreateSymbolicLinkTransactedW]
1=LPCWSTR lpSymlinkFileName
2=LPCWSTR lpTargetFileName
3=DWORD dwFlags
4=HANDLE hTransaction
ParamCount=4
@=CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction);
[GetFinalPathNameByHandleA]
1=HANDLE hFile
2=LPSTR lpszFilePath
3=DWORD cchFilePath
4=DWORD dwFlags
ParamCount=4
@=GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
[GetFinalPathNameByHandleW]
1=HANDLE hFile
2=LPWSTR lpszFilePath
3=DWORD cchFilePath
4=DWORD dwFlags
ParamCount=4
@=GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
[QueryActCtxSettingsW]
1=DWORD dwFlags
2=HANDLE hActCtx
3=PCWSTR settingsNameSpace
4=PCWSTR settingName
5=PWSTR pvBuffer
6=SIZE_T dwBuffer
7=SIZE_T *pdwWrittenOrRequired
ParamCount=7
@=QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired);
[ReplacePartitionUnit]
1=PWSTR TargetPartition
2=PWSTR SparePartition
3=ULONG Flags
ParamCount=3
@=ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags);
[AddSecureMemoryCacheCallback]
1=ULONG PSECURE_MEMORY_CACHE_CALLBACKpfnCallBack
ParamCount=1
@=AddSecureMemoryCacheCallback(ULONG PSECURE_MEMORY_CACHE_CALLBACKpfnCallBack);
[RemoveSecureMemoryCacheCallback]
1=ULONG PSECURE_MEMORY_CACHE_CALLBACKpfnCallBack
ParamCount=1
@=RemoveSecureMemoryCacheCallback(ULONG PSECURE_MEMORY_CACHE_CALLBACKpfnCallBack);
[CopyExtendedContext]
1=PCONTEXT_EX Destination
2=DWORD ContextFlags
3=PCONTEXT_EX Source
ParamCount=3
@=CopyExtendedContext(PCONTEXT_EX Destination, DWORD ContextFlags, PCONTEXT_EX Source);
[InitializeExtendedContext]
1=PVOID Context
2=DWORD ContextFlags
3=PCONTEXT_EX* ContextEx
ParamCount=3
@=InitializeExtendedContext(PVOID Context, DWORD ContextFlags, PCONTEXT_EX* ContextEx);
[GetEnabledExtendedFeatures]
1=DWORD64 FeatureMask
ParamCount=1
@=GetEnabledExtendedFeatures(DWORD64 FeatureMask);
[GetExtendedContextLength]
1=DWORD ContextFlags
2=PDWORD ContextLength
ParamCount=2
@=GetExtendedContextLength(DWORD ContextFlags, PDWORD ContextLength);
[GetExtendedFeaturesMask]
1=PCONTEXT_EX ContextEx
ParamCount=1
@=GetExtendedFeaturesMask(PCONTEXT_EX ContextEx);
[LocateExtendedFeature]
1=PCONTEXT_EX ContextEx
2=DWORD FeatureId
3=PDWORD Length
ParamCount=3
@=LocateExtendedFeature(PCONTEXT_EX ContextEx, DWORD FeatureId, PDWORD Length);
[LocateLegacyContext]
1=PCONTEXT_EX ContextEx
2=PDWORD Length
ParamCount=2
@=LocateLegacyContext(PCONTEXT_EX ContextEx, PDWORD Length);
[SetExtendedFeaturesMask]
1=PCONTEXT_EX ContextEx
2=DWORD64 FeatureMask
ParamCount=2
@=SetExtendedFeaturesMask(PCONTEXT_EX ContextEx, DWORD64 FeatureMask);
[EnableThreadProfiling]
1=HANDLE ThreadHandle
2=DWORD Flags
3=DWORD64 HardwareCounters
4=HANDLE *PerformanceDataHandle
ParamCount=4
@=EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle);
[DisableThreadProfiling]
1=HANDLE PerformanceDataHandle
ParamCount=1
@=DisableThreadProfiling(HANDLE PerformanceDataHandle);
[QueryThreadProfiling]
1=HANDLE ThreadHandle
2=PBOOLEAN Enabled
ParamCount=2
@=QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled);
[ReadThreadProfilingData]
1=HANDLE PerformanceDataHandle
2=DWORD Flags
3=PPERFORMANCE_DATA PerformanceData
ParamCount=3
@=ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData);



================================================
File: api-definitions/ntdll.api
================================================
[NtdllDefWindowProc_A]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=NtdllDefWindowProc_A(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[NtdllDefWindowProc_W]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=NtdllDefWindowProc_W(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[NtdllDefWindowProc]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=NtdllDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[DefWindowProcA]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[DefWindowProcW]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[PostQuitMessage]
1=int nExitCode
ParamCount=1
@=PostQuitMessage(int nExitCode);
[Int64ShllMod32]
1=ULONGLONG Value
2=DWORD ShiftCount
ParamCount=2
@=Int64ShllMod32(ULONGLONG Value, DWORD ShiftCount);
[Int64ShraMod32]
1=LONGLONG Value
2=DWORD ShiftCount
ParamCount=2
@=Int64ShraMod32(LONGLONG Value, DWORD ShiftCount);
[Int64ShrlMod32]
1=ULONGLONG Value
2=DWORD ShiftCount
ParamCount=2
@=Int64ShrlMod32(ULONGLONG Value, DWORD ShiftCount);
[EXCEPTION_ROUTINE]
1=_EXCEPTION_RECORD *ExceptionRecord
2=PVOID EstablisherFrame
3=_CONTEXT *ContextRecord
4=PVOID DispatcherContext
ParamCount=4
@=EXCEPTION_ROUTINE(_EXCEPTION_RECORD *ExceptionRecord, PVOID EstablisherFrame, _CONTEXT *ContextRecord, PVOID DispatcherContext);
[RtlLookupFunctionEntry]
1=ULONGLONG ControlPc
2=PULONGLONG ImageBase
3=PULONGLONG TargetGp
ParamCount=3
@=RtlLookupFunctionEntry(ULONGLONG ControlPc, PULONGLONG ImageBase, PULONGLONG TargetGp);
[RtlVirtualUnwind]
1=ULONGLONG ImageBase
2=ULONGLONG ControlPc
3=PRUNTIME_FUNCTION FunctionEntry
4=PCONTEXT ContextRecord
5=PBOOLEAN InFunction
6=PFRAME_POINTERS EstablisherFrame
7=PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
8=PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
ParamCount=7
@=RtlVirtualUnwind(ULONGLONG ImageBase, ULONGLONG ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PBOOLEAN InFunction, PFRAME_POINTERS EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
[RtlAddFunctionTable]
1=PRUNTIME_FUNCTION FunctionTable
2=DWORD EntryCount
3=ULONGLONG BaseAddress
4=ULONGLONG TargetGp
ParamCount=4
@=RtlAddFunctionTable(PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, ULONGLONG BaseAddress, ULONGLONG TargetGp);
[RtlInstallFunctionTableCallback]
1=DWORD64 TableIdentifier
2=DWORD64 BaseAddress
3=DWORD Length
4=DWORD64 TargetGp
5=PGET_RUNTIME_FUNCTION_CALLBACK Callback
6=PVOID Context
7=PCWSTR OutOfProcessCallbackDll
ParamCount=7
@=RtlInstallFunctionTableCallback(DWORD64 TableIdentifier, DWORD64 BaseAddress, DWORD Length, DWORD64 TargetGp, PGET_RUNTIME_FUNCTION_CALLBACK Callback, PVOID Context, PCWSTR OutOfProcessCallbackDll);
[RtlDeleteFunctionTable]
1=PRUNTIME_FUNCTION FunctionTable
ParamCount=1
@=RtlDeleteFunctionTable(PRUNTIME_FUNCTION FunctionTable);
[RtlRestoreContext]
1=PCONTEXT ContextRecord
2=_EXCEPTION_RECORD *ExceptionRecord
ParamCount=2
@=RtlRestoreContext(PCONTEXT ContextRecord, _EXCEPTION_RECORD *ExceptionRecord);
[__jump_unwind]
1=ULONGLONG TargetMsFrame
2=ULONGLONG TargetBsFrame
3=ULONGLONG TargetPc
ParamCount=3
@=__jump_unwind(ULONGLONG TargetMsFrame, ULONGLONG TargetBsFrame, ULONGLONG TargetPc);
[RtlUnwind]
1=PVOID TargetFrame
2=PVOID TargetIp
3=PEXCEPTION_RECORD ExceptionRecord
4=PVOID ReturnValue
ParamCount=4
@=RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
[RtlUnwind2]
1=FRAME_POINTERS TargetFrame
2=PVOID TargetIp
3=PEXCEPTION_RECORD ExceptionRecord
4=PVOID ReturnValue
5=PCONTEXT ContextRecord
ParamCount=5
@=RtlUnwind2(FRAME_POINTERS TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord);
[RtlUnwindEx]
1=FRAME_POINTERS TargetFrame
2=PVOID TargetIp
3=PEXCEPTION_RECORD ExceptionRecord
4=PVOID ReturnValue
5=PCONTEXT ContextRecord
6=PUNWIND_HISTORY_TABLE HistoryTable
ParamCount=6
@=RtlUnwindEx(FRAME_POINTERS TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable);
[RtlInitializeSListHead]
1=PSLIST_HEADER ListHead
ParamCount=1
@=RtlInitializeSListHead(PSLIST_HEADER ListHead);
[RtlFirstEntrySList]
1=SLIST_HEADER *ListHead
ParamCount=1
@=RtlFirstEntrySList(SLIST_HEADER *ListHead);
[RtlInterlockedPopEntrySList]
1=PSLIST_HEADER ListHead
ParamCount=1
@=RtlInterlockedPopEntrySList(PSLIST_HEADER ListHead);
[RtlInterlockedPushEntrySList]
1=PSLIST_HEADER ListHead
2=PSLIST_HEADER PSLIST_ENTRYListEntry
ParamCount=2
@=RtlInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_HEADER PSLIST_ENTRYListEntry);
[RtlInterlockedFlushSList]
1=PSLIST_HEADER ListHead
ParamCount=1
@=RtlInterlockedFlushSList(PSLIST_HEADER ListHead);
[RtlQueryDepthSList]
1=PSLIST_HEADER ListHead
ParamCount=1
@=RtlQueryDepthSList(PSLIST_HEADER ListHead);
[RtlInterlockedPopEntrySList32]
1=PSLIST_HEADER32 ListHead
ParamCount=1
@=RtlInterlockedPopEntrySList32(PSLIST_HEADER32 ListHead);
[RTL_RUN_ONCE_INIT_FN]
1=PRTL_RUN_ONCE RunOnce
2=PVOID Parameter
3=PVOID *Context
ParamCount=3
@=RTL_RUN_ONCE_INIT_FN(PRTL_RUN_ONCE RunOnce, PVOID Parameter, PVOID *Context);
[RtlRunOnceInitialize]
1=PRTL_RUN_ONCE RunOnce
ParamCount=1
@=RtlRunOnceInitialize(PRTL_RUN_ONCE RunOnce);
[RtlRunOnceExecuteOnce]
1=PRTL_RUN_ONCE RunOnce
2=PRTL_RUN_ONCE PRTL_RUN_ONCE_INIT_FNInitFn
3=PVOID Parameter
4=PVOID *Context
ParamCount=4
@=RtlRunOnceExecuteOnce(PRTL_RUN_ONCE RunOnce, PRTL_RUN_ONCE PRTL_RUN_ONCE_INIT_FNInitFn, PVOID Parameter, PVOID *Context);
[RtlRunOnceBeginInitialize]
1=PRTL_RUN_ONCE RunOnce
2=DWORD Flags
3=PVOID *Context
ParamCount=3
@=RtlRunOnceBeginInitialize(PRTL_RUN_ONCE RunOnce, DWORD Flags, PVOID *Context);
[RtlRunOnceComplete]
1=PRTL_RUN_ONCE RunOnce
2=DWORD Flags
3=PVOID Context
ParamCount=3
@=RtlRunOnceComplete(PRTL_RUN_ONCE RunOnce, DWORD Flags, PVOID Context);
[RtlCaptureStackBackTrace]
1=DWORD FramesToSkip
2=DWORD FramesToCapture
3=PVOID *BackTrace
4=PDWORD BackTraceHash
ParamCount=4
@=RtlCaptureStackBackTrace(DWORD FramesToSkip, DWORD FramesToCapture, PVOID *BackTrace, PDWORD BackTraceHash);
[RtlCaptureContext]
1=PCONTEXT ContextRecord
ParamCount=1
@=RtlCaptureContext(PCONTEXT ContextRecord);
[RtlCompareMemory]
1=VOID *Source1
2=VOID *Source2
3=SIZE_T Length
ParamCount=3
@=RtlCompareMemory(VOID *Source1, VOID *Source2, SIZE_T Length);
[RtlPcToFileHeader]
1=PVOID PcValue
2=PVOID *BaseOfImage
ParamCount=2
@=RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage);
[VerSetConditionMask]
1=ULONGLONG ConditionMask
2=DWORD TypeMask
3=BYTE Condition
ParamCount=3
@=VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);
[RtlGetProductInfo]
1=DWORD OSMajorVersion
2=DWORD OSMinorVersion
3=DWORD SpMajorVersion
4=DWORD SpMinorVersion
5=PDWORD ReturnedProductType
ParamCount=5
@=RtlGetProductInfo(DWORD OSMajorVersion, DWORD OSMinorVersion, DWORD SpMajorVersion, DWORD SpMinorVersion, PDWORD ReturnedProductType);
[RTL_UMS_SCHEDULER_ENTRY_POINT]
1=RTL_UMS_SCHEDULER_REASON Reason
2=ULONG_PTR ActivationPayload
3=PVOID SchedulerParam
ParamCount=3
@=RTL_UMS_SCHEDULER_ENTRY_POINT(RTL_UMS_SCHEDULER_REASON Reason, ULONG_PTR ActivationPayload, PVOID SchedulerParam);
[RtlCopyExtendedContext]
1=PCONTEXT_EX Destination
2=DWORD ContextFlags
3=PCONTEXT_EX Source
ParamCount=3
@=RtlCopyExtendedContext(PCONTEXT_EX Destination, DWORD ContextFlags, PCONTEXT_EX Source);
[RtlInitializeExtendedContext]
1=PVOID Context
2=DWORD ContextFlags
3=PCONTEXT_EX* ContextEx
ParamCount=3
@=RtlInitializeExtendedContext(PVOID Context, DWORD ContextFlags, PCONTEXT_EX* ContextEx);
[RtlGetEnabledExtendedFeatures]
1=DWORD64 FeatureMask
ParamCount=1
@=RtlGetEnabledExtendedFeatures(DWORD64 FeatureMask);
[RtlGetExtendedContextLength]
1=DWORD ContextFlags
2=PDWORD ContextLength
ParamCount=2
@=RtlGetExtendedContextLength(DWORD ContextFlags, PDWORD ContextLength);
[RtlGetExtendedFeaturesMask]
1=PCONTEXT_EX ContextEx
ParamCount=1
@=RtlGetExtendedFeaturesMask(PCONTEXT_EX ContextEx);
[RtlLocateExtendedFeature]
1=PCONTEXT_EX ContextEx
2=DWORD FeatureId
3=PDWORD Length
ParamCount=3
@=RtlLocateExtendedFeature(PCONTEXT_EX ContextEx, DWORD FeatureId, PDWORD Length);
[RtlLocateLegacyContext]
1=PCONTEXT_EX ContextEx
2=PDWORD Length
ParamCount=2
@=RtlLocateLegacyContext(PCONTEXT_EX ContextEx, PDWORD Length);
[RtlSetExtendedFeaturesMask]
1=PCONTEXT_EX ContextEx
2=DWORD64 FeatureMask
ParamCount=2
@=RtlSetExtendedFeaturesMask(PCONTEXT_EX ContextEx, DWORD64 FeatureMask);
[NtClose]
1=HANDLE Handle
ParamCount=1
@=NtClose(HANDLE Handle);
[NtCreateFile]
1=OUT PHANDLEFileHandle
2=ACCESS_MASK DesiredAccess
3=POBJECT_ATTRIBUTES ObjectAttributes
4=IoStatusBlock
5=PLARGE_INTEGER AllocationSizeOPTIONAL
6=ULONG FileAttributes
7=ULONG ShareAccess
8=ULONG CreateDisposition
9=ULONG CreateOptions
10=PVOID EaBufferOPTIONAL
11=ULONG EaLength
ParamCount=11
@=NtCreateFile(OUT PHANDLEFileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, IoStatusBlock, PLARGE_INTEGER AllocationSizeOPTIONAL, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBufferOPTIONAL, ULONG EaLength);
[NtOpenFile]
1=OUT PHANDLEFileHandle
2=ACCESS_MASK DesiredAccess
3=POBJECT_ATTRIBUTES ObjectAttributes
4=IoStatusBlock
5=ULONG ShareAccess
6=ULONG OpenOptions
ParamCount=6
@=NtOpenFile(OUT PHANDLEFileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
[NtDeviceIoControlFile]
1=HANDLE FileHandle
2=HANDLE EventOPTIONAL
3=PIO_APC_ROUTINE ApcRoutineOPTIONAL
4=PVOID ApcContextOPTIONAL
5=IoStatusBlock
6=ULONG IoControlCode
7=PVOID InputBufferOPTIONAL
8=ULONG InputBufferLength
9=OUT PVOIDOutputBufferOPTIONAL
10=ULONG OutputBufferLength
ParamCount=10
@=NtDeviceIoControlFile(HANDLE FileHandle, HANDLE EventOPTIONAL, PIO_APC_ROUTINE ApcRoutineOPTIONAL, PVOID ApcContextOPTIONAL, IoStatusBlock, ULONG IoControlCode, PVOID InputBufferOPTIONAL, ULONG InputBufferLength, OUT PVOIDOutputBufferOPTIONAL, ULONG OutputBufferLength);
[NtWaitForSingleObject]
1=HANDLE Handle
2=BOOLEAN Alertable
3=PLARGE_INTEGER TimeoutOPTIONAL
ParamCount=3
@=NtWaitForSingleObject(HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER TimeoutOPTIONAL);
[RtlIsNameLegalDOS8Dot3]
1=PUNICODE_STRING Name
2=OUT POEM_STRINGOemNameOPTIONAL
3=OUT PBOOLEANNameContainsSpacesOPTIONAL
ParamCount=3
@=RtlIsNameLegalDOS8Dot3(PUNICODE_STRING Name, OUT POEM_STRINGOemNameOPTIONAL, OUT PBOOLEANNameContainsSpacesOPTIONAL);
[RtlNtStatusToDosError]
1=NTSTATUS Status
ParamCount=1
@=RtlNtStatusToDosError(NTSTATUS Status);
[NtQueryInformationProcess]
1=HANDLE ProcessHandle
2=PROCESSINFOCLASS ProcessInformationClass
3=OUT PVOIDProcessInformation
4=ULONG ProcessInformationLength
5=OUT PULONGReturnLengthOPTIONAL
ParamCount=5
@=NtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, OUT PVOIDProcessInformation, ULONG ProcessInformationLength, OUT PULONGReturnLengthOPTIONAL);
[NtQueryInformationThread]
1=HANDLE ThreadHandle
2=THREADINFOCLASS ThreadInformationClass
3=OUT PVOIDThreadInformation
4=ULONG ThreadInformationLength
5=OUT PULONGReturnLengthOPTIONAL
ParamCount=5
@=NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, OUT PVOIDThreadInformation, ULONG ThreadInformationLength, OUT PULONGReturnLengthOPTIONAL);
[NtQueryObject]
1=HANDLE Handle
2=OBJECT_INFORMATION_CLASS ObjectInformationClass
3=PVOID ObjectInformation
4=ULONG ObjectInformationLength
5=PULONG ReturnLength
ParamCount=5
@=NtQueryObject(HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);
[NtQuerySystemInformation]
1=SYSTEM_INFORMATION_CLASS SystemInformationClass
2=OUT PVOIDSystemInformation
3=ULONG SystemInformationLength
4=OUT PULONGReturnLengthOPTIONAL
ParamCount=4
@=NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, OUT PVOIDSystemInformation, ULONG SystemInformationLength, OUT PULONGReturnLengthOPTIONAL);
[NtQuerySystemTime]
1=SystemTime

ParamCount=1
@=NtQuerySystemTime(SystemTime
);
[RtlLocalTimeToSystemTime]
1=PLARGE_INTEGER LocalTime
2=SystemTime

ParamCount=2
@=RtlLocalTimeToSystemTime(PLARGE_INTEGER LocalTime, SystemTime
);
[RtlTimeToSecondsSince1970]
1=Time
2=PULONG ElapsedSeconds
ParamCount=2
@=RtlTimeToSecondsSince1970(Time, PULONG ElapsedSeconds);
[RtlFreeAnsiString]
1=AnsiString

ParamCount=1
@=RtlFreeAnsiString(AnsiString
);
[RtlFreeUnicodeString]
1=UnicodeString

ParamCount=1
@=RtlFreeUnicodeString(UnicodeString
);
[RtlFreeOemString]
1=OemString

ParamCount=1
@=RtlFreeOemString(OemString
);
[RtlInitString]
1=PSTRING DestinationString
2=PCSZ SourceString
ParamCount=2
@=RtlInitString(PSTRING DestinationString, PCSZ SourceString);
[RtlInitAnsiString]
1=DestinationString
2=PCSZ SourceString
ParamCount=2
@=RtlInitAnsiString(DestinationString, PCSZ SourceString);
[RtlInitUnicodeString]
1=DestinationString
2=PCWSTR SourceString
ParamCount=2
@=RtlInitUnicodeString(DestinationString, PCWSTR SourceString);
[RtlAnsiStringToUnicodeString]
1=DestinationString
2=SourceString
3=BOOLEAN AllocateDestinationString
ParamCount=3
@=RtlAnsiStringToUnicodeString(DestinationString, SourceString, BOOLEAN AllocateDestinationString);
[RtlUnicodeStringToAnsiString]
1=DestinationString
2=SourceString
3=BOOLEAN AllocateDestinationString
ParamCount=3
@=RtlUnicodeStringToAnsiString(DestinationString, SourceString, BOOLEAN AllocateDestinationString);
[RtlUnicodeStringToOemString]
1=DestinationString
2=SourceString
3=BOOLEAN AllocateDestinationString
ParamCount=3
@=RtlUnicodeStringToOemString(DestinationString, SourceString, BOOLEAN AllocateDestinationString);
[RtlUnicodeToMultiByteSize]
1=PULONG BytesInMultiByteString
2=PWCH UnicodeString
3=ULONG BytesInUnicodeString
ParamCount=3
@=RtlUnicodeToMultiByteSize(PULONG BytesInMultiByteString, PWCH UnicodeString, ULONG BytesInUnicodeString);
[RtlCharToInteger]
1=PCSZ String
2=ULONG Base
3=PULONG Value
ParamCount=3
@=RtlCharToInteger(PCSZ String, ULONG Base, PULONG Value);
[RtlConvertSidToUnicodeString]
1=UnicodeString
2=PSID Sid
3=BOOLEAN AllocateDestinationString
ParamCount=3
@=RtlConvertSidToUnicodeString(UnicodeString, PSID Sid, BOOLEAN AllocateDestinationString);
[RtlUniform]
1=PULONG Seed
ParamCount=1
@=RtlUniform(PULONG Seed);
[HalDisplayString]
1=PCHAR String
ParamCount=1
@=HalDisplayString(PCHAR String);
[HalQueryRealTimeClock]
1=OUT PTIME_FIELDSTimeFields
ParamCount=1
@=HalQueryRealTimeClock(OUT PTIME_FIELDSTimeFields);
[HalSetRealTimeClock]
1=PTIME_FIELDS TimeFields
ParamCount=1
@=HalSetRealTimeClock(PTIME_FIELDS TimeFields);
[RtlGetNtGlobalFlags]
ParamCount=0
@=RtlGetNtGlobalFlags();
[RtlImageNtHeader]
1=PVOID BaseAddress
ParamCount=1
@=RtlImageNtHeader(PVOID BaseAddress);
[RtlSetSaclSecurityDescriptor]
1=OUT PSECURITY_DESCRIPTORSecurityDescriptor
2=BOOLEAN SaclPresent
3=PACL Sacl
4=BOOLEAN SaclDefaulted
ParamCount=4
@=RtlSetSaclSecurityDescriptor(OUT PSECURITY_DESCRIPTORSecurityDescriptor, BOOLEAN SaclPresent, PACL Sacl, BOOLEAN SaclDefaulted);
[RtlMoveMemory]
1=VOID UNALIGNED *Destination
2=VOID UNALIGNED *Source
3=SIZE_T Length
ParamCount=3
@=RtlMoveMemory(VOID UNALIGNED *Destination, VOID UNALIGNED *Source, SIZE_T Length);
[RtlFillMemory]
1=VOID UNALIGNED *Destination
2=SIZE_T Length
3=UCHAR Fill
ParamCount=3
@=RtlFillMemory(VOID UNALIGNED *Destination, SIZE_T Length, UCHAR Fill);
[RtlZeroMemory]
1=VOID UNALIGNED *Destination
2=SIZE_T Length
ParamCount=2
@=RtlZeroMemory(VOID UNALIGNED *Destination, SIZE_T Length);
[ZwAdjustPrivilegesToken]
1=HANDLE TokenHandle
2=BOOLEAN DisableAllPrivileges
3=PTOKEN_PRIVILEGES NewState
4=ULONG BufferLength
5=PreviousState OPTIONAL
6=OUT PULONGReturnLength
ParamCount=6
@=ZwAdjustPrivilegesToken(HANDLE TokenHandle, BOOLEAN DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, ULONG BufferLength, PreviousState OPTIONAL, OUT PULONGReturnLength);
[ZwAlertThread]
1=HANDLE ThreadHandle
ParamCount=1
@=ZwAlertThread(HANDLE ThreadHandle);
[ZwAccessCheckAndAuditAlarm]
1=PUNICODE_STRING SubsystemName
2=PVOID HandleId
3=PUNICODE_STRING ObjectTypeName
4=PUNICODE_STRING ObjectName
5=PSECURITY_DESCRIPTOR SecurityDescriptor
6=ACCESS_MASK DesiredAccess
7=PGENERIC_MAPPING GenericMapping
8=BOOLEAN ObjectCreation
9=GrantedAccess
10=OUT PBOOLEANAccessStatus
11=OUT PBOOLEANGenerateOnClose
ParamCount=11
@=ZwAccessCheckAndAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, PUNICODE_STRING ObjectTypeName, PUNICODE_STRING ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOLEAN ObjectCreation, GrantedAccess, OUT PBOOLEANAccessStatus, OUT PBOOLEANGenerateOnClose);
[ZwCancelIoFile]
1=HANDLE FileHandle
2=IoStatusBlock

ParamCount=2
@=ZwCancelIoFile(HANDLE FileHandle, IoStatusBlock
);
[ZwClearEvent]
1=HANDLE EventHandle
ParamCount=1
@=ZwClearEvent(HANDLE EventHandle);
[ZwConnectPort]
1=OUT PHANDLEClientPortHandle
2=PUNICODE_STRING ServerPortName
3=PSECURITY_QUALITY_OF_SERVICE SecurityQos
4=OUT PLPC_SECTION_WRITEClientSharedMemoryOPTIONAL
5=OUT PLPC_SECTION_READServerSharedMemoryOPTIONAL
6=OUT PULONGMaximumMessageLengthOPTIONAL
7=OUT PVOIDConnectionInfoOPTIONAL
8=OUT PULONGConnectionInfoLengthOPTIONAL
ParamCount=8
@=ZwConnectPort(OUT PHANDLEClientPortHandle, PUNICODE_STRING ServerPortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, OUT PLPC_SECTION_WRITEClientSharedMemoryOPTIONAL, OUT PLPC_SECTION_READServerSharedMemoryOPTIONAL, OUT PULONGMaximumMessageLengthOPTIONAL, OUT PVOIDConnectionInfoOPTIONAL, OUT PULONGConnectionInfoLengthOPTIONAL);
[ZwCloseObjectAuditAlarm]
1=PUNICODE_STRING SubsystemName
2=PVOID HandleId
3=BOOLEAN GenerateOnClose
ParamCount=3
@=ZwCloseObjectAuditAlarm(PUNICODE_STRING SubsystemName, PVOID HandleId, BOOLEAN GenerateOnClose);
[ZwCreateSymbolicLinkObject]
1=OUT PHANDLESymbolicLinkHandle
2=ACCESS_MASK DesiredAccess
3=POBJECT_ATTRIBUTES ObjectAttributes
4=PUNICODE_STRING TargetName
ParamCount=4
@=ZwCreateSymbolicLinkObject(OUT PHANDLESymbolicLinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PUNICODE_STRING TargetName);
[ZwFlushInstructionCache]
1=HANDLE ProcessHandle
2=PVOID BaseAddressOPTIONAL
3=ULONG FlushSize
ParamCount=3
@=ZwFlushInstructionCache(HANDLE ProcessHandle, PVOID BaseAddressOPTIONAL, ULONG FlushSize);
[ZwInitiatePowerAction]
1=POWER_ACTION SystemAction
2=SYSTEM_POWER_STATE MinSystemState
3=ULONG Flags
4=BOOLEAN Asynchronous
ParamCount=4
@=ZwInitiatePowerAction(POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);
[ZwLoadKey]
1=POBJECT_ATTRIBUTES KeyObjectAttributes
2=POBJECT_ATTRIBUTES FileObjectAttributes
ParamCount=2
@=ZwLoadKey(POBJECT_ATTRIBUTES KeyObjectAttributes, POBJECT_ATTRIBUTES FileObjectAttributes);
[ZwOpenProcessToken]
1=HANDLE ProcessHandle
2=ACCESS_MASK DesiredAccess
3=OUT PHANDLETokenHandle
ParamCount=3
@=ZwOpenProcessToken(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, OUT PHANDLETokenHandle);
[ZwOpenThread]
1=OUT PHANDLEThreadHandle
2=ACCESS_MASK DesiredAccess
3=POBJECT_ATTRIBUTES ObjectAttributes
4=PCLIENT_ID ClientId
ParamCount=4
@=ZwOpenThread(OUT PHANDLEThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
[ZwOpenThreadToken]
1=HANDLE ThreadHandle
2=ACCESS_MASK DesiredAccess
3=BOOLEAN OpenAsSelf
4=OUT PHANDLETokenHandle
ParamCount=4
@=ZwOpenThreadToken(HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, OUT PHANDLETokenHandle);
[ZwPulseEvent]
1=HANDLE EventHandle
2=OUT PULONGPreviousStateOPTIONAL
ParamCount=2
@=ZwPulseEvent(HANDLE EventHandle, OUT PULONGPreviousStateOPTIONAL);
[ZwQueryDefaultLocale]
1=BOOLEAN ThreadOrSystem
2=OUT PLCIDLocale
ParamCount=2
@=ZwQueryDefaultLocale(BOOLEAN ThreadOrSystem, OUT PLCIDLocale);
[ZwQueryDefaultUILanguage]
1=OUT LANGID*LanguageId
ParamCount=1
@=ZwQueryDefaultUILanguage(OUT LANGID*LanguageId);
[ZwQueryDirectoryObject]
1=HANDLE DirectoryHandle
2=OUT PVOIDBuffer
3=ULONG Length
4=BOOLEAN ReturnSingleEntry
5=BOOLEAN RestartScan
6=OUT PULONGContext
7=OUT PULONGReturnLengthOPTIONAL
ParamCount=7
@=ZwQueryDirectoryObject(HANDLE DirectoryHandle, OUT PVOIDBuffer, ULONG Length, BOOLEAN ReturnSingleEntry, BOOLEAN RestartScan, OUT PULONGContext, OUT PULONGReturnLengthOPTIONAL);
[ZwQueryInformationProcess]
1=HANDLE ProcessHandle
2=PROCESSINFOCLASS ProcessInformationClass
3=OUT PVOIDProcessInformation
4=ULONG ProcessInformationLength
5=OUT PULONGReturnLengthOPTIONAL
ParamCount=5
@=ZwQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, OUT PVOIDProcessInformation, ULONG ProcessInformationLength, OUT PULONGReturnLengthOPTIONAL);
[ZwQueryInformationThread]
1=HANDLE ThreadHandle
2=THREADINFOCLASS ThreadInformationClass
3=OUT PVOIDThreadInformation
4=ULONG ThreadInformationLength
5=OUT PULONGReturnLengthOPTIONAL
ParamCount=5
@=ZwQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, OUT PVOIDThreadInformation, ULONG ThreadInformationLength, OUT PULONGReturnLengthOPTIONAL);
[ZwQueryInstallUILanguage]
1=OUT LANGID*LanguageId
ParamCount=1
@=ZwQueryInstallUILanguage(OUT LANGID*LanguageId);
[ZwQuerySection]
1=HANDLE SectionHandle
2=SECTION_INFORMATION_CLASS SectionInformationClass
3=OUT PVOIDSectionInformation
4=ULONG SectionInformationLength
5=OUT PULONGResultLengthOPTIONAL
ParamCount=5
@=ZwQuerySection(HANDLE SectionHandle, SECTION_INFORMATION_CLASS SectionInformationClass, OUT PVOIDSectionInformation, ULONG SectionInformationLength, OUT PULONGResultLengthOPTIONAL);
[ZwQuerySystemInformation]
1=SYSTEM_INFORMATION_CLASS SystemInformationClass
2=OUT PVOIDSystemInformation
3=ULONG Length
4=OUT PULONGReturnLength
ParamCount=4
@=ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, OUT PVOIDSystemInformation, ULONG Length, OUT PULONGReturnLength);
[ZwReplaceKey]
1=POBJECT_ATTRIBUTES NewFileObjectAttributes
2=HANDLE KeyHandle
3=POBJECT_ATTRIBUTES OldFileObjectAttributes
ParamCount=3
@=ZwReplaceKey(POBJECT_ATTRIBUTES NewFileObjectAttributes, HANDLE KeyHandle, POBJECT_ATTRIBUTES OldFileObjectAttributes);
[ZwRequestWaitReplyPort]
1=HANDLE PortHandle
2=PLPC_MESSAGE Request
3=Reply

ParamCount=3
@=ZwRequestWaitReplyPort(HANDLE PortHandle, PLPC_MESSAGE Request, Reply
);
[ZwResetEvent]
1=HANDLE EventHandle
2=OUT PULONGPreviousStateOPTIONAL
ParamCount=2
@=ZwResetEvent(HANDLE EventHandle, OUT PULONGPreviousStateOPTIONAL);
[ZwRestoreKey]
1=HANDLE KeyHandle
2=HANDLE FileHandle
3=ULONG Flags
ParamCount=3
@=ZwRestoreKey(HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);
[ZwSaveKey]
1=HANDLE KeyHandle
2=HANDLE FileHandle
ParamCount=2
@=ZwSaveKey(HANDLE KeyHandle, HANDLE FileHandle);
[ZwSetDefaultLocale]
1=BOOLEAN ThreadOrSystem
2=LCID Locale
ParamCount=2
@=ZwSetDefaultLocale(BOOLEAN ThreadOrSystem, LCID Locale);
[ZwSetDefaultUILanguage]
1=LANGID LanguageId
ParamCount=1
@=ZwSetDefaultUILanguage(LANGID LanguageId);
[ZwSetInformationObject]
1=HANDLE ObjectHandle
2=OBJECT_INFO_CLASS ObjectInformationClass
3=PVOID ObjectInformation
4=ULONG ObjectInformationLength
ParamCount=4
@=ZwSetInformationObject(HANDLE ObjectHandle, OBJECT_INFO_CLASS ObjectInformationClass, PVOID ObjectInformation, ULONG ObjectInformationLength);
[ZwSetInformationProcess]
1=HANDLE ProcessHandle
2=PROCESSINFOCLASS ProcessInformationClass
3=PVOID ProcessInformation
4=ULONG ProcessInformationLength
ParamCount=4
@=ZwSetInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);
[ZwSetSystemInformation]
1=SYSTEM_INFORMATION_CLASS SystemInformationClass
2=PVOID SystemInformation
3=ULONG Length
ParamCount=3
@=ZwSetSystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG Length);
[ZwSetSystemTime]
1=PLARGE_INTEGER NewTime
2=OldTime OPTIONAL
ParamCount=2
@=ZwSetSystemTime(PLARGE_INTEGER NewTime, OldTime OPTIONAL);
[ZwUnloadKey]
1=POBJECT_ATTRIBUTES KeyObjectAttributes
ParamCount=1
@=ZwUnloadKey(POBJECT_ATTRIBUTES KeyObjectAttributes);
[ZwWaitForMultipleObjects]
1=ULONG HandleCount
2=PHANDLE Handles
3=WAIT_TYPE WaitType
4=BOOLEAN Alertable
5=PLARGE_INTEGER TimeoutOPTIONAL
ParamCount=5
@=ZwWaitForMultipleObjects(ULONG HandleCount, PHANDLE Handles, WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER TimeoutOPTIONAL);
[ZwYieldExecution]
ParamCount=0
@=ZwYieldExecution();



================================================
File: api-definitions/psapi.api
================================================
[EnumProcesses]
1=DWORD *lpidProcess
2=DWORD cb
3=LPDWORD lpcbNeeded
ParamCount=3
@=EnumProcesses(DWORD *lpidProcess, DWORD cb, LPDWORD lpcbNeeded);
[EnumProcessModules]
1=HANDLE hProcess
2=HMODULE *lphModule
3=DWORD cb
4=LPDWORD lpcbNeeded
ParamCount=4
@=EnumProcessModules(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded);
[EnumProcessModulesEx]
1=HANDLE hProcess
2=HMODULE *lphModule
3=DWORD cb
4=LPDWORD lpcbNeeded
5=DWORD dwFilterFlag
ParamCount=5
@=EnumProcessModulesEx(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded, DWORD dwFilterFlag);
[GetModuleBaseNameA]
1=HANDLE hProcess
2=HMODULE hModule
3=LPSTR lpBaseName
4=DWORD nSize
ParamCount=4
@=GetModuleBaseNameA(HANDLE hProcess, HMODULE hModule, LPSTR lpBaseName, DWORD nSize);
[GetModuleBaseNameW]
1=HANDLE hProcess
2=HMODULE hModule
3=LPWSTR lpBaseName
4=DWORD nSize
ParamCount=4
@=GetModuleBaseNameW(HANDLE hProcess, HMODULE hModule, LPWSTR lpBaseName, DWORD nSize);
[GetModuleFileNameExA]
1=HANDLE hProcess
2=HMODULE hModule
3=LPSTR lpFilename
4=DWORD nSize
ParamCount=4
@=GetModuleFileNameExA(HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize);
[GetModuleFileNameExW]
1=HANDLE hProcess
2=HMODULE hModule
3=LPWSTR lpFilename
4=DWORD nSize
ParamCount=4
@=GetModuleFileNameExW(HANDLE hProcess, HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
[GetModuleInformation]
1=HANDLE hProcess
2=HMODULE hModule
3=LPMODULEINFO lpmodinfo
4=DWORD cb
ParamCount=4
@=GetModuleInformation(HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb);
[EmptyWorkingSet]
1=HANDLE hProcess
ParamCount=1
@=EmptyWorkingSet(HANDLE hProcess);
[QueryWorkingSet]
1=HANDLE hProcess
2=PVOID pv
3=DWORD cb
ParamCount=3
@=QueryWorkingSet(HANDLE hProcess, PVOID pv, DWORD cb);
[QueryWorkingSetEx]
1=HANDLE hProcess
2=PVOID pv
3=DWORD cb
ParamCount=3
@=QueryWorkingSetEx(HANDLE hProcess, PVOID pv, DWORD cb);
[InitializeProcessForWsWatch]
1=HANDLE hProcess
ParamCount=1
@=InitializeProcessForWsWatch(HANDLE hProcess);
[GetWsChanges]
1=HANDLE hProcess
2=PPSAPI_WS_WATCH_INFORMATION lpWatchInfo
3=DWORD cb
ParamCount=3
@=GetWsChanges(HANDLE hProcess, PPSAPI_WS_WATCH_INFORMATION lpWatchInfo, DWORD cb);
[GetWsChangesEx]
1=HANDLE hProcess
2=PPSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx
3=PDWORD cb
ParamCount=3
@=GetWsChangesEx(HANDLE hProcess, PPSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx, PDWORD cb);
[GetMappedFileNameW]
1=HANDLE hProcess
2=LPVOID lpv
3=LPWSTR lpFilename
4=DWORD nSize
ParamCount=4
@=GetMappedFileNameW(HANDLE hProcess, LPVOID lpv, LPWSTR lpFilename, DWORD nSize);
[GetMappedFileNameA]
1=HANDLE hProcess
2=LPVOID lpv
3=LPSTR lpFilename
4=DWORD nSize
ParamCount=4
@=GetMappedFileNameA(HANDLE hProcess, LPVOID lpv, LPSTR lpFilename, DWORD nSize);
[EnumDeviceDrivers]
1=LPVOID *lpImageBase
2=DWORD cb
3=LPDWORD lpcbNeeded
ParamCount=3
@=EnumDeviceDrivers(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded);
[GetDeviceDriverBaseNameA]
1=LPVOID ImageBase
2=LPSTR lpFilename
3=DWORD nSize
ParamCount=3
@=GetDeviceDriverBaseNameA(LPVOID ImageBase, LPSTR lpFilename, DWORD nSize);
[GetDeviceDriverBaseNameW]
1=LPVOID ImageBase
2=LPWSTR lpBaseName
3=DWORD nSize
ParamCount=3
@=GetDeviceDriverBaseNameW(LPVOID ImageBase, LPWSTR lpBaseName, DWORD nSize);
[GetDeviceDriverFileNameA]
1=LPVOID ImageBase
2=LPSTR lpFilename
3=DWORD nSize
ParamCount=3
@=GetDeviceDriverFileNameA(LPVOID ImageBase, LPSTR lpFilename, DWORD nSize);
[GetDeviceDriverFileNameW]
1=LPVOID ImageBase
2=LPWSTR lpFilename
3=DWORD nSize
ParamCount=3
@=GetDeviceDriverFileNameW(LPVOID ImageBase, LPWSTR lpFilename, DWORD nSize);
[GetProcessMemoryInfo]
1=HANDLE Process
2=ppsmemCounters
3=DWORD cb
ParamCount=3
@=GetProcessMemoryInfo(HANDLE Process, ppsmemCounters, DWORD cb);
[GetPerformanceInfo]
1=pPerformanceInformation
2=DWORD cb
ParamCount=2
@=GetPerformanceInfo(pPerformanceInformation, DWORD cb);
[EnumPageFilesW]
1=pCallBackRoutine
2=LPVOID pContext
ParamCount=2
@=EnumPageFilesW(pCallBackRoutine, LPVOID pContext);
[EnumPageFilesA]
1=pCallBackRoutine
2=LPVOID pContext
ParamCount=2
@=EnumPageFilesA(pCallBackRoutine, LPVOID pContext);
[GetProcessImageFileNameA]
1=HANDLE hProcess
2=LPSTR lpImageFileName
3=DWORD nSize
ParamCount=3
@=GetProcessImageFileNameA(HANDLE hProcess, LPSTR lpImageFileName, DWORD nSize);
[GetProcessImageFileNameW]
1=HANDLE hProcess
2=LPWSTR lpImageFileName
3=DWORD nSize
ParamCount=3
@=GetProcessImageFileNameW(HANDLE hProcess, LPWSTR lpImageFileName, DWORD nSize);



================================================
File: api-definitions/shell32.api
================================================
[DragQueryFileA]
1=HDROP hDrop
2=UINT iFile
3=LPSTR lpszFile
4=UINT cch
ParamCount=4
@=DragQueryFileA(HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cch);
[DragQueryFileW]
1=HDROP hDrop
2=UINT iFile
3=LPWSTR lpszFile
4=UINT cch
ParamCount=4
@=DragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);
[DragQueryPoint]
1=HDROP hDrop
2=POINT *ppt
ParamCount=2
@=DragQueryPoint(HDROP hDrop, POINT *ppt);
[DragFinish]
1=HDROP hDrop
ParamCount=1
@=DragFinish(HDROP hDrop);
[DragAcceptFiles]
1=HWND hWnd
2=BOOL fAccept
ParamCount=2
@=DragAcceptFiles(HWND hWnd, BOOL fAccept);
[ShellExecuteA]
1=HWND hwnd
2=LPCSTR lpOperation
3=LPCSTR lpFile
4=LPCSTR lpParameters
5=LPCSTR lpDirectory
6=INT nShowCmd
ParamCount=6
@=ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
[ShellExecuteW]
1=HWND hwnd
2=LPCWSTR lpOperation
3=LPCWSTR lpFile
4=LPCWSTR lpParameters
5=LPCWSTR lpDirectory
6=INT nShowCmd
ParamCount=6
@=ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
[FindExecutableA]
1=LPCSTR lpFile
2=LPCSTR lpDirectory
3=LPSTR lpResult
ParamCount=3
@=FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
[FindExecutableW]
1=LPCWSTR lpFile
2=LPCWSTR lpDirectory
3=LPWSTR lpResult
ParamCount=3
@=FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult);
[CommandLineToArgvW]
1=LPCWSTR lpCmdLine
2=int* pNumArgs
ParamCount=2
@=CommandLineToArgvW(LPCWSTR lpCmdLine, int* pNumArgs);
[ShellAboutA]
1=HWND hWnd
2=LPCSTR szApp
3=LPCSTR szOtherStuff
4=HICON hIcon
ParamCount=4
@=ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);
[ShellAboutW]
1=HWND hWnd
2=LPCWSTR szApp
3=LPCWSTR szOtherStuff
4=HICON hIcon
ParamCount=4
@=ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon);
[DuplicateIcon]
1=HINSTANCE hInst
2=HICON hIcon
ParamCount=2
@=DuplicateIcon(HINSTANCE hInst, HICON hIcon);
[ExtractAssociatedIconA]
1=HINSTANCE hInst
2=LPSTR pszIconPath
3=WORD *piIcon
ParamCount=3
@=ExtractAssociatedIconA(HINSTANCE hInst, LPSTR pszIconPath, WORD *piIcon);
[ExtractAssociatedIconW]
1=HINSTANCE hInst
2=LPWSTR pszIconPath
3=WORD *piIcon
ParamCount=3
@=ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR pszIconPath, WORD *piIcon);
[ExtractAssociatedIconExA]
1=HINSTANCE hInst
2=LPSTR pszIconPath
3=WORD *piIconIndex
4=WORD *piIconId
ParamCount=4
@=ExtractAssociatedIconExA(HINSTANCE hInst, LPSTR pszIconPath, WORD *piIconIndex, WORD *piIconId);
[ExtractAssociatedIconExW]
1=HINSTANCE hInst
2=LPWSTR pszIconPath
3=WORD *piIconIndex
4=WORD *piIconId
ParamCount=4
@=ExtractAssociatedIconExW(HINSTANCE hInst, LPWSTR pszIconPath, WORD *piIconIndex, WORD *piIconId);
[ExtractIconA]
1=HINSTANCE hInst
2=LPCSTR pszExeFileName
3=UINT nIconIndex
ParamCount=3
@=ExtractIconA(HINSTANCE hInst, LPCSTR pszExeFileName, UINT nIconIndex);
[ExtractIconW]
1=HINSTANCE hInst
2=LPCWSTR pszExeFileName
3=UINT nIconIndex
ParamCount=3
@=ExtractIconW(HINSTANCE hInst, LPCWSTR pszExeFileName, UINT nIconIndex);
[SHAppBarMessage]
1=DWORD dwMessage
2=PAPPBARDATA pData
ParamCount=2
@=SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData);
[DoEnvironmentSubstA]
1=LPSTR pszSrc
2=UINT cchSrc
ParamCount=2
@=DoEnvironmentSubstA(LPSTR pszSrc, UINT cchSrc);
[DoEnvironmentSubstW]
1=LPWSTR pszSrc
2=UINT cchSrc
ParamCount=2
@=DoEnvironmentSubstW(LPWSTR pszSrc, UINT cchSrc);
[ExtractIconExA]
1=LPCSTR lpszFile
2=int nIconIndex
3=HICON *phiconLarge
4=HICON *phiconSmall
5=UINT nIcons
ParamCount=5
@=ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
[ExtractIconExW]
1=LPCWSTR lpszFile
2=int nIconIndex
3=HICON *phiconLarge
4=HICON *phiconSmall
5=UINT nIcons
ParamCount=5
@=ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
[SHFileOperationA]
1=LPSHFILEOPSTRUCTA lpFileOp
ParamCount=1
@=SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp);
[SHFileOperationW]
1=LPSHFILEOPSTRUCTW lpFileOp
ParamCount=1
@=SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp);
[SHFreeNameMappings]
1=HANDLE hNameMappings
ParamCount=1
@=SHFreeNameMappings(HANDLE hNameMappings);
[ShellExecuteExA]
1=SHELLEXECUTEINFOA *pExecInfo
ParamCount=1
@=ShellExecuteExA(SHELLEXECUTEINFOA *pExecInfo);
[ShellExecuteExW]
1=SHELLEXECUTEINFOW *pExecInfo
ParamCount=1
@=ShellExecuteExW(SHELLEXECUTEINFOW *pExecInfo);
[SHCreateProcessAsUserW]
1=PSHCREATEPROCESSINFOW pscpi
ParamCount=1
@=SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi);
[SHEvaluateSystemCommandTemplate]
1=PCWSTR pszCmdTemplate
2=PWSTR *ppszApplication
3=PWSTR *ppszCommandLine
4=PWSTR *ppszParameters
ParamCount=4
@=SHEvaluateSystemCommandTemplate(PCWSTR pszCmdTemplate, PWSTR *ppszApplication, PWSTR *ppszCommandLine, PWSTR *ppszParameters);
[AssocCreateForClasses]
1=ASSOCIATIONELEMENT *rgClasses
2=ULONG cClasses
3=REFIID riid
4=void **ppv
ParamCount=4
@=AssocCreateForClasses(ASSOCIATIONELEMENT *rgClasses, ULONG cClasses, REFIID riid, void **ppv);
[SHQueryRecycleBinA]
1=LPCSTR pszRootPath
2=LPSHQUERYRBINFO pSHQueryRBInfo
ParamCount=2
@=SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo);
[SHQueryRecycleBinW]
1=LPCWSTR pszRootPath
2=LPSHQUERYRBINFO pSHQueryRBInfo
ParamCount=2
@=SHQueryRecycleBinW(LPCWSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo);
[SHEmptyRecycleBinA]
1=HWND hwnd
2=LPCSTR pszRootPath
3=DWORD dwFlags
ParamCount=3
@=SHEmptyRecycleBinA(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags);
[SHEmptyRecycleBinW]
1=HWND hwnd
2=LPCWSTR pszRootPath
3=DWORD dwFlags
ParamCount=3
@=SHEmptyRecycleBinW(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags);
[SHQueryUserNotificationState]
1=QUERY_USER_NOTIFICATION_STATE *pquns
ParamCount=1
@=SHQueryUserNotificationState(QUERY_USER_NOTIFICATION_STATE *pquns);
[SHGetPropertyStoreForWindow]
1=HWND hwnd
2=REFIID riid
3=void** ppv
ParamCount=3
@=SHGetPropertyStoreForWindow(HWND hwnd, REFIID riid, void** ppv);
[Shell_NotifyIconA]
1=DWORD dwMessage
2=PNOTIFYICONDATAA lpData
ParamCount=2
@=Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData);
[Shell_NotifyIconW]
1=DWORD dwMessage
2=PNOTIFYICONDATAW lpData
ParamCount=2
@=Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);
[Shell_NotifyIconGetRect]
1=NOTIFYICONIDENTIFIER* identifier
2=RECT* iconLocation
ParamCount=2
@=Shell_NotifyIconGetRect(NOTIFYICONIDENTIFIER* identifier, RECT* iconLocation);
[SHGetFileInfoA]
1=LPCSTR pszPath
2=DWORD dwFileAttributes
3=SHFILEINFOA *psfi
4=UINT cbFileInfo
5=UINT uFlags
ParamCount=5
@=SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags);
[SHGetFileInfoW]
1=LPCWSTR pszPath
2=DWORD dwFileAttributes
3=SHFILEINFOW *psfi
4=UINT cbFileInfo
5=UINT uFlags
ParamCount=5
@=SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);
[SHGetStockIconInfo]
1=SHSTOCKICONID siid
2=UINT uFlags
3=SHSTOCKICONINFO *psii
ParamCount=3
@=SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO *psii);
[SHGetDiskFreeSpaceExA]
1=LPCSTR pszDirectoryName
2=ULARGE_INTEGER* pulFreeBytesAvailableToCaller
3=ULARGE_INTEGER* pulTotalNumberOfBytes
4=ULARGE_INTEGER* pulTotalNumberOfFreeBytes
ParamCount=4
@=SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER* pulFreeBytesAvailableToCaller, ULARGE_INTEGER* pulTotalNumberOfBytes, ULARGE_INTEGER* pulTotalNumberOfFreeBytes);
[SHGetDiskFreeSpaceExW]
1=LPCWSTR pszDirectoryName
2=ULARGE_INTEGER* pulFreeBytesAvailableToCaller
3=ULARGE_INTEGER* pulTotalNumberOfBytes
4=ULARGE_INTEGER* pulTotalNumberOfFreeBytes
ParamCount=4
@=SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER* pulFreeBytesAvailableToCaller, ULARGE_INTEGER* pulTotalNumberOfBytes, ULARGE_INTEGER* pulTotalNumberOfFreeBytes);
[SHGetNewLinkInfoA]
1=LPCSTR pszLinkTo
2=LPCSTR pszDir
3=LPSTR pszName
4=BOOL *pfMustCopy
5=UINT uFlags
ParamCount=5
@=SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags);
[SHGetNewLinkInfoW]
1=LPCWSTR pszLinkTo
2=LPCWSTR pszDir
3=LPWSTR pszName
4=BOOL *pfMustCopy
5=UINT uFlags
ParamCount=5
@=SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags);
[SHInvokePrinterCommandA]
1=HWND hwnd
2=UINT uAction
3=LPCSTR lpBuf1
4=LPCSTR lpBuf2
5=BOOL fModal
ParamCount=5
@=SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal);
[SHInvokePrinterCommandW]
1=HWND hwnd
2=UINT uAction
3=LPCWSTR lpBuf1
4=LPCWSTR lpBuf2
5=BOOL fModal
ParamCount=5
@=SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal);
[SHLoadNonloadedIconOverlayIdentifiers]
ParamCount=0
@=SHLoadNonloadedIconOverlayIdentifiers();
[SHIsFileAvailableOffline]
1=PCWSTR pwszPath
2=DWORD *pdwStatus
ParamCount=2
@=SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD *pdwStatus);
[SHSetLocalizedName]
1=PCWSTR pszPath
2=PCWSTR pszResModule
3=int idsRes
ParamCount=3
@=SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes);
[SHRemoveLocalizedName]
1=PCWSTR pszPath
ParamCount=1
@=SHRemoveLocalizedName(PCWSTR pszPath);
[SHGetLocalizedName]
1=PCWSTR pszPath
2=PWSTR pszResModule
3=UINT cch
4=int *pidsRes
ParamCount=4
@=SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int *pidsRes);
[IsLFNDriveA]
1=LPCSTR pszPath
ParamCount=1
@=IsLFNDriveA(LPCSTR pszPath);
[IsLFNDriveW]
1=LPCWSTR pszPath
ParamCount=1
@=IsLFNDriveW(LPCWSTR pszPath);
[SHEnumerateUnreadMailAccountsA]
1=HKEY hKeyUser
2=DWORD dwIndex
3=LPSTR pszMailAddress
4=int cchMailAddress
ParamCount=4
@=SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress);
[SHEnumerateUnreadMailAccountsW]
1=HKEY hKeyUser
2=DWORD dwIndex
3=LPWSTR pszMailAddress
4=int cchMailAddress
ParamCount=4
@=SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress);
[SHGetUnreadMailCountA]
1=HKEY hKeyUser
2=LPCSTR pszMailAddress
3=DWORD *pdwCount
4=FILETIME *pFileTime
5=LPSTR pszShellExecuteCommand
6=int cchShellExecuteCommand
ParamCount=6
@=SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand);
[SHGetUnreadMailCountW]
1=HKEY hKeyUser
2=LPCWSTR pszMailAddress
3=DWORD *pdwCount
4=FILETIME *pFileTime
5=LPWSTR pszShellExecuteCommand
6=int cchShellExecuteCommand
ParamCount=6
@=SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand);
[SHSetUnreadMailCountA]
1=LPCSTR pszMailAddress
2=DWORD dwCount
3=LPCSTR pszShellExecuteCommand
ParamCount=3
@=SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand);
[SHSetUnreadMailCountW]
1=LPCWSTR pszMailAddress
2=DWORD dwCount
3=LPCWSTR pszShellExecuteCommand
ParamCount=3
@=SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand);
[SHTestTokenMembership]
1=HANDLE hToken
2=ULONG ulRID
ParamCount=2
@=SSHTestTokenMembership(HANDLE hToken, ULONG ulRID);
[SHGetImageList]
1=int iImageList
2=REFIID riid
3=void **ppvObj
ParamCount=3
@=SHGetImageList(int iImageList, REFIID riid, void **ppvObj);
[InitNetworkAddressControl]
ParamCount=0
@=InitNetworkAddressControl();



================================================
File: api-definitions/user32.api
================================================
[wvsprintfA]
1=LPSTR
2=LPCSTR __format_string
3=va_list arglist
ParamCount=3
@=wvsprintfA(LPSTR, LPCSTR __format_string, va_list arglist);
[wvsprintfW]
1=LPWSTR
2=LPCWSTR __format_string
3=va_list arglist
ParamCount=3
@=wvsprintfW(LPWSTR, LPCWSTR __format_string, va_list arglist);
[wsprintfA]
1=LPSTR
2=LPCSTR __format_string
ParamCount=2
@=wsprintfA(LPSTR, LPCSTR __format_string);
[wsprintfW]
1=LPWSTR
2=LPCWSTR __format_string
ParamCount=2
@=wsprintfW(LPWSTR, LPCWSTR __format_string);
[LoadKeyboardLayoutA]
1=LPCSTR pwszKLID
2=UINT Flags
ParamCount=2
@=LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags);
[LoadKeyboardLayoutW]
1=LPCWSTR pwszKLID
2=UINT Flags
ParamCount=2
@=LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags);
[ActivateKeyboardLayout]
1=HKL hkl
2=UINT Flags
ParamCount=2
@=ActivateKeyboardLayout(HKL hkl, UINT Flags);
[ToUnicodeEx]
1=UINT wVirtKey
2=UINT wScanCode
3=BYTE *lpKeyState
4=LPWSTR pwszBuff
5=int cchBuff
6=UINT wFlags
7=HKL dwhkl
ParamCount=7
@=ToUnicodeEx(UINT wVirtKey, UINT wScanCode, BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl);
[UnloadKeyboardLayout]
1=HKL hkl
ParamCount=1
@=UnloadKeyboardLayout(HKL hkl);
[GetKeyboardLayoutNameA]
1=LPSTR pwszKLID
ParamCount=1
@=GetKeyboardLayoutNameA(LPSTR pwszKLID);
[GetKeyboardLayoutNameW]
1=LPWSTR pwszKLID
ParamCount=1
@=GetKeyboardLayoutNameW(LPWSTR pwszKLID);
[GetKeyboardLayoutList]
1=int nBuff
2=HKL *lpList
ParamCount=2
@=GetKeyboardLayoutList(int nBuff, HKL *lpList);
[GetKeyboardLayout]
1=DWORD idThread
ParamCount=1
@=GetKeyboardLayout(DWORD idThread);
[GetMouseMovePointsEx]
1=UINT cbSize
2=LPMOUSEMOVEPOINT lppt
3=LPMOUSEMOVEPOINT lpptBuf
4=int nBufPoints
5=DWORD resolution
ParamCount=5
@=GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution);
[CreateDesktopA]
1=LPCSTR lpszDesktop
2=LPCSTR lpszDevice
3=DEVMODEA* pDevmode
4=DWORD dwFlags
5=ACCESS_MASK dwDesiredAccess
6=LPSECURITY_ATTRIBUTES lpsa
ParamCount=6
@=CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA* pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
[CreateDesktopW]
1=LPCWSTR lpszDesktop
2=LPCWSTR lpszDevice
3=DEVMODEW* pDevmode
4=DWORD dwFlags
5=ACCESS_MASK dwDesiredAccess
6=LPSECURITY_ATTRIBUTES lpsa
ParamCount=6
@=CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW* pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
[CreateDesktopExA]
1=LPCSTR lpszDesktop
2=LPCSTR lpszDevice
3=DEVMODEA* pDevmode
4=DWORD dwFlags
5=ACCESS_MASK dwDesiredAccess
6=LPSECURITY_ATTRIBUTES lpsa
7=ULONG ulHeapSize
8=PVOID pvoid
ParamCount=8
@=CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA* pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid);
[CreateDesktopExW]
1=LPCWSTR lpszDesktop
2=LPCWSTR lpszDevice
3=DEVMODEW* pDevmode
4=DWORD dwFlags
5=ACCESS_MASK dwDesiredAccess
6=LPSECURITY_ATTRIBUTES lpsa
7=ULONG ulHeapSize
8=PVOID pvoid
ParamCount=8
@=CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW* pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid);
[OpenDesktopA]
1=LPCSTR lpszDesktop
2=DWORD dwFlags
3=BOOL fInherit
4=ACCESS_MASK dwDesiredAccess
ParamCount=4
@=OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess);
[OpenDesktopW]
1=LPCWSTR lpszDesktop
2=DWORD dwFlags
3=BOOL fInherit
4=ACCESS_MASK dwDesiredAccess
ParamCount=4
@=OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess);
[OpenInputDesktop]
1=DWORD dwFlags
2=BOOL fInherit
3=ACCESS_MASK dwDesiredAccess
ParamCount=3
@=OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess);
[EnumDesktopsA]
1=HWINSTA hwinsta
2=DESKTOPENUMPROCA lpEnumFunc
3=LPARAM lParam
ParamCount=3
@=EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam);
[EnumDesktopsW]
1=HWINSTA hwinsta
2=DESKTOPENUMPROCW lpEnumFunc
3=LPARAM lParam
ParamCount=3
@=EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam);
[EnumDesktopWindows]
1=HDESK hDesktop
2=WNDENUMPROC lpfn
3=LPARAM lParam
ParamCount=3
@=EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam);
[SwitchDesktop]
1=HDESK hDesktop
ParamCount=1
@=SwitchDesktop(HDESK hDesktop);
[SetThreadDesktop]
1=HDESK hDesktop
ParamCount=1
@=SetThreadDesktop(HDESK hDesktop);
[CloseDesktop]
1=HDESK hDesktop
ParamCount=1
@=CloseDesktop(HDESK hDesktop);
[GetThreadDesktop]
1=DWORD dwThreadId
ParamCount=1
@=GetThreadDesktop(DWORD dwThreadId);
[CreateWindowStationA]
1=LPCSTR lpwinsta
2=DWORD dwFlags
3=ACCESS_MASK dwDesiredAccess
4=LPSECURITY_ATTRIBUTES lpsa
ParamCount=4
@=CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
[CreateWindowStationW]
1=LPCWSTR lpwinsta
2=DWORD dwFlags
3=ACCESS_MASK dwDesiredAccess
4=LPSECURITY_ATTRIBUTES lpsa
ParamCount=4
@=CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
[OpenWindowStationA]
1=LPCSTR lpszWinSta
2=BOOL fInherit
3=ACCESS_MASK dwDesiredAccess
ParamCount=3
@=OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess);
[OpenWindowStationW]
1=LPCWSTR lpszWinSta
2=BOOL fInherit
3=ACCESS_MASK dwDesiredAccess
ParamCount=3
@=OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess);
[EnumWindowStationsA]
1=WINSTAENUMPROCA lpEnumFunc
2=LPARAM lParam
ParamCount=2
@=EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam);
[EnumWindowStationsW]
1=WINSTAENUMPROCW lpEnumFunc
2=LPARAM lParam
ParamCount=2
@=EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam);
[CloseWindowStation]
1=HWINSTA hWinSta
ParamCount=1
@=CloseWindowStation(HWINSTA hWinSta);
[SetProcessWindowStation]
1=HWINSTA hWinSta
ParamCount=1
@=SetProcessWindowStation(HWINSTA hWinSta);
[GetProcessWindowStation]
ParamCount=0
@=GetProcessWindowStation();
[SetUserObjectSecurity]
1=HANDLE hObj
2=PSECURITY_INFORMATION pSIRequested
3=PSECURITY_DESCRIPTOR pSID
ParamCount=3
@=SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID);
[GetUserObjectSecurity]
1=HANDLE hObj
2=PSECURITY_INFORMATION pSIRequested
3=PSECURITY_DESCRIPTOR pSID
4=DWORD nLength
5=LPDWORD lpnLengthNeeded
ParamCount=5
@=GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded);
[GetUserObjectInformationA]
1=HANDLE hObj
2=int nIndex
3=PVOID pvInfo
4=DWORD nLength
5=LPDWORD lpnLengthNeeded
ParamCount=5
@=GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);
[GetUserObjectInformationW]
1=HANDLE hObj
2=int nIndex
3=PVOID pvInfo
4=DWORD nLength
5=LPDWORD lpnLengthNeeded
ParamCount=5
@=GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);
[SetUserObjectInformationA]
1=HANDLE hObj
2=int nIndex
3=PVOID pvInfo
4=DWORD nLength
ParamCount=4
@=SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength);
[SetUserObjectInformationW]
1=HANDLE hObj
2=int nIndex
3=PVOID pvInfo
4=DWORD nLength
ParamCount=4
@=SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength);
[IsHungAppWindow]
1=HWND hwnd
ParamCount=1
@=IsHungAppWindow(HWND hwnd);
[DisableProcessWindowsGhosting]
ParamCount=0
@=DisableProcessWindowsGhosting();
[RegisterWindowMessageA]
1=LPCSTR lpString
ParamCount=1
@=RegisterWindowMessageA(LPCSTR lpString);
[RegisterWindowMessageW]
1=LPCWSTR lpString
ParamCount=1
@=RegisterWindowMessageW(LPCWSTR lpString);
[TrackMouseEvent]
1=LPTRACKMOUSEEVENT lpEventTrack
ParamCount=1
@=TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack);
[DrawEdge]
1=HDC hdc
2=LPRECT qrc
3=UINT edge
4=UINT grfFlags
ParamCount=4
@=DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);
[DrawFrameControl]
1=HDC
2=LPRECT
3=UINT
4=UINT
ParamCount=4
@=DrawFrameControl(HDC, LPRECT, UINT, UINT);
[DrawCaption]
1=HWND hwnd
2=HDC hdc
3=RECT *lprect
4=UINT flags
ParamCount=4
@=DrawCaption(HWND hwnd, HDC hdc, RECT *lprect, UINT flags);
[DrawAnimatedRects]
1=HWND hwnd
2=int idAni
3=RECT *lprcFrom
4=RECT *lprcTo
ParamCount=4
@=DrawAnimatedRects(HWND hwnd, int idAni, RECT *lprcFrom, RECT *lprcTo);
[GetMessageA]
1=LPMSG lpMsg
2=HWND hWnd
3=UINT wMsgFilterMin
4=UINT wMsgFilterMax
ParamCount=4
@=GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
[GetMessageW]
1=LPMSG lpMsg
2=HWND hWnd
3=UINT wMsgFilterMin
4=UINT wMsgFilterMax
ParamCount=4
@=GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
[TranslateMessage]
1=MSG *lpMsg
ParamCount=1
@=TranslateMessage(MSG *lpMsg);
[DispatchMessageA]
1=MSG *lpMsg
ParamCount=1
@=DispatchMessageA(MSG *lpMsg);
[DispatchMessageW]
1=MSG *lpMsg
ParamCount=1
@=DispatchMessageW(MSG *lpMsg);
[SetMessageQueue]
1=int cMessagesMax
ParamCount=1
@=SetMessageQueue(int cMessagesMax);
[PeekMessageA]
1=LPMSG lpMsg
2=HWND hWnd
3=UINT wMsgFilterMin
4=UINT wMsgFilterMax
5=UINT wRemoveMsg
ParamCount=5
@=PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
[PeekMessageW]
1=LPMSG lpMsg
2=HWND hWnd
3=UINT wMsgFilterMin
4=UINT wMsgFilterMax
5=UINT wRemoveMsg
ParamCount=5
@=PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
[RegisterHotKey]
1=HWND hWnd
2=int id
3=UINT fsModifiers
4=UINT vk
ParamCount=4
@=RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk);
[UnregisterHotKey]
1=HWND hWnd
2=int id
ParamCount=2
@=UnregisterHotKey(HWND hWnd, int id);
[ExitWindowsEx]
1=UINT uFlags
2=DWORD dwReason
ParamCount=2
@=ExitWindowsEx(UINT uFlags, DWORD dwReason);
[SwapMouseButton]
1=BOOL fSwap
ParamCount=1
@=SwapMouseButton(BOOL fSwap);
[GetMessagePos]
ParamCount=0
@=GetMessagePos();
[GetMessageTime]
ParamCount=0
@=GetMessageTime();
[GetMessageExtraInfo]
ParamCount=0
@=GetMessageExtraInfo();
[GetUnpredictedMessagePos]
ParamCount=0
@=GetUnpredictedMessagePos();
[IsWow64Message]
ParamCount=0
@=IsWow64Message();
[SetMessageExtraInfo]
1=LPARAM lParam
ParamCount=1
@=SetMessageExtraInfo(LPARAM lParam);
[SendMessageA]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[SendMessageW]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[SendMessageTimeoutA]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
5=UINT fuFlags
6=UINT uTimeout
7=PDWORD_PTR lpdwResult
ParamCount=7
@=SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult);
[SendMessageTimeoutW]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
5=UINT fuFlags
6=UINT uTimeout
7=PDWORD_PTR lpdwResult
ParamCount=7
@=SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult);
[SendNotifyMessageA]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[SendNotifyMessageW]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[SendMessageCallbackA]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
5=SENDASYNCPROC lpResultCallBack
6=ULONG_PTR dwData
ParamCount=6
@=SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData);
[SendMessageCallbackW]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
5=SENDASYNCPROC lpResultCallBack
6=ULONG_PTR dwData
ParamCount=6
@=SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData);
[BroadcastSystemMessageExA]
1=DWORD flags
2=LPDWORD lpInfo
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
6=PBSMINFO pbsmInfo
ParamCount=6
@=BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo);
[BroadcastSystemMessageExW]
1=DWORD flags
2=LPDWORD lpInfo
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
6=PBSMINFO pbsmInfo
ParamCount=6
@=BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo);
[BroadcastSystemMessageA]
1=DWORD flags
2=LPDWORD lpInfo
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam);
[BroadcastSystemMessageW]
1=DWORD flags
2=LPDWORD lpInfo
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam);
[BroadcastSystemMessage]
1=DWORD flags
2=LPDWORD lpInfo
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=BroadcastSystemMessage(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam);
[RegisterDeviceNotificationA]
1=HANDLE hRecipient
2=LPVOID NotificationFilter
3=DWORD Flags
ParamCount=3
@=RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags);
[RegisterDeviceNotificationW]
1=HANDLE hRecipient
2=LPVOID NotificationFilter
3=DWORD Flags
ParamCount=3
@=RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags);
[UnregisterDeviceNotification]
1=HDEVNOTIFY Handle
ParamCount=1
@=UnregisterDeviceNotification(HDEVNOTIFY Handle);
[RegisterPowerSettingNotification]
1=HANDLE hRecipient
2=LPCGUID PowerSettingGuid
3=DWORD Flags
ParamCount=3
@=RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags);
[UnregisterPowerSettingNotification]
1=HPOWERNOTIFY Handle
ParamCount=1
@=UnregisterPowerSettingNotification(HPOWERNOTIFY Handle);
[RegisterSuspendResumeNotification]
1=HANDLE hRecipient
2=DWORD Flags
ParamCount=2
@=RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags);
[UnregisterSuspendResumeNotification]
1=HPOWERNOTIFY Handle
ParamCount=1
@=UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle);
[PostMessageA]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[PostMessageW]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[PostThreadMessageA]
1=DWORD idThread
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);
[PostThreadMessageW]
1=DWORD idThread
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);
[AttachThreadInput]
1=DWORD idAttach
2=DWORD idAttachTo
3=BOOL fAttach
ParamCount=3
@=AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach);
[ReplyMessage]
1=LRESULT lResult
ParamCount=1
@=ReplyMessage(LRESULT lResult);
[WaitMessage]
ParamCount=0
@=WaitMessage();
[WaitForInputIdle]
1=HANDLE hProcess
2=DWORD dwMilliseconds
ParamCount=2
@=WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds);
[DefWindowProcA]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[DefWindowProcW]
1=HWND hWnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[PostQuitMessage]
1=int nExitCode
ParamCount=1
@=PostQuitMessage(int nExitCode);
[CallWindowProcA]
1=FARPROC lpPrevWndFunc
2=HWND hWnd
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=CallWindowProcA(FARPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[CallWindowProcW]
1=FARPROC lpPrevWndFunc
2=HWND hWnd
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=CallWindowProcW(FARPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[InSendMessage]
ParamCount=0
@=InSendMessage();
[InSendMessageEx]
1=LPVOID lpReserved
ParamCount=1
@=InSendMessageEx(LPVOID lpReserved);
[GetDoubleClickTime]
ParamCount=0
@=GetDoubleClickTime();
[SetDoubleClickTime]
1=UINT
ParamCount=1
@=SetDoubleClickTime(UINT);
[RegisterClassA]
1=WNDCLASSA *lpWndClass
ParamCount=1
@=RegisterClassA(WNDCLASSA *lpWndClass);
[RegisterClassW]
1=WNDCLASSW *lpWndClass
ParamCount=1
@=RegisterClassW(WNDCLASSW *lpWndClass);
[UnregisterClassA]
1=LPCSTR lpClassName
2=HINSTANCE hInstance
ParamCount=2
@=UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance);
[UnregisterClassW]
1=LPCWSTR lpClassName
2=HINSTANCE hInstance
ParamCount=2
@=UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance);
[GetClassInfoA]
1=HINSTANCE hInstance
2=LPCSTR lpClassName
3=LPWNDCLASSA lpWndClass
ParamCount=3
@=GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass);
[GetClassInfoW]
1=HINSTANCE hInstance
2=LPCWSTR lpClassName
3=LPWNDCLASSW lpWndClass
ParamCount=3
@=GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass);
[RegisterClassExA]
1=WNDCLASSEXA *
ParamCount=1
@=RegisterClassExA(WNDCLASSEXA *);
[RegisterClassExW]
1=WNDCLASSEXW *
ParamCount=1
@=RegisterClassExW(WNDCLASSEXW *);
[GetClassInfoExA]
1=HINSTANCE hInstance
2=LPCSTR lpszClass
3=LPWNDCLASSEXA lpwcx
ParamCount=3
@=GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx);
[GetClassInfoExW]
1=HINSTANCE hInstance
2=LPCWSTR lpszClass
3=LPWNDCLASSEXW lpwcx
ParamCount=3
@=GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx);
[CreateWindowExA]
1=DWORD dwExStyle
2=LPCSTR lpClassName
3=LPCSTR lpWindowName
4=DWORD dwStyle
5=int X
6=int Y
7=int nWidth
8=int nHeight
9=HWND hWndParent
10=HMENU hMenu
11=HINSTANCE hInstance
12=LPVOID lpParam
ParamCount=12
@=CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
[CreateWindowExW]
1=DWORD dwExStyle
2=LPCWSTR lpClassName
3=LPCWSTR lpWindowName
4=DWORD dwStyle
5=int X
6=int Y
7=int nWidth
8=int nHeight
9=HWND hWndParent
10=HMENU hMenu
11=HINSTANCE hInstance
12=LPVOID lpParam
ParamCount=12
@=CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
[IsWindow]
1=HWND hWnd
ParamCount=1
@=IsWindow(HWND hWnd);
[IsMenu]
1=HMENU hMenu
ParamCount=1
@=IsMenu(HMENU hMenu);
[IsChild]
1=HWND hWndParent
2=HWND hWnd
ParamCount=2
@=IsChild(HWND hWndParent, HWND hWnd);
[DestroyWindow]
1=HWND hWnd
ParamCount=1
@=DestroyWindow(HWND hWnd);
[ShowWindow]
1=HWND hWnd
2=int nCmdShow
ParamCount=2
@=ShowWindow(HWND hWnd, int nCmdShow);
[AnimateWindow]
1=HWND hWnd
2=DWORD dwTime
3=DWORD dwFlags
ParamCount=3
@=AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags);
[UpdateLayeredWindow]
1=HWND hWnd
2=HDC hdcDst
3=POINT* pptDst
4=SIZE* psize
5=HDC hdcSrc
6=POINT* pptSrc
7=COLORREF crKey
8=BLENDFUNCTION* pblend
9=DWORD dwFlags
ParamCount=9
@=UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT* pptDst, SIZE* psize, HDC hdcSrc, POINT* pptSrc, COLORREF crKey, BLENDFUNCTION* pblend, DWORD dwFlags);
[UpdateLayeredWindowIndirect]
1=HWND hWnd
2=UPDATELAYEREDWINDOWINFO* pULWInfo
ParamCount=2
@=UpdateLayeredWindowIndirect(HWND hWnd, UPDATELAYEREDWINDOWINFO* pULWInfo);
[GetLayeredWindowAttributes]
1=HWND hwnd
2=COLORREF* pcrKey
3=BYTE* pbAlpha
4=DWORD* pdwFlags
ParamCount=4
@=GetLayeredWindowAttributes(HWND hwnd, COLORREF* pcrKey, BYTE* pbAlpha, DWORD* pdwFlags);
[PrintWindow]
1=HWND hwnd
2=HDC hdcBlt
3=UINT nFlags
ParamCount=3
@=PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags);
[SetLayeredWindowAttributes]
1=HWND hwnd
2=COLORREF crKey
3=BYTE bAlpha
4=DWORD dwFlags
ParamCount=4
@=SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
[ShowWindowAsync]
1=HWND hWnd
2=int nCmdShow
ParamCount=2
@=ShowWindowAsync(HWND hWnd, int nCmdShow);
[FlashWindow]
1=HWND hWnd
2=BOOL bInvert
ParamCount=2
@=FlashWindow(HWND hWnd, BOOL bInvert);
[FlashWindowEx]
1=PFLASHWINFO pfwi
ParamCount=1
@=FlashWindowEx(PFLASHWINFO pfwi);
[ShowOwnedPopups]
1=HWND hWnd
2=BOOL fShow
ParamCount=2
@=ShowOwnedPopups(HWND hWnd, BOOL fShow);
[OpenIcon]
1=HWND hWnd
ParamCount=1
@=OpenIcon(HWND hWnd);
[CloseWindow]
1=HWND hWnd
ParamCount=1
@=CloseWindow(HWND hWnd);
[MoveWindow]
1=HWND hWnd
2=int X
3=int Y
4=int nWidth
5=int nHeight
6=BOOL bRepaint
ParamCount=6
@=MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
[SetWindowPos]
1=HWND hWnd
2=HWND hWndInsertAfter
3=int X
4=int Y
5=int cx
6=int cy
7=UINT uFlags
ParamCount=7
@=SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
[GetWindowPlacement]
1=HWND hWnd
2=WINDOWPLACEMENT *lpwndpl
ParamCount=2
@=GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
[SetWindowPlacement]
1=HWND hWnd
2=WINDOWPLACEMENT *lpwndpl
ParamCount=2
@=SetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
[GetWindowDisplayAffinity]
1=HWND hWnd
2=DWORD* pdwAffinity
ParamCount=2
@=GetWindowDisplayAffinity(HWND hWnd, DWORD* pdwAffinity);
[SetWindowDisplayAffinity]
1=HWND hWnd
2=DWORD dwAffinity
ParamCount=2
@=SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity);
[BeginDeferWindowPos]
1=int nNumWindows
ParamCount=1
@=BeginDeferWindowPos(int nNumWindows);
[DeferWindowPos]
1=HDWP hWinPosInfo
2=HWND hWnd
3=HWND hWndInsertAfter
4=int x
5=int y
6=int cx
7=int cy
8=UINT uFlags
ParamCount=8
@=DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags);
[EndDeferWindowPos]
1=HDWP hWinPosInfo
ParamCount=1
@=EndDeferWindowPos(HDWP hWinPosInfo);
[IsWindowVisible]
1=HWND hWnd
ParamCount=1
@=IsWindowVisible(HWND hWnd);
[IsIconic]
1=HWND hWnd
ParamCount=1
@=IsIconic(HWND hWnd);
[AnyPopup]
ParamCount=0
@=AnyPopup();
[BringWindowToTop]
1=HWND hWnd
ParamCount=1
@=BringWindowToTop(HWND hWnd);
[IsZoomed]
1=HWND hWnd
ParamCount=1
@=IsZoomed(HWND hWnd);
[CreateDialogParamA]
1=HINSTANCE hInstance
2=LPCSTR lpTemplateName
3=HWND hWndParent
4=DLGPROC lpDialogFunc
5=LPARAM dwInitParam
ParamCount=5
@=CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
[CreateDialogParamW]
1=HINSTANCE hInstance
2=LPCWSTR lpTemplateName
3=HWND hWndParent
4=DLGPROC lpDialogFunc
5=LPARAM dwInitParam
ParamCount=5
@=CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
[CreateDialogIndirectParamA]
1=HINSTANCE hInstance
2=LPCDLGTEMPLATEA lpTemplate
3=HWND hWndParent
4=DLGPROC lpDialogFunc
5=LPARAM dwInitParam
ParamCount=5
@=CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
[CreateDialogIndirectParamW]
1=HINSTANCE hInstance
2=LPCDLGTEMPLATEW lpTemplate
3=HWND hWndParent
4=DLGPROC lpDialogFunc
5=LPARAM dwInitParam
ParamCount=5
@=CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
[DialogBoxParamA]
1=HINSTANCE hInstance
2=LPCSTR lpTemplateName
3=HWND hWndParent
4=DLGPROC lpDialogFunc
5=LPARAM dwInitParam
ParamCount=5
@=DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
[DialogBoxParamW]
1=HINSTANCE hInstance
2=LPCWSTR lpTemplateName
3=HWND hWndParent
4=DLGPROC lpDialogFunc
5=LPARAM dwInitParam
ParamCount=5
@=DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
[DialogBoxIndirectParamA]
1=HINSTANCE hInstance
2=LPCDLGTEMPLATEA hDialogTemplate
3=HWND hWndParent
4=DLGPROC lpDialogFunc
5=LPARAM dwInitParam
ParamCount=5
@=DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
[DialogBoxIndirectParamW]
1=HINSTANCE hInstance
2=LPCDLGTEMPLATEW hDialogTemplate
3=HWND hWndParent
4=DLGPROC lpDialogFunc
5=LPARAM dwInitParam
ParamCount=5
@=DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
[EndDialog]
1=HWND hDlg
2=INT_PTR nResult
ParamCount=2
@=EndDialog(HWND hDlg, INT_PTR nResult);
[GetDlgItem]
1=HWND hDlg
2=int nIDDlgItem
ParamCount=2
@=GetDlgItem(HWND hDlg, int nIDDlgItem);
[SetDlgItemInt]
1=HWND hDlg
2=int nIDDlgItem
3=UINT uValue
4=BOOL bSigned
ParamCount=4
@=SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned);
[GetDlgItemInt]
1=HWND hDlg
2=int nIDDlgItem
3=BOOL *lpTranslated
4=BOOL bSigned
ParamCount=4
@=GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned);
[SetDlgItemTextA]
1=HWND hDlg
2=int nIDDlgItem
3=LPCSTR lpString
ParamCount=3
@=SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString);
[SetDlgItemTextW]
1=HWND hDlg
2=int nIDDlgItem
3=LPCWSTR lpString
ParamCount=3
@=SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
[GetDlgItemTextA]
1=HWND hDlg
2=int nIDDlgItem
3=LPSTR lpString
4=int cchMax
ParamCount=4
@=GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax);
[GetDlgItemTextW]
1=HWND hDlg
2=int nIDDlgItem
3=LPWSTR lpString
4=int cchMax
ParamCount=4
@=GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax);
[CheckDlgButton]
1=HWND hDlg
2=int nIDButton
3=UINT uCheck
ParamCount=3
@=CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck);
[CheckRadioButton]
1=HWND hDlg
2=int nIDFirstButton
3=int nIDLastButton
4=int nIDCheckButton
ParamCount=4
@=CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton);
[IsDlgButtonChecked]
1=HWND hDlg
2=int nIDButton
ParamCount=2
@=IsDlgButtonChecked(HWND hDlg, int nIDButton);
[SendDlgItemMessageA]
1=HWND hDlg
2=int nIDDlgItem
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
[SendDlgItemMessageW]
1=HWND hDlg
2=int nIDDlgItem
3=UINT Msg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
[GetNextDlgGroupItem]
1=HWND hDlg
2=HWND hCtl
3=BOOL bPrevious
ParamCount=3
@=GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious);
[GetNextDlgTabItem]
1=HWND hDlg
2=HWND hCtl
3=BOOL bPrevious
ParamCount=3
@=GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious);
[GetDlgCtrlID]
1=HWND hWnd
ParamCount=1
@=GetDlgCtrlID(HWND hWnd);
[GetDialogBaseUnits]
ParamCount=0
@=GetDialogBaseUnits();
[DefDlgProcA]
1=HWND hDlg
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
[DefDlgProcW]
1=HWND hDlg
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
[CallMsgFilterA]
1=LPMSG lpMsg
2=int nCode
ParamCount=2
@=CallMsgFilterA(LPMSG lpMsg, int nCode);
[CallMsgFilterW]
1=LPMSG lpMsg
2=int nCode
ParamCount=2
@=CallMsgFilterW(LPMSG lpMsg, int nCode);
[OpenClipboard]
1=HWND hWndNewOwner
ParamCount=1
@=OpenClipboard(HWND hWndNewOwner);
[CloseClipboard]
ParamCount=0
@=CloseClipboard();
[GetClipboardSequenceNumber]
ParamCount=0
@=GetClipboardSequenceNumber();
[GetClipboardOwner]
ParamCount=0
@=GetClipboardOwner();
[SetClipboardViewer]
1=HWND hWndNewViewer
ParamCount=1
@=SetClipboardViewer(HWND hWndNewViewer);
[GetClipboardViewer]
ParamCount=0
@=GetClipboardViewer();
[ChangeClipboardChain]
1=HWND hWndRemove
2=HWND hWndNewNext
ParamCount=2
@=ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext);
[SetClipboardData]
1=UINT uFormat
2=HANDLE hMem
ParamCount=2
@=SetClipboardData(UINT uFormat, HANDLE hMem);
[GetClipboardData]
1=UINT uFormat
ParamCount=1
@=GetClipboardData(UINT uFormat);
[RegisterClipboardFormatA]
1=LPCSTR lpszFormat
ParamCount=1
@=RegisterClipboardFormatA(LPCSTR lpszFormat);
[RegisterClipboardFormatW]
1=LPCWSTR lpszFormat
ParamCount=1
@=RegisterClipboardFormatW(LPCWSTR lpszFormat);
[CountClipboardFormats]
ParamCount=0
@=CountClipboardFormats();
[EnumClipboardFormats]
1=UINT format
ParamCount=1
@=EnumClipboardFormats(UINT format);
[GetClipboardFormatNameA]
1=UINT format
2=LPSTR lpszFormatName
3=int cchMaxCount
ParamCount=3
@=GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount);
[GetClipboardFormatNameW]
1=UINT format
2=LPWSTR lpszFormatName
3=int cchMaxCount
ParamCount=3
@=GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount);
[EmptyClipboard]
ParamCount=0
@=EmptyClipboard();
[IsClipboardFormatAvailable]
1=UINT format
ParamCount=1
@=IsClipboardFormatAvailable(UINT format);
[GetPriorityClipboardFormat]
1=UINT *paFormatPriorityList
2=int cFormats
ParamCount=2
@=GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats);
[GetOpenClipboardWindow]
ParamCount=0
@=GetOpenClipboardWindow();
[AddClipboardFormatListener]
1=HWND hwnd
ParamCount=1
@=AddClipboardFormatListener(HWND hwnd);
[RemoveClipboardFormatListener]
1=HWND hwnd
ParamCount=1
@=RemoveClipboardFormatListener(HWND hwnd);
[GetUpdatedClipboardFormats]
1=PUINT lpuiFormats
2=UINT cFormats
3=PUINT pcFormatsOut
ParamCount=3
@=GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut);
[CharToOemA]
1=LPCSTR pSrc
2=LPSTR pDst
ParamCount=2
@=CharToOemA(LPCSTR pSrc, LPSTR pDst);
[CharToOemW]
1=LPCWSTR pSrc
2=LPSTR pDst
ParamCount=2
@=CharToOemW(LPCWSTR pSrc, LPSTR pDst);
[OemToCharA]
1=LPCSTR pSrc
2=LPSTR pDst
ParamCount=2
@=OemToCharA(LPCSTR pSrc, LPSTR pDst);
[OemToCharW]
1=LPCSTR pSrc
2=LPWSTR pDst
ParamCount=2
@=OemToCharW(LPCSTR pSrc, LPWSTR pDst);
[CharToOemBuffA]
1=LPCSTR lpszSrc
2=LPSTR lpszDst
3=DWORD cchDstLength
ParamCount=3
@=CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);
[CharToOemBuffW]
1=LPCWSTR lpszSrc
2=LPSTR lpszDst
3=DWORD cchDstLength
ParamCount=3
@=CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);
[OemToCharBuffA]
1=LPCSTR lpszSrc
2=LPSTR lpszDst
3=DWORD cchDstLength
ParamCount=3
@=OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);
[OemToCharBuffW]
1=LPCSTR lpszSrc
2=LPWSTR lpszDst
3=DWORD cchDstLength
ParamCount=3
@=OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength);
[CharUpperA]
1=LPSTR lpsz
ParamCount=1
@=CharUpperA(LPSTR lpsz);
[CharUpperW]
1=LPWSTR lpsz
ParamCount=1
@=CharUpperW(LPWSTR lpsz);
[CharUpperBuffA]
1=LPSTR lpsz
2=DWORD cchLength
ParamCount=2
@=CharUpperBuffA(LPSTR lpsz, DWORD cchLength);
[CharUpperBuffW]
1=LPWSTR lpsz
2=DWORD cchLength
ParamCount=2
@=CharUpperBuffW(LPWSTR lpsz, DWORD cchLength);
[CharLowerA]
1=LPSTR lpsz
ParamCount=1
@=CharLowerA(LPSTR lpsz);
[CharLowerW]
1=LPWSTR lpsz
ParamCount=1
@=CharLowerW(LPWSTR lpsz);
[CharLowerBuffA]
1=LPSTR lpsz
2=DWORD cchLength
ParamCount=2
@=CharLowerBuffA(LPSTR lpsz, DWORD cchLength);
[CharLowerBuffW]
1=LPWSTR lpsz
2=DWORD cchLength
ParamCount=2
@=CharLowerBuffW(LPWSTR lpsz, DWORD cchLength);
[CharNextA]
1=LPCSTR lpsz
ParamCount=1
@=CharNextA(LPCSTR lpsz);
[CharNextW]
1=LPCWSTR lpsz
ParamCount=1
@=CharNextW(LPCWSTR lpsz);
[CharPrevA]
1=LPCSTR lpszStart
2=LPCSTR lpszCurrent
ParamCount=2
@=CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent);
[CharPrevW]
1=LPCWSTR lpszStart
2=LPCWSTR lpszCurrent
ParamCount=2
@=CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);
[CharNextExA]
1=WORD CodePage
2=LPCSTR lpCurrentChar
3=DWORD dwFlags
ParamCount=3
@=CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags);
[CharPrevExA]
1=WORD CodePage
2=LPCSTR lpStart
3=LPCSTR lpCurrentChar
4=DWORD dwFlags
ParamCount=4
@=CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags);
[IsCharAlphaA]
1=CHAR ch
ParamCount=1
@=IsCharAlphaA(CHAR ch);
[IsCharAlphaW]
1=WCHAR ch
ParamCount=1
@=IsCharAlphaW(WCHAR ch);
[IsCharAlphaNumericA]
1=CHAR ch
ParamCount=1
@=IsCharAlphaNumericA(CHAR ch);
[IsCharAlphaNumericW]
1=WCHAR ch
ParamCount=1
@=IsCharAlphaNumericW(WCHAR ch);
[IsCharUpperA]
1=CHAR ch
ParamCount=1
@=IsCharUpperA(CHAR ch);
[IsCharUpperW]
1=WCHAR ch
ParamCount=1
@=IsCharUpperW(WCHAR ch);
[IsCharLowerA]
1=CHAR ch
ParamCount=1
@=IsCharLowerA(CHAR ch);
[IsCharLowerW]
1=WCHAR ch
ParamCount=1
@=IsCharLowerW(WCHAR ch);
[SetFocus]
1=HWND hWnd
ParamCount=1
@=SetFocus(HWND hWnd);
[GetActiveWindow]
ParamCount=0
@=GetActiveWindow();
[GetFocus]
ParamCount=0
@=GetFocus();
[GetKBCodePage]
ParamCount=0
@=GetKBCodePage();
[GetKeyState]
1=int nVirtKey
ParamCount=1
@=GetKeyState(int nVirtKey);
[GetAsyncKeyState]
1=int vKey
ParamCount=1
@=GetAsyncKeyState(int vKey);
[GetKeyboardState]
1=PBYTE lpKeyState
ParamCount=1
@=GetKeyboardState(PBYTE lpKeyState);
[SetKeyboardState]
1=LPBYTE lpKeyState
ParamCount=1
@=SetKeyboardState(LPBYTE lpKeyState);
[GetKeyNameTextA]
1=LONG lParam
2=LPSTR lpString
3=int cchSize
ParamCount=3
@=GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize);
[GetKeyNameTextW]
1=LONG lParam
2=LPWSTR lpString
3=int cchSize
ParamCount=3
@=GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize);
[GetKeyboardType]
1=int nTypeFlag
ParamCount=1
@=GetKeyboardType(int nTypeFlag);
[ToAscii]
1=UINT uVirtKey
2=UINT uScanCode
3=BYTE *lpKeyState
4=LPWORD lpChar
5=UINT uFlags
ParamCount=5
@=ToAscii(UINT uVirtKey, UINT uScanCode, BYTE *lpKeyState, LPWORD lpChar, UINT uFlags);
[ToAsciiEx]
1=UINT uVirtKey
2=UINT uScanCode
3=BYTE *lpKeyState
4=LPWORD lpChar
5=UINT uFlags
6=HKL dwhkl
ParamCount=6
@=ToAsciiEx(UINT uVirtKey, UINT uScanCode, BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl);
[ToUnicode]
1=UINT wVirtKey
2=UINT wScanCode
3=BYTE *lpKeyState
4=LPWSTR pwszBuff
5=int cchBuff
6=UINT wFlags
ParamCount=6
@=ToUnicode(UINT wVirtKey, UINT wScanCode, BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags);
[OemKeyScan]
1=WORD wOemChar
ParamCount=1
@=OemKeyScan(WORD wOemChar);
[VkKeyScanA]
1=CHAR ch
ParamCount=1
@=VkKeyScanA(CHAR ch);
[VkKeyScanW]
1=WCHAR ch
ParamCount=1
@=VkKeyScanW(WCHAR ch);
[VkKeyScanExA]
1=CHAR ch
2=HKL dwhkl
ParamCount=2
@=VkKeyScanExA(CHAR ch, HKL dwhkl);
[VkKeyScanExW]
1=WCHAR ch
2=HKL dwhkl
ParamCount=2
@=VkKeyScanExW(WCHAR ch, HKL dwhkl);
[keybd_event]
1=BYTE bVk
2=BYTE bScan
3=DWORD dwFlags
4=ULONG_PTR dwExtraInfo
ParamCount=4
@=keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo);
[mouse_event]
1=DWORD dwFlags
2=DWORD dx
3=DWORD dy
4=DWORD dwData
5=ULONG_PTR dwExtraInfo
ParamCount=5
@=mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo);
[SendInput]
1=UINT cInputs
2=LPINPUT pInputs
3=int cbSize
ParamCount=3
@=SendInput(UINT cInputs, LPINPUT pInputs, int cbSize);
[GetTouchInputInfo]
1=HTOUCHINPUT hTouchInput
2=UINT cInputs
3=PTOUCHINPUT pInputs
4=int cbSize
ParamCount=4
@=GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize);
[CloseTouchInputHandle]
1=HTOUCHINPUT hTouchInput
ParamCount=1
@=CloseTouchInputHandle(HTOUCHINPUT hTouchInput);
[RegisterTouchWindow]
1=HWND hwnd
2=ULONG ulFlags
ParamCount=2
@=RegisterTouchWindow(HWND hwnd, ULONG ulFlags);
[UnregisterTouchWindow]
1=HWND hwnd
ParamCount=1
@=UnregisterTouchWindow(HWND hwnd);
[IsTouchWindow]
1=HWND hwnd
2=PULONG pulFlags
ParamCount=2
@=IsTouchWindow(HWND hwnd, PULONG pulFlags);
[InitializeTouchInjection]
1=UINT32 maxCount
2=DWORD dwMode
ParamCount=2
@=InitializeTouchInjection(UINT32 maxCount, DWORD dwMode);
[InjectTouchInput]
1=UINT32 count
2=POINTER_TOUCH_INFO *contacts
ParamCount=2
@=InjectTouchInput(UINT32 count, POINTER_TOUCH_INFO *contacts);
[GetPointerType]
1=UINT32 pointerId
2=POINTER_INPUT_TYPE *pointerType
ParamCount=2
@=GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType);
[GetPointerCursorId]
1=UINT32 pointerId
2=UINT32 *cursorId
ParamCount=2
@=GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId);
[GetPointerInfo]
1=UINT32 pointerId
2=POINTER_INFO *pointerInfo
ParamCount=2
@=GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo);
[GetPointerInfoHistory]
1=UINT32 pointerId
2=UINT32 *entriesCount
3=POINTER_INFO *pointerInfo
ParamCount=3
@=GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo);
[GetPointerFrameInfo]
1=UINT32 pointerId
2=UINT32 *pointerCount
3=POINTER_INFO *pointerInfo
ParamCount=3
@=GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo);
[GetPointerFrameInfoHistory]
1=UINT32 pointerId
2=UINT32 *entriesCount
3=UINT32 *pointerCount
4=POINTER_INFO *pointerInfo
ParamCount=4
@=GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo);
[GetPointerTouchInfo]
1=UINT32 pointerId
2=POINTER_TOUCH_INFO *touchInfo
ParamCount=2
@=GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo);
[GetPointerTouchInfoHistory]
1=UINT32 pointerId
2=UINT32 *entriesCount
3=POINTER_TOUCH_INFO *touchInfo
ParamCount=3
@=GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo);
[GetPointerFrameTouchInfo]
1=UINT32 pointerId
2=UINT32 *pointerCount
3=POINTER_TOUCH_INFO *touchInfo
ParamCount=3
@=GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo);
[GetPointerFrameTouchInfoHistory]
1=UINT32 pointerId
2=UINT32 *entriesCount
3=UINT32 *pointerCount
4=POINTER_TOUCH_INFO *touchInfo
ParamCount=4
@=GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo);
[GetPointerPenInfo]
1=UINT32 pointerId
2=POINTER_PEN_INFO *penInfo
ParamCount=2
@=GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo);
[GetPointerPenInfoHistory]
1=UINT32 pointerId
2=UINT32 *entriesCount
3=POINTER_PEN_INFO *penInfo
ParamCount=3
@=GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo);
[GetPointerFramePenInfo]
1=UINT32 pointerId
2=UINT32 *pointerCount
3=POINTER_PEN_INFO *penInfo
ParamCount=3
@=GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo);
[GetPointerFramePenInfoHistory]
1=UINT32 pointerId
2=UINT32 *entriesCount
3=UINT32 *pointerCount
4=POINTER_PEN_INFO *penInfo
ParamCount=4
@=GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo);
[SkipPointerFrameMessages]
1=UINT32 pointerId
ParamCount=1
@=SkipPointerFrameMessages(UINT32 pointerId);
[RegisterPointerInputTarget]
1=HWND hwnd
2=POINTER_INPUT_TYPE pointerType
ParamCount=2
@=RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType);
[UnregisterPointerInputTarget]
1=HWND hwnd
2=POINTER_INPUT_TYPE pointerType
ParamCount=2
@=UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType);
[EnableMouseInPointer]
1=BOOL fEnable
ParamCount=1
@=EnableMouseInPointer(BOOL fEnable);
[IsMouseInPointerEnabled]
ParamCount=0
@=IsMouseInPointerEnabled();
[RegisterTouchHitTestingWindow]
1=HWND hwnd
2=ULONG value
ParamCount=2
@=RegisterTouchHitTestingWindow(HWND hwnd, ULONG value);
[EvaluateProximityToRect]
1=RECT *controlBoundingBox
2=TOUCH_HIT_TESTING_INPUT *pHitTestingInput
3=TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval
ParamCount=3
@=EvaluateProximityToRect(RECT *controlBoundingBox, TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);
[EvaluateProximityToPolygon]
1=UINT32 numVertices
2=POINT *controlPolygon
3=TOUCH_HIT_TESTING_INPUT *pHitTestingInput
4=TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval
ParamCount=4
@=EvaluateProximityToPolygon(UINT32 numVertices, POINT *controlPolygon, TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);
[PackTouchHitTestingProximityEvaluation]
1=TOUCH_HIT_TESTING_INPUT *pHitTestingInput
2=TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval
ParamCount=2
@=PackTouchHitTestingProximityEvaluation(TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);
[GetWindowFeedbackSetting]
1=HWND hwnd
2=FEEDBACK_TYPE feedback
3=DWORD dwFlags
4=UINT32* pSize
5=VOID* config
ParamCount=5
@=GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32* pSize, VOID* config);
[SetWindowFeedbackSetting]
1=HWND hwnd
2=FEEDBACK_TYPE feedback
3=DWORD dwFlags
4=UINT32 size
5=VOID* configuration
ParamCount=5
@=SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, VOID* configuration);
[GetPointerInputTransform]
1=UINT32 pointerId
2=UINT32 historyCount
3=INPUT_TRANSFORM *inputTransform
ParamCount=3
@=GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform);
[GetLastInputInfo]
1=PLASTINPUTINFO plii
ParamCount=1
@=GetLastInputInfo(PLASTINPUTINFO plii);
[MapVirtualKeyA]
1=UINT uCode
2=UINT uMapType
ParamCount=2
@=MapVirtualKeyA(UINT uCode, UINT uMapType);
[MapVirtualKeyW]
1=UINT uCode
2=UINT uMapType
ParamCount=2
@=MapVirtualKeyW(UINT uCode, UINT uMapType);
[MapVirtualKeyExA]
1=UINT uCode
2=UINT uMapType
3=HKL dwhkl
ParamCount=3
@=MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl);
[MapVirtualKeyExW]
1=UINT uCode
2=UINT uMapType
3=HKL dwhkl
ParamCount=3
@=MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl);
[GetInputState]
ParamCount=0
@=GetInputState();
[GetQueueStatus]
1=UINT flags
ParamCount=1
@=GetQueueStatus(UINT flags);
[GetCapture]
ParamCount=0
@=GetCapture();
[SetCapture]
1=HWND hWnd
ParamCount=1
@=SetCapture(HWND hWnd);
[ReleaseCapture]
ParamCount=0
@=ReleaseCapture();
[MsgWaitForMultipleObjects]
1=DWORD nCount
2=HANDLE *pHandles
3=BOOL fWaitAll
4=DWORD dwMilliseconds
5=DWORD dwWakeMask
ParamCount=5
@=MsgWaitForMultipleObjects(DWORD nCount, HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);
[MsgWaitForMultipleObjectsEx]
1=DWORD nCount
2=HANDLE *pHandles
3=DWORD dwMilliseconds
4=DWORD dwWakeMask
5=DWORD dwFlags
ParamCount=5
@=MsgWaitForMultipleObjectsEx(DWORD nCount, HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags);
[SetTimer]
1=HWND hWnd
2=UINT_PTR nIDEvent
3=UINT uElapse
4=TIMERPROC lpTimerFunc
ParamCount=4
@=SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
[SetCoalescableTimer]
1=HWND hWnd
2=UINT_PTR nIDEvent
3=UINT uElapse
4=TIMERPROC lpTimerFunc
5=ULONG uToleranceDelay
ParamCount=5
@=SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay);
[KillTimer]
1=HWND hWnd
2=UINT_PTR uIDEvent
ParamCount=2
@=KillTimer(HWND hWnd, UINT_PTR uIDEvent);
[IsWindowUnicode]
1=HWND hWnd
ParamCount=1
@=IsWindowUnicode(HWND hWnd);
[EnableWindow]
1=HWND hWnd
2=BOOL bEnable
ParamCount=2
@=EnableWindow(HWND hWnd, BOOL bEnable);
[IsWindowEnabled]
1=HWND hWnd
ParamCount=1
@=IsWindowEnabled(HWND hWnd);
[LoadAcceleratorsA]
1=HINSTANCE hInstance
2=LPCSTR lpTableName
ParamCount=2
@=LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName);
[LoadAcceleratorsW]
1=HINSTANCE hInstance
2=LPCWSTR lpTableName
ParamCount=2
@=LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName);
[CreateAcceleratorTableA]
1=LPACCEL paccel
2=int cAccel
ParamCount=2
@=CreateAcceleratorTableA(LPACCEL paccel, int cAccel);
[CreateAcceleratorTableW]
1=LPACCEL paccel
2=int cAccel
ParamCount=2
@=CreateAcceleratorTableW(LPACCEL paccel, int cAccel);
[DestroyAcceleratorTable]
1=HACCEL hAccel
ParamCount=1
@=DestroyAcceleratorTable(HACCEL hAccel);
[CopyAcceleratorTableA]
1=HACCEL hAccelSrc
2=LPACCEL lpAccelDst
3=int cAccelEntries
ParamCount=3
@=CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries);
[CopyAcceleratorTableW]
1=HACCEL hAccelSrc
2=LPACCEL lpAccelDst
3=int cAccelEntries
ParamCount=3
@=CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries);
[TranslateAcceleratorA]
1=HWND hWnd
2=HACCEL hAccTable
3=LPMSG lpMsg
ParamCount=3
@=TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
[TranslateAcceleratorW]
1=HWND hWnd
2=HACCEL hAccTable
3=LPMSG lpMsg
ParamCount=3
@=TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
[GetSystemMetrics]
1=int nIndex
ParamCount=1
@=GetSystemMetrics(int nIndex);
[LoadMenuA]
1=HINSTANCE hInstance
2=LPCSTR lpMenuName
ParamCount=2
@=LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName);
[LoadMenuW]
1=HINSTANCE hInstance
2=LPCWSTR lpMenuName
ParamCount=2
@=LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);
[LoadMenuIndirectA]
1=MENUTEMPLATEA *lpMenuTemplate
ParamCount=1
@=LoadMenuIndirectA(MENUTEMPLATEA *lpMenuTemplate);
[LoadMenuIndirectW]
1=MENUTEMPLATEW *lpMenuTemplate
ParamCount=1
@=LoadMenuIndirectW(MENUTEMPLATEW *lpMenuTemplate);
[GetMenu]
1=HWND hWnd
ParamCount=1
@=GetMenu(HWND hWnd);
[SetMenu]
1=HWND hWnd
2=HMENU hMenu
ParamCount=2
@=SetMenu(HWND hWnd, HMENU hMenu);
[ChangeMenuA]
1=HMENU hMenu
2=UINT cmd
3=LPCSTR lpszNewItem
4=UINT cmdInsert
5=UINT flags
ParamCount=5
@=ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags);
[ChangeMenuW]
1=HMENU hMenu
2=UINT cmd
3=LPCWSTR lpszNewItem
4=UINT cmdInsert
5=UINT flags
ParamCount=5
@=ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags);
[HiliteMenuItem]
1=HWND hWnd
2=HMENU hMenu
3=UINT uIDHiliteItem
4=UINT uHilite
ParamCount=4
@=HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite);
[GetMenuStringA]
1=HMENU hMenu
2=UINT uIDItem
3=LPSTR lpString
4=int cchMax
5=UINT flags
ParamCount=5
@=GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags);
[GetMenuStringW]
1=HMENU hMenu
2=UINT uIDItem
3=LPWSTR lpString
4=int cchMax
5=UINT flags
ParamCount=5
@=GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags);
[GetMenuState]
1=HMENU hMenu
2=UINT uId
3=UINT uFlags
ParamCount=3
@=GetMenuState(HMENU hMenu, UINT uId, UINT uFlags);
[DrawMenuBar]
1=HWND hWnd
ParamCount=1
@=DrawMenuBar(HWND hWnd);
[GetSystemMenu]
1=HWND hWnd
2=BOOL bRevert
ParamCount=2
@=GetSystemMenu(HWND hWnd, BOOL bRevert);
[CreateMenu]
ParamCount=0
@=CreateMenu();
[CreatePopupMenu]
ParamCount=0
@=CreatePopupMenu();
[DestroyMenu]
1=HMENU hMenu
ParamCount=1
@=DestroyMenu(HMENU hMenu);
[CheckMenuItem]
1=HMENU hMenu
2=UINT uIDCheckItem
3=UINT uCheck
ParamCount=3
@=CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck);
[EnableMenuItem]
1=HMENU hMenu
2=UINT uIDEnableItem
3=UINT uEnable
ParamCount=3
@=EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
[GetSubMenu]
1=HMENU hMenu
2=int nPos
ParamCount=2
@=GetSubMenu(HMENU hMenu, int nPos);
[GetMenuItemID]
1=HMENU hMenu
2=int nPos
ParamCount=2
@=GetMenuItemID(HMENU hMenu, int nPos);
[GetMenuItemCount]
1=HMENU hMenu
ParamCount=1
@=GetMenuItemCount(HMENU hMenu);
[InsertMenuA]
1=HMENU hMenu
2=UINT uPosition
3=UINT uFlags
4=UINT_PTR uIDNewItem
5=LPCSTR lpNewItem
ParamCount=5
@=InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
[InsertMenuW]
1=HMENU hMenu
2=UINT uPosition
3=UINT uFlags
4=UINT_PTR uIDNewItem
5=LPCWSTR lpNewItem
ParamCount=5
@=InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
[AppendMenuA]
1=HMENU hMenu
2=UINT uFlags
3=UINT_PTR uIDNewItem
4=LPCSTR lpNewItem
ParamCount=4
@=AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
[AppendMenuW]
1=HMENU hMenu
2=UINT uFlags
3=UINT_PTR uIDNewItem
4=LPCWSTR lpNewItem
ParamCount=4
@=AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
[ModifyMenuA]
1=HMENU hMnu
2=UINT uPosition
3=UINT uFlags
4=UINT_PTR uIDNewItem
5=LPCSTR lpNewItem
ParamCount=5
@=ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
[ModifyMenuW]
1=HMENU hMnu
2=UINT uPosition
3=UINT uFlags
4=UINT_PTR uIDNewItem
5=LPCWSTR lpNewItem
ParamCount=5
@=ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
[RemoveMenu]
1=HMENU hMenu
2=UINT uPosition
3=UINT uFlags
ParamCount=3
@=RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags);
[DeleteMenu]
1=HMENU hMenu
2=UINT uPosition
3=UINT uFlags
ParamCount=3
@=DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags);
[SetMenuItemBitmaps]
1=HMENU hMenu
2=UINT uPosition
3=UINT uFlags
4=HBITMAP hBitmapUnchecked
5=HBITMAP hBitmapChecked
ParamCount=5
@=SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked);
[GetMenuCheckMarkDimensions]
ParamCount=0
@=GetMenuCheckMarkDimensions();
[TrackPopupMenu]
1=HMENU hMenu
2=UINT uFlags
3=int x
4=int y
5=int nReserved
6=HWND hWnd
7=RECT *prcRect
ParamCount=7
@=TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, RECT *prcRect);
[TrackPopupMenuEx]
1=HMENU hMenu
2=UINT uFlags
3=int x
4=int y
5=HWND hwnd
6=LPTPMPARAMS lptpm
ParamCount=6
@=TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm);
[CalculatePopupWindowPosition]
1=POINT *anchorPoint
2=SIZE *windowSize
3=UINT flags
4=RECT *excludeRect
5=RECT *popupWindowPosition
ParamCount=5
@=CalculatePopupWindowPosition(POINT *anchorPoint, SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition);
[GetMenuInfo]
1=HMENU
2=LPMENUINFO
ParamCount=2
@=GetMenuInfo(HMENU, LPMENUINFO);
[SetMenuInfo]
1=HMENU
2=LPCMENUINFO
ParamCount=2
@=SetMenuInfo(HMENU, LPCMENUINFO);
[EndMenu]
ParamCount=0
@=EndMenu();
[InsertMenuItemA]
1=HMENU hmenu
2=UINT item
3=BOOL fByPosition
4=LPCMENUITEMINFOA lpmi
ParamCount=4
@=InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi);
[InsertMenuItemW]
1=HMENU hmenu
2=UINT item
3=BOOL fByPosition
4=LPCMENUITEMINFOW lpmi
ParamCount=4
@=InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi);
[GetMenuItemInfoA]
1=HMENU hmenu
2=UINT item
3=BOOL fByPosition
4=LPMENUITEMINFOA lpmii
ParamCount=4
@=GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii);
[GetMenuItemInfoW]
1=HMENU hmenu
2=UINT item
3=BOOL fByPosition
4=LPMENUITEMINFOW lpmii
ParamCount=4
@=GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii);
[SetMenuItemInfoA]
1=HMENU hmenu
2=UINT item
3=BOOL fByPositon
4=LPCMENUITEMINFOA lpmii
ParamCount=4
@=SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii);
[SetMenuItemInfoW]
1=HMENU hmenu
2=UINT item
3=BOOL fByPositon
4=LPCMENUITEMINFOW lpmii
ParamCount=4
@=SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii);
[GetMenuDefaultItem]
1=HMENU hMenu
2=UINT fByPos
3=UINT gmdiFlags
ParamCount=3
@=GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags);
[SetMenuDefaultItem]
1=HMENU hMenu
2=UINT uItem
3=UINT fByPos
ParamCount=3
@=SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos);
[GetMenuItemRect]
1=HWND hWnd
2=HMENU hMenu
3=UINT uItem
4=LPRECT lprcItem
ParamCount=4
@=GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem);
[MenuItemFromPoint]
1=HWND hWnd
2=HMENU hMenu
3=POINT ptScreen
ParamCount=3
@=MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen);
[DragObject]
1=HWND hwndParent
2=HWND hwndFrom
3=UINT fmt
4=ULONG_PTR data
5=HCURSOR hcur
ParamCount=5
@=DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur);
[DragDetect]
1=HWND hwnd
2=POINT pt
ParamCount=2
@=DragDetect(HWND hwnd, POINT pt);
[DrawIcon]
1=HDC hDC
2=int X
3=int Y
4=HICON hIcon
ParamCount=4
@=DrawIcon(HDC hDC, int X, int Y, HICON hIcon);
[DrawTextA]
1=HDC hdc
2=LPCSTR lpchText
3=int cchText
4=LPRECT lprc
5=UINT format
ParamCount=5
@=DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
[DrawTextW]
1=HDC hdc
2=LPCWSTR lpchText
3=int cchText
4=LPRECT lprc
5=UINT format
ParamCount=5
@=DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
[DrawTextExA]
1=HDC hdc
2=LPSTR lpchText
3=int cchText
4=LPRECT lprc
5=UINT format
6=LPDRAWTEXTPARAMS lpdtp
ParamCount=6
@=DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp);
[DrawTextExW]
1=HDC hdc
2=LPWSTR lpchText
3=int cchText
4=LPRECT lprc
5=UINT format
6=LPDRAWTEXTPARAMS lpdtp
ParamCount=6
@=DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp);
[GrayStringA]
1=HDC hDC
2=HBRUSH hBrush
3=GRAYSTRINGPROC lpOutputFunc
4=LPARAM lpData
5=int nCount
6=int X
7=int Y
8=int nWidth
9=int nHeight
ParamCount=9
@=GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
[GrayStringW]
1=HDC hDC
2=HBRUSH hBrush
3=GRAYSTRINGPROC lpOutputFunc
4=LPARAM lpData
5=int nCount
6=int X
7=int Y
8=int nWidth
9=int nHeight
ParamCount=9
@=GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
[DrawStateA]
1=HDC hdc
2=HBRUSH hbrFore
3=DRAWSTATEPROC qfnCallBack
4=LPARAM lData
5=WPARAM wData
6=int x
7=int y
8=int cx
9=int cy
10=UINT uFlags
ParamCount=10
@=DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags);
[DrawStateW]
1=HDC hdc
2=HBRUSH hbrFore
3=DRAWSTATEPROC qfnCallBack
4=LPARAM lData
5=WPARAM wData
6=int x
7=int y
8=int cx
9=int cy
10=UINT uFlags
ParamCount=10
@=DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags);
[TabbedTextOutA]
1=HDC hdc
2=int x
3=int y
4=LPCSTR lpString
5=int chCount
6=int nTabPositions
7=INT *lpnTabStopPositions
8=int nTabOrigin
ParamCount=8
@=TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, INT *lpnTabStopPositions, int nTabOrigin);
[TabbedTextOutW]
1=HDC hdc
2=int x
3=int y
4=LPCWSTR lpString
5=int chCount
6=int nTabPositions
7=INT *lpnTabStopPositions
8=int nTabOrigin
ParamCount=8
@=TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, INT *lpnTabStopPositions, int nTabOrigin);
[GetTabbedTextExtentA]
1=HDC hdc
2=LPCSTR lpString
3=int chCount
4=int nTabPositions
5=INT *lpnTabStopPositions
ParamCount=5
@=GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, INT *lpnTabStopPositions);
[GetTabbedTextExtentW]
1=HDC hdc
2=LPCWSTR lpString
3=int chCount
4=int nTabPositions
5=INT *lpnTabStopPositions
ParamCount=5
@=GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, INT *lpnTabStopPositions);
[UpdateWindow]
1=HWND hWnd
ParamCount=1
@=UpdateWindow(HWND hWnd);
[SetActiveWindow]
1=HWND hWnd
ParamCount=1
@=SetActiveWindow(HWND hWnd);
[GetForegroundWindow]
ParamCount=0
@=GetForegroundWindow();
[PaintDesktop]
1=HDC hdc
ParamCount=1
@=PaintDesktop(HDC hdc);
[SwitchToThisWindow]
1=HWND hwnd
2=BOOL fUnknown
ParamCount=2
@=SwitchToThisWindow(HWND hwnd, BOOL fUnknown);
[SetForegroundWindow]
1=HWND hWnd
ParamCount=1
@=SetForegroundWindow(HWND hWnd);
[AllowSetForegroundWindow]
1=DWORD dwProcessId
ParamCount=1
@=AllowSetForegroundWindow(DWORD dwProcessId);
[LockSetForegroundWindow]
1=UINT uLockCode
ParamCount=1
@=LockSetForegroundWindow(UINT uLockCode);
[WindowFromDC]
1=HDC hDC
ParamCount=1
@=WindowFromDC(HDC hDC);
[GetDC]
1=HWND hWnd
ParamCount=1
@=GetDC(HWND hWnd);
[GetDCEx]
1=HWND hWnd
2=HRGN hrgnClip
3=DWORD flags
ParamCount=3
@=GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags);
[GetWindowDC]
1=HWND hWnd
ParamCount=1
@=GetWindowDC(HWND hWnd);
[ReleaseDC]
1=HWND hWnd
2=HDC hDC
ParamCount=2
@=ReleaseDC(HWND hWnd, HDC hDC);
[BeginPaint]
1=HWND hWnd
2=LPPAINTSTRUCT lpPaint
ParamCount=2
@=BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
[EndPaint]
1=HWND hWnd
2=PAINTSTRUCT *lpPaint
ParamCount=2
@=EndPaint(HWND hWnd, PAINTSTRUCT *lpPaint);
[GetUpdateRect]
1=HWND hWnd
2=LPRECT lpRect
3=BOOL bErase
ParamCount=3
@=GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase);
[GetUpdateRgn]
1=HWND hWnd
2=HRGN hRgn
3=BOOL bErase
ParamCount=3
@=GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
[SetWindowRgn]
1=HWND hWnd
2=HRGN hRgn
3=BOOL bRedraw
ParamCount=3
@=SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw);
[GetWindowRgn]
1=HWND hWnd
2=HRGN hRgn
ParamCount=2
@=GetWindowRgn(HWND hWnd, HRGN hRgn);
[GetWindowRgnBox]
1=HWND hWnd
2=LPRECT lprc
ParamCount=2
@=GetWindowRgnBox(HWND hWnd, LPRECT lprc);
[ExcludeUpdateRgn]
1=HDC hDC
2=HWND hWnd
ParamCount=2
@=ExcludeUpdateRgn(HDC hDC, HWND hWnd);
[InvalidateRect]
1=HWND hWnd
2=RECT *lpRect
3=BOOL bErase
ParamCount=3
@=InvalidateRect(HWND hWnd, RECT *lpRect, BOOL bErase);
[ValidateRect]
1=HWND hWnd
2=RECT *lpRect
ParamCount=2
@=ValidateRect(HWND hWnd, RECT *lpRect);
[InvalidateRgn]
1=HWND hWnd
2=HRGN hRgn
3=BOOL bErase
ParamCount=3
@=InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
[ValidateRgn]
1=HWND hWnd
2=HRGN hRgn
ParamCount=2
@=ValidateRgn(HWND hWnd, HRGN hRgn);
[RedrawWindow]
1=HWND hWnd
2=RECT *lprcUpdate
3=HRGN hrgnUpdate
4=UINT flags
ParamCount=4
@=RedrawWindow(HWND hWnd, RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
[LockWindowUpdate]
1=HWND hWndLock
ParamCount=1
@=LockWindowUpdate(HWND hWndLock);
[ScrollWindow]
1=HWND hWnd
2=int XAmount
3=int YAmount
4=RECT *lpRect
5=RECT *lpClipRect
ParamCount=5
@=ScrollWindow(HWND hWnd, int XAmount, int YAmount, RECT *lpRect, RECT *lpClipRect);
[ScrollDC]
1=HDC hDC
2=int dx
3=int dy
4=RECT *lprcScroll
5=RECT *lprcClip
6=HRGN hrgnUpdate
7=LPRECT lprcUpdate
ParamCount=7
@=ScrollDC(HDC hDC, int dx, int dy, RECT *lprcScroll, RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate);
[ScrollWindowEx]
1=HWND hWnd
2=int dx
3=int dy
4=RECT *prcScroll
5=RECT *prcClip
6=HRGN hrgnUpdate
7=LPRECT prcUpdate
8=UINT flags
ParamCount=8
@=ScrollWindowEx(HWND hWnd, int dx, int dy, RECT *prcScroll, RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags);
[SetScrollPos]
1=HWND hWnd
2=int nBar
3=int nPos
4=BOOL bRedraw
ParamCount=4
@=SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw);
[GetScrollPos]
1=HWND hWnd
2=int nBar
ParamCount=2
@=GetScrollPos(HWND hWnd, int nBar);
[SetScrollRange]
1=HWND hWnd
2=int nBar
3=int nMinPos
4=int nMaxPos
5=BOOL bRedraw
ParamCount=5
@=SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw);
[GetScrollRange]
1=HWND hWnd
2=int nBar
3=LPINT lpMinPos
4=LPINT lpMaxPos
ParamCount=4
@=GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos);
[ShowScrollBar]
1=HWND hWnd
2=int wBar
3=BOOL bShow
ParamCount=3
@=ShowScrollBar(HWND hWnd, int wBar, BOOL bShow);
[EnableScrollBar]
1=HWND hWnd
2=UINT wSBflags
3=UINT wArrows
ParamCount=3
@=EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows);
[SetPropA]
1=HWND hWnd
2=LPCSTR lpString
3=HANDLE hData
ParamCount=3
@=SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData);
[SetPropW]
1=HWND hWnd
2=LPCWSTR lpString
3=HANDLE hData
ParamCount=3
@=SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);
[GetPropA]
1=HWND hWnd
2=LPCSTR lpString
ParamCount=2
@=GetPropA(HWND hWnd, LPCSTR lpString);
[GetPropW]
1=HWND hWnd
2=LPCWSTR lpString
ParamCount=2
@=GetPropW(HWND hWnd, LPCWSTR lpString);
[RemovePropA]
1=HWND hWnd
2=LPCSTR lpString
ParamCount=2
@=RemovePropA(HWND hWnd, LPCSTR lpString);
[RemovePropW]
1=HWND hWnd
2=LPCWSTR lpString
ParamCount=2
@=RemovePropW(HWND hWnd, LPCWSTR lpString);
[EnumPropsExA]
1=HWND hWnd
2=PROPENUMPROCEXA lpEnumFunc
3=LPARAM lParam
ParamCount=3
@=EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam);
[EnumPropsExW]
1=HWND hWnd
2=PROPENUMPROCEXW lpEnumFunc
3=LPARAM lParam
ParamCount=3
@=EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam);
[EnumPropsA]
1=HWND hWnd
2=PROPENUMPROCA lpEnumFunc
ParamCount=2
@=EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc);
[EnumPropsW]
1=HWND hWnd
2=PROPENUMPROCW lpEnumFunc
ParamCount=2
@=EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc);
[SetWindowTextA]
1=HWND hWnd
2=LPCSTR lpString
ParamCount=2
@=SetWindowTextA(HWND hWnd, LPCSTR lpString);
[SetWindowTextW]
1=HWND hWnd
2=LPCWSTR lpString
ParamCount=2
@=SetWindowTextW(HWND hWnd, LPCWSTR lpString);
[GetWindowTextA]
1=HWND hWnd
2=LPSTR lpString
3=int nMaxCount
ParamCount=3
@=GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount);
[GetWindowTextW]
1=HWND hWnd
2=LPWSTR lpString
3=int nMaxCount
ParamCount=3
@=GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
[GetWindowTextLengthA]
1=HWND hWnd
ParamCount=1
@=GetWindowTextLengthA(HWND hWnd);
[GetWindowTextLengthW]
1=HWND hWnd
ParamCount=1
@=GetWindowTextLengthW(HWND hWnd);
[GetClientRect]
1=HWND hWnd
2=LPRECT lpRect
ParamCount=2
@=GetClientRect(HWND hWnd, LPRECT lpRect);
[GetWindowRect]
1=HWND hWnd
2=LPRECT lpRect
ParamCount=2
@=GetWindowRect(HWND hWnd, LPRECT lpRect);
[AdjustWindowRect]
1=LPRECT lpRect
2=DWORD dwStyle
3=BOOL bMenu
ParamCount=3
@=AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu);
[AdjustWindowRectEx]
1=LPRECT lpRect
2=DWORD dwStyle
3=BOOL bMenu
4=DWORD dwExStyle
ParamCount=4
@=AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
[SetWindowContextHelpId]
1=HWND
2=DWORD
ParamCount=2
@=SetWindowContextHelpId(HWND, DWORD);
[GetWindowContextHelpId]
1=HWND
ParamCount=1
@=GetWindowContextHelpId(HWND);
[SetMenuContextHelpId]
1=HMENU
2=DWORD
ParamCount=2
@=SetMenuContextHelpId(HMENU, DWORD);
[GetMenuContextHelpId]
1=HMENU
ParamCount=1
@=GetMenuContextHelpId(HMENU);
[MessageBoxA]
1=HWND hWnd
2=LPCSTR lpText
3=LPCSTR lpCaption
4=UINT uType
ParamCount=4
@=MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
[MessageBoxW]
1=HWND hWnd
2=LPCWSTR lpText
3=LPCWSTR lpCaption
4=UINT uType
ParamCount=4
@=MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
[MessageBoxExA]
1=HWND hWnd
2=LPCSTR lpText
3=LPCSTR lpCaption
4=UINT uType
5=WORD wLanguageId
ParamCount=5
@=MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId);
[MessageBoxExW]
1=HWND hWnd
2=LPCWSTR lpText
3=LPCWSTR lpCaption
4=UINT uType
5=WORD wLanguageId
ParamCount=5
@=MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId);
[MessageBoxIndirectA]
1=MSGBOXPARAMSA *lpmbp
ParamCount=1
@=MessageBoxIndirectA(MSGBOXPARAMSA *lpmbp);
[MessageBoxIndirectW]
1=MSGBOXPARAMSW *lpmbp
ParamCount=1
@=MessageBoxIndirectW(MSGBOXPARAMSW *lpmbp);
[MessageBeep]
1=UINT uType
ParamCount=1
@=MessageBeep(UINT uType);
[ShowCursor]
1=BOOL bShow
ParamCount=1
@=ShowCursor(BOOL bShow);
[SetCursorPos]
1=int X
2=int Y
ParamCount=2
@=SetCursorPos(int X, int Y);
[SetPhysicalCursorPos]
1=int X
2=int Y
ParamCount=2
@=SetPhysicalCursorPos(int X, int Y);
[SetCursor]
1=HCURSOR hCursor
ParamCount=1
@=SetCursor(HCURSOR hCursor);
[GetCursorPos]
1=LPPOINT lpPoint
ParamCount=1
@=GetCursorPos(LPPOINT lpPoint);
[GetPhysicalCursorPos]
1=LPPOINT lpPoint
ParamCount=1
@=GetPhysicalCursorPos(LPPOINT lpPoint);
[ClipCursor]
1=RECT *lpRect
ParamCount=1
@=ClipCursor(RECT *lpRect);
[GetClipCursor]
1=LPRECT lpRect
ParamCount=1
@=GetClipCursor(LPRECT lpRect);
[GetCursor]
ParamCount=0
@=GetCursor();
[CreateCaret]
1=HWND hWnd
2=HBITMAP hBitmap
3=int nWidth
4=int nHeight
ParamCount=4
@=CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight);
[GetCaretBlinkTime]
ParamCount=0
@=GetCaretBlinkTime();
[SetCaretBlinkTime]
1=UINT uMSeconds
ParamCount=1
@=SetCaretBlinkTime(UINT uMSeconds);
[DestroyCaret]
ParamCount=0
@=DestroyCaret();
[HideCaret]
1=HWND hWnd
ParamCount=1
@=HideCaret(HWND hWnd);
[ShowCaret]
1=HWND hWnd
ParamCount=1
@=ShowCaret(HWND hWnd);
[SetCaretPos]
1=int X
2=int Y
ParamCount=2
@=SetCaretPos(int X, int Y);
[GetCaretPos]
1=LPPOINT lpPoint
ParamCount=1
@=GetCaretPos(LPPOINT lpPoint);
[ClientToScreen]
1=HWND hWnd
2=LPPOINT lpPoint
ParamCount=2
@=ClientToScreen(HWND hWnd, LPPOINT lpPoint);
[ScreenToClient]
1=HWND hWnd
2=LPPOINT lpPoint
ParamCount=2
@=ScreenToClient(HWND hWnd, LPPOINT lpPoint);
[LogicalToPhysicalPoint]
1=HWND hWnd
2=LPPOINT lpPoint
ParamCount=2
@=LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint);
[PhysicalToLogicalPoint]
1=HWND hWnd
2=LPPOINT lpPoint
ParamCount=2
@=PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint);
[LogicalToPhysicalPointForPerMonitorDPI]
1=HWND hWnd
2=LPPOINT lpPoint
ParamCount=2
@=LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint);
[PhysicalToLogicalPointForPerMonitorDPI]
1=HWND hWnd
2=LPPOINT lpPoint
ParamCount=2
@=PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint);
[MapWindowPoints]
1=HWND hWndFrom
2=HWND hWndTo
3=LPPOINT lpPoints
4=UINT cPoints
ParamCount=4
@=MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints);
[WindowFromPoint]
1=POINT Point
ParamCount=1
@=WindowFromPoint(POINT Point);
[WindowFromPhysicalPoint]
1=POINT Point
ParamCount=1
@=WindowFromPhysicalPoint(POINT Point);
[ChildWindowFromPoint]
1=HWND hWndParent
2=POINT Point
ParamCount=2
@=ChildWindowFromPoint(HWND hWndParent, POINT Point);
[ChildWindowFromPointEx]
1=HWND hwnd
2=POINT pt
3=UINT flags
ParamCount=3
@=ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags);
[GetSysColor]
1=int nIndex
ParamCount=1
@=GetSysColor(int nIndex);
[GetSysColorBrush]
1=int nIndex
ParamCount=1
@=GetSysColorBrush(int nIndex);
[SetSysColors]
1=int cElements
2=INT *lpaElements
3=COLORREF *lpaRgbValues
ParamCount=3
@=SetSysColors(int cElements, INT *lpaElements, COLORREF *lpaRgbValues);
[DrawFocusRect]
1=HDC hDC
2=RECT *lprc
ParamCount=2
@=DrawFocusRect(HDC hDC, RECT *lprc);
[FillRect]
1=HDC hDC
2=RECT *lprc
3=HBRUSH hbr
ParamCount=3
@=FillRect(HDC hDC, RECT *lprc, HBRUSH hbr);
[FrameRect]
1=HDC hDC
2=RECT *lprc
3=HBRUSH hbr
ParamCount=3
@=FrameRect(HDC hDC, RECT *lprc, HBRUSH hbr);
[InvertRect]
1=HDC hDC
2=RECT *lprc
ParamCount=2
@=InvertRect(HDC hDC, RECT *lprc);
[SetRect]
1=LPRECT lprc
2=int xLeft
3=int yTop
4=int xRight
5=int yBottom
ParamCount=5
@=SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom);
[SetRectEmpty]
1=LPRECT lprc
ParamCount=1
@=SetRectEmpty(LPRECT lprc);
[CopyRect]
1=LPRECT lprcDst
2=RECT *lprcSrc
ParamCount=2
@=CopyRect(LPRECT lprcDst, RECT *lprcSrc);
[InflateRect]
1=LPRECT lprc
2=int dx
3=int dy
ParamCount=3
@=InflateRect(LPRECT lprc, int dx, int dy);
[IntersectRect]
1=LPRECT lprcDst
2=RECT *lprcSrc1
3=RECT *lprcSrc2
ParamCount=3
@=IntersectRect(LPRECT lprcDst, RECT *lprcSrc1, RECT *lprcSrc2);
[UnionRect]
1=LPRECT lprcDst
2=RECT *lprcSrc1
3=RECT *lprcSrc2
ParamCount=3
@=UnionRect(LPRECT lprcDst, RECT *lprcSrc1, RECT *lprcSrc2);
[SubtractRect]
1=LPRECT lprcDst
2=RECT *lprcSrc1
3=RECT *lprcSrc2
ParamCount=3
@=SubtractRect(LPRECT lprcDst, RECT *lprcSrc1, RECT *lprcSrc2);
[OffsetRect]
1=LPRECT lprc
2=int dx
3=int dy
ParamCount=3
@=OffsetRect(LPRECT lprc, int dx, int dy);
[IsRectEmpty]
1=RECT *lprc
ParamCount=1
@=IsRectEmpty(RECT *lprc);
[EqualRect]
1=RECT *lprc1
2=RECT *lprc2
ParamCount=2
@=EqualRect(RECT *lprc1, RECT *lprc2);
[PtInRect]
1=RECT *lprc
2=POINT pt
ParamCount=2
@=PtInRect(RECT *lprc, POINT pt);
[GetWindowWord]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetWindowWord(HWND hWnd, int nIndex);
[SetWindowWord]
1=HWND hWnd
2=int nIndex
3=WORD wNewWord
ParamCount=3
@=SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord);
[GetWindowLongA]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetWindowLongA(HWND hWnd, int nIndex);
[GetWindowLongW]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetWindowLongW(HWND hWnd, int nIndex);
[SetWindowLongA]
1=HWND hWnd
2=int nIndex
3=LONG dwNewLong
ParamCount=3
@=SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong);
[SetWindowLongW]
1=HWND hWnd
2=int nIndex
3=LONG dwNewLong
ParamCount=3
@=SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong);
[GetWindowLongPtrA]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetWindowLongPtrA(HWND hWnd, int nIndex);
[GetWindowLongPtrW]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetWindowLongPtrW(HWND hWnd, int nIndex);
[SetWindowLongPtrA]
1=HWND hWnd
2=int nIndex
3=LONG_PTR dwNewLong
ParamCount=3
@=SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
[SetWindowLongPtrW]
1=HWND hWnd
2=int nIndex
3=LONG_PTR dwNewLong
ParamCount=3
@=SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
[GetClassWord]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetClassWord(HWND hWnd, int nIndex);
[SetClassWord]
1=HWND hWnd
2=int nIndex
3=WORD wNewWord
ParamCount=3
@=SetClassWord(HWND hWnd, int nIndex, WORD wNewWord);
[GetClassLongA]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetClassLongA(HWND hWnd, int nIndex);
[GetClassLongW]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetClassLongW(HWND hWnd, int nIndex);
[SetClassLongA]
1=HWND hWnd
2=int nIndex
3=LONG dwNewLong
ParamCount=3
@=SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong);
[SetClassLongW]
1=HWND hWnd
2=int nIndex
3=LONG dwNewLong
ParamCount=3
@=SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong);
[GetClassLongPtrA]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetClassLongPtrA(HWND hWnd, int nIndex);
[GetClassLongPtrW]
1=HWND hWnd
2=int nIndex
ParamCount=2
@=GetClassLongPtrW(HWND hWnd, int nIndex);
[SetClassLongPtrA]
1=HWND hWnd
2=int nIndex
3=LONG_PTR dwNewLong
ParamCount=3
@=SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
[SetClassLongPtrW]
1=HWND hWnd
2=int nIndex
3=LONG_PTR dwNewLong
ParamCount=3
@=SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
[GetProcessDefaultLayout]
1=DWORD *pdwDefaultLayout
ParamCount=1
@=GetProcessDefaultLayout(DWORD *pdwDefaultLayout);
[SetProcessDefaultLayout]
1=DWORD dwDefaultLayout
ParamCount=1
@=SetProcessDefaultLayout(DWORD dwDefaultLayout);
[GetDesktopWindow]
ParamCount=0
@=GetDesktopWindow();
[GetParent]
1=HWND hWnd
ParamCount=1
@=GetParent(HWND hWnd);
[SetParent]
1=HWND hWndChild
2=HWND hWndNewParent
ParamCount=2
@=SetParent(HWND hWndChild, HWND hWndNewParent);
[EnumChildWindows]
1=HWND hWndParent
2=WNDENUMPROC lpEnumFunc
3=LPARAM lParam
ParamCount=3
@=EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);
[FindWindowA]
1=LPCSTR lpClassName
2=LPCSTR lpWindowName
ParamCount=2
@=FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
[FindWindowW]
1=LPCWSTR lpClassName
2=LPCWSTR lpWindowName
ParamCount=2
@=FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);
[FindWindowExA]
1=HWND hWndParent
2=HWND hWndChildAfter
3=LPCSTR lpszClass
4=LPCSTR lpszWindow
ParamCount=4
@=FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow);
[FindWindowExW]
1=HWND hWndParent
2=HWND hWndChildAfter
3=LPCWSTR lpszClass
4=LPCWSTR lpszWindow
ParamCount=4
@=FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow);
[GetShellWindow]
ParamCount=0
@=GetShellWindow();
[RegisterShellHookWindow]
1=HWND hwnd
ParamCount=1
@=RegisterShellHookWindow(HWND hwnd);
[DeregisterShellHookWindow]
1=HWND hwnd
ParamCount=1
@=DeregisterShellHookWindow(HWND hwnd);
[EnumWindows]
1=WNDENUMPROC lpEnumFunc
2=LPARAM lParam
ParamCount=2
@=EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam);
[EnumThreadWindows]
1=DWORD dwThreadId
2=WNDENUMPROC lpfn
3=LPARAM lParam
ParamCount=3
@=EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam);
[GetClassNameA]
1=HWND hWnd
2=LPSTR lpClassName
3=int nMaxCount
ParamCount=3
@=GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount);
[GetClassNameW]
1=HWND hWnd
2=LPWSTR lpClassName
3=int nMaxCount
ParamCount=3
@=GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);
[GetTopWindow]
1=HWND hWnd
ParamCount=1
@=GetTopWindow(HWND hWnd);
[GetWindowThreadProcessId]
1=HWND hWnd
2=LPDWORD lpdwProcessId
ParamCount=2
@=GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId);
[IsGUIThread]
1=BOOL bConvert
ParamCount=1
@=IsGUIThread(BOOL bConvert);
[GetLastActivePopup]
1=HWND hWnd
ParamCount=1
@=GetLastActivePopup(HWND hWnd);
[GetWindow]
1=HWND hWnd
2=UINT uCmd
ParamCount=2
@=GetWindow(HWND hWnd, UINT uCmd);
[SetWindowsHookA]
1=int nFilterType
2=HOOKPROC pfnFilterProc
ParamCount=2
@=SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc);
[SetWindowsHookW]
1=int nFilterType
2=HOOKPROC pfnFilterProc
ParamCount=2
@=SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc);
[UnhookWindowsHook]
1=int nCode
2=HOOKPROC pfnFilterProc
ParamCount=2
@=UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc);
[SetWindowsHookExA]
1=int idHook
2=HOOKPROC lpfn
3=HINSTANCE hmod
4=DWORD dwThreadId
ParamCount=4
@=SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);
[SetWindowsHookExW]
1=int idHook
2=HOOKPROC lpfn
3=HINSTANCE hmod
4=DWORD dwThreadId
ParamCount=4
@=SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);
[UnhookWindowsHookEx]
1=HHOOK hhk
ParamCount=1
@=UnhookWindowsHookEx(HHOOK hhk);
[CallNextHookEx]
1=HHOOK hhk
2=int nCode
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam);
[CheckMenuRadioItem]
1=HMENU hmenu
2=UINT first
3=UINT last
4=UINT check
5=UINT flags
ParamCount=5
@=CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags);
[LoadBitmapA]
1=HINSTANCE hInstance
2=LPCSTR lpBitmapName
ParamCount=2
@=LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName);
[LoadBitmapW]
1=HINSTANCE hInstance
2=LPCWSTR lpBitmapName
ParamCount=2
@=LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);
[LoadCursorA]
1=HINSTANCE hInstance
2=LPCSTR lpCursorName
ParamCount=2
@=LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
[LoadCursorW]
1=HINSTANCE hInstance
2=LPCWSTR lpCursorName
ParamCount=2
@=LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
[LoadCursorFromFileA]
1=LPCSTR lpFileName
ParamCount=1
@=LoadCursorFromFileA(LPCSTR lpFileName);
[LoadCursorFromFileW]
1=LPCWSTR lpFileName
ParamCount=1
@=LoadCursorFromFileW(LPCWSTR lpFileName);
[CreateCursor]
1=HINSTANCE hInst
2=int xHotSpot
3=int yHotSpot
4=int nWidth
5=int nHeight
6=VOID *pvANDPlane
7=VOID *pvXORPlane
ParamCount=7
@=CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, VOID *pvANDPlane, VOID *pvXORPlane);
[DestroyCursor]
1=HCURSOR hCursor
ParamCount=1
@=DestroyCursor(HCURSOR hCursor);
[CopyCursor]
1=HCURSOR hCursor
ParamCount=1
@=CopyCursor(HCURSOR hCursor);
[SetSystemCursor]
1=HCURSOR hcur
2=DWORD id
ParamCount=2
@=SetSystemCursor(HCURSOR hcur, DWORD id);
[LoadIconA]
1=HINSTANCE hInstance
2=LPCSTR lpIconName
ParamCount=2
@=LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
[LoadIconW]
1=HINSTANCE hInstance
2=LPCWSTR lpIconName
ParamCount=2
@=LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
[PrivateExtractIconsA]
1=LPCSTR szFileName
2=int nIconIndex
3=int cxIcon
4=int cyIcon
5=HICON *phicon
6=UINT *piconid
7=UINT nIcons
8=UINT flags
ParamCount=8
@=PrivateExtractIconsA(LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);
[PrivateExtractIconsW]
1=LPCWSTR szFileName
2=int nIconIndex
3=int cxIcon
4=int cyIcon
5=HICON *phicon
6=UINT *piconid
7=UINT nIcons
8=UINT flags
ParamCount=8
@=PrivateExtractIconsW(LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);
[CreateIcon]
1=HINSTANCE hInstance
2=int nWidth
3=int nHeight
4=BYTE cPlanes
5=BYTE cBitsPixel
6=BYTE *lpbANDbits
7=BYTE *lpbXORbits
ParamCount=7
@=CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, BYTE *lpbANDbits, BYTE *lpbXORbits);
[DestroyIcon]
1=HICON hIcon
ParamCount=1
@=DestroyIcon(HICON hIcon);
[LookupIconIdFromDirectory]
1=PBYTE presbits
2=BOOL fIcon
ParamCount=2
@=LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon);
[LookupIconIdFromDirectoryEx]
1=PBYTE presbits
2=BOOL fIcon
3=int cxDesired
4=int cyDesired
5=UINT Flags
ParamCount=5
@=LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags);
[CreateIconFromResource]
1=PBYTE presbits
2=DWORD dwResSize
3=BOOL fIcon
4=DWORD dwVer
ParamCount=4
@=CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer);
[CreateIconFromResourceEx]
1=PBYTE presbits
2=DWORD dwResSize
3=BOOL fIcon
4=DWORD dwVer
5=int cxDesired
6=int cyDesired
7=UINT Flags
ParamCount=7
@=CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags);
[LoadImageA]
1=HINSTANCE hInst
2=LPCSTR name
3=UINT type
4=int cx
5=int cy
6=UINT fuLoad
ParamCount=6
@=LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad);
[LoadImageW]
1=HINSTANCE hInst
2=LPCWSTR name
3=UINT type
4=int cx
5=int cy
6=UINT fuLoad
ParamCount=6
@=LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad);
[CopyImage]
1=HANDLE h
2=UINT type
3=int cx
4=int cy
5=UINT flags
ParamCount=5
@=CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags);
[DrawIconEx]
1=HDC hdc
2=int xLeft
3=int yTop
4=HICON hIcon
5=int cxWidth
6=int cyWidth
7=UINT istepIfAniCur
8=HBRUSH hbrFlickerFreeDraw
9=UINT diFlags
ParamCount=9
@=DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
[CreateIconIndirect]
1=PICONINFO piconinfo
ParamCount=1
@=CreateIconIndirect(PICONINFO piconinfo);
[CopyIcon]
1=HICON hIcon
ParamCount=1
@=CopyIcon(HICON hIcon);
[GetIconInfo]
1=HICON hIcon
2=PICONINFO piconinfo
ParamCount=2
@=GetIconInfo(HICON hIcon, PICONINFO piconinfo);
[GetIconInfoExA]
1=HICON hicon
2=PICONINFOEXA piconinfo
ParamCount=2
@=GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo);
[GetIconInfoExW]
1=HICON hicon
2=PICONINFOEXW piconinfo
ParamCount=2
@=GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo);
[LoadStringA]
1=HINSTANCE hInstance
2=UINT uID
3=LPSTR lpBuffer
4=int cchBufferMax
ParamCount=4
@=LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax);
[LoadStringW]
1=HINSTANCE hInstance
2=UINT uID
3=LPWSTR lpBuffer
4=int cchBufferMax
ParamCount=4
@=LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
[IsDialogMessageA]
1=HWND hDlg
2=LPMSG lpMsg
ParamCount=2
@=IsDialogMessageA(HWND hDlg, LPMSG lpMsg);
[IsDialogMessageW]
1=HWND hDlg
2=LPMSG lpMsg
ParamCount=2
@=IsDialogMessageW(HWND hDlg, LPMSG lpMsg);
[MapDialogRect]
1=HWND hDlg
2=LPRECT lpRect
ParamCount=2
@=MapDialogRect(HWND hDlg, LPRECT lpRect);
[DlgDirListA]
1=HWND hDlg
2=LPSTR lpPathSpec
3=int nIDListBox
4=int nIDStaticPath
5=UINT uFileType
ParamCount=5
@=DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType);
[DlgDirListW]
1=HWND hDlg
2=LPWSTR lpPathSpec
3=int nIDListBox
4=int nIDStaticPath
5=UINT uFileType
ParamCount=5
@=DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType);
[DlgDirSelectExA]
1=HWND hwndDlg
2=LPSTR lpString
3=int chCount
4=int idListBox
ParamCount=4
@=DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox);
[DlgDirSelectExW]
1=HWND hwndDlg
2=LPWSTR lpString
3=int chCount
4=int idListBox
ParamCount=4
@=DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox);
[DlgDirListComboBoxA]
1=HWND hDlg
2=LPSTR lpPathSpec
3=int nIDComboBox
4=int nIDStaticPath
5=UINT uFiletype
ParamCount=5
@=DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype);
[DlgDirListComboBoxW]
1=HWND hDlg
2=LPWSTR lpPathSpec
3=int nIDComboBox
4=int nIDStaticPath
5=UINT uFiletype
ParamCount=5
@=DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype);
[DlgDirSelectComboBoxExA]
1=HWND hwndDlg
2=LPSTR lpString
3=int cchOut
4=int idComboBox
ParamCount=4
@=DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox);
[DlgDirSelectComboBoxExW]
1=HWND hwndDlg
2=LPWSTR lpString
3=int cchOut
4=int idComboBox
ParamCount=4
@=DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox);
[SetScrollInfo]
1=HWND hwnd
2=int nBar
3=LPCSCROLLINFO lpsi
4=BOOL redraw
ParamCount=4
@=SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);
[GetScrollInfo]
1=HWND hwnd
2=int nBar
3=LPSCROLLINFO lpsi
ParamCount=3
@=GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi);
[DefFrameProcA]
1=HWND hWnd
2=HWND hWndMDIClient
3=UINT uMsg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
[DefFrameProcW]
1=HWND hWnd
2=HWND hWndMDIClient
3=UINT uMsg
4=WPARAM wParam
5=LPARAM lParam
ParamCount=5
@=DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
[DefMDIChildProcA]
1=HWND hWnd
2=UINT uMsg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
[DefMDIChildProcW]
1=HWND hWnd
2=UINT uMsg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
[TranslateMDISysAccel]
1=HWND hWndClient
2=LPMSG lpMsg
ParamCount=2
@=TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg);
[ArrangeIconicWindows]
1=HWND hWnd
ParamCount=1
@=ArrangeIconicWindows(HWND hWnd);
[CreateMDIWindowA]
1=LPCSTR lpClassName
2=LPCSTR lpWindowName
3=DWORD dwStyle
4=int X
5=int Y
6=int nWidth
7=int nHeight
8=HWND hWndParent
9=HINSTANCE hInstance
10=LPARAM lParam
ParamCount=10
@=CreateMDIWindowA(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);
[CreateMDIWindowW]
1=LPCWSTR lpClassName
2=LPCWSTR lpWindowName
3=DWORD dwStyle
4=int X
5=int Y
6=int nWidth
7=int nHeight
8=HWND hWndParent
9=HINSTANCE hInstance
10=LPARAM lParam
ParamCount=10
@=CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);
[TileWindows]
1=HWND hwndParent
2=UINT wHow
3=RECT *lpRect
4=UINT cKids
5=HWND *lpKids
ParamCount=5
@=TileWindows(HWND hwndParent, UINT wHow, RECT *lpRect, UINT cKids, HWND *lpKids);
[CascadeWindows]
1=HWND hwndParent
2=UINT wHow
3=RECT *lpRect
4=UINT cKids
5=HWND *lpKids
ParamCount=5
@=CascadeWindows(HWND hwndParent, UINT wHow, RECT *lpRect, UINT cKids, HWND *lpKids);
[WinHelpA]
1=HWND hWndMain
2=LPCSTR lpszHelp
3=UINT uCommand
4=ULONG_PTR dwData
ParamCount=4
@=WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData);
[WinHelpW]
1=HWND hWndMain
2=LPCWSTR lpszHelp
3=UINT uCommand
4=ULONG_PTR dwData
ParamCount=4
@=WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData);
[GetGuiResources]
1=HANDLE hProcess
2=DWORD uiFlags
ParamCount=2
@=GetGuiResources(HANDLE hProcess, DWORD uiFlags);
[ChangeDisplaySettingsA]
1=DEVMODEA* lpDevMode
2=DWORD dwFlags
ParamCount=2
@=ChangeDisplaySettingsA(DEVMODEA* lpDevMode, DWORD dwFlags);
[ChangeDisplaySettingsW]
1=DEVMODEW* lpDevMode
2=DWORD dwFlags
ParamCount=2
@=ChangeDisplaySettingsW(DEVMODEW* lpDevMode, DWORD dwFlags);
[ChangeDisplaySettingsExA]
1=LPCSTR lpszDeviceName
2=DEVMODEA* lpDevMode
3=HWND hwnd
4=DWORD dwflags
5=LPVOID lParam
ParamCount=5
@=ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA* lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
[ChangeDisplaySettingsExW]
1=LPCWSTR lpszDeviceName
2=DEVMODEW* lpDevMode
3=HWND hwnd
4=DWORD dwflags
5=LPVOID lParam
ParamCount=5
@=ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW* lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
[EnumDisplaySettingsA]
1=LPCSTR lpszDeviceName
2=DWORD iModeNum
3=DEVMODEA* lpDevMode
ParamCount=3
@=EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA* lpDevMode);
[EnumDisplaySettingsW]
1=LPCWSTR lpszDeviceName
2=DWORD iModeNum
3=DEVMODEW* lpDevMode
ParamCount=3
@=EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW* lpDevMode);
[EnumDisplaySettingsExA]
1=LPCSTR lpszDeviceName
2=DWORD iModeNum
3=DEVMODEA* lpDevMode
4=DWORD dwFlags
ParamCount=4
@=EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA* lpDevMode, DWORD dwFlags);
[EnumDisplaySettingsExW]
1=LPCWSTR lpszDeviceName
2=DWORD iModeNum
3=DEVMODEW* lpDevMode
4=DWORD dwFlags
ParamCount=4
@=EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW* lpDevMode, DWORD dwFlags);
[EnumDisplayDevicesA]
1=LPCSTR lpDevice
2=DWORD iDevNum
3=PDISPLAY_DEVICEA lpDisplayDevice
4=DWORD dwFlags
ParamCount=4
@=EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags);
[EnumDisplayDevicesW]
1=LPCWSTR lpDevice
2=DWORD iDevNum
3=PDISPLAY_DEVICEW lpDisplayDevice
4=DWORD dwFlags
ParamCount=4
@=EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags);
[GetDisplayConfigBufferSizes]
1=UINT32 flags
2=UINT32* numPathArrayElements
3=UINT32* numModeInfoArrayElements
ParamCount=3
@=GetDisplayConfigBufferSizes(UINT32 flags, UINT32* numPathArrayElements, UINT32* numModeInfoArrayElements);
[SetDisplayConfig]
1=UINT32 numPathArrayElements
2=DISPLAYCONFIG_PATH_INFO* pathArray
3=UINT32 numModeInfoArrayElements
4=DISPLAYCONFIG_MODE_INFO* modeInfoArray
5=UINT32 flags
ParamCount=5
@=SetDisplayConfig(UINT32 numPathArrayElements, DISPLAYCONFIG_PATH_INFO* pathArray, UINT32 numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO* modeInfoArray, UINT32 flags);
[QueryDisplayConfig]
1=UINT32 flags
2=UINT32* numPathArrayElements
3=DISPLAYCONFIG_PATH_INFO* pathArray
4=UINT32* numModeInfoArrayElements
5=DISPLAYCONFIG_MODE_INFO* modeInfoArray
6=DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId
ParamCount=6
@=QueryDisplayConfig(UINT32 flags, UINT32* numPathArrayElements, DISPLAYCONFIG_PATH_INFO* pathArray, UINT32* numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO* modeInfoArray, DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);
[DisplayConfigGetDeviceInfo]
1=DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket
ParamCount=1
@=DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);
[DisplayConfigSetDeviceInfo]
1=DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket
ParamCount=1
@=DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);
[SystemParametersInfoA]
1=UINT uiAction
2=UINT uiParam
3=PVOID pvParam
4=UINT fWinIni
ParamCount=4
@=SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
[SystemParametersInfoW]
1=UINT uiAction
2=UINT uiParam
3=PVOID pvParam
4=UINT fWinIni
ParamCount=4
@=SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
[SoundSentry]
ParamCount=0
@=SoundSentry();
[SetDebugErrorLevel]
1=DWORD dwLevel
ParamCount=1
@=SetDebugErrorLevel(DWORD dwLevel);
[SetLastErrorEx]
1=DWORD dwErrCode
2=DWORD dwType
ParamCount=2
@=SetLastErrorEx(DWORD dwErrCode, DWORD dwType);
[InternalGetWindowText]
1=HWND hWnd
2=LPWSTR pString
3=int cchMaxCount
ParamCount=3
@=InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount);
[EndTask]
1=HWND hWnd
2=BOOL fShutDown
3=BOOL fForce
ParamCount=3
@=EndTask(HWND hWnd, BOOL fShutDown, BOOL fForce);
[CancelShutdown]
ParamCount=0
@=CancelShutdown();
[MonitorFromPoint]
1=POINT pt
2=DWORD dwFlags
ParamCount=2
@=MonitorFromPoint(POINT pt, DWORD dwFlags);
[MonitorFromRect]
1=LPCRECT lprc
2=DWORD dwFlags
ParamCount=2
@=MonitorFromRect(LPCRECT lprc, DWORD dwFlags);
[MonitorFromWindow]
1=HWND hwnd
2=DWORD dwFlags
ParamCount=2
@=MonitorFromWindow(HWND hwnd, DWORD dwFlags);
[GetMonitorInfoA]
1=HMONITOR hMonitor
2=LPMONITORINFO lpmi
ParamCount=2
@=GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi);
[GetMonitorInfoW]
1=HMONITOR hMonitor
2=LPMONITORINFO lpmi
ParamCount=2
@=GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi);
[EnumDisplayMonitors]
1=HDC hdc
2=LPCRECT lprcClip
3=MONITORENUMPROC lpfnEnum
4=LPARAM dwData
ParamCount=4
@=EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData);
[NotifyWinEvent]
1=DWORD event
2=HWND hwnd
3=LONG idObject
4=LONG idChild
ParamCount=4
@=NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild);
[SetWinEventHook]
1=DWORD eventMin
2=DWORD eventMax
3=HMODULE hmodWinEventProc
4=WINEVENTPROC pfnWinEventProc
5=DWORD idProcess
6=DWORD idThread
7=DWORD dwFlags
ParamCount=7
@=SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags);
[IsWinEventHookInstalled]
1=DWORD event
ParamCount=1
@=IsWinEventHookInstalled(DWORD event);
[UnhookWinEvent]
1=HWINEVENTHOOK hWinEventHook
ParamCount=1
@=UnhookWinEvent(HWINEVENTHOOK hWinEventHook);
[GetGUIThreadInfo]
1=DWORD idThread
2=PGUITHREADINFO pgui
ParamCount=2
@=GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui);
[BlockInput]
1=BOOL fBlockIt
ParamCount=1
@=BlockInput(BOOL fBlockIt);
[SetProcessDPIAware]
ParamCount=0
@=SetProcessDPIAware();
[IsProcessDPIAware]
ParamCount=0
@=IsProcessDPIAware();
[GetWindowModuleFileNameA]
1=HWND hwnd
2=LPSTR pszFileName
3=UINT cchFileNameMax
ParamCount=3
@=GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax);
[GetWindowModuleFileNameW]
1=HWND hwnd
2=LPWSTR pszFileName
3=UINT cchFileNameMax
ParamCount=3
@=GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax);
[GetCursorInfo]
1=PCURSORINFO pci
ParamCount=1
@=GetCursorInfo(PCURSORINFO pci);
[GetWindowInfo]
1=HWND hwnd
2=PWINDOWINFO pwi
ParamCount=2
@=GetWindowInfo(HWND hwnd, PWINDOWINFO pwi);
[GetTitleBarInfo]
1=HWND hwnd
2=PTITLEBARINFO pti
ParamCount=2
@=GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti);
[GetMenuBarInfo]
1=HWND hwnd
2=LONG idObject
3=LONG idItem
4=PMENUBARINFO pmbi
ParamCount=4
@=GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi);
[GetScrollBarInfo]
1=HWND hwnd
2=LONG idObject
3=PSCROLLBARINFO psbi
ParamCount=3
@=GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi);
[GetComboBoxInfo]
1=HWND hwndCombo
2=PCOMBOBOXINFO pcbi
ParamCount=2
@=GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi);
[GetAncestor]
1=HWND hwnd
2=UINT gaFlags
ParamCount=2
@=GetAncestor(HWND hwnd, UINT gaFlags);
[RealChildWindowFromPoint]
1=HWND hwndParent
2=POINT ptParentClientCoords
ParamCount=2
@=RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords);
[RealGetWindowClassA]
1=HWND hwnd
2=LPSTR ptszClassName
3=UINT cchClassNameMax
ParamCount=3
@=RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax);
[RealGetWindowClassW]
1=HWND hwnd
2=LPWSTR ptszClassName
3=UINT cchClassNameMax
ParamCount=3
@=RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax);
[GetAltTabInfoA]
1=HWND hwnd
2=int iItem
3=PALTTABINFO pati
4=LPSTR pszItemText
5=UINT cchItemText
ParamCount=5
@=GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText);
[GetAltTabInfoW]
1=HWND hwnd
2=int iItem
3=PALTTABINFO pati
4=LPWSTR pszItemText
5=UINT cchItemText
ParamCount=5
@=GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText);
[GetListBoxInfo]
1=HWND hwnd
ParamCount=1
@=GetListBoxInfo(HWND hwnd);
[LockWorkStation]
ParamCount=0
@=LockWorkStation();
[UserHandleGrantAccess]
1=HANDLE hUserHandle
2=HANDLE hJob
3=BOOL bGrant
ParamCount=3
@=UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant);
[GetRawInputData]
1=HRAWINPUT hRawInput
2=UINT uiCommand
3=LPVOID pData
4=PUINT pcbSize
5=UINT cbSizeHeader
ParamCount=5
@=GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader);
[GetRawInputDeviceInfoA]
1=HANDLE hDevice
2=UINT uiCommand
3=LPVOID pData
4=PUINT pcbSize
ParamCount=4
@=GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize);
[GetRawInputDeviceInfoW]
1=HANDLE hDevice
2=UINT uiCommand
3=LPVOID pData
4=PUINT pcbSize
ParamCount=4
@=GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize);
[GetRawInputBuffer]
1=PRAWINPUT pData
2=PUINT pcbSize
3=UINT cbSizeHeader
ParamCount=3
@=GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader);
[RegisterRawInputDevices]
1=PCRAWINPUTDEVICE pRawInputDevices
2=UINT uiNumDevices
3=UINT cbSize
ParamCount=3
@=RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize);
[GetRegisteredRawInputDevices]
1=PRAWINPUTDEVICE pRawInputDevices
2=PUINT puiNumDevices
3=UINT cbSize
ParamCount=3
@=GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize);
[GetRawInputDeviceList]
1=PRAWINPUTDEVICELIST pRawInputDeviceList
2=PUINT puiNumDevices
3=UINT cbSize
ParamCount=3
@=GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize);
[DefRawInputProc]
1=PRAWINPUT* paRawInput
2=INT nInput
3=UINT cbSizeHeader
ParamCount=3
@=DefRawInputProc(PRAWINPUT* paRawInput, INT nInput, UINT cbSizeHeader);
[GetPointerDevices]
1=UINT32* deviceCount
2=POINTER_DEVICE_INFO *pointerDevices
ParamCount=2
@=GetPointerDevices(UINT32* deviceCount, POINTER_DEVICE_INFO *pointerDevices);
[GetPointerDevice]
1=HANDLE device
2=POINTER_DEVICE_INFO *pointerDevice
ParamCount=2
@=GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO *pointerDevice);
[GetPointerDeviceProperties]
1=HANDLE device
2=UINT32* propertyCount
3=POINTER_DEVICE_PROPERTY *pointerProperties
ParamCount=3
@=GetPointerDeviceProperties(HANDLE device, UINT32* propertyCount, POINTER_DEVICE_PROPERTY *pointerProperties);
[RegisterPointerDeviceNotifications]
1=HWND window
2=BOOL notifyRange
ParamCount=2
@=RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange);
[GetPointerDeviceRects]
1=HANDLE device
2=RECT* pointerDeviceRect
3=RECT* displayRect
ParamCount=3
@=GetPointerDeviceRects(HANDLE device, RECT* pointerDeviceRect, RECT* displayRect);
[GetPointerDeviceCursors]
1=HANDLE device
2=UINT32* cursorCount
3=POINTER_DEVICE_CURSOR_INFO *deviceCursors
ParamCount=3
@=GetPointerDeviceCursors(HANDLE device, UINT32* cursorCount, POINTER_DEVICE_CURSOR_INFO *deviceCursors);
[GetRawPointerDeviceData]
1=UINT32 pointerId
2=UINT32 historyCount
3=UINT32 propertiesCount
4=POINTER_DEVICE_PROPERTY* pProperties
5=LONG* pValues
ParamCount=5
@=GetRawPointerDeviceData(UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY* pProperties, LONG* pValues);
[ChangeWindowMessageFilter]
1=UINT message
2=DWORD dwFlag
ParamCount=2
@=ChangeWindowMessageFilter(UINT message, DWORD dwFlag);
[ChangeWindowMessageFilterEx]
1=HWND hwnd
2=UINT message
3=DWORD action
4=PCHANGEFILTERSTRUCT pChangeFilterStruct
ParamCount=4
@=ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct);
[GetGestureInfo]
1=HGESTUREINFO hGestureInfo
2=PGESTUREINFO pGestureInfo
ParamCount=2
@=GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo);
[GetGestureExtraArgs]
1=HGESTUREINFO hGestureInfo
2=UINT cbExtraArgs
3=PBYTE pExtraArgs
ParamCount=3
@=GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs);
[CloseGestureInfoHandle]
1=HGESTUREINFO hGestureInfo
ParamCount=1
@=CloseGestureInfoHandle(HGESTUREINFO hGestureInfo);
[SetGestureConfig]
1=HWND hwnd
2=DWORD dwReserved
3=UINT cIDs
4=PGESTURECONFIG pGestureConfig
5=UINT cbSize
ParamCount=5
@=SetGestureConfig(HWND hwnd, DWORD dwReserved, UINT cIDs, PGESTURECONFIG pGestureConfig, UINT cbSize);
[GetGestureConfig]
1=HWND hwnd
2=DWORD dwReserved
3=DWORD dwFlags
4=PUINT pcIDs
5=PGESTURECONFIG pGestureConfig
6=UINT cbSize
ParamCount=6
@=GetGestureConfig(HWND hwnd, DWORD dwReserved, DWORD dwFlags, PUINT pcIDs, PGESTURECONFIG pGestureConfig, UINT cbSize);
[ShutdownBlockReasonCreate]
1=HWND hWnd
2=LPCWSTR pwszReason
ParamCount=2
@=ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason);
[ShutdownBlockReasonQuery]
1=HWND hWnd
2=LPWSTR pwszBuff
3=DWORD *pcchBuff
ParamCount=3
@=ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD *pcchBuff);
[ShutdownBlockReasonDestroy]
1=HWND hWnd
ParamCount=1
@=ShutdownBlockReasonDestroy(HWND hWnd);
[GetCurrentInputMessageSource]
1=INPUT_MESSAGE_SOURCE *inputMessageSource
ParamCount=1
@=GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE *inputMessageSource);
[GetCIMSSM]
1=INPUT_MESSAGE_SOURCE *inputMessageSource
ParamCount=1
@=GetCIMSSM(INPUT_MESSAGE_SOURCE *inputMessageSource);
[GetAutoRotationState]
1=PAR_STATE pState
ParamCount=1
@=GetAutoRotationState(PAR_STATE pState);
[GetDisplayAutoRotationPreferences]
1=ORIENTATION_PREFERENCE *pOrientation
ParamCount=1
@=GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE *pOrientation);
[GetDisplayAutoRotationPreferencesByProcessId]
1=DWORD dwProcessId
2=ORIENTATION_PREFERENCE *pOrientation
3=BOOL *fRotateScreen
ParamCount=3
@=GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE *pOrientation, BOOL *fRotateScreen);
[SetDisplayAutoRotationPreferences]
1=ORIENTATION_PREFERENCE orientation
ParamCount=1
@=SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation);
[IsImmersiveProcess]
1=HANDLE hProcess
ParamCount=1
@=IsImmersiveProcess(HANDLE hProcess);
[SetProcessRestrictionExemption]
1=BOOL fEnableExemption
ParamCount=1
@=SetProcessRestrictionExemption(BOOL fEnableExemption);
[NtUserHardErrorControl]
1=HARDERRORCONTROL dwCmd
2=HANDLE handle
3=PDESKRESTOREDATA pdrdRestore
ParamCount=3
@=NtUserHardErrorControl(HARDERRORCONTROL dwCmd, HANDLE handle, PDESKRESTOREDATA pdrdRestore);
[NtUserGetObjectInformation]
1=HANDLE hObject
2=int nIndex
3=PVOID pvInfo
4=DWORD nLength
5=LPDWORD pnLengthNeeded
ParamCount=5
@=NtUserGetObjectInformation(HANDLE hObject, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD pnLengthNeeded);
[NtUserSetObjectInformation]
1=HANDLE hObject
2=int nIndex
3=LPCVOID pvInfo
4=DWORD nLength
ParamCount=4
@=NtUserSetObjectInformation(HANDLE hObject, int nIndex, LPCVOID pvInfo, DWORD nLength);
[NtUserWin32PoolAllocationStats]
1=LPDWORD parrTags
2=tagsCount
3=lpdwMaxMem
4=lpdwCrtMem
5=LPDWORD lpdwMaxAlloc
6=LPDWORD lpdwCrtAlloc
ParamCount=6
@=NtUserWin32PoolAllocationStats(LPDWORD parrTags, tagsCount, lpdwMaxMem, lpdwCrtMem, LPDWORD lpdwMaxAlloc, LPDWORD lpdwCrtAlloc);
[NtUserDbgWin32HeapFail]
1=DWORD dwFlags
2=BOOL bFail
ParamCount=2
@=NtUserDbgWin32HeapFail(DWORD dwFlags, BOOL bFail);
[NtUserDbgWin32HeapStat]
1=PDBGHEAPSTAT phs
2=DWORD dwLen
ParamCount=2
@=NtUserDbgWin32HeapStat(PDBGHEAPSTAT phs, DWORD dwLen);
[NtUserConsoleControl]
1=ECONTROL ConsoleCommand
2=PVOID ConsoleInformation
3=DWORD ConsoleInformationLength
ParamCount=3
@=NtUserConsoleControl(ECONTROL ConsoleCommand, PVOID ConsoleInformation, DWORD ConsoleInformationLength);
[NtUserCreateWindowStation]
1=POBJECT_ATTRIBUTES pObja
2=amRequest
3=HANDLE hKbdLayoutFile
4=DWORD offTable
5=PUNICODE_STRING pstrKLID
6=UINT uKbdInputLocale
ParamCount=6
@=NtUserCreateWindowStation(POBJECT_ATTRIBUTES pObja, amRequest, HANDLE hKbdLayoutFile, DWORD offTable, PUNICODE_STRING pstrKLID, UINT uKbdInputLocale);
[NtUserOpenWindowStation]
1=POBJECT_ATTRIBUTES pObja
2=amRequest
ParamCount=2
@=NtUserOpenWindowStation(POBJECT_ATTRIBUTES pObja, amRequest);
[NtUserCloseWindowStation]
1=HWINSTA hwinsta
ParamCount=1
@=NtUserCloseWindowStation(HWINSTA hwinsta);
[NtUserGetProcessWindowStation]
1=VOID
ParamCount=1
@=NtUserGetProcessWindowStation(VOID);
[NtUserLockWorkStation]
1=VOID
ParamCount=1
@=NtUserLockWorkStation(VOID);
[NtUserCreateDesktop]
1=POBJECT_ATTRIBUTES pObja
2=PUNICODE_STRING pstrDevice
3=LPDEVMODEW pDevmode
4=DWORD dwFlags
5=amRequest
ParamCount=5
@=NtUserCreateDesktop(POBJECT_ATTRIBUTES pObja, PUNICODE_STRING pstrDevice, LPDEVMODEW pDevmode, DWORD dwFlags, amRequest);
[NtUserOpenDesktop]
1=POBJECT_ATTRIBUTES pObja
2=DWORD dwFlags
3=amRequest
ParamCount=3
@=NtUserOpenDesktop(POBJECT_ATTRIBUTES pObja, DWORD dwFlags, amRequest);
[NtUserOpenInputDesktop]
1=DWORD dwFlags
2=BOOL fInherit
3=DWORD amRequest
ParamCount=3
@=NtUserOpenInputDesktop(DWORD dwFlags, BOOL fInherit, DWORD amRequest);
[NtUserResolveDesktopForWOW]
1=PUNICODE_STRING pstrDesktop
ParamCount=1
@=NtUserResolveDesktopForWOW(PUNICODE_STRING pstrDesktop);
[NtUserResolveDesktop]
1=HANDLE hProcess
2=PUNICODE_STRING pstrDesktop
3=BOOL fInherit
4=HWINSTA *phwinsta
ParamCount=4
@=NtUserResolveDesktop(HANDLE hProcess, PUNICODE_STRING pstrDesktop, BOOL fInherit, HWINSTA *phwinsta);
[NtUserCloseDesktop]
1=HDESK hdesk
ParamCount=1
@=NtUserCloseDesktop(HDESK hdesk);
[NtUserSetThreadDesktop]
1=HDESK hdesk
ParamCount=1
@=NtUserSetThreadDesktop(HDESK hdesk);
[NtUserGetThreadDesktop]
1=DWORD dwThreadId
2=HDESK hdeskConsole
ParamCount=2
@=NtUserGetThreadDesktop(DWORD dwThreadId, HDESK hdeskConsole);
[NtUserSwitchDesktop]
1=HDESK hdesk
ParamCount=1
@=NtUserSwitchDesktop(HDESK hdesk);
[NtUserInitializeClientPfnArrays]
1=PFNCLIENT *ppfnClientA
2=PFNCLIENT *ppfnClientW
3=PFNCLIENTWORKER *ppfnClientWorker
4=HANDLE hModUser
ParamCount=4
@=NtUserInitializeClientPfnArrays(PFNCLIENT *ppfnClientA, PFNCLIENT *ppfnClientW, PFNCLIENTWORKER *ppfnClientWorker, HANDLE hModUser);
[NtUserWaitForMsgAndEvent]
1=HANDLE hevent
ParamCount=1
@=NtUserWaitForMsgAndEvent(HANDLE hevent);
[NtUserDragObject]
1=HWND hwndParent
2=HWND hwndFrom
3=UINT wFmt
4=dwData
5=HCURSOR hcur
ParamCount=5
@=NtUserDragObject(HWND hwndParent, HWND hwndFrom, UINT wFmt, dwData, HCURSOR hcur);
[NtUserGetIconInfo]
1=HICON hicon
2=PICONINFO piconinfo
3=PUNICODE_STRING pstrInstanceName
4=PUNICODE_STRING pstrResName
5=LPDWORD pbpp
6=BOOL fInternal
ParamCount=6
@=NtUserGetIconInfo(HICON hicon, PICONINFO piconinfo, PUNICODE_STRING pstrInstanceName, PUNICODE_STRING pstrResName, LPDWORD pbpp, BOOL fInternal);
[NtUserGetIconSize]
1=HICON hIcon
2=UINT istepIfAniCur
3=int *pcx
4=int *pcy
ParamCount=4
@=NtUserGetIconSize(HICON hIcon, UINT istepIfAniCur, int *pcx, int *pcy);
[NtUserDrawIconEx]
1=HDC hdc
2=int x
3=int y
4=HICON hicon
5=int cx
6=int cy
7=UINT istepIfAniCur
8=HBRUSH hbrush
9=UINT diFlags
10=BOOL fMeta
11=DRAWICONEXDATA *pdid
ParamCount=11
@=NtUserDrawIconEx(HDC hdc, int x, int y, HICON hicon, int cx, int cy, UINT istepIfAniCur, HBRUSH hbrush, UINT diFlags, BOOL fMeta, DRAWICONEXDATA *pdid);
[NtUserDeferWindowPos]
1=HDWP hWinPosInfo
2=HWND hwnd
3=HWND hwndInsertAfter
4=int x
5=int y
6=int cx
7=int cy
8=UINT wFlags
ParamCount=8
@=NtUserDeferWindowPos(HDWP hWinPosInfo, HWND hwnd, HWND hwndInsertAfter, int x, int y, int cx, int cy, UINT wFlags);
[NtUserEndDeferWindowPosEx]
1=HDWP hWinPosInfo
2=BOOL fAsync
ParamCount=2
@=NtUserEndDeferWindowPosEx(HDWP hWinPosInfo, BOOL fAsync);
[NtUserGetMessage]
1=LPMSG pmsg
2=HWND hwnd
3=UINT wMsgFilterMin
4=UINT wMsgFilterMax
ParamCount=4
@=NtUserGetMessage(LPMSG pmsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
[NtUserMoveWindow]
1=HWND hwnd
2=int x
3=int y
4=int cx
5=int cy
6=BOOL fRepaint
ParamCount=6
@=NtUserMoveWindow(HWND hwnd, int x, int y, int cx, int cy, BOOL fRepaint);
[NtUserTranslateAccelerator]
1=HWND hwnd
2=HACCEL hAccTable
3=LPMSG lpMsg
ParamCount=3
@=NtUserTranslateAccelerator(HWND hwnd, HACCEL hAccTable, LPMSG lpMsg);
[NtUserSetClassLong]
1=HWND hwnd
2=int nIndex
3=LONG dwNewLong
4=BOOL bAnsi
ParamCount=4
@=NtUserSetClassLong(HWND hwnd, int nIndex, LONG dwNewLong, BOOL bAnsi);
[NtUserSetClassLongPtr]
1=HWND hwnd
2=int nIndex
3=dwNewLong
4=BOOL bAnsi
ParamCount=4
@=NtUserSetClassLongPtr(HWND hwnd, int nIndex, dwNewLong, BOOL bAnsi);
[NtUserSetKeyboardState]
1=BYTE *lpKeyState
ParamCount=1
@=NtUserSetKeyboardState(BYTE *lpKeyState);
[NtUserSetWindowPos]
1=HWND hwnd
2=HWND hwndInsertAfter
3=int x
4=int y
5=int cx
6=int cy
7=UINT dwFlags
ParamCount=7
@=NtUserSetWindowPos(HWND hwnd, HWND hwndInsertAfter, int x, int y, int cx, int cy, UINT dwFlags);
[NtUserSetShellWindowEx]
1=HWND hwnd
2=HWND hwndBkGnd
ParamCount=2
@=NtUserSetShellWindowEx(HWND hwnd, HWND hwndBkGnd);
[NtUserSystemParametersInfo]
1=UINT wFlag
2=DWORD wParam
3=LPVOID lpData
4=UINT flags
ParamCount=4
@=NtUserSystemParametersInfo(UINT wFlag, DWORD wParam, LPVOID lpData, UINT flags);
[NtUserUpdatePerUserSystemParameters]
1=HANDLE hToken
2=BOOL bUserLoggedOn
ParamCount=2
@=NtUserUpdatePerUserSystemParameters(HANDLE hToken, BOOL bUserLoggedOn);
[NtUserDdeInitialize]
1=PHANDLE phInst
2=HWND *phwnd
3=LPDWORD pMonFlags
4=DWORD afCmd
5=PVOID pcii
ParamCount=5
@=NtUserDdeInitialize(PHANDLE phInst, HWND *phwnd, LPDWORD pMonFlags, DWORD afCmd, PVOID pcii);
[NtUserUpdateInstance]
1=HANDLE hInst
2=LPDWORD pMonFlags
3=DWORD afCmd
ParamCount=3
@=NtUserUpdateInstance(HANDLE hInst, LPDWORD pMonFlags, DWORD afCmd);
[NtUserEvent]
1=PEVENT_PACKET pep
ParamCount=1
@=NtUserEvent(PEVENT_PACKET pep);
[NtUserFillWindow]
1=HWND hwndBrush
2=HWND hwndPaint
3=HDC hdc
4=HBRUSH hbr
ParamCount=4
@=NtUserFillWindow(HWND hwndBrush, HWND hwndPaint, HDC hdc, HBRUSH hbr);
[NtUserGetWOWClass]
1=HINSTANCE hInstance
2=PUNICODE_STRING pString
ParamCount=2
@=NtUserGetWOWClass(HINSTANCE hInstance, PUNICODE_STRING pString);
[NtUserGetInternalWindowPos]
1=HWND hwnd
2=LPRECT lpRect
3=LPPOINT lpPoint
ParamCount=3
@=NtUserGetInternalWindowPos(HWND hwnd, LPRECT lpRect, LPPOINT lpPoint);
[NtUserInitTask]
1=UINT dwExpWinVer
2=DWORD dwAppCompatFlags
3=PUNICODE_STRING pstrModName
4=PUNICODE_STRING pstrBaseFileName
5=DWORD hTaskWow
6=DWORD dwHotkey
7=DWORD idTask
8=DWORD dwX
9=DWORD dwY
10=DWORD dwXSize
11=DWORD dwYSize
ParamCount=11
@=NtUserInitTask(UINT dwExpWinVer, DWORD dwAppCompatFlags, PUNICODE_STRING pstrModName, PUNICODE_STRING pstrBaseFileName, DWORD hTaskWow, DWORD dwHotkey, DWORD idTask, DWORD dwX, DWORD dwY, DWORD dwXSize, DWORD dwYSize);
[NtUserPostThreadMessage]
1=DWORD id
2=UINT msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=NtUserPostThreadMessage(DWORD id, UINT msg, WPARAM wParam, LPARAM lParam);
[NtUserRegisterTasklist]
1=HWND hwndTasklist
ParamCount=1
@=NtUserRegisterTasklist(HWND hwndTasklist);
[NtUserSetClipboardData]
1=UINT wFmt
2=HANDLE hMem
3=PSETCLIPBDATA scd
ParamCount=3
@=NtUserSetClipboardData(UINT wFmt, HANDLE hMem, PSETCLIPBDATA scd);
[NtUserCloseClipboard]
1=VOID
ParamCount=1
@=NtUserCloseClipboard(VOID);
[NtUserEmptyClipboard]
1=VOID
ParamCount=1
@=NtUserEmptyClipboard(VOID);
[NtUserConvertMemHandle]
1=LPBYTE lpData
2=UINT cbNULL
ParamCount=2
@=NtUserConvertMemHandle(LPBYTE lpData, UINT cbNULL);
[NtUserCreateLocalMemHandle]
1=HANDLE hMem
2=LPBYTE lpData
3=UINT cbData
4=PUINT lpcbNeeded
ParamCount=4
@=NtUserCreateLocalMemHandle(HANDLE hMem, LPBYTE lpData, UINT cbData, PUINT lpcbNeeded);
[NtUserSetWindowsHookEx]
1=HANDLE hmod
2=pstrLib
3=DWORD idThread
4=int nFilterType
5=PROC pfnFilterProc
6=DWORD dwFlags
ParamCount=6
@=NtUserSetWindowsHookEx(HANDLE hmod, pstrLib, DWORD idThread, int nFilterType, PROC pfnFilterProc, DWORD dwFlags);
[NtUserSetInternalWindowPos]
1=HWND hwnd
2=UINT cmdShow
3=RECT *lpRect
4=POINT *lpPoint
ParamCount=4
@=NtUserSetInternalWindowPos(HWND hwnd, UINT cmdShow, RECT *lpRect, POINT *lpPoint);
[NtUserChangeClipboardChain]
1=HWND hwndRemove
2=HWND hwndNewNext
ParamCount=2
@=NtUserChangeClipboardChain(HWND hwndRemove, HWND hwndNewNext);
[NtUserCheckMenuItem]
1=HMENU hmenu
2=UINT wIDCheckItem
3=UINT wCheck
ParamCount=3
@=NtUserCheckMenuItem(HMENU hmenu, UINT wIDCheckItem, UINT wCheck);
[NtUserChildWindowFromPointEx]
1=HWND hwndParent
2=POINT point
3=UINT flags
ParamCount=3
@=NtUserChildWindowFromPointEx(HWND hwndParent, POINT point, UINT flags);
[NtUserClipCursor]
1=RECT *lpRect
ParamCount=1
@=NtUserClipCursor(RECT *lpRect);
[NtUserCreateAcceleratorTable]
1=LPACCEL lpAccel
2=INT cAccel
ParamCount=2
@=NtUserCreateAcceleratorTable(LPACCEL lpAccel, INT cAccel);
[NtUserDeleteMenu]
1=HMENU hmenu
2=UINT nPosition
3=UINT dwFlags
ParamCount=3
@=NtUserDeleteMenu(HMENU hmenu, UINT nPosition, UINT dwFlags);
[NtUserDestroyAcceleratorTable]
1=HACCEL hAccel
ParamCount=1
@=NtUserDestroyAcceleratorTable(HACCEL hAccel);
[NtUserDestroyCursor]
1=HCURSOR hcurs
2=DWORD cmd
ParamCount=2
@=NtUserDestroyCursor(HCURSOR hcurs, DWORD cmd);
[NtUserGetClipboardData]
1=UINT fmt
2=PGETCLIPBDATA pgcd
ParamCount=2
@=NtUserGetClipboardData(UINT fmt, PGETCLIPBDATA pgcd);
[NtUserDestroyMenu]
1=HMENU hmenu
ParamCount=1
@=NtUserDestroyMenu(HMENU hmenu);
[NtUserDestroyWindow]
1=HWND hwnd
ParamCount=1
@=NtUserDestroyWindow(HWND hwnd);
[NtUserDispatchMessage]
1=MSG *pmsg
ParamCount=1
@=NtUserDispatchMessage(MSG *pmsg);
[NtUserEnableMenuItem]
1=HMENU hMenu
2=UINT wIDEnableItem
3=UINT wEnable
ParamCount=3
@=NtUserEnableMenuItem(HMENU hMenu, UINT wIDEnableItem, UINT wEnable);
[NtUserAttachThreadInput]
1=DWORD idAttach
2=DWORD idAttachTo
3=BOOL fAttach
ParamCount=3
@=NtUserAttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach);
[NtUserGetWindowPlacement]
1=HWND hwnd
2=PWINDOWPLACEMENT pwp
ParamCount=2
@=NtUserGetWindowPlacement(HWND hwnd, PWINDOWPLACEMENT pwp);
[NtUserSetWindowPlacement]
1=HWND hwnd
2=WINDOWPLACEMENT *lpwndpl
ParamCount=2
@=NtUserSetWindowPlacement(HWND hwnd, WINDOWPLACEMENT *lpwndpl);
[NtUserLockWindowUpdate]
1=HWND hwnd
ParamCount=1
@=NtUserLockWindowUpdate(HWND hwnd);
[NtUserEnableScrollBar]
1=HWND hwnd
2=UINT wSBflags
3=UINT wArrows
ParamCount=3
@=NtUserEnableScrollBar(HWND hwnd, UINT wSBflags, UINT wArrows);
[NtUserDdeSetQualityOfService]
1=HWND hwndClient
2= NTAPINtUserDdeGetQualityOfService(INHWNDhwndClient
3=HWND hwndServer
4=pqos
ParamCount=4
@=NtUserDdeSetQualityOfService(HWND hwndClient,  NTAPINtUserDdeGetQualityOfService(INHWNDhwndClient, HWND hwndServer, pqos);
[NtUserGetMenuIndex]
1=HMENU hMenu
2=HMENU hSubMenu
ParamCount=2
@=NtUserGetMenuIndex(HMENU hMenu, HMENU hSubMenu);
[NtUserSetRipFlags]
1=DWORD dwRipFlags
2=DWORD PID
ParamCount=2
@=NtUserSetRipFlags(DWORD dwRipFlags, DWORD PID);
[NtUserSetDbgTag]
1=
2=DWORD dwBitFlags
ParamCount=2
@=NtUserSetDbgTag(
 inttag, DWORD dwBitFlags);
 inttag
[NtUserThunkedMenuItemInfo]
1=HMENU hMenu
2=UINT nPosition
3=BOOL fByPosition
4=BOOL fInsert
5=LPMENUITEMINFOW lpmii
6=pstrItem
ParamCount=6
@=NtUserThunkedMenuItemInfo(HMENU hMenu, UINT nPosition, BOOL fByPosition, BOOL fInsert, LPMENUITEMINFOW lpmii, pstrItem);
[NtUserThunkedMenuInfo]
1=HMENU hMenu
2=LPCMENUINFO lpmi
ParamCount=2
@=NtUserThunkedMenuInfo(HMENU hMenu, LPCMENUINFO lpmi);
[NtUserSetMenuDefaultItem]
1=HMENU hMenu
2=UINT wID
3=UINT fByPosition
ParamCount=3
@=NtUserSetMenuDefaultItem(HMENU hMenu, UINT wID, UINT fByPosition);
[NtUserDrawAnimatedRects]
1=HWND hwnd
2=int idAni
3=RECT *lprcFrom
4=RECT *lprcTo
ParamCount=4
@=NtUserDrawAnimatedRects(HWND hwnd, int idAni, RECT *lprcFrom, RECT *lprcTo);
[NtUserLoadIcoCur]
1=HANDLE hIcon
2=DWORD cxNew
3=DWORD cyNew
4=
5=HDC hdc
6=RECT *lprc
7=UINT flags
ParamCount=7
@=NtUserLoadIcoCur(HANDLE hIcon, DWORD cxNew, DWORD cyNew, 
 NTAPINtUserDrawCaption(INHWNDhwnd, HDC hdc, RECT *lprc, UINT flags);
 NTAPINtUserDrawCaption(INHWNDhwnd
[NtUserFlashWindowEx]
1=PFLASHWINFO pfwi
ParamCount=1
@=NtUserFlashWindowEx(PFLASHWINFO pfwi);
[NtUserPaintDesktop]
1=HDC hdc
ParamCount=1
@=NtUserPaintDesktop(HDC hdc);
[NtUserGetAsyncKeyState]
1=int vKey
ParamCount=1
@=NtUserGetAsyncKeyState(int vKey);
[NtUserGetControlBrush]
1=HWND hwnd
2=HDC hdc
3=UINT msg
ParamCount=3
@=NtUserGetControlBrush(HWND hwnd, HDC hdc, UINT msg);
[NtUserGetControlColor]
1=HWND hwndParent
2=HWND hwndCtl
3=HDC hdc
4=UINT msg
ParamCount=4
@=NtUserGetControlColor(HWND hwndParent, HWND hwndCtl, HDC hdc, UINT msg);
[NtUserEndMenu]
1=VOID
ParamCount=1
@=NtUserEndMenu(VOID);
[NtUserCountClipboardFormats]
1=VOID
ParamCount=1
@=NtUserCountClipboardFormats(VOID);
[NtUserGetClipboardSequenceNumber]
1=VOID
ParamCount=1
@=NtUserGetClipboardSequenceNumber(VOID);
[NtUserGetClipboardOwner]
1=VOID
ParamCount=1
@=NtUserGetClipboardOwner(VOID);
[NtUserGetClipboardSerialNumber]
1=VOID
ParamCount=1
@=NtUserGetClipboardSerialNumber(VOID);
[NtUserGetClipboardViewer]
1=VOID
ParamCount=1
@=NtUserGetClipboardViewer(VOID);
[NtUserGetDoubleClickTime]
1=VOID
ParamCount=1
@=NtUserGetDoubleClickTime(VOID);
[NtUserGetForegroundWindow]
1=VOID
ParamCount=1
@=NtUserGetForegroundWindow(VOID);
[NtUserGetOpenClipboardWindow]
1=VOID
ParamCount=1
@=NtUserGetOpenClipboardWindow(VOID);
[NtUserGetPriorityClipboardFormat]
1=UINT *paFormatPriorityList
2=int cFormats
ParamCount=2
@=NtUserGetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats);
[NtUserGetSystemMenu]
1=HWND hwnd
2=BOOL bRevert
ParamCount=2
@=NtUserGetSystemMenu(HWND hwnd, BOOL bRevert);
[NtUserGetUpdateRect]
1=HWND hwnd
2=LPRECT prect
3=BOOL bErase
ParamCount=3
@=NtUserGetUpdateRect(HWND hwnd, LPRECT prect, BOOL bErase);
[NtUserHideCaret]
1=HWND hwnd
ParamCount=1
@=NtUserHideCaret(HWND hwnd);
[NtUserHiliteMenuItem]
1=HWND hwnd
2=HMENU hMenu
3=UINT uIDHiliteItem
4=UINT uHilite
ParamCount=4
@=NtUserHiliteMenuItem(HWND hwnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite);
[NtUserInvalidateRect]
1=HWND hwnd
2=RECT *prect
3=BOOL bErase
ParamCount=3
@=NtUserInvalidateRect(HWND hwnd, RECT *prect, BOOL bErase);
[NtUserIsClipboardFormatAvailable]
1=UINT nFormat
ParamCount=1
@=NtUserIsClipboardFormatAvailable(UINT nFormat);
[NtUserKillTimer]
1=HWND hwnd
2=nIDEvent
ParamCount=2
@=NtUserKillTimer(HWND hwnd, nIDEvent);
[NtUserMinMaximize]
1=HWND hwnd
2=UINT nCmdShow
3=BOOL fKeepHidden
ParamCount=3
@=NtUserMinMaximize(HWND hwnd, UINT nCmdShow, BOOL fKeepHidden);
[NtUserMNDragOver]
1=POINT *ppt
2=PMNDRAGOVERINFO pmndoi
ParamCount=2
@=NtUserMNDragOver(POINT *ppt, PMNDRAGOVERINFO pmndoi);
[NtUserMNDragLeave]
1=VOID
ParamCount=1
@=NtUserMNDragLeave(VOID);
[NtUserOpenClipboard]
1=HWND hwnd
2=PBOOL pfEmptyClient
ParamCount=2
@=NtUserOpenClipboard(HWND hwnd, PBOOL pfEmptyClient);
[NtUserPeekMessage]
1=LPMSG pmsg
2=HWND hwnd
3=UINT wMsgFilterMin
4=UINT wMsgFilterMax
5=UINT wRemoveMsg
ParamCount=5
@=NtUserPeekMessage(LPMSG pmsg, HWND hwnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
[NtUserPostMessage]
1=HWND hwnd
2=UINT msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=NtUserPostMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
[NtUserSendNotifyMessage]
1=HWND hwnd
2=UINT Msg
3=WPARAM wParam
4=LPARAM lParam
ParamCount=4
@=NtUserSendNotifyMessage(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);
[NtUserSendMessageCallback]
1=HWND hwnd
2=UINT wMsg
3=WPARAM wParam
4=LPARAM lParam
5=SENDASYNCPROC lpResultCallBack
6=dwData
ParamCount=6
@=NtUserSendMessageCallback(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, dwData);
[NtUserRegisterHotKey]
1=HWND hwnd
2=int id
3=UINT fsModifiers
4=UINT vk
ParamCount=4
@=NtUserRegisterHotKey(HWND hwnd, int id, UINT fsModifiers, UINT vk);
[NtUserRemoveMenu]
1=HMENU hmenu
2=UINT nPosition
3=UINT dwFlags
ParamCount=3
@=NtUserRemoveMenu(HMENU hmenu, UINT nPosition, UINT dwFlags);
[NtUserScrollWindowEx]
1=HWND hwnd
2=int XAmount
3=int YAmount
4=RECT *pRect
5=RECT *pClipRect
6=HRGN hrgnUpdate
7=LPRECT prcUpdate
8=UINT flags
ParamCount=8
@=NtUserScrollWindowEx(HWND hwnd, int XAmount, int YAmount, RECT *pRect, RECT *pClipRect, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags);
[NtUserSetActiveWindow]
1=HWND hwnd
ParamCount=1
@=NtUserSetActiveWindow(HWND hwnd);
[NtUserSetCapture]
1=HWND hwnd
ParamCount=1
@=NtUserSetCapture(HWND hwnd);
[NtUserSetClassWord]
1=HWND hwnd
2=int nIndex
3=WORD wNewWord
ParamCount=3
@=NtUserSetClassWord(HWND hwnd, int nIndex, WORD wNewWord);
[NtUserSetClipboardViewer]
1=HWND hwndNewViewer
ParamCount=1
@=NtUserSetClipboardViewer(HWND hwndNewViewer);
[NtUserSetCursor]
1=HCURSOR hCursor
ParamCount=1
@=NtUserSetCursor(HCURSOR hCursor);
[NtUserSetFocus]
1=HWND hwnd
ParamCount=1
@=NtUserSetFocus(HWND hwnd);
[NtUserSetMenu]
1=HWND hwnd
2=HMENU hmenu
3=BOOL fRedraw
ParamCount=3
@=NtUserSetMenu(HWND hwnd, HMENU hmenu, BOOL fRedraw);
[NtUserSetMenuContextHelpId]
1=HMENU hMenu
2=DWORD dwContextHelpId
ParamCount=2
@=NtUserSetMenuContextHelpId(HMENU hMenu, DWORD dwContextHelpId);
[NtUserSetMenuFlagRtoL]
1=HMENU hMenu
ParamCount=1
@=NtUserSetMenuFlagRtoL(HMENU hMenu);
[NtUserSetParent]
1=HWND hwndChild
2=HWND hwndNewParent
ParamCount=2
@=NtUserSetParent(HWND hwndChild, HWND hwndNewParent);
[NtUserSetScrollInfo]
1=HWND hwnd
2=int nBar
3=LPCSCROLLINFO pInfo
4=BOOL fRedraw
ParamCount=4
@=NtUserSetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO pInfo, BOOL fRedraw);
[NtUserSetSysColors]
1=int cElements
2=INT *lpaElements
3=COLORREF *lpaRgbValues
4=UINT uOptions
ParamCount=4
@=NtUserSetSysColors(int cElements, INT *lpaElements, COLORREF *lpaRgbValues, UINT uOptions);
[NtUserSetTimer]
1=HWND hwnd
2=nIDEvent
3=UINT wElapse
4=TIMERPROC pTimerFunc
ParamCount=4
@=NtUserSetTimer(HWND hwnd, nIDEvent, UINT wElapse, TIMERPROC pTimerFunc);
[NtUserSetWindowLong]
1=HWND hwnd
2=int nIndex
3=LONG dwNewLong
4=BOOL bAnsi
ParamCount=4
@=NtUserSetWindowLong(HWND hwnd, int nIndex, LONG dwNewLong, BOOL bAnsi);
[NtUserSetWindowLongPtr]
1=HWND hwnd
2=int nIndex
3=dwNewLong
4=BOOL bAnsi
ParamCount=4
@=NtUserSetWindowLongPtr(HWND hwnd, int nIndex, dwNewLong, BOOL bAnsi);
[NtUserSetWindowWord]
1=HWND hwnd
2=int nIndex
3=WORD wNewWord
ParamCount=3
@=NtUserSetWindowWord(HWND hwnd, int nIndex, WORD wNewWord);
[NtUserSetWindowsHookAW]
1=int nFilterType
2=HOOKPROC pfnFilterProc
3=DWORD dwFlags
ParamCount=3
@=NtUserSetWindowsHookAW(int nFilterType, HOOKPROC pfnFilterProc, DWORD dwFlags);
[NtUserShowCaret]
1=HWND hwnd
ParamCount=1
@=NtUserShowCaret(HWND hwnd);
[NtUserShowScrollBar]
1=HWND hwnd
2=int iBar
3=BOOL fShow
ParamCount=3
@=NtUserShowScrollBar(HWND hwnd, int iBar, BOOL fShow);
[NtUserShowWindowAsync]
1=HWND hwnd
2=int nCmdShow
ParamCount=2
@=NtUserShowWindowAsync(HWND hwnd, int nCmdShow);
[NtUserShowWindow]
1=HWND hwnd
2=int nCmdShow
ParamCount=2
@=NtUserShowWindow(HWND hwnd, int nCmdShow);
[NtUserTrackMouseEvent]
1=LPTRACKMOUSEEVENT lpTME
ParamCount=1
@=NtUserTrackMouseEvent(LPTRACKMOUSEEVENT lpTME);
[NtUserTrackPopupMenuEx]
1=HMENU hMenu
2=UINT uFlags
3=int x
4=int y
5=HWND hwnd
6=TPMPARAMS *pparamst
ParamCount=6
@=NtUserTrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, TPMPARAMS *pparamst);
[NtUserTranslateMessage]
1=MSG *lpMsg
2=UINT flags
ParamCount=2
@=NtUserTranslateMessage(MSG *lpMsg, UINT flags);
[NtUserUnhookWindowsHookEx]
1=HHOOK hhk
ParamCount=1
@=NtUserUnhookWindowsHookEx(HHOOK hhk);
[NtUserUnregisterHotKey]
1=HWND hwnd
2=int id
ParamCount=2
@=NtUserUnregisterHotKey(HWND hwnd, int id);
[NtUserValidateRect]
1=HWND hwnd
2=RECT *lpRect
ParamCount=2
@=NtUserValidateRect(HWND hwnd, RECT *lpRect);
[NtUserWaitForInputIdle]
1=ULONG_PTR idProcess
2=DWORD dwMilliseconds
3=BOOL fSharedWow
ParamCount=3
@=NtUserWaitForInputIdle(ULONG_PTR idProcess, DWORD dwMilliseconds, BOOL fSharedWow);
[NtUserWindowFromPoint]
1=POINT Point
ParamCount=1
@=NtUserWindowFromPoint(POINT Point);
[NtUserBeginPaint]
1=HWND hwnd
2=LPPAINTSTRUCT lpPaint
ParamCount=2
@=NtUserBeginPaint(HWND hwnd, LPPAINTSTRUCT lpPaint);
[NtUserCreateCaret]
1=HWND hwnd
2=HBITMAP hBitmap
3=int nWidth
4=int nHeight
ParamCount=4
@=NtUserCreateCaret(HWND hwnd, HBITMAP hBitmap, int nWidth, int nHeight);
[NtUserEndPaint]
1=HWND hwnd
2=PAINTSTRUCT *lpPaint
ParamCount=2
@=NtUserEndPaint(HWND hwnd, PAINTSTRUCT *lpPaint);
[NtUserExcludeUpdateRgn]
1=HDC hDC
2=HWND hwnd
ParamCount=2
@=NtUserExcludeUpdateRgn(HDC hDC, HWND hwnd);
[NtUserGetDC]
1=HWND hwnd
ParamCount=1
@=NtUserGetDC(HWND hwnd);
[NtUserGetDCEx]
1=HWND hwnd
2=HRGN hrgnClip
3=DWORD flags
ParamCount=3
@=NtUserGetDCEx(HWND hwnd, HRGN hrgnClip, DWORD flags);
[NtUserGetWindowDC]
1=HWND hwnd
ParamCount=1
@=NtUserGetWindowDC(HWND hwnd);
[NtUserGetUpdateRgn]
1=HWND hwnd
2=HRGN hRgn
3=BOOL bErase
ParamCount=3
@=NtUserGetUpdateRgn(HWND hwnd, HRGN hRgn, BOOL bErase);
[NtUserRedrawWindow]
1=HWND hwnd
2=RECT *lprcUpdate
3=HRGN hrgnUpdate
4=UINT flags
ParamCount=4
@=NtUserRedrawWindow(HWND hwnd, RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
[NtUserInvalidateRgn]
1=HWND hwnd
2=HRGN hRgn
3=BOOL bErase
ParamCount=3
@=NtUserInvalidateRgn(HWND hwnd, HRGN hRgn, BOOL bErase);
[NtUserSetWindowRgn]
1=HWND hwnd
2=HRGN hRgn
3=BOOL bRedraw
ParamCount=3
@=NtUserSetWindowRgn(HWND hwnd, HRGN hRgn, BOOL bRedraw);
[NtUserScrollDC]
1=HDC hDC
2=int dx
3=int dy
4=RECT *lprcScroll
5=RECT *lprcClip
6=HRGN hrgnUpdate
7=LPRECT lprcUpdate
ParamCount=7
@=NtUserScrollDC(HDC hDC, int dx, int dy, RECT *lprcScroll, RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate);
[NtUserInternalGetWindowText]
1=HWND hwnd
2=LPWSTR lpString
3=int nMaxCount
ParamCount=3
@=NtUserInternalGetWindowText(HWND hwnd, LPWSTR lpString, int nMaxCount);
[NtUserGetMouseMovePointsEx]
1=UINT cbSize
2=MOUSEMOVEPOINT *lppt
3=MOUSEMOVEPOINT *lpptBuf
4=UINT nBufPoints
5=DWORD resolution
ParamCount=5
@=NtUserGetMouseMovePointsEx(UINT cbSize, MOUSEMOVEPOINT *lppt, MOUSEMOVEPOINT *lpptBuf, UINT nBufPoints, DWORD resolution);
[NtUserToUnicodeEx]
1=UINT wVirtKey
2=UINT wScanCode
3=BYTE *lpKeyState
4=LPWSTR lpszBuff
5=int cchBuff
6=UINT wFlags
7=HKL hKeyboardLayout
ParamCount=7
@=NtUserToUnicodeEx(UINT wVirtKey, UINT wScanCode, BYTE *lpKeyState, LPWSTR lpszBuff, int cchBuff, UINT wFlags, HKL hKeyboardLayout);
[NtUserYieldTask]
1=VOID
ParamCount=1
@=NtUserYieldTask(VOID);
[NtUserWaitMessage]
1=VOID
ParamCount=1
@=NtUserWaitMessage(VOID);
[NtUserLockWindowStation]
1=HWINSTA hWindowStation
ParamCount=1
@=NtUserLockWindowStation(HWINSTA hWindowStation);
[NtUserUnlockWindowStation]
1=HWINSTA hWindowStation
ParamCount=1
@=NtUserUnlockWindowStation(HWINSTA hWindowStation);
[NtUserSetWindowStationUser]
1=HWINSTA hWindowStation
2=PLUID pLuidUser
3=PSID pSidUser
4=DWORD cbSidUser
ParamCount=4
@=NtUserSetWindowStationUser(HWINSTA hWindowStation, PLUID pLuidUser, PSID pSidUser, DWORD cbSidUser);
[NtUserSetLogonNotifyWindow]
1=HWND hwndNotify
ParamCount=1
@=NtUserSetLogonNotifyWindow(HWND hwndNotify);
[NtUserSetSystemCursor]
1=HCURSOR hcur
2=DWORD id
ParamCount=2
@=NtUserSetSystemCursor(HCURSOR hcur, DWORD id);
[NtUserGetCursorFrameInfo]
1=HCURSOR hcur
2=int iFrame
3=LPDWORD pjifRate
4=LPINT pccur
ParamCount=4
@=NtUserGetCursorFrameInfo(HCURSOR hcur, int iFrame, LPDWORD pjifRate, LPINT pccur);
[NtUserSetCursorContents]
1=HCURSOR hCursor
2=HCURSOR hCursorNew
ParamCount=2
@=NtUserSetCursorContents(HCURSOR hCursor, HCURSOR hCursorNew);
[NtUserFindExistingCursorIcon]
1=PUNICODE_STRING pstrModName
2=PUNICODE_STRING pstrResName
3=PCURSORFIND pcfSearch
ParamCount=3
@=NtUserFindExistingCursorIcon(PUNICODE_STRING pstrModName, PUNICODE_STRING pstrResName, PCURSORFIND pcfSearch);
[NtUserSetCursorIconData]
1=HCURSOR hCursor
2=PUNICODE_STRING pstrModName
3=PUNICODE_STRING pstrResName
4=PCURSORDATA pData
ParamCount=4
@=NtUserSetCursorIconData(HCURSOR hCursor, PUNICODE_STRING pstrModName, PUNICODE_STRING pstrResName, PCURSORDATA pData);
[NtUserWOWModuleUnload]
1=HANDLE hModule
ParamCount=1
@=NtUserWOWModuleUnload(HANDLE hModule);
[NtUserWOWCleanup]
1=HANDLE hInstance
2=DWORD hTaskWow
ParamCount=2
@=NtUserWOWCleanup(HANDLE hInstance, DWORD hTaskWow);
[NtUserGetMenuItemRect]
1=HWND hwnd
2=HMENU hMenu
3=UINT uItem
4=LPRECT lprcItem
ParamCount=4
@=NtUserGetMenuItemRect(HWND hwnd, HMENU hMenu, UINT uItem, LPRECT lprcItem);
[NtUserMenuItemFromPoint]
1=HWND hwnd
2=HMENU hMenu
3=POINT ptScreen
ParamCount=3
@=NtUserMenuItemFromPoint(HWND hwnd, HMENU hMenu, POINT ptScreen);
[NtUserGetCaretPos]
1=LPPOINT lpPoint
ParamCount=1
@=NtUserGetCaretPos(LPPOINT lpPoint);
[NtUserDefSetText]
1=HWND hwnd
2=Text
ParamCount=2
@=NtUserDefSetText(HWND hwnd, Text);
[NtUserQueryInformationThread]
1=HANDLE hThread
2=USERTHREADINFOCLASS ThreadInfoClass
3=PVOID ThreadInformation
4=ULONG ThreadInformationLength
5=PULONG ReturnLength
ParamCount=5
@=NtUserQueryInformationThread(HANDLE hThread, USERTHREADINFOCLASS ThreadInfoClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
[NtUserSetInformationThread]
1=HANDLE hThread
2=USERTHREADINFOCLASS ThreadInfoClass
3=PVOID ThreadInformation
4=ULONG ThreadInformationLength
ParamCount=4
@=NtUserSetInformationThread(HANDLE hThread, USERTHREADINFOCLASS ThreadInfoClass, PVOID ThreadInformation, ULONG ThreadInformationLength);
[NtUserSetInformationProcess]
1=HANDLE hProcess
2=USERPROCESSINFOCLASS ProcessInfoClass
3=PVOID ProcessInformation
4=ULONG ProcessInformationLength
ParamCount=4
@=NtUserSetInformationProcess(HANDLE hProcess, USERPROCESSINFOCLASS ProcessInfoClass, PVOID ProcessInformation, ULONG ProcessInformationLength);
[NtUserNotifyProcessCreate]
1=DWORD dwProcessId
2=DWORD dwParentThreadId
3=dwData
4=DWORD dwFlags
ParamCount=4
@=NtUserNotifyProcessCreate(DWORD dwProcessId, DWORD dwParentThreadId, dwData, DWORD dwFlags);
[NtUserTestForInteractiveUser]
1=PLUID pluidCaller
ParamCount=1
@=NtUserTestForInteractiveUser(PLUID pluidCaller);
[NtUserSetConsoleReserveKeys]
1=HWND hwnd
2=DWORD fsReserveKeys
ParamCount=2
@=NtUserSetConsoleReserveKeys(HWND hwnd, DWORD fsReserveKeys);
[NtUserModifyUserStartupInfoFlags]
1=DWORD dwMask
2=DWORD dwFlags
ParamCount=2
@=NtUserModifyUserStartupInfoFlags(DWORD dwMask, DWORD dwFlags);
[NtUserSetWindowFNID]
1=HWND hwnd
2=WORD fnid
ParamCount=2
@=NtUserSetWindowFNID(HWND hwnd, WORD fnid);
[NtUserAlterWindowStyle]
1=HWND hwnd
2=DWORD mask
3=DWORD flags
ParamCount=3
@=NtUserAlterWindowStyle(HWND hwnd, DWORD mask, DWORD flags);
[NtUserSetThreadState]
1=DWORD dwFlags
2=DWORD dwMask
ParamCount=2
@=NtUserSetThreadState(DWORD dwFlags, DWORD dwMask);
[NtUserGetThreadState]
1=USERTHREADSTATECLASS ThreadState
ParamCount=1
@=NtUserGetThreadState(USERTHREADSTATECLASS ThreadState);
[NtUserGetListboxString]
1=HWND hwnd
2=UINT msg
3=WPARAM wParam
4=pString
5=xParam
6=DWORD xpfn
7=PBOOL pbNotString
ParamCount=7
@=NtUserGetListboxString(HWND hwnd, UINT msg, WPARAM wParam, pString, xParam, DWORD xpfn, PBOOL pbNotString);
[NtUserValidateHandleSecure]
1=HANDLE h
ParamCount=1
@=NtUserValidateHandleSecure(HANDLE h);
[NtUserUserHandleGrantAccess]
1=HANDLE hUserHandle
2=HANDLE hJob
3=BOOL bGrant
ParamCount=3
@=NtUserUserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant);
[NtUserCreateWindowEx]
1=DWORD dwExStyle
2=pstrClassName
3=pstrWindowName
4=DWORD dwStyle
5=int x
6=int y
7=int nWidth
8=int nHeight
9=HWND hwndParent
10=HMENU hmenu
11=HANDLE hModule
12=LPVOID pParam
13=DWORD dwFlags
ParamCount=13
@=NtUserCreateWindowEx(DWORD dwExStyle, pstrClassName, pstrWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hwndParent, HMENU hmenu, HANDLE hModule, LPVOID pParam, DWORD dwFlags);
[NtUserBuildHwndList]
1=HDESK hdesk
2=HWND hwndNext
3=BOOL fEnumChildren
4=DWORD idThread
5=UINT cHwndMax
6=HWND *phwndFirst
7=PUINT pcHwndNeeded
ParamCount=7
@=NtUserBuildHwndList(HDESK hdesk, HWND hwndNext, BOOL fEnumChildren, DWORD idThread, UINT cHwndMax, HWND *phwndFirst, PUINT pcHwndNeeded);
[NtUserBuildPropList]
1=HWND hwnd
2=UINT cPropMax
3=PPROPSET pPropSet
4=PUINT pcPropNeeded
ParamCount=4
@=NtUserBuildPropList(HWND hwnd, UINT cPropMax, PPROPSET pPropSet, PUINT pcPropNeeded);
[NtUserBuildNameList]
1=HWINSTA hwinsta
2=UINT cbNameList
3=PNAMELIST pNameList
4=PUINT pcbNeeded
ParamCount=4
@=NtUserBuildNameList(HWINSTA hwinsta, UINT cbNameList, PNAMELIST pNameList, PUINT pcbNeeded);
[NtUserActivateKeyboardLayout]
1=HKL hkl
2=UINT Flags
ParamCount=2
@=NtUserActivateKeyboardLayout(HKL hkl, UINT Flags);
[NtUserLoadKeyboardLayoutEx]
1=HANDLE hFile
2=DWORD offTable
3=HKL hkl
4=PUNICODE_STRING pstrKLID
5=UINT KbdInputLocale
6=UINT Flags
ParamCount=6
@=NtUserLoadKeyboardLayoutEx(HANDLE hFile, DWORD offTable, HKL hkl, PUNICODE_STRING pstrKLID, UINT KbdInputLocale, UINT Flags);
[NtUserUnloadKeyboardLayout]
1=HKL hkl
ParamCount=1
@=NtUserUnloadKeyboardLayout(HKL hkl);
[NtUserSetSystemMenu]
1=HWND hwnd
2=HMENU hmenu
ParamCount=2
@=NtUserSetSystemMenu(HWND hwnd, HMENU hmenu);
[NtUserDragDetect]
1=HWND hwnd
2=POINT pt
ParamCount=2
@=NtUserDragDetect(HWND hwnd, POINT pt);
[NtUserSetSystemTimer]
1=HWND hwnd
2=nIDEvent
3=DWORD dwElapse
4=WNDPROC pTimerFunc
ParamCount=4
@=NtUserSetSystemTimer(HWND hwnd, nIDEvent, DWORD dwElapse, WNDPROC pTimerFunc);
[NtUserQuerySendMessage]
1=PMSG pmsg
ParamCount=1
@=NtUserQuerySendMessage(PMSG pmsg);
[NtUserSendInput]
1=UINT cInputs
2=INPUT *pInputs
3=int cbSize
ParamCount=3
@=NtUserSendInput(UINT cInputs, INPUT *pInputs, int cbSize);
[NtUserImpersonateDdeClientWindow]
1=HWND hwndClient
2=HWND hwndServer
ParamCount=2
@=NtUserImpersonateDdeClientWindow(HWND hwndClient, HWND hwndServer);
[NtUserGetCPD]
1=HWND hwnd
2=DWORD options
3=dwData
ParamCount=3
@=NtUserGetCPD(HWND hwnd, DWORD options, dwData);
[NtUserCopyAcceleratorTable]
1=HACCEL hAccelSrc
2=LPACCEL lpAccelDst
3=int cAccelEntries
ParamCount=3
@=NtUserCopyAcceleratorTable(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries);
[NtUserFindWindowEx]
1=HWND hwndParent
2=HWND hwndChild
3=PUNICODE_STRING pstrClassName
4=PUNICODE_STRING pstrWindowName
5=DWORD dwType
ParamCount=5
@=NtUserFindWindowEx(HWND hwndParent, HWND hwndChild, PUNICODE_STRING pstrClassName, PUNICODE_STRING pstrWindowName, DWORD dwType);
[NtUserGetClassInfo]
1=HINSTANCE hInstance
2=PUNICODE_STRING pstrClassName
3=LPWNDCLASSEXW lpWndClass
4=LPWSTR *ppszMenuName
5=BOOL bAnsi
ParamCount=5
@=NtUserGetClassInfo(HINSTANCE hInstance, PUNICODE_STRING pstrClassName, LPWNDCLASSEXW lpWndClass, LPWSTR *ppszMenuName, BOOL bAnsi);
[NtUserGetClassName]
1=HWND hwnd
2=BOOL bReal
3=PUNICODE_STRING pstrClassName
ParamCount=3
@=NtUserGetClassName(HWND hwnd, BOOL bReal, PUNICODE_STRING pstrClassName);
[NtUserGetClipboardFormatName]
1=UINT format
2=LPWSTR lpszFormatName
3=UINT chMax
ParamCount=3
@=NtUserGetClipboardFormatName(UINT format, LPWSTR lpszFormatName, UINT chMax);
[NtUserGetKeyNameText]
1=LONG lParam
2=LPWSTR lpszKeyName
3=UINT chMax
ParamCount=3
@=NtUserGetKeyNameText(LONG lParam, LPWSTR lpszKeyName, UINT chMax);
[NtUserGetKeyboardLayoutName]
1=PUNICODE_STRING pstrKLID
ParamCount=1
@=NtUserGetKeyboardLayoutName(PUNICODE_STRING pstrKLID);
[NtUserGetKeyboardLayoutList]
1=UINT nItems
2=HKL *lpBuff
ParamCount=2
@=NtUserGetKeyboardLayoutList(UINT nItems, HKL *lpBuff);
[NtUserGetGuiResources]
1=HANDLE hProcess
2=DWORD dwFlags
ParamCount=2
@=NtUserGetGuiResources(HANDLE hProcess, DWORD dwFlags);
[NtUserMapVirtualKeyEx]
1=UINT uCode
2=UINT uMapType
3=dwHKLorPKL
4=BOOL bHKL
ParamCount=4
@=NtUserMapVirtualKeyEx(UINT uCode, UINT uMapType, dwHKLorPKL, BOOL bHKL);
[NtUserRegisterClassExWOW]
1=WNDCLASSEX *lpWndClass
2=PUNICODE_STRING pstrClassName
3=PCLSMENUNAME pcmn
4=WORD fnid
5=DWORD dwFlags
6=LPDWORD pdwWOWstuff
ParamCount=6
@=NtUserRegisterClassExWOW(WNDCLASSEX *lpWndClass, PUNICODE_STRING pstrClassName, PCLSMENUNAME pcmn, WORD fnid, DWORD dwFlags, LPDWORD pdwWOWstuff);
[NtUserRegisterWindowMessage]
1=PUNICODE_STRING pstrMessage
ParamCount=1
@=NtUserRegisterWindowMessage(PUNICODE_STRING pstrMessage);
[NtUserRemoveProp]
1=HWND hwnd
2=DWORD dwProp
ParamCount=2
@=NtUserRemoveProp(HWND hwnd, DWORD dwProp);
[NtUserSetProp]
1=HWND hwnd
2=DWORD dwProp
3=HANDLE hData
ParamCount=3
@=NtUserSetProp(HWND hwnd, DWORD dwProp, HANDLE hData);
[NtUserUnregisterClass]
1=PUNICODE_STRING pstrClassName
2=HINSTANCE hInstance
3=PCLSMENUNAME pcmn
ParamCount=3
@=NtUserUnregisterClass(PUNICODE_STRING pstrClassName, HINSTANCE hInstance, PCLSMENUNAME pcmn);
[NtUserVkKeyScanEx]
1=WCHAR ch
2=dwHKLorPKL
3=BOOL bHKL
ParamCount=3
@=NtUserVkKeyScanEx(WCHAR ch, dwHKLorPKL, BOOL bHKL);
[NtUserEnumDisplayDevices]
1=PUNICODE_STRING pstrDeviceName
2=DWORD iDevNum
3=lpDisplayDevice
4=DWORD dwFlags
ParamCount=4
@=NtUserEnumDisplayDevices(PUNICODE_STRING pstrDeviceName, DWORD iDevNum, lpDisplayDevice, DWORD dwFlags);
[NtUserSetWinEventHook]
1=DWORD eventMin
2=DWORD eventMax
3=HMODULE hmodWinEventProc
4=PUNICODE_STRING pstrLib
5=WINEVENTPROC pfnWinEventProc
6=DWORD idEventProcess
7=DWORD idEventThread
8=DWORD dwFlags
ParamCount=8
@=NtUserSetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, PUNICODE_STRING pstrLib, WINEVENTPROC pfnWinEventProc, DWORD idEventProcess, DWORD idEventThread, DWORD dwFlags);
[NtUserUnhookWinEvent]
1=HWINEVENTHOOK hWinEventHook
ParamCount=1
@=NtUserUnhookWinEvent(HWINEVENTHOOK hWinEventHook);
[NtUserNotifyWinEvent]
1=DWORD event
2=HWND hwnd
3=LONG idObject
4=LONG idChild
ParamCount=4
@=NtUserNotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild);
[NtUserGetGUIThreadInfo]
1=DWORD idThread
2=PGUITHREADINFO pgui
ParamCount=2
@=NtUserGetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui);
[NtUserGetTitleBarInfo]
1=HWND hwnd
2=PTITLEBARINFO ptbi
ParamCount=2
@=NtUserGetTitleBarInfo(HWND hwnd, PTITLEBARINFO ptbi);
[NtUserGetScrollBarInfo]
1=HWND hwnd
2=LONG idObject
3=PSCROLLBARINFO ptbi
ParamCount=3
@=NtUserGetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO ptbi);
[NtUserGetComboBoxInfo]
1=HWND hwnd
2=PCOMBOBOXINFO pcbi
ParamCount=2
@=NtUserGetComboBoxInfo(HWND hwnd, PCOMBOBOXINFO pcbi);
[NtUserGetListBoxInfo]
1=HWND hwnd
ParamCount=1
@=NtUserGetListBoxInfo(HWND hwnd);
[NtUserGetAncestor]
1=HWND hwnd
2=UINT gaFlags
ParamCount=2
@=NtUserGetAncestor(HWND hwnd, UINT gaFlags);
[NtUserGetCursorInfo]
1=PCURSORINFO pci
ParamCount=1
@=NtUserGetCursorInfo(PCURSORINFO pci);
[NtUserRealChildWindowFromPoint]
1=HWND hwndParent
2=POINT pt
ParamCount=2
@=NtUserRealChildWindowFromPoint(HWND hwndParent, POINT pt);
[NtUserGetAltTabInfo]
1=HWND hwnd
2=int iItem
3=PALTTABINFO pati
4=LPWSTR lpszItemText
5=UINT cchItemText
6=BOOL bAnsi
ParamCount=6
@=NtUserGetAltTabInfo(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR lpszItemText, UINT cchItemText, BOOL bAnsi);
[NtUserGetMenuBarInfo]
1=HWND hwnd
2=long idObject
3=long idItem
4=PMENUBARINFO pmbi
ParamCount=4
@=NtUserGetMenuBarInfo(HWND hwnd, long idObject, long idItem, PMENUBARINFO pmbi);
[NtUserChangeDisplaySettings]
1=PUNICODE_STRING pstrDeviceName
2=LPDEVMODEW lpDevMode
3=HWND hwnd
4=DWORD dwFlags
5=PVOID lParam
ParamCount=5
@=NtUserChangeDisplaySettings(PUNICODE_STRING pstrDeviceName, LPDEVMODEW lpDevMode, HWND hwnd, DWORD dwFlags, PVOID lParam);
[NtUserCallMsgFilter]
1=LPMSG lpMsg
2=int nCode
ParamCount=2
@=NtUserCallMsgFilter(LPMSG lpMsg, int nCode);
[NtUserDrawMenuBarTemp]
1=HWND hwnd
2=HDC hdc
3=LPCRECT lprc
4=HMENU hMenu
5=HFONT hFont
ParamCount=5
@=NtUserDrawMenuBarTemp(HWND hwnd, HDC hdc, LPCRECT lprc, HMENU hMenu, HFONT hFont);
[NtUserDrawCaptionTemp]
1=HWND hwnd
2=HDC hdc
3=LPCRECT lprc
4=HFONT hFont
5=HICON hicon
6=PUNICODE_STRING pstrText
7=UINT flags
ParamCount=7
@=NtUserDrawCaptionTemp(HWND hwnd, HDC hdc, LPCRECT lprc, HFONT hFont, HICON hicon, PUNICODE_STRING pstrText, UINT flags);
[NtUserGetKeyState]
1=int vk
ParamCount=1
@=NtUserGetKeyState(int vk);
[NtUserGetKeyboardState]
1=PBYTE pb
ParamCount=1
@=NtUserGetKeyboardState(PBYTE pb);
[NtUserQueryWindow]
1=HWND hwnd
2=WINDOWINFOCLASS WindowInfo
ParamCount=2
@=NtUserQueryWindow(HWND hwnd, WINDOWINFOCLASS WindowInfo);
[NtUserSBGetParms]
1=HWND hwnd
2=int code
3=PSBDATA pw
4=LPSCROLLINFO lpsi
ParamCount=4
@=NtUserSBGetParms(HWND hwnd, int code, PSBDATA pw, LPSCROLLINFO lpsi);
[NtUserBitBltSysBmp]
1=HDC hdc
2=int xDest
3=int yDest
4=int cxDest
5=int cyDest
6=int xSrc
7=int ySrc
8=DWORD dwRop
ParamCount=8
@=NtUserBitBltSysBmp(HDC hdc, int xDest, int yDest, int cxDest, int cyDest, int xSrc, int ySrc, DWORD dwRop);
[NtUserMessageCall]
1=HWND hwnd
2=UINT msg
3=WPARAM wParam
4=LPARAM lParam
5=xParam
6=DWORD xpfnProc
7=BOOL bAnsi
ParamCount=7
@=NtUserMessageCall(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, xParam, DWORD xpfnProc, BOOL bAnsi);
[NtUserCallNextHookEx]
1=int nCode
2=WPARAM wParam
3=LPARAM lParam
4=BOOL bAnsi
ParamCount=4
@=NtUserCallNextHookEx(int nCode, WPARAM wParam, LPARAM lParam, BOOL bAnsi);
[NtUserEnumDisplayMonitors]
1=HDC hdc
2=LPCRECT lprcClip
3=MONITORENUMPROC lpfnEnum
4=LPARAM dwData
ParamCount=4
@=NtUserEnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData);
[NtUserEnumDisplaySettings]
1=PUNICODE_STRING pstrDeviceName
2=DWORD iModeNum
3=LPDEVMODEW lpDevMode
4=DWORD dwFlags
ParamCount=4
@=NtUserEnumDisplaySettings(PUNICODE_STRING pstrDeviceName, DWORD iModeNum, LPDEVMODEW lpDevMode, DWORD dwFlags);
[NtUserQueryUserCounters]
1=DWORD dwQueryType
2=LPVOID pvIn
3=DWORD dwInSize
4=LPVOID pvResult
5=DWORD dwOutSize
ParamCount=5
@=NtUserQueryUserCounters(DWORD dwQueryType, LPVOID pvIn, DWORD dwInSize, LPVOID pvResult, DWORD dwOutSize);
[NtUserUpdateLayeredWindow]
1=HWND hwnd
2=HDC hdcDst
3=POINT *pptDst
4=SIZE *psize
5=HDC hdcSrc
6=POINT *pptSrc
7=COLORREF crKey
8=BLENDFUNCTION *pblend
9=DWORD dwFlags
ParamCount=9
@=NtUserUpdateLayeredWindow(HWND hwnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags);
[NtUserSetLayeredWindowAttributes]
1=HWND hwnd
2=COLORREF crKey
3=BYTE bAlpha
4=DWORD dwFlags
ParamCount=4
@=NtUserSetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
[NtUserRemoteConnect]
1=PDOCONNECTDATA pDoConnectData
2=ULONG DisplayDriverNameLength
3=PWCHAR DisplayDriverName
ParamCount=3
@=NtUserRemoteConnect(PDOCONNECTDATA pDoConnectData, ULONG DisplayDriverNameLength, PWCHAR DisplayDriverName);
[NtUserRemoteRedrawRectangle]
1=WORD Left
2=WORD Top
3=WORD Right
4=WORD Bottom
ParamCount=4
@=NtUserRemoteRedrawRectangle(WORD Left, WORD Top, WORD Right, WORD Bottom);
[NtUserRemoteRedrawScreen]
ParamCount=0
@=NtUserRemoteRedrawScreen();
[NtUserRemoteStopScreenUpdates]
ParamCount=0
@=NtUserRemoteStopScreenUpdates();
[NtUserCtxDisplayIOCtl]
1=ULONG DisplayIOCtlFlags
2=PUCHAR pDisplayIOCtlData
3=ULONG cbDisplayIOCtlData
ParamCount=3
@=NtUserCtxDisplayIOCtl(ULONG DisplayIOCtlFlags, PUCHAR pDisplayIOCtlData, ULONG cbDisplayIOCtlData);
[NtUserSelectPalette]
1=HDC hdc
2=HPALETTE hpalette
3=BOOL fForceBackground
ParamCount=3
@=NtUserSelectPalette(HDC hdc, HPALETTE hpalette, BOOL fForceBackground);
[NtUserProcessConnect]
1=HANDLE hProcess
2=PVOID pConnectInfo
3=ULONG cbConnectInfo
ParamCount=3
@=NtUserProcessConnect(HANDLE hProcess, PVOID pConnectInfo, ULONG cbConnectInfo);
[NtUserSoundSentry]
ParamCount=0
@=NtUserSoundSentry();
[NtUserInitialize]
1=DWORD dwVersion
2=HANDLE hPowerRequestEvent
3=HANDLE hMediaRequestEvent
ParamCount=3
@=NtUserInitialize(DWORD dwVersion, HANDLE hPowerRequestEvent, HANDLE hMediaRequestEvent);




================================================
File: release/APIInfo-readme.txt
================================================
;=====================================================================================
;
; APIInfo-readme.txt
;
; v1.0.0.3 - Last updated: 26/06/2016 
;
;-------------------------------------------------------------------------------------

NOTE
----

APIInfo plugin has been superseded by ThunderCls's xAnalyzer plugin.

xAnalyzer supports both x86 and x64 versions of x64dbg.

For more information, please visit: https://github.com/ThunderCls/xAnalyzer




About
-----

APIInfo Plugin (x86) For x64dbg (32bit plugin)
by fearless - www.LetTheLight.in

Created with the x64dbg Plugin SDK For x86 Assembler
https://github.com/mrfearless/x64dbg-Plugin-SDK-For-x86-Assembler


Overview
--------

A plugin to populate the comments with windows api calls


Features
--------

- Add windows api function definition information to the comments


Installation
------------

Copy APIInfo.dp32 to x32\plugins folder of x64dbg
Extract APIInfo-API-Definitions.zip which contains the api definition files to the same 
plugins folder


How to use
----------

 - Set the required detail level in the APIInfo options dialog (from the plugins menu, 
   APIInfo Options)
 - Select Generate API Information from the plugins menu (or from the right click context
   menu in the CPU View)
 - Wait till the information has been generated - hopefully you should see some API
   definitions show up in the comments now

 
Notes
-----

The API defintion files are created with a utility called ApiCreator (currently unreleased)
which takes a selected windows sdk header file and parses it, outputting the function
definitions into a file which uses a standard .ini format

Each function name is the stored as a section name, the key values for parameters, 
parameter count and full definition (key '@') are stored under this section name for easy 
retrieval with standard win32 api calls: GetPrivateProfileString & GetPrivateProfileInt
Some of the definition files have to be manually fixed up afterwards, so there may be 
errors or omissions. If you require a specific api file generated, feel free to contact me.

The comments where APIInfo thinks there is a parameter may be incorrect in some cases.

There isnt an x64 version of the plugin at this time due to the differences in calling 
conventions for 64bit, and would require considerable more time than i can spare to look
into ways of maybe generating this info.



- 26/06/2016 updated plugin to use ico, added definitions with plugin
- 01/03/2016 Updated x64dbg SDK for masm to version 1.0.0.2 and recompiled plugin.
- Added function APIInfoLoadMenuIcon to load png resource image as raw bytes 
- Added menu icon for plugin (uses _plugin_menuseticon)
- Added menu entry icons for options and gen api (uses _plugin_menuentryseticon)



================================================
File: release/APIInfo.dp32
================================================
[Non-text file]


================================================
File: res/APIInfoDlg.rc
================================================
#define IDD_APIInfoOptionsDlg 1000
#define IDC_GRP1 1010
#define IDC_GrpAPIFilesToInclude 1001
#define IDC_BtnAPIInfoOptionsOk 1014
#define IDC_LV_APIFILES 1002
#define IDC_GrpAPIDisplayOptions 1003
#define IDC_RbDisplayModuleAndFunction 1007
#define IDC_RbDisplayFunctionDef 1008
#define IDC_RbDisplayModuleOnly 1005
#define IDC_RbDisplayFunctionOnly 1006
#define IDC_RbDisplayFunctionDefParams 1009
#define IDC_BtnAPIInfoOptionsCancel 1013
#define IDC_RbDisplayNothing 1004
#define IDC_ChkAutoLoad 1011
#define IDC_ChkPreserveExistingComments 1012
IDD_APIInfoOptionsDlg DIALOGEX 6,6,322,232
CAPTION "APIInfo Options"
FONT 8,"Segoe UI",400,0
STYLE 0x10C80800
EXSTYLE 0x00000000
BEGIN
  CONTROL "API files to include:",IDC_GrpAPIFilesToInclude,"Button",0x50000007,5,7,118,192,0x00000000
  CONTROL "",IDC_LV_APIFILES,"SysListView32",0x5001400D,10,24,107,168,0x00000200
  CONTROL "API Display Options:",IDC_GrpAPIDisplayOptions,"Button",0x50000007,130,7,184,133,0x00000000
  CONTROL "Display module name only",IDC_RbDisplayModuleOnly,"Button",0x50010009,144,41,160,12,0x00000000
  CONTROL "Display function name only",IDC_RbDisplayFunctionOnly,"Button",0x50010009,144,61,160,12,0x00000000
  CONTROL "Display module and function name",IDC_RbDisplayModuleAndFunction,"Button",0x50010009,144,81,160,12,0x00000000
  CONTROL "Display function definition",IDC_RbDisplayFunctionDef,"Button",0x50010009,144,100,160,12,0x00000000
  CONTROL "Display function definition && parameters ",IDC_RbDisplayFunctionDefParams,"Button",0x50010009,144,120,160,12,0x00000000
  CONTROL "&Cancel",IDC_BtnAPIInfoOptionsCancel,"Button",0x50010000,130,206,88,17,0x00000000
  CONTROL "O&k",IDC_BtnAPIInfoOptionsOk,"Button",0x50010001,226,206,88,17,0x00000000
  CONTROL "Automatically apply API info on entry",IDC_ChkAutoLoad,"Button",0x50030003,144,162,158,12,0x00000000
  CONTROL "Display nothing (disable plugin)",IDC_RbDisplayNothing,"Button",0x50010009,144,22,160,12,0x00000000
  CONTROL "Preserve existing user made comments",IDC_ChkPreserveExistingComments,"Button",0x50030003,144,179,158,12,0x00000000
  CONTROL "Other Options:",IDC_GRP1,"Button",0x50000007,130,147,184,52,0x00000000
END



================================================
File: res/APIInfoRes.rc
================================================
#define MANIFEST 						24
1						MANIFEST  DISCARDABLE "APIInfo.xml"
101						RCDATA    DISCARDABLE "Images/APIInfo.png"
102						RCDATA    DISCARDABLE "Images/APIInfoOptions.png"
103						RCDATA    DISCARDABLE "Images/APIInfoGenAPI.png"
100						ICON      DISCARDABLE "Images/APIInfo.ico"



================================================
File: res/APIInfoVer.rc
================================================
#define VERINF1 1
VERINF1 VERSIONINFO
FILEVERSION 1,0,0,3
PRODUCTVERSION 1,0,0,3
FILEOS 0x00000004
FILETYPE 0x00000002
BEGIN
  BLOCK "StringFileInfo"
  BEGIN
    BLOCK "040904B0"
    BEGIN
      VALUE "CompanyName", "fearless @ www.LetTheLight.in\0"
      VALUE "FileVersion", "1.0.0.3\0"
      VALUE "FileDescription", "APIInfo plugin for x32dbg\0"
      VALUE "InternalName", "APIInfo.dll\0"
      VALUE "LegalCopyright", "fearless (C) 2016 www.LetTheLight.in\0"
      VALUE "LegalTrademarks", "fearless (C) 2016 www.LetTheLight.in\0"
      VALUE "OriginalFilename", "APIInfo.dp32\0"
      VALUE "ProductName", "APIInfo\0"
      VALUE "ProductVersion", "1.0.0.3\0"
    END
  END
  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x0409, 0x04B0
  END
END



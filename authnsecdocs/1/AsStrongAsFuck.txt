Directory structure:
└── decay88-asstrongasfuck/
    ├── README.md
    ├── LICENSE
    └── AsStrongAsFuck/
        ├── App.config
        ├── AsStrongAsFuck.csproj
        ├── AsStrongAsFuck.sln
        ├── ConstantsEncoding.cs
        ├── ControlFlow.cs
        ├── Extensions.cs
        ├── IObfuscation.cs
        ├── LocalsToFields.cs
        ├── Logger.cs
        ├── ModuleRenaming.cs
        ├── OwnRandom.cs
        ├── Program.cs
        ├── RandomNamespaces.cs
        ├── ReferenceProxy.cs
        ├── Runtime.cs
        ├── Utils.cs
        ├── Worker.cs
        ├── Mutations/
        │   ├── Funcs.cs
        │   ├── MutationObf.cs
        │   ├── NumbersToModuleReference.cs
        │   └── iMutation.cs
        ├── Properties/
        │   └── AssemblyInfo.cs
        └── libs/

================================================
File: README.md
================================================
# AsStrongAsFuck

AsStrongAsFuck - Free C# console obfuscation engine.
Help me by improving the obfuscator! Discord: https://discord.gg/84ktUrr

Example of working:
-
The first screenshot: <br>
![one.png](https://charter.ml/one.png) <br>
The second screenshot: <br> 
![two.png](https://charter.ml/two.png) <br>



================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2019 Charterino

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: AsStrongAsFuck/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
    </startup>
</configuration>


================================================
File: AsStrongAsFuck/AsStrongAsFuck.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{0FE687CD-6631-428E-A054-8039A20E6F6E}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>AsStrongAsFuck</RootNamespace>
    <AssemblyName>AsStrongAsFuck</AssemblyName>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib, Version=1.5.0.1500, Culture=neutral, PublicKeyToken=50e96378b6e77999, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>libs\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="ConstantsEncoding.cs" />
    <Compile Include="ControlFlow.cs" />
    <Compile Include="Extensions.cs" />
    <Compile Include="IObfuscation.cs" />
    <Compile Include="LocalsToFields.cs" />
    <Compile Include="Logger.cs" />
    <Compile Include="ModuleRenaming.cs" />
    <Compile Include="Mutations\Funcs.cs" />
    <Compile Include="Mutations\iMutation.cs" />
    <Compile Include="Mutations\MutationObf.cs" />
    <Compile Include="Mutations\NumbersToModuleReference.cs" />
    <Compile Include="OwnRandom.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="RandomNamespaces.cs" />
    <Compile Include="ReferenceProxy.cs" />
    <Compile Include="Runtime.cs" />
    <Compile Include="Utils.cs" />
    <Compile Include="Worker.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================
File: AsStrongAsFuck/AsStrongAsFuck.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28721.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AsStrongAsFuck", "AsStrongAsFuck.csproj", "{0FE687CD-6631-428E-A054-8039A20E6F6E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0FE687CD-6631-428E-A054-8039A20E6F6E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0FE687CD-6631-428E-A054-8039A20E6F6E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0FE687CD-6631-428E-A054-8039A20E6F6E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0FE687CD-6631-428E-A054-8039A20E6F6E}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F96ECAE6-F835-420A-9A2E-6949E2E8F581}
	EndGlobalSection
EndGlobal



================================================
File: AsStrongAsFuck/ConstantsEncoding.cs
================================================
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.PE;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;

namespace AsStrongAsFuck
{
    public class ConstantsEncoding : IObfuscation
    {
        public int CurrentIndex { get; set; } = 0;
        public MethodDef Decryptor { get; set; }
        public List<byte> array = new List<byte>();
        public Dictionary<RVA, List<Tuple<int, int, int>>> Keys = new Dictionary<RVA, List<Tuple<int, int, int>>>();

        public void Execute(ModuleDefMD md)
        {
            FieldDef field = Runtime.GetStaticField("array");
            field.Name = Runtime.GetRandomName();
            field.DeclaringType = null;
            foreach (TypeDef type in md.Types)
                foreach (MethodDef method in type.Methods)
                    if (method.HasBody && method.Body.HasInstructions)
                        ExtractStrings(method);
            md.GlobalType.Fields.Add(field);
            MethodDef todef = Runtime.GetStaticMethod("Get");
            todef.DeclaringType = null;
            todef.Body.Instructions[8].Operand = field;
            todef.Name = Runtime.GetRandomName();
            md.GlobalType.Methods.Add(todef);
            MethodDef init = Runtime.GetStaticMethod("Initialize");
            MethodDef add = Runtime.GetStaticMethod("Set");
            init.DeclaringType = null;
            init.Body.Instructions[3].Operand = field;
            List<Instruction> insts = new List<Instruction>(add.Body.Instructions);
            insts[1].Operand = field;
            insts[insts.Count - 1].OpCode = OpCodes.Nop;
            insts.RemoveAt(0);
            insts[1].OpCode = OpCodes.Ldc_I4;
            insts[2].OpCode = OpCodes.Ldc_I4;

            var compressed = Compress(array.ToArray());


            for (int i = 0; i < compressed.Length; i++)
            {
                insts[1].Operand = i;
                insts[2].Operand = Convert.ToInt32(compressed[i]);
                for (int x = insts.Count - 1; x >= 0; x--)
                {
                    init.Body.Instructions.Insert(4, new Instruction(insts[x].OpCode, insts[x].Operand));
                }
            }
            init.Body.Instructions[init.Body.Instructions.Count - 1 - 1].Operand = field;
            init.Body.Instructions[init.Body.Instructions.Count - 1 - 99].Operand = field;
            init.Name = Runtime.GetRandomName();
            md.GlobalType.Methods.Add(init);
            Decryptor = todef;
            MethodDef cctor = md.GlobalType.FindOrCreateStaticConstructor();
            cctor.Body = new CilBody();
            cctor.Body.Instructions.Add(new Instruction(OpCodes.Ldc_I4, compressed.Length));
            cctor.Body.Instructions.Add(new Instruction(OpCodes.Call, init));
            cctor.Body.Instructions.Add(new Instruction(OpCodes.Ret));
            foreach (TypeDef type2 in md.Types)
                foreach (MethodDef method2 in type2.Methods)
                    if (method2.HasBody && method2.Body.HasInstructions)
                        ReferenceReplace(method2);

        }

        public void ReferenceReplace(MethodDef method)
        {
            if (Keys.ContainsKey(method.RVA))
            {
                List<Tuple<int, int, int>> keys = Keys[method.RVA];
                keys.Reverse();
                foreach (Tuple<int, int, int> v in keys)
                {
                    method.Body.Instructions[v.Item1].OpCode = OpCodes.Call;
                    method.Body.Instructions[v.Item1].Operand = this.Decryptor;

                    method.Body.Instructions.Insert(v.Item1, new Instruction(OpCodes.Ldc_I4, v.Item3));
                    method.Body.Instructions.Insert(v.Item1, new Instruction(OpCodes.Ldc_I4, v.Item2));
                    method.Body.Instructions.Insert(v.Item1, new Instruction(OpCodes.Ldstr, "AsStrongAsFuck - Obfuscator by Charter (vk.com/violent_0)"));
                }
            }
            method.Body.SimplifyBranches();
            method.Body.OptimizeBranches();
        }

        public void ExtractStrings(MethodDef method)
        {
            List<Tuple<int, int, int>> shit = new List<Tuple<int, int, int>>();
            foreach (Instruction instr in method.Body.Instructions)
            {
                bool flag = instr.OpCode == OpCodes.Ldstr;
                if (flag)
                {
                    string code = (string)instr.Operand;
                    byte[] bytes = Encoding.UTF8.GetBytes(code);
                    foreach (byte v in bytes)
                    {
                        array.Add(v);
                    }
                    shit.Add(new Tuple<int, int, int>(method.Body.Instructions.IndexOf(instr), CurrentIndex, bytes.Length));
                    CurrentIndex += bytes.Length;
                }
            }
            if (!Keys.ContainsKey(method.RVA))
                Keys.Add(method.RVA, shit);
        }


        public static byte[] Compress(byte[] data)
        {
            MemoryStream ms = new MemoryStream();
            DeflateStream ds = new DeflateStream(ms, CompressionMode.Compress);
            ds.Write(data, 0, data.Length);
            ds.Flush();
            ds.Close();
            return ms.ToArray();
        }
        public static byte[] Decompress(byte[] data)
        {
            const int BUFFER_SIZE = 256;
            byte[] tempArray = new byte[BUFFER_SIZE];
            List<byte[]> tempList = new List<byte[]>();
            int count = 0, length = 0;
            MemoryStream ms = new MemoryStream(data);
            DeflateStream ds = new DeflateStream(ms, CompressionMode.Decompress);
            while ((count = ds.Read(tempArray, 0, BUFFER_SIZE)) > 0)
            {
                if (count == BUFFER_SIZE)
                {
                    tempList.Add(tempArray);
                    tempArray = new byte[BUFFER_SIZE];
                }
                else
                {
                    byte[] temp = new byte[count];
                    Array.Copy(tempArray, 0, temp, 0, count);
                    tempList.Add(temp);
                }
                length += count;
            }
            byte[] retVal = new byte[length];
            count = 0;
            foreach (byte[] temp in tempList)
            {
                Array.Copy(temp, 0, retVal, count, temp.Length);
                count += temp.Length;
            }
            return retVal;
        }

    }
}


================================================
File: AsStrongAsFuck/ControlFlow.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;

namespace AsStrongAsFuck
{
    public class ControlFlow : IObfuscation
    {
        public void Execute(ModuleDefMD md)
        {
            throw new NotImplementedException();
        }
    }
}



================================================
File: AsStrongAsFuck/Extensions.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AsStrongAsFuck
{
    public static class Extensions
    {
        public static void AddListEntry<TKey, TValue>(this IDictionary<TKey, List<TValue>> self, TKey key, TValue value)
        {
            if (key == null)
                throw new ArgumentNullException("key");
            List<TValue> list;
            if (!self.TryGetValue(key, out list))
                list = self[key] = new List<TValue>();
            list.Add(value);
        }
    }
}



================================================
File: AsStrongAsFuck/IObfuscation.cs
================================================
ï»¿using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AsStrongAsFuck
{
    public interface IObfuscation
    {
        void Execute(ModuleDefMD md);
    }
}



================================================
File: AsStrongAsFuck/LocalsToFields.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace AsStrongAsFuck
{
    public class LocalsToFields : IObfuscation
    {
        public ModuleDef Module { get; set; }
        Dictionary<Local, FieldDef> convertedLocals = new Dictionary<Local, FieldDef>();
        public void Execute(ModuleDefMD md)
        {
            Module = md;

            foreach (var type in md.Types.Where(x => x != md.GlobalType))
            {
                foreach (var method in type.Methods.Where(x => x.HasBody && x.Body.HasInstructions && !x.IsConstructor))
                {
                    convertedLocals = new Dictionary<Local, FieldDef>();
                    ProcessMethod(method);
                }
            }
        }

        public void ProcessMethod(MethodDef method)
        {
            var instructions = method.Body.Instructions;
            for (int i = 0; i < instructions.Count; i++)
            {
                if (instructions[i].Operand is Local local)
                {
                    FieldDef def = null;
                    if (!convertedLocals.ContainsKey(local))
                    {
                        def = new FieldDefUser("卐AsStrongAsFuckᅠByᅠCharter卍" + Convert.ToBase64String(Encoding.Default.GetBytes(Runtime.GetRandomName() + method.Name)), new FieldSig(local.Type), FieldAttributes.Public | FieldAttributes.Static);
                        Module.GlobalType.Fields.Add(def);
                        convertedLocals.Add(local, def);
                    }
                    else
                        def = convertedLocals[local];


                    OpCode eq = null;
                    switch (instructions[i].OpCode.Code)
                    {
                        case Code.Ldloc:
                        case Code.Ldloc_S:
                        case Code.Ldloc_0:
                        case Code.Ldloc_1:
                        case Code.Ldloc_2:
                        case Code.Ldloc_3:
                            eq = OpCodes.Ldsfld;
                            break;
                        case Code.Ldloca:
                        case Code.Ldloca_S:
                            eq = OpCodes.Ldsflda;
                            break;
                        case Code.Stloc:
                        case Code.Stloc_0:
                        case Code.Stloc_1:
                        case Code.Stloc_2:
                        case Code.Stloc_3:
                        case Code.Stloc_S:
                            eq = OpCodes.Stsfld;
                            break;
                    }
                    if (eq == null)
                        Console.WriteLine(instructions[i].OpCode);
                    instructions[i].OpCode = eq;
                    instructions[i].Operand = def;

                }
            }
        }
    }
}



================================================
File: AsStrongAsFuck/Logger.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AsStrongAsFuck
{
    public class Logger
    {
        public static void LogMessage(string pre, string past, ConsoleColor PastColor)
        {
            Console.Write(pre);
            Console.ForegroundColor = PastColor;
            Console.WriteLine(past);
            Console.ForegroundColor = ConsoleColor.White;
        }
    }
}



================================================
File: AsStrongAsFuck/ModuleRenaming.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;

namespace AsStrongAsFuck
{
    public class ModuleRenaming : IObfuscation
    {
        public void Execute(ModuleDefMD md)
        {
            string shit = Runtime.GetRandomName();
            Logger.LogMessage("Renaming module to ", shit, ConsoleColor.Red);
            md.Name = shit;
        }
    }
}



================================================
File: AsStrongAsFuck/OwnRandom.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace AsStrongAsFuck
{
    public class OwnRandom : RandomNumberGenerator
    {
        private static RandomNumberGenerator r;

        public OwnRandom()
        {
            r = RandomNumberGenerator.Create();
        }

        public override void GetBytes(byte[] buffer)
        {
            r.GetBytes(buffer);
        }

        public double NextDouble()
        {
            byte[] b = new byte[4];
            r.GetBytes(b);
            return (double)BitConverter.ToUInt32(b, 0) / UInt32.MaxValue;
        }

        public int Next(int minValue, int maxValue)
        {
            return (int)Math.Floor(NextDouble() * (maxValue - minValue)) + minValue;
        }

        public int Next()
        {
            return Next(0, Int32.MaxValue);
        }

        public int Next(int maxValue)
        {
            return Next(0, maxValue);
        }

        public byte NextByte()
        {
            return (Byte)Next(Byte.MaxValue);
        }

        public uint NextUInt32()
        {
            return (uint)Next() * 2;
        }
    }
}



================================================
File: AsStrongAsFuck/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AsStrongAsFuck
{
    class Program
    {
        public static Worker Worker { get; set; }
        public static void Main(string[] args)
        {
            Console.WriteLine("AsStrongAsFuck by Charter.");
            Console.Write("Input an assembly: ");
            string path = Console.ReadLine();
            Worker = new Worker(path);
            Runtime.Random = new OwnRandom();
            Console.WriteLine("Choose options to obfuscate: ");

            for (int i = 0; i < Worker.Obfuscations.Count; i++)
            {
                Console.WriteLine(i + 1 + ") " + Worker.Obfuscations[i]);
            }
            string opts = Console.ReadLine();
            Worker.ExecuteObfuscations(opts);
            Worker.Save();
            Console.ReadLine();
        }
    }
}



================================================
File: AsStrongAsFuck/RandomNamespaces.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;

namespace AsStrongAsFuck
{
    public class RandomNamespaces : IObfuscation
    {
        public void Execute(ModuleDefMD md)
        {
            foreach (var type in md.Types)
            {
                var shit = Runtime.GetRandomName();
                Logger.LogMessage("Renaming " + type.Name + " namespace to ", shit, ConsoleColor.Red);
                type.Namespace = shit;
            }
        }
    }
}



================================================
File: AsStrongAsFuck/ReferenceProxy.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace AsStrongAsFuck
{
    public class ReferenceProxy : IObfuscation
    {
        Dictionary<Tuple<Code, TypeDef, IMethod>, MethodDef> proxies = new Dictionary<Tuple<Code, TypeDef, IMethod>, MethodDef>();

        public ModuleDef Module { get; set; }

        public void Execute(ModuleDefMD md)
        {
            Module = md;
            foreach (var type in md.Types)
            {
                proxies = new Dictionary<Tuple<Code, TypeDef, IMethod>, MethodDef>();
                
                for (int i = 0; i < type.Methods.Count; i++)
                {
                    var method = type.Methods[i];
                    if (method.HasBody && method.Body.HasInstructions && !proxies.ContainsValue(method) && !method.Name.Contains("ctor"))
                        ProcessMethod(method);
                }
                Logger.LogMessage("Added " + proxies.Count + " reference proxy to ", type.Name, ConsoleColor.Cyan);
            }
        }

        public void ProcessMethod(MethodDef method)
        {
            for (int i = 0; i < method.Body.Instructions.Count; i++)
            {
                var instr = method.Body.Instructions[i];
                if (instr.OpCode == OpCodes.Call)
                {
                    var target = (IMethod)instr.Operand;

                    // Value type proxy is not supported in mild mode.
                    if (target.DeclaringType.IsValueType)
                        return;
                    // Skipping visibility is not supported in mild mode.
                    if (!target.ResolveMethodDefThrow().IsPublic && !target.ResolveMethodDefThrow().IsAssembly)
                        return;

                    Tuple<Code, TypeDef, IMethod> key = Tuple.Create(instr.OpCode.Code, method.DeclaringType, target);
                    MethodDef proxy;
                    if (!proxies.TryGetValue(key, out proxy))
                    {
                        MethodSig sig = CreateProxySignature(target, instr.OpCode.Code == Code.Newobj);

                        proxy = new MethodDefUser(Runtime.GetRandomName(), sig);
                        proxy.Attributes = MethodAttributes.PrivateScope | MethodAttributes.Static;
                        proxy.ImplAttributes = MethodImplAttributes.Managed | MethodImplAttributes.IL;
                        method.DeclaringType.Methods.Add(proxy);

                        // Fix peverify --- Non-virtual call to virtual methods must be done on this pointer
                        if (instr.OpCode.Code == Code.Call && target.ResolveMethodDef().IsVirtual)
                        {
                            proxy.IsStatic = false;
                            sig.HasThis = true;
                            sig.Params.RemoveAt(0);
                        }
                        
                        proxy.Body = new CilBody();
                        for (int x = 0; x < proxy.Parameters.Count; x++)
                            proxy.Body.Instructions.Add(Instruction.Create(OpCodes.Ldarg, proxy.Parameters[x]));
                        proxy.Body.Instructions.Add(Instruction.Create(instr.OpCode, target));
                        proxy.Body.Instructions.Add(Instruction.Create(OpCodes.Ret));

                        proxies[key] = proxy;
                    }

                    instr.OpCode = OpCodes.Call;
                    instr.Operand = proxy;
                }
            }
        }

        public static void InsertListOfInstructions(List<Instruction> instrs, ref MethodDef def, int state)
        {
            instrs.Reverse();
            foreach (var instr in instrs)
                def.Body.Instructions.Insert(state, instr);
        }

        protected MethodSig CreateProxySignature(IMethod method, bool newObj)
        {
            ModuleDef module = Module;
            if (newObj)
            {
                TypeSig[] paramTypes = method.MethodSig.Params.Select(type => {
                    if (type.IsClassSig && method.MethodSig.HasThis)
                        return module.CorLibTypes.Object;
                    return type;
                }).ToArray();

                TypeSig retType;
                TypeDef declType = method.DeclaringType.ResolveTypeDefThrow();
                retType = Import(Module, declType).ToTypeSig();
                return MethodSig.CreateStatic(retType, paramTypes);
            }
            else
            {
                IEnumerable<TypeSig> paramTypes = method.MethodSig.Params.Select(type => {
                    if (type.IsClassSig && method.MethodSig.HasThis)
                        return module.CorLibTypes.Object;
                    return type;
                });
                if (method.MethodSig.HasThis && !method.MethodSig.ExplicitThis)
                {
                    TypeDef declType = method.DeclaringType.ResolveTypeDefThrow();
                    if (!declType.IsValueType)
                        paramTypes = new[] { module.CorLibTypes.Object }.Concat(paramTypes);
                    else
                        paramTypes = new[] { Import(Module, declType).ToTypeSig() }.Concat(paramTypes);
                }
                TypeSig retType = method.MethodSig.RetType;
                if (retType.IsClassSig)
                    retType = module.CorLibTypes.Object;
                return MethodSig.CreateStatic(retType, paramTypes.ToArray());
            }
        }

        static ITypeDefOrRef Import(ModuleDef module, TypeDef typeDef)
        {
            ITypeDefOrRef retTypeRef = new Importer(module, ImporterOptions.TryToUseTypeDefs).Import(typeDef);
            return retTypeRef;
        }
    }
}



================================================
File: AsStrongAsFuck/Runtime.cs
================================================
﻿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace AsStrongAsFuck
{
    public class Runtime
    {
        public static OwnRandom Random { get; set; }
        public static TypeDef Type => ModuleDefMD.Load(typeof(Runtime).Assembly.Modules.First()).Types.FirstOrDefault(x => x.Name.Contains("Runtime"));

        public static string GetRandomName()
        {
            return Names[Random.Next(Names.Length)];
        }

        public static string[] Names =
        {
            "HasPermission", "HasPermissions", "GetPermissions", "GetOpenWindows", "EnumWindows", "GetWindowText", "GetWindowTextLength", "IsWindowVisible", "GetShellWindow", "Awake", "FixedUpdate", "add_OnRockedInitialized", "remove_OnRockedInitialized", "Awake", "Initialize", "Translate", "Reload", "<Initialize>b__13_0", "Initialize", "FixedUpdate", "Start", "checkTimerRestart", "QueueOnMainThread", "QueueOnMainThread", "RunAsync", "RunAction", "Awake", "FixedUpdate", "IsUri", "GetTypes", "GetTypesFromParentClass", "GetTypesFromParentClass", "GetTypesFromInterface", "GetTypesFromInterface", "get_Timeout", "set_Timeout", "GetWebRequest", "get_SteamID64", "set_SteamID64", "get_SteamID", "set_SteamID", "get_OnlineState", "set_OnlineState", "get_StateMessage", "set_StateMessage", "get_PrivacyState", "set_PrivacyState", "get_VisibilityState", "set_VisibilityState", "get_AvatarIcon", "set_AvatarIcon", "get_AvatarMedium", "set_AvatarMedium", "get_AvatarFull", "set_AvatarFull", "get_IsVacBanned", "set_IsVacBanned", "get_TradeBanState", "set_TradeBanState", "get_IsLimitedAccount", "set_IsLimitedAccount", "get_CustomURL", "set_CustomURL", "get_MemberSince", "set_MemberSince", "get_HoursPlayedLastTwoWeeks", "set_HoursPlayedLastTwoWeeks", "get_Headline", "set_Headline", "get_Location", "set_Location", "get_RealName", "set_RealName", "get_Summary", "set_Summary", "get_MostPlayedGames", "set_MostPlayedGames", "get_Groups", "set_Groups", "Reload", "ParseString", "ParseDateTime", "ParseDouble", "ParseUInt16", "ParseUInt32", "ParseUInt64", "ParseBool", "ParseUri", "IsValidCSteamID", "LoadDefaults", "LoadDefaults", "get_Clients", "Awake", "handleConnection", "FixedUpdate", "Broadcast", "OnDestroy", "Read", "Send", "<Awake>b__8_0", "get_InstanceID", "set_InstanceID", "get_ConnectedTime", "set_ConnectedTime", "Send", "Read", "Close", "get_Address", "get_Instance", "set_Instance", "Save", "Load", "Unload", "Load", "Save", "Load", "get_Configuration", "LoadPlugin", "<.ctor>b__3_0", "<LoadPlugin>b__4_0", "add_OnPluginUnloading", "remove_OnPluginUnloading", "add_OnPluginLoading", "remove_OnPluginLoading", "get_Translations", "get_State", "get_Assembly", "set_Assembly", "get_Directory", "set_Directory", "get_Name", "set_Name", "get_DefaultTranslations", "IsDependencyLoaded", "ExecuteDependencyCode", "Translate", "ReloadPlugin", "LoadPlugin", "UnloadPlugin", "OnEnable", "OnDisable", "Load", "Unload", "TryAddComponent", "TryRemoveComponent", "add_OnPluginsLoaded", "remove_OnPluginsLoaded", "get_Plugins", "GetPlugins", "GetPlugin", "GetPlugin", "Awake", "Start", "GetMainTypeFromAssembly", "loadPlugins", "unloadPlugins", "Reload", "GetAssembliesFromDirectory", "LoadAssembliesFromDirectory", "<Awake>b__12_0", "GetGroupsByIds", "GetParentGroups", "HasPermission", "GetGroup", "RemovePlayerFromGroup", "AddPlayerToGroup", "DeleteGroup", "SaveGroup", "AddGroup", "GetGroups", "GetPermissions", "GetPermissions", "<GetGroups>b__11_3", "Start", "FixedUpdate", "Reload", "HasPermission", "GetGroups", "GetPermissions", "GetPermissions", "AddPlayerToGroup", "RemovePlayerFromGroup", "GetGroup", "SaveGroup", "AddGroup", "DeleteGroup", "DeleteGroup", "<FixedUpdate>b__4_0", "Enqueue", "_Logger_DoWork", "processLog", "Log", "Log", "var_dump", "LogWarning", "LogError", "LogError", "Log", "LogException", "ProcessInternalLog", "logRCON", "writeToConsole", "ProcessLog", "ExternalLog", "Invoke", "_invoke", "TryInvoke", "get_Aliases", "get_AllowedCaller", "get_Help", "get_Name", "get_Permissions", "get_Syntax", "Execute", "get_Aliases", "get_AllowedCaller", "get_Help", "get_Name", "get_Permissions", "get_Syntax", "Execute", "get_Aliases", "get_AllowedCaller", "get_Help", "get_Name", "get_Permissions", "get_Syntax", "Execute", "get_Name", "set_Name", "get_Name", "set_Name", "get_Name", "get_Help", "get_Syntax", "get_AllowedCaller", "get_Commands", "set_Commands", "add_OnExecuteCommand", "remove_OnExecuteCommand", "Reload", "Awake", "checkCommandMappings", "checkDuplicateCommandMappings", "Plugins_OnPluginsLoaded", "GetCommand", "GetCommand", "getCommandIdentity", "getCommandType", "Register", "Register", "Register", "DeregisterFromAssembly", "GetCooldown", "SetCooldown", "Execute", "RegisterFromAssembly"
        };

        public static MethodDef GetStaticMethod(string name)
        {
            return Type.FindMethod(name);
        }
        public static FieldDef GetStaticField(string name)
        {
            return Type.FindField(name);
        }

        public static string Get(string one, int key, int len)
        {
            List<byte> shit = new List<byte>();
            for (int i = 0; i < len; i++)
            {
                shit.Add(array[key + i]);
            }
            return Encoding.UTF8.GetString(shit.ToArray());
        }

        public static void Initialize(int len)
        {
            array = new byte[len];

            const int BUFFER_SIZE = 256;
            byte[] tempArray = new byte[BUFFER_SIZE];
            List<byte[]> tempList = new List<byte[]>();
            int count = 0, length = 0;
            MemoryStream ms = new MemoryStream(array);
            DeflateStream ds = new DeflateStream(ms, CompressionMode.Decompress);
            while ((count = ds.Read(tempArray, 0, BUFFER_SIZE)) > 0)
            {
                if (count == BUFFER_SIZE)
                {
                    tempList.Add(tempArray);
                    tempArray = new byte[BUFFER_SIZE];
                }
                else
                {
                    byte[] temp = new byte[count];
                    Array.Copy(tempArray, 0, temp, 0, count);
                    tempList.Add(temp);
                }
                length += count;
            }
            byte[] retVal = new byte[length];
            count = 0;
            foreach (byte[] temp in tempList)
            {
                Array.Copy(temp, 0, retVal, count, temp.Length);
                count += temp.Length;
            }
            array = retVal;
        }

        public static void Set()
        {
            array[0] = 0;
        }

        public static byte[] array = new byte[] { };
        public static int val;

        public static string GetChineseString(int len)
        {
            string shit = "";
            for (int i = 0; i < len; i++)
            {
                shit += ChineseCharacters[Random.Next(ChineseCharacters.Length)];
            }
            return shit;
        }

        public static char[] ChineseCharacters => new char[]
        {
            '㐀',
            '㐁',
            '㐂',
            '㐃',
            '㐄',
            '㐅',
            '㐆',
            '㐇',
            '㐈',
            '㐉',
            '㐊'
        };
    }
}



================================================
File: AsStrongAsFuck/Utils.cs
================================================
ï»¿using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static AsStrongAsFuck.Mutations.MutationObf;

namespace AsStrongAsFuck
{
    public class Utils
    {
        public static void Shuffle<T>(IList<T> list)
        {
            for (int i = list.Count - 1; i > 1; i--)
            {
                int k = Runtime.Random.Next(i + 1);
                T tmp = list[k];
                list[k] = list[i];
                list[i] = tmp;
            }
        }

        public static bool CheckArithmetic(Instruction instruction)
        {
            if (!instruction.IsLdcI4())
                return false;
            if (instruction.GetLdcI4Value() <= 1)
                return false;
            return true;
        }

        public static double GetY(double x) => (x / 2);
    }
}



================================================
File: AsStrongAsFuck/Worker.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace AsStrongAsFuck
{
    public class Worker
    {
        private Assembly OwnAssembly => this.GetType().Assembly;
        public Assembly Default_Assembly { get; set; }
        public ModuleDefMD Module { get; set; }
        public string Path { get; set; }

        public string Code { get; set; }
        public Worker(string path)
        {
            Path = path.Replace("\"", "");
            LoadAssembly();
            LoadModuleDefMD();
            LoadObfuscations();
            LoadDependencies();
        }

        public void Watermark()
        {
            Console.WriteLine("Watermarking...");
            TypeRef attrRef = Module.CorLibTypes.GetTypeRef("System", "Attribute");
            var attrType = new TypeDefUser("", "AsStrongAsFuckAttribute", attrRef);
            Module.Types.Add(attrType);
            var ctor = new MethodDefUser(
                ".ctor",
                MethodSig.CreateInstance(Module.CorLibTypes.Void, Module.CorLibTypes.String),
                dnlib.DotNet.MethodImplAttributes.Managed,
                dnlib.DotNet.MethodAttributes.HideBySig | dnlib.DotNet.MethodAttributes.Public | dnlib.DotNet.MethodAttributes.SpecialName | dnlib.DotNet.MethodAttributes.RTSpecialName);
            ctor.Body = new CilBody();
            ctor.Body.MaxStack = 1;
            ctor.Body.Instructions.Add(OpCodes.Ldarg_0.ToInstruction());
            ctor.Body.Instructions.Add(OpCodes.Call.ToInstruction(new MemberRefUser(Module, ".ctor", MethodSig.CreateInstance(Module.CorLibTypes.Void), attrRef)));
            ctor.Body.Instructions.Add(OpCodes.Ret.ToInstruction());
            attrType.Methods.Add(ctor);
            var attr = new CustomAttribute(ctor);
            attr.ConstructorArguments.Add(new CAArgument(Module.CorLibTypes.String, "AsStrongAsFuck obfuscator by Charter(vk.com/violent_0). " + Code));
            Module.CustomAttributes.Add(attr);
        }

        public void ExecuteObfuscations(string param)
        {
            Code = param;
            var shit = param.ToCharArray().ToList();
            foreach (var v in shit)
            {
                int i = int.Parse(v.ToString()) - 1;
                Logger.LogMessage("Executing ", Obfuscations[i], ConsoleColor.Magenta);
                Type type = OwnAssembly.GetTypes().First(x => x.Name == Obfuscations[i]);
                var instance = Activator.CreateInstance(type);
                MethodInfo info = type.GetMethod("Execute");
                try
                {
                    info.Invoke(instance, new object[] { Module });
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex);
                }
            }
        }

        public void LoadAssembly()
        {
            Console.Write("Loading assembly...");
            Default_Assembly = Assembly.LoadFile(Path);
            Console.ForegroundColor = ConsoleColor.Green;
            Console.Write(" Loaded: ");
            Console.WriteLine(Default_Assembly.FullName);
            Console.ForegroundColor = ConsoleColor.White;
        }

        public void LoadModuleDefMD()
        {
            Console.Write("Loading ModuleDefMD...");
            Module = ModuleDefMD.Load(Path);
            Console.ForegroundColor = ConsoleColor.Green;
            Console.Write(" Loaded: ");
            Console.WriteLine(Module.FullName);
            Console.ForegroundColor = ConsoleColor.White;
        }

        public void LoadDependencies()
        {
            Console.WriteLine("Resolving dependencies...");
            var asmResolver = new AssemblyResolver();
            ModuleContext modCtx = new ModuleContext(asmResolver);
            
            asmResolver.DefaultModuleContext = modCtx;

            asmResolver.EnableTypeDefCache = true;

            asmResolver.DefaultModuleContext = new ModuleContext(asmResolver);
            asmResolver.PostSearchPaths.Insert(0, Path);
            foreach (var dependency in Module.GetAssemblyRefs())
            {
                AssemblyDef assembly = asmResolver.ResolveThrow(dependency, Module);
                Console.WriteLine("Resolved " + dependency.Name);
            }
            Module.Context = modCtx;
        }

        public void Save()
        {
            Watermark();
            Logger.LogMessage("Saving as ", Path + ".obfuscated", ConsoleColor.Yellow);
            ModuleWriterOptions opts = new ModuleWriterOptions(Module);
            opts.Logger = DummyLogger.NoThrowInstance;
            Module.Write(Path + ".obfuscated", opts);
            Console.WriteLine("Saved.");
        }

        public void LoadObfuscations()
        {
            Obfuscations = new List<string>();
            var ass = this.GetType().Assembly;
            var types = ass.GetTypes();
            foreach (Type type in Enumerable.Where<Type>(types, (Type t) => t != null))
            {
                if (type.GetInterface("IObfuscation") != null)
                {
                    Obfuscations.Add(type.Name);
                }
            }
        }

        public List<string> Obfuscations { get; set; }
    }
}



================================================
File: AsStrongAsFuck/Mutations/Funcs.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace AsStrongAsFuck.Mutations
{
    public class Add : iMutation
    {
        public void Process(MethodDef method, ref int index)
        {
            var defvalue = method.Body.Instructions[index].GetLdcI4Value();
            var inda = Runtime.Random.Next((int)((double)defvalue / 1.5));
            method.Body.Instructions[index].OpCode = OpCodes.Ldc_I4;
            method.Body.Instructions[index].Operand = defvalue - inda;
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Ldc_I4, inda));
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Add));
        }
    }

    public class Sub : iMutation
    {
        public void Process(MethodDef method, ref int index)
        {
            var defvalue = method.Body.Instructions[index].GetLdcI4Value();
            var two = Runtime.Random.Next((int)((double)defvalue / 1.5));
            method.Body.Instructions[index].OpCode = OpCodes.Ldc_I4;
            method.Body.Instructions[index].Operand = defvalue + two;
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Ldc_I4, two));
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Sub));
        }
    }

    public class Mul : iMutation
    {
        public void Process(MethodDef method, ref int index)
        {
            var defvalue = method.Body.Instructions[index].GetLdcI4Value();
            var two = Runtime.Random.Next(1, (int)((double)defvalue / 1.5));
            var one = defvalue / two;
            while (two * one != defvalue)
            {
                two = Runtime.Random.Next(1, (int)((double)defvalue / 1.5));
                one = defvalue / two;
            }
            method.Body.Instructions[index].OpCode = OpCodes.Ldc_I4;
            method.Body.Instructions[index].Operand = one;
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Ldc_I4, two));
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Mul));
        }
    }

    public class Div : iMutation
    {
        public void Process(MethodDef method, ref int index)
        {
            var defvalue = method.Body.Instructions[index].GetLdcI4Value();
            var two = Runtime.Random.Next(1, 10);
            method.Body.Instructions[index].OpCode = OpCodes.Ldc_I4;
            method.Body.Instructions[index].Operand = defvalue * two;
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Ldc_I4, two));
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Div));
        }
    }

    public class Abs : iMutation
    {
        public void Process(MethodDef method, ref int index)
        {
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Call, method.Module.Import(typeof(Math).GetMethod("Abs", new Type[] { typeof(int) }))));
        }
    }

    public class StringLen : iMutation
    {
        public void Process(MethodDef method, ref int index)
        {
            if (method.DeclaringType == method.Module.GlobalType)
            {
                index--;
                return;
            }
            int defval = method.Body.Instructions[index].GetLdcI4Value();
            int needed = Runtime.Random.Next(4, 15);
            string ch = Runtime.GetChineseString(needed);
            method.Body.Instructions[index].OpCode = OpCodes.Ldc_I4;
            method.Body.Instructions[index].Operand = defval - needed;
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Ldstr, ch));
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Call, method.Module.Import(typeof(string).GetMethod("get_Length"))));
            method.Body.Instructions.Insert(++index, new Instruction(OpCodes.Add));
        }
    }
}



================================================
File: AsStrongAsFuck/Mutations/MutationObf.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace AsStrongAsFuck.Mutations
{
    public class MutationObf : IObfuscation
    {
        public ModuleDef Module { get; set; }
        List<iMutation> Tasks = new List<iMutation>()
        {
            new Add(),
            new Sub(),
            new Div(),
            new Mul(),
            new Abs(),
            new StringLen()
        };



        public void Execute(ModuleDefMD md)
        {
            Module = md;
            foreach (TypeDef tDef in md.Types)
            {
                foreach (MethodDef mDef in tDef.Methods.Where(x => !x.IsConstructor))
                {
                    if (!mDef.HasBody) continue;
                    for (int i = 0; i < mDef.Body.Instructions.Count; i++)
                    {
                        if (Utils.CheckArithmetic(mDef.Body.Instructions[i]))
                        {
                            var rndshit = Tasks[Runtime.Random.Next(Tasks.Count)];
                            rndshit.Process(mDef, ref i);
                        }
                    }
                }
            }
        }
        
    }
}



================================================
File: AsStrongAsFuck/Mutations/NumbersToModuleReference.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.PE;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AsStrongAsFuck.Mutations
{
    public class NumbersToModuleReference : IObfuscation
    {
        public ModuleDef Module { get; set; }

        public Dictionary<int, FieldDef> Numbers { get; set; }

        public void Execute(ModuleDefMD md)
        {
            Numbers = new Dictionary<int, FieldDef>();
            Module = md;
            foreach (var type in md.Types.Where(x => x != md.GlobalType))
                foreach (var method in type.Methods.Where(x => !x.IsConstructor && x.HasBody && x.Body.HasInstructions))
                    ExtractNumbers(method);
            foreach (var type in md.Types.Where(x => x != md.GlobalType))
                foreach (var method in type.Methods.Where(x => !x.IsConstructor && x.HasBody && x.Body.HasInstructions))
                    ReplaceReferences(method);
        }

        public FieldDef AddNumberField(int num)
        {
            FieldDef field = Runtime.GetStaticField("val");
            field.Name = "AsStrongAsFuck" + Runtime.GetRandomName();
            field.DeclaringType = null;
            Module.GlobalType.Fields.Add(field);

            var method = Module.GlobalType.FindOrCreateStaticConstructor();
            method.Body.Instructions.Insert(0, new Instruction(OpCodes.Ldc_I4, num));
            method.Body.Instructions.Insert(1, new Instruction(OpCodes.Stsfld, field));
            return field;
        }

        public void ExtractNumbers(MethodDef method)
        {
            for (int i = 0; i < method.Body.Instructions.Count; i++)
            {
                var instr = method.Body.Instructions[i];
                if (instr.IsLdcI4())
                {
                    var val = instr.GetLdcI4Value();
                    if (!Numbers.ContainsKey(val))
                    {
                        Numbers.Add(val, AddNumberField(val));
                    }
                }
            }
        }

        public void ReplaceReferences(MethodDef method)
        {
            for (int i = 0; i < method.Body.Instructions.Count; i++)
            {
                var instr = method.Body.Instructions[i];
                if (instr.IsLdcI4())
                {
                    var val = instr.GetLdcI4Value();
                    var fld = Numbers[val];
                    instr.OpCode = OpCodes.Ldsfld;
                    instr.Operand = fld;
                }
            }
        }
    }
}



================================================
File: AsStrongAsFuck/Mutations/iMutation.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace AsStrongAsFuck.Mutations
{
    public interface iMutation
    {
        void Process(MethodDef method, ref int index);
    }
}



================================================
File: AsStrongAsFuck/Properties/AssemblyInfo.cs
================================================




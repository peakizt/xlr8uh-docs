Directory structure:
└── wwh1004-assemblyrebuilderold/
    ├── AssemblyRebuilder.sln
    ├── .editorconfig
    ├── AssemblyRebuilder/
    │   ├── AssemblyRebuilder.csproj
    │   ├── IManagedEntryPointWrapper.cs
    │   ├── MainForm.Designer.cs
    │   ├── MainForm.cs
    │   ├── MainForm.resx
    │   ├── Program.cs
    │   └── Properties/
    │       └── AssemblyInfo.cs
    └── Libraries/
        └── dnlib/
            ├── LICENSE.txt
            └── dnlib.Shared/
                ├── Settings.cs
                ├── dnlib.Shared.projitems
                ├── dnlib.Shared.shproj
                ├── DotNet/
                │   ├── AllTypesHelper.cs
                │   ├── AssemblyAttributes.cs
                │   ├── AssemblyDef.cs
                │   ├── AssemblyHash.cs
                │   ├── AssemblyHashAlgorithm.cs
                │   ├── AssemblyNameComparer.cs
                │   ├── AssemblyNameInfo.cs
                │   ├── AssemblyRef.cs
                │   ├── AssemblyResolver.cs
                │   ├── CallingConvention.cs
                │   ├── CallingConventionSig.cs
                │   ├── ClassLayout.cs
                │   ├── Constant.cs
                │   ├── CorLibTypes.cs
                │   ├── CpuArch.cs
                │   ├── CustomAttribute.cs
                │   ├── CustomAttributeCollection.cs
                │   ├── CustomAttributeReader.cs
                │   ├── DeclSecurity.cs
                │   ├── DeclSecurityReader.cs
                │   ├── ElementType.cs
                │   ├── EventAttributes.cs
                │   ├── EventDef.cs
                │   ├── ExportedType.cs
                │   ├── Extensions.cs
                │   ├── FieldAttributes.cs
                │   ├── FieldDef.cs
                │   ├── FileAttributes.cs
                │   ├── FileDef.cs
                │   ├── FrameworkRedirect.cs
                │   ├── FullNameCreator.cs
                │   ├── GenericArguments.cs
                │   ├── GenericParam.cs
                │   ├── GenericParamAttributes.cs
                │   ├── GenericParamConstraint.cs
                │   ├── GenericParamContext.cs
                │   ├── IAssemblyResolver.cs
                │   ├── ICodedToken.cs
                │   ├── ICorLibTypes.cs
                │   ├── ICustomAttribute.cs
                │   ├── IDecrypters.cs
                │   ├── ILogger.cs
                │   ├── IResolver.cs
                │   ├── ITokenResolver.cs
                │   ├── IType.cs
                │   ├── ITypeDefFinder.cs
                │   ├── IVariable.cs
                │   ├── ImplMap.cs
                │   ├── Importer.cs
                │   ├── InterfaceImpl.cs
                │   ├── MDToken.cs
                │   ├── ManifestResource.cs
                │   ├── ManifestResourceAttributes.cs
                │   ├── MarshalBlobReader.cs
                │   ├── MarshalType.cs
                │   ├── MemberFinder.cs
                │   ├── MemberMDInitializer.cs
                │   ├── MemberRef.cs
                │   ├── MethodAttributes.cs
                │   ├── MethodDef.cs
                │   ├── MethodExportInfo.cs
                │   ├── MethodExportInfoProvider.cs
                │   ├── MethodImplAttributes.cs
                │   ├── MethodOverride.cs
                │   ├── MethodSemanticsAttributes.cs
                │   ├── MethodSpec.cs
                │   ├── ModuleContext.cs
                │   ├── ModuleCreationOptions.cs
                │   ├── ModuleDef.cs
                │   ├── ModuleDefMD.cs
                │   ├── ModuleKind.cs
                │   ├── ModuleLoader.cs
                │   ├── ModuleRef.cs
                │   ├── NativeType.cs
                │   ├── NullResolver.cs
                │   ├── PInvokeAttributes.cs
                │   ├── ParamAttributes.cs
                │   ├── ParamDef.cs
                │   ├── ParameterList.cs
                │   ├── PropertyAttributes.cs
                │   ├── PropertyDef.cs
                │   ├── PublicKey.cs
                │   ├── PublicKeyBase.cs
                │   ├── PublicKeyToken.cs
                │   ├── RecursionCounter.cs
                │   ├── ReflectionExtensions.cs
                │   ├── ResolveException.cs
                │   ├── Resolver.cs
                │   ├── Resource.cs
                │   ├── ResourceCollection.cs
                │   ├── SecurityAction.cs
                │   ├── SecurityAttribute.cs
                │   ├── SerializationType.cs
                │   ├── SigComparer.cs
                │   ├── SignatureReader.cs
                │   ├── StandAloneSig.cs
                │   ├── StrongNameKey.cs
                │   ├── StrongNameSigner.cs
                │   ├── TIAHelper.cs
                │   ├── TypeAttributes.cs
                │   ├── TypeDef.cs
                │   ├── TypeDefFinder.cs
                │   ├── TypeHelper.cs
                │   ├── TypeNameParser.cs
                │   ├── TypeRef.cs
                │   ├── TypeSig.cs
                │   ├── TypeSpec.cs
                │   ├── UTF8String.cs
                │   ├── Utils.cs
                │   ├── VTableFixups.cs
                │   ├── VariantType.cs
                │   ├── WinMDHelpers.cs
                │   ├── WinMDStatus.cs
                │   ├── Emit/
                │   │   ├── Code.cs
                │   │   ├── DynamicMethodBodyReader.cs
                │   │   ├── ExceptionHandler.cs
                │   │   ├── ExceptionHandlerType.cs
                │   │   ├── Extensions.cs
                │   │   ├── FlowControl.cs
                │   │   ├── Instruction.cs
                │   │   ├── InstructionPrinter.cs
                │   │   ├── InvalidMethodException.cs
                │   │   ├── LocalList.cs
                │   │   ├── MethodBody.cs
                │   │   ├── MethodBodyReader.cs
                │   │   ├── MethodBodyReaderBase.cs
                │   │   ├── MethodTableToTypeConverter.cs
                │   │   ├── MethodUtils.cs
                │   │   ├── OpCode.cs
                │   │   ├── OpCodeType.cs
                │   │   ├── OpCodes.cs
                │   │   ├── OperandType.cs
                │   │   └── StackBehaviour.cs
                │   ├── MD/
                │   │   ├── BlobStream.cs
                │   │   ├── CodedToken.cs
                │   │   ├── ColumnInfo.cs
                │   │   ├── ColumnSize.cs
                │   │   ├── ComImageFlags.cs
                │   │   ├── CompressedMetaData.cs
                │   │   ├── DotNetStream.cs
                │   │   ├── DotNetTableSizes.cs
                │   │   ├── ENCMetaData.cs
                │   │   ├── GuidStream.cs
                │   │   ├── HeapType.cs
                │   │   ├── HotHeapStream.cs
                │   │   ├── HotHeapVersion.cs
                │   │   ├── HotStream.cs
                │   │   ├── HotTableStream.cs
                │   │   ├── IMetaData.cs
                │   │   ├── IRowReaders.cs
                │   │   ├── ImageCor20Header.cs
                │   │   ├── MDHeaderRuntimeVersion.cs
                │   │   ├── MDStreamFlags.cs
                │   │   ├── MDTable.cs
                │   │   ├── MetaData.cs
                │   │   ├── MetaDataCreator.cs
                │   │   ├── MetaDataHeader.cs
                │   │   ├── PdbStream.cs
                │   │   ├── RawRowEqualityComparer.cs
                │   │   ├── RawTableRows.cs
                │   │   ├── RidList.cs
                │   │   ├── StorageFlags.cs
                │   │   ├── StreamHeader.cs
                │   │   ├── StringsStream.cs
                │   │   ├── Table.cs
                │   │   ├── TableInfo.cs
                │   │   ├── TablesStream.cs
                │   │   ├── TablesStream_Read.cs
                │   │   └── USStream.cs
                │   ├── Pdb/
                │   │   ├── CustomDebugInfoGuids.cs
                │   │   ├── IMAGE_DEBUG_DIRECTORY.cs
                │   │   ├── ImageStreamUtils.cs
                │   │   ├── ManagedSymbolReaderCreator.cs
                │   │   ├── PdbConstant.cs
                │   │   ├── PdbCustomDebugInfo.cs
                │   │   ├── PdbDocument.cs
                │   │   ├── PdbDocumentConstants.cs
                │   │   ├── PdbFileKind.cs
                │   │   ├── PdbImplType.cs
                │   │   ├── PdbImport.cs
                │   │   ├── PdbLocal.cs
                │   │   ├── PdbLocalAttributes.cs
                │   │   ├── PdbMethod.cs
                │   │   ├── PdbScope.cs
                │   │   ├── PdbState.cs
                │   │   ├── SequencePoint.cs
                │   │   ├── SymbolReaderCreator.cs
                │   │   ├── Dss/
                │   │   │   ├── ComInterfaces.cs
                │   │   │   ├── ImageStreamIStream.cs
                │   │   │   ├── MDEmitter.cs
                │   │   │   ├── PinnedMetaData.cs
                │   │   │   ├── StreamIStream.cs
                │   │   │   ├── SymbolDocumentImpl.cs
                │   │   │   ├── SymbolDocumentWriter.cs
                │   │   │   ├── SymbolMethodImpl.cs
                │   │   │   ├── SymbolNamespaceImpl.cs
                │   │   │   ├── SymbolReaderCreator.cs
                │   │   │   ├── SymbolReaderImpl.cs
                │   │   │   ├── SymbolScopeImpl.cs
                │   │   │   ├── SymbolVariableImpl.cs
                │   │   │   ├── SymbolWriter.cs
                │   │   │   └── SymbolWriterCreator.cs
                │   │   ├── Managed/
                │   │   │   ├── DbiDocument.cs
                │   │   │   ├── DbiFunction.cs
                │   │   │   ├── DbiModule.cs
                │   │   │   ├── DbiNamespace.cs
                │   │   │   ├── DbiScope.cs
                │   │   │   ├── DbiVariable.cs
                │   │   │   ├── ModuleStreamType.cs
                │   │   │   ├── MsfStream.cs
                │   │   │   ├── NumericLeaf.cs
                │   │   │   ├── NumericReader.cs
                │   │   │   ├── PdbAddress.cs
                │   │   │   ├── PdbException.cs
                │   │   │   ├── PdbReader.cs
                │   │   │   ├── SymbolReaderCreator.cs
                │   │   │   └── SymbolType.cs
                │   │   ├── Portable/
                │   │   │   ├── DocumentNameReader.cs
                │   │   │   ├── ImportDefinitionKindUtils.cs
                │   │   │   ├── ImportScopeBlobReader.cs
                │   │   │   ├── ImportScopeBlobWriter.cs
                │   │   │   ├── ListCache.cs
                │   │   │   ├── LocalConstantSigBlobReader.cs
                │   │   │   ├── LocalConstantSigBlobWriter.cs
                │   │   │   ├── PortablePdbCustomDebugInfoReader.cs
                │   │   │   ├── PortablePdbCustomDebugInfoWriter.cs
                │   │   │   ├── PortablePdbReader.cs
                │   │   │   ├── SequencePointConstants.cs
                │   │   │   ├── SymbolDocumentImpl.cs
                │   │   │   ├── SymbolMethodImpl.cs
                │   │   │   ├── SymbolReaderCreator.cs
                │   │   │   ├── SymbolScopeImpl.cs
                │   │   │   └── SymbolVariableImpl.cs
                │   │   ├── Symbols/
                │   │   │   ├── SymbolAsyncStepInfo.cs
                │   │   │   ├── SymbolDocument.cs
                │   │   │   ├── SymbolMethod.cs
                │   │   │   ├── SymbolNamespace.cs
                │   │   │   ├── SymbolReader.cs
                │   │   │   ├── SymbolScope.cs
                │   │   │   ├── SymbolSequencePoint.cs
                │   │   │   └── SymbolVariable.cs
                │   │   └── WindowsPdb/
                │   │       ├── CorSymVarFlag.cs
                │   │       ├── CustomDebugInfoConstants.cs
                │   │       ├── ISymbolWriter2.cs
                │   │       ├── PdbCustomDebugInfoReader.cs
                │   │       ├── PdbCustomDebugInfoWriter.cs
                │   │       ├── PseudoCustomDebugInfoFactory.cs
                │   │       ├── SymbolWriterCreator.cs
                │   │       └── WindowsPdbWriter.cs
                │   ├── Resources/
                │   │   ├── BuiltInResourceData.cs
                │   │   ├── IResourceData.cs
                │   │   ├── ResourceDataCreator.cs
                │   │   ├── ResourceElement.cs
                │   │   ├── ResourceElementSet.cs
                │   │   ├── ResourceReader.cs
                │   │   ├── ResourceTypeCode.cs
                │   │   ├── ResourceWriter.cs
                │   │   ├── UserResourceData.cs
                │   │   └── UserResourceType.cs
                │   └── Writer/
                │       ├── BinaryReaderChunk.cs
                │       ├── BlobHeap.cs
                │       ├── ByteArrayChunk.cs
                │       ├── ChunkList.cs
                │       ├── ChunkListBase.cs
                │       ├── CustomAttributeWriter.cs
                │       ├── DebugDirectory.cs
                │       ├── DeclSecurityWriter.cs
                │       ├── Extensions.cs
                │       ├── GuidHeap.cs
                │       ├── HeapBase.cs
                │       ├── HotHeap.cs
                │       ├── HotPool.cs
                │       ├── HotTable.cs
                │       ├── IChunk.cs
                │       ├── IHeap.cs
                │       ├── IMetaDataListener.cs
                │       ├── IModuleWriterListener.cs
                │       ├── IOffsetHeap.cs
                │       ├── IWriterError.cs
                │       ├── ImageCor20Header.cs
                │       ├── ImportAddressTable.cs
                │       ├── ImportDirectory.cs
                │       ├── MDTable.cs
                │       ├── MDTableWriter.cs
                │       ├── ManagedExportsWriter.cs
                │       ├── MarshalBlobWriter.cs
                │       ├── MaxStackCalculator.cs
                │       ├── MetaData.cs
                │       ├── MetaDataHeader.cs
                │       ├── MethodBody.cs
                │       ├── MethodBodyChunks.cs
                │       ├── MethodBodyWriter.cs
                │       ├── MethodBodyWriterBase.cs
                │       ├── ModuleWriter.cs
                │       ├── ModuleWriterBase.cs
                │       ├── ModuleWriterException.cs
                │       ├── NativeModuleWriter.cs
                │       ├── NetResources.cs
                │       ├── NormalMetaData.cs
                │       ├── PEHeaders.cs
                │       ├── PESection.cs
                │       ├── PdbHeap.cs
                │       ├── PortablePdbConstants.cs
                │       ├── PreserveTokensMetaData.cs
                │       ├── RelocDirectory.cs
                │       ├── SectionSizes.cs
                │       ├── SerializerMethodContext.cs
                │       ├── SignatureWriter.cs
                │       ├── StartupStub.cs
                │       ├── StringsHeap.cs
                │       ├── StrongNameSignature.cs
                │       ├── TablesHeap.cs
                │       ├── USHeap.cs
                │       ├── UniqueChunkList.cs
                │       ├── Win32ResourcesChunk.cs
                │       └── WriterUtils.cs
                ├── IO/
                │   ├── BinaryReaderStream.cs
                │   ├── FileOffset.cs
                │   ├── FileSection.cs
                │   ├── IBinaryReader.cs
                │   ├── IFileSection.cs
                │   ├── IImageStream.cs
                │   ├── IImageStreamCreator.cs
                │   ├── IOExtensions.cs
                │   ├── ImageStreamCreator.cs
                │   ├── MemoryImageStream.cs
                │   ├── MemoryMappedFileStreamCreator.cs
                │   ├── MemoryStreamCreator.cs
                │   ├── UnmanagedMemoryImageStream.cs
                │   └── UnmanagedMemoryStreamCreator.cs
                ├── PE/
                │   ├── Characteristics.cs
                │   ├── DllCharacteristics.cs
                │   ├── IImageOptionalHeader.cs
                │   ├── IPEImage.cs
                │   ├── IPEType.cs
                │   ├── ImageDataDirectory.cs
                │   ├── ImageDebugDirectory.cs
                │   ├── ImageDebugType.cs
                │   ├── ImageDosHeader.cs
                │   ├── ImageFileHeader.cs
                │   ├── ImageNTHeaders.cs
                │   ├── ImageOptionalHeader32.cs
                │   ├── ImageOptionalHeader64.cs
                │   ├── ImageSectionHeader.cs
                │   ├── Machine.cs
                │   ├── PEExtensions.cs
                │   ├── PEImage.cs
                │   ├── PEInfo.cs
                │   ├── RVA.cs
                │   └── Subsystem.cs
                ├── Threading/
                │   ├── Extensions.cs
                │   ├── ICancellationToken.cs
                │   ├── IThreadSafeList.cs
                │   ├── Lock.cs
                │   ├── ThreadSafeListCreator.cs
                │   └── ThreadSafeListWrapper.cs
                ├── Utils/
                │   ├── Extensions.cs
                │   ├── ILazyList.cs
                │   ├── LazyList.cs
                │   ├── MFunc.cs
                │   ├── SimpleLazyList.cs
                │   └── UserValue.cs
                └── W32Resources/
                    ├── ResourceData.cs
                    ├── ResourceDirectory.cs
                    ├── ResourceDirectoryEntry.cs
                    ├── ResourceName.cs
                    └── Win32Resources.cs

================================================
File: AssemblyRebuilder.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27406.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AssemblyRebuilder", "AssemblyRebuilder\AssemblyRebuilder.csproj", "{00B85EF8-FB7A-4546-828E-08B093DBDDE8}"
EndProject
Project("{D954291E-2A0B-460D-934E-DC6B0785DB48}") = "dnlib.Shared", "Libraries\dnlib\dnlib.Shared\dnlib.Shared.shproj", "{9E1FEE5B-49A3-4C7F-B3C2-389E40108BF2}"
EndProject
Global
	GlobalSection(SharedMSBuildProjectFiles) = preSolution
		Libraries\dnlib\dnlib.Shared\dnlib.Shared.projitems*{00b85ef8-fb7a-4546-828e-08b093dbdde8}*SharedItemsImports = 4
		Libraries\dnlib\dnlib.Shared\dnlib.Shared.projitems*{9e1fee5b-49a3-4c7f-b3c2-389e40108bf2}*SharedItemsImports = 13
	EndGlobalSection
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{00B85EF8-FB7A-4546-828E-08B093DBDDE8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{00B85EF8-FB7A-4546-828E-08B093DBDDE8}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{00B85EF8-FB7A-4546-828E-08B093DBDDE8}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{00B85EF8-FB7A-4546-828E-08B093DBDDE8}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FA10773E-E2D4-481D-9F8C-7987DDF32546}
	EndGlobalSection
EndGlobal



================================================
File: .editorconfig
================================================
root = true

[*]
charset = utf-8
end_of_line = crlf  
indent_style = tab
trim_trailing_whitespace = true
insert_final_newline = true

[*.xaml]
indent_style = space

[*.cs]
csharp_indent_block_contents = true
csharp_indent_braces = false
csharp_indent_case_contents = true
csharp_indent_labels = one_less_than_current
csharp_indent_switch_labels = false
csharp_new_line_before_catch = true
csharp_new_line_before_else = true
csharp_new_line_before_finally = true
csharp_new_line_before_members_in_anonymous_types = false
csharp_new_line_before_members_in_object_initializers = false
csharp_new_line_before_open_brace = none
csharp_new_line_between_query_expression_clauses = false
csharp_prefer_braces = false
csharp_preserve_single_line_blocks = true
csharp_preserve_single_line_statements = true
csharp_style_conditional_delegate_call = true:suggestion
csharp_style_expression_bodied_accessors = true:suggestion
csharp_style_expression_bodied_constructors = true:suggestion
csharp_style_expression_bodied_indexers = true:suggestion
csharp_style_expression_bodied_methods = true:suggestion
csharp_style_expression_bodied_operators = true:suggestion
csharp_style_expression_bodied_properties = true:suggestion
csharp_style_throw_expression = false:suggestion
csharp_style_var_elsewhere = false:suggestion
csharp_style_var_for_built_in_types = false:suggestion
csharp_style_var_when_type_is_apparent = false:suggestion



================================================
File: AssemblyRebuilder/AssemblyRebuilder.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{00B85EF8-FB7A-4546-828E-08B093DBDDE8}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>AssemblyRebuilder</RootNamespace>
    <AssemblyName>AssemblyRebuilder</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>Icon.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="MainForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <Compile Include="IManagedEntryPointWrapper.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.XML" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="MainForm.resx">
      <DependentUpon>MainForm.cs</DependentUpon>
    </EmbeddedResource>
  </ItemGroup>
  <Import Project="..\Libraries\dnlib\dnlib.Shared\dnlib.Shared.projitems" Label="Shared" />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================
File: AssemblyRebuilder/IManagedEntryPointWrapper.cs
================================================
using dnlib.DotNet;

namespace AssemblyRebuilder {
	internal class IManagedEntryPointWrapper {
		public IManagedEntryPoint ManagedEntryPoint { get; set; }

		public IManagedEntryPointWrapper(IManagedEntryPoint managedEntryPoint) => ManagedEntryPoint = managedEntryPoint;

		public override string ToString() {
			string str;

			str = ManagedEntryPoint.ToString();
			str = str.Replace("System.Void", "void").Replace("System.Integer", "int");
			return ManagedEntryPoint.MDToken.ToString() + " " + str;
		}
	}
}



================================================
File: AssemblyRebuilder/MainForm.Designer.cs
================================================
namespace AssemblyRebuilder {
	partial class MainForm {
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing) {
			if (disposing && (components != null)) {
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent() {
			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
			this.tbAssemblyPath = new System.Windows.Forms.TextBox();
			this.btSelectAssembly = new System.Windows.Forms.Button();
			this.odlgSelectAssembly = new System.Windows.Forms.OpenFileDialog();
			this.cmbEntryPoint = new System.Windows.Forms.ComboBox();
			this.btRebuild = new System.Windows.Forms.Button();
			this.cmbManifestModuleKind = new System.Windows.Forms.ComboBox();
			this.chkNoStaticConstructor = new System.Windows.Forms.CheckBox();
			this.SuspendLayout();
			// 
			// tbAssemblyPath
			// 
			this.tbAssemblyPath.Location = new System.Drawing.Point(12, 13);
			this.tbAssemblyPath.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
			this.tbAssemblyPath.Name = "tbAssemblyPath";
			this.tbAssemblyPath.Size = new System.Drawing.Size(965, 23);
			this.tbAssemblyPath.TabIndex = 0;
			this.tbAssemblyPath.TextChanged += new System.EventHandler(this.tbAssemblyPath_TextChanged);
			// 
			// btSelectAssembly
			// 
			this.btSelectAssembly.Location = new System.Drawing.Point(983, 13);
			this.btSelectAssembly.Name = "btSelectAssembly";
			this.btSelectAssembly.Size = new System.Drawing.Size(98, 23);
			this.btSelectAssembly.TabIndex = 1;
			this.btSelectAssembly.Text = "选择程序集...";
			this.btSelectAssembly.UseVisualStyleBackColor = true;
			this.btSelectAssembly.Click += new System.EventHandler(this.btSelectAssembly_Click);
			// 
			// cmbEntryPoint
			// 
			this.cmbEntryPoint.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.cmbEntryPoint.Enabled = false;
			this.cmbEntryPoint.FormattingEnabled = true;
			this.cmbEntryPoint.Location = new System.Drawing.Point(12, 43);
			this.cmbEntryPoint.Name = "cmbEntryPoint";
			this.cmbEntryPoint.Size = new System.Drawing.Size(718, 25);
			this.cmbEntryPoint.TabIndex = 2;
			this.cmbEntryPoint.SelectedIndexChanged += new System.EventHandler(this.cmbEntryPoint_SelectedIndexChanged);
			// 
			// btRebuild
			// 
			this.btRebuild.Enabled = false;
			this.btRebuild.Location = new System.Drawing.Point(983, 42);
			this.btRebuild.Name = "btRebuild";
			this.btRebuild.Size = new System.Drawing.Size(98, 27);
			this.btRebuild.TabIndex = 3;
			this.btRebuild.Text = "重建";
			this.btRebuild.UseVisualStyleBackColor = true;
			this.btRebuild.Click += new System.EventHandler(this.btRebuild_Click);
			// 
			// cmbManifestModuleKind
			// 
			this.cmbManifestModuleKind.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
			this.cmbManifestModuleKind.Enabled = false;
			this.cmbManifestModuleKind.FormattingEnabled = true;
			this.cmbManifestModuleKind.Location = new System.Drawing.Point(853, 43);
			this.cmbManifestModuleKind.Name = "cmbManifestModuleKind";
			this.cmbManifestModuleKind.Size = new System.Drawing.Size(124, 25);
			this.cmbManifestModuleKind.TabIndex = 4;
			this.cmbManifestModuleKind.SelectedIndexChanged += new System.EventHandler(this.cmbManifestModuleKind_SelectedIndexChanged);
			// 
			// chkNoStaticConstructor
			// 
			this.chkNoStaticConstructor.AutoSize = true;
			this.chkNoStaticConstructor.Checked = true;
			this.chkNoStaticConstructor.CheckState = System.Windows.Forms.CheckState.Checked;
			this.chkNoStaticConstructor.Enabled = false;
			this.chkNoStaticConstructor.Location = new System.Drawing.Point(736, 45);
			this.chkNoStaticConstructor.Name = "chkNoStaticConstructor";
			this.chkNoStaticConstructor.Size = new System.Drawing.Size(111, 21);
			this.chkNoStaticConstructor.TabIndex = 5;
			this.chkNoStaticConstructor.Text = "过滤静态构造器";
			this.chkNoStaticConstructor.UseVisualStyleBackColor = true;
			this.chkNoStaticConstructor.CheckedChanged += new System.EventHandler(this.chkNoStaticConstructor_CheckedChanged);
			// 
			// MainForm
			// 
			this.AllowDrop = true;
			this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 17F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(1093, 82);
			this.Controls.Add(this.chkNoStaticConstructor);
			this.Controls.Add(this.cmbManifestModuleKind);
			this.Controls.Add(this.btRebuild);
			this.Controls.Add(this.cmbEntryPoint);
			this.Controls.Add(this.btSelectAssembly);
			this.Controls.Add(this.tbAssemblyPath);
			this.Font = new System.Drawing.Font("微软雅黑", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134)));
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
			this.MaximizeBox = false;
			this.Name = "MainForm";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.DragDrop += new System.Windows.Forms.DragEventHandler(this.MainForm_DragDrop);
			this.DragEnter += new System.Windows.Forms.DragEventHandler(this.MainForm_DragEnter);
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.TextBox tbAssemblyPath;
		private System.Windows.Forms.Button btSelectAssembly;
		private System.Windows.Forms.OpenFileDialog odlgSelectAssembly;
		private System.Windows.Forms.ComboBox cmbEntryPoint;
		private System.Windows.Forms.Button btRebuild;
		private System.Windows.Forms.ComboBox cmbManifestModuleKind;
		private System.Windows.Forms.CheckBox chkNoStaticConstructor;
	}
}



================================================
File: AssemblyRebuilder/MainForm.cs
================================================
using System;
using System.IO;
using System.Reflection;
using System.Windows.Forms;
using dnlib.DotNet;
using dnlib.DotNet.Writer;

namespace AssemblyRebuilder {
	internal partial class MainForm : Form {
		private static readonly string ProgramName = Assembly.GetExecutingAssembly().GetName().Name;

		public string AssemblyPath { get; set; }

		public ModuleDef ManifestModule { get; set; }

		public IManagedEntryPoint ManagedEntryPoint { get; set; }

		public ModuleKind ManifestModuleKind { get; set; }

		public MainForm() {
			InitializeComponent();
			Text = GetAssemblyAttribute<AssemblyProductAttribute>().Product + " v" + Assembly.GetExecutingAssembly().GetName().Version.ToString() + " by " + GetAssemblyAttribute<AssemblyCopyrightAttribute>().Copyright.Substring(17);
			for (int i = 0; i < 4; i++)
				cmbManifestModuleKind.Items.Add((ModuleKind)i);
		}

		public MainForm(string assemblyPath) : this() {
			AssemblyPath = Path.GetFullPath(assemblyPath);
			LoadAssembly();
		}

		private static T GetAssemblyAttribute<T>() => (T)Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(T), false)[0];

		private void MainForm_DragEnter(object sender, DragEventArgs e) => e.Effect = e.Data.GetDataPresent(DataFormats.FileDrop) ? DragDropEffects.Copy : DragDropEffects.None;

		private void MainForm_DragDrop(object sender, DragEventArgs e) {
			tbAssemblyPath.Text = ((string[])e.Data.GetData(DataFormats.FileDrop))[0];
			LoadAssembly();
		}

		private void btSelectAssembly_Click(object sender, EventArgs e) {
			if (odlgSelectAssembly.ShowDialog() == DialogResult.OK)
				tbAssemblyPath.Text = odlgSelectAssembly.FileName;
			else
				return;
			LoadAssembly();
		}

		private void tbAssemblyPath_TextChanged(object sender, EventArgs e) => AssemblyPath = tbAssemblyPath.Text;

		private void chkNoStaticConstructor_CheckedChanged(object sender, EventArgs e) => LoadAllEntryPoints();

		private void cmbEntryPoint_SelectedIndexChanged(object sender, EventArgs e) => ManagedEntryPoint = ((IManagedEntryPointWrapper)cmbEntryPoint.SelectedItem).ManagedEntryPoint;

		private void cmbManifestModuleKind_SelectedIndexChanged(object sender, EventArgs e) {
			bool isExecutable;

			ManifestModuleKind = (ModuleKind)cmbManifestModuleKind.SelectedItem;
			isExecutable = MustHasManagedEntryPoint();
			cmbEntryPoint.Enabled = isExecutable;
			chkNoStaticConstructor.Enabled = isExecutable;
			if (isExecutable)
				LoadAllEntryPoints();
			else
				cmbEntryPoint.Items.Clear();
		}

		private void btRebuild_Click(object sender, EventArgs e) => Rebuild();

		private void LoadAssembly() {
			try {
				ManifestModule = ModuleDefMD.Load(AssemblyPath);
				chkNoStaticConstructor.Enabled = true;
				cmbManifestModuleKind.Enabled = true;
				btRebuild.Enabled = true;
			}
			catch {
				MessageBox.Show("无效程序集，请重新选定路径", ProgramName);
				ManifestModule = null;
				cmbEntryPoint.Enabled = false;
				chkNoStaticConstructor.Enabled = false;
				cmbManifestModuleKind.Enabled = false;
				btRebuild.Enabled = false;
				return;
			}
			LoadManifestModuleKind();
			LoadAllEntryPoints();
		}

		private void LoadAllEntryPoints() {
			MethodSig methodSig;

			cmbEntryPoint.Items.Clear();
			foreach (TypeDef typeDef in ManifestModule.GetTypes())
				foreach (MethodDef methodDef in typeDef.Methods) {
					if (!methodDef.IsStatic)
						continue;
					if (methodDef.IsGetter || methodDef.IsSetter)
						continue;
					if (chkNoStaticConstructor.Checked && methodDef.IsStaticConstructor)
						continue;
					methodSig = (MethodSig)methodDef.Signature;
					switch (methodSig.Params.Count) {
					case 0:
						break;
					case 1:
						if (methodSig.Params[0].FullName == "System.String[]")
							break;
						else
							continue;
					default:
						continue;
					}
					switch (methodSig.RetType.FullName) {
					case "System.Void":
					case "System.Int32":
						break;
					default:
						continue;
					}
					cmbEntryPoint.Items.Add(new IManagedEntryPointWrapper(methodDef));
				}
			ManagedEntryPoint = ManifestModule.ManagedEntryPoint;
			if (ManagedEntryPoint != null)
				for (int i = 0; i < cmbEntryPoint.Items.Count; i++)
					if (((IManagedEntryPointWrapper)cmbEntryPoint.Items[i]).ManagedEntryPoint.MDToken.Raw == ManagedEntryPoint.MDToken.Raw)
						cmbEntryPoint.SelectedIndex = i;
		}

		private void LoadManifestModuleKind() {
			ManifestModuleKind = ManifestModule.Kind;
			cmbManifestModuleKind.SelectedItem = ManifestModuleKind;
		}

		private bool MustHasManagedEntryPoint() => ManifestModuleKind != ModuleKind.Dll && ManifestModuleKind != ModuleKind.NetModule;

		private void Rebuild() {
			if (MustHasManagedEntryPoint() && ManagedEntryPoint == null && MessageBox.Show("未选择入口点，是否重建？", ProgramName, MessageBoxButtons.YesNo) != DialogResult.Yes)
				return;

			ManifestModule.ManagedEntryPoint = ManagedEntryPoint;
			ManifestModule.Kind = ManifestModuleKind;
			ManifestModule.Write(Path.Combine(Path.GetDirectoryName(AssemblyPath), Path.GetFileNameWithoutExtension(AssemblyPath) + ".rb" + Path.GetExtension(AssemblyPath)), new ModuleWriterOptions(ManifestModule) { MetaDataOptions = new MetaDataOptions(MetaDataFlags.KeepOldMaxStack) });
			MessageBox.Show("重建成功", ProgramName);
		}
	}
}



================================================
File: AssemblyRebuilder/MainForm.resx
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="tbAssemblyPath.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="btSelectAssembly.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="odlgSelectAssembly.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <metadata name="cmbEntryPoint.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="btRebuild.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="cmbManifestModuleKind.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <metadata name="chkNoStaticConstructor.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAQAEBAAAAAAIABoBAAARgAAACAgAAAAACAAqBAAAK4EAABAQAAAAAAgAChCAABWFQAAgIAAAAAA
        IAAoCAEAflcAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAACQkJAdAQEB0QEBAwEBAQMZAQECIMzMzFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAACQkJAdAQEDDQUFB/0FBQf9BQUH/QUFB/0BAQOA5OTkbAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAABAQEB0RkZG/0VFRf9GRkb/SkpK/0ZGRv9LS0v/QEBApAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAQEBAwG9vb/97e3v/ra2t/7Kysv9sbGz/lpaW/0RERPAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQMZBQUH/nJyc/5OTk/+Ghob/e3t7/6enp/9DQ0P2AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQECIQUFB/1ZWVv9QUFD/QUFB/0FBQf9QUFD/QEBAuAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMzFEBAQOBBQUH/QUFB/0FBQf9BQUH/QUFB80BA
        QDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5OTkbQEBApEBAQO9AQED2QEBAuEFB
        QS88PDwRPz8/okBAQNpAQECbLi4uCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAQEBAokFBQf9BQUH/QUFB/0FBQZIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAEBAQNlBQUH/QUFB/0FBQf9AQEDKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAA/Pz+aQUFB/0FBQf9BQUH/QEBAiwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAALi4uCz8/P5JBQUHJPj4+iyQkJAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//
        AAD4/wAA4H8AAOA/AADAPwAAwD8AAMA/AADgfwAA8McAAP+DAAD/gwAA/4MAAP/HAAD//wAA//8AACgA
        AAAgAAAAQAAAAAEAIAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQCQ/Pz9uPz8/lUBA
        QJs/Pz+BQEBARAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs7Ox5AQECwQEBA/kFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB3T09PVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7Ozs4QUFB7EFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA/j8/P4UAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOzs7HkFB
        QexBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQGwAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AABAQECwQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA9Ts7
        OxoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAPj4+JUBAQP5SUlL/RkZG/0VFRf9PT0//SUlJ/1BQUP9DQ0P/ZWVl/1VVVf9BQUH/SkpK/2Rk
        ZP9DQ0P/Pj4+gwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAA/Pz9uQUFB/7W1tf9+fn7/Xl5e/5iYmP+dnZ3/paWl/6SkpP+lpaX/i4uL/0FB
        Qf+7u7v/oqKi/01NTf9AQEDOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQZVBQUH/SUlJ/0NDQ/9eXl7/m5ub/87Ozv+lpaX/ysrK/7W1
        tf+mpqb/QUFB/7u7u/9BQUH/QUFB/0BAQPUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAnEFBQf9BQUH/QUFB/15eXv/MzMz/oaGh/6Wl
        pf+zs7P/d3d3/8DAwP9bW1v/yMjI/2xsbP9FRUX/QEBA+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQECAQUFB/0FBQf9BQUH/Xl5e/+vr
        6/9hYWH/paWl/1RUVP+bm5v/YWFh/3R0dP/U1NT/lJSU/0pKSv9BQUHgAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQERBQUH/QUFB/0FB
        Qf9PT0//iIiI/0lJSf91dXX/QUFB/0FBQf9BQUH/QUFB/35+fv9BQUH/QUFB/0BAQKMAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0FB
        QdxBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/QQAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAPT09UEBAQP5BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BA
        QLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAPz8/hUFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9AQEDSPDw8EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAbEBAQPVBQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBArzw8PBEAAAAAAAAAADs7Oxo/Pz+CQEBAt0BAQLM+Pj53PDw8EQAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOzs7GkBAQINAQEDOQUFB9EBA
        QPtBQUHgQEBAoz8/P0EAAAAAAAAAAAAAAABAQEBEQEBA8UFBQf9BQUH/QUFB/0FBQf9BQUHlPDw8LwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOzs7GkFBQfBBQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUHgMzMzCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/Pz+CQUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf8+Pj5iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQLZBQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQJcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAs0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAA+Pj53QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEBXAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAEBAQBBBQUHlQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/0TMzMwUAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAADw8PC9AQEDgQUFB/0FBQf9BQUH/QUFB/z8/P9E7OzseAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMzMwo+Pj5iPz8/lkBAQJNAQEBXMzMzBQAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////
        ///////////////j////AP///gA///wAP//4AB//+AAP//gAD//wAA//8AAP//AAD//4AA//+AAf//wA
        H//8AD///wB4//+B8D///+Af///AH///wA///8AP///gH///4B////A////8////////////////////
        //8oAAAAQAAAAIAAAAABACAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAADPj4+IUFBQTc+Pj4+PDw8Mz09PRkAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAANTU1HUBAQHdBQUHBQEBA9kFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB7EBA
        QLA/Pz9hOzs7DQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5OTkkQEBApkFBQftBQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQPE/Pz+GMzMzDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/Pz95QUFB+EFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQOY/Pz9NAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs7Ow0/Pz+1QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBA/kBAQIMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs7
        Ow1AQEDHQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAJBQUG1QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEB4AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/Pz95QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/D8/Pz0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAkQUFB+EFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDXMzMzBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPz8/pkFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/z4+PmYAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAPj4+HUFBQftBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9AQEDYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQHdBQUH/QUFB/0RERP+Ghob/WFhY/0FBQf9BQUH/UVFR/3l5
        ef9BQUH/QUFB/2RkZP97e3v/RkZG/0FBQf9JSUn/g4OD/5CQkP+BgYH/UlJS/0FBQf9BQUH/QUFB/2Zm
        Zv+Ojo7/goKC/0tLS/9BQUH/QUFB/zw8PDcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBQUHBQUFB/0FBQf+CgoL/8PDw/8LC
        wv9BQUH/QUFB/3t7e//w8PD/QUFB/0FBQf/X19f/8PDw/1paWv9JSUn/09PT//Dw8P/w8PD/8PDw/5iY
        mP9BQUH/QUFB/3V1df/v7+//8PDw//Dw8P9sbGz/QUFB/0FBQf8/Pz+BAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQEBA9kFB
        Qf9BQUH/dHR0//Dw8P+0tLT/QUFB/0FBQf97e3v/8PDw/0FBQf9tbW3/8PDw//Dw8P9aWlr/h4eH/+/v
        7/93d3f/QUFB/1JSUv9TU1P/QUFB/0FBQf+xsbH/2NjY/1BQUP9YWFj/SEhI/0FBQf9BQUH/QEBAugAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAPj4+IUFBQf9BQUH/QUFB/0FBQf9iYmL/SUlJ/0FBQf9BQUH/e3t7//Dw8P9BQUH/r6+v/+vr
        6//w8PD/Wlpa/6urq//f39//e3t7/3t7e/97e3v/bGxs/0FBQf9BQUH/u7u7/7u7u/9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQeEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQTdBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/3t7
        e//w8PD/S0tL/+np6f+4uLj/8PDw/1paWv+ysrL/8PDw//Dw8P/w8PD/8PDw/8TExP9BQUH/QUFB/7u7
        u/+7u7v/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQED3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+Pj4+QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf97e3v/8PDw/4eHh//t7e3/dnZ2//Dw8P9aWlr/m5ub/+Tk5P9RUVH/T09P/8LC
        wv+/v7//QUFB/0FBQf+7u7v/u7u7/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA/QAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOzs7NEFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/e3t7//Dw8P/Ly8v/vb29/2RkZP/w8PD/Wlpa/2Ji
        Yv/v7+//q6ur/5KSkv/s7Oz/lJSU/1RUVP+YmJj/1dXV/9XV1f+YmJj/mJiY/1NTU/9BQUH/QUFB/0BA
        QPMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAD09PRlBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/3t7e//w8PD/7+/v/3h4
        eP9kZGT/8PDw/1paWv9BQUH/jo6O/+vr6//w8PD/vb29/0dHR/9oaGj/5+fn/+3t7f/t7e3/5+fn/+fn
        5/9oaGj/QUFB/0FBQf9BQUHYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQUFB7EFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf97e3v/8PDw/+Dg4P9ERET/ZGRk//Dw8P9aWlr/QUFB/0FBQf9HR0f/S0tL/0FBQf9BQUH/QUFB/0FB
        Qf+7u7v/u7u7/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQLBBQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/eHh4//Dw8P+goKD/QUFB/2NjY//w8PD/WFhY/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/srKy/7u7u/9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQHAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAA/Pz9hQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0JCQv9PT0//RUVF/0FBQf9CQkL/Tk5O/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9OTk7/QUFB/0FBQf9BQUH/QUFB/0BA
        QP48PDwiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAOzs7DUFBQfBBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9AQEC+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/Pz+FQUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pj4+RgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMzD0BA
        QOZBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAtgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAA/Pz9NQEBA/kFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA7js7
        Ox4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4+PoNBQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBA+j09PUcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAk0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QEBA+j8/P1kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAABAQEB4QUFB/EFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA7j09PUcAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAADo6OjBAQEBkQEBAfEBAQHg/Pz9ZOjo6HwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs7OzxAQEDXQUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/tj4+Ph0AAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAADPj4+Z0BAQNtBQUH/QUFB/0FBQf9BQUH/QUFB/0BAQP5AQEDCPz8/RQAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMzBT4+
        PmZAQEDYQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQP5AQEC+Pj4+RgAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCQkIbQEBAx0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0BAQP5AQECcKioqBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAADw8PDc/Pz+BQUFBuUFBQeBAQED2QEBA/UBAQPNBQUHYPz8/rUBA
        QHA8PDwiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5OTkbQEBA3kFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQLRAQEAEAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQEBAxkFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/iQAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAPj4+ZkFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQfs9PT0qAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQNtBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw8PC9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQOwAAAACAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBQUFiQUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/Ojo6IwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAQUFBekFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQHhBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEA4AAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/Pz9ZQUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/PT09GQAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPj4+HUBA
        QP5BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAABAQEDCQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/z8/P4IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPT09Q0BAQP5BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQO5AQEAUAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQECaQUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQP4+Pj5bAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAKioqBkFBQbVBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BA
        QP5AQEB7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAEQEBAiEFBQftBQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0BAQO5AQEBbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9PT0qQEBAnEBA
        QO1BQUH/QUFB/0FBQf9BQUH/QUFB3UFBQYJAQEAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAACOTk5JD4+Pjo8PDw3PT09GQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//////////////////
        ////////////////////////////////////////////////////////////////////////////////
        8Af///////+AAP///////wAAf//////8AAAf//////gAAA//////8AAAD//////wAAAH/////+AAAAP/
        ////wAAAA//////AAAAB/////8AAAAH/////gAAAAP////+AAAAA/////4AAAAD/////gAAAAP////+A
        AAAA/////4AAAAD/////gAAAAP////+AAAAA/////4AAAAH/////wAAAAf/////AAAAB/////8AAAAP/
        ////4AAAA//////wAAAH//////AAAA//////+AAAH//////+AAA///////8AAH/AP////8AB/wAP////
        8A/+AAf///////wAA////////AAD///////4AAH///////gAAf//////+AAB///////4AAH///////gA
        Af//////+AAB///////4AAH///////gAAf///////AAD///////8AAf///////4AD////////wAf////
        ////wD//////////////////////////////////////////////////////////////////////////
        ////////////////////////KAAAAIAAAAAAAQAAAQAgAAAAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANzc3DkBA
        QDQ9PT1TQEBAaEFBQXZAQEB/QUFBej8/P3E+Pj5eQEBARDw8PCIAAAACAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAADk5ORtAQEBkQEBApEFBQd1AQED+QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0BAQPNAQEDCPz8/hUFBQT9AQEAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANzc3Dj4+PmdBQUHFQEBA/UFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BA
        QOtAQECYPz8/NQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAGD8/
        P41AQEDxQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAx0FBQU8AAAABAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAQEBADEBAQIRAQED1QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQMtAQEA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8/P01AQEDjQUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BA
        QP5AQECfOTk5EgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAADMzMwpAQECbQEBA/kFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDkPz8/QQAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+Pj4hQEBA0EFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH8Pz8/dQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAQEBANEFBQehBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/mgAA
        AAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQDxAQEDxQUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/qUBAQAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAA7Ozs0QEBA8UFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBApAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPj4+IUFBQehBQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/igAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMz
        MwpAQEDQQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9AQED+QEBAWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAm0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH0QEBAKAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8/
        P01AQED+QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDKAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAMQEBA40FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9AQEBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8/
        P4VBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQe89PT0VAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAYQEBA9UFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQY4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8/
        P41BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA9jo6OhYAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7OzsNQEBA8UFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QEBAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4+
        PmdBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDjAAAAAwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQUFBxUFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf8/Pz9FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADk5
        ORtAQED9QUFB/0FBQf9BQUH/QUFB/0FBQf9PT0//vr6+/9zc3P+fn5//QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/g4OD/7W1tf+wsLD/QUFB/0FBQf9BQUH/QUFB/1lZWf+1tbX/tbW1/7W1tf9YWFj/QUFB/0FB
        Qf9BQUH/QUFB/2NjY/+xsbH/2tra/9/f3//f39//09PT/7Gxsf+FhYX/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/2NjY/+0tLT/2NjY/9/f3//T09P/tLS0/2pqav9BQUH/QUFB/0FBQf9BQUH/QUFB/z8/
        P5kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAZEFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/6+v
        r//w8PD/8PDw//Dw8P9/f3//QUFB/0FBQf9BQUH/QUFB/0FBQf+1tbX/8PDw//Dw8P9BQUH/QUFB/0FB
        Qf9BQUH/nZ2d//Dw8P/w8PD/8PDw/3R0dP9BQUH/QUFB/0FBQf+BgYH/7u7u//Dw8P/w8PD/8PDw//Dw
        8P/w8PD/8PDw//Dw8P9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf94eHj/7u7u//Dw8P/w8PD/8PDw//Dw
        8P/w8PD/mJiY/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AABAQECkQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/2tra//Dw8P/w8PD/8PDw/6urq/9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/7W1tf/w8PD/8PDw/0FBQf9BQUH/QUFB/0FBQf/g4OD/8PDw//Dw8P/w8PD/dHR0/0FB
        Qf9BQUH/YWFh/+7u7v/w8PD/8PDw//Dw8P/w8PD/8PDw//Dw8P/w8PD/8PDw/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/9zc3P/w8PD/8PDw//Dw8P/w8PD/8PDw//Dw8P+YmJj/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/Pj4+JQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQd1BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf/Ozs7/8PDw//Dw8P/w8PD/mpqa/0FBQf9BQUH/QUFB/0FBQf9BQUH/tbW1//Dw8P/w8PD/QUFB/0FB
        Qf9BQUH/eHh4//Dw8P/w8PD/8PDw//Dw8P90dHT/QUFB/0FBQf+zs7P/8PDw//Dw8P/Y2Nj/bm5u/0FB
        Qf9BQUH/U1NT/3Z2dv+JiYn/QUFB/0FBQf9BQUH/QUFB/0FBQf9paWn/8PDw//Dw8P/l5eX/dXV1/0lJ
        Sf9hYWH/gICA/19fX/9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf8+Pj5eAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAA3NzcOQEBA/kFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/4ODg//w8PD/8PDw/+np6f9fX1//QUFB/0FB
        Qf9BQUH/QUFB/0FBQf+1tbX/8PDw//Dw8P9BQUH/QUFB/0FBQf+6urr/8PDw//Dw8P/w8PD/8PDw/3R0
        dP9BQUH/QUFB/+fn5//w8PD/7Ozs/1hYWP9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/35+fv/w8PD/8PDw/5ycnP9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/z8/P40AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQDRBQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/3V1df+UlJT/YWFh/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/7W1tf/w8PD/8PDw/0FB
        Qf9BQUH/UlJS/+zs7P/w8PD/8PDw//Dw8P/w8PD/dHR0/0FBQf9aWlr/8PDw//Dw8P/Dw8P/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/h4eH//Dw8P/w8PD/h4eH/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAswAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAPT09U0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/tbW1//Dw8P/w8PD/QUFB/0FBQf+Pj4//8PDw//Dw8P/d3d3/8PDw//Dw
        8P90dHT/QUFB/3R0dP/w8PD/8PDw/9vb2/+1tbX/tbW1/7W1tf+1tbX/tbW1/7W1tf+1tbX/e3t7/0FB
        Qf9BQUH/QUFB/0FBQf+Hh4f/8PDw//Dw8P+Hh4f/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9AQEDTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBoQUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf+1tbX/8PDw//Dw
        8P9BQUH/QUFB/9fX1//w8PD/8PDw/6CgoP/w8PD/8PDw/3R0dP9BQUH/dHR0//Dw8P/w8PD/8PDw//Dw
        8P/w8PD/8PDw//Dw8P/w8PD/8PDw//Dw8P+YmJj/QUFB/0FBQf9BQUH/QUFB/4eHh//w8PD/8PDw/4eH
        h/9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQOgAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAEBAQHdBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/7W1tf/w8PD/8PDw/0FBQf9qamr/8PDw//Dw8P/Ly8v/h4eH//Dw
        8P/w8PD/dHR0/0FBQf90dHT/8PDw//Dw8P/w8PD/8PDw//Dw8P/w8PD/8PDw//Dw8P/w8PD/8PDw/5iY
        mP9BQUH/QUFB/0FBQf9BQUH/h4eH//Dw8P/w8PD/h4eH/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QEBA9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQUFBfkFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/tbW1//Dw
        8P/w8PD/QUFB/6+vr//w8PD/8PDw/4WFhf+Hh4f/8PDw//Dw8P90dHT/QUFB/1paWv/w8PD/8PDw/8nJ
        yf9eXl7/Xl5e/15eXv9eXl7/jIyM//Dw8P/w8PD/mJiY/0FBQf9BQUH/QUFB/0FBQf+Hh4f/8PDw//Dw
        8P+Hh4f/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQED+AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAA/Pz96QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf+1tbX/8PDw//Dw8P9ISEj/5+fn//Dw8P/n5+f/SEhI/4eH
        h//w8PD/8PDw/3R0dP9BQUH/QUFB/+Pj4//w8PD/5+fn/0hISP9BQUH/QUFB/0FBQf+dnZ3/8PDw//Dw
        8P+Hh4f/QUFB/0FBQf9BQUH/QUFB/4eHh//w8PD/8PDw/4eHh/9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQPoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8/P3JBQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/7W1
        tf/w8PD/8PDw/4WFhf/w8PD/8PDw/6qqqv9BQUH/h4eH//Dw8P/w8PD/dHR0/0FBQf9BQUH/qqqq//Dw
        8P/w8PD/rKys/0FBQf9BQUH/X19f/+Li4v/w8PD/8PDw/11dXf9BQUH/QUFB/0FBQf9BQUH/h4eH//Dw
        8P/w8PD/h4eH/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA8QAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAPj4+X0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/tbW1//Dw8P/w8PD/yMjI//Dw8P/w8PD/ampq/0FB
        Qf+Hh4f/8PDw//Dw8P90dHT/QUFB/0FBQf9fX1//7Ozs//Dw8P/w8PD/0tLS/8DAwP/p6en/8PDw//Dw
        8P/ExMT/QUFB/0FBQf+NjY3/8PDw//Dw8P/w8PD/8PDw//Dw8P/w8PD/8PDw//Dw8P/w8PD/8PDw/4uL
        i/9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBEQUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf+1tbX/8PDw//Dw8P/u7u7/8PDw/9LS0v9BQUH/QUFB/4eHh//w8PD/8PDw/3R0dP9BQUH/QUFB/0FB
        Qf+MjIz/8PDw//Dw8P/w8PD/8PDw//Dw8P/w8PD/4uLi/1paWv9BQUH/QUFB/5iYmP/w8PD/8PDw//Dw
        8P/w8PD/8PDw//Dw8P/w8PD/8PDw//Dw8P/w8PD/mJiY/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BA
        QMMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAADw8PCJBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/7W1tf/w8PD/8PDw//Dw8P/w8PD/j4+P/0FB
        Qf9BQUH/h4eH//Dw8P/w8PD/dHR0/0FBQf9BQUH/QUFB/0FBQf99fX3/3Nzc//Dw8P/w8PD/8PDw/8jI
        yP9dXV3/QUFB/0FBQf9BQUH/iYmJ/9/f3//f39//5eXl//Dw8P/w8PD/5eXl/9/f3//f39//39/f/9/f
        3/+JiYn/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAogAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUBA
        QPNBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/tbW1//Dw8P/w8PD/8PDw/+zs7P9PT0//QUFB/0FBQf+Hh4f/8PDw//Dw8P90dHT/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/Wlpa/15eXv9PT0//QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf+Hh4f/8PDw//Dw8P+Hh4f/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf8/Pz91AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAwkFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf+1tbX/8PDw//Dw8P/w8PD/t7e3/0FB
        Qf9BQUH/QUFB/4eHh//w8PD/8PDw/3R0dP9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/4eHh//w8PD/8PDw/4eHh/9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/z4+PkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAA/Pz+FQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/7W1tf/w8PD/8PDw//Dw8P9zc3P/QUFB/0FBQf9BQUH/h4eH//Dw8P/w8PD/dHR0/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/h4eH//Dw8P/w8PD/h4eH/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9AQED5Li4uCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD09PT9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/rKys//Dw8P/w8PD/3Nzc/0FB
        Qf9BQUH/QUFB/0FBQf+FhYX/8PDw//Dw8P9sbGz/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9ycnL/4ODg//Dw8P+Hh4f/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQL8AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAQEBABEBAQOtBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9ISEj/Xl5e/15eXv9TU1P/QUFB/0FBQf9BQUH/QUFB/0VFRf9eXl7/Wlpa/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/a2tr/0xMTP9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAl0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQfw5OTkbAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAABAQEA0QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBAtAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEDGQUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf89PT1HAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4+Pk5BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFBzQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBA
        QMpBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEBMAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAPEBAQP5BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBAvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAQEBAn0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQfdBQUEnAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5OTkSQEBA40FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBAdwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAA/Pz9BQUFB+0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQLsAAAACAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/Pz91QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9AQEDgQEBAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/Pz+ZQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA7j09PSoAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAM/Pz+pQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BA
        QPM/Pz85AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQARAQECkQUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDuPz8/OQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAE/Pz+JQEBA/kFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA4Ds7
        OysAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBbQUFB9EFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQLtAQEAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9PT0/Pz8/gkBAQLZAQEDbQEBA8kBA
        QP5AQED6QUFB6EBAQMo/Pz+dPj4+Yjs7OxoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8PDwmPz8/yUFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQPc/Pz91AAAAAgAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD09
        PRlAQECIQUFB6UFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA/UFB
        Qb0+Pj5OAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAADQEBAb0BAQO9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9AQEC7Ozs7JwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAADc3Nw4/Pz+NQEBA90FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUHRPj4+QgAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPT09FT8/P45AQED2QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDOQEBATAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/Pz9BQEBA4kFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9AQED+QEBAmjMzMwoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAADo6OhZAQEB/QEBA40FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        QfxAQEC0QUFBRwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAQEBAb0FBQftBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAzz09
        PRkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAADQEBARD8/P5lAQEDjQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QEBA+UBAQL9AQEBwOzs7GgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQX5BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA3js7Ox4AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAkPz8/XUBA
        QIxAQECzQEBA0kBAQOdAQED2QEBA/kBAQPlAQEDxQEBA3kBAQMRBQUGhPz8/dT4+PkIuLi4LAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAABAQEBsQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBA2DY2NhMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPz8/PUBAQPtBQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBAtwAAAAEAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAEBAQAxAQEDiQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/Pj4+bwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAi0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDxPT09GQAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAD09PRlAQED3QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf8/Pz+RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPz8/iUFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BA
        QPU2NjYTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAANAQEDoQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BAQGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPz8/PUFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QEBAvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAABAQEB/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQED2QEBACAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQLJBQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf88PDwzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAQEBA2UFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/z8/P1kAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEDuQUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QEBAcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFBQftBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUF+AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBA+UFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/z8/P3oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEDoQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/aQAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBA
        QMpBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf8+Pj5KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQUFBnUFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/z4+
        Ph0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAA+Pj5eQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUHdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD09PRlAQED9QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0BA
        QJcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAD8/P71BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/PQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPj4+TkFBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qc0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAABQEBA0EFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/Pz8/UQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+Pj4+QEBA/kFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/z8/
        P70AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQECXQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEDyPj4+JQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBA
        QAg/Pz/OQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA/j4+
        PlcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs7OxpBQUHdQUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQEB3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAEBAQCBAQEDaQUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9AQED+QEBAdwAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAENDQxNAQEC2QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QEBA8kBAQFcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE/Pz9uQEBA8UFBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/z8/P70+Pj4lAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAA9PT0ZQEBAkEBAQPVBQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FB
        Qf9BQUH/QUFB/0FBQc0/Pz9RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANjY2E0BAQGxAQEC/QEBA+UFB
        Qf9BQUH/QUFB/0FBQf9BQUH/QUFB/0FBQf9BQUH/QEBA4kBAQJc/Pz89AAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEAIPT09NkBAQFtAQEBvQEBAez8/P3VAQEBoPj4+Sj4+
        Ph0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        /////////4AAf/////////////////wAAA/////////////////gAAAD////////////////gAAAAP//
        /////////////wAAAAA///////////////wAAAAAH//////////////4AAAAAA//////////////8AAA
        AAAD/////////////+AAAAAAAf/////////////AAAAAAAD/////////////gAAAAAAAf///////////
        /wAAAAAAAH////////////4AAAAAAAA////////////+AAAAAAAAH////////////AAAAAAAAB//////
        //////gAAAAAAAAP///////////4AAAAAAAAB///////////8AAAAAAAAAf///////////AAAAAAAAAH
        ///////////wAAAAAAAAA///////////4AAAAAAAAAP//////////+AAAAAAAAAB///////////gAAAA
        AAAAAf//////////wAAAAAAAAAH//////////8AAAAAAAAAB///////////AAAAAAAAAAP//////////
        wAAAAAAAAAD//////////8AAAAAAAAAA///////////AAAAAAAAAAP//////////wAAAAAAAAAD/////
        /////8AAAAAAAAAA///////////AAAAAAAAAAP//////////wAAAAAAAAAD//////////8AAAAAAAAAA
        ///////////AAAAAAAAAAP//////////wAAAAAAAAAD//////////8AAAAAAAAAB///////////AAAAA
        AAAAAf//////////wAAAAAAAAAH//////////+AAAAAAAAAB///////////gAAAAAAAAA///////////
        4AAAAAAAAAP///////////AAAAAAAAAD///////////wAAAAAAAAB///////////+AAAAAAAAAf/////
        //////gAAAAAAAAP///////////8AAAAAAAAD////////////AAAAAAAAB////////////4AAAAAAAA/
        ////////////AAAAAAAAP////////////4AAAAAAAH////////////+AAAAAAAD/////////////wAAA
        AAAB/////////////+AAAAAAA//////////////wAAAAAAf//////////////AAAAAAP//4A////////
        //4AAAAAP//wAB//////////gAAAAH//wAAH/////////8AAAAH//4AAAf/////////4AAAH//8AAAD/
        /////////gAAP//+AAAAf//////////gA////AAAAD////////////////gAAAAf///////////////w
        AAAAH///////////////4AAAAA///////////////+AAAAAH///////////////AAAAAB///////////
        ////wAAAAAf//////////////8AAAAAD///////////////AAAAAA///////////////gAAAAAP/////
        /////////4AAAAAD//////////////+AAAAAA///////////////gAAAAAP//////////////4AAAAAD
        //////////////+AAAAAA///////////////gAAAAAP//////////////4AAAAAD///////////////A
        AAAAA///////////////wAAAAAP//////////////8AAAAAH///////////////gAAAAB///////////
        ////4AAAAA////////////////AAAAAP///////////////wAAAAH///////////////+AAAAD//////
        //////////wAAAB////////////////+AAAA/////////////////wAAAf/////////////////AAAP/
        ////////////////4AAP//////////////////wAP///////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////
        /////////////////////////////w==
</value>
  </data>
</root>


================================================
File: AssemblyRebuilder/Program.cs
================================================
using System;
using System.IO;
using System.Text;
using System.Windows.Forms;

namespace AssemblyRebuilder {
	internal static class Program {
		[STAThread]
		private static void Main(string[] args) {
			AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
			Application.EnableVisualStyles();
			Application.SetCompatibleTextRenderingDefault(false);
			if (args != null && args.Length == 1 && !string.IsNullOrEmpty(args[0]) && File.Exists(args[0]))
				Application.Run(new MainForm(args[0]));
			else
				Application.Run(new MainForm());
		}

		private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e) => MessageBox.Show(((Exception)e.ExceptionObject).GetRealException().ToFullString());

		/// <summary>
		/// 获取最内层异常
		/// </summary>
		/// <param name="exception"></param>
		/// <returns></returns>
		private static Exception GetRealException(this Exception exception) => exception.InnerException == null ? exception : GetRealException(exception.InnerException);

		/// <summary>
		/// 返回一个字符串，其中包含异常的所有信息。
		/// </summary>
		/// <param name="exception"></param>
		/// <returns></returns>
		private static string ToFullString(this Exception exception) {
			StringBuilder stringBuilder;

			stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("Type: " + Environment.NewLine + exception.GetType().FullName);
			stringBuilder.AppendLine("Message: " + Environment.NewLine + exception.Message);
			stringBuilder.AppendLine("Source: " + Environment.NewLine + exception.Source);
			stringBuilder.AppendLine("StackTrace: " + Environment.NewLine + exception.StackTrace);
			stringBuilder.AppendLine("TargetSite: " + Environment.NewLine + exception.TargetSite.ToString());
			return stringBuilder.ToString();
		}
	}
}



================================================
File: AssemblyRebuilder/Properties/AssemblyInfo.cs
================================================
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("AssemblyRebuilder")]
[assembly: AssemblyDescription("重建程序集")]
[assembly: AssemblyProduct("AssemblyRebuilder")]
[assembly: AssemblyCopyright("Copyright © 2018 Wwh / NCK")]
[assembly: ComVisible(false)]
[assembly: Guid("b54f91e5-a01b-473b-b3ea-570c6617f2df")]
[assembly: AssemblyVersion("1.2.2.0")]
[assembly: AssemblyFileVersion("1.2.2.0")]



================================================
File: Libraries/dnlib/LICENSE.txt
================================================
dnlib: .NET assembly library
https://github.com/0xd4d/dnlib

Copyright (C) 2012-2018 de4dot@gmail.com

Contributors
------------

Ki, "yck1509 <confuser.net@gmail.com>", https://github.com/yck1509
kiootic, "kiootic <kiootic@gmail.com>", https://github.com/kiootic
SlowLogicBoy, https://github.com/SlowLogicBoy

MIT LICENSE
-----------

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



================================================
File: Libraries/dnlib/dnlib.Shared/Settings.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib {
	/// <summary>
	/// dnlib settings
	/// </summary>
	public static class Settings {
		/// <summary>
		/// <c>true</c> if dnlib is thread safe. (<c>THREAD_SAFE</c> was defined during compilation)
		/// </summary>
		public static bool IsThreadSafe {
			get {
#if THREAD_SAFE
				return true;
#else
				return false;
#endif
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/dnlib.Shared.projitems
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <HasSharedItems>true</HasSharedItems>
    <SharedGUID>9e1fee5b-49a3-4c7f-b3c2-389e40108bf2</SharedGUID>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <Import_RootNamespace>dnlib.Shared</Import_RootNamespace>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AllTypesHelper.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AssemblyAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AssemblyDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AssemblyHash.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AssemblyHashAlgorithm.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AssemblyNameComparer.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AssemblyNameInfo.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AssemblyRef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\AssemblyResolver.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\CallingConvention.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\CallingConventionSig.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ClassLayout.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Constant.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\CorLibTypes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\CpuArch.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\CustomAttribute.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\CustomAttributeCollection.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\CustomAttributeReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\DeclSecurity.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\DeclSecurityReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ElementType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\Code.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\DynamicMethodBodyReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\ExceptionHandler.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\ExceptionHandlerType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\Extensions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\FlowControl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\Instruction.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\InstructionPrinter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\InvalidMethodException.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\LocalList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\MethodBody.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\MethodBodyReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\MethodBodyReaderBase.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\MethodTableToTypeConverter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\MethodUtils.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\OpCode.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\OpCodes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\OpCodeType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\OperandType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Emit\StackBehaviour.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\EventAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\EventDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ExportedType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Extensions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\FieldAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\FieldDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\FileAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\FileDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\FrameworkRedirect.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\FullNameCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\GenericArguments.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\GenericParam.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\GenericParamAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\GenericParamConstraint.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\GenericParamContext.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\IAssemblyResolver.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ICodedToken.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ICorLibTypes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ICustomAttribute.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\IDecrypters.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ILogger.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ImplMap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Importer.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\InterfaceImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\IResolver.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ITokenResolver.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\IType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ITypeDefFinder.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\IVariable.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ManifestResource.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ManifestResourceAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MarshalBlobReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MarshalType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MDToken.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\BlobStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\CodedToken.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\ColumnInfo.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\ColumnSize.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\ComImageFlags.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\CompressedMetaData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\DotNetStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\DotNetTableSizes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\ENCMetaData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\GuidStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\HeapType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\HotHeapStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\HotHeapVersion.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\HotStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\HotTableStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\ImageCor20Header.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\IMetaData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\IRowReaders.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\MDHeaderRuntimeVersion.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\MDStreamFlags.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\MDTable.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\MetaData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\MetaDataCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\MetaDataHeader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\PdbStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\RawRowEqualityComparer.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\RawTableRows.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\RidList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\StorageFlags.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\StreamHeader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\StringsStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\Table.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\TableInfo.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\TablesStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\TablesStream_Read.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MD\USStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MemberFinder.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MemberMDInitializer.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MemberRef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MethodAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MethodDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MethodExportInfo.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MethodExportInfoProvider.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MethodImplAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MethodOverride.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MethodSemanticsAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\MethodSpec.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ModuleContext.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ModuleCreationOptions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ModuleDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ModuleDefMD.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ModuleKind.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ModuleLoader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ModuleRef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\NativeType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\NullResolver.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ParamAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ParamDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ParameterList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\CustomDebugInfoGuids.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\ComInterfaces.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\ImageStreamIStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\MDEmitter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\PinnedMetaData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\StreamIStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolDocumentImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolDocumentWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolMethodImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolNamespaceImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolReaderCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolReaderImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolScopeImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolVariableImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Dss\SymbolWriterCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\ImageStreamUtils.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\IMAGE_DEBUG_DIRECTORY.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\ManagedSymbolReaderCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\DbiDocument.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\DbiFunction.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\DbiModule.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\DbiNamespace.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\DbiScope.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\DbiVariable.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\ModuleStreamType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\MsfStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\NumericLeaf.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\NumericReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\PdbAddress.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\PdbException.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\PdbReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\SymbolReaderCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Managed\SymbolType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbConstant.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbCustomDebugInfo.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbDocument.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbDocumentConstants.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbFileKind.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbImplType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbImport.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbLocal.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbLocalAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbMethod.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbScope.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\PdbState.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\DocumentNameReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\ImportDefinitionKindUtils.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\ImportScopeBlobReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\ImportScopeBlobWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\ListCache.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\LocalConstantSigBlobReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\LocalConstantSigBlobWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\PortablePdbCustomDebugInfoReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\PortablePdbCustomDebugInfoWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\PortablePdbReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\SequencePointConstants.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\SymbolDocumentImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\SymbolMethodImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\SymbolReaderCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\SymbolScopeImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Portable\SymbolVariableImpl.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\SequencePoint.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\SymbolReaderCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Symbols\SymbolAsyncStepInfo.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Symbols\SymbolDocument.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Symbols\SymbolMethod.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Symbols\SymbolNamespace.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Symbols\SymbolReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Symbols\SymbolScope.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Symbols\SymbolSequencePoint.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\Symbols\SymbolVariable.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\WindowsPdb\CorSymVarFlag.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\WindowsPdb\CustomDebugInfoConstants.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\WindowsPdb\ISymbolWriter2.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\WindowsPdb\PdbCustomDebugInfoWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\WindowsPdb\PseudoCustomDebugInfoFactory.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\WindowsPdb\SymbolWriterCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Pdb\WindowsPdb\WindowsPdbWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\PInvokeAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\PropertyAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\PropertyDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\PublicKey.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\PublicKeyBase.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\PublicKeyToken.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\RecursionCounter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ReflectionExtensions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ResolveException.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resolver.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resource.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\ResourceCollection.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\BuiltInResourceData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\IResourceData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\ResourceDataCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\ResourceElement.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\ResourceElementSet.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\ResourceReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\ResourceTypeCode.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\ResourceWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\UserResourceData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Resources\UserResourceType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\SecurityAction.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\SecurityAttribute.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\SerializationType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\SigComparer.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\SignatureReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\StandAloneSig.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\StrongNameKey.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\StrongNameSigner.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TIAHelper.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TypeAttributes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TypeDef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TypeDefFinder.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TypeHelper.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TypeNameParser.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TypeRef.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TypeSig.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\TypeSpec.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\UTF8String.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Utils.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\VariantType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\VTableFixups.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\WinMDHelpers.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\WinMDStatus.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\BinaryReaderChunk.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\BlobHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ByteArrayChunk.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ChunkList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ChunkListBase.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\CustomAttributeWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\DebugDirectory.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\DeclSecurityWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\Extensions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\GuidHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\HeapBase.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\HotHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\HotPool.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\HotTable.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\IChunk.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\IHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ImageCor20Header.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\IMetaDataListener.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\IModuleWriterListener.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ImportAddressTable.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ImportDirectory.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\IOffsetHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\IWriterError.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ManagedExportsWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MarshalBlobWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MaxStackCalculator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MDTable.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MDTableWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MetaData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MetaDataHeader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MethodBody.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MethodBodyChunks.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MethodBodyWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\MethodBodyWriterBase.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ModuleWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ModuleWriterBase.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\ModuleWriterException.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\NativeModuleWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\NetResources.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\NormalMetaData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\PdbHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\PEHeaders.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\PESection.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\PortablePdbConstants.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\PreserveTokensMetaData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\RelocDirectory.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\SectionSizes.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\SerializerMethodContext.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\SignatureWriter.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\StartupStub.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\StringsHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\StrongNameSignature.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\TablesHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\UniqueChunkList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\USHeap.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\Win32ResourcesChunk.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)DotNet\Writer\WriterUtils.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\BinaryReaderStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\FileOffset.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\FileSection.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\IBinaryReader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\IFileSection.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\IImageStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\IImageStreamCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\ImageStreamCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\IOExtensions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\MemoryImageStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\MemoryMappedFileStreamCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\MemoryStreamCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\UnmanagedMemoryImageStream.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)IO\UnmanagedMemoryStreamCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\Characteristics.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\DllCharacteristics.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\IImageOptionalHeader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageDataDirectory.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageDebugDirectory.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageDebugType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageDosHeader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageFileHeader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageNTHeaders.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageOptionalHeader32.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageOptionalHeader64.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\ImageSectionHeader.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\IPEImage.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\IPEType.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\Machine.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\PEExtensions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\PEImage.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\PEInfo.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\RVA.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)PE\Subsystem.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Settings.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Threading\Extensions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Threading\ICancellationToken.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Threading\IThreadSafeList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Threading\Lock.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Threading\ThreadSafeListCreator.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Threading\ThreadSafeListWrapper.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Utils\Extensions.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Utils\ILazyList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Utils\LazyList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Utils\MFunc.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Utils\SimpleLazyList.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)Utils\UserValue.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)W32Resources\ResourceData.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)W32Resources\ResourceDirectory.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)W32Resources\ResourceDirectoryEntry.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)W32Resources\ResourceName.cs" />
    <Compile Include="$(MSBuildThisFileDirectory)W32Resources\Win32Resources.cs" />
  </ItemGroup>
</Project>


================================================
File: Libraries/dnlib/dnlib.Shared/dnlib.Shared.shproj
================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Label="Globals">
    <ProjectGuid>9e1fee5b-49a3-4c7f-b3c2-389e40108bf2</ProjectGuid>
    <MinimumVisualStudioVersion>14.0</MinimumVisualStudioVersion>
  </PropertyGroup>
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeSharing\Microsoft.CodeSharing.Common.Default.props" />
  <Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeSharing\Microsoft.CodeSharing.Common.props" />
  <PropertyGroup />
  <Import Project="dnlib.Shared.projitems" Label="Shared" />
  <Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeSharing\Microsoft.CodeSharing.CSharp.targets" />
</Project>



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AllTypesHelper.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Returns types without getting stuck in an infinite loop
	/// </summary>
	public struct AllTypesHelper {
		/// <summary>
		/// Gets a list of all types and nested types
		/// </summary>
		/// <param name="types">A list of types</param>
		public static IEnumerable<TypeDef> Types(IEnumerable<TypeDef> types) {
			var visited = new Dictionary<TypeDef, bool>();
			var stack = new Stack<IEnumerator<TypeDef>>();
			if (types != null)
				stack.Push(types.GetSafeEnumerable().GetEnumerator());
			while (stack.Count > 0) {
				var enumerator = stack.Pop();
				while (enumerator.MoveNext()) {
					var type = enumerator.Current;
					if (visited.ContainsKey(type))
						continue;
					visited[type] = true;
					yield return type;
					if (type.NestedTypes.Count > 0) {
						stack.Push(enumerator);
						enumerator = type.NestedTypes.GetSafeEnumerable().GetEnumerator();
					}
				}
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AssemblyAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Assembly flags from Assembly.Flags column.
	/// </summary>
	/// <remarks>See CorHdr.h/CorAssemblyFlags</remarks>
	[Flags]
	public enum AssemblyAttributes : uint {
		/// <summary>No flags set</summary>
		None						= 0,

		/// <summary>The assembly ref holds the full (unhashed) public key.</summary>
		PublicKey					= 1,

		/// <summary>Processor Architecture unspecified</summary>
		PA_None						= 0x0000,
		/// <summary>Processor Architecture: neutral (PE32)</summary>
		PA_MSIL						= 0x0010,
		/// <summary>Processor Architecture: x86 (PE32)</summary>
		PA_x86						= 0x0020,
		/// <summary>Processor Architecture: Itanium (PE32+)</summary>
		PA_IA64						= 0x0030,
		/// <summary>Processor Architecture: AMD X64 (PE32+)</summary>
		PA_AMD64					= 0x0040,
		/// <summary>Processor Architecture: ARM (PE32)</summary>
		PA_ARM						= 0x0050,
		/// <summary>applies to any platform but cannot run on any (e.g. reference assembly), should not have "specified" set</summary>
		PA_NoPlatform				= 0x0070,
		/// <summary>Propagate PA flags to AssemblyRef record</summary>
		PA_Specified				= 0x0080,
		/// <summary>Bits describing the processor architecture</summary>
		PA_Mask						= 0x0070,
		/// <summary>Bits describing the PA incl. Specified</summary>
		PA_FullMask					= 0x00F0,
		/// <summary>NOT A FLAG, shift count in PA flags &lt;--&gt; index conversion</summary>
		PA_Shift					= 0x0004,

		/// <summary>From "DebuggableAttribute".</summary>
		EnableJITcompileTracking	= 0x8000,
		/// <summary>From "DebuggableAttribute".</summary>
		DisableJITcompileOptimizer	= 0x4000,

		/// <summary>The assembly can be retargeted (at runtime) to an assembly from a different publisher.</summary>
		Retargetable				= 0x0100,

		/// <summary/>
		ContentType_Default			= 0x0000,
		/// <summary/>
		ContentType_WindowsRuntime	= 0x0200,
		/// <summary>Bits describing ContentType</summary>
		ContentType_Mask			= 0x0E00,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AssemblyDef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using System.Reflection;
using System.Threading;
using dnlib.Utils;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;
using dnlib.Threading;
using System.Text.RegularExpressions;
using dnlib.DotNet.Pdb;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Assembly table
	/// </summary>
	public abstract class AssemblyDef : IHasCustomAttribute, IHasDeclSecurity, IHasCustomDebugInformation, IAssembly, IListListener<ModuleDef>, ITypeDefFinder, IDnlibDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.Assembly, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 14; }
		}

		/// <inheritdoc/>
		public int HasDeclSecurityTag {
			get { return 2; }
		}

		/// <summary>
		/// From column Assembly.HashAlgId
		/// </summary>
		public AssemblyHashAlgorithm HashAlgorithm {
			get { return hashAlgorithm; }
			set { hashAlgorithm = value; }
		}
		/// <summary/>
		protected AssemblyHashAlgorithm hashAlgorithm;

		/// <summary>
		/// From columns Assembly.MajorVersion, Assembly.MinorVersion, Assembly.BuildNumber,
		/// Assembly.RevisionNumber.
		/// </summary>
		/// <exception cref="ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
		public Version Version {
			get { return version; }
			set {
				if (value == null)
					throw new ArgumentNullException("value");
				version = value;
			}
		}
		/// <summary/>
		protected Version version;

		/// <summary>
		/// From column Assembly.Flags
		/// </summary>
		public AssemblyAttributes Attributes {
			get { return (AssemblyAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Assembly.PublicKey
		/// </summary>
		/// <remarks>An empty <see cref="PublicKey"/> is created if the caller writes <c>null</c></remarks>
		public PublicKey PublicKey {
			get { return publicKey; }
			set { publicKey = value ?? new PublicKey(); }
		}
		/// <summary/>
		protected PublicKey publicKey;

		/// <summary>
		/// Gets the public key token which is calculated from <see cref="PublicKey"/>
		/// </summary>
		public PublicKeyToken PublicKeyToken {
			get { return publicKey.Token; }
		}

		/// <summary>
		/// From column Assembly.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Assembly.Locale
		/// </summary>
		public UTF8String Culture {
			get { return culture; }
			set { culture = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String culture;

		/// <inheritdoc/>
		public ThreadSafe.IList<DeclSecurity> DeclSecurities {
			get {
				if (declSecurities == null)
					InitializeDeclSecurities();
				return declSecurities;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<DeclSecurity> declSecurities;
		/// <summary>Initializes <see cref="declSecurities"/></summary>
		protected virtual void InitializeDeclSecurities() {
			Interlocked.CompareExchange(ref declSecurities, ThreadSafeListCreator.Create<DeclSecurity>(), null);
		}

		/// <inheritdoc/>
		public PublicKeyBase PublicKeyOrToken {
			get { return publicKey; }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return GetFullNameWithPublicKeyToken(); }
		}

		/// <inheritdoc/>
		public string FullNameToken {
			get { return GetFullNameWithPublicKeyToken(); }
		}

		/// <summary>
		/// Gets all modules. The first module is always the <see cref="ManifestModule"/>.
		/// </summary>
		public ThreadSafe.IList<ModuleDef> Modules {
			get {
				if (modules == null)
					InitializeModules();
				return modules;
			}
		}
		/// <summary/>
		protected LazyList<ModuleDef> modules;
		/// <summary>Initializes <see cref="modules"/></summary>
		protected virtual void InitializeModules() {
			Interlocked.CompareExchange(ref modules, new LazyList<ModuleDef>(this), null);
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}


		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 14; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}
		/// <inheritdoc/>
		public bool HasDeclSecurities {
			get { return DeclSecurities.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Modules"/> is not empty
		/// </summary>
		public bool HasModules {
			get { return Modules.Count > 0; }
		}

		/// <summary>
		/// Gets the manifest (main) module. This is always the first module in <see cref="Modules"/>.
		/// <c>null</c> is returned if <see cref="Modules"/> is empty.
		/// </summary>
		public ModuleDef ManifestModule {
			get { return Modules.Get(0, null); }
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(AssemblyAttributes andMask, AssemblyAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, AssemblyAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PublicKey"/> bit
		/// </summary>
		public bool HasPublicKey {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PublicKey) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.PublicKey); }
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitecture {
			get { return (AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask; }
			set { ModifyAttributes(~AssemblyAttributes.PA_Mask, value & AssemblyAttributes.PA_Mask); }
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitectureFull {
			get { return (AssemblyAttributes)attributes & AssemblyAttributes.PA_FullMask; }
			set { ModifyAttributes(~AssemblyAttributes.PA_FullMask, value & AssemblyAttributes.PA_FullMask); }
		}

		/// <summary>
		/// <c>true</c> if unspecified processor architecture
		/// </summary>
		public bool IsProcessorArchitectureNone {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_None; }
		}

		/// <summary>
		/// <c>true</c> if neutral (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureMSIL {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_MSIL; }
		}

		/// <summary>
		/// <c>true</c> if x86 (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureX86 {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_x86; }
		}

		/// <summary>
		/// <c>true</c> if IA-64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureIA64 {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_IA64; }
		}

		/// <summary>
		/// <c>true</c> if x64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureX64 {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_AMD64; }
		}

		/// <summary>
		/// <c>true</c> if ARM (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureARM {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_ARM; }
		}

		/// <summary>
		/// <c>true</c> if eg. reference assembly (not runnable)
		/// </summary>
		public bool IsProcessorArchitectureNoPlatform {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_NoPlatform; }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PA_Specified"/> bit
		/// </summary>
		public bool IsProcessorArchitectureSpecified {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Specified) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.PA_Specified); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.EnableJITcompileTracking"/> bit
		/// </summary>
		public bool EnableJITcompileTracking {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.EnableJITcompileTracking) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.EnableJITcompileTracking); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.DisableJITcompileOptimizer"/> bit
		/// </summary>
		public bool DisableJITcompileOptimizer {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.DisableJITcompileOptimizer) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.DisableJITcompileOptimizer); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.Retargetable"/> bit
		/// </summary>
		public bool IsRetargetable {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.Retargetable) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.Retargetable); }
		}

		/// <summary>
		/// Gets/sets the content type
		/// </summary>
		public AssemblyAttributes ContentType {
			get { return (AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask; }
			set { ModifyAttributes(~AssemblyAttributes.ContentType_Mask, value & AssemblyAttributes.ContentType_Mask); }
		}

		/// <summary>
		/// <c>true</c> if content type is <c>Default</c>
		/// </summary>
		public bool IsContentTypeDefault {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_Default; }
		}

		/// <summary>
		/// <c>true</c> if content type is <c>WindowsRuntime</c>
		/// </summary>
		public bool IsContentTypeWindowsRuntime {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_WindowsRuntime; }
		}

		/// <summary>
		/// Finds a module in this assembly
		/// </summary>
		/// <param name="name">Name of module</param>
		/// <returns>A <see cref="ModuleDef"/> instance or <c>null</c> if it wasn't found.</returns>
		public ModuleDef FindModule(UTF8String name) {
			foreach (var module in Modules.GetSafeEnumerable()) {
				if (module == null)
					continue;
				if (UTF8String.CaseInsensitiveEquals(module.Name, name))
					return module;
			}
			return null;
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a file
		/// </summary>
		/// <param name="fileName">File name of an existing .NET assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="fileName"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(string fileName, ModuleContext context) {
			return Load(fileName, new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a file
		/// </summary>
		/// <param name="fileName">File name of an existing .NET assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="fileName"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(string fileName, ModuleCreationOptions options = null) {
			if (fileName == null)
				throw new ArgumentNullException("fileName");
			ModuleDef module = null;
			try {
				module = ModuleDefMD.Load(fileName, options);
				var asm = module.Assembly;
				if (asm == null)
					throw new BadImageFormatException(string.Format("{0} is only a .NET module, not a .NET assembly. Use ModuleDef.Load().", fileName));
				return asm;
			}
			catch {
				if (module != null)
					module.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a byte[]
		/// </summary>
		/// <param name="data">Contents of a .NET assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="data"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(byte[] data, ModuleContext context) {
			return Load(data, new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a byte[]
		/// </summary>
		/// <param name="data">Contents of a .NET assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="data"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(byte[] data, ModuleCreationOptions options = null) {
			if (data == null)
				throw new ArgumentNullException("data");
			ModuleDef module = null;
			try {
				module = ModuleDefMD.Load(data, options);
				var asm = module.Assembly;
				if (asm == null)
					throw new BadImageFormatException(string.Format("{0} is only a .NET module, not a .NET assembly. Use ModuleDef.Load().", module.ToString()));
				return asm;
			}
			catch {
				if (module != null)
					module.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="addr"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(IntPtr addr, ModuleContext context) {
			return Load(addr, new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="addr"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(IntPtr addr, ModuleCreationOptions options = null) {
			if (addr == IntPtr.Zero)
				throw new ArgumentNullException("addr");
			ModuleDef module = null;
			try {
				module = ModuleDefMD.Load(addr, options);
				var asm = module.Assembly;
				if (asm == null)
					throw new BadImageFormatException(string.Format("{0} (addr: {1:X8}) is only a .NET module, not a .NET assembly. Use ModuleDef.Load().", module.ToString(), addr.ToInt64()));
				return asm;
			}
			catch {
				if (module != null)
					module.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleContext)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(Stream stream, ModuleContext context) {
			return Load(stream, new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleContext)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(Stream stream, ModuleCreationOptions options = null) {
			if (stream == null)
				throw new ArgumentNullException("stream");
			ModuleDef module = null;
			try {
				module = ModuleDefMD.Load(stream, options);
				var asm = module.Assembly;
				if (asm == null)
					throw new BadImageFormatException(string.Format("{0} is only a .NET module, not a .NET assembly. Use ModuleDef.Load().", module.ToString()));
				return asm;
			}
			catch {
				if (module != null)
					module.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Gets the assembly name with the public key
		/// </summary>
		public string GetFullNameWithPublicKey() {
			return GetFullName(publicKey);
		}

		/// <summary>
		/// Gets the assembly name with the public key token
		/// </summary>
		public string GetFullNameWithPublicKeyToken() {
			return GetFullName(publicKey.Token);
		}

		string GetFullName(PublicKeyBase pkBase) {
			return Utils.GetAssemblyNameString(name, version, culture, pkBase, Attributes);
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. For speed, enable <see cref="ModuleDef.EnableTypeDefFindCache"/>
		/// if possible (read the documentation first).
		/// </summary>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public TypeDef Find(string fullName, bool isReflectionName) {
			foreach (var module in Modules.GetSafeEnumerable()) {
				if (module == null)
					continue;
				var type = module.Find(fullName, isReflectionName);
				if (type != null)
					return type;
			}
			return null;
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
		/// looking up the type. For speed, enable <see cref="ModuleDef.EnableTypeDefFindCache"/>
		/// if possible (read the documentation first).
		/// </summary>
		/// <param name="typeRef">The type ref</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public TypeDef Find(TypeRef typeRef) {
			foreach (var module in Modules.GetSafeEnumerable()) {
				if (module == null)
					continue;
				var type = module.Find(typeRef);
				if (type != null)
					return type;
			}
			return null;
		}

		/// <summary>
		/// Writes the assembly to a file on disk. If the file exists, it will be truncated.
		/// </summary>
		/// <param name="filename">Filename</param>
		/// <param name="options">Writer options</param>
		public void Write(string filename, ModuleWriterOptions options = null) {
			ManifestModule.Write(filename, options);
		}

		/// <summary>
		/// Writes the assembly to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		/// <param name="options">Writer options</param>
		public void Write(Stream dest, ModuleWriterOptions options = null) {
			ManifestModule.Write(dest, options);
		}

		/// <summary>
		/// Checks whether this assembly is a friend assembly of <paramref name="targetAsm"/>
		/// </summary>
		/// <param name="targetAsm">Target assembly</param>
		public bool IsFriendAssemblyOf(AssemblyDef targetAsm) {
			if (targetAsm == null)
				return false;
			if (this == targetAsm)
				return true;

			// Both must be unsigned or both must be signed according to the
			// InternalsVisibleToAttribute documentation.
			if (PublicKeyBase.IsNullOrEmpty2(publicKey) != PublicKeyBase.IsNullOrEmpty2(targetAsm.PublicKey))
				return false;

			foreach (var ca in targetAsm.CustomAttributes.FindAll("System.Runtime.CompilerServices.InternalsVisibleToAttribute")) {
				if (ca.ConstructorArguments.Count != 1)
					continue;
				var arg = ca.ConstructorArguments.Get(0, default(CAArgument));
				if (arg.Type.GetElementType() != ElementType.String)
					continue;
				var asmName = arg.Value as UTF8String;
				if (UTF8String.IsNull(asmName))
					continue;

				var asmInfo = new AssemblyNameInfo(asmName);
				if (asmInfo.Name != name)
					continue;
				if (!PublicKeyBase.IsNullOrEmpty2(publicKey)) {
					if (!PublicKey.Equals(asmInfo.PublicKeyOrToken as PublicKey))
						continue;
				}
				else if (!PublicKeyBase.IsNullOrEmpty2(asmInfo.PublicKeyOrToken))
					continue;

				return true;
			}

			return false;
		}

		/// <summary>
		/// Adds or updates an existing <c>System.Reflection.AssemblySignatureKeyAttribute</c>
		/// attribute. This attribute is used in enhanced strong naming with key migration.
		/// See http://msdn.microsoft.com/en-us/library/hh415055.aspx
		/// </summary>
		/// <param name="identityPubKey">Identity public key</param>
		/// <param name="identityKey">Identity strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		public void UpdateOrCreateAssemblySignatureKeyAttribute(StrongNamePublicKey identityPubKey, StrongNameKey identityKey, StrongNamePublicKey signaturePubKey) {
			var manifestModule = ManifestModule;
			if (manifestModule == null)
				return;

			// Remove all existing attributes
			var ca = CustomAttributes.ExecuteLocked<CustomAttribute, object, CustomAttribute>(null, (tsList, arg) => {
				CustomAttribute foundCa = null;
				for (int i = 0; i < tsList.Count_NoLock(); i++) {
					var caTmp = tsList.Get_NoLock(i);
					if (caTmp.TypeFullName != "System.Reflection.AssemblySignatureKeyAttribute")
						continue;
					tsList.RemoveAt_NoLock(i);
					i--;
					if (foundCa == null)
						foundCa = caTmp;
				}
				return foundCa;
			});

			if (IsValidAssemblySignatureKeyAttribute(ca))
				ca.NamedArguments.Clear();
			else
				ca = CreateAssemblySignatureKeyAttribute();

			var counterSig = StrongNameKey.CreateCounterSignatureAsString(identityPubKey, identityKey, signaturePubKey);
			ca.ConstructorArguments[0] = new CAArgument(manifestModule.CorLibTypes.String, new UTF8String(signaturePubKey.ToString()));
			ca.ConstructorArguments[1] = new CAArgument(manifestModule.CorLibTypes.String, new UTF8String(counterSig));
			CustomAttributes.Add(ca);
		}

		bool IsValidAssemblySignatureKeyAttribute(CustomAttribute ca) {
#if THREAD_SAFE
			return false;
#else
			if (ca == null)
				return false;
			var ctor = ca.Constructor;
			if (ctor == null)
				return false;
			var sig = ctor.MethodSig;
			if (sig == null || sig.Params.Count != 2)
				return false;
			if (sig.Params[0].GetElementType() != ElementType.String)
				return false;
			if (sig.Params[1].GetElementType() != ElementType.String)
				return false;
			if (ca.ConstructorArguments.Count != 2)
				return false;
			return true;
#endif
		}

		CustomAttribute CreateAssemblySignatureKeyAttribute() {
			var manifestModule = ManifestModule;
			var owner = manifestModule.UpdateRowId(new TypeRefUser(manifestModule, "System.Reflection", "AssemblySignatureKeyAttribute", manifestModule.CorLibTypes.AssemblyRef));
			var methodSig = MethodSig.CreateInstance(manifestModule.CorLibTypes.Void, manifestModule.CorLibTypes.String, manifestModule.CorLibTypes.String);
			var ctor = manifestModule.UpdateRowId(new MemberRefUser(manifestModule, MethodDef.InstanceConstructorName, methodSig, owner));
			var ca = new CustomAttribute(ctor);
			ca.ConstructorArguments.Add(new CAArgument(manifestModule.CorLibTypes.String, UTF8String.Empty));
			ca.ConstructorArguments.Add(new CAArgument(manifestModule.CorLibTypes.String, UTF8String.Empty));
			return ca;
		}

		/// <summary>
		/// Gets the original <c>System.Runtime.Versioning.TargetFrameworkAttribute</c> custom attribute information if possible.
		/// It reads this from the original metadata and doesn't use <see cref="CustomAttributes"/>.
		/// Returns false if the custom attribute isn't present or if it is invalid.
		/// </summary>
		/// <param name="framework">Framework name</param>
		/// <param name="version">Version</param>
		/// <param name="profile">Profile</param>
		/// <returns></returns>
		public virtual bool TryGetOriginalTargetFrameworkAttribute(out string framework, out Version version, out string profile) {
			framework = null;
			version = null;
			profile = null;
			return false;
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnLazyAdd(int index, ref ModuleDef module) {
			if (module == null)
				return;
#if DEBUG
			if (module.Assembly == null)
				throw new InvalidOperationException("Module.Assembly == null");
#endif
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnAdd(int index, ModuleDef module) {
			if (module == null)
				return;
			if (module.Assembly != null)
				throw new InvalidOperationException("Module already has an assembly. Remove it from that assembly before adding it to this assembly.");
			module.Assembly = this;
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnRemove(int index, ModuleDef module) {
			if (module != null)
				module.Assembly = null;
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnClear() {
			foreach (var module in Modules.GetEnumerable_NoLock()) {
				if (module != null)
					module.Assembly = null;
			}
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// An Assembly row created by the user and not present in the original .NET file
	/// </summary>
	public class AssemblyDefUser : AssemblyDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyDefUser()
			: this(UTF8String.Empty, new Version(0, 0, 0, 0)) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyDefUser(UTF8String name)
			: this(name, new Version(0, 0, 0, 0), new PublicKey()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyDefUser(UTF8String name, Version version)
			: this(name, version, new PublicKey()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <param name="publicKey">Public key</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyDefUser(UTF8String name, Version version, PublicKey publicKey)
			: this(name, version, publicKey, UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <param name="publicKey">Public key</param>
		/// <param name="locale">Locale</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyDefUser(UTF8String name, Version version, PublicKey publicKey, UTF8String locale) {
			if ((object)name == null)
				throw new ArgumentNullException("name");
			if (version == null)
				throw new ArgumentNullException("version");
			if ((object)locale == null)
				throw new ArgumentNullException("locale");
			this.modules = new LazyList<ModuleDef>(this);
			this.name = name;
			this.version = version;
			this.publicKey = publicKey ?? new PublicKey();
			this.culture = locale;
			this.attributes = (int)AssemblyAttributes.None;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmName">Assembly name info</param>
		/// <exception cref="ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
		public AssemblyDefUser(AssemblyName asmName)
			: this(new AssemblyNameInfo(asmName)) {
			this.hashAlgorithm = (AssemblyHashAlgorithm)asmName.HashAlgorithm;
			this.attributes = (int)asmName.Flags;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmName">Assembly name info</param>
		/// <exception cref="ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
		public AssemblyDefUser(IAssembly asmName) {
			if (asmName == null)
				throw new ArgumentNullException("asmName");
			this.modules = new LazyList<ModuleDef>(this);
			this.name = asmName.Name;
			this.version = asmName.Version ?? new Version(0, 0, 0, 0);
			this.publicKey = asmName.PublicKeyOrToken as PublicKey ?? new PublicKey();
			this.culture = asmName.Culture;
			this.attributes = (int)AssemblyAttributes.None;
			this.hashAlgorithm = AssemblyHashAlgorithm.SHA1;
		}
	}

	/// <summary>
	/// Created from a row in the Assembly table
	/// </summary>
	sealed class AssemblyDefMD : AssemblyDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeDeclSecurities() {
			var list = readerModule.MetaData.GetDeclSecurityRidList(Table.Assembly, origRid);
			var tmp = new LazyList<DeclSecurity>((int)list.Length, list, (list2, index) => readerModule.ResolveDeclSecurity(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref declSecurities, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeModules() {
			var list = readerModule.GetModuleRidList();
			var tmp = new LazyList<ModuleDef>((int)list.Length + 1, this, list, (list2, index) => {
				ModuleDef module;
				if (index == 0)
					module = readerModule;
				else
					module = readerModule.ReadModule(((RidList)list2)[index - 1], this);
				if (module == null)
					module = new ModuleDefUser("INVALID", Guid.NewGuid());
				module.Assembly = this;
				return module;
			});
			Interlocked.CompareExchange(ref modules, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.Assembly, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		public override bool TryGetOriginalTargetFrameworkAttribute(out string framework, out Version version, out string profile) {
			if (!hasInitdTFA)
				InitializeTargetFrameworkAttribute();
			framework = tfaFramework;
			version = tfaVersion;
			profile = tfaProfile;
			return tfaReturnValue;
		}
		volatile bool hasInitdTFA;
		string tfaFramework;
		Version tfaVersion;
		string tfaProfile;
		bool tfaReturnValue;

		void InitializeTargetFrameworkAttribute() {
			if (hasInitdTFA)
				return;

			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.Assembly, origRid);
			var gpContext = new GenericParamContext();
			for (int i = 0; i < list.Count; i++) {
				var caRid = list[i];
				var caRow = readerModule.TablesStream.ReadCustomAttributeRow(caRid);
				if (caRow == null)
					continue;
				var caType = readerModule.ResolveCustomAttributeType(caRow.Type, gpContext);
				UTF8String ns, name;
				if (!TryGetName(caType, out ns, out name))
					continue;
				if (ns != nameSystemRuntimeVersioning || name != nameTargetFrameworkAttribute)
					continue;
				var ca = CustomAttributeReader.Read(readerModule, caType, caRow.Value, gpContext);
				if (ca == null || ca.ConstructorArguments.Count != 1)
					continue;
				var s = ca.ConstructorArguments[0].Value as UTF8String;
				if ((object)s == null)
					continue;
				string tmpFramework, tmpProfile;
				Version tmpVersion;
				if (TryCreateTargetFrameworkInfo(s, out tmpFramework, out tmpVersion, out tmpProfile)) {
					tfaFramework = tmpFramework;
					tfaVersion = tmpVersion;
					tfaProfile = tmpProfile;
					tfaReturnValue = true;
					break;
				}
			}

			hasInitdTFA = true;
		}
		static readonly UTF8String nameSystemRuntimeVersioning = new UTF8String("System.Runtime.Versioning");
		static readonly UTF8String nameTargetFrameworkAttribute = new UTF8String("TargetFrameworkAttribute");

		static bool TryGetName(ICustomAttributeType caType, out UTF8String ns, out UTF8String name) {
			ITypeDefOrRef type;
			var mr = caType as MemberRef;
			if (mr != null)
				type = mr.DeclaringType;
			else {
				var md = caType as MethodDef;
				type = md == null ? null : md.DeclaringType;
			}
			var tr = type as TypeRef;
			if (tr != null) {
				ns = tr.Namespace;
				name = tr.Name;
				return true;
			}
			var td = type as TypeDef;
			if (td != null) {
				ns = td.Namespace;
				name = td.Name;
				return true;
			}
			ns = null;
			name = null;
			return false;
		}

		static bool TryCreateTargetFrameworkInfo(string attrString, out string framework, out Version version, out string profile) {
			framework = null;
			version = null;
			profile = null;

			// See corclr/src/mscorlib/src/System/Runtime/Versioning/BinaryCompatibility.cs
			var values = attrString.Split(new char[] { ',' });
			if (values.Length < 2 || values.Length > 3)
				return false;
			var frameworkRes = values[0].Trim();
			if (frameworkRes.Length == 0)
				return false;

			Version versionRes = null;
			string profileRes = null;
			for (int i = 1; i < values.Length; i++) {
				var kvp = values[i].Split('=');
				if (kvp.Length != 2)
					return false;

				var key = kvp[0].Trim();
				var value = kvp[1].Trim();

				if (key.Equals("Version", StringComparison.OrdinalIgnoreCase)) {
					if (value.StartsWith("v", StringComparison.OrdinalIgnoreCase))
						value = value.Substring(1);
					if (!TryParse(value, out versionRes))
						return false;
					versionRes = new Version(versionRes.Major, versionRes.Minor, versionRes.Build == -1 ? 0 : versionRes.Build, 0);
				}
				else if (key.Equals("Profile", StringComparison.OrdinalIgnoreCase)) {
					if (!string.IsNullOrEmpty(value))
						profileRes = value;
				}
			}
			if (versionRes == null)
				return false;

			framework = frameworkRes;
			version = versionRes;
			profile = profileRes;
			return true;
		}

		static int ParseInt32(string s) {
			int res;
			return int.TryParse(s, out res) ? res : 0;
		}

		static bool TryParse(string s, out Version version) {
			Match m;

			m = Regex.Match(s, @"^(\d+)\.(\d+)$");
			if (m.Groups.Count == 3) {
				version = new Version(ParseInt32(m.Groups[1].Value), ParseInt32(m.Groups[2].Value));
				return true;
			}

			m = Regex.Match(s, @"^(\d+)\.(\d+)\.(\d+)$");
			if (m.Groups.Count == 4) {
				version = new Version(ParseInt32(m.Groups[1].Value), ParseInt32(m.Groups[2].Value), ParseInt32(m.Groups[3].Value));
				return true;
			}

			m = Regex.Match(s, @"^(\d+)\.(\d+)\.(\d+)\.(\d+)$");
			if (m.Groups.Count == 5) {
				version = new Version(ParseInt32(m.Groups[1].Value), ParseInt32(m.Groups[2].Value), ParseInt32(m.Groups[3].Value), ParseInt32(m.Groups[4].Value));
				return true;
			}

			version = null;
			return false;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Assembly</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public AssemblyDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.AssemblyTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("Assembly rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			if (rid != 1)
				this.modules = new LazyList<ModuleDef>(this);
			uint publicKey, name;
			uint culture = readerModule.TablesStream.ReadAssemblyRow(origRid, out this.hashAlgorithm, out this.version, out this.attributes, out publicKey, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.culture = readerModule.StringsStream.ReadNoNull(culture);
			this.publicKey = new PublicKey(readerModule.BlobStream.Read(publicKey));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AssemblyHash.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.IO;
using System.Security.Cryptography;

namespace dnlib.DotNet {
	/// <summary>
	/// Hashes some data according to a <see cref="AssemblyHashAlgorithm"/>
	/// </summary>
	struct AssemblyHash : IDisposable {
		readonly HashAlgorithm hasher;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>If <paramref name="hashAlgo"/> is an unsupported hash algorithm, then
		/// <see cref="AssemblyHashAlgorithm.SHA1"/> will be used as the hash algorithm.</remarks>
		/// <param name="hashAlgo">The algorithm to use</param>
		public AssemblyHash(AssemblyHashAlgorithm hashAlgo) {
			switch (hashAlgo) {
			case AssemblyHashAlgorithm.MD5:
				hasher = MD5.Create();
				break;

			case AssemblyHashAlgorithm.None:
			case AssemblyHashAlgorithm.MD2:
			case AssemblyHashAlgorithm.MD4:
			case AssemblyHashAlgorithm.SHA1:
			case AssemblyHashAlgorithm.MAC:
			case AssemblyHashAlgorithm.SSL3_SHAMD5:
			case AssemblyHashAlgorithm.HMAC:
			case AssemblyHashAlgorithm.TLS1PRF:
			case AssemblyHashAlgorithm.HASH_REPLACE_OWF:
			default:
				hasher = SHA1.Create();
				break;

			case AssemblyHashAlgorithm.SHA_256:
				hasher = SHA256.Create();
				break;

			case AssemblyHashAlgorithm.SHA_384:
				hasher = SHA384.Create();
				break;

			case AssemblyHashAlgorithm.SHA_512:
				hasher = SHA512.Create();
				break;
			}
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (hasher != null)
				((IDisposable)hasher).Dispose();
		}

		/// <summary>
		/// Hash data
		/// </summary>
		/// <remarks>If <paramref name="hashAlgo"/> is an unsupported hash algorithm, then
		/// <see cref="AssemblyHashAlgorithm.SHA1"/> will be used as the hash algorithm.</remarks>
		/// <param name="data">The data</param>
		/// <param name="hashAlgo">The algorithm to use</param>
		/// <returns>Hashed data or null if <paramref name="data"/> was <c>null</c></returns>
		public static byte[] Hash(byte[] data, AssemblyHashAlgorithm hashAlgo) {
			if (data == null)
				return null;

			using (var asmHash = new AssemblyHash(hashAlgo)) {
				asmHash.Hash(data);
				return asmHash.ComputeHash();
			}
		}

		/// <summary>
		/// Hash data
		/// </summary>
		/// <param name="data">Data</param>
		public void Hash(byte[] data) {
			Hash(data, 0, data.Length);
		}

		/// <summary>
		/// Hash data
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="offset">Offset</param>
		/// <param name="length">Length</param>
		public void Hash(byte[] data, int offset, int length) {
			if (hasher.TransformBlock(data, offset, length, data, offset) != length)
				throw new IOException("Could not calculate hash");
		}

		/// <summary>
		/// Hash stream data
		/// </summary>
		/// <param name="stream">Stream</param>
		/// <param name="length">Number of bytes to hash</param>
		/// <param name="buffer">Temp buffer</param>
		public void Hash(Stream stream, uint length, byte[] buffer) {
			while (length > 0) {
				int len = length > (uint)buffer.Length ? buffer.Length : (int)length;
				if (stream.Read(buffer, 0, len) != len)
					throw new IOException("Could not read data");
				Hash(buffer, 0, len);
				length -= (uint)len;
			}
		}

		/// <summary>
		/// Computes the hash
		/// </summary>
		public byte[] ComputeHash() {
			hasher.TransformFinalBlock(new byte[0], 0, 0);
			return hasher.Hash;
		}

		/// <summary>
		/// Creates a public key token from the hash of some <paramref name="publicKeyData"/>
		/// </summary>
		/// <remarks>A public key is hashed, and the last 8 bytes of the hash, in reverse
		/// order, is used as the public key token</remarks>
		/// <param name="publicKeyData">The data</param>
		/// <returns>A new <see cref="PublicKeyToken"/> instance</returns>
		public static PublicKeyToken CreatePublicKeyToken(byte[] publicKeyData) {
			if (publicKeyData == null)
				return new PublicKeyToken();
			var hash = Hash(publicKeyData, AssemblyHashAlgorithm.SHA1);
			byte[] pkt = new byte[8];
			for (int i = 0; i < pkt.Length && i < hash.Length; i++)
				pkt[i] = hash[hash.Length - i - 1];
			return new PublicKeyToken(pkt);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AssemblyHashAlgorithm.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Any ALG_CLASS_HASH type in WinCrypt.h can be used by Microsoft's CLI implementation
	/// </summary>
	public enum AssemblyHashAlgorithm : uint {
		/// <summary/>
		None				= 0,
		/// <summary/>
		MD2					= 0x8001,
		/// <summary/>
		MD4					= 0x8002,
		/// <summary>This is a reserved value in the CLI</summary>
		MD5					= 0x8003,
		/// <summary>The only algorithm supported by the CLI</summary>
		SHA1				= 0x8004,
		/// <summary/>
		MAC					= 0x8005,
		/// <summary/>
		SSL3_SHAMD5			= 0x8008,
		/// <summary/>
		HMAC				= 0x8009,
		/// <summary/>
		TLS1PRF				= 0x800A,
		/// <summary/>
		HASH_REPLACE_OWF	= 0x800B,
		/// <summary/>
		SHA_256				= 0x800C,
		/// <summary/>
		SHA_384				= 0x800D,
		/// <summary/>
		SHA_512				= 0x800E,
	}

	public static partial class Extensions {
		internal static string GetName(this AssemblyHashAlgorithm hashAlg) {
			switch (hashAlg) {
			case AssemblyHashAlgorithm.MD2:		return null;
			case AssemblyHashAlgorithm.MD4:		return null;
			case AssemblyHashAlgorithm.MD5:		return "MD5";
			case AssemblyHashAlgorithm.SHA1:	return "SHA1";
			case AssemblyHashAlgorithm.MAC:		return null;
			case AssemblyHashAlgorithm.SSL3_SHAMD5: return null;
			case AssemblyHashAlgorithm.HMAC:	return null;
			case AssemblyHashAlgorithm.TLS1PRF:	return null;
			case AssemblyHashAlgorithm.HASH_REPLACE_OWF: return null;
			case AssemblyHashAlgorithm.SHA_256:	return "SHA256";
			case AssemblyHashAlgorithm.SHA_384:	return "SHA384";
			case AssemblyHashAlgorithm.SHA_512:	return "SHA512";
			default: return null;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AssemblyNameComparer.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;

namespace dnlib.DotNet {
	/// <summary>
	/// Flags used by <see cref="AssemblyNameComparer"/>
	/// </summary>
	[Flags]
	public enum AssemblyNameComparerFlags {
		/// <summary>
		/// Compare assembly simple name
		/// </summary>
		Name = 1,

		/// <summary>
		/// Compare assembly version
		/// </summary>
		Version = 2,

		/// <summary>
		/// Compare assembly public key token
		/// </summary>
		PublicKeyToken = 4,

		/// <summary>
		/// Compare assembly culture
		/// </summary>
		Culture = 8,

		/// <summary>
		/// Compare content type
		/// </summary>
		ContentType = 0x10,

		/// <summary>
		/// Compare assembly simple name, version, public key token, locale and content type
		/// </summary>
		All = Name | Version | PublicKeyToken | Culture | ContentType,
	}

	/// <summary>
	/// Compares two assembly names
	/// </summary>
	public struct AssemblyNameComparer : IEqualityComparer<IAssembly> {
		/// <summary>
		/// Compares the name, version, public key token, culture and content type
		/// </summary>
		public static AssemblyNameComparer CompareAll = new AssemblyNameComparer(AssemblyNameComparerFlags.All);

		/// <summary>
		/// Compares only the name and the public key token
		/// </summary>
		public static AssemblyNameComparer NameAndPublicKeyTokenOnly = new AssemblyNameComparer(AssemblyNameComparerFlags.Name | AssemblyNameComparerFlags.PublicKeyToken);

		/// <summary>
		/// Compares only the name
		/// </summary>
		public static AssemblyNameComparer NameOnly = new AssemblyNameComparer(AssemblyNameComparerFlags.Name);

		readonly AssemblyNameComparerFlags flags;

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.Name"/> bit
		/// </summary>
		public bool CompareName {
			get { return (flags & AssemblyNameComparerFlags.Name) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.Version"/> bit
		/// </summary>
		public bool CompareVersion {
			get { return (flags & AssemblyNameComparerFlags.Version) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.PublicKeyToken"/> bit
		/// </summary>
		public bool ComparePublicKeyToken {
			get { return (flags & AssemblyNameComparerFlags.PublicKeyToken) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.Culture"/> bit
		/// </summary>
		public bool CompareCulture {
			get { return (flags & AssemblyNameComparerFlags.Culture) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.ContentType"/> bit
		/// </summary>
		public bool CompareContentType {
			get { return (flags & AssemblyNameComparerFlags.ContentType) != 0; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Comparison flags</param>
		public AssemblyNameComparer(AssemblyNameComparerFlags flags) {
			this.flags = flags;
		}

		/// <summary>
		/// Compares two assembly names
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public int CompareTo(IAssembly a, IAssembly b) {
			if (a == b)
				return 0;
			if (a == null)
				return -1;
			if (b == null)
				return 1;

			int v;

			if (CompareName && (v = UTF8String.CaseInsensitiveCompareTo(a.Name, b.Name)) != 0)
				return v;
			if (CompareVersion && (v = Utils.CompareTo(a.Version, b.Version)) != 0)
				return v;
			if (ComparePublicKeyToken && (v = PublicKeyBase.TokenCompareTo(a.PublicKeyOrToken, b.PublicKeyOrToken)) != 0)
				return v;
			if (CompareCulture && (v = Utils.LocaleCompareTo(a.Culture, b.Culture)) != 0)
				return v;
			if (CompareContentType && (v = a.ContentType.CompareTo(b.ContentType)) != 0)
				return v;

			return 0;
		}

		/// <summary>
		/// Compares two assembly names
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if equal, <c>false</c> otherwise</returns>
		public bool Equals(IAssembly a, IAssembly b) {
			return CompareTo(a, b) == 0;
		}

		/// <summary>
		/// Figures out which of two assembly names is closer to another assembly name
		/// </summary>
		/// <param name="requested">Requested assembly name</param>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>-1 if both are equally close, 0 if <paramref name="a"/> is closest, 1 if
		/// <paramref name="b"/> is closest</returns>
		public int CompareClosest(IAssembly requested, IAssembly a, IAssembly b) {
			if (a == b)
				return 0;
			if (a == null)
				return !CompareName ? 1 : UTF8String.CaseInsensitiveEquals(requested.Name, b.Name) ? 1 : 0;
			if (b == null)
				return !CompareName ? 0 : UTF8String.CaseInsensitiveEquals(requested.Name, a.Name) ? 0 : 1;

			// Compare the most important parts first:
			//	1. Assembly simple name
			//	2. Public key token
			//	3. Version
			//	4. Locale
			//	5. Content type

			if (CompareName) {
				// If the name only matches one of a or b, return that one.
				bool na = UTF8String.CaseInsensitiveEquals(requested.Name, a.Name);
				bool nb = UTF8String.CaseInsensitiveEquals(requested.Name, b.Name);
				if (na && !nb)
					return 0;
				if (!na && nb)
					return 1;
				if (!na && !nb)
					return -1;
			}

			if (ComparePublicKeyToken) {
				bool pa, pb;
				if (PublicKeyBase.IsNullOrEmpty2(requested.PublicKeyOrToken)) {
					// If one of them has a pkt but the other one hasn't, return the one with
					// no pkt.
					pa = PublicKeyBase.IsNullOrEmpty2(a.PublicKeyOrToken);
					pb = PublicKeyBase.IsNullOrEmpty2(b.PublicKeyOrToken);
				}
				else {
					// If one of them has the correct pkt, but the other one has an incorrect
					// pkt, return the one with the correct pkt.
					pa = PublicKeyBase.TokenEquals(requested.PublicKeyOrToken, a.PublicKeyOrToken);
					pb = PublicKeyBase.TokenEquals(requested.PublicKeyOrToken, b.PublicKeyOrToken);
				}
				if (pa && !pb)
					return 0;
				if (!pa && pb)
					return 1;
			}

			if (CompareVersion && !Utils.Equals(a.Version, b.Version)) {
				var rv = Utils.CreateVersionWithNoUndefinedValues(requested.Version);
				if (rv == new Version(0, 0, 0, 0))
					rv = new Version(ushort.MaxValue, ushort.MaxValue, ushort.MaxValue, ushort.MaxValue);
				int va = Utils.CompareTo(a.Version, rv);
				int vb = Utils.CompareTo(b.Version, rv);
				if (va == 0)
					return 0;	// vb != 0 so return 0
				if (vb == 0)
					return 1;	// va != 0 so return 1
				if (va > 0 && vb < 0)
					return 0;
				if (va < 0 && vb > 0)
					return 1;
				// Now either both a and b's version > req version or both are < req version
				if (va > 0) {
					// a.Version and b.Version > req.Version. Pick the one that is closest.
					return Utils.CompareTo(a.Version, b.Version) < 0 ? 0 : 1;
				}
				else {
					// a.Version and b.Version < req.Version. Pick the one that is closest.
					return Utils.CompareTo(a.Version, b.Version) > 0 ? 0 : 1;
				}
			}

			if (CompareCulture) {
				bool la = Utils.LocaleEquals(requested.Culture, a.Culture);
				bool lb = Utils.LocaleEquals(requested.Culture, b.Culture);
				if (la && !lb)
					return 0;
				if (!la && lb)
					return 1;
			}

			if (CompareContentType) {
				bool ca = requested.ContentType == a.ContentType;
				bool cb = requested.ContentType == b.ContentType;
				if (ca && !cb)
					return 0;
				if (!ca && cb)
					return 1;
			}

			return -1;
		}

		/// <summary>
		/// Gets the hash code of an assembly name
		/// </summary>
		/// <param name="a">Assembly name</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IAssembly a) {
			if (a == null)
				return 0;

			int hash = 0;

			if (CompareName)
				hash += UTF8String.GetHashCode(a.Name);
			if (CompareVersion)
				hash += Utils.CreateVersionWithNoUndefinedValues(a.Version).GetHashCode();
			if (ComparePublicKeyToken)
				hash += PublicKeyBase.GetHashCodeToken(a.PublicKeyOrToken);
			if (CompareCulture)
				hash += Utils.GetHashCodeLocale(a.Culture);
			if (CompareContentType)
				hash += (int)a.ContentType;

			return hash;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AssemblyNameInfo.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Reflection;

namespace dnlib.DotNet {
	/// <summary>
	/// Stores assembly name information
	/// </summary>
	public sealed class AssemblyNameInfo : IAssembly {
		AssemblyHashAlgorithm hashAlgId;
		Version version;
		AssemblyAttributes flags;
		PublicKeyBase publicKeyOrToken;
		UTF8String name;
		UTF8String culture;

		/// <summary>
		/// Gets/sets the <see cref="AssemblyHashAlgorithm"/>
		/// </summary>
		public AssemblyHashAlgorithm HashAlgId {
			get { return hashAlgId; }
			set { hashAlgId = value; }
		}

		/// <summary>
		/// Gets/sets the <see cref="Version"/> or <c>null</c> if none specified
		/// </summary>
		public Version Version {
			get { return version; }
			set { version = value; }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes"/>
		/// </summary>
		public AssemblyAttributes Attributes {
			get { return flags; }
			set { flags = value; }
		}

		/// <summary>
		/// Gets/sets the public key or token
		/// </summary>
		public PublicKeyBase PublicKeyOrToken {
			get { return publicKeyOrToken; }
			set { publicKeyOrToken = value; }
		}

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}

		/// <summary>
		/// Gets/sets the culture or <c>null</c> if none specified
		/// </summary>
		public UTF8String Culture {
			get { return culture; }
			set { culture = value; }
		}

		/// <summary>
		/// Gets the full name of the assembly
		/// </summary>
		public string FullName {
			get { return FullNameToken; }
		}

		/// <summary>
		/// Gets the full name of the assembly but use a public key token
		/// </summary>
		public string FullNameToken {
			get {
				var pk = publicKeyOrToken;
				if (pk is PublicKey)
					pk = (pk as PublicKey).Token;
				return Utils.GetAssemblyNameString(name, version, culture, pk, flags);
			}
		}

		/// <summary>
		/// Modify <see cref="Attributes"/> property: <see cref="Attributes"/> =
		/// (<see cref="Attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(AssemblyAttributes andMask, AssemblyAttributes orMask) {
			Attributes = (Attributes & andMask) | orMask;
		}

		/// <summary>
		/// Set or clear flags in <see cref="Attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, AssemblyAttributes flags) {
			if (set)
				Attributes |= flags;
			else
				Attributes &= ~flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PublicKey"/> bit
		/// </summary>
		public bool HasPublicKey {
			get { return (Attributes & AssemblyAttributes.PublicKey) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.PublicKey); }
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitecture {
			get { return Attributes & AssemblyAttributes.PA_Mask; }
			set { ModifyAttributes(~AssemblyAttributes.PA_Mask, value & AssemblyAttributes.PA_Mask); }
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitectureFull {
			get { return Attributes & AssemblyAttributes.PA_FullMask; }
			set { ModifyAttributes(~AssemblyAttributes.PA_FullMask, value & AssemblyAttributes.PA_FullMask); }
		}

		/// <summary>
		/// <c>true</c> if unspecified processor architecture
		/// </summary>
		public bool IsProcessorArchitectureNone {
			get { return (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_None; }
		}

		/// <summary>
		/// <c>true</c> if neutral (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureMSIL {
			get { return (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_MSIL; }
		}

		/// <summary>
		/// <c>true</c> if x86 (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureX86 {
			get { return (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_x86; }
		}

		/// <summary>
		/// <c>true</c> if IA-64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureIA64 {
			get { return (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_IA64; }
		}

		/// <summary>
		/// <c>true</c> if x64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureX64 {
			get { return (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_AMD64; }
		}

		/// <summary>
		/// <c>true</c> if ARM (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureARM {
			get { return (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_ARM; }
		}

		/// <summary>
		/// <c>true</c> if eg. reference assembly (not runnable)
		/// </summary>
		public bool IsProcessorArchitectureNoPlatform {
			get { return (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_NoPlatform; }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PA_Specified"/> bit
		/// </summary>
		public bool IsProcessorArchitectureSpecified {
			get { return (Attributes & AssemblyAttributes.PA_Specified) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.PA_Specified); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.EnableJITcompileTracking"/> bit
		/// </summary>
		public bool EnableJITcompileTracking {
			get { return (Attributes & AssemblyAttributes.EnableJITcompileTracking) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.EnableJITcompileTracking); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.DisableJITcompileOptimizer"/> bit
		/// </summary>
		public bool DisableJITcompileOptimizer {
			get { return (Attributes & AssemblyAttributes.DisableJITcompileOptimizer) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.DisableJITcompileOptimizer); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.Retargetable"/> bit
		/// </summary>
		public bool IsRetargetable {
			get { return (Attributes & AssemblyAttributes.Retargetable) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.Retargetable); }
		}

		/// <summary>
		/// Gets/sets the content type
		/// </summary>
		public AssemblyAttributes ContentType {
			get { return Attributes & AssemblyAttributes.ContentType_Mask; }
			set { ModifyAttributes(~AssemblyAttributes.ContentType_Mask, value & AssemblyAttributes.ContentType_Mask); }
		}

		/// <summary>
		/// <c>true</c> if content type is <c>Default</c>
		/// </summary>
		public bool IsContentTypeDefault {
			get { return (Attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_Default; }
		}

		/// <summary>
		/// <c>true</c> if content type is <c>WindowsRuntime</c>
		/// </summary>
		public bool IsContentTypeWindowsRuntime {
			get { return (Attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_WindowsRuntime; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyNameInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmFullName">An assembly name</param>
		public AssemblyNameInfo(string asmFullName)
			: this(ReflectionTypeNameParser.ParseAssemblyRef(asmFullName)) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asm">The assembly</param>
		public AssemblyNameInfo(IAssembly asm) {
			if (asm == null)
				return;
			var asmDef = asm as AssemblyDef;
			this.hashAlgId = asmDef == null ? 0 : asmDef.HashAlgorithm;
			this.version = asm.Version ?? new Version(0, 0, 0, 0);
			this.flags = asm.Attributes;
			this.publicKeyOrToken = asm.PublicKeyOrToken;
			this.name = UTF8String.IsNullOrEmpty(asm.Name) ? UTF8String.Empty : asm.Name;
			this.culture = UTF8String.IsNullOrEmpty(asm.Culture) ? UTF8String.Empty : asm.Culture;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmName">Assembly name info</param>
		public AssemblyNameInfo(AssemblyName asmName) {
			if (asmName == null)
				return;
			this.hashAlgId = (AssemblyHashAlgorithm)asmName.HashAlgorithm;
			this.version = asmName.Version ?? new Version(0, 0, 0, 0);
			this.flags = (AssemblyAttributes)asmName.Flags;
			this.publicKeyOrToken = (PublicKeyBase)PublicKeyBase.CreatePublicKey(asmName.GetPublicKey()) ??
							PublicKeyBase.CreatePublicKeyToken(asmName.GetPublicKeyToken());
			this.name = asmName.Name ?? string.Empty;
			this.culture = asmName.CultureInfo != null && asmName.CultureInfo.Name != null ? asmName.CultureInfo.Name : string.Empty;
		}

		/// <inhertidoc/>
		public override string ToString() {
			return FullName;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AssemblyRef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Reflection;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the AssemblyRef table
	/// </summary>
	public abstract class AssemblyRef : IHasCustomAttribute, IImplementation, IResolutionScope, IHasCustomDebugInformation, IAssembly, IScope {
		/// <summary>
		/// An assembly ref that can be used to indicate that it references the current assembly
		/// when the current assembly is not known (eg. a type string without any assembly info
		/// when it references a type in the current assembly).
		/// </summary>
		public static readonly AssemblyRef CurrentAssembly = new AssemblyRefUser("<<<CURRENT_ASSEMBLY>>>");

		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.AssemblyRef, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 15; }
		}

		/// <inheritdoc/>
		public int ImplementationTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public int ResolutionScopeTag {
			get { return 2; }
		}

		/// <inheritdoc/>
		public ScopeType ScopeType {
			get { return ScopeType.AssemblyRef; }
		}

		/// <inheritdoc/>
		public string ScopeName {
			get { return FullName; }
		}

		/// <summary>
		/// From columns AssemblyRef.MajorVersion, AssemblyRef.MinorVersion,
		/// AssemblyRef.BuildNumber, AssemblyRef.RevisionNumber
		/// </summary>
		/// <exception cref="ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
		public Version Version {
			get { return version; }
			set {
				if (value == null)
					throw new ArgumentNullException("value");
				version = value;
			}
		}
		/// <summary/>
		protected Version version;

		/// <summary>
		/// From column AssemblyRef.Flags
		/// </summary>
		public AssemblyAttributes Attributes {
			get { return (AssemblyAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column AssemblyRef.PublicKeyOrToken
		/// </summary>
		/// <exception cref="ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
		public PublicKeyBase PublicKeyOrToken {
			get { return publicKeyOrToken; }
			set {
				if (value == null)
					throw new ArgumentNullException("value");
				publicKeyOrToken = value;
			}
		}
		/// <summary/>
		protected PublicKeyBase publicKeyOrToken;

		/// <summary>
		/// From column AssemblyRef.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column AssemblyRef.Locale
		/// </summary>
		public UTF8String Culture {
			get { return culture; }
			set { culture = value; }
		}
		/// <summary>Culture</summary>
		protected UTF8String culture;

		/// <summary>
		/// From column AssemblyRef.HashValue
		/// </summary>
		public byte[] Hash {
			get { return hashValue; }
			set { hashValue = value; }
		}
		/// <summary/>
		protected byte[] hashValue;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 15; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <inheritdoc/>
		public string FullName {
			get { return FullNameToken; }
		}

		/// <summary>
		/// Same as <see cref="FullName"/>, except that it uses the <c>PublicKey</c> if available.
		/// </summary>
		public string RealFullName {
			get { return Utils.GetAssemblyNameString(name, version, culture, publicKeyOrToken, Attributes); }
		}

		/// <summary>
		/// Gets the full name of the assembly but use a public key token
		/// </summary>
		public string FullNameToken {
			get { return Utils.GetAssemblyNameString(name, version, culture, PublicKeyBase.ToPublicKeyToken(publicKeyOrToken), Attributes); }
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(AssemblyAttributes andMask, AssemblyAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, AssemblyAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PublicKey"/> bit
		/// </summary>
		public bool HasPublicKey {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PublicKey) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.PublicKey); }
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitecture {
			get { return (AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask; }
			set { ModifyAttributes(~AssemblyAttributes.PA_Mask, value & AssemblyAttributes.PA_Mask); }
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitectureFull {
			get { return (AssemblyAttributes)attributes & AssemblyAttributes.PA_FullMask; }
			set { ModifyAttributes(~AssemblyAttributes.PA_FullMask, value & AssemblyAttributes.PA_FullMask); }
		}

		/// <summary>
		/// <c>true</c> if unspecified processor architecture
		/// </summary>
		public bool IsProcessorArchitectureNone {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_None; }
		}

		/// <summary>
		/// <c>true</c> if neutral (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureMSIL {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_MSIL; }
		}

		/// <summary>
		/// <c>true</c> if x86 (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureX86 {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_x86; }
		}

		/// <summary>
		/// <c>true</c> if IA-64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureIA64 {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_IA64; }
		}

		/// <summary>
		/// <c>true</c> if x64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureX64 {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_AMD64; }
		}

		/// <summary>
		/// <c>true</c> if ARM (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureARM {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_ARM; }
		}

		/// <summary>
		/// <c>true</c> if eg. reference assembly (not runnable)
		/// </summary>
		public bool IsProcessorArchitectureNoPlatform {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_NoPlatform; }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PA_Specified"/> bit
		/// </summary>
		public bool IsProcessorArchitectureSpecified {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Specified) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.PA_Specified); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.EnableJITcompileTracking"/> bit
		/// </summary>
		public bool EnableJITcompileTracking {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.EnableJITcompileTracking) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.EnableJITcompileTracking); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.DisableJITcompileOptimizer"/> bit
		/// </summary>
		public bool DisableJITcompileOptimizer {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.DisableJITcompileOptimizer) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.DisableJITcompileOptimizer); }
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.Retargetable"/> bit
		/// </summary>
		public bool IsRetargetable {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.Retargetable) != 0; }
			set { ModifyAttributes(value, AssemblyAttributes.Retargetable); }
		}

		/// <summary>
		/// Gets/sets the content type
		/// </summary>
		public AssemblyAttributes ContentType {
			get { return (AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask; }
			set { ModifyAttributes(~AssemblyAttributes.ContentType_Mask, value & AssemblyAttributes.ContentType_Mask); }
		}

		/// <summary>
		/// <c>true</c> if content type is <c>Default</c>
		/// </summary>
		public bool IsContentTypeDefault {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_Default; }
		}

		/// <summary>
		/// <c>true</c> if content type is <c>WindowsRuntime</c>
		/// </summary>
		public bool IsContentTypeWindowsRuntime {
			get { return ((AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_WindowsRuntime; }
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// An AssemblyRef row created by the user and not present in the original .NET file
	/// </summary>
	public class AssemblyRefUser : AssemblyRef {
		/// <summary>
		/// Creates a reference to CLR 1.0's mscorlib
		/// </summary>
		public static AssemblyRefUser CreateMscorlibReferenceCLR10() {
			return new AssemblyRefUser("mscorlib", new Version(1, 0, 3300, 0), new PublicKeyToken("b77a5c561934e089"));
		}

		/// <summary>
		/// Creates a reference to CLR 1.1's mscorlib
		/// </summary>
		public static AssemblyRefUser CreateMscorlibReferenceCLR11() {
			return new AssemblyRefUser("mscorlib", new Version(1, 0, 5000, 0), new PublicKeyToken("b77a5c561934e089"));
		}

		/// <summary>
		/// Creates a reference to CLR 2.0's mscorlib
		/// </summary>
		public static AssemblyRefUser CreateMscorlibReferenceCLR20() {
			return new AssemblyRefUser("mscorlib", new Version(2, 0, 0, 0), new PublicKeyToken("b77a5c561934e089"));
		}

		/// <summary>
		/// Creates a reference to CLR 4.0's mscorlib
		/// </summary>
		public static AssemblyRefUser CreateMscorlibReferenceCLR40() {
			return new AssemblyRefUser("mscorlib", new Version(4, 0, 0, 0), new PublicKeyToken("b77a5c561934e089"));
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyRefUser()
			: this(UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyRefUser(UTF8String name)
			: this(name, new Version(0, 0, 0, 0)) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyRefUser(UTF8String name, Version version)
			: this(name, version, new PublicKey()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <param name="publicKey">Public key or public key token</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyRefUser(UTF8String name, Version version, PublicKeyBase publicKey)
			: this(name, version, publicKey, UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <param name="publicKey">Public key or public key token</param>
		/// <param name="locale">Locale</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyRefUser(UTF8String name, Version version, PublicKeyBase publicKey, UTF8String locale) {
			if ((object)name == null)
				throw new ArgumentNullException("name");
			if (version == null)
				throw new ArgumentNullException("version");
			if ((object)locale == null)
				throw new ArgumentNullException("locale");
			this.name = name;
			this.version = version;
			this.publicKeyOrToken = publicKey;
			this.culture = locale;
			this.attributes = (int)(publicKey is PublicKey ? AssemblyAttributes.PublicKey : AssemblyAttributes.None);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmName">Assembly name info</param>
		/// <exception cref="ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
		public AssemblyRefUser(AssemblyName asmName)
			: this(new AssemblyNameInfo(asmName)) {
			this.attributes = (int)asmName.Flags;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="assembly">Assembly</param>
		public AssemblyRefUser(IAssembly assembly) {
			if (assembly == null)
				throw new ArgumentNullException("asmName");

			this.version = assembly.Version ?? new Version(0, 0, 0, 0);
			this.publicKeyOrToken = assembly.PublicKeyOrToken;
			this.name = UTF8String.IsNullOrEmpty(assembly.Name) ? UTF8String.Empty : assembly.Name;
			this.culture = assembly.Culture;
			this.attributes = (int)((publicKeyOrToken is PublicKey ? AssemblyAttributes.PublicKey : AssemblyAttributes.None) | assembly.ContentType);
		}
	}

	/// <summary>
	/// Created from a row in the AssemblyRef table
	/// </summary>
	sealed class AssemblyRefMD : AssemblyRef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.AssemblyRef, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>AssemblyRef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public AssemblyRefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.AssemblyRefTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("AssemblyRef rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint publicKeyOrToken, name, culture;
			uint hashValue = readerModule.TablesStream.ReadAssemblyRefRow(origRid, out this.version, out this.attributes, out publicKeyOrToken, out name, out culture);
			var pkData = readerModule.BlobStream.Read(publicKeyOrToken);
			if ((this.attributes & (uint)AssemblyAttributes.PublicKey) != 0)
				this.publicKeyOrToken = new PublicKey(pkData);
			else
				this.publicKeyOrToken = new PublicKeyToken(pkData);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.culture = readerModule.StringsStream.ReadNoNull(culture);
			this.hashValue = readerModule.BlobStream.Read(hashValue);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/AssemblyResolver.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// Resolves assemblies
	/// </summary>
	public class AssemblyResolver : IAssemblyResolver {
		static readonly ModuleDef nullModule = new ModuleDefUser();

		// DLL files are searched before EXE files
		static readonly string[] assemblyExtensions = new string[] { ".dll", ".exe" };
		static readonly string[] winMDAssemblyExtensions = new string[] { ".winmd" };

		static readonly List<GacInfo> gacInfos;
		static readonly string[] extraMonoPaths;
		static readonly string[] monoVerDirs = new string[] {
			// The "-api" dirs are reference assembly dirs.
			"4.5", @"4.5\Facades", "4.5-api", @"4.5-api\Facades", "4.0", "4.0-api",
			"3.5", "3.5-api", "3.0", "3.0-api", "2.0", "2.0-api",
			"1.1", "1.0",
		};

		ModuleContext defaultModuleContext;
		readonly Dictionary<ModuleDef, IList<string>> moduleSearchPaths = new Dictionary<ModuleDef, IList<string>>();
		readonly Dictionary<string, AssemblyDef> cachedAssemblies = new Dictionary<string, AssemblyDef>(StringComparer.Ordinal);
		readonly ThreadSafe.IList<string> preSearchPaths = ThreadSafeListCreator.Create<string>();
		readonly ThreadSafe.IList<string> postSearchPaths = ThreadSafeListCreator.Create<string>();
		bool findExactMatch;
		bool enableFrameworkRedirect;
		bool enableTypeDefCache = true;
		bool useGac = true;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		sealed class GacInfo {
			public readonly int Version;
			public readonly string Path;
			public readonly string Prefix;
			public readonly IList<string> SubDirs;

			public GacInfo(int version, string prefix, string path, IList<string> subDirs) {
				this.Version = version;
				this.Prefix = prefix;
				this.Path = path;
				this.SubDirs = subDirs;
			}
		}

		static AssemblyResolver() {
			gacInfos = new List<GacInfo>();

			if (Type.GetType("Mono.Runtime") != null) {
				var dirs = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
				var extraMonoPathsList = new List<string>();
				foreach (var prefix in FindMonoPrefixes()) {
					var dir = Path.Combine(Path.Combine(Path.Combine(prefix, "lib"), "mono"), "gac");
					if (dirs.ContainsKey(dir))
						continue;
					dirs[dir] = true;

					if (Directory.Exists(dir)) {
						gacInfos.Add(new GacInfo(-1, "", Path.GetDirectoryName(dir), new string[] {
							Path.GetFileName(dir)
						}));
					}

					dir = Path.GetDirectoryName(dir);
					foreach (var verDir in monoVerDirs) {
						var dir2 = dir;
						foreach (var d in verDir.Split(new char[] { '\\' }))
							dir2 = Path.Combine(dir2, d);
						if (Directory.Exists(dir2))
							extraMonoPathsList.Add(dir2);
					}
				}

				var paths = Environment.GetEnvironmentVariable("MONO_PATH");
				if (paths != null) {
					foreach (var tmp in paths.Split(Path.PathSeparator)) {
						var path = tmp.Trim();
						if (path != string.Empty && Directory.Exists(path))
							extraMonoPathsList.Add(path);
					}
				}
				extraMonoPaths = extraMonoPathsList.ToArray();
			}
			else {
				var windir = Environment.GetEnvironmentVariable("WINDIR");
				if (!string.IsNullOrEmpty(windir)) {
					string path;

					// .NET 1.x and 2.x
					path = Path.Combine(windir, "assembly");
					if (Directory.Exists(path)) {
						gacInfos.Add(new GacInfo(2, "", path, new string[] {
							"GAC_32", "GAC_64", "GAC_MSIL", "GAC"
						}));
					}

					// .NET 4.x
					path = Path.Combine(Path.Combine(windir, "Microsoft.NET"), "assembly");
					if (Directory.Exists(path)) {
						gacInfos.Add(new GacInfo(4, "v4.0_", path, new string[] {
							"GAC_32", "GAC_64", "GAC_MSIL"
						}));
					}
				}
			}
		}

		static string GetCurrentMonoPrefix() {
			var path = typeof(object).Module.FullyQualifiedName;
			for (int i = 0; i < 4; i++)
				path = Path.GetDirectoryName(path);
			return path;
		}

		static IEnumerable<string> FindMonoPrefixes() {
			yield return GetCurrentMonoPrefix();

			var prefixes = Environment.GetEnvironmentVariable("MONO_GAC_PREFIX");
			if (!string.IsNullOrEmpty(prefixes)) {
				foreach (var tmp in prefixes.Split(Path.PathSeparator)) {
					var prefix = tmp.Trim();
					if (prefix != string.Empty)
						yield return prefix;
				}
			}
		}

		/// <summary>
		/// Gets/sets the default <see cref="ModuleContext"/>
		/// </summary>
		public ModuleContext DefaultModuleContext {
			get { return defaultModuleContext; }
			set { defaultModuleContext = value; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Resolve"/> should find an assembly that matches exactly.
		/// <c>false</c> if it first tries to match exactly, and if that fails, it picks an
		/// assembly that is closest to the requested assembly.
		/// </summary>
		public bool FindExactMatch {
			get { return findExactMatch; }
			set { findExactMatch = value; }
		}

		/// <summary>
		/// <c>true</c> if resolved .NET framework assemblies can be redirected to the source
		/// module's framework assembly version. Eg. if a resolved .NET 3.5 assembly can be
		/// redirected to a .NET 4.0 assembly if the source module is a .NET 4.0 assembly. This is
		/// ignored if <see cref="FindExactMatch"/> is <c>true</c>.
		/// </summary>
		public bool EnableFrameworkRedirect {
			get { return enableFrameworkRedirect; }
			set { enableFrameworkRedirect = value; }
		}

		/// <summary>
		/// If <c>true</c>, all modules in newly resolved assemblies will have their
		/// <see cref="ModuleDef.EnableTypeDefFindCache"/> property set to <c>true</c>. This is
		/// enabled by default since these modules shouldn't be modified by the user.
		/// </summary>
		public bool EnableTypeDefCache {
			get { return enableTypeDefCache; }
			set { enableTypeDefCache = value; }
		}

		/// <summary>
		/// true to search the Global Assembly Cache. Default value is true.
		/// </summary>
		public bool UseGAC {
			get { return useGac; }
			set { useGac = value; }
		}

		/// <summary>
		/// Gets paths searched before trying the standard locations
		/// </summary>
		public ThreadSafe.IList<string> PreSearchPaths {
			get { return preSearchPaths; }
		}

		/// <summary>
		/// Gets paths searched after trying the standard locations
		/// </summary>
		public ThreadSafe.IList<string> PostSearchPaths {
			get { return postSearchPaths; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyResolver()
			: this(null, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="defaultModuleContext">Module context for all resolved assemblies</param>
		public AssemblyResolver(ModuleContext defaultModuleContext)
			: this(defaultModuleContext, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="defaultModuleContext">Module context for all resolved assemblies</param>
		/// <param name="addOtherSearchPaths">If <c>true</c>, add other common assembly search
		/// paths, not just the module search paths and the GAC.</param>
		public AssemblyResolver(ModuleContext defaultModuleContext, bool addOtherSearchPaths) {
			this.defaultModuleContext = defaultModuleContext;
			this.enableFrameworkRedirect = true;
			if (addOtherSearchPaths)
				AddOtherSearchPaths(postSearchPaths);
		}

		/// <inheritdoc/>
		public AssemblyDef Resolve(IAssembly assembly, ModuleDef sourceModule) {
			if (assembly == null)
				return null;

			if (EnableFrameworkRedirect && !FindExactMatch)
				FrameworkRedirect.ApplyFrameworkRedirect(ref assembly, sourceModule);

#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			AssemblyDef resolvedAssembly = Resolve2(assembly, sourceModule);
			if (resolvedAssembly == null) {
				string asmName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
				string asmNameTrimmed = asmName.Trim();
				if (asmName != asmNameTrimmed) {
					assembly = new AssemblyNameInfo {
						Name = asmNameTrimmed,
						Version = assembly.Version,
						PublicKeyOrToken = assembly.PublicKeyOrToken,
						Culture = assembly.Culture,
					};
					resolvedAssembly = Resolve2(assembly, sourceModule);
				}
			}

			if (resolvedAssembly == null) {
				// Make sure we don't search for this assembly again. This speeds up callers who
				// keep asking for this assembly when trying to resolve many different TypeRefs
				cachedAssemblies[GetAssemblyNameKey(assembly)] = null;
				return null;
			}

			var key1 = GetAssemblyNameKey(resolvedAssembly);
			var key2 = GetAssemblyNameKey(assembly);
			AssemblyDef asm1, asm2;
			cachedAssemblies.TryGetValue(key1, out asm1);
			cachedAssemblies.TryGetValue(key2, out asm2);

			if (asm1 != resolvedAssembly && asm2 != resolvedAssembly) {
				// This assembly was just resolved
				if (enableTypeDefCache) {
					foreach (var module in resolvedAssembly.Modules.GetSafeEnumerable()) {
						if (module != null)
							module.EnableTypeDefFindCache = true;
					}
				}
			}

			bool inserted = false;
			if (!cachedAssemblies.ContainsKey(key1)) {
				cachedAssemblies.Add(key1, resolvedAssembly);
				inserted = true;
			}
			if (!cachedAssemblies.ContainsKey(key2)) {
				cachedAssemblies.Add(key2, resolvedAssembly);
				inserted = true;
			}
			if (inserted || asm1 == resolvedAssembly || asm2 == resolvedAssembly)
				return resolvedAssembly;

			// Dupe assembly. Don't insert it.
			var dupeModule = resolvedAssembly.ManifestModule;
			if (dupeModule != null)
				dupeModule.Dispose();
			return asm1 ?? asm2;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public bool AddToCache(AssemblyDef asm) {
			if (asm == null)
				return false;
			var asmKey = GetAssemblyNameKey(asm);
			AssemblyDef cachedAsm;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (cachedAssemblies.TryGetValue(asmKey, out cachedAsm) && cachedAsm != null)
				return asm == cachedAsm;
			cachedAssemblies[asmKey] = asm;
			return true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public bool Remove(AssemblyDef asm) {
			if (asm == null)
				return false;
			var asmKey = GetAssemblyNameKey(asm);
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return cachedAssemblies.Remove(asmKey);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public void Clear() {
			List<AssemblyDef> asms;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			asms = new List<AssemblyDef>(cachedAssemblies.Values);
			cachedAssemblies.Clear();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			foreach (var asm in asms) {
				if (asm == null)
					continue;
				foreach (var mod in asm.Modules.GetSafeEnumerable())
					mod.Dispose();
			}
		}

		static string GetAssemblyNameKey(IAssembly asmName) {
			// Make sure the name contains PublicKeyToken= and not PublicKey=
			return asmName.FullNameToken.ToUpperInvariant();
		}

		AssemblyDef Resolve2(IAssembly assembly, ModuleDef sourceModule) {
			AssemblyDef resolvedAssembly;

			if (cachedAssemblies.TryGetValue(GetAssemblyNameKey(assembly), out resolvedAssembly))
				return resolvedAssembly;

			var moduleContext = defaultModuleContext;
			if (moduleContext == null && sourceModule != null)
				moduleContext = sourceModule.Context;

			resolvedAssembly = FindExactAssembly(assembly, PreFindAssemblies(assembly, sourceModule, true), moduleContext) ??
					FindExactAssembly(assembly, FindAssemblies(assembly, sourceModule, true), moduleContext) ??
					FindExactAssembly(assembly, PostFindAssemblies(assembly, sourceModule, true), moduleContext);
			if (resolvedAssembly != null)
				return resolvedAssembly;

			if (!findExactMatch) {
				resolvedAssembly = FindClosestAssembly(assembly);
				resolvedAssembly = FindClosestAssembly(assembly, resolvedAssembly, PreFindAssemblies(assembly, sourceModule, false), moduleContext);
				resolvedAssembly = FindClosestAssembly(assembly, resolvedAssembly, FindAssemblies(assembly, sourceModule, false), moduleContext);
				resolvedAssembly = FindClosestAssembly(assembly, resolvedAssembly, PostFindAssemblies(assembly, sourceModule, false), moduleContext);
			}

			return resolvedAssembly;
		}

		/// <summary>
		/// Finds an assembly that exactly matches the requested assembly
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <param name="paths">Search paths or <c>null</c> if none</param>
		/// <param name="moduleContext">Module context</param>
		/// <returns>An <see cref="AssemblyDef"/> instance or <c>null</c> if an exact match
		/// couldn't be found.</returns>
		AssemblyDef FindExactAssembly(IAssembly assembly, IEnumerable<string> paths, ModuleContext moduleContext) {
			if (paths == null)
				return null;
			var asmComparer = AssemblyNameComparer.CompareAll;
			foreach (var path in paths.GetSafeEnumerable()) {
				ModuleDefMD mod = null;
				try {
					mod = ModuleDefMD.Load(path, moduleContext);
					var asm = mod.Assembly;
					if (asm != null && asmComparer.Equals(assembly, asm)) {
						mod = null;
						return asm;
					}
				}
				catch {
				}
				finally {
					if (mod != null)
						mod.Dispose();
				}
			}
			return null;
		}

		/// <summary>
		/// Finds the closest assembly from the already cached assemblies
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <returns>The closest <see cref="AssemblyDef"/> or <c>null</c> if none found</returns>
		AssemblyDef FindClosestAssembly(IAssembly assembly) {
			AssemblyDef closest = null;
			var asmComparer = AssemblyNameComparer.CompareAll;
			foreach (var asm in cachedAssemblies.Values) {
				if (asm == null)
					continue;
				if (asmComparer.CompareClosest(assembly, closest, asm) == 1)
					closest = asm;
			}
			return closest;
		}

		AssemblyDef FindClosestAssembly(IAssembly assembly, AssemblyDef closest, IEnumerable<string> paths, ModuleContext moduleContext) {
			if (paths == null)
				return closest;
			var asmComparer = AssemblyNameComparer.CompareAll;
			foreach (var path in paths.GetSafeEnumerable()) {
				ModuleDefMD mod = null;
				try {
					mod = ModuleDefMD.Load(path, moduleContext);
					var asm = mod.Assembly;
					if (asm != null && asmComparer.CompareClosest(assembly, closest, asm) == 1) {
						if (!IsCached(closest) && closest != null) {
							var closeMod = closest.ManifestModule;
							if (closeMod != null)
								closeMod.Dispose();
						}
						closest = asm;
						mod = null;
					}
				}
				catch {
				}
				finally {
					if (mod != null)
						mod.Dispose();
				}
			}

			return closest;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="asm"/> is inserted in <see cref="cachedAssemblies"/>
		/// </summary>
		/// <param name="asm">Assembly to check</param>
		bool IsCached(AssemblyDef asm) {
			if (asm == null)
				return false;
			AssemblyDef cachedAsm;
			return cachedAssemblies.TryGetValue(GetAssemblyNameKey(asm), out cachedAsm) &&
					cachedAsm == asm;
		}

		IEnumerable<string> FindAssemblies2(IAssembly assembly, IEnumerable<string> paths) {
			if (paths != null) {
				var asmSimpleName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
				var exts = assembly.IsContentTypeWindowsRuntime ? winMDAssemblyExtensions : assemblyExtensions;
				foreach (var ext in exts) {
					foreach (var path in paths.GetSafeEnumerable()) {
						var fullPath = Path.Combine(path, asmSimpleName + ext);
						if (File.Exists(fullPath))
							yield return fullPath;
					}
				}
			}
		}

		/// <summary>
		/// Called before <see cref="FindAssemblies"/>
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <param name="matchExactly">We're trying to find an exact match</param>
		/// <returns><c>null</c> or an enumerable of full paths to try</returns>
		protected virtual IEnumerable<string> PreFindAssemblies(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			foreach (var path in FindAssemblies2(assembly, preSearchPaths))
				yield return path;
		}

		/// <summary>
		/// Called after <see cref="FindAssemblies"/> (if it fails)
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <param name="matchExactly">We're trying to find an exact match</param>
		/// <returns><c>null</c> or an enumerable of full paths to try</returns>
		protected virtual IEnumerable<string> PostFindAssemblies(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			foreach (var path in FindAssemblies2(assembly, postSearchPaths))
				yield return path;
		}

		/// <summary>
		/// Called after <see cref="PreFindAssemblies"/> (if it fails)
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <param name="matchExactly">We're trying to find an exact match</param>
		/// <returns><c>null</c> or an enumerable of full paths to try</returns>
		protected virtual IEnumerable<string> FindAssemblies(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			if (assembly.IsContentTypeWindowsRuntime) {
				var path = Path.Combine(Path.Combine(Environment.SystemDirectory, "WinMetadata"), assembly.Name + ".winmd");
				if (File.Exists(path))
					yield return path;
			}
			else {
				if (UseGAC) {
					foreach (var path in FindAssembliesGac(assembly, sourceModule, matchExactly))
						yield return path;
				}
			}
			foreach (var path in FindAssembliesModuleSearchPaths(assembly, sourceModule, matchExactly))
				yield return path;
		}

		IEnumerable<string> FindAssembliesGac(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			if (matchExactly)
				return FindAssembliesGacExactly(assembly, sourceModule);
			return FindAssembliesGacAny(assembly, sourceModule);
		}

		IEnumerable<GacInfo> GetGacInfos(ModuleDef sourceModule) {
			int version = sourceModule == null ? int.MinValue : sourceModule.IsClr40 ? 4 : 2;
			// Try the correct GAC first (eg. GAC4 if it's a .NET 4 assembly)
			foreach (var gacInfo in gacInfos) {
				if (gacInfo.Version == version)
					yield return gacInfo;
			}
			foreach (var gacInfo in gacInfos) {
				if (gacInfo.Version != version)
					yield return gacInfo;
			}
		}

		IEnumerable<string> FindAssembliesGacExactly(IAssembly assembly, ModuleDef sourceModule) {
			foreach (var gacInfo in GetGacInfos(sourceModule)) {
				foreach (var path in FindAssembliesGacExactly(gacInfo, assembly, sourceModule))
					yield return path;
			}
			if (extraMonoPaths != null) {
				foreach (var path in GetExtraMonoPaths(assembly, sourceModule))
					yield return path;
			}
		}

		static IEnumerable<string> GetExtraMonoPaths(IAssembly assembly, ModuleDef sourceModule) {
			if (extraMonoPaths != null) {
				foreach (var dir in extraMonoPaths) {
					var file = Path.Combine(dir, assembly.Name + ".dll");
					if (File.Exists(file))
						yield return file;
				}
			}
		}

		IEnumerable<string> FindAssembliesGacExactly(GacInfo gacInfo, IAssembly assembly, ModuleDef sourceModule) {
			var pkt = PublicKeyBase.ToPublicKeyToken(assembly.PublicKeyOrToken);
			if (gacInfo != null && pkt != null) {
				string pktString = pkt.ToString();
				string verString = Utils.CreateVersionWithNoUndefinedValues(assembly.Version).ToString();
				var cultureString = UTF8String.ToSystemStringOrEmpty(assembly.Culture);
				if (cultureString.Equals("neutral", StringComparison.OrdinalIgnoreCase))
					cultureString = string.Empty;
				var asmSimpleName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
				foreach (var subDir in gacInfo.SubDirs) {
					var baseDir = Path.Combine(gacInfo.Path, subDir);
					baseDir = Path.Combine(baseDir, asmSimpleName);
					baseDir = Path.Combine(baseDir, string.Format("{0}{1}_{2}_{3}", gacInfo.Prefix, verString, cultureString, pktString));
					var pathName = Path.Combine(baseDir, asmSimpleName + ".dll");
					if (File.Exists(pathName))
						yield return pathName;
				}
			}
		}

		IEnumerable<string> FindAssembliesGacAny(IAssembly assembly, ModuleDef sourceModule) {
			foreach (var gacInfo in GetGacInfos(sourceModule)) {
				foreach (var path in FindAssembliesGacAny(gacInfo, assembly, sourceModule))
					yield return path;
			}
			if (extraMonoPaths != null) {
				foreach (var path in GetExtraMonoPaths(assembly, sourceModule))
					yield return path;
			}
		}

		IEnumerable<string> FindAssembliesGacAny(GacInfo gacInfo, IAssembly assembly, ModuleDef sourceModule) {
			if (gacInfo != null) {
				var asmSimpleName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
				foreach (var subDir in gacInfo.SubDirs) {
					var baseDir = Path.Combine(gacInfo.Path, subDir);
					baseDir = Path.Combine(baseDir, asmSimpleName);
					foreach (var dir in GetDirs(baseDir)) {
						var pathName = Path.Combine(dir, asmSimpleName + ".dll");
						if (File.Exists(pathName))
							yield return pathName;
					}
				}
			}
		}

		IEnumerable<string> GetDirs(string baseDir) {
			if (!Directory.Exists(baseDir))
				return emtpyStringArray;
			var dirs = new List<string>();
			try {
				foreach (var di in new DirectoryInfo(baseDir).GetDirectories())
					dirs.Add(di.FullName);
			}
			catch {
			}
			return dirs;
		}
		static readonly string[] emtpyStringArray = new string[0];

		IEnumerable<string> FindAssembliesModuleSearchPaths(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			string asmSimpleName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
			var searchPaths = GetSearchPaths(sourceModule);
			var exts = assembly.IsContentTypeWindowsRuntime ? winMDAssemblyExtensions : assemblyExtensions;
			foreach (var ext in exts) {
				foreach (var path in searchPaths.GetSafeEnumerable()) {
					for (int i = 0; i < 2; i++) {
						string path2;
						if (i == 0)
							path2 = Path.Combine(path, asmSimpleName + ext);
						else
							path2 = Path.Combine(Path.Combine(path, asmSimpleName), asmSimpleName + ext);
						if (File.Exists(path2))
							yield return path2;
					}
				}
			}
		}

		/// <summary>
		/// Gets all search paths to use for this module
		/// </summary>
		/// <param name="module">The module or <c>null</c> if unknown</param>
		/// <returns>A list of all search paths to use for this module</returns>
		IEnumerable<string> GetSearchPaths(ModuleDef module) {
			ModuleDef keyModule = module;
			if (keyModule == null)
				keyModule = nullModule;
			IList<string> searchPaths;
			if (moduleSearchPaths.TryGetValue(keyModule, out searchPaths))
				return searchPaths;
			moduleSearchPaths[keyModule] = searchPaths = new List<string>(GetModuleSearchPaths(module));
			return searchPaths;
		}

		/// <summary>
		/// Gets all module search paths. This is usually empty unless its assembly has
		/// a <c>.config</c> file specifying any additional private search paths in a
		/// &lt;probing/&gt; element.
		/// </summary>
		/// <param name="module">The module or <c>null</c> if unknown</param>
		/// <returns>A list of search paths</returns>
		protected virtual IEnumerable<string> GetModuleSearchPaths(ModuleDef module) {
			return GetModulePrivateSearchPaths(module);
		}

		/// <summary>
		/// Gets all private assembly search paths as found in the module's <c>.config</c> file.
		/// </summary>
		/// <param name="module">The module or <c>null</c> if unknown</param>
		/// <returns>A list of search paths</returns>
		protected IEnumerable<string> GetModulePrivateSearchPaths(ModuleDef module) {
			if (module == null)
				return new string[0];
			var asm = module.Assembly;
			if (asm == null)
				return new string[0];
			module = asm.ManifestModule;
			if (module == null)
				return new string[0];	// Should never happen

			string baseDir = null;
			try {
				var imageName = module.Location;
				if (imageName != string.Empty) {
					baseDir = Directory.GetParent(imageName).FullName;
					var configName = imageName + ".config";
					if (File.Exists(configName))
						return GetPrivatePaths(baseDir, configName);
				}
			}
			catch {
			}
			if (baseDir != null)
				return new List<string> { baseDir };
			return new string[0];
		}

		IEnumerable<string> GetPrivatePaths(string baseDir, string configFileName) {
			var searchPaths = new List<string>();

			try {
				var dirName = Path.GetDirectoryName(Path.GetFullPath(configFileName));
				searchPaths.Add(dirName);

				using (var xmlStream = new FileStream(configFileName, FileMode.Open, FileAccess.Read, FileShare.Read)) {
					var doc = new XmlDocument();
					doc.Load(XmlReader.Create(xmlStream));
					foreach (var tmp in doc.GetElementsByTagName("probing")) {
						var probingElem = tmp as XmlElement;
						if (probingElem == null)
							continue;
						var privatePath = probingElem.GetAttribute("privatePath");
						if (string.IsNullOrEmpty(privatePath))
							continue;
						foreach (var tmp2 in privatePath.Split(';')) {
							var path = tmp2.Trim();
							if (path == "")
								continue;
							var newPath = Path.GetFullPath(Path.Combine(dirName, path.Replace('\\', Path.DirectorySeparatorChar)));
							if (Directory.Exists(newPath) && newPath.StartsWith(baseDir + Path.DirectorySeparatorChar))
								searchPaths.Add(newPath);
						}
					}
				}
			}
			catch (ArgumentException) {
			}
			catch (IOException) {
			}
			catch (XmlException) {
			}

			return searchPaths;
		}

		/// <summary>
		/// Add other common search paths
		/// </summary>
		/// <param name="paths">A list that gets updated with the new paths</param>
		protected static void AddOtherSearchPaths(IList<string> paths) {
			var dirPF = Environment.GetEnvironmentVariable("ProgramFiles");
			AddOtherAssemblySearchPaths(paths, dirPF);
			var dirPFx86 = Environment.GetEnvironmentVariable("ProgramFiles(x86)");
			if (!StringComparer.OrdinalIgnoreCase.Equals(dirPF, dirPFx86))
				AddOtherAssemblySearchPaths(paths, dirPFx86);

			var windir = Environment.GetEnvironmentVariable("WINDIR");
			if (!string.IsNullOrEmpty(windir)) {
				AddIfExists(paths, windir, @"Microsoft.NET\Framework\v1.1.4322");
				AddIfExists(paths, windir, @"Microsoft.NET\Framework\v1.0.3705");
			}
		}

		static void AddOtherAssemblySearchPaths(IList<string> paths, string path) {
			if (string.IsNullOrEmpty(path))
				return;
			AddSilverlightDirs(paths, Path.Combine(path, @"Microsoft Silverlight"));
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v2.0\Libraries\Client");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v2.0\Libraries\Server");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v2.0\Reference Assemblies");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v3.0\Libraries\Client");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v3.0\Libraries\Server");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v4.0\Libraries\Client");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v4.0\Libraries\Server");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v5.0\Libraries\Client");
			AddIfExists(paths, path, @"Microsoft SDKs\Silverlight\v5.0\Libraries\Server");
			AddIfExists(paths, path, @"Microsoft.NET\SDK\CompactFramework\v2.0\WindowsCE");
			AddIfExists(paths, path, @"Microsoft.NET\SDK\CompactFramework\v3.5\WindowsCE");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.2");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.5");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\Profile\Client");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETFramework\v3.5\Profile\Client");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETCore\v5.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETCore\v4.5.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETCore\v4.5");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v3.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v4.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v4.2");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETMicroFramework\v4.3");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETPortable\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETPortable\v4.5");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETPortable\v4.6");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\.NETPortable\v5.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\v3.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\v3.5");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\Silverlight\v3.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\Silverlight\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\Silverlight\v5.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\WindowsPhone\v8.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\Framework\WindowsPhoneApp\v8.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.259.4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.259.3.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.78.4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.78.3.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.7.4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETCore\3.3.1.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETFramework\v2.0\2.3.0.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.3.0.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.3.1.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETFramework\v4.0\4.4.0.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETPortable\2.3.5.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETPortable\2.3.5.1");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\.NETPortable\3.47.4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\2.0\Runtime\v2.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\2.0\Runtime\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\3.0\Runtime\.NETPortable");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\3.0\Runtime\v2.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\FSharp\3.0\Runtime\v4.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\WindowsPowerShell\v1.0");
			AddIfExists(paths, path, @"Reference Assemblies\Microsoft\WindowsPowerShell\3.0");
			AddIfExists(paths, path, @"Microsoft Visual Studio .NET\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio .NET\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio .NET 2003\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio .NET 2003\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 8\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 8\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 9.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 9.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 10.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 10.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 11.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 11.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 12.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 12.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 14.0\Common7\IDE\PublicAssemblies");
			AddIfExists(paths, path, @"Microsoft Visual Studio 14.0\Common7\IDE\PrivateAssemblies");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v2.0\References\Windows\x86");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v2.0\References\Xbox360");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.0\References\Windows\x86");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.0\References\Xbox360");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.0\References\Zune");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.1\References\Windows\x86");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.1\References\Xbox360");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v3.1\References\Zune");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v4.0\References\Windows\x86");
			AddIfExists(paths, path, @"Microsoft XNA\XNA Game Studio\v4.0\References\Xbox360");
			AddIfExists(paths, path, @"Windows CE Tools\wce500\Windows Mobile 5.0 Pocket PC SDK\Designtimereferences");
			AddIfExists(paths, path, @"Windows CE Tools\wce500\Windows Mobile 5.0 Smartphone SDK\Designtimereferences");
			AddIfExists(paths, path, @"Windows Mobile 5.0 SDK R2\Managed Libraries");
			AddIfExists(paths, path, @"Windows Mobile 6 SDK\Managed Libraries");
			AddIfExists(paths, path, @"Windows Mobile 6.5.3 DTK\Managed Libraries");
			AddIfExists(paths, path, @"Microsoft SQL Server\90\SDK\Assemblies");
			AddIfExists(paths, path, @"Microsoft SQL Server\100\SDK\Assemblies");
			AddIfExists(paths, path, @"Microsoft SQL Server\110\SDK\Assemblies");
			AddIfExists(paths, path, @"Microsoft SQL Server\120\SDK\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET MVC 2\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET MVC 3\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET MVC 4\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET Web Pages\v1.0\Assemblies");
			AddIfExists(paths, path, @"Microsoft ASP.NET\ASP.NET Web Pages\v2.0\Assemblies");
			AddIfExists(paths, path, @"Microsoft SDKs\F#\3.0\Framework\v4.0");
		}

		static void AddSilverlightDirs(IList<string> paths, string basePath) {
			if (!Directory.Exists(basePath))
				return;
			try {
				var di = new DirectoryInfo(basePath);
				foreach (var dir in di.GetDirectories()) {
					if (Regex.IsMatch(dir.Name, @"^\d+(?:\.\d+){3}$"))
						AddIfExists(paths, basePath, dir.Name);
				}
			}
			catch {
			}
		}

		static void AddIfExists(IList<string> paths, string basePath, string extraPath) {
			var path = Path.Combine(basePath, extraPath);
			if (Directory.Exists(path))
				paths.Add(path);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/CallingConvention.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// See CorHdr.h/CorCallingConvention
	/// </summary>
	[Flags]
	public enum CallingConvention : byte {
		/// <summary>The managed calling convention</summary>
		Default			= 0x0,
		/// <summary/>
		C				= 0x1,
		/// <summary/>
		StdCall			= 0x2,
		/// <summary/>
		ThisCall		= 0x3,
		/// <summary/>
		FastCall		= 0x4,
		/// <summary/>
		VarArg			= 0x5,
		/// <summary/>
		Field			= 0x6,
		/// <summary/>
		LocalSig		= 0x7,
		/// <summary/>
		Property		= 0x8,
		/// <summary/>
		Unmanaged		= 0x9,
		/// <summary>generic method instantiation</summary>
		GenericInst		= 0xA,
		/// <summary>used ONLY for 64bit vararg PInvoke calls</summary>
		NativeVarArg	= 0xB,

		/// <summary>Calling convention is bottom 4 bits</summary>
		Mask			= 0x0F,

		/// <summary>Generic method</summary>
		Generic			= 0x10,
		/// <summary>Method needs a 'this' parameter</summary>
		HasThis			= 0x20,
		/// <summary>'this' parameter is the first arg if set (else it's hidden)</summary>
		ExplicitThis	= 0x40,
		/// <summary>Used internally by the CLR</summary>
		ReservedByCLR	= 0x80,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/CallingConventionSig.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

/*
All signature classes:

CallingConventionSig
	FieldSig
	MethodBaseSig
		MethodSig
		PropertySig
	LocalSig
	GenericInstMethodSig
*/

namespace dnlib.DotNet {
	/// <summary>
	/// Base class for sigs with a calling convention
	/// </summary>
	public abstract class CallingConventionSig : IContainsGenericParameter {
		/// <summary>
		/// The calling convention
		/// </summary>
		protected CallingConvention callingConvention;

		byte[] extraData;

		/// <summary>
		/// Gets/sets the extra data found after the signature
		/// </summary>
		public byte[] ExtraData {
			get { return extraData; }
			set { extraData = value; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.Default"/> is set
		/// </summary>
		public bool IsDefault {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.Default; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.C"/> is set
		/// </summary>
		public bool IsC {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.C; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.StdCall"/> is set
		/// </summary>
		public bool IsStdCall {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.StdCall; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.ThisCall"/> is set
		/// </summary>
		public bool IsThisCall {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.ThisCall; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.FastCall"/> is set
		/// </summary>
		public bool IsFastCall {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.FastCall; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.VarArg"/> is set
		/// </summary>
		public bool IsVarArg {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.VarArg; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.Field"/> is set
		/// </summary>
		public bool IsField {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.Field; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.LocalSig"/> is set
		/// </summary>
		public bool IsLocalSig {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.LocalSig; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.Property"/> is set
		/// </summary>
		public bool IsProperty {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.Property; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.Unmanaged"/> is set
		/// </summary>
		public bool IsUnmanaged {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.Unmanaged; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.GenericInst"/> is set
		/// </summary>
		public bool IsGenericInst {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.GenericInst; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.NativeVarArg"/> is set
		/// </summary>
		public bool IsNativeVarArg {
			get { return (callingConvention & CallingConvention.Mask) == CallingConvention.NativeVarArg; }
		}

		/// <summary>
		/// Gets/sets the <see cref="CallingConvention.Generic"/> bit
		/// </summary>
		public bool Generic {
			get { return (callingConvention & CallingConvention.Generic) != 0; }
			set {
				if (value)
					callingConvention |= CallingConvention.Generic;
				else
					callingConvention &= ~CallingConvention.Generic;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="CallingConvention.HasThis"/> bit
		/// </summary>
		public bool HasThis {
			get { return (callingConvention & CallingConvention.HasThis) != 0; }
			set {
				if (value)
					callingConvention |= CallingConvention.HasThis;
				else
					callingConvention &= ~CallingConvention.HasThis;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="CallingConvention.ExplicitThis"/> bit
		/// </summary>
		public bool ExplicitThis {
			get { return (callingConvention & CallingConvention.ExplicitThis) != 0; }
			set {
				if (value)
					callingConvention |= CallingConvention.ExplicitThis;
				else
					callingConvention &= ~CallingConvention.ExplicitThis;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="CallingConvention.ReservedByCLR"/> bit
		/// </summary>
		public bool ReservedByCLR {
			get { return (callingConvention & CallingConvention.ReservedByCLR) != 0; }
			set {
				if (value)
					callingConvention |= CallingConvention.ReservedByCLR;
				else
					callingConvention &= ~CallingConvention.ReservedByCLR;
			}
		}

		/// <summary>
		/// <c>true</c> if there's an implicit <c>this</c> parameter
		/// </summary>
		public bool ImplicitThis {
			get { return HasThis && !ExplicitThis; }
		}

		/// <summary>
		/// <c>true</c> if this <see cref="CallingConventionSig"/> contains a
		/// <see cref="GenericVar"/> or a <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter {
			get { return TypeHelper.ContainsGenericParameter(this); }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		protected CallingConventionSig() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">The calling convention</param>
		protected CallingConventionSig(CallingConvention callingConvention) {
			this.callingConvention = callingConvention;
		}

		/// <summary>
		/// Gets the calling convention
		/// </summary>
		public CallingConvention GetCallingConvention() {
			return callingConvention;
		}
	}

	/// <summary>
	/// A field signature
	/// </summary>
	public sealed class FieldSig : CallingConventionSig {
		TypeSig type;

		/// <summary>
		/// Gets/sets the field type
		/// </summary>
		public TypeSig Type {
			get { return type; }
			set { type = value; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public FieldSig() {
			this.callingConvention = CallingConvention.Field;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Field type</param>
		public FieldSig(TypeSig type) {
			this.callingConvention = CallingConvention.Field;
			this.type = type;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Field type</param>
		/// <param name="callingConvention">The calling convention (must have Field set)</param>
		internal FieldSig(CallingConvention callingConvention, TypeSig type) {
			this.callingConvention = callingConvention;
			this.type = type;
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public FieldSig Clone() {
			return new FieldSig(callingConvention, type);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullNameCreator.FullName(type == null ? null : type, false, null, null, null, null);
		}
	}

	/// <summary>
	/// Method sig base class
	/// </summary>
	public abstract class MethodBaseSig : CallingConventionSig {
		/// <summary/>
		protected TypeSig retType;
		/// <summary/>
		protected ThreadSafe.IList<TypeSig> parameters;
		/// <summary/>
		protected uint genParamCount;
		/// <summary/>
		protected ThreadSafe.IList<TypeSig> paramsAfterSentinel;

		/// <summary>
		/// Gets/sets the calling convention
		/// </summary>
		public CallingConvention CallingConvention {
			get { return callingConvention; }
			set { callingConvention = value; }
		}

		/// <summary>
		/// Gets/sets the return type
		/// </summary>
		public TypeSig RetType {
			get { return retType; }
			set { retType = value; }
		}

		/// <summary>
		/// Gets the parameters. This is never <c>null</c>
		/// </summary>
		public ThreadSafe.IList<TypeSig> Params {
			get { return parameters; }
		}

		/// <summary>
		/// Gets/sets the generic param count
		/// </summary>
		public uint GenParamCount {
			get { return genParamCount; }
			set { genParamCount = value; }
		}

		/// <summary>
		/// Gets the parameters that are present after the sentinel. Note that this is <c>null</c>
		/// if there's no sentinel. It can still be empty even if it's not <c>null</c>.
		/// </summary>
		public ThreadSafe.IList<TypeSig> ParamsAfterSentinel {
			get { return paramsAfterSentinel; }
			set { paramsAfterSentinel = value; }
		}
	}

	/// <summary>
	/// A method signature
	/// </summary>
	public sealed class MethodSig : MethodBaseSig {
		uint origToken;

		/// <summary>
		/// Gets/sets the original token. It's set when reading calli instruction operands
		/// and it's a hint to the module writer if it tries to re-use the same token.
		/// </summary>
		public uint OriginalToken {
			get { return origToken; }
			set { origToken = value; }
		}

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		public static MethodSig CreateStatic(TypeSig retType) {
			return new MethodSig(CallingConvention.Default, 0, retType);
		}

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static MethodSig CreateStatic(TypeSig retType, TypeSig argType1) {
			return new MethodSig(CallingConvention.Default, 0, retType, argType1);
		}

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static MethodSig CreateStatic(TypeSig retType, TypeSig argType1, TypeSig argType2) {
			return new MethodSig(CallingConvention.Default, 0, retType, argType1, argType2);
		}

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static MethodSig CreateStatic(TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			return new MethodSig(CallingConvention.Default, 0, retType, argType1, argType2, argType3);
		}

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static MethodSig CreateStatic(TypeSig retType, params TypeSig[] argTypes) {
			return new MethodSig(CallingConvention.Default, 0, retType, argTypes);
		}

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		public static MethodSig CreateInstance(TypeSig retType) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType);
		}

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static MethodSig CreateInstance(TypeSig retType, TypeSig argType1) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType, argType1);
		}

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static MethodSig CreateInstance(TypeSig retType, TypeSig argType1, TypeSig argType2) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType, argType1, argType2);
		}

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static MethodSig CreateInstance(TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType, argType1, argType2, argType3);
		}

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static MethodSig CreateInstance(TypeSig retType, params TypeSig[] argTypes) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType, argTypes);
		}

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType) {
			return new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType);
		}

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType, TypeSig argType1) {
			return new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType, argType1);
		}

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2) {
			return new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType, argType1, argType2);
		}

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			return new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType, argType1, argType2, argType3);
		}

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType, params TypeSig[] argTypes) {
			return new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType, argTypes);
		}

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType);
		}

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType, TypeSig argType1) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType, argType1);
		}

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType, argType1, argType2);
		}

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType, argType1, argType2, argType3);
		}

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType, params TypeSig[] argTypes) {
			return new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType, argTypes);
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public MethodSig() {
			this.parameters = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		public MethodSig(CallingConvention callingConvention) {
			this.callingConvention = callingConvention;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, TypeSig argType1) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argType1);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argType1, argType2);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argType1, argType2, argType3);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, params TypeSig[] argTypes) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argTypes);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, IList<TypeSig> argTypes) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argTypes);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		/// <param name="paramsAfterSentinel">Parameters after sentinel</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, IList<TypeSig> argTypes, IList<TypeSig> paramsAfterSentinel) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argTypes);
			this.paramsAfterSentinel = paramsAfterSentinel == null ? null : ThreadSafeListCreator.Create<TypeSig>(paramsAfterSentinel);
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public MethodSig Clone() {
			return new MethodSig(callingConvention, genParamCount, retType, parameters, paramsAfterSentinel);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullNameCreator.MethodBaseSigFullName(this, null);
		}
	}

	/// <summary>
	/// A property signature
	/// </summary>
	public sealed class PropertySig : MethodBaseSig {
		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		public static PropertySig CreateStatic(TypeSig retType) {
			return new PropertySig(false, retType);
		}

		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static PropertySig CreateStatic(TypeSig retType, TypeSig argType1) {
			return new PropertySig(false, retType, argType1);
		}

		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static PropertySig CreateStatic(TypeSig retType, TypeSig argType1, TypeSig argType2) {
			return new PropertySig(false, retType, argType1, argType2);
		}

		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static PropertySig CreateStatic(TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			return new PropertySig(false, retType, argType1, argType2, argType3);
		}

		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static PropertySig CreateStatic(TypeSig retType, params TypeSig[] argTypes) {
			return new PropertySig(false, retType, argTypes);
		}

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		public static PropertySig CreateInstance(TypeSig retType) {
			return new PropertySig(true, retType);
		}

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static PropertySig CreateInstance(TypeSig retType, TypeSig argType1) {
			return new PropertySig(true, retType, argType1);
		}

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static PropertySig CreateInstance(TypeSig retType, TypeSig argType1, TypeSig argType2) {
			return new PropertySig(true, retType, argType1, argType2);
		}

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static PropertySig CreateInstance(TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			return new PropertySig(true, retType, argType1, argType2, argType3);
		}

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static PropertySig CreateInstance(TypeSig retType, params TypeSig[] argTypes) {
			return new PropertySig(true, retType, argTypes);
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public PropertySig() {
			this.callingConvention = CallingConvention.Property;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention (must have Property set)</param>
		internal PropertySig(CallingConvention callingConvention) {
			this.callingConvention = callingConvention;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		public PropertySig(bool hasThis) {
			this.callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.parameters = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		public PropertySig(bool hasThis, TypeSig retType) {
			this.callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public PropertySig(bool hasThis, TypeSig retType, TypeSig argType1) {
			this.callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argType1);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public PropertySig(bool hasThis, TypeSig retType, TypeSig argType1, TypeSig argType2) {
			this.callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argType1, argType2);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public PropertySig(bool hasThis, TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			this.callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argType1, argType2, argType3);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public PropertySig(bool hasThis, TypeSig retType, params TypeSig[] argTypes) {
			this.callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argTypes);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		/// <param name="paramsAfterSentinel">Parameters after sentinel</param>
		internal PropertySig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, IList<TypeSig> argTypes, IList<TypeSig> paramsAfterSentinel) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			this.parameters = ThreadSafeListCreator.Create<TypeSig>(argTypes);
			this.paramsAfterSentinel = paramsAfterSentinel == null ? null : ThreadSafeListCreator.Create<TypeSig>(paramsAfterSentinel);
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public PropertySig Clone() {
			return new PropertySig(callingConvention, genParamCount, retType, parameters, paramsAfterSentinel);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullNameCreator.MethodBaseSigFullName(this, null);
		}
	}

	/// <summary>
	/// A local variables signature
	/// </summary>
	public sealed class LocalSig : CallingConventionSig {
		readonly ThreadSafe.IList<TypeSig> locals;

		/// <summary>
		/// All local types. This is never <c>null</c>.
		/// </summary>
		public ThreadSafe.IList<TypeSig> Locals {
			get { return locals; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public LocalSig() {
			this.callingConvention = CallingConvention.LocalSig;
			this.locals = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention (must have LocalSig set)</param>
		/// <param name="count">Number of locals</param>
		internal LocalSig(CallingConvention callingConvention, uint count) {
			this.callingConvention = callingConvention;
			this.locals = ThreadSafeListCreator.Create<TypeSig>((int)count);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="local1">Local type #1</param>
		public LocalSig(TypeSig local1) {
			this.callingConvention = CallingConvention.LocalSig;
			this.locals = ThreadSafeListCreator.Create<TypeSig>(local1);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="local1">Local type #1</param>
		/// <param name="local2">Local type #2</param>
		public LocalSig(TypeSig local1, TypeSig local2) {
			this.callingConvention = CallingConvention.LocalSig;
			this.locals = ThreadSafeListCreator.Create<TypeSig>(local1, local2);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="local1">Local type #1</param>
		/// <param name="local2">Local type #2</param>
		/// <param name="local3">Local type #3</param>
		public LocalSig(TypeSig local1, TypeSig local2, TypeSig local3) {
			this.callingConvention = CallingConvention.LocalSig;
			this.locals = ThreadSafeListCreator.Create<TypeSig>(local1, local2, local3);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="locals">All locals</param>
		public LocalSig(params TypeSig[] locals) {
			this.callingConvention = CallingConvention.LocalSig;
			this.locals = ThreadSafeListCreator.Create<TypeSig>(locals);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="locals">All locals</param>
		public LocalSig(IList<TypeSig> locals) {
			this.callingConvention = CallingConvention.LocalSig;
			this.locals = ThreadSafeListCreator.Create<TypeSig>(locals);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="locals">All locals (this instance now owns it)</param>
		/// <param name="dummy">Dummy</param>
		internal LocalSig(IList<TypeSig> locals, bool dummy) {
			this.callingConvention = CallingConvention.LocalSig;
			this.locals = ThreadSafeListCreator.MakeThreadSafe(locals);
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public LocalSig Clone() {
			return new LocalSig(locals);
		}
	}

	/// <summary>
	/// An instantiated generic method signature
	/// </summary>
	public sealed class GenericInstMethodSig : CallingConventionSig {
		readonly ThreadSafe.IList<TypeSig> genericArgs;

		/// <summary>
		/// Gets the generic arguments (must be instantiated types, i.e., closed types)
		/// </summary>
		public ThreadSafe.IList<TypeSig> GenericArguments {
			get { return genericArgs; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public GenericInstMethodSig() {
			this.callingConvention = CallingConvention.GenericInst;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention (must have GenericInst set)</param>
		/// <param name="size">Number of generic args</param>
		internal GenericInstMethodSig(CallingConvention callingConvention, uint size) {
			this.callingConvention = callingConvention;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>((int)size);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arg1">Generic arg #1</param>
		public GenericInstMethodSig(TypeSig arg1) {
			this.callingConvention = CallingConvention.GenericInst;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(arg1);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arg1">Generic arg #1</param>
		/// <param name="arg2">Generic arg #2</param>
		public GenericInstMethodSig(TypeSig arg1, TypeSig arg2) {
			this.callingConvention = CallingConvention.GenericInst;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(arg1, arg2);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arg1">Generic arg #1</param>
		/// <param name="arg2">Generic arg #2</param>
		/// <param name="arg3">Generic arg #3</param>
		public GenericInstMethodSig(TypeSig arg1, TypeSig arg2, TypeSig arg3) {
			this.callingConvention = CallingConvention.GenericInst;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(arg1, arg2, arg3);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="args">Generic args</param>
		public GenericInstMethodSig(params TypeSig[] args) {
			this.callingConvention = CallingConvention.GenericInst;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(args);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="args">Generic args</param>
		public GenericInstMethodSig(IList<TypeSig> args) {
			this.callingConvention = CallingConvention.GenericInst;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(args);
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public GenericInstMethodSig Clone() {
			return new GenericInstMethodSig(genericArgs);
		}
	}

	public static partial class Extensions {
		/// <summary>
		/// Gets the field type
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Field type or <c>null</c> if none</returns>
		public static TypeSig GetFieldType(this FieldSig sig) {
			return sig == null ? null : sig.Type;
		}

		/// <summary>
		/// Gets the return type
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Return type or <c>null</c> if none</returns>
		public static TypeSig GetRetType(this MethodBaseSig sig) {
			return sig == null ? null : sig.RetType;
		}

		/// <summary>
		/// Gets the parameters
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>The parameters</returns>
		public static IList<TypeSig> GetParams(this MethodBaseSig sig) {
			return sig == null ? ThreadSafeListCreator.Create<TypeSig>() : sig.Params;
		}

		/// <summary>
		/// Gets the parameter count
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Parameter count</returns>
		public static int GetParamCount(this MethodBaseSig sig) {
			return sig == null ? 0 : sig.Params.Count;
		}

		/// <summary>
		/// Gets the generic parameter count
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Generic parameter count</returns>
		public static uint GetGenParamCount(this MethodBaseSig sig) {
			return sig == null ? 0 : sig.GenParamCount;
		}

		/// <summary>
		/// Gets the parameters after the sentinel
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Parameters after sentinel or <c>null</c> if none</returns>
		public static IList<TypeSig> GetParamsAfterSentinel(this MethodBaseSig sig) {
			return sig == null ? null : sig.ParamsAfterSentinel;
		}

		/// <summary>
		/// Gets the locals
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>All locals</returns>
		public static IList<TypeSig> GetLocals(this LocalSig sig) {
			return sig == null ? ThreadSafeListCreator.Create<TypeSig>() : sig.Locals;
		}

		/// <summary>
		/// Gets the generic arguments
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>All generic arguments</returns>
		public static IList<TypeSig> GetGenericArguments(this GenericInstMethodSig sig) {
			return sig == null ? ThreadSafeListCreator.Create<TypeSig>() : sig.GenericArguments;
		}

		/// <summary>
		/// Gets the <see cref="CallingConventionSig.IsDefault"/> property
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>The type's <see cref="CallingConventionSig.IsDefault"/> property or
		/// <c>false</c> if input is<c>null</c></returns>
		public static bool GetIsDefault(this CallingConventionSig sig) {
			return sig == null ? false : sig.IsDefault;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ClassLayout.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.DotNet.MD;

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ClassLayout table
	/// </summary>
	public abstract class ClassLayout : IMDTokenProvider {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.ClassLayout, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <summary>
		/// From column ClassLayout.PackingSize
		/// </summary>
		public ushort PackingSize {
			get { return packingSize; }
			set { packingSize = value; }
		}
		/// <summary/>
		protected ushort packingSize;

		/// <summary>
		/// From column ClassLayout.ClassSize
		/// </summary>
		public uint ClassSize {
			get { return classSize; }
			set { classSize = value; }
		}
		/// <summary/>
		protected uint classSize;
	}

	/// <summary>
	/// A ClassLayout row created by the user and not present in the original .NET file
	/// </summary>
	public class ClassLayoutUser : ClassLayout {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ClassLayoutUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="packingSize">PackingSize</param>
		/// <param name="classSize">ClassSize</param>
		public ClassLayoutUser(ushort packingSize, uint classSize) {
			this.packingSize = packingSize;
			this.classSize = classSize;
		}
	}

	/// <summary>
	/// Created from a row in the ClassLayout table
	/// </summary>
	sealed class ClassLayoutMD : ClassLayout, IMDTokenProviderMD {
		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ClassLayout</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ClassLayoutMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ClassLayoutTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("ClassLayout rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.classSize = readerModule.TablesStream.ReadClassLayoutRow(origRid, out this.packingSize);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Constant.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Text;
using dnlib.DotNet.MD;

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Constant table
	/// </summary>
	public abstract class Constant : IMDTokenProvider {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.Constant, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <summary>
		/// From column Constant.Type
		/// </summary>
		public ElementType Type {
			get { return type; }
			set { type = value; }
		}
		/// <summary/>
		protected ElementType type;

		/// <summary>
		/// From column Constant.Value
		/// </summary>
		public object Value {
			get { return value; }
			set { this.value = value; }
		}
		/// <summary/>
		protected object value;
	}

	/// <summary>
	/// A Constant row created by the user and not present in the original .NET file
	/// </summary>
	public class ConstantUser : Constant {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ConstantUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="value">Value</param>
		public ConstantUser(object value) {
			this.type = GetElementType(value);
			this.value = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="type">Type</param>
		public ConstantUser(object value, ElementType type) {
			this.type = type;
			this.value = value;
		}

		static ElementType GetElementType(object value) {
			if (value == null)
				return ElementType.Class;
			switch (System.Type.GetTypeCode(value.GetType())) {
			case TypeCode.Boolean:	return ElementType.Boolean;
			case TypeCode.Char:		return ElementType.Char;
			case TypeCode.SByte:	return ElementType.I1;
			case TypeCode.Byte:		return ElementType.U1;
			case TypeCode.Int16:	return ElementType.I2;
			case TypeCode.UInt16:	return ElementType.U2;
			case TypeCode.Int32:	return ElementType.I4;
			case TypeCode.UInt32:	return ElementType.U4;
			case TypeCode.Int64:	return ElementType.I8;
			case TypeCode.UInt64:	return ElementType.U8;
			case TypeCode.Single:	return ElementType.R4;
			case TypeCode.Double:	return ElementType.R8;
			case TypeCode.String:	return ElementType.String;
			default: return ElementType.Void;
			}
		}
	}

	/// <summary>
	/// Created from a row in the Constant table
	/// </summary>
	sealed class ConstantMD : Constant, IMDTokenProviderMD {
		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Constant</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ConstantMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ConstantTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("Constant rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			uint value = readerModule.TablesStream.ReadConstantRow(origRid, out this.type);
			this.value = GetValue(this.type, readerModule.BlobStream.ReadNoNull(value));
		}

		static object GetValue(ElementType etype, byte[] data) {
			switch (etype) {
			case ElementType.Boolean:
				if (data == null || data.Length < 1)
					return false;
				return BitConverter.ToBoolean(data, 0);

			case ElementType.Char:
				if (data == null || data.Length < 2)
					return (char)0;
				return BitConverter.ToChar(data, 0);

			case ElementType.I1:
				if (data == null || data.Length < 1)
					return (sbyte)0;
				return (sbyte)data[0];

			case ElementType.U1:
				if (data == null || data.Length < 1)
					return (byte)0;
				return data[0];

			case ElementType.I2:
				if (data == null || data.Length < 2)
					return (short)0;
				return BitConverter.ToInt16(data, 0);

			case ElementType.U2:
				if (data == null || data.Length < 2)
					return (ushort)0;
				return BitConverter.ToUInt16(data, 0);

			case ElementType.I4:
				if (data == null || data.Length < 4)
					return (int)0;
				return BitConverter.ToInt32(data, 0);

			case ElementType.U4:
				if (data == null || data.Length < 4)
					return (uint)0;
				return BitConverter.ToUInt32(data, 0);

			case ElementType.I8:
				if (data == null || data.Length < 8)
					return (long)0;
				return BitConverter.ToInt64(data, 0);

			case ElementType.U8:
				if (data == null || data.Length < 8)
					return (ulong)0;
				return BitConverter.ToUInt64(data, 0);

			case ElementType.R4:
				if (data == null || data.Length < 4)
					return (float)0;
				return BitConverter.ToSingle(data, 0);

			case ElementType.R8:
				if (data == null || data.Length < 8)
					return (double)0;
				return BitConverter.ToDouble(data, 0);

			case ElementType.String:
				if (data == null)
					return string.Empty;
				return Encoding.Unicode.GetString(data, 0, data.Length / 2 * 2);

			case ElementType.Class:
				return null;

			default:
				return null;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/CorLibTypes.cs
================================================
// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet {
	/// <summary>
	/// Default implementation of <see cref="ICorLibTypes"/>
	/// </summary>
	public sealed class CorLibTypes : ICorLibTypes {
		readonly ModuleDef module;
		CorLibTypeSig typeVoid;
		CorLibTypeSig typeBoolean;
		CorLibTypeSig typeChar;
		CorLibTypeSig typeSByte;
		CorLibTypeSig typeByte;
		CorLibTypeSig typeInt16;
		CorLibTypeSig typeUInt16;
		CorLibTypeSig typeInt32;
		CorLibTypeSig typeUInt32;
		CorLibTypeSig typeInt64;
		CorLibTypeSig typeUInt64;
		CorLibTypeSig typeSingle;
		CorLibTypeSig typeDouble;
		CorLibTypeSig typeString;
		CorLibTypeSig typeTypedReference;
		CorLibTypeSig typeIntPtr;
		CorLibTypeSig typeUIntPtr;
		CorLibTypeSig typeObject;
		readonly AssemblyRef corLibAssemblyRef;

		/// <inheritdoc/>
		public CorLibTypeSig Void {
			get { return typeVoid; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Boolean {
			get { return typeBoolean; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Char {
			get { return typeChar; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig SByte {
			get { return typeSByte; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Byte {
			get { return typeByte; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Int16 {
			get { return typeInt16; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig UInt16 {
			get { return typeUInt16; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Int32 {
			get { return typeInt32; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig UInt32 {
			get { return typeUInt32; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Int64 {
			get { return typeInt64; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig UInt64 {
			get { return typeUInt64; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Single {
			get { return typeSingle; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Double {
			get { return typeDouble; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig String {
			get { return typeString; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig TypedReference {
			get { return typeTypedReference; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig IntPtr {
			get { return typeIntPtr; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig UIntPtr {
			get { return typeUIntPtr; }
		}

		/// <inheritdoc/>
		public CorLibTypeSig Object {
			get { return typeObject; }
		}

		/// <inheritdoc/>
		public AssemblyRef AssemblyRef {
			get { return corLibAssemblyRef; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The owner module</param>
		public CorLibTypes(ModuleDef module)
			: this(module, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The owner module</param>
		/// <param name="corLibAssemblyRef">Corlib assembly reference or <c>null</c> if a default
		/// assembly reference should be created</param>
		public CorLibTypes(ModuleDef module, AssemblyRef corLibAssemblyRef) {
			this.module = module;
			this.corLibAssemblyRef = corLibAssemblyRef ?? CreateCorLibAssemblyRef();
			Initialize();
		}

		AssemblyRef CreateCorLibAssemblyRef() {
			return module.UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR20());
		}

		void Initialize() {
			bool isCorLib = module.Assembly.IsCorLib();
			typeVoid	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Void"),		ElementType.Void);
			typeBoolean	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Boolean"),	ElementType.Boolean);
			typeChar	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Char"),		ElementType.Char);
			typeSByte	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "SByte"),		ElementType.I1);
			typeByte	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Byte"),		ElementType.U1);
			typeInt16	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Int16"),		ElementType.I2);
			typeUInt16	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "UInt16"),	ElementType.U2);
			typeInt32	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Int32"),		ElementType.I4);
			typeUInt32	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "UInt32"),	ElementType.U4);
			typeInt64	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Int64"),		ElementType.I8);
			typeUInt64	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "UInt64"),	ElementType.U8);
			typeSingle	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Single"),	ElementType.R4);
			typeDouble	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Double"),	ElementType.R8);
			typeString	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "String"),	ElementType.String);
			typeTypedReference = new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "TypedReference"), ElementType.TypedByRef);
			typeIntPtr	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "IntPtr"),	ElementType.I);
			typeUIntPtr	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "UIntPtr"),	ElementType.U);
			typeObject	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Object"),	ElementType.Object);
		}

		ITypeDefOrRef CreateCorLibTypeRef(bool isCorLib, string name) {
			var tr = new TypeRefUser(module, "System", name, corLibAssemblyRef);
			if (isCorLib) {
				var td = module.Find(tr);
				if (td != null)
					return td;
			}
			return module.UpdateRowId(tr);
		}

		/// <inheritdoc/>
		public TypeRef GetTypeRef(string @namespace, string name) {
			return module.UpdateRowId(new TypeRefUser(module, @namespace, name, corLibAssemblyRef));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/CpuArch.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using dnlib.DotNet.Writer;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet {
	enum StubType {
		Export,
		EntryPoint,
	}

	abstract class CpuArch {
		static readonly Dictionary<Machine, CpuArch> toCpuArch = new Dictionary<Machine, CpuArch> {
			// To support a new CPU arch, the easiest way is to check coreclr/src/ilasm/writer.cpp or
			// coreclr/src/dlls/mscorpe/stubs.h, eg. ExportStubAMD64Template, ExportStubX86Template,
			// ExportStubARMTemplate, ExportStubIA64Template, or use ilasm to generate a file with
			// exports and check the stub
			{ Machine.I386, new X86CpuArch() },
			{ Machine.AMD64, new X64CpuArch() },
			{ Machine.IA64, new ItaniumCpuArch() },
			{ Machine.ARMNT, new ArmCpuArch() },
			//TODO: Support ARM64
			// { Machine.ARM64, new Arm64CpuArch() },
		};

		/// <summary>
		/// Gets the required alignment for the stubs, must be a power of 2
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <returns></returns>
		public abstract uint GetStubAlignment(StubType stubType);

		/// <summary>
		/// Gets the size of a stub, it doesn't have to be a multiple of <see cref="GetStubAlignment(StubType)"/>
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <returns></returns>
		public abstract uint GetStubSize(StubType stubType);

		/// <summary>
		/// Gets the offset of the code (entry point) relative to the start of the stub
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <returns></returns>
		public abstract uint GetStubCodeOffset(StubType stubType);

		public static bool TryGetCpuArch(Machine machine, out CpuArch cpuArch) {
			return toCpuArch.TryGetValue(machine, out cpuArch);
		}

		/// <summary>
		/// Gets the RVA of the func field that the stub jumps to
		/// </summary>
		/// <param name="reader">Reader, positioned at the stub func</param>
		/// <param name="peImage">PE image</param>
		/// <param name="funcRva">Updated with RVA of func field</param>
		/// <returns></returns>
		public bool TryGetExportedRvaFromStub(IBinaryReader reader, IPEImage peImage, out uint funcRva) {
			bool b = TryGetExportedRvaFromStubCore(reader, peImage, out funcRva);
			Debug.Assert(b);
			return b;
		}

		protected abstract bool TryGetExportedRvaFromStubCore(IBinaryReader reader, IPEImage peImage, out uint funcRva);

		/// <summary>
		/// Writes stub relocs, if needed
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <param name="relocDirectory">Reloc directory</param>
		/// <param name="chunk">The chunk where this stub will be written to</param>
		/// <param name="stubOffset">Offset of this stub in <paramref name="chunk"/></param>
		public abstract void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset);

		/// <summary>
		/// Writes the stub that jumps to the managed function
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <param name="writer">Writer</param>
		/// <param name="imageBase">Image base</param>
		/// <param name="stubRva">RVA of this stub</param>
		/// <param name="managedFuncRva">RVA of a pointer-sized field that contains the absolute address of the managed function</param>
		public abstract void WriteStub(StubType stubType, BinaryWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva);
	}

	sealed class X86CpuArch : CpuArch {
		public override uint GetStubAlignment(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 4;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubSize(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 2/*padding*/ + 6;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubCodeOffset(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 2/*padding*/;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		protected override bool TryGetExportedRvaFromStubCore(IBinaryReader reader, IPEImage peImage, out uint funcRva) {
			funcRva = 0;

			// FF25xxxxxxxx	jmp DWORD PTR [xxxxxxxx]
			if (reader.ReadUInt16() != 0x25FF)
				return false;
			funcRva = reader.ReadUInt32() - (uint)peImage.ImageNTHeaders.OptionalHeader.ImageBase;
			return true;
		}

		public override void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				relocDirectory.Add(chunk, stubOffset + 4);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override void WriteStub(StubType stubType, BinaryWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				writer.Write((ushort)0);// padding
				writer.Write((ushort)0x25FF);
				writer.Write((uint)imageBase + managedFuncRva);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}

	sealed class X64CpuArch : CpuArch {
		public override uint GetStubAlignment(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 4;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubSize(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 2/*padding*/ + 12;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubCodeOffset(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 2/*padding*/;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		protected override bool TryGetExportedRvaFromStubCore(IBinaryReader reader, IPEImage peImage, out uint funcRva) {
			funcRva = 0;

			// 48A1xxxxxxxxxxxxxxxx		movabs	rax,[xxxxxxxxxxxxxxxx]
			// FFE0						jmp		rax
			if (reader.ReadUInt16() != 0xA148)
				return false;
			ulong absAddr = reader.ReadUInt64();
			if (reader.ReadUInt16() != 0xE0FF)
				return false;
			ulong rva = absAddr - peImage.ImageNTHeaders.OptionalHeader.ImageBase;
			if (rva > uint.MaxValue)
				return false;
			funcRva = (uint)rva;
			return true;
		}

		public override void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				relocDirectory.Add(chunk, stubOffset + 4);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override void WriteStub(StubType stubType, BinaryWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				writer.Write((ushort)0);// padding
				writer.Write((ushort)0xA148);
				writer.Write(imageBase + managedFuncRva);
				writer.Write((ushort)0xE0FF);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}

	sealed class ItaniumCpuArch : CpuArch {
		public override uint GetStubAlignment(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 16;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubSize(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 0x30;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubCodeOffset(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 0x20;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		protected override bool TryGetExportedRvaFromStubCore(IBinaryReader reader, IPEImage peImage, out uint funcRva) {
			funcRva = 0;

			// From ExportStubIA64Template in coreclr/src/ilasm/writer.cpp
			//
			// ld8    r9  = [gp]    ;;
			// ld8    r10 = [r9],8
			// nop.i                ;;
			// ld8    gp  = [r9]
			// mov    b6  = r10
			// br.cond.sptk.few  b6
			//
			// 0x0B, 0x48, 0x00, 0x02, 0x18, 0x10, 0xA0, 0x40, 
			// 0x24, 0x30, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 
			// 0x10, 0x08, 0x00, 0x12, 0x18, 0x10, 0x60, 0x50, 
			// 0x04, 0x80, 0x03, 0x00, 0x60, 0x00, 0x80, 0x00,
			// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,//address of the template
			// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 //address of VTFixup slot
			ulong addrTemplate = reader.ReadUInt64();
			ulong absAddr = reader.ReadUInt64();
			reader.Position = (long)peImage.ToFileOffset((RVA)(addrTemplate - peImage.ImageNTHeaders.OptionalHeader.ImageBase));
			if (reader.ReadUInt64() != 0x40A010180200480BUL)
				return false;
			if (reader.ReadUInt64() != 0x0004000000283024UL)
				return false;
			if (reader.ReadUInt64() != 0x5060101812000810UL)
				return false;
			if (reader.ReadUInt64() != 0x0080006000038004UL)
				return false;

			ulong rva = absAddr - peImage.ImageNTHeaders.OptionalHeader.ImageBase;
			if (rva > uint.MaxValue)
				return false;
			funcRva = (uint)rva;
			return true;
		}

		public override void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				relocDirectory.Add(chunk, stubOffset + 0x20);
				relocDirectory.Add(chunk, stubOffset + 0x28);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override void WriteStub(StubType stubType, BinaryWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				writer.Write(0x40A010180200480BUL);
				writer.Write(0x0004000000283024UL);
				writer.Write(0x5060101812000810UL);
				writer.Write(0x0080006000038004UL);
				writer.Write(imageBase + stubRva);
				writer.Write(imageBase + managedFuncRva);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}

	sealed class ArmCpuArch : CpuArch {
		public override uint GetStubAlignment(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 4;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubSize(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 8;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubCodeOffset(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 0;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		protected override bool TryGetExportedRvaFromStubCore(IBinaryReader reader, IPEImage peImage, out uint funcRva) {
			funcRva = 0;

			// DFF800F0		ldr.w	pc,[pc]
			// xxxxxxxx
			if (reader.ReadUInt32() != 0xF000F8DF)
				return false;
			funcRva = reader.ReadUInt32() - (uint)peImage.ImageNTHeaders.OptionalHeader.ImageBase;
			return true;
		}

		public override void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				relocDirectory.Add(chunk, stubOffset + 4);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override void WriteStub(StubType stubType, BinaryWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				writer.Write(0xF000F8DF);
				writer.Write((uint)imageBase + managedFuncRva);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/CustomAttribute.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using dnlib.Threading;
using dnlib.IO;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A custom attribute
	/// </summary>
	public sealed class CustomAttribute : ICustomAttribute {
		ICustomAttributeType ctor;
		byte[] rawData;
		readonly ThreadSafe.IList<CAArgument> arguments;
		readonly ThreadSafe.IList<CANamedArgument> namedArguments;
		IBinaryReader blobReader;

		/// <summary>
		/// Gets/sets the custom attribute constructor
		/// </summary>
		public ICustomAttributeType Constructor {
			get { return ctor; }
			set { ctor = value; }
		}

		/// <summary>
		/// Gets the attribute type
		/// </summary>
		public ITypeDefOrRef AttributeType {
			get {
				var cat = ctor;
				return cat == null ? null : cat.DeclaringType;
			}
		}

		/// <summary>
		/// Gets the full name of the attribute type
		/// </summary>
		public string TypeFullName {
			get {
				var mrCtor = ctor as MemberRef;
				if (mrCtor != null)
					return mrCtor.GetDeclaringTypeFullName() ?? string.Empty;

				var mdCtor = ctor as MethodDef;
				if (mdCtor != null) {
					var declType = mdCtor.DeclaringType;
					if (declType != null)
						return declType.FullName;
				}

				return string.Empty;
			}
		}

		/// <summary>
		/// <c>true</c> if the raw custom attribute blob hasn't been parsed
		/// </summary>
		public bool IsRawBlob {
			get { return rawData != null; }
		}

		/// <summary>
		/// Gets the raw custom attribute blob or <c>null</c> if the CA was successfully parsed.
		/// </summary>
		public byte[] RawData {
			get { return rawData; }
		}

		/// <summary>
		/// Gets all constructor arguments
		/// </summary>
		public ThreadSafe.IList<CAArgument> ConstructorArguments {
			get { return arguments; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ConstructorArguments"/> is not empty
		/// </summary>
		public bool HasConstructorArguments {
			get { return arguments.Count > 0; }
		}

		/// <summary>
		/// Gets all named arguments (field and property values)
		/// </summary>
		public ThreadSafe.IList<CANamedArgument> NamedArguments {
			get { return namedArguments; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="NamedArguments"/> is not empty
		/// </summary>
		public bool HasNamedArguments {
			get { return namedArguments.Count > 0; }
		}

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are field arguments
		/// </summary>
		public IEnumerable<CANamedArgument> Fields {
			get {
				foreach (var namedArg in namedArguments.GetSafeEnumerable()) {
					if (namedArg.IsField)
						yield return namedArg;
				}
			}
		}

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are property arguments
		/// </summary>
		public IEnumerable<CANamedArgument> Properties {
			get {
				foreach (var namedArg in namedArguments.GetSafeEnumerable()) {
					if (namedArg.IsProperty)
						yield return namedArg;
				}
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="rawData">Raw custom attribute blob</param>
		public CustomAttribute(ICustomAttributeType ctor, byte[] rawData)
			: this(ctor, null, null, null) {
			this.rawData = rawData;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		public CustomAttribute(ICustomAttributeType ctor)
			: this(ctor, null, null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="arguments">Constructor arguments or <c>null</c> if none</param>
		public CustomAttribute(ICustomAttributeType ctor, IEnumerable<CAArgument> arguments)
			: this(ctor, arguments, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="namedArguments">Named arguments or <c>null</c> if none</param>
		public CustomAttribute(ICustomAttributeType ctor, IEnumerable<CANamedArgument> namedArguments)
			: this(ctor, null, namedArguments) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="arguments">Constructor arguments or <c>null</c> if none</param>
		/// <param name="namedArguments">Named arguments or <c>null</c> if none</param>
		public CustomAttribute(ICustomAttributeType ctor, IEnumerable<CAArgument> arguments, IEnumerable<CANamedArgument> namedArguments)
			: this(ctor, arguments, namedArguments, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="arguments">Constructor arguments or <c>null</c> if none</param>
		/// <param name="namedArguments">Named arguments or <c>null</c> if none</param>
		/// <param name="blobReader">A reader that returns the original custom attribute blob data</param>
		public CustomAttribute(ICustomAttributeType ctor, IEnumerable<CAArgument> arguments, IEnumerable<CANamedArgument> namedArguments, IBinaryReader blobReader) {
			this.ctor = ctor;
			this.arguments = arguments == null ? ThreadSafeListCreator.Create<CAArgument>() : ThreadSafeListCreator.Create<CAArgument>(arguments);
			this.namedArguments = namedArguments == null ? ThreadSafeListCreator.Create<CANamedArgument>() : ThreadSafeListCreator.Create<CANamedArgument>(namedArguments);
			this.blobReader = blobReader;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="arguments">Constructor arguments. The list is now owned by this instance.</param>
		/// <param name="namedArguments">Named arguments. The list is now owned by this instance.</param>
		/// <param name="blobReader">A reader that returns the original custom attribute blob data</param>
		internal CustomAttribute(ICustomAttributeType ctor, List<CAArgument> arguments, List<CANamedArgument> namedArguments, IBinaryReader blobReader) {
			this.ctor = ctor;
			this.arguments = arguments == null ? ThreadSafeListCreator.Create<CAArgument>() : ThreadSafeListCreator.MakeThreadSafe(arguments);
			this.namedArguments = namedArguments == null ? ThreadSafeListCreator.Create<CANamedArgument>() : ThreadSafeListCreator.MakeThreadSafe(namedArguments);
			this.blobReader = blobReader;
		}

		/// <summary>
		/// Gets the field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of field</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetField(string name) {
			return GetNamedArgument(name, true);
		}

		/// <summary>
		/// Gets the field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of field</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetField(UTF8String name) {
			return GetNamedArgument(name, true);
		}

		/// <summary>
		/// Gets the property named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetProperty(string name) {
			return GetNamedArgument(name, false);
		}

		/// <summary>
		/// Gets the property named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetProperty(UTF8String name) {
			return GetNamedArgument(name, false);
		}

		/// <summary>
		/// Gets the property/field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of property/field</param>
		/// <param name="isField"><c>true</c> if it's a field, <c>false</c> if it's a property</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetNamedArgument(string name, bool isField) {
			foreach (var namedArg in namedArguments.GetSafeEnumerable()) {
				if (namedArg.IsField == isField && UTF8String.ToSystemStringOrEmpty(namedArg.Name) == name)
					return namedArg;
			}
			return null;
		}

		/// <summary>
		/// Gets the property/field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of property/field</param>
		/// <param name="isField"><c>true</c> if it's a field, <c>false</c> if it's a property</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetNamedArgument(UTF8String name, bool isField) {
			foreach (var namedArg in namedArguments.GetSafeEnumerable()) {
				if (namedArg.IsField == isField && UTF8String.Equals(namedArg.Name, name))
					return namedArg;
			}
			return null;
		}

		/// <summary>
		/// Gets the binary custom attribute data that was used to create this instance.
		/// </summary>
		/// <returns>Blob of this custom attribute</returns>
		public byte[] GetBlob() {
			if (rawData != null)
				return rawData;
			if (blob != null)
				return blob;
#if THREAD_SAFE
			if (blobReader != null) {
				lock (this) {
#endif
					if (blobReader != null) {
						blob = blobReader.ReadAllBytes();
						blobReader.Dispose();
						blobReader = null;
						return blob;
					}
#if THREAD_SAFE
				}
			}
#endif
			if (blob != null)
				return blob;
			return blob = new byte[0];
		}
		byte[] blob;

		/// <inheritdoc/>
		public override string ToString() {
			return TypeFullName;
		}
	}

	/// <summary>
	/// A custom attribute constructor argument
	/// </summary>
	public struct CAArgument : ICloneable {
		TypeSig type;
		object value;

		/// <summary>
		/// Gets/sets the argument type
		/// </summary>
		public TypeSig Type {
			get { return type; }
			set { type = value; }
		}

		/// <summary>
		/// Gets/sets the argument value
		/// </summary>
		public object Value {
			get { return value; }
			set { this.value = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Argument type</param>
		public CAArgument(TypeSig type) {
			this.type = type;
			this.value = null;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Argument type</param>
		/// <param name="value">Argument value</param>
		public CAArgument(TypeSig type, object value) {
			this.type = type;
			this.value = value;
		}

		object ICloneable.Clone() {
			return Clone();
		}

		/// <summary>
		/// Clones this instance and any <see cref="CAArgument"/>s and <see cref="CANamedArgument"/>s
		/// referenced from this instance.
		/// </summary>
		/// <returns></returns>
		public CAArgument Clone() {
			var value = this.value;
			if (value is CAArgument)
				value = ((CAArgument)value).Clone();
			else if (value is IList<CAArgument>) {
				var args = (IList<CAArgument>)value;
				var newArgs = ThreadSafeListCreator.Create<CAArgument>(args.Count);
				foreach (var arg in args.GetSafeEnumerable())
					newArgs.Add(arg.Clone());
				value = newArgs;
			}
			return new CAArgument(type, value);
		}

		/// <inheritdoc/>
		public override string ToString() {
			object v = value;
			return string.Format("{0} ({1})", v == null ? "null" : v, type);
		}
	}

	/// <summary>
	/// A custom attribute field/property argument
	/// </summary>
	public sealed class CANamedArgument : ICloneable {
		bool isField;
		TypeSig type;
		UTF8String name;
		CAArgument argument;

		/// <summary>
		/// <c>true</c> if it's a field
		/// </summary>
		public bool IsField {
			get { return isField; }
			set { isField = value; }
		}

		/// <summary>
		/// <c>true</c> if it's a property
		/// </summary>
		public bool IsProperty {
			get { return !isField; }
			set { isField = !value; }
		}

		/// <summary>
		/// Gets/sets the field/property type
		/// </summary>
		public TypeSig Type {
			get { return type; }
			set { type = value; }
		}

		/// <summary>
		/// Gets/sets the property/field name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}

		/// <summary>
		/// Gets/sets the argument
		/// </summary>
		public CAArgument Argument {
			get { return argument; }
			set { argument = value; }
		}

		/// <summary>
		/// Gets/sets the argument type
		/// </summary>
		public TypeSig ArgumentType {
			get { return argument.Type; }
			set { argument.Type = value; }
		}

		/// <summary>
		/// Gets/sets the argument value
		/// </summary>
		public object Value {
			get { return argument.Value; }
			set { argument.Value = value; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public CANamedArgument() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
		public CANamedArgument(bool isField) {
			this.isField = isField;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
		/// <param name="type">Field/property type</param>
		public CANamedArgument(bool isField, TypeSig type) {
			this.isField = isField;
			this.type = type;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
		/// <param name="type">Field/property type</param>
		/// <param name="name">Name of field/property</param>
		public CANamedArgument(bool isField, TypeSig type, UTF8String name) {
			this.isField = isField;
			this.type = type;
			this.name = name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
		/// <param name="type">Field/property type</param>
		/// <param name="name">Name of field/property</param>
		/// <param name="argument">Field/property argument</param>
		public CANamedArgument(bool isField, TypeSig type, UTF8String name, CAArgument argument) {
			this.isField = isField;
			this.type = type;
			this.name = name;
			this.argument = argument;
		}

		object ICloneable.Clone() {
			return Clone();
		}

		/// <summary>
		/// Clones this instance and any <see cref="CAArgument"/>s referenced from this instance.
		/// </summary>
		/// <returns></returns>
		public CANamedArgument Clone() {
			return new CANamedArgument(isField, type, name, argument.Clone());
		}

		/// <inheritdoc/>
		public override string ToString() {
			object v = Value;
			return string.Format("({0}) {1} {2} = {3} ({4})", isField ? "field" : "property", type, name, v == null ? "null" : v, ArgumentType);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/CustomAttributeCollection.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using dnlib.Utils;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Stores <see cref="CustomAttribute"/>s
	/// </summary>
	public class CustomAttributeCollection : LazyList<CustomAttribute> {
		/// <summary>
		/// Default constructor
		/// </summary>
		public CustomAttributeCollection() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Initial length of the list</param>
		/// <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
		/// <param name="readOriginalValue">Delegate instance that returns original values</param>
		public CustomAttributeCollection(int length, object context, MFunc<object, uint, CustomAttribute> readOriginalValue)
			: base(length, context, readOriginalValue) {
		}

		/// <summary>
		/// Checks whether a custom attribute is present
		/// </summary>
		/// <param name="fullName">Full name of custom attribute type</param>
		/// <returns><c>true</c> if the custom attribute type is present, <c>false</c> otherwise</returns>
		public bool IsDefined(string fullName) {
			return Find(fullName) != null;
		}

		/// <summary>
		/// Removes all custom attributes of a certain type
		/// </summary>
		/// <param name="fullName">Full name of custom attribute type that should be removed</param>
		public void RemoveAll(string fullName) {
			this.IterateAllReverse((tsList, index, value) => {
				if (value.TypeFullName == fullName)
					RemoveAt_NoLock(index);
			});
		}

		/// <summary>
		/// Finds a custom attribute
		/// </summary>
		/// <param name="fullName">Full name of custom attribute type</param>
		/// <returns>A <see cref="CustomAttribute"/> or <c>null</c> if it wasn't found</returns>
		public CustomAttribute Find(string fullName) {
			foreach (var ca in this.GetSafeEnumerable()) {
				if (ca != null && ca.TypeFullName == fullName)
					return ca;
			}

			return null;
		}

		/// <summary>
		/// Finds all custom attributes of a certain type
		/// </summary>
		/// <param name="fullName">Full name of custom attribute type</param>
		/// <returns>All <see cref="CustomAttribute"/>s of the requested type</returns>
		public IEnumerable<CustomAttribute> FindAll(string fullName) {
			foreach (var ca in this.GetSafeEnumerable()) {
				if (ca != null && ca.TypeFullName == fullName)
					yield return ca;
			}
		}

		/// <summary>
		/// Finds a custom attribute
		/// </summary>
		/// <param name="attrType">Custom attribute type</param>
		/// <returns>The first <see cref="CustomAttribute"/> found or <c>null</c> if none found</returns>
		public CustomAttribute Find(IType attrType) {
			return Find(attrType, 0);
		}

		/// <summary>
		/// Finds a custom attribute
		/// </summary>
		/// <param name="attrType">Custom attribute type</param>
		/// <param name="options">Attribute type comparison flags</param>
		/// <returns>The first <see cref="CustomAttribute"/> found or <c>null</c> if none found</returns>
		public CustomAttribute Find(IType attrType, SigComparerOptions options) {
			var comparer = new SigComparer(options);
			foreach (var ca in this.GetSafeEnumerable()) {
				if (comparer.Equals(ca.AttributeType, attrType))
					return ca;
			}
			return null;
		}

		/// <summary>
		/// Finds all custom attributes of a certain type
		/// </summary>
		/// <param name="attrType">Custom attribute type</param>
		/// <returns>All <see cref="CustomAttribute"/>s of the requested type</returns>
		public IEnumerable<CustomAttribute> FindAll(IType attrType) {
			return FindAll(attrType, 0);
		}

		/// <summary>
		/// Finds all custom attributes of a certain type
		/// </summary>
		/// <param name="attrType">Custom attribute type</param>
		/// <param name="options">Attribute type comparison flags</param>
		/// <returns>All <see cref="CustomAttribute"/>s of the requested type</returns>
		public IEnumerable<CustomAttribute> FindAll(IType attrType, SigComparerOptions options) {
			var comparer = new SigComparer(options);
			foreach (var ca in this.GetSafeEnumerable()) {
				if (comparer.Equals(ca.AttributeType, attrType))
					yield return ca;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/CustomAttributeReader.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization;
using dnlib.IO;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Searches for a type according to custom attribute search rules: first try the
	/// current assembly, and if that fails, try mscorlib
	/// </summary>
	sealed class CAAssemblyRefFinder : IAssemblyRefFinder {
		readonly ModuleDef module;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module to search first</param>
		public CAAssemblyRefFinder(ModuleDef module) {
			this.module = module;
		}

		/// <inheritdoc/>
		public AssemblyRef FindAssemblyRef(TypeRef nonNestedTypeRef) {
			var modAsm = module.Assembly;
			if (modAsm != null) {
				var type = modAsm.Find(nonNestedTypeRef);
				if (type != null)
					return module.UpdateRowId(new AssemblyRefUser(modAsm));
			}
			else if (module.Find(nonNestedTypeRef) != null)
				return AssemblyRef.CurrentAssembly;

			var corLibAsm = module.Context.AssemblyResolver.Resolve(module.CorLibTypes.AssemblyRef, module);
			if (corLibAsm != null) {
				var type = corLibAsm.Find(nonNestedTypeRef);
				if (type != null)
					return module.CorLibTypes.AssemblyRef;
			}

			if (modAsm != null)
				return module.UpdateRowId(new AssemblyRefUser(modAsm));
			return AssemblyRef.CurrentAssembly;
		}
	}

	/// <summary>
	/// Thrown by CustomAttributeReader when it fails to parse a custom attribute blob
	/// </summary>
	[Serializable]
	public class CABlobParserException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public CABlobParserException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		public CABlobParserException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="innerException">Other exception</param>
		public CABlobParserException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected CABlobParserException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Reads custom attributes from the #Blob stream
	/// </summary>
	public struct CustomAttributeReader : IDisposable {
		readonly ModuleDef module;
		readonly IBinaryReader reader;
		readonly GenericParamContext gpContext;
		GenericArguments genericArguments;
		RecursionCounter recursionCounter;
		bool verifyReadAllBytes;
		readonly bool ownReader;

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="offset">Offset of custom attribute in the #Blob stream</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDefMD readerModule, ICustomAttributeType ctor, uint offset) {
			return Read(readerModule, ctor, offset, new GenericParamContext());
		}

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="offset">Offset of custom attribute in the #Blob stream</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDefMD readerModule, ICustomAttributeType ctor, uint offset, GenericParamContext gpContext) {
			using (var reader = new CustomAttributeReader(readerModule, offset, gpContext)) {
				try {
					if (ctor == null)
						return reader.CreateRaw(ctor);
					return reader.Read(ctor);
				}
				catch (CABlobParserException) {
					return reader.CreateRaw(ctor);
				}
				catch (IOException) {
					return reader.CreateRaw(ctor);
				}
			}
		}

		CustomAttribute CreateRaw(ICustomAttributeType ctor) {
			return new CustomAttribute(ctor, GetRawBlob());
		}

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="caBlob">CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDef module, byte[] caBlob, ICustomAttributeType ctor) {
			return Read(module, MemoryImageStream.Create(caBlob), ctor, new GenericParamContext());
		}

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="stream">A stream positioned at the the first byte of the CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDef module, IBinaryReader stream, ICustomAttributeType ctor) {
			return Read(module, stream, ctor, new GenericParamContext());
		}

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="caBlob">CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDef module, byte[] caBlob, ICustomAttributeType ctor, GenericParamContext gpContext) {
			return Read(module, MemoryImageStream.Create(caBlob), ctor, gpContext);
		}

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="stream">A stream positioned at the the first byte of the CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDef module, IBinaryReader stream, ICustomAttributeType ctor, GenericParamContext gpContext) {
			using (var reader = new CustomAttributeReader(module, stream, gpContext)) {
				try {
					if (stream == null || ctor == null)
						return reader.CreateRaw(ctor);
					return reader.Read(ctor);
				}
				catch (CABlobParserException) {
					return reader.CreateRaw(ctor);
				}
				catch (IOException) {
					return reader.CreateRaw(ctor);
				}
			}
		}

		/// <summary>
		/// Reads custom attribute named arguments
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="stream">A stream positioned at the the first byte of the CA blob</param>
		/// <param name="numNamedArgs">Number of named arguments to read from <paramref name="stream"/></param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A list of <see cref="CANamedArgument"/>s or <c>null</c> if some error
		/// occurred.</returns>
		internal static List<CANamedArgument> ReadNamedArguments(ModuleDef module, IBinaryReader stream, int numNamedArgs, GenericParamContext gpContext) {
			try {
				using (var reader = new CustomAttributeReader(module, stream, false, gpContext))
					return reader.ReadNamedArguments(numNamedArgs);
			}
			catch (CABlobParserException) {
				return null;
			}
			catch (IOException) {
				return null;
			}
		}

		CustomAttributeReader(ModuleDefMD readerModule, uint offset, GenericParamContext gpContext) {
			this.module = readerModule;
			this.reader = readerModule.BlobStream.CreateStream(offset);
			this.ownReader = true;
			this.genericArguments = null;
			this.recursionCounter = new RecursionCounter();
			this.verifyReadAllBytes = false;
			this.gpContext = gpContext;
		}

		CustomAttributeReader(ModuleDef module, IBinaryReader reader, GenericParamContext gpContext) {
			this.module = module;
			this.reader = reader;
			this.ownReader = false;
			this.genericArguments = null;
			this.recursionCounter = new RecursionCounter();
			this.verifyReadAllBytes = false;
			this.gpContext = gpContext;
		}

		CustomAttributeReader(ModuleDef module, IBinaryReader reader, bool ownRerader, GenericParamContext gpContext) {
			this.module = module;
			this.reader = reader;
			this.ownReader = ownRerader;
			this.genericArguments = null;
			this.recursionCounter = new RecursionCounter();
			this.verifyReadAllBytes = false;
			this.gpContext = gpContext;
		}

		byte[] GetRawBlob() {
			return reader.ReadAllBytes();
		}

		CustomAttribute Read(ICustomAttributeType ctor) {
			var methodSig = ctor == null ? null : ctor.MethodSig;
			if (methodSig == null)
				throw new CABlobParserException("ctor is null or not a method");

			var mrCtor = ctor as MemberRef;
			if (mrCtor != null) {
				var owner = mrCtor.Class as TypeSpec;
				if (owner != null) {
					var gis = owner.TypeSig as GenericInstSig;
					if (gis != null) {
						genericArguments = new GenericArguments();
						genericArguments.PushTypeArgs(gis.GenericArguments);
					}
				}
			}

			bool isEmpty = methodSig.Params.Count == 0 && reader.Position == reader.Length;
			if (!isEmpty && reader.ReadUInt16() != 1)
				throw new CABlobParserException("Invalid CA blob prolog");

			var ctorArgs = new List<CAArgument>(methodSig.Params.Count);
			foreach (var arg in methodSig.Params.GetSafeEnumerable())
				ctorArgs.Add(ReadFixedArg(FixTypeSig(arg)));

			// Some tools don't write the next ushort if there are no named arguments.
			int numNamedArgs = reader.Position == reader.Length ? 0 : reader.ReadUInt16();
			var namedArgs = ReadNamedArguments(numNamedArgs);

			// verifyReadAllBytes will be set when we guess the underlying type of an enum.
			// To make sure we guessed right, verify that we read all bytes.
			if (verifyReadAllBytes && reader.Position != reader.Length)
				throw new CABlobParserException("Not all CA blob bytes were read");

			return new CustomAttribute(ctor, ctorArgs, namedArgs, CloneBlobReader(reader));
		}

		static IBinaryReader CloneBlobReader(IBinaryReader reader) {
			if (reader == null)
				return null;
			var imgStream = reader as IImageStream;
			if (imgStream != null)
				return imgStream.Clone();
			return MemoryImageStream.Create(reader.ReadAllBytes());
		}

		List<CANamedArgument> ReadNamedArguments(int numNamedArgs) {
			var namedArgs = new List<CANamedArgument>(numNamedArgs);
			for (int i = 0; i < numNamedArgs; i++) {
				if (reader.Position == reader.Length)
					break;
				namedArgs.Add(ReadNamedArgument());
			}
			return namedArgs;
		}

		TypeSig FixTypeSig(TypeSig type) {
			return SubstituteGenericParameter(type.RemoveModifiers()).RemoveModifiers();
		}

		TypeSig SubstituteGenericParameter(TypeSig type) {
			if (genericArguments == null)
				return type;
			return genericArguments.Resolve(type);
		}

		CAArgument ReadFixedArg(TypeSig argType) {
			if (!recursionCounter.Increment())
				throw new CABlobParserException("Too much recursion");
			if (argType == null)
				throw new CABlobParserException("null argType");
			CAArgument result;

			var arrayType = argType as SZArraySig;
			if (arrayType != null)
				result = ReadArrayArgument(arrayType);
			else
				result = ReadElem(argType);

			recursionCounter.Decrement();
			return result;
		}

		CAArgument ReadElem(TypeSig argType) {
			if (argType == null)
				throw new CABlobParserException("null argType");
			TypeSig realArgType;
			var value = ReadValue((SerializationType)argType.ElementType, argType, out realArgType);
			if (realArgType == null)
				throw new CABlobParserException("Invalid arg type");

			// One example when this is true is when prop/field type is object and
			// value type is string[]
			if (value is CAArgument)
				return (CAArgument)value;

			return new CAArgument(realArgType, value);
		}

		object ReadValue(SerializationType etype, TypeSig argType, out TypeSig realArgType) {
			if (!recursionCounter.Increment())
				throw new CABlobParserException("Too much recursion");

			object result;
			switch (etype) {
			case SerializationType.Boolean:
				realArgType = module.CorLibTypes.Boolean;
				result = reader.ReadByte() != 0;
				break;

			case SerializationType.Char:
				realArgType = module.CorLibTypes.Char;
				result = (char)reader.ReadUInt16();
				break;

			case SerializationType.I1:
				realArgType = module.CorLibTypes.SByte;
				result = reader.ReadSByte();
				break;

			case SerializationType.U1:
				realArgType = module.CorLibTypes.Byte;
				result = reader.ReadByte();
				break;

			case SerializationType.I2:
				realArgType = module.CorLibTypes.Int16;
				result = reader.ReadInt16();
				break;

			case SerializationType.U2:
				realArgType = module.CorLibTypes.UInt16;
				result = reader.ReadUInt16();
				break;

			case SerializationType.I4:
				realArgType = module.CorLibTypes.Int32;
				result = reader.ReadInt32();
				break;

			case SerializationType.U4:
				realArgType = module.CorLibTypes.UInt32;
				result = reader.ReadUInt32();
				break;

			case SerializationType.I8:
				realArgType = module.CorLibTypes.Int64;
				result = reader.ReadInt64();
				break;

			case SerializationType.U8:
				realArgType = module.CorLibTypes.UInt64;
				result = reader.ReadUInt64();
				break;

			case SerializationType.R4:
				realArgType = module.CorLibTypes.Single;
				result = reader.ReadSingle();
				break;

			case SerializationType.R8:
				realArgType = module.CorLibTypes.Double;
				result = reader.ReadDouble();
				break;

			case SerializationType.String:
				realArgType = module.CorLibTypes.String;
				result = ReadUTF8String();
				break;

			// It's ET.ValueType if it's eg. a ctor enum arg type
			case (SerializationType)ElementType.ValueType:
				if (argType == null)
					throw new CABlobParserException("Invalid element type");
				realArgType = argType;
				result = ReadEnumValue(GetEnumUnderlyingType(argType));
				break;

			// It's ET.Object if it's a ctor object arg type
			case (SerializationType)ElementType.Object:
			case SerializationType.TaggedObject:
				realArgType = ReadFieldOrPropType();
				var arraySig = realArgType as SZArraySig;
				if (arraySig != null)
					result = ReadArrayArgument(arraySig);
				else {
					TypeSig tmpType;
					result = ReadValue((SerializationType)realArgType.ElementType, realArgType, out tmpType);
				}
				break;

			// It's ET.Class if it's eg. a ctor System.Type arg type
			case (SerializationType)ElementType.Class:
				var tdr = argType as TypeDefOrRefSig;
				if (tdr != null && tdr.DefinitionAssembly.IsCorLib() && tdr.Namespace == "System") {
					if (tdr.TypeName == "Type") {
						result = ReadValue(SerializationType.Type, tdr, out realArgType);
						break;
					}
					if (tdr.TypeName == "String") {
						result = ReadValue(SerializationType.String, tdr, out realArgType);
						break;
					}
					if (tdr.TypeName == "Object") {
						result = ReadValue(SerializationType.TaggedObject, tdr, out realArgType);
						break;
					}
				}

				// Assume it's an enum that couldn't be resolved
				realArgType = argType;
				result = ReadEnumValue(null);
				break;

			case SerializationType.Type:
				realArgType = argType;
				result = ReadType(true);
				break;

			case SerializationType.Enum:
				realArgType = ReadType(false);
				result = ReadEnumValue(GetEnumUnderlyingType(realArgType));
				break;

			default:
				throw new CABlobParserException("Invalid element type");
			}

			recursionCounter.Decrement();
			return result;
		}

		object ReadEnumValue(TypeSig underlyingType) {
			if (underlyingType != null) {
				if (underlyingType.ElementType < ElementType.Boolean || underlyingType.ElementType > ElementType.U8)
					throw new CABlobParserException("Invalid enum underlying type");
				TypeSig realArgType;
				return ReadValue((SerializationType)underlyingType.ElementType, underlyingType, out realArgType);
			}

			// We couldn't resolve the type ref. It should be an enum, but we don't know for sure.
			// Most enums use Int32 as the underlying type. Assume that's true also in this case.
			// Since we're guessing, verify that we've read all CA blob bytes. If we haven't, then
			// we probably guessed wrong.
			verifyReadAllBytes = true;
			return reader.ReadInt32();
		}

		TypeSig ReadType(bool canReturnNull) {
			var name = ReadUTF8String();
			if (canReturnNull && (object)name == null)
				return null;
			var asmRefFinder = new CAAssemblyRefFinder(module);
			var type = TypeNameParser.ParseAsTypeSigReflection(module, UTF8String.ToSystemStringOrEmpty(name), asmRefFinder, gpContext);
			if (type == null)
				throw new CABlobParserException("Could not parse type");
			return type;
		}

		/// <summary>
		/// Gets the enum's underlying type
		/// </summary>
		/// <param name="type">An enum type</param>
		/// <returns>The underlying type or <c>null</c> if we couldn't resolve the type ref</returns>
		/// <exception cref="CABlobParserException">If <paramref name="type"/> is not an enum or <c>null</c></exception>
		static TypeSig GetEnumUnderlyingType(TypeSig type) {
			if (type == null)
				throw new CABlobParserException("null enum type");
			var td = GetTypeDef(type);
			if (td == null)
				return null;
			if (!td.IsEnum)
				throw new CABlobParserException("Not an enum");
			return td.GetEnumUnderlyingType().RemoveModifiers();
		}

		/// <summary>
		/// Converts <paramref name="type"/> to a <see cref="TypeDef"/>, possibly resolving
		/// a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if we couldn't resolve the
		/// <see cref="TypeRef"/> or if <paramref name="type"/> is a type spec</returns>
		static TypeDef GetTypeDef(TypeSig type) {
			var tdr = type as TypeDefOrRefSig;
			if (tdr != null) {
				var td = tdr.TypeDef;
				if (td != null)
					return td;

				var tr = tdr.TypeRef;
				if (tr != null)
					return tr.Resolve();
			}

			return null;
		}

		CAArgument ReadArrayArgument(SZArraySig arrayType) {
			if (!recursionCounter.Increment())
				throw new CABlobParserException("Too much recursion");
			var arg = new CAArgument(arrayType);

			int arrayCount = reader.ReadInt32();
			if (arrayCount == -1) {	// -1 if it's null
			}
			else if (arrayCount < 0)
				throw new CABlobParserException("Array is too big");
			else {
				var array = ThreadSafeListCreator.Create<CAArgument>(arrayCount);
				arg.Value = array;
				for (int i = 0; i < arrayCount; i++)
					array.Add(ReadFixedArg(FixTypeSig(arrayType.Next)));
			}

			recursionCounter.Decrement();
			return arg;
		}

		CANamedArgument ReadNamedArgument() {
			bool isField;
			switch ((SerializationType)reader.ReadByte()) {
			case SerializationType.Property:isField = false; break;
			case SerializationType.Field:	isField = true; break;
			default: throw new CABlobParserException("Named argument is not a field/property");
			}

			TypeSig fieldPropType = ReadFieldOrPropType();
			var name = ReadUTF8String();
			var argument = ReadFixedArg(fieldPropType);

			return new CANamedArgument(isField, fieldPropType, name, argument);
		}

		TypeSig ReadFieldOrPropType() {
			if (!recursionCounter.Increment())
				throw new CABlobParserException("Too much recursion");
			TypeSig result;
			switch ((SerializationType)reader.ReadByte()) {
			case SerializationType.Boolean: result = module.CorLibTypes.Boolean; break;
			case SerializationType.Char:	result = module.CorLibTypes.Char; break;
			case SerializationType.I1:		result = module.CorLibTypes.SByte; break;
			case SerializationType.U1:		result = module.CorLibTypes.Byte; break;
			case SerializationType.I2:		result = module.CorLibTypes.Int16; break;
			case SerializationType.U2:		result = module.CorLibTypes.UInt16; break;
			case SerializationType.I4:		result = module.CorLibTypes.Int32; break;
			case SerializationType.U4:		result = module.CorLibTypes.UInt32; break;
			case SerializationType.I8:		result = module.CorLibTypes.Int64; break;
			case SerializationType.U8:		result = module.CorLibTypes.UInt64; break;
			case SerializationType.R4:		result = module.CorLibTypes.Single; break;
			case SerializationType.R8:		result = module.CorLibTypes.Double; break;
			case SerializationType.String:	result = module.CorLibTypes.String; break;
			case SerializationType.SZArray: result = new SZArraySig(ReadFieldOrPropType()); break;
			case SerializationType.Type:	result = new ClassSig(module.CorLibTypes.GetTypeRef("System", "Type")); break;
			case SerializationType.TaggedObject: result = module.CorLibTypes.Object; break;
			case SerializationType.Enum:	result = ReadType(false); break;
			default: throw new CABlobParserException("Invalid type");
			}
			recursionCounter.Decrement();
			return result;
		}

		UTF8String ReadUTF8String() {
			if (reader.ReadByte() == 0xFF)
				return null;
			reader.Position--;
			uint len;
			if (!reader.ReadCompressedUInt32(out len))
				throw new CABlobParserException("Could not read compressed UInt32");
			if (len == 0)
				return UTF8String.Empty;
			return new UTF8String(reader.ReadBytes((int)len));
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (ownReader && reader != null)
				reader.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/DeclSecurity.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the DeclSecurity table
	/// </summary>
	[DebuggerDisplay("{Action} Count={SecurityAttributes.Count}")]
	public abstract class DeclSecurity : IHasCustomAttribute, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.DeclSecurity, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 8; }
		}

		/// <summary>
		/// From column DeclSecurity.Action
		/// </summary>
		public SecurityAction Action {
			get { return action; }
			set { action = value; }
		}
		/// <summary/>
		protected SecurityAction action;

		/// <summary>
		/// From column DeclSecurity.PermissionSet
		/// </summary>
		public ThreadSafe.IList<SecurityAttribute> SecurityAttributes {
			get {
				if (securityAttributes == null)
					InitializeSecurityAttributes();
				return securityAttributes;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<SecurityAttribute> securityAttributes;
		/// <summary>Initializes <see cref="securityAttributes"/></summary>
		protected virtual void InitializeSecurityAttributes() {
			Interlocked.CompareExchange(ref securityAttributes, ThreadSafeListCreator.Create<SecurityAttribute>(), null);
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 8; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// <c>true</c> if <see cref="SecurityAttributes"/> is not empty
		/// </summary>
		public bool HasSecurityAttributes {
			get { return SecurityAttributes.Count > 0; }
		}

		/// <summary>
		/// Gets the blob data or <c>null</c> if there's none
		/// </summary>
		/// <returns>Blob data or <c>null</c></returns>
		public abstract byte[] GetBlob();

		/// <summary>
		/// Returns the .NET 1.x XML string or null if it's not a .NET 1.x format
		/// </summary>
		/// <returns></returns>
		public string GetNet1xXmlString() {
			return GetNet1xXmlStringInternal(SecurityAttributes);
		}

		internal static string GetNet1xXmlStringInternal(IList<SecurityAttribute> secAttrs) {
			if (secAttrs == null || secAttrs.Count != 1)
				return null;
			var sa = secAttrs[0];
			if (sa == null || sa.TypeFullName != "System.Security.Permissions.PermissionSetAttribute")
				return null;
			if (sa.NamedArguments.Count != 1)
				return null;
			var na = sa.NamedArguments[0];
			if (na == null || !na.IsProperty || na.Name != "XML")
				return null;
			if (na.ArgumentType.GetElementType() != ElementType.String)
				return null;
			var arg = na.Argument;
			if (arg.Type.GetElementType() != ElementType.String)
				return null;
			var utf8 = arg.Value as UTF8String;
			if ((object)utf8 != null)
				return utf8;
			var s = arg.Value as string;
			if (s != null)
				return s;
			return null;
		}
	}

	/// <summary>
	/// A DeclSecurity row created by the user and not present in the original .NET file
	/// </summary>
	public class DeclSecurityUser : DeclSecurity {
		/// <summary>
		/// Default constructor
		/// </summary>
		public DeclSecurityUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="action">The security action</param>
		/// <param name="securityAttrs">The security attributes (now owned by this)</param>
		public DeclSecurityUser(SecurityAction action, IList<SecurityAttribute> securityAttrs) {
			this.action = action;
			this.securityAttributes = ThreadSafeListCreator.MakeThreadSafe(securityAttrs);
		}

		/// <inheritdoc/>
		public override byte[] GetBlob() {
			return null;
		}
	}

	/// <summary>
	/// Created from a row in the DeclSecurity table
	/// </summary>
	sealed class DeclSecurityMD : DeclSecurity, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly uint permissionSet;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeSecurityAttributes() {
			var gpContext = new GenericParamContext();
			var tmp = DeclSecurityReader.Read(readerModule, permissionSet, gpContext);
			Interlocked.CompareExchange(ref securityAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.DeclSecurity, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			var gpContext = new GenericParamContext();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>DeclSecurity</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public DeclSecurityMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.DeclSecurityTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("DeclSecurity rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.permissionSet = readerModule.TablesStream.ReadDeclSecurityRow(origRid, out this.action);
		}

		/// <inheritdoc/>
		public override byte[] GetBlob() {
			return readerModule.BlobStream.Read(permissionSet);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/DeclSecurityReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Text;
using dnlib.IO;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// Reads <c>DeclSecurity</c> blobs
	/// </summary>
	public struct DeclSecurityReader : IDisposable {
		readonly IBinaryReader reader;
		readonly ModuleDef module;
		readonly GenericParamContext gpContext;

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="sig"><c>#Blob</c> offset of <c>DeclSecurity</c> signature</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static ThreadSafe.IList<SecurityAttribute> Read(ModuleDefMD module, uint sig) {
			return Read(module, module.BlobStream.CreateStream(sig), new GenericParamContext());
		}

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="sig"><c>#Blob</c> offset of <c>DeclSecurity</c> signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static ThreadSafe.IList<SecurityAttribute> Read(ModuleDefMD module, uint sig, GenericParamContext gpContext) {
			return Read(module, module.BlobStream.CreateStream(sig), gpContext);
		}

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="blob"><c>DeclSecurity</c> blob</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static ThreadSafe.IList<SecurityAttribute> Read(ModuleDef module, byte[] blob) {
			return Read(module, MemoryImageStream.Create(blob), new GenericParamContext());
		}

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="blob"><c>DeclSecurity</c> blob</param>
		/// <param name="gpContext">Generic parameter context</param>/// 
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static ThreadSafe.IList<SecurityAttribute> Read(ModuleDef module, byte[] blob, GenericParamContext gpContext) {
			return Read(module, MemoryImageStream.Create(blob), gpContext);
		}

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="signature"><c>DeclSecurity</c> stream that will be owned by us</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static ThreadSafe.IList<SecurityAttribute> Read(ModuleDef module, IBinaryReader signature) {
			return Read(module, signature, new GenericParamContext());
		}

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="signature"><c>DeclSecurity</c> stream that will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static ThreadSafe.IList<SecurityAttribute> Read(ModuleDef module, IBinaryReader signature, GenericParamContext gpContext) {
			using (var reader = new DeclSecurityReader(module, signature, gpContext))
				return reader.Read();
		}

		DeclSecurityReader(ModuleDef module, IBinaryReader reader, GenericParamContext gpContext) {
			this.reader = reader;
			this.module = module;
			this.gpContext = gpContext;
		}

		ThreadSafe.IList<SecurityAttribute> Read() {
			try {
				if (reader.Position >= reader.Length)
					return ThreadSafeListCreator.Create<SecurityAttribute>();

				if (reader.ReadByte() == '.')
					return ReadBinaryFormat();
				reader.Position--;
				return ReadXmlFormat();
			}
			catch {
				return ThreadSafeListCreator.Create<SecurityAttribute>();
			}
		}

		/// <summary>
		/// Reads the new (.NET 2.0+) DeclSecurity blob format
		/// </summary>
		/// <returns></returns>
		ThreadSafe.IList<SecurityAttribute> ReadBinaryFormat() {
			int numAttrs = (int)reader.ReadCompressedUInt32();
			var list = ThreadSafeListCreator.Create<SecurityAttribute>(numAttrs);

			for (int i = 0; i < numAttrs; i++) {
				var name = ReadUTF8String();
				// Use CA search rules. Some tools don't write the fully qualified name.
				var attrRef = TypeNameParser.ParseReflection(module, UTF8String.ToSystemStringOrEmpty(name), new CAAssemblyRefFinder(module), gpContext);
				/*int blobLength = (int)*/reader.ReadCompressedUInt32();
				int numNamedArgs = (int)reader.ReadCompressedUInt32();
				var namedArgs = CustomAttributeReader.ReadNamedArguments(module, reader, numNamedArgs, gpContext);
				if (namedArgs == null)
					throw new ApplicationException("Could not read named arguments");
				list.Add(new SecurityAttribute(attrRef, namedArgs));
			}

			return list;
		}

		/// <summary>
		/// Reads the old (.NET 1.x) DeclSecurity blob format
		/// </summary>
		/// <returns></returns>
		ThreadSafe.IList<SecurityAttribute> ReadXmlFormat() {
			var xml = Encoding.Unicode.GetString(reader.ReadAllBytes());
			var sa = SecurityAttribute.CreateFromXml(module, xml);
			return ThreadSafeListCreator.Create<SecurityAttribute>(sa);
		}

		UTF8String ReadUTF8String() {
			uint len = reader.ReadCompressedUInt32();
			return len == 0 ? UTF8String.Empty : new UTF8String(reader.ReadBytes((int)len));
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (reader != null)
				reader.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ElementType.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// See CorHdr.h/CorElementType
	/// </summary>
	public enum ElementType : byte {
		/// <summary/>
		End			= 0x00,
		/// <summary>System.Void</summary>
		Void		= 0x01,
		/// <summary>System.Boolean</summary>
		Boolean		= 0x02,
		/// <summary>System.Char</summary>
		Char		= 0x03,
		/// <summary>System.SByte</summary>
		I1			= 0x04,
		/// <summary>System.Byte</summary>
		U1 			= 0x05,
		/// <summary>System.Int16</summary>
		I2 			= 0x06,
		/// <summary>System.UInt16</summary>
		U2 			= 0x07,
		/// <summary>System.Int32</summary>
		I4 			= 0x08,
		/// <summary>System.UInt32</summary>
		U4			= 0x09,
		/// <summary>System.Int64</summary>
		I8			= 0x0A,
		/// <summary>System.UInt64</summary>
		U8			= 0x0B,
		/// <summary>System.Single</summary>
		R4			= 0x0C,
		/// <summary>System.Double</summary>
		R8			= 0x0D,
		/// <summary>System.String</summary>
		String		= 0x0E,
		/// <summary>Pointer type (*)</summary>
		Ptr			= 0x0F,
		/// <summary>ByRef type (&amp;)</summary>
		ByRef		= 0x10,
		/// <summary>Value type</summary>
		ValueType	= 0x11,
		/// <summary>Reference type</summary>
		Class		= 0x12,
		/// <summary>Type generic parameter</summary>
		Var			= 0x13,
		/// <summary>Multidimensional array ([*], [,], [,,], ...)</summary>
		Array		= 0x14,
		/// <summary>Generic instance type</summary>
		GenericInst	= 0x15,
		/// <summary>Typed byref</summary>
		TypedByRef	= 0x16,
		/// <summary>Value array (don't use)</summary>
		ValueArray	= 0x17,
		/// <summary>System.IntPtr</summary>
		I			= 0x18,
		/// <summary>System.UIntPtr</summary>
		U			= 0x19,
		/// <summary>native real (don't use)</summary>
		R			= 0x1A,
		/// <summary>Function pointer</summary>
		FnPtr		= 0x1B,
		/// <summary>System.Object</summary>
		Object		= 0x1C,
		/// <summary>Single-dimension, zero lower bound array ([])</summary>
		SZArray		= 0x1D,
		/// <summary>Method generic parameter</summary>
		MVar		= 0x1E,
		/// <summary>Required C modifier</summary>
		CModReqd	= 0x1F,
		/// <summary>Optional C modifier</summary>
		CModOpt		= 0x20,
		/// <summary>Used internally by the CLR (don't use)</summary>
		Internal	= 0x21,
		/// <summary>Module (don't use)</summary>
		Module		= 0x3F,
		/// <summary>Sentinel (method sigs only)</summary>
		Sentinel	= 0x41,
		/// <summary>Pinned type (locals only)</summary>
		Pinned		= 0x45,
	}

	public static partial class Extensions {
		/// <summary>
		/// Returns <c>true</c> if it's an integer or a floating point type
		/// </summary>
		/// <param name="etype">Element type</param>
		/// <returns></returns>
		public static bool IsPrimitive(this ElementType etype) {
			switch (etype) {
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.I:
			case ElementType.U:
			case ElementType.R:
				return true;

			default:
				return false;
			}
		}

		/// <summary>
		/// Returns the size of the element type in bytes or <c>-1</c> if it's unknown
		/// </summary>
		/// <param name="etype">Element type</param>
		/// <param name="ptrSize">Size of a pointer</param>
		/// <returns></returns>
		public static int GetPrimitiveSize(this ElementType etype, int ptrSize = -1) {
			switch (etype) {
			case ElementType.Boolean:
			case ElementType.I1:
			case ElementType.U1:
				return 1;

			case ElementType.Char:
			case ElementType.I2:
			case ElementType.U2:
				return 2;

			case ElementType.I4:
			case ElementType.U4:
			case ElementType.R4:
				return 4;

			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R8:
				return 8;

			case ElementType.Ptr:
			case ElementType.FnPtr:
			case ElementType.I:
			case ElementType.U:
				return ptrSize;

			default:
				return -1;
			}
		}

		/// <summary>
		/// Checks whether it's a value type
		/// </summary>
		/// <param name="etype">this</param>
		/// <returns><c>true</c> if it's a value type, <c>false</c> if it's not a value type or
		/// if we couldn't determine whether it's a value type. Eg., it could be a generic
		/// instance type.</returns>
		public static bool IsValueType(this ElementType etype) {
			switch (etype) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.ValueType:
			case ElementType.TypedByRef:
			case ElementType.ValueArray:
			case ElementType.I:
			case ElementType.U:
			case ElementType.R:
				return true;

			case ElementType.GenericInst:
				// We don't have enough info to determine whether this is a value type
				return false;

			case ElementType.End:
			case ElementType.String:
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Class:
			case ElementType.Var:
			case ElementType.Array:
			case ElementType.FnPtr:
			case ElementType.Object:
			case ElementType.SZArray:
			case ElementType.MVar:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Internal:
			case ElementType.Module:
			case ElementType.Sentinel:
			case ElementType.Pinned:
			default:
				return false;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/EventAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Event attributes, see CorHdr.h/CorEventAttr
	/// </summary>
	[Flags]
	public enum EventAttributes : ushort {
		/// <summary>event is special.  Name describes how.</summary>
		SpecialName			= 0x0200,
		/// <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
		RTSpecialName		= 0x0400,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/EventDef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Event table
	/// </summary>
	public abstract class EventDef : IHasCustomAttribute, IHasSemantic, IHasCustomDebugInformation, IFullName, IMemberDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.Event, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 10; }
		}

		/// <inheritdoc/>
		public int HasSemanticTag {
			get { return 0; }
		}

		/// <summary>
		/// From column Event.EventFlags
		/// </summary>
		public EventAttributes Attributes {
			get { return (EventAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary/>
		protected int attributes;

		/// <summary>
		/// From column Event.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Event.EventType
		/// </summary>
		public ITypeDefOrRef EventType {
			get { return eventType; }
			set { eventType = value; }
		}
		/// <summary/>
		protected ITypeDefOrRef eventType;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 10; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// Gets/sets the adder method
		/// </summary>
		public MethodDef AddMethod {
			get {
				if (otherMethods == null)
					InitializeEventMethods();
				return addMethod;
			}
			set {
				if (otherMethods == null)
					InitializeEventMethods();
				addMethod = value;
			}
		}

		/// <summary>
		/// Gets/sets the invoker method
		/// </summary>
		public MethodDef InvokeMethod {
			get {
				if (otherMethods == null)
					InitializeEventMethods();
				return invokeMethod;
			}
			set {
				if (otherMethods == null)
					InitializeEventMethods();
				invokeMethod = value;
			}
		}

		/// <summary>
		/// Gets/sets the remover method
		/// </summary>
		public MethodDef RemoveMethod {
			get {
				if (otherMethods == null)
					InitializeEventMethods();
				return removeMethod;
			}
			set {
				if (otherMethods == null)
					InitializeEventMethods();
				removeMethod = value;
			}
		}

		/// <summary>
		/// Gets the other methods
		/// </summary>
		public ThreadSafe.IList<MethodDef> OtherMethods {
			get {
				if (otherMethods == null)
					InitializeEventMethods();
				return otherMethods;
			}
		}

		void InitializeEventMethods() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (otherMethods == null)
				InitializeEventMethods_NoLock();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Initializes <see cref="otherMethods"/>, <see cref="addMethod"/>,
		/// <see cref="invokeMethod"/> and <see cref="removeMethod"/>.
		/// </summary>
		protected virtual void InitializeEventMethods_NoLock() {
			otherMethods = ThreadSafeListCreator.Create<MethodDef>();
		}

		/// <summary/>
		protected MethodDef addMethod;
		/// <summary/>
		protected MethodDef invokeMethod;
		/// <summary/>
		protected MethodDef removeMethod;
		/// <summary/>
		protected ThreadSafe.IList<MethodDef> otherMethods;

		/// <summary>Reset <see cref="AddMethod"/>, <see cref="InvokeMethod"/>, <see cref="RemoveMethod"/>, <see cref="OtherMethods"/></summary>
		protected void ResetMethods() {
			otherMethods = null;
		}

		/// <summary>
		/// <c>true</c> if there are no methods attached to this event
		/// </summary>
		public bool IsEmpty {
			get {
				// The first property access initializes the other fields we access here
				return AddMethod == null &&
					removeMethod == null &&
					invokeMethod == null &&
					otherMethods.Count == 0;
			}
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="OtherMethods"/> is not empty
		/// </summary>
		public bool HasOtherMethods {
			get { return OtherMethods.Count > 0; }
		}

		/// <summary>
		/// Gets/sets the declaring type (owner type)
		/// </summary>
		public TypeDef DeclaringType {
			get { return declaringType2; }
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType != null)
					currentDeclaringType.Events.Remove(this);	// Will set DeclaringType2 = null
				if (value != null)
					value.Events.Add(this);	// Will set DeclaringType2 = value
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get { return declaringType2; }
		}

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get { return declaringType2; }
			set { declaringType2 = value; }
		}
		/// <summary/>
		protected TypeDef declaringType2;

		/// <inheritdoc/>
		public ModuleDef Module {
			get {
				var dt = declaringType2;
				return dt == null ? null : dt.Module;
			}
		}

		/// <summary>
		/// Gets the full name of the event
		/// </summary>
		public string FullName {
			get {
				var dt = declaringType2;
				return FullNameCreator.EventFullName(dt == null ? null : dt.FullName, name, eventType, null, null);
			}
		}

		bool IIsTypeOrMethod.IsType {
			get { return false; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		bool IMemberRef.IsField {
			get { return false; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return true; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, EventAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="EventAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get { return ((EventAttributes)attributes & EventAttributes.SpecialName) != 0; }
			set { ModifyAttributes(value, EventAttributes.SpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="EventAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get { return ((EventAttributes)attributes & EventAttributes.RTSpecialName) != 0; }
			set { ModifyAttributes(value, EventAttributes.RTSpecialName); }
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// An Event row created by the user and not present in the original .NET file
	/// </summary>
	public class EventDefUser : EventDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public EventDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public EventDefUser(UTF8String name)
			: this(name, null, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="type">Type</param>
		public EventDefUser(UTF8String name, ITypeDefOrRef type)
			: this(name, type, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="type">Type</param>
		/// <param name="flags">Flags</param>
		public EventDefUser(UTF8String name, ITypeDefOrRef type, EventAttributes flags) {
			this.name = name;
			this.eventType = type;
			this.attributes = (int)flags;
		}
	}

	/// <summary>
	/// Created from a row in the Event table
	/// </summary>
	sealed class EventDefMD : EventDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.Event, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(declaringType2), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Event</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public EventDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.EventTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("Event rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name;
			uint eventType = readerModule.TablesStream.ReadEventRow(origRid, out this.attributes, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.declaringType2 = readerModule.GetOwnerType(this);
			this.eventType = readerModule.ResolveTypeDefOrRef(eventType, new GenericParamContext(declaringType2));
		}

		internal EventDefMD InitializeAll() {
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(EventType);
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(AddMethod);
			MemberMDInitializer.Initialize(InvokeMethod);
			MemberMDInitializer.Initialize(RemoveMethod);
			MemberMDInitializer.Initialize(OtherMethods);
			MemberMDInitializer.Initialize(DeclaringType);
			return this;
		}

		/// <inheritdoc/>
		protected override void InitializeEventMethods_NoLock() {
			ThreadSafe.IList<MethodDef> newOtherMethods;
			var dt = declaringType2 as TypeDefMD;
			if (dt == null)
				newOtherMethods = ThreadSafeListCreator.Create<MethodDef>();
			else
				dt.InitializeEvent(this, out addMethod, out invokeMethod, out removeMethod, out newOtherMethods);
			otherMethods = newOtherMethods;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ExportedType.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ExportedType table
	/// </summary>
	public abstract class ExportedType : IHasCustomAttribute, IImplementation, IHasCustomDebugInformation, IType {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// The owner module
		/// </summary>
		protected ModuleDef module;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.ExportedType, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 17; }
		}

		/// <inheritdoc/>
		public int ImplementationTag {
			get { return 2; }
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 17; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				var td = Resolve();
				return td != null && td.IsValueType;
			}
		}

		/// <inheritdoc/>
		public bool IsPrimitive {
			get { return this.IsPrimitive(); }
		}

		/// <inheritdoc/>
		string IType.TypeName {
			get { return FullNameCreator.Name(this, false, null); }
		}

		/// <inheritdoc/>
		public UTF8String Name {
			get { return typeName; }
			set { typeName = value; }
		}

		/// <inheritdoc/>
		public string ReflectionName {
			get { return FullNameCreator.Name(this, true, null); }
		}

		/// <inheritdoc/>
		public string Namespace {
			get { return FullNameCreator.Namespace(this, false, null); }
		}

		/// <inheritdoc/>
		public string ReflectionNamespace {
			get { return FullNameCreator.Namespace(this, true, null); }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return FullNameCreator.FullName(this, false, null, null); }
		}

		/// <inheritdoc/>
		public string ReflectionFullName {
			get { return FullNameCreator.FullName(this, true, null, null); }
		}

		/// <inheritdoc/>
		public string AssemblyQualifiedName {
			get { return FullNameCreator.AssemblyQualifiedName(this, null, null); }
		}

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly {
			get { return FullNameCreator.DefinitionAssembly(this); }
		}

		/// <inheritdoc/>
		public IScope Scope {
			get { return FullNameCreator.Scope(this); }
		}

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType {
			get { return FullNameCreator.ScopeType(this); }
		}

		/// <summary>
		/// Always returns <c>false</c> since a <see cref="ExportedType"/> does not contain any
		/// <see cref="GenericVar"/> or <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter {
			get { return false; }
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get { return module; }
		}

		/// <inheritdoc/>
		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		/// <inheritdoc/>
		bool IIsTypeOrMethod.IsType {
			get { return true; }
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get { return 0; }
		}

		/// <summary>
		/// From column ExportedType.Flags
		/// </summary>
		public TypeAttributes Attributes {
			get { return (TypeAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column ExportedType.TypeDefId
		/// </summary>
		public uint TypeDefId {
			get { return typeDefId; }
			set { typeDefId = value; }
		}
		/// <summary/>
		protected uint typeDefId;

		/// <summary>
		/// From column ExportedType.TypeName
		/// </summary>
		public UTF8String TypeName {
			get { return typeName; }
			set { typeName = value; }
		}
		/// <summary/>
		protected UTF8String typeName;

		/// <summary>
		/// From column ExportedType.TypeNamespace
		/// </summary>
		public UTF8String TypeNamespace {
			get { return typeNamespace; }
			set { typeNamespace = value; }
		}
		/// <summary/>
		protected UTF8String typeNamespace;

		/// <summary>
		/// From column ExportedType.Implementation
		/// </summary>
		public IImplementation Implementation {
			get {
				if (!implementation_isInitialized)
					InitializeImplementation();
				return implementation;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				implementation = value;
				implementation_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected IImplementation implementation;
		/// <summary/>
		protected bool implementation_isInitialized;

		void InitializeImplementation() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (implementation_isInitialized)
				return;
			implementation = GetImplementation_NoLock();
			implementation_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="implementation"/></summary>
		protected virtual IImplementation GetImplementation_NoLock() {
			return null;
		}

		/// <summary>
		/// <c>true</c> if it's nested within another <see cref="ExportedType"/>
		/// </summary>
		public bool IsNested {
			get { return DeclaringType != null; }
		}

		/// <summary>
		/// Gets the declaring type, if any
		/// </summary>
		public ExportedType DeclaringType {
			get {
				if (!implementation_isInitialized)
					InitializeImplementation();
				return implementation as ExportedType;
			}
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(TypeAttributes andMask, TypeAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, TypeAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the visibility
		/// </summary>
		public TypeAttributes Visibility {
			get { return (TypeAttributes)attributes & TypeAttributes.VisibilityMask; }
			set { ModifyAttributes(~TypeAttributes.VisibilityMask, value & TypeAttributes.VisibilityMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NotPublic"/> is set
		/// </summary>
		public bool IsNotPublic {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.Public; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedPublic"/> is set
		/// </summary>
		public bool IsNestedPublic {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPublic; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedPrivate"/> is set
		/// </summary>
		public bool IsNestedPrivate {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamily"/> is set
		/// </summary>
		public bool IsNestedFamily {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamily; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedAssembly"/> is set
		/// </summary>
		public bool IsNestedAssembly {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedAssembly; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamANDAssem"/> is set
		/// </summary>
		public bool IsNestedFamilyAndAssembly {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamANDAssem; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamORAssem"/> is set
		/// </summary>
		public bool IsNestedFamilyOrAssembly {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamORAssem; }
		}

		/// <summary>
		/// Gets/sets the layout
		/// </summary>
		public TypeAttributes Layout {
			get { return (TypeAttributes)attributes & TypeAttributes.LayoutMask; }
			set { ModifyAttributes(~TypeAttributes.LayoutMask, value & TypeAttributes.LayoutMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AutoLayout"/> is set
		/// </summary>
		public bool IsAutoLayout {
			get { return ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.AutoLayout; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.SequentialLayout"/> is set
		/// </summary>
		public bool IsSequentialLayout {
			get { return ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.SequentialLayout; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.ExplicitLayout"/> is set
		/// </summary>
		public bool IsExplicitLayout {
			get { return ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.ExplicitLayout; }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Interface"/> bit
		/// </summary>
		public bool IsInterface {
			get { return ((TypeAttributes)attributes & TypeAttributes.Interface) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Interface); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Class"/> bit
		/// </summary>
		public bool IsClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.Interface) == 0; }
			set { ModifyAttributes(!value, TypeAttributes.Interface); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Abstract"/> bit
		/// </summary>
		public bool IsAbstract {
			get { return ((TypeAttributes)attributes & TypeAttributes.Abstract) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Abstract); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Sealed"/> bit
		/// </summary>
		public bool IsSealed {
			get { return ((TypeAttributes)attributes & TypeAttributes.Sealed) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Sealed); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get { return ((TypeAttributes)attributes & TypeAttributes.SpecialName) != 0; }
			set { ModifyAttributes(value, TypeAttributes.SpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Import"/> bit
		/// </summary>
		public bool IsImport {
			get { return ((TypeAttributes)attributes & TypeAttributes.Import) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Import); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Serializable"/> bit
		/// </summary>
		public bool IsSerializable {
			get { return ((TypeAttributes)attributes & TypeAttributes.Serializable) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Serializable); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.WindowsRuntime"/> bit
		/// </summary>
		public bool IsWindowsRuntime {
			get { return ((TypeAttributes)attributes & TypeAttributes.WindowsRuntime) != 0; }
			set { ModifyAttributes(value, TypeAttributes.WindowsRuntime); }
		}

		/// <summary>
		/// Gets/sets the string format
		/// </summary>
		public TypeAttributes StringFormat {
			get { return (TypeAttributes)attributes & TypeAttributes.StringFormatMask; }
			set { ModifyAttributes(~TypeAttributes.StringFormatMask, value & TypeAttributes.StringFormatMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AnsiClass"/> is set
		/// </summary>
		public bool IsAnsiClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AnsiClass; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.UnicodeClass"/> is set
		/// </summary>
		public bool IsUnicodeClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.UnicodeClass; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AutoClass"/> is set
		/// </summary>
		public bool IsAutoClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AutoClass; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.CustomFormatClass"/> is set
		/// </summary>
		public bool IsCustomFormatClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.CustomFormatClass; }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.BeforeFieldInit"/> bit
		/// </summary>
		public bool IsBeforeFieldInit {
			get { return ((TypeAttributes)attributes & TypeAttributes.BeforeFieldInit) != 0; }
			set { ModifyAttributes(value, TypeAttributes.BeforeFieldInit); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Forwarder"/> bit. See also <see cref="MovedToAnotherAssembly"/>
		/// </summary>
		public bool IsForwarder {
			get { return ((TypeAttributes)attributes & TypeAttributes.Forwarder) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Forwarder); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get { return ((TypeAttributes)attributes & TypeAttributes.RTSpecialName) != 0; }
			set { ModifyAttributes(value, TypeAttributes.RTSpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.HasSecurity"/> bit
		/// </summary>
		public bool HasSecurity {
			get { return ((TypeAttributes)attributes & TypeAttributes.HasSecurity) != 0; }
			set { ModifyAttributes(value, TypeAttributes.HasSecurity); }
		}

		const int MAX_LOOP_ITERS = 50;

		/// <summary>
		/// <c>true</c> if this type has been moved to another assembly
		/// </summary>
		public bool MovedToAnotherAssembly {
			get {
				ExportedType et = this;
				for (int i = 0; i < MAX_LOOP_ITERS; i++) {
					var impl = et.Implementation;
					if (impl is AssemblyRef)
						return et.IsForwarder;

					et = impl as ExportedType;
					if (et == null)
						break;
				}
				return false;
			}
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public TypeDef Resolve() {
			return Resolve(null);
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <param name="sourceModule">Source module or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public TypeDef Resolve(ModuleDef sourceModule) {
			if (module == null)
				return null;

			return Resolve(sourceModule, this);
		}

		static TypeDef Resolve(ModuleDef sourceModule, ExportedType et) {
			for (int i = 0; i < MAX_LOOP_ITERS; i++) {
				if (et == null || et.module == null)
					break;
				var resolver = et.module.Context.AssemblyResolver;
				var etAsm = resolver.Resolve(et.DefinitionAssembly, sourceModule ?? et.module);
				if (etAsm == null)
					break;

				var td = etAsm.Find(et.FullName, false);
				if (td != null)
					return td;

				et = FindExportedType(etAsm, et);
			}

			return null;
		}

		static ExportedType FindExportedType(AssemblyDef asm, ExportedType et) {
			foreach (var mod in asm.Modules.GetSafeEnumerable()) {
				foreach (var et2 in mod.ExportedTypes.GetSafeEnumerable()) {
					if (new SigComparer(SigComparerOptions.DontCompareTypeScope).Equals(et, et2))
						return et2;
				}
			}
			return null;
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public TypeDef ResolveThrow() {
			var type = Resolve();
			if (type != null)
				return type;
			throw new TypeResolveException(string.Format("Could not resolve type: {0} ({1})", this, DefinitionAssembly));
		}

		/// <summary>
		/// Converts this instance to a <see cref="TypeRef"/>
		/// </summary>
		/// <returns>A new <see cref="TypeRef"/> instance</returns>
		public TypeRef ToTypeRef() {
			TypeRef result = null, prev = null;
			var mod = module;
			IImplementation impl = this;
			for (int i = 0; i < MAX_LOOP_ITERS && impl != null; i++) {
				var et = impl as ExportedType;
				if (et != null) {
					var newTr = mod.UpdateRowId(new TypeRefUser(mod, et.TypeNamespace, et.TypeName));
					if (result == null)
						result = newTr;
					if (prev != null)
						prev.ResolutionScope = newTr;

					prev = newTr;
					impl = et.Implementation;
					continue;
				}

				var asmRef = impl as AssemblyRef;
				if (asmRef != null) {
					// prev is never null when we're here
					prev.ResolutionScope = asmRef;
					return result;
				}

				var file = impl as FileDef;
				if (file != null) {
					// prev is never null when we're here
					prev.ResolutionScope = FindModule(mod, file);
					return result;
				}

				break;
			}
			return result;
		}

		static ModuleDef FindModule(ModuleDef module, FileDef file) {
			if (module == null || file == null)
				return null;
			if (UTF8String.CaseInsensitiveEquals(module.Name, file.Name))
				return module;
			var asm = module.Assembly;
			if (asm == null)
				return null;
			return asm.FindModule(file.Name);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// An ExportedType row created by the user and not present in the original .NET file
	/// </summary>
	public class ExportedTypeUser : ExportedType {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		public ExportedTypeUser(ModuleDef module) {
			this.module = module;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="typeDefId">TypeDef ID</param>
		/// <param name="typeName">Type name</param>
		/// <param name="typeNamespace">Type namespace</param>
		/// <param name="flags">Flags</param>
		/// <param name="implementation">Implementation</param>
		public ExportedTypeUser(ModuleDef module, uint typeDefId, UTF8String typeNamespace, UTF8String typeName, TypeAttributes flags, IImplementation implementation) {
			this.module = module;
			this.typeDefId = typeDefId;
			this.typeName = typeName;
			this.typeNamespace = typeNamespace;
			this.attributes = (int)flags;
			this.implementation = implementation;
			this.implementation_isInitialized = true;
		}
	}

	/// <summary>
	/// Created from a row in the ExportedType table
	/// </summary>
	sealed class ExportedTypeMD : ExportedType, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly uint implementationRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.ExportedType, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override IImplementation GetImplementation_NoLock() {
			return readerModule.ResolveImplementation(implementationRid);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ExportedType</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ExportedTypeMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ExportedTypeTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("ExportedType rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.module = readerModule;
			uint name, @namespace;
			this.implementationRid = readerModule.TablesStream.ReadExportedTypeRow(origRid, out this.attributes, out this.typeDefId, out name, out @namespace);
			this.typeName = readerModule.StringsStream.ReadNoNull(name);
			this.typeNamespace = readerModule.StringsStream.ReadNoNull(@namespace);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Extensions.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class Extensions {
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/FieldAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Field flags, see CorHdr.h/CorFieldAttr
	/// </summary>
	[Flags]
	public enum FieldAttributes : ushort {
		/// <summary>member access mask - Use this mask to retrieve accessibility information.</summary>
		FieldAccessMask		= 0x0007,
		/// <summary>Member not referenceable.</summary>
		PrivateScope		= 0x0000,
		/// <summary>Member not referenceable.</summary>
		CompilerControlled	= PrivateScope,
		/// <summary>Accessible only by the parent type.</summary>
		Private				= 0x0001,
		/// <summary>Accessible by sub-types only in this Assembly.</summary>
		FamANDAssem			= 0x0002,
		/// <summary>Accessibly by anyone in the Assembly.</summary>
		Assembly			= 0x0003,
		/// <summary>Accessible only by type and sub-types.</summary>
		Family				= 0x0004,
		/// <summary>Accessibly by sub-types anywhere, plus anyone in assembly.</summary>
		FamORAssem			= 0x0005,
		/// <summary>Accessibly by anyone who has visibility to this scope.</summary>
		Public				= 0x0006,

		/// <summary>Defined on type, else per instance.</summary>
		Static				= 0x0010,
		/// <summary>Field may only be initialized, not written to after init.</summary>
		InitOnly			= 0x0020,
		/// <summary>Value is compile time constant.</summary>
		Literal				= 0x0040,
		/// <summary>Field does not have to be serialized when type is remoted.</summary>
		NotSerialized		= 0x0080,

		/// <summary>field is special.  Name describes how.</summary>
		SpecialName			= 0x0200,

		/// <summary>Implementation is forwarded through pinvoke.</summary>
		PinvokeImpl			= 0x2000,

		/// <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
		RTSpecialName		= 0x0400,
		/// <summary>Field has marshalling information.</summary>
		HasFieldMarshal		= 0x1000,
		/// <summary>Field has default.</summary>
		HasDefault			= 0x8000,
		/// <summary>Field has RVA.</summary>
		HasFieldRVA			= 0x0100,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/FieldDef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.PE;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Field table
	/// </summary>
	public abstract class FieldDef : IHasConstant, IHasCustomAttribute, IHasFieldMarshal, IMemberForwarded, IHasCustomDebugInformation, IField, ITokenOperand, IMemberDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.Field, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasConstantTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public int HasFieldMarshalTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		public int MemberForwardedTag {
			get { return 0; }
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// From column Field.Flags
		/// </summary>
		public FieldAttributes Attributes {
			get { return (FieldAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Field.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Field.Signature
		/// </summary>
		public CallingConventionSig Signature {
			get { return signature; }
			set { signature = value; }
		}
		/// <summary/>
		protected CallingConventionSig signature;

		/// <summary>
		/// Gets/sets the field layout offset
		/// </summary>
		public uint? FieldOffset {
			get {
				if (!fieldOffset_isInitialized)
					InitializeFieldOffset();
				return fieldOffset;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				fieldOffset = value;
				fieldOffset_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected uint? fieldOffset;
		/// <summary/>
		protected bool fieldOffset_isInitialized;

		void InitializeFieldOffset() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (fieldOffset_isInitialized)
				return;
			fieldOffset = GetFieldOffset_NoLock();
			fieldOffset_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="fieldOffset"/></summary>
		protected virtual uint? GetFieldOffset_NoLock() {
			return null;
		}

		/// <inheritdoc/>
		public MarshalType MarshalType {
			get {
				if (!marshalType_isInitialized)
					InitializeMarshalType();
				return marshalType;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				marshalType = value;
				marshalType_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected MarshalType marshalType;
		/// <summary/>
		protected bool marshalType_isInitialized;

		void InitializeMarshalType() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (marshalType_isInitialized)
				return;
			marshalType = GetMarshalType_NoLock();
			marshalType_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="marshalType"/></summary>
		protected virtual MarshalType GetMarshalType_NoLock() {
			return null;
		}

		/// <summary>Reset <see cref="MarshalType"/></summary>
		protected void ResetMarshalType() {
			marshalType_isInitialized = false;
		}

		/// <summary>
		/// Gets/sets the field RVA
		/// </summary>
		public RVA RVA {
			get {
				if (!rva_isInitialized)
					InitializeRVA();
				return rva;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				rva = value;
				rva_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected RVA rva;
		/// <summary/>
		protected bool rva_isInitialized;

		void InitializeRVA() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (rva_isInitialized)
				return;
			rva = GetRVA_NoLock();
			rva_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="rva"/></summary>
		protected virtual RVA GetRVA_NoLock() {
			return 0;
		}

		/// <summary>Reset <see cref="RVA"/></summary>
		protected void ResetRVA() {
			rva_isInitialized = false;
		}

		/// <summary>
		/// Gets/sets the initial value. Be sure to set <see cref="HasFieldRVA"/> to <c>true</c> if
		/// you write to this field.
		/// </summary>
		public byte[] InitialValue {
			get {
				if (!initialValue_isInitialized)
					InitializeInitialValue();
				return initialValue;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				initialValue = value;
				initialValue_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected byte[] initialValue;
		/// <summary/>
		protected bool initialValue_isInitialized;

		void InitializeInitialValue() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (initialValue_isInitialized)
				return;
			initialValue = GetInitialValue_NoLock();
			initialValue_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="initialValue"/></summary>
		protected virtual byte[] GetInitialValue_NoLock() {
			return null;
		}

		/// <summary>Reset <see cref="InitialValue"/></summary>
		protected void ResetInitialValue() {
			initialValue_isInitialized = false;
		}

		/// <inheritdoc/>
		public ImplMap ImplMap {
			get {
				if (!implMap_isInitialized)
					InitializeImplMap();
				return implMap;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				implMap = value;
				implMap_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ImplMap implMap;
		/// <summary/>
		protected bool implMap_isInitialized;

		void InitializeImplMap() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (implMap_isInitialized)
				return;
			implMap = GetImplMap_NoLock();
			implMap_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="implMap"/></summary>
		protected virtual ImplMap GetImplMap_NoLock() {
			return null;
		}

		/// <inheritdoc/>
		public Constant Constant {
			get {
				if (!constant_isInitialized)
					InitializeConstant();
				return constant;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				constant = value;
				constant_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Constant constant;
		/// <summary/>
		protected bool constant_isInitialized;

		void InitializeConstant() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (constant_isInitialized)
				return;
			constant = GetConstant_NoLock();
			constant_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="constant"/></summary>
		protected virtual Constant GetConstant_NoLock() {
			return null;
		}

		/// <summary>Reset <see cref="Constant"/></summary>
		protected void ResetConstant() {
			constant_isInitialized = false;
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public bool HasImplMap {
			get { return ImplMap != null; }
		}

		/// <summary>
		/// Gets/sets the declaring type (owner type)
		/// </summary>
		public TypeDef DeclaringType {
			get { return declaringType2; }
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType != null)
					currentDeclaringType.Fields.Remove(this);	// Will set DeclaringType2 = null
				if (value != null)
					value.Fields.Add(this);		// Will set DeclaringType2 = value
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get { return declaringType2; }
		}

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get { return declaringType2; }
			set { declaringType2 = value; }
		}
		/// <summary/>
		protected TypeDef declaringType2;

		/// <summary>
		/// Gets/sets the <see cref="FieldSig"/>
		/// </summary>
		public FieldSig FieldSig {
			get { return signature as FieldSig; }
			set { signature = value; }
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get {
				var dt = declaringType2;
				return dt == null ? null : dt.Module;
			}
		}

		bool IIsTypeOrMethod.IsType {
			get { return false; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		bool IMemberRef.IsField {
			get { return true; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return true; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldOffset"/> is not <c>null</c>
		/// </summary>
		public bool HasLayoutInfo {
			get { return FieldOffset != null; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Constant"/> is not <c>null</c>
		/// </summary>
		public bool HasConstant {
			get { return Constant != null; }
		}

		/// <summary>
		/// Gets the constant element type or <see cref="dnlib.DotNet.ElementType.End"/> if there's no constant
		/// </summary>
		public ElementType ElementType {
			get {
				var c = Constant;
				return c == null ? ElementType.End : c.Type;
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="MarshalType"/> is not <c>null</c>
		/// </summary>
		public bool HasMarshalType {
			get { return MarshalType != null; }
		}

		/// <summary>
		/// Gets/sets the field type
		/// </summary>
		public TypeSig FieldType {
			get { return FieldSig.GetFieldType(); }
			set {
				var sig = FieldSig;
				if (sig != null)
					sig.Type = value;
			}
		}

		/// <summary>
		/// Modify <see cref="attributes"/> field: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(FieldAttributes andMask, FieldAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, FieldAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the field access
		/// </summary>
		public FieldAttributes Access {
			get { return (FieldAttributes)attributes & FieldAttributes.FieldAccessMask; }
			set { ModifyAttributes(~FieldAttributes.FieldAccessMask, value & FieldAttributes.FieldAccessMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.PrivateScope"/> is set
		/// </summary>
		public bool IsCompilerControlled {
			get { return IsPrivateScope; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.PrivateScope"/> is set
		/// </summary>
		public bool IsPrivateScope {
			get { return ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.PrivateScope; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.Private"/> is set
		/// </summary>
		public bool IsPrivate {
			get { return ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Private; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.FamANDAssem"/> is set
		/// </summary>
		public bool IsFamilyAndAssembly {
			get { return ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.FamANDAssem; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.Assembly"/> is set
		/// </summary>
		public bool IsAssembly {
			get { return ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Assembly; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.Family"/> is set
		/// </summary>
		public bool IsFamily {
			get { return ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Family; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.FamORAssem"/> is set
		/// </summary>
		public bool IsFamilyOrAssembly {
			get { return ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.FamORAssem; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic {
			get { return ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Public; }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.Static"/> bit
		/// </summary>
		public bool IsStatic {
			get { return ((FieldAttributes)attributes & FieldAttributes.Static) != 0; }
			set { ModifyAttributes(value, FieldAttributes.Static); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.InitOnly"/> bit
		/// </summary>
		public bool IsInitOnly {
			get { return ((FieldAttributes)attributes & FieldAttributes.InitOnly) != 0; }
			set { ModifyAttributes(value, FieldAttributes.InitOnly); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.Literal"/> bit
		/// </summary>
		public bool IsLiteral {
			get { return ((FieldAttributes)attributes & FieldAttributes.Literal) != 0; }
			set { ModifyAttributes(value, FieldAttributes.Literal); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.NotSerialized"/> bit
		/// </summary>
		public bool IsNotSerialized {
			get { return ((FieldAttributes)attributes & FieldAttributes.NotSerialized) != 0; }
			set { ModifyAttributes(value, FieldAttributes.NotSerialized); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get { return ((FieldAttributes)attributes & FieldAttributes.SpecialName) != 0; }
			set { ModifyAttributes(value, FieldAttributes.SpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.PinvokeImpl"/> bit
		/// </summary>
		public bool IsPinvokeImpl {
			get { return ((FieldAttributes)attributes & FieldAttributes.PinvokeImpl) != 0; }
			set { ModifyAttributes(value, FieldAttributes.PinvokeImpl); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get { return ((FieldAttributes)attributes & FieldAttributes.RTSpecialName) != 0; }
			set { ModifyAttributes(value, FieldAttributes.RTSpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.HasFieldMarshal"/> bit
		/// </summary>
		public bool HasFieldMarshal {
			get { return ((FieldAttributes)attributes & FieldAttributes.HasFieldMarshal) != 0; }
			set { ModifyAttributes(value, FieldAttributes.HasFieldMarshal); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.HasDefault"/> bit
		/// </summary>
		public bool HasDefault {
			get { return ((FieldAttributes)attributes & FieldAttributes.HasDefault) != 0; }
			set { ModifyAttributes(value, FieldAttributes.HasDefault); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.HasFieldRVA"/> bit
		/// </summary>
		public bool HasFieldRVA {
			get { return ((FieldAttributes)attributes & FieldAttributes.HasFieldRVA) != 0; }
			set { ModifyAttributes(value, FieldAttributes.HasFieldRVA); }
		}

		/// <summary>
		/// Returns the full name of this field
		/// </summary>
		public string FullName {
			get {
				var dt = declaringType2;
				return FullNameCreator.FieldFullName(dt == null ? null : dt.FullName, name, FieldSig, null, null);
			}
		}

		/// <summary>
		/// Gets the size of this field in bytes or <c>0</c> if unknown.
		/// </summary>
		public uint GetFieldSize() {
			uint size;
			if (!GetFieldSize(out size))
				return 0;
			return size;
		}

		/// <summary>
		/// Gets the size of this field in bytes or <c>0</c> if unknown.
		/// </summary>
		/// <param name="size">Updated with size</param>
		/// <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
		public bool GetFieldSize(out uint size) {
			return GetFieldSize(declaringType2, FieldSig, out size);
		}

		/// <summary>
		/// Gets the size of this field in bytes or <c>0</c> if unknown.
		/// </summary>
		/// <param name="declaringType">The declaring type of <c>this</c></param>
		/// <param name="fieldSig">The field signature of <c>this</c></param>
		/// <param name="size">Updated with size</param>
		/// <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
		protected bool GetFieldSize(TypeDef declaringType, FieldSig fieldSig, out uint size) {
			return GetFieldSize(declaringType, fieldSig, GetPointerSize(declaringType), out size);
		}

		/// <summary>
		/// Gets the size of this field in bytes or <c>0</c> if unknown.
		/// </summary>
		/// <param name="declaringType">The declaring type of <c>this</c></param>
		/// <param name="fieldSig">The field signature of <c>this</c></param>
		/// <param name="ptrSize">Size of a pointer</param>
		/// <param name="size">Updated with size</param>
		/// <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
		protected bool GetFieldSize(TypeDef declaringType, FieldSig fieldSig, int ptrSize, out uint size) {
			size = 0;
			if (fieldSig == null)
				return false;
			return GetClassSize(declaringType, fieldSig.Type, ptrSize, out size);
		}

		bool GetClassSize(TypeDef declaringType, TypeSig ts, int ptrSize, out uint size) {
			size = 0;
			ts = ts.RemovePinnedAndModifiers();
			if (ts == null)
				return false;

			int size2 = ts.ElementType.GetPrimitiveSize(ptrSize);
			if (size2 >= 0) {
				size = (uint)size2;
				return true;
			}

			var tdrs = ts as TypeDefOrRefSig;
			if (tdrs == null)
				return false;

			var td = tdrs.TypeDef;
			if (td != null)
				return TypeDef.GetClassSize(td, out size);

			var tr = tdrs.TypeRef;
			if (tr != null)
				return TypeDef.GetClassSize(tr.Resolve(), out size);

			return false;
		}

		int GetPointerSize(TypeDef declaringType) {
			if (declaringType == null)
				return 4;
			var module = declaringType.Module;
			if (module == null)
				return 4;
			return module.GetPointerSize();
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A Field row created by the user and not present in the original .NET file
	/// </summary>
	public class FieldDefUser : FieldDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public FieldDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public FieldDefUser(UTF8String name)
			: this(name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="signature">Signature</param>
		public FieldDefUser(UTF8String name, FieldSig signature)
			: this(name, signature, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="signature">Signature</param>
		/// <param name="attributes">Flags</param>
		public FieldDefUser(UTF8String name, FieldSig signature, FieldAttributes attributes) {
			this.name = name;
			this.signature = signature;
			this.attributes = (int)attributes;
		}
	}

	/// <summary>
	/// Created from a row in the Field table
	/// </summary>
	sealed class FieldDefMD : FieldDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly FieldAttributes origAttributes;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.Field, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(declaringType2), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override uint? GetFieldOffset_NoLock() {
			return readerModule.TablesStream.ReadFieldLayoutRow2(readerModule.MetaData.GetFieldLayoutRid(origRid));
		}

		/// <inheritdoc/>
		protected override MarshalType GetMarshalType_NoLock() {
			return readerModule.ReadMarshalType(Table.Field, origRid, new GenericParamContext(declaringType2));
		}

		/// <inheritdoc/>
		protected override RVA GetRVA_NoLock() {
			RVA rva2;
			GetFieldRVA_NoLock(out rva2);
			return rva2;
		}

		/// <inheritdoc/>
		protected override byte[] GetInitialValue_NoLock() {
			RVA rva2;
			if (!GetFieldRVA_NoLock(out rva2))
				return null;
			return ReadInitialValue_NoLock(rva2);
		}

		/// <inheritdoc/>
		protected override ImplMap GetImplMap_NoLock() {
			return readerModule.ResolveImplMap(readerModule.MetaData.GetImplMapRid(Table.Field, origRid));
		}

		/// <inheritdoc/>
		protected override Constant GetConstant_NoLock() {
			return readerModule.ResolveConstant(readerModule.MetaData.GetConstantRid(Table.Field, origRid));
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Field</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public FieldDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.FieldTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("Field rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name;
			uint signature = readerModule.TablesStream.ReadFieldRow(origRid, out this.attributes, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.origAttributes = (FieldAttributes)attributes;
			this.declaringType2 = readerModule.GetOwnerType(this);
			this.signature = readerModule.ReadSignature(signature, new GenericParamContext(declaringType2));
		}

		internal FieldDefMD InitializeAll() {
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(Signature);
			MemberMDInitializer.Initialize(FieldOffset);
			MemberMDInitializer.Initialize(MarshalType);
			MemberMDInitializer.Initialize(RVA);
			MemberMDInitializer.Initialize(InitialValue);
			MemberMDInitializer.Initialize(ImplMap);
			MemberMDInitializer.Initialize(Constant);
			MemberMDInitializer.Initialize(DeclaringType);
			return this;
		}

		bool GetFieldRVA_NoLock(out RVA rva) {
			if ((origAttributes & FieldAttributes.HasFieldRVA) == 0) {
				rva = 0;
				return false;
			}
			return readerModule.TablesStream.ReadFieldRVARow(readerModule.MetaData.GetFieldRVARid(origRid), out rva);
		}

		byte[] ReadInitialValue_NoLock(RVA rva) {
			uint size;
			if (!GetFieldSize(declaringType2, signature as FieldSig, out size))
				return null;
			if (size >= int.MaxValue)
				return null;
			return readerModule.ReadDataAt(rva, (int)size);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/FileAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet {
	/// <summary>
	/// File row flags. See CorHdr.h/CorFileFlags
	/// </summary>
	[Flags]
	public enum FileAttributes : uint {
		/// <summary>This is not a resource file</summary>
		ContainsMetaData	= 0x0000,
		/// <summary>This is a resource file or other non-metadata-containing file</summary>
		ContainsNoMetaData	= 0x0001,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/FileDef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the File table
	/// </summary>
	public abstract class FileDef : IHasCustomAttribute, IImplementation, IHasCustomDebugInformation, IManagedEntryPoint {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.File, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 16; }
		}

		/// <inheritdoc/>
		public int ImplementationTag {
			get { return 0; }
		}

		/// <summary>
		/// From column File.Flags
		/// </summary>
		public FileAttributes Flags {
			get { return (FileAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column File.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column File.HashValue
		/// </summary>
		public byte[] HashValue {
			get { return hashValue; }
			set { hashValue = value; }
		}
		/// <summary/>
		protected byte[] hashValue;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 16; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, FileAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="FileAttributes.ContainsMetaData"/> bit
		/// </summary>
		public bool ContainsMetaData {
			get { return ((FileAttributes)attributes & FileAttributes.ContainsNoMetaData) == 0; }
			set { ModifyAttributes(!value, FileAttributes.ContainsNoMetaData); }
		}

		/// <summary>
		/// Gets/sets the <see cref="FileAttributes.ContainsNoMetaData"/> bit
		/// </summary>
		public bool ContainsNoMetaData {
			get { return ((FileAttributes)attributes & FileAttributes.ContainsNoMetaData) != 0; }
			set { ModifyAttributes(value, FileAttributes.ContainsNoMetaData); }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return UTF8String.ToSystemStringOrEmpty(name); }
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A File row created by the user and not present in the original .NET file
	/// </summary>
	public class FileDefUser : FileDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public FileDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of file</param>
		/// <param name="flags">Flags</param>
		/// <param name="hashValue">File hash</param>
		public FileDefUser(UTF8String name, FileAttributes flags, byte[] hashValue) {
			this.name = name;
			this.attributes = (int)flags;
			this.hashValue = hashValue;
		}
	}

	/// <summary>
	/// Created from a row in the File table
	/// </summary>
	sealed class FileDefMD : FileDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.File, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>File</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public FileDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.FileTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("File rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name;
			uint hashValue = readerModule.TablesStream.ReadFileRow(origRid, out this.attributes, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.hashValue = readerModule.BlobStream.Read(hashValue);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/FrameworkRedirect.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;

namespace dnlib.DotNet {
	/// <summary>
	/// Redirects .NET framework assembly references from older to newer versions
	/// </summary>
	public static class FrameworkRedirect {
		static readonly Dictionary<string, FrameworkRedirectInfo> frmRedir2;
		static readonly Dictionary<string, FrameworkRedirectInfo> frmRedir4;

		struct FrameworkRedirectInfo {
			public readonly PublicKeyToken publicKeyToken;
			public readonly Version redirectVersion;

			public FrameworkRedirectInfo(string publicKeyToken, string redirectVersion) {
				this.publicKeyToken = new PublicKeyToken(publicKeyToken);
				this.redirectVersion = new Version(redirectVersion);
			}
		}

		static FrameworkRedirect() {
			frmRedir2 = new Dictionary<string, FrameworkRedirectInfo>(StringComparer.OrdinalIgnoreCase);
			frmRedir4 = new Dictionary<string, FrameworkRedirectInfo>(StringComparer.OrdinalIgnoreCase);
			InitFrameworkRedirectV2();
			InitFrameworkRedirectV4();
		}

		static void InitFrameworkRedirectV2() {
			frmRedir2["Accessibility"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["cscompmgd"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["CustomMarshalers"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["IEExecRemote"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["IEHost"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["IIEHost"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["ISymWrapper"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["Microsoft.JScript"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualBasic"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualBasic.Compatibility"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualBasic.Compatibility.Data"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualBasic.Vsa"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualC"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.Vsa"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.Vsa.Vb.CodeDOMProcessor"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft_VsaVb"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["mscorcfg"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["mscorlib"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Configuration"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Configuration.Install"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Data"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Data.OracleClient"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Data.SqlXml"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Deployment"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Design"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.DirectoryServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.DirectoryServices.Protocols"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Drawing"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Drawing.Design"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.EnterpriseServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Management"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Messaging"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Runtime.Remoting"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Runtime.Serialization.Formatters.Soap"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Security"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.ServiceProcess"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Transactions"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Web"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Web.Mobile"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Web.RegularExpressions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Web.Services"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Windows.Forms"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Xml"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["vjscor"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["VJSharpCodeProvider"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjsJBC"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjslib"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjslibcw"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["Vjssupuilib"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjsvwaux"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjswfc"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["VJSWfcBrowserStubLib"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjswfccw"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjswfchtml"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
		}

		static void InitFrameworkRedirectV4() {
			frmRedir4["Accessibility"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["CustomMarshalers"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["ISymWrapper"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.JScript"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualBasic"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualBasic.Compatibility"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualBasic.Compatibility.Data"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualC"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["mscorlib"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Configuration"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Configuration.Install"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Data"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.OracleClient"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.SqlXml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Deployment"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Design"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.DirectoryServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.DirectoryServices.Protocols"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Drawing"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Drawing.Design"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.EnterpriseServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Management"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Messaging"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Remoting"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization.Formatters.Soap"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Security"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceProcess"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Transactions"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Web.Mobile"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Web.RegularExpressions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Web.Services"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Windows.Forms"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Xml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["AspNetMMCExt"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["sysglobl"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Build.Engine"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Build.Framework"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["PresentationCFFRasterizer"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationCore"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Aero"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Classic"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Luna"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Royale"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationUI"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["ReachFramework"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Printing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Speech"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["UIAutomationClient"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["UIAutomationClientsideProviders"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["UIAutomationProvider"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["UIAutomationTypes"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["WindowsBase"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["WindowsFormsIntegration"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["SMDiagnostics"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IdentityModel"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IdentityModel.Selectors"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IO.Log"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.ServiceModel"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.ServiceModel.Install"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.ServiceModel.WasHosting"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Workflow.Activities"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Workflow.ComponentModel"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Workflow.Runtime"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["Microsoft.Transactions.Bridge"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Transactions.Bridge.Dtc"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.AddIn"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.AddIn.Contract"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ComponentModel.Composition"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Core"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.DataSetExtensions"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Linq"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Xml.Linq"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.DirectoryServices.AccountManagement"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Management.Instrumentation"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Net"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Web"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.Extensions"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.Extensions.Design"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Windows.Presentation"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.WorkflowServices"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ComponentModel.DataAnnotations"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Data.Entity"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Entity.Design"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Services"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Services.Client"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Services.Design"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web.Abstractions"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.DynamicData"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.DynamicData.Design"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.Entity"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web.Entity.Design"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web.Routing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["Microsoft.Build"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.CSharp"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Dynamic"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Numerics"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Xaml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["Microsoft.Workflow.Compiler"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["Microsoft.Activities.Build"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["Microsoft.Build.Conversion.v4.0"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Build.Tasks.v4.0"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Build.Utilities.v4.0"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Internal.Tasks.Dataflow"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["Microsoft.VisualBasic.Activities.Compiler"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualC.STLCLR"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir4["Microsoft.Windows.ApplicationServer.Applications"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationBuildTasks"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Aero2"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.AeroLite"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemCore"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemData"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemDrawing"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemXml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemXmlLinq"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Activities"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Activities.Core.Presentation"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Activities.DurableInstancing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Activities.Presentation"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ComponentModel.Composition.Registration"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Device"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IdentityModel.Services"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IO.Compression"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IO.Compression.FileSystem"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Net.Http"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.Http.WebRequest"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Context"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Runtime.Caching"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.DurableInstancing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Runtime.WindowsRuntime"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Runtime.WindowsRuntime.UI.Xaml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.ServiceModel.Activation"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Activities"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Channels"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Discovery"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Internals"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Routing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.ServiceMoniker40"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web.ApplicationServices"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.DataVisualization"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.DataVisualization.Design"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Windows.Controls.Ribbon"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Windows.Forms.DataVisualization"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Windows.Forms.DataVisualization.Design"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Windows.Input.Manipulations"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Xaml.Hosting"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["XamlBuildTask"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["XsdBuildTask"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Collections"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Collections.Concurrent"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ComponentModel"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ComponentModel.Annotations"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ComponentModel.EventBasedAsync"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Diagnostics.Contracts"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Diagnostics.Debug"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Diagnostics.Tools"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Diagnostics.Tracing"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Dynamic.Runtime"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Globalization"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.IO"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Linq"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Linq.Expressions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Linq.Parallel"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Linq.Queryable"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.NetworkInformation"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.Primitives"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.Requests"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ObjectModel"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Emit"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Emit.ILGeneration"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Emit.Lightweight"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Extensions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Primitives"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Resources.ResourceManager"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Extensions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.InteropServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.InteropServices.WindowsRuntime"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Numerics"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization.Json"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization.Primitives"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization.Xml"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Security.Principal"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Duplex"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Http"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.NetTcp"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Primitives"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Security"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Text.Encoding"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Text.Encoding.Extensions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Text.RegularExpressions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Threading"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Threading.Timer"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Threading.Tasks"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Threading.Tasks.Parallel"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Xml.ReaderWriter"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Xml.XDocument"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Xml.XmlSerializer"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.Http.Rtc"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Windows"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Xml.Serialization"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
		}

		/// <summary>
		/// Redirects a .NET framework assembly from an older version to the correct version
		/// loaded at runtime.
		/// </summary>
		/// <param name="assembly">Current assembly reference that might get updated</param>
		/// <param name="sourceModule">Module using the assembly reference</param>
		public static void ApplyFrameworkRedirect(ref IAssembly assembly, ModuleDef sourceModule) {
			if (sourceModule == null)
				return;
			if (!Utils.LocaleEquals(assembly.Culture, ""))
				return;
			if (!sourceModule.IsClr20 && !sourceModule.IsClr40)
				return;

			FrameworkRedirectInfo redirect;
			if (!(sourceModule.IsClr20 ? frmRedir2 : frmRedir4).TryGetValue(assembly.Name, out redirect))
				return;
			if (PublicKeyBase.TokenCompareTo(assembly.PublicKeyOrToken, redirect.publicKeyToken) != 0)
				return;
			if (Utils.CompareTo(assembly.Version, redirect.redirectVersion) == 0)
				return;

			assembly = new AssemblyNameInfo(assembly);
			assembly.Version = redirect.redirectVersion;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/FullNameCreator.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using System.Text;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Helps <see cref="FullNameCreator"/> create a name
	/// </summary>
	public interface IFullNameCreatorHelper {
		/// <summary>
		/// Checks whether the assembly name should be included when printing
		/// the full type name. The assembly name isn't required in custom attributes
		/// when the type already exists in the same module as the CA, or if the type
		/// exists in mscorlib.
		/// </summary>
		/// <param name="type">The type (<c>TypeDef</c>, <c>TypeRef</c> or <c>ExportedType</c>)
		/// or <c>null</c></param>
		/// <returns><c>true</c> if the assembly name must be included, <c>false</c> otherwise</returns>
		bool MustUseAssemblyName(IType type);
	}

	/// <summary>
	/// Creates type names, method names, etc.
	/// </summary>
	public struct FullNameCreator {
		const string RECURSION_ERROR_RESULT_STRING = "<<<INFRECURSION>>>";
		const string NULLVALUE = "<<<NULL>>>";
		readonly StringBuilder sb;
		readonly bool isReflection;
		readonly IFullNameCreatorHelper helper;
		GenericArguments genericArguments;
		RecursionCounter recursionCounter;

		/// <summary>
		/// Checks whether the assembly name should be included when printing the full name.
		/// See <see cref="IFullNameCreatorHelper.MustUseAssemblyName"/> for more info.
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="type">The type (<c>TypeDef</c>, <c>TypeRef</c> or <c>ExportedType</c>)
		/// or <c>null</c></param>
		/// <returns><c>true</c> if the assembly name must be included, <c>false</c> otherwise</returns>
		public static bool MustUseAssemblyName(ModuleDef module, IType type) {
			var td = type as TypeDef;
			if (td != null)
				return td.Module != module;

			var tr = type as TypeRef;
			if (tr == null)
				return true;
			if (tr.ResolutionScope == AssemblyRef.CurrentAssembly)
				return false;
			if (!tr.DefinitionAssembly.IsCorLib())
				return true;
			// If it's present in this module, but it's a corlib type, then we will need the
			// assembly name.
			return module.Find(tr) != null;
		}

		/// <summary>
		/// Returns the full name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(IType type, bool isReflection, IFullNameCreatorHelper helper, StringBuilder sb) {
			return FullNameSB(type, isReflection, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(IType type, bool isReflection, IFullNameCreatorHelper helper, StringBuilder sb) {
			var td = type as TypeDef;
			if (td != null)
				return FullNameSB(td, isReflection, helper, sb);
			var tr = type as TypeRef;
			if (tr != null)
				return FullNameSB(tr, isReflection, helper, sb);
			var ts = type as TypeSpec;
			if (ts != null)
				return FullNameSB(ts, isReflection, helper, sb);
			var sig = type as TypeSig;
			if (sig != null)
				return FullNameSB(sig, isReflection, helper, null, null, sb);
			var et = type as ExportedType;
			if (et != null)
				return FullNameSB(et, isReflection, helper, sb);
			return sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string Name(IType type, bool isReflection, StringBuilder sb) {
			return NameSB(type, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder NameSB(IType type, bool isReflection, StringBuilder sb) {
			var td = type as TypeDef;
			if (td != null)
				return NameSB(td, isReflection, sb);
			var tr = type as TypeRef;
			if (tr != null)
				return NameSB(tr, isReflection, sb);
			var ts = type as TypeSpec;
			if (ts != null)
				return NameSB(ts, isReflection, sb);
			var sig = type as TypeSig;
			if (sig != null)
				return NameSB(sig, false, sb);
			var et = type as ExportedType;
			if (et != null)
				return NameSB(et, isReflection, sb);
			return sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string Namespace(IType type, bool isReflection, StringBuilder sb) {
			return NamespaceSB(type, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder NamespaceSB(IType type, bool isReflection, StringBuilder sb) {
			var td = type as TypeDef;
			if (td != null)
				return NamespaceSB(td, isReflection, sb);
			var tr = type as TypeRef;
			if (tr != null)
				return NamespaceSB(tr, isReflection, sb);
			var ts = type as TypeSpec;
			if (ts != null)
				return NamespaceSB(ts, isReflection, sb);
			var sig = type as TypeSig;
			if (sig != null)
				return NamespaceSB(sig, false, sb);
			var et = type as ExportedType;
			if (et != null)
				return NamespaceSB(et, isReflection, sb);
			return sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>IType</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(IType type, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return AssemblyQualifiedNameSB(type, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>IType</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(IType type, IFullNameCreatorHelper helper, StringBuilder sb) {
			var td = type as TypeDef;
			if (td != null)
				return AssemblyQualifiedNameSB(td, helper, sb);

			var tr = type as TypeRef;
			if (tr != null)
				return AssemblyQualifiedNameSB(tr, helper, sb);

			var ts = type as TypeSpec;
			if (ts != null)
				return AssemblyQualifiedNameSB(ts, helper, sb);

			var sig = type as TypeSig;
			if (sig != null)
				return AssemblyQualifiedNameSB(sig, helper, sb);

			var et = type as ExportedType;
			if (et != null)
				return AssemblyQualifiedNameSB(et, helper, sb);

			return sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a property
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of property</param>
		/// <param name="propertySig">Property signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property full name</returns>
		public static string PropertyFullName(string declaringType, UTF8String name, CallingConventionSig propertySig, IList<TypeSig> typeGenArgs = null, StringBuilder sb = null) {
			return PropertyFullNameSB(declaringType, name, propertySig, typeGenArgs, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a property
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of property</param>
		/// <param name="propertySig">Property signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property full name</returns>
		public static StringBuilder PropertyFullNameSB(string declaringType, UTF8String name, CallingConventionSig propertySig, IList<TypeSig> typeGenArgs, StringBuilder sb) {
			var fnc = new FullNameCreator(false, null, sb);
			if (typeGenArgs != null) {
				fnc.genericArguments = new GenericArguments();
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			}

			fnc.CreatePropertyFullName(declaringType, name, propertySig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a property
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of property</param>
		/// <param name="typeDefOrRef">Event type</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property full name</returns>
		public static string EventFullName(string declaringType, UTF8String name, ITypeDefOrRef typeDefOrRef, IList<TypeSig> typeGenArgs = null, StringBuilder sb = null) {
			return EventFullNameSB(declaringType, name, typeDefOrRef, typeGenArgs, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a property
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of property</param>
		/// <param name="typeDefOrRef">Event type</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property full name</returns>
		public static StringBuilder EventFullNameSB(string declaringType, UTF8String name, ITypeDefOrRef typeDefOrRef, IList<TypeSig> typeGenArgs, StringBuilder sb) {
			var fnc = new FullNameCreator(false, null, sb);
			if (typeGenArgs != null) {
				fnc.genericArguments = new GenericArguments();
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			}

			fnc.CreateEventFullName(declaringType, name, typeDefOrRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a field
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of field</param>
		/// <param name="fieldSig">Field signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Field full name</returns>
		public static string FieldFullName(string declaringType, string name, FieldSig fieldSig, IList<TypeSig> typeGenArgs = null, StringBuilder sb = null) {
			return FieldFullNameSB(declaringType, name, fieldSig, typeGenArgs, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a field
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of field</param>
		/// <param name="fieldSig">Field signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Field full name</returns>
		public static StringBuilder FieldFullNameSB(string declaringType, string name, FieldSig fieldSig, IList<TypeSig> typeGenArgs, StringBuilder sb) {
			var fnc = new FullNameCreator(false, null, sb);
			if (typeGenArgs != null) {
				fnc.genericArguments = new GenericArguments();
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			}

			fnc.CreateFieldFullName(declaringType, name, fieldSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a method
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of method or <c>null</c> if none</param>
		/// <param name="methodSig">Method signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="methodGenArgs">Method generic arguments or <c>null</c> if none</param>
		/// <param name="gppMethod">Generic parameter owner method or <c>null</c></param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Method full name</returns>
		public static string MethodFullName(string declaringType, string name, MethodSig methodSig, IList<TypeSig> typeGenArgs = null, IList<TypeSig> methodGenArgs = null, MethodDef gppMethod = null, StringBuilder sb = null) {
			return MethodFullNameSB(declaringType, name, methodSig, typeGenArgs, methodGenArgs, gppMethod, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a method
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of method or <c>null</c> if none</param>
		/// <param name="methodSig">Method signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="methodGenArgs">Method generic arguments or <c>null</c> if none</param>
		/// <param name="gppMethod">Generic parameter owner method or <c>null</c></param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Method full name</returns>
		public static StringBuilder MethodFullNameSB(string declaringType, string name, MethodSig methodSig, IList<TypeSig> typeGenArgs, IList<TypeSig> methodGenArgs, MethodDef gppMethod, StringBuilder sb) {
			var fnc = new FullNameCreator(false, null, sb);
			if (typeGenArgs != null || methodGenArgs != null)
				fnc.genericArguments = new GenericArguments();
			if (typeGenArgs != null)
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			if (methodGenArgs != null)
				fnc.genericArguments.PushMethodArgs(methodGenArgs);
			fnc.CreateMethodFullName(declaringType, name, methodSig, gppMethod);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a property sig
		/// </summary>
		/// <param name="sig">Property sig</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property sig full name</returns>
		public static string MethodBaseSigFullName(MethodBaseSig sig, StringBuilder sb = null) {
			return MethodBaseSigFullNameSB(sig, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a property sig
		/// </summary>
		/// <param name="sig">Property sig</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property sig full name</returns>
		public static StringBuilder MethodBaseSigFullNameSB(MethodBaseSig sig, StringBuilder sb) {
			var fnc = new FullNameCreator(false, null, sb);
			fnc.CreateMethodFullName(null, null, sig, null);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a sig
		/// </summary>
		/// <param name="declType">Declaring type or null</param>
		/// <param name="name">Name or null</param>
		/// <param name="sig">Method sig</param>
		/// <param name="gppMethod">Owner method or null</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Sig full name</returns>
		public static string MethodBaseSigFullName(string declType, string name, MethodBaseSig sig, MethodDef gppMethod, StringBuilder sb = null) {
			return MethodBaseSigFullNameSB(declType, name, sig, gppMethod, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a sig
		/// </summary>
		/// <param name="declType">Declaring type or null</param>
		/// <param name="name">Name or null</param>
		/// <param name="sig">Method sig</param>
		/// <param name="gppMethod">Owner method or null</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Sig full name</returns>
		public static StringBuilder MethodBaseSigFullNameSB(string declType, string name, MethodBaseSig sig, MethodDef gppMethod, StringBuilder sb) {
			var fnc = new FullNameCreator(false, null, sb);
			fnc.CreateMethodFullName(declType, name, sig, gppMethod);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(TypeRef typeRef, bool isReflection, StringBuilder sb = null) {
			return NamespaceSB(typeRef, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(TypeRef typeRef, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateNamespace(typeRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(TypeRef typeRef, bool isReflection, StringBuilder sb = null) {
			return NameSB(typeRef, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(TypeRef typeRef, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateName(typeRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(TypeRef typeRef, bool isReflection, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return FullNameSB(typeRef, isReflection, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(TypeRef typeRef, bool isReflection, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, helper, sb);
			fnc.CreateFullName(typeRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(TypeRef typeRef, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return AssemblyQualifiedNameSB(typeRef, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(TypeRef typeRef, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(typeRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(TypeRef typeRef) {
			return new FullNameCreator().GetDefinitionAssembly(typeRef);
		}

		/// <summary>
		/// Gets the scope
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <returns>The <see cref="IScope"/> or <c>null</c> if none found</returns>
		public static IScope Scope(TypeRef typeRef) {
			return new FullNameCreator().GetScope(typeRef);
		}

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(TypeRef typeRef) {
			return new FullNameCreator().GetOwnerModule(typeRef);
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(TypeDef typeDef, bool isReflection, StringBuilder sb = null) {
			return NamespaceSB(typeDef, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(TypeDef typeDef, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateNamespace(typeDef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(TypeDef typeDef, bool isReflection, StringBuilder sb = null) {
			return NameSB(typeDef, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(TypeDef typeDef, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateName(typeDef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(TypeDef typeDef, bool isReflection, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return FullNameSB(typeDef, isReflection, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(TypeDef typeDef, bool isReflection, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, helper, sb);
			fnc.CreateFullName(typeDef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(TypeDef typeDef, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return AssemblyQualifiedNameSB(typeDef, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(TypeDef typeDef, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(typeDef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(TypeDef typeDef) {
			return new FullNameCreator().GetDefinitionAssembly(typeDef);
		}

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(TypeDef typeDef) {
			return new FullNameCreator().GetOwnerModule(typeDef);
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(TypeSpec typeSpec, bool isReflection, StringBuilder sb = null) {
			return NamespaceSB(typeSpec, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(TypeSpec typeSpec, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateNamespace(typeSpec);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(TypeSpec typeSpec, bool isReflection, StringBuilder sb = null) {
			return NameSB(typeSpec, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(TypeSpec typeSpec, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateName(typeSpec);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(TypeSpec typeSpec, bool isReflection, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return FullNameSB(typeSpec, isReflection, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(TypeSpec typeSpec, bool isReflection, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, helper, sb);
			fnc.CreateFullName(typeSpec);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(TypeSpec typeSpec, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return AssemblyQualifiedNameSB(typeSpec, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(TypeSpec typeSpec, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(typeSpec);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(TypeSpec typeSpec) {
			return new FullNameCreator().GetDefinitionAssembly(typeSpec);
		}

		/// <summary>
		/// Gets the scope type
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <returns>The scope type or <c>null</c> if none found</returns>
		public static ITypeDefOrRef ScopeType(TypeSpec typeSpec) {
			return new FullNameCreator().GetScopeType(typeSpec);
		}

		/// <summary>
		/// Gets the scope
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <returns>The <see cref="IScope"/> or <c>null</c> if none found</returns>
		public static IScope Scope(TypeSpec typeSpec) {
			return new FullNameCreator().GetScope(typeSpec);
		}

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(TypeSpec typeSpec) {
			return new FullNameCreator().GetOwnerModule(typeSpec);
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(TypeSig typeSig, bool isReflection, StringBuilder sb = null) {
			return NamespaceSB(typeSig, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(TypeSig typeSig, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateNamespace(typeSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(TypeSig typeSig, bool isReflection, StringBuilder sb = null) {
			return NameSB(typeSig, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(TypeSig typeSig, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateName(typeSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="typeGenArgs">Type generic args or <c>null</c> if none</param>
		/// <param name="methodGenArgs">Method generic args or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(TypeSig typeSig, bool isReflection, IFullNameCreatorHelper helper = null, IList<TypeSig> typeGenArgs = null, IList<TypeSig> methodGenArgs = null, StringBuilder sb = null) {
			return FullNameSB(typeSig, isReflection, helper, typeGenArgs, methodGenArgs, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="typeGenArgs">Type generic args or <c>null</c> if none</param>
		/// <param name="methodGenArgs">Method generic args or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(TypeSig typeSig, bool isReflection, IFullNameCreatorHelper helper, IList<TypeSig> typeGenArgs, IList<TypeSig> methodGenArgs, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, helper, sb);
			if (typeGenArgs != null || methodGenArgs != null)
				fnc.genericArguments = new GenericArguments();
			if (typeGenArgs != null)
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			if (methodGenArgs != null)
				fnc.genericArguments.PushMethodArgs(methodGenArgs);
			fnc.CreateFullName(typeSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(TypeSig typeSig, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return AssemblyQualifiedNameSB(typeSig, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(TypeSig typeSig, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(typeSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(TypeSig typeSig) {
			return new FullNameCreator().GetDefinitionAssembly(typeSig);
		}

		/// <summary>
		/// Gets the scope
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <returns>The <see cref="IScope"/> or <c>null</c> if none found</returns>
		public static IScope Scope(TypeSig typeSig) {
			return new FullNameCreator().GetScope(typeSig);
		}

		/// <summary>
		/// Gets the scope type
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <returns>The scope type or <c>null</c> if none found</returns>
		public static ITypeDefOrRef ScopeType(TypeSig typeSig) {
			return new FullNameCreator().GetScopeType(typeSig);
		}

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(TypeSig typeSig) {
			return new FullNameCreator().GetOwnerModule(typeSig);
		}

		/// <summary>
		/// Returns the namespace of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(ExportedType exportedType, bool isReflection, StringBuilder sb = null) {
			return NamespaceSB(exportedType, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(ExportedType exportedType, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateNamespace(exportedType);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(ExportedType exportedType, bool isReflection, StringBuilder sb = null) {
			return NameSB(exportedType, isReflection, sb).ToString();
		}

		/// <summary>
		/// Returns the name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(ExportedType exportedType, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, null, sb);
			fnc.CreateName(exportedType);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(ExportedType exportedType, bool isReflection, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return FullNameSB(exportedType, isReflection, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the full name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(ExportedType exportedType, bool isReflection, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(isReflection, helper, sb);
			fnc.CreateFullName(exportedType);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(ExportedType exportedType, IFullNameCreatorHelper helper = null, StringBuilder sb = null) {
			return AssemblyQualifiedNameSB(exportedType, helper, sb).ToString();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(ExportedType exportedType, IFullNameCreatorHelper helper, StringBuilder sb) {
			var fnc = new FullNameCreator(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(exportedType);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(ExportedType exportedType) {
			return new FullNameCreator().GetDefinitionAssembly(exportedType);
		}

		/// <summary>
		/// Gets the scope type
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <returns>The scope type or <c>null</c> if none found</returns>
		public static ITypeDefOrRef ScopeType(ExportedType exportedType) {
			return new FullNameCreator().GetScopeType(exportedType);
		}

		/// <summary>
		/// Gets the scope
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <returns>The <see cref="IScope"/> or <c>null</c> if none found</returns>
		public static IScope Scope(ExportedType exportedType) {
			return new FullNameCreator().GetScope(exportedType);
		}

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(ExportedType exportedType) {
			return new FullNameCreator().GetOwnerModule(exportedType);
		}

		string Result {
			get { return sb == null ? null : sb.ToString(); }
		}

		FullNameCreator(bool isReflection, IFullNameCreatorHelper helper, StringBuilder sb) {
			this.sb = sb ?? new StringBuilder();
			this.isReflection = isReflection;
			this.helper = helper;
			this.genericArguments = null;
			this.recursionCounter = new RecursionCounter();
		}

		bool MustUseAssemblyName(IType type) {
			if (helper == null)
				return true;
			return helper.MustUseAssemblyName(GetDefinitionType(type));
		}

		IType GetDefinitionType(IType type) {
			if (!recursionCounter.Increment())
				return type;

			TypeSpec ts = type as TypeSpec;
			if (ts != null)
				type = ts.TypeSig;

			TypeSig sig = type as TypeSig;
			if (sig != null) {
				TypeDefOrRefSig tdr;
				GenericInstSig gis;
				if ((tdr = sig as TypeDefOrRefSig) != null)
					type = GetDefinitionType(tdr.TypeDefOrRef);
				else if ((gis = sig as GenericInstSig) != null)
					type = GetDefinitionType(gis.GenericType);
				else
					type = GetDefinitionType(sig.Next);
			}

			recursionCounter.Decrement();
			return type;
		}

		void CreateFullName(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef)
				CreateFullName((TypeRef)typeDefOrRef);
			else if (typeDefOrRef is TypeDef)
				CreateFullName((TypeDef)typeDefOrRef);
			else if (typeDefOrRef is TypeSpec)
				CreateFullName((TypeSpec)typeDefOrRef);
			else
				sb.Append(NULLVALUE);
		}

		void CreateNamespace(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef)
				CreateNamespace((TypeRef)typeDefOrRef);
			else if (typeDefOrRef is TypeDef)
				CreateNamespace((TypeDef)typeDefOrRef);
			else if (typeDefOrRef is TypeSpec)
				CreateNamespace((TypeSpec)typeDefOrRef);
			else
				sb.Append(NULLVALUE);
		}

		void CreateName(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef)
				CreateName((TypeRef)typeDefOrRef);
			else if (typeDefOrRef is TypeDef)
				CreateName((TypeDef)typeDefOrRef);
			else if (typeDefOrRef is TypeSpec)
				CreateName((TypeSpec)typeDefOrRef);
			else
				sb.Append(NULLVALUE);
		}

		void CreateAssemblyQualifiedName(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef)
				CreateAssemblyQualifiedName((TypeRef)typeDefOrRef);
			else if (typeDefOrRef is TypeDef)
				CreateAssemblyQualifiedName((TypeDef)typeDefOrRef);
			else if (typeDefOrRef is TypeSpec)
				CreateAssemblyQualifiedName((TypeSpec)typeDefOrRef);
			else
				sb.Append(NULLVALUE);
		}

		void CreateAssemblyQualifiedName(TypeRef typeRef) {
			if (typeRef == null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			CreateFullName(typeRef);
			if (MustUseAssemblyName(typeRef))
				AddAssemblyName(GetDefinitionAssembly(typeRef));

			recursionCounter.Decrement();
		}

		void CreateFullName(TypeRef typeRef) {
			if (typeRef == null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			var declaringTypeRef = typeRef.ResolutionScope as TypeRef;
			if (declaringTypeRef != null) {
				CreateFullName(declaringTypeRef);
				AddNestedTypeSeparator();
			}

			if (AddNamespace(typeRef.Namespace))
				sb.Append('.');
			AddName(typeRef.Name);

			recursionCounter.Decrement();
		}

		void CreateNamespace(TypeRef typeRef) {
			if (typeRef == null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddNamespace(typeRef.Namespace);
		}

		void CreateName(TypeRef typeRef) {
			if (typeRef == null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddName(typeRef.Name);
		}

		void CreateAssemblyQualifiedName(TypeDef typeDef) {
			if (typeDef == null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			CreateFullName(typeDef);
			if (MustUseAssemblyName(typeDef))
				AddAssemblyName(GetDefinitionAssembly(typeDef));

			recursionCounter.Decrement();
		}

		void CreateFullName(TypeDef typeDef) {
			if (typeDef == null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			var declaringTypeDef = typeDef.DeclaringType;
			if (declaringTypeDef != null) {
				CreateFullName(declaringTypeDef);
				AddNestedTypeSeparator();
			}

			if (AddNamespace(typeDef.Namespace))
				sb.Append('.');
			AddName(typeDef.Name);

			recursionCounter.Decrement();
		}

		void CreateNamespace(TypeDef typeDef) {
			if (typeDef == null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddNamespace(typeDef.Namespace);
		}

		void CreateName(TypeDef typeDef) {
			if (typeDef == null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddName(typeDef.Name);
		}

		void CreateAssemblyQualifiedName(TypeSpec typeSpec) {
			if (typeSpec == null) {
				sb.Append(NULLVALUE);
				return;
			}
			CreateAssemblyQualifiedName(typeSpec.TypeSig);
		}

		void CreateFullName(TypeSpec typeSpec) {
			if (typeSpec == null) {
				sb.Append(NULLVALUE);
				return;
			}
			CreateFullName(typeSpec.TypeSig);
		}

		void CreateNamespace(TypeSpec typeSpec) {
			if (typeSpec == null) {
				sb.Append(NULLVALUE);
				return;
			}
			CreateNamespace(typeSpec.TypeSig);
		}

		void CreateName(TypeSpec typeSpec) {
			if (typeSpec == null) {
				sb.Append(NULLVALUE);
				return;
			}
			CreateName(typeSpec.TypeSig);
		}


		void CreateAssemblyQualifiedName(TypeSig typeSig) {
			if (typeSig == null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			CreateFullName(typeSig);
			if (MustUseAssemblyName(typeSig))
				AddAssemblyName(GetDefinitionAssembly(typeSig));

			recursionCounter.Decrement();
		}

		void CreateFullName(TypeSig typeSig) {
			CreateTypeSigName(typeSig, TYPESIG_NAMESPACE | TYPESIG_NAME);
		}

		void CreateNamespace(TypeSig typeSig) {
			CreateTypeSigName(typeSig, TYPESIG_NAMESPACE);
		}

		void CreateName(TypeSig typeSig) {
			CreateTypeSigName(typeSig, TYPESIG_NAME);
		}

		TypeSig ReplaceGenericArg(TypeSig typeSig) {
			if (genericArguments == null)
				return typeSig;
			var newTypeSig = genericArguments.Resolve(typeSig);
			if (newTypeSig != typeSig)
				genericArguments = null;
			return newTypeSig;
		}

		const int TYPESIG_NAMESPACE = 1;
		const int TYPESIG_NAME = 2;
		void CreateTypeSigName(TypeSig typeSig, int flags) {
			if (typeSig == null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			bool createNamespace = (flags & TYPESIG_NAMESPACE) != 0;
			bool createName = (flags & TYPESIG_NAME) != 0;
			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				if (createNamespace && createName)
					CreateFullName(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				else if (createNamespace)
					CreateNamespace(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				else if (createName)
					CreateName(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName)
					sb.Append('*');
				break;

			case ElementType.ByRef:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName)
					sb.Append('&');
				break;

			case ElementType.Array:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName) {
					var arraySig = (ArraySig)typeSig;
					sb.Append('[');
					uint rank = arraySig.Rank;
					if (rank == 0)
						sb.Append("<RANK0>");	// Not allowed
					else if (rank == 1)
						sb.Append('*');
					else for (int i = 0; i < (int)rank; i++) {
						if (i != 0)
							sb.Append(',');
						if (!isReflection) {
							const int NO_LOWER = int.MinValue;
							const uint NO_SIZE = uint.MaxValue;
							int lower = arraySig.LowerBounds.Get(i, NO_LOWER);
							uint size = arraySig.Sizes.Get(i, NO_SIZE);
							if (lower != NO_LOWER) {
								sb.Append(lower);
								sb.Append("..");
								if (size != NO_SIZE)
									sb.Append(lower + (int)size - 1);
								else
									sb.Append('.');
							}
						}
					}
					sb.Append(']');
				}
				break;

			case ElementType.SZArray:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName)
					sb.Append("[]");
				break;

			case ElementType.CModReqd:
				CreateTypeSigName(typeSig.Next, flags);
				if (!isReflection && createName) {
					sb.Append(" modreq(");
					if (createNamespace)
						CreateFullName(((ModifierSig)typeSig).Modifier);
					else
						CreateName(((ModifierSig)typeSig).Modifier);
					sb.Append(")");
				}
				break;

			case ElementType.CModOpt:
				CreateTypeSigName(typeSig.Next, flags);
				if (!isReflection && createName) {
					sb.Append(" modopt(");
					if (createNamespace)
						CreateFullName(((ModifierSig)typeSig).Modifier);
					else
						CreateName(((ModifierSig)typeSig).Modifier);
					sb.Append(")");
				}
				break;

			case ElementType.Pinned:
				CreateTypeSigName(typeSig.Next, flags);
				break;

			case ElementType.ValueArray:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName) {
					var valueArraySig = (ValueArraySig)typeSig;
					sb.Append(" ValueArray(");
					sb.Append(valueArraySig.Size);
					sb.Append(')');
				}
				break;

			case ElementType.Module:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName) {
					var moduleSig = (ModuleSig)typeSig;
					sb.Append(" Module(");
					sb.Append(moduleSig.Index);
					sb.Append(')');
				}
				break;

			case ElementType.GenericInst:
				var genericInstSig = (GenericInstSig)typeSig;
				var typeGenArgs = genericInstSig.GenericArguments;
				CreateTypeSigName(genericInstSig.GenericType, flags);
				if (createNamespace && createName) {
					if (isReflection) {
						sb.Append('[');
						int i = -1;
						foreach (var genArg in typeGenArgs.GetSafeEnumerable()) {
							i++;
							if (i != 0)
								sb.Append(',');

							bool mustWriteAssembly = MustUseAssemblyName(genArg);
							if (mustWriteAssembly)
								sb.Append('[');

							CreateFullName(genArg);

							if (mustWriteAssembly) {
								sb.Append(", ");
								var asm = GetDefinitionAssembly(genArg);
								if (asm == null)
									sb.Append(NULLVALUE);
								else
									sb.Append(EscapeAssemblyName(GetAssemblyName(asm)));
								sb.Append(']');
							}
						}
						sb.Append(']');
					}
					else {
						sb.Append('<');
						int i = -1;
						foreach (var genArg in typeGenArgs.GetSafeEnumerable()) {
							i++;
							if (i != 0)
								sb.Append(',');
							CreateFullName(genArg);
						}
						sb.Append('>');
					}
				}
				break;

			case ElementType.Var:
			case ElementType.MVar:
				if (createName) {
					var gs = (GenericSig)typeSig;
					var gp = gs.GenericParam;
					if (gp == null || !AddName(gp.Name)) {
						sb.Append(gs.IsMethodVar ? "!!" : "!");
						sb.Append(gs.Number);
					}
				}
				break;

			case ElementType.FnPtr:
				if (createName) {
					if (isReflection)
						sb.Append("(fnptr)");
					else
						CreateMethodFullName(null, null, ((FnPtrSig)typeSig).MethodSig, null);
				}
				break;

			case ElementType.Sentinel:
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
		}

		void CreateAssemblyQualifiedName(ExportedType exportedType) {
			if (exportedType == null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			CreateFullName(exportedType);
			if (MustUseAssemblyName(exportedType))
				AddAssemblyName(GetDefinitionAssembly(exportedType));

			recursionCounter.Decrement();
		}

		void CreateFullName(ExportedType exportedType) {
			if (exportedType == null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			var declaringExportedType = exportedType.Implementation as ExportedType;
			if (declaringExportedType != null) {
				CreateFullName(declaringExportedType);
				AddNestedTypeSeparator();
			}

			if (AddNamespace(exportedType.TypeNamespace))
				sb.Append('.');
			AddName(exportedType.TypeName);

			recursionCounter.Decrement();
		}

		void CreateNamespace(ExportedType exportedType) {
			if (exportedType == null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddNamespace(exportedType.TypeNamespace);
		}

		void CreateName(ExportedType exportedType) {
			if (exportedType == null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddName(exportedType.TypeName);
		}

		static string GetAssemblyName(IAssembly assembly) {
			var pk = assembly.PublicKeyOrToken;
			if (pk is PublicKey)
				pk = ((PublicKey)pk).Token;
			return Utils.GetAssemblyNameString(EscapeAssemblyName(assembly.Name), assembly.Version, assembly.Culture, pk, assembly.Attributes);
		}

		static string EscapeAssemblyName(UTF8String asmSimplName) {
			return EscapeAssemblyName(UTF8String.ToSystemString(asmSimplName));
		}

		static string EscapeAssemblyName(string asmSimplName) {
			var sb = new StringBuilder(asmSimplName.Length);
			foreach (var c in asmSimplName) {
				if (c == ']')
					sb.Append('\\');
				sb.Append(c);
			}
			return sb.ToString();
		}

		void AddNestedTypeSeparator() {
			if (isReflection)
				sb.Append('+');
			else
				sb.Append('/');
		}

		bool AddNamespace(UTF8String @namespace) {
			if (UTF8String.IsNullOrEmpty(@namespace))
				return false;
			AddIdentifier(@namespace.String);
			return true;
		}

		bool AddName(UTF8String name) {
			if (UTF8String.IsNullOrEmpty(name))
				return false;
			AddIdentifier(name.String);
			return true;
		}

		void AddAssemblyName(IAssembly assembly) {
			sb.Append(", ");
			if (assembly == null)
				sb.Append(NULLVALUE);
			else {
				var pkt = assembly.PublicKeyOrToken;
				if (pkt is PublicKey)
					pkt = ((PublicKey)pkt).Token;
				sb.Append(Utils.GetAssemblyNameString(assembly.Name, assembly.Version, assembly.Culture, pkt, assembly.Attributes));
			}
		}

		void AddIdentifier(string id) {
			if (isReflection) {
				// Periods are not escaped by Reflection, even if they're part of a type name.
				foreach (var c in id) {
					switch (c) {
					case ',':
					case '+':
					case '&':
					case '*':
					case '[':
					case ']':
					case '\\':
						sb.Append('\\');
						break;
					}
					sb.Append(c);
				}
			}
			else
				sb.Append(id);
		}

		IAssembly GetDefinitionAssembly(ITypeDefOrRef typeDefOrRef) {
			var tr = typeDefOrRef as TypeRef;
			if (tr != null)
				return GetDefinitionAssembly(tr);

			var td = typeDefOrRef as TypeDef;
			if (td != null)
				return GetDefinitionAssembly(td);

			var ts = typeDefOrRef as TypeSpec;
			if (ts != null)
				return GetDefinitionAssembly(ts);

			return null;
		}

		IScope GetScope(ITypeDefOrRef typeDefOrRef) {
			var tr = typeDefOrRef as TypeRef;
			if (tr != null)
				return GetScope(tr);

			var td = typeDefOrRef as TypeDef;
			if (td != null)
				return td.Scope;

			var ts = typeDefOrRef as TypeSpec;
			if (ts != null)
				return GetScope(ts);

			return null;
		}

		ITypeDefOrRef GetScopeType(ITypeDefOrRef typeDefOrRef) {
			var tr = typeDefOrRef as TypeRef;
			if (tr != null)
				return tr;

			var td = typeDefOrRef as TypeDef;
			if (td != null)
				return td;

			var ts = typeDefOrRef as TypeSpec;
			if (ts != null)
				return GetScopeType(ts);

			return null;
		}

		ModuleDef GetOwnerModule(ITypeDefOrRef typeDefOrRef) {
			var tr = typeDefOrRef as TypeRef;
			if (tr != null)
				return GetOwnerModule(tr);

			var td = typeDefOrRef as TypeDef;
			if (td != null)
				return GetOwnerModule(td);

			var ts = typeDefOrRef as TypeSpec;
			if (ts != null)
				return GetOwnerModule(ts);

			return null;
		}

		IAssembly GetDefinitionAssembly(TypeRef typeRef) {
			if (typeRef == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IAssembly result;

			var scope = typeRef.ResolutionScope;
			if (scope == null)
				result = null;	//TODO: Check ownerModule's ExportedType table
			else if (scope is TypeRef)
				result = GetDefinitionAssembly((TypeRef)scope);
			else if (scope is AssemblyRef)
				result = (AssemblyRef)scope;
			else if (scope is ModuleRef) {
				var ownerModule = GetOwnerModule(typeRef);
				result = ownerModule == null ? null : ownerModule.Assembly;
			}
			else if (scope is ModuleDef)
				result = ((ModuleDef)scope).Assembly;
			else
				result = null;	// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		IScope GetScope(TypeRef typeRef) {
			if (typeRef == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IScope result;
			TypeRef tr;
			AssemblyRef asmRef;
			ModuleRef modRef;
			ModuleDef modDef;

			var scope = typeRef.ResolutionScope;
			if (scope == null)
				result = null;	//TODO: Check ownerModule's ExportedType table
			else if ((tr = scope as TypeRef) != null)
				result = GetScope(tr);
			else if ((asmRef = scope as AssemblyRef) != null)
				result = asmRef;
			else if ((modRef = scope as ModuleRef) != null)
				result = modRef;
			else if ((modDef = scope as ModuleDef) != null)
				result = modDef;
			else
				result = null;	// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		ModuleDef GetOwnerModule(TypeRef typeRef) {
			if (typeRef == null)
				return null;
			return typeRef.Module;
		}

		IAssembly GetDefinitionAssembly(TypeDef typeDef) {
			var ownerModule = GetOwnerModule(typeDef);
			return ownerModule == null ? null : ownerModule.Assembly;
		}

		ModuleDef GetOwnerModule(TypeDef typeDef) {
			if (typeDef == null)
				return null;

			ModuleDef result = null;
			for (int i = recursionCounter.Counter; i < RecursionCounter.MAX_RECURSION_COUNT; i++) {
				var declaringType = typeDef.DeclaringType;
				if (declaringType == null) {
					result = typeDef.Module2;
					break;
				}
				typeDef = declaringType;
			}

			return result;
		}

		IAssembly GetDefinitionAssembly(TypeSpec typeSpec) {
			if (typeSpec == null)
				return null;
			return GetDefinitionAssembly(typeSpec.TypeSig);
		}

		IScope GetScope(TypeSpec typeSpec) {
			if (typeSpec == null)
				return null;
			return GetScope(typeSpec.TypeSig);
		}

		ITypeDefOrRef GetScopeType(TypeSpec typeSpec) {
			if (typeSpec == null)
				return null;
			return GetScopeType(typeSpec.TypeSig);
		}

		ModuleDef GetOwnerModule(TypeSpec typeSpec) {
			if (typeSpec == null)
				return null;
			return GetOwnerModule(typeSpec.TypeSig);
		}

		IAssembly GetDefinitionAssembly(TypeSig typeSig) {
			if (typeSig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IAssembly result;

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				result = GetDefinitionAssembly(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				result = GetDefinitionAssembly(typeSig.Next);
				break;

			case ElementType.GenericInst:
				var genericInstSig = (GenericInstSig)typeSig;
				var genericType = genericInstSig.GenericType;
				result = GetDefinitionAssembly(genericType == null ? null : genericType.TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.Sentinel:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
			return result;
		}

		ITypeDefOrRef GetScopeType(TypeSig typeSig) {
			if (typeSig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			ITypeDefOrRef result;

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				result = GetScopeType(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				result = GetScopeType(typeSig.Next);
				break;

			case ElementType.GenericInst:
				var genericInstSig = (GenericInstSig)typeSig;
				var genericType = genericInstSig.GenericType;
				result = GetScopeType(genericType == null ? null : genericType.TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.Sentinel:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
			return result;
		}

		IScope GetScope(TypeSig typeSig) {
			if (typeSig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IScope result;

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				result = GetScope(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				result = GetScope(typeSig.Next);
				break;

			case ElementType.GenericInst:
				var genericInstSig = (GenericInstSig)typeSig;
				var genericType = genericInstSig.GenericType;
				result = GetScope(genericType == null ? null : genericType.TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.Sentinel:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
			return result;
		}

		ModuleDef GetOwnerModule(TypeSig typeSig) {
			if (typeSig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			ModuleDef result;

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				result = GetOwnerModule(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				result = GetOwnerModule(typeSig.Next);
				break;

			case ElementType.GenericInst:
				var genericInstSig = (GenericInstSig)typeSig;
				var genericType = genericInstSig.GenericType;
				result = GetOwnerModule(genericType == null ? null : genericType.TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.Sentinel:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
			return result;
		}

		IAssembly GetDefinitionAssembly(ExportedType exportedType) {
			if (exportedType == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IAssembly result;
			ExportedType et;
			AssemblyRef asmRef;

			var scope = exportedType.Implementation;
			if ((et = scope as ExportedType) != null)
				result = GetDefinitionAssembly(et);
			else if ((asmRef = scope as AssemblyRef) != null)
				result = asmRef;
			else if (scope is FileDef) {
				var ownerModule = GetOwnerModule(exportedType);
				result = ownerModule == null ? null : ownerModule.Assembly;
			}
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		ITypeDefOrRef GetScopeType(ExportedType exportedType) {
			return null;
		}

		IScope GetScope(ExportedType exportedType) {
			if (exportedType == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IScope result;
			ExportedType et;
			AssemblyRef asmRef;
			FileDef file;

			var scope = exportedType.Implementation;
			if ((et = scope as ExportedType) != null)
				result = GetScope(et);
			else if ((asmRef = scope as AssemblyRef) != null)
				result = asmRef;
			else if ((file = scope as FileDef) != null) {
				var ownerModule = GetOwnerModule(exportedType);
				//TODO: Not all modules' names are equal to the name in FileDef.Name
				var modRef = new ModuleRefUser(ownerModule, file.Name);
				if (ownerModule != null)
					ownerModule.UpdateRowId(modRef);
				result = modRef;
			}
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		ModuleDef GetOwnerModule(ExportedType exportedType) {
			if (exportedType == null)
				return null;
			return exportedType.Module;
		}

		void CreateFieldFullName(string declaringType, string name, FieldSig fieldSig) {
			CreateFullName(fieldSig == null ? null : fieldSig.Type);
			sb.Append(' ');

			if (declaringType != null) {
				sb.Append(declaringType);
				sb.Append("::");
			}
			if (name != null)
				sb.Append(name);
		}

		void CreateMethodFullName(string declaringType, string name, MethodBaseSig methodSig, MethodDef gppMethod) {
			if (methodSig == null) {
				sb.Append(NULLVALUE);
				return;
			}

			CreateFullName(methodSig.RetType);
			sb.Append(' ');
			if (declaringType != null) {
				sb.Append(declaringType);
				sb.Append("::");
			}
			if (name != null)
				sb.Append(name);

			if (methodSig.Generic) {
				sb.Append('<');
				uint genParamCount = methodSig.GenParamCount;
				for (uint i = 0; i < genParamCount; i++) {
					if (i != 0)
						sb.Append(',');
					CreateFullName(new GenericMVar(i, gppMethod));
				}
				sb.Append('>');
			}
			sb.Append('(');
			int count = PrintMethodArgList(methodSig.Params, false, false);
			PrintMethodArgList(methodSig.ParamsAfterSentinel, count > 0, true);
			sb.Append(')');
		}

		int PrintMethodArgList(IEnumerable<TypeSig> args, bool hasPrintedArgs, bool isAfterSentinel) {
			if (args == null)
				return 0;
			if (isAfterSentinel) {
				if (hasPrintedArgs)
					sb.Append(',');
				sb.Append("...");
				hasPrintedArgs = true;
			}
			int count = 0;
			foreach (var arg in args.GetSafeEnumerable()) {
				count++;
				if (hasPrintedArgs)
					sb.Append(',');
				CreateFullName(arg);
				hasPrintedArgs = true;
			}
			return count;
		}

		void CreatePropertyFullName(string declaringType, UTF8String name, CallingConventionSig propertySig) {
			CreateMethodFullName(declaringType, UTF8String.ToSystemString(name), propertySig as MethodBaseSig, null);
		}

		void CreateEventFullName(string declaringType, UTF8String name, ITypeDefOrRef typeDefOrRef) {
			CreateFullName(typeDefOrRef);
			sb.Append(' ');
			if (declaringType != null) {
				sb.Append(declaringType);
				sb.Append("::");
			}
			if (!UTF8String.IsNull(name))
				sb.Append(UTF8String.ToSystemString(name));
		}

		/// <inheritdoc/>
		public override string ToString() {
			return Result;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/GenericArguments.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;

namespace dnlib.DotNet {
	struct GenericArgumentsStack {
		readonly List<IList<TypeSig>> argsStack;
		readonly bool isTypeVar;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isTypeVar"><c>true</c> if it's for generic types, <c>false</c> if generic methods</param>
		public GenericArgumentsStack(bool isTypeVar) {
			this.argsStack = new List<IList<TypeSig>>();
			this.isTypeVar = isTypeVar;
		}

		/// <summary>
		/// Pushes generic arguments
		/// </summary>
		/// <param name="args">The generic arguments</param>
		public void Push(IList<TypeSig> args) {
			argsStack.Add(args);
		}

		/// <summary>
		/// Pops generic arguments
		/// </summary>
		/// <returns>The popped generic arguments</returns>
		public IList<TypeSig> Pop() {
			int index = argsStack.Count - 1;
			var result = argsStack[index];
			argsStack.RemoveAt(index);
			return result;
		}

		/// <summary>
		/// Resolves a generic argument
		/// </summary>
		/// <param name="number">Generic variable number</param>
		/// <returns>A <see cref="TypeSig"/> or <c>null</c> if none was found</returns>
		public TypeSig Resolve(uint number) {
			TypeSig result = null;
			for (int i = argsStack.Count - 1; i >= 0; i--) {
				var args = argsStack[i];
				if (number >= args.Count)
					return null;
				var typeSig = args[(int)number];
				var gvar = typeSig as GenericSig;
				if (gvar == null || gvar.IsTypeVar != isTypeVar)
					return typeSig;
				result = gvar;
				number = gvar.Number;
			}
			return result;
		}
	}

	/// <summary>
	/// Replaces generic type/method var with its generic argument
	/// </summary>
	public sealed class GenericArguments {
		GenericArgumentsStack typeArgsStack = new GenericArgumentsStack(true);
		GenericArgumentsStack methodArgsStack = new GenericArgumentsStack(false);

		/// <summary>
		/// Pushes generic arguments
		/// </summary>
		/// <param name="typeArgs">The generic arguments</param>
		public void PushTypeArgs(IList<TypeSig> typeArgs) {
			typeArgsStack.Push(typeArgs);
		}

		/// <summary>
		/// Pops generic arguments
		/// </summary>
		/// <returns>The popped generic arguments</returns>
		public IList<TypeSig> PopTypeArgs() {
			return typeArgsStack.Pop();
		}

		/// <summary>
		/// Pushes generic arguments
		/// </summary>
		/// <param name="methodArgs">The generic arguments</param>
		public void PushMethodArgs(IList<TypeSig> methodArgs) {
			methodArgsStack.Push(methodArgs);
		}

		/// <summary>
		/// Pops generic arguments
		/// </summary>
		/// <returns>The popped generic arguments</returns>
		public IList<TypeSig> PopMethodArgs() {
			return methodArgsStack.Pop();
		}

		/// <summary>
		/// Replaces a generic type/method var with its generic argument (if any). If
		/// <paramref name="typeSig"/> isn't a generic type/method var or if it can't
		/// be resolved, it itself is returned. Else the resolved type is returned.
		/// </summary>
		/// <param name="typeSig">Type signature</param>
		/// <returns>New <see cref="TypeSig"/> which is never <c>null</c> unless
		/// <paramref name="typeSig"/> is <c>null</c></returns>
		public TypeSig Resolve(TypeSig typeSig) {
			if (typeSig == null)
				return null;

			var sig = typeSig;

			var genericMVar = sig as GenericMVar;
			if (genericMVar != null) {
				var newSig = methodArgsStack.Resolve(genericMVar.Number);
				if (newSig == null || newSig == sig)
					return sig;
				return newSig;
			}

			var genericVar = sig as GenericVar;
			if (genericVar != null) {
				var newSig = typeArgsStack.Resolve(genericVar.Number);
				if (newSig == null || newSig == sig)
					return sig;
				return newSig;
			}

			return sig;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/GenericParam.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Diagnostics;
using System.Threading;
using dnlib.Utils;
using dnlib.DotNet.MD;
using dnlib.Threading;
using dnlib.DotNet.Pdb;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the GenericParam table
	/// </summary>
	[DebuggerDisplay("{Name.String}")]
	public abstract class GenericParam : IHasCustomAttribute, IHasCustomDebugInformation, IMemberDef, IListListener<GenericParamConstraint> {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.GenericParam, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 19; }
		}

		/// <summary>
		/// Gets the owner type/method
		/// </summary>
		public ITypeOrMethodDef Owner {
			get { return owner; }
			internal set { owner = value; }
		}
		/// <summary/>
		protected ITypeOrMethodDef owner;

		/// <summary>
		/// Gets the declaring type or <c>null</c> if none or if <see cref="Owner"/> is
		/// not a <see cref="TypeDef"/>
		/// </summary>
		public TypeDef DeclaringType {
			get { return owner as TypeDef; }
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get { return owner as TypeDef; }
		}

		/// <summary>
		/// Gets the declaring method or <c>null</c> if none or if <see cref="Owner"/> is
		/// not a <see cref="MethodDef"/>
		/// </summary>
		public MethodDef DeclaringMethod {
			get { return owner as MethodDef; }
		}

		/// <summary>
		/// From column GenericParam.Number
		/// </summary>
		public ushort Number {
			get { return number; }
			set { number = value; }
		}
		/// <summary/>
		protected ushort number;

		/// <summary>
		/// From column GenericParam.Flags
		/// </summary>
		public GenericParamAttributes Flags {
			get { return (GenericParamAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column GenericParam.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column GenericParam.Kind (v1.1 only)
		/// </summary>
		public ITypeDefOrRef Kind {
			get { return kind; }
			set { kind = value; }
		}
		/// <summary/>
		protected ITypeDefOrRef kind;

		/// <summary>
		/// Gets the generic param constraints
		/// </summary>
		public ThreadSafe.IList<GenericParamConstraint> GenericParamConstraints {
			get {
				if (genericParamConstraints == null)
					InitializeGenericParamConstraints();
				return genericParamConstraints;
			}
		}
		/// <summary/>
		protected LazyList<GenericParamConstraint> genericParamConstraints;
		/// <summary>Initializes <see cref="genericParamConstraints"/></summary>
		protected virtual void InitializeGenericParamConstraints() {
			Interlocked.CompareExchange(ref genericParamConstraints, new LazyList<GenericParamConstraint>(this), null);
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 19; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// <c>true</c> if <see cref="GenericParamConstraints"/> is not empty
		/// </summary>
		public bool HasGenericParamConstraints {
			get { return GenericParamConstraints.Count > 0; }
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get {
				var dt = owner;
				return dt == null ? null : dt.Module;
			}
		}

		/// <inheritdoc/>
		public string FullName {
			get { return UTF8String.ToSystemStringOrEmpty(name); }
		}

		bool IIsTypeOrMethod.IsType {
			get { return false; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		bool IMemberRef.IsField {
			get { return false; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return true; }
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(GenericParamAttributes andMask, GenericParamAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, GenericParamAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets variance (non, contra, co)
		/// </summary>
		public GenericParamAttributes Variance {
			get { return (GenericParamAttributes)attributes & GenericParamAttributes.VarianceMask; }
			set { ModifyAttributes(~GenericParamAttributes.VarianceMask, value & GenericParamAttributes.VarianceMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="GenericParamAttributes.NonVariant"/> is set
		/// </summary>
		public bool IsNonVariant {
			get { return Variance == GenericParamAttributes.NonVariant; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="GenericParamAttributes.Covariant"/> is set
		/// </summary>
		public bool IsCovariant {
			get { return Variance == GenericParamAttributes.Covariant; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="GenericParamAttributes.Contravariant"/> is set
		/// </summary>
		public bool IsContravariant {
			get { return Variance == GenericParamAttributes.Contravariant; }
		}

		/// <summary>
		/// Gets/sets the special constraint
		/// </summary>
		public GenericParamAttributes SpecialConstraint {
			get { return (GenericParamAttributes)attributes & GenericParamAttributes.SpecialConstraintMask; }
			set { ModifyAttributes(~GenericParamAttributes.SpecialConstraintMask, value & GenericParamAttributes.SpecialConstraintMask); }
		}

		/// <summary>
		/// <c>true</c> if there are no special constraints
		/// </summary>
		public bool HasNoSpecialConstraint {
			get { return ((GenericParamAttributes)attributes & GenericParamAttributes.SpecialConstraintMask) == GenericParamAttributes.NoSpecialConstraint; }
		}

		/// <summary>
		/// Gets/sets the <see cref="GenericParamAttributes.ReferenceTypeConstraint"/> bit
		/// </summary>
		public bool HasReferenceTypeConstraint {
			get { return ((GenericParamAttributes)attributes & GenericParamAttributes.ReferenceTypeConstraint) != 0; }
			set { ModifyAttributes(value, GenericParamAttributes.ReferenceTypeConstraint); }
		}

		/// <summary>
		/// Gets/sets the <see cref="GenericParamAttributes.NotNullableValueTypeConstraint"/> bit
		/// </summary>
		public bool HasNotNullableValueTypeConstraint {
			get { return ((GenericParamAttributes)attributes & GenericParamAttributes.NotNullableValueTypeConstraint) != 0; }
			set { ModifyAttributes(value, GenericParamAttributes.NotNullableValueTypeConstraint); }
		}

		/// <summary>
		/// Gets/sets the <see cref="GenericParamAttributes.DefaultConstructorConstraint"/> bit
		/// </summary>
		public bool HasDefaultConstructorConstraint {
			get { return ((GenericParamAttributes)attributes & GenericParamAttributes.DefaultConstructorConstraint) != 0; }
			set { ModifyAttributes(value, GenericParamAttributes.DefaultConstructorConstraint); }
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnLazyAdd(int index, ref GenericParamConstraint value) {
			OnLazyAdd2(index, ref value);
		}

		internal virtual void OnLazyAdd2(int index, ref GenericParamConstraint value) {
#if DEBUG
			if (value.Owner != this)
				throw new InvalidOperationException("Added generic param constraint's Owner != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnAdd(int index, GenericParamConstraint value) {
			if (value.Owner != null)
				throw new InvalidOperationException("Generic param constraint is already owned by another generic param. Set Owner to null first.");
			value.Owner = this;
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnRemove(int index, GenericParamConstraint value) {
			value.Owner = null;
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnClear() {
			foreach (var gpc in GenericParamConstraints.GetEnumerable_NoLock())
				gpc.Owner = null;
		}

		/// <inheritdoc/>
		public override string ToString() {
			var o = owner;
			if (o is TypeDef)
				return string.Format("!{0}", number);
			if (o is MethodDef)
				return string.Format("!!{0}", number);
			return string.Format("??{0}", number);
		}
	}

	/// <summary>
	/// A GenericParam row created by the user and not present in the original .NET file
	/// </summary>
	public class GenericParamUser : GenericParam {
		/// <summary>
		/// Default constructor
		/// </summary>
		public GenericParamUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">The generic param number</param>
		public GenericParamUser(ushort number)
			: this(number, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">The generic param number</param>
		/// <param name="flags">Flags</param>
		public GenericParamUser(ushort number, GenericParamAttributes flags)
			: this(number, flags, UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">The generic param number</param>
		/// <param name="flags">Flags</param>
		/// <param name="name">Name</param>
		public GenericParamUser(ushort number, GenericParamAttributes flags, UTF8String name) {
			this.genericParamConstraints = new LazyList<GenericParamConstraint>(this);
			this.number = number;
			this.attributes = (int)flags;
			this.name = name;
		}
	}

	/// <summary>
	/// Created from a row in the GenericParam table
	/// </summary>
	sealed class GenericParamMD : GenericParam, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.GenericParam, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), GetGenericParamContext(owner), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override void InitializeGenericParamConstraints() {
			var list = readerModule.MetaData.GetGenericParamConstraintRidList(origRid);
			var tmp = new LazyList<GenericParamConstraint>((int)list.Length, this, list, (list2, index) => readerModule.ResolveGenericParamConstraint(((RidList)list2)[index], GetGenericParamContext(owner)));
			Interlocked.CompareExchange(ref genericParamConstraints, tmp, null);
		}

		static GenericParamContext GetGenericParamContext(ITypeOrMethodDef tmOwner) {
			var md = tmOwner as MethodDef;
			if (md != null)
				return GenericParamContext.Create(md);
			return new GenericParamContext(tmOwner as TypeDef);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>GenericParam</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public GenericParamMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.GenericParamTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("GenericParam rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name;
			uint kind = readerModule.TablesStream.ReadGenericParamRow(origRid, out this.number, out this.attributes, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.owner = readerModule.GetOwner(this);
			if (kind != 0)
				this.kind = readerModule.ResolveTypeDefOrRef(kind, GetGenericParamContext(owner));
		}

		internal GenericParamMD InitializeAll() {
			MemberMDInitializer.Initialize(Owner);
			MemberMDInitializer.Initialize(Number);
			MemberMDInitializer.Initialize(Flags);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(Kind);
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(GenericParamConstraints);
			return this;
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref GenericParamConstraint value) {
			if (value.Owner != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadGenericParamConstraint(value.Rid, GetGenericParamContext(owner)).InitializeAll());
				value.Owner = this;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/GenericParamAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Generic parameter flags. See CorHdr.h/CorGenericParamAttr
	/// </summary>
	[Flags]
	public enum GenericParamAttributes : ushort {
		/// <summary/>
		VarianceMask			= 0x0003,
		/// <summary/>
		NonVariant				= 0x0000,
		/// <summary/>
		Covariant				= 0x0001,
		/// <summary/>
		Contravariant			= 0x0002,

		/// <summary/>
		SpecialConstraintMask	= 0x001C,
		/// <summary/>
		NoSpecialConstraint		= 0x0000,
		/// <summary>type argument must be a reference type</summary>
		ReferenceTypeConstraint = 0x0004,
		/// <summary>type argument must be a value type but not Nullable</summary>
		NotNullableValueTypeConstraint = 0x0008,
		/// <summary>type argument must have a public default constructor</summary>
		DefaultConstructorConstraint = 0x0010,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/GenericParamConstraint.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the GenericParamConstraint table
	/// </summary>
	public abstract class GenericParamConstraint : IHasCustomAttribute, IHasCustomDebugInformation, IContainsGenericParameter {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.GenericParamConstraint, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 20; }
		}

		/// <summary>
		/// Gets the owner generic param
		/// </summary>
		public GenericParam Owner {
			get { return owner; }
			internal set { owner = value; }
		}
		/// <summary/>
		protected GenericParam owner;

		/// <summary>
		/// From column GenericParamConstraint.Constraint
		/// </summary>
		public ITypeDefOrRef Constraint {
			get { return constraint; }
			set { constraint = value; }
		}
		/// <summary/>
		protected ITypeDefOrRef constraint;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 20; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		bool IContainsGenericParameter.ContainsGenericParameter {
			get { return TypeHelper.ContainsGenericParameter(this); }
		}
	}

	/// <summary>
	/// A GenericParamConstraintAssembly row created by the user and not present in the original .NET file
	/// </summary>
	public class GenericParamConstraintUser : GenericParamConstraint {
		/// <summary>
		/// Default constructor
		/// </summary>
		public GenericParamConstraintUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="constraint">The constraint</param>
		public GenericParamConstraintUser(ITypeDefOrRef constraint) {
			this.constraint = constraint;
		}
	}

	/// <summary>
	/// Created from a row in the GenericParamConstraint table
	/// </summary>
	sealed class GenericParamConstraintMD : GenericParamConstraint, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.GenericParamConstraint, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>GenericParamConstraint</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public GenericParamConstraintMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.GenericParamConstraintTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("GenericParamConstraint rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			uint constraint = readerModule.TablesStream.ReadGenericParamConstraintRow2(origRid);
			this.constraint = readerModule.ResolveTypeDefOrRef(constraint, gpContext);
			this.owner = readerModule.GetOwner(this);
		}

		internal GenericParamConstraintMD InitializeAll() {
			MemberMDInitializer.Initialize(Owner);
			MemberMDInitializer.Initialize(Constraint);
			MemberMDInitializer.Initialize(CustomAttributes);
			return this;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/GenericParamContext.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet {
	/// <summary>
	/// Generic parameter context
	/// </summary>
	public struct GenericParamContext {
		/// <summary>
		/// Type context
		/// </summary>
		public readonly TypeDef Type;

		/// <summary>
		/// Method context
		/// </summary>
		public readonly MethodDef Method;

		/// <summary>
		/// true if <see cref="Type"/> and <see cref="Method"/> are both <c>null</c>
		/// </summary>
		public bool IsEmpty {
			get { return Type == null && Method == null; }
		}

		/// <summary>
		/// Creates a new <see cref="GenericParamContext"/> instance and initializes the
		/// <see cref="Type"/> field to <paramref name="method"/>'s <see cref="MethodDef.DeclaringType"/>
		/// and the <see cref="Method"/> field to <paramref name="method"/>.
		/// </summary>
		/// <param name="method">Method</param>
		/// <returns>A new <see cref="GenericParamContext"/> instance</returns>
		public static GenericParamContext Create(MethodDef method) {
			if (method == null)
				return new GenericParamContext();
			return new GenericParamContext(method.DeclaringType, method);
		}

		/// <summary>
		/// Creates a new <see cref="GenericParamContext"/> instance and initializes the
		/// <see cref="Type"/> field to <paramref name="type"/> and the <see cref="Method"/> field
		/// to <c>null</c>
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns>A new <see cref="GenericParamContext"/> instance</returns>
		public static GenericParamContext Create(TypeDef type) {
			return new GenericParamContext(type);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Type context</param>
		public GenericParamContext(TypeDef type) {
			this.Type = type;
			this.Method = null;
		}

		/// <summary>
		/// Constructor. The <see cref="Type"/> field is set to <c>null</c> and <c>NOT</c> to
		/// <paramref name="method"/>'s <see cref="MethodDef.DeclaringType"/>. Use
		/// <see cref="Create(MethodDef)"/> if you want that behavior.
		/// </summary>
		/// <param name="method">Method context</param>
		public GenericParamContext(MethodDef method) {
			this.Type = null;
			this.Method = method;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Type context</param>
		/// <param name="method">Method context</param>
		public GenericParamContext(TypeDef type, MethodDef method) {
			this.Type = type;
			this.Method = method;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/IAssemblyResolver.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Reflection;

namespace dnlib.DotNet {
	/// <summary>
	/// Resolves assemblies
	/// </summary>
	public interface IAssemblyResolver {
		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="assembly">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver or
		/// <c>null</c> if the assembly couldn't be found.</returns>
		AssemblyDef Resolve(IAssembly assembly, ModuleDef sourceModule);

		/// <summary>
		/// Add an assembly to the assembly cache
		/// </summary>
		/// <param name="asm">The assembly</param>
		/// <returns><c>true</c> if <paramref name="asm"/> is cached, <c>false</c> if it's not
		/// cached because some other assembly with the exact same full name has already been
		/// cached or if <paramref name="asm"/> is <c>null</c>.</returns>
		bool AddToCache(AssemblyDef asm);

		/// <summary>
		/// Removes the assembly from the cache
		/// </summary>
		/// <param name="asm">The assembly</param>
		/// <returns><c>true</c> if it was removed, <c>false</c> if it wasn't removed since it
		/// wasn't in the cache or if <paramref name="asm"/> was <c>null</c></returns>
		bool Remove(AssemblyDef asm);

		/// <summary>
		/// Clears the cache and calls <see cref="IDisposable.Dispose()"/> on each cached module.
		/// Use <see cref="Remove(AssemblyDef)"/> to remove any assemblies you added yourself
		/// using <see cref="AddToCache(AssemblyDef)"/> before calling this method if you don't want
		/// them disposed.
		/// </summary>
		void Clear();
	}

	public static partial class Extensions {
		/// <summary>
		/// Add a module's assembly to the assembly cache
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="module">The module whose assembly should be cached</param>
		/// <returns><c>true</c> if <paramref name="module"/>'s assembly is cached, <c>false</c>
		/// if it's not cached because some other assembly with the exact same full name has
		/// already been cached or if <paramref name="module"/> or its assembly is <c>null</c>.</returns>
		public static bool AddToCache(this IAssemblyResolver self, ModuleDef module) {
			return module != null && self.AddToCache(module.Assembly);
		}

		/// <summary>
		/// Removes a module's assembly from the cache
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="module">The module</param>
		/// <returns><c>true</c> if its assembly was removed, <c>false</c> if it wasn't removed
		/// since it wasn't in the cache, it has no assembly, or <paramref name="module"/> was
		/// <c>null</c></returns>
		public static bool Remove(this IAssemblyResolver self, ModuleDef module) {
			return module != null && self.Remove(module.Assembly);
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="assembly">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver or
		/// <c>null</c> if the assembly couldn't be found.</returns>
		public static AssemblyDef Resolve(this IAssemblyResolver self, AssemblyName assembly, ModuleDef sourceModule) {
			if (assembly == null)
				return null;
			return self.Resolve(new AssemblyNameInfo(assembly), sourceModule);
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="asmFullName">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver or
		/// <c>null</c> if the assembly couldn't be found.</returns>
		public static AssemblyDef Resolve(this IAssemblyResolver self, string asmFullName, ModuleDef sourceModule) {
			if (asmFullName == null)
				return null;
			return self.Resolve(new AssemblyNameInfo(asmFullName), sourceModule);
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="assembly">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver</returns>
		/// <exception cref="AssemblyResolveException">If the assembly couldn't be found.</exception>
		public static AssemblyDef ResolveThrow(this IAssemblyResolver self, IAssembly assembly, ModuleDef sourceModule) {
			if (assembly == null)
				return null;
			var asm = self.Resolve(assembly, sourceModule);
			if (asm != null)
				return asm;
			throw new AssemblyResolveException(string.Format("Could not resolve assembly: {0}", assembly));
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="assembly">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver</returns>
		/// <exception cref="AssemblyResolveException">If the assembly couldn't be found.</exception>
		public static AssemblyDef ResolveThrow(this IAssemblyResolver self, AssemblyName assembly, ModuleDef sourceModule) {
			if (assembly == null)
				return null;
			var asm = self.Resolve(new AssemblyNameInfo(assembly), sourceModule);
			if (asm != null)
				return asm;
			throw new AssemblyResolveException(string.Format("Could not resolve assembly: {0}", assembly));
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="asmFullName">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver</returns>
		/// <exception cref="AssemblyResolveException">If the assembly couldn't be found.</exception>
		public static AssemblyDef ResolveThrow(this IAssemblyResolver self, string asmFullName, ModuleDef sourceModule) {
			if (asmFullName == null)
				return null;
			var asm = self.Resolve(new AssemblyNameInfo(asmFullName), sourceModule);
			if (asm != null)
				return asm;
			throw new AssemblyResolveException(string.Format("Could not resolve assembly: {0}", asmFullName));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ICodedToken.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.DotNet.Pdb;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// The table row can be referenced by a MD token
	/// </summary>
	public interface IMDTokenProvider {
		/// <summary>
		/// Returns the metadata token
		/// </summary>
		MDToken MDToken { get; }

		/// <summary>
		/// Gets/sets the row ID
		/// </summary>
		uint Rid { get; set; }
	}

	/// <summary>
	/// All <c>*MD</c> classes implement this interface.
	/// </summary>
	public interface IMDTokenProviderMD : IMDTokenProvider {
		/// <summary>
		/// Gets the original row ID
		/// </summary>
		uint OrigRid { get; }
	}

	/// <summary>
	/// An assembly. Implemented by <see cref="AssemblyRef"/>, <see cref="AssemblyDef"/> and
	/// <see cref="AssemblyNameInfo"/>.
	/// </summary>
	public interface IAssembly : IFullName {
		/// <summary>
		/// The assembly version
		/// </summary>
		Version Version { get; set; }

		/// <summary>
		/// Assembly flags
		/// </summary>
		AssemblyAttributes Attributes { get; set; }

		/// <summary>
		/// Public key or public key token
		/// </summary>
		PublicKeyBase PublicKeyOrToken { get; }

		/// <summary>
		/// Locale, aka culture
		/// </summary>
		UTF8String Culture { get; set; }

		/// <summary>
		/// Gets the full name of the assembly but use a public key token
		/// </summary>
		string FullNameToken { get; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PublicKey"/> bit
		/// </summary>
		bool HasPublicKey { get; set; }

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		AssemblyAttributes ProcessorArchitecture { get; set; }

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		AssemblyAttributes ProcessorArchitectureFull { get; set; }

		/// <summary>
		/// <c>true</c> if unspecified processor architecture
		/// </summary>
		bool IsProcessorArchitectureNone { get; }

		/// <summary>
		/// <c>true</c> if neutral (PE32) architecture
		/// </summary>
		bool IsProcessorArchitectureMSIL { get; }

		/// <summary>
		/// <c>true</c> if x86 (PE32) architecture
		/// </summary>
		bool IsProcessorArchitectureX86 { get; }

		/// <summary>
		/// <c>true</c> if IA-64 (PE32+) architecture
		/// </summary>
		bool IsProcessorArchitectureIA64 { get; }

		/// <summary>
		/// <c>true</c> if x64 (PE32+) architecture
		/// </summary>
		bool IsProcessorArchitectureX64 { get; }

		/// <summary>
		/// <c>true</c> if ARM (PE32) architecture
		/// </summary>
		bool IsProcessorArchitectureARM { get; }

		/// <summary>
		/// <c>true</c> if eg. reference assembly (not runnable)
		/// </summary>
		bool IsProcessorArchitectureNoPlatform { get; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PA_Specified"/> bit
		/// </summary>
		bool IsProcessorArchitectureSpecified { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.EnableJITcompileTracking"/> bit
		/// </summary>
		bool EnableJITcompileTracking { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.DisableJITcompileOptimizer"/> bit
		/// </summary>
		bool DisableJITcompileOptimizer { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.Retargetable"/> bit
		/// </summary>
		bool IsRetargetable { get; set; }

		/// <summary>
		/// Gets/sets the content type
		/// </summary>
		AssemblyAttributes ContentType { get; set; }

		/// <summary>
		/// <c>true</c> if content type is <c>Default</c>
		/// </summary>
		bool IsContentTypeDefault { get; }

		/// <summary>
		/// <c>true</c> if content type is <c>WindowsRuntime</c>
		/// </summary>
		bool IsContentTypeWindowsRuntime { get; }
	}

	public static partial class Extensions {
		/// <summary>
		/// Checks whether <paramref name="asm"/> appears to be the core library (eg.
		/// mscorlib, System.Runtime or corefx).
		/// 
		/// If <paramref name="asm"/> is a reference to a private corlib (eg. System.Private.CoreLib),
		/// this method returns false unless <paramref name="asm"/> is an <see cref="AssemblyDef"/>
		/// whose manifest (first) module defines <c>System.Object</c>. This check is performed in
		/// the constructor and the result can be found in <see cref="ModuleDef.IsCoreLibraryModule"/>.
		/// 
		/// Note that this method also returns true if it appears to be a 'public' corlib,
		/// eg. mscorlib, etc, even if it internally possibly references a private corlib.
		/// </summary>
		/// <param name="asm">The assembly</param>
		public static bool IsCorLib(this IAssembly asm) {
			var asmDef = asm as AssemblyDef;
			if (asmDef != null) {
				var manifestModule = asmDef.ManifestModule;
				if (manifestModule != null) {
					var isCorModule = manifestModule.IsCoreLibraryModule;
					if (isCorModule != null)
						return isCorModule.Value;
				}
			}

			string asmName;
			return asm != null &&
				UTF8String.IsNullOrEmpty(asm.Culture) &&
				((asmName = UTF8String.ToSystemStringOrEmpty(asm.Name)).Equals("mscorlib", StringComparison.OrdinalIgnoreCase) ||
				asmName.Equals("System.Runtime", StringComparison.OrdinalIgnoreCase) ||
				// This name could change but since CoreCLR is used a lot, it's worth supporting
				asmName.Equals("System.Private.CoreLib", StringComparison.OrdinalIgnoreCase) ||
				asmName.Equals("netstandard", StringComparison.OrdinalIgnoreCase) ||
				asmName.Equals("corefx", StringComparison.OrdinalIgnoreCase));
		}

		/// <summary>
		/// Converts <paramref name="asm"/> to a <see cref="AssemblyRef"/> instance
		/// </summary>
		/// <param name="asm">The assembly</param>
		/// <returns>A new <see cref="AssemblyRef"/> instance</returns>
		public static AssemblyRef ToAssemblyRef(this IAssembly asm) {
			if (asm == null)
				return null;
			// Always create a new one, even if it happens to be an AssemblyRef
			return new AssemblyRefUser(asm.Name, asm.Version, asm.PublicKeyOrToken, asm.Culture) { Attributes = asm.Attributes };
		}

		/// <summary>
		/// Converts <paramref name="type"/> to a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <param name="checkValueType"><c>true</c> if we should try to figure out whether
		/// <paramref name="type"/> is a <see cref="ValueType"/></param>
		/// <returns>A <see cref="TypeSig"/> instance or <c>null</c> if <paramref name="type"/>
		/// is invalid</returns>
		public static TypeSig ToTypeSig(this ITypeDefOrRef type, bool checkValueType = true) {
			if (type == null)
				return null;

			var module = type.Module;
			if (module != null) {
				var corLibType = module.CorLibTypes.GetCorLibTypeSig(type);
				if (corLibType != null)
					return corLibType;
			}

			var td = type as TypeDef;
			if (td != null)
				return CreateClassOrValueType(type, checkValueType ? td.IsValueType : false);

			var tr = type as TypeRef;
			if (tr != null) {
				if (checkValueType)
					td = tr.Resolve();
				return CreateClassOrValueType(type, td == null ? false : td.IsValueType);
			}

			var ts = type as TypeSpec;
			if (ts != null)
				return ts.TypeSig;

			return null;
		}

		static TypeSig CreateClassOrValueType(ITypeDefOrRef type, bool isValueType) {
			if (isValueType)
				return new ValueTypeSig(type);
			return new ClassSig(type);
		}

		/// <summary>
		/// Returns a <see cref="TypeDefOrRefSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="TypeDefOrRefSig"/> or <c>null</c> if it's not a
		/// <see cref="TypeDefOrRefSig"/></returns>
		public static TypeDefOrRefSig TryGetTypeDefOrRefSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as TypeDefOrRefSig;
		}

		/// <summary>
		/// Returns a <see cref="ClassOrValueTypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ClassOrValueTypeSig"/> or <c>null</c> if it's not a
		/// <see cref="ClassOrValueTypeSig"/></returns>
		public static ClassOrValueTypeSig TryGetClassOrValueTypeSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ClassOrValueTypeSig;
		}

		/// <summary>
		/// Returns a <see cref="ValueTypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ValueTypeSig"/> or <c>null</c> if it's not a
		/// <see cref="ValueTypeSig"/></returns>
		public static ValueTypeSig TryGetValueTypeSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ValueTypeSig;
		}

		/// <summary>
		/// Returns a <see cref="ClassSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ClassSig"/> or <c>null</c> if it's not a
		/// <see cref="ClassSig"/></returns>
		public static ClassSig TryGetClassSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ClassSig;
		}

		/// <summary>
		/// Returns a <see cref="GenericSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericSig"/> or <c>null</c> if it's not a
		/// <see cref="GenericSig"/></returns>
		public static GenericSig TryGetGenericSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as GenericSig;
		}

		/// <summary>
		/// Returns a <see cref="GenericVar"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericVar"/> or <c>null</c> if it's not a
		/// <see cref="GenericVar"/></returns>
		public static GenericVar TryGetGenericVar(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as GenericVar;
		}

		/// <summary>
		/// Returns a <see cref="GenericMVar"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericMVar"/> or <c>null</c> if it's not a
		/// <see cref="GenericMVar"/></returns>
		public static GenericMVar TryGetGenericMVar(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as GenericMVar;
		}

		/// <summary>
		/// Returns a <see cref="GenericInstSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericInstSig"/> or <c>null</c> if it's not a
		/// <see cref="GenericInstSig"/></returns>
		public static GenericInstSig TryGetGenericInstSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as GenericInstSig;
		}

		/// <summary>
		/// Returns a <see cref="PtrSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="PtrSig"/> or <c>null</c> if it's not a
		/// <see cref="PtrSig"/></returns>
		public static PtrSig TryGetPtrSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as PtrSig;
		}

		/// <summary>
		/// Returns a <see cref="ByRefSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ByRefSig"/> or <c>null</c> if it's not a
		/// <see cref="ByRefSig"/></returns>
		public static ByRefSig TryGetByRefSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ByRefSig;
		}

		/// <summary>
		/// Returns a <see cref="ArraySig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ArraySig"/> or <c>null</c> if it's not a
		/// <see cref="ArraySig"/></returns>
		public static ArraySig TryGetArraySig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ArraySig;
		}

		/// <summary>
		/// Returns a <see cref="SZArraySig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="SZArraySig"/> or <c>null</c> if it's not a
		/// <see cref="SZArraySig"/></returns>
		public static SZArraySig TryGetSZArraySig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts == null ? null : ts.TypeSig.RemovePinnedAndModifiers() as SZArraySig;
		}

		/// <summary>
		/// Returns the base type of <paramref name="tdr"/>. Throws if we can't resolve
		/// a <see cref="TypeRef"/>.
		/// </summary>
		/// <param name="tdr">The type</param>
		/// <returns>The base type or <c>null</c> if there's no base type</returns>
		public static ITypeDefOrRef GetBaseTypeThrow(this ITypeDefOrRef tdr) {
			return tdr.GetBaseType(true);
		}

		/// <summary>
		/// Returns the base type of <paramref name="tdr"/>
		/// </summary>
		/// <param name="tdr">The type</param>
		/// <param name="throwOnResolveFailure"><c>true</c> if we should throw if we can't
		/// resolve a <see cref="TypeRef"/>. <c>false</c> if we should ignore the error and
		/// just return <c>null</c>.</param>
		/// <returns>The base type or <c>null</c> if there's no base type, or if
		/// <paramref name="throwOnResolveFailure"/> is <c>true</c> and we couldn't resolve
		/// a <see cref="TypeRef"/></returns>
		public static ITypeDefOrRef GetBaseType(this ITypeDefOrRef tdr, bool throwOnResolveFailure = false) {
			var td = tdr as TypeDef;
			if (td != null)
				return td.BaseType;

			var tr = tdr as TypeRef;
			if (tr != null) {
				td = throwOnResolveFailure ? tr.ResolveThrow() : tr.Resolve();
				return td == null ? null : td.BaseType;
			}

			var ts = tdr as TypeSpec;
			if (ts == null)
				return null;

			var git = ts.TypeSig.ToGenericInstSig();
			if (git != null) {
				var genType = git.GenericType;
				tdr = genType == null ? null : genType.TypeDefOrRef;
			}
			else {
				var sig = ts.TypeSig.ToTypeDefOrRefSig();
				tdr = sig == null ? null : sig.TypeDefOrRef;
			}

			td = tdr as TypeDef;
			if (td != null)
				return td.BaseType;

			tr = tdr as TypeRef;
			if (tr != null) {
				td = throwOnResolveFailure ? tr.ResolveThrow() : tr.Resolve();
				return td == null ? null : td.BaseType;
			}

			return null;
		}

		/// <summary>
		/// Gets the scope type, resolves it, and returns the <see cref="TypeDef"/>
		/// </summary>
		/// <param name="tdr">Type</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if input was <c>null</c> or if we
		/// couldn't resolve the reference.</returns>
		public static TypeDef ResolveTypeDef(this ITypeDefOrRef tdr) {
			var td = tdr as TypeDef;
			if (td != null)
				return td;

			var tr = tdr as TypeRef;
			if (tr != null)
				return tr.Resolve();

			if (tdr == null)
				return null;
			tdr = tdr.ScopeType;

			td = tdr as TypeDef;
			if (td != null)
				return td;

			tr = tdr as TypeRef;
			if (tr != null)
				return tr.Resolve();

			return null;
		}

		/// <summary>
		/// Gets the scope type, resolves it, and returns the <see cref="TypeDef"/>
		/// </summary>
		/// <param name="tdr">Type</param>
		/// <returns>A <see cref="TypeDef"/> instance.</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public static TypeDef ResolveTypeDefThrow(this ITypeDefOrRef tdr) {
			var td = tdr as TypeDef;
			if (td != null)
				return td;

			var tr = tdr as TypeRef;
			if (tr != null)
				return tr.ResolveThrow();

			if (tdr == null)
				throw new TypeResolveException("Can't resolve a null pointer");
			tdr = tdr.ScopeType;

			td = tdr as TypeDef;
			if (td != null)
				return td;

			tr = tdr as TypeRef;
			if (tr != null)
				return tr.ResolveThrow();

			throw new TypeResolveException(string.Format("Could not resolve type: {0} ({1})", tdr, tdr == null ? null : tdr.DefinitionAssembly));
		}

		/// <summary>
		/// Resolves an <see cref="IField"/> to a <see cref="FieldDef"/>. Returns <c>null</c> if it
		/// was not possible to resolve it. See also <see cref="ResolveFieldDefThrow"/>
		/// </summary>
		/// <param name="field">Field to resolve</param>
		/// <returns>The <see cref="FieldDef"/> or <c>null</c> if <paramref name="field"/> is
		/// <c>null</c> or if it wasn't possible to resolve it (the field doesn't exist or its
		/// assembly couldn't be loaded)</returns>
		public static FieldDef ResolveFieldDef(this IField field) {
			var fd = field as FieldDef;
			if (fd != null)
				return fd;

			var mr = field as MemberRef;
			if (mr != null)
				return mr.ResolveField();

			return null;
		}

		/// <summary>
		/// Resolves an <see cref="IField"/> to a <see cref="FieldDef"/> and throws an exception if
		/// it was not possible to resolve it. See also <see cref="ResolveFieldDef"/>
		/// </summary>
		/// <param name="field">Field to resolve</param>
		/// <returns>The <see cref="FieldDef"/></returns>
		public static FieldDef ResolveFieldDefThrow(this IField field) {
			var fd = field as FieldDef;
			if (fd != null)
				return fd;

			var mr = field as MemberRef;
			if (mr != null)
				return mr.ResolveFieldThrow();

			throw new MemberRefResolveException(string.Format("Could not resolve field: {0}", field));
		}

		/// <summary>
		/// Resolves an <see cref="IMethod"/> to a <see cref="MethodDef"/>. Returns <c>null</c> if it
		/// was not possible to resolve it. See also <see cref="ResolveMethodDefThrow"/>. If
		/// <paramref name="method"/> is a <see cref="MethodSpec"/>, then the
		/// <see cref="MethodSpec.Method"/> property is resolved and returned.
		/// </summary>
		/// <param name="method">Method to resolve</param>
		/// <returns>The <see cref="MethodDef"/> or <c>null</c> if <paramref name="method"/> is
		/// <c>null</c> or if it wasn't possible to resolve it (the method doesn't exist or its
		/// assembly couldn't be loaded)</returns>
		public static MethodDef ResolveMethodDef(this IMethod method) {
			var md = method as MethodDef;
			if (md != null)
				return md;

			var mr = method as MemberRef;
			if (mr != null)
				return mr.ResolveMethod();

			var ms = method as MethodSpec;
			if (ms != null) {
				md = ms.Method as MethodDef;
				if (md != null)
					return md;

				mr = ms.Method as MemberRef;
				if (mr != null)
					return mr.ResolveMethod();
			}

			return null;
		}

		/// <summary>
		/// Resolves an <see cref="IMethod"/> to a <see cref="MethodDef"/> and throws an exception
		/// if it was not possible to resolve it. See also <see cref="ResolveMethodDef"/>. If
		/// <paramref name="method"/> is a <see cref="MethodSpec"/>, then the
		/// <see cref="MethodSpec.Method"/> property is resolved and returned.
		/// </summary>
		/// <param name="method">Method to resolve</param>
		/// <returns>The <see cref="MethodDef"/></returns>
		public static MethodDef ResolveMethodDefThrow(this IMethod method) {
			var md = method as MethodDef;
			if (md != null)
				return md;

			var mr = method as MemberRef;
			if (mr != null)
				return mr.ResolveMethodThrow();

			var ms = method as MethodSpec;
			if (ms != null) {
				md = ms.Method as MethodDef;
				if (md != null)
					return md;

				mr = ms.Method as MemberRef;
				if (mr != null)
					return mr.ResolveMethodThrow();
			}

			throw new MemberRefResolveException(string.Format("Could not resolve method: {0}", method));
		}

		/// <summary>
		/// Returns the definition assembly of a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="mr">Member reference</param>
		/// <returns></returns>
		static internal IAssembly GetDefinitionAssembly(this MemberRef mr) {
			if (mr == null)
				return null;
			var parent = mr.Class;

			var tdr = parent as ITypeDefOrRef;
			if (tdr != null)
				return tdr.DefinitionAssembly;

			if (parent is ModuleRef) {
				var mod = mr.Module;
				return mod == null ? null : mod.Assembly;
			}

			var md = parent as MethodDef;
			if (md != null) {
				var declType = md.DeclaringType;
				return declType == null ? null : declType.DefinitionAssembly;
			}

			return null;
		}
	}

	/// <summary>
	/// Implemented by <see cref="MethodDef"/> and <see cref="FileDef"/>, which are the only
	/// valid managed entry point tokens.
	/// </summary>
	public interface IManagedEntryPoint : ICodedToken {
	}

	/// <summary>
	/// Interface to access a module def/ref
	/// </summary>
	public interface IModule : IScope, IFullName {
	}

	/// <summary>
	/// Type of scope
	/// </summary>
	public enum ScopeType {
		/// <summary>
		/// It's an <see cref="dnlib.DotNet.AssemblyRef"/> instance
		/// </summary>
		AssemblyRef,

		/// <summary>
		/// It's a <see cref="dnlib.DotNet.ModuleRef"/> instance
		/// </summary>
		ModuleRef,

		/// <summary>
		/// It's a <see cref="dnlib.DotNet.ModuleDef"/> instance
		/// </summary>
		ModuleDef,
	}

	/// <summary>
	/// Implemented by modules and assemblies
	/// </summary>
	public interface IScope {
		/// <summary>
		/// Gets the scope type
		/// </summary>
		ScopeType ScopeType { get; }

		/// <summary>
		/// Gets the scope name
		/// </summary>
		string ScopeName { get; }
	}

	/// <summary>
	/// Interface to get the full name of a type, field, or method
	/// </summary>
	public interface IFullName {
		/// <summary>
		/// Gets the full name
		/// </summary>
		string FullName { get; }

		/// <summary>
		/// Simple name of implementer
		/// </summary>
		UTF8String Name { get; set; }
	}

	/// <summary>
	/// Implemented by all member refs and types
	/// </summary>
	public interface IOwnerModule {
		/// <summary>
		/// Gets the owner module
		/// </summary>
		ModuleDef Module { get; }
	}

	/// <summary>
	/// Methods to check whether the implementer is a type or a method.
	/// </summary>
	public interface IIsTypeOrMethod {
		/// <summary>
		/// <c>true</c> if it's a type
		/// </summary>
		bool IsType { get; }

		/// <summary>
		/// <c>true</c> if it's a method
		/// </summary>
		bool IsMethod { get; }
	}

	/// <summary>
	/// Implemented by types, fields, methods, properties, events
	/// </summary>
	public interface IMemberRef : ICodedToken, IFullName, IOwnerModule, IIsTypeOrMethod {
		/// <summary>
		/// Gets the declaring type
		/// </summary>
		ITypeDefOrRef DeclaringType { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="FieldDef"/> or a <see cref="MemberRef"/> that's
		/// referencing a field.
		/// </summary>
		bool IsField { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="TypeSpec"/>
		/// </summary>
		bool IsTypeSpec { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="TypeRef"/>
		/// </summary>
		bool IsTypeRef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="TypeDef"/>
		/// </summary>
		bool IsTypeDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="MethodSpec"/>
		/// </summary>
		bool IsMethodSpec { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="MethodDef"/>
		/// </summary>
		bool IsMethodDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="MemberRef"/>
		/// </summary>
		bool IsMemberRef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="FieldDef"/>
		/// </summary>
		bool IsFieldDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="PropertyDef"/>
		/// </summary>
		bool IsPropertyDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="EventDef"/>
		/// </summary>
		bool IsEventDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericParam"/>
		/// </summary>
		bool IsGenericParam { get; }
	}

	/// <summary>
	/// All member definitions implement this interface: <see cref="TypeDef"/>,
	/// <see cref="FieldDef"/>, <see cref="MethodDef"/>, <see cref="EventDef"/>,
	/// <see cref="PropertyDef"/>, and <see cref="GenericParam"/>.
	/// </summary>
	public interface IMemberDef : IDnlibDef, IMemberRef {
		/// <summary>
		/// Gets the declaring type
		/// </summary>
		new TypeDef DeclaringType { get; }
	}

	/// <summary>
	/// Implemented by the following classes: <see cref="TypeDef"/>,
	/// <see cref="FieldDef"/>, <see cref="MethodDef"/>, <see cref="EventDef"/>,
	/// <see cref="PropertyDef"/>, <see cref="GenericParam"/>, <see cref="AssemblyDef"/>,
	/// and <see cref="ModuleDef"/>
	/// </summary>
	public interface IDnlibDef : ICodedToken, IFullName, IHasCustomAttribute {
	}

	/// <summary>
	/// Implemented by types and methods
	/// </summary>
	public interface IGenericParameterProvider : ICodedToken, IIsTypeOrMethod {
		/// <summary>
		/// Gets the number of generic parameters / arguments
		/// </summary>
		int NumberOfGenericParameters { get; }
	}

	/// <summary>
	/// Implemented by fields (<see cref="FieldDef"/> and <see cref="MemberRef"/>)
	/// </summary>
	public interface IField : ICodedToken, ITokenOperand, IFullName, IMemberRef {
		/// <summary>
		/// Gets/sets the field signature
		/// </summary>
		FieldSig FieldSig { get; set; }
	}

	/// <summary>
	/// Implemented by methods (<see cref="MethodDef"/>, <see cref="MemberRef"/> and <see cref="MethodSpec"/>)
	/// </summary>
	public interface IMethod : ICodedToken, ITokenOperand, IFullName, IGenericParameterProvider, IMemberRef {
		/// <summary>
		/// Method signature
		/// </summary>
		MethodSig MethodSig { get; set; }
	}

	/// <summary>
	/// Implemented by tables that can be a token in the <c>ldtoken</c> instruction
	/// </summary>
	public interface ITokenOperand : ICodedToken {
	}

	/// <summary>
	/// The table row can be referenced by a coded token
	/// </summary>
	public interface ICodedToken : IMDTokenProvider {
	}

	/// <summary>
	/// TypeDefOrRef coded token interface
	/// </summary>
	public interface ITypeDefOrRef : ICodedToken, IHasCustomAttribute, IMemberRefParent, IType, ITokenOperand, IMemberRef {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int TypeDefOrRefTag { get; }
	}

	/// <summary>
	/// HasConstant coded token interface
	/// </summary>
	public interface IHasConstant : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasConstantTag { get; }

		/// <summary>
		/// Gets/sets the constant value
		/// </summary>
		Constant Constant { get; set; }
	}

	/// <summary>
	/// HasCustomAttribute coded token interface
	/// </summary>
	public interface IHasCustomAttribute : ICodedToken {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasCustomAttributeTag { get; }

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		CustomAttributeCollection CustomAttributes { get; }

		/// <summary>
		/// <c>true</c> if <see cref="CustomAttributes"/> is not empty
		/// </summary>
		bool HasCustomAttributes { get; }
	}

	/// <summary>
	/// HasFieldMarshal coded token interface
	/// </summary>
	public interface IHasFieldMarshal : ICodedToken, IHasCustomAttribute, IHasConstant, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasFieldMarshalTag { get; }

		/// <summary>
		/// Gets/sets the marshal type
		/// </summary>
		MarshalType MarshalType { get; set; }

		/// <summary>
		/// <c>true</c> if <see cref="MarshalType"/> is not <c>null</c>
		/// </summary>
		bool HasMarshalType { get; }
	}

	/// <summary>
	/// HasDeclSecurity coded token interface
	/// </summary>
	public interface IHasDeclSecurity : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasDeclSecurityTag { get; }

		/// <summary>
		/// Gets the permission sets
		/// </summary>
		ThreadSafe.IList<DeclSecurity> DeclSecurities { get; }

		/// <summary>
		/// <c>true</c> if <see cref="DeclSecurities"/> is not empty
		/// </summary>
		bool HasDeclSecurities { get; }
	}

	/// <summary>
	/// MemberRefParent coded token interface
	/// </summary>
	public interface IMemberRefParent : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int MemberRefParentTag { get; }
	}

	/// <summary>
	/// HasSemantic coded token interface
	/// </summary>
	public interface IHasSemantic : ICodedToken, IHasCustomAttribute, IFullName, IMemberRef {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasSemanticTag { get; }
	}

	/// <summary>
	/// MethodDefOrRef coded token interface
	/// </summary>
	public interface IMethodDefOrRef : ICodedToken, IHasCustomAttribute, ICustomAttributeType, IMethod {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int MethodDefOrRefTag { get; }
	}

	/// <summary>
	/// MemberForwarded coded token interface
	/// </summary>
	public interface IMemberForwarded : ICodedToken, IHasCustomAttribute, IFullName, IMemberRef {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int MemberForwardedTag { get; }

		/// <summary>
		/// Gets/sets the impl map
		/// </summary>
		ImplMap ImplMap { get; set; }

		/// <summary>
		/// <c>true</c> if <see cref="ImplMap"/> is not <c>null</c>
		/// </summary>
		bool HasImplMap { get; }
	}

	/// <summary>
	/// Implementation coded token interface
	/// </summary>
	public interface IImplementation : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int ImplementationTag { get; }
	}

	/// <summary>
	/// CustomAttributeType coded token interface
	/// </summary>
	public interface ICustomAttributeType : ICodedToken, IHasCustomAttribute, IMethod {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int CustomAttributeTypeTag { get; }
	}

	/// <summary>
	/// ResolutionScope coded token interface
	/// </summary>
	public interface IResolutionScope : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int ResolutionScopeTag { get; }
	}

	/// <summary>
	/// TypeOrMethodDef coded token interface
	/// </summary>
	public interface ITypeOrMethodDef : ICodedToken, IHasCustomAttribute, IHasDeclSecurity, IMemberRefParent, IFullName, IMemberRef, IGenericParameterProvider {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int TypeOrMethodDefTag { get; }

		/// <summary>
		/// Gets the generic parameters
		/// </summary>
		ThreadSafe.IList<GenericParam> GenericParameters { get; }

		/// <summary>
		/// <c>true</c> if <see cref="GenericParameters"/> is not empty
		/// </summary>
		bool HasGenericParameters { get; }
	}

	/// <summary>
	/// HasCustomDebugInformation interface
	/// </summary>
	public interface IHasCustomDebugInformation {
		/// <summary>
		/// The custom debug information tag
		/// </summary>
		int HasCustomDebugInformationTag { get; }

		/// <summary>
		/// Gets the custom debug infos
		/// </summary>
		ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos { get; }

		/// <summary>
		/// <c>true</c> if <see cref="CustomDebugInfos"/> is not empty
		/// </summary>
		bool HasCustomDebugInfos { get; }
	}

	public static partial class Extensions {
		/// <summary>
		/// Converts a <see cref="TypeSig"/> to a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		public static ITypeDefOrRef ToTypeDefOrRef(this TypeSig sig) {
			if (sig == null)
				return null;
			var tdrSig = sig as TypeDefOrRefSig;
			if (tdrSig != null)
				return tdrSig.TypeDefOrRef;
			var module = sig.Module;
			if (module == null)
				return new TypeSpecUser(sig);
			return module.UpdateRowId(new TypeSpecUser(sig));
		}

		/// <summary>
		/// Returns <c>true</c> if it's an integer or a floating point type
		/// </summary>
		/// <param name="tdr">Type</param>
		/// <returns></returns>
		internal static bool IsPrimitive(this IType tdr) {
			if (tdr == null)
				return false;
			if (!tdr.DefinitionAssembly.IsCorLib())
				return false;

			switch (tdr.FullName) {
			case "System.Boolean":
			case "System.Char":
			case "System.SByte":
			case "System.Byte":
			case "System.Int16":
			case "System.UInt16":
			case "System.Int32":
			case "System.UInt32":
			case "System.Int64":
			case "System.UInt64":
			case "System.Single":
			case "System.Double":
			case "System.IntPtr":
			case "System.UIntPtr":
				return true;
			default:
				return false;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ICorLibTypes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Access to .NET core library's simple types
	/// </summary>
	public interface ICorLibTypes {
		/// <summary>
		/// Gets a <c>System.Void</c>
		/// </summary>
		CorLibTypeSig Void { get; }

		/// <summary>
		/// Gets a <c>System.Boolean</c>
		/// </summary>
		CorLibTypeSig Boolean { get; }

		/// <summary>
		/// Gets a <c>System.Char</c>
		/// </summary>
		CorLibTypeSig Char { get; }

		/// <summary>
		/// Gets a <c>System.SByte</c>
		/// </summary>
		CorLibTypeSig SByte { get; }

		/// <summary>
		/// Gets a <c>System.Byte</c>
		/// </summary>
		CorLibTypeSig Byte { get; }

		/// <summary>
		/// Gets a <c>System.Int16</c>
		/// </summary>
		CorLibTypeSig Int16 { get; }

		/// <summary>
		/// Gets a <c>System.UInt16</c>
		/// </summary>
		CorLibTypeSig UInt16 { get; }

		/// <summary>
		/// Gets a <c>System.Int32</c>
		/// </summary>
		CorLibTypeSig Int32 { get; }

		/// <summary>
		/// Gets a <c>System.UInt32</c>
		/// </summary>
		CorLibTypeSig UInt32 { get; }

		/// <summary>
		/// Gets a <c>System.Int64</c>
		/// </summary>
		CorLibTypeSig Int64 { get; }

		/// <summary>
		/// Gets a <c>System.UInt64</c>
		/// </summary>
		CorLibTypeSig UInt64 { get; }

		/// <summary>
		/// Gets a <c>System.Single</c>
		/// </summary>
		CorLibTypeSig Single { get; }

		/// <summary>
		/// Gets a <c>System.Double</c>
		/// </summary>
		CorLibTypeSig Double { get; }

		/// <summary>
		/// Gets a <c>System.String</c>
		/// </summary>
		CorLibTypeSig String { get; }

		/// <summary>
		/// Gets a <c>System.TypedReference</c>
		/// </summary>
		CorLibTypeSig TypedReference { get; }

		/// <summary>
		/// Gets a <c>System.IntPtr</c>
		/// </summary>
		CorLibTypeSig IntPtr { get; }

		/// <summary>
		/// Gets a <c>System.UIntPtr</c>
		/// </summary>
		CorLibTypeSig UIntPtr { get; }

		/// <summary>
		/// Gets a <c>System.Object</c>
		/// </summary>
		CorLibTypeSig Object { get; }

		/// <summary>
		/// Gets the assembly reference to the core library
		/// </summary>
		AssemblyRef AssemblyRef { get; }

		/// <summary>
		/// Gets a <see cref="TypeRef"/> that references a type in the core library assembly
		/// </summary>
		/// <param name="namespace">Namespace of type (eg. "System")</param>
		/// <param name="name">Name of type</param>
		/// <returns>A <see cref="TypeRef"/> instance. This instance may be a cached instance.</returns>
		TypeRef GetTypeRef(string @namespace, string name);
	}

	public static partial class Extensions {
		/// <summary>
		/// Gets a <see cref="CorLibTypeSig"/> if <paramref name="type"/> matches a primitive type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
		public static CorLibTypeSig GetCorLibTypeSig(this ICorLibTypes self, ITypeDefOrRef type) {
			CorLibTypeSig corLibType;

			TypeDef td;
			if ((td = type as TypeDef) != null &&
				td.DeclaringType == null &&
				(corLibType = self.GetCorLibTypeSig(td.Namespace, td.Name, td.DefinitionAssembly)) != null) {
				return corLibType;
			}

			TypeRef tr;
			if ((tr = type as TypeRef) != null &&
				!(tr.ResolutionScope is TypeRef) &&
				(corLibType = self.GetCorLibTypeSig(tr.Namespace, tr.Name, tr.DefinitionAssembly)) != null) {
				return corLibType;
			}

			return null;
		}

		/// <summary>
		/// Gets a <see cref="CorLibTypeSig"/> if <paramref name="namespace"/> and
		/// <paramref name="name"/> matches a primitive type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="namespace">Namespace</param>
		/// <param name="name">Name</param>
		/// <param name="defAsm">Definition assembly</param>
		/// <returns>A <see cref="CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
		public static CorLibTypeSig GetCorLibTypeSig(this ICorLibTypes self, UTF8String @namespace, UTF8String name, IAssembly defAsm) {
			return self.GetCorLibTypeSig(UTF8String.ToSystemStringOrEmpty(@namespace), UTF8String.ToSystemStringOrEmpty(name), defAsm);
		}

		/// <summary>
		/// Gets a <see cref="CorLibTypeSig"/> if <paramref name="namespace"/> and
		/// <paramref name="name"/> matches a primitive type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="namespace">Namespace</param>
		/// <param name="name">Name</param>
		/// <param name="defAsm">Definition assembly</param>
		/// <returns>A <see cref="CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
		public static CorLibTypeSig GetCorLibTypeSig(this ICorLibTypes self, string @namespace, string name, IAssembly defAsm) {
			if (@namespace != "System")
				return null;
			if (defAsm == null || !defAsm.IsCorLib())
				return null;
			switch (name) {
			case "Void":	return self.Void;
			case "Boolean":	return self.Boolean;
			case "Char":	return self.Char;
			case "SByte":	return self.SByte;
			case "Byte":	return self.Byte;
			case "Int16":	return self.Int16;
			case "UInt16":	return self.UInt16;
			case "Int32":	return self.Int32;
			case "UInt32":	return self.UInt32;
			case "Int64":	return self.Int64;
			case "UInt64":	return self.UInt64;
			case "Single":	return self.Single;
			case "Double":	return self.Double;
			case "String":	return self.String;
			case "TypedReference": return self.TypedReference;
			case "IntPtr":	return self.IntPtr;
			case "UIntPtr":	return self.UIntPtr;
			case "Object":	return self.Object;
			}
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ICustomAttribute.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// Custom attribute interface. Implemented by <see cref="SecurityAttribute"/> and
	/// <see cref="CustomAttribute"/>
	/// </summary>
	public interface ICustomAttribute {
		/// <summary>
		/// Gets the attribute type
		/// </summary>
		ITypeDefOrRef AttributeType { get; }

		/// <summary>
		/// Gets the full name of the attribute type
		/// </summary>
		string TypeFullName { get; }

		/// <summary>
		/// Gets all named arguments (field and property values)
		/// </summary>
		ThreadSafe.IList<CANamedArgument> NamedArguments { get; }

		/// <summary>
		/// <c>true</c> if <see cref="NamedArguments"/> is not empty
		/// </summary>
		bool HasNamedArguments { get; }

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are field arguments
		/// </summary>
		IEnumerable<CANamedArgument> Fields { get; }

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are property arguments
		/// </summary>
		IEnumerable<CANamedArgument> Properties { get; }
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/IDecrypters.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using dnlib.PE;
using dnlib.DotNet.Emit;

namespace dnlib.DotNet {
	/// <summary>
	/// Interface to decrypt methods
	/// </summary>
	public interface IMethodDecrypter {
		/// <summary>
		/// Gets the method's body
		/// </summary>
		/// <param name="rid"><c>Method</c> rid</param>
		/// <param name="rva">The <see cref="RVA"/> found in the method's <c>Method</c> row</param>
		/// <param name="parameters">The method's parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="methodBody">Updated with the method's <see cref="MethodBody"/> if this
		/// method returns <c>true</c></param>
		/// <returns><c>true</c> if the method body was decrypted, <c>false</c> if the method isn't
		/// encrypted and the default <see cref="MethodDef"/> body reader code should be used.</returns>
		bool GetMethodBody(uint rid, RVA rva, IList<Parameter> parameters, GenericParamContext gpContext, out MethodBody methodBody);
	}

	/// <summary>
	/// Interface to decrypt strings
	/// </summary>
	public interface IStringDecrypter {
		/// <summary>
		/// Reads a string
		/// </summary>
		/// <param name="token">String token</param>
		/// <returns>A string or <c>null</c> if we should read it from the #US heap</returns>
		string ReadUserString(uint token);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ILogger.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Reflection;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet {
	/// <summary>
	/// <see cref="ILogger"/> events
	/// </summary>
	public enum LoggerEvent {
		/// <summary>
		/// An error was detected. An exception should normally be thrown but the error
		/// can be ignored.
		/// </summary>
		Error,

		/// <summary>
		/// Just a warning and can be ignored.
		/// </summary>
		Warning,

		/// <summary>
		/// A normal message
		/// </summary>
		Info,

		/// <summary>
		/// A verbose message
		/// </summary>
		Verbose,

		/// <summary>
		/// A very verbose message
		/// </summary>
		VeryVerbose,
	}

	/// <summary>
	/// Simple logger
	/// </summary>
	public interface ILogger {
		/// <summary>
		/// Log something
		/// </summary>
		/// <param name="sender">Caller or <c>null</c></param>
		/// <param name="loggerEvent">Logger event</param>
		/// <param name="format">Format</param>
		/// <param name="args">Arguments</param>
		void Log(object sender, LoggerEvent loggerEvent, string format, params object[] args);

		/// <summary>
		/// <c>true</c> if this event is ignored. If the event is ignored, the caller can
		/// choose not to call <see cref="Log"/>. This is useful if it can take time to
		/// prepare the message.
		/// </summary>
		/// <param name="loggerEvent">The logger event</param>
		bool IgnoresEvent(LoggerEvent loggerEvent);
	}

	public static partial class Extensions {
		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void Error(this ILogger logger, object sender, string message) {
			logger.Log(sender, LoggerEvent.Error, "{0}", message);
		}

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void Error(this ILogger logger, object sender, string message, object arg1) {
			logger.Log(sender, LoggerEvent.Error, message, arg1);
		}

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void Error(this ILogger logger, object sender, string message, object arg1, object arg2) {
			logger.Log(sender, LoggerEvent.Error, message, arg1, arg2);
		}

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void Error(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) {
			logger.Log(sender, LoggerEvent.Error, message, arg1, arg2, arg3);
		}

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void Error(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) {
			logger.Log(sender, LoggerEvent.Error, message, arg1, arg2, arg3, arg4);
		}

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void Error(this ILogger logger, object sender, string message, params object[] args) {
			logger.Log(sender, LoggerEvent.Error, message, args);
		}

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void Warning(this ILogger logger, object sender, string message) {
			logger.Log(sender, LoggerEvent.Warning, "{0}", message);
		}

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void Warning(this ILogger logger, object sender, string message, object arg1) {
			logger.Log(sender, LoggerEvent.Warning, message, arg1);
		}

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void Warning(this ILogger logger, object sender, string message, object arg1, object arg2) {
			logger.Log(sender, LoggerEvent.Warning, message, arg1, arg2);
		}

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void Warning(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) {
			logger.Log(sender, LoggerEvent.Warning, message, arg1, arg2, arg3);
		}

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void Warning(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) {
			logger.Log(sender, LoggerEvent.Warning, message, arg1, arg2, arg3, arg4);
		}

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void Warning(this ILogger logger, object sender, string message, params object[] args) {
			logger.Log(sender, LoggerEvent.Warning, message, args);
		}

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void Info(this ILogger logger, object sender, string message) {
			logger.Log(sender, LoggerEvent.Info, "{0}", message);
		}

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void Info(this ILogger logger, object sender, string message, object arg1) {
			logger.Log(sender, LoggerEvent.Info, message, arg1);
		}

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void Info(this ILogger logger, object sender, string message, object arg1, object arg2) {
			logger.Log(sender, LoggerEvent.Info, message, arg1, arg2);
		}

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void Info(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) {
			logger.Log(sender, LoggerEvent.Info, message, arg1, arg2, arg3);
		}

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void Info(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) {
			logger.Log(sender, LoggerEvent.Info, message, arg1, arg2, arg3, arg4);
		}

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void Info(this ILogger logger, object sender, string message, params object[] args) {
			logger.Log(sender, LoggerEvent.Info, message, args);
		}

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void Verbose(this ILogger logger, object sender, string message) {
			logger.Log(sender, LoggerEvent.Verbose, "{0}", message);
		}

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void Verbose(this ILogger logger, object sender, string message, object arg1) {
			logger.Log(sender, LoggerEvent.Verbose, message, arg1);
		}

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void Verbose(this ILogger logger, object sender, string message, object arg1, object arg2) {
			logger.Log(sender, LoggerEvent.Verbose, message, arg1, arg2);
		}

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void Verbose(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) {
			logger.Log(sender, LoggerEvent.Verbose, message, arg1, arg2, arg3);
		}

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void Verbose(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) {
			logger.Log(sender, LoggerEvent.Verbose, message, arg1, arg2, arg3, arg4);
		}

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void Verbose(this ILogger logger, object sender, string message, params object[] args) {
			logger.Log(sender, LoggerEvent.Verbose, message, args);
		}

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message) {
			logger.Log(sender, LoggerEvent.VeryVerbose, "{0}", message);
		}

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, object arg1) {
			logger.Log(sender, LoggerEvent.VeryVerbose, message, arg1);
		}

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, object arg1, object arg2) {
			logger.Log(sender, LoggerEvent.VeryVerbose, message, arg1, arg2);
		}

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) {
			logger.Log(sender, LoggerEvent.VeryVerbose, message, arg1, arg2, arg3);
		}

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) {
			logger.Log(sender, LoggerEvent.VeryVerbose, message, arg1, arg2, arg3, arg4);
		}

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, params object[] args) {
			logger.Log(sender, LoggerEvent.VeryVerbose, message, args);
		}
	}

	/// <summary>
	/// Dummy logger which ignores all messages, but can optionally throw on errors.
	/// </summary>
	public sealed class DummyLogger : ILogger {
		ConstructorInfo ctor;

		/// <summary>
		/// It ignores everything and doesn't throw anything.
		/// </summary>
		public static readonly DummyLogger NoThrowInstance = new DummyLogger();

		/// <summary>
		/// Throws a <see cref="ModuleWriterException"/> on errors, but ignores anything else.
		/// </summary>
		public static readonly DummyLogger ThrowModuleWriterExceptionOnErrorInstance = new DummyLogger(typeof(ModuleWriterException));

		DummyLogger() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="exceptionToThrow">If non-<c>null</c>, this exception type is thrown on
		/// errors. It must have a public constructor that takes a <see cref="string"/> as the only
		/// argument.</param>
		public DummyLogger(Type exceptionToThrow) {
			if (exceptionToThrow != null) {
				if (!exceptionToThrow.IsSubclassOf(typeof(Exception)))
					throw new ArgumentException(string.Format("Not a System.Exception sub class: {0}", exceptionToThrow.GetType()));
				ctor = exceptionToThrow.GetConstructor(new Type[] { typeof(string) });
				if (ctor == null)
					throw new ArgumentException(string.Format("Exception type {0} doesn't have a public constructor that takes a string as the only argument", exceptionToThrow.GetType()));
			}
		}

		/// <inheritdoc/>
		public void Log(object sender, LoggerEvent loggerEvent, string format, params object[] args) {
			if (loggerEvent == LoggerEvent.Error && ctor != null)
				throw (Exception)ctor.Invoke(new object[] { string.Format(format, args) });
		}

		/// <inheritdoc/>
		public bool IgnoresEvent(LoggerEvent loggerEvent) {
			if (ctor == null)
				return true;
			return loggerEvent != LoggerEvent.Error;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/IResolver.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Resolves types, methods, fields
	/// </summary>
	public interface IResolver : ITypeResolver, IMemberRefResolver {
	}

	/// <summary>
	/// Resolves types
	/// </summary>
	public interface ITypeResolver {
		/// <summary>
		/// Resolves a type
		/// </summary>
		/// <param name="typeRef">The type</param>
		/// <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		TypeDef Resolve(TypeRef typeRef, ModuleDef sourceModule);
	}

	/// <summary>
	/// Resolves fields and methods
	/// </summary>
	public interface IMemberRefResolver {
		/// <summary>
		/// Resolves a method or a field
		/// </summary>
		/// <param name="memberRef">A method/field reference</param>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance or <c>null</c>
		/// if it couldn't be resolved.</returns>
		IMemberForwarded Resolve(MemberRef memberRef);
	}

	public static partial class Extensions {
		/// <summary>
		/// Resolves a type
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type</param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public static TypeDef Resolve(this ITypeResolver self, TypeRef typeRef) {
			return self.Resolve(typeRef, null);
		}

		/// <summary>
		/// Resolves a type
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type</param>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public static TypeDef ResolveThrow(this ITypeResolver self, TypeRef typeRef) {
			return self.ResolveThrow(typeRef, null);
		}

		/// <summary>
		/// Resolves a type
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type</param>
		/// <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public static TypeDef ResolveThrow(this ITypeResolver self, TypeRef typeRef, ModuleDef sourceModule) {
			var type = self.Resolve(typeRef, sourceModule);
			if (type != null)
				return type;
			throw new TypeResolveException(string.Format("Could not resolve type: {0} ({1})", typeRef, typeRef == null ? null : typeRef.DefinitionAssembly));
		}

		/// <summary>
		/// Resolves a method or a field
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A method/field reference</param>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance</returns>
		/// <exception cref="MemberRefResolveException">If the method/field couldn't be resolved</exception>
		public static IMemberForwarded ResolveThrow(this IMemberRefResolver self, MemberRef memberRef) {
			var memberDef = self.Resolve(memberRef);
			if (memberDef != null)
				return memberDef;
			throw new MemberRefResolveException(string.Format("Could not resolve method/field: {0} ({1})", memberRef, memberRef == null ? null : memberRef.GetDefinitionAssembly()));
		}

		/// <summary>
		/// Resolves a field
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A field reference</param>
		/// <returns>A <see cref="FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		public static FieldDef ResolveField(this IMemberRefResolver self, MemberRef memberRef) {
			return self.Resolve(memberRef) as FieldDef;
		}

		/// <summary>
		/// Resolves a field
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A field reference</param>
		/// <returns>A <see cref="FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		/// <exception cref="MemberRefResolveException">If the field couldn't be resolved</exception>
		public static FieldDef ResolveFieldThrow(this IMemberRefResolver self, MemberRef memberRef) {
			var field = self.Resolve(memberRef) as FieldDef;
			if (field != null)
				return field;
			throw new MemberRefResolveException(string.Format("Could not resolve field: {0} ({1})", memberRef, memberRef == null ? null : memberRef.GetDefinitionAssembly()));
		}

		/// <summary>
		/// Resolves a method
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A method reference</param>
		/// <returns>A <see cref="MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		public static MethodDef ResolveMethod(this IMemberRefResolver self, MemberRef memberRef) {
			return self.Resolve(memberRef) as MethodDef;
		}

		/// <summary>
		/// Resolves a method
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A method reference</param>
		/// <returns>A <see cref="MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		/// <exception cref="MemberRefResolveException">If the method couldn't be resolved</exception>
		public static MethodDef ResolveMethodThrow(this IMemberRefResolver self, MemberRef memberRef) {
			var method = self.Resolve(memberRef) as MethodDef;
			if (method != null)
				return method;
			throw new MemberRefResolveException(string.Format("Could not resolve method: {0} ({1})", memberRef, memberRef == null ? null : memberRef.GetDefinitionAssembly()));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ITokenResolver.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet {
	/// <summary>
	/// Resolves tokens
	/// </summary>
	public interface ITokenResolver {
		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		IMDTokenProvider ResolveToken(uint token, GenericParamContext gpContext);
	}

	public static partial class Extensions {
		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="self">This</param>
		/// <param name="token">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public static IMDTokenProvider ResolveToken(this ITokenResolver self, uint token) {
			return self.ResolveToken(token, new GenericParamContext());
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/IType.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Interface to get the full name of a type
	/// </summary>
	public interface IType : IFullName, IOwnerModule, ICodedToken, IGenericParameterProvider, IContainsGenericParameter {
		/// <summary>
		/// <c>true</c> if it's a value type
		/// </summary>
		bool IsValueType { get; }

		/// <summary>
		/// Returns the name of this type
		/// </summary>
		string TypeName { get; }

		/// <summary>
		/// Returns the reflection name of this type
		/// </summary>
		string ReflectionName { get; }

		/// <summary>
		/// Returns the namespace of this type
		/// </summary>
		string Namespace { get; }

		/// <summary>
		/// Returns the reflection namespace of this type
		/// </summary>
		string ReflectionNamespace { get; }

		/// <summary>
		/// Returns the reflection name of this type. See also <see cref="AssemblyQualifiedName"/>.
		/// </summary>
		string ReflectionFullName { get; }

		/// <summary>
		/// Returns the reflection name of this type, and includes the assembly name where the
		/// type is located. It can be passed to <see cref="System.Type.GetType(string)"/> to
		/// load the type.
		/// </summary>
		string AssemblyQualifiedName { get; }

		/// <summary>
		/// Gets the assembly where this type is defined
		/// </summary>
		IAssembly DefinitionAssembly { get; }

		/// <summary>
		/// Gets the scope, which is different from <see cref="DefinitionAssembly"/> since it
		/// can differentiate between modules within the same assembly.
		/// </summary>
		IScope Scope { get; }

		/// <summary>
		/// Gets the type whose scope is returned by <see cref="Scope"/> and whose assembly
		/// is returned by <see cref="DefinitionAssembly"/>. This is always a
		/// <see cref="TypeDef"/>, <see cref="TypeRef"/> or <c>null</c>. It can also be a
		/// nested <see cref="TypeRef"/>.
		/// For example, if this type is a System.String&amp;, then this value is a System.String.
		/// If it's a generic instance type (eg. List&lt;int&gt;), then the generic type is
		/// returned (eg. List&lt;T&gt;). In other words, the first <see cref="TypeDef"/> or
		/// <see cref="TypeRef"/> that is found (without searching generic arguments) is returned.
		/// </summary>
		ITypeDefOrRef ScopeType { get; }

		/// <summary>
		/// <c>true</c> if it's an integer or a floating point type
		/// </summary>
		bool IsPrimitive { get; }
	}

	/// <summary>
	/// Implemented by types and calling convention signatures.
	/// </summary>
	public interface IContainsGenericParameter {
		/// <summary>
		/// <c>true</c> if this contains a <see cref="GenericVar"/> or a <see cref="GenericMVar"/>.
		/// </summary>
		bool ContainsGenericParameter { get; }
	}

	public static partial class Extensions {
		/// <summary>
		/// Returns <see cref="IType.ScopeType"/>, but if it's a nested <see cref="TypeRef"/>,
		/// return the non-nested <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">this</param>
		/// <returns>The scope type</returns>
		public static ITypeDefOrRef GetNonNestedTypeRefScope(this IType type) {
			if (type == null)
				return null;
			var scopeType = type.ScopeType;
			var tr = scopeType as TypeRef;
			if (tr == null)
				return scopeType;
			for (int i = 0; i < 100; i++) {
				var dt = tr.ResolutionScope as TypeRef;
				if (dt == null)
					return tr;
				tr = dt;
			}
			return tr;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ITypeDefFinder.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Finds <see cref="TypeDef"/>s
	/// </summary>
	public interface ITypeDefFinder {
		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		TypeDef Find(string fullName, bool isReflectionName);

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. <paramref name="typeRef"/>'s scope (i.e., module or
		/// assembly) is ignored when looking up the type.
		/// </summary>
		/// <param name="typeRef">The type ref</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		TypeDef Find(TypeRef typeRef);
	}

	public static partial class Extensions {
		/// <summary>
		/// Finds a <see cref="TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
		/// looking up the type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type ref</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		/// <exception cref="TypeResolveException">If type couldn't be found</exception>
		public static TypeDef FindThrow(this ITypeDefFinder self, TypeRef typeRef) {
			var type = self.Find(typeRef);
			if (type != null)
				return type;
			throw new TypeResolveException(string.Format("Could not find type: {0}", typeRef));
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns>An existing <see cref="TypeDef"/></returns>
		/// <exception cref="TypeResolveException">If type couldn't be found</exception>
		public static TypeDef FindThrow(this ITypeDefFinder self, string fullName, bool isReflectionName) {
			var type = self.Find(fullName, isReflectionName);
			if (type != null)
				return type;
			throw new TypeResolveException(string.Format("Could not find type: {0}", fullName));
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public static TypeDef FindNormal(this ITypeDefFinder self, string fullName) {
			return self.Find(fullName, false);
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
		/// <returns>An existing <see cref="TypeDef"/></returns>
		/// <exception cref="TypeResolveException">If type couldn't be found</exception>
		public static TypeDef FindNormalThrow(this ITypeDefFinder self, string fullName) {
			var type = self.Find(fullName, false);
			if (type != null)
				return type;
			throw new TypeResolveException(string.Format("Could not find type: {0}", fullName));
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public static TypeDef FindReflection(this ITypeDefFinder self, string fullName) {
			return self.Find(fullName, true);
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
		/// <returns>An existing <see cref="TypeDef"/></returns>
		/// <exception cref="TypeResolveException">If type couldn't be found</exception>
		public static TypeDef FindReflectionThrow(this ITypeDefFinder self, string fullName) {
			var type = self.Find(fullName, true);
			if (type != null)
				return type;
			throw new TypeResolveException(string.Format("Could not find type: {0}", fullName));
		}

		/// <summary>
		/// Checks whether a <see cref="TypeDef"/> exists. <paramref name="typeRef"/>'s scope (i.e.,
		/// module or assembly) is ignored when looking up the type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type ref</param>
		/// <returns><c>true</c> if the <see cref="TypeDef"/> exists, <c>false</c> otherwise</returns>
		public static bool TypeExists(this ITypeDefFinder self, TypeRef typeRef) {
			return self.Find(typeRef) != null;
		}

		/// <summary>
		/// Checks whether a <see cref="TypeDef"/> exists
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns><c>true</c> if the <see cref="TypeDef"/> exists, <c>false</c> otherwise</returns>
		public static bool TypeExists(this ITypeDefFinder self, string fullName, bool isReflectionName) {
			return self.Find(fullName, isReflectionName) != null;
		}

		/// <summary>
		/// Checks whether a <see cref="TypeDef"/> exists
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
		/// <returns><c>true</c> if the <see cref="TypeDef"/> exists, <c>false</c> otherwise</returns>
		public static bool TypeExistsNormal(this ITypeDefFinder self, string fullName) {
			return self.Find(fullName, false) != null;
		}

		/// <summary>
		/// Checks whether a <see cref="TypeDef"/> exists
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
		/// <returns><c>true</c> if the <see cref="TypeDef"/> exists, <c>false</c> otherwise</returns>
		public static bool TypeExistsReflection(this ITypeDefFinder self, string fullName) {
			return self.Find(fullName, true) != null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/IVariable.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Interface to access a local or a parameter
	/// </summary>
	public interface IVariable {
		/// <summary>
		/// Gets the variable type
		/// </summary>
		TypeSig Type { get; }

		/// <summary>
		/// Gets the 0-based position
		/// </summary>
		int Index { get; }

		/// <summary>
		/// Gets/sets the variable name
		/// </summary>
		string Name { get; set; }
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ImplMap.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.Threading;
using dnlib.DotNet.MD;

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ImplMap table
	/// </summary>
	[DebuggerDisplay("{Module} {Name}")]
	public abstract class ImplMap : IMDTokenProvider {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.ImplMap, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <summary>
		/// From column ImplMap.MappingFlags
		/// </summary>
		public PInvokeAttributes Attributes {
			get { return (PInvokeAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column ImplMap.ImportName
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column ImplMap.ImportScope
		/// </summary>
		public ModuleRef Module {
			get { return module; }
			set { module = value; }
		}
		/// <summary/>
		protected ModuleRef module;

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(PInvokeAttributes andMask, PInvokeAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, PInvokeAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="PInvokeAttributes.NoMangle"/> bit
		/// </summary>
		public bool IsNoMangle {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.NoMangle) != 0; }
			set { ModifyAttributes(value, PInvokeAttributes.NoMangle); }
		}

		/// <summary>
		/// Gets/sets the char set
		/// </summary>
		public PInvokeAttributes CharSet {
			get { return (PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask; }
			set { ModifyAttributes(~PInvokeAttributes.CharSetMask, value & PInvokeAttributes.CharSetMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CharSetNotSpec"/> is set
		/// </summary>
		public bool IsCharSetNotSpec {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask) == PInvokeAttributes.CharSetNotSpec; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CharSetAnsi"/> is set
		/// </summary>
		public bool IsCharSetAnsi {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask) == PInvokeAttributes.CharSetAnsi; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CharSetUnicode"/> is set
		/// </summary>
		public bool IsCharSetUnicode {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask) == PInvokeAttributes.CharSetUnicode; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CharSetAuto"/> is set
		/// </summary>
		public bool IsCharSetAuto {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask) == PInvokeAttributes.CharSetAuto; }
		}

		/// <summary>
		/// Gets/sets best fit
		/// </summary>
		public PInvokeAttributes BestFit {
			get { return (PInvokeAttributes)attributes & PInvokeAttributes.BestFitMask; }
			set { ModifyAttributes(~PInvokeAttributes.BestFitMask, value & PInvokeAttributes.BestFitMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.BestFitUseAssem"/> is set
		/// </summary>
		public bool IsBestFitUseAssem {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.BestFitMask) == PInvokeAttributes.BestFitUseAssem; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.BestFitEnabled"/> is set
		/// </summary>
		public bool IsBestFitEnabled {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.BestFitMask) == PInvokeAttributes.BestFitEnabled; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.BestFitDisabled"/> is set
		/// </summary>
		public bool IsBestFitDisabled {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.BestFitMask) == PInvokeAttributes.BestFitDisabled; }
		}

		/// <summary>
		/// Gets/sets throw on unmappable char
		/// </summary>
		public PInvokeAttributes ThrowOnUnmappableChar {
			get { return (PInvokeAttributes)attributes & PInvokeAttributes.ThrowOnUnmappableCharMask; }
			set { ModifyAttributes(~PInvokeAttributes.ThrowOnUnmappableCharMask, value & PInvokeAttributes.ThrowOnUnmappableCharMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.ThrowOnUnmappableCharUseAssem"/> is set
		/// </summary>
		public bool IsThrowOnUnmappableCharUseAssem {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.ThrowOnUnmappableCharMask) == PInvokeAttributes.ThrowOnUnmappableCharUseAssem; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.ThrowOnUnmappableCharEnabled"/> is set
		/// </summary>
		public bool IsThrowOnUnmappableCharEnabled {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.ThrowOnUnmappableCharMask) == PInvokeAttributes.ThrowOnUnmappableCharEnabled; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.ThrowOnUnmappableCharDisabled"/> is set
		/// </summary>
		public bool IsThrowOnUnmappableCharDisabled {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.ThrowOnUnmappableCharMask) == PInvokeAttributes.ThrowOnUnmappableCharDisabled; }
		}

		/// <summary>
		/// Gets/sets the <see cref="PInvokeAttributes.SupportsLastError"/> bit
		/// </summary>
		public bool SupportsLastError {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.SupportsLastError) != 0; }
			set { ModifyAttributes(value, PInvokeAttributes.SupportsLastError); }
		}

		/// <summary>
		/// Gets/sets calling convention
		/// </summary>
		public PInvokeAttributes CallConv {
			get { return (PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask; }
			set { ModifyAttributes(~PInvokeAttributes.CallConvMask, value & PInvokeAttributes.CallConvMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvWinapi"/> is set
		/// </summary>
		public bool IsCallConvWinapi {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvWinapi; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvCdecl"/> is set
		/// </summary>
		public bool IsCallConvCdecl {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvCdecl; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvStdcall"/> is set
		/// </summary>
		public bool IsCallConvStdcall {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvStdcall; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvThiscall"/> is set
		/// </summary>
		public bool IsCallConvThiscall {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvThiscall; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvFastcall"/> is set
		/// </summary>
		public bool IsCallConvFastcall {
			get { return ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvFastcall; }
		}

		/// <summary>
		/// Checks whether this <see cref="ImplMap"/> is a certain P/Invoke method
		/// </summary>
		/// <param name="dllName">Name of the DLL</param>
		/// <param name="funcName">Name of the function within the DLL</param>
		/// <returns><c>true</c> if it's the specified P/Invoke method, else <c>false</c></returns>
		public bool IsPinvokeMethod(string dllName, string funcName) {
			if (name != funcName)
				return false;
			var mod = module;
			if (mod == null)
				return false;
			return GetDllName(dllName).Equals(GetDllName(mod.Name), StringComparison.OrdinalIgnoreCase);
		}

		static string GetDllName(string dllName) {
			if (dllName.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
				return dllName.Substring(0, dllName.Length - 4);
			return dllName;
		}
	}

	/// <summary>
	/// An ImplMap row created by the user and not present in the original .NET file
	/// </summary>
	public class ImplMapUser : ImplMap {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ImplMapUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="scope">Scope</param>
		/// <param name="name">Name</param>
		/// <param name="flags">Flags</param>
		public ImplMapUser(ModuleRef scope, UTF8String name, PInvokeAttributes flags) {
			this.module = scope;
			this.name = name;
			this.attributes = (int)flags;
		}
	}

	/// <summary>
	/// Created from a row in the ImplMap table
	/// </summary>
	sealed class ImplMapMD : ImplMap, IMDTokenProviderMD {
		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ImplMap</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ImplMapMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ImplMapTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("ImplMap rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			uint name;
			uint scope = readerModule.TablesStream.ReadImplMapRow(origRid, out this.attributes, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.module = readerModule.ResolveModuleRef(scope);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Importer.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Reflection;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// <see cref="Importer"/> options
	/// </summary>
	[Flags]
	public enum ImporterOptions {
		/// <summary>
		/// Use <see cref="TypeDef"/>s whenever possible if the <see cref="TypeDef"/> is located
		/// in this module.
		/// </summary>
		TryToUseTypeDefs = 1,

		/// <summary>
		/// Use <see cref="MethodDef"/>s whenever possible if the <see cref="MethodDef"/> is located
		/// in this module.
		/// </summary>
		TryToUseMethodDefs = 2,

		/// <summary>
		/// Use <see cref="FieldDef"/>s whenever possible if the <see cref="FieldDef"/> is located
		/// in this module.
		/// </summary>
		TryToUseFieldDefs = 4,

		/// <summary>
		/// Use <see cref="TypeDef"/>s, <see cref="MethodDef"/>s and <see cref="FieldDef"/>s
		/// whenever possible if the definition is located in this module.
		/// </summary>
		/// <seealso cref="TryToUseTypeDefs"/>
		/// <seealso cref="TryToUseMethodDefs"/>
		/// <seealso cref="TryToUseFieldDefs"/>
		TryToUseDefs = TryToUseTypeDefs | TryToUseMethodDefs | TryToUseFieldDefs,

		/// <summary>
		/// Don't set this flag. For internal use only.
		/// </summary>
		FixSignature = int.MinValue,
	}

	/// <summary>
	/// Imports <see cref="Type"/>s, <see cref="ConstructorInfo"/>s, <see cref="MethodInfo"/>s
	/// and <see cref="FieldInfo"/>s as references
	/// </summary>
	public struct Importer {
		readonly ModuleDef module;
		readonly GenericParamContext gpContext;
		RecursionCounter recursionCounter;
		ImporterOptions options;

		bool TryToUseTypeDefs {
			get { return (options & ImporterOptions.TryToUseTypeDefs) != 0; }
		}

		bool TryToUseMethodDefs {
			get { return (options & ImporterOptions.TryToUseMethodDefs) != 0; }
		}

		bool TryToUseFieldDefs {
			get { return (options & ImporterOptions.TryToUseFieldDefs) != 0; }
		}

		bool FixSignature {
			get { return (options & ImporterOptions.FixSignature) != 0; }
			set {
				if (value)
					options |= ImporterOptions.FixSignature;
				else
					options &= ~ImporterOptions.FixSignature;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		public Importer(ModuleDef module)
			: this(module, 0, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		/// <param name="gpContext">Generic parameter context</param>
		public Importer(ModuleDef module, GenericParamContext gpContext)
			: this(module, 0, gpContext) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		/// <param name="options">Importer options</param>
		public Importer(ModuleDef module, ImporterOptions options)
			: this(module, options, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		/// <param name="options">Importer options</param>
		/// <param name="gpContext">Generic parameter context</param>
		public Importer(ModuleDef module, ImporterOptions options, GenericParamContext gpContext) {
			this.module = module;
			this.recursionCounter = new RecursionCounter();
			this.options = options;
			this.gpContext = gpContext;
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public ITypeDefOrRef Import(Type type) {
			return module.UpdateRowId(ImportAsTypeSig(type).ToTypeDefOrRef());
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <param name="requiredModifiers">A list of all required modifiers or <c>null</c></param>
		/// <param name="optionalModifiers">A list of all optional modifiers or <c>null</c></param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public ITypeDefOrRef Import(Type type, IList<Type> requiredModifiers, IList<Type> optionalModifiers) {
			return module.UpdateRowId(ImportAsTypeSig(type, requiredModifiers, optionalModifiers).ToTypeDefOrRef());
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public TypeSig ImportAsTypeSig(Type type) {
			return ImportAsTypeSig(type, false);
		}

		TypeSig ImportAsTypeSig(Type type, bool treatAsGenericInst) {
			if (type == null)
				return null;
			switch (treatAsGenericInst ? ElementType.GenericInst : type.GetElementType2()) {
			case ElementType.Void:		return module.CorLibTypes.Void;
			case ElementType.Boolean:	return module.CorLibTypes.Boolean;
			case ElementType.Char:		return module.CorLibTypes.Char;
			case ElementType.I1:		return module.CorLibTypes.SByte;
			case ElementType.U1:		return module.CorLibTypes.Byte;
			case ElementType.I2:		return module.CorLibTypes.Int16;
			case ElementType.U2:		return module.CorLibTypes.UInt16;
			case ElementType.I4:		return module.CorLibTypes.Int32;
			case ElementType.U4:		return module.CorLibTypes.UInt32;
			case ElementType.I8:		return module.CorLibTypes.Int64;
			case ElementType.U8:		return module.CorLibTypes.UInt64;
			case ElementType.R4:		return module.CorLibTypes.Single;
			case ElementType.R8:		return module.CorLibTypes.Double;
			case ElementType.String:	return module.CorLibTypes.String;
			case ElementType.TypedByRef:return module.CorLibTypes.TypedReference;
			case ElementType.U:			return module.CorLibTypes.UIntPtr;
			case ElementType.Object:	return module.CorLibTypes.Object;
			case ElementType.Ptr:		return new PtrSig(ImportAsTypeSig(type.GetElementType(), treatAsGenericInst));
			case ElementType.ByRef:		return new ByRefSig(ImportAsTypeSig(type.GetElementType(), treatAsGenericInst));
			case ElementType.SZArray:	return new SZArraySig(ImportAsTypeSig(type.GetElementType(), treatAsGenericInst));
			case ElementType.ValueType: return new ValueTypeSig(CreateTypeRef(type));
			case ElementType.Class:		return new ClassSig(CreateTypeRef(type));
			case ElementType.Var:		return new GenericVar((uint)type.GenericParameterPosition, gpContext.Type);
			case ElementType.MVar:		return new GenericMVar((uint)type.GenericParameterPosition, gpContext.Method);

			case ElementType.I:
				FixSignature = true;	// FnPtr is mapped to System.IntPtr
				return module.CorLibTypes.IntPtr;

			case ElementType.Array:
				FixSignature = true;	// We don't know sizes and lower bounds
				return new ArraySig(ImportAsTypeSig(type.GetElementType(), treatAsGenericInst), (uint)type.GetArrayRank());

			case ElementType.GenericInst:
				var typeGenArgs = type.GetGenericArguments();
				var git = new GenericInstSig(ImportAsTypeSig(type.GetGenericTypeDefinition()) as ClassOrValueTypeSig, (uint)typeGenArgs.Length);
				foreach (var ga in typeGenArgs)
					git.GenericArguments.Add(ImportAsTypeSig(ga));
				return git;

			case ElementType.Sentinel:
			case ElementType.Pinned:
			case ElementType.FnPtr:		// mapped to System.IntPtr
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.ValueArray:
			case ElementType.R:
			case ElementType.Internal:
			case ElementType.Module:
			case ElementType.End:
			default:
				return null;
			}
		}

		ITypeDefOrRef TryResolve(TypeRef tr) {
			if (!TryToUseTypeDefs || tr == null)
				return tr;
			if (!IsThisModule(tr))
				return tr;
			var td = tr.Resolve();
			if (td == null || td.Module != module)
				return tr;
			return td;
		}

		IMethodDefOrRef TryResolveMethod(IMethodDefOrRef mdr) {
			if (!TryToUseMethodDefs || mdr == null)
				return mdr;

			var mr = mdr as MemberRef;
			if (mr == null)
				return mdr;
			if (!mr.IsMethodRef)
				return mr;

			var declType = GetDeclaringType(mr);
			if (declType == null)
				return mr;
			if (declType.Module != module)
				return mr;
			return (IMethodDefOrRef)declType.ResolveMethod(mr) ?? mr;
		}

		IField TryResolveField(MemberRef mr) {
			if (!TryToUseFieldDefs || mr == null)
				return mr;

			if (!mr.IsFieldRef)
				return mr;

			var declType = GetDeclaringType(mr);
			if (declType == null)
				return mr;
			if (declType.Module != module)
				return mr;
			return (IField)declType.ResolveField(mr) ?? mr;
		}

		TypeDef GetDeclaringType(MemberRef mr) {
			if (mr == null)
				return null;

			var td = mr.Class as TypeDef;
			if (td != null)
				return td;

			td = TryResolve(mr.Class as TypeRef) as TypeDef;
			if (td != null)
				return td;

			var modRef = mr.Class as ModuleRef;
			if (IsThisModule(modRef))
				return module.GlobalType;

			return null;
		}

		bool IsThisModule(TypeRef tr) {
			if (tr == null)
				return false;
			var scopeType = tr.ScopeType.GetNonNestedTypeRefScope() as TypeRef;
			if (scopeType == null)
				return false;

			if (module == scopeType.ResolutionScope)
				return true;

			var modRef = scopeType.ResolutionScope as ModuleRef;
			if (modRef != null)
				return IsThisModule(modRef);

			var asmRef = scopeType.ResolutionScope as AssemblyRef;
			return Equals(module.Assembly, asmRef);
		}

		bool IsThisModule(ModuleRef modRef) {
			return modRef != null &&
				module.Name == modRef.Name &&
				Equals(module.Assembly, modRef.DefinitionAssembly);
		}

		static bool Equals(IAssembly a, IAssembly b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			return Utils.Equals(a.Version, b.Version) &&
				PublicKeyBase.TokenEquals(a.PublicKeyOrToken, b.PublicKeyOrToken) &&
				UTF8String.Equals(a.Name, b.Name) &&
				UTF8String.CaseInsensitiveEquals(a.Culture, b.Culture);
		}

		ITypeDefOrRef CreateTypeRef(Type type) {
			return TryResolve(CreateTypeRef2(type));
		}

		TypeRef CreateTypeRef2(Type type) {
			if (!type.IsNested)
				return module.UpdateRowId(new TypeRefUser(module, type.Namespace ?? string.Empty, type.Name ?? string.Empty, CreateScopeReference(type)));
			return module.UpdateRowId(new TypeRefUser(module, string.Empty, type.Name ?? string.Empty, CreateTypeRef2(type.DeclaringType)));
		}

		IResolutionScope CreateScopeReference(Type type) {
			if (type == null)
				return null;
			var asmName = type.Assembly.GetName();
			var modAsm = module.Assembly;
			if (modAsm != null) {
				if (UTF8String.ToSystemStringOrEmpty(modAsm.Name).Equals(asmName.Name, StringComparison.OrdinalIgnoreCase)) {
					if (UTF8String.ToSystemStringOrEmpty(module.Name).Equals(type.Module.ScopeName, StringComparison.OrdinalIgnoreCase))
						return module;
					return module.UpdateRowId(new ModuleRefUser(module, type.Module.ScopeName));
				}
			}
			var pkt = asmName.GetPublicKeyToken();
			if (pkt == null || pkt.Length == 0)
				pkt = null;
			return module.UpdateRowId(new AssemblyRefUser(asmName.Name, asmName.Version, PublicKeyBase.CreatePublicKeyToken(pkt), asmName.CultureInfo.Name));
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <param name="requiredModifiers">A list of all required modifiers or <c>null</c></param>
		/// <param name="optionalModifiers">A list of all optional modifiers or <c>null</c></param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public TypeSig ImportAsTypeSig(Type type, IList<Type> requiredModifiers, IList<Type> optionalModifiers) {
			return ImportAsTypeSig(type, requiredModifiers, optionalModifiers, false);
		}

		TypeSig ImportAsTypeSig(Type type, IList<Type> requiredModifiers, IList<Type> optionalModifiers, bool treatAsGenericInst) {
			if (type == null)
				return null;
			if (IsEmpty(requiredModifiers) && IsEmpty(optionalModifiers))
				return ImportAsTypeSig(type, treatAsGenericInst);

			FixSignature = true;	// Order of modifiers is unknown
			var ts = ImportAsTypeSig(type, treatAsGenericInst);

			// We don't know the original order of the modifiers.
			// Assume all required modifiers are closer to the real type.
			// Assume all modifiers should be applied in the same order as in the lists.

			if (requiredModifiers != null) {
				foreach (var modifier in requiredModifiers.GetSafeEnumerable())
					ts = new CModReqdSig(Import(modifier), ts);
			}

			if (optionalModifiers != null) {
				foreach (var modifier in optionalModifiers.GetSafeEnumerable())
					ts = new CModOptSig(Import(modifier), ts);
			}

			return ts;
		}

		static bool IsEmpty<T>(IList<T> list) {
			return list == null || list.Count == 0;
		}

		/// <summary>
		/// Imports a <see cref="MethodBase"/> as a <see cref="IMethod"/>. This will be either
		/// a <see cref="MemberRef"/> or a <see cref="MethodSpec"/>.
		/// </summary>
		/// <param name="methodBase">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
		/// or if we failed to import the method</returns>
		public IMethod Import(MethodBase methodBase) {
			return Import(methodBase, false);
		}

		/// <summary>
		/// Imports a <see cref="MethodBase"/> as a <see cref="IMethod"/>. This will be either
		/// a <see cref="MemberRef"/> or a <see cref="MethodSpec"/>.
		/// </summary>
		/// <param name="methodBase">The method</param>
		/// <param name="forceFixSignature">Always verify method signature to make sure the
		/// returned reference matches the metadata in the source assembly</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
		/// or if we failed to import the method</returns>
		public IMethod Import(MethodBase methodBase, bool forceFixSignature) {
			FixSignature = false;
			return ImportInternal(methodBase, forceFixSignature);
		}

		IMethod ImportInternal(MethodBase methodBase) {
			return ImportInternal(methodBase, false);
		}

		IMethod ImportInternal(MethodBase methodBase, bool forceFixSignature) {
			if (methodBase == null)
				return null;

			if (forceFixSignature) {
				//TODO:
			}

			bool isMethodSpec = methodBase.IsGenericButNotGenericMethodDefinition();
			if (isMethodSpec) {
				IMethodDefOrRef method;
				var origMethod = methodBase.Module.ResolveMethod(methodBase.MetadataToken);
				if (methodBase.DeclaringType.GetElementType2() == ElementType.GenericInst)
					method = module.UpdateRowId(new MemberRefUser(module, methodBase.Name, CreateMethodSig(origMethod), Import(methodBase.DeclaringType)));
				else
					method = ImportInternal(origMethod) as IMethodDefOrRef;

				method = TryResolveMethod(method);

				var gim = CreateGenericInstMethodSig(methodBase);
				var methodSpec = module.UpdateRowId(new MethodSpecUser(method, gim));
				if (FixSignature && !forceFixSignature) {
					//TODO:
				}
				return methodSpec;
			}
			else {
				IMemberRefParent parent;
				if (methodBase.DeclaringType == null) {
					// It's the global type. We can reference it with a ModuleRef token.
					parent = GetModuleParent(methodBase.Module);
				}
				else
					parent = Import(methodBase.DeclaringType);
				if (parent == null)
					return null;

				MethodBase origMethod;
				try {
					// Get the original method def in case the declaring type is a generic
					// type instance and the method uses at least one generic type parameter.
					origMethod = methodBase.Module.ResolveMethod(methodBase.MetadataToken);
				}
				catch (ArgumentException) {
					// Here if eg. the method was created by the runtime (eg. a multi-dimensional
					// array getter/setter method). The method token is in that case 0x06000000,
					// which is invalid.
					origMethod = methodBase;
				}

				var methodSig = CreateMethodSig(origMethod);
				IMethodDefOrRef methodRef = module.UpdateRowId(new MemberRefUser(module, methodBase.Name, methodSig, parent));
				methodRef = TryResolveMethod(methodRef);
				if (FixSignature && !forceFixSignature) {
					//TODO:
				}
				return methodRef;
			}
		}

		MethodSig CreateMethodSig(MethodBase mb) {
			var sig = new MethodSig(GetCallingConvention(mb));

			var mi = mb as MethodInfo;
			if (mi != null)
				sig.RetType = ImportAsTypeSig(mi.ReturnParameter, mb.DeclaringType);
			else
				sig.RetType = module.CorLibTypes.Void;

			foreach (var p in mb.GetParameters())
				sig.Params.Add(ImportAsTypeSig(p, mb.DeclaringType));

			if (mb.IsGenericMethodDefinition)
				sig.GenParamCount = (uint)mb.GetGenericArguments().Length;

			return sig;
		}

		TypeSig ImportAsTypeSig(ParameterInfo p, Type declaringType) {
			return ImportAsTypeSig(p.ParameterType, p.GetRequiredCustomModifiers(), p.GetOptionalCustomModifiers(), declaringType.MustTreatTypeAsGenericInstType(p.ParameterType));
		}

		CallingConvention GetCallingConvention(MethodBase mb) {
			CallingConvention cc = 0;

			var mbcc = mb.CallingConvention;
			if (mb.IsGenericMethodDefinition)
				cc |= CallingConvention.Generic;
			if ((mbcc & CallingConventions.HasThis) != 0)
				cc |= CallingConvention.HasThis;
			if ((mbcc & CallingConventions.ExplicitThis) != 0)
				cc |= CallingConvention.ExplicitThis;

			switch (mbcc & CallingConventions.Any) {
			case CallingConventions.Standard:
				cc |= CallingConvention.Default;
				break;

			case CallingConventions.VarArgs:
				cc |= CallingConvention.VarArg;
				break;

			case CallingConventions.Any:
			default:
				FixSignature = true;
				cc |= CallingConvention.Default;
				break;
			}

			return cc;
		}

		GenericInstMethodSig CreateGenericInstMethodSig(MethodBase mb) {
			var genMethodArgs = mb.GetGenericArguments();
			var gim = new GenericInstMethodSig(CallingConvention.GenericInst, (uint)genMethodArgs.Length);
			foreach (var gma in genMethodArgs)
				gim.GenericArguments.Add(ImportAsTypeSig(gma));
			return gim;
		}

		IMemberRefParent GetModuleParent(Module module2) {
			// If we have no assembly, assume this is a netmodule in the same assembly as module
			var modAsm = module.Assembly;
			bool isSameAssembly = modAsm == null ||
				UTF8String.ToSystemStringOrEmpty(modAsm.Name).Equals(module2.Assembly.GetName().Name, StringComparison.OrdinalIgnoreCase);
			if (!isSameAssembly)
				return null;
			return module.UpdateRowId(new ModuleRefUser(module, module.Name));
		}

		/// <summary>
		/// Imports a <see cref="FieldInfo"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="fieldInfo">The field</param>
		/// <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
		/// or if we failed to import the field</returns>
		public IField Import(FieldInfo fieldInfo) {
			return Import(fieldInfo, false);
		}

		/// <summary>
		/// Imports a <see cref="FieldInfo"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="fieldInfo">The field</param>
		/// <param name="forceFixSignature">Always verify field signature to make sure the
		/// returned reference matches the metadata in the source assembly</param>
		/// <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
		/// or if we failed to import the field</returns>
		public IField Import(FieldInfo fieldInfo, bool forceFixSignature) {
			FixSignature = false;
			if (fieldInfo == null)
				return null;

			if (forceFixSignature) {
				//TODO:
			}

			IMemberRefParent parent;
			if (fieldInfo.DeclaringType == null) {
				// It's the global type. We can reference it with a ModuleRef token.
				parent = GetModuleParent(fieldInfo.Module);
			}
			else
				parent = Import(fieldInfo.DeclaringType);
			if (parent == null)
				return null;

			FieldInfo origField;
			try {
				// Get the original field def in case the declaring type is a generic
				// type instance and the field uses a generic type parameter.
				origField = fieldInfo.Module.ResolveField(fieldInfo.MetadataToken);
			}
			catch (ArgumentException) {
				origField = fieldInfo;
			}

			MemberRef fieldRef;
			if (origField.FieldType.ContainsGenericParameters) {
				var origDeclType = origField.DeclaringType;
				var asm = module.Context.AssemblyResolver.Resolve(origDeclType.Module.Assembly.GetName(), module);
				if (asm == null || asm.FullName != origDeclType.Assembly.FullName)
					throw new Exception("Couldn't resolve the correct assembly");
				var mod = asm.FindModule(origDeclType.Module.Name) as ModuleDefMD;
				if (mod == null)
					throw new Exception("Couldn't resolve the correct module");
				var fieldDef = mod.ResolveField((uint)(origField.MetadataToken & 0x00FFFFFF));
				if (fieldDef == null)
					throw new Exception("Couldn't resolve the correct field");

				var fieldSig = new FieldSig(Import(fieldDef.FieldSig.GetFieldType()));
				fieldRef = module.UpdateRowId(new MemberRefUser(module, fieldInfo.Name, fieldSig, parent));
			}
			else {
				var fieldSig = new FieldSig(ImportAsTypeSig(fieldInfo.FieldType, fieldInfo.GetRequiredCustomModifiers(), fieldInfo.GetOptionalCustomModifiers()));
				fieldRef = module.UpdateRowId(new MemberRefUser(module, fieldInfo.Name, fieldSig, parent));
			}
			var field = TryResolveField(fieldRef);
			if (FixSignature && !forceFixSignature) {
				//TODO:
			}
			return field;
		}

		/// <summary>
		/// Imports a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public IType Import(IType type) {
			if (type == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			IType result;
			TypeDef td;
			TypeRef tr;
			TypeSpec ts;
			TypeSig sig;

			if ((td = type as TypeDef) != null)
				result = Import(td);
			else if ((tr = type as TypeRef) != null)
				result = Import(tr);
			else if ((ts = type as TypeSpec) != null)
				result = Import(ts);
			else if ((sig = type as TypeSig) != null)
				result = Import(sig);
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="TypeDef"/> as a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public ITypeDefOrRef Import(TypeDef type) {
			if (type == null)
				return null;
			if (TryToUseTypeDefs && type.Module == module)
				return type;
			return Import2(type);
		}

		TypeRef Import2(TypeDef type) {
			if (type == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			TypeRef result;

			var declType = type.DeclaringType;
			if (declType != null)
				result = module.UpdateRowId(new TypeRefUser(module, type.Namespace, type.Name, Import2(declType)));
			else
				result = module.UpdateRowId(new TypeRefUser(module, type.Namespace, type.Name, CreateScopeReference(type.DefinitionAssembly, type.Module)));

			recursionCounter.Decrement();
			return result;
		}

		IResolutionScope CreateScopeReference(IAssembly defAsm, ModuleDef defMod) {
			if (defAsm == null)
				return null;
			var modAsm = module.Assembly;
			if (defMod != null && defAsm != null && modAsm != null) {
				if (UTF8String.CaseInsensitiveEquals(modAsm.Name, defAsm.Name)) {
					if (UTF8String.CaseInsensitiveEquals(module.Name, defMod.Name))
						return module;
					return module.UpdateRowId(new ModuleRefUser(module, defMod.Name));
				}
			}
			var pkt = PublicKeyBase.ToPublicKeyToken(defAsm.PublicKeyOrToken);
			if (PublicKeyBase.IsNullOrEmpty2(pkt))
				pkt = null;
			return module.UpdateRowId(new AssemblyRefUser(defAsm.Name, defAsm.Version, pkt, defAsm.Culture) { Attributes = defAsm.Attributes & ~AssemblyAttributes.PublicKey });
		}

		/// <summary>
		/// Imports a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public ITypeDefOrRef Import(TypeRef type) {
			return TryResolve(Import2(type));
		}

		TypeRef Import2(TypeRef type) {
			if (type == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			TypeRef result;

			var declaringType = type.DeclaringType;
			if (declaringType != null)
				result = module.UpdateRowId(new TypeRefUser(module, type.Namespace, type.Name, Import2(declaringType)));
			else
				result = module.UpdateRowId(new TypeRefUser(module, type.Namespace, type.Name, CreateScopeReference(type.DefinitionAssembly, type.Module)));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeSpec Import(TypeSpec type) {
			if (type == null)
				return null;
			return module.UpdateRowId(new TypeSpecUser(Import(type.TypeSig)));
		}

		/// <summary>
		/// Imports a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeSig Import(TypeSig type) {
			if (type == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			TypeSig result;
			switch (type.ElementType) {
			case ElementType.Void:		result = module.CorLibTypes.Void; break;
			case ElementType.Boolean:	result = module.CorLibTypes.Boolean; break;
			case ElementType.Char:		result = module.CorLibTypes.Char; break;
			case ElementType.I1:		result = module.CorLibTypes.SByte; break;
			case ElementType.U1:		result = module.CorLibTypes.Byte; break;
			case ElementType.I2:		result = module.CorLibTypes.Int16; break;
			case ElementType.U2:		result = module.CorLibTypes.UInt16; break;
			case ElementType.I4:		result = module.CorLibTypes.Int32; break;
			case ElementType.U4:		result = module.CorLibTypes.UInt32; break;
			case ElementType.I8:		result = module.CorLibTypes.Int64; break;
			case ElementType.U8:		result = module.CorLibTypes.UInt64; break;
			case ElementType.R4:		result = module.CorLibTypes.Single; break;
			case ElementType.R8:		result = module.CorLibTypes.Double; break;
			case ElementType.String:	result = module.CorLibTypes.String; break;
			case ElementType.TypedByRef:result = module.CorLibTypes.TypedReference; break;
			case ElementType.I:			result = module.CorLibTypes.IntPtr; break;
			case ElementType.U:			result = module.CorLibTypes.UIntPtr; break;
			case ElementType.Object:	result = module.CorLibTypes.Object; break;
			case ElementType.Ptr:		result = new PtrSig(Import(type.Next)); break;
			case ElementType.ByRef:		result = new ByRefSig(Import(type.Next)); break;
			case ElementType.ValueType: result = CreateClassOrValueType((type as ClassOrValueTypeSig).TypeDefOrRef, true); break;
			case ElementType.Class:		result = CreateClassOrValueType((type as ClassOrValueTypeSig).TypeDefOrRef, false); break;
			case ElementType.Var:		result = new GenericVar((type as GenericVar).Number, gpContext.Type); break;
			case ElementType.ValueArray:result = new ValueArraySig(Import(type.Next), (type as ValueArraySig).Size); break;
			case ElementType.FnPtr:		result = new FnPtrSig(Import((type as FnPtrSig).Signature)); break;
			case ElementType.SZArray:	result = new SZArraySig(Import(type.Next)); break;
			case ElementType.MVar:		result = new GenericMVar((type as GenericMVar).Number, gpContext.Method); break;
			case ElementType.CModReqd:	result = new CModReqdSig(Import((type as ModifierSig).Modifier), Import(type.Next)); break;
			case ElementType.CModOpt:	result = new CModOptSig(Import((type as ModifierSig).Modifier), Import(type.Next)); break;
			case ElementType.Module:	result = new ModuleSig((type as ModuleSig).Index, Import(type.Next)); break;
			case ElementType.Sentinel:	result = new SentinelSig(); break;
			case ElementType.Pinned:	result = new PinnedSig(Import(type.Next)); break;

			case ElementType.Array:
				var arraySig = (ArraySig)type;
				var sizes = new List<uint>(arraySig.Sizes);
				var lbounds = new List<int>(arraySig.LowerBounds);
				result = new ArraySig(Import(type.Next), arraySig.Rank, sizes, lbounds);
				break;

			case ElementType.GenericInst:
				var gis = (GenericInstSig)type;
				var genArgs = new List<TypeSig>(gis.GenericArguments.Count);
				foreach (var ga in gis.GenericArguments.GetSafeEnumerable())
					genArgs.Add(Import(ga));
				result = new GenericInstSig(Import(gis.GenericType) as ClassOrValueTypeSig, genArgs);
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			recursionCounter.Decrement();
			return result;
		}

		ITypeDefOrRef Import(ITypeDefOrRef type) {
			return (ITypeDefOrRef)Import((IType)type);
		}

		TypeSig CreateClassOrValueType(ITypeDefOrRef type, bool isValueType) {
			var corLibType = module.CorLibTypes.GetCorLibTypeSig(type);
			if (corLibType != null)
				return corLibType;

			if (isValueType)
				return new ValueTypeSig(Import(type));
			return new ClassSig(Import(type));
		}

		/// <summary>
		/// Imports a <see cref="CallingConventionSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public CallingConventionSig Import(CallingConventionSig sig) {
			if (sig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			CallingConventionSig result;

			var sigType = sig.GetType();
			if (sigType == typeof(MethodSig))
				result = Import((MethodSig)sig);
			else if (sigType == typeof(FieldSig))
				result = Import((FieldSig)sig);
			else if (sigType == typeof(GenericInstMethodSig))
				result = Import((GenericInstMethodSig)sig);
			else if (sigType == typeof(PropertySig))
				result = Import((PropertySig)sig);
			else if (sigType == typeof(LocalSig))
				result = Import((LocalSig)sig);
			else
				result = null;	// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="FieldSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public FieldSig Import(FieldSig sig) {
			if (sig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			var result = new FieldSig(sig.GetCallingConvention(), Import(sig.Type));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="MethodSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public MethodSig Import(MethodSig sig) {
			if (sig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			MethodSig result = Import(new MethodSig(sig.GetCallingConvention()), sig);

			recursionCounter.Decrement();
			return result;
		}

		T Import<T>(T sig, T old) where T : MethodBaseSig {
			sig.RetType = Import(old.RetType);
			foreach (var p in old.Params.GetSafeEnumerable())
				sig.Params.Add(Import(p));
			sig.GenParamCount = old.GenParamCount;
			var paramsAfterSentinel = sig.ParamsAfterSentinel;
			if (paramsAfterSentinel != null) {
				foreach (var p in old.ParamsAfterSentinel.GetSafeEnumerable())
					paramsAfterSentinel.Add(Import(p));
			}
			return sig;
		}

		/// <summary>
		/// Imports a <see cref="PropertySig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public PropertySig Import(PropertySig sig) {
			if (sig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			PropertySig result = Import(new PropertySig(sig.GetCallingConvention()), sig);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="LocalSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public LocalSig Import(LocalSig sig) {
			if (sig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			LocalSig result = new LocalSig(sig.GetCallingConvention(), (uint)sig.Locals.Count);
			foreach (var l in sig.Locals.GetSafeEnumerable())
				result.Locals.Add(Import(l));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="GenericInstMethodSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public GenericInstMethodSig Import(GenericInstMethodSig sig) {
			if (sig == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			GenericInstMethodSig result = new GenericInstMethodSig(sig.GetCallingConvention(), (uint)sig.GenericArguments.Count);
			foreach (var l in sig.GenericArguments.GetSafeEnumerable())
				result.GenericArguments.Add(Import(l));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="IField"/>
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
		public IField Import(IField field) {
			if (field == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			IField result;
			MemberRef mr;
			FieldDef fd;

			if ((fd = field as FieldDef) != null)
				result = Import(fd);
			else if ((mr = field as MemberRef) != null)
				result = Import(mr);
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="IMethod"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public IMethod Import(IMethod method) {
			if (method == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			IMethod result;
			MethodDef md;
			MethodSpec ms;
			MemberRef mr;

			if ((md = method as MethodDef) != null)
				result = Import(md);
			else if ((ms = method as MethodSpec) != null)
				result = Import(ms);
			else if ((mr = method as MemberRef) != null)
				result = Import(mr);
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="FieldDef"/> as an <see cref="IField"/>
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
		public IField Import(FieldDef field) {
			if (field == null)
				return null;
			if (TryToUseFieldDefs && field.Module == module)
				return field;
			if (!recursionCounter.Increment())
				return null;

			MemberRef result = module.UpdateRowId(new MemberRefUser(module, field.Name));
			result.Signature = Import(field.Signature);
			result.Class = ImportParent(field.DeclaringType);

			recursionCounter.Decrement();
			return result;
		}

		IMemberRefParent ImportParent(TypeDef type) {
			if (type == null)
				return null;
			if (type.IsGlobalModuleType) {
				var om = type.Module;
				return module.UpdateRowId(new ModuleRefUser(module, om == null ? null : om.Name));
			}
			return Import(type);
		}

		/// <summary>
		/// Imports a <see cref="MethodDef"/> as an <see cref="IMethod"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public IMethod Import(MethodDef method) {
			if (method == null)
				return null;
			if (TryToUseMethodDefs && method.Module == module)
				return method;
			if (!recursionCounter.Increment())
				return null;

			MemberRef result = module.UpdateRowId(new MemberRefUser(module, method.Name));
			result.Signature = Import(method.Signature);
			result.Class = ImportParent(method.DeclaringType);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public MethodSpec Import(MethodSpec method) {
			if (method == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			MethodSpec result = module.UpdateRowId(new MethodSpecUser((IMethodDefOrRef)Import(method.Method)));
			result.Instantiation = Import(method.Instantiation);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="memberRef">The member ref</param>
		/// <returns>The imported member ref or <c>null</c> if <paramref name="memberRef"/> is invalid</returns>
		public MemberRef Import(MemberRef memberRef) {
			if (memberRef == null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			MemberRef result = module.UpdateRowId(new MemberRefUser(module, memberRef.Name));
			result.Signature = Import(memberRef.Signature);
			result.Class = Import(memberRef.Class);
			if (result.Class == null)	// Will be null if memberRef.Class is null or a MethodDef
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		IMemberRefParent Import(IMemberRefParent parent) {
			var tdr = parent as ITypeDefOrRef;
			if (tdr != null) {
				var td = tdr as TypeDef;
				if (td != null && td.IsGlobalModuleType) {
					var om = td.Module;
					return module.UpdateRowId(new ModuleRefUser(module, om == null ? null : om.Name));
				}
				return Import(tdr);
			}

			var modRef = parent as ModuleRef;
			if (modRef != null)
				return module.UpdateRowId(new ModuleRefUser(module, modRef.Name));

			var method = parent as MethodDef;
			if (method != null) {
				var dt = method.DeclaringType;
				return dt == null || dt.Module != module ? null : method;
			}

			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/InterfaceImpl.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the InterfaceImpl table
	/// </summary>
	[DebuggerDisplay("{Interface}")]
	public abstract class InterfaceImpl : IHasCustomAttribute, IContainsGenericParameter, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.InterfaceImpl, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 5; }
		}

		/// <summary>
		/// From column InterfaceImpl.Interface
		/// </summary>
		public ITypeDefOrRef Interface {
			get { return @interface; }
			set { @interface = value; }
		}
		/// <summary/>
		protected ITypeDefOrRef @interface;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 5; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		bool IContainsGenericParameter.ContainsGenericParameter {
			get { return TypeHelper.ContainsGenericParameter(this); }
		}
	}

	/// <summary>
	/// An InterfaceImpl row created by the user and not present in the original .NET file
	/// </summary>
	public class InterfaceImplUser : InterfaceImpl {
		/// <summary>
		/// Default constructor
		/// </summary>
		public InterfaceImplUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="interface">The interface the type implements</param>
		public InterfaceImplUser(ITypeDefOrRef @interface) {
			this.@interface = @interface;
		}
	}

	/// <summary>
	/// Created from a row in the InterfaceImpl table
	/// </summary>
	sealed class InterfaceImplMD : InterfaceImpl, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.InterfaceImpl, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>InterfaceImpl</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public InterfaceImplMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.InterfaceImplTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("InterfaceImpl rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			uint @interface = readerModule.TablesStream.ReadInterfaceImplRow2(origRid);
			this.@interface = readerModule.ResolveTypeDefOrRef(@interface, gpContext);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MDToken.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Diagnostics;
using dnlib.DotNet.MD;

namespace dnlib.DotNet {
	/// <summary>
	/// MetaData token
	/// </summary>
	[DebuggerDisplay("{Table} {Rid}")]
	public struct MDToken : IEquatable<MDToken>, IComparable<MDToken> {
		/// <summary>
		/// Mask to get the rid from a raw metadata token
		/// </summary>
		public const uint RID_MASK = 0x00FFFFFF;

		/// <summary>
		/// Max rid value
		/// </summary>
		public const uint RID_MAX = RID_MASK;

		/// <summary>
		/// Number of bits to right shift a raw metadata token to get the table index
		/// </summary>
		public const int TABLE_SHIFT = 24;

		readonly uint token;

		/// <summary>
		/// Returns the table type
		/// </summary>
		public Table Table {
			get { return ToTable(token); }
		}

		/// <summary>
		/// Returns the row id
		/// </summary>
		public uint Rid {
			get { return ToRID(token); }
		}

		/// <summary>
		/// Returns the raw token
		/// </summary>
		public uint Raw {
			get { return token; }
		}

		/// <summary>
		/// Returns <c>true</c> if it's a <c>null</c> token
		/// </summary>
		public bool IsNull {
			get { return Rid == 0; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="token">Raw token</param>
		public MDToken(uint token) {
			this.token = token;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="token">Raw token</param>
		public MDToken(int token)
			: this((uint)token) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">The table type</param>
		/// <param name="rid">Row id</param>
		public MDToken(Table table, uint rid)
			: this(((uint)table << TABLE_SHIFT) | rid) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">The table type</param>
		/// <param name="rid">Row id</param>
		public MDToken(Table table, int rid)
			: this(((uint)table << TABLE_SHIFT) | (uint)rid) {
		}

		/// <summary>
		/// Returns the <c>rid</c> (row ID)
		/// </summary>
		/// <param name="token">A raw metadata token</param>
		/// <returns>A <c>rid</c></returns>
		public static uint ToRID(uint token) {
			return token & RID_MASK;
		}

		/// <summary>
		/// Returns the <c>rid</c> (row ID)
		/// </summary>
		/// <param name="token">A raw metadata token</param>
		/// <returns>A <c>rid</c></returns>
		public static uint ToRID(int token) {
			return ToRID((uint)token);
		}

		/// <summary>
		/// Returns the <c>table</c>
		/// </summary>
		/// <param name="token">A raw metadata token</param>
		/// <returns>A metadata table index</returns>
		public static Table ToTable(uint token) {
			return (Table)(token >> TABLE_SHIFT);
		}

		/// <summary>
		/// Returns the <c>table</c>
		/// </summary>
		/// <param name="token">A raw metadata token</param>
		/// <returns>A metadata table index</returns>
		public static Table ToTable(int token) {
			return ToTable((uint)token);
		}

		/// <summary>
		/// Gets the token as a raw 32-bit signed integer
		/// </summary>
		public int ToInt32() {
			return (int)token;
		}

		/// <summary>
		/// Gets the token as a raw 32-bit unsigned integer
		/// </summary>
		public uint ToUInt32() {
			return token;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(MDToken left, MDToken right) {
			return left.CompareTo(right) == 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(MDToken left, MDToken right) {
			return left.CompareTo(right) != 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator <(MDToken left, MDToken right) {
			return left.CompareTo(right) < 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator >(MDToken left, MDToken right) {
			return left.CompareTo(right) > 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator <=(MDToken left, MDToken right) {
			return left.CompareTo(right) <= 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator >=(MDToken left, MDToken right) {
			return left.CompareTo(right) >= 0;
		}

		/// <inheritdoc/>
		public int CompareTo(MDToken other) {
			return token.CompareTo(other.token);
		}

		/// <inheritdoc/>
		public bool Equals(MDToken other) {
			return CompareTo(other) == 0;
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			if (!(obj is MDToken))
				return false;
			return Equals((MDToken)obj);
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			return (int)token;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0:X8}", token);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ManifestResource.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ManifestResource table
	/// </summary>
	[DebuggerDisplay("{Offset} {Name.String} {Implementation}")]
	public abstract class ManifestResource : IHasCustomAttribute, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.ManifestResource, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 18; }
		}

		/// <summary>
		/// From column ManifestResource.Offset
		/// </summary>
		public uint Offset {
			get { return offset; }
			set { offset = value; }
		}
		/// <summary/>
		protected uint offset;

		/// <summary>
		/// From column ManifestResource.Flags
		/// </summary>
		public ManifestResourceAttributes Flags {
			get { return (ManifestResourceAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column ManifestResource.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column ManifestResource.Implementation
		/// </summary>
		public IImplementation Implementation {
			get { return implementation; }
			set { implementation = value; }
		}
		/// <summary/>
		protected IImplementation implementation;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 18; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(ManifestResourceAttributes andMask, ManifestResourceAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Gets/sets the visibility
		/// </summary>
		public ManifestResourceAttributes Visibility {
			get { return (ManifestResourceAttributes)attributes & ManifestResourceAttributes.VisibilityMask; }
			set { ModifyAttributes(~ManifestResourceAttributes.VisibilityMask, value & ManifestResourceAttributes.VisibilityMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ManifestResourceAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic {
			get { return ((ManifestResourceAttributes)attributes & ManifestResourceAttributes.VisibilityMask) == ManifestResourceAttributes.Public; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ManifestResourceAttributes.Private"/> is set
		/// </summary>
		public bool IsPrivate {
			get { return ((ManifestResourceAttributes)attributes & ManifestResourceAttributes.VisibilityMask) == ManifestResourceAttributes.Private; }
		}
	}

	/// <summary>
	/// A ManifestResource row created by the user and not present in the original .NET file
	/// </summary>
	public class ManifestResourceUser : ManifestResource {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ManifestResourceUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="implementation">Implementation</param>
		public ManifestResourceUser(UTF8String name, IImplementation implementation)
			: this(name, implementation, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="implementation">Implementation</param>
		/// <param name="flags">Flags</param>
		public ManifestResourceUser(UTF8String name, IImplementation implementation, ManifestResourceAttributes flags)
			: this(name, implementation, flags, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="implementation">Implementation</param>
		/// <param name="flags">Flags</param>
		/// <param name="offset">Offset</param>
		public ManifestResourceUser(UTF8String name, IImplementation implementation, ManifestResourceAttributes flags, uint offset) {
			this.name = name;
			this.implementation = implementation;
			this.attributes = (int)flags;
			this.offset = offset;
		}
	}

	/// <summary>
	/// Created from a row in the ManifestResource table
	/// </summary>
	sealed class ManifestResourceMD : ManifestResource, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.ManifestResource, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ManifestResource</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ManifestResourceMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ManifestResourceTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("ManifestResource rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name;
			uint implementation = readerModule.TablesStream.ReadManifestResourceRow(origRid, out this.offset, out this.attributes, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.implementation = readerModule.ResolveImplementation(implementation);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ManifestResourceAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// ManifestResource flags. See CorHdr.h/CorManifestResourceFlags
	/// </summary>
	[Flags]
	public enum ManifestResourceAttributes : uint {
		/// <summary/>
		VisibilityMask	= 0x0007,
		/// <summary>The Resource is exported from the Assembly.</summary>
		Public			= 0x0001,
		/// <summary>The Resource is private to the Assembly.</summary>
		Private			= 0x0002,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MarshalBlobReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;

namespace dnlib.DotNet {
	/// <summary>
	/// Reads <see cref="MarshalType"/>s
	/// </summary>
	public struct MarshalBlobReader : IDisposable {
		readonly ModuleDef module;
		readonly IBinaryReader reader;
		readonly GenericParamContext gpContext;

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from the <c>#Blob</c> heap
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="sig">Blob offset</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDefMD module, uint sig) {
			return Read(module, module.BlobStream.CreateStream(sig), new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from the <c>#Blob</c> heap
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="sig">Blob offset</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDefMD module, uint sig, GenericParamContext gpContext) {
			return Read(module, module.BlobStream.CreateStream(sig), gpContext);
		}

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from <paramref name="data"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="data">Marshal data</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDef module, byte[] data) {
			return Read(module, MemoryImageStream.Create(data), new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from <paramref name="data"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="data">Marshal data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDef module, byte[] data, GenericParamContext gpContext) {
			return Read(module, MemoryImageStream.Create(data), gpContext);
		}

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from <see cref="reader"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">A reader that will be owned by us</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDef module, IBinaryReader reader) {
			return Read(module, reader, new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from <see cref="reader"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">A reader that will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDef module, IBinaryReader reader, GenericParamContext gpContext) {
			using (var marshalReader = new MarshalBlobReader(module, reader, gpContext))
				return marshalReader.Read();
		}

		MarshalBlobReader(ModuleDef module, IBinaryReader reader, GenericParamContext gpContext) {
			this.module = module;
			this.reader = reader;
			this.gpContext = gpContext;
		}

		MarshalType Read() {
			MarshalType returnValue;
			try {
				var nativeType = (NativeType)reader.ReadByte();
				NativeType nt;
				int size;
				switch (nativeType) {
				case NativeType.FixedSysString:
					size = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					returnValue = new FixedSysStringMarshalType(size);
					break;

				case NativeType.SafeArray:
					var vt = CanRead() ? (VariantType)reader.ReadCompressedUInt32() : VariantType.NotInitialized;
					var udtName = CanRead() ? ReadUTF8String() : null;
					var udtRef = (object)udtName == null ? null : TypeNameParser.ParseReflection(module, UTF8String.ToSystemStringOrEmpty(udtName), null, gpContext);
					returnValue = new SafeArrayMarshalType(vt, udtRef);
					break;

				case NativeType.FixedArray:
					size = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					nt = CanRead() ? (NativeType)reader.ReadCompressedUInt32() : NativeType.NotInitialized;
					returnValue = new FixedArrayMarshalType(size, nt);
					break;

				case NativeType.Array:
					nt = CanRead() ? (NativeType)reader.ReadCompressedUInt32() : NativeType.NotInitialized;
					int paramNum = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					size = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					int flags = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					returnValue = new ArrayMarshalType(nt, paramNum, size, flags);
					break;

				case NativeType.CustomMarshaler:
					var guid = ReadUTF8String();
					var nativeTypeName = ReadUTF8String();
					var custMarshalerName = ReadUTF8String();
					var cmRef = TypeNameParser.ParseReflection(module, UTF8String.ToSystemStringOrEmpty(custMarshalerName), new CAAssemblyRefFinder(module), gpContext);
					var cookie = ReadUTF8String();
					returnValue = new CustomMarshalType(guid, nativeTypeName, cmRef, cookie);
					break;

				case NativeType.IUnknown:
				case NativeType.IDispatch:
				case NativeType.IntF:
					int iidParamIndex = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					return new InterfaceMarshalType(nativeType, iidParamIndex);

				default:
					returnValue = new MarshalType(nativeType);
					break;
				}
			}
			catch {
				returnValue = new RawMarshalType(reader.ReadAllBytes());
			}

			return returnValue;
		}

		bool CanRead() {
			return reader.Position < reader.Length;
		}

		UTF8String ReadUTF8String() {
			uint len = reader.ReadCompressedUInt32();
			return len == 0 ? UTF8String.Empty : new UTF8String(reader.ReadBytes((int)len));
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (reader != null)
				reader.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MarshalType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Base class of all marshal types
	/// </summary>
	public class MarshalType {
		/// <summary>
		/// The native type
		/// </summary>
		protected readonly NativeType nativeType;

		/// <summary>
		/// Gets the <see cref="dnlib.DotNet.NativeType"/>
		/// </summary>
		public NativeType NativeType {
			get { return nativeType; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nativeType">Native type</param>
		public MarshalType(NativeType nativeType) {
			this.nativeType = nativeType;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return nativeType.ToString();
		}
	}

	/// <summary>
	/// Contains the raw marshal blob data
	/// </summary>
	public sealed class RawMarshalType : MarshalType {
		byte[] data;

		/// <summary>
		/// Gets/sets the raw data
		/// </summary>
		public byte[] Data {
			get { return data; }
			set { data = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Raw data</param>
		public RawMarshalType(byte[] data)
			: base(NativeType.RawBlob) {
			this.data = data;
		}
	}

	/// <summary>
	/// A <see cref="NativeType.FixedSysString"/> marshal type
	/// </summary>
	public sealed class FixedSysStringMarshalType : MarshalType {
		int size;

		/// <summary>
		/// Gets/sets the size
		/// </summary>
		public int Size {
			get { return size; }
			set { size = value; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Size"/> is valid
		/// </summary>
		public bool IsSizeValid {
			get { return size >= 0; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public FixedSysStringMarshalType()
			: this(-1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="size">Size</param>
		public FixedSysStringMarshalType(int size)
			: base(NativeType.FixedSysString) {
			this.size = size;
		}

		/// <inheritdoc/>
		public override string ToString() {
			if (IsSizeValid)
				return string.Format("{0} ({1})", nativeType, size);
			return string.Format("{0} (<no size>)", nativeType);
		}
	}

	/// <summary>
	/// A <see cref="NativeType.SafeArray"/> marshal type
	/// </summary>
	public sealed class SafeArrayMarshalType : MarshalType {
		VariantType vt;
		ITypeDefOrRef userDefinedSubType;

		/// <summary>
		/// Gets/sets the variant type
		/// </summary>
		public VariantType VariantType {
			get { return vt; }
			set { vt = value; }
		}

		/// <summary>
		/// Gets/sets the user-defined sub type (it's usually <c>null</c>)
		/// </summary>
		public ITypeDefOrRef UserDefinedSubType {
			get { return userDefinedSubType; }
			set { userDefinedSubType = value; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="VariantType"/> is valid
		/// </summary>
		public bool IsVariantTypeValid {
			get { return vt != VariantType.NotInitialized; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="UserDefinedSubType"/> is valid
		/// </summary>
		public bool IsUserDefinedSubTypeValid {
			get { return userDefinedSubType != null; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public SafeArrayMarshalType()
			: this(VariantType.NotInitialized, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="vt">Variant type</param>
		public SafeArrayMarshalType(VariantType vt)
			: this(vt, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="userDefinedSubType">User-defined sub type</param>
		public SafeArrayMarshalType(ITypeDefOrRef userDefinedSubType)
			: this(VariantType.NotInitialized, userDefinedSubType) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="vt">Variant type</param>
		/// <param name="userDefinedSubType">User-defined sub type</param>
		public SafeArrayMarshalType(VariantType vt, ITypeDefOrRef userDefinedSubType)
			: base(NativeType.SafeArray) {
			this.vt = vt;
			this.userDefinedSubType = userDefinedSubType;
		}

		/// <inheritdoc/>
		public override string ToString() {
			var udt = userDefinedSubType;
			if (udt != null)
				return string.Format("{0} ({1}, {2})", nativeType, vt, udt);
			return string.Format("{0} ({1})", nativeType, vt);
		}
	}

	/// <summary>
	/// A <see cref="NativeType.FixedArray"/> marshal type
	/// </summary>
	public sealed class FixedArrayMarshalType : MarshalType {
		int size;
		NativeType elementType;

		/// <summary>
		/// Gets/sets the element type
		/// </summary>
		public NativeType ElementType {
			get { return elementType; }
			set { elementType = value; }
		}

		/// <summary>
		/// Gets/sets the size
		/// </summary>
		public int Size {
			get { return size; }
			set { size = value; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ElementType"/> is valid
		/// </summary>
		public bool IsElementTypeValid {
			get { return elementType != NativeType.NotInitialized; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Size"/> is valid
		/// </summary>
		public bool IsSizeValid {
			get { return size >= 0; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public FixedArrayMarshalType()
			: this(0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="size">Size</param>
		public FixedArrayMarshalType(int size)
			: this(size, NativeType.NotInitialized) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="size">Size</param>
		/// <param name="elementType">Element type</param>
		public FixedArrayMarshalType(int size, NativeType elementType)
			: base(NativeType.FixedArray) {
			this.size = size;
			this.elementType = elementType;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0} ({1}, {2})", nativeType, size, elementType);
		}
	}

	/// <summary>
	/// A <see cref="NativeType.Array"/> marshal type
	/// </summary>
	public sealed class ArrayMarshalType : MarshalType {
		NativeType elementType;
		int paramNum;
		int numElems;
		int flags;

		/// <summary>
		/// Gets/sets the element type
		/// </summary>
		public NativeType ElementType {
			get { return elementType; }
			set { elementType = value; }
		}

		/// <summary>
		/// Gets/sets the parameter number
		/// </summary>
		public int ParamNumber {
			get { return paramNum; }
			set { paramNum = value; }
		}

		/// <summary>
		/// Gets/sets the size of the array
		/// </summary>
		public int Size {
			get { return numElems; }
			set { numElems = value; }
		}

		/// <summary>
		/// Gets/sets the flags
		/// </summary>
		public int Flags {
			get { return flags; }
			set { flags = value; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ElementType"/> is valid
		/// </summary>
		public bool IsElementTypeValid {
			get { return elementType != NativeType.NotInitialized; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ParamNumber"/> is valid
		/// </summary>
		public bool IsParamNumberValid {
			get { return paramNum >= 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Size"/> is valid
		/// </summary>
		public bool IsSizeValid {
			get { return numElems >= 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Flags"/> is valid
		/// </summary>
		public bool IsFlagsValid {
			get { return flags >= 0; }
		}

		const int ntaSizeParamIndexSpecified = 1;

		/// <summary>
		/// <c>true</c> if <c>ntaSizeParamIndexSpecified</c> bit is set, <c>false</c> if it's not
		/// set or if <see cref="Flags"/> is invalid.
		/// </summary>
		public bool IsSizeParamIndexSpecified {
			get { return IsFlagsValid && (flags & ntaSizeParamIndexSpecified) != 0; }
		}

		/// <summary>
		/// <c>true</c> if <c>ntaSizeParamIndexSpecified</c> bit is not set, <c>false</c> if it's
		/// set or if <see cref="Flags"/> is invalid.
		/// </summary>
		public bool IsSizeParamIndexNotSpecified {
			get { return IsFlagsValid && (flags & ntaSizeParamIndexSpecified) == 0; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public ArrayMarshalType()
			: this(NativeType.NotInitialized, -1, -1, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="elementType">Element type</param>
		public ArrayMarshalType(NativeType elementType)
			: this(elementType, -1, -1, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="elementType">Element type</param>
		/// <param name="paramNum">Parameter number</param>
		public ArrayMarshalType(NativeType elementType, int paramNum)
			: this(elementType, paramNum, -1, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="elementType">Element type</param>
		/// <param name="paramNum">Parameter number</param>
		/// <param name="numElems">Number of elements</param>
		public ArrayMarshalType(NativeType elementType, int paramNum, int numElems)
			: this(elementType, paramNum, numElems, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="elementType">Element type</param>
		/// <param name="paramNum">Parameter number</param>
		/// <param name="numElems">Number of elements</param>
		/// <param name="flags">Flags</param>
		public ArrayMarshalType(NativeType elementType, int paramNum, int numElems, int flags)
			: base(NativeType.Array) {
			this.elementType = elementType;
			this.paramNum = paramNum;
			this.numElems = numElems;
			this.flags = flags;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0} ({1}, {2}, {3}, {4})", nativeType, elementType, paramNum, numElems, flags);
		}
	}

	/// <summary>
	/// A <see cref="NativeType.CustomMarshaler"/> marshal type
	/// </summary>
	public sealed class CustomMarshalType : MarshalType {
		UTF8String guid;
		UTF8String nativeTypeName;
		ITypeDefOrRef custMarshaler;
		UTF8String cookie;

		/// <summary>
		/// Gets/sets the <c>GUID</c> string
		/// </summary>
		public UTF8String Guid {
			get { return guid; }
			set { guid = value; }
		}

		/// <summary>
		/// Gets/sets the native type name string
		/// </summary>
		public UTF8String NativeTypeName {
			get { return nativeTypeName; }
			set { nativeTypeName = value; }
		}

		/// <summary>
		/// Gets/sets the custom marshaler
		/// </summary>
		public ITypeDefOrRef CustomMarshaler {
			get { return custMarshaler; }
			set { custMarshaler = value; }
		}

		/// <summary>
		/// Gets/sets the cookie string
		/// </summary>
		public UTF8String Cookie {
			get { return cookie; }
			set { cookie = value; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public CustomMarshalType()
			: this(null, null, null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">GUID string</param>
		public CustomMarshalType(UTF8String guid)
			: this(guid, null, null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">GUID string</param>
		/// <param name="nativeTypeName">Native type name string</param>
		public CustomMarshalType(UTF8String guid, UTF8String nativeTypeName)
			: this(guid, nativeTypeName, null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">GUID string</param>
		/// <param name="nativeTypeName">Native type name string</param>
		/// <param name="custMarshaler">Custom marshaler name string</param>
		public CustomMarshalType(UTF8String guid, UTF8String nativeTypeName, ITypeDefOrRef custMarshaler)
			: this(guid, nativeTypeName, custMarshaler, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">GUID string</param>
		/// <param name="nativeTypeName">Native type name string</param>
		/// <param name="custMarshaler">Custom marshaler name string</param>
		/// <param name="cookie">Cookie string</param>
		public CustomMarshalType(UTF8String guid, UTF8String nativeTypeName, ITypeDefOrRef custMarshaler, UTF8String cookie)
			: base(NativeType.CustomMarshaler) {
			this.guid = guid;
			this.nativeTypeName = nativeTypeName;
			this.custMarshaler = custMarshaler;
			this.cookie = cookie;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0} ({1}, {2}, {3}, {4})", nativeType, guid, nativeTypeName, custMarshaler, cookie);
		}
	}

	/// <summary>
	/// A <see cref="NativeType.IUnknown"/>, <see cref="NativeType.IDispatch"/> or a
	/// <see cref="NativeType.IntF"/> marshal type
	/// </summary>
	public sealed class InterfaceMarshalType : MarshalType {
		int iidParamIndex;

		/// <summary>
		/// Gets/sets the IID parameter index
		/// </summary>
		public int IidParamIndex {
			get { return iidParamIndex; }
			set { iidParamIndex = value; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="IidParamIndex"/> is valid
		/// </summary>
		public bool IsIidParamIndexValid {
			get { return iidParamIndex >= 0; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nativeType">Native type</param>
		public InterfaceMarshalType(NativeType nativeType)
			: this(nativeType, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nativeType">Native type</param>
		/// <param name="iidParamIndex">IID parameter index</param>
		public InterfaceMarshalType(NativeType nativeType, int iidParamIndex)
			: base(nativeType) {
			if (nativeType != NativeType.IUnknown &&
				nativeType != NativeType.IDispatch &&
				nativeType != NativeType.IntF)
				throw new ArgumentException("Invalid nativeType");
			this.iidParamIndex = iidParamIndex;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0} ({1})", nativeType, iidParamIndex);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MemberFinder.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace dnlib.DotNet {
	/// <summary>
	/// Finds types, fields, methods, etc in a module. If nothing has been added to the module, it's
	/// faster to call ResolveMethodDef(), ResolveTypeRef() etc.
	/// </summary>
	public class MemberFinder {
		enum ObjectType {
			Unknown,
			EventDef,
			FieldDef,
			GenericParam,
			MemberRef,
			MethodDef,
			MethodSpec,
			PropertyDef,
			TypeDef,
			TypeRef,
			TypeSig,
			TypeSpec,
			ExportedType,
		}

		/// <summary>
		/// All found <see cref="CustomAttribute"/>s
		/// </summary>
		public readonly Dictionary<CustomAttribute, bool> CustomAttributes = new Dictionary<CustomAttribute, bool>();

		/// <summary>
		/// All found <see cref="EventDef"/>s
		/// </summary>
		public readonly Dictionary<EventDef, bool> EventDefs = new Dictionary<EventDef, bool>();

		/// <summary>
		/// All found <see cref="FieldDef"/>s
		/// </summary>
		public readonly Dictionary<FieldDef, bool> FieldDefs = new Dictionary<FieldDef, bool>();

		/// <summary>
		/// All found <see cref="GenericParam"/>s
		/// </summary>
		public readonly Dictionary<GenericParam, bool> GenericParams = new Dictionary<GenericParam, bool>();

		/// <summary>
		/// All found <see cref="MemberRef"/>s
		/// </summary>
		public readonly Dictionary<MemberRef, bool> MemberRefs = new Dictionary<MemberRef, bool>();

		/// <summary>
		/// All found <see cref="MethodDef"/>s
		/// </summary>
		public readonly Dictionary<MethodDef, bool> MethodDefs = new Dictionary<MethodDef, bool>();

		/// <summary>
		/// All found <see cref="MethodSpec"/>s
		/// </summary>
		public readonly Dictionary<MethodSpec, bool> MethodSpecs = new Dictionary<MethodSpec, bool>();

		/// <summary>
		/// All found <see cref="PropertyDef"/>s
		/// </summary>
		public readonly Dictionary<PropertyDef, bool> PropertyDefs = new Dictionary<PropertyDef, bool>();

		/// <summary>
		/// All found <see cref="TypeDef"/>s
		/// </summary>
		public readonly Dictionary<TypeDef, bool> TypeDefs = new Dictionary<TypeDef, bool>();

		/// <summary>
		/// All found <see cref="TypeRef"/>s
		/// </summary>
		public readonly Dictionary<TypeRef, bool> TypeRefs = new Dictionary<TypeRef, bool>();

		/// <summary>
		/// All found <see cref="TypeSig"/>s
		/// </summary>
		public readonly Dictionary<TypeSig, bool> TypeSigs = new Dictionary<TypeSig, bool>();

		/// <summary>
		/// All found <see cref="TypeSpec"/>s
		/// </summary>
		public readonly Dictionary<TypeSpec, bool> TypeSpecs = new Dictionary<TypeSpec, bool>();

		/// <summary>
		/// All found <see cref="ExportedType"/>s
		/// </summary>
		public readonly Dictionary<ExportedType, bool> ExportedTypes = new Dictionary<ExportedType, bool>();

		Stack<object> objectStack;
		ModuleDef validModule;

		/// <summary>
		/// Finds all types, fields, etc
		/// </summary>
		/// <param name="module">The module to scan</param>
		/// <returns>Itself</returns>
		public MemberFinder FindAll(ModuleDef module) {
			validModule = module;

			// This needs to be big. About 2048 entries should be enough for most though...
			objectStack = new Stack<object>(0x1000);

			Add(module);
			ProcessAll();

			objectStack = null;

			return this;
		}

		void Push(object mr) {
			if (mr == null)
				return;
			objectStack.Push(mr);
		}

		void ProcessAll() {
			while (objectStack.Count > 0) {
				var o = objectStack.Pop();
				switch (GetObjectType(o)) {
				case ObjectType.Unknown: break;
				case ObjectType.EventDef:		Add((EventDef)o); break;
				case ObjectType.FieldDef:		Add((FieldDef)o); break;
				case ObjectType.GenericParam:	Add((GenericParam)o); break;
				case ObjectType.MemberRef:		Add((MemberRef)o); break;
				case ObjectType.MethodDef:		Add((MethodDef)o); break;
				case ObjectType.MethodSpec:		Add((MethodSpec)o); break;
				case ObjectType.PropertyDef:	Add((PropertyDef)o); break;
				case ObjectType.TypeDef:		Add((TypeDef)o); break;
				case ObjectType.TypeRef:		Add((TypeRef)o); break;
				case ObjectType.TypeSig:		Add((TypeSig)o); break;
				case ObjectType.TypeSpec:		Add((TypeSpec)o); break;
				case ObjectType.ExportedType:	Add((ExportedType)o); break;
				default: throw new InvalidOperationException(string.Format("Unknown type: {0}", o.GetType()));
				}
			}
		}

		readonly Dictionary<Type, ObjectType> toObjectType = new Dictionary<Type, ObjectType>();
		ObjectType GetObjectType(object o) {
			if (o == null)
				return ObjectType.Unknown;
			var type = o.GetType();
			ObjectType mrType;
			if (toObjectType.TryGetValue(type, out mrType))
				return mrType;
			mrType = GetObjectType2(o);
			toObjectType[type] = mrType;
			return mrType;
		}

		static ObjectType GetObjectType2(object o) {
			if (o is EventDef)		return ObjectType.EventDef;
			if (o is FieldDef)		return ObjectType.FieldDef;
			if (o is GenericParam)	return ObjectType.GenericParam;
			if (o is MemberRef)		return ObjectType.MemberRef;
			if (o is MethodDef)		return ObjectType.MethodDef;
			if (o is MethodSpec)	return ObjectType.MethodSpec;
			if (o is PropertyDef)	return ObjectType.PropertyDef;
			if (o is TypeDef)		return ObjectType.TypeDef;
			if (o is TypeRef)		return ObjectType.TypeRef;
			if (o is TypeSig)		return ObjectType.TypeSig;
			if (o is TypeSpec)		return ObjectType.TypeSpec;
			if (o is ExportedType)	return ObjectType.ExportedType;
			return ObjectType.Unknown;
		}

		void Add(ModuleDef mod) {
			Push(mod.ManagedEntryPoint);
			Add(mod.CustomAttributes);
			Add(mod.Types);
			Add(mod.ExportedTypes);
			if (mod.IsManifestModule)
				Add(mod.Assembly);
			Add(mod.VTableFixups);
		}

		void Add(VTableFixups fixups) {
			if (fixups == null)
				return;
			foreach (var fixup in fixups) {
				foreach (var method in fixup)
					Push(method);
			}
		}

		void Add(AssemblyDef asm) {
			if (asm == null)
				return;
			Add(asm.DeclSecurities);
			Add(asm.CustomAttributes);
		}

		void Add(CallingConventionSig sig) {
			if (sig == null)
				return;

			var fs = sig as FieldSig;
			if (fs != null) {
				Add(fs);
				return;
			}

			var mbs = sig as MethodBaseSig;
			if (mbs != null) {
				Add(mbs);
				return;
			}

			var ls = sig as LocalSig;
			if (ls != null) {
				Add(ls);
				return;
			}

			var gims = sig as GenericInstMethodSig;
			if (gims != null) {
				Add(gims);
				return;
			}
		}

		void Add(FieldSig sig) {
			if (sig == null)
				return;
			Add(sig.Type);
		}

		void Add(MethodBaseSig sig) {
			if (sig == null)
				return;
			Add(sig.RetType);
			Add(sig.Params);
			Add(sig.ParamsAfterSentinel);
		}

		void Add(LocalSig sig) {
			if (sig == null)
				return;
			Add(sig.Locals);
		}

		void Add(GenericInstMethodSig sig) {
			if (sig == null)
				return;
			Add(sig.GenericArguments);
		}

		void Add(IEnumerable<CustomAttribute> cas) {
			if (cas == null)
				return;
			foreach (var ca in cas)
				Add(ca);
		}

		void Add(CustomAttribute ca) {
			if (ca == null || CustomAttributes.ContainsKey(ca))
				return;
			CustomAttributes[ca] = true;
			Push(ca.Constructor);
			Add(ca.ConstructorArguments);
			Add(ca.NamedArguments);
		}

		void Add(IEnumerable<CAArgument> args) {
			if (args == null)
				return;
			foreach (var arg in args)
				Add(arg);
		}

		void Add(CAArgument arg) {
			// It's a struct so can't be null
			Add(arg.Type);
		}

		void Add(IEnumerable<CANamedArgument> args) {
			if (args == null)
				return;
			foreach (var arg in args)
				Add(arg);
		}

		void Add(CANamedArgument arg) {
			if (arg == null)
				return;
			Add(arg.Type);
			Add(arg.Argument);
		}

		void Add(IEnumerable<DeclSecurity> decls) {
			if (decls == null)
				return;
			foreach (var decl in decls)
				Add(decl);
		}

		void Add(DeclSecurity decl) {
			if (decl == null)
				return;
			Add(decl.SecurityAttributes);
			Add(decl.CustomAttributes);
		}

		void Add(IEnumerable<SecurityAttribute> secAttrs) {
			if (secAttrs == null)
				return;
			foreach (var secAttr in secAttrs)
				Add(secAttr);
		}

		void Add(SecurityAttribute secAttr) {
			if (secAttr == null)
				return;
			Add(secAttr.AttributeType);
			Add(secAttr.NamedArguments);
		}

		void Add(ITypeDefOrRef tdr) {
			var td = tdr as TypeDef;
			if (td != null) {
				Add(td);
				return;
			}

			var tr = tdr as TypeRef;
			if (tr != null) {
				Add(tr);
				return;
			}

			var ts = tdr as TypeSpec;
			if (ts != null) {
				Add(ts);
				return;
			}
		}

		void Add(IEnumerable<EventDef> eds) {
			if (eds == null)
				return;
			foreach (var ed in eds)
				Add(ed);
		}

		void Add(EventDef ed) {
			if (ed == null || EventDefs.ContainsKey(ed))
				return;
			if (ed.DeclaringType != null && ed.DeclaringType.Module != validModule)
				return;
			EventDefs[ed] = true;
			Push(ed.EventType);
			Add(ed.CustomAttributes);
			Add(ed.AddMethod);
			Add(ed.InvokeMethod);
			Add(ed.RemoveMethod);
			Add(ed.OtherMethods);
			Add(ed.DeclaringType);
		}

		void Add(IEnumerable<FieldDef> fds) {
			if (fds == null)
				return;
			foreach (var fd in fds)
				Add(fd);
		}

		void Add(FieldDef fd) {
			if (fd == null || FieldDefs.ContainsKey(fd))
				return;
			if (fd.DeclaringType != null && fd.DeclaringType.Module != validModule)
				return;
			FieldDefs[fd] = true;
			Add(fd.CustomAttributes);
			Add(fd.Signature);
			Add(fd.DeclaringType);
			Add(fd.MarshalType);
		}

		void Add(IEnumerable<GenericParam> gps) {
			if (gps == null)
				return;
			foreach (var gp in gps)
				Add(gp);
		}

		void Add(GenericParam gp) {
			if (gp == null || GenericParams.ContainsKey(gp))
				return;
			GenericParams[gp] = true;
			Push(gp.Owner);
			Push(gp.Kind);
			Add(gp.GenericParamConstraints);
			Add(gp.CustomAttributes);
		}

		void Add(IEnumerable<GenericParamConstraint> gpcs) {
			if (gpcs == null)
				return;
			foreach (var gpc in gpcs)
				Add(gpc);
		}

		void Add(GenericParamConstraint gpc) {
			if (gpc == null)
				return;
			Add(gpc.Owner);
			Push(gpc.Constraint);
			Add(gpc.CustomAttributes);
		}

		void Add(MemberRef mr) {
			if (mr == null || MemberRefs.ContainsKey(mr))
				return;
			if (mr.Module != validModule)
				return;
			MemberRefs[mr] = true;
			Push(mr.Class);
			Add(mr.Signature);
			Add(mr.CustomAttributes);
		}

		void Add(IEnumerable<MethodDef> methods) {
			if (methods == null)
				return;
			foreach (var m in methods)
				Add(m);
		}

		void Add(MethodDef md) {
			if (md == null || MethodDefs.ContainsKey(md))
				return;
			if (md.DeclaringType != null && md.DeclaringType.Module != validModule)
				return;
			MethodDefs[md] = true;
			Add(md.Signature);
			Add(md.ParamDefs);
			Add(md.GenericParameters);
			Add(md.DeclSecurities);
			Add(md.MethodBody);
			Add(md.CustomAttributes);
			Add(md.Overrides);
			Add(md.DeclaringType);
		}

		void Add(MethodBody mb) {
			var cb = mb as CilBody;
			if (cb != null)
				Add(cb);
		}

		void Add(CilBody cb) {
			if (cb == null)
				return;
			Add(cb.Instructions);
			Add(cb.ExceptionHandlers);
			Add(cb.Variables);
		}

		void Add(IEnumerable<Instruction> instrs) {
			if (instrs == null)
				return;
			foreach (var instr in instrs) {
				if (instr == null)
					continue;
				switch (instr.OpCode.OperandType) {
				case OperandType.InlineTok:
				case OperandType.InlineType:
				case OperandType.InlineMethod:
				case OperandType.InlineField:
					Push(instr.Operand);
					break;

				case OperandType.InlineSig:
					Add(instr.Operand as CallingConventionSig);
					break;

				case OperandType.InlineVar:
				case OperandType.ShortInlineVar:
					var local = instr.Operand as Local;
					if (local != null) {
						Add(local);
						break;
					}
					var arg = instr.Operand as Parameter;
					if (arg != null) {
						Add(arg);
						break;
					}
					break;
				}
			}
		}

		void Add(IEnumerable<ExceptionHandler> ehs) {
			if (ehs == null)
				return;
			foreach (var eh in ehs)
				Push(eh.CatchType);
		}

		void Add(IEnumerable<Local> locals) {
			if (locals == null)
				return;
			foreach (var local in locals)
				Add(local);
		}

		void Add(Local local) {
			if (local == null)
				return;
			Add(local.Type);
		}

		void Add(IEnumerable<Parameter> ps) {
			if (ps == null)
				return;
			foreach (var p in ps)
				Add(p);
		}

		void Add(Parameter param) {
			if (param == null)
				return;
			Add(param.Type);
			Add(param.Method);
		}

		void Add(IEnumerable<ParamDef> pds) {
			if (pds == null)
				return;
			foreach (var pd in pds)
				Add(pd);
		}

		void Add(ParamDef pd) {
			if (pd == null)
				return;
			Add(pd.DeclaringMethod);
			Add(pd.CustomAttributes);
			Add(pd.MarshalType);
		}

		void Add(MarshalType mt) {
			if (mt == null)
				return;

			switch (mt.NativeType) {
			case NativeType.SafeArray:
				Add(((SafeArrayMarshalType)mt).UserDefinedSubType);
				break;

			case NativeType.CustomMarshaler:
				Add(((CustomMarshalType)mt).CustomMarshaler);
				break;
			}
		}

		void Add(IEnumerable<MethodOverride> mos) {
			if (mos == null)
				return;
			foreach (var mo in mos)
				Add(mo);
		}

		void Add(MethodOverride mo) {
			// It's a struct so can't be null
			Push(mo.MethodBody);
			Push(mo.MethodDeclaration);
		}

		void Add(MethodSpec ms) {
			if (ms == null || MethodSpecs.ContainsKey(ms))
				return;
			if (ms.Method != null && ms.Method.DeclaringType != null && ms.Method.DeclaringType.Module != validModule)
				return;
			MethodSpecs[ms] = true;
			Push(ms.Method);
			Add(ms.Instantiation);
			Add(ms.CustomAttributes);
		}

		void Add(IEnumerable<PropertyDef> pds) {
			if (pds == null)
				return;
			foreach (var pd in pds)
				Add(pd);
		}

		void Add(PropertyDef pd) {
			if (pd == null || PropertyDefs.ContainsKey(pd))
				return;
			if (pd.DeclaringType != null && pd.DeclaringType.Module != validModule)
				return;
			PropertyDefs[pd] = true;
			Add(pd.Type);
			Add(pd.CustomAttributes);
			Add(pd.GetMethods);
			Add(pd.SetMethods);
			Add(pd.OtherMethods);
			Add(pd.DeclaringType);
		}

		void Add(IEnumerable<TypeDef> tds) {
			if (tds == null)
				return;
			foreach (var td in tds)
				Add(td);
		}

		void Add(TypeDef td) {
			if (td == null || TypeDefs.ContainsKey(td))
				return;
			if (td.Module != validModule)
				return;
			TypeDefs[td] = true;
			Push(td.BaseType);
			Add(td.Fields);
			Add(td.Methods);
			Add(td.GenericParameters);
			Add(td.Interfaces);
			Add(td.DeclSecurities);
			Add(td.DeclaringType);
			Add(td.Events);
			Add(td.Properties);
			Add(td.NestedTypes);
			Add(td.CustomAttributes);
		}

		void Add(IEnumerable<InterfaceImpl> iis) {
			if (iis == null)
				return;
			foreach (var ii in iis)
				Add(ii);
		}

		void Add(InterfaceImpl ii) {
			if (ii == null)
				return;
			Push(ii.Interface);
			Add(ii.CustomAttributes);
		}

		void Add(TypeRef tr) {
			if (tr == null || TypeRefs.ContainsKey(tr))
				return;
			if (tr.Module != validModule)
				return;
			TypeRefs[tr] = true;
			Push(tr.ResolutionScope);
			Add(tr.CustomAttributes);
		}

		void Add(IEnumerable<TypeSig> tss) {
			if (tss == null)
				return;
			foreach (var ts in tss)
				Add(ts);
		}

		void Add(TypeSig ts) {
			if (ts == null || TypeSigs.ContainsKey(ts))
				return;
			if (ts.Module != validModule)
				return;
			TypeSigs[ts] = true;

			for (; ts != null; ts = ts.Next) {
				switch (ts.ElementType) {
				case ElementType.Void:
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.String:
				case ElementType.ValueType:
				case ElementType.Class:
				case ElementType.TypedByRef:
				case ElementType.I:
				case ElementType.U:
				case ElementType.Object:
					var tdrs = (TypeDefOrRefSig)ts;
					Push(tdrs.TypeDefOrRef);
					break;

				case ElementType.FnPtr:
					var fps = (FnPtrSig)ts;
					Add(fps.Signature);
					break;

				case ElementType.GenericInst:
					var gis = (GenericInstSig)ts;
					Add(gis.GenericType);
					Add(gis.GenericArguments);
					break;

				case ElementType.CModReqd:
				case ElementType.CModOpt:
					var ms = (ModifierSig)ts;
					Push(ms.Modifier);
					break;

				case ElementType.End:
				case ElementType.Ptr:
				case ElementType.ByRef:
				case ElementType.Var:
				case ElementType.Array:
				case ElementType.ValueArray:
				case ElementType.R:
				case ElementType.SZArray:
				case ElementType.MVar:
				case ElementType.Internal:
				case ElementType.Module:
				case ElementType.Sentinel:
				case ElementType.Pinned:
				default:
					break;
				}
			}
		}

		void Add(TypeSpec ts) {
			if (ts == null || TypeSpecs.ContainsKey(ts))
				return;
			if (ts.Module != validModule)
				return;
			TypeSpecs[ts] = true;
			Add(ts.TypeSig);
			Add(ts.CustomAttributes);
		}

		void Add(IEnumerable<ExportedType> ets) {
			if (ets == null)
				return;
			foreach (var et in ets)
				Add(et);
		}

		void Add(ExportedType et) {
			if (et == null || ExportedTypes.ContainsKey(et))
				return;
			if (et.Module != validModule)
				return;
			ExportedTypes[et] = true;
			Add(et.CustomAttributes);
			Push(et.Implementation);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MemberMDInitializer.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Methods to load properties to make sure they're initialized
	/// </summary>
	static class MemberMDInitializer {
		/// <summary>
		/// Read every collection element
		/// </summary>
		/// <typeparam name="T">Collection element type</typeparam>
		/// <param name="coll">Collection</param>
		public static void Initialize<T>(IEnumerable<T> coll) {
			if (coll == null)
				return;
			foreach (var c in coll.GetSafeEnumerable()) {
			}
		}

		/// <summary>
		/// Load the object instance
		/// </summary>
		/// <param name="o">The value (ignored)</param>
		public static void Initialize(object o) {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MemberRef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the MemberRef table
	/// </summary>
	public abstract class MemberRef : IHasCustomAttribute, IMethodDefOrRef, ICustomAttributeType, IField, IContainsGenericParameter, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <summary>
		/// The owner module
		/// </summary>
		protected ModuleDef module;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.MemberRef, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 6; }
		}

		/// <inheritdoc/>
		public int MethodDefOrRefTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public int CustomAttributeTypeTag {
			get { return 3; }
		}

		/// <summary>
		/// From column MemberRef.Class
		/// </summary>
		public IMemberRefParent Class {
			get { return @class; }
			set { @class = value; }
		}
		/// <summary/>
		protected IMemberRefParent @class;

		/// <summary>
		/// From column MemberRef.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column MemberRef.Signature
		/// </summary>
		public CallingConventionSig Signature {
			get { return signature; }
			set { signature = value; }
		}
		/// <summary/>
		protected CallingConventionSig signature;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 6; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <inheritdoc/>
		public ITypeDefOrRef DeclaringType {
			get {
				var owner = @class;

				var tdr = owner as ITypeDefOrRef;
				if (tdr != null)
					return tdr;

				var method = owner as MethodDef;
				if (method != null)
					return method.DeclaringType;

				var mr = owner as ModuleRef;
				if (mr != null) {
					var tr = GetGlobalTypeRef(mr);
					if (module != null)
						return module.UpdateRowId(tr);
					return tr;
				}

				return null;
			}
		}

		TypeRefUser GetGlobalTypeRef(ModuleRef mr) {
			if (module == null)
				return CreateDefaultGlobalTypeRef(mr);
			var globalType = module.GlobalType;
			if (globalType != null && new SigComparer().Equals(module, mr))
				return new TypeRefUser(module, globalType.Namespace, globalType.Name, mr);
			var asm = module.Assembly;
			if (asm == null)
				return CreateDefaultGlobalTypeRef(mr);
			var mod = asm.FindModule(mr.Name);
			if (mod == null)
				return CreateDefaultGlobalTypeRef(mr);
			globalType = mod.GlobalType;
			if (globalType == null)
				return CreateDefaultGlobalTypeRef(mr);
			return new TypeRefUser(module, globalType.Namespace, globalType.Name, mr);
		}

		TypeRefUser CreateDefaultGlobalTypeRef(ModuleRef mr) {
			var tr = new TypeRefUser(module, string.Empty, "<Module>", mr);
			if (module != null)
				module.UpdateRowId(tr);
			return tr;
		}

		bool IIsTypeOrMethod.IsType {
			get { return false; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return IsMethodRef; }
		}

		bool IMemberRef.IsField {
			get { return IsFieldRef; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return true; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		/// <summary>
		/// <c>true</c> if this is a method reference (<see cref="MethodSig"/> != <c>null</c>)
		/// </summary>
		public bool IsMethodRef {
			get { return MethodSig != null; }
		}

		/// <summary>
		/// <c>true</c> if this is a field reference (<see cref="FieldSig"/> != <c>null</c>)
		/// </summary>
		public bool IsFieldRef {
			get { return FieldSig != null; }
		}

		/// <summary>
		/// Gets/sets the method sig
		/// </summary>
		public MethodSig MethodSig {
			get { return signature as MethodSig; }
			set { signature = value; }
		}

		/// <summary>
		/// Gets/sets the field sig
		/// </summary>
		public FieldSig FieldSig {
			get { return signature as FieldSig; }
			set { signature = value; }
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get { return module; }
		}

		/// <summary>
		/// <c>true</c> if the method has a hidden 'this' parameter
		/// </summary>
		public bool HasThis {
			get {
				var ms = MethodSig;
				return ms == null ? false : ms.HasThis;
			}
		}

		/// <summary>
		/// <c>true</c> if the method has an explicit 'this' parameter
		/// </summary>
		public bool ExplicitThis {
			get {
				var ms = MethodSig;
				return ms == null ? false : ms.ExplicitThis;
			}
		}

		/// <summary>
		/// Gets the calling convention
		/// </summary>
		public CallingConvention CallingConvention {
			get {
				var ms = MethodSig;
				return ms == null ? 0 : ms.CallingConvention & CallingConvention.Mask;
			}
		}

		/// <summary>
		/// Gets/sets the method return type
		/// </summary>
		public TypeSig ReturnType {
			get {
				var ms = MethodSig;
				return ms == null ? null : ms.RetType;
			}
			set {
				var ms = MethodSig;
				if (ms != null)
					ms.RetType = value;
			}
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get {
				var sig = MethodSig;
				return sig == null ? 0 : (int)sig.GenParamCount;
			}
		}

		/// <summary>
		/// Gets the full name
		/// </summary>
		public string FullName {
			get {
				var parent = @class;
				IList<TypeSig> typeGenArgs = null;
				if (parent is TypeSpec) {
					var sig = ((TypeSpec)parent).TypeSig as GenericInstSig;
					if (sig != null)
						typeGenArgs = sig.GenericArguments;
				}
				var methodSig = MethodSig;
				if (methodSig != null)
					return FullNameCreator.MethodFullName(GetDeclaringTypeFullName(parent), name, methodSig, typeGenArgs, null, null, null);
				var fieldSig = FieldSig;
				if (fieldSig != null)
					return FullNameCreator.FieldFullName(GetDeclaringTypeFullName(parent), name, fieldSig, typeGenArgs, null);
				return string.Empty;
			}
		}

		/// <summary>
		/// Get the declaring type's full name
		/// </summary>
		/// <returns>Full name or <c>null</c> if there's no declaring type</returns>
		public string GetDeclaringTypeFullName() {
			return GetDeclaringTypeFullName(@class);
		}

		string GetDeclaringTypeFullName(IMemberRefParent parent) {
			if (parent == null)
				return null;
			if (parent is ITypeDefOrRef)
				return ((ITypeDefOrRef)parent).FullName;
			if (parent is ModuleRef)
				return string.Format("[module:{0}]<Module>", ((ModuleRef)parent).ToString());
			if (parent is MethodDef) {
				var declaringType = ((MethodDef)parent).DeclaringType;
				return declaringType == null ? null : declaringType.FullName;
			}
			return null;	// Should never be reached
		}

		/// <summary>
		/// Resolves the method/field
		/// </summary>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance or <c>null</c>
		/// if it couldn't be resolved.</returns>
		public IMemberForwarded Resolve() {
			if (module == null)
				return null;
			return module.Context.Resolver.Resolve(this);
		}

		/// <summary>
		/// Resolves the method/field
		/// </summary>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance</returns>
		/// <exception cref="MemberRefResolveException">If the method/field couldn't be resolved</exception>
		public IMemberForwarded ResolveThrow() {
			var memberDef = Resolve();
			if (memberDef != null)
				return memberDef;
			throw new MemberRefResolveException(string.Format("Could not resolve method/field: {0} ({1})", this, this.GetDefinitionAssembly()));
		}

		/// <summary>
		/// Resolves the field
		/// </summary>
		/// <returns>A <see cref="FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		public FieldDef ResolveField() {
			return Resolve() as FieldDef;
		}

		/// <summary>
		/// Resolves the field
		/// </summary>
		/// <returns>A <see cref="FieldDef"/> instance</returns>
		/// <exception cref="MemberRefResolveException">If the field couldn't be resolved</exception>
		public FieldDef ResolveFieldThrow() {
			var field = ResolveField();
			if (field != null)
				return field;
			throw new MemberRefResolveException(string.Format("Could not resolve field: {0} ({1})", this, this.GetDefinitionAssembly()));
		}

		/// <summary>
		/// Resolves the method
		/// </summary>
		/// <returns>A <see cref="MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		public MethodDef ResolveMethod() {
			return Resolve() as MethodDef;
		}

		/// <summary>
		/// Resolves the method
		/// </summary>
		/// <returns>A <see cref="MethodDef"/> instance</returns>
		/// <exception cref="MemberRefResolveException">If the method couldn't be resolved</exception>
		public MethodDef ResolveMethodThrow() {
			var method = ResolveMethod();
			if (method != null)
				return method;
			throw new MemberRefResolveException(string.Format("Could not resolve method: {0} ({1})", this, this.GetDefinitionAssembly()));
		}

		bool IContainsGenericParameter.ContainsGenericParameter {
			get { return TypeHelper.ContainsGenericParameter(this); }
		}

		/// <summary>
		/// Gets a <see cref="GenericParamContext"/> that can be used as signature context
		/// </summary>
		/// <param name="gpContext">Context passed to the constructor</param>
		/// <param name="class">Field/method class owner</param>
		/// <returns></returns>
		protected static GenericParamContext GetSignatureGenericParamContext(GenericParamContext gpContext, IMemberRefParent @class) {
			TypeDef type = null;
			MethodDef method = gpContext.Method;

			var ts = @class as TypeSpec;
			if (ts != null) {
				var gis = ts.TypeSig as GenericInstSig;
				if (gis != null)
					type = gis.GenericType.ToTypeDefOrRef().ResolveTypeDef();
			}

			return new GenericParamContext(type, method);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A MemberRef row created by the user and not present in the original .NET file
	/// </summary>
	public class MemberRefUser : MemberRef {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		public MemberRefUser(ModuleDef module) {
			this.module = module;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of ref</param>
		public MemberRefUser(ModuleDef module, UTF8String name) {
			this.module = module;
			this.name = name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of field ref</param>
		/// <param name="sig">Field sig</param>
		public MemberRefUser(ModuleDef module, UTF8String name, FieldSig sig)
			: this(module, name, sig, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of field ref</param>
		/// <param name="sig">Field sig</param>
		/// <param name="class">Owner of field</param>
		public MemberRefUser(ModuleDef module, UTF8String name, FieldSig sig, IMemberRefParent @class) {
			this.module = module;
			this.name = name;
			this.@class = @class;
			this.signature = sig;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of method ref</param>
		/// <param name="sig">Method sig</param>
		public MemberRefUser(ModuleDef module, UTF8String name, MethodSig sig)
			: this(module, name, sig, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of method ref</param>
		/// <param name="sig">Method sig</param>
		/// <param name="class">Owner of method</param>
		public MemberRefUser(ModuleDef module, UTF8String name, MethodSig sig, IMemberRefParent @class) {
			this.module = module;
			this.name = name;
			this.@class = @class;
			this.signature = sig;
		}
	}

	/// <summary>
	/// Created from a row in the MemberRef table
	/// </summary>
	sealed class MemberRefMD : MemberRef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.MemberRef, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>MemberRef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public MemberRefMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.MemberRefTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("MemberRef rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			this.module = readerModule;
			uint @class, name;
			uint signature = readerModule.TablesStream.ReadMemberRefRow(origRid, out @class, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.@class = readerModule.ResolveMemberRefParent(@class, gpContext);
			this.signature = readerModule.ReadSignature(signature, GetSignatureGenericParamContext(gpContext, this.@class));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MethodAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Method attributes, see CorHdr.h/CorMethodAttr
	/// </summary>
	[Flags]
	public enum MethodAttributes : ushort {
		/// <summary>member access mask - Use this mask to retrieve accessibility information.</summary>
		MemberAccessMask	= 0x0007,
		/// <summary>Member not referenceable.</summary>
		PrivateScope		= 0x0000,
		/// <summary>Member not referenceable.</summary>
		CompilerControlled	= PrivateScope,
		/// <summary>Accessible only by the parent type.</summary>
		Private				= 0x0001,
		/// <summary>Accessible by sub-types only in this Assembly.</summary>
		FamANDAssem			= 0x0002,
		/// <summary>Accessibly by anyone in the Assembly.</summary>
		Assembly			= 0x0003,
		/// <summary>Accessible only by type and sub-types.</summary>
		Family				= 0x0004,
		/// <summary>Accessibly by sub-types anywhere, plus anyone in assembly.</summary>
		FamORAssem			= 0x0005,
		/// <summary>Accessibly by anyone who has visibility to this scope.</summary>
		Public				= 0x0006,

		/// <summary>Defined on type, else per instance.</summary>
		Static				= 0x0010,
		/// <summary>Method may not be overridden.</summary>
		Final				= 0x0020,
		/// <summary>Method virtual.</summary>
		Virtual				= 0x0040,
		/// <summary>Method hides by name+sig, else just by name.</summary>
		HideBySig			= 0x0080,

		/// <summary>vtable layout mask - Use this mask to retrieve vtable attributes.</summary>
		VtableLayoutMask	= 0x0100,
		/// <summary>The default.</summary>
		ReuseSlot			= 0x0000,
		/// <summary>Method always gets a new slot in the vtable.</summary>
		NewSlot				= 0x0100,

		/// <summary>Overridability is the same as the visibility.</summary>
		CheckAccessOnOverride = 0x0200,
		/// <summary>Method does not provide an implementation.</summary>
		Abstract			= 0x0400,
		/// <summary>Method is special.  Name describes how.</summary>
		SpecialName			= 0x0800,

		/// <summary>Implementation is forwarded through pinvoke.</summary>
		PinvokeImpl			= 0x2000,
		/// <summary>Implementation is forwarded through pinvoke.</summary>
		PInvokeImpl			= PinvokeImpl,
		/// <summary>Managed method exported via thunk to unmanaged code.</summary>
		UnmanagedExport		= 0x0008,

		/// <summary>Runtime should check name encoding.</summary>
		RTSpecialName		= 0x1000,
		/// <summary>Method has security associate with it.</summary>
		HasSecurity			= 0x4000,
		/// <summary>Method calls another method containing security code.</summary>
		RequireSecObject	= 0x8000,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MethodDef.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Threading;
using dnlib.Utils;
using dnlib.PE;
using dnlib.DotNet.MD;
using dnlib.DotNet.Emit;
using dnlib.Threading;
using dnlib.DotNet.Pdb;
using System.Diagnostics;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Method table
	/// </summary>
	public abstract class MethodDef : IHasCustomAttribute, IHasDeclSecurity, IMemberRefParent, IMethodDefOrRef, IMemberForwarded, ICustomAttributeType, ITypeOrMethodDef, IManagedEntryPoint, IHasCustomDebugInformation, IListListener<GenericParam>, IListListener<ParamDef>, IMemberDef {
		internal static readonly UTF8String StaticConstructorName = ".cctor";
		internal static readonly UTF8String InstanceConstructorName = ".ctor";

		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// All parameters
		/// </summary>
		protected ParameterList parameterList;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.Method, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		public int HasDeclSecurityTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public int MemberRefParentTag {
			get { return 3; }
		}

		/// <inheritdoc/>
		public int MethodDefOrRefTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		public int MemberForwardedTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public int CustomAttributeTypeTag {
			get { return 2; }
		}

		/// <inheritdoc/>
		public int TypeOrMethodDefTag {
			get { return 1; }
		}

		/// <summary>
		/// From column Method.RVA
		/// </summary>
		public RVA RVA {
			get { return rva; }
			set { rva = value; }
		}
		/// <summary/>
		protected RVA rva;

		/// <summary>
		/// From column Method.ImplFlags
		/// </summary>
		public MethodImplAttributes ImplAttributes {
			get { return (MethodImplAttributes)implAttributes; }
			set { implAttributes = (int)value; }
		}
		/// <summary>Implementation attributes</summary>
		protected int implAttributes;

		/// <summary>
		/// From column Method.Flags
		/// </summary>
		public MethodAttributes Attributes {
			get { return (MethodAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Method.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Method.Signature
		/// </summary>
		public CallingConventionSig Signature {
			get { return signature; }
			set { signature = value; }
		}
		/// <summary/>
		protected CallingConventionSig signature;

		/// <summary>
		/// From column Method.ParamList
		/// </summary>
		public ThreadSafe.IList<ParamDef> ParamDefs {
			get {
				if (paramDefs == null)
					InitializeParamDefs();
				return paramDefs;
			}
		}
		/// <summary/>
		protected LazyList<ParamDef> paramDefs;
		/// <summary>Initializes <see cref="paramDefs"/></summary>
		protected virtual void InitializeParamDefs() {
			Interlocked.CompareExchange(ref paramDefs, new LazyList<ParamDef>(this), null);
		}

		/// <inheritdoc/>
		public ThreadSafe.IList<GenericParam> GenericParameters {
			get {
				if (genericParameters == null)
					InitializeGenericParameters();
				return genericParameters;
			}
		}
		/// <summary/>
		protected LazyList<GenericParam> genericParameters;
		/// <summary>Initializes <see cref="genericParameters"/></summary>
		protected virtual void InitializeGenericParameters() {
			Interlocked.CompareExchange(ref genericParameters, new LazyList<GenericParam>(this), null);
		}

		/// <inheritdoc/>
		public ThreadSafe.IList<DeclSecurity> DeclSecurities {
			get {
				if (declSecurities == null)
					InitializeDeclSecurities();
				return declSecurities;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<DeclSecurity> declSecurities;
		/// <summary>Initializes <see cref="declSecurities"/></summary>
		protected virtual void InitializeDeclSecurities() {
			Interlocked.CompareExchange(ref declSecurities, ThreadSafeListCreator.Create<DeclSecurity>(), null);
		}

		/// <inheritdoc/>
		public ImplMap ImplMap {
			get {
				if (!implMap_isInitialized)
					InitializeImplMap();
				return implMap;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				implMap = value;
				implMap_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ImplMap implMap;
		/// <summary/>
		protected bool implMap_isInitialized;

		void InitializeImplMap() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (implMap_isInitialized)
				return;
			implMap = GetImplMap_NoLock();
			implMap_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="implMap"/></summary>
		protected virtual ImplMap GetImplMap_NoLock() {
			return null;
		}

		/// <summary>Reset <see cref="ImplMap"/></summary>
		protected void ResetImplMap() {
			implMap_isInitialized = false;
		}

		/// <summary>
		/// Gets/sets the method body. See also <see cref="Body"/>
		/// </summary>
		public MethodBody MethodBody {
			get {
				if (!methodBody_isInitialized)
					InitializeMethodBody();
				return methodBody;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				methodBody = value;
				methodBody_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected MethodBody methodBody;
		/// <summary/>
		protected bool methodBody_isInitialized;

		void InitializeMethodBody() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (methodBody_isInitialized)
				return;
			methodBody = GetMethodBody_NoLock();
			methodBody_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Frees the method body if it has been loaded. This does nothing if <see cref="CanFreeMethodBody"/>
		/// returns <c>false</c>.
		/// </summary>
		public void FreeMethodBody() {
			if (!CanFreeMethodBody)
				return;
			if (!methodBody_isInitialized)
				return;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			methodBody = null;
			methodBody_isInitialized = false;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="methodBody"/></summary>
		protected virtual MethodBody GetMethodBody_NoLock() {
			return null;
		}

		/// <summary>
		/// true if <see cref="FreeMethodBody()"/> can free the method body
		/// </summary>
		protected virtual bool CanFreeMethodBody {
			get { return true; }
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// Gets the methods this method implements
		/// </summary>
		public ThreadSafe.IList<MethodOverride> Overrides {
			get {
				if (overrides == null)
					InitializeOverrides();
				return overrides;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<MethodOverride> overrides;
		/// <summary>Initializes <see cref="overrides"/></summary>
		protected virtual void InitializeOverrides() {
			Interlocked.CompareExchange(ref overrides, ThreadSafeListCreator.Create<MethodOverride>(), null);
		}

		/// <summary>
		/// Gets the export info or null if the method isn't exported to unmanaged code.
		/// </summary>
		public MethodExportInfo ExportInfo {
			get { return exportInfo; }
			set { exportInfo = value; }
		}
		/// <summary/>
		protected MethodExportInfo exportInfo;

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public bool HasDeclSecurities {
			get { return DeclSecurities.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ParamDefs"/> is not empty
		/// </summary>
		public bool HasParamDefs {
			get { return ParamDefs.Count > 0; }
		}

		/// <summary>
		/// Gets/sets the declaring type (owner type)
		/// </summary>
		public TypeDef DeclaringType {
			get { return declaringType2; }
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType != null)
					currentDeclaringType.Methods.Remove(this);	// Will set DeclaringType2 = null
				if (value != null)
					value.Methods.Add(this);	// Will set DeclaringType2 = value
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get { return declaringType2; }
		}

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get { return declaringType2; }
			set { declaringType2 = value; }
		}
		/// <summary/>
		protected TypeDef declaringType2;

		/// <inheritdoc/>
		public ModuleDef Module {
			get {
				var dt = declaringType2;
				return dt == null ? null : dt.Module;
			}
		}

		bool IIsTypeOrMethod.IsType {
			get { return false; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return true; }
		}

		bool IMemberRef.IsField {
			get { return false; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return true; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		/// <summary>
		/// Gets/sets the CIL method body. See also <see cref="FreeMethodBody()"/>
		/// </summary>
		public CilBody Body {
			get {
				if (!methodBody_isInitialized)
					InitializeMethodBody();
				return methodBody as CilBody;
			}
			set { MethodBody = value; }
		}

		/// <summary>
		/// Gets/sets the native method body
		/// </summary>
		public NativeMethodBody NativeBody {
			get {
				if (!methodBody_isInitialized)
					InitializeMethodBody();
				return methodBody as NativeMethodBody;
			}
			set { MethodBody = value; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="GenericParam"/> in <see cref="GenericParameters"/>
		/// </summary>
		public bool HasGenericParameters {
			get { return GenericParameters.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if it has a <see cref="Body"/>
		/// </summary>
		public bool HasBody {
			get { return Body != null; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="MethodOverride"/> in <see cref="Overrides"/>
		/// </summary>
		public bool HasOverrides {
			get { return Overrides.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ImplMap"/> is not <c>null</c>
		/// </summary>
		public bool HasImplMap {
			get { return ImplMap != null; }
		}

		/// <summary>
		/// Gets the full name
		/// </summary>
		public string FullName {
			get {
				var dt = declaringType2;
				return FullNameCreator.MethodFullName(dt == null ? null : dt.FullName, name, MethodSig, null, null, this, null);
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSig"/>
		/// </summary>
		public MethodSig MethodSig {
			get { return signature as MethodSig; }
			set { signature = value; }
		}

		/// <summary>
		/// Gets the parameters
		/// </summary>
		public ParameterList Parameters {
			get { return parameterList; }
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get {
				var sig = MethodSig;
				return sig == null ? 0 : (int)sig.GenParamCount;
			}
		}

		/// <summary>
		/// <c>true</c> if the method has a hidden 'this' parameter
		/// </summary>
		public bool HasThis {
			get {
				var ms = MethodSig;
				return ms == null ? false : ms.HasThis;
			}
		}

		/// <summary>
		/// <c>true</c> if the method has an explicit 'this' parameter
		/// </summary>
		public bool ExplicitThis {
			get {
				var ms = MethodSig;
				return ms == null ? false : ms.ExplicitThis;
			}
		}

		/// <summary>
		/// Gets the calling convention
		/// </summary>
		public CallingConvention CallingConvention {
			get {
				var ms = MethodSig;
				return ms == null ? 0 : ms.CallingConvention & CallingConvention.Mask;
			}
		}

		/// <summary>
		/// Gets/sets the method return type
		/// </summary>
		public TypeSig ReturnType {
			get {
				var ms = MethodSig;
				return ms == null ? null : ms.RetType;
			}
			set {
				var ms = MethodSig;
				if (ms != null)
					ms.RetType = value;
			}
		}

		/// <summary>
		/// <c>true</c> if the method returns a value (i.e., return type is not <see cref="System.Void"/>)
		/// </summary>
		public bool HasReturnType {
			get { return ReturnType.RemovePinnedAndModifiers().GetElementType() != ElementType.Void; }
		}

		/// <summary>
		/// Gets/sets the method semantics attributes. If you remove/add a method to a property or
		/// an event, you must manually update this property or eg. <see cref="IsSetter"/> won't
		/// work as expected.
		/// </summary>
		public MethodSemanticsAttributes SemanticsAttributes {
			get {
				if ((semAttrs & SEMATTRS_INITD) == 0)
					InitializeSemanticsAttributes();
				return (MethodSemanticsAttributes)semAttrs;
			}
			set { semAttrs = (ushort)value | SEMATTRS_INITD; }
		}
		/// <summary>Set when <see cref="semAttrs"/> has been initialized</summary>
		protected internal static int SEMATTRS_INITD = unchecked((int)0x80000000);
		/// <summary/>
		protected internal int semAttrs;
		/// <summary>Initializes <see cref="semAttrs"/></summary>
		protected virtual void InitializeSemanticsAttributes() {
			semAttrs = 0 | SEMATTRS_INITD;
		}

		/// <summary>
		/// Set or clear flags in <see cref="semAttrs"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, MethodSemanticsAttributes flags) {
			if ((semAttrs & SEMATTRS_INITD) == 0)
				InitializeSemanticsAttributes();
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = semAttrs;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref semAttrs, newVal, origVal) != origVal);
#else
			if (set)
				semAttrs |= (int)flags;
			else
				semAttrs &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(MethodAttributes andMask, MethodAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, MethodAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Modify <see cref="implAttributes"/> property: <see cref="implAttributes"/> =
		/// (<see cref="implAttributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyImplAttributes(MethodImplAttributes andMask, MethodImplAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = implAttributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref implAttributes, newVal, origVal) != origVal);
#else
			implAttributes = (implAttributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="implAttributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyImplAttributes(bool set, MethodImplAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = implAttributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref implAttributes, newVal, origVal) != origVal);
#else
			if (set)
				implAttributes |= (int)flags;
			else
				implAttributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the method access
		/// </summary>
		public MethodAttributes Access {
			get { return (MethodAttributes)attributes & MethodAttributes.MemberAccessMask; }
			set { ModifyAttributes(~MethodAttributes.MemberAccessMask, value & MethodAttributes.MemberAccessMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.PrivateScope"/> is set
		/// </summary>
		public bool IsCompilerControlled {
			get { return IsPrivateScope; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.PrivateScope"/> is set
		/// </summary>
		public bool IsPrivateScope {
			get { return ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.Private"/> is set
		/// </summary>
		public bool IsPrivate {
			get { return ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Private; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.FamANDAssem"/> is set
		/// </summary>
		public bool IsFamilyAndAssembly {
			get { return ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.FamANDAssem; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.Assembly"/> is set
		/// </summary>
		public bool IsAssembly {
			get { return ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Assembly; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.Family"/> is set
		/// </summary>
		public bool IsFamily {
			get { return ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Family; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.FamORAssem"/> is set
		/// </summary>
		public bool IsFamilyOrAssembly {
			get { return ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.FamORAssem; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic {
			get { return ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Public; }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.Static"/> bit
		/// </summary>
		public bool IsStatic {
			get { return ((MethodAttributes)attributes & MethodAttributes.Static) != 0; }
			set { ModifyAttributes(value, MethodAttributes.Static); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.Final"/> bit
		/// </summary>
		public bool IsFinal {
			get { return ((MethodAttributes)attributes & MethodAttributes.Final) != 0; }
			set { ModifyAttributes(value, MethodAttributes.Final); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.Virtual"/> bit
		/// </summary>
		public bool IsVirtual {
			get { return ((MethodAttributes)attributes & MethodAttributes.Virtual) != 0; }
			set { ModifyAttributes(value, MethodAttributes.Virtual); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.HideBySig"/> bit
		/// </summary>
		public bool IsHideBySig {
			get { return ((MethodAttributes)attributes & MethodAttributes.HideBySig) != 0; }
			set { ModifyAttributes(value, MethodAttributes.HideBySig); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.NewSlot"/> bit
		/// </summary>
		public bool IsNewSlot {
			get { return ((MethodAttributes)attributes & MethodAttributes.NewSlot) != 0; }
			set { ModifyAttributes(value, MethodAttributes.NewSlot); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.ReuseSlot"/> bit
		/// </summary>
		public bool IsReuseSlot {
			get { return ((MethodAttributes)attributes & MethodAttributes.NewSlot) == 0; }
			set { ModifyAttributes(!value, MethodAttributes.NewSlot); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.CheckAccessOnOverride"/> bit
		/// </summary>
		public bool IsCheckAccessOnOverride {
			get { return ((MethodAttributes)attributes & MethodAttributes.CheckAccessOnOverride) != 0; }
			set { ModifyAttributes(value, MethodAttributes.CheckAccessOnOverride); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.Abstract"/> bit
		/// </summary>
		public bool IsAbstract {
			get { return ((MethodAttributes)attributes & MethodAttributes.Abstract) != 0; }
			set { ModifyAttributes(value, MethodAttributes.Abstract); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get { return ((MethodAttributes)attributes & MethodAttributes.SpecialName) != 0; }
			set { ModifyAttributes(value, MethodAttributes.SpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.PinvokeImpl"/> bit
		/// </summary>
		public bool IsPinvokeImpl {
			get { return ((MethodAttributes)attributes & MethodAttributes.PinvokeImpl) != 0; }
			set { ModifyAttributes(value, MethodAttributes.PinvokeImpl); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.UnmanagedExport"/> bit
		/// </summary>
		public bool IsUnmanagedExport {
			get { return ((MethodAttributes)attributes & MethodAttributes.UnmanagedExport) != 0; }
			set { ModifyAttributes(value, MethodAttributes.UnmanagedExport); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get { return ((MethodAttributes)attributes & MethodAttributes.RTSpecialName) != 0; }
			set { ModifyAttributes(value, MethodAttributes.RTSpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.HasSecurity"/> bit
		/// </summary>
		public bool HasSecurity {
			get { return ((MethodAttributes)attributes & MethodAttributes.HasSecurity) != 0; }
			set { ModifyAttributes(value, MethodAttributes.HasSecurity); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.RequireSecObject"/> bit
		/// </summary>
		public bool IsRequireSecObject {
			get { return ((MethodAttributes)attributes & MethodAttributes.RequireSecObject) != 0; }
			set { ModifyAttributes(value, MethodAttributes.RequireSecObject); }
		}

		/// <summary>
		/// Gets/sets the code type
		/// </summary>
		public MethodImplAttributes CodeType {
			get { return (MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask; }
			set { ModifyImplAttributes(~MethodImplAttributes.CodeTypeMask, value & MethodImplAttributes.CodeTypeMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodImplAttributes.IL"/> is set
		/// </summary>
		public bool IsIL {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.IL; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodImplAttributes.Native"/> is set
		/// </summary>
		public bool IsNative {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.Native; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodImplAttributes.OPTIL"/> is set
		/// </summary>
		public bool IsOPTIL {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.OPTIL; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodImplAttributes.Runtime"/> is set
		/// </summary>
		public bool IsRuntime {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.Runtime; }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.Unmanaged"/> bit
		/// </summary>
		public bool IsUnmanaged {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.Unmanaged) != 0; }
			set { ModifyImplAttributes(value, MethodImplAttributes.Unmanaged); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.Managed"/> bit
		/// </summary>
		public bool IsManaged {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.Unmanaged) == 0; }
			set { ModifyImplAttributes(!value, MethodImplAttributes.Unmanaged); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.ForwardRef"/> bit
		/// </summary>
		public bool IsForwardRef {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.ForwardRef) != 0; }
			set { ModifyImplAttributes(value, MethodImplAttributes.ForwardRef); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.PreserveSig"/> bit
		/// </summary>
		public bool IsPreserveSig {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.PreserveSig) != 0; }
			set { ModifyImplAttributes(value, MethodImplAttributes.PreserveSig); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.InternalCall"/> bit
		/// </summary>
		public bool IsInternalCall {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.InternalCall) != 0; }
			set { ModifyImplAttributes(value, MethodImplAttributes.InternalCall); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.Synchronized"/> bit
		/// </summary>
		public bool IsSynchronized {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.Synchronized) != 0; }
			set { ModifyImplAttributes(value, MethodImplAttributes.Synchronized); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.NoInlining"/> bit
		/// </summary>
		public bool IsNoInlining {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.NoInlining) != 0; }
			set { ModifyImplAttributes(value, MethodImplAttributes.NoInlining); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.AggressiveInlining"/> bit
		/// </summary>
		public bool IsAggressiveInlining {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.AggressiveInlining) != 0; }
			set { ModifyImplAttributes(value, MethodImplAttributes.AggressiveInlining); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.NoOptimization"/> bit
		/// </summary>
		public bool IsNoOptimization {
			get { return ((MethodImplAttributes)implAttributes & MethodImplAttributes.NoOptimization) != 0; }
			set { ModifyImplAttributes(value, MethodImplAttributes.NoOptimization); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.Setter"/> bit
		/// </summary>
		public bool IsSetter {
			get { return (SemanticsAttributes & MethodSemanticsAttributes.Setter) != 0; }
			set { ModifyAttributes(value, MethodSemanticsAttributes.Setter); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.Getter"/> bit
		/// </summary>
		public bool IsGetter {
			get { return (SemanticsAttributes & MethodSemanticsAttributes.Getter) != 0; }
			set { ModifyAttributes(value, MethodSemanticsAttributes.Getter); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.Other"/> bit
		/// </summary>
		public bool IsOther {
			get { return (SemanticsAttributes & MethodSemanticsAttributes.Other) != 0; }
			set { ModifyAttributes(value, MethodSemanticsAttributes.Other); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.AddOn"/> bit
		/// </summary>
		public bool IsAddOn {
			get { return (SemanticsAttributes & MethodSemanticsAttributes.AddOn) != 0; }
			set { ModifyAttributes(value, MethodSemanticsAttributes.AddOn); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.RemoveOn"/> bit
		/// </summary>
		public bool IsRemoveOn {
			get { return (SemanticsAttributes & MethodSemanticsAttributes.RemoveOn) != 0; }
			set { ModifyAttributes(value, MethodSemanticsAttributes.RemoveOn); }
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.Fire"/> bit
		/// </summary>
		public bool IsFire {
			get { return (SemanticsAttributes & MethodSemanticsAttributes.Fire) != 0; }
			set { ModifyAttributes(value, MethodSemanticsAttributes.Fire); }
		}

		/// <summary>
		/// <c>true</c> if this is the static type constructor
		/// </summary>
		public bool IsStaticConstructor {
			get { return IsRuntimeSpecialName && UTF8String.Equals(name, StaticConstructorName); }
		}

		/// <summary>
		/// <c>true</c> if this is an instance constructor
		/// </summary>
		public bool IsInstanceConstructor {
			get { return IsRuntimeSpecialName && UTF8String.Equals(name, InstanceConstructorName); }
		}

		/// <summary>
		/// <c>true</c> if this is a static or an instance constructor
		/// </summary>
		public bool IsConstructor {
			get { return IsStaticConstructor || IsInstanceConstructor; }
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnLazyAdd(int index, ref GenericParam value) {
			OnLazyAdd2(index, ref value);
		}

		internal virtual void OnLazyAdd2(int index, ref GenericParam value) {
#if DEBUG
			if (value.Owner != this)
				throw new InvalidOperationException("Added generic param's Owner != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnAdd(int index, GenericParam value) {
			if (value.Owner != null)
				throw new InvalidOperationException("Generic param is already owned by another type/method. Set Owner to null first.");
			value.Owner = this;
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnRemove(int index, GenericParam value) {
			value.Owner = null;
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnClear() {
			foreach (var gp in GenericParameters.GetEnumerable_NoLock())
				gp.Owner = null;
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnLazyAdd(int index, ref ParamDef value) {
			OnLazyAdd2(index, ref value);
		}

		internal virtual void OnLazyAdd2(int index, ref ParamDef value) {
#if DEBUG
			if (value.DeclaringMethod != this)
				throw new InvalidOperationException("Added param's DeclaringMethod != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnAdd(int index, ParamDef value) {
			if (value.DeclaringMethod != null)
				throw new InvalidOperationException("Param is already owned by another method. Set DeclaringMethod to null first.");
			value.DeclaringMethod = this;
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnRemove(int index, ParamDef value) {
			value.DeclaringMethod = null;
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnClear() {
			foreach (var pd in ParamDefs.GetEnumerable_NoLock())
				pd.DeclaringMethod = null;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A Method row created by the user and not present in the original .NET file
	/// </summary>
	public class MethodDefUser : MethodDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public MethodDefUser() {
			this.paramDefs = new LazyList<ParamDef>(this);
			this.genericParameters = new LazyList<GenericParam>(this);
			this.parameterList = new ParameterList(this, null);
			this.semAttrs = 0 | SEMATTRS_INITD;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		public MethodDefUser(UTF8String name)
			: this(name, null, 0, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="methodSig">Method sig</param>
		public MethodDefUser(UTF8String name, MethodSig methodSig)
			: this(name, methodSig, 0, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="methodSig">Method sig</param>
		/// <param name="flags">Flags</param>
		public MethodDefUser(UTF8String name, MethodSig methodSig, MethodAttributes flags)
			: this(name, methodSig, 0, flags) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="methodSig">Method sig</param>
		/// <param name="implFlags">Impl flags</param>
		public MethodDefUser(UTF8String name, MethodSig methodSig, MethodImplAttributes implFlags)
			: this(name, methodSig, implFlags, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="methodSig">Method sig</param>
		/// <param name="implFlags">Impl flags</param>
		/// <param name="flags">Flags</param>
		public MethodDefUser(UTF8String name, MethodSig methodSig, MethodImplAttributes implFlags, MethodAttributes flags) {
			this.name = name;
			this.signature = methodSig;
			this.paramDefs = new LazyList<ParamDef>(this);
			this.genericParameters = new LazyList<GenericParam>(this);
			this.implAttributes = (int)implFlags;
			this.attributes = (int)flags;
			this.parameterList = new ParameterList(this, null);
			this.semAttrs = 0 | SEMATTRS_INITD;
		}
	}

	/// <summary>
	/// Created from a row in the Method table
	/// </summary>
	sealed class MethodDefMD : MethodDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly RVA origRva;
		readonly MethodImplAttributes origImplAttributes;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeParamDefs() {
			var list = readerModule.MetaData.GetParamRidList(origRid);
			var tmp = new LazyList<ParamDef>((int)list.Length, this, list, (list2, index) => readerModule.ResolveParam(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref paramDefs, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeGenericParameters() {
			var list = readerModule.MetaData.GetGenericParamRidList(Table.Method, origRid);
			var tmp = new LazyList<GenericParam>((int)list.Length, this, list, (list2, index) => readerModule.ResolveGenericParam(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref genericParameters, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeDeclSecurities() {
			var list = readerModule.MetaData.GetDeclSecurityRidList(Table.Method, origRid);
			var tmp = new LazyList<DeclSecurity>((int)list.Length, list, (list2, index) => readerModule.ResolveDeclSecurity(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref declSecurities, tmp, null);
		}

		/// <inheritdoc/>
		protected override ImplMap GetImplMap_NoLock() {
			return readerModule.ResolveImplMap(readerModule.MetaData.GetImplMapRid(Table.Method, origRid));
		}

		/// <inheritdoc/>
		protected override MethodBody GetMethodBody_NoLock() {
			return readerModule.ReadMethodBody(this, origRva, origImplAttributes, new GenericParamContext(declaringType2, this));
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.Method, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			if (Interlocked.CompareExchange(ref customDebugInfos, list, null) == null) {
				var body = Body;
				readerModule.InitializeCustomDebugInfos(this, body, list);
			}
		}

		/// <inheritdoc/>
		protected override void InitializeOverrides() {
			var dt = declaringType2 as TypeDefMD;
			var tmp = dt == null ? ThreadSafeListCreator.Create<MethodOverride>() : dt.GetMethodOverrides(this, new GenericParamContext(declaringType2, this));
			Interlocked.CompareExchange(ref overrides, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeSemanticsAttributes() {
			var dt = DeclaringType as TypeDefMD;
			if (dt != null)
				dt.InitializeMethodSemanticsAttributes();
			semAttrs |= SEMATTRS_INITD;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Method</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public MethodDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.MethodTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("Method rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name;
			uint signature = readerModule.TablesStream.ReadMethodRow(origRid, out this.rva, out this.implAttributes, out this.attributes, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.origRva = rva;
			this.origImplAttributes = (MethodImplAttributes)implAttributes;
			this.declaringType2 = readerModule.GetOwnerType(this);
			this.signature = readerModule.ReadSignature(signature, new GenericParamContext(declaringType2, this));
			this.parameterList = new ParameterList(this, declaringType2);
			this.exportInfo = readerModule.GetExportInfo(rid);
		}

		internal MethodDefMD InitializeAll() {
			MemberMDInitializer.Initialize(RVA);
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(ImplAttributes);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(Signature);
			MemberMDInitializer.Initialize(ImplMap);
			MemberMDInitializer.Initialize(MethodBody);
			MemberMDInitializer.Initialize(DeclaringType);
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(Overrides);
			MemberMDInitializer.Initialize(ParamDefs);
			MemberMDInitializer.Initialize(GenericParameters);
			MemberMDInitializer.Initialize(DeclSecurities);
			return this;
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref GenericParam value) {
			if (value.Owner != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadGenericParam(value.Rid).InitializeAll());
				value.Owner = this;
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref ParamDef value) {
			if (value.DeclaringMethod != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadParam(value.Rid).InitializeAll());
				value.DeclaringMethod = this;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MethodExportInfo.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Diagnostics;

namespace dnlib.DotNet {
	/// <summary>
	/// Contains the name and ordinal of a method that gets exported to unmanaged code.
	/// </summary>
	[DebuggerDisplay("{Ordinal} {Name} {Options}")]
	public sealed class MethodExportInfo {
		MethodExportInfoOptions options;
		ushort? ordinal;
		string name;

		const MethodExportInfoOptions DefaultOptions = MethodExportInfoOptions.FromUnmanaged;

		/// <summary>
		/// Gets the ordinal or null
		/// </summary>
		public ushort? Ordinal {
			get { return ordinal; }
			set { ordinal = value; }
		}

		/// <summary>
		/// Gets the name. If it's null, and <see cref="Ordinal"/> is also null, the name of the method
		/// (<see cref="MethodDef.Name"/>) is used as the exported name.
		/// </summary>
		public string Name {
			get { return name; }
			set { name = value; }
		}

		/// <summary>
		/// Gets the options
		/// </summary>
		public MethodExportInfoOptions Options {
			get { return options; }
			set { options = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public MethodExportInfo() {
			options = DefaultOptions;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name or null to export by ordinal</param>
		public MethodExportInfo(string name) {
			options = DefaultOptions;
			this.name = name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ordinal">Ordinal</param>
		public MethodExportInfo(ushort ordinal) {
			options = DefaultOptions;
			this.ordinal = ordinal;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name or null to export by ordinal</param>
		/// <param name="ordinal">Ordinal or null to export by name</param>
		public MethodExportInfo(string name, ushort? ordinal) {
			options = DefaultOptions;
			this.name = name;
			this.ordinal = ordinal;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name or null to export by ordinal</param>
		/// <param name="ordinal">Ordinal or null to export by name</param>
		/// <param name="options">Options</param>
		public MethodExportInfo(string name, ushort? ordinal, MethodExportInfoOptions options) {
			this.options = options;
			this.name = name;
			this.ordinal = ordinal;
		}
	}

	/// <summary>
	/// Exported method options
	/// </summary>
	public enum MethodExportInfoOptions {
		/// <summary>
		/// No bit is set
		/// </summary>
		None							= 0,

		/// <summary>
		/// Transition from unmanaged code
		/// </summary>
		FromUnmanaged					= 0x00000001,

		/// <summary>
		/// Also retain app domain
		/// </summary>
		FromUnmanagedRetainAppDomain	= 0x00000002,

		/// <summary>
		/// Call most derived method
		/// </summary>
		CallMostDerived					= 0x00000004,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MethodExportInfoProvider.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.PE;
using dnlib.IO;
using System.Diagnostics;
using System.Text;

namespace dnlib.DotNet {
	sealed class MethodExportInfoProvider {
		readonly Dictionary<uint, MethodExportInfo> toInfo;

		public MethodExportInfoProvider(ModuleDefMD module) {
			toInfo = new Dictionary<uint, MethodExportInfo>();
			try {
				Initialize(module);
			}
			catch (OutOfMemoryException) {
			}
			catch (IOException) {
			}
		}

		void Initialize(ModuleDefMD module) {
			var vtblHdr = module.MetaData.ImageCor20Header.VTableFixups;
			if (vtblHdr.VirtualAddress == 0 || vtblHdr.Size == 0)
				return;

			var peImage = module.MetaData.PEImage;
			var exportHdr = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[0];
			if (exportHdr.VirtualAddress == 0 || exportHdr.Size < 0x28)
				return;

			CpuArch cpuArch;
			if (!CpuArch.TryGetCpuArch(peImage.ImageNTHeaders.FileHeader.Machine, out cpuArch)) {
				Debug.Fail(string.Format("Exported methods: Unsupported machine: {0}", peImage.ImageNTHeaders.FileHeader.Machine));
				return;
			}

			using (var reader = peImage.CreateFullStream()) {
				var offsetToInfo = GetOffsetToExportInfoDictionary(reader, peImage, exportHdr, cpuArch);
				reader.Position = (long)peImage.ToFileOffset(vtblHdr.VirtualAddress);
				long endPos = reader.Position + vtblHdr.Size;
				while (reader.Position + 8 <= endPos && reader.CanRead(8)) {
					var tableRva = (RVA)reader.ReadUInt32();
					int numSlots = reader.ReadUInt16();
					var flags = (VTableFlags)reader.ReadUInt16();
					bool is64bit = (flags & VTableFlags._64Bit) != 0;
					var exportOptions = ToMethodExportInfoOptions(flags);

					var pos = reader.Position;
					reader.Position = (long)peImage.ToFileOffset(tableRva);
					int slotSize = is64bit ? 8 : 4;
					while (numSlots-- > 0 && reader.CanRead(slotSize)) {
						var tokenPos = reader.Position;
						MethodExportInfo exportInfo;
						uint token = reader.ReadUInt32();
						bool b = offsetToInfo.TryGetValue(tokenPos, out exportInfo);
						Debug.Assert(token == 0 || b);
						if (b) {
							exportInfo = new MethodExportInfo(exportInfo.Name, exportInfo.Ordinal, exportOptions);
							toInfo[token] = exportInfo;
						}
						if (slotSize == 8)
							reader.ReadUInt32();
					}
					reader.Position = pos;
				}
			}
		}

		static MethodExportInfoOptions ToMethodExportInfoOptions(VTableFlags flags) {
			var res = MethodExportInfoOptions.None;
			if ((flags & VTableFlags.FromUnmanaged) != 0)
				res |= MethodExportInfoOptions.FromUnmanaged;
			if ((flags & VTableFlags.FromUnmanagedRetainAppDomain) != 0)
				res |= MethodExportInfoOptions.FromUnmanagedRetainAppDomain;
			if ((flags & VTableFlags.CallMostDerived) != 0)
				res |= MethodExportInfoOptions.CallMostDerived;
			return res;
		}

		static Dictionary<long, MethodExportInfo> GetOffsetToExportInfoDictionary(IImageStream reader, IPEImage peImage, ImageDataDirectory exportHdr, CpuArch cpuArch) {
			reader.Position = (long)peImage.ToFileOffset(exportHdr.VirtualAddress);
			// Skip Characteristics(4), TimeDateStamp(4), MajorVersion(2), MinorVersion(2), Name(4)
			reader.Position += 16;
			uint ordinalBase = reader.ReadUInt32();
			int numFuncs = reader.ReadInt32();
			int numNames = reader.ReadInt32();
			long offsetOfFuncs = (long)peImage.ToFileOffset((RVA)reader.ReadUInt32());
			long offsetOfNames = (long)peImage.ToFileOffset((RVA)reader.ReadUInt32());
			long offsetOfNameIndexes = (long)peImage.ToFileOffset((RVA)reader.ReadUInt32());

			var names = ReadNames(reader, peImage, numNames, offsetOfNames, offsetOfNameIndexes);
			reader.Position = offsetOfFuncs;
			var allInfos = new MethodExportInfo[numFuncs];
			var dict = new Dictionary<long, MethodExportInfo>(numFuncs);
			for (int i = 0; i < allInfos.Length; i++) {
				var currOffset = reader.Position;
				var nextOffset = reader.Position + 4;
				uint funcRva = 0;
				var rva = (RVA)reader.ReadUInt32();
				reader.Position = (long)peImage.ToFileOffset(rva);
				bool rvaValid = rva != 0 && cpuArch.TryGetExportedRvaFromStub(reader, peImage, out funcRva);
				long funcOffset = rvaValid ? (long)peImage.ToFileOffset((RVA)funcRva) : 0;
				var exportInfo = new MethodExportInfo((ushort)(ordinalBase + (uint)i));
				if (funcOffset != 0)
					dict[funcOffset] = exportInfo;
				allInfos[i] = exportInfo;
				reader.Position = nextOffset;
			}

			foreach (var info in names) {
				int index = info.Index;
				if ((uint)index >= (uint)numFuncs)
					continue;
				allInfos[index].Ordinal = null;
				allInfos[index].Name = info.Name;
			}

			return dict;
		}

		static NameAndIndex[] ReadNames(IImageStream reader, IPEImage peImage, int numNames, long offsetOfNames, long offsetOfNameIndexes) {
			var names = new NameAndIndex[numNames];

			reader.Position = offsetOfNameIndexes;
			for (int i = 0; i < names.Length; i++)
				names[i].Index = reader.ReadUInt16();

			var currentOffset = offsetOfNames;
			for (int i = 0; i < names.Length; i++, currentOffset += 4) {
				reader.Position = currentOffset;
				long offsetOfName = (long)peImage.ToFileOffset((RVA)reader.ReadUInt32());
				names[i].Name = ReadMethodNameASCIIZ(reader, offsetOfName);
			}

			return names;
		}

		struct NameAndIndex {
			public string Name;
			public int Index;
		}

		// If this method gets updated, also update the writer (ManagedExportsWriter)
		static string ReadMethodNameASCIIZ(IImageStream reader, long offset) {
			reader.Position = offset;
			var stringData = reader.ReadBytesUntilByte(0);
			return Encoding.UTF8.GetString(stringData);
		}

		public MethodExportInfo GetMethodExportInfo(uint token) {
			if (toInfo.Count == 0)
				return null;
			MethodExportInfo info;
			if (toInfo.TryGetValue(token, out info))
				return new MethodExportInfo(info.Name, info.Ordinal, info.Options);
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MethodImplAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Method impl attributes, see CorHdr.h/CorMethodImpl
	/// </summary>
	[Flags]
	public enum MethodImplAttributes : ushort {
		/// <summary>Flags about code type.</summary>
		CodeTypeMask		= 0x0003,
		/// <summary>Method impl is IL.</summary>
		IL					= 0x0000,
		/// <summary>Method impl is native.</summary>
		Native				= 0x0001,
		/// <summary>Method impl is OPTIL</summary>
		OPTIL				= 0x0002,
		/// <summary>Method impl is provided by the runtime.</summary>
		Runtime				= 0x0003,

		/// <summary>Flags specifying whether the code is managed or unmanaged.</summary>
		ManagedMask			= 0x0004,
		/// <summary>Method impl is unmanaged, otherwise managed.</summary>
		Unmanaged			= 0x0004,
		/// <summary>Method impl is managed.</summary>
		Managed				= 0x0000,

		/// <summary>Indicates method is defined; used primarily in merge scenarios.</summary>
		ForwardRef			= 0x0010,
		/// <summary>Indicates method sig is not to be mangled to do HRESULT conversion.</summary>
		PreserveSig			= 0x0080,

		/// <summary>Reserved for internal use.</summary>
		InternalCall		= 0x1000,

		/// <summary>Method is single threaded through the body.</summary>
		Synchronized		= 0x0020,
		/// <summary>Method may not be inlined.</summary>
		NoInlining			= 0x0008,
		/// <summary>Method should be inlined if possible.</summary>
		AggressiveInlining	= 0x0100,
		/// <summary>Method may not be optimized.</summary>
		NoOptimization		= 0x0040,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MethodOverride.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Describes which method some method implements
	/// </summary>
	public struct MethodOverride {
		/// <summary>
		/// The method body. Usually a <see cref="MethodDef"/> but could be a <see cref="MemberRef"/>
		/// </summary>
		public IMethodDefOrRef MethodBody;

		/// <summary>
		/// The method <see cref="MethodBody"/> implements
		/// </summary>
		public IMethodDefOrRef MethodDeclaration;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="methodBody">Method body</param>
		/// <param name="methodDeclaration">The method <paramref name="methodBody"/> implements</param>
		public MethodOverride(IMethodDefOrRef methodBody, IMethodDefOrRef methodDeclaration) {
			this.MethodBody = methodBody;
			this.MethodDeclaration = methodDeclaration;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MethodSemanticsAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Method semantics flags, see CorHdr.h/CorMethodSemanticsAttr
	/// </summary>
	[Flags]
	public enum MethodSemanticsAttributes : ushort {
		/// <summary>No bit is set</summary>
		None		= 0,
		/// <summary>Setter for property</summary>
		Setter		= 0x0001,
		/// <summary>Getter for property</summary>
		Getter		= 0x0002,
		/// <summary>other method for property or event</summary>
		Other		= 0x0004,
		/// <summary>AddOn method for event</summary>
		AddOn		= 0x0008,
		/// <summary>RemoveOn method for event</summary>
		RemoveOn	= 0x0010,
		/// <summary>Fire method for event</summary>
		Fire		= 0x0020,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MethodSpec.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the MethodSpec table
	/// </summary>
	public abstract class MethodSpec : IHasCustomAttribute, IHasCustomDebugInformation, IMethod, IContainsGenericParameter {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.MethodSpec, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 21; }
		}

		/// <summary>
		/// From column MethodSpec.Method
		/// </summary>
		public IMethodDefOrRef Method {
			get { return method; }
			set { method = value; }
		}
		/// <summary/>
		protected IMethodDefOrRef method;

		/// <summary>
		/// From column MethodSpec.Instantiation
		/// </summary>
		public CallingConventionSig Instantiation {
			get { return instantiation; }
			set { instantiation = value; }
		}
		/// <summary/>
		protected CallingConventionSig instantiation;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 21; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <inheritdoc/>
		MethodSig IMethod.MethodSig {
			get {
				var m = method;
				return m == null ? null : m.MethodSig;
			}
			set {
				var m = method;
				if (m != null)
					m.MethodSig = value;
			}
		}

		/// <inheritdoc/>
		public UTF8String Name {
			get {
				var m = method;
				return m == null ? UTF8String.Empty : m.Name;
			}
			set {
				var m = method;
				if (m != null)
					m.Name = value;
			}
		}

		/// <inheritdoc/>
		public ITypeDefOrRef DeclaringType {
			get {
				var m = method;
				return m == null ? null : m.DeclaringType;
			}
		}

		/// <summary>
		/// Gets/sets the generic instance method sig
		/// </summary>
		public GenericInstMethodSig GenericInstMethodSig {
			get { return instantiation as GenericInstMethodSig; }
			set { instantiation = value; }
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get {
				var sig = GenericInstMethodSig;
				return sig == null ? 0 : sig.GenericArguments.Count;
			}
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get {
				var m = method;
				return m == null ? null : m.Module;
			}
		}

		/// <summary>
		/// Gets the full name
		/// </summary>
		public string FullName {
			get {
				var gims = GenericInstMethodSig;
				var methodGenArgs = gims == null ? null : gims.GenericArguments;
				var m = method;
				var methodDef = m as MethodDef;
				if (methodDef != null) {
					var declaringType = methodDef.DeclaringType;
					return FullNameCreator.MethodFullName(declaringType == null ? null : declaringType.FullName, methodDef.Name, methodDef.MethodSig, null, methodGenArgs, null, null);
				}

				var memberRef = m as MemberRef;
				if (memberRef != null) {
					var methodSig = memberRef.MethodSig;
					if (methodSig != null) {
						var tsOwner = memberRef.Class as TypeSpec;
						var gis = tsOwner == null ? null : tsOwner.TypeSig as GenericInstSig;
						var typeGenArgs = gis == null ? null : gis.GenericArguments;
						return FullNameCreator.MethodFullName(memberRef.GetDeclaringTypeFullName(), memberRef.Name, methodSig, typeGenArgs, methodGenArgs, null, null);
					}
				}

				return string.Empty;
			}
		}

		bool IIsTypeOrMethod.IsType {
			get { return false; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return true; }
		}

		bool IMemberRef.IsField {
			get { return false; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return true; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		bool IContainsGenericParameter.ContainsGenericParameter {
			get { return TypeHelper.ContainsGenericParameter(this); }
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A MethodSpec row created by the user and not present in the original .NET file
	/// </summary>
	public class MethodSpecUser : MethodSpec {
		/// <summary>
		/// Default constructor
		/// </summary>
		public MethodSpecUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The generic method</param>
		public MethodSpecUser(IMethodDefOrRef method)
			: this(method, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The generic method</param>
		/// <param name="sig">The instantiated method sig</param>
		public MethodSpecUser(IMethodDefOrRef method, GenericInstMethodSig sig) {
			this.method = method;
			this.instantiation = sig;
		}
	}

	/// <summary>
	/// Created from a row in the MethodSpec table
	/// </summary>
	sealed class MethodSpecMD : MethodSpec, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.MethodSpec, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>MethodSpec</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public MethodSpecMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.MethodSpecTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("MethodSpec rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			uint method;
			uint instantiation = readerModule.TablesStream.ReadMethodSpecRow(origRid, out method);
			this.method = readerModule.ResolveMethodDefOrRef(method, gpContext);
			this.instantiation = readerModule.ReadSignature(instantiation, gpContext);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ModuleContext.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Threading;

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// <see cref="ModuleDef"/> context
	/// </summary>
	public class ModuleContext {
		IAssemblyResolver assemblyResolver;
		IResolver resolver;

		/// <summary>
		/// Gets/sets the assembly resolver. This is never <c>null</c>.
		/// </summary>
		public IAssemblyResolver AssemblyResolver {
			get {
				if (assemblyResolver == null)
					Interlocked.CompareExchange(ref assemblyResolver, NullResolver.Instance, null);
				return assemblyResolver;
			}
			set { assemblyResolver = value; }
		}

		/// <summary>
		/// Gets/sets the resolver. This is never <c>null</c>.
		/// </summary>
		public IResolver Resolver {
			get {
				if (resolver == null)
					Interlocked.CompareExchange(ref resolver, NullResolver.Instance, null);
				return resolver;
			}
			set { resolver = value; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleContext() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="assemblyResolver">Assembly resolver or <c>null</c></param>
		public ModuleContext(IAssemblyResolver assemblyResolver)
			: this(assemblyResolver, new Resolver(assemblyResolver)) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="resolver">Type/method/field resolver or <c>null</c></param>
		public ModuleContext(IResolver resolver)
			: this(null, resolver) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="assemblyResolver">Assembly resolver or <c>null</c></param>
		/// <param name="resolver">Type/method/field resolver or <c>null</c></param>
		public ModuleContext(IAssemblyResolver assemblyResolver, IResolver resolver) {
			this.assemblyResolver = assemblyResolver;
			this.resolver = resolver;
			if (resolver == null && assemblyResolver != null)
				this.resolver = new Resolver(assemblyResolver);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ModuleCreationOptions.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.IO;
using dnlib.DotNet.Pdb;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet {
	/// <summary>
	/// <see cref="ModuleDefMD"/> creation options
	/// </summary>
	public sealed class ModuleCreationOptions {
		internal static readonly ModuleCreationOptions Default = new ModuleCreationOptions();

		/// <summary>
		/// Module context
		/// </summary>
		public ModuleContext Context { get; set; }

		/// <summary>
		/// Set this if you want to decide how to create the PDB symbol reader. You don't need to
		/// initialize <see cref="PdbFileOrData"/> or <see cref="TryToLoadPdbFromDisk"/>.
		/// </summary>
		public CreateSymbolReaderDelegate CreateSymbolReader { get; set; }

		/// <summary>
		/// Which PDB reader to use. Default is <see cref="PdbImplType.Default"/>.
		/// </summary>
		public PdbImplType PdbImplementation { get; set; }

		/// <summary>
		/// Set it to A) the path (string) of the PDB file, B) the data (byte[]) of the PDB file or
		/// C) to an <see cref="IImageStream"/> of the PDB data. The <see cref="IImageStream"/> will
		/// be owned by the module. You don't need to initialize <see cref="TryToLoadPdbFromDisk"/>
		/// or <see cref="CreateSymbolReader"/>
		/// </summary>
		public object PdbFileOrData { get; set; }

		/// <summary>
		/// If <c>true</c>, will load the PDB file from disk if present, or an embedded portable PDB file
		/// stored in the PE file. The default value is <c>true</c>.
		/// You don't need to initialize <see cref="CreateSymbolReader"/> or <see cref="PdbFileOrData"/>.
		/// </summary>
		public bool TryToLoadPdbFromDisk { get; set; }

		/// <summary>
		/// corlib assembly reference to use or <c>null</c> if the default one from the opened
		/// module should be used.
		/// </summary>
		public AssemblyRef CorLibAssemblyRef { get; set; }

		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleCreationOptions() {
			this.PdbImplementation = PdbImplType.Default;
			this.TryToLoadPdbFromDisk = true;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="context">Module context</param>
		public ModuleCreationOptions(ModuleContext context) {
			this.Context = context;
			this.PdbImplementation = PdbImplType.Default;
			this.TryToLoadPdbFromDisk = true;
		}
	}

	/// <summary>
	/// Creates a <see cref="SymbolReader"/>
	/// </summary>
	/// <param name="module">Module</param>
	/// <returns>A <see cref="SymbolReader"/> instance for (and now owned by)
	/// <paramref name="module"/> or <c>null</c>.</returns>
	public delegate SymbolReader CreateSymbolReaderDelegate(ModuleDefMD module);
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ModuleDef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Threading;
using dnlib.Utils;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.DotNet.Writer;
using dnlib.PE;
using dnlib.Threading;
using dnlib.W32Resources;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Module table
	/// </summary>
	public abstract class ModuleDef : IHasCustomAttribute, IHasCustomDebugInformation, IResolutionScope, IDisposable, IListListener<TypeDef>, IModule, ITypeDefFinder, IDnlibDef, ITokenResolver, ISignatureReaderHelper {
		/// <summary>Default characteristics</summary>
		protected const Characteristics DefaultCharacteristics = Characteristics.ExecutableImage | Characteristics._32BitMachine;

		/// <summary>Default DLL characteristics</summary>
		protected const DllCharacteristics DefaultDllCharacteristics = DllCharacteristics.TerminalServerAware | DllCharacteristics.NoSeh | DllCharacteristics.NxCompat | DllCharacteristics.DynamicBase;

		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Initialize this in the ctor
		/// </summary>
		protected ICorLibTypes corLibTypes;

		/// <summary>
		/// PDB state
		/// </summary>
		protected PdbState pdbState;

		TypeDefFinder typeDefFinder;

		/// <summary>
		/// Array of last used rid in each table. I.e., next free rid is value + 1
		/// </summary>
		protected readonly int[] lastUsedRids = new int[64];

		/// <summary>Module context</summary>
		protected ModuleContext context;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.Module, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 7; }
		}

		/// <inheritdoc/>
		public int ResolutionScopeTag {
			get { return 0; }
		}

		/// <summary>
		/// Gets/sets a user value. This is never used by dnlib. This property isn't thread safe.
		/// </summary>
		public object Tag {
			get { return tag; }
			set { tag = value; }
		}
		object tag;

		/// <inheritdoc/>
		public ScopeType ScopeType {
			get { return ScopeType.ModuleDef; }
		}

		/// <inheritdoc/>
		public string ScopeName {
			get { return FullName; }
		}

		/// <summary>
		/// Gets/sets Module.Generation column
		/// </summary>
		public ushort Generation {
			get { return generation; }
			set { generation = value; }
		}
		/// <summary/>
		protected ushort generation;

		/// <summary>
		/// Gets/sets Module.Name column
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// Gets/sets Module.Mvid column
		/// </summary>
		public Guid? Mvid {
			get { return mvid; }
			set { mvid = value; }
		}
		/// <summary/>
		protected Guid? mvid;

		/// <summary>
		/// Gets/sets Module.EncId column
		/// </summary>
		public Guid? EncId {
			get { return encId; }
			set { encId = value; }
		}
		/// <summary/>
		protected Guid? encId;

		/// <summary>
		/// Gets/sets Module.EncBaseId column
		/// </summary>
		public Guid? EncBaseId {
			get { return encBaseId; }
			set { encBaseId = value; }
		}
		/// <summary/>
		protected Guid? encBaseId;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 7; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// Gets the module's assembly. To set this value, add this <see cref="ModuleDef"/>
		/// to <see cref="AssemblyDef.Modules"/>.
		/// </summary>
		public AssemblyDef Assembly {
			get { return assembly; }
			internal set { assembly = value; }
		}
		/// <summary/>
		protected AssemblyDef assembly;

		/// <summary>
		/// Gets a list of all non-nested <see cref="TypeDef"/>s. See also <see cref="GetTypes()"/>
		/// </summary>
		public ThreadSafe.IList<TypeDef> Types {
			get {
				if (types == null)
					InitializeTypes();
				return types;
			}
		}
		/// <summary/>
		protected LazyList<TypeDef> types;
		/// <summary>Initializes <see cref="types"/></summary>
		protected virtual void InitializeTypes() {
			Interlocked.CompareExchange(ref types, new LazyList<TypeDef>(this), null);
		}

		/// <summary>
		/// Gets a list of all <see cref="ExportedType"/>s
		/// </summary>
		public ThreadSafe.IList<ExportedType> ExportedTypes {
			get {
				if (exportedTypes == null)
					InitializeExportedTypes();
				return exportedTypes;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<ExportedType> exportedTypes;
		/// <summary>Initializes <see cref="exportedTypes"/></summary>
		protected virtual void InitializeExportedTypes() {
			Interlocked.CompareExchange(ref exportedTypes, ThreadSafeListCreator.Create<ExportedType>(), null);
		}

		/// <summary>
		/// Gets/sets the native entry point. Only one of <see cref="NativeEntryPoint"/> and
		/// <see cref="ManagedEntryPoint"/> can be set. You write to one and the other one gets cleared.
		/// </summary>
		public RVA NativeEntryPoint {
			get {
				if (!nativeAndManagedEntryPoint_initialized)
					InitializeNativeAndManagedEntryPoint();
				return nativeEntryPoint;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				nativeEntryPoint = value;
				managedEntryPoint = null;
				Cor20HeaderFlags |= ComImageFlags.NativeEntryPoint;
				nativeAndManagedEntryPoint_initialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary>
		/// Gets/sets the managed entry point. Only one of <see cref="NativeEntryPoint"/> and
		/// <see cref="ManagedEntryPoint"/> can be set. You write to one and the other one gets cleared.
		/// </summary>
		public IManagedEntryPoint ManagedEntryPoint {
			get {
				if (!nativeAndManagedEntryPoint_initialized)
					InitializeNativeAndManagedEntryPoint();
				return managedEntryPoint;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				nativeEntryPoint = 0;
				managedEntryPoint = value;
				Cor20HeaderFlags &= ~ComImageFlags.NativeEntryPoint;
				nativeAndManagedEntryPoint_initialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected RVA nativeEntryPoint;
		/// <summary/>
		protected IManagedEntryPoint managedEntryPoint;
		/// <summary/>
		protected bool nativeAndManagedEntryPoint_initialized;

		void InitializeNativeAndManagedEntryPoint() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (nativeAndManagedEntryPoint_initialized)
				return;
			nativeEntryPoint = GetNativeEntryPoint_NoLock();
			managedEntryPoint = GetManagedEntryPoint_NoLock();
			nativeAndManagedEntryPoint_initialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}
		/// <summary>Called to initialize <see cref="nativeEntryPoint"/></summary>
		protected virtual RVA GetNativeEntryPoint_NoLock() {
			return 0;
		}
		/// <summary>Called to initialize <see cref="managedEntryPoint"/></summary>
		protected virtual IManagedEntryPoint GetManagedEntryPoint_NoLock() {
			return null;
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <summary>
		/// Gets/sets the entry point method
		/// </summary>
		public MethodDef EntryPoint {
			get { return ManagedEntryPoint as MethodDef; }
			set { ManagedEntryPoint = value; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="NativeEntryPoint"/> is non-zero
		/// </summary>
		public bool IsNativeEntryPointValid {
			get { return NativeEntryPoint != 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ManagedEntryPoint"/> is non-null
		/// </summary>
		public bool IsManagedEntryPointValid {
			get { return ManagedEntryPoint != null; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="EntryPoint"/> is non-null
		/// </summary>
		public bool IsEntryPointValid {
			get { return EntryPoint != null; }
		}

		/// <summary>
		/// Gets a list of all <see cref="Resource"/>s
		/// </summary>
		public ResourceCollection Resources {
			get {
				if (resources == null)
					InitializeResources();
				return resources;
			}
		}
		/// <summary/>
		protected ResourceCollection resources;
		/// <summary>Initializes <see cref="resources"/></summary>
		protected virtual void InitializeResources() {
			Interlocked.CompareExchange(ref resources, new ResourceCollection(), null);
		}

		/// <summary>
		/// Gets/sets the <see cref="VTableFixups"/>. This is <c>null</c> if there are no
		/// vtable fixups.
		/// </summary>
		public VTableFixups VTableFixups {
			get {
				if (!vtableFixups_isInitialized)
					InitializeVTableFixups();
				return vtableFixups;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				vtableFixups = value;
				vtableFixups_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected VTableFixups vtableFixups;
		/// <summary/>
		protected bool vtableFixups_isInitialized;

		void InitializeVTableFixups() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (vtableFixups_isInitialized)
				return;
			vtableFixups = GetVTableFixups_NoLock();
			vtableFixups_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="vtableFixups"/></summary>
		protected virtual VTableFixups GetVTableFixups_NoLock() {
			return null;
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="TypeDef"/> in <see cref="Types"/>
		/// </summary>
		public bool HasTypes {
			get { return Types.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="ExportedType"/> in <see cref="ExportedTypes"/>
		/// </summary>
		public bool HasExportedTypes {
			get { return ExportedTypes.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="Resource"/> in <see cref="Resources"/>
		/// </summary>
		public bool HasResources {
			get { return Resources.Count > 0; }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return UTF8String.ToSystemStringOrEmpty(name); }
		}

		/// <summary>
		/// Gets/sets the path of the module or an empty string if it wasn't loaded from disk
		/// </summary>
		public string Location {
			get { return location; }
			set { location = value; }
		}
		/// <summary/>
		protected string location;

		/// <summary>
		/// Gets the <see cref="ICorLibTypes"/>
		/// </summary>
		public ICorLibTypes CorLibTypes {
			get { return corLibTypes; }
		}

		/// <summary>
		/// Gets the <see cref="TypeDefFinder"/> instance
		/// </summary>
		TypeDefFinder TypeDefFinder {
			get {
				if (typeDefFinder == null)
					Interlocked.CompareExchange(ref typeDefFinder, new TypeDefFinder(Types), null);
				return typeDefFinder;
			}
		}

		/// <summary>
		/// Gets/sets the module context. This is never <c>null</c>.
		/// </summary>
		public ModuleContext Context {
			get {
				if (context == null)
					Interlocked.CompareExchange(ref context, new ModuleContext(), null);
				return context;
			}
			set { context = value ?? new ModuleContext(); }
		}

		/// <summary>
		/// If <c>true</c>, the <see cref="TypeDef"/> cache is enabled. The cache is used by
		/// <see cref="Find(string,bool)"/> and <see cref="Find(TypeRef)"/> to find types.
		/// <br/><br/>
		/// <c>IMPORTANT:</c> Only enable the cache if this module's types keep their exact
		/// name, namespace, and declaring type and if <c>no</c> type is either added or
		/// removed from <see cref="Types"/> or from any type that is reachable from the
		/// top-level types in <see cref="Types"/> (i.e., any type owned by this module).
		/// This is disabled by default. When disabled, all calls to <see cref="Find(string,bool)"/>
		/// and <see cref="Find(TypeRef)"/> will result in a slow <c>O(n)</c> (linear) search.
		/// </summary>
		/// <seealso cref="ResetTypeDefFindCache()"/>
		public bool EnableTypeDefFindCache {
			get { return TypeDefFinder.IsCacheEnabled; }
			set { TypeDefFinder.IsCacheEnabled = value; }
		}

		/// <summary>
		/// <c>true</c> if this is the manifest (main) module
		/// </summary>
		public bool IsManifestModule {
			get {
				var asm = assembly;
				return asm != null && asm.ManifestModule == this;
			}
		}

		/// <summary>
		/// Gets the global (aka. &lt;Module&gt;) type or <c>null</c> if there are no types
		/// </summary>
		public TypeDef GlobalType {
			get { return Types.Get(0, null); }
		}

		/// <summary>
		/// true if it's the core library module, false if it's not the core library module,
		/// and null if it's not known.
		/// </summary>
		public bool? IsCoreLibraryModule { get; set; }

		/// <summary>
		/// Gets/sets the Win32 resources
		/// </summary>
		public Win32Resources Win32Resources {
			get {
				if (!win32Resources_isInitialized)
					InitializeWin32Resources();
				return win32Resources;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				win32Resources = value;
				win32Resources_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Win32Resources win32Resources;
		/// <summary/>
		protected bool win32Resources_isInitialized;

		void InitializeWin32Resources() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (win32Resources_isInitialized)
				return;
			win32Resources = GetWin32Resources_NoLock();
			win32Resources_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="win32Resources"/></summary>
		protected virtual Win32Resources GetWin32Resources_NoLock() {
			return null;
		}

		/// <summary>
		/// Gets the <see cref="dnlib.DotNet.Pdb.PdbState"/>. This is <c>null</c> if no PDB file
		/// has been loaded or if no PDB file could be found.
		/// </summary>
		public PdbState PdbState {
			get { return pdbState; }
		}

		/// <summary>
		/// Module kind
		/// </summary>
		public ModuleKind Kind { get; set; }

		/// <summary>
		/// Gets/sets the characteristics (from PE file header)
		/// </summary>
		public Characteristics Characteristics { get; set; }

		/// <summary>
		/// Gets/sets the DLL characteristics (from PE optional header)
		/// </summary>
		public DllCharacteristics DllCharacteristics { get; set; }

		/// <summary>
		/// Gets/sets the runtime version which is stored in the MetaData header.
		/// See <see cref="MDHeaderRuntimeVersion"/>.
		/// </summary>
		/// <remarks>Not thread safe</remarks>
		public string RuntimeVersion {
			get { return runtimeVersion; }
			set {
				if (runtimeVersion != value) {
					runtimeVersion = value;
					cachedWinMDStatus = null;
					runtimeVersionWinMD = null;
					winMDVersion = null;
				}
			}
		}
		string runtimeVersion;

		/// <summary>
		/// Gets the WinMD status
		/// </summary>
		/// <remarks>Not thread safe</remarks>
		public WinMDStatus WinMDStatus {
			get {
				var cval = cachedWinMDStatus;
				if (cval != null)
					return cval.Value;
				cachedWinMDStatus = cval = CalculateWinMDStatus(RuntimeVersion);
				return cval.Value;
			}
		}
		WinMDStatus? cachedWinMDStatus;

		/// <summary>
		/// <c>true</c> if this is a WinMD file
		/// </summary>
		public bool IsWinMD {
			get { return WinMDStatus != WinMDStatus.None; }
		}

		/// <summary>
		/// <c>true</c> if this is a managed WinMD file
		/// </summary>
		public bool IsManagedWinMD {
			get { return WinMDStatus == WinMDStatus.Managed; }
		}

		/// <summary>
		/// <c>true</c> if this is a pure (non-managed) WinMD file
		/// </summary>
		public bool IsPureWinMD {
			get { return WinMDStatus == WinMDStatus.Pure; }
		}

		/// <summary>
		/// Gets the CLR runtime version of the managed WinMD file or <c>null</c> if none. This is
		/// similar to <see cref="RuntimeVersion"/> for normal non-WinMD files.
		/// </summary>
		/// <remarks>Not thread safe</remarks>
		public string RuntimeVersionWinMD {
			get {
				var rtver = runtimeVersionWinMD;
				if (rtver != null)
					return rtver;
				runtimeVersionWinMD = rtver = CalculateRuntimeVersionWinMD(RuntimeVersion);
				return rtver;
			}
		}
		string runtimeVersionWinMD;

		/// <summary>
		/// Gets the WinMD version or <c>null</c> if none
		/// </summary>
		/// <remarks>Not thread safe</remarks>
		public string WinMDVersion {
			get {
				var ver = winMDVersion;
				if (ver != null)
					return ver;
				winMDVersion = ver = CalculateWinMDVersion(RuntimeVersion);
				return ver;
			}
		}
		string winMDVersion;

		static WinMDStatus CalculateWinMDStatus(string version) {
			if (version == null)
				return WinMDStatus.None;
			if (!version.StartsWith("WindowsRuntime ", StringComparison.Ordinal))
				return WinMDStatus.None;

			return version.IndexOf(';') < 0 ? WinMDStatus.Pure : WinMDStatus.Managed;
		}

		static string CalculateRuntimeVersionWinMD(string version) {
			// Original parser code:
			// CoreCLR file: src/md/winmd/adapter.cpp
			// Func: WinMDAdapter::Create(IMDCommon *pRawMDCommon, /*[out]*/ WinMDAdapter **ppAdapter)
			if (version == null)
				return null;
			if (!version.StartsWith("WindowsRuntime ", StringComparison.Ordinal))
				return null;
			int index = version.IndexOf(';');
			if (index < 0)
				return null;
			var s = version.Substring(index + 1);
			if (s.StartsWith("CLR", StringComparison.OrdinalIgnoreCase))
				s = s.Substring(3);
			s = s.TrimStart(' ');

			return s;
		}

		static string CalculateWinMDVersion(string version) {
			if (version == null)
				return null;
			if (!version.StartsWith("WindowsRuntime ", StringComparison.Ordinal))
				return null;
			int index = version.IndexOf(';');
			if (index < 0)
				return version;
			return version.Substring(0, index);
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.0 string (only the major
		/// and minor version numbers are checked)
		/// </summary>
		public bool IsClr10 {
			get {
				var ver = RuntimeVersion ?? string.Empty;
				return ver.StartsWith(MDHeaderRuntimeVersion.MS_CLR_10_PREFIX) ||
					ver.StartsWith(MDHeaderRuntimeVersion.MS_CLR_10_PREFIX_X86RETAIL) ||
					ver == MDHeaderRuntimeVersion.MS_CLR_10_RETAIL ||
					ver == MDHeaderRuntimeVersion.MS_CLR_10_COMPLUS;
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.0 string
		/// </summary>
		public bool IsClr10Exactly {
			get {
				return RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_10 ||
					RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_10_X86RETAIL ||
					RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_10_RETAIL ||
					RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_10_COMPLUS;
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.1 string (only the major
		/// and minor version numbers are checked)
		/// </summary>
		public bool IsClr11 {
			get { return (RuntimeVersion ?? string.Empty).StartsWith(MDHeaderRuntimeVersion.MS_CLR_11_PREFIX); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.1 string
		/// </summary>
		public bool IsClr11Exactly {
			get { return RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_11; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.0 or v1.1 string (only the
		/// major and minor version numbers are checked)
		/// </summary>
		public bool IsClr1x {
			get { return IsClr10 || IsClr11; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.0 or v1.1 string
		/// </summary>
		public bool IsClr1xExactly {
			get { return IsClr10Exactly || IsClr11Exactly; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v2.0 string (only the major
		/// and minor version numbers are checked)
		/// </summary>
		public bool IsClr20 {
			get { return (RuntimeVersion ?? string.Empty).StartsWith(MDHeaderRuntimeVersion.MS_CLR_20_PREFIX); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v2.0 string
		/// </summary>
		public bool IsClr20Exactly {
			get { return RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_20; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v4.0 string (only the major
		/// and minor version numbers are checked)
		/// </summary>
		public bool IsClr40 {
			get { return (RuntimeVersion ?? string.Empty).StartsWith(MDHeaderRuntimeVersion.MS_CLR_40_PREFIX); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v4.0 string
		/// </summary>
		public bool IsClr40Exactly {
			get { return RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_40; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the ECMA 2002 string
		/// </summary>
		public bool IsEcma2002 {
			get { return RuntimeVersion == MDHeaderRuntimeVersion.ECMA_2002; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the ECMA 2005 string
		/// </summary>
		public bool IsEcma2005 {
			get { return RuntimeVersion == MDHeaderRuntimeVersion.ECMA_2005; }
		}

		/// <summary>
		/// Gets/sets the <see cref="Machine"/> (from PE header)
		/// </summary>
		public Machine Machine { get; set; }

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="dnlib.PE.Machine.I386"/>
		/// </summary>
		public bool IsI386 {
			get { return Machine == Machine.I386; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="dnlib.PE.Machine.IA64"/>
		/// </summary>
		public bool IsIA64 {
			get { return Machine == Machine.IA64; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="dnlib.PE.Machine.AMD64"/>
		/// </summary>
		public bool IsAMD64 {
			get { return Machine == Machine.AMD64; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="dnlib.PE.Machine.ARM64"/>
		/// </summary>
		public bool IsARM64 {
			get { return Machine == Machine.ARM64; }
		}

		/// <summary>
		/// Gets/sets the <see cref="Cor20HeaderFlags"/> (from .NET header)
		/// </summary>
		public ComImageFlags Cor20HeaderFlags {
			get { return (ComImageFlags)cor20HeaderFlags; }
			set { cor20HeaderFlags = (int)value; }
		}
		/// <summary/>
		protected int cor20HeaderFlags;

		/// <summary>
		/// Gets/sets the runtime version number in the COR20 header. The major version is
		/// in the high 16 bits. The minor version is in the low 16 bits. This is normally 2.5
		/// (0x00020005), but if it's .NET 1.x, it should be 2.0 (0x00020000). If this is
		/// <c>null</c>, the default value will be used when saving the module (2.0 if CLR 1.x,
		/// and 2.5 if not CLR 1.x).
		/// </summary>
		public uint? Cor20HeaderRuntimeVersion { get; set; }

		/// <summary>
		/// Gets the tables header version. The major version is in the upper 8 bits and the
		/// minor version is in the lower 8 bits. .NET 1.0/1.1 use version 1.0 (0x0100) and
		/// .NET 2.x and later use version 2.0 (0x0200). 1.0 has no support for generics,
		/// 1.1 has support for generics (GenericParam rows have an extra Kind column),
		/// and 2.0 has support for generics (GenericParam rows have the standard 4 columns).
		/// No other version is supported. If this is <c>null</c>, the default version is
		/// used (1.0 if .NET 1.x, else 2.0).
		/// </summary>
		public ushort? TablesHeaderVersion { get; set; }

		/// <summary>
		/// Set or clear flags in <see cref="cor20HeaderFlags"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyComImageFlags(bool set, ComImageFlags flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = cor20HeaderFlags;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref cor20HeaderFlags, newVal, origVal) != origVal);
#else
			if (set)
				cor20HeaderFlags |= (int)flags;
			else
				cor20HeaderFlags &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags.ILOnly"/> bit
		/// </summary>
		public bool IsILOnly {
			get { return ((ComImageFlags)cor20HeaderFlags & ComImageFlags.ILOnly) != 0; }
			set { ModifyComImageFlags(value, ComImageFlags.ILOnly); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags._32BitRequired"/> bit
		/// </summary>
		public bool Is32BitRequired {
			get { return ((ComImageFlags)cor20HeaderFlags & ComImageFlags._32BitRequired) != 0; }
			set { ModifyComImageFlags(value, ComImageFlags._32BitRequired); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags.StrongNameSigned"/> bit
		/// </summary>
		public bool IsStrongNameSigned {
			get { return ((ComImageFlags)cor20HeaderFlags & ComImageFlags.StrongNameSigned) != 0; }
			set { ModifyComImageFlags(value, ComImageFlags.StrongNameSigned); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags.NativeEntryPoint"/> bit
		/// </summary>
		public bool HasNativeEntryPoint {
			get { return ((ComImageFlags)cor20HeaderFlags & ComImageFlags.NativeEntryPoint) != 0; }
			set { ModifyComImageFlags(value, ComImageFlags.NativeEntryPoint); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags._32BitPreferred"/> bit
		/// </summary>
		public bool Is32BitPreferred {
			get { return ((ComImageFlags)cor20HeaderFlags & ComImageFlags._32BitPreferred) != 0; }
			set { ModifyComImageFlags(value, ComImageFlags._32BitPreferred); }
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			foreach (var resource in Resources.GetInitializedElements(true)) {
				if (resource != null)
					resource.Dispose();
			}
			var tdf = typeDefFinder;
			if (tdf != null) {
				tdf.Dispose();
				typeDefFinder = null;
			}
			var ps = pdbState;
			if (ps != null)
				ps.Dispose();
			pdbState = null;
		}

		/// <summary>
		/// Gets all the types (including nested types) present in this module
		/// </summary>
		public IEnumerable<TypeDef> GetTypes() {
			return AllTypesHelper.Types(Types);
		}

		/// <summary>
		/// Adds <paramref name="typeDef"/> as a non-nested type. If it's already nested, its
		/// <see cref="TypeDef.DeclaringType"/> will be set to <c>null</c>.
		/// </summary>
		/// <param name="typeDef">The <see cref="TypeDef"/> to insert</param>
		public void AddAsNonNestedType(TypeDef typeDef) {
			if (typeDef == null)
				return;
			typeDef.DeclaringType = null;
			Types.Add(typeDef);
		}

		/// <summary>
		/// Updates the <c>rid</c> to the next free <c>rid</c> available. It's only updated if
		/// the original <c>rid</c> is 0.
		/// </summary>
		/// <typeparam name="T">IMDTokenProvider</typeparam>
		/// <param name="tableRow">The row that should be updated</param>
		/// <returns>Returns the input</returns>
		public T UpdateRowId<T>(T tableRow) where T : IMDTokenProvider {
			if (tableRow != null && tableRow.Rid == 0)
				tableRow.Rid = GetNextFreeRid(tableRow.MDToken.Table);
			return tableRow;
		}

		/// <summary>
		/// Updates the <c>rid</c> to the next free <c>rid</c> available.
		/// </summary>
		/// <typeparam name="T">IMDTokenProvider</typeparam>
		/// <param name="tableRow">The row that should be updated</param>
		/// <returns>Returns the input</returns>
		public T ForceUpdateRowId<T>(T tableRow) where T : IMDTokenProvider {
			if (tableRow != null)
				tableRow.Rid = GetNextFreeRid(tableRow.MDToken.Table);
			return tableRow;
		}

		uint GetNextFreeRid(Table table) {
			var lastUsedRids = this.lastUsedRids;
			if ((uint)table >= lastUsedRids.Length)
				return 0;
			return (uint)Interlocked.Increment(ref lastUsedRids[(int)table]) & 0x00FFFFFF;
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public ITypeDefOrRef Import(Type type) {
			return new Importer(this).Import(type);
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public TypeSig ImportAsTypeSig(Type type) {
			return new Importer(this).ImportAsTypeSig(type);
		}

		/// <summary>
		/// Imports a <see cref="FieldInfo"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="fieldInfo">The field</param>
		/// <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
		/// or if we failed to import the field</returns>
		public MemberRef Import(FieldInfo fieldInfo) {
			return (MemberRef)new Importer(this).Import(fieldInfo);
		}

		/// <summary>
		/// Imports a <see cref="MethodBase"/> as a <see cref="IMethod"/>. This will be either
		/// a <see cref="MemberRef"/> or a <see cref="MethodSpec"/>.
		/// </summary>
		/// <param name="methodBase">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
		/// or if we failed to import the method</returns>
		public IMethod Import(MethodBase methodBase) {
			return new Importer(this).Import(methodBase);
		}

		/// <summary>
		/// Imports a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public IType Import(IType type) {
			return new Importer(this).Import(type);
		}

		/// <summary>
		/// Imports a <see cref="TypeDef"/> as a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeRef Import(TypeDef type) {
			return (TypeRef)new Importer(this).Import(type);
		}

		/// <summary>
		/// Imports a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeRef Import(TypeRef type) {
			return (TypeRef)new Importer(this).Import(type);
		}

		/// <summary>
		/// Imports a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeSpec Import(TypeSpec type) {
			return new Importer(this).Import(type);
		}

		/// <summary>
		/// Imports a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeSig Import(TypeSig type) {
			return new Importer(this).Import(type);
		}

		/// <summary>
		/// Imports a <see cref="IField"/>
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
		public MemberRef Import(IField field) {
			return (MemberRef)new Importer(this).Import(field);
		}

		/// <summary>
		/// Imports a <see cref="FieldDef"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
		public MemberRef Import(FieldDef field) {
			return (MemberRef)new Importer(this).Import(field);
		}

		/// <summary>
		/// Imports a <see cref="IMethod"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public IMethod Import(IMethod method) {
			return new Importer(this).Import(method);
		}

		/// <summary>
		/// Imports a <see cref="MethodDef"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public MemberRef Import(MethodDef method) {
			return (MemberRef)new Importer(this).Import(method);
		}

		/// <summary>
		/// Imports a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public MethodSpec Import(MethodSpec method) {
			return new Importer(this).Import(method);
		}

		/// <summary>
		/// Imports a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="memberRef">The member ref</param>
		/// <returns>The imported member ref or <c>null</c> if <paramref name="memberRef"/> is invalid</returns>
		public MemberRef Import(MemberRef memberRef) {
			return new Importer(this).Import(memberRef);
		}

		/// <summary>
		/// Writes the module to a file on disk. If the file exists, it will be overwritten.
		/// </summary>
		/// <param name="filename">Filename</param>
		public void Write(string filename) {
			Write(filename, null);
		}

		/// <summary>
		/// Writes the module to a file on disk. If the file exists, it will be overwritten.
		/// </summary>
		/// <param name="filename">Filename</param>
		/// <param name="options">Writer options</param>
		public void Write(string filename, ModuleWriterOptions options) {
			var writer = new ModuleWriter(this, options ?? new ModuleWriterOptions(this));
			writer.Write(filename);
		}

		/// <summary>
		/// Writes the module to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		public void Write(Stream dest) {
			Write(dest, null);
		}

		/// <summary>
		/// Writes the module to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		/// <param name="options">Writer options</param>
		public void Write(Stream dest, ModuleWriterOptions options) {
			var writer = new ModuleWriter(this, options ?? new ModuleWriterOptions(this));
			writer.Write(dest);
		}

		/// <summary>
		/// Resets the <see cref="TypeDef"/> cache which can be enabled by setting
		/// <see cref="EnableTypeDefFindCache"/> to <c>true</c>. Use this method if the cache is
		/// enabled but some of the types have been modified (eg. removed, added, renamed).
		/// </summary>
		public void ResetTypeDefFindCache() {
			TypeDefFinder.ResetCache();
		}

		/// <summary>
		/// Finds a <see cref="ResourceData"/>
		/// </summary>
		/// <param name="type">Type</param>
		/// <param name="name">Name</param>
		/// <param name="langId">Language ID</param>
		/// <returns>The <see cref="ResourceData"/> or <c>null</c> if none found</returns>
		public ResourceData FindWin32ResourceData(ResourceName type, ResourceName name, ResourceName langId) {
			var w32Resources = Win32Resources;
			return w32Resources == null ? null : w32Resources.Find(type, name, langId);
		}

		/// <summary>
		/// Creates a new <see cref="dnlib.DotNet.Pdb.PdbState"/>
		/// </summary>
		/// <param name="pdbFileKind">PDB file kind</param>
		public void CreatePdbState(PdbFileKind pdbFileKind) {
			SetPdbState(new PdbState(this, pdbFileKind));
		}

		/// <summary>
		/// Sets a <see cref="dnlib.DotNet.Pdb.PdbState"/>
		/// </summary>
		/// <param name="pdbState">New <see cref="dnlib.DotNet.Pdb.PdbState"/></param>
		public void SetPdbState(PdbState pdbState) {
			if (pdbState == null)
				throw new ArgumentNullException("pdbState");
			var orig = Interlocked.CompareExchange(ref this.pdbState, pdbState, null);
			if (orig != null)
				throw new InvalidOperationException("PDB file has already been initialized");
		}

		uint GetCor20RuntimeVersion() {
			var rtVer = Cor20HeaderRuntimeVersion;
			if (rtVer != null)
				return rtVer.Value;
			return IsClr1x ? 0x00020000U : 0x00020005;
		}

		/// <summary>
		/// Returns the size of a pointer. Assumes it's 32-bit if pointer size is unknown or
		/// if it can be 32-bit or 64-bit.
		/// </summary>
		/// <returns>Size of a pointer (4 or 8)</returns>
		public int GetPointerSize() {
			return GetPointerSize(4);
		}

		/// <summary>
		/// Returns the size of a pointer
		/// </summary>
		/// <param name="defaultPointerSize">Default pointer size if it's not known or if it
		/// can be 32-bit or 64-bit</param>
		/// <returns>Size of a pointer (4 or 8)</returns>
		public int GetPointerSize(int defaultPointerSize) {
			return GetPointerSize(defaultPointerSize, defaultPointerSize);
		}

		/// <summary>
		/// Returns the size of a pointer
		/// </summary>
		/// <param name="defaultPointerSize">Default pointer size</param>
		/// <param name="prefer32bitPointerSize">Pointer size if it's prefer-32-bit (should usually be 4)</param>
		/// <returns></returns>
		public int GetPointerSize(int defaultPointerSize, int prefer32bitPointerSize) {
			var machine = Machine;
			if (machine == Machine.AMD64 || machine == Machine.IA64 || machine == Machine.ARM64)
				return 8;
			if (machine != Machine.I386)
				return 4;

			// Machine is I386 so it's either x86 or platform neutral

			// If the runtime version is < 2.5, then it's always loaded as a 32-bit process.
			if (GetCor20RuntimeVersion() < 0x00020005)
				return 4;

			// If it's a 32-bit PE header, and ILOnly is cleared, it's always loaded as a
			// 32-bit process.
			var flags = (ComImageFlags)cor20HeaderFlags;
			if ((flags & ComImageFlags.ILOnly) == 0)
				return 4;

			// 32-bit Preferred flag is new in .NET 4.5. See CorHdr.h in Windows SDK for more info
			switch (flags & (ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred)) {
			case 0:
				// Machine and ILOnly flag should be checked
				break;

			case ComImageFlags._32BitPreferred:
				// Illegal
				break;

			case ComImageFlags._32BitRequired:
				// x86 image (32-bit process)
				return 4;

			case ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred:
				// Platform neutral but prefers to be 32-bit
				return prefer32bitPointerSize;
			}

			return defaultPointerSize;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnLazyAdd(int index, ref TypeDef value) {
#if DEBUG
			if (value.DeclaringType != null)
				throw new InvalidOperationException("Added type's DeclaringType != null");
#endif
			value.Module2 = this;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnAdd(int index, TypeDef value) {
			if (value.DeclaringType != null)
				throw new InvalidOperationException("Nested type is already owned by another type. Set DeclaringType to null first.");
			if (value.Module != null)
				throw new InvalidOperationException("Type is already owned by another module. Remove it from that module's type list.");
			value.Module2 = this;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnRemove(int index, TypeDef value) {
			value.Module2 = null;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnClear() {
			foreach (var type in Types.GetEnumerable_NoLock())
				type.Module2 = null;
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. For speed, enable <see cref="EnableTypeDefFindCache"/>
		/// if possible (read the documentation first).
		/// </summary>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public TypeDef Find(string fullName, bool isReflectionName) {
			return TypeDefFinder.Find(fullName, isReflectionName);
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
		/// looking up the type. For speed, enable <see cref="EnableTypeDefFindCache"/> if possible
		/// (read the documentation first).
		/// </summary>
		/// <param name="typeRef">The type ref</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public TypeDef Find(TypeRef typeRef) {
			return TypeDefFinder.Find(typeRef);
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeRef">The type</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if it wasn't found</returns>
		public TypeDef Find(ITypeDefOrRef typeRef) {
			var td = typeRef as TypeDef;
			if (td != null)
				return td.Module == this ? td : null;

			var tr = typeRef as TypeRef;
			if (tr != null)
				return Find(tr);

			var ts = typeRef as TypeSpec;
			if (ts == null)
				return null;
			var sig = ts.TypeSig as TypeDefOrRefSig;
			if (sig == null)
				return null;

			td = sig.TypeDef;
			if (td != null)
				return td.Module == this ? td : null;

			tr = sig.TypeRef;
			if (tr != null)
				return Find(tr);

			return null;
		}

		/// <summary>
		/// Creates a new <see cref="ModuleContext"/> instance. There should normally only be one
		/// instance shared by all <see cref="ModuleDef"/>s.
		/// </summary>
		/// <param name="addOtherSearchPaths">If <c>true</c>, add other common assembly search
		/// paths, not just the module search paths and the GAC.</param>
		/// <returns>A new <see cref="ModuleContext"/> instance</returns>
		public static ModuleContext CreateModuleContext(bool addOtherSearchPaths = true) {
			var ctx = new ModuleContext();
			var asmRes = new AssemblyResolver(ctx, addOtherSearchPaths);
			var res = new Resolver(asmRes);
			ctx.AssemblyResolver = asmRes;
			ctx.Resolver = res;
			return ctx;
		}

		/// <summary>
		/// Load everything in this module. All types, fields, asm refs, etc are loaded, all their
		/// properties are read to make sure everything is cached.
		/// </summary>
		/// <param name="cancellationToken">Cancellation token or <c>null</c></param>
		public virtual void LoadEverything(ICancellationToken cancellationToken = null) {
			ModuleLoader.LoadAll(this, cancellationToken);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="mdToken">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="mdToken"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(MDToken mdToken) {
			return ResolveToken(mdToken.Raw, new GenericParamContext());
		}

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="mdToken">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="mdToken"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(MDToken mdToken, GenericParamContext gpContext) {
			return ResolveToken(mdToken.Raw, gpContext);
		}

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(int token) {
			return ResolveToken((uint)token, new GenericParamContext());
		}

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(int token, GenericParamContext gpContext) {
			return ResolveToken((uint)token, gpContext);
		}

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(uint token) {
			return ResolveToken(token, new GenericParamContext());
		}

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public virtual IMDTokenProvider ResolveToken(uint token, GenericParamContext gpContext) {
			return null;
		}

		/// <summary>
		/// Gets all <see cref="AssemblyRef"/>s
		/// </summary>
		public IEnumerable<AssemblyRef> GetAssemblyRefs() {
			for (uint rid = 1; ; rid++) {
				var asmRef = ResolveToken(new MDToken(Table.AssemblyRef, rid).Raw) as AssemblyRef;
				if (asmRef == null)
					break;
				yield return asmRef;
			}
		}

		/// <summary>
		/// Gets all <see cref="ModuleRef"/>s
		/// </summary>
		public IEnumerable<ModuleRef> GetModuleRefs() {
			for (uint rid = 1; ; rid++) {
				var modRef = ResolveToken(new MDToken(Table.ModuleRef, rid).Raw) as ModuleRef;
				if (modRef == null)
					break;
				yield return modRef;
			}
		}

		/// <summary>
		/// Gets all <see cref="MemberRef"/>s. <see cref="MemberRef"/>s with generic parameters
		/// aren't cached and a new copy is always returned.
		/// </summary>
		public IEnumerable<MemberRef> GetMemberRefs() {
			return GetMemberRefs(new GenericParamContext());
		}

		/// <summary>
		/// Gets all <see cref="MemberRef"/>s. <see cref="MemberRef"/>s with generic parameters
		/// aren't cached and a new copy is always returned.
		/// </summary>
		/// <param name="gpContext">Generic parameter context</param>
		public IEnumerable<MemberRef> GetMemberRefs(GenericParamContext gpContext) {
			for (uint rid = 1; ; rid++) {
				var mr = ResolveToken(new MDToken(Table.MemberRef, rid).Raw, gpContext) as MemberRef;
				if (mr == null)
					break;
				yield return mr;
			}
		}

		/// <summary>
		/// Gets all <see cref="TypeRef"/>s
		/// </summary>
		public IEnumerable<TypeRef> GetTypeRefs() {
			for (uint rid = 1; ; rid++) {
				var mr = ResolveToken(new MDToken(Table.TypeRef, rid).Raw) as TypeRef;
				if (mr == null)
					break;
				yield return mr;
			}
		}

		/// <summary>
		/// Finds an assembly reference by name. If there's more than one, pick the one with
		/// the greatest version number.
		/// </summary>
		/// <param name="simpleName">Simple name of assembly (eg. "mscorlib")</param>
		/// <returns>The found <see cref="AssemblyRef"/> or <c>null</c> if there's no such
		/// assembly reference.</returns>
		public AssemblyRef GetAssemblyRef(UTF8String simpleName) {
			AssemblyRef found = null;
			foreach (var asmRef in GetAssemblyRefs()) {
				if (asmRef.Name != simpleName)
					continue;
				if (IsGreaterAssemblyRefVersion(found, asmRef))
					found = asmRef;
			}
			return found;
		}

		/// <summary>
		/// Compare asm refs' version
		/// </summary>
		/// <param name="found">First asm ref</param>
		/// <param name="newOne">New asm ref</param>
		/// <returns></returns>
		protected static bool IsGreaterAssemblyRefVersion(AssemblyRef found, AssemblyRef newOne) {
			if (found == null)
				return true;
			var foundVer = found.Version;
			var newVer = newOne.Version;
			return foundVer == null || (newVer != null && newVer >= foundVer);
		}

		ITypeDefOrRef ISignatureReaderHelper.ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext) {
			uint token;
			if (!CodedToken.TypeDefOrRef.Decode(codedToken, out token))
				return null;
			return ResolveToken(token) as ITypeDefOrRef;
		}

		TypeSig ISignatureReaderHelper.ConvertRTInternalAddress(IntPtr address) {
			return null;
		}
	}

	/// <summary>
	/// A Module row created by the user and not present in the original .NET file
	/// </summary>
	public class ModuleDefUser : ModuleDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleDefUser()
			: this(null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks><see cref="ModuleDef.Mvid"/> is initialized to a random <see cref="Guid"/></remarks>
		/// <param name="name">Module nam</param>
		public ModuleDefUser(UTF8String name)
			: this(name, Guid.NewGuid()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Module name</param>
		/// <param name="mvid">Module version ID</param>
		public ModuleDefUser(UTF8String name, Guid? mvid)
			: this(name, mvid, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Module name</param>
		/// <param name="mvid">Module version ID</param>
		/// <param name="corLibAssemblyRef">Corlib assembly ref or <c>null</c></param>
		public ModuleDefUser(UTF8String name, Guid? mvid, AssemblyRef corLibAssemblyRef) {
			this.Kind = ModuleKind.Windows;
			this.Characteristics = DefaultCharacteristics;
			this.DllCharacteristics = DefaultDllCharacteristics;
			this.RuntimeVersion = MDHeaderRuntimeVersion.MS_CLR_20;
			this.Machine = Machine.I386;
			this.cor20HeaderFlags = (int)ComImageFlags.ILOnly;
			this.Cor20HeaderRuntimeVersion = 0x00020005;	// .NET 2.0 or later should use 2.5
			this.TablesHeaderVersion = 0x0200;				// .NET 2.0 or later should use 2.0
			this.types = new LazyList<TypeDef>(this);
			this.exportedTypes = new LazyList<ExportedType>();
			this.resources = new ResourceCollection();
			this.corLibTypes = new CorLibTypes(this, corLibAssemblyRef);
			this.types = new LazyList<TypeDef>(this);
			this.name = name;
			this.mvid = mvid;
			types.Add(CreateModuleType());
			UpdateRowId(this);
		}

		TypeDef CreateModuleType() {
			var type = UpdateRowId(new TypeDefUser(UTF8String.Empty, "<Module>", null));
			type.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.Class | TypeAttributes.AnsiClass;
			return type;
		}
	}

	/// <summary>
	/// Created from a row in the Module table
	/// </summary>
	public class ModuleDefMD2 : ModuleDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.Module, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override RVA GetNativeEntryPoint_NoLock() {
			return readerModule.GetNativeEntryPoint();
		}

		/// <inheritdoc/>
		protected override IManagedEntryPoint GetManagedEntryPoint_NoLock() {
			return readerModule.GetManagedEntryPoint();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Module</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		internal ModuleDefMD2(ModuleDefMD readerModule, uint rid) {
			if (rid == 1 && readerModule == null)
				readerModule = (ModuleDefMD)this;
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (rid != 1 && readerModule.TablesStream.ModuleTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("Module rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			if (rid != 1) {
				this.Kind = ModuleKind.Windows;
				this.Characteristics = DefaultCharacteristics;
				this.DllCharacteristics = DefaultDllCharacteristics;
				this.RuntimeVersion = MDHeaderRuntimeVersion.MS_CLR_20;
				this.Machine = Machine.I386;
				this.cor20HeaderFlags = (int)ComImageFlags.ILOnly;
				this.Cor20HeaderRuntimeVersion = 0x00020005;	// .NET 2.0 or later should use 2.5
				this.TablesHeaderVersion = 0x0200;				// .NET 2.0 or later should use 2.0
				this.corLibTypes = new CorLibTypes(this);
				this.location = string.Empty;
				InitializeFromRawRow();
			}
		}

		/// <summary>
		/// Initialize fields from the raw <c>Module</c> row
		/// </summary>
		protected void InitializeFromRawRow() {
			uint name, mvid, encId;
			uint encBaseId = readerModule.TablesStream.ReadModuleRow(origRid, out generation, out name, out mvid, out encId);
			this.mvid = readerModule.GuidStream.Read(mvid);
			this.encId = readerModule.GuidStream.Read(encId);
			this.encBaseId = readerModule.GuidStream.Read(encBaseId);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			if (origRid == 1)
				assembly = readerModule.ResolveAssembly(origRid);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ModuleDefMD.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;
using dnlib.PE;
using dnlib.Utils;
using dnlib.IO;
using dnlib.DotNet.MD;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Pdb;
using dnlib.W32Resources;

using DNW = dnlib.DotNet.Writer;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet {
	/// <summary>
	/// Created from a row in the Module table
	/// </summary>
	public sealed class ModuleDefMD : ModuleDefMD2, IInstructionOperandResolver {
		/// <summary>The file that contains all .NET metadata</summary>
		MetaData metaData;
		IMethodDecrypter methodDecrypter;
		IStringDecrypter stringDecrypter;

		RandomRidList moduleRidList;

		SimpleLazyList<ModuleDefMD2> listModuleDefMD;
		SimpleLazyList<TypeRefMD> listTypeRefMD;
		SimpleLazyList<TypeDefMD> listTypeDefMD;
		SimpleLazyList<FieldDefMD> listFieldDefMD;
		SimpleLazyList<MethodDefMD> listMethodDefMD;
		SimpleLazyList<ParamDefMD> listParamDefMD;
		SimpleLazyList2<InterfaceImplMD> listInterfaceImplMD;
		SimpleLazyList2<MemberRefMD> listMemberRefMD;
		SimpleLazyList<ConstantMD> listConstantMD;
		SimpleLazyList<DeclSecurityMD> listDeclSecurityMD;
		SimpleLazyList<ClassLayoutMD> listClassLayoutMD;
		SimpleLazyList2<StandAloneSigMD> listStandAloneSigMD;
		SimpleLazyList<EventDefMD> listEventDefMD;
		SimpleLazyList<PropertyDefMD> listPropertyDefMD;
		SimpleLazyList<ModuleRefMD> listModuleRefMD;
		SimpleLazyList2<TypeSpecMD> listTypeSpecMD;
		SimpleLazyList<ImplMapMD> listImplMapMD;
		SimpleLazyList<AssemblyDefMD> listAssemblyDefMD;
		SimpleLazyList<AssemblyRefMD> listAssemblyRefMD;
		SimpleLazyList<FileDefMD> listFileDefMD;
		SimpleLazyList<ExportedTypeMD> listExportedTypeMD;
		SimpleLazyList<ManifestResourceMD> listManifestResourceMD;
		SimpleLazyList<GenericParamMD> listGenericParamMD;
		SimpleLazyList2<MethodSpecMD> listMethodSpecMD;
		SimpleLazyList2<GenericParamConstraintMD> listGenericParamConstraintMD;

		/// <summary>
		/// Gets/sets the method decrypter
		/// </summary>
		public IMethodDecrypter MethodDecrypter {
			get { return methodDecrypter; }
			set { methodDecrypter = value; }
		}

		/// <summary>
		/// Gets/sets the string decrypter
		/// </summary>
		public IStringDecrypter StringDecrypter {
			get { return stringDecrypter; }
			set { stringDecrypter = value; }
		}

		/// <summary>
		/// Returns the .NET metadata interface
		/// </summary>
		public IMetaData MetaData {
			get { return metaData; }
		}

		/// <summary>
		/// Returns the #~ or #- tables stream
		/// </summary>
		public TablesStream TablesStream {
			get { return metaData.TablesStream; }
		}

		/// <summary>
		/// Returns the #Strings stream
		/// </summary>
		public StringsStream StringsStream {
			get { return metaData.StringsStream; }
		}

		/// <summary>
		/// Returns the #Blob stream
		/// </summary>
		public BlobStream BlobStream {
			get { return metaData.BlobStream; }
		}

		/// <summary>
		/// Returns the #GUID stream
		/// </summary>
		public GuidStream GuidStream {
			get { return metaData.GuidStream; }
		}

		/// <summary>
		/// Returns the #US stream
		/// </summary>
		public USStream USStream {
			get { return metaData.USStream; }
		}

		/// <inheritdoc/>
		protected override void InitializeTypes() {
			var list = MetaData.GetNonNestedClassRidList();
			var tmp = new LazyList<TypeDef>((int)list.Length, this, list, (list2, index) => ResolveTypeDef(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref types, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeExportedTypes() {
			var list = MetaData.GetExportedTypeRidList();
			var tmp = new LazyList<ExportedType>((int)list.Length, list, (list2, i) => ResolveExportedType(((RidList)list2)[i]));
			Interlocked.CompareExchange(ref exportedTypes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeResources() {
			var table = TablesStream.ManifestResourceTable;
			var tmp = new ResourceCollection((int)table.Rows, null, (ctx, i) => CreateResource(i + 1));
			Interlocked.CompareExchange(ref resources, tmp, null);
		}

		/// <inheritdoc/>
		protected override Win32Resources GetWin32Resources_NoLock() {
			return metaData.PEImage.Win32Resources;
		}

		/// <inheritdoc/>
		protected override VTableFixups GetVTableFixups_NoLock() {
			var vtableFixupsInfo = metaData.ImageCor20Header.VTableFixups;
			if (vtableFixupsInfo.VirtualAddress == 0 || vtableFixupsInfo.Size == 0)
				return null;
			return new VTableFixups(this);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a file
		/// </summary>
		/// <param name="fileName">File name of an existing .NET module/assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(string fileName, ModuleContext context) {
			return Load(fileName, new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a file
		/// </summary>
		/// <param name="fileName">File name of an existing .NET module/assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(string fileName, ModuleCreationOptions options = null) {
			return Load(MetaDataCreator.Load(fileName), options);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a byte[]
		/// </summary>
		/// <param name="data">Contents of a .NET module/assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(byte[] data, ModuleContext context) {
			return Load(data, new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a byte[]
		/// </summary>
		/// <param name="data">Contents of a .NET module/assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(byte[] data, ModuleCreationOptions options = null) {
			return Load(MetaDataCreator.Load(data), options);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod) {
			return Load(mod, (ModuleCreationOptions)null, GetImageLayout(mod));
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod, ModuleContext context) {
			return Load(mod, new ModuleCreationOptions(context), GetImageLayout(mod));
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod, ModuleCreationOptions options) {
			return Load(mod, options, GetImageLayout(mod));
		}

		static ImageLayout GetImageLayout(System.Reflection.Module mod) {
			var fqn = mod.FullyQualifiedName;
			if (fqn.Length > 0 && fqn[0] == '<' && fqn[fqn.Length - 1] == '>')
				return ImageLayout.File;
			return ImageLayout.Memory;
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <param name="imageLayout">Image layout of the module in memory</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod, ModuleContext context, ImageLayout imageLayout) {
			return Load(mod, new ModuleCreationOptions(context), imageLayout);
		}

		static IntPtr GetModuleHandle(System.Reflection.Module mod) {
#if NETSTANDARD2_0
			var GetHINSTANCE = typeof(Marshal).GetMethod("GetHINSTANCE", new[] { typeof(System.Reflection.Module) });
			if (GetHINSTANCE == null)
				throw new NotSupportedException("System.Reflection.Module loading is not supported on current platform");

			var addr = (IntPtr)GetHINSTANCE.Invoke(null, new[] { mod });
#else
			var addr = Marshal.GetHINSTANCE(mod);
#endif
			if (addr == IntPtr.Zero || addr == new IntPtr(-1))
				throw new ArgumentException("It is not possible to get address of module");

			return addr;
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <param name="imageLayout">Image layout of the module in memory</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod, ModuleCreationOptions options, ImageLayout imageLayout) {
			IntPtr addr = GetModuleHandle(mod);
			if (addr == new IntPtr(-1))
				throw new InvalidOperationException(string.Format("Module {0} has no HINSTANCE", mod));
			return Load(addr, options, imageLayout);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr) {
			return Load(MetaDataCreator.Load(addr), (ModuleCreationOptions)null);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr, ModuleContext context) {
			return Load(MetaDataCreator.Load(addr), new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr, ModuleCreationOptions options) {
			return Load(MetaDataCreator.Load(addr), options);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance
		/// </summary>
		/// <param name="peImage">PE image</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IPEImage peImage) {
			return Load(MetaDataCreator.Load(peImage), (ModuleCreationOptions)null);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance
		/// </summary>
		/// <param name="peImage">PE image</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IPEImage peImage, ModuleContext context) {
			return Load(MetaDataCreator.Load(peImage), new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance
		/// </summary>
		/// <param name="peImage">PE image</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IPEImage peImage, ModuleCreationOptions options) {
			return Load(MetaDataCreator.Load(peImage), options);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <param name="imageLayout">Image layout of the file in memory</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr, ModuleContext context, ImageLayout imageLayout) {
			return Load(MetaDataCreator.Load(addr, imageLayout), new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <param name="imageLayout">Image layout of the file in memory</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr, ModuleCreationOptions options, ImageLayout imageLayout) {
			return Load(MetaDataCreator.Load(addr, imageLayout), options);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleCreationOptions)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream (owned by caller)</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		public static ModuleDefMD Load(Stream stream) {
			return Load(stream, (ModuleCreationOptions)null);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleContext)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream (owned by caller)</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		public static ModuleDefMD Load(Stream stream, ModuleContext context) {
			return Load(stream, new ModuleCreationOptions(context));
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleContext)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream (owned by caller)</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		public static ModuleDefMD Load(Stream stream, ModuleCreationOptions options) {
			if (stream == null)
				throw new ArgumentNullException("stream");
			if (stream.Length > int.MaxValue)
				throw new ArgumentException("Stream is too big");
			var data = new byte[(int)stream.Length];
			stream.Position = 0;
			if (stream.Read(data, 0, data.Length) != data.Length)
				throw new IOException("Could not read all bytes from the stream");
			return Load(data, options);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a <see cref="MetaData"/>
		/// </summary>
		/// <param name="metaData">The metadata</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance that now owns <paramref name="metaData"/></returns>
		internal static ModuleDefMD Load(MetaData metaData, ModuleCreationOptions options) {
			return new ModuleDefMD(metaData, options);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metaData">The metadata</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <exception cref="ArgumentNullException">If <paramref name="metaData"/> is <c>null</c></exception>
		ModuleDefMD(MetaData metaData, ModuleCreationOptions options)
			: base(null, 1) {
#if DEBUG
			if (metaData == null)
				throw new ArgumentNullException("metaData");
#endif
			if (options == null)
				options = ModuleCreationOptions.Default;
			this.metaData = metaData;
			this.context = options.Context;
			Initialize();
			InitializeFromRawRow();
			location = metaData.PEImage.FileName ?? string.Empty;

			this.Kind = GetKind();
			this.Characteristics = MetaData.PEImage.ImageNTHeaders.FileHeader.Characteristics;
			this.DllCharacteristics = MetaData.PEImage.ImageNTHeaders.OptionalHeader.DllCharacteristics;
			this.RuntimeVersion = MetaData.VersionString;
			this.Machine = MetaData.PEImage.ImageNTHeaders.FileHeader.Machine;
			this.Cor20HeaderFlags = MetaData.ImageCor20Header.Flags;
			this.Cor20HeaderRuntimeVersion = (uint)(MetaData.ImageCor20Header.MajorRuntimeVersion << 16) | MetaData.ImageCor20Header.MinorRuntimeVersion;
			this.TablesHeaderVersion = MetaData.TablesStream.Version;
			corLibTypes = new CorLibTypes(this, options.CorLibAssemblyRef ?? FindCorLibAssemblyRef() ?? CreateDefaultCorLibAssemblyRef());
			InitializePdb(options);
		}

		void InitializePdb(ModuleCreationOptions options) {
			if (options == null)
				return;
			LoadPdb(CreateSymbolReader(options));
		}

		SymbolReader CreateSymbolReader(ModuleCreationOptions options) {
			if (options.CreateSymbolReader != null) {
				var symReader = options.CreateSymbolReader(this);
				if (symReader != null)
					return symReader;
			}

			if (options.PdbFileOrData != null) {
				var pdbFileName = options.PdbFileOrData as string;
				if (!string.IsNullOrEmpty(pdbFileName)) {
					var symReader = SymbolReaderCreator.Create(options.PdbImplementation, metaData, pdbFileName);
					if (symReader != null)
						return symReader;
				}

				var pdbData = options.PdbFileOrData as byte[];
				if (pdbData != null)
					return SymbolReaderCreator.Create(options.PdbImplementation, metaData, pdbData);

				var pdbStream = options.PdbFileOrData as IImageStream;
				if (pdbStream != null)
					return SymbolReaderCreator.Create(options.PdbImplementation, metaData, pdbStream);
			}

			if (options.TryToLoadPdbFromDisk) {
				if (!string.IsNullOrEmpty(location))
					return SymbolReaderCreator.CreateFromAssemblyFile(options.PdbImplementation, metaData, location);
				else
					return SymbolReaderCreator.Create(options.PdbImplementation, metaData);
			}

			return null;
		}

		/// <summary>
		/// Loads symbols using <paramref name="symbolReader"/>
		/// </summary>
		/// <param name="symbolReader">PDB symbol reader</param>
		public void LoadPdb(SymbolReader symbolReader) {
			if (symbolReader == null)
				return;
			if (pdbState != null)
				throw new InvalidOperationException("PDB file has already been initialized");

			var orig = Interlocked.CompareExchange(ref pdbState, new PdbState(symbolReader, this), null);
			if (orig != null)
				throw new InvalidOperationException("PDB file has already been initialized");
		}

		/// <summary>
		/// Loads symbols from a PDB file
		/// </summary>
		/// <param name="pdbFileName">PDB file name</param>
		public void LoadPdb(string pdbFileName) {
			LoadPdb(PdbImplType.Default, pdbFileName);
		}

		/// <summary>
		/// Loads symbols from a PDB file
		/// </summary>
		/// <param name="pdbImpl">PDB implementation to use</param>
		/// <param name="pdbFileName">PDB file name</param>
		public void LoadPdb(PdbImplType pdbImpl, string pdbFileName) {
			LoadPdb(SymbolReaderCreator.Create(pdbImpl, metaData, pdbFileName));
		}

		/// <summary>
		/// Loads symbols from a byte array
		/// </summary>
		/// <param name="pdbData">PDB data</param>
		public void LoadPdb(byte[] pdbData) {
			LoadPdb(PdbImplType.Default, pdbData);
		}

		/// <summary>
		/// Loads symbols from a byte array
		/// </summary>
		/// <param name="pdbImpl">PDB implementation to use</param>
		/// <param name="pdbData">PDB data</param>
		public void LoadPdb(PdbImplType pdbImpl, byte[] pdbData) {
			LoadPdb(SymbolReaderCreator.Create(pdbImpl, metaData, pdbData));
		}

		/// <summary>
		/// Loads symbols from a stream
		/// </summary>
		/// <param name="pdbStream">PDB file stream which is now owned by us</param>
		public void LoadPdb(IImageStream pdbStream) {
			LoadPdb(PdbImplType.Default, pdbStream);
		}

		/// <summary>
		/// Loads symbols from a stream
		/// </summary>
		/// <param name="pdbImpl">PDB implementation to use</param>
		/// <param name="pdbStream">PDB file stream which is now owned by us</param>
		public void LoadPdb(PdbImplType pdbImpl, IImageStream pdbStream) {
			LoadPdb(SymbolReaderCreator.Create(pdbImpl, metaData, pdbStream));
		}

		/// <summary>
		/// Loads symbols if a PDB file is available
		/// </summary>
		public void LoadPdb() {
			LoadPdb(PdbImplType.Default);
		}

		/// <summary>
		/// Loads symbols if a PDB file is available
		/// </summary>
		/// <param name="pdbImpl">PDB implementation to use</param>
		public void LoadPdb(PdbImplType pdbImpl) {
			var loc = location;
			if (string.IsNullOrEmpty(loc))
				return;
			LoadPdb(SymbolReaderCreator.Create(pdbImpl, metaData, loc));
		}

		internal void InitializeCustomDebugInfos(MDToken token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
			var ps = pdbState;
			if (ps == null)
				return;
			ps.InitializeCustomDebugInfos(token, gpContext, result);
		}

		ModuleKind GetKind() {
			if (TablesStream.AssemblyTable.Rows < 1)
				return ModuleKind.NetModule;

			var peImage = MetaData.PEImage;
			if ((peImage.ImageNTHeaders.FileHeader.Characteristics & Characteristics.Dll) != 0)
				return ModuleKind.Dll;

			switch (peImage.ImageNTHeaders.OptionalHeader.Subsystem) {
			default:
			case Subsystem.WindowsGui:
				return ModuleKind.Windows;

			case Subsystem.WindowsCui:
				return ModuleKind.Console;
			}
		}

		void Initialize() {
			var ts = metaData.TablesStream;

			listModuleDefMD = new SimpleLazyList<ModuleDefMD2>(ts.ModuleTable.Rows, rid2 => rid2 == 1 ? this : new ModuleDefMD2(this, rid2));
			listTypeRefMD = new SimpleLazyList<TypeRefMD>(ts.TypeRefTable.Rows, rid2 => new TypeRefMD(this, rid2));
			listTypeDefMD = new SimpleLazyList<TypeDefMD>(ts.TypeDefTable.Rows, rid2 => new TypeDefMD(this, rid2));
			listFieldDefMD = new SimpleLazyList<FieldDefMD>(ts.FieldTable.Rows, rid2 => new FieldDefMD(this, rid2));
			listMethodDefMD = new SimpleLazyList<MethodDefMD>(ts.MethodTable.Rows, rid2 => new MethodDefMD(this, rid2));
			listParamDefMD = new SimpleLazyList<ParamDefMD>(ts.ParamTable.Rows, rid2 => new ParamDefMD(this, rid2));
			listInterfaceImplMD = new SimpleLazyList2<InterfaceImplMD>(ts.InterfaceImplTable.Rows, (rid2, gpContext) => new InterfaceImplMD(this, rid2, gpContext));
			listMemberRefMD = new SimpleLazyList2<MemberRefMD>(ts.MemberRefTable.Rows, (rid2, gpContext) => new MemberRefMD(this, rid2, gpContext));
			listConstantMD = new SimpleLazyList<ConstantMD>(ts.ConstantTable.Rows, rid2 => new ConstantMD(this, rid2));
			listDeclSecurityMD = new SimpleLazyList<DeclSecurityMD>(ts.DeclSecurityTable.Rows, rid2 => new DeclSecurityMD(this, rid2));
			listClassLayoutMD = new SimpleLazyList<ClassLayoutMD>(ts.ClassLayoutTable.Rows, rid2 => new ClassLayoutMD(this, rid2));
			listStandAloneSigMD = new SimpleLazyList2<StandAloneSigMD>(ts.StandAloneSigTable.Rows, (rid2, gpContext) => new StandAloneSigMD(this, rid2, gpContext));
			listEventDefMD = new SimpleLazyList<EventDefMD>(ts.EventTable.Rows, rid2 => new EventDefMD(this, rid2));
			listPropertyDefMD = new SimpleLazyList<PropertyDefMD>(ts.PropertyTable.Rows, rid2 => new PropertyDefMD(this, rid2));
			listModuleRefMD = new SimpleLazyList<ModuleRefMD>(ts.ModuleRefTable.Rows, rid2 => new ModuleRefMD(this, rid2));
			listTypeSpecMD = new SimpleLazyList2<TypeSpecMD>(ts.TypeSpecTable.Rows, (rid2, gpContext) => new TypeSpecMD(this, rid2, gpContext));
			listImplMapMD = new SimpleLazyList<ImplMapMD>(ts.ImplMapTable.Rows, rid2 => new ImplMapMD(this, rid2));
			listAssemblyDefMD = new SimpleLazyList<AssemblyDefMD>(ts.AssemblyTable.Rows, rid2 => new AssemblyDefMD(this, rid2));
			listFileDefMD = new SimpleLazyList<FileDefMD>(ts.FileTable.Rows, rid2 => new FileDefMD(this, rid2));
			listAssemblyRefMD = new SimpleLazyList<AssemblyRefMD>(ts.AssemblyRefTable.Rows, rid2 => new AssemblyRefMD(this, rid2));
			listExportedTypeMD = new SimpleLazyList<ExportedTypeMD>(ts.ExportedTypeTable.Rows, rid2 => new ExportedTypeMD(this, rid2));
			listManifestResourceMD = new SimpleLazyList<ManifestResourceMD>(ts.ManifestResourceTable.Rows, rid2 => new ManifestResourceMD(this, rid2));
			listGenericParamMD = new SimpleLazyList<GenericParamMD>(ts.GenericParamTable.Rows, rid2 => new GenericParamMD(this, rid2));
			listMethodSpecMD = new SimpleLazyList2<MethodSpecMD>(ts.MethodSpecTable.Rows, (rid2, gpContext) => new MethodSpecMD(this, rid2, gpContext));
			listGenericParamConstraintMD = new SimpleLazyList2<GenericParamConstraintMD>(ts.GenericParamConstraintTable.Rows, (rid2, gpContext) => new GenericParamConstraintMD(this, rid2, gpContext));

			for (int i = 0; i < 64; i++) {
				var tbl = TablesStream.Get((Table)i);
				lastUsedRids[i] = tbl == null ? 0 : (int)tbl.Rows;
			}
		}

		static readonly Dictionary<string, int> preferredCorLibs = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase) {
			// .NET Framework
			{ "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", 100 },
			{ "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", 90 },
			{ "mscorlib, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", 60 },
			{ "mscorlib, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", 50 },

			// Silverlight
			{ "mscorlib, Version=5.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e", 80 },
			{ "mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e", 70 },

			// Zune
			{ "mscorlib, Version=3.5.0.0, Culture=neutral, PublicKeyToken=e92a8b81eba7ceb7", 60 },

			// Compact Framework
			{ "mscorlib, Version=3.5.0.0, Culture=neutral, PublicKeyToken=969db8053d3322ac", 60 },
			{ "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=969db8053d3322ac", 50 },
		};

		/// <summary>
		/// Finds a mscorlib <see cref="AssemblyRef"/>
		/// </summary>
		/// <returns>An existing <see cref="AssemblyRef"/> instance or <c>null</c> if it wasn't found</returns>
		AssemblyRef FindCorLibAssemblyRef() {
			var numAsmRefs = TablesStream.AssemblyRefTable.Rows;
			AssemblyRef corLibAsmRef = null;

			int currentPriority = int.MinValue;
			for (uint i = 1; i <= numAsmRefs; i++) {
				var asmRef = ResolveAssemblyRef(i);
				int priority;
				if (!preferredCorLibs.TryGetValue(asmRef.FullName, out priority))
					continue;
				if (priority > currentPriority) {
					currentPriority = priority;
					corLibAsmRef = asmRef;
				}
			}
			if (corLibAsmRef != null)
				return corLibAsmRef;

			for (uint i = 1; i <= numAsmRefs; i++) {
				var asmRef = ResolveAssemblyRef(i);
				if (!UTF8String.ToSystemStringOrEmpty(asmRef.Name).Equals("netstandard", StringComparison.OrdinalIgnoreCase))
					continue;
				if (IsGreaterAssemblyRefVersion(corLibAsmRef, asmRef))
					corLibAsmRef = asmRef;
			}
			if (corLibAsmRef != null)
				return corLibAsmRef;

			for (uint i = 1; i <= numAsmRefs; i++) {
				var asmRef = ResolveAssemblyRef(i);
				if (!UTF8String.ToSystemStringOrEmpty(asmRef.Name).Equals("mscorlib", StringComparison.OrdinalIgnoreCase))
					continue;
				if (IsGreaterAssemblyRefVersion(corLibAsmRef, asmRef))
					corLibAsmRef = asmRef;
			}
			if (corLibAsmRef != null)
				return corLibAsmRef;

			// If we've loaded mscorlib itself, it won't have any AssemblyRefs to itself.
			var asm = Assembly;
			if (asm != null && (asm.IsCorLib() || Find("System.Object", false) != null)) {
				IsCoreLibraryModule = true;
				return UpdateRowId(new AssemblyRefUser(asm));
			}

			return corLibAsmRef;
		}

		/// <summary>
		/// Called when no corlib assembly reference was found
		/// </summary>
		/// <returns></returns>
		AssemblyRef CreateDefaultCorLibAssemblyRef() {
			var asmRef = GetAlternativeCorLibReference();
			if (asmRef != null)
				return UpdateRowId(asmRef);

			if (this.IsClr40)
				return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR40());
			if (this.IsClr20)
				return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR20());
			if (this.IsClr11)
				return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR11());
			if (this.IsClr10)
				return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR10());
			return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR40());
		}

		AssemblyRef GetAlternativeCorLibReference() {
			foreach (var asmRef in GetAssemblyRefs()) {
				if (IsAssemblyRef(asmRef, systemRuntimeName, contractsPublicKeyToken))
					return asmRef;
			}
			foreach (var asmRef in GetAssemblyRefs()) {
				if (IsAssemblyRef(asmRef, corefxName, contractsPublicKeyToken))
					return asmRef;
			}
			return null;
		}

		static bool IsAssemblyRef(AssemblyRef asmRef, UTF8String name, PublicKeyToken token) {
			if (asmRef.Name != name)
				return false;
			var pkot = asmRef.PublicKeyOrToken;
			if (pkot == null)
				return false;
			return token.Equals(pkot.Token);
		}
		static readonly UTF8String systemRuntimeName = new UTF8String("System.Runtime");
		static readonly UTF8String corefxName = new UTF8String("corefx");
		static readonly PublicKeyToken contractsPublicKeyToken = new PublicKeyToken("b03f5f7f11d50a3a");

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			// Call base first since it will dispose of all the resources, which will
			// eventually use metaData that we will dispose
			base.Dispose(disposing);
			if (disposing) {
				var md = metaData;
				if (md != null)
					md.Dispose();
				metaData = null;
			}
		}

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public override IMDTokenProvider ResolveToken(uint token, GenericParamContext gpContext) {
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Module:			return ResolveModule(rid);
			case Table.TypeRef:			return ResolveTypeRef(rid);
			case Table.TypeDef:			return ResolveTypeDef(rid);
			case Table.Field:			return ResolveField(rid);
			case Table.Method:			return ResolveMethod(rid);
			case Table.Param:			return ResolveParam(rid);
			case Table.InterfaceImpl:	return ResolveInterfaceImpl(rid, gpContext);
			case Table.MemberRef:		return ResolveMemberRef(rid, gpContext);
			case Table.Constant:		return ResolveConstant(rid);
			case Table.DeclSecurity:	return ResolveDeclSecurity(rid);
			case Table.ClassLayout:		return ResolveClassLayout(rid);
			case Table.StandAloneSig:	return ResolveStandAloneSig(rid, gpContext);
			case Table.Event:			return ResolveEvent(rid);
			case Table.Property:		return ResolveProperty(rid);
			case Table.ModuleRef:		return ResolveModuleRef(rid);
			case Table.TypeSpec:		return ResolveTypeSpec(rid, gpContext);
			case Table.ImplMap:			return ResolveImplMap(rid);
			case Table.Assembly:		return ResolveAssembly(rid);
			case Table.AssemblyRef:		return ResolveAssemblyRef(rid);
			case Table.File:			return ResolveFile(rid);
			case Table.ExportedType:	return ResolveExportedType(rid);
			case Table.ManifestResource:return ResolveManifestResource(rid);
			case Table.GenericParam:	return ResolveGenericParam(rid);
			case Table.MethodSpec:		return ResolveMethodSpec(rid, gpContext);
			case Table.GenericParamConstraint: return ResolveGenericParamConstraint(rid, gpContext);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="ModuleDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ModuleDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ModuleDef ResolveModule(uint rid) {
			return listModuleDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="TypeRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public TypeRef ResolveTypeRef(uint rid) {
			return listTypeRefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public TypeDef ResolveTypeDef(uint rid) {
			return listTypeDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="FieldDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="FieldDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public FieldDef ResolveField(uint rid) {
			return listFieldDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="MethodDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="MethodDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MethodDef ResolveMethod(uint rid) {
			return listMethodDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="ParamDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ParamDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ParamDef ResolveParam(uint rid) {
			return listParamDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves an <see cref="InterfaceImpl"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="InterfaceImpl"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public InterfaceImpl ResolveInterfaceImpl(uint rid) {
			return listInterfaceImplMD[rid - 1, new GenericParamContext()];
		}

		/// <summary>
		/// Resolves an <see cref="InterfaceImpl"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="InterfaceImpl"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public InterfaceImpl ResolveInterfaceImpl(uint rid, GenericParamContext gpContext) {
			return listInterfaceImplMD[rid - 1, gpContext];
		}

		/// <summary>
		/// Resolves a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="MemberRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MemberRef ResolveMemberRef(uint rid) {
			return listMemberRefMD[rid - 1, new GenericParamContext()];
		}

		/// <summary>
		/// Resolves a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="MemberRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MemberRef ResolveMemberRef(uint rid, GenericParamContext gpContext) {
			return listMemberRefMD[rid - 1, gpContext];
		}

		/// <summary>
		/// Resolves a <see cref="Constant"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="Constant"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public Constant ResolveConstant(uint rid) {
			return listConstantMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="DeclSecurity"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="DeclSecurity"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public DeclSecurity ResolveDeclSecurity(uint rid) {
			return listDeclSecurityMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="ClassLayout"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ClassLayout"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ClassLayout ResolveClassLayout(uint rid) {
			return listClassLayoutMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="StandAloneSig"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="StandAloneSig"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public StandAloneSig ResolveStandAloneSig(uint rid) {
			return listStandAloneSigMD[rid - 1, new GenericParamContext()];
		}

		/// <summary>
		/// Resolves a <see cref="StandAloneSig"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="StandAloneSig"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public StandAloneSig ResolveStandAloneSig(uint rid, GenericParamContext gpContext) {
			return listStandAloneSigMD[rid - 1, gpContext];
		}

		/// <summary>
		/// Resolves an <see cref="EventDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="EventDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public EventDef ResolveEvent(uint rid) {
			return listEventDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="PropertyDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="PropertyDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public PropertyDef ResolveProperty(uint rid) {
			return listPropertyDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="ModuleRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ModuleRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ModuleRef ResolveModuleRef(uint rid) {
			return listModuleRefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="TypeSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public TypeSpec ResolveTypeSpec(uint rid) {
			return listTypeSpecMD[rid - 1, new GenericParamContext()];
		}

		/// <summary>
		/// Resolves a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="TypeSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public TypeSpec ResolveTypeSpec(uint rid, GenericParamContext gpContext) {
			return listTypeSpecMD[rid - 1, gpContext];
		}

		/// <summary>
		/// Resolves an <see cref="ImplMap"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ImplMap"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ImplMap ResolveImplMap(uint rid) {
			return listImplMapMD[rid - 1];
		}

		/// <summary>
		/// Resolves an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="AssemblyDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public AssemblyDef ResolveAssembly(uint rid) {
			return listAssemblyDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves an <see cref="AssemblyRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="AssemblyRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public AssemblyRef ResolveAssemblyRef(uint rid) {
			return listAssemblyRefMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="FileDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="FileDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public FileDef ResolveFile(uint rid) {
			return listFileDefMD[rid - 1];
		}

		/// <summary>
		/// Resolves an <see cref="ExportedType"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ExportedType"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ExportedType ResolveExportedType(uint rid) {
			return listExportedTypeMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="ManifestResource"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ManifestResource"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ManifestResource ResolveManifestResource(uint rid) {
			return listManifestResourceMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="GenericParam"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="GenericParam"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public GenericParam ResolveGenericParam(uint rid) {
			return listGenericParamMD[rid - 1];
		}

		/// <summary>
		/// Resolves a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="MethodSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MethodSpec ResolveMethodSpec(uint rid) {
			return listMethodSpecMD[rid - 1, new GenericParamContext()];
		}

		/// <summary>
		/// Resolves a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="MethodSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MethodSpec ResolveMethodSpec(uint rid, GenericParamContext gpContext) {
			return listMethodSpecMD[rid - 1, gpContext];
		}

		/// <summary>
		/// Resolves a <see cref="GenericParamConstraint"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="GenericParamConstraint"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public GenericParamConstraint ResolveGenericParamConstraint(uint rid) {
			return listGenericParamConstraintMD[rid - 1, new GenericParamContext()];
		}

		/// <summary>
		/// Resolves a <see cref="GenericParamConstraint"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="GenericParamConstraint"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public GenericParamConstraint ResolveGenericParamConstraint(uint rid, GenericParamContext gpContext) {
			return listGenericParamConstraintMD[rid - 1, gpContext];
		}

		/// <summary>
		/// Resolves a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
		/// <returns>A <see cref="ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ITypeDefOrRef ResolveTypeDefOrRef(uint codedToken) {
			return ResolveTypeDefOrRef(codedToken, new GenericParamContext());
		}

		/// <summary>
		/// Resolves a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ITypeDefOrRef ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext) {
			uint token;
			if (!CodedToken.TypeDefOrRef.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.TypeDef:		return ResolveTypeDef(rid);
			case Table.TypeRef:		return ResolveTypeRef(rid);
			case Table.TypeSpec:	return ResolveTypeSpec(rid, gpContext);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IHasConstant"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasConstant</c> coded token</param>
		/// <returns>A <see cref="IHasConstant"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasConstant ResolveHasConstant(uint codedToken) {
			uint token;
			if (!CodedToken.HasConstant.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Field:	return ResolveField(rid);
			case Table.Param:	return ResolveParam(rid);
			case Table.Property:return ResolveProperty(rid);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IHasCustomAttribute"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasCustomAttribute</c> coded token</param>
		/// <returns>A <see cref="IHasCustomAttribute"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasCustomAttribute ResolveHasCustomAttribute(uint codedToken) {
			return ResolveHasCustomAttribute(codedToken, new GenericParamContext());
		}

		/// <summary>
		/// Resolves a <see cref="IHasCustomAttribute"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasCustomAttribute</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IHasCustomAttribute"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasCustomAttribute ResolveHasCustomAttribute(uint codedToken, GenericParamContext gpContext) {
			uint token;
			if (!CodedToken.HasCustomAttribute.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Method:		return ResolveMethod(rid);
			case Table.Field:		return ResolveField(rid);
			case Table.TypeRef:		return ResolveTypeRef(rid);
			case Table.TypeDef:		return ResolveTypeDef(rid);
			case Table.Param:		return ResolveParam(rid);
			case Table.InterfaceImpl: return ResolveInterfaceImpl(rid, gpContext);
			case Table.MemberRef:	return ResolveMemberRef(rid, gpContext);
			case Table.Module:		return ResolveModule(rid);
			case Table.DeclSecurity:return ResolveDeclSecurity(rid);
			case Table.Property:	return ResolveProperty(rid);
			case Table.Event:		return ResolveEvent(rid);
			case Table.StandAloneSig: return ResolveStandAloneSig(rid, gpContext);
			case Table.ModuleRef:	return ResolveModuleRef(rid);
			case Table.TypeSpec:	return ResolveTypeSpec(rid, gpContext);
			case Table.Assembly:	return ResolveAssembly(rid);
			case Table.AssemblyRef:	return ResolveAssemblyRef(rid);
			case Table.File:		return ResolveFile(rid);
			case Table.ExportedType:return ResolveExportedType(rid);
			case Table.ManifestResource: return ResolveManifestResource(rid);
			case Table.GenericParam:return ResolveGenericParam(rid);
			case Table.MethodSpec:	return ResolveMethodSpec(rid, gpContext);
			case Table.GenericParamConstraint: return ResolveGenericParamConstraint(rid, gpContext);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IHasFieldMarshal"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasFieldMarshal</c> coded token</param>
		/// <returns>A <see cref="IHasFieldMarshal"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasFieldMarshal ResolveHasFieldMarshal(uint codedToken) {
			uint token;
			if (!CodedToken.HasFieldMarshal.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Field:	return ResolveField(rid);
			case Table.Param:	return ResolveParam(rid);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IHasDeclSecurity"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasDeclSecurity</c> coded token</param>
		/// <returns>A <see cref="IHasDeclSecurity"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasDeclSecurity ResolveHasDeclSecurity(uint codedToken) {
			uint token;
			if (!CodedToken.HasDeclSecurity.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.TypeDef:		return ResolveTypeDef(rid);
			case Table.Method:		return ResolveMethod(rid);
			case Table.Assembly:	return ResolveAssembly(rid);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IMemberRefParent"/>
		/// </summary>
		/// <param name="codedToken">A <c>MemberRefParent</c> coded token</param>
		/// <returns>A <see cref="IMemberRefParent"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMemberRefParent ResolveMemberRefParent(uint codedToken) {
			return ResolveMemberRefParent(codedToken, new GenericParamContext());
		}

		/// <summary>
		/// Resolves a <see cref="IMemberRefParent"/>
		/// </summary>
		/// <param name="codedToken">A <c>MemberRefParent</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMemberRefParent"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMemberRefParent ResolveMemberRefParent(uint codedToken, GenericParamContext gpContext) {
			uint token;
			if (!CodedToken.MemberRefParent.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.TypeDef:		return ResolveTypeDef(rid);
			case Table.TypeRef:		return ResolveTypeRef(rid);
			case Table.ModuleRef:	return ResolveModuleRef(rid);
			case Table.Method:		return ResolveMethod(rid);
			case Table.TypeSpec:	return ResolveTypeSpec(rid, gpContext);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IHasSemantic"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasSemantic</c> coded token</param>
		/// <returns>A <see cref="IHasSemantic"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasSemantic ResolveHasSemantic(uint codedToken) {
			uint token;
			if (!CodedToken.HasSemantic.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Event:		return ResolveEvent(rid);
			case Table.Property:	return ResolveProperty(rid);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IMethodDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>MethodDefOrRef</c> coded token</param>
		/// <returns>A <see cref="IMethodDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMethodDefOrRef ResolveMethodDefOrRef(uint codedToken) {
			return ResolveMethodDefOrRef(codedToken, new GenericParamContext());
		}

		/// <summary>
		/// Resolves a <see cref="IMethodDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>MethodDefOrRef</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMethodDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMethodDefOrRef ResolveMethodDefOrRef(uint codedToken, GenericParamContext gpContext) {
			uint token;
			if (!CodedToken.MethodDefOrRef.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Method:		return ResolveMethod(rid);
			case Table.MemberRef:	return ResolveMemberRef(rid, gpContext);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IMemberForwarded"/>
		/// </summary>
		/// <param name="codedToken">A <c>MemberForwarded</c> coded token</param>
		/// <returns>A <see cref="IMemberForwarded"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMemberForwarded ResolveMemberForwarded(uint codedToken) {
			uint token;
			if (!CodedToken.MemberForwarded.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Field:	return ResolveField(rid);
			case Table.Method:	return ResolveMethod(rid);
			}
			return null;
		}

		/// <summary>
		/// Resolves an <see cref="IImplementation"/>
		/// </summary>
		/// <param name="codedToken">An <c>Implementation</c> coded token</param>
		/// <returns>A <see cref="IImplementation"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IImplementation ResolveImplementation(uint codedToken) {
			uint token;
			if (!CodedToken.Implementation.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.File:			return ResolveFile(rid);
			case Table.AssemblyRef:		return ResolveAssemblyRef(rid);
			case Table.ExportedType:	return ResolveExportedType(rid);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="ICustomAttributeType"/>
		/// </summary>
		/// <param name="codedToken">A <c>CustomAttributeType</c> coded token</param>
		/// <returns>A <see cref="ICustomAttributeType"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ICustomAttributeType ResolveCustomAttributeType(uint codedToken) {
			return ResolveCustomAttributeType(codedToken, new GenericParamContext());
		}

		/// <summary>
		/// Resolves a <see cref="ICustomAttributeType"/>
		/// </summary>
		/// <param name="codedToken">A <c>CustomAttributeType</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="ICustomAttributeType"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ICustomAttributeType ResolveCustomAttributeType(uint codedToken, GenericParamContext gpContext) {
			uint token;
			if (!CodedToken.CustomAttributeType.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Method:		return ResolveMethod(rid);
			case Table.MemberRef:	return ResolveMemberRef(rid, gpContext);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="IResolutionScope"/>
		/// </summary>
		/// <param name="codedToken">A <c>ResolutionScope</c> coded token</param>
		/// <returns>A <see cref="IResolutionScope"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IResolutionScope ResolveResolutionScope(uint codedToken) {
			uint token;
			if (!CodedToken.ResolutionScope.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Module:		return ResolveModule(rid);
			case Table.ModuleRef:	return ResolveModuleRef(rid);
			case Table.AssemblyRef:	return ResolveAssemblyRef(rid);
			case Table.TypeRef:		return ResolveTypeRef(rid);
			}
			return null;
		}

		/// <summary>
		/// Resolves a <see cref="ITypeOrMethodDef"/>
		/// </summary>
		/// <param name="codedToken">A <c>TypeOrMethodDef</c>> coded token</param>
		/// <returns>A <see cref="ITypeOrMethodDef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ITypeOrMethodDef ResolveTypeOrMethodDef(uint codedToken) {
			uint token;
			if (!CodedToken.TypeOrMethodDef.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.TypeDef:	return ResolveTypeDef(rid);
			case Table.Method:	return ResolveMethod(rid);
			}
			return null;
		}

		/// <summary>
		/// Reads a signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public CallingConventionSig ReadSignature(uint sig) {
			return SignatureReader.ReadSig(this, sig, new GenericParamContext());
		}

		/// <summary>
		/// Reads a signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public CallingConventionSig ReadSignature(uint sig, GenericParamContext gpContext) {
			return SignatureReader.ReadSig(this, sig, gpContext);
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public TypeSig ReadTypeSignature(uint sig) {
			return SignatureReader.ReadTypeSig(this, sig, new GenericParamContext());
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public TypeSig ReadTypeSignature(uint sig, GenericParamContext gpContext) {
			return SignatureReader.ReadTypeSig(this, sig, gpContext);
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public TypeSig ReadTypeSignature(uint sig, out byte[] extraData) {
			return SignatureReader.ReadTypeSig(this, sig, new GenericParamContext(), out extraData);
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public TypeSig ReadTypeSignature(uint sig, GenericParamContext gpContext, out byte[] extraData) {
			return SignatureReader.ReadTypeSig(this, sig, gpContext, out extraData);
		}

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from the blob
		/// </summary>
		/// <param name="table">Table of owner</param>
		/// <param name="rid">Row ID of owner</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="MarshalType"/> instance or <c>null</c> if there's no field
		/// marshal for this owner.</returns>
		internal MarshalType ReadMarshalType(Table table, uint rid, GenericParamContext gpContext) {
			var row = TablesStream.ReadFieldMarshalRow(MetaData.GetFieldMarshalRid(table, rid));
			if (row == null)
				return null;
			return MarshalBlobReader.Read(this, row.NativeType, gpContext);
		}

		/// <summary>
		/// Reads a CIL method body
		/// </summary>
		/// <param name="parameters">Method parameters</param>
		/// <param name="rva">RVA</param>
		/// <returns>A new <see cref="CilBody"/> instance. It's empty if RVA is invalid (eg. 0 or
		/// it doesn't point to a CIL method body)</returns>
		public CilBody ReadCilBody(IList<Parameter> parameters, RVA rva) {
			return ReadCilBody(parameters, rva, new GenericParamContext());
		}

		/// <summary>
		/// Reads a CIL method body
		/// </summary>
		/// <param name="parameters">Method parameters</param>
		/// <param name="rva">RVA</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CilBody"/> instance. It's empty if RVA is invalid (eg. 0 or
		/// it doesn't point to a CIL method body)</returns>
		public CilBody ReadCilBody(IList<Parameter> parameters, RVA rva, GenericParamContext gpContext) {
			if (rva == 0)
				return new CilBody();

			// Create a full stream so position will be the real position in the file. This
			// is important when reading exception handlers since those must be 4-byte aligned.
			// If we create a partial stream starting from rva, then position will be 0 and always
			// 4-byte aligned. All fat method bodies should be 4-byte aligned, but the CLR doesn't
			// seem to verify it. We must parse the method exactly the way the CLR parses it.
			using (var reader = metaData.PEImage.CreateFullStream()) {
				reader.Position = (long)metaData.PEImage.ToFileOffset(rva);
				return MethodBodyReader.CreateCilBody(this, reader, parameters, gpContext);
			}
		}

		/// <summary>
		/// Returns the owner type of a field
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The owner type or <c>null</c> if none</returns>
		internal TypeDef GetOwnerType(FieldDefMD field) {
			return ResolveTypeDef(MetaData.GetOwnerTypeOfField(field.OrigRid));
		}

		/// <summary>
		/// Returns the owner type of a method
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The owner type or <c>null</c> if none</returns>
		internal TypeDef GetOwnerType(MethodDefMD method) {
			return ResolveTypeDef(MetaData.GetOwnerTypeOfMethod(method.OrigRid));
		}

		/// <summary>
		/// Returns the owner type of an event
		/// </summary>
		/// <param name="evt">The event</param>
		/// <returns>The owner type or <c>null</c> if none</returns>
		internal TypeDef GetOwnerType(EventDefMD evt) {
			return ResolveTypeDef(MetaData.GetOwnerTypeOfEvent(evt.OrigRid));
		}

		/// <summary>
		/// Returns the owner type of a property
		/// </summary>
		/// <param name="property">The property</param>
		/// <returns>The owner type or <c>null</c> if none</returns>
		internal TypeDef GetOwnerType(PropertyDefMD property) {
			return ResolveTypeDef(MetaData.GetOwnerTypeOfProperty(property.OrigRid));
		}

		/// <summary>
		/// Returns the owner type/method of a generic param
		/// </summary>
		/// <param name="gp">The generic param</param>
		/// <returns>The owner type/method or <c>null</c> if none</returns>
		internal ITypeOrMethodDef GetOwner(GenericParamMD gp) {
			return ResolveTypeOrMethodDef(MetaData.GetOwnerOfGenericParam(gp.OrigRid));
		}

		/// <summary>
		/// Returns the owner generic param of a generic param constraint
		/// </summary>
		/// <param name="gpc">The generic param constraint</param>
		/// <returns>The owner generic param or <c>null</c> if none</returns>
		internal GenericParam GetOwner(GenericParamConstraintMD gpc) {
			return ResolveGenericParam(MetaData.GetOwnerOfGenericParamConstraint(gpc.OrigRid));
		}

		/// <summary>
		/// Returns the owner method of a param
		/// </summary>
		/// <param name="pd">The param</param>
		/// <returns>The owner method or <c>null</c> if none</returns>
		internal MethodDef GetOwner(ParamDefMD pd) {
			return ResolveMethod(MetaData.GetOwnerOfParam(pd.OrigRid));
		}

		/// <summary>
		/// Reads a module
		/// </summary>
		/// <param name="fileRid">File rid</param>
		/// <param name="owner">The assembly owning the module we should read</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance or <c>null</c> if <paramref name="fileRid"/>
		/// is invalid or if it's not a .NET module.</returns>
		internal ModuleDefMD ReadModule(uint fileRid, AssemblyDef owner) {
			var fileDef = ResolveFile(fileRid);
			if (fileDef == null)
				return null;
			if (!fileDef.ContainsMetaData)
				return null;
			var fileName = GetValidFilename(GetBaseDirectoryOfImage(), UTF8String.ToSystemString(fileDef.Name));
			if (fileName == null)
				return null;
			ModuleDefMD module;
			try {
				module = ModuleDefMD.Load(fileName);
			}
			catch {
				module = null;
			}
			if (module != null) {
				// share context
				module.context = context;

				var asm = module.Assembly;
				if (asm != null && asm != owner)
					asm.Modules.Remove(module);
			}
			return module;
		}

		/// <summary>
		/// Gets a list of all <c>File</c> rids that are .NET modules. Call <see cref="ReadModule(uint,AssemblyDef)"/>
		/// to read one of these modules.
		/// </summary>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		internal RidList GetModuleRidList() {
			if (moduleRidList == null)
				InitializeModuleList();
			return moduleRidList;
		}

		void InitializeModuleList() {
			if (moduleRidList != null)
				return;
			uint rows = TablesStream.FileTable.Rows;
			var newModuleRidList = new RandomRidList((int)rows);

			var baseDir = GetBaseDirectoryOfImage();
			for (uint fileRid = 1; fileRid <= rows; fileRid++) {
				var fileDef = ResolveFile(fileRid);
				if (fileDef == null)
					continue;	// Should never happen
				if (!fileDef.ContainsMetaData)
					continue;
				var pathName = GetValidFilename(baseDir, UTF8String.ToSystemString(fileDef.Name));
				if (pathName != null)
					newModuleRidList.Add(fileRid);
			}
			Interlocked.CompareExchange(ref moduleRidList, newModuleRidList, null);
		}

		/// <summary>
		/// Concatenates the inputs and returns the result if it's a valid path
		/// </summary>
		/// <param name="baseDir">Base dir</param>
		/// <param name="name">File name</param>
		/// <returns>Full path to the file or <c>null</c> if one of the inputs is invalid</returns>
		static string GetValidFilename(string baseDir, string name) {
			if (baseDir == null)
				return null;

			string pathName;
			try {
				if (name.IndexOfAny(Path.GetInvalidPathChars()) >= 0)
					return null;
				pathName = Path.Combine(baseDir, name);
				if (pathName != Path.GetFullPath(pathName))
					return null;
				if (!File.Exists(pathName))
					return null;
			}
			catch {
				return null;
			}

			return pathName;
		}

		/// <summary>
		/// Gets the base directory where this .NET module is located on disk
		/// </summary>
		/// <returns>Base directory or <c>null</c> if unknown or if an error occurred</returns>
		string GetBaseDirectoryOfImage() {
			var imageFileName = Location;
			if (string.IsNullOrEmpty(imageFileName))
				return null;
			try {
				return Path.GetDirectoryName(imageFileName);
			}
			catch (IOException) {
			}
			catch (ArgumentException) {
			}
			return null;
		}

		/// <summary>
		/// Creates a <see cref="Resource"/> instance
		/// </summary>
		/// <param name="rid"><c>ManifestResource</c> rid</param>
		/// <returns>A new <see cref="Resource"/> instance</returns>
		Resource CreateResource(uint rid) {
			var row = TablesStream.ReadManifestResourceRow(rid);
			if (row == null)
				return new EmbeddedResource(UTF8String.Empty, MemoryImageStream.CreateEmpty(), 0) { Rid = rid };

			MDToken token;
			if (!CodedToken.Implementation.Decode(row.Implementation, out token))
				return new EmbeddedResource(UTF8String.Empty, MemoryImageStream.CreateEmpty(), 0) { Rid = rid };

			var mr = ResolveManifestResource(rid);
			if (mr == null)
				return new EmbeddedResource(UTF8String.Empty, MemoryImageStream.CreateEmpty(), 0) { Rid = rid };

			if (token.Rid == 0)
				return new EmbeddedResource(mr.Name, CreateResourceStream(mr.Offset), mr.Flags) { Rid = rid, Offset = mr.Offset };

			var file = mr.Implementation as FileDef;
			if (file != null)
				return new LinkedResource(mr.Name, file, mr.Flags) { Rid = rid, Offset = mr.Offset };

			var asmRef = mr.Implementation as AssemblyRef;
			if (asmRef != null)
				return new AssemblyLinkedResource(mr.Name, asmRef, mr.Flags) { Rid = rid, Offset = mr.Offset };

			return new EmbeddedResource(mr.Name, MemoryImageStream.CreateEmpty(), mr.Flags) { Rid = rid, Offset = mr.Offset };
		}

		/// <summary>
		/// Creates a resource stream that can access part of the resource section of this module
		/// </summary>
		/// <param name="offset">Offset of resource relative to the .NET resources section</param>
		/// <returns>A stream the size of the resource</returns>
		[SecurityCritical]	// Req'd on .NET 4.0
		IImageStream CreateResourceStream(uint offset) {
			IImageStream fs = null, imageStream = null;
			try {
				var peImage = metaData.PEImage;
				var cor20Header = metaData.ImageCor20Header;
				var resources = cor20Header.Resources;
				if (resources.VirtualAddress == 0 || resources.Size == 0)
					return MemoryImageStream.CreateEmpty();
				fs = peImage.CreateFullStream();

				var resourceOffset = (long)peImage.ToFileOffset(resources.VirtualAddress);
				if (resourceOffset <= 0 || resourceOffset + offset < resourceOffset)
					return MemoryImageStream.CreateEmpty();
				if (offset + 3 <= offset || offset + 3 >= resources.Size)
					return MemoryImageStream.CreateEmpty();
				if (resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length)
					return MemoryImageStream.CreateEmpty();
				fs.Position = resourceOffset + offset;
				uint length = fs.ReadUInt32();	// Could throw
				if (length == 0 || fs.Position + length - 1 < fs.Position || fs.Position + length - 1 >= fs.Length)
					return MemoryImageStream.CreateEmpty();
				if (fs.Position - resourceOffset + length - 1 >= resources.Size)
					return MemoryImageStream.CreateEmpty();

				imageStream = peImage.CreateStream((FileOffset)fs.Position, length);
				if (peImage.MayHaveInvalidAddresses) {
					for (; imageStream.Position < imageStream.Length; imageStream.Position += 0x1000)
						imageStream.ReadByte();	// Could throw
					imageStream.Position = imageStream.Length - 1;	// length is never 0 if we're here
					imageStream.ReadByte();	// Could throw
					imageStream.Position = 0;
				}
			}
			catch (AccessViolationException) {
				if (imageStream != null)
					imageStream.Dispose();
				return MemoryImageStream.CreateEmpty();
			}
			finally {
				if (fs != null)
					fs.Dispose();
			}
			return imageStream;
		}

		/// <summary>
		/// Reads a <see cref="CustomAttribute"/>
		/// </summary>
		/// <param name="caRid">Custom attribute rid</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance or <c>null</c> if
		/// <paramref name="caRid"/> is invalid</returns>
		public CustomAttribute ReadCustomAttribute(uint caRid) {
			return ReadCustomAttribute(caRid, new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="CustomAttribute"/>
		/// </summary>
		/// <param name="caRid">Custom attribute rid</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance or <c>null</c> if
		/// <paramref name="caRid"/> is invalid</returns>
		public CustomAttribute ReadCustomAttribute(uint caRid, GenericParamContext gpContext) {
			var caRow = TablesStream.ReadCustomAttributeRow(caRid);
			if (caRow == null)
				return null;
			return CustomAttributeReader.Read(this, ResolveCustomAttributeType(caRow.Type, gpContext), caRow.Value, gpContext);
		}

		/// <summary>
		/// Reads data somewhere in the address space of the image
		/// </summary>
		/// <param name="rva">RVA of data</param>
		/// <param name="size">Size of data</param>
		/// <returns>All the data or <c>null</c> if <paramref name="rva"/> or <paramref name="size"/>
		/// is invalid</returns>
		public byte[] ReadDataAt(RVA rva, int size) {
			if (size < 0)
				return null;
			var peImage = MetaData.PEImage;
			using (var reader = peImage.CreateStream(rva, size)) {
				if (reader.Length < size)
					return null;
				return reader.ReadBytes(size);
			}
		}

		/// <summary>
		/// Gets the native entry point or 0 if none
		/// </summary>
		public RVA GetNativeEntryPoint() {
			var cor20Header = MetaData.ImageCor20Header;
			if ((cor20Header.Flags & ComImageFlags.NativeEntryPoint) == 0)
				return 0;
			return (RVA)cor20Header.EntryPointToken_or_RVA;
		}

		/// <summary>
		/// Gets the managed entry point (a Method or a File) or null if none
		/// </summary>
		public IManagedEntryPoint GetManagedEntryPoint() {
			var cor20Header = MetaData.ImageCor20Header;
			if ((cor20Header.Flags & ComImageFlags.NativeEntryPoint) != 0)
				return null;
			return ResolveToken(cor20Header.EntryPointToken_or_RVA) as IManagedEntryPoint;
		}

		/// <summary>
		/// Reads a new <see cref="FieldDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="FieldDefMD"/> instance</returns>
		internal FieldDefMD ReadField(uint rid) {
			return new FieldDefMD(this, rid);
		}

		/// <summary>
		/// Reads a new <see cref="MethodDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="MethodDefMD"/> instance</returns>
		internal MethodDefMD ReadMethod(uint rid) {
			return new MethodDefMD(this, rid);
		}

		/// <summary>
		/// Reads a new <see cref="EventDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="EventDefMD"/> instance</returns>
		internal EventDefMD ReadEvent(uint rid) {
			return new EventDefMD(this, rid);
		}

		/// <summary>
		/// Reads a new <see cref="PropertyDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="PropertyDefMD"/> instance</returns>
		internal PropertyDefMD ReadProperty(uint rid) {
			return new PropertyDefMD(this, rid);
		}

		/// <summary>
		/// Reads a new <see cref="ParamDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="ParamDefMD"/> instance</returns>
		internal ParamDefMD ReadParam(uint rid) {
			return new ParamDefMD(this, rid);
		}

		/// <summary>
		/// Reads a new <see cref="GenericParamMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="GenericParamMD"/> instance</returns>
		internal GenericParamMD ReadGenericParam(uint rid) {
			return new GenericParamMD(this, rid);
		}

		/// <summary>
		/// Reads a new <see cref="GenericParamConstraintMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="GenericParamConstraintMD"/> instance</returns>
		internal GenericParamConstraintMD ReadGenericParamConstraint(uint rid) {
			return new GenericParamConstraintMD(this, rid, new GenericParamContext());
		}

		/// <summary>
		/// Reads a new <see cref="GenericParamConstraintMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="GenericParamConstraintMD"/> instance</returns>
		internal GenericParamConstraintMD ReadGenericParamConstraint(uint rid, GenericParamContext gpContext) {
			return new GenericParamConstraintMD(this, rid, gpContext);
		}

		/// <summary>
		/// Reads a method body
		/// </summary>
		/// <param name="method">Method</param>
		/// <param name="rva">Method RVA</param>
		/// <param name="implAttrs">Method impl attrs</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="MethodBody"/> or <c>null</c> if none</returns>
		internal MethodBody ReadMethodBody(MethodDefMD method, RVA rva, MethodImplAttributes implAttrs, GenericParamContext gpContext) {
			MethodBody mb;
			var mDec = methodDecrypter;
			if (mDec != null && mDec.GetMethodBody(method.OrigRid, rva, method.Parameters, gpContext, out mb)) {
				var cilBody = mb as CilBody;
				if (cilBody != null)
					return InitializeBodyFromPdb(method, cilBody);
				return mb;
			}

			if (rva == 0)
				return null;
			var codeType = implAttrs & MethodImplAttributes.CodeTypeMask;
			if (codeType == MethodImplAttributes.IL)
				return InitializeBodyFromPdb(method, ReadCilBody(method.Parameters, rva, gpContext));
			if (codeType == MethodImplAttributes.Native)
				return new NativeMethodBody(rva);
			return null;
		}

		/// <summary>
		/// Updates <paramref name="body"/> with the PDB info (if any)
		/// </summary>
		/// <param name="method">Owner method</param>
		/// <param name="body">Method body</param>
		/// <returns>Returns originak <paramref name="body"/> value</returns>
		CilBody InitializeBodyFromPdb(MethodDefMD method, CilBody body) {
			var ps = pdbState;
			if (ps != null)
				ps.InitializeMethodBody(this, method, body);
			return body;
		}

		internal void InitializeCustomDebugInfos(MethodDefMD method, CilBody body, IList<PdbCustomDebugInfo> customDebugInfos) {
			if (body == null)
				return;

			var ps = pdbState;
			if (ps != null)
				ps.InitializeCustomDebugInfos(method, body, customDebugInfos);
		}

		/// <summary>
		/// Reads a string from the #US heap
		/// </summary>
		/// <param name="token">String token</param>
		/// <returns>A non-null string</returns>
		public string ReadUserString(uint token) {
			var sDec = stringDecrypter;
			if (sDec != null) {
				var s = sDec.ReadUserString(token);
				if (s != null)
					return s;
			}
			return USStream.ReadNoNull(token & 0x00FFFFFF);
		}

		internal MethodExportInfo GetExportInfo(uint methodRid) {
			if (methodExportInfoProvider == null)
				InitializeMethodExportInfoProvider();
			return methodExportInfoProvider.GetMethodExportInfo(0x06000000 + methodRid);
		}

		void InitializeMethodExportInfoProvider() {
			Interlocked.CompareExchange(ref methodExportInfoProvider, new MethodExportInfoProvider(this), null);
		}
		MethodExportInfoProvider methodExportInfoProvider;

		/// <summary>
		/// Writes the mixed-mode module to a file on disk. If the file exists, it will be overwritten.
		/// </summary>
		/// <param name="filename">Filename</param>
		public void NativeWrite(string filename) {
			NativeWrite(filename, null);
		}

		/// <summary>
		/// Writes the mixed-mode module to a file on disk. If the file exists, it will be overwritten.
		/// </summary>
		/// <param name="filename">Filename</param>
		/// <param name="options">Writer options</param>
		public void NativeWrite(string filename, DNW.NativeModuleWriterOptions options) {
			var writer = new DNW.NativeModuleWriter(this, options ?? new DNW.NativeModuleWriterOptions(this));
			writer.Write(filename);
		}

		/// <summary>
		/// Writes the mixed-mode module to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		public void NativeWrite(Stream dest) {
			NativeWrite(dest, null);
		}

		/// <summary>
		/// Writes the mixed-mode module to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		/// <param name="options">Writer options</param>
		public void NativeWrite(Stream dest, DNW.NativeModuleWriterOptions options) {
			var writer = new DNW.NativeModuleWriter(this, options ?? new DNW.NativeModuleWriterOptions(this));
			writer.Write(dest);
		}

		/// <summary>
		/// Reads data from the #Blob. The following columns are returned:
		/// Field.Signature
		/// Method.Signature
		/// MemberRef.Signature
		/// Constant.Value
		/// CustomAttribute.Value
		/// FieldMarshal.NativeType
		/// DeclSecurity.PermissionSet
		/// StandAloneSig.Signature
		/// Property.Type
		/// TypeSpec.Signature
		/// Assembly.PublicKey
		/// AssemblyRef.PublicKeyOrToken
		/// File.HashValue
		/// MethodSpec.Instantiation
		/// </summary>
		/// <param name="token">A token</param>
		/// <returns>The value in the #Blob or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public byte[] ReadBlob(uint token) {
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Field:
				var fieldRow = TablesStream.ReadFieldRow(rid);
				if (fieldRow == null)
					break;
				return BlobStream.Read(fieldRow.Signature);

			case Table.Method:
				var methodRow = TablesStream.ReadMethodRow(rid);
				if (methodRow == null)
					break;
				return BlobStream.Read(methodRow.Signature);

			case Table.MemberRef:
				var mrRow = TablesStream.ReadMemberRefRow(rid);
				if (mrRow == null)
					break;
				return BlobStream.Read(mrRow.Signature);

			case Table.Constant:
				var constRow = TablesStream.ReadConstantRow(rid);
				if (constRow == null)
					break;
				return BlobStream.Read(constRow.Value);

			case Table.CustomAttribute:
				var caRow = TablesStream.ReadCustomAttributeRow(rid);
				if (caRow == null)
					break;
				return BlobStream.Read(caRow.Value);

			case Table.FieldMarshal:
				var fmRow = TablesStream.ReadFieldMarshalRow(rid);
				if (fmRow == null)
					break;
				return BlobStream.Read(fmRow.NativeType);

			case Table.DeclSecurity:
				var dsRow = TablesStream.ReadDeclSecurityRow(rid);
				if (dsRow == null)
					break;
				return BlobStream.Read(dsRow.PermissionSet);

			case Table.StandAloneSig:
				var sasRow = TablesStream.ReadStandAloneSigRow(rid);
				if (sasRow == null)
					break;
				return BlobStream.Read(sasRow.Signature);

			case Table.Property:
				var propRow = TablesStream.ReadPropertyRow(rid);
				if (propRow == null)
					break;
				return BlobStream.Read(propRow.Type);

			case Table.TypeSpec:
				var tsRow = TablesStream.ReadTypeSpecRow(rid);
				if (tsRow == null)
					break;
				return BlobStream.Read(tsRow.Signature);

			case Table.Assembly:
				var asmRow = TablesStream.ReadAssemblyRow(rid);
				if (asmRow == null)
					break;
				return BlobStream.Read(asmRow.PublicKey);

			case Table.AssemblyRef:
				// HashValue is also in the #Blob but the user has to read it some other way
				var asmRefRow = TablesStream.ReadAssemblyRefRow(rid);
				if (asmRefRow == null)
					break;
				return BlobStream.Read(asmRefRow.PublicKeyOrToken);

			case Table.File:
				var fileRow = TablesStream.ReadFileRow(rid);
				if (fileRow == null)
					break;
				return BlobStream.Read(fileRow.HashValue);

			case Table.MethodSpec:
				var msRow = TablesStream.ReadMethodSpecRow(rid);
				if (msRow == null)
					break;
				return BlobStream.Read(msRow.Instantiation);
			}

			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ModuleKind.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Module kind
	/// </summary>
	public enum ModuleKind {
		/// <summary>
		/// Console UI module
		/// </summary>
		Console,

		/// <summary>
		/// Windows GUI module
		/// </summary>
		Windows,

		/// <summary>
		/// DLL module
		/// </summary>
		Dll,

		/// <summary>
		/// Netmodule (it has no assembly manifest)
		/// </summary>
		NetModule,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ModuleLoader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.IO;
using dnlib.PE;
using dnlib.Threading;
using dnlib.W32Resources;

namespace dnlib.DotNet {
	struct ModuleLoader {
		readonly ModuleDef module;
		readonly ICancellationToken cancellationToken;
		readonly Dictionary<object, bool> seen;
		readonly Stack<object> stack;

		ModuleLoader(ModuleDef module, ICancellationToken cancellationToken) {
			const int CAPACITY = 0x4000;
			this.module = module;
			this.cancellationToken = cancellationToken;
			this.seen = new Dictionary<object, bool>(CAPACITY);
			this.stack = new Stack<object>(CAPACITY);
		}

		public static void LoadAll(ModuleDef module, ICancellationToken cancellationToken) {
			new ModuleLoader(module, cancellationToken).Load();
		}

		void Add(UTF8String a) { }
		void Add(Guid? a) { }
		void Add(ushort a) { }
		void Add(AssemblyHashAlgorithm a) { }
		void Add(Version a) { }
		void Add(AssemblyAttributes a) { }
		void Add(PublicKeyBase a) { }
		void Add(RVA a) { }
		void Add(IManagedEntryPoint a) { }
		void Add(string a) { }
		void Add(WinMDStatus a) { }
		void Add(TypeAttributes a) { }
		void Add(FieldAttributes a) { }
		void Add(uint? a) { }
		void Add(byte[] a) { }
		void Add(MethodImplAttributes a) { }
		void Add(MethodAttributes a) { }
		void Add(MethodSemanticsAttributes a) { }
		void Add(ParamAttributes a) { }
		void Add(ElementType a) { }
		void Add(SecurityAction a) { }
		void Add(EventAttributes a) { }
		void Add(PropertyAttributes a) { }
		void Add(PInvokeAttributes a) { }
		void Add(FileAttributes a) { }
		void Add(ManifestResourceAttributes a) { }
		void Add(GenericParamAttributes a) { }
		void Add(NativeType a) { }

		void Load() {
			LoadAllTables();
			Load(module);
			Process();
		}

		void Process() {
			while (stack.Count != 0) {
				if (cancellationToken != null)
					cancellationToken.ThrowIfCancellationRequested();
				var o = stack.Pop();
				LoadObj(o);
			}
		}

		void LoadAllTables() {
			var resolver = module as ITokenResolver;
			if (resolver == null)
				return;
			for (Table tbl = 0; tbl <= Table.GenericParamConstraint; tbl++) {
				for (uint rid = 1; ; rid++) {
					var o = resolver.ResolveToken(new MDToken(tbl, rid).Raw, new GenericParamContext());
					if (o == null)
						break;
					Add(o);
					Process();
				}
			}
		}

		void LoadObj(object o) {
			var ts = o as TypeSig;
			if (ts != null) {
				Load(ts);
				return;
			}

			var mdt = o as IMDTokenProvider;
			if (mdt != null) {
				Load(mdt);
				return;
			}

			var ca = o as CustomAttribute;
			if (ca != null) {
				Load(ca);
				return;
			}

			var sa = o as SecurityAttribute;
			if (sa != null) {
				Load(sa);
				return;
			}

			var na = o as CANamedArgument;
			if (na != null) {
				Load(na);
				return;
			}

			var p = o as Parameter;
			if (p != null) {
				Load(p);
				return;
			}

			var pdbMethod = o as PdbMethod;
			if (pdbMethod != null) {
				Load(pdbMethod);
				return;
			}

			var rd = o as ResourceDirectory;
			if (rd != null) {
				Load(rd);
				return;
			}

			var rdata = o as ResourceData;
			if (rdata != null) {
				Load(rdata);
				return;
			}

			Debug.Fail("Unknown type");
		}

		void Load(TypeSig ts) {
			if (ts == null)
				return;
			Add(ts.Next);

			switch (ts.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.ValueType:
			case ElementType.Class:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
				Add(((TypeDefOrRefSig)ts).TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
				var vsig = (GenericSig)ts;
				Add(vsig.OwnerType);
				Add(vsig.OwnerMethod);
				break;

			case ElementType.GenericInst:
				var gis = (GenericInstSig)ts;
				Add(gis.GenericType);
				Add(gis.GenericArguments);
				break;

			case ElementType.FnPtr:
				var fpsig = (FnPtrSig)ts;
				Add(fpsig.Signature);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				var cmod = (ModifierSig)ts;
				Add(cmod.Modifier);
				break;

			case ElementType.End:
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.ValueArray:
			case ElementType.SZArray:
			case ElementType.Module:
			case ElementType.Pinned:
			case ElementType.Sentinel:
			case ElementType.R:
			case ElementType.Internal:
			default:
				break;
			}
		}

		void Load(IMDTokenProvider mdt) {
			if (mdt == null)
				return;
			switch (mdt.MDToken.Table) {
			case Table.Module:					Load((ModuleDef)mdt); break;
			case Table.TypeRef:					Load((TypeRef)mdt); break;
			case Table.TypeDef:					Load((TypeDef)mdt); break;
			case Table.Field:					Load((FieldDef)mdt); break;
			case Table.Method:					Load((MethodDef)mdt); break;
			case Table.Param:					Load((ParamDef)mdt); break;
			case Table.InterfaceImpl:			Load((InterfaceImpl)mdt); break;
			case Table.MemberRef:				Load((MemberRef)mdt); break;
			case Table.Constant:				Load((Constant)mdt); break;
			case Table.DeclSecurity:			Load((DeclSecurity)mdt); break;
			case Table.ClassLayout:				Load((ClassLayout)mdt); break;
			case Table.StandAloneSig:			Load((StandAloneSig)mdt); break;
			case Table.Event:					Load((EventDef)mdt); break;
			case Table.Property:				Load((PropertyDef)mdt); break;
			case Table.ModuleRef:				Load((ModuleRef)mdt); break;
			case Table.TypeSpec:				Load((TypeSpec)mdt); break;
			case Table.ImplMap:					Load((ImplMap)mdt); break;
			case Table.Assembly:				Load((AssemblyDef)mdt); break;
			case Table.AssemblyRef:				Load((AssemblyRef)mdt); break;
			case Table.File:					Load((FileDef)mdt); break;
			case Table.ExportedType:			Load((ExportedType)mdt); break;
			case Table.GenericParam:			Load((GenericParam)mdt); break;
			case Table.MethodSpec:				Load((MethodSpec)mdt); break;
			case Table.GenericParamConstraint:	Load((GenericParamConstraint)mdt); break;

			case Table.ManifestResource:
				var rsrc = mdt as Resource;
				if (rsrc != null) {
					Load(rsrc);
					break;
				}

				var mr = mdt as ManifestResource;
				if (mr != null) {
					Load(mr);
					break;
				}

				Debug.Fail("Unknown ManifestResource");
				break;

			case Table.FieldPtr:
			case Table.MethodPtr:
			case Table.ParamPtr:
			case Table.CustomAttribute:
			case Table.FieldMarshal:
			case Table.FieldLayout:
			case Table.EventMap:
			case Table.EventPtr:
			case Table.PropertyMap:
			case Table.PropertyPtr:
			case Table.MethodSemantics:
			case Table.MethodImpl:
			case Table.FieldRVA:
			case Table.ENCLog:
			case Table.ENCMap:
			case Table.AssemblyProcessor:
			case Table.AssemblyOS:
			case Table.AssemblyRefProcessor:
			case Table.AssemblyRefOS:
			case Table.NestedClass:
			case Table.Document:
			case Table.MethodDebugInformation:
			case Table.LocalScope:
			case Table.LocalVariable:
			case Table.LocalConstant:
			case Table.ImportScope:
			case Table.StateMachineMethod:
			case Table.CustomDebugInformation:
				break;

			default:
				Debug.Fail("Unknown type");
				break;
			}
		}

		void Load(ModuleDef obj) {
			if (obj == null || obj != this.module)
				return;
			Add(obj.Generation);
			Add(obj.Name);
			Add(obj.Mvid);
			Add(obj.EncId);
			Add(obj.EncBaseId);
			Add(obj.CustomAttributes);
			Add(obj.Assembly);
			Add(obj.Types);
			Add(obj.ExportedTypes);
			Add(obj.NativeEntryPoint);
			Add(obj.ManagedEntryPoint);
			Add(obj.Resources);
			Add(obj.VTableFixups);
			Add(obj.Location);
			Add(obj.Win32Resources);
			Add(obj.RuntimeVersion);
			Add(obj.WinMDStatus);
			Add(obj.RuntimeVersionWinMD);
			Add(obj.WinMDVersion);
			Add(obj.PdbState);
		}

		void Load(TypeRef obj) {
			if (obj == null)
				return;
			Add(obj.ResolutionScope);
			Add(obj.Name);
			Add(obj.Namespace);
			Add(obj.CustomAttributes);
		}

		void Load(TypeDef obj) {
			if (obj == null)
				return;
			Add(obj.Module2);
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Namespace);
			Add(obj.BaseType);
			Add(obj.Fields);
			Add(obj.Methods);
			Add(obj.GenericParameters);
			Add(obj.Interfaces);
			Add(obj.DeclSecurities);
			Add(obj.ClassLayout);
			Add(obj.DeclaringType);
			Add(obj.DeclaringType2);
			Add(obj.NestedTypes);
			Add(obj.Events);
			Add(obj.Properties);
			Add(obj.CustomAttributes);
		}

		void Load(FieldDef obj) {
			if (obj == null)
				return;
			Add(obj.CustomAttributes);
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Signature);
			Add(obj.FieldOffset);
			Add(obj.MarshalType);
			Add(obj.RVA);
			Add(obj.InitialValue);
			Add(obj.ImplMap);
			Add(obj.Constant);
			Add(obj.DeclaringType);
		}

		void Load(MethodDef obj) {
			if (obj == null)
				return;
			Add(obj.RVA);
			Add(obj.ImplAttributes);
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Signature);
			Add(obj.ParamDefs);
			Add(obj.GenericParameters);
			Add(obj.DeclSecurities);
			Add(obj.ImplMap);
			Add(obj.MethodBody);
			Add(obj.CustomAttributes);
			Add(obj.Overrides);
			Add(obj.DeclaringType);
			Add(obj.Parameters);
			Add(obj.SemanticsAttributes);
		}

		void Load(ParamDef obj) {
			if (obj == null)
				return;
			Add(obj.DeclaringMethod);
			Add(obj.Attributes);
			Add(obj.Sequence);
			Add(obj.Name);
			Add(obj.MarshalType);
			Add(obj.Constant);
			Add(obj.CustomAttributes);
		}

		void Load(InterfaceImpl obj) {
			if (obj == null)
				return;
			Add(obj.Interface);
			Add(obj.CustomAttributes);
		}

		void Load(MemberRef obj) {
			if (obj == null)
				return;
			Add(obj.Class);
			Add(obj.Name);
			Add(obj.Signature);
			Add(obj.CustomAttributes);
		}

		void Load(Constant obj) {
			if (obj == null)
				return;
			Add(obj.Type);
			var o = obj.Value;
		}

		void Load(DeclSecurity obj) {
			if (obj == null)
				return;
			Add(obj.Action);
			Add(obj.SecurityAttributes);
			Add(obj.CustomAttributes);
			obj.GetBlob();
		}

		void Load(ClassLayout obj) {
			if (obj == null)
				return;
			Add(obj.PackingSize);
			Add(obj.ClassSize);
		}

		void Load(StandAloneSig obj) {
			if (obj == null)
				return;
			Add(obj.Signature);
			Add(obj.CustomAttributes);
		}

		void Load(EventDef obj) {
			if (obj == null)
				return;
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.EventType);
			Add(obj.CustomAttributes);
			Add(obj.AddMethod);
			Add(obj.InvokeMethod);
			Add(obj.RemoveMethod);
			Add(obj.OtherMethods);
			Add(obj.DeclaringType);
		}

		void Load(PropertyDef obj) {
			if (obj == null)
				return;
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Type);
			Add(obj.Constant);
			Add(obj.CustomAttributes);
			Add(obj.GetMethods);
			Add(obj.SetMethods);
			Add(obj.OtherMethods);
			Add(obj.DeclaringType);
		}

		void Load(ModuleRef obj) {
			if (obj == null)
				return;
			Add(obj.Name);
			Add(obj.CustomAttributes);
		}

		void Load(TypeSpec obj) {
			if (obj == null)
				return;
			Add(obj.TypeSig);
			Add(obj.ExtraData);
			Add(obj.CustomAttributes);
		}

		void Load(ImplMap obj) {
			if (obj == null)
				return;
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Module);
		}

		void Load(AssemblyDef obj) {
			if (obj == null)
				return;
			if (obj.ManifestModule != module)
				return;
			Add(obj.HashAlgorithm);
			Add(obj.Version);
			Add(obj.Attributes);
			Add(obj.PublicKey);
			Add(obj.Name);
			Add(obj.Culture);
			Add(obj.DeclSecurities);
			Add(obj.Modules);
			Add(obj.CustomAttributes);
		}

		void Load(AssemblyRef obj) {
			if (obj == null)
				return;
			Add(obj.Version);
			Add(obj.Attributes);
			Add(obj.PublicKeyOrToken);
			Add(obj.Name);
			Add(obj.Culture);
			Add(obj.Hash);
			Add(obj.CustomAttributes);
		}

		void Load(FileDef obj) {
			if (obj == null)
				return;
			Add(obj.Flags);
			Add(obj.Name);
			Add(obj.HashValue);
			Add(obj.CustomAttributes);
		}

		void Load(ExportedType obj) {
			if (obj == null)
				return;
			Add(obj.CustomAttributes);
			Add(obj.Attributes);
			Add(obj.TypeDefId);
			Add(obj.TypeName);
			Add(obj.TypeNamespace);
			Add(obj.Implementation);
		}

		void Load(Resource obj) {
			if (obj == null)
				return;

			Add(obj.Offset);
			Add(obj.Name);
			Add(obj.Attributes);

			switch (obj.ResourceType) {
			case ResourceType.Embedded:
				var er = (EmbeddedResource)obj;
				// Make sure data is cached
				if (!(er.Data is MemoryImageStream))
					er.Data = MemoryImageStream.Create(er.GetClonedResourceStream().ReadAllBytes());
				break;

			case ResourceType.AssemblyLinked:
				var ar = (AssemblyLinkedResource)obj;
				Add(ar.Assembly);
				break;

			case ResourceType.Linked:
				var lr = (LinkedResource)obj;
				Add(lr.File);
				Add(lr.Hash);
				break;

			default:
				Debug.Fail("Unknown resource");
				break;
			}
		}

		void Load(ManifestResource obj) {
			if (obj == null)
				return;
			Add(obj.Offset);
			Add(obj.Flags);
			Add(obj.Name);
			Add(obj.Implementation);
			Add(obj.CustomAttributes);
		}

		void Load(GenericParam obj) {
			if (obj == null)
				return;
			Add(obj.Owner);
			Add(obj.Number);
			Add(obj.Flags);
			Add(obj.Name);
			Add(obj.Kind);
			Add(obj.GenericParamConstraints);
			Add(obj.CustomAttributes);
		}

		void Load(MethodSpec obj) {
			if (obj == null)
				return;
			Add(obj.Method);
			Add(obj.Instantiation);
			Add(obj.CustomAttributes);
		}

		void Load(GenericParamConstraint obj) {
			if (obj == null)
				return;
			Add(obj.Owner);
			Add(obj.Constraint);
			Add(obj.CustomAttributes);
		}

		void Load(CANamedArgument obj) {
			if (obj == null)
				return;
			Add(obj.Type);
			Add(obj.Name);
			Load(obj.Argument);
		}

		void Load(Parameter obj) {
			if (obj == null)
				return;
			Add(obj.Type);
		}

		void Load(SecurityAttribute obj) {
			if (obj == null)
				return;
			Add(obj.AttributeType);
			Add(obj.NamedArguments);
		}

		void Load(CustomAttribute obj) {
			if (obj == null)
				return;
			Add(obj.Constructor);
			Add(obj.RawData);
			Add(obj.ConstructorArguments);
			Add(obj.NamedArguments);
		}

		void Load(MethodOverride obj) {
			Add(obj.MethodBody);
			Add(obj.MethodDeclaration);
		}

		void AddCAValue(object obj) {
			if (obj is CAArgument) {
				Load((CAArgument)obj);
				return;
			}

			var list = obj as IList<CAArgument>;
			if (list != null) {
				Add(list);
				return;
			}

			var md = obj as IMDTokenProvider;
			if (md != null) {
				Add(md);
				return;
			}
		}

		void Load(CAArgument obj) {
			Add(obj.Type);
			AddCAValue(obj.Value);
		}

		void Load(PdbMethod obj) { }

		void Load(ResourceDirectory obj) {
			if (obj == null)
				return;
			Add(obj.Directories);
			Add(obj.Data);
		}

		void Load(ResourceData obj) {
			if (obj == null)
				return;
			var data = obj.Data;
			if (data != null && !(data is MemoryImageStream))
				obj.Data = MemoryImageStream.Create(data.ReadAllBytes());
		}

		void AddToStack<T>(T t) where T : class {
			if (t == null)
				return;
			if (seen.ContainsKey(t))
				return;
			seen[t] = true;
			stack.Push(t);
		}

		void Add(CustomAttribute obj) {
			AddToStack(obj);
		}

		void Add(SecurityAttribute obj) {
			AddToStack(obj);
		}

		void Add(CANamedArgument obj) {
			AddToStack(obj);
		}

		void Add(Parameter obj) {
			AddToStack(obj);
		}

		void Add(IMDTokenProvider o) {
			AddToStack(o);
		}

		void Add(PdbMethod pdbMethod) { }

		void Add(TypeSig ts) {
			AddToStack(ts);
		}

		void Add(ResourceDirectory rd) {
			AddToStack(rd);
		}

		void Add(ResourceData rd) {
			AddToStack(rd);
		}

		void Add<T>(IList<T> list) where T : IMDTokenProvider {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<TypeSig> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<CustomAttribute> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<SecurityAttribute> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<MethodOverride> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Load(item);
		}

		void Add(IList<CAArgument> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Load(item);
		}

		void Add(IList<CANamedArgument> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(ParameterList list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<Instruction> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<ExceptionHandler> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<Local> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<ResourceDirectory> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(IList<ResourceData> list) {
			if (list == null)
				return;
			foreach (var item in list.GetSafeEnumerable())
				Add(item);
		}

		void Add(VTableFixups vtf) {
			if (vtf == null)
				return;
			foreach (var fixup in vtf) {
				foreach (var method in fixup)
					Add(method);
			}
		}

		void Add(Win32Resources vtf) {
			if (vtf == null)
				return;
			Add(vtf.Root);
		}

		void Add(CallingConventionSig sig) {
			var msig = sig as MethodBaseSig;
			if (msig != null) {
				Add(msig);
				return;
			}

			var fsig = sig as FieldSig;
			if (fsig != null) {
				Add(fsig);
				return;
			}

			var lsig = sig as LocalSig;
			if (lsig != null) {
				Add(lsig);
				return;
			}

			var gsig = sig as GenericInstMethodSig;
			if (gsig != null) {
				Add(gsig);
				return;
			}

			Debug.Assert(sig == null);
		}

		void Add(MethodBaseSig msig) {
			if (msig == null)
				return;
			Add(msig.ExtraData);
			Add(msig.RetType);
			Add(msig.Params);
			Add(msig.ParamsAfterSentinel);
		}

		void Add(FieldSig fsig) {
			if (fsig == null)
				return;
			Add(fsig.ExtraData);
			Add(fsig.Type);
		}

		void Add(LocalSig lsig) {
			if (lsig == null)
				return;
			Add(lsig.ExtraData);
			Add(lsig.Locals);
		}

		void Add(GenericInstMethodSig gsig) {
			if (gsig == null)
				return;
			Add(gsig.ExtraData);
			Add(gsig.GenericArguments);
		}

		void Add(MarshalType mt) {
			if (mt == null)
				return;
			Add(mt.NativeType);
		}

		void Add(MethodBody mb) {
			var cilBody = mb as CilBody;
			if (cilBody != null) {
				Add(cilBody);
				return;
			}

			var nb = mb as NativeMethodBody;
			if (nb != null) {
				Add(nb);
				return;
			}

			Debug.Assert(mb == null, "Unknown method body");
		}

		void Add(NativeMethodBody body) {
			if (body == null)
				return;
			Add(body.RVA);
		}

		void Add(CilBody body) {
			if (body == null)
				return;
			Add(body.Instructions);
			Add(body.ExceptionHandlers);
			Add(body.Variables);
			Add(body.PdbMethod);
		}

		void Add(Instruction instr) {
			if (instr == null)
				return;

			var mdt = instr.Operand as IMDTokenProvider;
			if (mdt != null) {
				Add(mdt);
				return;
			}

			var p = instr.Operand as Parameter;
			if (p != null) {
				Add(p);
				return;
			}

			var l = instr.Operand as Local;
			if (l != null) {
				Add(l);
				return;
			}

			var csig = instr.Operand as CallingConventionSig;
			if (csig != null) {
				Add(csig);
				return;
			}
		}

		void Add(ExceptionHandler eh) {
			if (eh == null)
				return;
			Add(eh.CatchType);
		}

		void Add(Local local) {
			if (local == null)
				return;
			Add(local.Type);
		}

		void Add(PdbState state) {
			if (state == null)
				return;
			Add(state.UserEntryPoint);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ModuleRef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ModuleRef table
	/// </summary>
	public abstract class ModuleRef : IHasCustomAttribute, IMemberRefParent, IHasCustomDebugInformation, IResolutionScope, IModule, IOwnerModule {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <summary>
		/// The owner module
		/// </summary>
		protected ModuleDef module;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.ModuleRef, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 12; }
		}

		/// <inheritdoc/>
		public int MemberRefParentTag {
			get { return 2; }
		}

		/// <inheritdoc/>
		public int ResolutionScopeTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public ScopeType ScopeType {
			get { return ScopeType.ModuleRef; }
		}

		/// <inheritdoc/>
		public string ScopeName {
			get { return FullName; }
		}

		/// <summary>
		/// From column ModuleRef.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 12; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get { return module; }
		}

		/// <summary>
		/// Gets the definition module, i.e., the module which it references, or <c>null</c>
		/// if the module can't be found.
		/// </summary>
		public ModuleDef DefinitionModule {
			get {
				if (module == null)
					return null;
				var n = name;
				if (UTF8String.CaseInsensitiveEquals(n, module.Name))
					return module;
				var asm = DefinitionAssembly;
				return asm == null ? null : asm.FindModule(n);
			}
		}

		/// <summary>
		/// Gets the definition assembly, i.e., the assembly of the module it references, or
		/// <c>null</c> if the assembly can't be found.
		/// </summary>
		public AssemblyDef DefinitionAssembly {
			get { return module == null ? null : module.Assembly; }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return UTF8String.ToSystemStringOrEmpty(name); }
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A ModuleRef row created by the user and not present in the original .NET file
	/// </summary>
	public class ModuleRefUser : ModuleRef {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		public ModuleRefUser(ModuleDef module)
			: this(module, UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Module name</param>
		public ModuleRefUser(ModuleDef module, UTF8String name) {
			this.module = module;
			this.name = name;
		}
	}

	/// <summary>
	/// Created from a row in the ModuleRef table
	/// </summary>
	sealed class ModuleRefMD : ModuleRef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.ModuleRef, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ModuleRef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ModuleRefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ModuleRefTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("ModuleRef rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.module = readerModule;
			uint name = readerModule.TablesStream.ReadModuleRefRow2(origRid);
			this.name = readerModule.StringsStream.ReadNoNull(name);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/NativeType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet {
	/// <summary>
	/// Native types used by field marshals. See CorHdr.h/CorNativeType
	/// </summary>
	public enum NativeType : uint {
		/// <summary>Deprecated</summary>
		End					= 0x00,
		/// <summary>void</summary>
		Void				= 0x01,
		/// <summary>bool</summary>
		Boolean				= 0x02,
		/// <summary>int8</summary>
		I1					= 0x03,
		/// <summary>unsigned int8</summary>
		U1					= 0x04,
		/// <summary>int16</summary>
		I2					= 0x05,
		/// <summary>unsigned int16</summary>
		U2					= 0x06,
		/// <summary>int32</summary>
		I4					= 0x07,
		/// <summary>unsigned int32</summary>
		U4					= 0x08,
		/// <summary>int64</summary>
		I8					= 0x09,
		/// <summary>unsigned int64</summary>
		U8					= 0x0A,
		/// <summary>float32</summary>
		R4					= 0x0B,
		/// <summary>float64</summary>
		R8					= 0x0C,
		/// <summary>syschar</summary>
		SysChar				= 0x0D,
		/// <summary>variant</summary>
		Variant				= 0x0E,
		/// <summary>currency</summary>
		Currency			= 0x0F,
		/// <summary>ptr</summary>
		Ptr					= 0x10,
		/// <summary>decimal</summary>
		Decimal				= 0x11,
		/// <summary>date</summary>
		Date				= 0x12,
		/// <summary>bstr</summary>
		BStr				= 0x13,
		/// <summary>lpstr</summary>
		LPStr				= 0x14,
		/// <summary>lpwstr</summary>
		LPWStr				= 0x15,
		/// <summary>lptstr</summary>
		LPTStr				= 0x16,
		/// <summary>fixed sysstring</summary>
		FixedSysString		= 0x17,
		/// <summary>objectref</summary>
		ObjectRef			= 0x18,
		/// <summary>iunknown</summary>
		IUnknown			= 0x19,
		/// <summary>idispatch</summary>
		IDispatch			= 0x1A,
		/// <summary>struct</summary>
		Struct				= 0x1B,
		/// <summary>interface</summary>
		IntF				= 0x1C,
		/// <summary>safearray</summary>
		SafeArray			= 0x1D,
		/// <summary>fixed array</summary>
		FixedArray			= 0x1E,
		/// <summary>int</summary>
		Int					= 0x1F,
		/// <summary>uint</summary>
		UInt				= 0x20,
		/// <summary>nested struct</summary>
		NestedStruct		= 0x21,
		/// <summary>byvalstr</summary>
		ByValStr			= 0x22,
		/// <summary>ansi bstr</summary>
		ANSIBStr			= 0x23,
		/// <summary>tbstr</summary>
		TBStr				= 0x24,
		/// <summary>variant bool</summary>
		VariantBool			= 0x25,
		/// <summary>func</summary>
		Func				= 0x26,
		/// <summary>as any</summary>
		ASAny				= 0x28,
		/// <summary>array</summary>
		Array				= 0x2A,
		/// <summary>lpstruct</summary>
		LPStruct			= 0x2B,
		/// <summary>custom marshaler</summary>
		CustomMarshaler		= 0x2C,
		/// <summary>error</summary>
		Error				= 0x2D,
		/// <summary>iinspectable</summary>
		IInspectable		= 0x2E,
		/// <summary>hstring</summary>
		HString				= 0x2F,
		/// <summary>UTF-8 encoded string</summary>
		LPUTF8Str			= 0x30,
		/// <summary>first invalid element type</summary>
		Max					= 0x50,
		/// <summary>Value wasn't present in the blob</summary>
		NotInitialized		= 0xFFFFFFFE,
		/// <summary>Raw marshal blob type</summary>
		RawBlob				= 0xFFFFFFFF,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/NullResolver.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// A resolver that always fails
	/// </summary>
	public sealed class NullResolver : IAssemblyResolver, IResolver {
		/// <summary>
		/// The one and only instance of this type
		/// </summary>
		public static readonly NullResolver Instance = new NullResolver();

		NullResolver() {
		}

		/// <inheritdoc/>
		public AssemblyDef Resolve(IAssembly assembly, ModuleDef sourceModule) {
			return null;
		}

		/// <inheritdoc/>
		public bool AddToCache(AssemblyDef asm) {
			return true;
		}

		/// <inheritdoc/>
		public bool Remove(AssemblyDef asm) {
			return false;
		}

		/// <inheritdoc/>
		public void Clear() {
		}

		/// <inheritdoc/>
		public TypeDef Resolve(TypeRef typeRef, ModuleDef sourceModule) {
			return null;
		}

		/// <inheritdoc/>
		public IMemberForwarded Resolve(MemberRef memberRef) {
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/PInvokeAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// P/Invoke attributes, see CorHdr.h/CorPinvokeMap
	/// </summary>
	[Flags]
	public enum PInvokeAttributes : ushort {
		/// <summary>Pinvoke is to use the member name as specified.</summary>
		NoMangle			= 0x0001,

		/// <summary>Use this mask to retrieve the CharSet information.</summary>
		CharSetMask			= 0x0006,
		/// <summary/>
		CharSetNotSpec		= 0x0000,
		/// <summary/>
		CharSetAnsi			= 0x0002,
		/// <summary/>
		CharSetUnicode		= 0x0004,
		/// <summary/>
		CharSetAuto			= 0x0006,

		/// <summary/>
		BestFitUseAssem		= 0x0000,
		/// <summary/>
		BestFitEnabled		= 0x0010,
		/// <summary/>
		BestFitDisabled		= 0x0020,
		/// <summary/>
		BestFitMask			= 0x0030,

		/// <summary/>
		ThrowOnUnmappableCharUseAssem	= 0x0000,
		/// <summary/>
		ThrowOnUnmappableCharEnabled	= 0x1000,
		/// <summary/>
		ThrowOnUnmappableCharDisabled	= 0x2000,
		/// <summary/>
		ThrowOnUnmappableCharMask		= 0x3000,

		/// <summary>Information about target function. Not relevant for fields.</summary>
		SupportsLastError	= 0x0040,

		/// <summary/>
		CallConvMask		= 0x0700,
		/// <summary>Pinvoke will use native callconv appropriate to target windows platform.</summary>
		CallConvWinapi		= 0x0100,
		/// <summary/>
		CallConvCdecl		= 0x0200,
		/// <summary/>
		CallConvStdcall		= 0x0300,
		/// <summary/>
		CallConvStdCall		= CallConvStdcall,
		/// <summary>In M9, pinvoke will raise exception.</summary>
		CallConvThiscall	= 0x0400,
		/// <summary/>
		CallConvFastcall	= 0x0500,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ParamAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Parameter flags. See CorHdr.h/CorParamAttr
	/// </summary>
	[Flags]
	public enum ParamAttributes : ushort {
		/// <summary>Param is [In]</summary>
		In					= 0x0001,
		/// <summary>Param is [out]</summary>
		Out					= 0x0002,
		/// <summary>Param is a locale identifier</summary>
		Lcid				= 0x0004,
		/// <summary>Param is a return value</summary>
		Retval				= 0x0008,
		/// <summary>Param is optional</summary>
		Optional			= 0x0010,

		/// <summary>Param has default value.</summary>
		HasDefault			= 0x1000,
		/// <summary>Param has FieldMarshal.</summary>
		HasFieldMarshal		= 0x2000,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ParamDef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Param table
	/// </summary>
	[DebuggerDisplay("{Sequence} {Name}")]
	public abstract class ParamDef : IHasConstant, IHasCustomAttribute, IHasFieldMarshal, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.Param, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasConstantTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 4; }
		}

		/// <inheritdoc/>
		public int HasFieldMarshalTag {
			get { return 1; }
		}

		/// <summary>
		/// Gets the declaring method
		/// </summary>
		public MethodDef DeclaringMethod {
			get { return declaringMethod; }
			internal set { declaringMethod = value; }
		}
		/// <summary/>
		protected MethodDef declaringMethod;

		/// <summary>
		/// From column Param.Flags
		/// </summary>
		public ParamAttributes Attributes {
			get { return (ParamAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Param.Sequence
		/// </summary>
		public ushort Sequence {
			get { return sequence; }
			set { sequence = value; }
		}
		/// <summary/>
		protected ushort sequence;

		/// <summary>
		/// From column Param.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <inheritdoc/>
		public MarshalType MarshalType {
			get {
				if (!marshalType_isInitialized)
					InitializeMarshalType();
				return marshalType;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				marshalType = value;
				marshalType_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected MarshalType marshalType;
		/// <summary/>
		protected bool marshalType_isInitialized;

		void InitializeMarshalType() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (marshalType_isInitialized)
				return;
			marshalType = GetMarshalType_NoLock();
			marshalType_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="marshalType"/></summary>
		protected virtual MarshalType GetMarshalType_NoLock() {
			return null;
		}

		/// <summary>Reset <see cref="MarshalType"/></summary>
		protected void ResetMarshalType() {
			marshalType_isInitialized = false;
		}

		/// <inheritdoc/>
		public Constant Constant {
			get {
				if (!constant_isInitialized)
					InitializeConstant();
				return constant;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				constant = value;
				constant_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Constant constant;
		/// <summary/>
		protected bool constant_isInitialized;

		void InitializeConstant() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (constant_isInitialized)
				return;
			constant = GetConstant_NoLock();
			constant_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="constant"/></summary>
		protected virtual Constant GetConstant_NoLock() {
			return null;
		}

		/// <summary>Reset <see cref="Constant"/></summary>
		protected void ResetConstant() {
			constant_isInitialized = false;
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 4; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// <c>true</c> if <see cref="Constant"/> is not <c>null</c>
		/// </summary>
		public bool HasConstant {
			get { return Constant != null; }
		}

		/// <summary>
		/// Gets the constant element type or <see cref="dnlib.DotNet.ElementType.End"/> if there's no constant
		/// </summary>
		public ElementType ElementType {
			get {
				var c = Constant;
				return c == null ? ElementType.End : c.Type;
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="MarshalType"/> is not <c>null</c>
		/// </summary>
		public bool HasMarshalType {
			get { return MarshalType != null; }
		}

		/// <inheritdoc/>
		public string FullName {
			get {
				var n = name;
				if (UTF8String.IsNullOrEmpty(n))
					return string.Format("A_{0}", sequence);
				return n.String;
			}
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, ParamAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.In"/> bit
		/// </summary>
		public bool IsIn {
			get { return ((ParamAttributes)attributes & ParamAttributes.In) != 0; }
			set { ModifyAttributes(value, ParamAttributes.In); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.Out"/> bit
		/// </summary>
		public bool IsOut {
			get { return ((ParamAttributes)attributes & ParamAttributes.Out) != 0; }
			set { ModifyAttributes(value, ParamAttributes.Out); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.Lcid"/> bit
		/// </summary>
		public bool IsLcid {
			get { return ((ParamAttributes)attributes & ParamAttributes.Lcid) != 0; }
			set { ModifyAttributes(value, ParamAttributes.Lcid); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.Retval"/> bit
		/// </summary>
		public bool IsRetval {
			get { return ((ParamAttributes)attributes & ParamAttributes.Retval) != 0; }
			set { ModifyAttributes(value, ParamAttributes.Retval); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.Optional"/> bit
		/// </summary>
		public bool IsOptional {
			get { return ((ParamAttributes)attributes & ParamAttributes.Optional) != 0; }
			set { ModifyAttributes(value, ParamAttributes.Optional); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.HasDefault"/> bit
		/// </summary>
		public bool HasDefault {
			get { return ((ParamAttributes)attributes & ParamAttributes.HasDefault) != 0; }
			set { ModifyAttributes(value, ParamAttributes.HasDefault); }
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.HasFieldMarshal"/> bit
		/// </summary>
		public bool HasFieldMarshal {
			get { return ((ParamAttributes)attributes & ParamAttributes.HasFieldMarshal) != 0; }
			set { ModifyAttributes(value, ParamAttributes.HasFieldMarshal); }
		}
	}

	/// <summary>
	/// A Param row created by the user and not present in the original .NET file
	/// </summary>
	public class ParamDefUser : ParamDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ParamDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public ParamDefUser(UTF8String name)
			: this(name, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="sequence">Sequence</param>
		public ParamDefUser(UTF8String name, ushort sequence)
			: this(name, sequence, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="sequence">Sequence</param>
		/// <param name="flags">Flags</param>
		public ParamDefUser(UTF8String name, ushort sequence, ParamAttributes flags) {
			this.name = name;
			this.sequence = sequence;
			this.attributes = (int)flags;
		}
	}

	/// <summary>
	/// Created from a row in the Param table
	/// </summary>
	sealed class ParamDefMD : ParamDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override MarshalType GetMarshalType_NoLock() {
			return readerModule.ReadMarshalType(Table.Param, origRid, GenericParamContext.Create(declaringMethod));
		}

		/// <inheritdoc/>
		protected override Constant GetConstant_NoLock() {
			return readerModule.ResolveConstant(readerModule.MetaData.GetConstantRid(Table.Param, origRid));
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.Param, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), GenericParamContext.Create(declaringMethod), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Param</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ParamDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ParamTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("Param rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name = readerModule.TablesStream.ReadParamRow(origRid, out this.attributes, out this.sequence);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.declaringMethod = readerModule.GetOwner(this);
		}

		internal ParamDefMD InitializeAll() {
			MemberMDInitializer.Initialize(DeclaringMethod);
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(Sequence);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(MarshalType);
			MemberMDInitializer.Initialize(Constant);
			MemberMDInitializer.Initialize(CustomAttributes);
			return this;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ParameterList.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A list of all method parameters
	/// </summary>
	[DebuggerDisplay("Count = {Count}")]
	public sealed class ParameterList : ThreadSafe.IList<Parameter> {
		readonly MethodDef method;
		readonly List<Parameter> parameters;
		readonly Parameter hiddenThisParameter;
		ParamDef hiddenThisParamDef;
		readonly Parameter returnParameter;
		int methodSigIndexBase;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Gets the owner method
		/// </summary>
		public MethodDef Method {
			get { return method; }
		}

		/// <summary>
		/// Gets the number of parameters, including a possible hidden 'this' parameter
		/// </summary>
		public int Count {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
					return ((ThreadSafe.IList<Parameter>)this).Count_NoLock;
				} finally { theLock.ExitReadLock(); }
#else
				return parameters.Count;
#endif
			}
		}

		/// <summary>
		/// Gets the index of the first parameter that is present in the method signature.
		/// If this is a static method, the value is 0, else it's an instance method so the
		/// index is 1 since the first parameter is the hidden 'this' parameter.
		/// </summary>
		public int MethodSigIndexBase {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return methodSigIndexBase == 1 ? 1 : 0;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets the N'th parameter
		/// </summary>
		/// <param name="index">The parameter index</param>
		public Parameter this[int index] {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
					return ((ThreadSafe.IList<Parameter>)this).Get_NoLock(index);
				} finally { theLock.ExitReadLock(); }
#else
				return parameters[index];
#endif
			}
			set { throw new NotSupportedException(); }
		}

		/// <summary>
		/// Gets the method return parameter
		/// </summary>
		public Parameter ReturnParameter {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return returnParameter;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The method with all parameters</param>
		/// <param name="declaringType"><paramref name="method"/>'s declaring type</param>
		public ParameterList(MethodDef method, TypeDef declaringType) {
			this.method = method;
			this.parameters = new List<Parameter>();
			this.methodSigIndexBase = -1;
			this.hiddenThisParameter = new Parameter(this, 0, Parameter.HIDDEN_THIS_METHOD_SIG_INDEX);
			this.returnParameter = new Parameter(this, -1, Parameter.RETURN_TYPE_METHOD_SIG_INDEX);
			UpdateThisParameterType(declaringType);
			UpdateParameterTypes();
		}

		/// <summary>
		/// Should be called when the method's declaring type has changed
		/// </summary>
		/// <param name="methodDeclaringType">Method declaring type</param>
		internal void UpdateThisParameterType(TypeDef methodDeclaringType) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (methodDeclaringType == null)
				hiddenThisParameter.SetType(false, null);
			else if (methodDeclaringType.IsValueType)
				hiddenThisParameter.SetType(false, new ByRefSig(new ValueTypeSig(methodDeclaringType)));
			else
				hiddenThisParameter.SetType(false, new ClassSig(methodDeclaringType));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Should be called when the method sig has changed
		/// </summary>
		public void UpdateParameterTypes() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var sig = method.MethodSig;
			if (sig == null) {
				methodSigIndexBase = -1;
				parameters.Clear();
				return;
			}
			if (UpdateThisParameter_NoLock(sig))
				parameters.Clear();
			returnParameter.SetType(false, sig.RetType);
			sig.Params.ExecuteLocked<TypeSig, object, object>(null, (tsList, arg) => {
				ResizeParameters_NoLock(tsList.Count_NoLock() + methodSigIndexBase);
				if (methodSigIndexBase > 0)
					parameters[0] = hiddenThisParameter;
				for (int i = 0; i < tsList.Count_NoLock(); i++)
					parameters[i + methodSigIndexBase].SetType(true, tsList.Get_NoLock(i));
				return null;
			});
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		bool UpdateThisParameter_NoLock(MethodSig methodSig) {
			int newIndex;
			if (methodSig == null)
				newIndex = -1;
			else
				newIndex = methodSig.ImplicitThis ? 1 : 0;
			if (methodSigIndexBase == newIndex)
				return false;
			methodSigIndexBase = newIndex;
			return true;
		}

		void ResizeParameters_NoLock(int length) {
			if (parameters.Count == length)
				return;
			if (parameters.Count < length) {
				for (int i = parameters.Count; i < length; i++)
					parameters.Add(new Parameter(this, i, i - methodSigIndexBase));
			}
			else {
				while (parameters.Count > length)
					parameters.RemoveAt(parameters.Count - 1);
			}
		}

		internal ParamDef FindParamDef(Parameter param) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			return FindParamDef_NoLock(param);
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
		}

		ParamDef FindParamDef_NoLock(Parameter param) {
			int seq;
			if (param.IsReturnTypeParameter)
				seq = 0;
			else if (param.IsNormalMethodParameter)
				seq = param.MethodSigIndex + 1;
			else
				return hiddenThisParamDef;

			foreach (var paramDef in method.ParamDefs.GetSafeEnumerable()) {
				if (paramDef != null && paramDef.Sequence == seq)
					return paramDef;
			}
			return null;
		}

		internal void TypeUpdated(Parameter param, bool noParamsLock) {
			var sig = method.MethodSig;
			if (sig == null)
				return;
			int index = param.MethodSigIndex;
			if (index == Parameter.RETURN_TYPE_METHOD_SIG_INDEX)
				sig.RetType = param.Type;
			else if (index >= 0) {
				if (noParamsLock)
					sig.Params.Set_NoLock(index, param.Type);
				else
					sig.Params.Set(index, param.Type);
			}
		}

		internal void CreateParamDef(Parameter param) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var paramDef = FindParamDef_NoLock(param);
			if (paramDef != null)
				return;
			if (param.IsHiddenThisParameter) {
				hiddenThisParamDef = UpdateRowId_NoLock(new ParamDefUser(UTF8String.Empty, ushort.MaxValue, 0));
				return;
			}
			int seq = param.IsReturnTypeParameter ? 0 : param.MethodSigIndex + 1;
			paramDef = UpdateRowId_NoLock(new ParamDefUser(UTF8String.Empty, (ushort)seq, 0));
			method.ParamDefs.Add(paramDef);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		ParamDef UpdateRowId_NoLock(ParamDef pd) {
			var dt = method.DeclaringType;
			if (dt == null)
				return pd;
			var module = dt.Module;
			if (module == null)
				return pd;
			return module.UpdateRowId(pd);
		}

		/// <inheritdoc/>
		public int IndexOf(Parameter item) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
				return ((ThreadSafe.IList<Parameter>)this).IndexOf_NoLock(item);
			} finally { theLock.ExitReadLock(); }
#else
			return parameters.IndexOf(item);
#endif
		}

		void IList<Parameter>.Insert(int index, Parameter item) {
			throw new NotSupportedException();
		}

		void IList<Parameter>.RemoveAt(int index) {
			throw new NotSupportedException();
		}

		void ICollection<Parameter>.Add(Parameter item) {
			throw new NotSupportedException();
		}

		void ICollection<Parameter>.Clear() {
			throw new NotSupportedException();
		}

		bool ICollection<Parameter>.Contains(Parameter item) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
				return ((ThreadSafe.IList<Parameter>)this).Contains_NoLock(item);
			} finally { theLock.ExitReadLock(); }
#else
			return parameters.Contains(item);
#endif
		}

		void ICollection<Parameter>.CopyTo(Parameter[] array, int arrayIndex) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
				((ThreadSafe.IList<Parameter>)this).CopyTo_NoLock(array, arrayIndex);
			} finally { theLock.ExitReadLock(); }
#else
			parameters.CopyTo(array, arrayIndex);
#endif
		}

		bool ICollection<Parameter>.IsReadOnly {
			get { return true; }
		}

		bool ICollection<Parameter>.Remove(Parameter item) {
			throw new NotSupportedException();
		}

		IEnumerator<Parameter> IEnumerable<Parameter>.GetEnumerator() {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
				return ((ThreadSafe.IList<Parameter>)this).GetEnumerator_NoLock();
			} finally { theLock.ExitReadLock(); }
#else
			return parameters.GetEnumerator();
#endif
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return ((IEnumerable<Parameter>)this).GetEnumerator();
		}

#if THREAD_SAFE
		int ThreadSafe.IList<Parameter>.IndexOf_NoLock(Parameter item) {
			return parameters.IndexOf(item);
		}

		void ThreadSafe.IList<Parameter>.Insert_NoLock(int index, Parameter item) {
			throw new NotSupportedException();
		}

		void ThreadSafe.IList<Parameter>.RemoveAt_NoLock(int index) {
			throw new NotSupportedException();
		}

		Parameter ThreadSafe.IList<Parameter>.Get_NoLock(int index) {
			return parameters[index];
		}

		void ThreadSafe.IList<Parameter>.Set_NoLock(int index, Parameter value) {
			throw new NotSupportedException();
		}

		void ThreadSafe.IList<Parameter>.Add_NoLock(Parameter item) {
			throw new NotSupportedException();
		}

		void ThreadSafe.IList<Parameter>.Clear_NoLock() {
			throw new NotSupportedException();
		}

		bool ThreadSafe.IList<Parameter>.Contains_NoLock(Parameter item) {
			return parameters.Contains(item);
		}

		void ThreadSafe.IList<Parameter>.CopyTo_NoLock(Parameter[] array, int arrayIndex) {
			parameters.CopyTo(array, arrayIndex);
		}

		bool ThreadSafe.IList<Parameter>.Remove_NoLock(Parameter item) {
			throw new NotSupportedException();
		}

		IEnumerator<Parameter> ThreadSafe.IList<Parameter>.GetEnumerator_NoLock() {
			return parameters.GetEnumerator();
		}

		int ThreadSafe.IList<Parameter>.Count_NoLock {
			get { return parameters.Count; }
		}

		bool ThreadSafe.IList<Parameter>.IsReadOnly_NoLock {
			get { return true; }
		}

		TRetType ThreadSafe.IList<Parameter>.ExecuteLocked<TArgType, TRetType>(TArgType arg, ExecuteLockedDelegate<Parameter, TArgType, TRetType> handler) {
			theLock.EnterWriteLock(); try {
				return handler(this, arg);
			} finally { theLock.ExitWriteLock(); }
		}
#endif
	}

	/// <summary>
	/// A method parameter
	/// </summary>
	public sealed class Parameter : IVariable {
		readonly ParameterList parameterList;
		TypeSig typeSig;
		readonly int paramIndex;
		readonly int methodSigIndex;

		/// <summary>
		/// The hidden 'this' parameter's <see cref="MethodSigIndex"/>
		/// </summary>
		public const int HIDDEN_THIS_METHOD_SIG_INDEX = -2;

		/// <summary>
		/// The return type parameter's <see cref="MethodSigIndex"/>
		/// </summary>
		public const int RETURN_TYPE_METHOD_SIG_INDEX = -1;

		/// <summary>
		/// Gets the parameter index. If the method has a hidden 'this' parameter, that parameter
		/// has index 0 and the remaining parameters in the method signature start from index 1.
		/// The method return parameter has index <c>-1</c>.
		/// </summary>
		public int Index {
			get { return paramIndex; }
		}

		/// <summary>
		/// Gets the index of the parameter in the method signature. See also
		/// <see cref="HIDDEN_THIS_METHOD_SIG_INDEX"/> and <see cref="RETURN_TYPE_METHOD_SIG_INDEX"/>
		/// </summary>
		public int MethodSigIndex {
			get { return methodSigIndex; }
		}

		/// <summary>
		/// <c>true</c> if it's a normal visible method parameter, i.e., it's not the hidden
		/// 'this' parameter and it's not the method return type parameter.
		/// </summary>
		public bool IsNormalMethodParameter {
			get { return methodSigIndex >= 0; }
		}

		/// <summary>
		/// <c>true</c> if it's the hidden 'this' parameter
		/// </summary>
		public bool IsHiddenThisParameter {
			get { return methodSigIndex == HIDDEN_THIS_METHOD_SIG_INDEX; }
		}

		/// <summary>
		/// <c>true</c> if it's the method return type parameter
		/// </summary>
		public bool IsReturnTypeParameter {
			get { return methodSigIndex == RETURN_TYPE_METHOD_SIG_INDEX; }
		}

		/// <summary>
		/// Gets the parameter type
		/// </summary>
		public TypeSig Type {
			get { return typeSig; }
			set {
				typeSig = value;
				if (parameterList != null)
					parameterList.TypeUpdated(this, false);
			}
		}

		/// <summary>
		/// This method does exactly what the <see cref="Type"/> setter does except that it
		/// uses the no-lock method if <paramref name="noParamsLock"/> is <c>true</c>.
		/// </summary>
		/// <param name="noParamsLock"><c>true</c> if <c>MethodSig.Params</c> lock is being held by
		/// us</param>
		/// <param name="type"></param>
		internal void SetType(bool noParamsLock, TypeSig type) {
			typeSig = type;
			if (parameterList != null)
				parameterList.TypeUpdated(this, noParamsLock);
		}

		/// <summary>
		/// Gets the owner method
		/// </summary>
		public MethodDef Method {
			get { return parameterList == null ? null : parameterList.Method; }
		}

		/// <summary>
		/// Gets the <see cref="dnlib.DotNet.ParamDef"/> or <c>null</c> if not present
		/// </summary>
		public ParamDef ParamDef {
			get { return parameterList == null ? null : parameterList.FindParamDef(this); }
		}

		/// <summary>
		/// <c>true</c> if it has a <see cref="dnlib.DotNet.ParamDef"/>
		/// </summary>
		public bool HasParamDef {
			get { return ParamDef != null; }
		}

		/// <summary>
		/// Gets the name from <see cref="ParamDef"/>. If <see cref="ParamDef"/> is <c>null</c>,
		/// an empty string is returned.
		/// </summary>
		public string Name {
			get {
				var paramDef = ParamDef;
				return paramDef == null ? string.Empty : UTF8String.ToSystemStringOrEmpty(paramDef.Name);
			}
			set {
				var paramDef = ParamDef;
				if (paramDef != null)
					paramDef.Name = value;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="paramIndex">Parameter index</param>
		public Parameter(int paramIndex) {
			this.paramIndex = paramIndex;
			this.methodSigIndex = paramIndex;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="paramIndex">Parameter index</param>
		/// <param name="type">Parameter type</param>
		public Parameter(int paramIndex, TypeSig type) {
			this.paramIndex = paramIndex;
			this.methodSigIndex = paramIndex;
			this.typeSig = type;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="paramIndex">Parameter index (0 is hidden this param if it exists)</param>
		/// <param name="methodSigIndex">Index in method signature</param>
		public Parameter(int paramIndex, int methodSigIndex) {
			this.paramIndex = paramIndex;
			this.methodSigIndex = methodSigIndex;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="paramIndex">Parameter index (0 is hidden this param if it exists)</param>
		/// <param name="methodSigIndex">Index in method signature</param>
		/// <param name="type">Parameter type</param>
		public Parameter(int paramIndex, int methodSigIndex, TypeSig type) {
			this.paramIndex = paramIndex;
			this.methodSigIndex = methodSigIndex;
			this.typeSig = type;
		}

		internal Parameter(ParameterList parameterList, int paramIndex, int methodSigIndex) {
			this.parameterList = parameterList;
			this.paramIndex = paramIndex;
			this.methodSigIndex = methodSigIndex;
		}

		/// <summary>
		/// Creates a <see cref="dnlib.DotNet.ParamDef"/> if it doesn't already exist
		/// </summary>
		public void CreateParamDef() {
			if (parameterList != null)
				parameterList.CreateParamDef(this);
		}

		/// <inheritdoc/>
		public override string ToString() {
			var name = Name;
			if (string.IsNullOrEmpty(name)) {
				if (IsReturnTypeParameter)
					return "RET_PARAM";
				return string.Format("A_{0}", paramIndex);
			}
			return name;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/PropertyAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Property attributes, see CorHdr.h/CorPropertyAttr
	/// </summary>
	[Flags]
	public enum PropertyAttributes : ushort {
		/// <summary>property is special.  Name describes how.</summary>
		SpecialName			= 0x0200,
		/// <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
		RTSpecialName		= 0x0400,
		/// <summary>Property has default</summary>
		HasDefault			= 0x1000,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/PropertyDef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Property table
	/// </summary>
	public abstract class PropertyDef : IHasConstant, IHasCustomAttribute, IHasSemantic, IHasCustomDebugInformation, IFullName, IMemberDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.Property, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasConstantTag {
			get { return 2; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 9; }
		}

		/// <inheritdoc/>
		public int HasSemanticTag {
			get { return 1; }
		}

		/// <summary>
		/// From column Property.PropFlags
		/// </summary>
		public PropertyAttributes Attributes {
			get { return (PropertyAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Property.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Property.Type
		/// </summary>
		public CallingConventionSig Type {
			get { return type; }
			set { type = value; }
		}
		/// <summary/>
		protected CallingConventionSig type;

		/// <inheritdoc/>
		public Constant Constant {
			get {
				if (!constant_isInitialized)
					InitializeConstant();
				return constant;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				constant = value;
				constant_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Constant constant;
		/// <summary/>
		protected bool constant_isInitialized;

		void InitializeConstant() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (constant_isInitialized)
				return;
			constant = GetConstant_NoLock();
			constant_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="constant"/></summary>
		protected virtual Constant GetConstant_NoLock() {
			return null;
		}

		/// <summary>Reset <see cref="Constant"/></summary>
		protected void ResetConstant() {
			constant_isInitialized = false;
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 9; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// Gets/sets the first getter method. Writing <c>null</c> will clear all get methods.
		/// </summary>
		public MethodDef GetMethod {
			get {
				if (otherMethods == null)
					InitializePropertyMethods();
				return getMethods.Get(0, null);
			}
			set {
				if (otherMethods == null)
					InitializePropertyMethods();
				if (value == null)
					getMethods.Clear();
				else if (getMethods.Count == 0)
					getMethods.Add(value);
				else
					getMethods.Set(0, value);
			}
		}

		/// <summary>
		/// Gets/sets the first setter method. Writing <c>null</c> will clear all set methods.
		/// </summary>
		public MethodDef SetMethod {
			get {
				if (otherMethods == null)
					InitializePropertyMethods();
				return setMethods.Get(0, null);
			}
			set {
				if (otherMethods == null)
					InitializePropertyMethods();
				if (value == null)
					setMethods.Clear();
				else if (setMethods.Count == 0)
					setMethods.Add(value);
				else
					setMethods.Set(0, value);
			}
		}

		/// <summary>
		/// Gets all getter methods
		/// </summary>
		public ThreadSafe.IList<MethodDef> GetMethods {
			get {
				if (otherMethods == null)
					InitializePropertyMethods();
				return getMethods;
			}
		}

		/// <summary>
		/// Gets all setter methods
		/// </summary>
		public ThreadSafe.IList<MethodDef> SetMethods {
			get {
				if (otherMethods == null)
					InitializePropertyMethods();
				return setMethods;
			}
		}

		/// <summary>
		/// Gets the other methods
		/// </summary>
		public ThreadSafe.IList<MethodDef> OtherMethods {
			get {
				if (otherMethods == null)
					InitializePropertyMethods();
				return otherMethods;
			}
		}

		void InitializePropertyMethods() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (otherMethods == null)
				InitializePropertyMethods_NoLock();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Initializes <see cref="otherMethods"/>, <see cref="getMethods"/>,
		/// and <see cref="setMethods"/>.
		/// </summary>
		protected virtual void InitializePropertyMethods_NoLock() {
			getMethods = ThreadSafeListCreator.Create<MethodDef>();
			setMethods = ThreadSafeListCreator.Create<MethodDef>();
			otherMethods = ThreadSafeListCreator.Create<MethodDef>();
		}

		/// <summary/>
		protected ThreadSafe.IList<MethodDef> getMethods;
		/// <summary/>
		protected ThreadSafe.IList<MethodDef> setMethods;
		/// <summary/>
		protected ThreadSafe.IList<MethodDef> otherMethods;

		/// <summary>Reset <see cref="GetMethods"/>, <see cref="SetMethods"/>, <see cref="OtherMethods"/></summary>
		protected void ResetMethods() {
			otherMethods = null;
		}

		/// <summary>
		/// <c>true</c> if there are no methods attached to this property
		/// </summary>
		public bool IsEmpty {
			get {
				// The first property access initializes the other fields we access here
				return GetMethods.Count == 0 &&
					setMethods.Count == 0 &&
					otherMethods.Count == 0;
			}
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="OtherMethods"/> is not empty
		/// </summary>
		public bool HasOtherMethods {
			get { return OtherMethods.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Constant"/> is not <c>null</c>
		/// </summary>
		public bool HasConstant {
			get { return Constant != null; }
		}

		/// <summary>
		/// Gets the constant element type or <see cref="dnlib.DotNet.ElementType.End"/> if there's no constant
		/// </summary>
		public ElementType ElementType {
			get {
				var c = Constant;
				return c == null ? ElementType.End : c.Type;
			}
		}

		/// <summary>
		/// Gets/sets the property sig
		/// </summary>
		public PropertySig PropertySig {
			get { return type as PropertySig; }
			set { type = value; }
		}

		/// <summary>
		/// Gets/sets the declaring type (owner type)
		/// </summary>
		public TypeDef DeclaringType {
			get { return declaringType2; }
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType != null)
					currentDeclaringType.Properties.Remove(this);	// Will set DeclaringType2 = null
				if (value != null)
					value.Properties.Add(this);	// Will set DeclaringType2 = value
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get { return declaringType2; }
		}

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get { return declaringType2; }
			set { declaringType2 = value; }
		}
		/// <summary/>
		protected TypeDef declaringType2;

		/// <inheritdoc/>
		public ModuleDef Module {
			get {
				var dt = declaringType2;
				return dt == null ? null : dt.Module;
			}
		}

		/// <summary>
		/// Gets the full name of the property
		/// </summary>
		public string FullName {
			get {
				var dt = declaringType2;
				return FullNameCreator.PropertyFullName(dt == null ? null : dt.FullName, name, type, null, null);
			}
		}

		bool IIsTypeOrMethod.IsType {
			get { return false; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		bool IMemberRef.IsField {
			get { return false; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return true; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, PropertyAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="PropertyAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get { return ((PropertyAttributes)attributes & PropertyAttributes.SpecialName) != 0; }
			set { ModifyAttributes(value, PropertyAttributes.SpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="PropertyAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get { return ((PropertyAttributes)attributes & PropertyAttributes.RTSpecialName) != 0; }
			set { ModifyAttributes(value, PropertyAttributes.RTSpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="PropertyAttributes.HasDefault"/> bit
		/// </summary>
		public bool HasDefault {
			get { return ((PropertyAttributes)attributes & PropertyAttributes.HasDefault) != 0; }
			set { ModifyAttributes(value, PropertyAttributes.HasDefault); }
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A Property row created by the user and not present in the original .NET file
	/// </summary>
	public class PropertyDefUser : PropertyDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public PropertyDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public PropertyDefUser(UTF8String name)
			: this(name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="sig">Property signature</param>
		public PropertyDefUser(UTF8String name, PropertySig sig)
			: this(name, sig, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="sig">Property signature</param>
		/// <param name="flags">Flags</param>
		public PropertyDefUser(UTF8String name, PropertySig sig, PropertyAttributes flags) {
			this.name = name;
			this.type = sig;
			this.attributes = (int)flags;
		}
	}

	/// <summary>
	/// Created from a row in the Property table
	/// </summary>
	sealed class PropertyDefMD : PropertyDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override Constant GetConstant_NoLock() {
			return readerModule.ResolveConstant(readerModule.MetaData.GetConstantRid(Table.Property, origRid));
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.Property, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(declaringType2), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Property</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public PropertyDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.PropertyTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("Property rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name;
			uint type = readerModule.TablesStream.ReadPropertyRow(origRid, out this.attributes, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.declaringType2 = readerModule.GetOwnerType(this);
			this.type = readerModule.ReadSignature(type, new GenericParamContext(declaringType2));
		}

		internal PropertyDefMD InitializeAll() {
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(Type);
			MemberMDInitializer.Initialize(Constant);
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(GetMethod);
			MemberMDInitializer.Initialize(SetMethod);
			MemberMDInitializer.Initialize(OtherMethods);
			MemberMDInitializer.Initialize(DeclaringType);
			return this;
		}

		/// <inheritdoc/>
		protected override void InitializePropertyMethods_NoLock() {
			if (otherMethods != null)
				return;
			ThreadSafe.IList<MethodDef> newOtherMethods;
			ThreadSafe.IList<MethodDef> newGetMethods, newSetMethods;
			var dt = declaringType2 as TypeDefMD;
			if (dt == null) {
				newGetMethods = ThreadSafeListCreator.Create<MethodDef>();
				newSetMethods = ThreadSafeListCreator.Create<MethodDef>();
				newOtherMethods = ThreadSafeListCreator.Create<MethodDef>();
			}
			else
				dt.InitializeProperty(this, out newGetMethods, out newSetMethods, out newOtherMethods);
			getMethods = newGetMethods;
			setMethods = newSetMethods;
			// Must be initialized last
			otherMethods = newOtherMethods;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/PublicKey.cs
================================================
// dnlib: See LICENSE.txt for more info

using dnlib.Threading;

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Represents a public key
	/// </summary>
	public sealed class PublicKey : PublicKeyBase {
		const AssemblyHashAlgorithm DEFAULT_ALGORITHM = AssemblyHashAlgorithm.SHA1;
		PublicKeyToken publicKeyToken;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Gets the <see cref="PublicKeyToken"/>
		/// </summary>
		public override PublicKeyToken Token {
			get {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				if (publicKeyToken == null && !IsNullOrEmpty_NoLock)
					publicKeyToken = AssemblyHash.CreatePublicKeyToken(data);
				return publicKeyToken;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <inheritdoc/>
		public override byte[] Data {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return data;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				if (data == value)
					return;
				data = value;
				publicKeyToken = null;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public PublicKey() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Public key data</param>
		public PublicKey(byte[] data)
			: base(data) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hexString">Public key data as a hex string or the string <c>"null"</c>
		/// to set public key data to <c>null</c></param>
		public PublicKey(string hexString)
			: base(hexString) {
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			if ((object)this == obj)
				return true;
			var other = obj as PublicKey;
			if (other == null)
				return false;
			return Utils.Equals(Data, other.Data);
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			return Utils.GetHashCode(Data);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/PublicKeyBase.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Public key / public key token base class
	/// </summary>
	public abstract class PublicKeyBase {
		/// <summary>
		/// The key data
		/// </summary>
		protected byte[] data;

		/// <summary>
		/// Returns <c>true</c> if <see cref="Data"/> is <c>null</c> or empty
		/// </summary>
		public bool IsNullOrEmpty {
			get { return IsNullOrEmpty_NoLock; }
		}

		/// <summary>
		/// The unlocked version of <see cref="IsNullOrEmpty"/>.
		/// </summary>
		protected bool IsNullOrEmpty_NoLock {
			get { return data == null || data.Length == 0; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="Data"/> is <c>null</c>
		/// </summary>
		public bool IsNull {
			get { return Data == null; }
		}

		/// <summary>
		/// Gets/sets key data
		/// </summary>
		public virtual byte[] Data {
			get { return data; }
			set { data = value; }
		}

		/// <summary>
		/// Gets the <see cref="PublicKeyToken"/>
		/// </summary>
		public abstract PublicKeyToken Token { get; }

		/// <summary>
		/// Default constructor
		/// </summary>
		protected PublicKeyBase() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Key data</param>
		protected PublicKeyBase(byte[] data) {
			this.data = data;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hexString">Key data as a hex string or the string <c>"null"</c>
		/// to set key data to <c>null</c></param>
		protected PublicKeyBase(string hexString) {
			this.data = Parse(hexString);
		}

		static byte[] Parse(string hexString) {
			if (hexString == null || hexString == "null")
				return null;
			return Utils.ParseBytes(hexString);
		}

		/// <summary>
		/// Checks whether a public key or token is null or empty
		/// </summary>
		/// <param name="a">Public key or token instance</param>
		public static bool IsNullOrEmpty2(PublicKeyBase a) {
			return a == null || a.IsNullOrEmpty;
		}

		/// <summary>
		/// Returns a <see cref="PublicKeyToken"/>
		/// </summary>
		/// <param name="pkb">A <see cref="PublicKey"/> or a <see cref="PublicKeyToken"/> instance</param>
		public static PublicKeyToken ToPublicKeyToken(PublicKeyBase pkb) {
			var pkt = pkb as PublicKeyToken;
			if (pkt != null)
				return pkt;
			var pk = pkb as PublicKey;
			if (pk != null)
				return pk.Token;
			return null;
		}

		/// <summary>
		/// Compares two <see cref="PublicKeyBase"/>s as <see cref="PublicKeyToken"/>s
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public static int TokenCompareTo(PublicKeyBase a, PublicKeyBase b) {
			if (a == b)
				return 0;
			return TokenCompareTo(ToPublicKeyToken(a), ToPublicKeyToken(b));
		}

		/// <summary>
		/// Checks whether two public key tokens are equal
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public static bool TokenEquals(PublicKeyBase a, PublicKeyBase b) {
			return TokenCompareTo(a, b) == 0;
		}

		static readonly byte[] EmptyByteArray = new byte[0];
		/// <summary>
		/// Compares two <see cref="PublicKeyToken"/>s
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public static int TokenCompareTo(PublicKeyToken a, PublicKeyToken b) {
			if (a == b)
				return 0;
			return TokenCompareTo(a == null ? null : a.Data, b == null ? null : b.Data);
		}

		static int TokenCompareTo(byte[] a, byte[] b) {
			return Utils.CompareTo(a ?? EmptyByteArray, b ?? EmptyByteArray);
		}

		/// <summary>
		/// Checks whether two public key tokens are equal
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public static bool TokenEquals(PublicKeyToken a, PublicKeyToken b) {
			return TokenCompareTo(a, b) == 0;
		}

		/// <summary>
		/// Gets the public key token hash code
		/// </summary>
		/// <param name="a">Public key or token</param>
		/// <returns>The hash code</returns>
		public static int GetHashCodeToken(PublicKeyBase a) {
			return GetHashCode(ToPublicKeyToken(a));
		}

		/// <summary>
		/// Gets the public key token hash code
		/// </summary>
		/// <param name="a">Public key token</param>
		/// <returns>The hash code</returns>
		public static int GetHashCode(PublicKeyToken a) {
			if (a == null)
				return 0;
			return Utils.GetHashCode(a.Data);
		}

		/// <summary>
		/// Creates a <see cref="PublicKey"/>
		/// </summary>
		/// <param name="data">Public key data or <c>null</c></param>
		/// <returns>A new <see cref="PublicKey"/> instance or <c>null</c> if <paramref name="data"/>
		/// was <c>null</c></returns>
		public static PublicKey CreatePublicKey(byte[] data) {
			if (data == null)
				return null;
			return new PublicKey(data);
		}

		/// <summary>
		/// Creates a <see cref="PublicKeyToken"/>
		/// </summary>
		/// <param name="data">Public key token data or <c>null</c></param>
		/// <returns>A new <see cref="PublicKeyToken"/> instance or <c>null</c> if <paramref name="data"/>
		/// was <c>null</c></returns>
		public static PublicKeyToken CreatePublicKeyToken(byte[] data) {
			if (data == null)
				return null;
			return new PublicKeyToken(data);
		}

		/// <summary>
		/// Gets the raw public key / public key token byte array
		/// </summary>
		/// <param name="pkb">The instance or <c>null</c></param>
		/// <returns>Raw public key / public key token data or <c>null</c></returns>
		public static byte[] GetRawData(PublicKeyBase pkb) {
			if (pkb == null)
				return null;
			return pkb.Data;
		}

		/// <inheritdoc/>
		public override string ToString() {
			var d = Data;
			if (d == null || d.Length == 0)
				return "null";
			return Utils.ToHex(d, false);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/PublicKeyToken.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Represents a public key token
	/// </summary>
	public sealed class PublicKeyToken : PublicKeyBase {
		/// <summary>
		/// Gets the <see cref="PublicKeyToken"/>
		/// </summary>
		public override PublicKeyToken Token {
			get { return this; }
		}

		/// <inheritdoc/>
		public PublicKeyToken()
			: base() {
		}

		/// <inheritdoc/>
		public PublicKeyToken(byte[] data)
			: base(data) {
		}

		/// <inheritdoc/>
		public PublicKeyToken(string hexString)
			: base(hexString) {
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			if ((object)this == obj)
				return true;
			var other = obj as PublicKeyToken;
			if (other == null)
				return false;
			return Utils.Equals(Data, other.Data);
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			return Utils.GetHashCode(Data);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/RecursionCounter.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet {
	/// <summary>
	/// Recursion counter
	/// </summary>
	public struct RecursionCounter {
		/// <summary>
		/// Max recursion count. If this is reached, we won't continue, and will use a default value.
		/// </summary>
		public const int MAX_RECURSION_COUNT = 100;
		int counter;

		/// <summary>
		/// Gets the recursion counter
		/// </summary>
		public int Counter {
			get { return counter; }
		}

		/// <summary>
		/// Increments <see cref="counter"/> if it's not too high. <c>ALL</c> instance methods
		/// that can be called recursively must call this method and <see cref="Decrement"/>
		/// (if this method returns <c>true</c>)
		/// </summary>
		/// <returns><c>true</c> if it was incremented and caller can continue, <c>false</c> if
		/// it was <c>not</c> incremented and the caller must return to its caller.</returns>
		public bool Increment() {
			if (counter >= MAX_RECURSION_COUNT)
				return false;
			counter++;
			return true;
		}

		/// <summary>
		/// Must be called before returning to caller if <see cref="Increment"/>
		/// returned <c>true</c>.
		/// </summary>
		public void Decrement() {
#if DEBUG
			if (counter <= 0)
				throw new InvalidOperationException("recursionCounter <= 0");
#endif
			counter--;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return counter.ToString();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ReflectionExtensions.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Reflection;

namespace dnlib.DotNet {
	/// <summary>
	/// Extension methods for reflection types, methods, fields
	/// </summary>
	static class ReflectionExtensions {
		/// <summary>
		/// Checks whether it's a <see cref="ElementType.SZArray"/>
		/// </summary>
		/// <param name="self">The type</param>
		public static bool IsSZArray(this Type self) {
			if (self == null || !self.IsArray)
				return false;
			var prop = self.GetType().GetProperty("IsSzArray", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (prop != null)
				return (bool)prop.GetValue(self, new object[0]);
			return (self.Name ?? string.Empty).EndsWith("[]");
		}

		/// <summary>
		/// Gets a <see cref="Type"/>'s <see cref="ElementType"/>
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The type's element type</returns>
		public static ElementType GetElementType2(this Type a) {
			if (a == null)
				return ElementType.End;	// Any invalid one is good enough
			if (a.IsArray)
				return IsSZArray(a) ? ElementType.SZArray : ElementType.Array;
			if (a.IsByRef)
				return ElementType.ByRef;
			if (a.IsPointer)
				return ElementType.Ptr;
			if (a.IsGenericParameter)
				return a.DeclaringMethod == null ? ElementType.Var : ElementType.MVar;
			if (a.IsGenericType && !a.IsGenericTypeDefinition)
				return ElementType.GenericInst;

			if (a == typeof(void))			return ElementType.Void;
			if (a == typeof(bool))			return ElementType.Boolean;
			if (a == typeof(char))			return ElementType.Char;
			if (a == typeof(sbyte))			return ElementType.I1;
			if (a == typeof(byte))			return ElementType.U1;
			if (a == typeof(short))			return ElementType.I2;
			if (a == typeof(ushort))		return ElementType.U2;
			if (a == typeof(int))			return ElementType.I4;
			if (a == typeof(uint))			return ElementType.U4;
			if (a == typeof(long))			return ElementType.I8;
			if (a == typeof(ulong))			return ElementType.U8;
			if (a == typeof(float))			return ElementType.R4;
			if (a == typeof(double))		return ElementType.R8;
			if (a == typeof(string))		return ElementType.String;
			if (a == typeof(TypedReference))return ElementType.TypedByRef;
			if (a == typeof(IntPtr))		return ElementType.I;
			if (a == typeof(UIntPtr))		return ElementType.U;
			if (a == typeof(object))		return ElementType.Object;

			return a.IsValueType ? ElementType.ValueType : ElementType.Class;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="mb"/> is a generic method, but
		/// not a generic method definition, i.e., a MethodSpec.
		/// </summary>
		/// <param name="mb">The method</param>
		public static bool IsGenericButNotGenericMethodDefinition(this MethodBase mb) {
			return mb != null && !mb.IsGenericMethodDefinition && mb.IsGenericMethod;
		}

		/// <summary>
		/// Checks whether a parameter/prop/event type should be treated as if it is really a
		/// generic instance type and not a generic type definition. In the .NET metadata (method
		/// sig), the parameter is a generic instance type, but the CLR treats it as if it's just
		/// a generic type def. This seems to happen only if the parameter type is exactly the same
		/// type as the declaring type, eg. a method similar to: <c>MyType&lt;!0&gt; MyType::SomeMethod()</c>.
		/// </summary>
		/// <param name="declaringType">Declaring type of method/event/property</param>
		/// <param name="t">Parameter/property/event type</param>
		internal static bool MustTreatTypeAsGenericInstType(this Type declaringType, Type t) {
			return declaringType != null &&
				declaringType.IsGenericTypeDefinition &&
				t == declaringType;
		}

		/// <summary>
		/// Checks whether <paramref name="type"/> is a type definition and not a type spec
		/// (eg. pointer or generic type instantiation)
		/// </summary>
		/// <param name="type">this</param>
		public static bool IsTypeDef(this Type type) {
			return type != null &&
				!type.HasElementType &&
				(!type.IsGenericType || type.IsGenericTypeDefinition);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ResolveException.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Runtime.Serialization;

namespace dnlib.DotNet {
	/// <summary>
	/// Resolve exception base class
	/// </summary>
	[Serializable]
	public class ResolveException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ResolveException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public ResolveException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public ResolveException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected ResolveException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Thrown if an assembly couldn't be resolved
	/// </summary>
	[Serializable]
	public class AssemblyResolveException : ResolveException {
		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyResolveException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public AssemblyResolveException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public AssemblyResolveException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected AssemblyResolveException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Thrown if a type couldn't be resolved
	/// </summary>
	[Serializable]
	public class TypeResolveException : ResolveException {
		/// <summary>
		/// Default constructor
		/// </summary>
		public TypeResolveException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public TypeResolveException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public TypeResolveException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected TypeResolveException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Thrown if a method/field couldn't be resolved
	/// </summary>
	[Serializable]
	public class MemberRefResolveException : ResolveException {
		/// <summary>
		/// Default constructor
		/// </summary>
		public MemberRefResolveException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public MemberRefResolveException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public MemberRefResolveException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected MemberRefResolveException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resolver.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using dnlib.Threading;

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Resolves types, methods, fields
	/// </summary>
	public sealed class Resolver : IResolver {
		readonly IAssemblyResolver assemblyResolver;

		/// <summary>
		/// <c>true</c> to project WinMD types to CLR types, eg. <c>Windows.UI.Xaml.Interop.TypeName</c>
		/// gets converted to <c>System.Type</c> before trying to resolve the type. This is enabled
		/// by default.
		/// </summary>
		public bool ProjectWinMDRefs {
			get { return projectWinMDRefs; }
			set { projectWinMDRefs = value; }
		}
		bool projectWinMDRefs = true;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="assemblyResolver">The assembly resolver</param>
		public Resolver(IAssemblyResolver assemblyResolver) {
			if (assemblyResolver == null)
				throw new ArgumentNullException("assemblyResolver");
			this.assemblyResolver = assemblyResolver;
		}

		/// <inheritdoc/>
		public TypeDef Resolve(TypeRef typeRef, ModuleDef sourceModule) {
			if (typeRef == null)
				return null;

			if (ProjectWinMDRefs)
				typeRef = WinMDHelpers.ToCLR(typeRef.Module ?? sourceModule, typeRef) ?? typeRef;

			var nonNestedTypeRef = TypeRef.GetNonNestedTypeRef(typeRef);
			if (nonNestedTypeRef == null)
				return null;

			var nonNestedResolutionScope = nonNestedTypeRef.ResolutionScope;
			var nonNestedModule = nonNestedTypeRef.Module;
			var asmRef = nonNestedResolutionScope as AssemblyRef;
			if (asmRef != null) {
				var asm = assemblyResolver.Resolve(asmRef, sourceModule ?? nonNestedModule);
				return asm == null ? null : asm.Find(typeRef) ?? ResolveExportedType(asm.Modules, typeRef, sourceModule);
			}

			var moduleDef = nonNestedResolutionScope as ModuleDef;
			if (moduleDef != null)
				return moduleDef.Find(typeRef) ??
					ResolveExportedType(new ModuleDef[] { moduleDef }, typeRef, sourceModule);

			var moduleRef = nonNestedResolutionScope as ModuleRef;
			if (moduleRef != null) {
				if (nonNestedModule == null)
					return null;
				if (new SigComparer().Equals(moduleRef, nonNestedModule))
					return nonNestedModule.Find(typeRef) ??
						ResolveExportedType(new ModuleDef[] { nonNestedModule }, typeRef, sourceModule);
				var nonNestedAssembly = nonNestedModule.Assembly;
				if (nonNestedAssembly == null)
					return null;
				var resolvedModule = nonNestedAssembly.FindModule(moduleRef.Name);
				return resolvedModule == null ? null : resolvedModule.Find(typeRef) ??
						ResolveExportedType(new ModuleDef[] { resolvedModule }, typeRef, sourceModule);
			}

			return null;
		}

		TypeDef ResolveExportedType(IList<ModuleDef> modules, TypeRef typeRef, ModuleDef sourceModule) {
			for (int i = 0; i < 30; i++) {
				var exportedType = FindExportedType(modules, typeRef);
				if (exportedType == null)
					return null;

				var asmResolver = modules[0].Context.AssemblyResolver;
				var etAsm = asmResolver.Resolve(exportedType.DefinitionAssembly, sourceModule ?? typeRef.Module);
				if (etAsm == null)
					return null;

				var td = etAsm.Find(typeRef);
				if (td != null)
					return td;

				modules = etAsm.Modules;
			}

			return null;
		}

		static ExportedType FindExportedType(IList<ModuleDef> modules, TypeRef typeRef) {
			if (typeRef == null)
				return null;
			foreach (var module in modules.GetSafeEnumerable()) {
				foreach (var exportedType in module.ExportedTypes.GetSafeEnumerable()) {
					if (new SigComparer(SigComparerOptions.DontCompareTypeScope).Equals(exportedType, typeRef))
						return exportedType;
				}
			}
			return null;
		}

		/// <inheritdoc/>
		public IMemberForwarded Resolve(MemberRef memberRef) {
			if (memberRef == null)
				return null;
			if (ProjectWinMDRefs)
				memberRef = WinMDHelpers.ToCLR(memberRef.Module, memberRef) ?? memberRef;
			var parent = memberRef.Class;
			var method = parent as MethodDef;
			if (method != null)
				return method;
			var declaringType = GetDeclaringType(memberRef, parent);
			return declaringType == null ? null : declaringType.Resolve(memberRef);
		}

		TypeDef GetDeclaringType(MemberRef memberRef, IMemberRefParent parent) {
			if (memberRef == null || parent == null)
				return null;

			var ts = parent as TypeSpec;
			if (ts != null)
				parent = ts.ScopeType;

			var declaringTypeDef = parent as TypeDef;
			if (declaringTypeDef != null)
				return declaringTypeDef;

			var declaringTypeRef = parent as TypeRef;
			if (declaringTypeRef != null)
				return Resolve(declaringTypeRef, memberRef.Module);

			// A module ref is used to reference the global type of a module in the same
			// assembly as the current module.
			var moduleRef = parent as ModuleRef;
			if (moduleRef != null) {
				var module = memberRef.Module;
				if (module == null)
					return null;
				TypeDef globalType = null;
				if (new SigComparer().Equals(module, moduleRef))
					globalType = module.GlobalType;
				var modAsm = module.Assembly;
				if (globalType == null && modAsm != null) {
					var moduleDef = modAsm.FindModule(moduleRef.Name);
					if (moduleDef != null)
						globalType = moduleDef.GlobalType;
				}
				return globalType;
			}

			var method = parent as MethodDef;
			if (method != null)
				return method.DeclaringType;

			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resource.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.IO;
using dnlib.IO;
using dnlib.DotNet.MD;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Type of resource
	/// </summary>
	public enum ResourceType {
		/// <summary>
		/// It's a <see cref="EmbeddedResource"/>
		/// </summary>
		Embedded,

		/// <summary>
		/// It's a <see cref="AssemblyLinkedResource"/>
		/// </summary>
		AssemblyLinked,

		/// <summary>
		/// It's a <see cref="LinkedResource"/>
		/// </summary>
		Linked,
	}

	/// <summary>
	/// Resource base class
	/// </summary>
	public abstract class Resource : IDisposable, IMDTokenProvider {
		uint rid;
		uint? offset;
		UTF8String name;
		ManifestResourceAttributes flags;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.ManifestResource, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <summary>
		/// Gets/sets the offset of the resource
		/// </summary>
		public uint? Offset {
			get { return offset; }
			set { offset = value; }
		}

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}

		/// <summary>
		/// Gets/sets the flags
		/// </summary>
		public ManifestResourceAttributes Attributes {
			get { return flags; }
			set { flags = value; }
		}

		/// <summary>
		/// Gets the type of resource
		/// </summary>
		public abstract ResourceType ResourceType { get; }

		/// <summary>
		/// Gets/sets the visibility
		/// </summary>
		public ManifestResourceAttributes Visibility {
			get { return flags & ManifestResourceAttributes.VisibilityMask; }
			set { flags = (flags & ~ManifestResourceAttributes.VisibilityMask) | (value & ManifestResourceAttributes.VisibilityMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ManifestResourceAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic {
			get { return (flags & ManifestResourceAttributes.VisibilityMask) == ManifestResourceAttributes.Public; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ManifestResourceAttributes.Private"/> is set
		/// </summary>
		public bool IsPrivate {
			get { return (flags & ManifestResourceAttributes.VisibilityMask) == ManifestResourceAttributes.Private; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="flags">flags</param>
		protected Resource(UTF8String name, ManifestResourceAttributes flags) {
			this.name = name;
			this.flags = flags;
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
		}
	}

	/// <summary>
	/// A resource that is embedded in a .NET module. This is the most common type of resource.
	/// </summary>
	public sealed class EmbeddedResource : Resource {
		IImageStream dataStream;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public override ResourceType ResourceType {
			get { return ResourceType.Embedded; }
		}

		/// <summary>
		/// Gets/sets the resource data. It's never <c>null</c>.
		/// </summary>
		public IImageStream Data {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return dataStream;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null)
					throw new ArgumentNullException("value");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				if (value == dataStream)
					return;
				if (dataStream != null)
					dataStream.Dispose();
				dataStream = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="data">Resource data</param>
		public EmbeddedResource(UTF8String name, byte[] data)
			: this(name, data, ManifestResourceAttributes.Private) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="data">Resource data</param>
		/// <param name="flags">Resource flags</param>
		public EmbeddedResource(UTF8String name, byte[] data, ManifestResourceAttributes flags)
			: this(name, new MemoryImageStream(0, data, 0, data.Length), flags) {
		}
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="dataStream">Resource data</param>
		public EmbeddedResource(UTF8String name, IImageStream dataStream)
			: this(name, dataStream, ManifestResourceAttributes.Private) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="dataStream">Resource data</param>
		/// <param name="flags">Resource flags</param>
		public EmbeddedResource(UTF8String name, IImageStream dataStream, ManifestResourceAttributes flags)
			: base(name, flags) {
			if (dataStream == null)
				throw new ArgumentNullException("dataStream");
			this.dataStream = dataStream;
		}

		/// <summary>
		/// Creates a new resource stream that can access the same data as the original
		/// Stream. Note that the data is shared between these streams.
		/// </summary>
		/// <returns>A new <see cref="IImageStream"/> instance</returns>
		public IImageStream GetClonedResourceStream() {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			return dataStream.Clone();
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
		}

		/// <summary>
		/// Gets the resource data as a <see cref="Stream"/>
		/// </summary>
		/// <returns>A stream</returns>
		public Stream GetResourceStream() {
			return GetClonedResourceStream().CreateStream(true);
		}

		/// <summary>
		/// Gets the resource data as a byte array
		/// </summary>
		/// <returns>The resource data</returns>
		public byte[] GetResourceData() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return dataStream.ReadAllBytes();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			if (!disposing)
				return;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (dataStream != null)
				dataStream.Dispose();
			dataStream = null;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			base.Dispose(disposing);
		}

		/// <inheritdoc/>
		public override string ToString() {
			var ds = dataStream;
			return string.Format("{0} - size: {1}", UTF8String.ToSystemStringOrEmpty(Name), ds == null ? 0 : ds.Length);
		}
	}

	/// <summary>
	/// A reference to a resource in another assembly
	/// </summary>
	public sealed class AssemblyLinkedResource : Resource {
		AssemblyRef asmRef;

		/// <inheritdoc/>
		public override ResourceType ResourceType {
			get { return ResourceType.AssemblyLinked; }
		}

		/// <summary>
		/// Gets/sets the assembly reference
		/// </summary>
		public AssemblyRef Assembly {
			get { return asmRef; }
			set {
				if (value == null)
					throw new ArgumentNullException("value");
				asmRef = value;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="asmRef">Assembly reference</param>
		/// <param name="flags">Resource flags</param>
		public AssemblyLinkedResource(UTF8String name, AssemblyRef asmRef, ManifestResourceAttributes flags)
			: base(name, flags) {
			if (asmRef == null)
				throw new ArgumentNullException("asmRef");
			this.asmRef = asmRef;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0} - assembly: {1}", UTF8String.ToSystemStringOrEmpty(Name), asmRef.FullName);
		}
	}

	/// <summary>
	/// A resource that is stored in a file on disk
	/// </summary>
	public sealed class LinkedResource : Resource {
		FileDef file;

		/// <inheritdoc/>
		public override ResourceType ResourceType {
			get { return ResourceType.Linked; }
		}

		/// <summary>
		/// Gets/sets the file
		/// </summary>
		public FileDef File {
			get { return file; }
			set {
				if (value == null)
					throw new ArgumentNullException("value");
				file = value;
			}
		}

		/// <summary>
		/// Gets/sets the hash
		/// </summary>
		public byte[] Hash {
			get { return file.HashValue; }
			set { file.HashValue = value; }
		}

		/// <summary>
		/// Gets/sets the file name
		/// </summary>
		public UTF8String FileName {
			get { return file == null ? UTF8String.Empty : file.Name; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="file">The file</param>
		/// <param name="flags">Resource flags</param>
		public LinkedResource(UTF8String name, FileDef file, ManifestResourceAttributes flags)
			: base(name, flags) {
			this.file = file;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0} - file: {1}", UTF8String.ToSystemStringOrEmpty(Name), UTF8String.ToSystemStringOrEmpty(FileName));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/ResourceCollection.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.Utils;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// A collection of <see cref="Resource"/>s
	/// </summary>
	public class ResourceCollection : LazyList<Resource> {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ResourceCollection() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="listener">List listener</param>
		public ResourceCollection(IListListener<Resource> listener)
			: base(listener) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Initial length of the list</param>
		/// <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
		/// <param name="readOriginalValue">Delegate instance that returns original values</param>
		public ResourceCollection(int length, object context, MFunc<object, uint, Resource> readOriginalValue)
			: base(length, context, readOriginalValue) {
		}

		/// <summary>
		/// Finds the index of a resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The index of the <see cref="Resource"/> or <c>-1</c> if none was found</returns>
		public int IndexOf(UTF8String name) {
			int i = -1;
			foreach (var resource in this.GetSafeEnumerable()) {
				i++;
				if (resource != null && resource.Name == name)
					return i;
			}
			return -1;
		}

		/// <summary>
		/// Finds the index of an embedded resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The index of the <see cref="EmbeddedResource"/> or <c>-1</c> if none was found</returns>
		public int IndexOfEmbeddedResource(UTF8String name) {
			int i = -1;
			foreach (var resource in this.GetSafeEnumerable()) {
				i++;
				if (resource != null &&
					resource.ResourceType == ResourceType.Embedded &&
					resource.Name == name)
					return i;
			}
			return -1;
		}

		/// <summary>
		/// Finds the index of an assembly linked resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The index of the <see cref="AssemblyLinkedResource"/> or <c>-1</c> if none was found</returns>
		public int IndexOfAssemblyLinkedResource(UTF8String name) {
			int i = -1;
			foreach (var resource in this.GetSafeEnumerable()) {
				i++;
				if (resource != null &&
					resource.ResourceType == ResourceType.AssemblyLinked &&
					resource.Name == name)
					return i;
			}
			return -1;
		}

		/// <summary>
		/// Finds the index of a linked resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The index of the <see cref="LinkedResource"/> or <c>-1</c> if none was found</returns>
		public int IndexOfLinkedResource(UTF8String name) {
			int i = -1;
			foreach (var resource in this.GetSafeEnumerable()) {
				i++;
				if (resource != null &&
					resource.ResourceType == ResourceType.Linked &&
					resource.Name == name)
					return i;
			}
			return -1;
		}

		/// <summary>
		/// Finds a resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The <see cref="Resource"/> or <c>null</c> if none was found</returns>
		public Resource Find(UTF8String name) {
			foreach (var resource in this.GetSafeEnumerable()) {
				if (resource != null && resource.Name == name)
					return resource;
			}
			return null;
		}

		/// <summary>
		/// Finds an embedded resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The <see cref="EmbeddedResource"/> or <c>null</c> if none was found</returns>
		public EmbeddedResource FindEmbeddedResource(UTF8String name) {
			foreach (var resource in this.GetSafeEnumerable()) {
				if (resource != null &&
					resource.ResourceType == ResourceType.Embedded &&
					resource.Name == name)
					return (EmbeddedResource)resource;
			}
			return null;
		}

		/// <summary>
		/// Finds an assembly linked resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The <see cref="AssemblyLinkedResource"/> or <c>null</c> if none was found</returns>
		public AssemblyLinkedResource FindAssemblyLinkedResource(UTF8String name) {
			foreach (var resource in this.GetSafeEnumerable()) {
				if (resource != null &&
					resource.ResourceType == ResourceType.AssemblyLinked &&
					resource.Name == name)
					return (AssemblyLinkedResource)resource;
			}
			return null;
		}

		/// <summary>
		/// Finds a linked resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The <see cref="LinkedResource"/> or <c>null</c> if none was found</returns>
		public LinkedResource FindLinkedResource(UTF8String name) {
			foreach (var resource in this.GetSafeEnumerable()) {
				if (resource != null &&
					resource.ResourceType == ResourceType.Linked &&
					resource.Name == name)
					return (LinkedResource)resource;
			}
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/SecurityAction.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// Security action. See CorHdr.h/CorDeclSecurity
	/// </summary>
	public enum SecurityAction : short {
		/// <summary>Mask allows growth of enum.</summary>
		ActionMask			= 0x001F,
		/// <summary/>
		ActionNil			= 0x0000,
		/// <summary/>
		Request				= 0x0001,
		/// <summary/>
		Demand				= 0x0002,
		/// <summary/>
		Assert				= 0x0003,
		/// <summary/>
		Deny				= 0x0004,
		/// <summary/>
		PermitOnly			= 0x0005,
		/// <summary/>
		LinktimeCheck		= 0x0006,
		/// <summary/>
		LinkDemand			= LinktimeCheck,
		/// <summary/>
		InheritanceCheck	= 0x0007,
		/// <summary/>
		InheritDemand		= InheritanceCheck,
		/// <summary/>
		RequestMinimum		= 0x0008,
		/// <summary/>
		RequestOptional		= 0x0009,
		/// <summary/>
		RequestRefuse		= 0x000A,
		/// <summary>Persisted grant set at prejit time</summary>
		PrejitGrant			= 0x000B,
		/// <summary>Persisted grant set at prejit time</summary>
		PreJitGrant			= PrejitGrant,
		/// <summary>Persisted denied set at prejit time</summary>
		PrejitDenied		= 0x000C,
		/// <summary>Persisted denied set at prejit time</summary>
		PreJitDeny			= PrejitDenied,
		/// <summary/>
		NonCasDemand		= 0x000D,
		/// <summary/>
		NonCasLinkDemand	= 0x000E,
		/// <summary/>
		NonCasInheritance	= 0x000F,
		/// <summary>Maximum legal value</summary>
		MaximumValue		= 0x000F,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/SecurityAttribute.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A <c>DeclSecurity</c> security attribute
	/// </summary>
	public sealed class SecurityAttribute : ICustomAttribute {
		ITypeDefOrRef attrType;
		readonly ThreadSafe.IList<CANamedArgument> namedArguments;

		/// <summary>
		/// Gets/sets the attribute type
		/// </summary>
		public ITypeDefOrRef AttributeType {
			get { return attrType; }
			set { attrType = value; }
		}

		/// <summary>
		/// Gets the full name of the attribute type
		/// </summary>
		public string TypeFullName {
			get {
				var at = attrType;
				return at == null ? string.Empty : at.FullName;
			}
		}

		/// <summary>
		/// Gets all named arguments (field and property values)
		/// </summary>
		public ThreadSafe.IList<CANamedArgument> NamedArguments {
			get { return namedArguments; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="NamedArguments"/> is not empty
		/// </summary>
		public bool HasNamedArguments {
			get { return namedArguments.Count > 0; }
		}

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are field arguments
		/// </summary>
		public IEnumerable<CANamedArgument> Fields {
			get {
				foreach (var namedArg in namedArguments.GetSafeEnumerable()) {
					if (namedArg.IsField)
						yield return namedArg;
				}
			}
		}

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are property arguments
		/// </summary>
		public IEnumerable<CANamedArgument> Properties {
			get {
				foreach (var namedArg in namedArguments.GetSafeEnumerable()) {
					if (namedArg.IsProperty)
						yield return namedArg;
				}
			}
		}

		/// <summary>
		/// Creates a <see cref="SecurityAttribute"/> from an XML string.
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="xml">XML</param>
		/// <returns>A new <see cref="SecurityAttribute"/> instance</returns>
		public static SecurityAttribute CreateFromXml(ModuleDef module, string xml) {
			var attrType = module.CorLibTypes.GetTypeRef("System.Security.Permissions", "PermissionSetAttribute");
			var utf8Xml = new UTF8String(xml);
			var namedArg = new CANamedArgument(false, module.CorLibTypes.String, "XML", new CAArgument(module.CorLibTypes.String, utf8Xml));
			var list = ThreadSafeListCreator.Create<CANamedArgument>(namedArg);
			return new SecurityAttribute(attrType, list);
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public SecurityAttribute()
			: this(null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="attrType">Attribute type</param>
		public SecurityAttribute(ITypeDefOrRef attrType)
			: this(attrType, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="attrType">Attribute type</param>
		/// <param name="namedArguments">Named arguments that will be owned by this instance</param>
		public SecurityAttribute(ITypeDefOrRef attrType, IList<CANamedArgument> namedArguments) {
			this.attrType = attrType;
			this.namedArguments = ThreadSafeListCreator.MakeThreadSafe(namedArguments ?? new List<CANamedArgument>());
		}

		/// <inheritdoc/>
		public override string ToString() {
			return TypeFullName;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/SerializationType.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet {
	/// <summary>
	/// See CorSerializationType/CorHdr.h
	/// </summary>
	enum SerializationType : byte {
		/// <summary/>
		Undefined	= 0,
		/// <summary>System.Boolean</summary>
		Boolean		= ElementType.Boolean,
		/// <summary>System.Char</summary>
		Char		= ElementType.Char,
		/// <summary>System.SByte</summary>
		I1			= ElementType.I1,
		/// <summary>System.Byte</summary>
		U1			= ElementType.U1,
		/// <summary>System.Int16</summary>
		I2			= ElementType.I2,
		/// <summary>System.UInt16</summary>
		U2			= ElementType.U2,
		/// <summary>System.Int32</summary>
		I4			= ElementType.I4,
		/// <summary>System.UInt32</summary>
		U4			= ElementType.U4,
		/// <summary>System.Int64</summary>
		I8			= ElementType.I8,
		/// <summary>System.UInt64</summary>
		U8			= ElementType.U8,
		/// <summary>System.Single</summary>
		R4			= ElementType.R4,
		/// <summary>System.Double</summary>
		R8			= ElementType.R8,
		/// <summary>System.String</summary>
		String		= ElementType.String,
		/// <summary>Single-dimension, zero lower bound array ([])</summary>
		SZArray		= ElementType.SZArray,
		/// <summary>System.Type</summary>
		Type		= 0x50,
		/// <summary>Boxed value type</summary>
		TaggedObject= 0x51,
		/// <summary>A field</summary>
		Field		= 0x53,
		/// <summary>A property</summary>
		Property	= 0x54,
		/// <summary>An enum</summary>
		Enum		= 0x55,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/SigComparer.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Reflection;

namespace dnlib.DotNet {
	/// <summary>
	/// Compares types
	/// </summary>
	public sealed class TypeEqualityComparer : IEqualityComparer<IType>, IEqualityComparer<ITypeDefOrRef>, IEqualityComparer<TypeRef>, IEqualityComparer<TypeDef>, IEqualityComparer<TypeSpec>, IEqualityComparer<TypeSig>, IEqualityComparer<ExportedType> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Default instance
		/// </summary>
		public static readonly TypeEqualityComparer Instance = new TypeEqualityComparer(0);

		/// <summary>
		/// Case insensitive names
		/// </summary>
		public static readonly TypeEqualityComparer CaseInsensitive = new TypeEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public TypeEqualityComparer(SigComparerOptions options) {
			this.options = options;
		}

		/// <inheritdoc/>
		public bool Equals(IType x, IType y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(IType obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(ITypeDefOrRef x, ITypeDefOrRef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(ITypeDefOrRef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(TypeRef x, TypeRef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(TypeRef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(TypeDef x, TypeDef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(TypeDef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(TypeSpec x, TypeSpec y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(TypeSpec obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(TypeSig x, TypeSig y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(TypeSig obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(ExportedType x, ExportedType y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(ExportedType obj) {
			return new SigComparer(options).GetHashCode(obj);
		}
	}

	/// <summary>
	/// Compares fields
	/// </summary>
	public sealed class FieldEqualityComparer : IEqualityComparer<IField>, IEqualityComparer<FieldDef>, IEqualityComparer<MemberRef> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Compares the declaring types
		/// </summary>
		public static readonly FieldEqualityComparer CompareDeclaringTypes = new FieldEqualityComparer(SigComparerOptions.CompareMethodFieldDeclaringType);

		/// <summary>
		/// Doesn't compare the declaring types
		/// </summary>
		public static readonly FieldEqualityComparer DontCompareDeclaringTypes = new FieldEqualityComparer(0);

		/// <summary>
		/// Compares the declaring types, case insensitive names
		/// </summary>
		public static readonly FieldEqualityComparer CaseInsensitiveCompareDeclaringTypes = new FieldEqualityComparer(SigComparerOptions.CompareMethodFieldDeclaringType | SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Doesn't compare the declaring types, case insensitive names
		/// </summary>
		public static readonly FieldEqualityComparer CaseInsensitiveDontCompareDeclaringTypes = new FieldEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public FieldEqualityComparer(SigComparerOptions options) {
			this.options = options;
		}

		/// <inheritdoc/>
		public bool Equals(IField x, IField y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(IField obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(FieldDef x, FieldDef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(FieldDef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(MemberRef x, MemberRef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(MemberRef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}
	}

	/// <summary>
	/// Compares methods
	/// </summary>
	public sealed class MethodEqualityComparer : IEqualityComparer<IMethod>, IEqualityComparer<IMethodDefOrRef>, IEqualityComparer<MethodDef>, IEqualityComparer<MemberRef>, IEqualityComparer<MethodSpec> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Compares the declaring types
		/// </summary>
		public static readonly MethodEqualityComparer CompareDeclaringTypes = new MethodEqualityComparer(SigComparerOptions.CompareMethodFieldDeclaringType);

		/// <summary>
		/// Doesn't compare the declaring types
		/// </summary>
		public static readonly MethodEqualityComparer DontCompareDeclaringTypes = new MethodEqualityComparer(0);

		/// <summary>
		/// Compares the declaring types, case insensitive names
		/// </summary>
		public static readonly MethodEqualityComparer CaseInsensitiveCompareDeclaringTypes = new MethodEqualityComparer(SigComparerOptions.CompareMethodFieldDeclaringType | SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Doesn't compare the declaring types, case insensitive names
		/// </summary>
		public static readonly MethodEqualityComparer CaseInsensitiveDontCompareDeclaringTypes = new MethodEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public MethodEqualityComparer(SigComparerOptions options) {
			this.options = options;
		}

		/// <inheritdoc/>
		public bool Equals(IMethod x, IMethod y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(IMethod obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(IMethodDefOrRef x, IMethodDefOrRef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(IMethodDefOrRef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(MethodDef x, MethodDef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(MethodDef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(MemberRef x, MemberRef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(MemberRef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(MethodSpec x, MethodSpec y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(MethodSpec obj) {
			return new SigComparer(options).GetHashCode(obj);
		}
	}

	/// <summary>
	/// Compares properties
	/// </summary>
	public sealed class PropertyEqualityComparer : IEqualityComparer<PropertyDef> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Compares the declaring types
		/// </summary>
		public static readonly PropertyEqualityComparer CompareDeclaringTypes = new PropertyEqualityComparer(SigComparerOptions.ComparePropertyDeclaringType);

		/// <summary>
		/// Doesn't compare the declaring types
		/// </summary>
		public static readonly PropertyEqualityComparer DontCompareDeclaringTypes = new PropertyEqualityComparer(0);

		/// <summary>
		/// Compares the declaring types, case insensitive names
		/// </summary>
		public static readonly PropertyEqualityComparer CaseInsensitiveCompareDeclaringTypes = new PropertyEqualityComparer(SigComparerOptions.ComparePropertyDeclaringType | SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Doesn't compare the declaring types, case insensitive names
		/// </summary>
		public static readonly PropertyEqualityComparer CaseInsensitiveDontCompareDeclaringTypes = new PropertyEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public PropertyEqualityComparer(SigComparerOptions options) {
			this.options = options;
		}

		/// <inheritdoc/>
		public bool Equals(PropertyDef x, PropertyDef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(PropertyDef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}
	}

	/// <summary>
	/// Compares events
	/// </summary>
	public sealed class EventEqualityComparer : IEqualityComparer<EventDef> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Compares the declaring types
		/// </summary>
		public static readonly EventEqualityComparer CompareDeclaringTypes = new EventEqualityComparer(SigComparerOptions.CompareEventDeclaringType);

		/// <summary>
		/// Doesn't compare the declaring types
		/// </summary>
		public static readonly EventEqualityComparer DontCompareDeclaringTypes = new EventEqualityComparer(0);

		/// <summary>
		/// Compares the declaring types, case insensitive names
		/// </summary>
		public static readonly EventEqualityComparer CaseInsensitiveCompareDeclaringTypes = new EventEqualityComparer(SigComparerOptions.CompareEventDeclaringType | SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Doesn't compare the declaring types, case insensitive names
		/// </summary>
		public static readonly EventEqualityComparer CaseInsensitiveDontCompareDeclaringTypes = new EventEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public EventEqualityComparer(SigComparerOptions options) {
			this.options = options;
		}

		/// <inheritdoc/>
		public bool Equals(EventDef x, EventDef y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(EventDef obj) {
			return new SigComparer(options).GetHashCode(obj);
		}
	}

	/// <summary>
	/// Compares calling convention signatures
	/// </summary>
	public sealed class SignatureEqualityComparer : IEqualityComparer<CallingConventionSig>, IEqualityComparer<MethodBaseSig>, IEqualityComparer<MethodSig>, IEqualityComparer<PropertySig>, IEqualityComparer<FieldSig>, IEqualityComparer<LocalSig>, IEqualityComparer<GenericInstMethodSig> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Default instance
		/// </summary>
		public static readonly SignatureEqualityComparer Instance = new SignatureEqualityComparer(0);

		/// <summary>
		/// Case insensitive names
		/// </summary>
		public static readonly SignatureEqualityComparer CaseInsensitive = new SignatureEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public SignatureEqualityComparer(SigComparerOptions options) {
			this.options = options;
		}

		/// <inheritdoc/>
		public bool Equals(CallingConventionSig x, CallingConventionSig y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(CallingConventionSig obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(MethodBaseSig x, MethodBaseSig y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(MethodBaseSig obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(MethodSig x, MethodSig y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(MethodSig obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(PropertySig x, PropertySig y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(PropertySig obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(FieldSig x, FieldSig y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(FieldSig obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(LocalSig x, LocalSig y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(LocalSig obj) {
			return new SigComparer(options).GetHashCode(obj);
		}

		/// <inheritdoc/>
		public bool Equals(GenericInstMethodSig x, GenericInstMethodSig y) {
			return new SigComparer(options).Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(GenericInstMethodSig obj) {
			return new SigComparer(options).GetHashCode(obj);
		}
	}

	/// <summary>
	/// Decides how to compare types, sigs, etc
	/// </summary>
	[Flags]
	public enum SigComparerOptions : uint {
		/// <summary>
		/// Don't compare a type's (assembly/module) scope
		/// </summary>
		DontCompareTypeScope = 1,

		/// <summary>
		/// Compares a method/field's declaring type.
		/// </summary>
		CompareMethodFieldDeclaringType = 2,

		/// <summary>
		/// Compares a property's declaring type
		/// </summary>
		ComparePropertyDeclaringType = 4,

		/// <summary>
		/// Compares an event's declaring type
		/// </summary>
		CompareEventDeclaringType = 8,

		/// <summary>
		/// Compares method / field / property / event declaring types
		/// </summary>
		CompareDeclaringTypes = CompareMethodFieldDeclaringType | ComparePropertyDeclaringType | CompareEventDeclaringType,

		/// <summary>
		/// Compares parameters after a sentinel in method sigs. Should not be enabled when
		/// comparing <see cref="MethodSig"/>s against <see cref="MethodInfo"/>s since it's
		/// not possible to get those sentinel params from a <see cref="MethodInfo"/>.
		/// </summary>
		CompareSentinelParams = 0x10,

		/// <summary>
		/// Compares assembly public key token
		/// </summary>
		CompareAssemblyPublicKeyToken = 0x20,

		/// <summary>
		/// Compares assembly version
		/// </summary>
		CompareAssemblyVersion = 0x40,

		/// <summary>
		/// Compares assembly locale
		/// </summary>
		CompareAssemblyLocale = 0x80,

		/// <summary>
		/// If set, a <see cref="TypeRef"/> and an <see cref="ExportedType"/> can reference the
		/// global <c>&lt;Module&gt;</c> type.
		/// </summary>
		TypeRefCanReferenceGlobalType = 0x100,

		/// <summary>
		/// Don't compare a method/property's return type
		/// </summary>
		DontCompareReturnType = 0x200,

		/// <summary>
		/// If set, all generic parameters are replaced with their generic arguments prior
		/// to comparing types. You should enable this when comparing a method, field, property
		/// or an event to a <see cref="MethodInfo"/>, <see cref="FieldInfo"/>,
		/// <see cref="PropertyInfo"/> or an <see cref="EventInfo"/> if the owner type could
		/// be a generic instance type.
		/// </summary>
		SubstituteGenericParameters = 0x400,

		/// <summary>
		/// Type namespaces are case insensitive
		/// </summary>
		CaseInsensitiveTypeNamespaces = 0x800,

		/// <summary>
		/// Type names (not namespaces) are case insensitive
		/// </summary>
		CaseInsensitiveTypeNames = 0x1000,

		/// <summary>
		/// Type names and namespaces are case insensitive
		/// </summary>
		CaseInsensitiveTypes = CaseInsensitiveTypeNamespaces | CaseInsensitiveTypeNames,

		/// <summary>
		/// Method and field names are case insensitive
		/// </summary>
		CaseInsensitiveMethodFieldNames = 0x2000,

		/// <summary>
		/// Property names are case insensitive
		/// </summary>
		CaseInsensitivePropertyNames = 0x4000,

		/// <summary>
		/// Event names are case insensitive
		/// </summary>
		CaseInsensitiveEventNames = 0x8000,

		/// <summary>
		/// Type namespaces, type names, method names, field names, property names
		/// and event names are all case insensitive
		/// </summary>
		CaseInsensitiveAll = CaseInsensitiveTypeNamespaces | CaseInsensitiveTypeNames |
						CaseInsensitiveMethodFieldNames | CaseInsensitivePropertyNames |
						CaseInsensitiveEventNames,

		/// <summary>
		/// A field that is <see cref="FieldAttributes.PrivateScope"/> can compare equal to
		/// a <see cref="MemberRef"/>
		/// </summary>
		PrivateScopeFieldIsComparable = 0x10000,

		/// <summary>
		/// A method that is <see cref="MethodAttributes.PrivateScope"/> can compare equal to
		/// a <see cref="MemberRef"/>
		/// </summary>
		PrivateScopeMethodIsComparable = 0x20000,

		/// <summary>
		/// A field that is <see cref="FieldAttributes.PrivateScope"/> and a method that is
		/// <see cref="MethodAttributes.PrivateScope"/> can compare equal to a <see cref="MemberRef"/>
		/// </summary>
		PrivateScopeIsComparable = PrivateScopeFieldIsComparable | PrivateScopeMethodIsComparable,

		/// <summary>
		/// Raw (bit by bit) comparison of signatures. This matches what the CLR does when it
		/// compares signatures. This means that metadata tokens will be compared.
		/// </summary>
		RawSignatureCompare = 0x40000,

		/// <summary>
		/// Ignore required and optional modifiers when comparing <see cref="TypeSig"/>s.
		/// They're already ignored when comparing eg. a <see cref="TypeSig"/> with a
		/// <see cref="TypeRef"/>.
		/// </summary>
		IgnoreModifiers = 0x80000,

		/// <summary>
		/// By default, all module and assembly compares when they're both the system library
		/// (eg. mscorlib or System.Runtime.dll) return true, even if they're really different,
		/// eg. mscorlib (.NET 2.0) vs mscorlib (Windows CE). If this flag is set, the system
		/// library is compared just like any other module/assembly.
		/// </summary>
		MscorlibIsNotSpecial = 0x100000,

		/// <summary>
		/// Don't project CLR compatible WinMD references back to the original CLR type/method before comparing
		/// </summary>
		DontProjectWinMDRefs = 0x200000,

		/// <summary>
		/// Don't check type equivalence when comparing types. Starting with .NET 4.0, two different
		/// types can be considered equivalent if eg. a TypeIdentifierAttribute is used.
		/// </summary>
		DontCheckTypeEquivalence = 0x400000,
	}

	/// <summary>
	/// Compares types, signatures, methods, fields, properties, events
	/// </summary>
	public struct SigComparer {
		const int HASHCODE_MAGIC_GLOBAL_TYPE = 1654396648;
		const int HASHCODE_MAGIC_NESTED_TYPE = -1049070942;
		const int HASHCODE_MAGIC_ET_MODULE = -299744851;
		const int HASHCODE_MAGIC_ET_VALUEARRAY = -674970533;
		const int HASHCODE_MAGIC_ET_GENERICINST = -2050514639;
		const int HASHCODE_MAGIC_ET_VAR = 1288450097;
		const int HASHCODE_MAGIC_ET_MVAR = -990598495;
		const int HASHCODE_MAGIC_ET_ARRAY = -96331531;
		const int HASHCODE_MAGIC_ET_SZARRAY = 871833535;
		const int HASHCODE_MAGIC_ET_BYREF = -634749586;
		const int HASHCODE_MAGIC_ET_PTR = 1976400808;
		const int HASHCODE_MAGIC_ET_SENTINEL = 68439620;

		RecursionCounter recursionCounter;
		SigComparerOptions options;
		GenericArguments genericArguments;
		readonly ModuleDef sourceModule;

		bool DontCompareTypeScope {
			get { return (options & SigComparerOptions.DontCompareTypeScope) != 0; }
		}

		bool CompareMethodFieldDeclaringType {
			get { return (options & SigComparerOptions.CompareMethodFieldDeclaringType) != 0; }
		}

		bool ComparePropertyDeclaringType {
			get { return (options & SigComparerOptions.ComparePropertyDeclaringType) != 0; }
		}

		bool CompareEventDeclaringType {
			get { return (options & SigComparerOptions.CompareEventDeclaringType) != 0; }
		}

		bool CompareSentinelParams {
			get { return (options & SigComparerOptions.CompareSentinelParams) != 0; }
		}

		bool CompareAssemblyPublicKeyToken {
			get { return (options & SigComparerOptions.CompareAssemblyPublicKeyToken) != 0; }
		}

		bool CompareAssemblyVersion {
			get { return (options & SigComparerOptions.CompareAssemblyVersion) != 0; }
		}

		bool CompareAssemblyLocale {
			get { return (options & SigComparerOptions.CompareAssemblyLocale) != 0; }
		}

		bool TypeRefCanReferenceGlobalType {
			get { return (options & SigComparerOptions.TypeRefCanReferenceGlobalType) != 0; }
		}

		bool DontCompareReturnType {
			get { return (options & SigComparerOptions.DontCompareReturnType) != 0; }
		}

		bool SubstituteGenericParameters {
			get { return (options & SigComparerOptions.SubstituteGenericParameters) != 0; }
		}

		bool CaseInsensitiveTypeNamespaces {
			get { return (options & SigComparerOptions.CaseInsensitiveTypeNamespaces) != 0; }
		}

		bool CaseInsensitiveTypeNames {
			get { return (options & SigComparerOptions.CaseInsensitiveTypeNames) != 0; }
		}

		bool CaseInsensitiveMethodFieldNames {
			get { return (options & SigComparerOptions.CaseInsensitiveMethodFieldNames) != 0; }
		}

		bool CaseInsensitivePropertyNames {
			get { return (options & SigComparerOptions.CaseInsensitivePropertyNames) != 0; }
		}

		bool CaseInsensitiveEventNames {
			get { return (options & SigComparerOptions.CaseInsensitiveEventNames) != 0; }
		}

		bool PrivateScopeFieldIsComparable {
			get { return (options & SigComparerOptions.PrivateScopeFieldIsComparable) != 0; }
		}

		bool PrivateScopeMethodIsComparable {
			get { return (options & SigComparerOptions.PrivateScopeMethodIsComparable) != 0; }
		}

		bool RawSignatureCompare {
			get { return (options & SigComparerOptions.RawSignatureCompare) != 0; }
		}

		bool IgnoreModifiers {
			get { return (options & SigComparerOptions.IgnoreModifiers) != 0; }
		}

		bool MscorlibIsNotSpecial {
			get { return (options & SigComparerOptions.MscorlibIsNotSpecial) != 0; }
		}

		bool DontProjectWinMDRefs {
			get { return (options & SigComparerOptions.DontProjectWinMDRefs) != 0; }
		}

		bool DontCheckTypeEquivalence {
			get { return (options & SigComparerOptions.DontCheckTypeEquivalence) != 0; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public SigComparer(SigComparerOptions options)
			: this(options, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		/// <param name="sourceModule">The module which the comparison take place in.</param>
		public SigComparer(SigComparerOptions options, ModuleDef sourceModule) {
			this.recursionCounter = new RecursionCounter();
			this.options = options;
			this.genericArguments = null;
			this.sourceModule = sourceModule;
		}

		/// <summary>
		/// <see cref="ElementType.FnPtr"/> is mapped to <see cref="System.IntPtr"/>, so use
		/// the same hash code for both
		/// </summary>
		int GetHashCode_FnPtr_SystemIntPtr() {
			// ********************************************
			// IMPORTANT: This must match GetHashCode(TYPE)
			// ********************************************

			return GetHashCode_TypeNamespace("System") +
					GetHashCode_TypeName("IntPtr");
		}

		bool Equals_Names(bool caseInsensitive, UTF8String a, UTF8String b) {
			if (caseInsensitive)
				return UTF8String.ToSystemStringOrEmpty(a).Equals(UTF8String.ToSystemStringOrEmpty(b), StringComparison.OrdinalIgnoreCase);
			return UTF8String.Equals(a, b);
		}

		bool Equals_Names(bool caseInsensitive, string a, string b) {
			if (caseInsensitive)
				return (a ?? string.Empty).Equals(b ?? string.Empty, StringComparison.OrdinalIgnoreCase);
			return (a ?? string.Empty) == (b ?? string.Empty);
		}

		int GetHashCode_Name(bool caseInsensitive, string a) {
			if (caseInsensitive)
				return (a ?? string.Empty).ToUpperInvariant().GetHashCode();
			return (a ?? string.Empty).GetHashCode();
		}

		bool Equals_TypeNamespaces(UTF8String a, UTF8String b) {
			return Equals_Names(CaseInsensitiveTypeNamespaces, a, b);
		}

		bool Equals_TypeNamespaces(UTF8String a, string b) {
			return Equals_Names(CaseInsensitiveTypeNamespaces, UTF8String.ToSystemStringOrEmpty(a), b);
		}

		int GetHashCode_TypeNamespace(UTF8String a) {
			return GetHashCode_Name(CaseInsensitiveTypeNamespaces, UTF8String.ToSystemStringOrEmpty(a));
		}

		int GetHashCode_TypeNamespace(string a) {
			return GetHashCode_Name(CaseInsensitiveTypeNamespaces, a);
		}

		bool Equals_TypeNames(UTF8String a, UTF8String b) {
			return Equals_Names(CaseInsensitiveTypeNames, a, b);
		}

		bool Equals_TypeNames(UTF8String a, string b) {
			return Equals_Names(CaseInsensitiveTypeNames, UTF8String.ToSystemStringOrEmpty(a), b);
		}

		int GetHashCode_TypeName(UTF8String a) {
			return GetHashCode_Name(CaseInsensitiveTypeNames, UTF8String.ToSystemStringOrEmpty(a));
		}

		int GetHashCode_TypeName(string a) {
			return GetHashCode_Name(CaseInsensitiveTypeNames, a);
		}

		bool Equals_MethodFieldNames(UTF8String a, UTF8String b) {
			return Equals_Names(CaseInsensitiveMethodFieldNames, a, b);
		}

		bool Equals_MethodFieldNames(UTF8String a, string b) {
			return Equals_Names(CaseInsensitiveMethodFieldNames, UTF8String.ToSystemStringOrEmpty(a), b);
		}

		int GetHashCode_MethodFieldName(UTF8String a) {
			return GetHashCode_Name(CaseInsensitiveMethodFieldNames, UTF8String.ToSystemStringOrEmpty(a));
		}

		int GetHashCode_MethodFieldName(string a) {
			return GetHashCode_Name(CaseInsensitiveMethodFieldNames, a);
		}

		bool Equals_PropertyNames(UTF8String a, UTF8String b) {
			return Equals_Names(CaseInsensitivePropertyNames, a, b);
		}

		bool Equals_PropertyNames(UTF8String a, string b) {
			return Equals_Names(CaseInsensitivePropertyNames, UTF8String.ToSystemStringOrEmpty(a), b);
		}

		int GetHashCode_PropertyName(UTF8String a) {
			return GetHashCode_Name(CaseInsensitivePropertyNames, UTF8String.ToSystemStringOrEmpty(a));
		}

		int GetHashCode_PropertyName(string a) {
			return GetHashCode_Name(CaseInsensitivePropertyNames, a);
		}

		bool Equals_EventNames(UTF8String a, UTF8String b) {
			return Equals_Names(CaseInsensitiveEventNames, a, b);
		}

		bool Equals_EventNames(UTF8String a, string b) {
			return Equals_Names(CaseInsensitiveEventNames, UTF8String.ToSystemStringOrEmpty(a), b);
		}

		int GetHashCode_EventName(UTF8String a) {
			return GetHashCode_Name(CaseInsensitiveEventNames, UTF8String.ToSystemStringOrEmpty(a));
		}

		int GetHashCode_EventName(string a) {
			return GetHashCode_Name(CaseInsensitiveEventNames, a);
		}

		SigComparerOptions ClearOptions(SigComparerOptions flags) {
			var old = options;
			options &= ~flags;
			return old;
		}

		SigComparerOptions SetOptions(SigComparerOptions flags) {
			var old = options;
			options |= flags;
			return old;
		}

		void RestoreOptions(SigComparerOptions oldFlags) {
			options = oldFlags;
		}

		void InitializeGenericArguments() {
			if (genericArguments == null)
				genericArguments = new GenericArguments();
		}

		static GenericInstSig GetGenericInstanceType(IMemberRefParent parent) {
			var ts = parent as TypeSpec;
			if (ts == null)
				return null;
			return ts.TypeSig.RemoveModifiers() as GenericInstSig;
		}

		bool Equals(IAssembly aAsm, IAssembly bAsm, TypeRef b) {
			if (Equals(aAsm, bAsm))
				return true;

			// Could be an exported type. Resolve it and check again.

			var td = b.Resolve(sourceModule);
			return td != null && Equals(aAsm, td.Module.Assembly);
		}

		bool Equals(IAssembly aAsm, IAssembly bAsm, ExportedType b) {
			if (Equals(aAsm, bAsm))
				return true;

			var td = b.Resolve();
			return td != null && Equals(aAsm, td.Module.Assembly);
		}

		bool Equals(IAssembly aAsm, TypeRef a, IAssembly bAsm, TypeRef b) {
			if (Equals(aAsm, bAsm))
				return true;

			// Could be exported types. Resolve them and check again.

			var tda = a.Resolve(sourceModule);
			var tdb = b.Resolve(sourceModule);
			return tda != null && tdb != null && Equals(tda.Module.Assembly, tdb.Module.Assembly);
		}

		bool Equals(IAssembly aAsm, ExportedType a, IAssembly bAsm, ExportedType b) {
			if (Equals(aAsm, bAsm))
				return true;

			var tda = a.Resolve();
			var tdb = b.Resolve();
			return tda != null && tdb != null && Equals(tda.Module.Assembly, tdb.Module.Assembly);
		}

		bool Equals(IAssembly aAsm, TypeRef a, IAssembly bAsm, ExportedType b) {
			if (Equals(aAsm, bAsm))
				return true;

			// Could be an exported type. Resolve it and check again.

			var tda = a.Resolve(sourceModule);
			var tdb = b.Resolve();
			return tda != null && tdb != null && Equals(tda.Module.Assembly, tdb.Module.Assembly);
		}

		bool Equals(TypeDef a, IModule bMod, TypeRef b) {
			if (Equals(a.Module, bMod) && Equals(a.DefinitionAssembly, b.DefinitionAssembly))
				return true;

			// Could be an exported type. Resolve it and check again.

			var td = b.Resolve(sourceModule);
			if (td == null)
				return false;
			if (!DontCheckTypeEquivalence) {
				if (TIAHelper.Equivalent(a, td))
					return true;
			}
			return Equals(a.Module, td.Module) && Equals(a.DefinitionAssembly, td.DefinitionAssembly);
		}

		bool Equals(TypeDef a, FileDef bFile, ExportedType b) {
			if (Equals(a.Module, bFile) && Equals(a.DefinitionAssembly, b.DefinitionAssembly))
				return true;

			var td = b.Resolve();
			return td != null && Equals(a.Module, td.Module) && Equals(a.DefinitionAssembly, td.DefinitionAssembly);
		}

		bool TypeDefScopeEquals(TypeDef a, TypeDef b) {
			if (a == null || b == null)
				return false;
			if (!DontCheckTypeEquivalence) {
				if (TIAHelper.Equivalent(a, b))
					return true;
			}
			return Equals(a.Module, b.Module);
		}

		bool Equals(TypeRef a, IModule ma, TypeRef b, IModule mb) {
			if (Equals(ma, mb) && Equals(a.DefinitionAssembly, b.DefinitionAssembly))
				return true;

			// Could be exported types. Resolve them and check again.

			var tda = a.Resolve(sourceModule);
			var tdb = b.Resolve(sourceModule);
			return tda != null && tdb != null &&
				Equals(tda.Module, tdb.Module) && Equals(tda.DefinitionAssembly, tdb.DefinitionAssembly);
		}

		bool Equals(TypeRef a, IModule ma, ExportedType b, FileDef fb) {
			if (Equals(ma, fb) && Equals(a.DefinitionAssembly, b.DefinitionAssembly))
				return true;

			// Could be an exported type. Resolve it and check again.

			var tda = a.Resolve(sourceModule);
			var tdb = b.Resolve();
			return tda != null && tdb != null &&
				Equals(tda.Module, tdb.Module) && Equals(tda.DefinitionAssembly, tdb.DefinitionAssembly);
		}

		bool Equals(Assembly aAsm, IAssembly bAsm, TypeRef b) {
			if (Equals(bAsm, aAsm))
				return true;

			// Could be an exported type. Resolve it and check again.

			var td = b.Resolve(sourceModule);
			return td != null && Equals(td.Module.Assembly, aAsm);
		}

		bool Equals(Assembly aAsm, IAssembly bAsm, ExportedType b) {
			if (Equals(bAsm, aAsm))
				return true;

			var td = b.Resolve();
			return td != null && Equals(td.Module.Assembly, aAsm);
		}

		bool Equals(Type a, IModule bMod, TypeRef b) {
			if (Equals(bMod, a.Module) && Equals(b.DefinitionAssembly, a.Assembly))
				return true;

			// Could be an exported type. Resolve it and check again.

			var td = b.Resolve(sourceModule);
			return td != null && Equals(td.Module, a.Module) && Equals(td.DefinitionAssembly, a.Assembly);
		}

		bool Equals(Type a, FileDef bFile, ExportedType b) {
			if (Equals(bFile, a.Module) && Equals(b.DefinitionAssembly, a.Assembly))
				return true;

			var td = b.Resolve();
			return td != null && Equals(td.Module, a.Module) && Equals(td.DefinitionAssembly, a.Assembly);
		}

		/// <summary>
		/// Compare members
		/// </summary>
		/// <param name="a">Member #1</param>
		/// <param name="b">Member #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IMemberRef a, IMemberRef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			IType ta, tb;
			IField fa, fb;
			IMethod ma, mb;
			PropertyDef pa, pb;
			EventDef ea, eb;

			if ((ta = a as IType) != null && (tb = b as IType) != null)
				result = Equals(ta, tb);
			else if ((fa = a as IField) != null && (fb = b as IField) != null && fa.IsField && fb.IsField)
				result = Equals(fa, fb);
			else if ((ma = a as IMethod) != null && (mb = b as IMethod) != null)
				result = Equals(ma, mb);
			else if ((pa = a as PropertyDef) != null && (pb = b as PropertyDef) != null)
				result = Equals(pa, pb);
			else if ((ea = a as EventDef) != null && (eb = b as EventDef) != null)
				result = Equals(ea, eb);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a member
		/// </summary>
		/// <param name="a">The member</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IMemberRef a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int result;
			IType ta;
			IField fa;
			IMethod ma;
			PropertyDef pa;
			EventDef ea;

			if ((ta = a as IType) != null)
				result = GetHashCode(ta);
			else if ((fa = a as IField) != null)
				result = GetHashCode(fa);
			else if ((ma = a as IMethod) != null)
				result = GetHashCode(ma);
			else if ((pa = a as PropertyDef) != null)
				result = GetHashCode(pa);
			else if ((ea = a as EventDef) != null)
				result = GetHashCode(ea);
			else
				result = 0;		// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ITypeDefOrRef a, ITypeDefOrRef b) {
			return Equals((IType)a, (IType)b);
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(ITypeDefOrRef a) {
			return GetHashCode((IType)a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IType a, IType b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeDef tda, tdb;
			TypeRef tra, trb;
			TypeSpec tsa, tsb;
			TypeSig sa, sb;
			ExportedType eta, etb;

			if ((tda = a as TypeDef) != null & (tdb = b as TypeDef) != null)
				result = Equals(tda, tdb);
			else if ((tra = a as TypeRef) != null & (trb = b as TypeRef) != null)
				result = Equals(tra, trb);
			else if ((tsa = a as TypeSpec) != null & (tsb = b as TypeSpec) != null)
				result = Equals(tsa, tsb);
			else if ((sa = a as TypeSig) != null & (sb = b as TypeSig) != null)
				result = Equals(sa, sb);
			else if ((eta = a as ExportedType) != null & (etb = b as ExportedType) != null)
				result = Equals(eta, etb);
			else if (tda != null && trb != null)
				result = Equals(tda, trb);		// TypeDef vs TypeRef
			else if (tra != null && tdb != null)
				result = Equals(tdb, tra);		// TypeDef vs TypeRef
			else if (tda != null && tsb != null)
				result = Equals(tda, tsb);		// TypeDef vs TypeSpec
			else if (tsa != null && tdb != null)
				result = Equals(tdb, tsa);		// TypeDef vs TypeSpec
			else if (tda != null && sb != null)
				result = Equals(tda, sb);		// TypeDef vs TypeSig
			else if (sa != null && tdb != null)
				result = Equals(tdb, sa);		// TypeDef vs TypeSig
			else if (tda != null && etb != null)
				result = Equals(tda, etb);		// TypeDef vs ExportedType
			else if (eta != null && tdb != null)
				result = Equals(tdb, eta);		// TypeDef vs ExportedType
			else if (tra != null && tsb != null)
				result = Equals(tra, tsb);		// TypeRef vs TypeSpec
			else if (tsa != null && trb != null)
				result = Equals(trb, tsa);		// TypeRef vs TypeSpec
			else if (tra != null && sb != null)
				result = Equals(tra, sb);		// TypeRef vs TypeSig
			else if (sa != null && trb != null)
				result = Equals(trb, sa);		// TypeRef vs TypeSig
			else if (tra != null && etb != null)
				result = Equals(tra, etb);		// TypeRef vs ExportedType
			else if (eta != null && trb != null)
				result = Equals(trb, eta);		// TypeRef vs ExportedType
			else if (tsa != null && sb != null)
				result = Equals(tsa, sb);		// TypeSpec vs TypeSig
			else if (sa != null && tsb != null)
				result = Equals(tsb, sa);		// TypeSpec vs TypeSig
			else if (tsa != null && etb != null)
				result = Equals(tsa, etb);		// TypeSpec vs ExportedType
			else if (eta != null && tsb != null)
				result = Equals(tsb, eta);		// TypeSpec vs ExportedType
			else if (sa != null && etb != null)
				result = Equals(sa, etb);		// TypeSig vs ExportedType
			else if (eta != null && sb != null)
				result = Equals(sb, eta);		// TypeSig vs ExportedType
			else
				result = false;	// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IType a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash;
			TypeDef td;
			TypeRef tr;
			TypeSpec ts;
			TypeSig sig;
			ExportedType et;

			if ((td = a as TypeDef) != null)
				hash = GetHashCode(td);
			else if ((tr = a as TypeRef) != null)
				hash = GetHashCode(tr);
			else if ((ts = a as TypeSpec) != null)
				hash = GetHashCode(ts);
			else if ((sig = a as TypeSig) != null)
				hash = GetHashCode(sig);
			else if ((et = a as ExportedType) != null)
				hash = GetHashCode(et);
			else
				hash = 0;	// Should never be reached

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, TypeDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, TypeRef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			IModule bMod;
			AssemblyRef bAsm;
			TypeRef dtb;

			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
				if (tra != null) {
					result = Equals(tra, b);
					goto exit;
				}
			}

			var scope = b.ResolutionScope;

			if (!Equals_TypeNames(a.Name, b.Name) || !Equals_TypeNamespaces(a.Namespace, b.Namespace))
				result = false;
			else if ((dtb = scope as TypeRef) != null)	// nested type
				result = Equals(a.DeclaringType, dtb);	// Compare enclosing types
			else if (a.DeclaringType != null) {
				// a is nested, b isn't
				result = false;
			}
			else if (DontCompareTypeScope)
				result = true;
			else if ((bMod = scope as IModule) != null)	// 'b' is defined in the same assembly as 'a'
				result = Equals(a, bMod, b);
			else if ((bAsm = scope as AssemblyRef) != null) {
				var aMod = a.Module;
				result = aMod != null && Equals(aMod.Assembly, bAsm, b);
				if (!result) {
					if (!DontCheckTypeEquivalence) {
						var tdb = b.Resolve();
						result = TypeDefScopeEquals(a, tdb);
					}
				}
			}
			else {
				result = false;
				//TODO: Handle the case where scope == null
			}

			if (result && !TypeRefCanReferenceGlobalType && a.IsGlobalModuleType)
				result = false;
exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, TypeDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ExportedType dtb;
			FileDef bFile;
			AssemblyRef bAsm;
			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
				if (tra != null) {
					result = Equals(tra, b);
					goto exit;
				}
			}

			var scope = b.Implementation;

			if (!Equals_TypeNames(a.Name, b.TypeName) || !Equals_TypeNamespaces(a.Namespace, b.TypeNamespace))
				result = false;
			else if ((dtb = scope as ExportedType) != null) {	// nested type
				result = Equals(a.DeclaringType, dtb);	// Compare enclosing types
			}
			else if (a.DeclaringType != null) {
				result = false;	// a is nested, b isn't
			}
			else if (DontCompareTypeScope)
				result = true;
			else {
				if ((bFile = scope as FileDef) != null)
					result = Equals(a, bFile, b);
				else if ((bAsm = scope as AssemblyRef) != null) {
					var aMod = a.Module;
					result = aMod != null && Equals(aMod.Assembly, bAsm, b);
				}
				else
					result = false;
				if (!result && !DontCheckTypeEquivalence) {
					var tdb = b.Resolve();
					result = TypeDefScopeEquals(a, tdb);
				}
			}

			if (result && !TypeRefCanReferenceGlobalType && a.IsGlobalModuleType)
				result = false;
exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, TypeDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, TypeSpec b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			return Equals(a, b.TypeSig);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, TypeDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, TypeSig b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			//*************************************************************
			// If this code gets updated, update GetHashCode(TypeSig),
			// Equals(TypeRef,TypeSig) and Equals(TypeSig,ExportedType) too
			//*************************************************************
			var b2 = b as TypeDefOrRefSig;
			if (b2 != null)
				result = Equals(a, (IType)b2.TypeDefOrRef);
			else if (b is ModifierSig || b is PinnedSig)
				result = Equals(a, b.Next);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, TypeRef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, TypeSpec b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			return Equals(a, b.TypeSig);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, TypeRef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}
			bool result = Equals_TypeNames(a.Name, b.TypeName) &&
					Equals_TypeNamespaces(a.Namespace, b.TypeNamespace) &&
					EqualsScope(a, b);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, TypeRef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, TypeSig b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			//*************************************************************
			// If this code gets updated, update GetHashCode(TypeSig),
			// Equals(TypeRef,TypeSig) and Equals(TypeSig,ExportedType) too
			//*************************************************************
			var b2 = b as TypeDefOrRefSig;
			if (b2 != null)
				result = Equals(a, (IType)b2.TypeDefOrRef);
			else if (b is ModifierSig || b is PinnedSig)
				result = Equals(a, b.Next);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, TypeSpec b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, TypeSig b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			return Equals(a.TypeSig, b);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, TypeSpec b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			return Equals(a.TypeSig, b);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, TypeSig b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			//*************************************************************
			// If this code gets updated, update GetHashCode(TypeSig),
			// Equals(TypeRef,TypeSig) and Equals(TypeSig,ExportedType) too
			//*************************************************************
			var a2 = a as TypeDefOrRefSig;
			if (a2 != null)
				result = Equals(a2.TypeDefOrRef, b);
			else if (a is ModifierSig || a is PinnedSig)
				result = Equals(a.Next, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		int GetHashCodeGlobalType() {
			// We don't always know the name+namespace of the global type, eg. when it's
			// referenced by a ModuleRef. Use the same hash for all global types.
			return HASHCODE_MAGIC_GLOBAL_TYPE;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, TypeRef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}
			bool result = Equals_TypeNames(a.Name, b.Name) &&
					Equals_TypeNamespaces(a.Namespace, b.Namespace) &&
					EqualsResolutionScope(a, b);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(TypeRef a) {
			// ************************************************************************************
			// IMPORTANT: This hash code must match the Type/TypeRef/TypeDef/ExportedType
			// hash code and GetHashCode_FnPtr_SystemIntPtr() method
			// ************************************************************************************

			// See GetHashCode(Type) for the reason why null returns GetHashCodeGlobalType()
			if (a == null)
				return TypeRefCanReferenceGlobalType ? GetHashCodeGlobalType() : 0;
			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;

			int hash;
			hash = GetHashCode_TypeName(a.Name);
			if (a.ResolutionScope is TypeRef)
				hash += HASHCODE_MAGIC_NESTED_TYPE;
			else
				hash += GetHashCode_TypeNamespace(a.Namespace);
			return hash;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, ExportedType b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}
			bool result = Equals_TypeNames(a.TypeName, b.TypeName) &&
					Equals_TypeNamespaces(a.TypeNamespace, b.TypeNamespace) &&
					EqualsImplementation(a, b);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(ExportedType a) {
			// ************************************************************************************
			// IMPORTANT: This hash code must match the Type/TypeRef/TypeDef/ExportedType
			// hash code and GetHashCode_FnPtr_SystemIntPtr() method
			// ************************************************************************************

			// See GetHashCode(Type) for the reason why null returns GetHashCodeGlobalType()
			if (a == null)
				return TypeRefCanReferenceGlobalType ? GetHashCodeGlobalType() : 0;
			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
			int hash;
			hash = GetHashCode_TypeName(a.TypeName);
			if (a.Implementation is ExportedType)
				hash += HASHCODE_MAGIC_NESTED_TYPE;
			else
				hash += GetHashCode_TypeNamespace(a.TypeNamespace);
			return hash;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, TypeDef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;

			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				var trb = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b);
				if (tra != null || trb != null) {
					result = Equals((IType)tra ?? a, (IType)trb ?? b);
					goto exit;
				}
			}
			result = Equals_TypeNames(a.Name, b.Name) &&
					Equals_TypeNamespaces(a.Namespace, b.Namespace) &&
					Equals(a.DeclaringType, b.DeclaringType) &&
					(DontCompareTypeScope || TypeDefScopeEquals(a, b));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(TypeDef a) {
			// ************************************************************************************
			// IMPORTANT: This hash code must match the Type/TypeRef/TypeDef/ExportedType
			// hash code and GetHashCode_FnPtr_SystemIntPtr() method
			// ************************************************************************************

			// See GetHashCode(Type) for the reason why null returns GetHashCodeGlobalType()
			if (a == null || a.IsGlobalModuleType)
				return GetHashCodeGlobalType();
			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				if (tra != null)
					return GetHashCode(tra);
			}

			int hash;
			hash = GetHashCode_TypeName(a.Name);
			if (a.DeclaringType != null)
				hash += HASHCODE_MAGIC_NESTED_TYPE;
			else
				hash += GetHashCode_TypeNamespace(a.Namespace);
			return hash;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, TypeSpec b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals(a.TypeSig, b.TypeSig);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(TypeSpec a) {
			if (a == null)
				return 0;
			return GetHashCode(a.TypeSig);
		}

		/// <summary>
		/// Compares resolution scopes
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool EqualsResolutionScope(TypeRef a, TypeRef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			var ra = a.ResolutionScope;
			var rb = b.ResolutionScope;
			if (ra == rb)
				return true;
			if (ra == null || rb == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeRef ea, eb;
			IModule ma, mb;
			AssemblyRef aa, ab;
			ModuleDef modDef;
			bool resolveCheck = true;

			// if one of them is a TypeRef, the other one must be too
			if ((ea = ra as TypeRef) != null | (eb = rb as TypeRef) != null) {
				result = Equals(ea, eb);
				resolveCheck = false;
			}
			else if (DontCompareTypeScope)
				result = true;
			// only compare if both are modules
			else if ((ma = ra as IModule) != null & (mb = rb as IModule) != null)
				result = Equals(a, ma, b, mb);
			// only compare if both are assemblies
			else if ((aa = ra as AssemblyRef) != null & (ab = rb as AssemblyRef) != null)
				result = Equals(aa, a, ab, b);
			else if (aa != null && rb is ModuleRef) {
				var bMod = b.Module;
				result = bMod != null && Equals(bMod.Assembly, b, aa, a);
			}
			else if (ab != null && ra is ModuleRef) {
				var aMod = a.Module;
				result = aMod != null && Equals(aMod.Assembly, a, ab, b);
			}
			else if (aa != null && (modDef = rb as ModuleDef) != null)
				result = Equals(modDef.Assembly, aa, a);
			else if (ab != null && (modDef = ra as ModuleDef) != null)
				result = Equals(modDef.Assembly, ab, b);
			else {
				result = false;
				resolveCheck = false;
			}
			if (!result && resolveCheck) {
				if (!DontCheckTypeEquivalence) {
					var td1 = a.Resolve();
					var td2 = b.Resolve();
					if (td1 != null && td2 != null)
						result = TypeDefScopeEquals(td1, td2);
				}
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares implementation
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool EqualsImplementation(ExportedType a, ExportedType b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			var ia = a.Implementation;
			var ib = b.Implementation;
			if (ia == ib)
				return true;
			if (ia == null || ib == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ExportedType ea, eb;
			FileDef fa, fb;
			AssemblyRef aa, ab;
			bool checkResolve = true;

			// if one of them is an ExportedType, the other one must be too
			if ((ea = ia as ExportedType) != null | (eb = ib as ExportedType) != null) {
				result = Equals(ea, eb);
				checkResolve = false;
			}
			else if (DontCompareTypeScope)
				result = true;
			// only compare if both are files
			else if ((fa = ia as FileDef) != null & (fb = ib as FileDef) != null)
				result = Equals(fa, fb);
			// only compare if both are assemblies
			else if ((aa = ia as AssemblyRef) != null & (ab = ib as AssemblyRef) != null)
				result = Equals(aa, a, ab, b);
			else if (fa != null && ab != null)
				result = Equals(a.DefinitionAssembly, ab, b);
			else if (fb != null && aa != null)
				result = Equals(b.DefinitionAssembly, aa, a);
			else {
				result = false;
				checkResolve = false;
			}
			if (!result && checkResolve && !DontCheckTypeEquivalence) {
				var td1 = a.Resolve();
				var td2 = b.Resolve();
				if (td1 != null && td2 != null)
					result = TypeDefScopeEquals(td1, td2);
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares resolution scope and implementation
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool EqualsScope(TypeRef a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			var ra = a.ResolutionScope;
			var ib = b.Implementation;
			if (ra == ib)
				return true;
			if (ra == null || ib == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeRef ea;
			ExportedType eb;
			IModule ma;
			FileDef fb;
			AssemblyRef aa, ab;
			bool checkResolve = true;

			// If one is a nested type, the other one must be too
			if ((ea = ra as TypeRef) != null | (eb = ib as ExportedType) != null) {
				result = Equals(ea, eb);
				checkResolve = false;
			}
			else if (DontCompareTypeScope)
				result = true;
			else if ((ma = ra as IModule) != null & (fb = ib as FileDef) != null)
				result = Equals(a, ma, b, fb);
			else if ((aa = ra as AssemblyRef) != null & (ab = ib as AssemblyRef) != null)
				result = Equals(aa, a, ab, b);
			else if (ma != null && ab != null)
				result = Equals(a.DefinitionAssembly, ab, b);
			else if (fb != null && aa != null)
				result = Equals(b.DefinitionAssembly, aa, a);
			else {
				checkResolve = false;
				result = false;
			}
			if (!result && checkResolve && !DontCheckTypeEquivalence) {
				var td1 = a.Resolve();
				var td2 = b.Resolve();
				if (td1 != null && td2 != null)
					result = TypeDefScopeEquals(td1, td2);
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares files
		/// </summary>
		/// <param name="a">File #1</param>
		/// <param name="b">File #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(FileDef a, FileDef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;

			return UTF8String.CaseInsensitiveEquals(a.Name, b.Name);
		}

		/// <summary>
		/// Compares a module with a file
		/// </summary>
		/// <param name="a">Module</param>
		/// <param name="b">File</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IModule a, FileDef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;

			//TODO: You should compare against the module's file name, not the name in the metadata!
			return UTF8String.CaseInsensitiveEquals(a.Name, b.Name);
		}

		/// <summary>
		/// Compares modules
		/// </summary>
		/// <param name="a">Module #1</param>
		/// <param name="b">Module #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal bool Equals(IModule a, IModule b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;

			return UTF8String.CaseInsensitiveEquals(a.Name, b.Name);
		}

		static bool IsCorLib(ModuleDef a) {
			return a != null && a.IsManifestModule && a.Assembly.IsCorLib();
		}

		static bool IsCorLib(IModule a) {
			var mod = a as ModuleDef;
			return mod != null && mod.IsManifestModule && mod.Assembly.IsCorLib();
		}

		static bool IsCorLib(Module a) {
			return a != null && a.Assembly.ManifestModule == a && a.Assembly == typeof(void).Assembly;
		}

		static bool IsCorLib(IAssembly a) {
			return a.IsCorLib();
		}

		static bool IsCorLib(Assembly a) {
			return a == typeof(void).Assembly;
		}

		/// <summary>
		/// Compares modules
		/// </summary>
		/// <param name="a">Module #1</param>
		/// <param name="b">Module #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(ModuleDef a, ModuleDef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals((IModule)a, (IModule)b) && Equals(a.Assembly, b.Assembly);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares assemblies
		/// </summary>
		/// <param name="a">Assembly #1</param>
		/// <param name="b">Assembly #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IAssembly a, IAssembly b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;
			if (!recursionCounter.Increment())
				return false;

			bool result = UTF8String.CaseInsensitiveEquals(a.Name, b.Name) &&
				(!CompareAssemblyPublicKeyToken || PublicKeyBase.TokenEquals(a.PublicKeyOrToken, b.PublicKeyOrToken)) &&
				(!CompareAssemblyVersion || Utils.Equals(a.Version, b.Version)) &&
				(!CompareAssemblyLocale || Utils.LocaleEquals(a.Culture, b.Culture));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, TypeSig b) {
			if (IgnoreModifiers) {
				a = a.RemoveModifiers();
				b = b.RemoveModifiers();
			}
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}

			if (a.ElementType != b.ElementType) {
				// Signatures must be identical. It's possible to have a U4 in a sig (short form
				// of System.UInt32), or a ValueType + System.UInt32 TypeRef (long form), but these
				// should not match in a sig (also the long form is invalid).
				result = false;
			}
			else {
				switch (a.ElementType) {
				case ElementType.Void:
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.String:
				case ElementType.TypedByRef:
				case ElementType.I:
				case ElementType.U:
				case ElementType.Object:
				case ElementType.Sentinel:
					result = true;
					break;

				case ElementType.Ptr:
				case ElementType.ByRef:
				case ElementType.SZArray:
				case ElementType.Pinned:
					result = Equals(a.Next, b.Next);
					break;

				case ElementType.Array:
					ArraySig ara = a as ArraySig, arb = b as ArraySig;
					result = ara.Rank == arb.Rank &&
							Equals(ara.Sizes, arb.Sizes) &&
							Equals(ara.LowerBounds, arb.LowerBounds) &&
							Equals(a.Next, b.Next);
					break;

				case ElementType.ValueType:
				case ElementType.Class:
					if (RawSignatureCompare)
						result = TokenEquals((a as ClassOrValueTypeSig).TypeDefOrRef, (b as ClassOrValueTypeSig).TypeDefOrRef);
					else
						result = Equals((IType)(a as ClassOrValueTypeSig).TypeDefOrRef, (IType)(b as ClassOrValueTypeSig).TypeDefOrRef);
					break;

				case ElementType.Var:
				case ElementType.MVar:
					result = (a as GenericSig).Number == (b as GenericSig).Number;
					break;

				case ElementType.GenericInst:
					var gia = (GenericInstSig)a;
					var gib = (GenericInstSig)b;
					if (RawSignatureCompare) {
						var gt1 = gia.GenericType;
						var gt2 = gib.GenericType;
						result = TokenEquals(gt1 == null ? null : gt1.TypeDefOrRef, gt2 == null ? null : gt2.TypeDefOrRef) &&
								Equals(gia.GenericArguments, gib.GenericArguments);
					}
					else {
						result = Equals(gia.GenericType, gib.GenericType) &&
								Equals(gia.GenericArguments, gib.GenericArguments);
					}
					break;

				case ElementType.FnPtr:
					result = Equals((a as FnPtrSig).Signature, (b as FnPtrSig).Signature);
					break;

				case ElementType.CModReqd:
				case ElementType.CModOpt:
					if (RawSignatureCompare)
						result = TokenEquals((a as ModifierSig).Modifier, (b as ModifierSig).Modifier) &&
								Equals(a.Next, b.Next);
					else
						result = Equals((IType)(a as ModifierSig).Modifier, (IType)(b as ModifierSig).Modifier) &&
								Equals(a.Next, b.Next);
					break;

				case ElementType.ValueArray:
					result = (a as ValueArraySig).Size == (b as ValueArraySig).Size && Equals(a.Next, b.Next);
					break;

				case ElementType.Module:
					result = (a as ModuleSig).Index == (b as ModuleSig).Index && Equals(a.Next, b.Next);
					break;

				case ElementType.End:
				case ElementType.R:
				case ElementType.Internal:
				default:
					result = false;
					break;
				}
			}

			recursionCounter.Decrement();
			return result;
		}

		static bool TokenEquals(ITypeDefOrRef a, ITypeDefOrRef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			return a.MDToken == b.MDToken;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(TypeSig a) {
			// ********************************************
			// IMPORTANT: This must match GetHashCode(Type)
			// ********************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			if (genericArguments != null)
				a = genericArguments.Resolve(a);

			switch (a.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				// When comparing an ExportedType/TypeDef/TypeRef to a TypeDefOrRefSig/Class/ValueType,
				// the ET is ignored, so we must ignore it when calculating the hash.
				hash = GetHashCode((IType)(a as TypeDefOrRefSig).TypeDefOrRef);
				break;

			case ElementType.Sentinel:
				hash = HASHCODE_MAGIC_ET_SENTINEL;
				break;

			case ElementType.Ptr:
				hash = HASHCODE_MAGIC_ET_PTR + GetHashCode(a.Next);
				break;

			case ElementType.ByRef:
				hash = HASHCODE_MAGIC_ET_BYREF + GetHashCode(a.Next);
				break;

			case ElementType.SZArray:
				hash = HASHCODE_MAGIC_ET_SZARRAY + GetHashCode(a.Next);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
				// When comparing an ExportedType/TypeDef/TypeRef to a ModifierSig/PinnedSig,
				// the ET is ignored, so we must ignore it when calculating the hash.
				hash = GetHashCode(a.Next);
				break;

			case ElementType.Array:
				// Don't include sizes and lower bounds since GetHashCode(Type) doesn't (and can't).
				ArraySig ara = (ArraySig)a;
				hash = HASHCODE_MAGIC_ET_ARRAY + (int)ara.Rank + GetHashCode(ara.Next);
				break;

			case ElementType.Var:
				hash = HASHCODE_MAGIC_ET_VAR + (int)(a as GenericVar).Number;
				break;

			case ElementType.MVar:
				hash = HASHCODE_MAGIC_ET_MVAR + (int)(a as GenericMVar).Number;
				break;

			case ElementType.GenericInst:
				var gia = (GenericInstSig)a;
				hash = HASHCODE_MAGIC_ET_GENERICINST;
				if (SubstituteGenericParameters) {
					InitializeGenericArguments();
					genericArguments.PushTypeArgs(gia.GenericArguments);
					hash += GetHashCode(gia.GenericType);
					genericArguments.PopTypeArgs();
				}
				else
					hash += GetHashCode(gia.GenericType);
				hash += GetHashCode(gia.GenericArguments);
				break;

			case ElementType.FnPtr:
				hash = GetHashCode_FnPtr_SystemIntPtr();
				break;

			case ElementType.ValueArray:
				hash = HASHCODE_MAGIC_ET_VALUEARRAY + (int)(a as ValueArraySig).Size + GetHashCode(a.Next);
				break;

			case ElementType.Module:
				hash = HASHCODE_MAGIC_ET_MODULE + (int)(a as ModuleSig).Index + GetHashCode(a.Next);
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				hash = 0;
				break;
			}

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares type lists
		/// </summary>
		/// <param name="a">Type list #1</param>
		/// <param name="b">Type list #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IList<TypeSig> a, IList<TypeSig> b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.Count != b.Count)
				result = false;
			else {
				int i;
				for (i = 0; i < a.Count; i++) {
					if (!Equals(a[i], b[i]))
						break;
				}
				result = i == a.Count;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type list
		/// </summary>
		/// <param name="a">The type list</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IList<TypeSig> a) {
			//************************************************************************
			// IMPORTANT: This code must match any other GetHashCode(IList<SOME_TYPE>)
			//************************************************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			uint hash = 0;
			for (int i = 0; i < a.Count; i++) {
				hash += (uint)GetHashCode(a[i]);
				hash = (hash << 13) | (hash >> 19);
			}
			recursionCounter.Decrement();
			return (int)hash;
		}

		bool Equals(IList<uint> a, IList<uint> b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (a.Count != b.Count)
				return false;
			for (int i = 0; i < a.Count; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		bool Equals(IList<int> a, IList<int> b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (a.Count != b.Count)
				return false;
			for (int i = 0; i < a.Count; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		/// <summary>
		/// Compares signatures
		/// </summary>
		/// <param name="a">Sig #1</param>
		/// <param name="b">Sig #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(CallingConventionSig a, CallingConventionSig b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.GetCallingConvention() != b.GetCallingConvention())
				result = false;
			else {
				switch (a.GetCallingConvention() & CallingConvention.Mask) {
				case CallingConvention.Default:
				case CallingConvention.C:
				case CallingConvention.StdCall:
				case CallingConvention.ThisCall:
				case CallingConvention.FastCall:
				case CallingConvention.VarArg:
				case CallingConvention.Property:
				case CallingConvention.NativeVarArg:
					MethodBaseSig ma = a as MethodBaseSig, mb = b as MethodBaseSig;
					result = ma != null && mb != null && Equals(ma, mb);
					break;

				case CallingConvention.Field:
					FieldSig fa = a as FieldSig, fb = b as FieldSig;
					result = fa != null && fb != null && Equals(fa, fb);
					break;

				case CallingConvention.LocalSig:
					LocalSig la = a as LocalSig, lb = b as LocalSig;
					result = la != null && lb != null && Equals(la, lb);
					break;

				case CallingConvention.GenericInst:
					GenericInstMethodSig ga = a as GenericInstMethodSig, gb = b as GenericInstMethodSig;
					result = ga != null && gb != null && Equals(ga, gb);
					break;

				case CallingConvention.Unmanaged:
				default:
					result = false;
					break;
				}
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a sig
		/// </summary>
		/// <param name="a">The sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(CallingConventionSig a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			switch (a.GetCallingConvention() & CallingConvention.Mask) {
			case CallingConvention.Default:
			case CallingConvention.C:
			case CallingConvention.StdCall:
			case CallingConvention.ThisCall:
			case CallingConvention.FastCall:
			case CallingConvention.VarArg:
			case CallingConvention.Property:
			case CallingConvention.NativeVarArg:
				MethodBaseSig ma = a as MethodBaseSig;
				hash = ma == null ? 0 : GetHashCode(ma);
				break;

			case CallingConvention.Field:
				FieldSig fa = a as FieldSig;
				hash = fa == null ? 0 : GetHashCode(fa);
				break;

			case CallingConvention.LocalSig:
				LocalSig la = a as LocalSig;
				hash = la == null ? 0 : GetHashCode(la);
				break;

			case CallingConvention.GenericInst:
				GenericInstMethodSig ga = a as GenericInstMethodSig;
				hash = ga == null ? 0 : GetHashCode(ga);
				break;

			case CallingConvention.Unmanaged:
			default:
				hash = GetHashCode_CallingConvention(a);
				break;
			}

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares method/property sigs
		/// </summary>
		/// <param name="a">Method/property #1</param>
		/// <param name="b">Method/property #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBaseSig a, MethodBaseSig b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.GetCallingConvention() == b.GetCallingConvention() &&
					(DontCompareReturnType || Equals(a.RetType, b.RetType)) &&
					Equals(a.Params, b.Params) &&
					(!a.Generic || a.GenParamCount == b.GenParamCount) &&
					(!CompareSentinelParams || Equals(a.ParamsAfterSentinel, b.ParamsAfterSentinel));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a method/property sig
		/// </summary>
		/// <param name="a">The method/property sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MethodBaseSig a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a) +
					GetHashCode(a.Params);
			if (!DontCompareReturnType)
				hash += GetHashCode(a.RetType);
			if (a.Generic)
				hash += GetHashCode_ElementType_MVar((int)a.GenParamCount);
			if (CompareSentinelParams)
				hash += GetHashCode(a.ParamsAfterSentinel);

			recursionCounter.Decrement();
			return hash;
		}

		int GetHashCode_CallingConvention(CallingConventionSig a) {
			return GetHashCode(a.GetCallingConvention());
		}

		int GetHashCode(CallingConvention a) {
			//*******************************************************************
			// IMPORTANT: This hash must match the Reflection call conv hash code
			//*******************************************************************

			switch (a & CallingConvention.Mask) {
			case CallingConvention.Default:
			case CallingConvention.C:
			case CallingConvention.StdCall:
			case CallingConvention.ThisCall:
			case CallingConvention.FastCall:
			case CallingConvention.VarArg:
			case CallingConvention.Property:
			case CallingConvention.GenericInst:
			case CallingConvention.Unmanaged:
			case CallingConvention.NativeVarArg:
			case CallingConvention.Field:
				return (int)(a & (CallingConvention.Generic | CallingConvention.HasThis | CallingConvention.ExplicitThis));

			case CallingConvention.LocalSig:
			default:
				return (int)a;
			}
		}

		/// <summary>
		/// Compares field sigs
		/// </summary>
		/// <param name="a">Field sig #1</param>
		/// <param name="b">Field sig #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldSig a, FieldSig b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.GetCallingConvention() == b.GetCallingConvention() && Equals(a.Type, b.Type);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a field sig
		/// </summary>
		/// <param name="a">The field sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(FieldSig a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a) + GetHashCode(a.Type);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares local sigs
		/// </summary>
		/// <param name="a">Local sig #1</param>
		/// <param name="b">Local sig #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(LocalSig a, LocalSig b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.GetCallingConvention() == b.GetCallingConvention() && Equals(a.Locals, b.Locals);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a local sig
		/// </summary>
		/// <param name="a">The local sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(LocalSig a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a) + GetHashCode(a.Locals);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares generic method instance sigs
		/// </summary>
		/// <param name="a">Generic inst method #1</param>
		/// <param name="b">Generic inst method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(GenericInstMethodSig a, GenericInstMethodSig b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.GetCallingConvention() == b.GetCallingConvention() && Equals(a.GenericArguments, b.GenericArguments);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a generic instance method sig
		/// </summary>
		/// <param name="a">The generic inst method sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(GenericInstMethodSig a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a) + GetHashCode(a.GenericArguments);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IMethod a, IMethod b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			MethodDef mda, mdb;
			MemberRef mra, mrb;
			MethodSpec msa, msb;

			if ((mda = a as MethodDef) != null & (mdb = b as MethodDef) != null)
				result = Equals(mda, mdb);
			else if ((mra = a as MemberRef) != null & (mrb = b as MemberRef) != null)
				result = Equals(mra, mrb);
			else if ((msa = a as MethodSpec) != null && (msb = b as MethodSpec) != null)
				result = Equals(msa, msb);
			else if (mda != null && mrb != null)
				result = Equals(mda, mrb);
			else if (mra != null && mdb != null)
				result = Equals(mdb, mra);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a method
		/// </summary>
		/// <param name="a">The method</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IMethod a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash;
			MethodDef mda;
			MemberRef mra;
			MethodSpec msa;

			if ((mda = a as MethodDef) != null)
				hash = GetHashCode(mda);
			else if ((mra = a as MemberRef) != null)
				hash = GetHashCode(mra);
			else if ((msa = a as MethodSpec) != null)
				hash = GetHashCode(msa);
			else
				hash = 0;

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, MethodDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodDef a, MemberRef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			if (!DontProjectWinMDRefs) {
				var mra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
				if (mra != null) {
					result = Equals(mra, b);
					goto exit;
				}
			}
			result = (PrivateScopeMethodIsComparable || !a.IsPrivateScope) &&
					Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.Class));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodDef a, MethodDef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			if (!DontProjectWinMDRefs) {
				var mra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				var mrb = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b);
				if (mra != null || mrb != null) {
					result = Equals((IMethod)mra ?? a, (IMethod)mrb ?? b);
					goto exit;
				}
			}
			result = Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a method
		/// </summary>
		/// <param name="a">The method</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MethodDef a) {
			// ***********************************************************************
			// IMPORTANT: This hash code must match the MemberRef/MethodBase hash code
			// ***********************************************************************
			if (a == null)
				return 0;
			if (!DontProjectWinMDRefs) {
				var mra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				if (mra != null)
					return GetHashCode(mra);
			}

			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_MethodFieldName(a.Name) +
					GetHashCode(a.Signature);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares <c>MemberRef</c>s
		/// </summary>
		/// <param name="a"><c>MemberRef</c> #1</param>
		/// <param name="b"><c>MemberRef</c> #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, MemberRef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}
			bool result = Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.Class, b.Class));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a <c>MemberRef</c>
		/// </summary>
		/// <param name="a">The <c>MemberRef</c></param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MemberRef a) {
			// ********************************************************************************
			// IMPORTANT: This hash code must match the MethodDef/FieldDef/MethodBase hash code
			// ********************************************************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;

			int hash = GetHashCode_MethodFieldName(a.Name);
			GenericInstSig git;
			if (SubstituteGenericParameters && (git = GetGenericInstanceType(a.Class)) != null) {
				InitializeGenericArguments();
				genericArguments.PushTypeArgs(git.GenericArguments);
				hash += GetHashCode(a.Signature);
				genericArguments.PopTypeArgs();
			}
			else
				hash += GetHashCode(a.Signature);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.Class);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares <c>MethodSpec</c>s
		/// </summary>
		/// <param name="a"><c>MethodSpec</c> #1</param>
		/// <param name="b"><c>MethodSpec</c> #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodSpec a, MethodSpec b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals(a.Method, b.Method) && Equals(a.Instantiation, b.Instantiation);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a <c>MethodSpec</c>
		/// </summary>
		/// <param name="a">The <c>MethodSpec</c></param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MethodSpec a) {
			// *************************************************************
			// IMPORTANT: This hash code must match the MethodBase hash code
			// *************************************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			// We must do this or it won't get the same hash code as some MethodInfos
			var oldOptions = SetOptions(SigComparerOptions.SubstituteGenericParameters);
			var gim = a.GenericInstMethodSig;
			if (gim != null) {
				InitializeGenericArguments();
				genericArguments.PushMethodArgs(gim.GenericArguments);
			}
			int hash = GetHashCode(a.Method);
			if (gim != null)
				genericArguments.PopMethodArgs();
			RestoreOptions(oldOptions);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares <c>MemberRefParent</c>s
		/// </summary>
		/// <param name="a"><c>MemberRefParent</c> #1</param>
		/// <param name="b"><c>MemberRefParent</c> #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IMemberRefParent a, IMemberRefParent b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ITypeDefOrRef ita, itb;
			ModuleRef moda, modb;
			MethodDef ma, mb;
			TypeDef td;

			if ((ita = a as ITypeDefOrRef) != null && (itb = b as ITypeDefOrRef) != null)
				result = Equals((IType)ita, (IType)itb);
			else if ((moda = a as ModuleRef) != null & (modb = b as ModuleRef) != null) {
				ModuleDef omoda = moda.Module, omodb = modb.Module;
				result = Equals((IModule)moda, (IModule)modb) &&
						Equals(omoda == null ? null : omoda.Assembly, omodb == null ? null : omodb.Assembly);
			}
			else if ((ma = a as MethodDef) != null && (mb = b as MethodDef) != null)
				result = Equals(ma, mb);
			else if (modb != null && (td = a as TypeDef) != null)
				result = EqualsGlobal(td, modb);
			else if (moda != null && (td = b as TypeDef) != null)
				result = EqualsGlobal(td, moda);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a <c>MemberRefParent</c>
		/// </summary>
		/// <param name="a">The <c>MemberRefParent</c></param>
		/// <returns>The hash code</returns>
		int GetHashCode(IMemberRefParent a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash;
			ITypeDefOrRef ita;
			MethodDef ma;

			if ((ita = a as ITypeDefOrRef) != null)
				hash = GetHashCode((IType)ita);
			else if (a is ModuleRef)
				hash = GetHashCodeGlobalType();
			else if ((ma = a as MethodDef) != null) {
				// Only use the declaring type so we get the same hash code when hashing a MethodBase.
				hash = GetHashCode(ma.DeclaringType);
			}
			else
				hash = 0;

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IField a, IField b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			FieldDef fa, fb;
			MemberRef ma, mb;

			if ((fa = a as FieldDef) != null & (fb = b as FieldDef) != null)
				result = Equals(fa, fb);
			else if ((ma = a as MemberRef) != null & (mb = b as MemberRef) != null)
				result = Equals(ma, mb);
			else if (fa != null && mb != null)
				result = Equals(fa, mb);
			else if (fb != null && ma != null)
				result = Equals(fb, ma);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a field
		/// </summary>
		/// <param name="a">The field</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IField a) {
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash;
			FieldDef fa;
			MemberRef ma;

			if ((fa = a as FieldDef) != null)
				hash = GetHashCode(fa);
			else if ((ma = a as MemberRef) != null)
				hash = GetHashCode(ma);
			else
				hash = 0;

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, FieldDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldDef a, MemberRef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = (PrivateScopeFieldIsComparable || !a.IsPrivateScope) &&
					Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.Class));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldDef a, FieldDef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a field
		/// </summary>
		/// <param name="a">The field</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(FieldDef a) {
			// **********************************************************************
			// IMPORTANT: This hash code must match the MemberRef/FieldInfo hash code
			// **********************************************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_MethodFieldName(a.Name) +
					GetHashCode(a.Signature);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares properties
		/// </summary>
		/// <param name="a">Property #1</param>
		/// <param name="b">Property #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(PropertyDef a, PropertyDef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_PropertyNames(a.Name, b.Name) &&
					Equals(a.Type, b.Type) &&
					(!ComparePropertyDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a property
		/// </summary>
		/// <param name="a">The property</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(PropertyDef a) {
			// ***************************************************************
			// IMPORTANT: This hash code must match the PropertyInfo hash code
			// ***************************************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			var sig = a.PropertySig;
			int hash = GetHashCode_PropertyName(a.Name) +
					GetHashCode(sig == null ? null : sig.RetType);
			if (ComparePropertyDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares events
		/// </summary>
		/// <param name="a">Event #1</param>
		/// <param name="b">Event #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(EventDef a, EventDef b) {
			if (a == b)
				return true;
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_EventNames(a.Name, b.Name) &&
					Equals((IType)a.EventType, (IType)b.EventType) &&
					(!CompareEventDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of an event
		/// </summary>
		/// <param name="a">The event</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(EventDef a) {
			// ************************************************************
			// IMPORTANT: This hash code must match the EventInfo hash code
			// ************************************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_EventName(a.Name) +
					GetHashCode((IType)a.EventType);
			if (CompareEventDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		// Compares a with b, and a must be the global type
		bool EqualsGlobal(TypeDef a, ModuleRef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.IsGlobalModuleType &&
				Equals((IModule)a.Module, (IModule)b) &&
				Equals(a.DefinitionAssembly, GetAssembly(b.Module));

			recursionCounter.Decrement();
			return result;
		}

		static AssemblyDef GetAssembly(ModuleDef module) {
			return module == null ? null : module.Assembly;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, IType b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IType a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeDef td;
			TypeRef tr;
			TypeSpec ts;
			TypeSig sig;
			ExportedType et;

			if ((td = a as TypeDef) != null)
				result = Equals(td, b);
			else if ((tr = a as TypeRef) != null)
				result = Equals(tr, b);
			else if ((ts = a as TypeSpec) != null)
				result = Equals(ts, b);
			else if ((sig = a as TypeSig) != null)
				result = Equals(sig, b);
			else if ((et = a as ExportedType) != null)
				result = Equals(et, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, TypeDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a == null)
				return false;
			if ((object)b == null)
				return a.IsGlobalModuleType;
			if (!recursionCounter.Increment())
				return false;

			bool result;

			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				if (tra != null) {
					result = Equals(tra, b);
					goto exit;
				}
			}
			result = !b.HasElementType &&
					Equals_TypeNames(a.Name, b.Name) &&
					Equals_TypeNamespaces(a.Namespace, b) &&
					EnclosingTypeEquals(a.DeclaringType, b.DeclaringType) &&
					(DontCompareTypeScope || Equals(a.Module, b.Module));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		bool EnclosingTypeEquals(TypeDef a, Type b) {
			// b == null doesn't mean that b is the global type
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			return Equals(a, b);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, TypeRef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="b">Type #1</param>
		/// <param name="a">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a == null)
				return false;
			if ((object)b == null)
				return false;	// Must use a ModuleRef to reference the global type, so always fail
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeRef dta;
			IModule aMod;
			AssemblyRef aAsm;
			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;

			var scope = a.ResolutionScope;

			if (!b.IsTypeDef())
				result = false;
			else if (!Equals_TypeNames(a.Name, b.Name) || !Equals_TypeNamespaces(a.Namespace, b))
				result = false;
			else if ((dta = scope as TypeRef) != null)	// nested type
				result = Equals(dta, b.DeclaringType);	// Compare enclosing types
			else if (b.IsNested)
				result = false;	// b is nested, a isn't
			else if (DontCompareTypeScope)
				result = true;
			else if ((aMod = scope as IModule) != null)	// 'a' is defined in the same assembly as 'b'
				result = Equals(b, aMod, a);
			else if ((aAsm = scope as AssemblyRef) != null)
				result = Equals(b.Assembly, aAsm, a);
			else {
				result = false;
				//TODO: Handle the case where scope == null
			}

			recursionCounter.Decrement();
			return result;
		}

		bool Equals_TypeNamespaces(UTF8String a, Type b) {
			if (b.IsNested)
				return true;
			return Equals_TypeNamespaces(a, b.Namespace);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, TypeSpec b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a == null)
				return false;
			if ((object)b == null)
				return false;	// Must use a ModuleRef to reference the global type, so always fail
			return Equals(a.TypeSig, b);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, TypeSig b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, Type b) {
			return Equals(a, b, false);
		}

		bool Equals(ITypeDefOrRef a, Type b, bool treatAsGenericInst) {
			var ts = a as TypeSpec;
			if (ts != null)
				return Equals(ts.TypeSig, b, treatAsGenericInst);
			return Equals(a, b);
		}

		/// <summary>
		/// Checks whether it's FnPtr&amp;, FnPtr*, FnPtr[], or FnPtr[...]
		/// </summary>
		/// <param name="a">The type</param>
		static bool IsFnPtrElementType(Type a) {
			if ((object)a == null || !a.HasElementType)
				return false;
			var et = a.GetElementType();
			if (et == null || et.HasElementType)
				return false;
			if (et != typeof(IntPtr))	// FnPtr is mapped to System.IntPtr
				return false;
			if (!a.FullName.StartsWith("(fnptr)"))
				return false;

			return true;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <param name="treatAsGenericInst"><c>true</c> if we should treat <paramref name="b"/>
		/// as a generic instance type</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(TypeSig a, Type b, bool treatAsGenericInst) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a == null)
				return false;
			if ((object)b == null)
				return false;	// Must use a ModuleRef to reference the global type, so always fail
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (genericArguments != null)
				a = genericArguments.Resolve(a);

			switch (a.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
				result = Equals(((TypeDefOrRefSig)a).TypeDefOrRef, b, treatAsGenericInst);
				break;

			case ElementType.Ptr:
				if (!b.IsPointer)
					result = false;
				else if (IsFnPtrElementType(b)) {
					a = a.Next.RemoveModifiers();
					result = a != null && a.ElementType == ElementType.FnPtr;
				}
				else
					result = Equals(a.Next, b.GetElementType());
				break;

			case ElementType.ByRef:
				if (!b.IsByRef)
					result = false;
				else if (IsFnPtrElementType(b)) {
					a = a.Next.RemoveModifiers();
					result = a != null && a.ElementType == ElementType.FnPtr;
				}
				else
					result = Equals(a.Next, b.GetElementType());
				break;

			case ElementType.SZArray:
				if (!b.IsArray || !b.IsSZArray())
					result = false;
				else if (IsFnPtrElementType(b)) {
					a = a.Next.RemoveModifiers();
					result = a != null && a.ElementType == ElementType.FnPtr;
				}
				else
					result = Equals(a.Next, b.GetElementType());
				break;

			case ElementType.Pinned:
				result = Equals(a.Next, b, treatAsGenericInst);
				break;

			case ElementType.Array:
				if (!b.IsArray || b.IsSZArray())
					result = false;
				else {
					ArraySig ara = a as ArraySig;
					result = ara.Rank == b.GetArrayRank() &&
						(IsFnPtrElementType(b) ?
								(a = a.Next.RemoveModifiers()) != null && a.ElementType == ElementType.FnPtr :
								Equals(a.Next, b.GetElementType()));
				}
				break;

			case ElementType.ValueType:
			case ElementType.Class:
				result = Equals((a as ClassOrValueTypeSig).TypeDefOrRef, b, treatAsGenericInst);
				break;

			case ElementType.Var:
				result = b.IsGenericParameter &&
						b.GenericParameterPosition == (a as GenericSig).Number &&
						(object)b.DeclaringMethod == null;
				break;

			case ElementType.MVar:
				result = b.IsGenericParameter &&
						b.GenericParameterPosition == (a as GenericSig).Number &&
						(object)b.DeclaringMethod != null;
				break;

			case ElementType.GenericInst:
				if (!(b.IsGenericType && !b.IsGenericTypeDefinition) && !treatAsGenericInst) {
					result = false;
					break;
				}
				var gia = (GenericInstSig)a;
				if (SubstituteGenericParameters) {
					InitializeGenericArguments();
					genericArguments.PushTypeArgs(gia.GenericArguments);
					result = Equals(gia.GenericType, b.GetGenericTypeDefinition());
					genericArguments.PopTypeArgs();
				}
				else
					result = Equals(gia.GenericType, b.GetGenericTypeDefinition());
				result = result && Equals(gia.GenericArguments, b.GetGenericArguments());
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				result = Equals(a.Next, b, treatAsGenericInst);
				break;

			case ElementType.FnPtr:
				// At least in method sigs, this will be mapped to System.IntPtr
				result = b == typeof(IntPtr);
				break;

			case ElementType.Sentinel:
			case ElementType.ValueArray:
			case ElementType.Module:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = false;
				break;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, ExportedType b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="b">Type #1</param>
		/// <param name="a">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a == null)
				return false;
			if ((object)b == null)
				return false;	// Must use a ModuleRef to reference the global type, so always fail
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ExportedType dta;
			FileDef aFile;
			AssemblyRef aAsm;
			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;

			var scope = a.Implementation;

			if (!b.IsTypeDef())
				result = false;
			else if (!Equals_TypeNames(a.TypeName, b.Name) || !Equals_TypeNamespaces(a.TypeNamespace, b))
				result = false;
			else if ((dta = scope as ExportedType) != null)	// nested type
				result = Equals(dta, b.DeclaringType);	// Compare enclosing types
			else if (b.IsNested)
				result = false;	// b is nested, a isn't
			else if (DontCompareTypeScope)
				result = true;
			else if ((aFile = scope as FileDef) != null)
				result = Equals(b, aFile, a);
			else if ((aAsm = scope as AssemblyRef) != null)
				result = Equals(b.Assembly, aAsm, a);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(Type a) {
			return GetHashCode(a, false);
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <param name="treatAsGenericInst"><c>true</c> if we should treat <paramref name="a"/>
		/// as a generic instance type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(Type a, bool treatAsGenericInst) {
			// **************************************************************************
			// IMPORTANT: This hash code must match the TypeSig/TypeDef/TypeRef hash code
			// **************************************************************************
			if ((object)a == null)	// Could be global type
				return GetHashCode_TypeDef(a);
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			switch (treatAsGenericInst ? ElementType.GenericInst : a.GetElementType2()) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				hash = GetHashCode_TypeDef(a);
				break;

			case ElementType.FnPtr:
				hash = GetHashCode_FnPtr_SystemIntPtr();
				break;

			case ElementType.Sentinel:
				hash = HASHCODE_MAGIC_ET_SENTINEL;
				break;

			case ElementType.Ptr:
				hash = HASHCODE_MAGIC_ET_PTR +
					(IsFnPtrElementType(a) ? GetHashCode_FnPtr_SystemIntPtr() : GetHashCode(a.GetElementType()));
				break;

			case ElementType.ByRef:
				hash = HASHCODE_MAGIC_ET_BYREF +
					(IsFnPtrElementType(a) ? GetHashCode_FnPtr_SystemIntPtr() : GetHashCode(a.GetElementType()));
				break;

			case ElementType.SZArray:
				hash = HASHCODE_MAGIC_ET_SZARRAY +
					(IsFnPtrElementType(a) ? GetHashCode_FnPtr_SystemIntPtr() : GetHashCode(a.GetElementType()));
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
				hash = GetHashCode(a.GetElementType());
				break;

			case ElementType.Array:
				// The type doesn't store sizes and lower bounds, so can't use them to
				// create the hash
				hash = HASHCODE_MAGIC_ET_ARRAY + a.GetArrayRank() +
					(IsFnPtrElementType(a) ? GetHashCode_FnPtr_SystemIntPtr() : GetHashCode(a.GetElementType()));
				break;

			case ElementType.Var:
				hash = HASHCODE_MAGIC_ET_VAR + a.GenericParameterPosition;
				break;

			case ElementType.MVar:
				hash = HASHCODE_MAGIC_ET_MVAR + a.GenericParameterPosition;
				break;

			case ElementType.GenericInst:
				hash = HASHCODE_MAGIC_ET_GENERICINST + GetHashCode(a.GetGenericTypeDefinition()) + GetHashCode(a.GetGenericArguments());
				break;

			case ElementType.ValueArray:
			case ElementType.Module:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				hash = 0;
				break;
			}

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Gets the hash code of a type list
		/// </summary>
		/// <param name="a">The type list</param>
		/// <returns>The hash code</returns>
		int GetHashCode(IList<Type> a) {
			//************************************************************************
			// IMPORTANT: This code must match any other GetHashCode(IList<SOME_TYPE>)
			//************************************************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			uint hash = 0;
			for (int i = 0; i < a.Count; i++) {
				hash += (uint)GetHashCode(a[i]);
				hash = (hash << 13) | (hash >> 19);
			}
			recursionCounter.Decrement();
			return (int)hash;
		}

		/// <summary>
		/// Gets the hash code of a list with only generic method parameters (<see cref="ElementType.MVar"/>)
		/// </summary>
		/// <param name="numGenericParams">Number of generic method parameters</param>
		/// <returns>Hash code</returns>
		static int GetHashCode_ElementType_MVar(int numGenericParams) {
			return GetHashCode(numGenericParams, HASHCODE_MAGIC_ET_MVAR);
		}

		static int GetHashCode(int numGenericParams, int etypeHashCode) {
			//************************************************************************
			// IMPORTANT: This code must match any other GetHashCode(IList<SOME_TYPE>)
			//************************************************************************
			uint hash = 0;
			for (int i = 0; i < numGenericParams; i++) {
				hash += (uint)(etypeHashCode + i);
				hash = (hash << 13) | (hash >> 19);
			}
			return (int)hash;
		}

		/// <summary>
		/// Gets the hash code of a TypeDef type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode_TypeDef(Type a) {
			// ************************************************************************************
			// IMPORTANT: This hash code must match the Type/TypeRef/TypeDef/ExportedType
			// hash code and GetHashCode_FnPtr_SystemIntPtr() method
			// ************************************************************************************

			// A global method/field's declaring type is null. This is the reason we must
			// return GetHashCodeGlobalType() here.
			if ((object)a == null)
				return GetHashCodeGlobalType();
			int hash;
			hash = GetHashCode_TypeName(a.Name);
			if (a.IsNested)
				hash += HASHCODE_MAGIC_NESTED_TYPE;
			else
				hash += GetHashCode_TypeNamespace(a.Namespace);
			return hash;
		}

		/// <summary>
		/// Compares type lists
		/// </summary>
		/// <param name="a">Type list #1</param>
		/// <param name="b">Type list #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IList<TypeSig> a, IList<Type> b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.Count != b.Count)
				result = false;
			else {
				int i;
				for (i = 0; i < a.Count; i++) {
					if (!Equals(a[i], b[i]))
						break;
				}
				result = i == a.Count;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares modules
		/// </summary>
		/// <param name="a">Module #1</param>
		/// <param name="b">Module #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(ModuleDef a, Module b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals((IModule)a, b) && Equals(a.Assembly, b.Assembly);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares a file and a module
		/// </summary>
		/// <param name="a">File</param>
		/// <param name="b">Module</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(FileDef a, Module b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;

			// Use b.Name since it's the filename we want to compare, not b.ScopeName
			return UTF8String.ToSystemStringOrEmpty(a.Name).Equals(b.Name, StringComparison.OrdinalIgnoreCase);
		}

		/// <summary>
		/// Compares modules
		/// </summary>
		/// <param name="a">Module #1</param>
		/// <param name="b">Module #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IModule a, Module b) {
			if ((object)a == b)
				return true;
			if (a == null || (object)b == null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;

			// Use b.ScopeName and not b.Name since b.Name is just the file name w/o path
			return UTF8String.ToSystemStringOrEmpty(a.Name).Equals(b.ScopeName, StringComparison.OrdinalIgnoreCase);
		}

		/// <summary>
		/// Compares assemblies
		/// </summary>
		/// <param name="a">Assembly #1</param>
		/// <param name="b">Assembly #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IAssembly a, Assembly b) {
			if ((object)a == b)
				return true;
			if (a == null || (object)b == null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;
			if (!recursionCounter.Increment())
				return false;

			var bAsmName = b.GetName();
			bool result = UTF8String.ToSystemStringOrEmpty(a.Name).Equals(bAsmName.Name, StringComparison.OrdinalIgnoreCase) &&
				(!CompareAssemblyPublicKeyToken || PublicKeyBase.TokenEquals(a.PublicKeyOrToken, new PublicKeyToken(bAsmName.GetPublicKeyToken()))) &&
				(!CompareAssemblyVersion || Utils.Equals(a.Version, bAsmName.Version)) &&
				(!CompareAssemblyLocale || Utils.LocaleEquals(a.Culture, bAsmName.CultureInfo.Name));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares method declaring types
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool DeclaringTypeEquals(IMethod a, MethodBase b) {
			// If this is disabled, always return true, even if one is null, etc.
			if (!CompareMethodFieldDeclaringType)
				return true;

			if ((object)a == b)
				return true;
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			MethodDef md;
			MemberRef mr;
			MethodSpec ms;

			if ((md = a as MethodDef) != null)
				result = DeclaringTypeEquals(md, b);
			else if ((mr = a as MemberRef) != null)
				result = DeclaringTypeEquals(mr, b);
			else if ((ms = a as MethodSpec) != null)
				result = DeclaringTypeEquals(ms, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		bool DeclaringTypeEquals(MethodDef a, MethodBase b) {
			// If this is disabled, always return true, even if one is null, etc.
			if (!CompareMethodFieldDeclaringType)
				return true;
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			return Equals(a.DeclaringType, b.DeclaringType);
		}

		bool DeclaringTypeEquals(MemberRef a, MethodBase b) {
			// If this is disabled, always return true, even if one is null, etc.
			if (!CompareMethodFieldDeclaringType)
				return true;
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			return Equals(a.Class, b.DeclaringType, b.Module);
		}

		bool DeclaringTypeEquals(MethodSpec a, MethodBase b) {
			// If this is disabled, always return true, even if one is null, etc.
			if (!CompareMethodFieldDeclaringType)
				return true;
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			return DeclaringTypeEquals(a.Method, b);
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, IMethod b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IMethod a, MethodBase b) {
			if ((object)a == b)
				return true;
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			MethodDef md;
			MemberRef mr;
			MethodSpec ms;

			if ((md = a as MethodDef) != null)
				result = Equals(md, b);
			else if ((mr = a as MemberRef) != null)
				result = Equals(mr, b);
			else if ((ms = a as MethodSpec) != null)
				result = Equals(ms, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, MethodDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodDef a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			if (!DontProjectWinMDRefs) {
				var mra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				if (mra != null) {
					result = Equals(mra, b);
					goto exit;
				}
			}

			var amSig = a.MethodSig;
			result = Equals_MethodFieldNames(a.Name, b.Name) &&
					amSig != null &&
					((amSig.Generic && b.IsGenericMethodDefinition && b.IsGenericMethod) ||
					(!amSig.Generic && !b.IsGenericMethodDefinition && !b.IsGenericMethod)) &&
					Equals(amSig, b) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares method sigs
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, MethodSig b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares method sigs
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodSig a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals(a.GetCallingConvention(), b) &&
					(DontCompareReturnType || ReturnTypeEquals(a.RetType, b)) &&
					Equals(a.Params, b.GetParameters(), b.DeclaringType) &&
					(!a.Generic || a.GenParamCount == b.GetGenericArguments().Length);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, MemberRef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
			if (b.IsGenericMethod && !b.IsGenericMethodDefinition) {
				// 'a' must be a method ref in a generic type. This comparison must match
				// the MethodSpec vs MethodBase comparison code.
				result = a.IsMethodRef && a.MethodSig.Generic;

				var oldOptions = ClearOptions(SigComparerOptions.CompareMethodFieldDeclaringType);
				result = result && Equals(a, b.Module.ResolveMethod(b.MetadataToken));
				RestoreOptions(oldOptions);
				result = result && DeclaringTypeEquals(a, b);

				result = result && GenericMethodArgsEquals((int)a.MethodSig.GenParamCount, b.GetGenericArguments());
			}
			else {
				var amSig = a.MethodSig;
				result = Equals_MethodFieldNames(a.Name, b.Name) &&
						amSig != null &&
						((amSig.Generic && b.IsGenericMethodDefinition && b.IsGenericMethod) ||
						(!amSig.Generic && !b.IsGenericMethodDefinition && !b.IsGenericMethod));

				GenericInstSig git;
				if (SubstituteGenericParameters && (git = GetGenericInstanceType(a.Class)) != null) {
					InitializeGenericArguments();
					genericArguments.PushTypeArgs(git.GenericArguments);
					result = result && Equals(amSig, b);
					genericArguments.PopTypeArgs();
				}
				else
					result = result && Equals(amSig, b);

				result = result && (!CompareMethodFieldDeclaringType || Equals(a.Class, b.DeclaringType, b.Module));
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares generic method args, making sure <paramref name="methodGenArgs"/> only
		/// contains <see cref="ElementType.MVar"/>s.
		/// </summary>
		/// <param name="numMethodArgs">Number of generic method args in method #1</param>
		/// <param name="methodGenArgs">Generic method args in method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		static bool GenericMethodArgsEquals(int numMethodArgs, IList<Type> methodGenArgs) {
			if (numMethodArgs != methodGenArgs.Count)
				return false;
			for (int i = 0; i < numMethodArgs; i++) {
				if (methodGenArgs[i].GetElementType2() != ElementType.MVar)
					return false;
			}
			return true;
		}

		bool Equals(IMemberRefParent a, Type b, Module bModule) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ITypeDefOrRef ita;
			ModuleRef moda;
			MethodDef ma;
			TypeDef td;

			if ((ita = a as ITypeDefOrRef) != null)
				result = Equals((IType)ita, b);
			else if ((moda = a as ModuleRef) != null) {
				ModuleDef omoda = moda.Module;
				result = (object)b == null &&	// b == null => it's the global type
						Equals(moda, bModule) &&
						Equals(omoda == null ? null : omoda.Assembly, bModule.Assembly);
			}
			else if ((ma = a as MethodDef) != null)
				result = Equals(ma.DeclaringType, b);
			else if ((object)b == null && (td = a as TypeDef) != null)
				result = td.IsGlobalModuleType;
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, MethodSpec b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodSpec a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			// Make sure it's a MethodSpec
			bool result = b.IsGenericMethod && !b.IsGenericMethodDefinition;

			// Don't compare declaring types yet because the resolved method has the wrong
			// declaring type (its declaring type is a generic type def).
			// NOTE: We must not push generic method args when comparing a.Method
			var oldOptions = ClearOptions(SigComparerOptions.CompareMethodFieldDeclaringType);
			result = result && Equals(a.Method, b.Module.ResolveMethod(b.MetadataToken));
			RestoreOptions(oldOptions);
			result = result && DeclaringTypeEquals(a.Method, b);

			var gim = a.GenericInstMethodSig;
			result = result && gim != null && Equals(gim.GenericArguments, b.GetGenericArguments());

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a <c>MethodBase</c>
		/// </summary>
		/// <param name="a">The <c>MethodBase</c></param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MethodBase a) {
			if ((object)a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			// ***********************************************************************
			// IMPORTANT: This hash code must match the MemberRef/MethodSpec hash code
			// ***********************************************************************
			int hash = GetHashCode_MethodFieldName(a.Name) +
					GetHashCode_MethodSig(a);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		int GetHashCode_MethodSig(MethodBase a) {
			if ((object)a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a.CallingConvention, a.IsGenericMethod) +
					GetHashCode(a.GetParameters(), a.DeclaringType);
			if (!DontCompareReturnType)
				hash += GetHashCode_ReturnType(a);
			if (a.IsGenericMethod)
				hash += GetHashCode_ElementType_MVar(a.GetGenericArguments().Length);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Gets the hash code of a parameter list
		/// </summary>
		/// <param name="a">The type list</param>
		/// <param name="declaringType">Declaring type of method that owns parameter <paramref name="a"/></param>
		/// <returns>The hash code</returns>
		int GetHashCode(IList<ParameterInfo> a, Type declaringType) {
			//************************************************************************
			// IMPORTANT: This code must match any other GetHashCode(IList<SOME_TYPE>)
			//************************************************************************
			if (a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			uint hash = 0;
			for (int i = 0; i < a.Count; i++) {
				hash += (uint)GetHashCode(a[i], declaringType);
				hash = (hash << 13) | (hash >> 19);
			}
			recursionCounter.Decrement();
			return (int)hash;
		}

		int GetHashCode_ReturnType(MethodBase a) {
			var mi = a as MethodInfo;
			if ((object)mi != null)
				return GetHashCode(mi.ReturnParameter, a.DeclaringType);
			return GetHashCode(typeof(void));
		}

		int GetHashCode(ParameterInfo a, Type declaringType) {
			return GetHashCode(a.ParameterType, declaringType.MustTreatTypeAsGenericInstType(a.ParameterType));
		}

		int GetHashCode(Type a, Type declaringType) {
			return GetHashCode(a, declaringType.MustTreatTypeAsGenericInstType(a));
		}

		/// <summary>
		/// Compares calling conventions
		/// </summary>
		/// <param name="a">Calling convention</param>
		/// <param name="b">Method</param>
		/// <returns></returns>
		static bool Equals(CallingConvention a, MethodBase b) {
			var bc = b.CallingConvention;

			if (((a & CallingConvention.Generic) != 0) != b.IsGenericMethod)
				return false;
			if (((a & CallingConvention.HasThis) != 0) != ((bc & CallingConventions.HasThis) != 0))
				return false;
			if (((a & CallingConvention.ExplicitThis) != 0) != ((bc & CallingConventions.ExplicitThis) != 0))
				return false;

			var cca = a & CallingConvention.Mask;
			switch (bc & CallingConventions.Any) {
			case CallingConventions.Standard:
				if (cca == CallingConvention.VarArg || cca == CallingConvention.NativeVarArg)
					return false;
				break;

			case CallingConventions.VarArgs:
				if (cca != CallingConvention.VarArg && cca != CallingConvention.NativeVarArg)
					return false;
				break;

			case CallingConventions.Any:
			default:
				break;
			}

			return true;
		}

		static int GetHashCode_CallingConvention(CallingConventions a, bool isGeneric) {
			//**************************************************************
			// IMPORTANT: This hash must match the other call conv hash code
			//**************************************************************

			CallingConvention cc = 0;

			if (isGeneric)
				cc |= CallingConvention.Generic;
			if ((a & CallingConventions.HasThis) != 0)
				cc |= CallingConvention.HasThis;
			if ((a & CallingConventions.ExplicitThis) != 0)
				cc |= CallingConvention.ExplicitThis;

			return (int)cc;
		}

		/// <summary>
		/// Compares return types
		/// </summary>
		/// <param name="a">Return type #1</param>
		/// <param name="b">MethodBase</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool ReturnTypeEquals(TypeSig a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			var mi = b as MethodInfo;
			if ((object)mi != null)
				result = Equals(a, mi.ReturnParameter, b.DeclaringType);
			else if (b is ConstructorInfo)
				result = IsSystemVoid(a);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		static bool IsSystemVoid(TypeSig a) {
			return a.RemovePinnedAndModifiers().GetElementType() == ElementType.Void;
		}

		/// <summary>
		/// Compares parameter lists
		/// </summary>
		/// <param name="a">Type list #1</param>
		/// <param name="b">Type list #2</param>
		/// <param name="declaringType">Declaring type of method that owns parameter <paramref name="b"/></param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IList<TypeSig> a, IList<ParameterInfo> b, Type declaringType) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.Count != b.Count)
				result = false;
			else {
				int i;
				for (i = 0; i < a.Count; i++) {
					if (!Equals(a[i], b[i], declaringType))
						break;
				}
				result = i == a.Count;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares parameter types
		/// </summary>
		/// <param name="a">Parameter type #1</param>
		/// <param name="b">Parameter #2</param>
		/// <param name="declaringType">Declaring type of method that owns parameter <paramref name="b"/></param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(TypeSig a, ParameterInfo b, Type declaringType) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			TypeSig a2;
			bool result = ModifiersEquals(a, b.GetRequiredCustomModifiers(), b.GetOptionalCustomModifiers(), out a2) &&
						Equals(a2, b.ParameterType, declaringType.MustTreatTypeAsGenericInstType(b.ParameterType));

			recursionCounter.Decrement();
			return result;
		}

		bool ModifiersEquals(TypeSig a, IList<Type> reqMods2, IList<Type> optMods2, out TypeSig aAfterModifiers) {
			aAfterModifiers = a;
			if (!(a is ModifierSig))
				return reqMods2.Count == 0 && optMods2.Count == 0;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			var reqMods1 = new List<ITypeDefOrRef>(reqMods2.Count);
			var optMods1 = new List<ITypeDefOrRef>(optMods2.Count);
			while (true) {
				var modifierSig = aAfterModifiers as ModifierSig;
				if (modifierSig == null)
					break;
				if (modifierSig is CModOptSig)
					optMods1.Add(modifierSig.Modifier);
				else
					reqMods1.Add(modifierSig.Modifier);

				// This can only loop forever if the user created a loop. It's not possible
				// to create a loop with invalid metadata.
				aAfterModifiers = aAfterModifiers.Next;
			}
			optMods1.Reverse();
			reqMods1.Reverse();

			result = reqMods1.Count == reqMods2.Count &&
					optMods1.Count == optMods2.Count &&
					ModifiersEquals(reqMods1, reqMods2) &&
					ModifiersEquals(optMods1, optMods2);

			recursionCounter.Decrement();
			return result;
		}

		bool ModifiersEquals(IList<ITypeDefOrRef> a, IList<Type> b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.Count != b.Count)
				result = false;
			else {
				int i;
				for (i = 0; i < b.Count; i++) {
					if (!Equals(a[i], b[i]))
						break;
				}
				result = i == b.Count;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldInfo a, IField b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IField a, FieldInfo b) {
			if ((object)a == b)
				return true;
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			FieldDef fa;
			MemberRef ma;

			if ((fa = a as FieldDef) != null)
				result = Equals(fa, b);
			else if ((ma = a as MemberRef) != null)
				result = Equals(ma, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldInfo a, FieldDef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldDef a, FieldInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.FieldSig, b) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		bool Equals(FieldSig a, FieldInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			TypeSig a2;
			bool result = ModifiersEquals(a.Type, b.GetRequiredCustomModifiers(), b.GetOptionalCustomModifiers(), out a2) &&
					Equals(a2, b.FieldType, b.DeclaringType.MustTreatTypeAsGenericInstType(b.FieldType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldInfo a, MemberRef b) {
			return Equals(b, a);
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, FieldInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_MethodFieldNames(a.Name, b.Name);

			GenericInstSig git;
			if (SubstituteGenericParameters && (git = GetGenericInstanceType(a.Class)) != null) {
				InitializeGenericArguments();
				genericArguments.PushTypeArgs(git.GenericArguments);
				result = result && Equals(a.FieldSig, b);
				genericArguments.PopTypeArgs();
			}
			else
				result = result && Equals(a.FieldSig, b);

			result = result && (!CompareMethodFieldDeclaringType || Equals(a.Class, b.DeclaringType, b.Module));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a field
		/// </summary>
		/// <param name="a">The field</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(FieldInfo a) {
			// ************************************************************
			// IMPORTANT: This hash code must match the MemberRef hash code
			// ************************************************************
			if ((object)a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_MethodFieldName(a.Name) +
					GetHashCode_FieldSig(a);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		int GetHashCode_FieldSig(FieldInfo a) {
			if ((object)a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(0, false) + GetHashCode(a.FieldType, a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares properties
		/// </summary>
		/// <param name="a">Property #1</param>
		/// <param name="b">Property #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(PropertyDef a, PropertyInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_PropertyNames(a.Name, b.Name) &&
					Equals(a.PropertySig, b) &&
					(!ComparePropertyDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		bool Equals(PropertySig a, PropertyInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			TypeSig a2;
			bool result = ModifiersEquals(a.RetType, b.GetRequiredCustomModifiers(), b.GetOptionalCustomModifiers(), out a2) &&
					Equals(a2, b.PropertyType, b.DeclaringType.MustTreatTypeAsGenericInstType(b.PropertyType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a property
		/// </summary>
		/// <param name="a">The property</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(PropertyInfo a) {
			// **************************************************************
			// IMPORTANT: This hash code must match the PropertyDef hash code
			// **************************************************************
			if ((object)a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_PropertyName(a.Name) +
					GetHashCode(a.PropertyType, a.DeclaringType);
			if (ComparePropertyDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares events
		/// </summary>
		/// <param name="a">Event #1</param>
		/// <param name="b">Event #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(EventDef a, EventInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a == null || (object)b == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_EventNames(a.Name, b.Name) &&
					Equals(a.EventType, b.EventHandlerType, b.DeclaringType.MustTreatTypeAsGenericInstType(b.EventHandlerType)) &&
					(!CompareEventDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of an event
		/// </summary>
		/// <param name="a">The event</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(EventInfo a) {
			// ***********************************************************
			// IMPORTANT: This hash code must match the EventDef hash code
			// ***********************************************************
			if ((object)a == null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_EventName(a.Name) +
					GetHashCode(a.EventHandlerType, a.DeclaringType);
			if (CompareEventDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0} - {1}", recursionCounter, options);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/SignatureReader.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Helps <see cref="SignatureReader"/> resolve types
	/// </summary>
	public interface ISignatureReaderHelper {
		/// <summary>
		/// Resolves a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/>
		/// is invalid</returns>
		ITypeDefOrRef ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext);

		/// <summary>
		/// Converts the address of a <see cref="Type"/> to a <see cref="TypeSig"/>
		/// </summary>
		/// <seealso cref="dnlib.DotNet.Emit.MethodTableToTypeConverter"/>
		/// <param name="address">Address of <see cref="Type"/>. This is also known as the
		/// method table and has the same value as <see cref="RuntimeTypeHandle.Value"/></param>
		/// <returns>A <see cref="TypeSig"/> or <c>null</c> if not supported</returns>
		TypeSig ConvertRTInternalAddress(IntPtr address);
	}

	/// <summary>
	/// Reads signatures from the #Blob stream
	/// </summary>
	public struct SignatureReader : IDisposable {
		readonly ISignatureReaderHelper helper;
		readonly ICorLibTypes corLibTypes;
		readonly IBinaryReader reader;
		readonly GenericParamContext gpContext;
		RecursionCounter recursionCounter;

		/// <summary>
		/// Reads a signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD readerModule, uint sig) {
			return ReadSig(readerModule, sig, new GenericParamContext());
		}

		/// <summary>
		/// Reads a signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD readerModule, uint sig, GenericParamContext gpContext) {
			try {
				using (var reader = new SignatureReader(readerModule, sig, gpContext)) {
					if (reader.reader.Length == 0)
						return null;
					var csig = reader.ReadSig();
					if (csig != null)
						csig.ExtraData = reader.GetExtraData();
					return csig;
				}
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature data</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD module, byte[] signature) {
			return ReadSig(module, module.CorLibTypes, MemoryImageStream.Create(signature), new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD module, byte[] signature, GenericParamContext gpContext) {
			return ReadSig(module, module.CorLibTypes, MemoryImageStream.Create(signature), gpContext);
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD module, IBinaryReader signature) {
			return ReadSig(module, module.CorLibTypes, signature, new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD module, IBinaryReader signature, GenericParamContext gpContext) {
			return ReadSig(module, module.CorLibTypes, signature, gpContext);
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature) {
			return ReadSig(helper, corLibTypes, MemoryImageStream.Create(signature), new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature, GenericParamContext gpContext) {
			return ReadSig(helper, corLibTypes, MemoryImageStream.Create(signature), gpContext);
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, IBinaryReader signature) {
			return ReadSig(helper, corLibTypes, signature, new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, IBinaryReader signature, GenericParamContext gpContext) {
			try {
				using (var reader = new SignatureReader(helper, corLibTypes, signature, gpContext)) {
					if (reader.reader.Length == 0)
						return null;
					return reader.ReadSig();
				}
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD readerModule, uint sig) {
			return ReadTypeSig(readerModule, sig, new GenericParamContext());
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD readerModule, uint sig, GenericParamContext gpContext) {
			try {
				using (var reader = new SignatureReader(readerModule, sig, gpContext))
					return reader.ReadType();
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD readerModule, uint sig, out byte[] extraData) {
			return ReadTypeSig(readerModule, sig, new GenericParamContext(), out extraData);
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD readerModule, uint sig, GenericParamContext gpContext, out byte[] extraData) {
			try {
				using (var reader = new SignatureReader(readerModule, sig, gpContext)) {
					TypeSig ts;
					try {
						ts = reader.ReadType();
					}
					catch (IOException) {
						reader.reader.Position = 0;
						ts = null;
					}
					extraData = reader.GetExtraData();
					return ts;
				}
			}
			catch {
				extraData = null;
				return null;
			}
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature data</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD module, byte[] signature) {
			return ReadTypeSig(module, module.CorLibTypes, MemoryImageStream.Create(signature), new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD module, byte[] signature, GenericParamContext gpContext) {
			return ReadTypeSig(module, module.CorLibTypes, MemoryImageStream.Create(signature), gpContext);
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD module, IBinaryReader signature) {
			return ReadTypeSig(module, module.CorLibTypes, signature, new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD module, IBinaryReader signature, GenericParamContext gpContext) {
			return ReadTypeSig(module, module.CorLibTypes, signature, gpContext);
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature) {
			return ReadTypeSig(helper, corLibTypes, MemoryImageStream.Create(signature), new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature, GenericParamContext gpContext) {
			return ReadTypeSig(helper, corLibTypes, MemoryImageStream.Create(signature), gpContext);
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, IBinaryReader signature) {
			return ReadTypeSig(helper, corLibTypes, signature, new GenericParamContext());
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, IBinaryReader signature, GenericParamContext gpContext) {
			byte[] extraData;
			return ReadTypeSig(helper, corLibTypes, signature, gpContext, out extraData);
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature, GenericParamContext gpContext, out byte[] extraData) {
			return ReadTypeSig(helper, corLibTypes, MemoryImageStream.Create(signature), gpContext, out extraData);
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader which will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, IBinaryReader signature, GenericParamContext gpContext, out byte[] extraData) {
			try {
				using (var reader = new SignatureReader(helper, corLibTypes, signature, gpContext)) {
					TypeSig ts;
					try {
						ts = reader.ReadType();
					}
					catch (IOException) {
						reader.reader.Position = 0;
						ts = null;
					}
					extraData = reader.GetExtraData();
					return ts;
				}
			}
			catch {
				extraData = null;
				return null;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		SignatureReader(ModuleDefMD readerModule, uint sig, GenericParamContext gpContext)
			: this(readerModule, readerModule.CorLibTypes, readerModule.BlobStream.CreateStream(sig), gpContext) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="reader">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		SignatureReader(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, IBinaryReader reader, GenericParamContext gpContext) {
			this.helper = helper;
			this.corLibTypes = corLibTypes;
			this.reader = reader;
			this.gpContext = gpContext;
			this.recursionCounter = new RecursionCounter();
		}

		byte[] GetExtraData() {
			if (reader.Position >= reader.Length)
				return null;
			return reader.ReadRemainingBytes();
		}

		/// <summary>
		/// Reads the signature
		/// </summary>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if invalid signature</returns>
		CallingConventionSig ReadSig() {
			if (!recursionCounter.Increment())
				return null;

			CallingConventionSig result;
			var callingConvention = (CallingConvention)reader.ReadByte();
			switch (callingConvention & CallingConvention.Mask) {
			case CallingConvention.Default:
			case CallingConvention.C:
			case CallingConvention.StdCall:
			case CallingConvention.ThisCall:
			case CallingConvention.FastCall:
			case CallingConvention.VarArg:
			case CallingConvention.NativeVarArg:
				result = ReadMethod(callingConvention);
				break;

			case CallingConvention.Field:
				result = ReadField(callingConvention);
				break;

			case CallingConvention.LocalSig:
				result = ReadLocalSig(callingConvention);
				break;

			case CallingConvention.Property:
				result = ReadProperty(callingConvention);
				break;

			case CallingConvention.GenericInst:
				result = ReadGenericInstMethod(callingConvention);
				break;

			case CallingConvention.Unmanaged:
			default:
				result = null;
				break;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Reads a <see cref="FieldSig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="FieldSig"/> instance</returns>
		FieldSig ReadField(CallingConvention callingConvention) {
			return new FieldSig(callingConvention, ReadType());
		}

		/// <summary>
		/// Reads a <see cref="MethodSig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="MethodSig"/> instance</returns>
		MethodSig ReadMethod(CallingConvention callingConvention) {
			return ReadSig(new MethodSig(callingConvention));
		}

		/// <summary>
		/// Reads a <see cref="PropertySig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="PropertySig"/> instance</returns>
		PropertySig ReadProperty(CallingConvention callingConvention) {
			return ReadSig(new PropertySig(callingConvention));
		}

		T ReadSig<T>(T methodSig) where T : MethodBaseSig {
			if (methodSig.Generic) {
				uint count;
				if (!reader.ReadCompressedUInt32(out count))
					return null;
				methodSig.GenParamCount = count;
			}

			uint numParams;
			if (!reader.ReadCompressedUInt32(out numParams))
				return null;

			methodSig.RetType = ReadType();

			var parameters = methodSig.Params;
			for (uint i = 0; i < numParams; i++) {
				var type = ReadType();
				if (type is SentinelSig) {
					if (methodSig.ParamsAfterSentinel == null)
						methodSig.ParamsAfterSentinel = parameters = ThreadSafeListCreator.Create<TypeSig>((int)(numParams - i));
					i--;
				}
				else
					parameters.Add(type);
			}

			return methodSig;
		}

		/// <summary>
		/// Reads a <see cref="LocalSig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="LocalSig"/> instance</returns>
		LocalSig ReadLocalSig(CallingConvention callingConvention) {
			uint count;
			if (!reader.ReadCompressedUInt32(out count))
				return null;
			var sig = new LocalSig(callingConvention, count);
			var locals = sig.Locals;
			for (uint i = 0; i < count; i++)
				locals.Add(ReadType());
			return sig;
		}

		/// <summary>
		/// Reads a <see cref="GenericInstMethodSig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="GenericInstMethodSig"/> instance</returns>
		GenericInstMethodSig ReadGenericInstMethod(CallingConvention callingConvention) {
			uint count;
			if (!reader.ReadCompressedUInt32(out count))
				return null;
			var sig = new GenericInstMethodSig(callingConvention, count);
			var args = sig.GenericArguments;
			for (uint i = 0; i < count; i++)
				args.Add(ReadType());
			return sig;
		}

		/// <summary>
		/// Reads the next type
		/// </summary>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if invalid element type</returns>
		TypeSig ReadType() {
			if (!recursionCounter.Increment())
				return null;

			uint num;
			TypeSig nextType, result = null;
			switch ((ElementType)reader.ReadByte()) {
			case ElementType.Void:		result = corLibTypes.Void; break;
			case ElementType.Boolean:	result = corLibTypes.Boolean; break;
			case ElementType.Char:		result = corLibTypes.Char; break;
			case ElementType.I1:		result = corLibTypes.SByte; break;
			case ElementType.U1:		result = corLibTypes.Byte; break;
			case ElementType.I2:		result = corLibTypes.Int16; break;
			case ElementType.U2:		result = corLibTypes.UInt16; break;
			case ElementType.I4:		result = corLibTypes.Int32; break;
			case ElementType.U4:		result = corLibTypes.UInt32; break;
			case ElementType.I8:		result = corLibTypes.Int64; break;
			case ElementType.U8:		result = corLibTypes.UInt64; break;
			case ElementType.R4:		result = corLibTypes.Single; break;
			case ElementType.R8:		result = corLibTypes.Double; break;
			case ElementType.String:	result = corLibTypes.String; break;
			case ElementType.TypedByRef:result = corLibTypes.TypedReference; break;
			case ElementType.I:			result = corLibTypes.IntPtr; break;
			case ElementType.U:			result = corLibTypes.UIntPtr; break;
			case ElementType.Object:	result = corLibTypes.Object; break;

			case ElementType.Ptr:		result = new PtrSig(ReadType()); break;
			case ElementType.ByRef:		result = new ByRefSig(ReadType()); break;
			case ElementType.ValueType:	result = new ValueTypeSig(ReadTypeDefOrRef()); break;
			case ElementType.Class:		result = new ClassSig(ReadTypeDefOrRef()); break;
			case ElementType.FnPtr:		result = new FnPtrSig(ReadSig()); break;
			case ElementType.SZArray:	result = new SZArraySig(ReadType()); break;
			case ElementType.CModReqd:	result = new CModReqdSig(ReadTypeDefOrRef(), ReadType()); break;
			case ElementType.CModOpt:	result = new CModOptSig(ReadTypeDefOrRef(), ReadType()); break;
			case ElementType.Sentinel:	result = new SentinelSig(); break;
			case ElementType.Pinned:	result = new PinnedSig(ReadType()); break;

			case ElementType.Var:
				if (!reader.ReadCompressedUInt32(out num))
					break;
				result = new GenericVar(num, gpContext.Type);
				break;

			case ElementType.MVar:
				if (!reader.ReadCompressedUInt32(out num))
					break;
				result = new GenericMVar(num, gpContext.Method);
				break;

			case ElementType.ValueArray:
				nextType = ReadType();
				if (!reader.ReadCompressedUInt32(out num))
					break;
				result = new ValueArraySig(nextType, num);
				break;

			case ElementType.Module:
				if (!reader.ReadCompressedUInt32(out num))
					break;
				result = new ModuleSig(num, ReadType());
				break;

			case ElementType.GenericInst:
				nextType = ReadType();
				if (!reader.ReadCompressedUInt32(out num))
					break;
				var genericInstSig = new GenericInstSig(nextType as ClassOrValueTypeSig, num);
				var args = genericInstSig.GenericArguments;
				for (uint i = 0; i < num; i++)
					args.Add(ReadType());
				result = genericInstSig;
				break;

			case ElementType.Array:
				nextType = ReadType();
				uint rank;
				if (!reader.ReadCompressedUInt32(out rank))
					break;
				if (rank == 0) {
					result = new ArraySig(nextType, rank);
					break;
				}
				if (!reader.ReadCompressedUInt32(out num))
					break;
				var sizes = new List<uint>((int)num);
				for (uint i = 0; i < num; i++) {
					uint size;
					if (!reader.ReadCompressedUInt32(out size))
						goto exit;
					sizes.Add(size);
				}
				if (!reader.ReadCompressedUInt32(out num))
					break;
				var lowerBounds = new List<int>((int)num);
				for (uint i = 0; i < num; i++) {
					int size;
					if (!reader.ReadCompressedInt32(out size))
						goto exit;
					lowerBounds.Add(size);
				}
				result = new ArraySig(nextType, rank, sizes, lowerBounds);
				break;

			case ElementType.Internal:
				IntPtr address;
				if (IntPtr.Size == 4)
					address = new IntPtr(reader.ReadInt32());
				else
					address = new IntPtr(reader.ReadInt64());
				result = helper.ConvertRTInternalAddress(address);
				break;

			case ElementType.End:
			case ElementType.R:
			default:
				result = null;
				break;
			}
exit:
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Reads a <c>TypeDefOrRef</c>
		/// </summary>
		/// <returns>A <see cref="ITypeDefOrRef"/> instance</returns>
		ITypeDefOrRef ReadTypeDefOrRef() {
			uint codedToken;
			if (!reader.ReadCompressedUInt32(out codedToken))
				return null;
			return helper.ResolveTypeDefOrRef(codedToken, gpContext);
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (reader != null)
				reader.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/StandAloneSig.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the StandAloneSig table
	/// </summary>
	public abstract class StandAloneSig : IHasCustomAttribute, IHasCustomDebugInformation, IContainsGenericParameter {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.StandAloneSig, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 11; }
		}

		/// <summary>
		/// From column StandAloneSig.Signature
		/// </summary>
		public CallingConventionSig Signature {
			get { return signature; }
			set { signature = value; }
		}
		/// <summary/>
		protected CallingConventionSig signature;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 11; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// Gets/sets the method sig
		/// </summary>
		public MethodSig MethodSig {
			get { return signature as MethodSig; }
			set { signature = value; }
		}

		/// <summary>
		/// Gets/sets the locals sig
		/// </summary>
		public LocalSig LocalSig {
			get { return signature as LocalSig; }
			set { signature = value; }
		}

		/// <inheritdoc/>
		public bool ContainsGenericParameter {
			get { return TypeHelper.ContainsGenericParameter(this); }
		}
	}

	/// <summary>
	/// A StandAloneSig row created by the user and not present in the original .NET file
	/// </summary>
	public class StandAloneSigUser : StandAloneSig {
		/// <summary>
		/// Default constructor
		/// </summary>
		public StandAloneSigUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="localSig">A locals sig</param>
		public StandAloneSigUser(LocalSig localSig) {
			this.signature = localSig;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="methodSig">A method sig</param>
		public StandAloneSigUser(MethodSig methodSig) {
			this.signature = methodSig;
		}
	}

	/// <summary>
	/// Created from a row in the StandAloneSig table
	/// </summary>
	sealed class StandAloneSigMD : StandAloneSig, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.StandAloneSig, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>StandAloneSig</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public StandAloneSigMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.StandAloneSigTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("StandAloneSig rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			uint signature = readerModule.TablesStream.ReadStandAloneSigRow2(origRid);
			this.signature = readerModule.ReadSignature(signature, gpContext);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/StrongNameKey.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.IO;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Thrown if the strong name key or public key is invalid
	/// </summary>
	[Serializable]
	public class InvalidKeyException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public InvalidKeyException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		public InvalidKeyException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="innerException">Other exception</param>
		public InvalidKeyException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected InvalidKeyException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Type of signature algorithm. See WinCrypt.h in the Windows SDK
	/// </summary>
	public enum SignatureAlgorithm : uint {
		/// <summary>
		/// RSA signature algorithm
		/// </summary>
		CALG_RSA_SIGN = 0x00002400,
	}

	static class StrongNameUtils {
		public static byte[] ReadBytesReverse(this BinaryReader reader, int len) {
			var data = reader.ReadBytes(len);
			if (data.Length != len)
				throw new InvalidKeyException("Can't read more bytes");
			Array.Reverse(data);
			return data;
		}

		public static void WriteReverse(this BinaryWriter writer, byte[] data) {
			var d = (byte[])data.Clone();
			Array.Reverse(d);
			writer.Write(d);
		}
	}

	/// <summary>
	/// A public key
	/// </summary>
	public sealed class StrongNamePublicKey {
		const uint RSA1_SIG = 0x31415352;
		SignatureAlgorithm signatureAlgorithm;
		AssemblyHashAlgorithm hashAlgorithm;
		byte[] modulus;
		byte[] publicExponent;

		/// <summary>
		/// Gets/sets the signature algorithm
		/// </summary>
		public SignatureAlgorithm SignatureAlgorithm {
			get { return signatureAlgorithm; }
			set { signatureAlgorithm = value; }
		}

		/// <summary>
		/// Gets/sets the hash algorithm
		/// </summary>
		public AssemblyHashAlgorithm HashAlgorithm {
			get { return hashAlgorithm; }
			set { hashAlgorithm = value; }
		}

		/// <summary>
		/// Gets/sets the modulus
		/// </summary>
		public byte[] Modulus {
			get { return modulus; }
			set { modulus = value; }
		}

		/// <summary>
		/// Gets/sets the public exponent
		/// </summary>
		public byte[] PublicExponent {
			get { return publicExponent; }
			set {
				if (value == null || value.Length != 4)
					throw new ArgumentException("PublicExponent must be exactly 4 bytes");
				publicExponent = value;
			}
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public StrongNamePublicKey() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="modulus">Modulus</param>
		/// <param name="publicExponent">Public exponent</param>
		public StrongNamePublicKey(byte[] modulus, byte[] publicExponent)
			: this(modulus, publicExponent, AssemblyHashAlgorithm.SHA1, SignatureAlgorithm.CALG_RSA_SIGN) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="modulus">Modulus</param>
		/// <param name="publicExponent">Public exponent</param>
		/// <param name="hashAlgorithm">Hash algorithm</param>
		public StrongNamePublicKey(byte[] modulus, byte[] publicExponent, AssemblyHashAlgorithm hashAlgorithm)
			: this(modulus, publicExponent, hashAlgorithm, SignatureAlgorithm.CALG_RSA_SIGN) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="modulus">Modulus</param>
		/// <param name="publicExponent">Public exponent</param>
		/// <param name="hashAlgorithm">Hash algorithm</param>
		/// <param name="signatureAlgorithm">Signature algorithm</param>
		public StrongNamePublicKey(byte[] modulus, byte[] publicExponent, AssemblyHashAlgorithm hashAlgorithm, SignatureAlgorithm signatureAlgorithm) {
			this.signatureAlgorithm = signatureAlgorithm;
			this.hashAlgorithm = hashAlgorithm;
			this.modulus = modulus;
			this.publicExponent = publicExponent;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="pk">Public key</param>
		public StrongNamePublicKey(PublicKey pk)
			: this(pk.Data) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="pk">Public key data</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNamePublicKey(byte[] pk) {
			Initialize(new BinaryReader(new MemoryStream(pk)));
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="filename">Public key file</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNamePublicKey(string filename) {
			using (var fileStream = File.OpenRead(filename))
				Initialize(new BinaryReader(fileStream));
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Public key stream</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNamePublicKey(Stream stream) {
			Initialize(new BinaryReader(stream));
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">Public key reader</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNamePublicKey(BinaryReader reader) {
			Initialize(reader);
		}

		void Initialize(BinaryReader reader) {
			try {
				// Read PublicKeyBlob
				signatureAlgorithm = (SignatureAlgorithm)reader.ReadUInt32();
				hashAlgorithm = (AssemblyHashAlgorithm)reader.ReadUInt32();
				/*int pkLen = */reader.ReadInt32();

				// Read PUBLICKEYSTRUC
				if (reader.ReadByte() != 6)
					throw new InvalidKeyException("Not a public key");
				if (reader.ReadByte() != 2)
					throw new InvalidKeyException("Invalid version");
				reader.ReadUInt16();	// reserved
				if ((SignatureAlgorithm)reader.ReadUInt32() != SignatureAlgorithm.CALG_RSA_SIGN)
					throw new InvalidKeyException("Not RSA sign");

				// Read RSAPUBKEY
				if (reader.ReadUInt32() != RSA1_SIG)	// magic = RSA1
					throw new InvalidKeyException("Invalid RSA1 magic");
				uint bitLength = reader.ReadUInt32();
				publicExponent = reader.ReadBytesReverse(4);

				modulus = reader.ReadBytesReverse((int)(bitLength / 8));
			}
			catch (IOException ex) {
				throw new InvalidKeyException("Invalid public key", ex);
			}
		}

		/// <summary>
		/// Creates a public key blob
		/// </summary>
		public byte[] CreatePublicKey() {
			return CreatePublicKey(signatureAlgorithm, hashAlgorithm, modulus, publicExponent);
		}

		internal static byte[] CreatePublicKey(SignatureAlgorithm sigAlg, AssemblyHashAlgorithm hashAlg, byte[] modulus, byte[] publicExponent) {
			if (sigAlg != SignatureAlgorithm.CALG_RSA_SIGN)
				throw new ArgumentException("Signature algorithm must be RSA");
			var outStream = new MemoryStream();
			var writer = new BinaryWriter(outStream);
			writer.Write((uint)sigAlg);		// SigAlgID
			writer.Write((uint)hashAlg);	// HashAlgID
			writer.Write(0x14 + modulus.Length);// cbPublicKey
			writer.Write((byte)6);			// bType (public key)
			writer.Write((byte)2);			// bVersion
			writer.Write((ushort)0);		// reserved
			writer.Write((uint)sigAlg);		// aiKeyAlg
			writer.Write(RSA1_SIG);			// magic (RSA1)
			writer.Write(modulus.Length * 8);	// bitlen
			writer.WriteReverse(publicExponent);// pubexp
			writer.WriteReverse(modulus);	// modulus
			return outStream.ToArray();
		}

		/// <inheritdoc/>
		public override string ToString() {
			return Utils.ToHex(CreatePublicKey(), false);
		}
	}

	/// <summary>
	/// Stores a strong name key pair
	/// </summary>
	public sealed class StrongNameKey {
		const uint RSA2_SIG = 0x32415352;
		byte[] publicKey;
		AssemblyHashAlgorithm hashAlg;
		byte[] publicExponent;
		byte[] modulus;
		byte[] prime1;
		byte[] prime2;
		byte[] exponent1;
		byte[] exponent2;
		byte[] coefficient;
		byte[] privateExponent;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Gets the public key
		/// </summary>
		public byte[] PublicKey {
			get {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				if (publicKey == null)
					publicKey = CreatePublicKey_NoLock();
				return publicKey;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets the strong name signature size in bytes
		/// </summary>
		public int SignatureSize {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return modulus.Length;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets the public key hash algorithm. It's usually <see cref="AssemblyHashAlgorithm.SHA1"/>
		/// </summary>
		public AssemblyHashAlgorithm HashAlgorithm {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return hashAlg;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				if (hashAlg == value)
					return;
				publicKey = null;
				hashAlg = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets the public exponent
		/// </summary>
		public byte[] PublicExponent {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return publicExponent;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null || value.Length != 4)
					throw new ArgumentException("PublicExponent must be exactly 4 bytes");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				publicExponent = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets the modulus
		/// </summary>
		public byte[] Modulus {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return modulus;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null)
					throw new ArgumentNullException("value");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				modulus = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets prime1
		/// </summary>
		public byte[] Prime1 {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return prime1;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null)
					throw new ArgumentNullException("value");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				prime1 = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets prime2
		/// </summary>
		public byte[] Prime2 {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return prime2;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null)
					throw new ArgumentNullException("value");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				prime2 = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets exponent1
		/// </summary>
		public byte[] Exponent1 {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return exponent1;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null)
					throw new ArgumentNullException("value");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				exponent1 = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets exponent2
		/// </summary>
		public byte[] Exponent2 {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return exponent2;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null)
					throw new ArgumentNullException("value");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				exponent2 = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets the coefficient
		/// </summary>
		public byte[] Coefficient {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return coefficient;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null)
					throw new ArgumentNullException("value");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				coefficient = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets/sets the private exponent
		/// </summary>
		public byte[] PrivateExponent {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return privateExponent;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
				if (value == null)
					throw new ArgumentNullException("value");
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				privateExponent = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public StrongNameKey() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="keyData">Strong name key data</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNameKey(byte[] keyData) {
			Initialize(new BinaryReader(new MemoryStream(keyData)));
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="filename">Strong name key file</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNameKey(string filename) {
			using (var fileStream = File.OpenRead(filename))
				Initialize(new BinaryReader(fileStream));
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Strong name key stream</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNameKey(Stream stream) {
			Initialize(new BinaryReader(stream));
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">Strong name key reader</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNameKey(BinaryReader reader) {
			Initialize(reader);
		}

		/// <summary>
		/// Initializes the public/private key pair data
		/// </summary>
		/// <param name="reader">Public/private key pair reader</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public void Initialize(BinaryReader reader) {
			/*
			 * Links:
			 *	http://msdn.microsoft.com/en-us/library/cc250013%28v=prot.20%29.aspx
			 *	http://msdn.microsoft.com/en-us/library/windows/desktop/aa387689%28v=vs.85%29.aspx
			 *
			 *	struct PublicKeyBlob {
			 *	  unsigned int SigAlgID;	// sig algorithm used to create the sig (00002400 = CALG_RSA_SIGN)
			 *	  unsigned int HashAlgID;	// hash alg used to create the sig (usually 00008004 = CALG_SHA1)
			 *	  ULONG        cbPublicKey;	// Size of the data that follows
			 *	  // the rest is here
			 *	}
			 *
			 *	typedef struct _PUBLICKEYSTRUC {
			 *	  BYTE   bType;
			 *	  BYTE   bVersion;
			 *	  WORD   reserved;
			 *	  ALG_ID aiKeyAlg;
			 *	} BLOBHEADER, PUBLICKEYSTRUC;
			 *
			 *	typedef struct _RSAPUBKEY {
			 *	  DWORD magic;
			 *	  DWORD bitlen;
			 *	  DWORD pubexp;
			 *	} RSAPUBKEY;
			 *
			 * Format of public key
			 *	PublicKeyBlob
			 *	PUBLICKEYSTRUC	publickeystruc;
			 *	RSAPUBKEY		rsapubkey;
			 *	BYTE			modulus[rsapubkey.bitlen/8]
			 *
			 * Format of public/private key pair
			 *	PUBLICKEYSTRUC	publickeystruc;
			 *	RSAPUBKEY		rsapubkey;
			 *	BYTE			modulus[rsapubkey.bitlen/8];
			 *	BYTE			prime1[rsapubkey.bitlen/16];		// aka P
			 *	BYTE			prime2[rsapubkey.bitlen/16];		// aka Q
			 *	BYTE			exponent1[rsapubkey.bitlen/16];		// aka DP
			 *	BYTE			exponent2[rsapubkey.bitlen/16];		// aka DQ
			 *	BYTE			coefficient[rsapubkey.bitlen/16];	// aka IQ
			 *	BYTE			privateExponent[rsapubkey.bitlen/8];// aka D
			 */

			try {
				publicKey = null;

				// Read PUBLICKEYSTRUC
				if (reader.ReadByte() != 7)
					throw new InvalidKeyException("Not a public/private key pair");
				if (reader.ReadByte() != 2)
					throw new InvalidKeyException("Invalid version");
				reader.ReadUInt16();	// reserved
				if ((SignatureAlgorithm)reader.ReadUInt32() != SignatureAlgorithm.CALG_RSA_SIGN)
					throw new InvalidKeyException("Not RSA sign");

				// Read RSAPUBKEY
				if (reader.ReadUInt32() != RSA2_SIG)	// magic = RSA2
					throw new InvalidKeyException("Invalid RSA2 magic");
				uint bitLength = reader.ReadUInt32();
				publicExponent = reader.ReadBytesReverse(4);

				int len8 = (int)(bitLength / 8);
				int len16 = (int)(bitLength / 16);

				// Read the rest
				modulus = reader.ReadBytesReverse(len8);
				prime1 = reader.ReadBytesReverse(len16);
				prime2 = reader.ReadBytesReverse(len16);
				exponent1 = reader.ReadBytesReverse(len16);
				exponent2 = reader.ReadBytesReverse(len16);
				coefficient = reader.ReadBytesReverse(len16);
				privateExponent = reader.ReadBytesReverse(len8);
			}
			catch (IOException ex) {
				throw new InvalidKeyException("Couldn't read strong name key", ex);
			}
		}

		byte[] CreatePublicKey_NoLock() {
			var halg = hashAlg == 0 ? AssemblyHashAlgorithm.SHA1 : hashAlg;
			return StrongNamePublicKey.CreatePublicKey(SignatureAlgorithm.CALG_RSA_SIGN, halg, modulus, publicExponent);
		}

		/// <summary>
		/// Creates an <see cref="RSA"/> instance
		/// </summary>
		public RSA CreateRSA() {
			RSAParameters rsaParams;
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			rsaParams = new RSAParameters {
				Exponent = publicExponent,
				Modulus = modulus,
				P = prime1,
				Q = prime2,
				DP = exponent1,
				DQ = exponent2,
				InverseQ = coefficient,
				D = privateExponent,
			};
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
			var rsa = RSA.Create();
			try {
				rsa.ImportParameters(rsaParams);
				return rsa;
			}
			catch {
				((IDisposable)rsa).Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates a strong name blob
		/// </summary>
		public byte[] CreateStrongName() {
			var outStream = new MemoryStream();
			var writer = new BinaryWriter(outStream);
			writer.Write((byte)7);			// bType (public/private key)
			writer.Write((byte)2);			// bVersion
			writer.Write((ushort)0);		// reserved
			writer.Write((uint)SignatureAlgorithm.CALG_RSA_SIGN);	// aiKeyAlg
			writer.Write(RSA2_SIG);			// magic (RSA2)
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			writer.Write(modulus.Length * 8);	// bitlen
			writer.WriteReverse(publicExponent);
			writer.WriteReverse(modulus);
			writer.WriteReverse(prime1);
			writer.WriteReverse(prime2);
			writer.WriteReverse(exponent1);
			writer.WriteReverse(exponent2);
			writer.WriteReverse(coefficient);
			writer.WriteReverse(privateExponent);
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
			return outStream.ToArray();
		}

		/// <summary>
		/// Creates a counter signature, just like
		/// <c>sn -a IdentityPubKey.snk IdentityKey.snk SignaturePubKey.snk</c> can do.
		/// The public key <c>sn</c> prints is <paramref name="signaturePubKey"/>'s value.
		/// </summary>
		/// <param name="identityPubKey">Identity public key</param>
		/// <param name="identityKey">Identity strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		/// <returns>The counter signature as a hex string</returns>
		public static string CreateCounterSignatureAsString(StrongNamePublicKey identityPubKey, StrongNameKey identityKey, StrongNamePublicKey signaturePubKey) {
			var counterSignature = CreateCounterSignature(identityPubKey, identityKey, signaturePubKey);
			return Utils.ToHex(counterSignature, false);
		}

		/// <summary>
		/// Creates a counter signature, just like
		/// <c>sn -a IdentityPubKey.snk IdentityKey.snk SignaturePubKey.snk</c> can do.
		/// The public key <c>sn</c> prints is <paramref name="signaturePubKey"/>'s value.
		/// </summary>
		/// <param name="identityPubKey">Identity public key</param>
		/// <param name="identityKey">Identity strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		/// <returns>The counter signature</returns>
		public static byte[] CreateCounterSignature(StrongNamePublicKey identityPubKey, StrongNameKey identityKey, StrongNamePublicKey signaturePubKey) {
			var hash = AssemblyHash.Hash(signaturePubKey.CreatePublicKey(), identityPubKey.HashAlgorithm);
			using (var rsa = identityKey.CreateRSA()) {
				var rsaFmt = new RSAPKCS1SignatureFormatter(rsa);
				string hashName = identityPubKey.HashAlgorithm.GetName();
				rsaFmt.SetHashAlgorithm(hashName);
				var snSig = rsaFmt.CreateSignature(hash);
				Array.Reverse(snSig);
				return snSig;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/StrongNameSigner.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.IO;
using System.Security.Cryptography;

namespace dnlib.DotNet {
	/// <summary>
	/// Strong name signs an assembly. It supports normal strong name signing and the new
	/// (.NET 4.5) enhanced strong name signing.
	/// </summary>
	public struct StrongNameSigner {
		readonly Stream stream;
		readonly long baseOffset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">.NET PE file stream</param>
		public StrongNameSigner(Stream stream)
			: this(stream, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">.NET PE file stream</param>
		/// <param name="baseOffset">Offset in <paramref name="stream"/> of the first byte of
		/// the PE file.</param>
		public StrongNameSigner(Stream stream, long baseOffset) {
			this.stream = stream;
			this.baseOffset = baseOffset;
		}

		/// <summary>
		/// Calculates the strong name signature and writes it to the stream. The signature
		/// is also returned.
		/// </summary>
		/// <param name="snk">Strong name key used for signing</param>
		/// <param name="snSigOffset">Offset (relative to the start of the PE file) of the strong
		/// name signature.</param>
		/// <returns>The strong name signature</returns>
		public byte[] WriteSignature(StrongNameKey snk, long snSigOffset) {
			var sign = CalculateSignature(snk, snSigOffset);
			stream.Position = baseOffset + snSigOffset;
			stream.Write(sign, 0, sign.Length);
			return sign;
		}

		/// <summary>
		/// Calculates and returns the strong name signature
		/// </summary>
		/// <param name="snk">Strong name key used for signing</param>
		/// <param name="snSigOffset">Offset (relative to start of PE file) of the strong
		/// name signature.</param>
		/// <returns>The strong name signature</returns>
		public byte[] CalculateSignature(StrongNameKey snk, long snSigOffset) {
			uint snSigSize = (uint)snk.SignatureSize;
			var hashAlg = snk.HashAlgorithm == 0 ? AssemblyHashAlgorithm.SHA1 : snk.HashAlgorithm;
			var hash = StrongNameHashData(hashAlg, snSigOffset, snSigSize);
			var snSig = GetStrongNameSignature(snk, hashAlg, hash);
			if (snSig.Length != snSigSize)
				throw new InvalidOperationException("Invalid strong name signature size");
			return snSig;
		}

		/// <summary>
		/// Strong name hashes the .NET file
		/// </summary>
		/// <param name="hashAlg">Hash algorithm</param>
		/// <param name="snSigOffset">Strong name sig offset (relative to start of .NET PE file)</param>
		/// <param name="snSigSize">Size of strong name signature</param>
		/// <returns>The strong name hash of the .NET file</returns>
		byte[] StrongNameHashData(AssemblyHashAlgorithm hashAlg, long snSigOffset, uint snSigSize) {
			var reader = new BinaryReader(stream);

			snSigOffset += baseOffset;
			long snSigOffsetEnd = snSigOffset + snSigSize;

			using (var hasher = new AssemblyHash(hashAlg)) {
				byte[] buffer = new byte[0x8000];

				// Hash the DOS header. It's defined to be all data from the start of
				// the file up to the NT headers.
				stream.Position = baseOffset + 0x3C;
				uint ntHeadersOffs = reader.ReadUInt32();
				stream.Position = baseOffset;
				hasher.Hash(stream, ntHeadersOffs, buffer);

				// Hash NT headers, but hash authenticode + checksum as 0s
				stream.Position += 6;
				int numSections = reader.ReadUInt16();
				stream.Position -= 8;
				hasher.Hash(stream, 0x18, buffer);	// magic + FileHeader

				bool is32bit = reader.ReadUInt16() == 0x010B;
				stream.Position -= 2;
				int optHeaderSize = is32bit ? 0x60 : 0x70;
				if (stream.Read(buffer, 0, optHeaderSize) != optHeaderSize)
					throw new IOException("Could not read data");
				// Clear checksum
				for (int i = 0; i < 4; i++)
					buffer[0x40 + i] = 0;
				hasher.Hash(buffer, 0, optHeaderSize);

				const int imageDirsSize = 16 * 8;
				if (stream.Read(buffer, 0, imageDirsSize) != imageDirsSize)
					throw new IOException("Could not read data");
				// Clear authenticode data dir
				for (int i = 0; i < 8; i++)
					buffer[4 * 8 + i] = 0;
				hasher.Hash(buffer, 0, imageDirsSize);

				// Hash section headers
				long sectHeadersOffs = stream.Position;
				hasher.Hash(stream, (uint)numSections * 0x28, buffer);

				// Hash all raw section data but make sure we don't hash the location
				// where the strong name signature will be stored.
				for (int i = 0; i < numSections; i++) {
					stream.Position = sectHeadersOffs + i * 0x28 + 0x10;
					uint sizeOfRawData = reader.ReadUInt32();
					uint pointerToRawData = reader.ReadUInt32();

					stream.Position = baseOffset + pointerToRawData;
					while (sizeOfRawData > 0) {
						var pos = stream.Position;

						if (snSigOffset <= pos && pos < snSigOffsetEnd) {
							uint skipSize = (uint)(snSigOffsetEnd - pos);
							if (skipSize >= sizeOfRawData)
								break;
							sizeOfRawData -= skipSize;
							stream.Position += skipSize;
							continue;
						}

						if (pos >= snSigOffsetEnd) {
							hasher.Hash(stream, sizeOfRawData, buffer);
							break;
						}

						uint maxLen = (uint)Math.Min(snSigOffset - pos, sizeOfRawData);
						hasher.Hash(stream, maxLen, buffer);
						sizeOfRawData -= maxLen;
					}
				}

				return hasher.ComputeHash();
			}
		}

		/// <summary>
		/// Returns the strong name signature
		/// </summary>
		/// <param name="snk">Strong name key</param>
		/// <param name="hashAlg">Hash algorithm</param>
		/// <param name="hash">Strong name hash of the .NET PE file</param>
		/// <returns>Strong name signature</returns>
		byte[] GetStrongNameSignature(StrongNameKey snk, AssemblyHashAlgorithm hashAlg, byte[] hash) {
			using (var rsa = snk.CreateRSA()) {
				var rsaFmt = new RSAPKCS1SignatureFormatter(rsa);
				string hashName = hashAlg.GetName() ?? AssemblyHashAlgorithm.SHA1.GetName();
				rsaFmt.SetHashAlgorithm(hashName);
				var snSig = rsaFmt.CreateSignature(hash);
				Array.Reverse(snSig);
				return snSig;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TIAHelper.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

// See coreclr/src/vm/siginfo.cpp

using System;
using System.Diagnostics;

namespace dnlib.DotNet {
	/// <summary>
	/// <c>System.Runtime.InteropServices.TypeIdentifierAttribute</c> helper code used by <see cref="SigComparer"/>
	/// </summary>
	static class TIAHelper {
		struct Info : IEquatable<Info> {
			public readonly UTF8String Scope;
			public readonly UTF8String Identifier;

			public Info(UTF8String scope, UTF8String identifier) {
				this.Scope = scope;
				this.Identifier = identifier;
			}

			public bool Equals(Info other) {
				return stricmp(Scope, other.Scope) &&
					UTF8String.Equals(Identifier, other.Identifier);
			}

			static bool stricmp(UTF8String a, UTF8String b) {
				var da = (object)a == null ? null : a.Data;
				var db = (object)b == null ? null : b.Data;
				if (da == db)
					return true;
				if (da == null || db == null)
					return false;
				if (da.Length != db.Length)
					return false;
				for (int i = 0; i < da.Length; i++) {
					byte ba = da[i], bb = db[i];
					if ((byte)'A' <= ba && ba <= (byte)'Z')
						ba = (byte)(ba - 'A' + 'a');
					if ((byte)'A' <= bb && bb <= (byte)'Z')
						bb = (byte)(bb - 'A' + 'a');
					if (ba != bb)
						return false;
				}
				return true;
			}
		}

		static Info? GetInfo(TypeDef td) {
			if (td == null)
				return null;
			if (td.IsWindowsRuntime)
				return null;

			UTF8String scope = null, identifier = null;
			var tia = td.CustomAttributes.Find("System.Runtime.InteropServices.TypeIdentifierAttribute");
			if (tia != null) {
				if (tia.ConstructorArguments.Count >= 2) {
					if (tia.ConstructorArguments[0].Type.GetElementType() != ElementType.String)
						return null;
					if (tia.ConstructorArguments[1].Type.GetElementType() != ElementType.String)
						return null;
					scope = tia.ConstructorArguments[0].Value as UTF8String ?? tia.ConstructorArguments[0].Value as string;
					identifier = tia.ConstructorArguments[1].Value as UTF8String ?? tia.ConstructorArguments[1].Value as string;
				}
			}
			else {
				var mod = td.Module;
				var asm = mod == null ? null : mod.Assembly;
				if (asm == null)
					return null;
				bool isTypeLib = asm.CustomAttributes.IsDefined("System.Runtime.InteropServices.ImportedFromTypeLibAttribute") ||
								asm.CustomAttributes.IsDefined("System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute");
				if (!isTypeLib)
					return null;
			}

			if (UTF8String.IsNull(identifier)) {
				CustomAttribute gca;
				if (td.IsInterface && td.IsImport)
					gca = td.CustomAttributes.Find("System.Runtime.InteropServices.GuidAttribute");
				else {
					var mod = td.Module;
					var asm = mod == null ? null : mod.Assembly;
					if (asm == null)
						return null;
					gca = asm.CustomAttributes.Find("System.Runtime.InteropServices.GuidAttribute");
				}
				if (gca == null)
					return null;
				if (gca.ConstructorArguments.Count < 1)
					return null;
				if (gca.ConstructorArguments[0].Type.GetElementType() != ElementType.String)
					return null;
				scope = gca.ConstructorArguments[0].Value as UTF8String ?? gca.ConstructorArguments[0].Value as string;
				var ns = td.Namespace;
				var name = td.Name;
				if (UTF8String.IsNullOrEmpty(ns))
					identifier = name;
				else if (UTF8String.IsNullOrEmpty(name))
					identifier = new UTF8String(Concat(ns.Data, (byte)'.', empty));
				else
					identifier = new UTF8String(Concat(ns.Data, (byte)'.', name.Data));
			}
			return new Info(scope, identifier);
		}
		static readonly byte[] empty = new byte[0];

		static byte[] Concat(byte[] a, byte b, byte[] c) {
			var data = new byte[a.Length + 1 + c.Length];
			for (int i = 0; i < a.Length; i++)
				data[i] = a[i];
			data[a.Length] = b;
			for (int i = 0, j = a.Length + 1; i < c.Length; i++, j++)
				data[j] = c[i];
			return data;
		}

		static bool CheckEquivalent(TypeDef td) {
			Debug.Assert(td != null);

			for (int i = 0; td != null && i < 1000; i++) {
				if (i != 0) {
					var info = GetInfo(td);
					if (info == null)
						return false;
				}

				bool f;
				if (td.IsInterface)
					f = td.IsImport || td.CustomAttributes.IsDefined("System.Runtime.InteropServices.ComEventInterfaceAttribute");
				else
					f = td.IsValueType || td.IsDelegate;
				if (!f)
					return false;
				if (td.GenericParameters.Count > 0)
					return false;

				var declType = td.DeclaringType;
				if (declType == null)
					return td.IsPublic;

				if (!td.IsNestedPublic)
					return false;
				td = declType;
			}

			return false;
		}

		public static bool Equivalent(TypeDef td1, TypeDef td2) {
			var info1 = GetInfo(td1);
			if (info1 == null)
				return false;
			var info2 = GetInfo(td2);
			if (info2 == null)
				return false;
			if (!CheckEquivalent(td1) || !CheckEquivalent(td2))
				return false;
			if (!info1.Value.Equals(info2.Value))
				return false;

			// Caller has already compared names of the types and any declaring types

			for (int i = 0; i < 1000; i++) {
				if (td1.IsInterface) {
					if (!td2.IsInterface)
						return false;
				}
				else {
					var bt1 = td1.BaseType;
					var bt2 = td2.BaseType;
					if (bt1 == null || bt2 == null)
						return false;
					if (td1.IsDelegate) {
						if (!td2.IsDelegate)
							return false;
						if (!DelegateEquals(td1, td2))
							return false;
					}
					else if (td1.IsValueType) {
						if (td1.IsEnum != td2.IsEnum)
							return false;
						if (!td2.IsValueType)
							return false;
						if (!ValueTypeEquals(td1, td2, td1.IsEnum))
							return false;
					}
					else
						return false;
				}

				td1 = td1.DeclaringType;
				td2 = td2.DeclaringType;
				if (td1 == null && td2 == null)
					break;
				if (td1 == null || td2 == null)
					return false;
			}

			return true;
		}

		static bool DelegateEquals(TypeDef td1, TypeDef td2) {
			var invoke1 = td1.FindMethod(InvokeString);
			var invoke2 = td2.FindMethod(InvokeString);
			if (invoke1 == null || invoke2 == null)
				return false;

			//TODO: Compare method signatures. Prevent infinite recursion...

			return true;
		}
		static readonly UTF8String InvokeString = new UTF8String("Invoke");

		static bool ValueTypeEquals(TypeDef td1, TypeDef td2, bool isEnum) {
			if (td1.Methods.Count != 0 || td2.Methods.Count != 0)
				return false;

			//TODO: Compare the fields. Prevent infinite recursion...

			return true;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TypeAttributes.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet {
	/// <summary>
	/// TypeDef and ExportedType flags. See CorHdr.h/CorTypeAttr
	/// </summary>
	[Flags]
	public enum TypeAttributes : uint {
		/// <summary>Use this mask to retrieve the type visibility information.</summary>
		VisibilityMask			= 0x00000007,
		/// <summary>Class is not public scope.</summary>
		NotPublic				= 0x00000000,
		/// <summary>Class is public scope.</summary>
		Public					= 0x00000001,
		/// <summary>Class is nested with public visibility.</summary>
		NestedPublic			= 0x00000002,
		/// <summary>Class is nested with private visibility.</summary>
		NestedPrivate			= 0x00000003,
		/// <summary>Class is nested with family visibility.</summary>
		NestedFamily			= 0x00000004,
		/// <summary>Class is nested with assembly visibility.</summary>
		NestedAssembly			= 0x00000005,
		/// <summary>Class is nested with family and assembly visibility.</summary>
		NestedFamANDAssem		= 0x00000006,
		/// <summary>Class is nested with family or assembly visibility.</summary>
		NestedFamORAssem		= 0x00000007,

		/// <summary>Use this mask to retrieve class layout information</summary>
		LayoutMask				= 0x00000018,
		/// <summary>Class fields are auto-laid out</summary>
		AutoLayout				= 0x00000000,
		/// <summary>Class fields are laid out sequentially</summary>
		SequentialLayout		= 0x00000008,
		/// <summary>Layout is supplied explicitly</summary>
		ExplicitLayout			= 0x00000010,

		/// <summary>Use this mask to retrieve class semantics information.</summary>
		ClassSemanticsMask		= 0x00000020,
		/// <summary>Use this mask to retrieve class semantics information.</summary>
		ClassSemanticMask		= ClassSemanticsMask,
		/// <summary>Type is a class.</summary>
		Class					= 0x00000000,
		/// <summary>Type is an interface.</summary>
		Interface				= 0x00000020,

		/// <summary>Class is abstract</summary>
		Abstract				= 0x00000080,
		/// <summary>Class is concrete and may not be extended</summary>
		Sealed					= 0x00000100,
		/// <summary>Class name is special.  Name describes how.</summary>
		SpecialName				= 0x00000400,

		/// <summary>Class / interface is imported</summary>
		Import					= 0x00001000,
		/// <summary>The class is Serializable.</summary>
		Serializable			= 0x00002000,
		/// <summary>The type is a Windows Runtime type</summary>
		WindowsRuntime			= 0x00004000,

		/// <summary>Use StringFormatMask to retrieve string information for native interop</summary>
		StringFormatMask		= 0x00030000,
		/// <summary>LPTSTR is interpreted as ANSI in this class</summary>
		AnsiClass				= 0x00000000,
		/// <summary>LPTSTR is interpreted as UNICODE</summary>
		UnicodeClass			= 0x00010000,
		/// <summary>LPTSTR is interpreted automatically</summary>
		AutoClass				= 0x00020000,
		/// <summary>A non-standard encoding specified by CustomFormatMask</summary>
		CustomFormatClass		= 0x00030000,
		/// <summary>Use this mask to retrieve non-standard encoding information for native interop. The meaning of the values of these 2 bits is unspecified.</summary>
		CustomFormatMask		= 0x00C00000,

		/// <summary>Initialize the class any time before first static field access.</summary>
		BeforeFieldInit			= 0x00100000,
		/// <summary>This ExportedType is a type forwarder.</summary>
		Forwarder				= 0x00200000,

		/// <summary>Flags reserved for runtime use.</summary>
		ReservedMask			= 0x00040800,
		/// <summary>Runtime should check name encoding.</summary>
		RTSpecialName			= 0x00000800,
		/// <summary>Class has security associate with it.</summary>
		HasSecurity				= 0x00040000,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TypeDef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Threading;
using dnlib.Utils;
using dnlib.DotNet.MD;
using dnlib.DotNet.Emit;
using dnlib.Threading;
using dnlib.DotNet.Pdb;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the TypeDef table
	/// </summary>
	public abstract class TypeDef : ITypeDefOrRef, IHasCustomAttribute, IHasDeclSecurity, IMemberRefParent, ITypeOrMethodDef, IHasCustomDebugInformation, IListListener<FieldDef>, IListListener<MethodDef>, IListListener<TypeDef>, IListListener<EventDef>, IListListener<PropertyDef>, IListListener<GenericParam>, IMemberRefResolver, IMemberDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.TypeDef, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int TypeDefOrRefTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 3; }
		}

		/// <inheritdoc/>
		public int HasDeclSecurityTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		public int MemberRefParentTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		public int TypeOrMethodDefTag {
			get { return 0; }
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get { return GenericParameters.Count; }
		}

		/// <inheritdoc/>
		string IType.TypeName {
			get { return FullNameCreator.Name(this, false, null); }
		}

		/// <inheritdoc/>
		public string ReflectionName {
			get { return FullNameCreator.Name(this, true, null); }
		}

		/// <inheritdoc/>
		string IType.Namespace {
			get { return FullNameCreator.Namespace(this, false, null); }
		}

		/// <inheritdoc/>
		public string ReflectionNamespace {
			get { return FullNameCreator.Namespace(this, true, null); }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return FullNameCreator.FullName(this, false, null, null); }
		}

		/// <inheritdoc/>
		public string ReflectionFullName {
			get { return FullNameCreator.FullName(this, true, null, null); }
		}

		/// <inheritdoc/>
		public string AssemblyQualifiedName {
			get { return FullNameCreator.AssemblyQualifiedName(this, null, null); }
		}

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly {
			get { return FullNameCreator.DefinitionAssembly(this); }
		}

		/// <inheritdoc/>
		public IScope Scope {
			get { return Module; }
		}

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType {
			get { return this; }
		}

		/// <summary>
		/// Always returns <c>false</c> since a <see cref="TypeDef"/> does not contain any
		/// <see cref="GenericVar"/> or <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter {
			get { return false; }
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get { return FullNameCreator.OwnerModule(this); }
		}

		/// <summary>
		/// Gets/sets the owner module
		/// </summary>
		internal ModuleDef Module2 {
			get {
				if (!module2_isInitialized)
					InitializeModule2();
				return module2;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				module2 = value;
				module2_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ModuleDef module2;
		/// <summary/>
		protected bool module2_isInitialized;

		void InitializeModule2() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (module2_isInitialized)
				return;
			module2 = GetModule2_NoLock();
			module2_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="module2"/></summary>
		protected virtual ModuleDef GetModule2_NoLock() {
			return null;
		}

		bool IIsTypeOrMethod.IsType {
			get { return true; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		bool IMemberRef.IsField {
			get { return false; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return true; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		/// <summary>
		/// From column TypeDef.Flags
		/// </summary>
		public TypeAttributes Attributes {
			get { return (TypeAttributes)attributes; }
			set { attributes = (int)value; }
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column TypeDef.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column TypeDef.Namespace
		/// </summary>
		public UTF8String Namespace {
			get { return @namespace; }
			set { @namespace = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String @namespace;

		/// <summary>
		/// From column TypeDef.Extends
		/// </summary>
		public ITypeDefOrRef BaseType {
			get {
				if (!baseType_isInitialized)
					InitializeBaseType();
				return baseType;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				baseType = value;
				baseType_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ITypeDefOrRef baseType;
		/// <summary/>
		protected bool baseType_isInitialized;

		void InitializeBaseType() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (baseType_isInitialized)
				return;
			baseType = GetBaseType_NoLock();
			baseType_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="baseType"/></summary>
		protected virtual ITypeDefOrRef GetBaseType_NoLock() {
			return null;
		}

		/// <summary>Reset <see cref="BaseType"/></summary>
		protected void ResetBaseType() {
			baseType_isInitialized = false;
		}

		/// <summary>
		/// From column TypeDef.FieldList
		/// </summary>
		public ThreadSafe.IList<FieldDef> Fields {
			get {
				if (fields == null)
					InitializeFields();
				return fields;
			}
		}
		/// <summary/>
		protected LazyList<FieldDef> fields;
		/// <summary>Initializes <see cref="fields"/></summary>
		protected virtual void InitializeFields() {
			Interlocked.CompareExchange(ref fields, new LazyList<FieldDef>(this), null);
		}

		/// <summary>
		/// From column TypeDef.MethodList
		/// </summary>
		public ThreadSafe.IList<MethodDef> Methods {
			get {
				if (methods == null)
					InitializeMethods();
				return methods;
			}
		}
		/// <summary/>
		protected LazyList<MethodDef> methods;
		/// <summary>Initializes <see cref="methods"/></summary>
		protected virtual void InitializeMethods() {
			Interlocked.CompareExchange(ref methods, new LazyList<MethodDef>(this), null);
		}

		/// <inheritdoc/>
		public ThreadSafe.IList<GenericParam> GenericParameters {
			get {
				if (genericParameters == null)
					InitializeGenericParameters();
				return genericParameters;
			}
		}
		/// <summary/>
		protected LazyList<GenericParam> genericParameters;
		/// <summary>Initializes <see cref="genericParameters"/></summary>
		protected virtual void InitializeGenericParameters() {
			Interlocked.CompareExchange(ref genericParameters, new LazyList<GenericParam>(this), null);
		}

		/// <summary>
		/// Gets the interfaces
		/// </summary>
		public ThreadSafe.IList<InterfaceImpl> Interfaces {
			get {
				if (interfaces == null)
					InitializeInterfaces();
				return interfaces;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<InterfaceImpl> interfaces;
		/// <summary>Initializes <see cref="interfaces"/></summary>
		protected virtual void InitializeInterfaces() {
			Interlocked.CompareExchange(ref interfaces, ThreadSafeListCreator.Create<InterfaceImpl>(), null);
		}

		/// <inheritdoc/>
		public ThreadSafe.IList<DeclSecurity> DeclSecurities {
			get {
				if (declSecurities == null)
					InitializeDeclSecurities();
				return declSecurities;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<DeclSecurity> declSecurities;
		/// <summary>Initializes <see cref="declSecurities"/></summary>
		protected virtual void InitializeDeclSecurities() {
			Interlocked.CompareExchange(ref declSecurities, ThreadSafeListCreator.Create<DeclSecurity>(), null);
		}

		/// <summary>
		/// Gets/sets the class layout
		/// </summary>
		public ClassLayout ClassLayout {
			get {
				if (!classLayout_isInitialized)
					InitializeClassLayout();
				return classLayout;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				classLayout = value;
				classLayout_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ClassLayout classLayout;
		/// <summary/>
		protected bool classLayout_isInitialized;

		void InitializeClassLayout() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (classLayout_isInitialized)
				return;
			classLayout = GetClassLayout_NoLock();
			classLayout_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}
		ClassLayout GetOrCreateClassLayout() {
			var cl = ClassLayout;
			if (cl != null)
				return cl;
			Interlocked.CompareExchange(ref classLayout, new ClassLayoutUser(0, 0), null);
			return classLayout;
		}

		/// <summary>Called to initialize <see cref="classLayout"/></summary>
		protected virtual ClassLayout GetClassLayout_NoLock() {
			return null;
		}

		/// <inheritdoc/>
		public bool HasDeclSecurities {
			get { return DeclSecurities.Count > 0; }
		}

		/// <summary>
		/// Gets/sets the enclosing type. It's <c>null</c> if this isn't a nested class.
		/// </summary>
		public TypeDef DeclaringType {
			get {
				if (!declaringType2_isInitialized)
					InitializeDeclaringType2();
				return declaringType2;
			}
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType != null)
					currentDeclaringType.NestedTypes.Remove(this);	// Will set DeclaringType2 = null
				if (value != null)
					value.NestedTypes.Add(this);		// Will set DeclaringType2 = value

				// Make sure this is clear. Will be set whenever it's inserted into ModulDef.Types
				Module2 = null;
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get { return DeclaringType; }
		}

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get {
				if (!declaringType2_isInitialized)
					InitializeDeclaringType2();
				return declaringType2;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				declaringType2 = value;
				declaringType2_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected TypeDef declaringType2;
		/// <summary/>
		protected bool declaringType2_isInitialized;

		void InitializeDeclaringType2() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (declaringType2_isInitialized)
				return;
			declaringType2 = GetDeclaringType2_NoLock();
			declaringType2_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="declaringType2"/></summary>
		protected virtual TypeDef GetDeclaringType2_NoLock() {
			return null;
		}

		/// <summary>
		/// Gets all the nested types
		/// </summary>
		public ThreadSafe.IList<TypeDef> NestedTypes {
			get {
				if (nestedTypes == null)
					InitializeNestedTypes();
				return nestedTypes;
			}
		}
		/// <summary/>
		protected LazyList<TypeDef> nestedTypes;
		/// <summary>Initializes <see cref="nestedTypes"/></summary>
		protected virtual void InitializeNestedTypes() {
			Interlocked.CompareExchange(ref nestedTypes, new LazyList<TypeDef>(this), null);
		}

		/// <summary>
		/// Gets all events
		/// </summary>
		public ThreadSafe.IList<EventDef> Events {
			get {
				if (events == null)
					InitializeEvents();
				return events;
			}
		}
		/// <summary/>
		protected LazyList<EventDef> events;
		/// <summary>Initializes <see cref="events"/></summary>
		protected virtual void InitializeEvents() {
			Interlocked.CompareExchange(ref events, new LazyList<EventDef>(this), null);
		}

		/// <summary>
		/// Gets all properties
		/// </summary>
		public ThreadSafe.IList<PropertyDef> Properties {
			get {
				if (properties == null)
					InitializeProperties();
				return properties;
			}
		}
		/// <summary/>
		protected LazyList<PropertyDef> properties;
		/// <summary>Initializes <see cref="properties"/></summary>
		protected virtual void InitializeProperties() {
			Interlocked.CompareExchange(ref properties, new LazyList<PropertyDef>(this), null);
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 3; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="FieldDef"/> in <see cref="Fields"/>
		/// </summary>
		public bool HasFields {
			get { return Fields.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="MethodDef"/> in <see cref="Methods"/>
		/// </summary>
		public bool HasMethods {
			get { return Methods.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="GenericParam"/> in <see cref="GenericParameters"/>
		/// </summary>
		public bool HasGenericParameters {
			get { return GenericParameters.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="EventDef"/> in <see cref="Events"/>
		/// </summary>
		public bool HasEvents {
			get { return Events.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="PropertyDef"/> in <see cref="Properties"/>
		/// </summary>
		public bool HasProperties {
			get { return Properties.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="TypeDef"/> in <see cref="NestedTypes"/>
		/// </summary>
		public bool HasNestedTypes {
			get { return NestedTypes.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="InterfaceImpl"/> in <see cref="Interfaces"/>
		/// </summary>
		public bool HasInterfaces {
			get { return Interfaces.Count > 0; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ClassLayout"/> is not <c>null</c>
		/// </summary>
		public bool HasClassLayout {
			get { return ClassLayout != null; }
		}

		/// <summary>
		/// Gets/sets the packing size. If you write to this property but <see cref="ClassLayout"/>
		/// is <c>null</c>, it will be created. The value <see cref="ushort.MaxValue"/> is returned
		/// if <see cref="ClassLayout"/> is <c>null</c>.
		/// </summary>
		public ushort PackingSize {
			get {
				var cl = ClassLayout;
				return cl == null ? ushort.MaxValue : cl.PackingSize;
			}
			set {
				var cl = GetOrCreateClassLayout();
				cl.PackingSize = value;
			}
		}

		/// <summary>
		/// Gets/sets the class size. If you write to this property but <see cref="ClassLayout"/>
		/// is <c>null</c>, it will be created. The value <see cref="uint.MaxValue"/> is returned
		/// if <see cref="ClassLayout"/> is <c>null</c>.
		/// </summary>
		public uint ClassSize {
			get {
				var cl = ClassLayout;
				return cl == null ? uint.MaxValue : cl.ClassSize;
			}
			set {
				var cl = GetOrCreateClassLayout();
				cl.ClassSize = value;
			}
		}

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				// Don't include abstract since value types can be abstract without throwing at runtime
				if ((Attributes & (TypeAttributes.Sealed | TypeAttributes.ClassSemanticsMask)) != (TypeAttributes.Sealed | TypeAttributes.Class))
					return false;
				var baseType = BaseType;
				if (baseType == null)
					return false;
				if (!baseType.DefinitionAssembly.IsCorLib())
					return false;

				// PERF: Don't allocate a System.String by calling FullName etc.
				UTF8String baseName, baseNamespace;
				var baseTr = baseType as TypeRef;
				if (baseTr != null) {
					baseName = baseTr.Name;
					baseNamespace = baseTr.Namespace;
				}
				else {
					var baseTd = baseType as TypeDef;
					if (baseTd == null)
						return false;
					baseName = baseTd.Name;
					baseNamespace = baseTd.Namespace;
				}

				if (baseNamespace != systemString)
					return false;
				if (baseName != valueTypeString && baseName != enumString)
					return false;

				if (!DefinitionAssembly.IsCorLib())
					return true;
				return !(Name == enumString && Namespace == systemString);
			}
		}
		static readonly UTF8String systemString = new UTF8String("System");
		static readonly UTF8String enumString = new UTF8String("Enum");
		static readonly UTF8String valueTypeString = new UTF8String("ValueType");
		static readonly UTF8String multicastDelegateString = new UTF8String("MulticastDelegate");

		/// <summary>
		/// <c>true</c> if it's an enum
		/// </summary>
		public bool IsEnum {
			get {
				// Don't include abstract since value types can be abstract without throwing at runtime
				if ((Attributes & (TypeAttributes.Sealed | TypeAttributes.ClassSemanticsMask)) != (TypeAttributes.Sealed | TypeAttributes.Class))
					return false;
				var baseType = BaseType;
				if (baseType == null)
					return false;
				if (!baseType.DefinitionAssembly.IsCorLib())
					return false;

				// PERF: Don't allocate a System.String by calling FullName etc.
				var baseTr = baseType as TypeRef;
				if (baseTr != null)
					return baseTr.Namespace == systemString && baseTr.Name == enumString;
				var baseTd = baseType as TypeDef;
				if (baseTd != null)
					return baseTd.Namespace == systemString && baseTd.Name == enumString;
				return false;
			}
		}

		/// <summary>
		/// <c>true</c> if it's a delegate (it derives from <see cref="System.MulticastDelegate"/>)
		/// </summary>
		public bool IsDelegate {
			get {
				if ((Attributes & (TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.ClassSemanticsMask)) != (TypeAttributes.Sealed | TypeAttributes.Class))
					return false;
				var baseType = BaseType;
				if (baseType == null)
					return false;
				if (!baseType.DefinitionAssembly.IsCorLib())
					return false;

				// PERF: Don't allocate a System.String by calling FullName etc.
				var baseTr = baseType as TypeRef;
				if (baseTr != null)
					return baseTr.Namespace == systemString && baseTr.Name == multicastDelegateString;
				var baseTd = baseType as TypeDef;
				if (baseTd != null)
					return baseTd.Namespace == systemString && baseTd.Name == multicastDelegateString;
				return false;
			}
		}

		/// <summary>
		/// <c>true</c> if this is a nested type (it has a declaring type)
		/// </summary>
		public bool IsNested {
			get { return DeclaringType != null; }
		}

		/// <inheritdoc/>
		public bool IsPrimitive {
			get { return this.IsPrimitive(); }
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(TypeAttributes andMask, TypeAttributes orMask) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				newVal = (origVal & (int)andMask) | (int)orMask;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			attributes = (attributes & (int)andMask) | (int)orMask;
#endif
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, TypeAttributes flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = attributes;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref attributes, newVal, origVal) != origVal);
#else
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the visibility
		/// </summary>
		public TypeAttributes Visibility {
			get { return (TypeAttributes)attributes & TypeAttributes.VisibilityMask; }
			set { ModifyAttributes(~TypeAttributes.VisibilityMask, value & TypeAttributes.VisibilityMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NotPublic"/> is set
		/// </summary>
		public bool IsNotPublic {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.Public; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedPublic"/> is set
		/// </summary>
		public bool IsNestedPublic {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPublic; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedPrivate"/> is set
		/// </summary>
		public bool IsNestedPrivate {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamily"/> is set
		/// </summary>
		public bool IsNestedFamily {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamily; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedAssembly"/> is set
		/// </summary>
		public bool IsNestedAssembly {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedAssembly; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamANDAssem"/> is set
		/// </summary>
		public bool IsNestedFamilyAndAssembly {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamANDAssem; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamORAssem"/> is set
		/// </summary>
		public bool IsNestedFamilyOrAssembly {
			get { return ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamORAssem; }
		}

		/// <summary>
		/// Gets/sets the layout
		/// </summary>
		public TypeAttributes Layout {
			get { return (TypeAttributes)attributes & TypeAttributes.LayoutMask; }
			set { ModifyAttributes(~TypeAttributes.LayoutMask, value & TypeAttributes.LayoutMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AutoLayout"/> is set
		/// </summary>
		public bool IsAutoLayout {
			get { return ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.AutoLayout; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.SequentialLayout"/> is set
		/// </summary>
		public bool IsSequentialLayout {
			get { return ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.SequentialLayout; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.ExplicitLayout"/> is set
		/// </summary>
		public bool IsExplicitLayout {
			get { return ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.ExplicitLayout; }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Interface"/> bit
		/// </summary>
		public bool IsInterface {
			get { return ((TypeAttributes)attributes & TypeAttributes.Interface) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Interface); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Class"/> bit
		/// </summary>
		public bool IsClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.Interface) == 0; }
			set { ModifyAttributes(!value, TypeAttributes.Interface); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Abstract"/> bit
		/// </summary>
		public bool IsAbstract {
			get { return ((TypeAttributes)attributes & TypeAttributes.Abstract) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Abstract); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Sealed"/> bit
		/// </summary>
		public bool IsSealed {
			get { return ((TypeAttributes)attributes & TypeAttributes.Sealed) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Sealed); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get { return ((TypeAttributes)attributes & TypeAttributes.SpecialName) != 0; }
			set { ModifyAttributes(value, TypeAttributes.SpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Import"/> bit
		/// </summary>
		public bool IsImport {
			get { return ((TypeAttributes)attributes & TypeAttributes.Import) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Import); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Serializable"/> bit
		/// </summary>
		public bool IsSerializable {
			get { return ((TypeAttributes)attributes & TypeAttributes.Serializable) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Serializable); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.WindowsRuntime"/> bit
		/// </summary>
		public bool IsWindowsRuntime {
			get { return ((TypeAttributes)attributes & TypeAttributes.WindowsRuntime) != 0; }
			set { ModifyAttributes(value, TypeAttributes.WindowsRuntime); }
		}

		/// <summary>
		/// Gets/sets the string format
		/// </summary>
		public TypeAttributes StringFormat {
			get { return (TypeAttributes)attributes & TypeAttributes.StringFormatMask; }
			set { ModifyAttributes(~TypeAttributes.StringFormatMask, value & TypeAttributes.StringFormatMask); }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AnsiClass"/> is set
		/// </summary>
		public bool IsAnsiClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AnsiClass; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.UnicodeClass"/> is set
		/// </summary>
		public bool IsUnicodeClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.UnicodeClass; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AutoClass"/> is set
		/// </summary>
		public bool IsAutoClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AutoClass; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.CustomFormatClass"/> is set
		/// </summary>
		public bool IsCustomFormatClass {
			get { return ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.CustomFormatClass; }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.BeforeFieldInit"/> bit
		/// </summary>
		public bool IsBeforeFieldInit {
			get { return ((TypeAttributes)attributes & TypeAttributes.BeforeFieldInit) != 0; }
			set { ModifyAttributes(value, TypeAttributes.BeforeFieldInit); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Forwarder"/> bit
		/// </summary>
		public bool IsForwarder {
			get { return ((TypeAttributes)attributes & TypeAttributes.Forwarder) != 0; }
			set { ModifyAttributes(value, TypeAttributes.Forwarder); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get { return ((TypeAttributes)attributes & TypeAttributes.RTSpecialName) != 0; }
			set { ModifyAttributes(value, TypeAttributes.RTSpecialName); }
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.HasSecurity"/> bit
		/// </summary>
		public bool HasSecurity {
			get { return ((TypeAttributes)attributes & TypeAttributes.HasSecurity) != 0; }
			set { ModifyAttributes(value, TypeAttributes.HasSecurity); }
		}

		/// <summary>
		/// <c>true</c> if this is the global (aka. &lt;Module&gt;) type
		/// </summary>
		public bool IsGlobalModuleType {
			get {
				var mod = Module;
				return mod != null && mod.GlobalType == this;
			}
		}

		/// <summary>
		/// Gets a list of all nested types and all their nested types
		/// </summary>
		public IEnumerable<TypeDef> GetTypes() {
			return AllTypesHelper.Types(NestedTypes);
		}

		/// <summary>
		/// Gets an enum's underlying type or <c>null</c> if none. Should only be called
		/// if this is an enum.
		/// </summary>
		public TypeSig GetEnumUnderlyingType() {
			foreach (var field in Fields.GetSafeEnumerable()) {
				if (!field.IsLiteral && !field.IsStatic) {
					var fieldSig = field.FieldSig;
					if (fieldSig != null)
						return fieldSig.Type;
				}
			}
			return null;
		}

		/// <summary>
		/// Resolves a method or a field. <see cref="MemberRef.Class"/> (owner type) is ignored when
		/// resolving the method/field. Private scope methods/fields are not returned.
		/// </summary>
		/// <param name="memberRef">A method/field reference</param>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance or <c>null</c>
		/// if it couldn't be resolved.</returns>
		public IMemberForwarded Resolve(MemberRef memberRef) {
			return Resolve(memberRef, 0);
		}

		/// <summary>
		/// Resolves a method or a field. <see cref="MemberRef.Class"/> (owner type) is ignored when
		/// resolving the method/field.
		/// </summary>
		/// <param name="memberRef">A method/field reference</param>
		/// <param name="options">Method/field signature comparison options</param>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance or <c>null</c>
		/// if it couldn't be resolved.</returns>
		public IMemberForwarded Resolve(MemberRef memberRef, SigComparerOptions options) {
			if (memberRef == null)
				return null;

			var methodSig = memberRef.MethodSig;
			if (methodSig != null)
				return FindMethodCheckBaseType(memberRef.Name, methodSig, options, memberRef.Module);

			var fieldSig = memberRef.FieldSig;
			if (fieldSig != null)
				return FindFieldCheckBaseType(memberRef.Name, fieldSig, options, memberRef.Module);

			return null;
		}

		/// <summary>
		/// Finds a method. Private scope methods are not returned.
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <returns>The first method that matches or <c>null</c> if none found</returns>
		public MethodDef FindMethod(UTF8String name, MethodSig sig) {
			return FindMethod(name, sig, 0, null);
		}

		/// <summary>
		/// Finds a method
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <param name="options">Method signature comparison options</param>
		/// <returns>The first method that matches or <c>null</c> if none found</returns>
		public MethodDef FindMethod(UTF8String name, MethodSig sig, SigComparerOptions options) {
			return FindMethod(name, sig, options, null);
		}

		/// <summary>
		/// Finds a method
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <param name="options">Method signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the method or <c>null</c></param>
		/// <returns>The first method that matches or <c>null</c> if none found</returns>
		public MethodDef FindMethod(UTF8String name, MethodSig sig, SigComparerOptions options, ModuleDef sourceModule) {
			if (UTF8String.IsNull(name) || sig == null)
				return null;
			var comparer = new SigComparer(options, sourceModule);
			bool allowPrivateScope = (options & SigComparerOptions.PrivateScopeMethodIsComparable) != 0;
			foreach (var method in Methods.GetSafeEnumerable()) {
				if (!allowPrivateScope && method.IsPrivateScope)
					continue;
				if (!UTF8String.Equals(method.Name, name))
					continue;
				if (comparer.Equals(method.MethodSig, sig))
					return method;
			}
			return null;
		}

		/// <summary>
		/// Finds a method by name
		/// </summary>
		/// <param name="name">Name of method</param>
		/// <returns>The <see cref="MethodDef"/> or <c>null</c> if not found</returns>
		public MethodDef FindMethod(UTF8String name) {
			foreach (var method in Methods.GetSafeEnumerable()) {
				if (UTF8String.Equals(method.Name, name))
					return method;
			}
			return null;
		}

		/// <summary>
		/// Finds all methods by name
		/// </summary>
		/// <param name="name">Name of method</param>
		/// <returns>All methods with that name</returns>
		public IEnumerable<MethodDef> FindMethods(UTF8String name) {
			foreach (var method in Methods.GetSafeEnumerable()) {
				if (UTF8String.Equals(method.Name, name))
					yield return method;
			}
		}

		/// <summary>
		/// Finds the class constructor (aka type initializer). It's the method named .cctor
		/// </summary>
		/// <returns>The class constructor or <c>null</c> if none found</returns>
		public MethodDef FindStaticConstructor() {
			return Methods.ExecuteLocked<MethodDef, object, MethodDef>(null, (tsList, arg) => FindStaticConstructor_NoMethodsLock());
		}

		MethodDef FindStaticConstructor_NoMethodsLock() {
			foreach (var method in Methods.GetEnumerable_NoLock()) {
				if (method.IsStaticConstructor)
					return method;
			}
			return null;
		}

		/// <summary>
		/// Finds the class constructor (aka type initializer). It's the method named .cctor.
		/// If it doesn't exist, it is created, inserted into <see cref="Methods"/> and returned.
		/// The created .cctor will have just one RET instruction.
		/// </summary>
		/// <returns>The class constructor</returns>
		public MethodDef FindOrCreateStaticConstructor() {
			var cctor = FindStaticConstructor();
			if (cctor != null)
				return cctor;

			var implFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
			var flags = MethodAttributes.Private | MethodAttributes.Static |
						MethodAttributes.HideBySig | MethodAttributes.ReuseSlot |
						MethodAttributes.SpecialName | MethodAttributes.RTSpecialName;
			var module = Module;
			cctor = module.UpdateRowId(new MethodDefUser(MethodDef.StaticConstructorName,
						MethodSig.CreateStatic(module.CorLibTypes.Void), implFlags, flags));
			var body = new CilBody();
			body.InitLocals = true;
			body.MaxStack = 8;
			body.Instructions.Add(OpCodes.Ret.ToInstruction());
			cctor.Body = body;
			return Methods.ExecuteLocked<MethodDef, MethodDef, MethodDef>(cctor, (tsList, cctor2) => {
				var cctor3 = FindStaticConstructor_NoMethodsLock();
				if (cctor3 != null)
					return cctor3;
				tsList.Add_NoLock(cctor2);
				return cctor2;
			});
		}

		/// <summary>
		/// Finds all instance constructors (not class constructors)
		/// </summary>
		/// <returns>All instance constructors</returns>
		public IEnumerable<MethodDef> FindInstanceConstructors() {
			foreach (var method in Methods.GetSafeEnumerable()) {
				if (method.IsInstanceConstructor)
					yield return method;
			}
		}

		/// <summary>
		/// Finds all static and instance constructors
		/// </summary>
		/// <returns>All static and instance constructors</returns>
		public IEnumerable<MethodDef> FindConstructors() {
			foreach (var method in Methods.GetSafeEnumerable()) {
				if (method.IsConstructor)
					yield return method;
			}
		}

		/// <summary>
		/// Finds the default instance constructor (the one with no arguments)
		/// </summary>
		/// <returns>The default instance constructor or <c>null</c> if none</returns>
		public MethodDef FindDefaultConstructor() {
			foreach (var method in Methods.GetSafeEnumerable()) {
				if (!method.IsInstanceConstructor)
					continue;
				var sig = method.MethodSig;
				if (sig != null && sig.Params.Count == 0)
					return method;
			}
			return null;
		}

		/// <summary>
		/// Finds a field. Private scope fields are not returned.
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <returns>The first field that matches or <c>null</c> if none found</returns>
		public FieldDef FindField(UTF8String name, FieldSig sig) {
			return FindField(name, sig, 0, null);
		}

		/// <summary>
		/// Finds a field
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <param name="options">Field signature comparison options</param>
		/// <returns>The first field that matches or <c>null</c> if none found</returns>
		public FieldDef FindField(UTF8String name, FieldSig sig, SigComparerOptions options) {
			return FindField(name, sig, options, null);
		}

		/// <summary>
		/// Finds a field
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <param name="options">Field signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the field or <c>null</c></param>
		/// <returns>The first field that matches or <c>null</c> if none found</returns>
		public FieldDef FindField(UTF8String name, FieldSig sig, SigComparerOptions options, ModuleDef sourceModule) {
			if (UTF8String.IsNull(name) || sig == null)
				return null;
			var comparer = new SigComparer(options, sourceModule);
			bool allowPrivateScope = (options & SigComparerOptions.PrivateScopeFieldIsComparable) != 0;
			foreach (var field in Fields.GetSafeEnumerable()) {
				if (!allowPrivateScope && field.IsPrivateScope)
					continue;
				if (!UTF8String.Equals(field.Name, name))
					continue;
				if (comparer.Equals(field.FieldSig, sig))
					return field;
			}
			return null;
		}

		/// <summary>
		/// Finds a field by name
		/// </summary>
		/// <param name="name">Name of field</param>
		/// <returns>The <see cref="FieldDef"/> or <c>null</c> if not found</returns>
		public FieldDef FindField(UTF8String name) {
			foreach (var field in Fields.GetSafeEnumerable()) {
				if (UTF8String.Equals(field.Name, name))
					return field;
			}
			return null;
		}

		/// <summary>
		/// Finds all fields by name
		/// </summary>
		/// <param name="name">Name of field</param>
		/// <returns>All fields with that name</returns>
		public IEnumerable<FieldDef> FindFields(UTF8String name) {
			foreach (var field in Fields.GetSafeEnumerable()) {
				if (UTF8String.Equals(field.Name, name))
					yield return field;
			}
		}

		/// <summary>
		/// Finds an event
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <param name="type">Type of event</param>
		/// <returns>A <see cref="EventDef"/> or <c>null</c> if not found</returns>
		public EventDef FindEvent(UTF8String name, IType type) {
			return FindEvent(name, type, 0, null);
		}

		/// <summary>
		/// Finds an event
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <param name="type">Type of event</param>
		/// <param name="options">Event type comparison options</param>
		/// <returns>A <see cref="EventDef"/> or <c>null</c> if not found</returns>
		public EventDef FindEvent(UTF8String name, IType type, SigComparerOptions options) {
			return FindEvent(name, type, options, null);
		}

		/// <summary>
		/// Finds an event
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <param name="type">Type of event</param>
		/// <param name="options">Event type comparison options</param>
		/// <param name="sourceModule">The module that needs to find the event or <c>null</c></param>
		/// <returns>A <see cref="EventDef"/> or <c>null</c> if not found</returns>
		public EventDef FindEvent(UTF8String name, IType type, SigComparerOptions options, ModuleDef sourceModule) {
			if (UTF8String.IsNull(name) || type == null)
				return null;
			var comparer = new SigComparer(options, sourceModule);
			foreach (var @event in Events.GetSafeEnumerable()) {
				if (!UTF8String.Equals(@event.Name, name))
					continue;
				if (comparer.Equals(@event.EventType, type))
					return @event;
			}
			return null;
		}

		/// <summary>
		/// Finds an event by name
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <returns>The <see cref="EventDef"/> or <c>null</c> if not found</returns>
		public EventDef FindEvent(UTF8String name) {
			foreach (var @event in Events.GetSafeEnumerable()) {
				if (UTF8String.Equals(@event.Name, name))
					return @event;
			}
			return null;
		}

		/// <summary>
		/// Finds all events by name
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <returns>All events with that name</returns>
		public IEnumerable<EventDef> FindEvents(UTF8String name) {
			foreach (var @event in Events.GetSafeEnumerable()) {
				if (UTF8String.Equals(@event.Name, name))
					yield return @event;
			}
		}

		/// <summary>
		/// Finds a property
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <param name="propSig">Property signature</param>
		/// <returns>A <see cref="PropertyDef"/> or <c>null</c> if not found</returns>
		public PropertyDef FindProperty(UTF8String name, CallingConventionSig propSig) {
			return FindProperty(name, propSig, 0, null);
		}

		/// <summary>
		/// Finds a property
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <param name="propSig">Property signature</param>
		/// <param name="options">Property signature comparison options</param>
		/// <returns>A <see cref="PropertyDef"/> or <c>null</c> if not found</returns>
		public PropertyDef FindProperty(UTF8String name, CallingConventionSig propSig, SigComparerOptions options) {
			return FindProperty(name, propSig, options, null);
		}

		/// <summary>
		/// Finds a property
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <param name="propSig">Property signature</param>
		/// <param name="options">Property signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the property or <c>null</c></param>
		/// <returns>A <see cref="PropertyDef"/> or <c>null</c> if not found</returns>
		public PropertyDef FindProperty(UTF8String name, CallingConventionSig propSig, SigComparerOptions options, ModuleDef sourceModule) {
			if (UTF8String.IsNull(name) || propSig == null)
				return null;
			var comparer = new SigComparer(options, sourceModule);
			foreach (var prop in Properties.GetSafeEnumerable()) {
				if (!UTF8String.Equals(prop.Name, name))
					continue;
				if (comparer.Equals(prop.Type, propSig))
					return prop;
			}
			return null;
		}

		/// <summary>
		/// Finds a prop by name
		/// </summary>
		/// <param name="name">Name of prop</param>
		/// <returns>The <see cref="PropertyDef"/> or <c>null</c> if not found</returns>
		public PropertyDef FindProperty(UTF8String name) {
			foreach (var prop in Properties.GetSafeEnumerable()) {
				if (UTF8String.Equals(prop.Name, name))
					return prop;
			}
			return null;
		}

		/// <summary>
		/// Finds all props by name
		/// </summary>
		/// <param name="name">Name of prop</param>
		/// <returns>All props with that name</returns>
		public IEnumerable<PropertyDef> FindProperties(UTF8String name) {
			foreach (var prop in Properties.GetSafeEnumerable()) {
				if (UTF8String.Equals(prop.Name, name))
					yield return prop;
			}
		}

		/// <summary>
		/// Finds a method by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <returns>The method or <c>null</c> if it wasn't found</returns>
		public MethodDef FindMethodCheckBaseType(UTF8String name, MethodSig sig) {
			return FindMethodCheckBaseType(name, sig, 0, null);
		}

		/// <summary>
		/// Finds a method by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <param name="options">Method signature comparison options</param>
		/// <returns>The method or <c>null</c> if it wasn't found</returns>
		public MethodDef FindMethodCheckBaseType(UTF8String name, MethodSig sig, SigComparerOptions options) {
			return FindMethodCheckBaseType(name, sig, options, null);
		}

		/// <summary>
		/// Finds a method by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <param name="options">Method signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the method or <c>null</c></param>
		/// <returns>The method or <c>null</c> if it wasn't found</returns>
		public MethodDef FindMethodCheckBaseType(UTF8String name, MethodSig sig, SigComparerOptions options, ModuleDef sourceModule) {
			var td = this;
			while (td != null) {
				var md = td.FindMethod(name, sig, options, sourceModule);
				if (md != null)
					return md;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a method by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Method name</param>
		/// <returns>The method or <c>null</c> if it wasn't found</returns>
		public MethodDef FindMethodCheckBaseType(UTF8String name) {
			var td = this;
			while (td != null) {
				var md = td.FindMethod(name);
				if (md != null)
					return md;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a field by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <returns>The field or <c>null</c> if it wasn't found</returns>
		public FieldDef FindFieldCheckBaseType(UTF8String name, FieldSig sig) {
			return FindFieldCheckBaseType(name, sig, 0, null);
		}

		/// <summary>
		/// Finds a field by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <param name="options">Field signature comparison options</param>
		/// <returns>The field or <c>null</c> if it wasn't found</returns>
		public FieldDef FindFieldCheckBaseType(UTF8String name, FieldSig sig, SigComparerOptions options) {
			return FindFieldCheckBaseType(name, sig, options, null);
		}

		/// <summary>
		/// Finds a field by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <param name="options">Field signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the field or <c>null</c></param>
		/// <returns>The field or <c>null</c> if it wasn't found</returns>
		public FieldDef FindFieldCheckBaseType(UTF8String name, FieldSig sig, SigComparerOptions options, ModuleDef sourceModule) {
			var td = this;
			while (td != null) {
				var fd = td.FindField(name, sig, options, sourceModule);
				if (fd != null)
					return fd;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a field by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Field name</param>
		/// <returns>The field or <c>null</c> if it wasn't found</returns>
		public FieldDef FindFieldCheckBaseType(UTF8String name) {
			var td = this;
			while (td != null) {
				var fd = td.FindField(name);
				if (fd != null)
					return fd;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds an event by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Event name</param>
		/// <param name="eventType">Event type</param>
		/// <returns>The event or <c>null</c> if it wasn't found</returns>
		public EventDef FindEventCheckBaseType(UTF8String name, ITypeDefOrRef eventType) {
			var td = this;
			while (td != null) {
				var ed = td.FindEvent(name, eventType);
				if (ed != null)
					return ed;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds an event by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Event name</param>
		/// <returns>The event or <c>null</c> if it wasn't found</returns>
		public EventDef FindEventCheckBaseType(UTF8String name) {
			var td = this;
			while (td != null) {
				var ed = td.FindEvent(name);
				if (ed != null)
					return ed;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a property by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Property name</param>
		/// <param name="sig">Property signature</param>
		/// <returns>The property or <c>null</c> if it wasn't found</returns>
		public PropertyDef FindPropertyCheckBaseType(UTF8String name, PropertySig sig) {
			return FindPropertyCheckBaseType(name, sig, 0, null);
		}

		/// <summary>
		/// Finds a property by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Property name</param>
		/// <param name="sig">Property signature</param>
		/// <param name="options">Property signature comparison options</param>
		/// <returns>The property or <c>null</c> if it wasn't found</returns>
		public PropertyDef FindPropertyCheckBaseType(UTF8String name, PropertySig sig, SigComparerOptions options) {
			return FindPropertyCheckBaseType(name, sig, options, null);
		}

		/// <summary>
		/// Finds a property by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Property name</param>
		/// <param name="sig">Property signature</param>
		/// <param name="options">Property signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the property or <c>null</c></param>
		/// <returns>The property or <c>null</c> if it wasn't found</returns>
		public PropertyDef FindPropertyCheckBaseType(UTF8String name, PropertySig sig, SigComparerOptions options, ModuleDef sourceModule) {
			var td = this;
			while (td != null) {
				var pd = td.FindProperty(name, sig, options, sourceModule);
				if (pd != null)
					return pd;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a property by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Property name</param>
		/// <returns>The property or <c>null</c> if it wasn't found</returns>
		public PropertyDef FindPropertyCheckBaseType(UTF8String name) {
			var td = this;
			while (td != null) {
				var pd = td.FindProperty(name);
				if (pd != null)
					return pd;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Removes a method from this type. It also removes it from any properties and events.
		/// </summary>
		/// <param name="method">The method to remove</param>
		public void Remove(MethodDef method) {
			Remove(method, false);
		}

		/// <summary>
		/// Removes a method from this type. It also removes it from any properties and events.
		/// </summary>
		/// <param name="method">The method to remove</param>
		/// <param name="removeEmptyPropertiesEvents"><c>true</c> if we should remove all
		/// empty properties and events.</param>
		public void Remove(MethodDef method, bool removeEmptyPropertiesEvents) {
			if (method == null)
				return;

			foreach (var prop in Properties.GetSafeEnumerable()) {
				prop.GetMethods.Remove(method);
				prop.SetMethods.Remove(method);
				prop.OtherMethods.Remove(method);
			}

			foreach (var evt in Events.GetSafeEnumerable()) {
				if (evt.AddMethod == method)
					evt.AddMethod = null;
				if (evt.RemoveMethod == method)
					evt.RemoveMethod = null;
				if (evt.InvokeMethod == method)
					evt.InvokeMethod = null;
				evt.OtherMethods.Remove(method);
			}

			if (removeEmptyPropertiesEvents) {
				RemoveEmptyProperties();
				RemoveEmptyEvents();
			}

			Methods.Remove(method);
		}

		void RemoveEmptyProperties() {
			Properties.IterateAllReverse((tsList, index, value) => {
				if (value.IsEmpty)
					tsList.RemoveAt_NoLock(index);
			});
		}

		void RemoveEmptyEvents() {
			Events.IterateAllReverse((tsList, index, value) => {
				if (value.IsEmpty)
					tsList.RemoveAt_NoLock(index);
			});
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnLazyAdd(int index, ref FieldDef value) {
			OnLazyAdd2(index, ref value);
		}

		internal virtual void OnLazyAdd2(int index, ref FieldDef value) {
#if DEBUG
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added field's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnAdd(int index, FieldDef value) {
			if (value.DeclaringType != null)
				throw new InvalidOperationException("Field is already owned by another type. Set DeclaringType to null first.");
			value.DeclaringType2 = this;
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnRemove(int index, FieldDef value) {
			value.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnClear() {
			foreach (var field in Fields.GetEnumerable_NoLock())
				field.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnLazyAdd(int index, ref MethodDef value) {
			OnLazyAdd2(index, ref value);
		}

		internal virtual void OnLazyAdd2(int index, ref MethodDef value) {
#if DEBUG
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added method's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnAdd(int index, MethodDef value) {
			if (value.DeclaringType != null)
				throw new InvalidOperationException("Method is already owned by another type. Set DeclaringType to null first.");
			value.DeclaringType2 = this;
			value.Parameters.UpdateThisParameterType(this);
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnRemove(int index, MethodDef value) {
			value.DeclaringType2 = null;
			value.Parameters.UpdateThisParameterType(null);
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnClear() {
			foreach (var method in Methods.GetEnumerable_NoLock()) {
				method.DeclaringType2 = null;
				method.Parameters.UpdateThisParameterType(null);
			}
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnLazyAdd(int index, ref TypeDef value) {
#if DEBUG
			if (value.Module2 != null)
				throw new InvalidOperationException("Added nested type's Module != null");
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added nested type's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnAdd(int index, TypeDef value) {
			if (value.DeclaringType != null)
				throw new InvalidOperationException("Nested type is already owned by another type. Set DeclaringType to null first.");
			if (value.Module != null)
				throw new InvalidOperationException("Type is already owned by another module. Remove it from that module's type list.");
			value.DeclaringType2 = this;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnRemove(int index, TypeDef value) {
			value.DeclaringType2 = null;
			value.Module2 = null;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnClear() {
			foreach (var type in NestedTypes.GetEnumerable_NoLock())
				type.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnLazyAdd(int index, ref EventDef value) {
			OnLazyAdd2(index, ref value);
		}

		internal virtual void OnLazyAdd2(int index, ref EventDef value) {
#if DEBUG
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added event's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnAdd(int index, EventDef value) {
			if (value.DeclaringType != null)
				throw new InvalidOperationException("Event is already owned by another type. Set DeclaringType to null first.");
			value.DeclaringType2 = this;
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnRemove(int index, EventDef value) {
			value.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnClear() {
			foreach (var @event in Events.GetEnumerable_NoLock())
				@event.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnLazyAdd(int index, ref PropertyDef value) {
			OnLazyAdd2(index, ref value);
		}

		internal virtual void OnLazyAdd2(int index, ref PropertyDef value) {
#if DEBUG
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added property's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnAdd(int index, PropertyDef value) {
			if (value.DeclaringType != null)
				throw new InvalidOperationException("Property is already owned by another type. Set DeclaringType to null first.");
			value.DeclaringType2 = this;
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnRemove(int index, PropertyDef value) {
			value.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnClear() {
			foreach (var prop in Properties.GetEnumerable_NoLock())
				prop.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnLazyAdd(int index, ref GenericParam value) {
			OnLazyAdd2(index, ref value);
		}

		internal virtual void OnLazyAdd2(int index, ref GenericParam value) {
#if DEBUG
			if (value.Owner != this)
				throw new InvalidOperationException("Added generic param's Owner != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnAdd(int index, GenericParam value) {
			if (value.Owner != null)
				throw new InvalidOperationException("Generic param is already owned by another type/method. Set Owner to null first.");
			value.Owner = this;
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnRemove(int index, GenericParam value) {
			value.Owner = null;
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnClear() {
			foreach (var gp in GenericParameters.GetEnumerable_NoLock())
				gp.Owner = null;
		}

		/// <summary>
		/// Gets all fields named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Field name</param>
		/// <returns>A list of 0 or more fields with name <paramref name="name"/></returns>
		public IList<FieldDef> GetFields(UTF8String name) {
			var fields = new List<FieldDef>();
			foreach (var field in Fields.GetSafeEnumerable()) {
				if (field.Name == name)
					fields.Add(field);
			}
			return fields;
		}

		/// <summary>
		/// Gets the first field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Field name</param>
		/// <returns>The field or <c>null</c> if none found</returns>
		public FieldDef GetField(UTF8String name) {
			foreach (var field in Fields.GetSafeEnumerable()) {
				if (field.Name == name)
					return field;
			}
			return null;
		}

		internal static bool GetClassSize(TypeDef td, out uint size) {
			size = 0;
			if (td == null)
				return false;
			if (!td.IsValueType)
				return false;	// Not supported by us
			if (!td.IsSequentialLayout && !td.IsExplicitLayout) {
				if (td.Fields.Count != 1)
					return false;
				var fd = td.Fields.Get(0, null);
				if (fd == null)
					return false;
				return fd.GetFieldSize(out size);
			}

			var classLayout = td.ClassLayout;
			if (classLayout == null)
				return false;
			uint classSize = classLayout.ClassSize;
			if (classSize != 0) {
				size = classSize;
				return true;
			}

			// Not supported by us
			return false;
		}

		/// <summary>
		/// FInd a method implementation method
		/// </summary>
		/// <param name="mdr">Method</param>
		/// <returns></returns>
		protected MethodDef FindMethodImplMethod(IMethodDefOrRef mdr) {
			// Check common case first
			var md = mdr as MethodDef;
			if (md != null)
				return md;

			// Must be a member ref
			var mr = mdr as MemberRef;
			if (mr == null)
				return null;

			// If Class is MethodDef, then it should be a vararg method
			var parent = mr.Class;
			md = parent as MethodDef;
			if (md != null)
				return md;

			// If it's a TypeSpec, it must be a generic instance type
			for (int i = 0; i < 10; i++) {
				var ts = parent as TypeSpec;
				if (ts == null)
					break;

				var gis = ts.TypeSig as GenericInstSig;
				if (gis == null || gis.GenericType == null)
					return null;
				parent = gis.GenericType.TypeDefOrRef;
			}

			var td = parent as TypeDef;
			if (td == null) {
				// If it's a TypeRef, resolve it as if it is a reference to a type in the
				// current module, even if its ResolutionScope happens to be some other
				// assembly/module (that's what the CLR does)
				var tr = parent as TypeRef;
				if (tr != null && Module != null)
					td = Module.Find(tr);
			}
			if (td == null)
				return null;
			return td.FindMethod(mr.Name, mr.MethodSig);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A TypeDef row created by the user and not present in the original .NET file
	/// </summary>
	public class TypeDefUser : TypeDef {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public TypeDefUser(UTF8String name)
			: this(null, name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="namespace">Namespace</param>
		/// <param name="name">Name</param>
		public TypeDefUser(UTF8String @namespace, UTF8String name)
			: this(@namespace, name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="baseType">Base class or <c>null</c> if it's an interface</param>
		public TypeDefUser(UTF8String name, ITypeDefOrRef baseType)
			: this(null, name, baseType) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="namespace">Namespace</param>
		/// <param name="name">Name</param>
		/// <param name="baseType">Base class or <c>null</c> if it's an interface</param>
		public TypeDefUser(UTF8String @namespace, UTF8String name, ITypeDefOrRef baseType) {
			this.fields = new LazyList<FieldDef>(this);
			this.methods = new LazyList<MethodDef>(this);
			this.genericParameters = new LazyList<GenericParam>(this);
			this.nestedTypes = new LazyList<TypeDef>(this);
			this.events = new LazyList<EventDef>(this);
			this.properties = new LazyList<PropertyDef>(this);
			this.@namespace = @namespace;
			this.name = name;
			this.baseType = baseType;
			this.baseType_isInitialized = true;
		}
	}

	/// <summary>
	/// Created from a row in the TypeDef table
	/// </summary>
	sealed class TypeDefMD : TypeDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly uint extendsCodedToken;
		Dictionary<uint, ThreadSafe.IList<MethodOverrideTokens>> methodRidToOverrides;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override ITypeDefOrRef GetBaseType_NoLock() {
			return readerModule.ResolveTypeDefOrRef(extendsCodedToken, new GenericParamContext(this));
		}

		/// <inheritdoc/>
		protected override void InitializeFields() {
			var list = readerModule.MetaData.GetFieldRidList(origRid);
			var tmp = new LazyList<FieldDef>((int)list.Length, this, list, (list2, index) => readerModule.ResolveField(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref fields, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeMethods() {
			var list = readerModule.MetaData.GetMethodRidList(origRid);
			var tmp = new LazyList<MethodDef>((int)list.Length, this, list, (list2, index) => readerModule.ResolveMethod(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref methods, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeGenericParameters() {
			var list = readerModule.MetaData.GetGenericParamRidList(Table.TypeDef, origRid);
			var tmp = new LazyList<GenericParam>((int)list.Length, this, list, (list2, index) => readerModule.ResolveGenericParam(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref genericParameters, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeInterfaces() {
			var list = readerModule.MetaData.GetInterfaceImplRidList(origRid);
			var tmp = new LazyList<InterfaceImpl>((int)list.Length, list, (list2, index) => readerModule.ResolveInterfaceImpl(((RidList)list2)[index], new GenericParamContext(this)));
			Interlocked.CompareExchange(ref interfaces, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeDeclSecurities() {
			var list = readerModule.MetaData.GetDeclSecurityRidList(Table.TypeDef, origRid);
			var tmp = new LazyList<DeclSecurity>((int)list.Length, list, (list2, index) => readerModule.ResolveDeclSecurity(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref declSecurities, tmp, null);
		}

		/// <inheritdoc/>
		protected override ClassLayout GetClassLayout_NoLock() {
			return readerModule.ResolveClassLayout(readerModule.MetaData.GetClassLayoutRid(origRid));
		}

		/// <inheritdoc/>
		protected override TypeDef GetDeclaringType2_NoLock() {
			uint enclosingClass = readerModule.TablesStream.ReadNestedClassRow2(readerModule.MetaData.GetNestedClassRid(origRid));
			return enclosingClass == 0 ? null : readerModule.ResolveTypeDef(enclosingClass);
		}

		TypeDef DeclaringType2_NoLock {
			get {
				if (!declaringType2_isInitialized) {
					declaringType2 = GetDeclaringType2_NoLock();
					declaringType2_isInitialized = true;
				}
				return declaringType2;
			}
		}

		/// <inheritdoc/>
		protected override void InitializeEvents() {
			var mapRid = readerModule.MetaData.GetEventMapRid(origRid);
			var list = readerModule.MetaData.GetEventRidList(mapRid);
			var tmp = new LazyList<EventDef>((int)list.Length, this, list, (list2, index) => readerModule.ResolveEvent(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref events, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeProperties() {
			var mapRid = readerModule.MetaData.GetPropertyMapRid(origRid);
			var list = readerModule.MetaData.GetPropertyRidList(mapRid);
			var tmp = new LazyList<PropertyDef>((int)list.Length, this, list, (list2, index) => readerModule.ResolveProperty(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref properties, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeNestedTypes() {
			var list = readerModule.MetaData.GetNestedClassRidList(origRid);
			var tmp = new LazyList<TypeDef>((int)list.Length, this, list, (list2, index) => readerModule.ResolveTypeDef(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref nestedTypes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.TypeDef, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(this), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override ModuleDef GetModule2_NoLock() {
			return DeclaringType2_NoLock != null ? null : readerModule;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>TypeDef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public TypeDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.TypeDefTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("TypeDef rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			uint name, @namespace;
			extendsCodedToken = readerModule.TablesStream.ReadTypeDefRow(origRid, out this.attributes, out name, out @namespace);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.@namespace = readerModule.StringsStream.ReadNoNull(@namespace);
		}

		/// <summary>
		/// Gets all methods <paramref name="method"/> overrides
		/// </summary>
		/// <param name="method">The method</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A list (possibly empty) of all methods <paramref name="method"/> overrides</returns>
		internal ThreadSafe.IList<MethodOverride> GetMethodOverrides(MethodDefMD method, GenericParamContext gpContext) {
			if (method == null)
				return ThreadSafeListCreator.Create<MethodOverride>();

			if (methodRidToOverrides == null)
				InitializeMethodOverrides();

			ThreadSafe.IList<MethodOverrideTokens> overrides;
			if (methodRidToOverrides.TryGetValue(method.OrigRid, out overrides)) {
				var newList = ThreadSafeListCreator.Create<MethodOverride>(overrides.Count);

				for (int i = 0; i < overrides.Count; i++) {
					var ovr = overrides[i];
					var newMethodBody = (IMethodDefOrRef)readerModule.ResolveToken(ovr.MethodBodyToken, gpContext);
					var newMethodDeclaration = (IMethodDefOrRef)readerModule.ResolveToken(ovr.MethodDeclarationToken, gpContext);
					newList.Add(new MethodOverride(newMethodBody, newMethodDeclaration));
				}
				return newList;
			}
			return ThreadSafeListCreator.Create<MethodOverride>();
		}

		struct MethodOverrideTokens {
			public readonly uint MethodBodyToken;
			public readonly uint MethodDeclarationToken;

			public MethodOverrideTokens(uint methodBodyToken, uint methodDeclarationToken) {
				this.MethodBodyToken = methodBodyToken;
				this.MethodDeclarationToken = methodDeclarationToken;
			}
		}

		void InitializeMethodOverrides() {
			var newMethodRidToOverrides = new Dictionary<uint, ThreadSafe.IList<MethodOverrideTokens>>();

			var ridList = readerModule.MetaData.GetMethodImplRidList(origRid);
			for (uint i = 0; i < ridList.Length; i++) {
				uint methodBodyToken;
				uint methodDeclToken = readerModule.TablesStream.ReadMethodImplRow(ridList[i], out methodBodyToken);

				var methodBody = readerModule.ResolveMethodDefOrRef(methodBodyToken);
				var methodDecl = readerModule.ResolveMethodDefOrRef(methodDeclToken);
				if (methodBody == null || methodDecl == null)
					continue;	// Should only happen if some obfuscator added invalid metadata

				// Find the real method. This is usually methodBody since it's usually a
				// MethodDef. The CLR only allows method bodies in the current type, and
				// so shall we.
				var method = FindMethodImplMethod(methodBody);
				if (method == null || method.DeclaringType != this)
					continue;

				ThreadSafe.IList<MethodOverrideTokens> overrides;
				uint rid = method.Rid;
				if (!newMethodRidToOverrides.TryGetValue(rid, out overrides))
					newMethodRidToOverrides[rid] = overrides = ThreadSafeListCreator.Create<MethodOverrideTokens>();
				overrides.Add(new MethodOverrideTokens(methodBody.MDToken.Raw, methodDecl.MDToken.Raw));
			}
			Interlocked.CompareExchange(ref methodRidToOverrides, newMethodRidToOverrides, null);
		}

		/// <summary>
		/// Initializes all <see cref="MethodDef.semAttrs"/>. Only those <see cref="MethodDef"/>s
		/// that are property or event handlers get updated.
		/// </summary>
		internal void InitializeMethodSemanticsAttributes() {
			var mapRid = readerModule.MetaData.GetPropertyMapRid(origRid);
			var list = readerModule.MetaData.GetPropertyRidList(mapRid);
			for (uint i = 0; i < list.Length; i++) {
				var ridList = readerModule.MetaData.GetMethodSemanticsRidList(Table.Property, list[i]);
				for (uint j = 0; j < ridList.Length; j++) {
					MethodSemanticsAttributes semantics;
					uint methodToken = readerModule.TablesStream.ReadMethodSemanticsRow(ridList[j], out semantics);
					var method = readerModule.ResolveMethod(methodToken);
					if (method == null)
						continue;

					Interlocked.CompareExchange(ref method.semAttrs, (int)semantics | MethodDef.SEMATTRS_INITD, 0);
				}
			}

			mapRid = readerModule.MetaData.GetEventMapRid(origRid);
			list = readerModule.MetaData.GetEventRidList(mapRid);
			for (uint i = 0; i < list.Length; i++) {
				var ridList = readerModule.MetaData.GetMethodSemanticsRidList(Table.Event, list[i]);
				for (uint j = 0; j < ridList.Length; j++) {
					MethodSemanticsAttributes semantics;
					uint methodToken = readerModule.TablesStream.ReadMethodSemanticsRow(ridList[j], out semantics);
					var method = readerModule.ResolveMethod(methodToken);
					if (method == null)
						continue;

					Interlocked.CompareExchange(ref method.semAttrs, (int)semantics | MethodDef.SEMATTRS_INITD, 0);
				}
			}
		}

		/// <summary>
		/// Initializes a property's special methods
		/// </summary>
		/// <param name="prop">The property</param>
		/// <param name="getMethods">Updated with a list of all get methods</param>
		/// <param name="setMethods">Updated with a list of all set methods</param>
		/// <param name="otherMethods">Updated with a list of all other methods</param>
		internal void InitializeProperty(PropertyDefMD prop, out ThreadSafe.IList<MethodDef> getMethods, out ThreadSafe.IList<MethodDef> setMethods, out ThreadSafe.IList<MethodDef> otherMethods) {
			getMethods = ThreadSafeListCreator.Create<MethodDef>();
			setMethods = ThreadSafeListCreator.Create<MethodDef>();
			otherMethods = ThreadSafeListCreator.Create<MethodDef>();
			if (prop == null)
				return;

			var ridList = readerModule.MetaData.GetMethodSemanticsRidList(Table.Property, prop.OrigRid);
			for (uint i = 0; i < ridList.Length; i++) {
				MethodSemanticsAttributes semantics;
				uint methodToken = readerModule.TablesStream.ReadMethodSemanticsRow(ridList[i], out semantics);
				var method = readerModule.ResolveMethod(methodToken);
				if (method == null || method.DeclaringType != prop.DeclaringType)
					continue;

				// It's documented to be flags, but ignore those with more than one bit set
				switch (semantics) {
				case MethodSemanticsAttributes.Setter:
					if (!setMethods.Contains(method))
						setMethods.Add(method);
					break;

				case MethodSemanticsAttributes.Getter:
					if (!getMethods.Contains(method))
						getMethods.Add(method);
					break;

				case MethodSemanticsAttributes.Other:
					if (!otherMethods.Contains(method))
						otherMethods.Add(method);
					break;

				default:
					// Ignore anything else
					break;
				}
			}
		}

		/// <summary>
		/// Initializes an event's special methods
		/// </summary>
		/// <param name="evt">The event</param>
		/// <param name="addMethod">Updated with the addOn method or <c>null</c> if none</param>
		/// <param name="invokeMethod">Updated with the fire method or <c>null</c> if none</param>
		/// <param name="removeMethod">Updated with the removeOn method or <c>null</c> if none</param>
		/// <param name="otherMethods">Updated with a list of all other methods</param>
		internal void InitializeEvent(EventDefMD evt, out MethodDef addMethod, out MethodDef invokeMethod, out MethodDef removeMethod, out ThreadSafe.IList<MethodDef> otherMethods) {
			addMethod = null;
			invokeMethod = null;
			removeMethod = null;
			otherMethods = ThreadSafeListCreator.Create<MethodDef>();
			if (evt == null)
				return;

			var ridList = readerModule.MetaData.GetMethodSemanticsRidList(Table.Event, evt.OrigRid);
			for (uint i = 0; i < ridList.Length; i++) {
				MethodSemanticsAttributes semantics;
				uint methodToken = readerModule.TablesStream.ReadMethodSemanticsRow(ridList[i], out semantics);
				var method = readerModule.ResolveMethod(methodToken);
				if (method == null || method.DeclaringType != evt.DeclaringType)
					continue;

				// It's documented to be flags, but ignore those with more than one bit set
				switch (semantics) {
				case MethodSemanticsAttributes.AddOn:
					if (addMethod == null)
						addMethod = method;
					break;

				case MethodSemanticsAttributes.RemoveOn:
					if (removeMethod == null)
						removeMethod = method;
					break;

				case MethodSemanticsAttributes.Fire:
					if (invokeMethod == null)
						invokeMethod = method;
					break;

				case MethodSemanticsAttributes.Other:
					if (!otherMethods.Contains(method))
						otherMethods.Add(method);
					break;

				default:
					// Ignore anything else
					break;
				}
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref FieldDef value) {
			if (value.DeclaringType != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadField(value.Rid).InitializeAll());
				value.DeclaringType2 = this;
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref MethodDef value) {
			if (value.DeclaringType != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadMethod(value.Rid).InitializeAll());
				value.DeclaringType2 = this;
				value.Parameters.UpdateThisParameterType(this);
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref EventDef value) {
			if (value.DeclaringType != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadEvent(value.Rid).InitializeAll());
				value.DeclaringType2 = this;
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref PropertyDef value) {
			if (value.DeclaringType != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadProperty(value.Rid).InitializeAll());
				value.DeclaringType2 = this;
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref GenericParam value) {
			if (value.Owner != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadGenericParam(value.Rid).InitializeAll());
				value.Owner = this;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TypeDefFinder.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.Threading;

namespace dnlib.DotNet {
	/// <summary>
	/// Finds <see cref="TypeDef"/>s
	/// </summary>
	sealed class TypeDefFinder : ITypeDefFinder, IDisposable {
		const SigComparerOptions TypeComparerOptions = SigComparerOptions.DontCompareTypeScope | SigComparerOptions.TypeRefCanReferenceGlobalType;
		bool isCacheEnabled;
		readonly bool includeNestedTypes;
		Dictionary<ITypeDefOrRef, TypeDef> typeRefCache = new Dictionary<ITypeDefOrRef, TypeDef>(new TypeEqualityComparer(TypeComparerOptions));
		Dictionary<string, TypeDef> normalNameCache = new Dictionary<string, TypeDef>(StringComparer.Ordinal);
		Dictionary<string, TypeDef> reflectionNameCache = new Dictionary<string, TypeDef>(StringComparer.Ordinal);
		readonly StringBuilder sb = new StringBuilder();
		IEnumerator<TypeDef> typeEnumerator;
		readonly IEnumerable<TypeDef> rootTypes;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// <c>true</c> if the <see cref="TypeDef"/> cache is enabled. <c>false</c> if the cache
		/// is disabled and a slower <c>O(n)</c> lookup is performed.
		/// </summary>
		public bool IsCacheEnabled {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return IsCacheEnabled_NoLock;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				IsCacheEnabled_NoLock = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		bool IsCacheEnabled_NoLock {
			get { return isCacheEnabled; }
			set {
				if (isCacheEnabled == value)
					return;

				if (typeEnumerator != null) {
					typeEnumerator.Dispose();
					typeEnumerator = null;
				}

				typeRefCache.Clear();
				normalNameCache.Clear();
				reflectionNameCache.Clear();

				if (value)
					InitializeTypeEnumerator();

				isCacheEnabled = value;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rootTypes">All root types. All their nested types are also included.</param>
		/// <exception cref="ArgumentNullException">If <paramref name="rootTypes"/> is <c>null</c></exception>
		public TypeDefFinder(IEnumerable<TypeDef> rootTypes)
			: this(rootTypes, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rootTypes">All root types</param>
		/// <param name="includeNestedTypes"><c>true</c> if all nested types that are reachable
		/// from <paramref name="rootTypes"/> should also be included.</param>
		/// <exception cref="ArgumentNullException">If <paramref name="rootTypes"/> is <c>null</c></exception>
		public TypeDefFinder(IEnumerable<TypeDef> rootTypes, bool includeNestedTypes) {
			if (rootTypes == null)
				throw new ArgumentNullException("rootTypes");
			this.rootTypes = rootTypes;
			this.includeNestedTypes = includeNestedTypes;
		}

		void InitializeTypeEnumerator() {
			if (typeEnumerator != null) {
				typeEnumerator.Dispose();
				typeEnumerator = null;
			}
			typeEnumerator = (includeNestedTypes ? AllTypesHelper.Types(rootTypes) : rootTypes).GetEnumerator();
		}

		/// <summary>
		/// Resets the cache (clears all cached elements). Use this method if the cache is
		/// enabled but some of the types have been modified (eg. removed, added, renamed).
		/// </summary>
		public void ResetCache() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			bool old = IsCacheEnabled_NoLock;
			IsCacheEnabled_NoLock = false;
			IsCacheEnabled_NoLock = old;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public TypeDef Find(string fullName, bool isReflectionName) {
			if (fullName == null)
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (isCacheEnabled)
				return isReflectionName ? FindCacheReflection(fullName) : FindCacheNormal(fullName);
			return isReflectionName ? FindSlowReflection(fullName) : FindSlowNormal(fullName);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public TypeDef Find(TypeRef typeRef) {
			if (typeRef == null)
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return isCacheEnabled ? FindCache(typeRef) : FindSlow(typeRef);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		TypeDef FindCache(TypeRef typeRef) {
			TypeDef cachedType;
			if (typeRefCache.TryGetValue(typeRef, out cachedType))
				return cachedType;

			// Build the cache lazily
			var comparer = new SigComparer(TypeComparerOptions);
			while (true) {
				cachedType = GetNextTypeDefCache();
				if (cachedType == null || comparer.Equals(cachedType, typeRef))
					return cachedType;
			}
		}

		TypeDef FindCacheReflection(string fullName) {
			TypeDef cachedType;
			if (reflectionNameCache.TryGetValue(fullName, out cachedType))
				return cachedType;

			// Build the cache lazily
			while (true) {
				cachedType = GetNextTypeDefCache();
				if (cachedType == null)
					return cachedType;
				sb.Length = 0;
				if (FullNameCreator.FullName(cachedType, true, null, sb) == fullName)
					return cachedType;
			}
		}

		TypeDef FindCacheNormal(string fullName) {
			TypeDef cachedType;
			if (normalNameCache.TryGetValue(fullName, out cachedType))
				return cachedType;

			// Build the cache lazily
			while (true) {
				cachedType = GetNextTypeDefCache();
				if (cachedType == null)
					return cachedType;
				sb.Length = 0;
				if (FullNameCreator.FullName(cachedType, false, null, sb) == fullName)
					return cachedType;
			}
		}

		TypeDef FindSlow(TypeRef typeRef) {
			InitializeTypeEnumerator();
			var comparer = new SigComparer(TypeComparerOptions);
			while (true) {
				var type = GetNextTypeDef();
				if (type == null || comparer.Equals(type, typeRef))
					return type;
			}
		}

		TypeDef FindSlowReflection(string fullName) {
			InitializeTypeEnumerator();
			while (true) {
				var type = GetNextTypeDef();
				if (type == null)
					return type;
				sb.Length = 0;
				if (FullNameCreator.FullName(type, true, null, sb) == fullName)
					return type;
			}
		}

		TypeDef FindSlowNormal(string fullName) {
			InitializeTypeEnumerator();
			while (true) {
				var type = GetNextTypeDef();
				if (type == null)
					return type;
				sb.Length = 0;
				if (FullNameCreator.FullName(type, false, null, sb) == fullName)
					return type;
			}
		}

		/// <summary>
		/// Gets the next <see cref="TypeDef"/> or <c>null</c> if there are no more left
		/// </summary>
		/// <returns>The next <see cref="TypeDef"/> or <c>null</c> if none</returns>
		TypeDef GetNextTypeDef() {
			while (typeEnumerator.MoveNext()) {
				var type = typeEnumerator.Current;
				if (type != null)
					return type;
			}
			return null;
		}

		/// <summary>
		/// Gets the next <see cref="TypeDef"/> or <c>null</c> if there are no more left.
		/// The cache is updated with the returned <see cref="TypeDef"/> before the method
		/// returns.
		/// </summary>
		/// <returns>The next <see cref="TypeDef"/> or <c>null</c> if none</returns>
		TypeDef GetNextTypeDefCache() {
			var type = GetNextTypeDef();
			if (type == null)
				return null;

			// Only insert it if another type with the exact same sig/name isn't already
			// in the cache. This should only happen with some obfuscated assemblies.

			if (!typeRefCache.ContainsKey(type))
				typeRefCache[type] = type;
			string fn;
			sb.Length = 0;
			if (!normalNameCache.ContainsKey(fn = FullNameCreator.FullName(type, false, null, sb)))
				normalNameCache[fn] = type;
			sb.Length = 0;
			if (!reflectionNameCache.ContainsKey(fn = FullNameCreator.FullName(type, true, null, sb)))
				reflectionNameCache[fn] = type;

			return type;
		}

		/// <inheritdoc/>
		public void Dispose() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (typeEnumerator != null)
				typeEnumerator.Dispose();
			typeEnumerator = null;
			typeRefCache = null;
			normalNameCache = null;
			reflectionNameCache = null;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TypeHelper.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// Various helper methods for <see cref="IType"/> classes to prevent infinite recursion
	/// </summary>
	struct TypeHelper {
		RecursionCounter recursionCounter;

		internal static bool ContainsGenericParameter(StandAloneSig ss) {
			return ss != null && TypeHelper.ContainsGenericParameter(ss.Signature);
		}

		internal static bool ContainsGenericParameter(InterfaceImpl ii) {
			return ii != null && TypeHelper.ContainsGenericParameter(ii.Interface);
		}

		internal static bool ContainsGenericParameter(GenericParamConstraint gpc) {
			return gpc != null && ContainsGenericParameter(gpc.Constraint);
		}

		internal static bool ContainsGenericParameter(MethodSpec ms) {
			if (ms == null)
				return false;

			// A normal MethodSpec should always contain generic arguments and thus
			// its MethodDef is always a generic method with generic parameters.
			return true;
		}

		internal static bool ContainsGenericParameter(MemberRef mr) {
			if (mr == null)
				return false;

			if (ContainsGenericParameter(mr.Signature))
				return true;

			var cl = mr.Class;

			var tdr = cl as ITypeDefOrRef;
			if (tdr != null)
				return tdr.ContainsGenericParameter;

			var md = cl as MethodDef;
			if (md != null)
				return TypeHelper.ContainsGenericParameter(md.Signature);

			return false;
		}

		/// <summary>
		/// Checks whether <paramref name="callConv"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="callConv">Calling convention signature</param>
		/// <returns><c>true</c> if <paramref name="callConv"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(CallingConventionSig callConv) {
			var fs = callConv as FieldSig;
			if (fs != null)
				return ContainsGenericParameter(fs);

			var mbs = callConv as MethodBaseSig;
			if (mbs != null)
				return ContainsGenericParameter(mbs);

			var ls = callConv as LocalSig;
			if (ls != null)
				return ContainsGenericParameter(ls);

			var gim = callConv as GenericInstMethodSig;
			if (gim != null)
				return ContainsGenericParameter(gim);

			return false;
		}

		/// <summary>
		/// Checks whether <paramref name="fieldSig"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="fieldSig">Field signature</param>
		/// <returns><c>true</c> if <paramref name="fieldSig"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(FieldSig fieldSig) {
			return new TypeHelper().ContainsGenericParameterInternal(fieldSig);
		}

		/// <summary>
		/// Checks whether <paramref name="methodSig"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="methodSig">Method or property signature</param>
		/// <returns><c>true</c> if <paramref name="methodSig"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(MethodBaseSig methodSig) {
			return new TypeHelper().ContainsGenericParameterInternal(methodSig);
		}

		/// <summary>
		/// Checks whether <paramref name="localSig"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="localSig">Local signature</param>
		/// <returns><c>true</c> if <paramref name="localSig"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(LocalSig localSig) {
			return new TypeHelper().ContainsGenericParameterInternal(localSig);
		}

		/// <summary>
		/// Checks whether <paramref name="gim"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="gim">Generic method signature</param>
		/// <returns><c>true</c> if <paramref name="gim"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(GenericInstMethodSig gim) {
			return new TypeHelper().ContainsGenericParameterInternal(gim);
		}

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(IType type) {
			var td = type as TypeDef;
			if (td != null)
				return ContainsGenericParameter(td);

			var tr = type as TypeRef;
			if (tr != null)
				return ContainsGenericParameter(tr);

			var ts = type as TypeSpec;
			if (ts != null)
				return ContainsGenericParameter(ts);

			var sig = type as TypeSig;
			if (sig != null)
				return ContainsGenericParameter(sig);

			var et = type as ExportedType;
			if (et != null)
				return ContainsGenericParameter(et);

			return false;
		}

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(TypeDef type) {
			return new TypeHelper().ContainsGenericParameterInternal(type);
		}

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(TypeRef type) {
			return new TypeHelper().ContainsGenericParameterInternal(type);
		}

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(TypeSpec type) {
			return new TypeHelper().ContainsGenericParameterInternal(type);
		}

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(TypeSig type) {
			return new TypeHelper().ContainsGenericParameterInternal(type);
		}

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(ExportedType type) {
			return new TypeHelper().ContainsGenericParameterInternal(type);
		}

		bool ContainsGenericParameterInternal(TypeDef type) {
			return false;
		}

		bool ContainsGenericParameterInternal(TypeRef type) {
			return false;
		}

		bool ContainsGenericParameterInternal(TypeSpec type) {
			if (type == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameterInternal(type.TypeSig);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(ITypeDefOrRef tdr) {
			if (tdr == null)
				return false;
			// TypeDef and TypeRef contain no generic parameters
			return ContainsGenericParameterInternal(tdr as TypeSpec);
		}

		bool ContainsGenericParameterInternal(TypeSig type) {
			if (type == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res;
			switch (type.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.ValueType:
			case ElementType.Class:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
				res = ContainsGenericParameterInternal((type as TypeDefOrRefSig).TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
				res = true;
				break;

			case ElementType.FnPtr:
				res = ContainsGenericParameterInternal((type as FnPtrSig).Signature);
				break;

			case ElementType.GenericInst:
				var gi = (GenericInstSig)type;
				res = ContainsGenericParameterInternal(gi.GenericType) ||
					ContainsGenericParameter(gi.GenericArguments);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				res = ContainsGenericParameterInternal((type as NonLeafSig).Next);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				res = ContainsGenericParameterInternal((type as ModifierSig).Modifier) ||
					ContainsGenericParameterInternal((type as NonLeafSig).Next);
				break;


			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			case ElementType.Sentinel:
			default:
				res = false;
				break;
			}

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(ExportedType type) {
			return false;
		}

		bool ContainsGenericParameterInternal(CallingConventionSig callConv) {
			var fs = callConv as FieldSig;
			if (fs != null)
				return ContainsGenericParameterInternal(fs);

			var mbs = callConv as MethodBaseSig;
			if (mbs != null)
				return ContainsGenericParameterInternal(mbs);

			var ls = callConv as LocalSig;
			if (ls != null)
				return ContainsGenericParameterInternal(ls);

			var gim = callConv as GenericInstMethodSig;
			if (gim != null)
				return ContainsGenericParameterInternal(gim);

			return false;
		}

		bool ContainsGenericParameterInternal(FieldSig fs) {
			if (fs == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameterInternal(fs.Type);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(MethodBaseSig mbs) {
			if (mbs == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameterInternal(mbs.RetType) ||
				ContainsGenericParameter(mbs.Params) ||
				ContainsGenericParameter(mbs.ParamsAfterSentinel);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(LocalSig ls) {
			if (ls == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameter(ls.Locals);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(GenericInstMethodSig gim) {
			if (gim == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameter(gim.GenericArguments);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameter(ThreadSafe.IList<TypeSig> types) {
			if (types == null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = false;
			foreach (var type in types.GetSafeEnumerable()) {
				if (ContainsGenericParameter(type)) {
					res = true;
					break;
				}
			}
			recursionCounter.Decrement();
			return res;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TypeNameParser.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization;
using System.Text;

namespace dnlib.DotNet {
	/// <summary>
	/// Thrown by <see cref="TypeNameParser"/> when it fails to parse a type name
	/// </summary>
	[Serializable]
	public class TypeNameParserException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public TypeNameParserException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public TypeNameParserException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public TypeNameParserException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected TypeNameParserException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Helps <see cref="TypeNameParser"/> create types
	/// </summary>
	public interface IAssemblyRefFinder {
		/// <summary>
		/// Finds a <see cref="TypeRef"/>'s <see cref="AssemblyRef"/> when the original assembly
		/// info is missing from the full type name.
		/// </summary>
		/// <param name="nonNestedTypeRef">A non-nested <see cref="TypeRef"/></param>
		/// <returns><paramref name="nonNestedTypeRef"/>'s <see cref="AssemblyRef"/> or <c>null</c></returns>
		AssemblyRef FindAssemblyRef(TypeRef nonNestedTypeRef);
	}

	/// <summary>
	/// Parses a type name and creates an <see cref="IType"/>
	/// </summary>
	public abstract class TypeNameParser : IDisposable {
		/// <summary>Owner module</summary>
		protected ModuleDef ownerModule;
		readonly GenericParamContext gpContext;
		StringReader reader;
		readonly IAssemblyRefFinder typeNameParserHelper;
		RecursionCounter recursionCounter;

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="ITypeDefOrRef"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <returns>A new <see cref="ITypeDefOrRef"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		public static ITypeDefOrRef ParseReflectionThrow(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper) {
			return ParseReflectionThrow(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext());
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="ITypeDefOrRef"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="ITypeDefOrRef"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		public static ITypeDefOrRef ParseReflectionThrow(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			using (var parser = new ReflectionTypeNameParser(ownerModule, typeFullName, typeNameParserHelper, gpContext))
				return parser.Parse();
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="ITypeDefOrRef"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <returns>A new <see cref="ITypeDefOrRef"/> instance or <c>null</c> if parsing failed</returns>
		public static ITypeDefOrRef ParseReflection(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper) {
			return ParseReflection(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext());
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="ITypeDefOrRef"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="ITypeDefOrRef"/> instance or <c>null</c> if parsing failed</returns>
		public static ITypeDefOrRef ParseReflection(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			try {
				return ParseReflectionThrow(ownerModule, typeFullName, typeNameParserHelper, gpContext);
			}
			catch (TypeNameParserException) {
				return null;
			}
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="TypeSig"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <returns>A new <see cref="TypeSig"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		public static TypeSig ParseAsTypeSigReflectionThrow(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper) {
			return ParseAsTypeSigReflectionThrow(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext());
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="TypeSig"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		public static TypeSig ParseAsTypeSigReflectionThrow(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			using (var parser = new ReflectionTypeNameParser(ownerModule, typeFullName, typeNameParserHelper, gpContext))
				return parser.ParseAsTypeSig();
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="TypeSig"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if parsing failed</returns>
		public static TypeSig ParseAsTypeSigReflection(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper) {
			return ParseAsTypeSigReflection(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext());
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="TypeSig"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if parsing failed</returns>
		public static TypeSig ParseAsTypeSigReflection(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			try {
				return ParseAsTypeSigReflectionThrow(ownerModule, typeFullName, typeNameParserHelper, gpContext);
			}
			catch (TypeNameParserException) {
				return null;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="IType"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		protected TypeNameParser(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper)
			: this(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="IType"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		protected TypeNameParser(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			this.ownerModule = ownerModule;
			this.reader = new StringReader(typeFullName ?? string.Empty);
			this.typeNameParserHelper = typeNameParserHelper;
			this.gpContext = gpContext;
		}

		/// <summary>
		/// Parses a type name and creates a <see cref="IType"/>
		/// </summary>
		/// <returns>A new <see cref="IType"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		internal ITypeDefOrRef Parse() {
			return ownerModule.UpdateRowId(ParseAsTypeSig().ToTypeDefOrRef());
		}

		/// <summary>
		/// Parses a type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <returns>A new <see cref="TypeSig"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		internal abstract TypeSig ParseAsTypeSig();

		/// <summary>
		/// Increment recursion counter
		/// </summary>
		/// <exception cref="TypeNameParserException">If this method has been called too many times</exception>
		protected void RecursionIncrement() {
			if (!recursionCounter.Increment())
				throw new TypeNameParserException("Stack overflow");
		}

		/// <summary>
		/// Decrement recursion counter
		/// </summary>
		protected void RecursionDecrement() {
			recursionCounter.Decrement();
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			if (reader != null)
				reader.Dispose();
			reader = null;
		}

		internal abstract class TSpec {
			public readonly ElementType etype;

			protected TSpec(ElementType etype) {
				this.etype = etype;
			}
		}

		internal sealed class SZArraySpec : TSpec {
			public static readonly SZArraySpec Instance = new SZArraySpec();
			SZArraySpec()
				: base(ElementType.SZArray) {
			}
		}

		internal sealed class ArraySpec : TSpec {
			public uint rank;
			public readonly IList<uint> sizes = new List<uint>();
			public readonly IList<int> lowerBounds = new List<int>();

			public ArraySpec()
				: base(ElementType.Array) {
			}
		}

		internal sealed class GenericInstSpec : TSpec {
			public readonly List<TypeSig> args = new List<TypeSig>();

			public GenericInstSpec()
				: base(ElementType.GenericInst) {
			}
		}

		internal sealed class ByRefSpec : TSpec {
			public static readonly ByRefSpec Instance = new ByRefSpec();
			ByRefSpec()
				: base(ElementType.ByRef) {
			}
		}

		internal sealed class PtrSpec : TSpec {
			public static readonly PtrSpec Instance = new PtrSpec();
			PtrSpec()
				: base(ElementType.Ptr) {
			}
		}

		internal GenericSig ReadGenericSig() {
			Verify(ReadChar() == '!', "Expected '!'");
			if (PeekChar() == '!') {
				ReadChar();
				return new GenericMVar(ReadUInt32(), gpContext.Method);
			}
			return new GenericVar(ReadUInt32(), gpContext.Type);
		}

		internal TypeSig CreateTypeSig(IList<TSpec> tspecs, TypeSig currentSig) {
			foreach (var tspec in tspecs) {
				switch (tspec.etype) {
				case ElementType.SZArray:
					currentSig = new SZArraySig(currentSig);
					break;

				case ElementType.Array:
					var arraySpec = (ArraySpec)tspec;
					currentSig = new ArraySig(currentSig, arraySpec.rank, arraySpec.sizes, arraySpec.lowerBounds);
					break;

				case ElementType.GenericInst:
					var ginstSpec = (GenericInstSpec)tspec;
					currentSig = new GenericInstSig(currentSig as ClassOrValueTypeSig, ginstSpec.args);
					break;

				case ElementType.ByRef:
					currentSig = new ByRefSig(currentSig);
					break;

				case ElementType.Ptr:
					currentSig = new PtrSig(currentSig);
					break;

				default:
					Verify(false, "Unknown TSpec");
					break;
				}
			}
			return currentSig;
		}

		/// <summary>
		/// Reads a <see cref="TypeRef"/> including any possible nested <see cref="TypeRef"/>s.
		/// </summary>
		/// <param name="nestedChar">Character separating nested types</param>
		/// <returns>A new <see cref="TypeRef"/> instance, which could be nested.</returns>
		protected TypeRef ReadTypeRefAndNestedNoAssembly(char nestedChar) {
			var typeRef = ReadTypeRefNoAssembly();
			while (true) {
				SkipWhite();
				if (PeekChar() != nestedChar)
					break;
				ReadChar();
				var newTypeRef = ReadTypeRefNoAssembly();
				newTypeRef.ResolutionScope = typeRef;
				typeRef = newTypeRef;
			}
			return typeRef;
		}

		/// <summary>
		/// Reads a namespace and name and creates a TypeRef. Does not read any nested types.
		/// </summary>
		/// <returns>A new <see cref="TypeRef"/> instance</returns>
		protected TypeRef ReadTypeRefNoAssembly() {
			string ns, name;
			// White space is important here. Any white space before the comma/EOF must be
			// parsed as part of the name.
			GetNamespaceAndName(ReadId(false), out ns, out name);
			return ownerModule.UpdateRowId(new TypeRefUser(ownerModule, ns, name));
		}

		static void GetNamespaceAndName(string fullName, out string ns, out string name) {
			int index = fullName.LastIndexOf('.');
			if (index < 0) {
				ns = string.Empty;
				name = fullName;
			}
			else {
				ns = fullName.Substring(0, index);
				name = fullName.Substring(index + 1);
			}
		}

		internal TypeSig ToTypeSig(ITypeDefOrRef type) {
			var td = type as TypeDef;
			if (td != null)
				return ToTypeSig(td, td.IsValueType);
			var tr = type as TypeRef;
			if (tr != null)
				return ToTypeSig(tr, IsValueType(tr));
			var ts = type as TypeSpec;
			if (ts != null)
				return ts.TypeSig;
			Verify(false, "Unknown type");
			return null;
		}

		static TypeSig ToTypeSig(ITypeDefOrRef type, bool isValueType) {
			return isValueType ? (TypeSig)new ValueTypeSig(type) : new ClassSig(type);
		}

		internal AssemblyRef FindAssemblyRef(TypeRef nonNestedTypeRef) {
			AssemblyRef asmRef = null;
			if (nonNestedTypeRef != null && typeNameParserHelper != null)
				asmRef = typeNameParserHelper.FindAssemblyRef(nonNestedTypeRef);
			if (asmRef != null)
				return asmRef;
			var ownerAsm = ownerModule.Assembly;
			if (ownerAsm != null)
				return ownerModule.UpdateRowId(ownerAsm.ToAssemblyRef());
			return AssemblyRef.CurrentAssembly;
		}

		internal bool IsValueType(TypeRef typeRef) {
			return typeRef != null && typeRef.IsValueType;
		}

		internal static void Verify(bool b, string msg) {
			if (!b)
				throw new TypeNameParserException(msg);
		}

		internal void SkipWhite() {
			while (true) {
				int next = PeekChar();
				if (next == -1)
					break;
				if (!char.IsWhiteSpace((char)next))
					break;
				ReadChar();
			}
		}

		internal uint ReadUInt32() {
			SkipWhite();
			bool readInt = false;
			uint val = 0;
			while (true) {
				int c = PeekChar();
				if (c == -1 || !(c >= '0' && c <= '9'))
					break;
				ReadChar();
				uint newVal = val * 10 + (uint)(c - '0');
				Verify(newVal >= val, "Integer overflow");
				val = newVal;
				readInt = true;
			}
			Verify(readInt, "Expected an integer");
			return val;
		}

		internal int ReadInt32() {
			SkipWhite();

			bool isSigned = false;
			if (PeekChar() == '-') {
				isSigned = true;
				ReadChar();
			}

			uint val = ReadUInt32();
			if (isSigned) {
				Verify(val <= (uint)int.MaxValue + 1, "Integer overflow");
				return -(int)val;
			}
			else {
				Verify(val <= (uint)int.MaxValue, "Integer overflow");
				return (int)val;
			}
		}

		internal string ReadId() {
			return ReadId(true);
		}

		internal string ReadId(bool ignoreWhiteSpace) {
			SkipWhite();
			var sb = new StringBuilder();
			int c;
			while ((c = GetIdChar(ignoreWhiteSpace)) != -1)
				sb.Append((char)c);
			Verify(sb.Length > 0, "Expected an id");
			return sb.ToString();
		}

		/// <summary>
		/// Peeks the next char. -1 if no more chars.
		/// </summary>
		protected int PeekChar() {
			return reader.Peek();
		}

		/// <summary>
		/// Gets the next char or -1 if no more chars
		/// </summary>
		protected int ReadChar() {
			return reader.Read();
		}

		/// <summary>
		/// Gets the next ID char or <c>-1</c> if no more ID chars
		/// </summary>
		/// <param name="ignoreWhiteSpace"><c>true</c> if white space should be ignored</param>
		internal abstract int GetIdChar(bool ignoreWhiteSpace);
	}

	/// <summary>
	/// Parses reflection type names. Grammar http://msdn.microsoft.com/en-us/library/yfsftwz6.aspx
	/// </summary>
	sealed class ReflectionTypeNameParser : TypeNameParser {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="IType"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		public ReflectionTypeNameParser(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper)
			: base(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="IType"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		public ReflectionTypeNameParser(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext)
			: base(ownerModule, typeFullName, typeNameParserHelper, gpContext) {
		}

		/// <summary>
		/// Parses an assembly name
		/// </summary>
		/// <param name="asmFullName">Full assembly name</param>
		/// <returns>A new <see cref="AssemblyRef"/> instance or <c>null</c> if parsing failed</returns>
		public static AssemblyRef ParseAssemblyRef(string asmFullName) {
			return ParseAssemblyRef(asmFullName, new GenericParamContext());
		}

		/// <summary>
		/// Parses an assembly name
		/// </summary>
		/// <param name="asmFullName">Full assembly name</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="AssemblyRef"/> instance or <c>null</c> if parsing failed</returns>
		public static AssemblyRef ParseAssemblyRef(string asmFullName, GenericParamContext gpContext) {
			try {
				using (var parser = new ReflectionTypeNameParser(null, asmFullName, null, gpContext))
					return parser.ReadAssemblyRef();
			}
			catch {
				return null;
			}
		}

		/// <inheritdoc/>
		internal override TypeSig ParseAsTypeSig() {
			try {
				var type = ReadType(true);
				SkipWhite();
				Verify(PeekChar() == -1, "Extra input after type name");
				return type;
			}
			catch (TypeNameParserException) {
				throw;
			}
			catch (Exception ex) {
				throw new TypeNameParserException("Could not parse type name", ex);
			}
		}

		TypeSig ReadType(bool readAssemblyReference) {
			RecursionIncrement();
			TypeSig result;

			SkipWhite();
			if (PeekChar() == '!') {
				var currentSig = ReadGenericSig();
				var tspecs = ReadTSpecs();
				ReadOptionalAssemblyRef();
				result = CreateTypeSig(tspecs, currentSig);
			}
			else {
				TypeRef typeRef = ReadTypeRefAndNestedNoAssembly('+');
				var tspecs = ReadTSpecs();
				var nonNestedTypeRef = TypeRef.GetNonNestedTypeRef(typeRef);
				AssemblyRef asmRef;
				if (readAssemblyReference)
					asmRef = ReadOptionalAssemblyRef() ?? FindAssemblyRef(nonNestedTypeRef);
				else
					asmRef = FindAssemblyRef(nonNestedTypeRef);
				nonNestedTypeRef.ResolutionScope = asmRef;

				// Make sure the CorLib types are used whenever possible
				result = null;
				if (typeRef == nonNestedTypeRef) {
					var corLibSig = ownerModule.CorLibTypes.GetCorLibTypeSig(typeRef.Namespace, typeRef.Name, typeRef.DefinitionAssembly);
					if (corLibSig != null)
						result = corLibSig;
				}
				if (result == null) {
					var typeDef = Resolve(asmRef, typeRef);
					result = ToTypeSig(typeDef != null ? (ITypeDefOrRef)typeDef : typeRef);
				}

				if (tspecs.Count != 0)
					result = CreateTypeSig(tspecs, result);
			}

			RecursionDecrement();
			return result;
		}

		TypeDef Resolve(AssemblyRef asmRef, TypeRef typeRef) {
			var asm = ownerModule.Assembly;
			if (asm == null)
				return null;
			if (!(AssemblyNameComparer.CompareAll.Equals(asmRef, asm) && asmRef.IsRetargetable == asm.IsRetargetable))
				return null;
			var td = typeRef.Resolve();
			return td != null && td.Module == ownerModule ? td : null;
		}

		AssemblyRef ReadOptionalAssemblyRef() {
			SkipWhite();
			if (PeekChar() == ',') {
				ReadChar();
				return ReadAssemblyRef();
			}
			return null;
		}

		IList<TSpec> ReadTSpecs() {
			var tspecs = new List<TSpec>();
			while (true) {
				SkipWhite();
				switch (PeekChar()) {
				case '[':	// SZArray, Array, or GenericInst
					ReadChar();
					SkipWhite();
					var peeked = PeekChar();
					if (peeked == ']') {
						// SZ array
						Verify(ReadChar() == ']', "Expected ']'");
						tspecs.Add(SZArraySpec.Instance);
					}
					else if (peeked == '*' || peeked == ',' || peeked == '-' || char.IsDigit((char)peeked)) {
						// Array

						var arraySpec = new ArraySpec();
						arraySpec.rank = 0;
						while (true) {
							SkipWhite();
							int c = PeekChar();
							if (c == '*')
								ReadChar();
							else if (c == ',' || c == ']') {
							}
							else if (c == '-' || char.IsDigit((char)c)) {
								int lower = ReadInt32();
								uint? size;
								SkipWhite();
								Verify(ReadChar() == '.', "Expected '.'");
								Verify(ReadChar() == '.', "Expected '.'");
								if (PeekChar() == '.') {
									ReadChar();
									size = null;
								}
								else {
									SkipWhite();
									if (PeekChar() == '-') {
										int upper = ReadInt32();
										Verify(upper >= lower, "upper < lower");
										size = (uint)(upper - lower + 1);
										Verify(size.Value != 0 && size.Value <= 0x1FFFFFFF, "Invalid size");
									}
									else {
										uint upper = ReadUInt32();
										long lsize = (long)upper - (long)lower + 1;
										Verify(lsize > 0 && lsize <= 0x1FFFFFFF, "Invalid size");
										size = (uint)lsize;
									}
								}
								if (arraySpec.lowerBounds.Count == arraySpec.rank)
									arraySpec.lowerBounds.Add(lower);
								if (size.HasValue && arraySpec.sizes.Count == arraySpec.rank)
									arraySpec.sizes.Add(size.Value);
							}
							else
								Verify(false, "Unknown char");

							arraySpec.rank++;
							SkipWhite();
							if (PeekChar() != ',')
								break;
							ReadChar();
						}

						Verify(ReadChar() == ']', "Expected ']'");
						tspecs.Add(arraySpec);
					}
					else {
						// Generic args

						var ginstSpec = new GenericInstSpec();
						while (true) {
							SkipWhite();
							peeked = PeekChar();
							bool needSeperators = peeked == '[';
							if (peeked == ']')
								break;
							Verify(!needSeperators || ReadChar() == '[', "Expected '['");
							ginstSpec.args.Add(ReadType(needSeperators));
							SkipWhite();
							Verify(!needSeperators || ReadChar() == ']', "Expected ']'");
							SkipWhite();
							if (PeekChar() != ',')
								break;
							ReadChar();
						}

						Verify(ReadChar() == ']', "Expected ']'");
						tspecs.Add(ginstSpec);
					}
					break;

				case '&':	// ByRef
					ReadChar();
					tspecs.Add(ByRefSpec.Instance);
					break;

				case '*':	// Ptr
					ReadChar();
					tspecs.Add(PtrSpec.Instance);
					break;

				default:
					return tspecs;
				}
			}
		}

		AssemblyRef ReadAssemblyRef() {
			var asmRef = new AssemblyRefUser();
			if (ownerModule != null)
				ownerModule.UpdateRowId(asmRef);

			asmRef.Name = ReadAssemblyNameId();
			SkipWhite();
			if (PeekChar() != ',')
				return asmRef;
			ReadChar();

			while (true) {
				SkipWhite();
				int c = PeekChar();
				if (c == -1 || c == ']')
					break;
				if (c == ',') {
					ReadChar();
					continue;
				}

				string key = ReadId();
				SkipWhite();
				if (PeekChar() != '=')
					continue;
				ReadChar();
				string value = ReadId();

				switch (key.ToUpperInvariant()) {
				case "VERSION":
					asmRef.Version = Utils.ParseVersion(value);
					break;

				case "CONTENTTYPE":
					if (value.Equals("WindowsRuntime", StringComparison.OrdinalIgnoreCase))
						asmRef.ContentType = AssemblyAttributes.ContentType_WindowsRuntime;
					else
						asmRef.ContentType = AssemblyAttributes.ContentType_Default;
					break;

				case "RETARGETABLE":
					if (value.Equals("Yes", StringComparison.OrdinalIgnoreCase))
						asmRef.IsRetargetable = true;
					else
						asmRef.IsRetargetable = false;
					break;

				case "PUBLICKEY":
					if (value.Equals("null", StringComparison.OrdinalIgnoreCase) ||
						value.Equals("neutral", StringComparison.OrdinalIgnoreCase))
						asmRef.PublicKeyOrToken = new PublicKey();
					else
						asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKey(Utils.ParseBytes(value));
					break;

				case "PUBLICKEYTOKEN":
					if (value.Equals("null", StringComparison.OrdinalIgnoreCase) ||
						value.Equals("neutral", StringComparison.OrdinalIgnoreCase))
						asmRef.PublicKeyOrToken = new PublicKeyToken();
					else
						asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKeyToken(Utils.ParseBytes(value));
					break;

				case "CULTURE":
				case "LANGUAGE":
					if (value.Equals("neutral", StringComparison.OrdinalIgnoreCase))
						asmRef.Culture = UTF8String.Empty;
					else
						asmRef.Culture = value;
					break;
				}
			}

			return asmRef;
		}

		string ReadAssemblyNameId() {
			SkipWhite();
			var sb = new StringBuilder();
			int c;
			while ((c = GetAsmNameChar()) != -1)
				sb.Append((char)c);
			var name = sb.ToString().Trim();
			Verify(name.Length > 0, "Expected an assembly name");
			return name;
		}

		int GetAsmNameChar() {
			int c = PeekChar();
			if (c == -1)
				return -1;
			switch (c) {
			case '\\':
				ReadChar();
				return ReadChar();

			case ']':
			case ',':
				return -1;

			default:
				return ReadChar();
			}
		}

		internal override int GetIdChar(bool ignoreWhiteSpace) {
			int c = PeekChar();
			if (c == -1)
				return -1;
			if (ignoreWhiteSpace && char.IsWhiteSpace((char)c))
				return -1;
			switch (c) {
			case '\\':
				ReadChar();
				return ReadChar();

			case ',':
			case '+':
			case '&':
			case '*':
			case '[':
			case ']':
			case '=':
				return -1;

			default:
				return ReadChar();
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TypeRef.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the TypeRef table
	/// </summary>
	public abstract class TypeRef : ITypeDefOrRef, IHasCustomAttribute, IMemberRefParent, IHasCustomDebugInformation, IResolutionScope {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <summary>
		/// The owner module
		/// </summary>
		protected ModuleDef module;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.TypeRef, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int TypeDefOrRefTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 2; }
		}

		/// <inheritdoc/>
		public int MemberRefParentTag {
			get { return 1; }
		}

		/// <inheritdoc/>
		public int ResolutionScopeTag {
			get { return 3; }
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get { return 0; }
		}

		/// <inheritdoc/>
		string IType.TypeName {
			get { return FullNameCreator.Name(this, false, null); }
		}

		/// <inheritdoc/>
		public string ReflectionName {
			get { return FullNameCreator.Name(this, true, null); }
		}

		/// <inheritdoc/>
		string IType.Namespace {
			get { return FullNameCreator.Namespace(this, false, null); }
		}

		/// <inheritdoc/>
		public string ReflectionNamespace {
			get { return FullNameCreator.Namespace(this, true, null); }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return FullNameCreator.FullName(this, false, null, null); }
		}

		/// <inheritdoc/>
		public string ReflectionFullName {
			get { return FullNameCreator.FullName(this, true, null, null); }
		}

		/// <inheritdoc/>
		public string AssemblyQualifiedName {
			get { return FullNameCreator.AssemblyQualifiedName(this, null, null); }
		}

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly {
			get { return FullNameCreator.DefinitionAssembly(this); }
		}

		/// <inheritdoc/>
		public IScope Scope {
			get { return FullNameCreator.Scope(this); }
		}

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType {
			get { return this; }
		}

		/// <summary>
		/// Always returns <c>false</c> since a <see cref="TypeRef"/> does not contain any
		/// <see cref="GenericVar"/> or <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter {
			get { return false; }
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get { return module; }
		}

		/// <summary>
		/// From column TypeRef.ResolutionScope
		/// </summary>
		public IResolutionScope ResolutionScope {
			get {
				if (!resolutionScope_isInitialized)
					InitializeResolutionScope();
				return resolutionScope;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				resolutionScope = value;
				resolutionScope_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected IResolutionScope resolutionScope;
		/// <summary/>
		protected bool resolutionScope_isInitialized;

		void InitializeResolutionScope() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (resolutionScope_isInitialized)
				return;
			resolutionScope = GetResolutionScope_NoLock();
			resolutionScope_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="resolutionScope"/></summary>
		protected virtual IResolutionScope GetResolutionScope_NoLock() {
			return null;
		}

		/// <summary>
		/// From column TypeRef.Name
		/// </summary>
		public UTF8String Name {
			get { return name; }
			set { name = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column TypeRef.Namespace
		/// </summary>
		public UTF8String Namespace {
			get { return @namespace; }
			set { @namespace = value; }
		}
		/// <summary>Name</summary>
		protected UTF8String @namespace;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 2; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}

		/// <summary>
		/// <c>true</c> if it's nested within another <see cref="TypeRef"/>
		/// </summary>
		public bool IsNested {
			get { return DeclaringType != null; }
		}

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				var td = Resolve();
				return td != null && td.IsValueType;
			}
		}

		/// <inheritdoc/>
		public bool IsPrimitive {
			get { return this.IsPrimitive(); }
		}

		/// <summary>
		/// Gets the declaring type, if any
		/// </summary>
		public TypeRef DeclaringType {
			get { return ResolutionScope as TypeRef; }
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get { return DeclaringType; }
		}

		bool IIsTypeOrMethod.IsType {
			get { return true; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		bool IMemberRef.IsField {
			get { return false; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return false; }
		}

		bool IMemberRef.IsTypeRef {
			get { return true; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public TypeDef Resolve() {
			return Resolve(null);
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public TypeDef Resolve(ModuleDef sourceModule) {
			if (module == null)
				return null;
			return module.Context.Resolver.Resolve(this, sourceModule ?? module);
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public TypeDef ResolveThrow() {
			return ResolveThrow(null);
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public TypeDef ResolveThrow(ModuleDef sourceModule) {
			var type = Resolve(sourceModule);
			if (type != null)
				return type;
			throw new TypeResolveException(string.Format("Could not resolve type: {0} ({1})", this, DefinitionAssembly));
		}

		/// <summary>
		/// Gets the top-most (non-nested) <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">Input</param>
		/// <returns>The non-nested <see cref="TypeRef"/> or <c>null</c></returns>
		internal static TypeRef GetNonNestedTypeRef(TypeRef typeRef) {
			if (typeRef == null)
				return null;
			for (int i = 0; i < 1000; i++) {
				var next = typeRef.ResolutionScope as TypeRef;
				if (next == null)
					return typeRef;
				typeRef = next;
			}
			return null;	// Here if eg. the TypeRef has an infinite loop
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A TypeRef row created by the user and not present in the original .NET file
	/// </summary>
	public class TypeRefUser : TypeRef {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Type name</param>
		public TypeRefUser(ModuleDef module, UTF8String name)
			: this(module, UTF8String.Empty, name) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="namespace">Type namespace</param>
		/// <param name="name">Type name</param>
		public TypeRefUser(ModuleDef module, UTF8String @namespace, UTF8String name)
			: this(module, @namespace, name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="namespace">Type namespace</param>
		/// <param name="name">Type name</param>
		/// <param name="resolutionScope">Resolution scope (a <see cref="ModuleDef"/>,
		/// <see cref="ModuleRef"/>, <see cref="AssemblyRef"/> or <see cref="TypeRef"/>)</param>
		public TypeRefUser(ModuleDef module, UTF8String @namespace, UTF8String name, IResolutionScope resolutionScope) {
			this.module = module;
			this.resolutionScope = resolutionScope;
			this.resolutionScope_isInitialized = true;
			this.name = name;
			this.@namespace = @namespace;
		}
	}

	/// <summary>
	/// Created from a row in the TypeRef table
	/// </summary>
	sealed class TypeRefMD : TypeRef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly uint resolutionScopeCodedToken;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override IResolutionScope GetResolutionScope_NoLock() {
			return readerModule.ResolveResolutionScope(resolutionScopeCodedToken);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.TypeRef, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>TypeRef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public TypeRefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.TypeRefTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("TypeRef rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.module = readerModule;
			uint resolutionScope, name;
			uint @namespace = readerModule.TablesStream.ReadTypeRefRow(origRid, out resolutionScope, out name);
			this.name = readerModule.StringsStream.ReadNoNull(name);
			this.@namespace = readerModule.StringsStream.ReadNoNull(@namespace);
			this.resolutionScopeCodedToken = resolutionScope;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TypeSig.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
ï»¿using System.Collections.Generic;
using dnlib.DotNet.MD;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

/*
All TypeSig classes:

TypeSig								base class
	LeafSig							base class for leaf types
		TypeDefOrRefSig				contains a ITypeDefOrRef instance
			CorLibTypeSig			simple corlib types (eg. System.Int32)
			ClassOrValueTypeSig		base class for Class/ValueType element types
				ValueTypeSig		ValueType
				ClassSig			Class
		GenericSig					base class for generic vars
			GenericVar				Generic type parameter
			GenericMVar				Generic method parameter
		SentinelSig					Sentinel
		FnPtrSig					Function pointer sig
		GenericInstSig				Generic instance type (contains a generic type + all generic args)
	NonLeafSig						base class for non-leaf types
		PtrSig						Pointer
		ByRefSig					By ref
		ArraySigBase				Array base class
			ArraySig				Array
			SZArraySig				Single dimension, zero lower limit array (i.e., THETYPE[])
		ModifierSig					C modifier base class
			CModReqdSig				C required modifier
			CModOptSig				C optional modifier
		PinnedSig					Pinned
		ValueArraySig				Value array (undocumented/not implemented by the CLR so don't use it)
		ModuleSig					Module (undocumented/not implemented by the CLR so don't use it)
*/

namespace dnlib.DotNet {
	/// <summary>
	/// Type sig base class
	/// </summary>
	public abstract class TypeSig : IType {
		uint rid;

		/// <summary>
		/// Returns the wrapped element type. Can only be <c>null</c> if it was an invalid sig or
		/// if it's a <see cref="LeafSig"/>
		/// </summary>
		public abstract TypeSig Next { get; }

		/// <summary>
		/// Gets the element type
		/// </summary>
		public abstract ElementType ElementType { get; }

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.TypeSpec, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		/// <inheritdoc/>
		bool IIsTypeOrMethod.IsType {
			get { return true; }
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get {
				var type = this.RemovePinnedAndModifiers() as GenericInstSig;
				return type == null ? 0 : type.GenericArguments.Count;
			}
		}

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				var t = this.RemovePinnedAndModifiers();
				if (t == null)
					return false;
				if (t.ElementType == ElementType.GenericInst) {
					var gis = (GenericInstSig)t;
					t = gis.GenericType;
					if (t == null)
						return false;
				}
				return t.ElementType.IsValueType();
			}
		}

		/// <inheritdoc/>
		public bool IsPrimitive {
			get { return ElementType.IsPrimitive(); }
		}

		/// <inheritdoc/>
		public string TypeName {
			get { return FullNameCreator.Name(this, false, null); }
		}

		/// <inheritdoc/>
		UTF8String IFullName.Name {
			get { return new UTF8String(FullNameCreator.Name(this, false, null)); }
			set { throw new NotSupportedException(); }
		}

		/// <inheritdoc/>
		public string ReflectionName {
			get { return FullNameCreator.Name(this, true, null); }
		}

		/// <inheritdoc/>
		public string Namespace {
			get { return FullNameCreator.Namespace(this, false, null); }
		}

		/// <inheritdoc/>
		public string ReflectionNamespace {
			get { return FullNameCreator.Namespace(this, true, null); }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return FullNameCreator.FullName(this, false, null, null, null, null); }
		}

		/// <inheritdoc/>
		public string ReflectionFullName {
			get { return FullNameCreator.FullName(this, true, null, null, null, null); }
		}

		/// <inheritdoc/>
		public string AssemblyQualifiedName {
			get { return FullNameCreator.AssemblyQualifiedName(this, null, null); }
		}

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly {
			get { return FullNameCreator.DefinitionAssembly(this); }
		}

		/// <inheritdoc/>
		public IScope Scope {
			get { return FullNameCreator.Scope(this); }
		}

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType {
			get { return FullNameCreator.ScopeType(this); }
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get { return FullNameCreator.OwnerModule(this); }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="TypeDefOrRefSig"/>
		/// </summary>
		public bool IsTypeDefOrRef {
			get { return this is TypeDefOrRefSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="CorLibTypeSig"/>
		/// </summary>
		public bool IsCorLibType {
			get { return this is CorLibTypeSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="ClassSig"/>
		/// </summary>
		public bool IsClassSig {
			get { return this is ClassSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="ValueTypeSig"/>
		/// </summary>
		public bool IsValueTypeSig {
			get { return this is ValueTypeSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericSig"/>
		/// </summary>
		public bool IsGenericParameter {
			get { return this is GenericSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericVar"/>
		/// </summary>
		public bool IsGenericTypeParameter {
			get { return this is GenericVar; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericMVar"/>
		/// </summary>
		public bool IsGenericMethodParameter {
			get { return this is GenericMVar; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="SentinelSig"/>
		/// </summary>
		public bool IsSentinel {
			get { return this is SentinelSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="FnPtrSig"/>
		/// </summary>
		public bool IsFunctionPointer {
			get { return this is FnPtrSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericInstSig"/>
		/// </summary>
		public bool IsGenericInstanceType {
			get { return this is GenericInstSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="PtrSig"/>
		/// </summary>
		public bool IsPointer {
			get { return this is PtrSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="ByRefSig"/>
		/// </summary>
		public bool IsByRef {
			get { return this is ByRefSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="ArraySig"/> or a <see cref="SZArraySig"/>
		/// </summary>
		public bool IsSingleOrMultiDimensionalArray {
			get { return this is ArraySigBase; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="ArraySig"/>
		/// </summary>
		public bool IsArray {
			get { return this is ArraySig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="SZArraySig"/>
		/// </summary>
		public bool IsSZArray {
			get { return this is SZArraySig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="ModifierSig"/>
		/// </summary>
		public bool IsModifier {
			get { return this is ModifierSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="CModReqdSig"/>
		/// </summary>
		public bool IsRequiredModifier {
			get { return this is CModReqdSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="CModOptSig"/>
		/// </summary>
		public bool IsOptionalModifier {
			get { return this is CModOptSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="PinnedSig"/>
		/// </summary>
		public bool IsPinned {
			get { return this is PinnedSig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="ValueArraySig"/>
		/// </summary>
		public bool IsValueArray {
			get { return this is ValueArraySig; }
		}

		/// <summary>
		/// <c>true</c> if it's a <see cref="ModuleSig"/>
		/// </summary>
		public bool IsModuleSig {
			get { return this is ModuleSig; }
		}

		/// <summary>
		/// <c>true</c> if this <see cref="TypeSig"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter {
			get { return TypeHelper.ContainsGenericParameter(this); }
		}

		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	public static partial class Extensions {
		/// <summary>
		/// Removes all C optional/required modifiers
		/// </summary>
		/// <param name="a">A <see cref="TypeSig"/> instance</param>
		/// <returns>Input after all modifiers</returns>
		public static TypeSig RemoveModifiers(this TypeSig a) {
			if (a == null)
				return null;
			while (true) {
				var modifier = a as ModifierSig;
				if (modifier == null)
					return a;
				a = a.Next;
			}
		}

		/// <summary>
		/// Removes pinned signature
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>Input after pinned signature</returns>
		public static TypeSig RemovePinned(this TypeSig a) {
			var pinned = a as PinnedSig;
			if (pinned == null)
				return a;
			return pinned.Next;
		}

		/// <summary>
		/// Removes all modifiers and pinned sig
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>Inputer after modifiers and pinned signature</returns>
		public static TypeSig RemovePinnedAndModifiers(this TypeSig a) {
			a = a.RemoveModifiers();
			a = a.RemovePinned();
			a = a.RemoveModifiers();
			return a;
		}

		/// <summary>
		/// Returns a <see cref="TypeDefOrRefSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="TypeDefOrRefSig"/> or <c>null</c> if it's not a
		/// <see cref="TypeDefOrRefSig"/></returns>
		public static TypeDefOrRefSig ToTypeDefOrRefSig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as TypeDefOrRefSig;
		}

		/// <summary>
		/// Returns a <see cref="ClassOrValueTypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ClassOrValueTypeSig"/> or <c>null</c> if it's not a
		/// <see cref="ClassOrValueTypeSig"/></returns>
		public static ClassOrValueTypeSig ToClassOrValueTypeSig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as ClassOrValueTypeSig;
		}

		/// <summary>
		/// Returns a <see cref="ValueTypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ValueTypeSig"/> or <c>null</c> if it's not a
		/// <see cref="ValueTypeSig"/></returns>
		public static ValueTypeSig ToValueTypeSig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as ValueTypeSig;
		}

		/// <summary>
		/// Returns a <see cref="ClassSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ClassSig"/> or <c>null</c> if it's not a
		/// <see cref="ClassSig"/></returns>
		public static ClassSig ToClassSig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as ClassSig;
		}

		/// <summary>
		/// Returns a <see cref="GenericSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericSig"/> or <c>null</c> if it's not a
		/// <see cref="GenericSig"/></returns>
		public static GenericSig ToGenericSig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as GenericSig;
		}

		/// <summary>
		/// Returns a <see cref="GenericVar"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericVar"/> or <c>null</c> if it's not a
		/// <see cref="GenericVar"/></returns>
		public static GenericVar ToGenericVar(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as GenericVar;
		}

		/// <summary>
		/// Returns a <see cref="GenericMVar"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericMVar"/> or <c>null</c> if it's not a
		/// <see cref="GenericMVar"/></returns>
		public static GenericMVar ToGenericMVar(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as GenericMVar;
		}

		/// <summary>
		/// Returns a <see cref="GenericInstSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericInstSig"/> or <c>null</c> if it's not a
		/// <see cref="GenericInstSig"/></returns>
		public static GenericInstSig ToGenericInstSig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as GenericInstSig;
		}

		/// <summary>
		/// Returns a <see cref="PtrSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="PtrSig"/> or <c>null</c> if it's not a
		/// <see cref="PtrSig"/></returns>
		public static PtrSig ToPtrSig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as PtrSig;
		}

		/// <summary>
		/// Returns a <see cref="ByRefSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ByRefSig"/> or <c>null</c> if it's not a
		/// <see cref="ByRefSig"/></returns>
		public static ByRefSig ToByRefSig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as ByRefSig;
		}

		/// <summary>
		/// Returns a <see cref="ArraySig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ArraySig"/> or <c>null</c> if it's not a
		/// <see cref="ArraySig"/></returns>
		public static ArraySig ToArraySig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as ArraySig;
		}

		/// <summary>
		/// Returns a <see cref="SZArraySig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="SZArraySig"/> or <c>null</c> if it's not a
		/// <see cref="SZArraySig"/></returns>
		public static SZArraySig ToSZArraySig(this TypeSig type) {
			return type.RemovePinnedAndModifiers() as SZArraySig;
		}

		/// <summary>
		/// Gets the next field or <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static TypeSig GetNext(this TypeSig self) {
			return self == null ? null : self.Next;
		}

		/// <summary>
		/// Gets the <see cref="TypeSig.IsValueType"/> value or <c>false</c> if
		/// <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static bool GetIsValueType(this TypeSig self) {
			return self == null ? false : self.IsValueType;
		}

		/// <summary>
		/// Gets the <see cref="TypeSig.IsPrimitive"/> value or <c>false</c> if
		/// <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static bool GetIsPrimitive(this TypeSig self) {
			return self == null ? false : self.IsPrimitive;
		}

		/// <summary>
		/// Gets the element type
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>The element type</returns>
		public static ElementType GetElementType(this TypeSig a) {
			return a == null ? ElementType.End : a.ElementType;
		}

		/// <summary>
		/// Gets the full name of the type
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>Full name of the type</returns>
		public static string GetFullName(this TypeSig a) {
			return a == null ? string.Empty : a.FullName;
		}

		/// <summary>
		/// Gets the name of the type
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>Name of the type</returns>
		public static string GetName(this TypeSig a) {
			return a == null ? string.Empty : a.TypeName;
		}

		/// <summary>
		/// Gets the namespace of the type
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>Namespace of the type</returns>
		public static string GetNamespace(this TypeSig a) {
			return a == null ? string.Empty : a.Namespace;
		}

		/// <summary>
		/// Returns the <see cref="TypeRef"/> if it is a <see cref="TypeDefOrRefSig"/>.
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>A <see cref="TypeRef"/> or <c>null</c> if none found</returns>
		public static TypeRef TryGetTypeRef(this TypeSig a) {
			var tdr = a.RemovePinnedAndModifiers() as TypeDefOrRefSig;
			return tdr == null ? null : tdr.TypeRef;
		}

		/// <summary>
		/// Returns the <see cref="TypeDef"/> if it is a <see cref="TypeDefOrRefSig"/>.
		/// Nothing is resolved.
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if none found</returns>
		public static TypeDef TryGetTypeDef(this TypeSig a) {
			var tdr = a.RemovePinnedAndModifiers() as TypeDefOrRefSig;
			return tdr == null ? null : tdr.TypeDef;
		}

		/// <summary>
		/// Returns the <see cref="TypeSpec"/> if it is a <see cref="TypeDefOrRefSig"/>.
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>A <see cref="TypeSpec"/> or <c>null</c> if none found</returns>
		public static TypeSpec TryGetTypeSpec(this TypeSig a) {
			var tdr = a.RemovePinnedAndModifiers() as TypeDefOrRefSig;
			return tdr == null ? null : tdr.TypeSpec;
		}
	}

	/// <summary>
	/// Base class for element types that are last in a type sig, ie.,
	/// <see cref="TypeDefOrRefSig"/>, <see cref="GenericSig"/>, <see cref="SentinelSig"/>,
	/// <see cref="FnPtrSig"/>, <see cref="GenericInstSig"/>
	/// </summary>
	public abstract class LeafSig : TypeSig {
		/// <inheritdoc/>
		public sealed override TypeSig Next {
			get { return null; }
		}
	}

	/// <summary>
	/// Wraps a <see cref="ITypeDefOrRef"/>
	/// </summary>
	public abstract class TypeDefOrRefSig : LeafSig {
		readonly ITypeDefOrRef typeDefOrRef;

		/// <summary>
		/// Gets the the <c>TypeDefOrRef</c>
		/// </summary>
		public ITypeDefOrRef TypeDefOrRef {
			get { return typeDefOrRef; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="TypeRef"/> != <c>null</c>
		/// </summary>
		public bool IsTypeRef {
			get { return TypeRef != null; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="TypeDef"/> != <c>null</c>
		/// </summary>
		public bool IsTypeDef {
			get { return TypeDef != null; }
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="TypeSpec"/> != <c>null</c>
		/// </summary>
		public bool IsTypeSpec {
			get { return TypeSpec != null; }
		}

		/// <summary>
		/// Gets the <see cref="TypeRef"/> or <c>null</c> if it's not a <see cref="TypeRef"/>
		/// </summary>
		public TypeRef TypeRef {
			get { return typeDefOrRef as TypeRef; }
		}

		/// <summary>
		/// Gets the <see cref="TypeDef"/> or <c>null</c> if it's not a <see cref="TypeDef"/>
		/// </summary>
		public TypeDef TypeDef {
			get { return typeDefOrRef as TypeDef; }
		}

		/// <summary>
		/// Gets the <see cref="TypeSpec"/> or <c>null</c> if it's not a <see cref="TypeSpec"/>
		/// </summary>
		public TypeSpec TypeSpec {
			get { return typeDefOrRef as TypeSpec; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeDefOrRef">A <see cref="TypeRef"/>, <see cref="TypeDef"/> or
		/// a <see cref="TypeSpec"/></param>
		protected TypeDefOrRefSig(ITypeDefOrRef typeDefOrRef) {
			this.typeDefOrRef = typeDefOrRef;
		}
	}

	/// <summary>
	/// A core library type
	/// </summary>
	public sealed class CorLibTypeSig : TypeDefOrRefSig {
		readonly ElementType elementType;

		/// <summary>
		/// Gets the element type
		/// </summary>
		public override ElementType ElementType {
			get { return elementType; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="corType">The type which must be a <see cref="TypeRef"/> or a
		/// <see cref="TypeDef"/>. <see cref="TypeSpec"/> and <c>null</c> are not allowed.</param>
		/// <param name="elementType">The type's element type</param>
		public CorLibTypeSig(ITypeDefOrRef corType, ElementType elementType)
			: base(corType) {
			if (!(corType is TypeRef) && !(corType is TypeDef))
				throw new ArgumentException("corType must be a TypeDef or a TypeRef. null and TypeSpec are invalid inputs.");
			this.elementType = elementType;
		}
	}

	/// <summary>
	/// Base class for class/valuetype element types
	/// </summary>
	public abstract class ClassOrValueTypeSig : TypeDefOrRefSig {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeDefOrRef">A <see cref="ITypeDefOrRef"/></param>
		protected ClassOrValueTypeSig(ITypeDefOrRef typeDefOrRef)
			: base(typeDefOrRef) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.ValueType"/>
	/// </summary>
	public sealed class ValueTypeSig : ClassOrValueTypeSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.ValueType; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeDefOrRef">A <see cref="ITypeDefOrRef"/></param>
		public ValueTypeSig(ITypeDefOrRef typeDefOrRef)
			: base(typeDefOrRef) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Class"/>
	/// </summary>
	public sealed class ClassSig : ClassOrValueTypeSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.Class; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeDefOrRef">A <see cref="ITypeDefOrRef"/></param>
		public ClassSig(ITypeDefOrRef typeDefOrRef)
			: base(typeDefOrRef) {
		}
	}

	/// <summary>
	/// Generic method/type var base class
	/// </summary>
	public abstract class GenericSig : LeafSig {
		readonly bool isTypeVar;
		readonly uint number;
		readonly ITypeOrMethodDef genericParamProvider;

		/// <summary>
		/// <c>true</c> if it has an owner <see cref="TypeDef"/> or <see cref="MethodDef"/>
		/// </summary>
		public bool HasOwner {
			get { return genericParamProvider != null; }
		}

		/// <summary>
		/// <c>true</c> if it has an owner <see cref="TypeDef"/> (<see cref="OwnerType"/> is
		/// not <c>null</c>)
		/// </summary>
		public bool HasOwnerType {
			get { return OwnerType != null; }
		}

		/// <summary>
		/// <c>true</c> if it has an owner <see cref="MethodDef"/> (<see cref="OwnerMethod"/> is
		/// not <c>null</c>)
		/// </summary>
		public bool HasOwnerMethod {
			get { return OwnerMethod != null; }
		}

		/// <summary>
		/// Gets the owner type or <c>null</c> if the owner is a <see cref="MethodDef"/> or if it
		/// has no owner.
		/// </summary>
		public TypeDef OwnerType {
			get { return genericParamProvider as TypeDef; }
		}

		/// <summary>
		/// Gets the owner method or <c>null</c> if the owner is a <see cref="TypeDef"/> or if it
		/// has no owner.
		/// </summary>
		public MethodDef OwnerMethod {
			get { return genericParamProvider as MethodDef; }
		}

		/// <summary>
		/// Gets the generic param number
		/// </summary>
		public uint Number {
			get { return number; }
		}

		/// <summary>
		/// Gets the corresponding <see cref="dnlib.DotNet.GenericParam"/> or <c>null</c> if none exists.
		/// </summary>
		public GenericParam GenericParam {
			get {
				var gpp = genericParamProvider;
				if (gpp == null)
					return null;
				foreach (var gp in gpp.GenericParameters.GetSafeEnumerable()) {
					if (gp.Number == number)
						return gp;
				}
				return null;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isTypeVar"><c>true</c> if it's a <c>Var</c>, <c>false</c> if it's a <c>MVar</c></param>
		/// <param name="number">Generic param number</param>
		protected GenericSig(bool isTypeVar, uint number)
			: this(isTypeVar, number, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isTypeVar"><c>true</c> if it's a <c>Var</c>, <c>false</c> if it's a <c>MVar</c></param>
		/// <param name="number">Generic param number</param>
		/// <param name="genericParamProvider">Owner method/type or <c>null</c></param>
		protected GenericSig(bool isTypeVar, uint number, ITypeOrMethodDef genericParamProvider) {
			this.isTypeVar = isTypeVar;
			this.number = number;
			this.genericParamProvider = genericParamProvider;
		}

		/// <summary>
		/// Returns <c>true</c> if it's a <c>MVar</c> element type
		/// </summary>
		public bool IsMethodVar {
			get { return !isTypeVar; }
		}

		/// <summary>
		/// Returns <c>true</c> if it's a <c>Var</c> element type
		/// </summary>
		public bool IsTypeVar {
			get { return isTypeVar; }
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Var"/>
	/// </summary>
	public sealed class GenericVar : GenericSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.Var; }
		}

		/// <inheritdoc/>
		public GenericVar(uint number)
			: base(true, number) {
		}

		/// <inheritdoc/>
		public GenericVar(int number)
			: base(true, (uint)number) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">Generic parameter number</param>
		/// <param name="genericParamProvider">Owner type or <c>null</c></param>
		public GenericVar(uint number, TypeDef genericParamProvider)
			: base(true, number, genericParamProvider) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">Generic parameter number</param>
		/// <param name="genericParamProvider">Owner type or <c>null</c></param>
		public GenericVar(int number, TypeDef genericParamProvider)
			: base(true, (uint)number, genericParamProvider) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.MVar"/>
	/// </summary>
	public sealed class GenericMVar : GenericSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.MVar; }
		}

		/// <inheritdoc/>
		public GenericMVar(uint number)
			: base(false, number) {
		}

		/// <inheritdoc/>
		public GenericMVar(int number)
			: base(false, (uint)number) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">Generic parameter number</param>
		/// <param name="genericParamProvider">Owner method or <c>null</c></param>
		public GenericMVar(uint number, MethodDef genericParamProvider)
			: base(false, number, genericParamProvider) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">Generic parameter number</param>
		/// <param name="genericParamProvider">Owner method or <c>null</c></param>
		public GenericMVar(int number, MethodDef genericParamProvider)
			: base(false, (uint)number, genericParamProvider) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Sentinel"/>
	/// </summary>
	public sealed class SentinelSig : LeafSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.Sentinel; }
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.FnPtr"/>
	/// </summary>
	public sealed class FnPtrSig : LeafSig {
		readonly CallingConventionSig signature;

		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.FnPtr; }
		}

		/// <summary>
		/// Gets the signature
		/// </summary>
		public CallingConventionSig Signature {
			get { return signature; }
		}

		/// <summary>
		/// Gets the <see cref="MethodSig"/>
		/// </summary>
		public MethodSig MethodSig {
			get { return signature as MethodSig; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="signature">The method signature</param>
		public FnPtrSig(CallingConventionSig signature) {
			this.signature = signature;
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.GenericInst"/>
	/// </summary>
	public sealed class GenericInstSig : LeafSig {
		ClassOrValueTypeSig genericType;
		readonly ThreadSafe.IList<TypeSig> genericArgs;

		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.GenericInst; }
		}

		/// <summary>
		/// Gets the generic type
		/// </summary>
		public ClassOrValueTypeSig GenericType {
			get { return genericType; }
			set { genericType = value; }
		}

		/// <summary>
		/// Gets the generic arguments (it's never <c>null</c>)
		/// </summary>
		public ThreadSafe.IList<TypeSig> GenericArguments {
			get { return genericArgs; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public GenericInstSig() {
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		public GenericInstSig(ClassOrValueTypeSig genericType) {
			this.genericType = genericType;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArgCount">Number of generic arguments</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, uint genArgCount) {
			this.genericType = genericType;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>((int)genArgCount);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArgCount">Number of generic arguments</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, int genArgCount)
			: this(genericType, (uint)genArgCount) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArg1">Generic argument #1</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, TypeSig genArg1) {
			this.genericType = genericType;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(genArg1);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArg1">Generic argument #1</param>
		/// <param name="genArg2">Generic argument #2</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, TypeSig genArg1, TypeSig genArg2) {
			this.genericType = genericType;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(genArg1, genArg2);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArg1">Generic argument #1</param>
		/// <param name="genArg2">Generic argument #2</param>
		/// <param name="genArg3">Generic argument #3</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, TypeSig genArg1, TypeSig genArg2, TypeSig genArg3) {
			this.genericType = genericType;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(genArg1, genArg2, genArg3);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArgs">Generic arguments</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, params TypeSig[] genArgs) {
			this.genericType = genericType;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(genArgs);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArgs">Generic arguments</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, IList<TypeSig> genArgs) {
			this.genericType = genericType;
			this.genericArgs = ThreadSafeListCreator.Create<TypeSig>(genArgs);
		}
	}

	/// <summary>
	/// Base class of non-leaf element types
	/// </summary>
	public abstract class NonLeafSig : TypeSig {
		readonly TypeSig nextSig;

		/// <inheritdoc/>
		public sealed override TypeSig Next {
			get { return nextSig; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">Next sig</param>
		protected NonLeafSig(TypeSig nextSig) {
			this.nextSig = nextSig;
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Ptr"/>
	/// </summary>
	public sealed class PtrSig : NonLeafSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.Ptr; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		public PtrSig(TypeSig nextSig)
			: base(nextSig) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.ByRef"/>
	/// </summary>
	public sealed class ByRefSig : NonLeafSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.ByRef; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		public ByRefSig(TypeSig nextSig)
			: base(nextSig) {
		}
	}

	/// <summary>
	/// Array base class
	/// </summary>
	public abstract class ArraySigBase : NonLeafSig {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		protected ArraySigBase(TypeSig arrayType)
			: base(arrayType) {
		}

		/// <summary>
		/// <c>true</c> if it's a multi-dimensional array (i.e., <see cref="ArraySig"/>),
		/// and <c>false</c> if it's a single-dimensional array (i.e., <see cref="SZArraySig"/>)
		/// </summary>
		/// <seealso cref="IsSingleDimensional"/>
		public bool IsMultiDimensional {
			get { return ElementType == ElementType.Array; }
		}

		/// <summary>
		/// <c>true</c> if it's a single-dimensional array (i.e., <see cref="SZArraySig"/>),
		/// and <c>false</c> if it's a multi-dimensional array (i.e., <see cref="ArraySig"/>)
		/// </summary>
		/// <see cref="IsMultiDimensional"/>
		public bool IsSingleDimensional {
			get { return ElementType == ElementType.SZArray; }
		}

		/// <summary>
		/// Gets/sets the rank (number of dimensions). This can only be set if
		/// <see cref="IsMultiDimensional"/> is <c>true</c>
		/// </summary>
		public abstract uint Rank { get; set; }

		/// <summary>
		/// Gets all sizes. If it's a <see cref="SZArraySig"/>, then it will be an empty temporary
		/// list that is re-created every time this method is called.
		/// </summary>
		/// <returns>A list of sizes</returns>
		public abstract ThreadSafe.IList<uint> GetSizes();

		/// <summary>
		/// Gets all lower bounds. If it's a <see cref="SZArraySig"/>, then it will be an empty
		/// temporary list that is re-created every time this method is called.
		/// </summary>
		/// <returns>A list of lower bounds</returns>
		public abstract ThreadSafe.IList<int> GetLowerBounds();
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Array"/>
	/// </summary>
	/// <seealso cref="SZArraySig"/>
	public sealed class ArraySig : ArraySigBase {
		uint rank;
		readonly ThreadSafe.IList<uint> sizes;
		readonly ThreadSafe.IList<int> lowerBounds;

		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.Array; }
		}

		/// <summary>
		/// Gets/sets the rank (max value is <c>0x1FFFFFFF</c>)
		/// </summary>
		public override uint Rank {
			get { return rank; }
			set { rank = value; }
		}

		/// <summary>
		/// Gets all sizes (max elements is <c>0x1FFFFFFF</c>)
		/// </summary>
		public ThreadSafe.IList<uint> Sizes {
			get { return sizes; }
		}

		/// <summary>
		/// Gets all lower bounds (max elements is <c>0x1FFFFFFF</c>)
		/// </summary>
		public ThreadSafe.IList<int> LowerBounds {
			get { return lowerBounds; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		public ArraySig(TypeSig arrayType)
			: base(arrayType) {
			this.sizes = ThreadSafeListCreator.Create<uint>();
			this.lowerBounds = ThreadSafeListCreator.Create<int>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		public ArraySig(TypeSig arrayType, uint rank)
			: base(arrayType) {
			this.rank = rank;
			this.sizes = ThreadSafeListCreator.Create<uint>();
			this.lowerBounds = ThreadSafeListCreator.Create<int>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		public ArraySig(TypeSig arrayType, int rank)
			: this(arrayType, (uint)rank) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		/// <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
		/// <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
		public ArraySig(TypeSig arrayType, uint rank, IEnumerable<uint> sizes, IEnumerable<int> lowerBounds)
			: base(arrayType) {
			this.rank = rank;
			this.sizes = ThreadSafeListCreator.Create<uint>(sizes);
			this.lowerBounds = ThreadSafeListCreator.Create<int>(lowerBounds);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		/// <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
		/// <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
		public ArraySig(TypeSig arrayType, int rank, IEnumerable<uint> sizes, IEnumerable<int> lowerBounds)
			: this(arrayType, (uint)rank, sizes, lowerBounds) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		/// <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
		/// <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
		internal ArraySig(TypeSig arrayType, uint rank, IList<uint> sizes, IList<int> lowerBounds)
			: base(arrayType) {
			this.rank = rank;
			this.sizes = ThreadSafeListCreator.MakeThreadSafe(sizes);
			this.lowerBounds = ThreadSafeListCreator.MakeThreadSafe(lowerBounds);
		}

		/// <inheritdoc/>
		public override ThreadSafe.IList<uint> GetSizes() {
			return sizes;
		}

		/// <inheritdoc/>
		public override ThreadSafe.IList<int> GetLowerBounds() {
			return lowerBounds;
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.SZArray"/> (single dimension, zero lower bound array)
	/// </summary>
	/// <seealso cref="ArraySig"/>
	public sealed class SZArraySig : ArraySigBase {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.SZArray; }
		}

		/// <inheritdoc/>
		public override uint Rank {
			get { return 1; }
			set { throw new NotSupportedException(); }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		public SZArraySig(TypeSig nextSig)
			: base(nextSig) {
		}

		/// <inheritdoc/>
		public override ThreadSafe.IList<uint> GetSizes() {
			return ThreadSafeListCreator.Create<uint>();
		}

		/// <inheritdoc/>
		public override ThreadSafe.IList<int> GetLowerBounds() {
			return ThreadSafeListCreator.Create<int>();
		}
	}

	/// <summary>
	/// Base class for modifier type sigs
	/// </summary>
	public abstract class ModifierSig : NonLeafSig {
		readonly ITypeDefOrRef modifier;

		/// <summary>
		/// Returns the modifier type
		/// </summary>
		public ITypeDefOrRef Modifier {
			get { return modifier; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="modifier">Modifier type</param>
		/// <param name="nextSig">The next element type</param>
		protected ModifierSig(ITypeDefOrRef modifier, TypeSig nextSig)
			: base(nextSig) {
			this.modifier = modifier;
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.CModReqd"/>
	/// </summary>
	public sealed class CModReqdSig : ModifierSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.CModReqd; }
		}

		/// <inheritdoc/>
		public CModReqdSig(ITypeDefOrRef modifier, TypeSig nextSig)
			: base(modifier, nextSig) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.CModOpt"/>
	/// </summary>
	public sealed class CModOptSig : ModifierSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.CModOpt; }
		}

		/// <inheritdoc/>
		public CModOptSig(ITypeDefOrRef modifier, TypeSig nextSig)
			: base(modifier, nextSig) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Pinned"/>
	/// </summary>
	public sealed class PinnedSig : NonLeafSig {
		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.Pinned; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		public PinnedSig(TypeSig nextSig)
			: base(nextSig) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.ValueArray"/>
	/// </summary>
	public sealed class ValueArraySig : NonLeafSig {
		uint size;

		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.ValueArray; }
		}

		/// <summary>
		/// Gets/sets the size
		/// </summary>
		public uint Size {
			get { return size; }
			set { size = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		/// <param name="size">Size of the array</param>
		public ValueArraySig(TypeSig nextSig, uint size)
			: base(nextSig) {
			this.size = size;
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Module"/>
	/// </summary>
	public sealed class ModuleSig : NonLeafSig {
		uint index;

		/// <inheritdoc/>
		public override ElementType ElementType {
			get { return ElementType.Module; }
		}

		/// <summary>
		/// Gets/sets the index
		/// </summary>
		public uint Index {
			get { return index; }
			set { index = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="index">Index</param>
		/// <param name="nextSig">The next element type</param>
		public ModuleSig(uint index, TypeSig nextSig)
			: base(nextSig) {
			this.index = index;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/TypeSpec.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Threading;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the TypeSpec table
	/// </summary>
	public abstract class TypeSpec : ITypeDefOrRef, IHasCustomAttribute, IMemberRefParent, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken {
			get { return new MDToken(Table.TypeSpec, rid); }
		}

		/// <inheritdoc/>
		public uint Rid {
			get { return rid; }
			set { rid = value; }
		}

		/// <inheritdoc/>
		public int TypeDefOrRefTag {
			get { return 2; }
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag {
			get { return 13; }
		}

		/// <inheritdoc/>
		public int MemberRefParentTag {
			get { return 4; }
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get {
				var ts = TypeSig;
				return ts == null ? 0 : ((IGenericParameterProvider)ts).NumberOfGenericParameters;
			}
		}

		/// <inheritdoc/>
		UTF8String IFullName.Name {
			get {
				var mr = ScopeType;
				return mr == null ? UTF8String.Empty : mr.Name;
			}
			set {
				var mr = ScopeType;
				if (mr != null)
					mr.Name = value;
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get {
				var sig = TypeSig.RemovePinnedAndModifiers();

				var gis = sig as GenericInstSig;
				if (gis != null)
					sig = gis.GenericType;

				var tdr = sig as TypeDefOrRefSig;
				if (tdr != null) {
					if (tdr.IsTypeDef || tdr.IsTypeRef)
						return tdr.TypeDefOrRef.DeclaringType;
					return null;	// If it's another TypeSpec, just stop. Don't want possible inf recursion.
				}

				return null;
			}
		}

		bool IIsTypeOrMethod.IsType {
			get { return true; }
		}

		bool IIsTypeOrMethod.IsMethod {
			get { return false; }
		}

		bool IMemberRef.IsField {
			get { return false; }
		}

		bool IMemberRef.IsTypeSpec {
			get { return true; }
		}

		bool IMemberRef.IsTypeRef {
			get { return false; }
		}

		bool IMemberRef.IsTypeDef {
			get { return false; }
		}

		bool IMemberRef.IsMethodSpec {
			get { return false; }
		}

		bool IMemberRef.IsMethodDef {
			get { return false; }
		}

		bool IMemberRef.IsMemberRef {
			get { return false; }
		}

		bool IMemberRef.IsFieldDef {
			get { return false; }
		}

		bool IMemberRef.IsPropertyDef {
			get { return false; }
		}

		bool IMemberRef.IsEventDef {
			get { return false; }
		}

		bool IMemberRef.IsGenericParam {
			get { return false; }
		}

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				var sig = TypeSig;
				return sig != null && sig.IsValueType;
			}
		}

		/// <inheritdoc/>
		public bool IsPrimitive {
			get {
				var sig = TypeSig;
				return sig != null && sig.IsPrimitive;
			}
		}

		/// <inheritdoc/>
		public string TypeName {
			get { return FullNameCreator.Name(this, false, null); }
		}

		/// <inheritdoc/>
		public string ReflectionName {
			get { return FullNameCreator.Name(this, true, null); }
		}

		/// <inheritdoc/>
		string IType.Namespace {
			get { return FullNameCreator.Namespace(this, false, null); }
		}

		/// <inheritdoc/>
		public string ReflectionNamespace {
			get { return FullNameCreator.Namespace(this, true, null); }
		}

		/// <inheritdoc/>
		public string FullName {
			get { return FullNameCreator.FullName(this, false, null, null); }
		}

		/// <inheritdoc/>
		public string ReflectionFullName {
			get { return FullNameCreator.FullName(this, true, null, null); }
		}

		/// <inheritdoc/>
		public string AssemblyQualifiedName {
			get { return FullNameCreator.AssemblyQualifiedName(this, null, null); }
		}

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly {
			get { return FullNameCreator.DefinitionAssembly(this); }
		}

		/// <inheritdoc/>
		public IScope Scope {
			get { return FullNameCreator.Scope(this); }
		}

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType {
			get { return FullNameCreator.ScopeType(this); }
		}

		/// <inheritdoc/>
		public bool ContainsGenericParameter {
			get { return TypeHelper.ContainsGenericParameter(this); }
		}

		/// <inheritdoc/>
		public ModuleDef Module {
			get { return FullNameCreator.OwnerModule(this); }
		}

		/// <summary>
		/// From column TypeSpec.Signature
		/// </summary>
		public TypeSig TypeSig {
			get {
				if (!typeSigAndExtraData_isInitialized)
					InitializeTypeSigAndExtraData();
				return typeSig;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				typeSig = value;
				if (!typeSigAndExtraData_isInitialized)
					GetTypeSigAndExtraData_NoLock(out extraData);
				typeSigAndExtraData_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary>
		/// Gets/sets the extra data that was found after the signature
		/// </summary>
		public byte[] ExtraData {
			get {
				if (!typeSigAndExtraData_isInitialized)
					InitializeTypeSigAndExtraData();
				return extraData;
			}
			set {
				if (!typeSigAndExtraData_isInitialized)
					InitializeTypeSigAndExtraData();
				extraData = value;
			}
		}
		/// <summary/>
		protected TypeSig typeSig;
		/// <summary/>
		protected byte[] extraData;
		/// <summary/>
		protected bool typeSigAndExtraData_isInitialized;

		void InitializeTypeSigAndExtraData() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (typeSigAndExtraData_isInitialized)
				return;
			typeSig = GetTypeSigAndExtraData_NoLock(out extraData);
			typeSigAndExtraData_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="typeSig"/></summary>
		protected virtual TypeSig GetTypeSigAndExtraData_NoLock(out byte[] extraData) {
			extraData = null;
			return null;
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes == null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() {
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);
		}

		/// <inheritdoc/>
		public bool HasCustomAttributes {
			get { return CustomAttributes.Count > 0; }
		}


		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 13; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos == null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() {
			Interlocked.CompareExchange(ref customDebugInfos, ThreadSafeListCreator.Create<PdbCustomDebugInfo>(), null);
		}
		/// <inheritdoc/>
		public override string ToString() {
			return FullName;
		}
	}

	/// <summary>
	/// A TypeSpec row created by the user and not present in the original .NET file
	/// </summary>
	public class TypeSpecUser : TypeSpec {
		/// <summary>
		/// Default constructor
		/// </summary>
		public TypeSpecUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeSig">A type sig</param>
		public TypeSpecUser(TypeSig typeSig) {
			this.typeSig = typeSig;
			this.extraData = null;
			this.typeSigAndExtraData_isInitialized = true;
		}
	}

	/// <summary>
	/// Created from a row in the TypeSpec table
	/// </summary>
	sealed class TypeSpecMD : TypeSpec, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;
		readonly uint signatureOffset;

		/// <inheritdoc/>
		public uint OrigRid {
			get { return origRid; }
		}

		/// <inheritdoc/>
		protected override TypeSig GetTypeSigAndExtraData_NoLock(out byte[] extraData) {
			var sig = readerModule.ReadTypeSignature(signatureOffset, gpContext, out extraData);
			if (sig != null)
				sig.Rid = origRid;
			return sig;
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.MetaData.GetCustomAttributeRidList(Table.TypeSpec, origRid);
			var tmp = new CustomAttributeCollection((int)list.Length, list, (list2, index) => readerModule.ReadCustomAttribute(((RidList)list2)[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>TypeSpec</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public TypeSpecMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule == null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.TypeSpecTable.IsInvalidRID(rid))
				throw new BadImageFormatException(string.Format("TypeSpec rid {0} does not exist", rid));
#endif
			this.origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			this.signatureOffset = readerModule.TablesStream.ReadTypeSpecRow2(origRid);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/UTF8String.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Text;

namespace dnlib.DotNet {
	/// <summary>
	/// Compares <see cref="UTF8String"/>s
	/// </summary>
	public sealed class UTF8StringEqualityComparer : IEqualityComparer<UTF8String> {
		/// <summary>
		/// The default instance
		/// </summary>
		public static readonly UTF8StringEqualityComparer Instance = new UTF8StringEqualityComparer();

		/// <inheritdoc/>
		public bool Equals(UTF8String x, UTF8String y) {
			return UTF8String.Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(UTF8String obj) {
			return UTF8String.GetHashCode(obj);
		}
	}

	/// <summary>
	/// A UTF-8 encoded string where the original data is kept in memory to avoid conversions
	/// when the data is not really valid UTF-8 encoded data
	/// </summary>
	/// <remarks>When comparing strings, a byte compare is performed. The reason is that this
	/// is what the CLR does when comparing strings in the #Strings stream.</remarks>
	[DebuggerDisplay("{String}")]
	public sealed class UTF8String : IEquatable<UTF8String>, IComparable<UTF8String> {
		/// <summary>
		/// An empty <see cref="UTF8String"/>
		/// </summary>
		public static readonly UTF8String Empty = new UTF8String(string.Empty);

		readonly byte[] data;
		string asString;

		/// <summary>
		/// Gets the value as a UTF8 decoded string. Only use it for display purposes,
		/// not for serialization.
		/// </summary>
		public string String {
			get {
				if (asString == null)
					asString = ConvertFromUTF8(data);
				return asString;
			}
		}

		/// <summary>
		/// Gets the original encoded data. Don't modify this data.
		/// </summary>
		public byte[] Data {
			get { return data; }
		}

		/// <summary>
		/// Gets the length of the this as a <see cref="string"/>. I.e., it's the same as
		/// <c>String.Length</c>.
		/// </summary>
		/// <seealso cref="DataLength"/>
		public int Length {
			get { return String.Length; }
		}

		/// <summary>
		/// Gets the length of the raw data. It's the same as <c>Data.Length</c>
		/// </summary>
		/// <seealso cref="Length"/>
		public int DataLength {
			get { return data == null ? 0 : data.Length; }
		}

		/// <summary>
		/// Checks whether <paramref name="utf8"/> is <c>null</c> or if its data is <c>null</c>.
		/// </summary>
		/// <param name="utf8">The instance to check</param>
		/// <returns><c>true</c> if <c>null</c> or empty, <c>false</c> otherwise</returns>
		public static bool IsNull(UTF8String utf8) {
			return (object)utf8 == null || utf8.data == null;
		}

		/// <summary>
		/// Checks whether <paramref name="utf8"/> is <c>null</c> or if its data is <c>null</c> or the
		/// data is zero length.
		/// </summary>
		/// <param name="utf8">The instance to check</param>
		/// <returns><c>true</c> if <c>null</c> or empty, <c>false</c> otherwise</returns>
		public static bool IsNullOrEmpty(UTF8String utf8) {
			return (object)utf8 == null || utf8.data == null || utf8.data.Length == 0;
		}

		/// <summary>Implicit conversion from <see cref="UTF8String"/> to <see cref="string"/></summary>
		public static implicit operator string(UTF8String s) {
			return UTF8String.ToSystemString(s);
		}

		/// <summary>Implicit conversion from <see cref="string"/> to <see cref="UTF8String"/></summary>
		public static implicit operator UTF8String(string s) {
			return s == null ? null : new UTF8String(s);
		}

		/// <summary>
		/// Converts it to a <see cref="string"/>
		/// </summary>
		/// <param name="utf8">The UTF-8 string instace or <c>null</c></param>
		/// <returns>A <see cref="string"/> or <c>null</c> if <paramref name="utf8"/> is <c>null</c></returns>
		public static string ToSystemString(UTF8String utf8) {
			if ((object)utf8 == null || utf8.data == null)
				return null;
			if (utf8.data.Length == 0)
				return string.Empty;
			return utf8.String;
		}

		/// <summary>
		/// Converts it to a <see cref="string"/> or an empty string if <paramref name="utf8"/> is <c>null</c>
		/// </summary>
		/// <param name="utf8">The UTF-8 string instace or <c>null</c></param>
		/// <returns>A <see cref="string"/> (never <c>null</c>)</returns>
		public static string ToSystemStringOrEmpty(UTF8String utf8) {
			return ToSystemString(utf8) ?? string.Empty;
		}

		/// <summary>
		/// Gets the hash code of a <see cref="UTF8String"/>
		/// </summary>
		/// <param name="utf8">Input</param>
		public static int GetHashCode(UTF8String utf8) {
			if (IsNullOrEmpty(utf8))
				return 0;
			return Utils.GetHashCode(utf8.data);
		}

		/// <inheritdoc/>
		public int CompareTo(UTF8String other) {
			return CompareTo(this, other);
		}

		/// <summary>
		/// Compares two <see cref="UTF8String"/> instances (case sensitive)
		/// </summary>
		/// <param name="a">Instance #1 or <c>null</c></param>
		/// <param name="b">Instance #2 or <c>null</c></param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public static int CompareTo(UTF8String a, UTF8String b) {
			return Utils.CompareTo((object)a == null ? null : a.data, (object)b == null ? null : b.data);
		}

		/// <summary>
		/// Compares two <see cref="UTF8String"/> instances (case insensitive)
		/// </summary>
		/// <param name="a">Instance #1 or <c>null</c></param>
		/// <param name="b">Instance #2 or <c>null</c></param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public static int CaseInsensitiveCompareTo(UTF8String a, UTF8String b) {
			if ((object)a == (object)b)
				return 0;
			var sa = ToSystemString(a);
			var sb = ToSystemString(b);
			if ((object)sa == (object)sb)
				return 0;
			if (sa == null)
				return -1;
			if (sb == null)
				return 1;
			return StringComparer.OrdinalIgnoreCase.Compare(sa, sb);
		}

		/// <summary>
		/// Compares two <see cref="UTF8String"/> instances (case insensitive)
		/// </summary>
		/// <param name="a">Instance #1 or <c>null</c></param>
		/// <param name="b">Instance #2 or <c>null</c></param>
		/// <returns><c>true</c> if equals, <c>false</c> otherwise</returns>
		public static bool CaseInsensitiveEquals(UTF8String a, UTF8String b) {
			return CaseInsensitiveCompareTo(a, b) == 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(UTF8String left, UTF8String right) {
			return CompareTo(left, right) == 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(UTF8String left, string right) {
			return ToSystemString(left) == right;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(string left, UTF8String right) {
			return left == ToSystemString(right);
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(UTF8String left, UTF8String right) {
			return CompareTo(left, right) != 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(UTF8String left, string right) {
			return ToSystemString(left) != right;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(string left, UTF8String right) {
			return left != ToSystemString(right);
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator >(UTF8String left, UTF8String right) {
			return CompareTo(left, right) > 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator <(UTF8String left, UTF8String right) {
			return CompareTo(left, right) < 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator >=(UTF8String left, UTF8String right) {
			return CompareTo(left, right) >= 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator <=(UTF8String left, UTF8String right) {
			return CompareTo(left, right) <= 0;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">UTF-8 data that this instance now owns</param>
		public UTF8String(byte[] data) {
			this.data = data;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="s">The string</param>
		public UTF8String(string s)
			: this(s == null ? null : Encoding.UTF8.GetBytes(s)) {
		}

		static string ConvertFromUTF8(byte[] data) {
			if (data == null)
				return null;
			try {
				return Encoding.UTF8.GetString(data);
			}
			catch {
			}
			return null;
		}

		/// <summary>
		/// Compares two instances
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if equals, <c>false</c> otherwise</returns>
		public static bool Equals(UTF8String a, UTF8String b) {
			return CompareTo(a, b) == 0;
		}

		/// <inheritdoc/>
		public bool Equals(UTF8String other) {
			return CompareTo(this, other) == 0;
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			var other = obj as UTF8String;
			if ((object)other == null)
				return false;
			return CompareTo(this, other) == 0;
		}

		/// <summary>
		/// Checks whether <paramref name="value"/> exists in this string
		/// </summary>
		/// <param name="value">Value to find</param>
		/// <returns><c>true</c> if <paramref name="value"/> exists in string or is the
		/// empty string, else <c>false</c></returns>
		public bool Contains(string value) {
			return String.Contains(value);
		}

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the end of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public bool EndsWith(string value) {
			return String.EndsWith(value);
		}

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the end of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="ignoreCase"><c>true</c> to ignore case</param>
		/// <param name="culture">Culture info</param>
		/// <returns></returns>
		public bool EndsWith(string value, bool ignoreCase, CultureInfo culture) {
			return String.EndsWith(value, ignoreCase, culture);
		}

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the end of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns></returns>
		public bool EndsWith(string value, StringComparison comparisonType) {
			return String.EndsWith(value, comparisonType);
		}

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the beginning of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public bool StartsWith(string value) {
			return String.StartsWith(value);
		}

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the beginning of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="ignoreCase"><c>true</c> to ignore case</param>
		/// <param name="culture">Culture info</param>
		/// <returns></returns>
		public bool StartsWith(string value, bool ignoreCase, CultureInfo culture) {
			return String.StartsWith(value, ignoreCase, culture);
		}

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the beginning of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns></returns>
		public bool StartsWith(string value, StringComparison comparisonType) {
			return String.StartsWith(value, comparisonType);
		}

		/// <summary>
		/// Compares this instance with <paramref name="strB"/>
		/// </summary>
		/// <param name="strB">Other string</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public int CompareTo(string strB) {
			return String.CompareTo(strB);
		}

		/// <summary>
		/// Returns the index of the first character <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">Character</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(char value) {
			return String.IndexOf(value);
		}

		/// <summary>
		/// Returns the index of the first character <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">Character</param>
		/// <param name="startIndex">Start index</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(char value, int startIndex) {
			return String.IndexOf(value, startIndex);
		}

		/// <summary>
		/// Returns the index of the first character <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">Character</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(char value, int startIndex, int count) {
			return String.IndexOf(value, startIndex, count);
		}

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">String</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value) {
			return String.IndexOf(value);
		}

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, int startIndex) {
			return String.IndexOf(value, startIndex);
		}

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, int startIndex, int count) {
			return String.IndexOf(value, startIndex, count);
		}

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType) {
			return String.IndexOf(value, startIndex, count, comparisonType);
		}

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, int startIndex, StringComparison comparisonType) {
			return String.IndexOf(value, startIndex, comparisonType);
		}

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, StringComparison comparisonType) {
			return String.IndexOf(value, comparisonType);
		}

		/// <summary>
		/// Returns the index of the last character <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">Character</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(char value) {
			return String.LastIndexOf(value);
		}

		/// <summary>
		/// Returns the index of the last character <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">Character</param>
		/// <param name="startIndex">Start index</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(char value, int startIndex) {
			return String.LastIndexOf(value, startIndex);
		}

		/// <summary>
		/// Returns the index of the last character <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">Character</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(char value, int startIndex, int count) {
			return String.LastIndexOf(value, startIndex, count);
		}

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">String</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value) {
			return String.LastIndexOf(value);
		}

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, int startIndex) {
			return String.LastIndexOf(value, startIndex);
		}

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, int startIndex, int count) {
			return String.LastIndexOf(value, startIndex, count);
		}

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType) {
			return String.LastIndexOf(value, startIndex, count, comparisonType);
		}

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, int startIndex, StringComparison comparisonType) {
			return String.LastIndexOf(value, startIndex, comparisonType);
		}

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, StringComparison comparisonType) {
			return String.LastIndexOf(value, comparisonType);
		}

		/// <summary>
		/// Inserts string <paramref name="value"/> at a index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <param name="value">Value to insert</param>
		/// <returns>A new instance with the <paramref name="value"/> inserted at position
		/// <paramref name="startIndex"/></returns>
		public UTF8String Insert(int startIndex, string value) {
			return new UTF8String(String.Insert(startIndex, value));
		}

		/// <summary>
		/// Removes all characters starting from position <paramref name="startIndex"/>
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <returns>A new instance</returns>
		public UTF8String Remove(int startIndex) {
			return new UTF8String(String.Remove(startIndex));
		}

		/// <summary>
		/// Removes <paramref name="count"/> characters starting from position
		/// <paramref name="startIndex"/>
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Number of characters to remove</param>
		/// <returns>A new instance</returns>
		public UTF8String Remove(int startIndex, int count) {
			return new UTF8String(String.Remove(startIndex, count));
		}

		/// <summary>
		/// Replaces all characters <paramref name="oldChar"/> with <paramref name="newChar"/>
		/// </summary>
		/// <param name="oldChar">Character to find</param>
		/// <param name="newChar">Character to replace all <paramref name="oldChar"/></param>
		/// <returns>A new instance</returns>
		public UTF8String Replace(char oldChar, char newChar) {
			return new UTF8String(String.Replace(oldChar, newChar));
		}

		/// <summary>
		/// Replaces all sub strings <paramref name="oldValue"/> with <paramref name="newValue"/>
		/// </summary>
		/// <param name="oldValue">Sub string to find</param>
		/// <param name="newValue">Sub string to replace all <paramref name="oldValue"/></param>
		/// <returns>A new instance</returns>
		public UTF8String Replace(string oldValue, string newValue) {
			return new UTF8String(String.Replace(oldValue, newValue));
		}

		/// <summary>
		/// Returns a sub string of this string starting at offset <paramref name="startIndex"/>
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <returns>A new instance</returns>
		public UTF8String Substring(int startIndex) {
			return new UTF8String(String.Substring(startIndex));
		}

		/// <summary>
		/// Returns a sub string of this string starting at offset <paramref name="startIndex"/>.
		/// Length of sub string is <paramref name="length"/>.
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <param name="length">Length of sub string</param>
		/// <returns>A new instance</returns>
		public UTF8String Substring(int startIndex, int length) {
			return new UTF8String(String.Substring(startIndex, length));
		}

		/// <summary>
		/// Returns the lower case version of this string
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String ToLower() {
			return new UTF8String(String.ToLower());
		}

		/// <summary>
		/// Returns the lower case version of this string
		/// </summary>
		/// <param name="culture">Culture info</param>
		/// <returns>A new instance</returns>
		public UTF8String ToLower(CultureInfo culture) {
			return new UTF8String(String.ToLower(culture));
		}

		/// <summary>
		/// Returns the lower case version of this string using the invariant culture
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String ToLowerInvariant() {
			return new UTF8String(String.ToLowerInvariant());
		}

		/// <summary>
		/// Returns the upper case version of this string
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String ToUpper() {
			return new UTF8String(String.ToUpper());
		}

		/// <summary>
		/// Returns the upper case version of this string
		/// </summary>
		/// <param name="culture">Culture info</param>
		/// <returns>A new instance</returns>
		public UTF8String ToUpper(CultureInfo culture) {
			return new UTF8String(String.ToUpper(culture));
		}

		/// <summary>
		/// Returns the upper case version of this string using the invariant culture
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String ToUpperInvariant() {
			return new UTF8String(String.ToUpperInvariant());
		}

		/// <summary>
		/// Removes all leading and trailing whitespace characters
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String Trim() {
			return new UTF8String(String.Trim());
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			return UTF8String.GetHashCode(this);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return String;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Utils.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace dnlib.DotNet {
	/// <summary>
	/// Compares byte arrays
	/// </summary>
	public sealed class ByteArrayEqualityComparer : IEqualityComparer<byte[]> {
		/// <summary>
		/// Default instance
		/// </summary>
		public static readonly ByteArrayEqualityComparer Instance = new ByteArrayEqualityComparer();

		/// <inheritdoc/>
		public bool Equals(byte[] x, byte[] y) {
			return Utils.Equals(x, y);
		}

		/// <inheritdoc/>
		public int GetHashCode(byte[] obj) {
			return Utils.GetHashCode(obj);
		}
	}

	static class Utils {
		/// <summary>
		/// Returns an assembly name string
		/// </summary>
		/// <param name="name">Simple assembly name</param>
		/// <param name="version">Version or <c>null</c></param>
		/// <param name="culture">Culture or <c>null</c></param>
		/// <param name="publicKey">Public key / public key token or <c>null</c></param>
		/// <param name="attributes">Assembly attributes</param>
		/// <returns>An assembly name string</returns>
		internal static string GetAssemblyNameString(UTF8String name, Version version, UTF8String culture, PublicKeyBase publicKey, AssemblyAttributes attributes) {
			var sb = new StringBuilder();

			foreach (var c in UTF8String.ToSystemStringOrEmpty(name)) {
				if (c == ',' || c == '=')
					sb.Append('\\');
				sb.Append(c);
			}

			if (version != null) {
				sb.Append(", Version=");
				sb.Append(CreateVersionWithNoUndefinedValues(version).ToString());
			}

			if ((object)culture != null) {
				sb.Append(", Culture=");
				sb.Append(UTF8String.IsNullOrEmpty(culture) ? "neutral" : culture.String);
			}

			sb.Append(", ");
			sb.Append(publicKey == null || publicKey is PublicKeyToken ? "PublicKeyToken=" : "PublicKey=");
			sb.Append(publicKey == null ? "null" : publicKey.ToString());

			if ((attributes & AssemblyAttributes.Retargetable) != 0)
				sb.Append(", Retargetable=Yes");

			if ((attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_WindowsRuntime)
				sb.Append(", ContentType=WindowsRuntime");

			return sb.ToString();
		}

		/// <summary>
		/// Convert a byte[] to a <see cref="string"/>
		/// </summary>
		/// <param name="bytes">All bytes</param>
		/// <param name="upper"><c>true</c> if output should be in upper case hex</param>
		/// <returns><paramref name="bytes"/> as a hex string</returns>
		internal static string ToHex(byte[] bytes, bool upper) {
			if (bytes == null)
				return "";
			var chars = new char[bytes.Length * 2];
			for (int i = 0, j = 0; i < bytes.Length; i++) {
				byte b = bytes[i];
				chars[j++] = ToHexChar(b >> 4, upper);
				chars[j++] = ToHexChar(b & 0x0F, upper);
			}
			return new string(chars);
		}

		static char ToHexChar(int val, bool upper) {
			if (0 <= val && val <= 9)
				return (char)(val + (int)'0');
			return (char)(val - 10 + (upper ? (int)'A' : (int)'a'));
		}

		/// <summary>
		/// Converts a hex string to a byte[]
		/// </summary>
		/// <param name="hexString">A string with an even number of hex characters</param>
		/// <returns><paramref name="hexString"/> converted to a byte[] or <c>null</c>
		/// if <paramref name="hexString"/> is invalid</returns>
		internal static byte[] ParseBytes(string hexString) {
			try {
				if (hexString.Length % 2 != 0)
					return null;
				var bytes = new byte[hexString.Length / 2];
				for (int i = 0; i < hexString.Length; i += 2) {
					int upper = TryParseHexChar(hexString[i]);
					int lower = TryParseHexChar(hexString[i + 1]);
					if (upper < 0 || lower < 0)
						return null;
					bytes[i / 2] = (byte)((upper << 4) | lower);
				}
				return bytes;
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Converts a character to a hex digit
		/// </summary>
		/// <param name="c">Hex character</param>
		/// <returns><c>0x00</c>-<c>0x0F</c> if successful, <c>-1</c> if <paramref name="c"/> is not
		/// a valid hex digit</returns>
		static int TryParseHexChar(char c) {
			if ('0' <= c && c <= '9')
				return (ushort)c - (ushort)'0';
			if ('a' <= c && c <= 'f')
				return 10 + (ushort)c - (ushort)'a';
			if ('A' <= c && c <= 'F')
				return 10 + (ushort)c - (ushort)'A';
			return -1;
		}

		/// <summary>
		/// Compares two byte arrays
		/// </summary>
		/// <param name="a">Byte array #1</param>
		/// <param name="b">Byte array #2</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		internal static int CompareTo(byte[] a, byte[] b) {
			if (a == b)
				return 0;
			if (a == null)
				return -1;
			if (b == null)
				return 1;
			int count = Math.Min(a.Length, b.Length);
			for (int i = 0; i < count; i++) {
				var ai = a[i];
				var bi = b[i];
				if (ai < bi)
					return -1;
				if (ai > bi)
					return 1;
			}
			return a.Length.CompareTo(b.Length);
		}

		/// <summary>
		/// Checks whether two byte arrays are equal
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal static bool Equals(byte[] a, byte[] b) {
			return CompareTo(a, b) == 0;
		}

		/// <summary>
		/// Gets the hash code of a byte array
		/// </summary>
		/// <param name="a">Byte array</param>
		/// <returns>The hash code</returns>
		internal static int GetHashCode(byte[] a) {
			if (a == null || a.Length == 0)
				return 0;
			int count = Math.Min(a.Length / 2, 20);
			if (count == 0)
				count = 1;
			uint hash = 0;
			for (int i = 0, j = a.Length - 1; i < count; i++, j--) {
				hash ^= a[i] | ((uint)a[j] << 8);
				hash = (hash << 13) | (hash >> 19);
			}
			return (int)hash;
		}

		/// <summary>
		/// Compares two versions
		/// </summary>
		/// <remarks>This differs from <see cref="System.Version.CompareTo(Version)"/> if the build
		/// and/or revision numbers haven't been initialized or if one of the args is <c>null</c>.
		/// </remarks>
		/// <param name="a">Version #1 or <c>null</c> to be treated as v0.0.0.0</param>
		/// <param name="b">Version #2 or <c>null</c> to be treated as v0.0.0.0</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		internal static int CompareTo(Version a, Version b) {
			if (a == null)
				a = new Version();
			if (b == null)
				b = new Version();
			if (a.Major != b.Major)
				return a.Major.CompareTo(b.Major);
			if (a.Minor != b.Minor)
				return a.Minor.CompareTo(b.Minor);
			if (GetDefaultVersionValue(a.Build) != GetDefaultVersionValue(b.Build))
				return GetDefaultVersionValue(a.Build).CompareTo(GetDefaultVersionValue(b.Build));
			return GetDefaultVersionValue(a.Revision).CompareTo(GetDefaultVersionValue(b.Revision));
		}

		/// <summary>
		/// Checks whether two versions are the same
		/// </summary>
		/// <remarks>This differs from <see cref="System.Version.Equals(Version)"/> if the build
		/// and/or revision numbers haven't been initialized or if one of the args is <c>null</c>.
		/// </remarks>
		/// <param name="a">Version #1 or <c>null</c> to be treated as v0.0.0.0</param>
		/// <param name="b">Version #2 or <c>null</c> to be treated as v0.0.0.0</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal static bool Equals(Version a, Version b) {
			return CompareTo(a, b) == 0;
		}

		/// <summary>
		/// Creates a new <see cref="Version"/> instance with no undefined version values (eg.
		/// the build and revision values won't be -1).
		/// </summary>
		/// <param name="a">A <see cref="Version"/> instance</param>
		/// <returns>A new <see cref="Version"/> instance</returns>
		internal static Version CreateVersionWithNoUndefinedValues(Version a) {
			if (a == null)
				return new Version(0, 0, 0, 0);
			return new Version(a.Major, a.Minor, GetDefaultVersionValue(a.Build), GetDefaultVersionValue(a.Revision));
		}

		static int GetDefaultVersionValue(int val) {
			return val == -1 ? 0 : val;
		}

		/// <summary>
		/// Parses a version string
		/// </summary>
		/// <param name="versionString">Version string</param>
		/// <returns>A new <see cref="Version"/> or <c>null</c> if <paramref name="versionString"/>
		/// is an invalid version</returns>
		internal static Version ParseVersion(string versionString) {
			try {
				return Utils.CreateVersionWithNoUndefinedValues(new Version(versionString));
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Compares two locales (cultures)
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		internal static int LocaleCompareTo(UTF8String a, UTF8String b) {
			return GetCanonicalLocale(a).CompareTo(GetCanonicalLocale(b));
		}

		/// <summary>
		/// Compares two locales (cultures)
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal static bool LocaleEquals(UTF8String a, UTF8String b) {
			return LocaleCompareTo(a, b) == 0;
		}

		/// <summary>
		/// Compares two locales (cultures)
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		internal static int LocaleCompareTo(UTF8String a, string b) {
			return GetCanonicalLocale(a).CompareTo(GetCanonicalLocale(b));
		}

		/// <summary>
		/// Compares two locales (cultures)
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal static bool LocaleEquals(UTF8String a, string b) {
			return LocaleCompareTo(a, b) == 0;
		}

		/// <summary>
		/// Gets the hash code of a locale
		/// </summary>
		/// <param name="a">Value</param>
		/// <returns>The hash code</returns>
		internal static int GetHashCodeLocale(UTF8String a) {
			return GetCanonicalLocale(a).GetHashCode();
		}

		static string GetCanonicalLocale(UTF8String locale) {
			return GetCanonicalLocale(UTF8String.ToSystemStringOrEmpty(locale));
		}

		static string GetCanonicalLocale(string locale) {
			var s = locale.ToUpperInvariant();
			if (s == "NEUTRAL")
				s = string.Empty;
			return s;
		}

		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="v">Value</param>
		/// <param name="alignment">Alignment</param>
		public static uint AlignUp(uint v, uint alignment) {
			return (v + alignment - 1) & ~(alignment - 1);
		}

		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="v">Value</param>
		/// <param name="alignment">Alignment</param>
		public static int AlignUp(int v, uint alignment) {
			return (int)AlignUp((uint)v, alignment);
		}

		/// <summary>
		/// Gets length of compressed integer
		/// </summary>
		/// <param name="value">Integer</param>
		/// <returns>Size of compressed integer in bytes (1, 2 or 4 bytes)</returns>
		/// <exception cref="ArgumentOutOfRangeException"><paramref name="value"/> can't be compressed (too big)</exception>
		public static int GetCompressedUInt32Length(uint value) {
			if (value <= 0x7F)
				return 1;
			if (value <= 0x3FFF)
				return 2;
			if (value <= 0x1FFFFFFF)
				return 4;
			throw new ArgumentOutOfRangeException("UInt32 value can't be compressed");
		}

		/// <summary>
		/// Writes a compressed <see cref="UInt32"/>
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="value">Value</param>
		/// <exception cref="ArgumentOutOfRangeException"><paramref name="value"/> can't be compressed (too big)</exception>
		public static void WriteCompressedUInt32(this BinaryWriter writer, uint value) {
			if (value <= 0x7F)
				writer.Write((byte)value);
			else if (value <= 0x3FFF) {
				writer.Write((byte)((value >> 8) | 0x80));
				writer.Write((byte)value);
			}
			else if (value <= 0x1FFFFFFF) {
				writer.Write((byte)((value >> 24) | 0xC0));
				writer.Write((byte)(value >> 16));
				writer.Write((byte)(value >> 8));
				writer.Write((byte)value);
			}
			else
				throw new ArgumentOutOfRangeException("UInt32 value can't be compressed");
		}

		/// <summary>
		/// Writes a compressed <see cref="Int32"/>
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="value">Value</param>
		/// <exception cref="ArgumentOutOfRangeException"><paramref name="value"/> can't be compressed (too big/small)</exception>
		public static void WriteCompressedInt32(this BinaryWriter writer, int value) {
			// This is almost identical to compressing a UInt32, except that we first
			// recode value so the sign bit is in bit 0. Then we compress it the same
			// way a UInt32 is compressed.
			uint sign = (uint)value >> 31;
			if (-0x40 <= value && value <= 0x3F) {
				uint v = (uint)((value & 0x3F) << 1) | sign;
				writer.Write((byte)v);
			}
			else if (-0x2000 <= value && value <= 0x1FFF) {
				uint v = ((uint)(value & 0x1FFF) << 1) | sign;
				writer.Write((byte)((v >> 8) | 0x80));
				writer.Write((byte)v);
			}
			else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {
				uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;
				writer.Write((byte)((v >> 24) | 0xC0));
				writer.Write((byte)(v >> 16));
				writer.Write((byte)(v >> 8));
				writer.Write((byte)v);
			}
			else
				throw new ArgumentOutOfRangeException("Int32 value can't be compressed");
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/VTableFixups.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.PE;
using dnlib.IO;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet {
	/// <summary>
	/// All native vtables
	/// </summary>
	[DebuggerDisplay("RVA = {RVA}, Count = {VTables.Count}")]
	public sealed class VTableFixups : IEnumerable<VTable> {
		RVA rva;
		ThreadSafe.IList<VTable> vtables;

		/// <summary>
		/// Gets/sets the RVA of the vtable fixups
		/// </summary>
		public RVA RVA {
			get { return rva; }
			set { rva = value; }
		}

		/// <summary>
		/// Gets all <see cref="VTable"/>s
		/// </summary>
		public ThreadSafe.IList<VTable> VTables {
			get { return vtables; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public VTableFixups() {
			this.vtables = ThreadSafeListCreator.Create<VTable>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module</param>
		public VTableFixups(ModuleDefMD module) {
			Initialize(module);
		}

		void Initialize(ModuleDefMD module) {
			var info = module.MetaData.ImageCor20Header.VTableFixups;
			if (info.VirtualAddress == 0 || info.Size == 0) {
				this.vtables = ThreadSafeListCreator.Create<VTable>();
				return;
			}
			this.rva = info.VirtualAddress;
			this.vtables = ThreadSafeListCreator.Create<VTable>((int)info.Size / 8);

			var peImage = module.MetaData.PEImage;
			using (var reader = peImage.CreateFullStream()) {
				reader.Position = (long)peImage.ToFileOffset(info.VirtualAddress);
				long endPos = reader.Position + info.Size;
				while (reader.Position + 8 <= endPos && reader.CanRead(8)) {
					RVA tableRva = (RVA)reader.ReadUInt32();
					int numSlots = reader.ReadUInt16();
					var flags = (VTableFlags)reader.ReadUInt16();
					var vtable = new VTable(tableRva, flags, numSlots);
					vtables.Add(vtable);

					var pos = reader.Position;
					reader.Position = (long)peImage.ToFileOffset(tableRva);
					int slotSize = vtable.Is64Bit ? 8 : 4;
					while (numSlots-- > 0 && reader.CanRead(slotSize)) {
						vtable.Methods.Add(module.ResolveToken(reader.ReadUInt32()) as IMethod);
						if (slotSize == 8)
							reader.ReadUInt32();
					}
					reader.Position = pos;
				}
			}
		}

		/// <inheritdoc/>
		public IEnumerator<VTable> GetEnumerator() {
			return vtables.GetEnumerator();
		}

		/// <inheritdoc/>
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}
	}

	/// <summary>
	/// See COR_VTABLE_XXX in CorHdr.h
	/// </summary>
	[Flags]
	public enum VTableFlags : ushort {
		/// <summary>
		/// 32-bit vtable slots
		/// </summary>
		_32Bit				= 0x01,

		/// <summary>
		/// 64-bit vtable slots
		/// </summary>
		_64Bit				= 0x02,

		/// <summary>
		/// Transition from unmanaged code
		/// </summary>
		FromUnmanaged		= 0x04,

		/// <summary>
		/// Also retain app domain
		/// </summary>
		FromUnmanagedRetainAppDomain = 0x08,

		/// <summary>
		/// Call most derived method
		/// </summary>
		CallMostDerived		= 0x10,
	}

	/// <summary>
	/// One VTable accessed by native code
	/// </summary>
	public sealed class VTable : IEnumerable<IMethod> {
		RVA rva;
		VTableFlags flags;
		readonly ThreadSafe.IList<IMethod> methods;

		/// <summary>
		/// Gets/sets the <see cref="RVA"/> of this vtable
		/// </summary>
		public RVA RVA {
			get { return rva; }
			set { rva = value; }
		}

		/// <summary>
		/// Gets/sets the flags
		/// </summary>
		public VTableFlags Flags {
			get { return flags; }
			set { flags = value; }
		}

		/// <summary>
		/// <c>true</c> if each vtable slot is 32 bits in size
		/// </summary>
		public bool Is32Bit {
			get { return (flags & VTableFlags._32Bit) != 0; }
		}

		/// <summary>
		/// <c>true</c> if each vtable slot is 64 bits in size
		/// </summary>
		public bool Is64Bit {
			get { return (flags & VTableFlags._64Bit) != 0; }
		}

		/// <summary>
		/// Gets the vtable methods
		/// </summary>
		public ThreadSafe.IList<IMethod> Methods {
			get { return methods; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public VTable() {
			this.methods = ThreadSafeListCreator.Create<IMethod>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Flags</param>
		public VTable(VTableFlags flags) {
			this.flags = flags;
			this.methods = ThreadSafeListCreator.Create<IMethod>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rva">RVA of this vtable</param>
		/// <param name="flags">Flgas</param>
		/// <param name="numSlots">Number of methods in vtable</param>
		public VTable(RVA rva, VTableFlags flags, int numSlots) {
			this.rva = rva;
			this.flags = flags;
			this.methods = ThreadSafeListCreator.Create<IMethod>(numSlots);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rva">RVA of this vtable</param>
		/// <param name="flags">Flgas</param>
		/// <param name="methods">Vtable methods</param>
		public VTable(RVA rva, VTableFlags flags, IEnumerable<IMethod> methods) {
			this.rva = rva;
			this.flags = flags;
			this.methods = ThreadSafeListCreator.Create<IMethod>(methods);
		}

		/// <inheritdoc/>
		public IEnumerator<IMethod> GetEnumerator() {
			return methods.GetEnumerator();
		}

		/// <inheritdoc/>
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}

		/// <inheritdoc/>
		public override string ToString() {
			if (methods.Count == 0)
				return string.Format("{0} {1:X8}", methods.Count, (uint)rva);
			return string.Format("{0} {1:X8} {2}", methods.Count, (uint)rva, methods.Get(0, null));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/VariantType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet {
	/// <summary>
	/// Variant type (<c>VT_XXX</c> in the Windows SDK)
	/// </summary>
	public enum VariantType : uint {
		/// <summary/>
		Empty			= 0,
		/// <summary/>
		None			= 0,
		/// <summary/>
		Null			= 1,
		/// <summary/>
		I2				= 2,
		/// <summary/>
		I4				= 3,
		/// <summary/>
		R4				= 4,
		/// <summary/>
		R8				= 5,
		/// <summary/>
		CY				= 6,
		/// <summary/>
		Date			= 7,
		/// <summary/>
		BStr			= 8,
		/// <summary/>
		Dispatch		= 9,
		/// <summary/>
		Error			= 10,
		/// <summary/>
		Bool			= 11,
		/// <summary/>
		Variant			= 12,
		/// <summary/>
		Unknown			= 13,
		/// <summary/>
		Decimal			= 14,
		/// <summary/>
		I1				= 16,
		/// <summary/>
		UI1				= 17,
		/// <summary/>
		UI2				= 18,
		/// <summary/>
		UI4				= 19,
		/// <summary/>
		I8				= 20,
		/// <summary/>
		UI8				= 21,
		/// <summary/>
		Int				= 22,
		/// <summary/>
		UInt			= 23,
		/// <summary/>
		Void			= 24,
		/// <summary/>
		HResult			= 25,
		/// <summary/>
		Ptr				= 26,
		/// <summary/>
		SafeArray		= 27,
		/// <summary/>
		CArray			= 28,
		/// <summary/>
		UserDefined		= 29,
		/// <summary/>
		LPStr			= 30,
		/// <summary/>
		LPWStr			= 31,
		/// <summary/>
		Record			= 36,
		/// <summary/>
		IntPtr			= 37,
		/// <summary/>
		UIntPtr			= 38,
		/// <summary/>
		FileTime		= 64,
		/// <summary/>
		Blob			= 65,
		/// <summary/>
		Stream			= 66,
		/// <summary/>
		Storage			= 67,
		/// <summary/>
		StreamedObject	= 68,
		/// <summary/>
		StoredObject	= 69,
		/// <summary/>
		BlobObject		= 70,
		/// <summary/>
		CF				= 71,
		/// <summary/>
		CLSID			= 72,
		/// <summary/>
		VersionedStream	= 73,
		/// <summary/>
		BStrBlob		= 0x0FFF,
		/// <summary/>
		Vector			= 0x1000,
		/// <summary/>
		Array			= 0x2000,
		/// <summary/>
		ByRef			= 0x4000,
		/// <summary/>
		Reserved		= 0x8000,
		/// <summary/>
		Illegal			= 0xFFFF,
		/// <summary/>
		IllegalMasked	= 0x0FFF,
		/// <summary/>
		TypeMask		= 0x0FFF,
		/// <summary>This wasn't present in the blob</summary>
		NotInitialized	= 0xFFFFFFFF,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/WinMDHelpers.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;

namespace dnlib.DotNet {
	enum ClrAssembly {
		Mscorlib,
		SystemNumericsVectors,
		SystemObjectModel,
		SystemRuntime,
		SystemRuntimeInteropServicesWindowsRuntime,
		SystemRuntimeWindowsRuntime,
		SystemRuntimeWindowsRuntimeUIXaml,
	}

	static class WinMDHelpers {
		struct ClassName : IEquatable<ClassName> {
			public readonly UTF8String Namespace;
			public readonly UTF8String Name;
			// Not used when comparing for equality etc
			public readonly bool IsValueType;

			public ClassName(UTF8String ns, UTF8String name, bool isValueType = false) {
				this.Namespace = ns;
				this.Name = name;
				this.IsValueType = isValueType;
			}

			public ClassName(string ns, string name, bool isValueType = false) {
				this.Namespace = ns;
				this.Name = name;
				this.IsValueType = isValueType;
			}

			public static bool operator ==(ClassName a, ClassName b) {
				return a.Equals(b);
			}

			public static bool operator !=(ClassName a, ClassName b) {
				return !a.Equals(b);
			}

			public bool Equals(ClassName other) {
				// Don't check IsValueType
				return UTF8String.Equals(Namespace, other.Namespace) &&
					UTF8String.Equals(Name, other.Name);
			}

			public override bool Equals(object obj) {
				if (!(obj is ClassName))
					return false;
				return Equals((ClassName)obj);
			}

			public override int GetHashCode() {
				// Don't use IsValueType
				return UTF8String.GetHashCode(Namespace) ^ UTF8String.GetHashCode(Name);
			}

			public override string ToString() {
				return string.Format("{0}.{1}", Namespace, Name);
			}
		}

		sealed class ProjectedClass {
			public readonly ClassName WinMDClass;
			public readonly ClassName ClrClass;
			public readonly ClrAssembly ClrAssembly;
			public readonly ClrAssembly ContractAssembly;

			public ProjectedClass(string mdns, string mdname, string clrns, string clrname, ClrAssembly clrAsm, ClrAssembly contractAsm, bool winMDValueType, bool clrValueType) {
				this.WinMDClass = new ClassName(mdns, mdname, winMDValueType);
				this.ClrClass = new ClassName(clrns, clrname, clrValueType);
				this.ClrAssembly = clrAsm;
				this.ContractAssembly = contractAsm;
			}

			public override string ToString() {
				return string.Format("{0} <-> {1}, {2}", WinMDClass, ClrClass, CreateAssembly(null, ContractAssembly));
			}
		}

		// See https://github.com/dotnet/coreclr/blob/master/src/inc/winrtprojectedtypes.h
		// To generate this code replace the contents of src/inc/winrtprojectedtypes.h with:
		//	DEFINE_PROJECTED_ENUM
		//	=>	DEFINE_PROJECTED_STRUCT
		//	^DEFINE_PROJECTED\w*_STRUCT\s*\(("[^"]+"),\s*("[^"]+"),\s*("[^"]+"),\s*("[^"]+"),\s*(\w+),\s*(\w+).*$
		//	=>	\t\t\tnew ProjectedClass(\1, \2, \3, \4, ClrAssembly.\5, ClrAssembly.\6, true, true),
		//	^DEFINE_PROJECTED\w+\s*\(("[^"]+"),\s*("[^"]+"),\s*("[^"]+"),\s*("[^"]+"),\s*(\w+),\s*(\w+).*$
		//	=>	\t\t\tnew ProjectedClass(\1, \2, \3, \4, ClrAssembly.\5, ClrAssembly.\6, false, false),
		// Sometimes the types aren't both structs or both classes. Known cases:
		//		IReference`1 (class)	vs	Nullable`1 (struct)
		//		IKeyValuePair`2 (class)	vs	KeyValuePair`2 (struct)
		//		TypeName (struct)		vs	Type (class)
		//		HResult (struct)		vs	Exception (class)
		// See md/winmd/adapter.cpp WinMDAdapter::RewriteTypeInSignature() or check the types
		// in a decompiler.
		static readonly ProjectedClass[] ProjectedClasses = new ProjectedClass[] {
			new ProjectedClass("Windows.Foundation.Metadata", "AttributeUsageAttribute", "System", "AttributeUsageAttribute", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Metadata", "AttributeTargets", "System", "AttributeTargets", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, true),

			new ProjectedClass("Windows.UI", "Color", "Windows.UI", "Color", ClrAssembly.SystemRuntimeWindowsRuntime, ClrAssembly.SystemRuntimeWindowsRuntime, true, true),

			new ProjectedClass("Windows.Foundation", "DateTime", "System", "DateTimeOffset", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "EventHandler`1", "System", "EventHandler`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation", "EventRegistrationToken", "System.Runtime.InteropServices.WindowsRuntime", "EventRegistrationToken", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntimeInteropServicesWindowsRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "HResult", "System", "Exception", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, false),
			new ProjectedClass("Windows.Foundation", "IReference`1", "System", "Nullable`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, true),
			new ProjectedClass("Windows.Foundation", "Point", "Windows.Foundation", "Point", ClrAssembly.SystemRuntimeWindowsRuntime, ClrAssembly.SystemRuntimeWindowsRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "Rect", "Windows.Foundation", "Rect", ClrAssembly.SystemRuntimeWindowsRuntime, ClrAssembly.SystemRuntimeWindowsRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "Size", "Windows.Foundation", "Size", ClrAssembly.SystemRuntimeWindowsRuntime, ClrAssembly.SystemRuntimeWindowsRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "TimeSpan", "System", "TimeSpan", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "Uri", "System", "Uri", ClrAssembly.SystemRuntime, ClrAssembly.SystemRuntime, false, false),

			new ProjectedClass("Windows.Foundation", "IClosable", "System", "IDisposable", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),

			new ProjectedClass("Windows.Foundation.Collections", "IIterable`1", "System.Collections.Generic", "IEnumerable`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IVector`1", "System.Collections.Generic", "IList`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IVectorView`1", "System.Collections.Generic", "IReadOnlyList`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IMap`2", "System.Collections.Generic", "IDictionary`2", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IMapView`2", "System.Collections.Generic", "IReadOnlyDictionary`2", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IKeyValuePair`2", "System.Collections.Generic", "KeyValuePair`2", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, true),

			new ProjectedClass("Windows.UI.Xaml.Input", "ICommand", "System.Windows.Input", "ICommand", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),

			new ProjectedClass("Windows.UI.Xaml.Interop", "IBindableIterable", "System.Collections", "IEnumerable", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.UI.Xaml.Interop", "IBindableVector", "System.Collections", "IList", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),

			new ProjectedClass("Windows.UI.Xaml.Interop", "INotifyCollectionChanged", "System.Collections.Specialized", "INotifyCollectionChanged", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Interop", "NotifyCollectionChangedEventHandler", "System.Collections.Specialized", "NotifyCollectionChangedEventHandler", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Interop", "NotifyCollectionChangedEventArgs", "System.Collections.Specialized", "NotifyCollectionChangedEventArgs", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Interop", "NotifyCollectionChangedAction", "System.Collections.Specialized", "NotifyCollectionChangedAction", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, true, true),

			new ProjectedClass("Windows.UI.Xaml.Data", "INotifyPropertyChanged", "System.ComponentModel", "INotifyPropertyChanged", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Data", "PropertyChangedEventHandler", "System.ComponentModel", "PropertyChangedEventHandler", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Data", "PropertyChangedEventArgs", "System.ComponentModel", "PropertyChangedEventArgs", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),

			new ProjectedClass("Windows.UI.Xaml", "CornerRadius", "Windows.UI.Xaml", "CornerRadius", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "Duration", "Windows.UI.Xaml", "Duration", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "DurationType", "Windows.UI.Xaml", "DurationType", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "GridLength", "Windows.UI.Xaml", "GridLength", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "GridUnitType", "Windows.UI.Xaml", "GridUnitType", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "Thickness", "Windows.UI.Xaml", "Thickness", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.UI.Xaml.Interop", "TypeName", "System", "Type", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, false),

			new ProjectedClass("Windows.UI.Xaml.Controls.Primitives", "GeneratorPosition", "Windows.UI.Xaml.Controls.Primitives", "GeneratorPosition", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.UI.Xaml.Media", "Matrix", "Windows.UI.Xaml.Media", "Matrix", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.UI.Xaml.Media.Animation", "KeyTime", "Windows.UI.Xaml.Media.Animation", "KeyTime", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml.Media.Animation", "RepeatBehavior", "Windows.UI.Xaml.Media.Animation", "RepeatBehavior", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml.Media.Animation", "RepeatBehaviorType", "Windows.UI.Xaml.Media.Animation", "RepeatBehaviorType", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.UI.Xaml.Media.Media3D", "Matrix3D", "Windows.UI.Xaml.Media.Media3D", "Matrix3D", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.Foundation.Numerics", "Vector2", "System.Numerics", "Vector2", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Vector3", "System.Numerics", "Vector3", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Vector4", "System.Numerics", "Vector4", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Matrix3x2", "System.Numerics", "Matrix3x2", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Matrix4x4", "System.Numerics", "Matrix4x4", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Plane", "System.Numerics", "Plane", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Quaternion", "System.Numerics", "Quaternion", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
		};

		static readonly Dictionary<ClassName, ProjectedClass> winMDToCLR = new Dictionary<ClassName, ProjectedClass>();

		static WinMDHelpers() {
			foreach (var projClass in ProjectedClasses)
				winMDToCLR.Add(projClass.WinMDClass, projClass);
		}

		static AssemblyRef ToCLR(ModuleDef module, ref UTF8String ns, ref UTF8String name) {
			ProjectedClass pc;
			if (!winMDToCLR.TryGetValue(new ClassName(ns, name), out pc))
				return null;

			ns = pc.ClrClass.Namespace;
			name = pc.ClrClass.Name;
			return CreateAssembly(module, pc.ContractAssembly);
		}

		static AssemblyRef CreateAssembly(ModuleDef module, ClrAssembly clrAsm) {
			var mscorlib = module == null ? null : module.CorLibTypes.AssemblyRef;

			var asm = new AssemblyRefUser(GetName(clrAsm), contractAsmVersion, new PublicKeyToken(GetPublicKeyToken(clrAsm)), UTF8String.Empty);

			if (mscorlib != null && mscorlib.Name == mscorlibName && mscorlib.Version != invalidWinMDVersion)
				asm.Version = mscorlib.Version;
			var mod = module as ModuleDefMD;
			if (mod != null) {
				Version ver = null;
				foreach (var asmRef in mod.GetAssemblyRefs()) {
					if (asmRef.IsContentTypeWindowsRuntime)
						continue;
					if (asmRef.Name != asm.Name)
						continue;
					if (asmRef.Culture != asm.Culture)
						continue;
					if (!PublicKeyBase.TokenEquals(asmRef.PublicKeyOrToken, asm.PublicKeyOrToken))
						continue;
					if (asmRef.Version == invalidWinMDVersion)
						continue;

					if (ver == null || asmRef.Version > ver)
						ver = asmRef.Version;
				}
				if (ver != null)
					asm.Version = ver;
			}

			return asm;
		}
		static readonly Version contractAsmVersion = new Version(4, 0, 0, 0);
		static readonly Version invalidWinMDVersion = new Version(255, 255, 255, 255);
		static readonly UTF8String mscorlibName = new UTF8String("mscorlib");

		static UTF8String GetName(ClrAssembly clrAsm) {
			switch (clrAsm) {
			case ClrAssembly.Mscorlib: return clrAsmName_Mscorlib;
			case ClrAssembly.SystemNumericsVectors: return clrAsmName_SystemNumericsVectors;
			case ClrAssembly.SystemObjectModel: return clrAsmName_SystemObjectModel;
			case ClrAssembly.SystemRuntime: return clrAsmName_SystemRuntime;
			case ClrAssembly.SystemRuntimeInteropServicesWindowsRuntime: return clrAsmName_SystemRuntimeInteropServicesWindowsRuntime;
			case ClrAssembly.SystemRuntimeWindowsRuntime: return clrAsmName_SystemRuntimeWindowsRuntime;
			case ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml: return clrAsmName_SystemRuntimeWindowsRuntimeUIXaml;
			default: throw new InvalidOperationException();
			}
		}
		static readonly UTF8String clrAsmName_Mscorlib = new UTF8String("mscorlib");
		static readonly UTF8String clrAsmName_SystemNumericsVectors = new UTF8String("System.Numerics.Vectors");
		static readonly UTF8String clrAsmName_SystemObjectModel = new UTF8String("System.ObjectModel");
		static readonly UTF8String clrAsmName_SystemRuntime = new UTF8String("System.Runtime");
		static readonly UTF8String clrAsmName_SystemRuntimeInteropServicesWindowsRuntime = new UTF8String("System.Runtime.InteropServices.WindowsRuntime");
		static readonly UTF8String clrAsmName_SystemRuntimeWindowsRuntime = new UTF8String("System.Runtime.WindowsRuntime");
		static readonly UTF8String clrAsmName_SystemRuntimeWindowsRuntimeUIXaml = new UTF8String("System.Runtime.WindowsRuntime.UI.Xaml");

		static byte[] GetPublicKeyToken(ClrAssembly clrAsm) {
			switch (clrAsm) {
			case ClrAssembly.Mscorlib: return neutralPublicKey;
			case ClrAssembly.SystemNumericsVectors: return contractPublicKeyToken;
			case ClrAssembly.SystemObjectModel: return contractPublicKeyToken;
			case ClrAssembly.SystemRuntime: return contractPublicKeyToken;
			case ClrAssembly.SystemRuntimeInteropServicesWindowsRuntime: return contractPublicKeyToken;
			case ClrAssembly.SystemRuntimeWindowsRuntime: return neutralPublicKey;
			case ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml: return neutralPublicKey;
			default: throw new InvalidOperationException();
			}
		}
		static readonly byte[] contractPublicKeyToken = new byte[] { 0xB0, 0x3F, 0x5F, 0x7F, 0x11, 0xD5, 0x0A, 0x3A };
		static readonly byte[] neutralPublicKey = new byte[] { 0xb7, 0x7a, 0x5c, 0x56, 0x19, 0x34, 0xe0, 0x89 };

		/// <summary>
		/// Converts WinMD type <paramref name="td"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="td">Type</param>
		/// <returns></returns>
		public static TypeRef ToCLR(ModuleDef module, TypeDef td) {
			bool isClrValueType;
			return ToCLR(module, td, out isClrValueType);
		}

		/// <summary>
		/// Converts WinMD type <paramref name="td"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="td">Type</param>
		/// <param name="isClrValueType"><c>true</c> if the returned type is a value type</param>
		/// <returns></returns>
		public static TypeRef ToCLR(ModuleDef module, TypeDef td, out bool isClrValueType) {
			isClrValueType = false;
			if (td == null || !td.IsWindowsRuntime)
				return null;
			var asm = td.DefinitionAssembly;
			if (asm == null || !asm.IsContentTypeWindowsRuntime)
				return null;

			ProjectedClass pc;
			if (!winMDToCLR.TryGetValue(new ClassName(td.Namespace, td.Name), out pc))
				return null;

			isClrValueType = pc.ClrClass.IsValueType;
			return new TypeRefUser(module, pc.ClrClass.Namespace, pc.ClrClass.Name, CreateAssembly(module, pc.ContractAssembly));
		}

		/// <summary>
		/// Converts WinMD type <paramref name="tr"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="tr">Type</param>
		/// <returns></returns>
		public static TypeRef ToCLR(ModuleDef module, TypeRef tr) {
			bool isClrValueType;
			return ToCLR(module, tr, out isClrValueType);
		}

		/// <summary>
		/// Converts WinMD type <paramref name="tr"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="tr">Type</param>
		/// <param name="isClrValueType"><c>true</c> if the returned type is a value type</param>
		/// <returns></returns>
		public static TypeRef ToCLR(ModuleDef module, TypeRef tr, out bool isClrValueType) {
			isClrValueType = false;
			if (tr == null)
				return null;
			var defAsm = tr.DefinitionAssembly;
			if (defAsm == null || !defAsm.IsContentTypeWindowsRuntime)
				return null;
			if (tr.DeclaringType != null)
				return null;

			ProjectedClass pc;
			if (!winMDToCLR.TryGetValue(new ClassName(tr.Namespace, tr.Name), out pc))
				return null;

			isClrValueType = pc.ClrClass.IsValueType;
			return new TypeRefUser(module, pc.ClrClass.Namespace, pc.ClrClass.Name, CreateAssembly(module, pc.ContractAssembly));
		}

		/// <summary>
		/// Converts WinMD type <paramref name="et"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="et">Type</param>
		/// <returns></returns>
		public static ExportedType ToCLR(ModuleDef module, ExportedType et) {
			if (et == null)
				return null;
			var defAsm = et.DefinitionAssembly;
			if (defAsm == null || !defAsm.IsContentTypeWindowsRuntime)
				return null;
			if (et.DeclaringType != null)
				return null;

			ProjectedClass pc;
			if (!winMDToCLR.TryGetValue(new ClassName(et.TypeNamespace, et.TypeName), out pc))
				return null;

			return new ExportedTypeUser(module, 0, pc.ClrClass.Namespace, pc.ClrClass.Name, et.Attributes, CreateAssembly(module, pc.ContractAssembly));
		}

		/// <summary>
		/// Converts WinMD type <paramref name="ts"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="ts">Type</param>
		/// <returns></returns>
		public static TypeSig ToCLR(ModuleDef module, TypeSig ts) {
			if (ts == null)
				return null;
			var et = ts.ElementType;
			if (et != ElementType.Class && et != ElementType.ValueType)
				return null;

			var tdr = ((ClassOrValueTypeSig)ts).TypeDefOrRef;

			TypeDef td;
			TypeRef tr, newTr;
			bool isClrValueType;
			if ((td = tdr as TypeDef) != null) {
				newTr = ToCLR(module, td, out isClrValueType);
				if (newTr == null)
					return null;
			}
			else if ((tr = tdr as TypeRef) != null) {
				newTr = ToCLR(module, tr, out isClrValueType);
				if (newTr == null)
					return null;
			}
			else
				return null;

			return isClrValueType ?
				(TypeSig)new ValueTypeSig(newTr) :
				new ClassSig(newTr);
		}

		/// <summary>
		/// Converts WinMD member reference <paramref name="mr"/> to a CLR member reference. Returns
		/// <c>null</c> if it's not a CLR compatible WinMD member reference.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="mr">Member reference</param>
		/// <returns></returns>
		public static MemberRef ToCLR(ModuleDef module, MemberRef mr) {
			// See WinMDAdapter::CheckIfMethodImplImplementsARedirectedInterface
			// in coreclr: md/winmd/adapter.cpp
			if (mr == null)
				return null;
			if (mr.Name != CloseName)
				return null;

			var msig = mr.MethodSig;
			if (msig == null)
				return null;

			var cl = mr.Class;
			IMemberRefParent newCl;
			TypeRef tr;
			TypeSpec ts;
			if ((tr = cl as TypeRef) != null) {
				var newTr = ToCLR(module, tr);
				if (newTr == null || !IsIDisposable(newTr))
					return null;

				newCl = newTr;
			}
			else if ((ts = cl as TypeSpec) != null) {
				var gis = ts.TypeSig as GenericInstSig;
				if (gis == null || !(gis.GenericType is ClassSig))
					return null;
				tr = gis.GenericType.TypeRef;
				if (tr == null)
					return null;

				bool isClrValueType;
				var newTr = ToCLR(module, tr, out isClrValueType);
				if (newTr == null || !IsIDisposable(newTr))
					return null;

				newCl = new TypeSpecUser(new GenericInstSig(isClrValueType ?
								(ClassOrValueTypeSig)new ValueTypeSig(newTr) :
								new ClassSig(newTr), gis.GenericArguments));
			}
			else
				return null;

			return new MemberRefUser(mr.Module, DisposeName, msig, newCl);
		}
		static readonly UTF8String CloseName = new UTF8String("Close");
		static readonly UTF8String DisposeName = new UTF8String("Dispose");

		static bool IsIDisposable(TypeRef tr) {
			return tr.Name == IDisposableName && tr.Namespace == IDisposableNamespace;
		}
		static readonly UTF8String IDisposableNamespace = new UTF8String("System");
		static readonly UTF8String IDisposableName = new UTF8String("IDisposable");

		/// <summary>
		/// Converts WinMD method <paramref name="md"/> to a CLR member reference. Returns
		/// <c>null</c> if it's not a CLR compatible WinMD method
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="md">Method</param>
		/// <returns></returns>
		public static MemberRef ToCLR(ModuleDef module, MethodDef md) {
			if (md == null)
				return null;
			if (md.Name != CloseName)
				return null;
			var declType = md.DeclaringType;
			if (declType == null)
				return null;

			var tr = ToCLR(module, declType);
			if (tr == null || !IsIDisposable(tr))
				return null;

			return new MemberRefUser(md.Module, DisposeName, md.MethodSig, tr);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/WinMDStatus.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet {
	/// <summary>
	/// WinMD status
	/// </summary>
	public enum WinMDStatus {
		/// <summary>
		/// This is not a WinMD file
		/// </summary>
		None,

		/// <summary>
		/// This is a pure WinMD file (not managed)
		/// </summary>
		Pure,

		/// <summary>
		/// This is a managed WinMD file (created by eg. winmdexp.exe)
		/// </summary>
		Managed,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/Code.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A CIL opcode. If the high byte is 0 or if it's <see cref="UNKNOWN1"/>, it's a 1-byte opcode,
	/// else it's a two-byte opcode and the highest byte is the first byte of the opcode.
	/// </summary>
	public enum Code : ushort {
#pragma warning disable 1591	// disable XML doc warning
		UNKNOWN1		= 0x0100,
		UNKNOWN2		= 0x0101,
		Add				= 0x0058,
		Add_Ovf			= 0x00D6,
		Add_Ovf_Un		= 0x00D7,
		And				= 0x005F,
		Arglist			= 0xFE00,
		Beq				= 0x003B,
		Beq_S			= 0x002E,
		Bge				= 0x003C,
		Bge_S			= 0x002F,
		Bge_Un			= 0x0041,
		Bge_Un_S		= 0x0034,
		Bgt				= 0x003D,
		Bgt_S			= 0x0030,
		Bgt_Un			= 0x0042,
		Bgt_Un_S		= 0x0035,
		Ble				= 0x003E,
		Ble_S			= 0x0031,
		Ble_Un			= 0x0043,
		Ble_Un_S		= 0x0036,
		Blt				= 0x003F,
		Blt_S			= 0x0032,
		Blt_Un			= 0x0044,
		Blt_Un_S		= 0x0037,
		Bne_Un			= 0x0040,
		Bne_Un_S		= 0x0033,
		Box				= 0x008C,
		Br				= 0x0038,
		Br_S			= 0x002B,
		Break			= 0x0001,
		Brfalse			= 0x0039,
		Brfalse_S		= 0x002C,
		Brtrue			= 0x003A,
		Brtrue_S		= 0x002D,
		Call			= 0x0028,
		Calli			= 0x0029,
		Callvirt		= 0x006F,
		Castclass		= 0x0074,
		Ceq				= 0xFE01,
		Cgt				= 0xFE02,
		Cgt_Un			= 0xFE03,
		Ckfinite		= 0x00C3,
		Clt				= 0xFE04,
		Clt_Un			= 0xFE05,
		Constrained		= 0xFE16,
		Conv_I			= 0x00D3,
		Conv_I1			= 0x0067,
		Conv_I2			= 0x0068,
		Conv_I4			= 0x0069,
		Conv_I8			= 0x006A,
		Conv_Ovf_I		= 0x00D4,
		Conv_Ovf_I_Un	= 0x008A,
		Conv_Ovf_I1		= 0x00B3,
		Conv_Ovf_I1_Un	= 0x0082,
		Conv_Ovf_I2		= 0x00B5,
		Conv_Ovf_I2_Un	= 0x0083,
		Conv_Ovf_I4		= 0x00B7,
		Conv_Ovf_I4_Un	= 0x0084,
		Conv_Ovf_I8		= 0x00B9,
		Conv_Ovf_I8_Un	= 0x0085,
		Conv_Ovf_U		= 0x00D5,
		Conv_Ovf_U_Un	= 0x008B,
		Conv_Ovf_U1		= 0x00B4,
		Conv_Ovf_U1_Un	= 0x0086,
		Conv_Ovf_U2		= 0x00B6,
		Conv_Ovf_U2_Un	= 0x0087,
		Conv_Ovf_U4		= 0x00B8,
		Conv_Ovf_U4_Un	= 0x0088,
		Conv_Ovf_U8		= 0x00BA,
		Conv_Ovf_U8_Un	= 0x0089,
		Conv_R_Un		= 0x0076,
		Conv_R4			= 0x006B,
		Conv_R8			= 0x006C,
		Conv_U			= 0x00E0,
		Conv_U1			= 0x00D2,
		Conv_U2			= 0x00D1,
		Conv_U4			= 0x006D,
		Conv_U8			= 0x006E,
		Cpblk			= 0xFE17,
		Cpobj			= 0x0070,
		Div				= 0x005B,
		Div_Un			= 0x005C,
		Dup				= 0x0025,
		Endfilter		= 0xFE11,
		Endfinally		= 0x00DC,
		Initblk			= 0xFE18,
		Initobj			= 0xFE15,
		Isinst			= 0x0075,
		Jmp				= 0x0027,
		Ldarg			= 0xFE09,
		Ldarg_0			= 0x0002,
		Ldarg_1			= 0x0003,
		Ldarg_2			= 0x0004,
		Ldarg_3			= 0x0005,
		Ldarg_S			= 0x000E,
		Ldarga			= 0xFE0A,
		Ldarga_S		= 0x000F,
		Ldc_I4			= 0x0020,
		Ldc_I4_0		= 0x0016,
		Ldc_I4_1		= 0x0017,
		Ldc_I4_2		= 0x0018,
		Ldc_I4_3		= 0x0019,
		Ldc_I4_4		= 0x001A,
		Ldc_I4_5		= 0x001B,
		Ldc_I4_6		= 0x001C,
		Ldc_I4_7		= 0x001D,
		Ldc_I4_8		= 0x001E,
		Ldc_I4_M1		= 0x0015,
		Ldc_I4_S		= 0x001F,
		Ldc_I8			= 0x0021,
		Ldc_R4			= 0x0022,
		Ldc_R8			= 0x0023,
		Ldelem			= 0x00A3,
		Ldelem_I		= 0x0097,
		Ldelem_I1		= 0x0090,
		Ldelem_I2		= 0x0092,
		Ldelem_I4		= 0x0094,
		Ldelem_I8		= 0x0096,
		Ldelem_R4		= 0x0098,
		Ldelem_R8		= 0x0099,
		Ldelem_Ref		= 0x009A,
		Ldelem_U1		= 0x0091,
		Ldelem_U2		= 0x0093,
		Ldelem_U4		= 0x0095,
		Ldelema			= 0x008F,
		Ldfld			= 0x007B,
		Ldflda			= 0x007C,
		Ldftn			= 0xFE06,
		Ldind_I			= 0x004D,
		Ldind_I1		= 0x0046,
		Ldind_I2		= 0x0048,
		Ldind_I4		= 0x004A,
		Ldind_I8		= 0x004C,
		Ldind_R4		= 0x004E,
		Ldind_R8		= 0x004F,
		Ldind_Ref		= 0x0050,
		Ldind_U1		= 0x0047,
		Ldind_U2		= 0x0049,
		Ldind_U4		= 0x004B,
		Ldlen			= 0x008E,
		Ldloc			= 0xFE0C,
		Ldloc_0			= 0x0006,
		Ldloc_1			= 0x0007,
		Ldloc_2			= 0x0008,
		Ldloc_3			= 0x0009,
		Ldloc_S			= 0x0011,
		Ldloca			= 0xFE0D,
		Ldloca_S		= 0x0012,
		Ldnull			= 0x0014,
		Ldobj			= 0x0071,
		Ldsfld			= 0x007E,
		Ldsflda			= 0x007F,
		Ldstr			= 0x0072,
		Ldtoken			= 0x00D0,
		Ldvirtftn		= 0xFE07,
		Leave			= 0x00DD,
		Leave_S			= 0x00DE,
		Localloc		= 0xFE0F,
		Mkrefany		= 0x00C6,
		Mul				= 0x005A,
		Mul_Ovf			= 0x00D8,
		Mul_Ovf_Un		= 0x00D9,
		Neg				= 0x0065,
		Newarr			= 0x008D,
		Newobj			= 0x0073,
//		No				= 0xFE19,	// Not supported by MS' CLI and must be parsed as an opcode without an operand
		Nop				= 0x0000,
		Not				= 0x0066,
		Or				= 0x0060,
		Pop				= 0x0026,
		Prefix1			= 0x00FE,
		Prefix2			= 0x00FD,
		Prefix3			= 0x00FC,
		Prefix4			= 0x00FB,
		Prefix5			= 0x00FA,
		Prefix6			= 0x00F9,
		Prefix7			= 0x00F8,
		Prefixref		= 0x00FF,
		Readonly		= 0xFE1E,
		Refanytype		= 0xFE1D,
		Refanyval		= 0x00C2,
		Rem				= 0x005D,
		Rem_Un			= 0x005E,
		Ret				= 0x002A,
		Rethrow			= 0xFE1A,
		Shl				= 0x0062,
		Shr				= 0x0063,
		Shr_Un			= 0x0064,
		Sizeof			= 0xFE1C,
		Starg			= 0xFE0B,
		Starg_S			= 0x0010,
		Stelem			= 0x00A4,
		Stelem_I		= 0x009B,
		Stelem_I1		= 0x009C,
		Stelem_I2		= 0x009D,
		Stelem_I4		= 0x009E,
		Stelem_I8		= 0x009F,
		Stelem_R4		= 0x00A0,
		Stelem_R8		= 0x00A1,
		Stelem_Ref		= 0x00A2,
		Stfld			= 0x007D,
		Stind_I			= 0x00DF,
		Stind_I1		= 0x0052,
		Stind_I2		= 0x0053,
		Stind_I4		= 0x0054,
		Stind_I8		= 0x0055,
		Stind_R4		= 0x0056,
		Stind_R8		= 0x0057,
		Stind_Ref		= 0x0051,
		Stloc			= 0xFE0E,
		Stloc_0			= 0x000A,
		Stloc_1			= 0x000B,
		Stloc_2			= 0x000C,
		Stloc_3			= 0x000D,
		Stloc_S			= 0x0013,
		Stobj			= 0x0081,
		Stsfld			= 0x0080,
		Sub				= 0x0059,
		Sub_Ovf			= 0x00DA,
		Sub_Ovf_Un		= 0x00DB,
		Switch			= 0x0045,
		Tailcall		= 0xFE14,
		Throw			= 0x007A,
		Unaligned		= 0xFE12,
		Unbox			= 0x0079,
		Unbox_Any		= 0x00A5,
		Volatile		= 0xFE13,
		Xor				= 0x0061,
#pragma warning restore
	}

	public static partial class Extensions {
		/// <summary>
		/// Converts a <see cref="Code"/> to an <see cref="OpCode"/>
		/// </summary>
		/// <param name="code">The code</param>
		/// <returns>A <see cref="OpCode"/> or <c>null</c> if it's invalid</returns>
		public static OpCode ToOpCode(this Code code) {
			int hi = (ushort)code >> 8;
			int lo = (byte)code;
			if (hi == 0)
				return OpCodes.OneByteOpCodes[lo];
			if (hi == 0xFE)
				return OpCodes.TwoByteOpCodes[lo];
			if (code == Code.UNKNOWN1)
				return OpCodes.UNKNOWN1;
			if (code == Code.UNKNOWN2)
				return OpCodes.UNKNOWN2;
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/DynamicMethodBodyReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using SR = System.Reflection;
using System.Reflection.Emit;
using System.IO;
using dnlib.DotNet.MD;
using dnlib.IO;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Reads code from a DynamicMethod
	/// </summary>
	public class DynamicMethodBodyReader : MethodBodyReaderBase, ISignatureReaderHelper {
		static readonly ReflectionFieldInfo rtdmOwnerFieldInfo = new ReflectionFieldInfo("m_owner");
		static readonly ReflectionFieldInfo dmResolverFieldInfo = new ReflectionFieldInfo("m_resolver");
		static readonly ReflectionFieldInfo rslvCodeFieldInfo = new ReflectionFieldInfo("m_code");
		static readonly ReflectionFieldInfo rslvDynamicScopeFieldInfo = new ReflectionFieldInfo("m_scope");
		static readonly ReflectionFieldInfo rslvMethodFieldInfo = new ReflectionFieldInfo("m_method");
		static readonly ReflectionFieldInfo rslvLocalsFieldInfo = new ReflectionFieldInfo("m_localSignature");
		static readonly ReflectionFieldInfo rslvMaxStackFieldInfo = new ReflectionFieldInfo("m_stackSize");
		static readonly ReflectionFieldInfo rslvExceptionsFieldInfo = new ReflectionFieldInfo("m_exceptions");
		static readonly ReflectionFieldInfo rslvExceptionHeaderFieldInfo = new ReflectionFieldInfo("m_exceptionHeader");
		static readonly ReflectionFieldInfo scopeTokensFieldInfo = new ReflectionFieldInfo("m_tokens");
		static readonly ReflectionFieldInfo gfiFieldHandleFieldInfo = new ReflectionFieldInfo("m_field", "m_fieldHandle");
		static readonly ReflectionFieldInfo gfiContextFieldInfo = new ReflectionFieldInfo("m_context");
		static readonly ReflectionFieldInfo gmiMethodHandleFieldInfo = new ReflectionFieldInfo("m_method", "m_methodHandle");
		static readonly ReflectionFieldInfo gmiContextFieldInfo = new ReflectionFieldInfo("m_context");
		static readonly ReflectionFieldInfo ehCatchAddrFieldInfo = new ReflectionFieldInfo("m_catchAddr");
		static readonly ReflectionFieldInfo ehCatchClassFieldInfo = new ReflectionFieldInfo("m_catchClass");
		static readonly ReflectionFieldInfo ehCatchEndAddrFieldInfo = new ReflectionFieldInfo("m_catchEndAddr");
		static readonly ReflectionFieldInfo ehCurrentCatchFieldInfo = new ReflectionFieldInfo("m_currentCatch");
		static readonly ReflectionFieldInfo ehTypeFieldInfo = new ReflectionFieldInfo("m_type");
		static readonly ReflectionFieldInfo ehStartAddrFieldInfo = new ReflectionFieldInfo("m_startAddr");
		static readonly ReflectionFieldInfo ehEndAddrFieldInfo = new ReflectionFieldInfo("m_endAddr");
		static readonly ReflectionFieldInfo ehEndFinallyFieldInfo = new ReflectionFieldInfo("m_endFinally");
		static readonly ReflectionFieldInfo vamMethodFieldInfo = new ReflectionFieldInfo("m_method");
		static readonly ReflectionFieldInfo vamDynamicMethodFieldInfo = new ReflectionFieldInfo("m_dynamicMethod");

		readonly ModuleDef module;
		readonly Importer importer;
		readonly GenericParamContext gpContext;
		readonly MethodDef method;
		readonly int codeSize;
		readonly int maxStack;
		readonly List<object> tokens;
		readonly IList<object> ehInfos;
		readonly byte[] ehHeader;
		readonly string methodName;

		class ReflectionFieldInfo {
			SR.FieldInfo fieldInfo;
			readonly string fieldName1;
			readonly string fieldName2;

			public ReflectionFieldInfo(string fieldName) {
				this.fieldName1 = fieldName;
			}

			public ReflectionFieldInfo(string fieldName1, string fieldName2) {
				this.fieldName1 = fieldName1;
				this.fieldName2 = fieldName2;
			}

			public object Read(object instance) {
				if (fieldInfo == null)
					InitializeField(instance.GetType());
				if (fieldInfo == null)
					throw new Exception(string.Format("Couldn't find field '{0}' or '{1}'", fieldName1, fieldName2));

				return fieldInfo.GetValue(instance);
			}

			public bool Exists(object instance) {
				InitializeField(instance.GetType());
				return fieldInfo != null;
			}

			void InitializeField(Type type) {
				if (fieldInfo != null)
					return;

				var flags = SR.BindingFlags.Instance | SR.BindingFlags.Public | SR.BindingFlags.NonPublic;
				fieldInfo = type.GetField(fieldName1, flags);
				if (fieldInfo == null && fieldName2 != null)
					fieldInfo = type.GetField(fieldName2, flags);
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module that will own the method body</param>
		/// <param name="obj">This can be one of several supported types: the delegate instance
		/// created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
		/// instance or a DynamicResolver instance.</param>
		public DynamicMethodBodyReader(ModuleDef module, object obj)
			: this(module, obj, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module that will own the method body</param>
		/// <param name="obj">This can be one of several supported types: the delegate instance
		/// created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
		/// instance or a DynamicResolver instance.</param>
		/// <param name="gpContext">Generic parameter context</param>
		public DynamicMethodBodyReader(ModuleDef module, object obj, GenericParamContext gpContext) {
			this.module = module;
			this.importer = new Importer(module, ImporterOptions.TryToUseDefs, gpContext);
			this.gpContext = gpContext;
			this.methodName = null;

			if (obj == null)
				throw new ArgumentNullException("obj");

			var del = obj as Delegate;
			if (del != null) {
				obj = del.Method;
				if (obj == null)
					throw new Exception("Delegate.Method == null");
			}

			if (obj.GetType().ToString() == "System.Reflection.Emit.DynamicMethod+RTDynamicMethod") {
				obj = rtdmOwnerFieldInfo.Read(obj) as DynamicMethod;
				if (obj == null)
					throw new Exception("RTDynamicMethod.m_owner is null or invalid");
			}

			if (obj is DynamicMethod) {
				methodName = ((DynamicMethod)obj).Name;
				obj = dmResolverFieldInfo.Read(obj);
				if (obj == null)
					throw new Exception("No resolver found");
			}

			if (obj.GetType().ToString() != "System.Reflection.Emit.DynamicResolver")
				throw new Exception("Couldn't find DynamicResolver");

			var code = rslvCodeFieldInfo.Read(obj) as byte[];
			if (code == null)
				throw new Exception("No code");
			codeSize = code.Length;
			var delMethod = rslvMethodFieldInfo.Read(obj) as SR.MethodBase;
			if (delMethod == null)
				throw new Exception("No method");
			maxStack = (int)rslvMaxStackFieldInfo.Read(obj);

			var scope = rslvDynamicScopeFieldInfo.Read(obj);
			if (scope == null)
				throw new Exception("No scope");
			var tokensList = scopeTokensFieldInfo.Read(scope) as System.Collections.IList;
			if (tokensList == null)
				throw new Exception("No tokens");
			tokens = new List<object>(tokensList.Count);
			for (int i = 0; i < tokensList.Count; i++)
				tokens.Add(tokensList[i]);

			ehInfos = (IList<object>)rslvExceptionsFieldInfo.Read(obj);
			ehHeader = rslvExceptionHeaderFieldInfo.Read(obj) as byte[];

			UpdateLocals(rslvLocalsFieldInfo.Read(obj) as byte[]);
			this.reader = MemoryImageStream.Create(code);
			this.method = CreateMethodDef(delMethod);
			this.parameters = this.method.Parameters;
		}

		class ExceptionInfo {
			public int[] CatchAddr;
			public Type[] CatchClass;
			public int[] CatchEndAddr;
			public int CurrentCatch;
			public int[] Type;
			public int StartAddr;
			public int EndAddr;
			public int EndFinally;
		}

		static List<ExceptionInfo> CreateExceptionInfos(IList<object> ehInfos) {
			if (ehInfos == null)
				return new List<ExceptionInfo>();

			var infos = new List<ExceptionInfo>(ehInfos.Count);

			foreach (var ehInfo in ehInfos) {
				var eh = new ExceptionInfo {
					CatchAddr = (int[])ehCatchAddrFieldInfo.Read(ehInfo),
					CatchClass = (Type[])ehCatchClassFieldInfo.Read(ehInfo),
					CatchEndAddr = (int[])ehCatchEndAddrFieldInfo.Read(ehInfo),
					CurrentCatch = (int)ehCurrentCatchFieldInfo.Read(ehInfo),
					Type = (int[])ehTypeFieldInfo.Read(ehInfo),
					StartAddr = (int)ehStartAddrFieldInfo.Read(ehInfo),
					EndAddr = (int)ehEndAddrFieldInfo.Read(ehInfo),
					EndFinally = (int)ehEndFinallyFieldInfo.Read(ehInfo),
				};
				infos.Add(eh);
			}

			return infos;
		}

		void UpdateLocals(byte[] localsSig) {
			if (localsSig == null || localsSig.Length == 0)
				return;

			var sig = SignatureReader.ReadSig(this, module.CorLibTypes, localsSig, gpContext) as LocalSig;
			if (sig == null)
				return;

			foreach (var local in sig.Locals)
				locals.Add(new Local(local));
		}

		MethodDef CreateMethodDef(SR.MethodBase delMethod) {
			bool isStatic = true;
			var method = new MethodDefUser();

			var retType = GetReturnType(delMethod);
			var pms = GetParameters(delMethod);
			if (isStatic)
				method.Signature = MethodSig.CreateStatic(retType, pms.ToArray());
			else
				method.Signature = MethodSig.CreateInstance(retType, pms.ToArray());

			method.Parameters.UpdateParameterTypes();
			method.ImplAttributes = MethodImplAttributes.IL;
			method.Attributes = MethodAttributes.PrivateScope;
			if (isStatic)
				method.Attributes |= MethodAttributes.Static;

			return module.UpdateRowId(method);
		}

		TypeSig GetReturnType(SR.MethodBase mb) {
			var mi = mb as SR.MethodInfo;
			if (mi != null)
				return importer.ImportAsTypeSig(mi.ReturnType);
			return module.CorLibTypes.Void;
		}

		List<TypeSig> GetParameters(SR.MethodBase delMethod) {
			var pms = new List<TypeSig>();
			foreach (var param in delMethod.GetParameters())
				pms.Add(importer.ImportAsTypeSig(param.ParameterType));
			return pms;
		}

		/// <summary>
		/// Reads the code
		/// </summary>
		/// <returns></returns>
		public bool Read() {
			ReadInstructionsNumBytes((uint)codeSize);
			CreateExceptionHandlers();

			return true;
		}

		void CreateExceptionHandlers() {
			if (ehHeader != null) {
				if (ehHeader.Length < 4)
					return;
				var reader = new BinaryReader(new MemoryStream(ehHeader));
				byte b = reader.ReadByte();
				if ((b & 0x40) == 0) { // DynamicResolver only checks bit 6
					// Calculate num ehs exactly the same way that DynamicResolver does
					int numHandlers = (ushort)((reader.ReadByte() - 2) / 12);
					reader.ReadUInt16();
					for (int i = 0; i < numHandlers; i++) {
						if (reader.BaseStream.Position + 12 > reader.BaseStream.Length)
							break;
						var eh = new ExceptionHandler();
						eh.HandlerType = (ExceptionHandlerType)reader.ReadUInt16();
						int offs = reader.ReadUInt16();
						eh.TryStart = GetInstructionThrow((uint)offs);
						eh.TryEnd = GetInstruction((uint)(reader.ReadByte() + offs));
						offs = reader.ReadUInt16();
						eh.HandlerStart = GetInstructionThrow((uint)offs);
						eh.HandlerEnd = GetInstruction((uint)(reader.ReadByte() + offs));

						if (eh.HandlerType == ExceptionHandlerType.Catch)
							eh.CatchType = ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;
						else if (eh.HandlerType == ExceptionHandlerType.Filter)
							eh.FilterStart = GetInstruction(reader.ReadUInt32());
						else
							reader.ReadUInt32();

						exceptionHandlers.Add(eh);
					}
				}
				else {
					reader.BaseStream.Position--;
					int numHandlers = (ushort)(((reader.ReadUInt32() >> 8) - 4) / 24);
					for (int i = 0; i < numHandlers; i++) {
						if (reader.BaseStream.Position + 24 > reader.BaseStream.Length)
							break;
						var eh = new ExceptionHandler();
						eh.HandlerType = (ExceptionHandlerType)reader.ReadUInt32();
						var offs = reader.ReadUInt32();
						eh.TryStart = GetInstructionThrow((uint)offs);
						eh.TryEnd = GetInstruction((uint)(reader.ReadUInt32() + offs));
						offs = reader.ReadUInt32();
						eh.HandlerStart = GetInstructionThrow((uint)offs);
						eh.HandlerEnd = GetInstruction((uint)(reader.ReadUInt32() + offs));

						if (eh.HandlerType == ExceptionHandlerType.Catch)
							eh.CatchType = ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;
						else if (eh.HandlerType == ExceptionHandlerType.Filter)
							eh.FilterStart = GetInstruction(reader.ReadUInt32());
						else
							reader.ReadUInt32();

						exceptionHandlers.Add(eh);
					}
				}
			}
			else if (ehInfos != null) {
				foreach (var ehInfo in CreateExceptionInfos(ehInfos)) {
					var tryStart = GetInstructionThrow((uint)ehInfo.StartAddr);
					var tryEnd = GetInstruction((uint)ehInfo.EndAddr);
					var endFinally = ehInfo.EndFinally < 0 ? null : GetInstruction((uint)ehInfo.EndFinally);
					for (int i = 0; i < ehInfo.CurrentCatch; i++) {
						var eh = new ExceptionHandler();
						eh.HandlerType = (ExceptionHandlerType)ehInfo.Type[i];
						eh.TryStart = tryStart;
						eh.TryEnd = eh.HandlerType == ExceptionHandlerType.Finally ? endFinally : tryEnd;
						eh.FilterStart = null;	// not supported by DynamicMethod.ILGenerator
						eh.HandlerStart = GetInstructionThrow((uint)ehInfo.CatchAddr[i]);
						eh.HandlerEnd = GetInstruction((uint)ehInfo.CatchEndAddr[i]);
						eh.CatchType = importer.Import(ehInfo.CatchClass[i]);
						exceptionHandlers.Add(eh);
					}
				}
			}
		}

		/// <summary>
		/// Returns the created method. Must be called after <see cref="Read()"/>.
		/// </summary>
		/// <returns>A new <see cref="CilBody"/> instance</returns>
		public MethodDef GetMethod() {
			bool initLocals = true;
			var cilBody = new CilBody(initLocals, instructions, exceptionHandlers, locals);
			cilBody.MaxStack = (ushort)Math.Min(maxStack, ushort.MaxValue);
			instructions = null;
			exceptionHandlers = null;
			locals = null;
			method.Body = cilBody;
			method.Name = methodName;
			return method;
		}

		/// <inheritdoc/>
		protected override IField ReadInlineField(Instruction instr) {
			return ReadToken(reader.ReadUInt32()) as IField;
		}

		/// <inheritdoc/>
		protected override IMethod ReadInlineMethod(Instruction instr) {
			return ReadToken(reader.ReadUInt32()) as IMethod;
		}

		/// <inheritdoc/>
		protected override MethodSig ReadInlineSig(Instruction instr) {
			return ReadToken(reader.ReadUInt32()) as MethodSig;
		}

		/// <inheritdoc/>
		protected override string ReadInlineString(Instruction instr) {
			return ReadToken(reader.ReadUInt32()) as string ?? string.Empty;
		}

		/// <inheritdoc/>
		protected override ITokenOperand ReadInlineTok(Instruction instr) {
			return ReadToken(reader.ReadUInt32()) as ITokenOperand;
		}

		/// <inheritdoc/>
		protected override ITypeDefOrRef ReadInlineType(Instruction instr) {
			return ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;
		}

		object ReadToken(uint token) {
			uint rid = token & 0x00FFFFFF;
			switch (token >> 24) {
			case 0x02:
				return ImportType(rid);

			case 0x04:
				return ImportField(rid);

			case 0x06:
			case 0x0A:
				return ImportMethod(rid);

			case 0x11:
				return ImportSignature(rid);

			case 0x70:
				return Resolve(rid) as string;

			default:
				return null;
			}
		}

		IMethod ImportMethod(uint rid) {
			var obj = Resolve(rid);
			if (obj == null)
				return null;

			if (obj is RuntimeMethodHandle)
				return importer.Import(SR.MethodBase.GetMethodFromHandle((RuntimeMethodHandle)obj));

			if (obj.GetType().ToString() == "System.Reflection.Emit.GenericMethodInfo") {
				var context = (RuntimeTypeHandle)gmiContextFieldInfo.Read(obj);
				var method = SR.MethodBase.GetMethodFromHandle((RuntimeMethodHandle)gmiMethodHandleFieldInfo.Read(obj), context);
				return importer.Import(method);
			}

			if (obj.GetType().ToString() == "System.Reflection.Emit.VarArgMethod") {
				var method = GetVarArgMethod(obj);
				if (!(method is DynamicMethod))
					return importer.Import(method);
				obj = method;
			}

			var dm = obj as DynamicMethod;
			if (dm != null)
				throw new Exception("DynamicMethod calls another DynamicMethod");

			return null;
		}

		SR.MethodInfo GetVarArgMethod(object obj) {
			if (vamDynamicMethodFieldInfo.Exists(obj)) {
				// .NET 4.0+
				var method = vamMethodFieldInfo.Read(obj) as SR.MethodInfo;
				var dynMethod = vamDynamicMethodFieldInfo.Read(obj) as DynamicMethod;
				return dynMethod ?? method;
			}
			else {
				// .NET 2.0
				// This is either a DynamicMethod or a MethodInfo
				return vamMethodFieldInfo.Read(obj) as SR.MethodInfo;
			}
		}

		IField ImportField(uint rid) {
			var obj = Resolve(rid);
			if (obj == null)
				return null;

			if (obj is RuntimeFieldHandle)
				return importer.Import(SR.FieldInfo.GetFieldFromHandle((RuntimeFieldHandle)obj));

			if (obj.GetType().ToString() == "System.Reflection.Emit.GenericFieldInfo") {
				var context = (RuntimeTypeHandle)gfiContextFieldInfo.Read(obj);
				var field = SR.FieldInfo.GetFieldFromHandle((RuntimeFieldHandle)gfiFieldHandleFieldInfo.Read(obj), context);
				return importer.Import(field);
			}

			return null;
		}

		ITypeDefOrRef ImportType(uint rid) {
			var obj = Resolve(rid);
			if (obj is RuntimeTypeHandle)
				return importer.Import(Type.GetTypeFromHandle((RuntimeTypeHandle)obj));

			return null;
		}

		CallingConventionSig ImportSignature(uint rid) {
			var sig = Resolve(rid) as byte[];
			if (sig == null)
				return null;

			return SignatureReader.ReadSig(this, module.CorLibTypes, sig, gpContext);
		}

		object Resolve(uint index) {
			if (index >= (uint)tokens.Count)
				return null;
			return tokens[(int)index];
		}

		ITypeDefOrRef ISignatureReaderHelper.ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext) {
			uint token;
			if (!CodedToken.TypeDefOrRef.Decode(codedToken, out token))
				return null;
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.TypeDef:
			case Table.TypeRef:
			case Table.TypeSpec:
				return ImportType(rid);
			}
			return null;
		}

		TypeSig ISignatureReaderHelper.ConvertRTInternalAddress(IntPtr address) {
			return importer.ImportAsTypeSig(MethodTableToTypeConverter.Convert(address));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/ExceptionHandler.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A CIL method exception handler
	/// </summary>
	public sealed class ExceptionHandler {
		/// <summary>
		/// First instruction of try block
		/// </summary>
		public Instruction TryStart;

		/// <summary>
		/// One instruction past the end of try block or <c>null</c> if it ends at the end
		/// of the method.
		/// </summary>
		public Instruction TryEnd;

		/// <summary>
		/// Start of filter handler or <c>null</c> if none. The end of filter handler is
		/// always <see cref="HandlerStart"/>.
		/// </summary>
		public Instruction FilterStart;

		/// <summary>
		/// First instruction of try handler block
		/// </summary>
		public Instruction HandlerStart;

		/// <summary>
		/// One instruction past the end of try handler block or <c>null</c> if it ends at the end
		/// of the method.
		/// </summary>
		public Instruction HandlerEnd;

		/// <summary>
		/// The catch type if <see cref="HandlerType"/> is <see cref="ExceptionHandlerType.Catch"/>
		/// </summary>
		public ITypeDefOrRef CatchType;

		/// <summary>
		/// Type of exception handler clause
		/// </summary>
		public ExceptionHandlerType HandlerType;

		/// <summary>
		/// Default constructor
		/// </summary>
		public ExceptionHandler() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="handlerType">Exception clause type</param>
		public ExceptionHandler(ExceptionHandlerType handlerType) {
			this.HandlerType = handlerType;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/ExceptionHandlerType.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Type of exception handler. See CorHdr.h/CorExceptionFlag
	/// </summary>
	[Flags]
	public enum ExceptionHandlerType {
		/// <summary/>
		Catch		= 0x0000,
		/// <summary/>
		Filter		= 0x0001,
		/// <summary/>
		Finally		= 0x0002,
		/// <summary/>
		Fault		= 0x0004,
		/// <summary/>
		Duplicated	= 0x0008,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/Extensions.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class Extensions {
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/FlowControl.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Emit {
	/// <summary>
	/// CIL opcode flow control
	/// </summary>
	public enum FlowControl {
		/// <summary/>
		Branch,
		/// <summary/>
		Break,
		/// <summary/>
		Call,
		/// <summary/>
		Cond_Branch,
		/// <summary/>
		Meta,
		/// <summary/>
		Next,
		/// <summary/>
		Phi,
		/// <summary/>
		Return,
		/// <summary/>
		Throw,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/Instruction.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet.Pdb;
using dnlib.Threading;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A CIL instruction (opcode + operand)
	/// </summary>
	public sealed class Instruction {
		/// <summary>
		/// The opcode
		/// </summary>
		public OpCode OpCode;

		/// <summary>
		/// The opcode operand
		/// </summary>
		public object Operand;

		/// <summary>
		/// Offset of the instruction in the method body
		/// </summary>
		public uint Offset;

		/// <summary>
		/// PDB sequence point or <c>null</c> if none
		/// </summary>
		public SequencePoint SequencePoint;

		/// <summary>
		/// Default constructor
		/// </summary>
		public Instruction() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opCode">Opcode</param>
		public Instruction(OpCode opCode) {
			this.OpCode = opCode;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opCode">Opcode</param>
		/// <param name="operand">The operand</param>
		public Instruction(OpCode opCode, object operand) {
			this.OpCode = opCode;
			this.Operand = operand;
		}

		/// <summary>
		/// Creates a new instruction with no operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode) {
			if (opCode.OperandType != OperandType.InlineNone)
				throw new ArgumentException("Must be a no-operand opcode", "opCode");
			return new Instruction(opCode);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="byte"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, byte value) {
			if (opCode.Code != Code.Unaligned)
				throw new ArgumentException("Opcode does not have a byte operand", "opCode");
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="sbyte"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, sbyte value) {
			if (opCode.Code != Code.Ldc_I4_S)
				throw new ArgumentException("Opcode does not have a sbyte operand", "opCode");
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with an <see cref="int"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, int value) {
			if (opCode.OperandType != OperandType.InlineI)
				throw new ArgumentException("Opcode does not have an int32 operand", "opCode");
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="long"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, long value) {
			if (opCode.OperandType != OperandType.InlineI8)
				throw new ArgumentException("Opcode does not have an int64 operand", "opCode");
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="float"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, float value) {
			if (opCode.OperandType != OperandType.ShortInlineR)
				throw new ArgumentException("Opcode does not have a real4 operand", "opCode");
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="double"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, double value) {
			if (opCode.OperandType != OperandType.InlineR)
				throw new ArgumentException("Opcode does not have a real8 operand", "opCode");
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a string operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="s">The string</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, string s) {
			if (opCode.OperandType != OperandType.InlineString)
				throw new ArgumentException("Opcode does not have a string operand", "opCode");
			return new Instruction(opCode, s);
		}

		/// <summary>
		/// Creates a new instruction with an instruction target operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="target">Target instruction</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, Instruction target) {
			if (opCode.OperandType != OperandType.ShortInlineBrTarget && opCode.OperandType != OperandType.InlineBrTarget)
				throw new ArgumentException("Opcode does not have an instruction operand", "opCode");
			return new Instruction(opCode, target);
		}

		/// <summary>
		/// Creates a new instruction with an instruction target list operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="targets">The targets</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, IList<Instruction> targets) {
			if (opCode.OperandType != OperandType.InlineSwitch)
				throw new ArgumentException("Opcode does not have a targets array operand", "opCode");
			return new Instruction(opCode, ThreadSafeListCreator.MakeThreadSafe(targets));
		}

		/// <summary>
		/// Creates a new instruction with a type operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="type">The type</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, ITypeDefOrRef type) {
			if (opCode.OperandType != OperandType.InlineType && opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a type operand", "opCode");
			return new Instruction(opCode, type);
		}

		/// <summary>
		/// Creates a new instruction with a type operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="type">The type</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, CorLibTypeSig type) {
			return Create(opCode, type.TypeDefOrRef);
		}

		/// <summary>
		/// Creates a new instruction with a method/field operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="mr">The method/field</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, MemberRef mr) {
			if (opCode.OperandType != OperandType.InlineField && opCode.OperandType != OperandType.InlineMethod && opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a field operand", "opCode");
			return new Instruction(opCode, mr);
		}

		/// <summary>
		/// Creates a new instruction with a field operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="field">The field</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, IField field) {
			if (opCode.OperandType != OperandType.InlineField && opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a field operand", "opCode");
			return new Instruction(opCode, field);
		}

		/// <summary>
		/// Creates a new instruction with a method operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="method">The method</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, IMethod method) {
			if (opCode.OperandType != OperandType.InlineMethod && opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a method operand", "opCode");
			return new Instruction(opCode, method);
		}

		/// <summary>
		/// Creates a new instruction with a token operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="token">The token</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, ITokenOperand token) {
			if (opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a token operand", "opCode");
			return new Instruction(opCode, token);
		}

		/// <summary>
		/// Creates a new instruction with a method signature operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="methodSig">The method signature</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, MethodSig methodSig) {
			if (opCode.OperandType != OperandType.InlineSig)
				throw new ArgumentException("Opcode does not have a method sig operand", "opCode");
			return new Instruction(opCode, methodSig);
		}

		/// <summary>
		/// Creates a new instruction with a method parameter operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="parameter">The method parameter</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, Parameter parameter) {
			if (opCode.OperandType != OperandType.ShortInlineVar && opCode.OperandType != OperandType.InlineVar)
				throw new ArgumentException("Opcode does not have a method parameter operand", "opCode");
			return new Instruction(opCode, parameter);
		}

		/// <summary>
		/// Creates a new instruction with a method local operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="local">The method local</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, Local local) {
			if (opCode.OperandType != OperandType.ShortInlineVar && opCode.OperandType != OperandType.InlineVar)
				throw new ArgumentException("Opcode does not have a method local operand", "opCode");
			return new Instruction(opCode, local);
		}

		/// <summary>
		/// Creates a <c>ldci4</c> instruction
		/// </summary>
		/// <param name="value">Operand value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction CreateLdcI4(int value) {
			switch (value) {
			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();
			case 0: return OpCodes.Ldc_I4_0.ToInstruction();
			case 1: return OpCodes.Ldc_I4_1.ToInstruction();
			case 2: return OpCodes.Ldc_I4_2.ToInstruction();
			case 3: return OpCodes.Ldc_I4_3.ToInstruction();
			case 4: return OpCodes.Ldc_I4_4.ToInstruction();
			case 5: return OpCodes.Ldc_I4_5.ToInstruction();
			case 6: return OpCodes.Ldc_I4_6.ToInstruction();
			case 7: return OpCodes.Ldc_I4_7.ToInstruction();
			case 8: return OpCodes.Ldc_I4_8.ToInstruction();
			}
			if (sbyte.MinValue <= value && value <= sbyte.MaxValue)
				return new Instruction(OpCodes.Ldc_I4_S, (sbyte)value);
			return new Instruction(OpCodes.Ldc_I4, value);
		}

		/// <summary>
		/// Gets the size in bytes of the instruction
		/// </summary>
		/// <returns></returns>
		public int GetSize() {
			var opCode = OpCode;
			switch (opCode.OperandType) {
			case OperandType.InlineBrTarget:
			case OperandType.InlineField:
			case OperandType.InlineI:
			case OperandType.InlineMethod:
			case OperandType.InlineSig:
			case OperandType.InlineString:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			case OperandType.ShortInlineR:
				return opCode.Size + 4;

			case OperandType.InlineI8:
			case OperandType.InlineR:
				return opCode.Size + 8;

			case OperandType.InlineNone:
			case OperandType.InlinePhi:
			default:
				return opCode.Size;

			case OperandType.InlineSwitch:
				var targets = Operand as IList<Instruction>;
				return opCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);

			case OperandType.InlineVar:
				return opCode.Size + 2;

			case OperandType.ShortInlineBrTarget:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineVar:
				return opCode.Size + 1;
			}
		}

		static bool IsSystemVoid(TypeSig type) {
			return type.RemovePinnedAndModifiers().GetElementType() == ElementType.Void;
		}

		/// <summary>
		/// Updates <paramref name="stack"/> with the new stack size
		/// </summary>
		/// <param name="stack">Current stack size</param>
		public void UpdateStack(ref int stack) {
			UpdateStack(ref stack, false);
		}

		/// <summary>
		/// Updates <paramref name="stack"/> with the new stack size
		/// </summary>
		/// <param name="stack">Current stack size</param>
		/// <param name="methodHasReturnValue"><c>true</c> if the method has a return value,
		/// <c>false</c> otherwise</param>
		public void UpdateStack(ref int stack, bool methodHasReturnValue) {
			int pushes, pops;
			CalculateStackUsage(methodHasReturnValue, out pushes, out pops);
			if (pops == -1)
				stack = 0;
			else
				stack += pushes - pops;
		}

		/// <summary>
		/// Calculates stack usage
		/// </summary>
		/// <param name="pushes">Updated with number of stack pushes</param>
		/// <param name="pops">Updated with number of stack pops or <c>-1</c> if the stack should
		/// be cleared.</param>
		public void CalculateStackUsage(out int pushes, out int pops) {
			CalculateStackUsage(false, out pushes, out pops);
		}

		/// <summary>
		/// Calculates stack usage
		/// </summary>
		/// <param name="methodHasReturnValue"><c>true</c> if method has a return value</param>
		/// <param name="pushes">Updated with number of stack pushes</param>
		/// <param name="pops">Updated with number of stack pops or <c>-1</c> if the stack should
		/// be cleared.</param>
		public void CalculateStackUsage(bool methodHasReturnValue, out int pushes, out int pops) {
			var opCode = OpCode;
			if (opCode.FlowControl == FlowControl.Call)
				CalculateStackUsageCall(opCode, out pushes, out pops);
			else
				CalculateStackUsageNonCall(opCode, methodHasReturnValue, out pushes, out pops);
		}

		void CalculateStackUsageCall(OpCode opCode, out int pushes, out int pops) {
			pushes = 0;
			pops = 0;

			// It doesn't push or pop anything. The stack should be empty when JMP is executed.
			if (opCode.Code == Code.Jmp)
				return;

			MethodSig sig;
			var op = Operand;
			var method = op as IMethod;
			if (method != null)
				sig = method.MethodSig;
			else
				sig = op as MethodSig;	// calli instruction
			if (sig == null)
				return;
			bool implicitThis = sig.ImplicitThis;
			if (!IsSystemVoid(sig.RetType) || (opCode.Code == Code.Newobj && sig.HasThis))
				pushes++;

			pops += sig.Params.Count;
			var paramsAfterSentinel = sig.ParamsAfterSentinel;
			if (paramsAfterSentinel != null)
				pops += paramsAfterSentinel.Count;
			if (implicitThis && opCode.Code != Code.Newobj)
				pops++;
			if (opCode.Code == Code.Calli)
				pops++;
		}

		void CalculateStackUsageNonCall(OpCode opCode, bool hasReturnValue, out int pushes, out int pops) {
			StackBehaviour stackBehavior;

			pushes = 0;
			pops = 0;

			stackBehavior = opCode.StackBehaviourPush;
			switch (stackBehavior) {
			case StackBehaviour.Push0:
				break;

			case StackBehaviour.Push1:
			case StackBehaviour.Pushi:
			case StackBehaviour.Pushi8:
			case StackBehaviour.Pushr4:
			case StackBehaviour.Pushr8:
			case StackBehaviour.Pushref:
				pushes++;
				break;

			case StackBehaviour.Push1_push1:
				pushes += 2;
				break;

			case StackBehaviour.Varpush:	// only call, calli, callvirt which are handled elsewhere
			default:
				break;
			}

			stackBehavior = opCode.StackBehaviourPop;
			switch (stackBehavior) {
			case StackBehaviour.Pop0:
				break;

			case StackBehaviour.Pop1:
			case StackBehaviour.Popi:
			case StackBehaviour.Popref:
				pops++;
				break;

			case StackBehaviour.Pop1_pop1:
			case StackBehaviour.Popi_pop1:
			case StackBehaviour.Popi_popi:
			case StackBehaviour.Popi_popi8:
			case StackBehaviour.Popi_popr4:
			case StackBehaviour.Popi_popr8:
			case StackBehaviour.Popref_pop1:
			case StackBehaviour.Popref_popi:
				pops += 2;
				break;

			case StackBehaviour.Popi_popi_popi:
			case StackBehaviour.Popref_popi_popi:
			case StackBehaviour.Popref_popi_popi8:
			case StackBehaviour.Popref_popi_popr4:
			case StackBehaviour.Popref_popi_popr8:
			case StackBehaviour.Popref_popi_popref:
			case StackBehaviour.Popref_popi_pop1:
				pops += 3;
				break;

			case StackBehaviour.PopAll:
				pops = -1;
				break;

			case StackBehaviour.Varpop:	// call, calli, callvirt, newobj (all handled elsewhere), and ret
				if (hasReturnValue)
					pops++;
				break;

			default:
				break;
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>leave</c> instructions
		/// </summary>
		public bool IsLeave() {
			return OpCode == OpCodes.Leave || OpCode == OpCodes.Leave_S;
		}

		/// <summary>
		/// Checks whether it's one of the <c>br</c> instructions
		/// </summary>
		public bool IsBr() {
			return OpCode == OpCodes.Br || OpCode == OpCodes.Br_S;
		}

		/// <summary>
		/// Checks whether it's one of the <c>brfalse</c> instructions
		/// </summary>
		public bool IsBrfalse() {
			return OpCode == OpCodes.Brfalse || OpCode == OpCodes.Brfalse_S;
		}

		/// <summary>
		/// Checks whether it's one of the <c>brtrue</c> instructions
		/// </summary>
		public bool IsBrtrue() {
			return OpCode == OpCodes.Brtrue || OpCode == OpCodes.Brtrue_S;
		}

		/// <summary>
		/// Checks whether it's one of the conditional branch instructions (bcc, brtrue, brfalse)
		/// </summary>
		public bool IsConditionalBranch() {
			switch (OpCode.Code) {
			case Code.Bge:
			case Code.Bge_S:
			case Code.Bge_Un:
			case Code.Bge_Un_S:
			case Code.Blt:
			case Code.Blt_S:
			case Code.Blt_Un:
			case Code.Blt_Un_S:
			case Code.Bgt:
			case Code.Bgt_S:
			case Code.Bgt_Un:
			case Code.Bgt_Un_S:
			case Code.Ble:
			case Code.Ble_S:
			case Code.Ble_Un:
			case Code.Ble_Un_S:
			case Code.Brfalse:
			case Code.Brfalse_S:
			case Code.Brtrue:
			case Code.Brtrue_S:
			case Code.Beq:
			case Code.Beq_S:
			case Code.Bne_Un:
			case Code.Bne_Un_S:
				return true;

			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether this is one of the <c>ldc.i4</c> instructions
		/// </summary>
		public bool IsLdcI4() {
			switch (OpCode.Code) {
			case Code.Ldc_I4_M1:
			case Code.Ldc_I4_0:
			case Code.Ldc_I4_1:
			case Code.Ldc_I4_2:
			case Code.Ldc_I4_3:
			case Code.Ldc_I4_4:
			case Code.Ldc_I4_5:
			case Code.Ldc_I4_6:
			case Code.Ldc_I4_7:
			case Code.Ldc_I4_8:
			case Code.Ldc_I4_S:
			case Code.Ldc_I4:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Returns a <c>ldc.i4</c> instruction's operand
		/// </summary>
		/// <returns>The integer value</returns>
		/// <exception cref="InvalidOperationException"><see cref="OpCode"/> isn't one of the
		/// <c>ldc.i4</c> opcodes</exception>
		public int GetLdcI4Value() {
			switch (OpCode.Code) {
			case Code.Ldc_I4_M1:return -1;
			case Code.Ldc_I4_0:	return 0;
			case Code.Ldc_I4_1:	return 1;
			case Code.Ldc_I4_2:	return 2;
			case Code.Ldc_I4_3:	return 3;
			case Code.Ldc_I4_4:	return 4;
			case Code.Ldc_I4_5:	return 5;
			case Code.Ldc_I4_6:	return 6;
			case Code.Ldc_I4_7:	return 7;
			case Code.Ldc_I4_8:	return 8;
			case Code.Ldc_I4_S:	return (sbyte)Operand;
			case Code.Ldc_I4:	return (int)Operand;
			default:
				throw new InvalidOperationException(string.Format("Not a ldc.i4 instruction: {0}", this));
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>ldarg</c> instructions, but does <c>not</c> check
		/// whether it's one of the <c>ldarga</c> instructions.
		/// </summary>
		public bool IsLdarg() {
			switch (OpCode.Code) {
			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarg_0:
			case Code.Ldarg_1:
			case Code.Ldarg_2:
			case Code.Ldarg_3:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>ldloc</c> instructions, but does <c>not</c> check
		/// whether it's one of the <c>ldloca</c> instructions.
		/// </summary>
		public bool IsLdloc() {
			switch (OpCode.Code) {
			case Code.Ldloc:
			case Code.Ldloc_0:
			case Code.Ldloc_1:
			case Code.Ldloc_2:
			case Code.Ldloc_3:
			case Code.Ldloc_S:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>starg</c> instructions
		/// </summary>
		public bool IsStarg() {
			switch (OpCode.Code) {
			case Code.Starg:
			case Code.Starg_S:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>stloc</c> instructions
		/// </summary>
		public bool IsStloc() {
			switch (OpCode.Code) {
			case Code.Stloc:
			case Code.Stloc_0:
			case Code.Stloc_1:
			case Code.Stloc_2:
			case Code.Stloc_3:
			case Code.Stloc_S:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Returns the local if it's a <c>ldloc</c> or <c>stloc</c> instruction. It does not
		/// return the local if it's a <c>ldloca</c> instruction.
		/// </summary>
		/// <param name="locals">The locals</param>
		/// <returns>The local or <c>null</c> if it's not a <c>ldloc</c> or <c>stloc</c>
		/// instruction or if the local doesn't exist.</returns>
		public Local GetLocal(IList<Local> locals) {
			int index;
			var code = OpCode.Code;
			switch (code) {
			case Code.Ldloc:
			case Code.Ldloc_S:
			case Code.Stloc:
			case Code.Stloc_S:
				return Operand as Local;

			case Code.Ldloc_0:
			case Code.Ldloc_1:
			case Code.Ldloc_2:
			case Code.Ldloc_3:
				index = code - Code.Ldloc_0;
				break;

			case Code.Stloc_0:
			case Code.Stloc_1:
			case Code.Stloc_2:
			case Code.Stloc_3:
				index = code - Code.Stloc_0;
				break;

			default:
				return null;
			}

			return locals.Get(index, null);
		}

		/// <summary>
		/// Gets the index of the instruction's parameter operand or <c>-1</c> if the parameter
		/// is missing or if it's not an instruction with a parameter operand.
		/// </summary>
		public int GetParameterIndex() {
			switch (OpCode.Code) {
			case Code.Ldarg_0: return 0;
			case Code.Ldarg_1: return 1;
			case Code.Ldarg_2: return 2;
			case Code.Ldarg_3: return 3;

			case Code.Starg:
			case Code.Starg_S:
			case Code.Ldarga:
			case Code.Ldarga_S:
			case Code.Ldarg:
			case Code.Ldarg_S:
				var parameter = Operand as Parameter;
				if (parameter != null)
					return parameter.Index;
				break;
			}

			return -1;
		}

		/// <summary>
		/// Returns a method parameter
		/// </summary>
		/// <param name="parameters">All parameters</param>
		/// <returns>A parameter or <c>null</c> if it doesn't exist</returns>
		public Parameter GetParameter(IList<Parameter> parameters) {
			return parameters.Get(GetParameterIndex(), null);
		}

		/// <summary>
		/// Returns an argument type
		/// </summary>
		/// <param name="methodSig">Method signature</param>
		/// <param name="declaringType">Declaring type (only needed if it's an instance method)</param>
		/// <returns>The type or <c>null</c> if it doesn't exist</returns>
		public TypeSig GetArgumentType(MethodSig methodSig, ITypeDefOrRef declaringType) {
			if (methodSig == null)
				return null;
			int index = GetParameterIndex();
			if (index == 0 && methodSig.ImplicitThis)
				return declaringType.ToTypeSig();	//TODO: Should be ByRef if value type
			if (methodSig.ImplicitThis)
				index--;
			return methodSig.Params.Get(index, null);
		}

		/// <summary>
		/// Clone this instance. The <see cref="Operand"/> and <see cref="SequencePoint"/> fields
		/// are shared by this instance and the created instance.
		/// </summary>
		public Instruction Clone() {
			return new Instruction {
				Offset = Offset,
				OpCode = OpCode,
				Operand = Operand,
				SequencePoint = SequencePoint,
			};
		}

		/// <inheritdoc/>
		public override string ToString() {
			return InstructionPrinter.ToString(this);
		}
	}

	static partial class Extensions {
		/// <summary>
		/// Gets the opcode or <see cref="OpCodes.UNKNOWN1"/> if <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static OpCode GetOpCode(this Instruction self) {
			return self == null ? OpCodes.UNKNOWN1 : self.OpCode;
		}

		/// <summary>
		/// Gets the operand or <c>null</c> if <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static object GetOperand(this Instruction self) {
			return self == null ? null : self.Operand;
		}

		/// <summary>
		/// Gets the offset or 0 if <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static uint GetOffset(this Instruction self) {
			return self == null ? 0 : self.Offset;
		}

		/// <summary>
		/// Gets the sequence point or <c>null</c> if <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static dnlib.DotNet.Pdb.SequencePoint GetSequencePoint(this Instruction self) {
			return self == null ? null : self.SequencePoint;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/InstructionPrinter.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using System.Text;
using dnlib.Threading;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Converts instructions to strings
	/// </summary>
	public static class InstructionPrinter {
		/// <summary>
		/// Converts an instruction to a string
		/// </summary>
		/// <param name="instr">The instruction</param>
		/// <returns>The result</returns>
		public static string ToString(Instruction instr) {
			if (instr == null)
				return string.Empty;

			var sb = new StringBuilder();

			sb.Append(string.Format("IL_{0:X4}: ", instr.Offset));
			sb.Append(instr.OpCode.Name);
			AddOperandString(sb, instr, " ");

			return sb.ToString();
		}

		/// <summary>
		/// Gets the instruction's operand as a string
		/// </summary>
		/// <param name="instr">The instruction</param>
		/// <returns>The operand as a string</returns>
		public static string GetOperandString(Instruction instr) {
			var sb = new StringBuilder();
			AddOperandString(sb, instr, string.Empty);
			return sb.ToString();
		}

		/// <summary>
		/// Add an instruction's operand to <paramref name="sb"/>
		/// </summary>
		/// <param name="sb">Place result here</param>
		/// <param name="instr">The instruction</param>
		public static void AddOperandString(StringBuilder sb, Instruction instr) {
			AddOperandString(sb, instr, string.Empty);
		}

		/// <summary>
		/// Add an instruction's operand to <paramref name="sb"/>
		/// </summary>
		/// <param name="sb">Place result here</param>
		/// <param name="instr">The instruction</param>
		/// <param name="extra">A string that will be added before the operand, if there's
		/// an operand.</param>
		public static void AddOperandString(StringBuilder sb, Instruction instr, string extra) {
			var op = instr.Operand;
			switch (instr.OpCode.OperandType) {
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				sb.Append(extra);
				AddInstructionTarget(sb, op as Instruction);
				break;

			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
			case OperandType.InlineType:
				sb.Append(extra);
				if (op is IFullName)
					sb.Append((op as IFullName).FullName);
				else if (op != null)
					sb.Append(op.ToString());
				else
					sb.Append("null");
				break;

			case OperandType.InlineI:
			case OperandType.InlineI8:
			case OperandType.InlineR:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineR:
				sb.Append(string.Format("{0}{1}", extra, op));
				break;

			case OperandType.InlineSig:
				sb.Append(extra);
				sb.Append(FullNameCreator.MethodFullName(null, (UTF8String)null, op as MethodSig, null, null, null, null));
				break;

			case OperandType.InlineString:
				sb.Append(extra);
				EscapeString(sb, op as string, true);
				break;

			case OperandType.InlineSwitch:
				var targets = op as IList<Instruction>;
				if (targets == null)
					sb.Append("null");
				else {
					sb.Append('(');
					for (int i = 0; i < targets.Count; i++) {
						if (i != 0)
							sb.Append(',');
						AddInstructionTarget(sb, targets.Get(i, null));
					}
					sb.Append(')');
				}
				break;

			case OperandType.InlineVar:
			case OperandType.ShortInlineVar:
				sb.Append(extra);
				if (op == null)
					sb.Append("null");
				else
					sb.Append(op.ToString());
				break;

			case OperandType.InlineNone:
			case OperandType.InlinePhi:
			default:
				break;
			}
		}

		static void AddInstructionTarget(StringBuilder sb, Instruction targetInstr) {
			if (targetInstr == null)
				sb.Append("null");
			else
				sb.Append(string.Format("IL_{0:X4}", targetInstr.Offset));
		}

		static void EscapeString(StringBuilder sb, string s, bool addQuotes) {
			if (s == null) {
				sb.Append("null");
				return;
			}

			if (addQuotes)
				sb.Append('"');

			foreach (var c in s) {
				if ((int)c < 0x20) {
					switch (c) {
					case '\a': sb.Append(@"\a"); break;
					case '\b': sb.Append(@"\b"); break;
					case '\f': sb.Append(@"\f"); break;
					case '\n': sb.Append(@"\n"); break;
					case '\r': sb.Append(@"\r"); break;
					case '\t': sb.Append(@"\t"); break;
					case '\v': sb.Append(@"\v"); break;
					default:
						sb.Append(string.Format(@"\u{0:X4}", (int)c));
						break;
					}
				}
				else if (c == '\\' || c == '"') {
					sb.Append('\\');
					sb.Append(c);
				}
				else
					sb.Append(c);
			}

			if (addQuotes)
				sb.Append('"');
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/InvalidMethodException.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Runtime.Serialization;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Thrown when invalid data is detected while parsing a .NET method
	/// </summary>
	[Serializable]
	public class InvalidMethodException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public InvalidMethodException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">Error message</param>
		public InvalidMethodException(string msg)
			: base(msg) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">Error message</param>
		/// <param name="innerException">The inner exception or <c>null</c> if none</param>
		public InvalidMethodException(string msg, Exception innerException)
			: base(msg, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected InvalidMethodException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/LocalList.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Diagnostics;
using dnlib.Utils;
using dnlib.Threading;
using dnlib.DotNet.Pdb;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A collection of <see cref="Local"/>s
	/// </summary>
	[DebuggerDisplay("Count = {Count}")]
	public sealed class LocalList : IListListener<Local>, ThreadSafe.IList<Local> {
		readonly LazyList<Local> locals;

		/// <summary>
		/// Gets the number of locals
		/// </summary>
		public int Count {
			get { return locals.Count; }
		}

		/// <summary>
		/// Gets the list of locals
		/// </summary>
		public ThreadSafe.IList<Local> Locals {
			get { return locals; }
		}

		/// <summary>
		/// Gets the N'th local
		/// </summary>
		/// <param name="index">The local index</param>
		public Local this[int index] {
			get { return locals[index]; }
			set { locals[index] = value; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public LocalList() {
			this.locals = new LazyList<Local>(this);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="locals">All locals that will be owned by this instance</param>
		public LocalList(IEnumerable<Local> locals) {
			this.locals = new LazyList<Local>(this);
			foreach (var local in locals.GetSafeEnumerable())
				this.locals.Add(local);
		}

		/// <summary>
		/// Adds a new local and then returns it
		/// </summary>
		/// <param name="local">The local that should be added to the list</param>
		/// <returns>The input is always returned</returns>
		public Local Add(Local local) {
			locals.Add(local);
			return local;
		}

		/// <inheritdoc/>
		void IListListener<Local>.OnLazyAdd(int index, ref Local value) {
		}

		/// <inheritdoc/>
		void IListListener<Local>.OnAdd(int index, Local value) {
			value.Index = index;
		}

		/// <inheritdoc/>
		void IListListener<Local>.OnRemove(int index, Local value) {
			value.Index = -1;
		}

		/// <inheritdoc/>
		void IListListener<Local>.OnResize(int index) {
			for (int i = index; i < locals.Count_NoLock(); i++)
				locals.Get_NoLock(i).Index = i;
		}

		/// <inheritdoc/>
		void IListListener<Local>.OnClear() {
			foreach (var local in locals.GetEnumerable_NoLock())
				local.Index = -1;
		}

		/// <inheritdoc/>
		public int IndexOf(Local item) {
			return locals.IndexOf(item);
		}

		/// <inheritdoc/>
		public void Insert(int index, Local item) {
			locals.Insert(index, item);
		}

		/// <inheritdoc/>
		public void RemoveAt(int index) {
			locals.RemoveAt(index);
		}

		void ICollection<Local>.Add(Local item) {
			locals.Add(item);
		}

		/// <inheritdoc/>
		public void Clear() {
			locals.Clear();
		}

		/// <inheritdoc/>
		public bool Contains(Local item) {
			return locals.Contains(item);
		}

		/// <inheritdoc/>
		public void CopyTo(Local[] array, int arrayIndex) {
			locals.CopyTo(array, arrayIndex);
		}

		/// <inheritdoc/>
		public bool IsReadOnly {
			get { return false; }
		}

		/// <inheritdoc/>
		public bool Remove(Local item) {
			return locals.Remove(item);
		}

		/// <inheritdoc/>
		public IEnumerator<Local> GetEnumerator() {
			return locals.GetEnumerator();
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return ((IEnumerable<Local>)this).GetEnumerator();
		}

#if THREAD_SAFE
		/// <inheritdoc/>
		public int IndexOf_NoLock(Local item) {
			return locals.IndexOf_NoLock(item);
		}

		/// <inheritdoc/>
		public void Insert_NoLock(int index, Local item) {
			locals.Insert_NoLock(index, item);
		}

		/// <inheritdoc/>
		public void RemoveAt_NoLock(int index) {
			locals.RemoveAt_NoLock(index);
		}

		/// <inheritdoc/>
		public Local Get_NoLock(int index) {
			return locals.Get_NoLock(index);
		}

		/// <inheritdoc/>
		public void Set_NoLock(int index, Local value) {
			locals.Set_NoLock(index, value);
		}

		/// <inheritdoc/>
		public void Add_NoLock(Local item) {
			locals.Add_NoLock(item);
		}

		/// <inheritdoc/>
		public void Clear_NoLock() {
			locals.Clear_NoLock();
		}

		/// <inheritdoc/>
		public bool Contains_NoLock(Local item) {
			return locals.Contains_NoLock(item);
		}

		/// <inheritdoc/>
		public void CopyTo_NoLock(Local[] array, int arrayIndex) {
			locals.CopyTo_NoLock(array, arrayIndex);
		}

		/// <inheritdoc/>
		public int Count_NoLock {
			get { return locals.Count_NoLock; }
		}

		/// <inheritdoc/>
		public bool IsReadOnly_NoLock {
			get { return locals.IsReadOnly_NoLock; }
		}

		/// <inheritdoc/>
		public bool Remove_NoLock(Local item) {
			return locals.Remove_NoLock(item);
		}

		/// <inheritdoc/>
		public IEnumerator<Local> GetEnumerator_NoLock() {
			return locals.GetEnumerator_NoLock();
		}

		/// <inheritdoc/>
		public TRetType ExecuteLocked<TArgType, TRetType>(TArgType arg, ExecuteLockedDelegate<Local, TArgType, TRetType> handler) {
			return locals.ExecuteLocked<TArgType, TRetType>(arg, (tsList, arg2) => handler(this, arg2));
		}
#endif
	}

	/// <summary>
	/// A method local
	/// </summary>
	public sealed class Local : IVariable {
		TypeSig typeSig;
		int index;
		string name;
		PdbLocalAttributes attributes;

		/// <summary>
		/// Gets/sets the type of the local
		/// </summary>
		public TypeSig Type {
			get { return typeSig; }
			set { typeSig = value; }
		}

		/// <summary>
		/// Local index
		/// </summary>
		public int Index {
			get { return index; }
			internal set { index = value; }
		}

		/// <summary>
		/// Gets the name. This property is obsolete, use <see cref="PdbLocal"/> to get/set the name stored in the PDB file.
		/// </summary>
		public string Name {
			get { return name; }
			set { name = value; }
		}

		/// <summary>
		/// Gets the attributes. This property is obsolete, use <see cref="PdbLocal"/> to get/set the attributes stored in the PDB file.
		/// </summary>
		public PdbLocalAttributes Attributes {
			get { return attributes; }
			set { attributes = value; }
		}

		internal void SetName(string name) {
			this.name = name;
		}

		internal void SetAttributes(PdbLocalAttributes attributes) {
			this.attributes = attributes;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeSig">The type</param>
		public Local(TypeSig typeSig) {
			this.typeSig = typeSig;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeSig">The type</param>
		/// <param name="name">Name of local</param>
		public Local(TypeSig typeSig, string name) {
			this.typeSig = typeSig;
			this.name = name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeSig">The type</param>
		/// <param name="name">Name of local</param>
		/// <param name="index">Index, should only be used if you don't add it to the locals list</param>
		public Local(TypeSig typeSig, string name, int index) {
			this.typeSig = typeSig;
			this.name = name;
			this.index = index;
		}

		/// <inheritdoc/>
		public override string ToString() {
			var n = name;
			if (string.IsNullOrEmpty(n))
				return string.Format("V_{0}", Index);
			return n;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/MethodBody.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using dnlib.DotNet.Pdb;
using dnlib.PE;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Method body base class
	/// </summary>
	public abstract class MethodBody {
	}

	/// <summary>
	/// A native method body
	/// </summary>
	public sealed class NativeMethodBody : MethodBody {
		RVA rva;

		/// <summary>
		/// Gets/sets the RVA of the native method body
		/// </summary>
		public RVA RVA {
			get { return rva; }
			set { rva = value; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public NativeMethodBody() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rva">RVA of method body</param>
		public NativeMethodBody(RVA rva) {
			this.rva = rva;
		}
	}

	/// <summary>
	/// CIL (managed code) body
	/// </summary>
	public sealed class CilBody : MethodBody {
		bool keepOldMaxStack;
		bool initLocals;
		byte headerSize;
		ushort maxStack;
		uint localVarSigTok;
		readonly ThreadSafe.IList<Instruction> instructions;
		readonly ThreadSafe.IList<ExceptionHandler> exceptionHandlers;
		readonly LocalList localList;

		/// <summary>
		/// Size of a small header
		/// </summary>
		public const byte SMALL_HEADER_SIZE = 1;

		/// <summary>
		/// Gets/sets a flag indicating whether the original max stack value should be used.
		/// </summary>
		public bool KeepOldMaxStack {
			get { return keepOldMaxStack; }
			set { keepOldMaxStack = value; }
		}

		/// <summary>
		/// Gets/sets the init locals flag. This is only valid if the method has any locals.
		/// </summary>
		public bool InitLocals {
			get { return initLocals; }
			set { initLocals = value; }
		}

		/// <summary>
		/// Gets/sets the size in bytes of the method body header. The instructions immediately follow
		/// the header.
		/// </summary>
		public byte HeaderSize {
			get { return headerSize; }
			set { headerSize = value; }
		}

		/// <summary>
		/// <c>true</c> if it was a small body header (<see cref="HeaderSize"/> is <c>1</c>)
		/// </summary>
		public bool IsSmallHeader {
			get { return headerSize == SMALL_HEADER_SIZE; }
		}

		/// <summary>
		/// <c>true</c> if it was a big body header
		/// </summary>
		public bool IsBigHeader {
			get { return headerSize != SMALL_HEADER_SIZE; }
		}

		/// <summary>
		/// Gets/sets max stack value from the fat method header.
		/// </summary>
		public ushort MaxStack {
			get { return maxStack; }
			set { maxStack = value; }
		}

		/// <summary>
		/// Gets/sets the locals metadata token
		/// </summary>
		public uint LocalVarSigTok {
			get { return localVarSigTok; }
			set { localVarSigTok = value; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Instructions"/> is not empty
		/// </summary>
		public bool HasInstructions {
			get { return instructions.Count > 0; }
		}

		/// <summary>
		/// Gets the instructions
		/// </summary>
		public ThreadSafe.IList<Instruction> Instructions {
			get { return instructions; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="ExceptionHandlers"/> is not empty
		/// </summary>
		public bool HasExceptionHandlers {
			get { return exceptionHandlers.Count > 0; }
		}

		/// <summary>
		/// Gets the exception handlers
		/// </summary>
		public ThreadSafe.IList<ExceptionHandler> ExceptionHandlers {
			get { return exceptionHandlers; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Variables"/> is not empty
		/// </summary>
		public bool HasVariables {
			get { return localList.Count > 0; }
		}

		/// <summary>
		/// Gets the locals
		/// </summary>
		public LocalList Variables {// Only called Variables for compat w/ older code. Locals is a better and more accurate name
			get { return localList; }
		}

		/// <summary>
		/// Gets/sets the PDB method. This is <c>null</c> if no PDB has been loaded or if there's
		/// no PDB info for this method.
		/// </summary>
		public PdbMethod PdbMethod {
			get { return pdbMethod; }
			set { pdbMethod = value; }
		}
		PdbMethod pdbMethod;

		/// <summary>
		/// <c>true</c> if <see cref="PdbMethod"/> is not <c>null</c>
		/// </summary>
		public bool HasPdbMethod {
			get { return PdbMethod != null; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public CilBody() {
			this.initLocals = true;
			this.instructions = ThreadSafeListCreator.Create<Instruction>();
			this.exceptionHandlers = ThreadSafeListCreator.Create<ExceptionHandler>();
			this.localList = new LocalList();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="initLocals">Init locals flag</param>
		/// <param name="instructions">All instructions. This instance will own the list.</param>
		/// <param name="exceptionHandlers">All exception handlers. This instance will own the list.</param>
		/// <param name="locals">All locals. This instance will own the locals in the list.</param>
		public CilBody(bool initLocals, IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers, IList<Local> locals) {
			this.initLocals = initLocals;
			this.instructions = ThreadSafeListCreator.MakeThreadSafe(instructions);
			this.exceptionHandlers = ThreadSafeListCreator.MakeThreadSafe(exceptionHandlers);
			this.localList = new LocalList(locals);
		}

		/// <summary>
		/// Shorter instructions are converted to the longer form, eg. <c>Ldc_I4_1</c> is
		/// converted to <c>Ldc_I4</c> with a <c>1</c> as the operand.
		/// </summary>
		/// <param name="parameters">All method parameters, including the hidden 'this' parameter
		/// if it's an instance method. Use <see cref="MethodDef.Parameters"/>.</param>
		public void SimplifyMacros(IList<Parameter> parameters) {
			instructions.SimplifyMacros(localList, parameters);
		}

		/// <summary>
		/// Optimizes instructions by using the shorter form if possible. Eg. <c>Ldc_I4</c> <c>1</c>
		/// will be replaced with <c>Ldc_I4_1</c>.
		/// </summary>
		public void OptimizeMacros() {
			instructions.OptimizeMacros();
		}

		/// <summary>
		/// Short branch instructions are converted to the long form, eg. <c>Beq_S</c> is
		/// converted to <c>Beq</c>.
		/// </summary>
		public void SimplifyBranches() {
			instructions.SimplifyBranches();
		}

		/// <summary>
		/// Optimizes branches by using the smallest possible branch
		/// </summary>
		public void OptimizeBranches() {
			instructions.OptimizeBranches();
		}

		/// <summary>
		/// Updates each instruction's offset
		/// </summary>
		/// <returns>Total size in bytes of all instructions</returns>
		public uint UpdateInstructionOffsets() {
			return instructions.UpdateInstructionOffsets();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/MethodBodyReader.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.IO;
using dnlib.IO;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Reads strings from #US heap
	/// </summary>
	public interface IStringResolver {
		/// <summary>
		/// Reads a string from the #US heap
		/// </summary>
		/// <param name="token">String token</param>
		/// <returns>A string</returns>
		string ReadUserString(uint token);
	}

	/// <summary>
	/// Resolves instruction operands
	/// </summary>
	public interface IInstructionOperandResolver : ITokenResolver, IStringResolver {
	}

	public static partial class Extensions {
		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="self">An <see cref="IInstructionOperandResolver"/> object</param>
		/// <param name="token">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public static IMDTokenProvider ResolveToken(this IInstructionOperandResolver self, uint token) {
			return self.ResolveToken(token, new GenericParamContext());
		}
	}

	/// <summary>
	/// Reads a .NET method body (header, locals, instructions, exception handlers)
	/// </summary>
	public sealed class MethodBodyReader : MethodBodyReaderBase {
		readonly IInstructionOperandResolver opResolver;
		bool hasReadHeader;
		byte headerSize;
		ushort flags;
		ushort maxStack;
		uint codeSize;
		uint localVarSigTok;
		IBinaryReader exceptionsReader;
		readonly GenericParamContext gpContext;

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="method">Use parameters from this method</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, IBinaryReader reader, MethodDef method) {
			return CreateCilBody(opResolver, reader, null, method.Parameters, new GenericParamContext());
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="method">Use parameters from this method</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, IBinaryReader reader, MethodDef method, GenericParamContext gpContext) {
			return CreateCilBody(opResolver, reader, null, method.Parameters, gpContext);
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, IBinaryReader reader, IList<Parameter> parameters) {
			return CreateCilBody(opResolver, reader, null, parameters, new GenericParamContext());
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, IBinaryReader reader, IList<Parameter> parameters, GenericParamContext gpContext) {
			return CreateCilBody(opResolver, reader, null, parameters, gpContext);
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters) {
			return CreateCilBody(opResolver, MemoryImageStream.Create(code), exceptions == null ? null : MemoryImageStream.Create(exceptions), parameters, new GenericParamContext());
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters, GenericParamContext gpContext) {
			return CreateCilBody(opResolver, MemoryImageStream.Create(code), exceptions == null ? null : MemoryImageStream.Create(exceptions), parameters, gpContext);
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="codeReader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, IBinaryReader codeReader, IBinaryReader ehReader, IList<Parameter> parameters) {
			return CreateCilBody(opResolver, codeReader, ehReader, parameters, new GenericParamContext());
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="codeReader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, IBinaryReader codeReader, IBinaryReader ehReader, IList<Parameter> parameters, GenericParamContext gpContext) {
			var mbReader = new MethodBodyReader(opResolver, codeReader, ehReader, parameters, gpContext);
			if (!mbReader.Read())
				return new CilBody();
			return mbReader.CreateCilBody();
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="flags">Method header flags, eg. 2 if tiny method</param>
		/// <param name="maxStack">Max stack</param>
		/// <param name="codeSize">Code size</param>
		/// <param name="localVarSigTok">Local variable signature token or 0 if none</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters, ushort flags, ushort maxStack, uint codeSize, uint localVarSigTok) {
			return CreateCilBody(opResolver, code, exceptions, parameters, flags, maxStack, codeSize, localVarSigTok, new GenericParamContext());
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="flags">Method header flags, eg. 2 if tiny method</param>
		/// <param name="maxStack">Max stack</param>
		/// <param name="codeSize">Code size</param>
		/// <param name="localVarSigTok">Local variable signature token or 0 if none</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters, ushort flags, ushort maxStack, uint codeSize, uint localVarSigTok, GenericParamContext gpContext) {
			var codeReader = MemoryImageStream.Create(code);
			var ehReader = exceptions == null ? null : MemoryImageStream.Create(exceptions);
			var mbReader = new MethodBodyReader(opResolver, codeReader, ehReader, parameters, gpContext);
			mbReader.SetHeader(flags, maxStack, codeSize, localVarSigTok);
			if (!mbReader.Read())
				return new CilBody();
			return mbReader.CreateCilBody();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="method">Use parameters from this method</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, IBinaryReader reader, MethodDef method)
			: this(opResolver, reader, null, method.Parameters, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="method">Use parameters from this method</param>
		/// <param name="gpContext">Generic parameter context</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, IBinaryReader reader, MethodDef method, GenericParamContext gpContext)
			: this(opResolver, reader, null, method.Parameters, gpContext) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, IBinaryReader reader, IList<Parameter> parameters)
			: this(opResolver, reader, null, parameters, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, IBinaryReader reader, IList<Parameter> parameters, GenericParamContext gpContext)
			: this(opResolver, reader, null, parameters, gpContext) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, IBinaryReader codeReader, IBinaryReader ehReader, IList<Parameter> parameters)
			: this(opResolver, codeReader, ehReader, parameters, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, IBinaryReader codeReader, IBinaryReader ehReader, IList<Parameter> parameters, GenericParamContext gpContext)
			: base(codeReader, parameters) {
			this.opResolver = opResolver;
			this.exceptionsReader = ehReader;
			this.gpContext = gpContext;
		}

		/// <summary>
		/// Initializes the method header
		/// </summary>
		/// <param name="flags">Header flags, eg. 2 if it's a tiny method</param>
		/// <param name="maxStack">Max stack</param>
		/// <param name="codeSize">Code size</param>
		/// <param name="localVarSigTok">Local variable signature token</param>
		void SetHeader(ushort flags, ushort maxStack, uint codeSize, uint localVarSigTok) {
			this.hasReadHeader = true;
			this.flags = flags;
			this.maxStack = maxStack;
			this.codeSize = codeSize;
			this.localVarSigTok = localVarSigTok;
		}

		/// <summary>
		/// Reads the method body header, locals, all instructions, and the exception handlers (if any)
		/// </summary>
		/// <returns><c>true</c> if it worked, and <c>false</c> if something failed</returns>
		public bool Read() {
			try {
				if (!ReadHeader())
					return false;
				SetLocals(ReadLocals());
				ReadInstructions();
				ReadExceptionHandlers();
				return true;
			}
			catch (InvalidMethodException) {
				return false;
			}
			catch (IOException) {
				return false;
			}
		}

		/// <summary>
		/// Reads the method header
		/// </summary>
		bool ReadHeader() {
			if (hasReadHeader)
				return true;
			hasReadHeader = true;

			byte b = reader.ReadByte();
			switch (b & 7) {
			case 2:
			case 6:
				// Tiny header. [7:2] = code size, max stack is 8, no locals or exception handlers
				flags = 2;
				maxStack = 8;
				codeSize = (uint)(b >> 2);
				localVarSigTok = 0;
				headerSize = 1;
				break;

			case 3:
				// Fat header. Can have locals and exception handlers
				flags = (ushort)((reader.ReadByte() << 8) | b);
				headerSize = (byte)(flags >> 12);
				maxStack = reader.ReadUInt16();
				codeSize = reader.ReadUInt32();
				localVarSigTok = reader.ReadUInt32();

				// The CLR allows the code to start inside the method header. But if it does,
				// the CLR doesn't read any exceptions.
				reader.Position += -12 + headerSize * 4;
				if (headerSize < 3)
					flags &= 0xFFF7;
				headerSize *= 4;
				break;

			default:
				return false;
			}

			if (reader.Position + codeSize < reader.Position || reader.Position + codeSize > reader.Length)
				return false;

			return true;
		}

		/// <summary>
		/// Reads the locals
		/// </summary>
		/// <returns>All locals or <c>null</c> if there are none</returns>
		IList<TypeSig> ReadLocals() {
			var standAloneSig = opResolver.ResolveToken(localVarSigTok, gpContext) as StandAloneSig;
			if (standAloneSig == null)
				return null;
			var localSig = standAloneSig.LocalSig;
			if (localSig == null)
				return null;
			return localSig.Locals;
		}

		/// <summary>
		/// Reads all instructions
		/// </summary>
		void ReadInstructions() {
			ReadInstructionsNumBytes(codeSize);
		}

		/// <inheritdoc/>
		protected override IField ReadInlineField(Instruction instr) {
			return opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as IField;
		}

		/// <inheritdoc/>
		protected override IMethod ReadInlineMethod(Instruction instr) {
			return opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as IMethod;
		}

		/// <inheritdoc/>
		protected override MethodSig ReadInlineSig(Instruction instr) {
			var standAloneSig = opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as StandAloneSig;
			if (standAloneSig == null)
				return null;
			var sig = standAloneSig.MethodSig;
			if (sig != null)
				sig.OriginalToken = standAloneSig.MDToken.Raw;
			return sig;
		}

		/// <inheritdoc/>
		protected override string ReadInlineString(Instruction instr) {
			return opResolver.ReadUserString(reader.ReadUInt32()) ?? string.Empty;
		}

		/// <inheritdoc/>
		protected override ITokenOperand ReadInlineTok(Instruction instr) {
			return opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITokenOperand;
		}

		/// <inheritdoc/>
		protected override ITypeDefOrRef ReadInlineType(Instruction instr) {
			return opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef;
		}

		/// <summary>
		/// Reads all exception handlers
		/// </summary>
		void ReadExceptionHandlers() {
			if ((flags & 8) == 0)
				return;
			IBinaryReader ehReader;
			if (exceptionsReader != null)
				ehReader = exceptionsReader;
			else {
				ehReader = reader;
				ehReader.Position = (ehReader.Position + 3) & ~3;
			}
			// Only read the first one. Any others aren't used.
			byte b = ehReader.ReadByte();
			if ((b & 0x3F) != 1)
				return;	// Not exception handler clauses
			if ((b & 0x40) != 0)
				ReadFatExceptionHandlers(ehReader);
			else
				ReadSmallExceptionHandlers(ehReader);
		}

		static ushort GetNumberOfExceptionHandlers(uint num) {
			// The CLR truncates the count so num handlers is always <= FFFFh.
			return (ushort)num;
		}

		void ReadFatExceptionHandlers(IBinaryReader ehReader) {
			ehReader.Position--;
			int num = GetNumberOfExceptionHandlers((ehReader.ReadUInt32() >> 8) / 24);
			for (int i = 0; i < num; i++) {
				var eh = new ExceptionHandler((ExceptionHandlerType)ehReader.ReadUInt32());
				uint offs = ehReader.ReadUInt32();
				eh.TryStart = GetInstruction(offs);
				eh.TryEnd = GetInstruction(offs + ehReader.ReadUInt32());
				offs = ehReader.ReadUInt32();
				eh.HandlerStart = GetInstruction(offs);
				eh.HandlerEnd = GetInstruction(offs + ehReader.ReadUInt32());
				if (eh.HandlerType == ExceptionHandlerType.Catch)
					eh.CatchType = opResolver.ResolveToken(ehReader.ReadUInt32(), gpContext) as ITypeDefOrRef;
				else if (eh.HandlerType == ExceptionHandlerType.Filter)
					eh.FilterStart = GetInstruction(ehReader.ReadUInt32());
				else
					ehReader.ReadUInt32();
				Add(eh);
			}
		}

		void ReadSmallExceptionHandlers(IBinaryReader ehReader) {
			int num = GetNumberOfExceptionHandlers((uint)ehReader.ReadByte() / 12);
			ehReader.Position += 2;
			for (int i = 0; i < num; i++) {
				var eh = new ExceptionHandler((ExceptionHandlerType)ehReader.ReadUInt16());
				uint offs = ehReader.ReadUInt16();
				eh.TryStart = GetInstruction(offs);
				eh.TryEnd = GetInstruction(offs + ehReader.ReadByte());
				offs = ehReader.ReadUInt16();
				eh.HandlerStart = GetInstruction(offs);
				eh.HandlerEnd = GetInstruction(offs + ehReader.ReadByte());
				if (eh.HandlerType == ExceptionHandlerType.Catch)
					eh.CatchType = opResolver.ResolveToken(ehReader.ReadUInt32(), gpContext) as ITypeDefOrRef;
				else if (eh.HandlerType == ExceptionHandlerType.Filter)
					eh.FilterStart = GetInstruction(ehReader.ReadUInt32());
				else
					ehReader.ReadUInt32();
				Add(eh);
			}
		}

		/// <summary>
		/// Creates a CIL body. Must be called after <see cref="Read()"/>, and can only be
		/// called once.
		/// </summary>
		/// <returns>A new <see cref="CilBody"/> instance</returns>
		public CilBody CreateCilBody() {
			// Set init locals if it's a tiny method or if the init locals bit is set (fat header)
			bool initLocals = flags == 2 || (flags & 0x10) != 0;
			var cilBody = new CilBody(initLocals, instructions, exceptionHandlers, locals);
			cilBody.HeaderSize = headerSize;
			cilBody.MaxStack = maxStack;
			cilBody.LocalVarSigTok = localVarSigTok;
			instructions = null;
			exceptionHandlers = null;
			locals = null;
			return cilBody;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/MethodBodyReaderBase.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.Threading;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Method body reader base class
	/// </summary>
	public abstract class MethodBodyReaderBase {
		/// <summary>The method reader</summary>
		protected IBinaryReader reader;
		/// <summary>All parameters</summary>
		protected IList<Parameter> parameters;
		/// <summary>All locals</summary>
		protected IList<Local> locals = new List<Local>();
		/// <summary>All instructions</summary>
		protected IList<Instruction> instructions;
		/// <summary>All exception handlers</summary>
		protected IList<ExceptionHandler> exceptionHandlers = new List<ExceptionHandler>();
		uint currentOffset;
		/// <summary>First byte after the end of the code</summary>
		protected long codeEndOffs;
		/// <summary>Start offset of method</summary>
		protected long codeStartOffs;

		/// <summary>
		/// Gets all parameters
		/// </summary>
		public IList<Parameter> Parameters {
			get { return parameters; }
		}

		/// <summary>
		/// Gets all locals
		/// </summary>
		public IList<Local> Locals {
			get { return locals; }
		}

		/// <summary>
		/// Gets all instructions
		/// </summary>
		public IList<Instruction> Instructions {
			get { return instructions; }
		}

		/// <summary>
		/// Gets all exception handlers
		/// </summary>
		public IList<ExceptionHandler> ExceptionHandlers {
			get { return exceptionHandlers; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		protected MethodBodyReaderBase() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">The reader</param>
		protected MethodBodyReaderBase(IBinaryReader reader)
			: this(reader, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">The reader</param>
		/// <param name="parameters">Method parameters or <c>null</c> if they're not known yet</param>
		protected MethodBodyReaderBase(IBinaryReader reader, IList<Parameter> parameters) {
			this.reader = reader;
			this.parameters = parameters;
		}

		/// <summary>
		/// Sets new locals
		/// </summary>
		/// <param name="newLocals">A list of types of all locals or <c>null</c> if none</param>
		protected void SetLocals(IList<TypeSig> newLocals) {
			locals.Clear();
			if (newLocals == null)
				return;
			foreach (var typeSig in newLocals.GetSafeEnumerable())
				locals.Add(new Local(typeSig));
		}

		/// <summary>
		/// Sets new locals
		/// </summary>
		/// <param name="newLocals">A list of types of all locals or <c>null</c> if none</param>
		protected void SetLocals(IList<Local> newLocals) {
			locals.Clear();
			if (newLocals == null)
				return;
			foreach (var local in newLocals.GetSafeEnumerable())
				locals.Add(new Local(local.Type));
		}

		/// <summary>
		/// Reads all instructions
		/// </summary>
		/// <param name="numInstrs">Number of instructions to read</param>
		protected void ReadInstructions(int numInstrs) {
			codeStartOffs = reader.Position;
			codeEndOffs = reader.Length;	// We don't know the end pos so use the last one
			instructions = new List<Instruction>(numInstrs);
			currentOffset = 0;
			for (int i = 0; i < numInstrs && reader.Position < codeEndOffs; i++)
				instructions.Add(ReadOneInstruction());
			FixBranches();
		}

		/// <summary>
		/// Reads all instructions
		/// </summary>
		/// <param name="codeSize">Size of code</param>
		protected void ReadInstructionsNumBytes(uint codeSize) {
			codeStartOffs = reader.Position;
			codeEndOffs = reader.Position + codeSize;
			if (codeEndOffs < codeStartOffs || codeEndOffs > reader.Length)
				throw new InvalidMethodException("Invalid code size");

			instructions = new List<Instruction>();	//TODO: Estimate number of instructions based on codeSize
			currentOffset = 0;
			while (reader.Position < codeEndOffs)
				instructions.Add(ReadOneInstruction());
			reader.Position = codeEndOffs;
			FixBranches();
		}

		/// <summary>
		/// Fixes all branch instructions so their operands are set to an <see cref="Instruction"/>
		/// instead of an offset.
		/// </summary>
		void FixBranches() {
			foreach (var instr in instructions) {
				switch (instr.OpCode.OperandType) {
				case OperandType.InlineBrTarget:
				case OperandType.ShortInlineBrTarget:
					instr.Operand = GetInstruction((uint)instr.Operand);
					break;

				case OperandType.InlineSwitch:
					var uintTargets = (IList<uint>)instr.Operand;
					var targets = new Instruction[uintTargets.Count];
					for (int i = 0; i < uintTargets.Count; i++)
						targets[i] = GetInstruction(uintTargets[i]);
					instr.Operand = targets;
					break;
				}
			}
		}

		/// <summary>
		/// Finds an instruction
		/// </summary>
		/// <param name="offset">Offset of instruction</param>
		/// <returns>The instruction or <c>null</c> if there's no instruction at <paramref name="offset"/>.</returns>
		protected Instruction GetInstruction(uint offset) {
			// The instructions are sorted and all Offset fields are correct. Do a binary search.
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}

		/// <summary>
		/// Finds an instruction and throws if it's not present
		/// </summary>
		/// <param name="offset">Offset of instruction</param>
		/// <returns>The instruction</returns>
		/// <exception cref="InvalidOperationException">There's no instruction at
		/// <paramref name="offset"/></exception>
		protected Instruction GetInstructionThrow(uint offset) {
			var instr = GetInstruction(offset);
			if (instr != null)
				return instr;
			throw new InvalidOperationException(string.Format("There's no instruction @ {0:X4}", offset));
		}

		/// <summary>
		/// Reads the next instruction
		/// </summary>
		Instruction ReadOneInstruction() {
			var instr = new Instruction();
			instr.Offset = currentOffset;
			instr.OpCode = ReadOpCode();
			instr.Operand = ReadOperand(instr);

			if (instr.OpCode.Code == Code.Switch) {
				var targets = (IList<uint>)instr.Operand;
				currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);
			}
			else
				currentOffset += (uint)instr.GetSize();
			if (currentOffset < instr.Offset)
				reader.Position = codeEndOffs;
			return instr;
		}

		/// <summary>
		/// Reads the next OpCode from the current position
		/// </summary>
		OpCode ReadOpCode() {
			var op = reader.ReadByte();
			if (op != 0xFE)
				return OpCodes.OneByteOpCodes[op];
			return OpCodes.TwoByteOpCodes[reader.ReadByte()];
		}

		/// <summary>
		/// Reads the instruction operand (if any)
		/// </summary>
		/// <param name="instr">The instruction</param>
		object ReadOperand(Instruction instr) {
			switch (instr.OpCode.OperandType) {
			case OperandType.InlineBrTarget:	return ReadInlineBrTarget(instr);
			case OperandType.InlineField:		return ReadInlineField(instr);
			case OperandType.InlineI:			return ReadInlineI(instr);
			case OperandType.InlineI8:			return ReadInlineI8(instr);
			case OperandType.InlineMethod:		return ReadInlineMethod(instr);
			case OperandType.InlineNone:		return ReadInlineNone(instr);
			case OperandType.InlinePhi:			return ReadInlinePhi(instr);
			case OperandType.InlineR:			return ReadInlineR(instr);
			case OperandType.InlineSig:			return ReadInlineSig(instr);
			case OperandType.InlineString:		return ReadInlineString(instr);
			case OperandType.InlineSwitch:		return ReadInlineSwitch(instr);
			case OperandType.InlineTok:			return ReadInlineTok(instr);
			case OperandType.InlineType:		return ReadInlineType(instr);
			case OperandType.InlineVar:			return ReadInlineVar(instr);
			case OperandType.ShortInlineBrTarget: return ReadShortInlineBrTarget(instr);
			case OperandType.ShortInlineI:		return ReadShortInlineI(instr);
			case OperandType.ShortInlineR:		return ReadShortInlineR(instr);
			case OperandType.ShortInlineVar:	return ReadShortInlineVar(instr);
			default: throw new InvalidOperationException("Invalid OpCode.OperandType");
			}
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineBrTarget"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual uint ReadInlineBrTarget(Instruction instr) {
			return instr.Offset + (uint)instr.GetSize() + reader.ReadUInt32();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineField"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract IField ReadInlineField(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineI"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual int ReadInlineI(Instruction instr) {
			return reader.ReadInt32();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineI8"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual long ReadInlineI8(Instruction instr) {
			return reader.ReadInt64();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineMethod"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract IMethod ReadInlineMethod(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineNone"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual object ReadInlineNone(Instruction instr) {
			return null;
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlinePhi"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual object ReadInlinePhi(Instruction instr) {
			return null;
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineR"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual double ReadInlineR(Instruction instr) {
			return reader.ReadDouble();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineSig"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract MethodSig ReadInlineSig(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineString"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract string ReadInlineString(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineSwitch"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual IList<uint> ReadInlineSwitch(Instruction instr) {
			var num = reader.ReadUInt32();
			long offsetAfterInstr = (long)instr.Offset + (long)instr.OpCode.Size + 4L + (long)num * 4;
			if (offsetAfterInstr > uint.MaxValue || codeStartOffs + offsetAfterInstr > codeEndOffs) {
				reader.Position = codeEndOffs;
				return new uint[0];
			}

			var targets = new uint[num];
			uint offset = (uint)offsetAfterInstr;
			for (int i = 0; i < targets.Length; i++)
				targets[i] = offset + reader.ReadUInt32();
			return targets;
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineTok"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract ITokenOperand ReadInlineTok(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineType"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract ITypeDefOrRef ReadInlineType(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineVar"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual IVariable ReadInlineVar(Instruction instr) {
			if (IsArgOperandInstruction(instr))
				return ReadInlineVarArg(instr);
			return ReadInlineVarLocal(instr);
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineVar"/> (a parameter) operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual Parameter ReadInlineVarArg(Instruction instr) {
			return GetParameter(reader.ReadUInt16());
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineVar"/> (a local) operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual Local ReadInlineVarLocal(Instruction instr) {
			return GetLocal(reader.ReadUInt16());
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineBrTarget"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual uint ReadShortInlineBrTarget(Instruction instr) {
			return instr.Offset + (uint)instr.GetSize() + (uint)reader.ReadSByte();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineI"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual object ReadShortInlineI(Instruction instr) {
			if (instr.OpCode.Code == Code.Ldc_I4_S)
				return reader.ReadSByte();
			return reader.ReadByte();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineR"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual float ReadShortInlineR(Instruction instr) {
			return reader.ReadSingle();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineVar"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual IVariable ReadShortInlineVar(Instruction instr) {
			if (IsArgOperandInstruction(instr))
				return ReadShortInlineVarArg(instr);
			return ReadShortInlineVarLocal(instr);
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineVar"/> (a parameter) operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual Parameter ReadShortInlineVarArg(Instruction instr) {
			return GetParameter(reader.ReadByte());
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineVar"/> (a local) operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual Local ReadShortInlineVarLocal(Instruction instr) {
			return GetLocal(reader.ReadByte());
		}

		/// <summary>
		/// Returns <c>true</c> if it's one of the ldarg/starg instructions that have an operand
		/// </summary>
		/// <param name="instr">The instruction to check</param>
		protected static bool IsArgOperandInstruction(Instruction instr) {
			switch (instr.OpCode.Code) {
			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarga:
			case Code.Ldarga_S:
			case Code.Starg:
			case Code.Starg_S:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Returns a parameter
		/// </summary>
		/// <param name="index">A parameter index</param>
		/// <returns>A <see cref="Parameter"/> or <c>null</c> if <paramref name="index"/> is invalid</returns>
		protected Parameter GetParameter(int index) {
			return parameters.Get(index, null);
		}

		/// <summary>
		/// Returns a local
		/// </summary>
		/// <param name="index">A local index</param>
		/// <returns>A <see cref="Local"/> or <c>null</c> if <paramref name="index"/> is invalid</returns>
		protected Local GetLocal(int index) {
			return locals.Get(index, null);
		}

		/// <summary>
		/// Add an exception handler if it appears valid
		/// </summary>
		/// <param name="eh">The exception handler</param>
		/// <returns><c>true</c> if it was added, <c>false</c> otherwise</returns>
		protected bool Add(ExceptionHandler eh) {
			uint tryStart = GetOffset(eh.TryStart);
			uint tryEnd = GetOffset(eh.TryEnd);
			if (tryEnd <= tryStart)
				return false;

			uint handlerStart = GetOffset(eh.HandlerStart);
			uint handlerEnd = GetOffset(eh.HandlerEnd);
			if (handlerEnd <= handlerStart)
				return false;

			if (eh.HandlerType == ExceptionHandlerType.Filter) {
				if (eh.FilterStart == null)
					return false;
				if (eh.FilterStart.Offset >= handlerStart)
					return false;
			}

			if (handlerStart <= tryStart && tryStart < handlerEnd)
				return false;
			if (handlerStart < tryEnd && tryEnd <= handlerEnd)
				return false;

			if (tryStart <= handlerStart && handlerStart < tryEnd)
				return false;
			if (tryStart < handlerEnd && handlerEnd <= tryEnd)
				return false;

			// It's probably valid, so let's add it.
			exceptionHandlers.Add(eh);
			return true;
		}

		/// <summary>
		/// Gets the offset of an instruction
		/// </summary>
		/// <param name="instr">The instruction or <c>null</c> if the offset is the first offset
		/// at the end of the method.</param>
		/// <returns>The instruction offset</returns>
		uint GetOffset(Instruction instr) {
			if (instr != null)
				return instr.Offset;
			if (instructions.Count == 0)
				return 0;
			return instructions[instructions.Count - 1].Offset;
		}

		/// <summary>
		/// Restores a <see cref="MethodDef"/>'s body with the parsed method instructions
		/// and exception handlers
		/// </summary>
		/// <param name="method">The method that gets updated with the instructions, locals, and
		/// exception handlers.</param>
		public virtual void RestoreMethod(MethodDef method) {
			var body = method.Body;

			body.Variables.Clear();
			if (locals != null) {
				foreach (var local in locals)
					body.Variables.Add(local);
			}

			body.Instructions.Clear();
			if (instructions != null) {
				foreach (var instr in instructions)
					body.Instructions.Add(instr);
			}

			body.ExceptionHandlers.Clear();
			if (exceptionHandlers != null) {
				foreach (var eh in exceptionHandlers)
					body.ExceptionHandlers.Add(eh);
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/MethodTableToTypeConverter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using SR = System.Reflection;
using dnlib.Threading;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Converts a type address to a <see cref="Type"/>. The address can be found in
	/// <c>RuntimeTypeHandle.Value</c> and it's the same address you use with the WinDbg SOS command
	/// !dumpmt.
	/// </summary>
	static class MethodTableToTypeConverter {
		const string METHOD_NAME = "m";
		static readonly MethodInfo setMethodBodyMethodInfo = typeof(MethodBuilder).GetMethod("SetMethodBody", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo localSignatureFieldInfo = typeof(ILGenerator).GetField("m_localSignature", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo sigDoneFieldInfo = typeof(SignatureHelper).GetField("m_sigDone", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo currSigFieldInfo = typeof(SignatureHelper).GetField("m_currSig", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo signatureFieldInfo = typeof(SignatureHelper).GetField("m_signature", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo ptrFieldInfo = typeof(RuntimeTypeHandle).GetField("m_ptr", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
		static readonly Dictionary<IntPtr, Type> addrToType = new Dictionary<IntPtr, Type>();
		static ModuleBuilder moduleBuilder;
		static int numNewTypes;
#if THREAD_SAFE
		static readonly Lock theLock = Lock.Create();
#endif

		static MethodTableToTypeConverter() {
			if (ptrFieldInfo == null) {
#if NETSTANDARD2_0
				var asmb = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("DynAsm"), AssemblyBuilderAccess.Run);
#else
				var asmb = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName("DynAsm"), AssemblyBuilderAccess.Run);
#endif
				moduleBuilder = asmb.DefineDynamicModule("DynMod");
			}
		}

		/// <summary>
		/// Converts <paramref name="address"/> to a <see cref="Type"/>.
		/// </summary>
		/// <param name="address">Address of type</param>
		/// <returns>The <see cref="Type"/> or <c>null</c></returns>
		public static Type Convert(IntPtr address) {
			Type type;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (addrToType.TryGetValue(address, out type))
				return type;

			type = GetTypeNET20(address) ?? GetTypeUsingTypeBuilder(address);
			addrToType[address] = type;
			return type;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		static Type GetTypeUsingTypeBuilder(IntPtr address) {
			if (moduleBuilder == null)
				return null;

			var tb = moduleBuilder.DefineType(GetNextTypeName());
			var mb = tb.DefineMethod(METHOD_NAME, SR.MethodAttributes.Static, typeof(void), new Type[0]);

			try {
				if (setMethodBodyMethodInfo != null)
					return GetTypeNET45(tb, mb, address);
				else
					return GetTypeNET40(tb, mb, address);
			}
			catch {
				moduleBuilder = null;
				return null;
			}
		}

		// .NET 4.5 and later have the documented SetMethodBody() method.
		static Type GetTypeNET45(TypeBuilder tb, MethodBuilder mb, IntPtr address) {
			byte[] code = new byte[1] { 0x2A };
			int maxStack = 8;
			byte[] locals = GetLocalSignature(address);
			setMethodBodyMethodInfo.Invoke(mb, new object[5] { code, maxStack, locals, null, null });
#if NETSTANDARD2_0
			var type = tb.CreateTypeInfo();
#else
			var type = tb.CreateType();
#endif
			var createdMethod = type.GetMethod(METHOD_NAME, BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			return createdMethod.GetMethodBody().LocalVariables[0].LocalType;
		}

		// This code works with .NET 4.0+ but will throw an exception if .NET 2.0 is used
		// ("operation could destabilize the runtime")
		static Type GetTypeNET40(TypeBuilder tb, MethodBuilder mb, IntPtr address) {
			var ilg = mb.GetILGenerator();
			ilg.Emit(SR.Emit.OpCodes.Ret);

			// We need at least one local to make sure the SignatureHelper from ILGenerator is used.
			ilg.DeclareLocal(typeof(int));

			var locals = GetLocalSignature(address);
			var sigHelper = (SignatureHelper)localSignatureFieldInfo.GetValue(ilg);
			sigDoneFieldInfo.SetValue(sigHelper, true);
			currSigFieldInfo.SetValue(sigHelper, locals.Length);
			signatureFieldInfo.SetValue(sigHelper, locals);
#if NETSTANDARD2_0
			var type = tb.CreateTypeInfo();
#else
			var type = tb.CreateType();
#endif
			var createdMethod = type.GetMethod(METHOD_NAME, BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			return createdMethod.GetMethodBody().LocalVariables[0].LocalType;
		}

		// .NET 2.0 - 3.5
		static Type GetTypeNET20(IntPtr address) {
			if (ptrFieldInfo == null)
				return null;
			object th = new RuntimeTypeHandle();
			ptrFieldInfo.SetValue(th, address);
			return Type.GetTypeFromHandle((RuntimeTypeHandle)th);
		}

		static string GetNextTypeName() {
			return string.Format("Type{0}", numNewTypes++);
		}

		static byte[] GetLocalSignature(IntPtr mtAddr) {
			ulong mtValue = (ulong)mtAddr.ToInt64();
			if (IntPtr.Size == 4) {
				return new byte[] {
					0x07,
					0x01,
					(byte)ElementType.Internal,
					(byte)mtValue,
					(byte)(mtValue >> 8),
					(byte)(mtValue >> 16),
					(byte)(mtValue >> 24),
				};
			}
			else {
				return new byte[] {
					0x07,
					0x01,
					(byte)ElementType.Internal,
					(byte)mtValue,
					(byte)(mtValue >> 8),
					(byte)(mtValue >> 16),
					(byte)(mtValue >> 24),
					(byte)(mtValue >> 32),
					(byte)(mtValue >> 40),
					(byte)(mtValue >> 48),
					(byte)(mtValue >> 56),
				};
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/MethodUtils.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using dnlib.Threading;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Instruction utility methods
	/// </summary>
	public static class MethodUtils {
		/// <summary>
		/// Shorter instructions are converted to the longer form, eg. <c>Ldc_I4_1</c> is
		/// converted to <c>Ldc_I4</c> with a <c>1</c> as the operand.
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <param name="locals">All locals</param>
		/// <param name="parameters">All method parameters, including the hidden 'this' parameter
		/// if it's an instance method. Use <see cref="MethodDef.Parameters"/>.</param>
		public static void SimplifyMacros(this IList<Instruction> instructions, IList<Local> locals, IList<Parameter> parameters) {
			foreach (var instr in instructions.GetSafeEnumerable()) {
				switch (instr.OpCode.Code) {
				case Code.Beq_S:
					instr.OpCode = OpCodes.Beq;
					break;

				case Code.Bge_S:
					instr.OpCode = OpCodes.Bge;
					break;

				case Code.Bge_Un_S:
					instr.OpCode = OpCodes.Bge_Un;
					break;

				case Code.Bgt_S:
					instr.OpCode = OpCodes.Bgt;
					break;

				case Code.Bgt_Un_S:
					instr.OpCode = OpCodes.Bgt_Un;
					break;

				case Code.Ble_S:
					instr.OpCode = OpCodes.Ble;
					break;

				case Code.Ble_Un_S:
					instr.OpCode = OpCodes.Ble_Un;
					break;

				case Code.Blt_S:
					instr.OpCode = OpCodes.Blt;
					break;

				case Code.Blt_Un_S:
					instr.OpCode = OpCodes.Blt_Un;
					break;

				case Code.Bne_Un_S:
					instr.OpCode = OpCodes.Bne_Un;
					break;

				case Code.Br_S:
					instr.OpCode = OpCodes.Br;
					break;

				case Code.Brfalse_S:
					instr.OpCode = OpCodes.Brfalse;
					break;

				case Code.Brtrue_S:
					instr.OpCode = OpCodes.Brtrue;
					break;

				case Code.Ldarg_0:
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = ReadList(parameters, 0);
					break;

				case Code.Ldarg_1:
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = ReadList(parameters, 1);
					break;

				case Code.Ldarg_2:
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = ReadList(parameters, 2);
					break;

				case Code.Ldarg_3:
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = ReadList(parameters, 3);
					break;

				case Code.Ldarg_S:
					instr.OpCode = OpCodes.Ldarg;
					break;

				case Code.Ldarga_S:
					instr.OpCode = OpCodes.Ldarga;
					break;

				case Code.Ldc_I4_0:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 0;
					break;

				case Code.Ldc_I4_1:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 1;
					break;

				case Code.Ldc_I4_2:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 2;
					break;

				case Code.Ldc_I4_3:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 3;
					break;

				case Code.Ldc_I4_4:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 4;
					break;

				case Code.Ldc_I4_5:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 5;
					break;

				case Code.Ldc_I4_6:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 6;
					break;

				case Code.Ldc_I4_7:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 7;
					break;

				case Code.Ldc_I4_8:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 8;
					break;

				case Code.Ldc_I4_M1:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = -1;
					break;

				case Code.Ldc_I4_S:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = (int)(sbyte)instr.Operand;
					break;

				case Code.Ldloc_0:
					instr.OpCode = OpCodes.Ldloc;
					instr.Operand = ReadList(locals, 0);
					break;

				case Code.Ldloc_1:
					instr.OpCode = OpCodes.Ldloc;
					instr.Operand = ReadList(locals, 1);
					break;

				case Code.Ldloc_2:
					instr.OpCode = OpCodes.Ldloc;
					instr.Operand = ReadList(locals, 2);
					break;

				case Code.Ldloc_3:
					instr.OpCode = OpCodes.Ldloc;
					instr.Operand = ReadList(locals, 3);
					break;

				case Code.Ldloc_S:
					instr.OpCode = OpCodes.Ldloc;
					break;

				case Code.Ldloca_S:
					instr.OpCode = OpCodes.Ldloca;
					break;

				case Code.Leave_S:
					instr.OpCode = OpCodes.Leave;
					break;

				case Code.Starg_S:
					instr.OpCode = OpCodes.Starg;
					break;

				case Code.Stloc_0:
					instr.OpCode = OpCodes.Stloc;
					instr.Operand = ReadList(locals, 0);
					break;

				case Code.Stloc_1:
					instr.OpCode = OpCodes.Stloc;
					instr.Operand = ReadList(locals, 1);
					break;

				case Code.Stloc_2:
					instr.OpCode = OpCodes.Stloc;
					instr.Operand = ReadList(locals, 2);
					break;

				case Code.Stloc_3:
					instr.OpCode = OpCodes.Stloc;
					instr.Operand = ReadList(locals, 3);
					break;

				case Code.Stloc_S:
					instr.OpCode = OpCodes.Stloc;
					break;
				}
			}
		}

		static T ReadList<T>(IList<T> list, int index) {
			if (list == null)
				return default(T);
			return list.Get(index, default(T));
		}

		/// <summary>
		/// Optimizes instructions by using the shorter form if possible. Eg. <c>Ldc_I4</c> <c>1</c>
		/// will be replaced with <c>Ldc_I4_1</c>.
		/// </summary>
		/// <param name="instructions">All instructions</param>
		public static void OptimizeMacros(this IList<Instruction> instructions) {
			foreach (var instr in instructions.GetSafeEnumerable()) {
				Parameter arg;
				Local local;
				switch (instr.OpCode.Code) {
				case Code.Ldarg:
				case Code.Ldarg_S:
					arg = instr.Operand as Parameter;
					if (arg == null)
						break;
					if (arg.Index == 0) {
						instr.OpCode = OpCodes.Ldarg_0;
						instr.Operand = null;
					}
					else if (arg.Index == 1) {
						instr.OpCode = OpCodes.Ldarg_1;
						instr.Operand = null;
					}
					else if (arg.Index == 2) {
						instr.OpCode = OpCodes.Ldarg_2;
						instr.Operand = null;
					}
					else if (arg.Index == 3) {
						instr.OpCode = OpCodes.Ldarg_3;
						instr.Operand = null;
					}
					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Ldarg_S;
					break;

				case Code.Ldarga:
					arg = instr.Operand as Parameter;
					if (arg == null)
						break;
					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Ldarga_S;
					break;

				case Code.Ldc_I4:
				case Code.Ldc_I4_S:
					int i4;
					if (instr.Operand is int)
						i4 = (int)instr.Operand;
					else if (instr.Operand is sbyte)
						i4 = (sbyte)instr.Operand;
					else
						break;
					switch (i4) {
					case 0:
						instr.OpCode = OpCodes.Ldc_I4_0;
						instr.Operand = null;
						break;

					case 1:
						instr.OpCode = OpCodes.Ldc_I4_1;
						instr.Operand = null;
						break;

					case 2:
						instr.OpCode = OpCodes.Ldc_I4_2;
						instr.Operand = null;
						break;

					case 3:
						instr.OpCode = OpCodes.Ldc_I4_3;
						instr.Operand = null;
						break;

					case 4:
						instr.OpCode = OpCodes.Ldc_I4_4;
						instr.Operand = null;
						break;

					case 5:
						instr.OpCode = OpCodes.Ldc_I4_5;
						instr.Operand = null;
						break;

					case 6:
						instr.OpCode = OpCodes.Ldc_I4_6;
						instr.Operand = null;
						break;

					case 7:
						instr.OpCode = OpCodes.Ldc_I4_7;
						instr.Operand = null;
						break;

					case 8:
						instr.OpCode = OpCodes.Ldc_I4_8;
						instr.Operand = null;
						break;

					case -1:
						instr.OpCode = OpCodes.Ldc_I4_M1;
						instr.Operand = null;
						break;

					default:
						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {
							instr.OpCode = OpCodes.Ldc_I4_S;
							instr.Operand = (sbyte)i4;
						}
						break;
					}
					break;

				case Code.Ldloc:
				case Code.Ldloc_S:
					local = instr.Operand as Local;
					if (local == null)
						break;
					if (local.Index == 0) {
						instr.OpCode = OpCodes.Ldloc_0;
						instr.Operand = null;
					}
					else if (local.Index == 1) {
						instr.OpCode = OpCodes.Ldloc_1;
						instr.Operand = null;
					}
					else if (local.Index == 2) {
						instr.OpCode = OpCodes.Ldloc_2;
						instr.Operand = null;
					}
					else if (local.Index == 3) {
						instr.OpCode = OpCodes.Ldloc_3;
						instr.Operand = null;
					}
					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Ldloc_S;
					break;

				case Code.Ldloca:
					local = instr.Operand as Local;
					if (local == null)
						break;
					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Ldloca_S;
					break;

				case Code.Starg:
					arg = instr.Operand as Parameter;
					if (arg == null)
						break;
					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Starg_S;
					break;

				case Code.Stloc:
				case Code.Stloc_S:
					local = instr.Operand as Local;
					if (local == null)
						break;
					if (local.Index == 0) {
						instr.OpCode = OpCodes.Stloc_0;
						instr.Operand = null;
					}
					else if (local.Index == 1) {
						instr.OpCode = OpCodes.Stloc_1;
						instr.Operand = null;
					}
					else if (local.Index == 2) {
						instr.OpCode = OpCodes.Stloc_2;
						instr.Operand = null;
					}
					else if (local.Index == 3) {
						instr.OpCode = OpCodes.Stloc_3;
						instr.Operand = null;
					}
					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Stloc_S;
					break;
				}
			}

			OptimizeBranches(instructions);
		}

		/// <summary>
		/// Short branch instructions are converted to the long form, eg. <c>Beq_S</c> is
		/// converted to <c>Beq</c>.
		/// </summary>
		/// <param name="instructions">All instructions</param>
		public static void SimplifyBranches(this IList<Instruction> instructions) {
			foreach (var instr in instructions.GetSafeEnumerable()) {
				switch (instr.OpCode.Code) {
				case Code.Beq_S:	instr.OpCode = OpCodes.Beq; break;
				case Code.Bge_S:	instr.OpCode = OpCodes.Bge; break;
				case Code.Bgt_S:	instr.OpCode = OpCodes.Bgt; break;
				case Code.Ble_S:	instr.OpCode = OpCodes.Ble; break;
				case Code.Blt_S:	instr.OpCode = OpCodes.Blt; break;
				case Code.Bne_Un_S:	instr.OpCode = OpCodes.Bne_Un; break;
				case Code.Bge_Un_S:	instr.OpCode = OpCodes.Bge_Un; break;
				case Code.Bgt_Un_S:	instr.OpCode = OpCodes.Bgt_Un; break;
				case Code.Ble_Un_S:	instr.OpCode = OpCodes.Ble_Un; break;
				case Code.Blt_Un_S:	instr.OpCode = OpCodes.Blt_Un; break;
				case Code.Br_S:		instr.OpCode = OpCodes.Br; break;
				case Code.Brfalse_S:instr.OpCode = OpCodes.Brfalse; break;
				case Code.Brtrue_S:	instr.OpCode = OpCodes.Brtrue; break;
				case Code.Leave_S:	instr.OpCode = OpCodes.Leave; break;
				}
			}
		}

		/// <summary>
		/// Optimizes branches by using the smallest possible branch
		/// </summary>
		/// <param name="instructions">All instructions</param>
		public static void OptimizeBranches(this IList<Instruction> instructions) {
			while (true) {
				UpdateInstructionOffsets(instructions);

				bool modified = false;
				foreach (var instr in instructions.GetSafeEnumerable()) {
					OpCode shortOpCode;
					switch (instr.OpCode.Code) {
					case Code.Beq:		shortOpCode = OpCodes.Beq_S; break;
					case Code.Bge:		shortOpCode = OpCodes.Bge_S; break;
					case Code.Bge_Un:	shortOpCode = OpCodes.Bge_Un_S; break;
					case Code.Bgt:		shortOpCode = OpCodes.Bgt_S; break;
					case Code.Bgt_Un:	shortOpCode = OpCodes.Bgt_Un_S; break;
					case Code.Ble:		shortOpCode = OpCodes.Ble_S; break;
					case Code.Ble_Un:	shortOpCode = OpCodes.Ble_Un_S; break;
					case Code.Blt:		shortOpCode = OpCodes.Blt_S; break;
					case Code.Blt_Un:	shortOpCode = OpCodes.Blt_Un_S; break;
					case Code.Bne_Un:	shortOpCode = OpCodes.Bne_Un_S; break;
					case Code.Br:		shortOpCode = OpCodes.Br_S; break;
					case Code.Brfalse:	shortOpCode = OpCodes.Brfalse_S; break;
					case Code.Brtrue:	shortOpCode = OpCodes.Brtrue_S; break;
					case Code.Leave:	shortOpCode = OpCodes.Leave_S; break;
					default: continue;
					}
					var targetInstr = instr.Operand as Instruction;
					if (targetInstr == null)
						continue;

					int afterShortInstr;
					if (targetInstr.Offset >= instr.Offset) {
						// Target is >= this instruction so use the offset after
						// current instruction
						afterShortInstr = (int)instr.Offset + instr.GetSize();
					}
					else {
						// Target is < this instruction so use the offset after
						// the short instruction
						const int operandSize = 1;
						afterShortInstr = (int)instr.Offset + shortOpCode.Size + operandSize;
					}

					int displ = (int)targetInstr.Offset - afterShortInstr;
					if (sbyte.MinValue <= displ && displ <= sbyte.MaxValue) {
						instr.OpCode = shortOpCode;
						modified = true;
					}
				}
				if (!modified)
					break;
			}
		}

		/// <summary>
		/// Updates each instruction's offset
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <returns>Total size in bytes of all instructions</returns>
		public static uint UpdateInstructionOffsets(this IList<Instruction> instructions) {
			uint offset = 0;
			foreach (var instr in instructions.GetSafeEnumerable()) {
				instr.Offset = offset;
				offset += (uint)instr.GetSize();
			}
			return offset;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/OpCode.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using dnlib.Threading;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A CIL opcode
	/// </summary>
	public sealed class OpCode {
		/// <summary>
		/// The opcode name
		/// </summary>
		public readonly string Name;

		/// <summary>
		/// The opcode as a <see cref="Code"/> enum
		/// </summary>
		public readonly Code Code;

		/// <summary>
		/// Operand type
		/// </summary>
		public readonly OperandType OperandType;

		/// <summary>
		/// Flow control info
		/// </summary>
		public readonly FlowControl FlowControl;

		/// <summary>
		/// Opcode type
		/// </summary>
		public readonly OpCodeType OpCodeType;

		/// <summary>
		/// Push stack behavior
		/// </summary>
		public readonly StackBehaviour StackBehaviourPush;	// UK spelling for compatibility with Reflection

		/// <summary>
		/// Pop stack behavior
		/// </summary>
		public readonly StackBehaviour StackBehaviourPop;	// UK spelling for compatibility with Reflection

		/// <summary>
		/// Gets the value which is compatible with <see cref="System.Reflection.Emit.OpCode.Value"/>
		/// </summary>
		public short Value {
			get { return (short)Code; }
		}

		/// <summary>
		/// Gets the size of the opcode. It's either 1 or 2 bytes.
		/// </summary>
		public int Size {
			get { return Code < (Code)0x100 || Code == Code.UNKNOWN1 ? 1 : 2; }
		}

		internal OpCode(string name, Code code, OperandType operandType, FlowControl flowControl, OpCodeType opCodeType, StackBehaviour push, StackBehaviour pop) {
			this.Name = name;
			this.Code = code;
			this.OperandType = operandType;
			this.FlowControl = flowControl;
			this.OpCodeType = opCodeType;
			this.StackBehaviourPush = push;
			this.StackBehaviourPop = pop;
			if (((ushort)code >> 8) == 0)
				OpCodes.OneByteOpCodes[(byte)code] = this;
			else if (((ushort)code >> 8) == 0xFE)
				OpCodes.TwoByteOpCodes[(byte)code] = this;
		}

		/// <summary>
		/// Creates a new instruction with no operand
		/// </summary>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction() {
			return Instruction.Create(this);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="byte"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(byte value) {
			return Instruction.Create(this, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="sbyte"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(sbyte value) {
			return Instruction.Create(this, value);
		}

		/// <summary>
		/// Creates a new instruction with an <see cref="int"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(int value) {
			return Instruction.Create(this, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="long"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(long value) {
			return Instruction.Create(this, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="float"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(float value) {
			return Instruction.Create(this, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="double"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(double value) {
			return Instruction.Create(this, value);
		}

		/// <summary>
		/// Creates a new instruction with a string operand
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(string s) {
			return Instruction.Create(this, s);
		}

		/// <summary>
		/// Creates a new instruction with an instruction target operand
		/// </summary>
		/// <param name="target">Target instruction</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(Instruction target) {
			return Instruction.Create(this, target);
		}

		/// <summary>
		/// Creates a new instruction with an instruction target list operand
		/// </summary>
		/// <param name="targets">The targets</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(IList<Instruction> targets) {
			return Instruction.Create(this, ThreadSafeListCreator.MakeThreadSafe(targets));
		}

		/// <summary>
		/// Creates a new instruction with a type operand
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(ITypeDefOrRef type) {
			return Instruction.Create(this, type);
		}

		/// <summary>
		/// Creates a new instruction with a type operand
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(CorLibTypeSig type) {
			return Instruction.Create(this, type.TypeDefOrRef);
		}

		/// <summary>
		/// Creates a new instruction with a method/field operand
		/// </summary>
		/// <param name="mr">The method/field</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(MemberRef mr) {
			return Instruction.Create(this, mr);
		}

		/// <summary>
		/// Creates a new instruction with a field operand
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(IField field) {
			return Instruction.Create(this, field);
		}

		/// <summary>
		/// Creates a new instruction with a method operand
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(IMethod method) {
			return Instruction.Create(this, method);
		}

		/// <summary>
		/// Creates a new instruction with a token operand
		/// </summary>
		/// <param name="token">The token</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(ITokenOperand token) {
			return Instruction.Create(this, token);
		}

		/// <summary>
		/// Creates a new instruction with a method signature operand
		/// </summary>
		/// <param name="methodSig">The method signature</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(MethodSig methodSig) {
			return Instruction.Create(this, methodSig);
		}

		/// <summary>
		/// Creates a new instruction with a method parameter operand
		/// </summary>
		/// <param name="parameter">The method parameter</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(Parameter parameter) {
			return Instruction.Create(this, parameter);
		}

		/// <summary>
		/// Creates a new instruction with a method local operand
		/// </summary>
		/// <param name="local">The method local</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(Local local) {
			return Instruction.Create(this, local);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return Name;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/OpCodeType.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Emit {
	/// <summary>
	/// CIL opcode type
	/// </summary>
	public enum OpCodeType : byte {
		/// <summary/>
		Annotation,
		/// <summary/>
		Macro,
		/// <summary/>
		Nternal,
		/// <summary/>
		Objmodel,
		/// <summary/>
		Prefix,
		/// <summary/>
		Primitive,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/OpCodes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Contains all valid CIL opcodes
	/// </summary>
	public static class OpCodes {
		/// <summary>
		/// All one-byte opcodes
		/// </summary>
		public static readonly OpCode[] OneByteOpCodes = new OpCode[0x100];

		/// <summary>
		/// All two-byte opcodes (first byte is <c>0xFE</c>)
		/// </summary>
		public static readonly OpCode[] TwoByteOpCodes = new OpCode[0x100];

#pragma warning disable 1591	// disable XML doc warning
		public static readonly OpCode UNKNOWN1		= new OpCode("UNKNOWN1",		Code.UNKNOWN1, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode UNKNOWN2		= new OpCode("UNKNOWN2",		Code.UNKNOWN2, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Nop			= new OpCode("nop",				Code.Nop, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Break			= new OpCode("break",			Code.Break, OperandType.InlineNone, FlowControl.Break, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Ldarg_0		= new OpCode("ldarg.0",			Code.Ldarg_0, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarg_1		= new OpCode("ldarg.1",			Code.Ldarg_1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarg_2		= new OpCode("ldarg.2",			Code.Ldarg_2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarg_3		= new OpCode("ldarg.3",			Code.Ldarg_3, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloc_0		= new OpCode("ldloc.0",			Code.Ldloc_0, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloc_1		= new OpCode("ldloc.1",			Code.Ldloc_1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloc_2		= new OpCode("ldloc.2",			Code.Ldloc_2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloc_3		= new OpCode("ldloc.3",			Code.Ldloc_3, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Stloc_0		= new OpCode("stloc.0",			Code.Stloc_0, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Stloc_1		= new OpCode("stloc.1",			Code.Stloc_1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Stloc_2		= new OpCode("stloc.2",			Code.Stloc_2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Stloc_3		= new OpCode("stloc.3",			Code.Stloc_3, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Ldarg_S		= new OpCode("ldarg.s",			Code.Ldarg_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarga_S		= new OpCode("ldarga.s",		Code.Ldarga_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Starg_S		= new OpCode("starg.s",			Code.Starg_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Ldloc_S		= new OpCode("ldloc.s",			Code.Ldloc_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloca_S		= new OpCode("ldloca.s",		Code.Ldloca_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Stloc_S		= new OpCode("stloc.s",			Code.Stloc_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Ldnull		= new OpCode("ldnull",			Code.Ldnull, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushref, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_M1		= new OpCode("ldc.i4.m1",		Code.Ldc_I4_M1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_0		= new OpCode("ldc.i4.0",		Code.Ldc_I4_0, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_1		= new OpCode("ldc.i4.1",		Code.Ldc_I4_1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_2		= new OpCode("ldc.i4.2",		Code.Ldc_I4_2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_3		= new OpCode("ldc.i4.3",		Code.Ldc_I4_3, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_4		= new OpCode("ldc.i4.4",		Code.Ldc_I4_4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_5		= new OpCode("ldc.i4.5",		Code.Ldc_I4_5, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_6		= new OpCode("ldc.i4.6",		Code.Ldc_I4_6, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_7		= new OpCode("ldc.i4.7",		Code.Ldc_I4_7, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_8		= new OpCode("ldc.i4.8",		Code.Ldc_I4_8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_S		= new OpCode("ldc.i4.s",		Code.Ldc_I4_S, OperandType.ShortInlineI, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4		= new OpCode("ldc.i4",			Code.Ldc_I4, OperandType.InlineI, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I8		= new OpCode("ldc.i8",			Code.Ldc_I8, OperandType.InlineI8, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_R4		= new OpCode("ldc.r4",			Code.Ldc_R4, OperandType.ShortInlineR, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr4, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_R8		= new OpCode("ldc.r8",			Code.Ldc_R8, OperandType.InlineR, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Pop0);
		public static readonly OpCode Dup			= new OpCode("dup",				Code.Dup, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1_push1, StackBehaviour.Pop1);
		public static readonly OpCode Pop			= new OpCode("pop",				Code.Pop, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Jmp			= new OpCode("jmp",				Code.Jmp, OperandType.InlineMethod, FlowControl.Call, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Call			= new OpCode("call",			Code.Call, OperandType.InlineMethod, FlowControl.Call, OpCodeType.Primitive, StackBehaviour.Varpush, StackBehaviour.Varpop);
		public static readonly OpCode Calli			= new OpCode("calli",			Code.Calli, OperandType.InlineSig, FlowControl.Call, OpCodeType.Primitive, StackBehaviour.Varpush, StackBehaviour.Varpop);
		public static readonly OpCode Ret			= new OpCode("ret",				Code.Ret, OperandType.InlineNone, FlowControl.Return, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Varpop);
		public static readonly OpCode Br_S			= new OpCode("br.s",			Code.Br_S, OperandType.ShortInlineBrTarget, FlowControl.Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Brfalse_S		= new OpCode("brfalse.s",		Code.Brfalse_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Brtrue_S		= new OpCode("brtrue.s",		Code.Brtrue_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Beq_S			= new OpCode("beq.s",			Code.Beq_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bge_S			= new OpCode("bge.s",			Code.Bge_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bgt_S			= new OpCode("bgt.s",			Code.Bgt_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ble_S			= new OpCode("ble.s",			Code.Ble_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Blt_S			= new OpCode("blt.s",			Code.Blt_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bne_Un_S		= new OpCode("bne.un.s",		Code.Bne_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bge_Un_S		= new OpCode("bge.un.s",		Code.Bge_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bgt_Un_S		= new OpCode("bgt.un.s",		Code.Bgt_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ble_Un_S		= new OpCode("ble.un.s",		Code.Ble_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Blt_Un_S		= new OpCode("blt.un.s",		Code.Blt_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Br			= new OpCode("br",				Code.Br, OperandType.InlineBrTarget, FlowControl.Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Brfalse		= new OpCode("brfalse",			Code.Brfalse, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Brtrue		= new OpCode("brtrue",			Code.Brtrue, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Beq			= new OpCode("beq",				Code.Beq, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bge			= new OpCode("bge",				Code.Bge, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bgt			= new OpCode("bgt",				Code.Bgt, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ble			= new OpCode("ble",				Code.Ble, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Blt			= new OpCode("blt",				Code.Blt, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bne_Un		= new OpCode("bne.un",			Code.Bne_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bge_Un		= new OpCode("bge.un",			Code.Bge_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bgt_Un		= new OpCode("bgt.un",			Code.Bgt_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ble_Un		= new OpCode("ble.un",			Code.Ble_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Blt_Un		= new OpCode("blt.un",			Code.Blt_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Switch		= new OpCode("switch",			Code.Switch, OperandType.InlineSwitch, FlowControl.Cond_Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I1		= new OpCode("ldind.i1",		Code.Ldind_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_U1		= new OpCode("ldind.u1",		Code.Ldind_U1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I2		= new OpCode("ldind.i2",		Code.Ldind_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_U2		= new OpCode("ldind.u2",		Code.Ldind_U2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I4		= new OpCode("ldind.i4",		Code.Ldind_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_U4		= new OpCode("ldind.u4",		Code.Ldind_U4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I8		= new OpCode("ldind.i8",		Code.Ldind_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I		= new OpCode("ldind.i",			Code.Ldind_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_R4		= new OpCode("ldind.r4",		Code.Ldind_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr4, StackBehaviour.Popi);
		public static readonly OpCode Ldind_R8		= new OpCode("ldind.r8",		Code.Ldind_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Popi);
		public static readonly OpCode Ldind_Ref		= new OpCode("ldind.ref",		Code.Ldind_Ref, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushref, StackBehaviour.Popi);
		public static readonly OpCode Stind_Ref		= new OpCode("stind.ref",		Code.Stind_Ref, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Stind_I1		= new OpCode("stind.i1",		Code.Stind_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Stind_I2		= new OpCode("stind.i2",		Code.Stind_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Stind_I4		= new OpCode("stind.i4",		Code.Stind_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Stind_I8		= new OpCode("stind.i8",		Code.Stind_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi8);
		public static readonly OpCode Stind_R4		= new OpCode("stind.r4",		Code.Stind_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popr4);
		public static readonly OpCode Stind_R8		= new OpCode("stind.r8",		Code.Stind_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popr8);
		public static readonly OpCode Add			= new OpCode("add",				Code.Add, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Sub			= new OpCode("sub",				Code.Sub, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Mul			= new OpCode("mul",				Code.Mul, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Div			= new OpCode("div",				Code.Div, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Div_Un		= new OpCode("div.un",			Code.Div_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Rem			= new OpCode("rem",				Code.Rem, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Rem_Un		= new OpCode("rem.un",			Code.Rem_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode And			= new OpCode("and",				Code.And, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Or			= new OpCode("or",				Code.Or, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Xor			= new OpCode("xor",				Code.Xor, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Shl			= new OpCode("shl",				Code.Shl, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Shr			= new OpCode("shr",				Code.Shr, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Shr_Un		= new OpCode("shr.un",			Code.Shr_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Neg			= new OpCode("neg",				Code.Neg, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1);
		public static readonly OpCode Not			= new OpCode("not",				Code.Not, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I1		= new OpCode("conv.i1",			Code.Conv_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I2		= new OpCode("conv.i2",			Code.Conv_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I4		= new OpCode("conv.i4",			Code.Conv_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I8		= new OpCode("conv.i8",			Code.Conv_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_R4		= new OpCode("conv.r4",			Code.Conv_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr4, StackBehaviour.Pop1);
		public static readonly OpCode Conv_R8		= new OpCode("conv.r8",			Code.Conv_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_U4		= new OpCode("conv.u4",			Code.Conv_U4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_U8		= new OpCode("conv.u8",			Code.Conv_U8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Callvirt		= new OpCode("callvirt",		Code.Callvirt, OperandType.InlineMethod, FlowControl.Call, OpCodeType.Objmodel, StackBehaviour.Varpush, StackBehaviour.Varpop);
		public static readonly OpCode Cpobj			= new OpCode("cpobj",			Code.Cpobj, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Ldobj			= new OpCode("ldobj",			Code.Ldobj, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Popi);
		public static readonly OpCode Ldstr			= new OpCode("ldstr",			Code.Ldstr, OperandType.InlineString, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Pop0);
		public static readonly OpCode Newobj		= new OpCode("newobj",			Code.Newobj, OperandType.InlineMethod, FlowControl.Call, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Varpop);
		public static readonly OpCode Castclass		= new OpCode("castclass",		Code.Castclass, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Popref);
		public static readonly OpCode Isinst		= new OpCode("isinst",			Code.Isinst, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Conv_R_Un		= new OpCode("conv.r.un",		Code.Conv_R_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Pop1);
		public static readonly OpCode Unbox			= new OpCode("unbox",			Code.Unbox, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Throw			= new OpCode("throw",			Code.Throw, OperandType.InlineNone, FlowControl.Throw, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref);
		public static readonly OpCode Ldfld			= new OpCode("ldfld",			Code.Ldfld, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Popref);
		public static readonly OpCode Ldflda		= new OpCode("ldflda",			Code.Ldflda, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Stfld			= new OpCode("stfld",			Code.Stfld, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_pop1);
		public static readonly OpCode Ldsfld		= new OpCode("ldsfld",			Code.Ldsfld, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldsflda		= new OpCode("ldsflda",			Code.Ldsflda, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Stsfld		= new OpCode("stsfld",			Code.Stsfld, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Stobj			= new OpCode("stobj",			Code.Stobj, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_pop1);
		public static readonly OpCode Conv_Ovf_I1_Un= new OpCode("conv.ovf.i1.un",	Code.Conv_Ovf_I1_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I2_Un= new OpCode("conv.ovf.i2.un",	Code.Conv_Ovf_I2_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I4_Un= new OpCode("conv.ovf.i4.un",	Code.Conv_Ovf_I4_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I8_Un= new OpCode("conv.ovf.i8.un",	Code.Conv_Ovf_I8_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U1_Un= new OpCode("conv.ovf.u1.un",	Code.Conv_Ovf_U1_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U2_Un= new OpCode("conv.ovf.u2.un",	Code.Conv_Ovf_U2_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U4_Un= new OpCode("conv.ovf.u4.un",	Code.Conv_Ovf_U4_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U8_Un= new OpCode("conv.ovf.u8.un",	Code.Conv_Ovf_U8_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I_Un	= new OpCode("conv.ovf.i.un",	Code.Conv_Ovf_I_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U_Un	= new OpCode("conv.ovf.u.un",	Code.Conv_Ovf_U_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Box			= new OpCode("box",				Code.Box, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushref, StackBehaviour.Pop1);
		public static readonly OpCode Newarr		= new OpCode("newarr",			Code.Newarr, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Popi);
		public static readonly OpCode Ldlen			= new OpCode("ldlen",			Code.Ldlen, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Ldelema		= new OpCode("ldelema",			Code.Ldelema, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I1		= new OpCode("ldelem.i1",		Code.Ldelem_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_U1		= new OpCode("ldelem.u1",		Code.Ldelem_U1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I2		= new OpCode("ldelem.i2",		Code.Ldelem_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_U2		= new OpCode("ldelem.u2",		Code.Ldelem_U2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I4		= new OpCode("ldelem.i4",		Code.Ldelem_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_U4		= new OpCode("ldelem.u4",		Code.Ldelem_U4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I8		= new OpCode("ldelem.i8",		Code.Ldelem_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi8, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I		= new OpCode("ldelem.i",		Code.Ldelem_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_R4		= new OpCode("ldelem.r4",		Code.Ldelem_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushr4, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_R8		= new OpCode("ldelem.r8",		Code.Ldelem_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushr8, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_Ref	= new OpCode("ldelem.ref",		Code.Ldelem_Ref, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Popref_popi);
		public static readonly OpCode Stelem_I		= new OpCode("stelem.i",		Code.Stelem_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi);
		public static readonly OpCode Stelem_I1		= new OpCode("stelem.i1",		Code.Stelem_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi);
		public static readonly OpCode Stelem_I2		= new OpCode("stelem.i2",		Code.Stelem_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi);
		public static readonly OpCode Stelem_I4		= new OpCode("stelem.i4",		Code.Stelem_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi);
		public static readonly OpCode Stelem_I8		= new OpCode("stelem.i8",		Code.Stelem_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi8);
		public static readonly OpCode Stelem_R4		= new OpCode("stelem.r4",		Code.Stelem_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popr4);
		public static readonly OpCode Stelem_R8		= new OpCode("stelem.r8",		Code.Stelem_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popr8);
		public static readonly OpCode Stelem_Ref	= new OpCode("stelem.ref",		Code.Stelem_Ref, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popref);
		public static readonly OpCode Ldelem		= new OpCode("ldelem",			Code.Ldelem, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Popref_popi);
		public static readonly OpCode Stelem		= new OpCode("stelem",			Code.Stelem, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_pop1);
		public static readonly OpCode Unbox_Any		= new OpCode("unbox.any",		Code.Unbox_Any, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Popref);
		public static readonly OpCode Conv_Ovf_I1	= new OpCode("conv.ovf.i1",		Code.Conv_Ovf_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U1	= new OpCode("conv.ovf.u1",		Code.Conv_Ovf_U1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I2	= new OpCode("conv.ovf.i2",		Code.Conv_Ovf_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U2	= new OpCode("conv.ovf.u2",		Code.Conv_Ovf_U2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I4	= new OpCode("conv.ovf.i4",		Code.Conv_Ovf_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U4	= new OpCode("conv.ovf.u4",		Code.Conv_Ovf_U4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I8	= new OpCode("conv.ovf.i8",		Code.Conv_Ovf_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U8	= new OpCode("conv.ovf.u8",		Code.Conv_Ovf_U8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Refanyval		= new OpCode("refanyval",		Code.Refanyval, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Ckfinite		= new OpCode("ckfinite",		Code.Ckfinite, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Pop1);
		public static readonly OpCode Mkrefany		= new OpCode("mkrefany",		Code.Mkrefany, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Popi);
		public static readonly OpCode Ldtoken		= new OpCode("ldtoken",			Code.Ldtoken, OperandType.InlineTok, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Conv_U2		= new OpCode("conv.u2",			Code.Conv_U2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_U1		= new OpCode("conv.u1",			Code.Conv_U1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I		= new OpCode("conv.i",			Code.Conv_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I	= new OpCode("conv.ovf.i",		Code.Conv_Ovf_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U	= new OpCode("conv.ovf.u",		Code.Conv_Ovf_U, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Add_Ovf		= new OpCode("add.ovf",			Code.Add_Ovf, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Add_Ovf_Un	= new OpCode("add.ovf.un",		Code.Add_Ovf_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Mul_Ovf		= new OpCode("mul.ovf",			Code.Mul_Ovf, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Mul_Ovf_Un	= new OpCode("mul.ovf.un",		Code.Mul_Ovf_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Sub_Ovf		= new OpCode("sub.ovf",			Code.Sub_Ovf, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Sub_Ovf_Un	= new OpCode("sub.ovf.un",		Code.Sub_Ovf_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Endfinally	= new OpCode("endfinally",		Code.Endfinally, OperandType.InlineNone, FlowControl.Return, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.PopAll);
		public static readonly OpCode Leave			= new OpCode("leave",			Code.Leave, OperandType.InlineBrTarget, FlowControl.Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.PopAll);
		public static readonly OpCode Leave_S		= new OpCode("leave.s",			Code.Leave_S, OperandType.ShortInlineBrTarget, FlowControl.Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.PopAll);
		public static readonly OpCode Stind_I		= new OpCode("stind.i",			Code.Stind_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Conv_U		= new OpCode("conv.u",			Code.Conv_U, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Prefix7		= new OpCode("prefix7",			Code.Prefix7, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix6		= new OpCode("prefix6",			Code.Prefix6, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix5		= new OpCode("prefix5",			Code.Prefix5, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix4		= new OpCode("prefix4",			Code.Prefix4, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix3		= new OpCode("prefix3",			Code.Prefix3, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix2		= new OpCode("prefix2",			Code.Prefix2, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix1		= new OpCode("prefix1",			Code.Prefix1, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefixref		= new OpCode("prefixref",		Code.Prefixref, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Arglist		= new OpCode("arglist",			Code.Arglist, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ceq			= new OpCode("ceq",				Code.Ceq, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Cgt			= new OpCode("cgt",				Code.Cgt, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Cgt_Un		= new OpCode("cgt.un",			Code.Cgt_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Clt			= new OpCode("clt",				Code.Clt, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Clt_Un		= new OpCode("clt.un",			Code.Clt_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ldftn			= new OpCode("ldftn",			Code.Ldftn, OperandType.InlineMethod, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldvirtftn		= new OpCode("ldvirtftn",		Code.Ldvirtftn, OperandType.InlineMethod, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Ldarg			= new OpCode("ldarg",			Code.Ldarg, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarga		= new OpCode("ldarga",			Code.Ldarga, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Starg			= new OpCode("starg",			Code.Starg, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Ldloc			= new OpCode("ldloc",			Code.Ldloc, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloca		= new OpCode("ldloca",			Code.Ldloca, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Stloc			= new OpCode("stloc",			Code.Stloc, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Localloc		= new OpCode("localloc",		Code.Localloc, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Endfilter		= new OpCode("endfilter",		Code.Endfilter, OperandType.InlineNone, FlowControl.Return, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Unaligned		= new OpCode("unaligned.",		Code.Unaligned, OperandType.ShortInlineI, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Volatile		= new OpCode("volatile.",		Code.Volatile, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Tailcall		= new OpCode("tail.",			Code.Tailcall, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Initobj		= new OpCode("initobj",			Code.Initobj, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Constrained	= new OpCode("constrained.",	Code.Constrained, OperandType.InlineType, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Cpblk			= new OpCode("cpblk",			Code.Cpblk, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi_popi);
		public static readonly OpCode Initblk		= new OpCode("initblk",			Code.Initblk, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi_popi);
//		public static readonly OpCode No			= new OpCode("no.",				Code.No, OperandType.ShortInlineI, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Rethrow		= new OpCode("rethrow",			Code.Rethrow, OperandType.InlineNone, FlowControl.Throw, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Sizeof		= new OpCode("sizeof",			Code.Sizeof, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Refanytype	= new OpCode("refanytype",		Code.Refanytype, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Readonly		= new OpCode("readonly.",		Code.Readonly, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
#pragma warning restore

		static OpCodes() {
			// The OpCode ctor copies itself to one of these arrays. Whatever are still null
			// are unsupported opcodes. Set them all to UNKNOWN1 or UNKNOWN2.
			for (int i = 0; i < OneByteOpCodes.Length; i++) {
				if (OneByteOpCodes[i] == null)
					OneByteOpCodes[i] = UNKNOWN1;
			}
			for (int i = 0; i < TwoByteOpCodes.Length; i++) {
				if (TwoByteOpCodes[i] == null)
					TwoByteOpCodes[i] = UNKNOWN2;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/OperandType.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using dnlib.DotNet.MD;

namespace dnlib.DotNet.Emit {
	/// <summary>
	/// CIL opcode operand type
	/// </summary>
	public enum OperandType : byte {
		/// <summary>4-byte relative instruction offset</summary>
		InlineBrTarget,
		/// <summary>4-byte field token (<see cref="Table.Field"/> or <see cref="Table.MemberRef"/>)</summary>
		InlineField,
		/// <summary>int32</summary>
		InlineI,
		/// <summary>int64</summary>
		InlineI8,
		/// <summary>4-byte method token (<see cref="Table.Method"/>, <see cref="Table.MemberRef"/>
		/// or <see cref="Table.MethodSpec"/>)</summary>
		InlineMethod,
		/// <summary>No operand</summary>
		InlineNone,
		/// <summary>Never used</summary>
		InlinePhi,
		/// <summary>64-bit real</summary>
		InlineR,
		/// <summary/>
		NOT_USED_8,
		/// <summary>4-byte method sig token (<see cref="Table.StandAloneSig"/>)</summary>
		InlineSig,
		/// <summary>4-byte string token (<c>0x70xxxxxx</c>)</summary>
		InlineString,
		/// <summary>4-byte count N followed by N 4-byte relative instruction offsets</summary>
		InlineSwitch,
		/// <summary>4-byte token (<see cref="Table.Field"/>, <see cref="Table.MemberRef"/>,
		/// <see cref="Table.Method"/>, <see cref="Table.MethodSpec"/>, <see cref="Table.TypeDef"/>,
		/// <see cref="Table.TypeRef"/> or <see cref="Table.TypeSpec"/>)</summary>
		InlineTok,
		/// <summary>4-byte type token (<see cref="Table.TypeDef"/>, <see cref="Table.TypeRef"/> or
		/// <see cref="Table.TypeSpec"/>)</summary>
		InlineType,
		/// <summary>2-byte param/local index</summary>
		InlineVar,
		/// <summary>1-byte relative instruction offset</summary>
		ShortInlineBrTarget,
		/// <summary>1-byte sbyte (<see cref="Code.Ldc_I4_S"/>) or byte (the rest)</summary>
		ShortInlineI,
		/// <summary>32-bit real</summary>
		ShortInlineR,
		/// <summary>1-byte param/local index</summary>
		ShortInlineVar,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Emit/StackBehaviour.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Emit {
	/// <summary>
	/// CIL opcode stack behavior
	/// </summary>
	public enum StackBehaviour : byte {
		/// <summary/>
		Pop0,
		/// <summary/>
		Pop1,
		/// <summary/>
		Pop1_pop1,
		/// <summary/>
		Popi,
		/// <summary/>
		Popi_pop1,
		/// <summary/>
		Popi_popi,
		/// <summary/>
		Popi_popi8,
		/// <summary/>
		Popi_popi_popi,
		/// <summary/>
		Popi_popr4,
		/// <summary/>
		Popi_popr8,
		/// <summary/>
		Popref,
		/// <summary/>
		Popref_pop1,
		/// <summary/>
		Popref_popi,
		/// <summary/>
		Popref_popi_popi,
		/// <summary/>
		Popref_popi_popi8,
		/// <summary/>
		Popref_popi_popr4,
		/// <summary/>
		Popref_popi_popr8,
		/// <summary/>
		Popref_popi_popref,
		/// <summary/>
		Push0,
		/// <summary/>
		Push1,
		/// <summary/>
		Push1_push1,
		/// <summary/>
		Pushi,
		/// <summary/>
		Pushi8,
		/// <summary/>
		Pushr4,
		/// <summary/>
		Pushr8,
		/// <summary/>
		Pushref,
		/// <summary/>
		Varpop,
		/// <summary/>
		Varpush,
		/// <summary/>
		Popref_popi_pop1,
		/// <summary/>
		PopAll = 0xFF,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/BlobStream.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the #Blob stream
	/// </summary>
	public sealed class BlobStream : HeapStream {
		static readonly byte[] noData = new byte[0];

		/// <inheritdoc/>
		public BlobStream() {
		}

		/// <inheritdoc/>
		public BlobStream(IImageStream imageStream, StreamHeader streamHeader)
			: base(imageStream, streamHeader) {
		}

		/// <summary>
		/// Reads data
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns>The data or <c>null</c> if invalid offset</returns>
		public byte[] Read(uint offset) {
			// The CLR has a special check for offset 0. It always interprets it as
			// 0-length data, even if that first byte isn't 0 at all.
			if (offset == 0)
				return noData;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			IImageStream reader;
			int size = GetReader_NoLock(offset, out reader);
			if (size < 0)
				return null;
			return reader.ReadBytes(size);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads data just like <see cref="Read"/>, but returns an empty array if
		/// offset is invalid
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns>The data</returns>
		public byte[] ReadNoNull(uint offset) {
			return Read(offset) ?? noData;
		}

		/// <summary>
		/// Creates a new sub stream of the #Blob stream that can access one blob
		/// </summary>
		/// <param name="offset">Offset of blob</param>
		/// <returns>A new stream</returns>
		public IImageStream CreateStream(uint offset) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			IImageStream reader;
			int size = GetReader_NoLock(offset, out reader);
			if (size < 0)
				return MemoryImageStream.CreateEmpty();
			return reader.Create((FileOffset)reader.Position, size);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		int GetReader_NoLock(uint offset, out IImageStream reader) {
			reader = null;
			if (!IsValidOffset(offset))
				return -1;
			reader = GetReader_NoLock(offset);
			uint length;
			if (!reader.ReadCompressedUInt32(out length))
				return -1;
			if (reader.Position + length < length || reader.Position + length > reader.Length)
				return -1;

			return (int)length;	// length <= 0x1FFFFFFF so this cast does not make it negative
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/CodedToken.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Contains all possible coded token classes
	/// </summary>
	public sealed class CodedToken {
		/// <summary>TypeDefOrRef coded token</summary>
		public static readonly CodedToken TypeDefOrRef = new CodedToken(2, new Table[3] {
			Table.TypeDef, Table.TypeRef, Table.TypeSpec,
		});

		/// <summary>HasConstant coded token</summary>
		public static readonly CodedToken HasConstant = new CodedToken(2, new Table[3] {
			Table.Field, Table.Param, Table.Property,
		});

		/// <summary>HasCustomAttribute coded token</summary>
		public static readonly CodedToken HasCustomAttribute = new CodedToken(5, new Table[24] {
			Table.Method, Table.Field, Table.TypeRef, Table.TypeDef,
			Table.Param, Table.InterfaceImpl, Table.MemberRef, Table.Module,
			Table.DeclSecurity, Table.Property, Table.Event, Table.StandAloneSig,
			Table.ModuleRef, Table.TypeSpec, Table.Assembly, Table.AssemblyRef,
			Table.File, Table.ExportedType, Table.ManifestResource, Table.GenericParam,
			Table.GenericParamConstraint, Table.MethodSpec, 0, 0,
		});

		/// <summary>HasFieldMarshal coded token</summary>
		public static readonly CodedToken HasFieldMarshal = new CodedToken(1, new Table[2] {
			Table.Field, Table.Param,
		});

		/// <summary>HasDeclSecurity coded token</summary>
		public static readonly CodedToken HasDeclSecurity = new CodedToken(2, new Table[3] {
			Table.TypeDef, Table.Method, Table.Assembly,
		});

		/// <summary>MemberRefParent coded token</summary>
		public static readonly CodedToken MemberRefParent = new CodedToken(3, new Table[5] {
			Table.TypeDef, Table.TypeRef, Table.ModuleRef, Table.Method,
			Table.TypeSpec,
		});

		/// <summary>HasSemantic coded token</summary>
		public static readonly CodedToken HasSemantic = new CodedToken(1, new Table[2] {
			Table.Event, Table.Property,
		});

		/// <summary>MethodDefOrRef coded token</summary>
		public static readonly CodedToken MethodDefOrRef = new CodedToken(1, new Table[2] {
			Table.Method, Table.MemberRef,
		});

		/// <summary>MemberForwarded coded token</summary>
		public static readonly CodedToken MemberForwarded = new CodedToken(1, new Table[2] {
			Table.Field, Table.Method,
		});

		/// <summary>Implementation coded token</summary>
		public static readonly CodedToken Implementation = new CodedToken(2, new Table[3] {
			Table.File, Table.AssemblyRef, Table.ExportedType,
		});

		/// <summary>CustomAttributeType coded token</summary>
		public static readonly CodedToken CustomAttributeType = new CodedToken(3, new Table[4] {
			0, 0, Table.Method, Table.MemberRef,
		});

		/// <summary>ResolutionScope coded token</summary>
		public static readonly CodedToken ResolutionScope = new CodedToken(2, new Table[4] {
			Table.Module, Table.ModuleRef, Table.AssemblyRef, Table.TypeRef,
		});

		/// <summary>TypeOrMethodDef coded token</summary>
		public static readonly CodedToken TypeOrMethodDef = new CodedToken(1, new Table[2] {
			Table.TypeDef, Table.Method,
		});

		/// <summary>HasCustomDebugInformation coded token</summary>
		public static readonly CodedToken HasCustomDebugInformation = new CodedToken(5, new Table[27] {
			Table.Method, Table.Field, Table.TypeRef, Table.TypeDef,
			Table.Param, Table.InterfaceImpl, Table.MemberRef, Table.Module,
			Table.DeclSecurity, Table.Property, Table.Event, Table.StandAloneSig,
			Table.ModuleRef, Table.TypeSpec, Table.Assembly, Table.AssemblyRef,
			Table.File, Table.ExportedType, Table.ManifestResource, Table.GenericParam,
			Table.GenericParamConstraint, Table.MethodSpec, Table.Document, Table.LocalScope,
			Table.LocalVariable, Table.LocalConstant, Table.ImportScope,
		});

		readonly Table[] tableTypes;
		readonly int bits;
		readonly int mask;

		/// <summary>
		/// Returns all types of tables
		/// </summary>
		public Table[] TableTypes {
			get { return tableTypes; }
		}

		/// <summary>
		/// Returns the number of bits that is used to encode table type
		/// </summary>
		public int Bits {
			get { return bits; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="bits">Number of bits used to encode token type</param>
		/// <param name="tableTypes">All table types</param>
		internal CodedToken(int bits, Table[] tableTypes) {
			this.bits = bits;
			this.mask = (1 << bits) - 1;
			this.tableTypes = tableTypes;
		}

		/// <summary>
		/// Encodes a token
		/// </summary>
		/// <param name="token">The token</param>
		/// <returns>Coded token</returns>
		/// <seealso cref="Encode(MDToken,out uint)"/>
		public uint Encode(MDToken token) {
			return Encode(token.Raw);
		}

		/// <summary>
		/// Encodes a token
		/// </summary>
		/// <param name="token">The token</param>
		/// <returns>Coded token</returns>
		/// <seealso cref="Encode(uint,out uint)"/>
		public uint Encode(uint token) {
			uint codedToken;
			Encode(token, out codedToken);
			return codedToken;
		}

		/// <summary>
		/// Encodes a token
		/// </summary>
		/// <param name="token">The token</param>
		/// <param name="codedToken">Coded token</param>
		/// <returns><c>true</c> if successful</returns>
		public bool Encode(MDToken token, out uint codedToken) {
			return Encode(token.Raw, out codedToken);
		}

		/// <summary>
		/// Encodes a token
		/// </summary>
		/// <param name="token">The token</param>
		/// <param name="codedToken">Coded token</param>
		/// <returns><c>true</c> if successful</returns>
		public bool Encode(uint token, out uint codedToken) {
			int index = Array.IndexOf(tableTypes, MDToken.ToTable(token));
			if (index < 0) {
				codedToken = uint.MaxValue;
				return false;
			}
			// This shift can never overflow a uint since bits < 8 (it's at most 5), and
			// ToRid() returns an integer <= 0x00FFFFFF.
			codedToken = (MDToken.ToRID(token) << bits) | (uint)index;
			return true;
		}

		/// <summary>
		/// Decodes a coded token
		/// </summary>
		/// <param name="codedToken">The coded token</param>
		/// <returns>Decoded token or 0 on failure</returns>
		/// <seealso cref="Decode(uint,out MDToken)"/>
		public MDToken Decode2(uint codedToken) {
			uint token;
			Decode(codedToken, out token);
			return new MDToken(token);
		}

		/// <summary>
		/// Decodes a coded token
		/// </summary>
		/// <param name="codedToken">The coded token</param>
		/// <returns>Decoded token or 0 on failure</returns>
		/// <seealso cref="Decode(uint,out uint)"/>
		public uint Decode(uint codedToken) {
			uint token;
			Decode(codedToken, out token);
			return token;
		}

		/// <summary>
		/// Decodes a coded token
		/// </summary>
		/// <param name="codedToken">The coded token</param>
		/// <param name="token">Decoded token</param>
		/// <returns><c>true</c> if successful</returns>
		public bool Decode(uint codedToken, out MDToken token) {
			uint decodedToken;
			bool result = Decode(codedToken, out decodedToken);
			token = new MDToken(decodedToken);
			return result;
		}

		/// <summary>
		/// Decodes a coded token
		/// </summary>
		/// <param name="codedToken">The coded token</param>
		/// <param name="token">Decoded token</param>
		/// <returns><c>true</c> if successful</returns>
		public bool Decode(uint codedToken, out uint token) {
			uint rid = codedToken >> bits;
			int index = (int)(codedToken & mask);
			if (rid > MDToken.RID_MAX || index >= tableTypes.Length) {
				token = 0;
				return false;
			}

			token = ((uint)tableTypes[index] << MDToken.TABLE_SHIFT) | rid;
			return true;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/ColumnInfo.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Diagnostics;
using System.IO;
using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Info about one column in a MD table
	/// </summary>
	[DebuggerDisplay("{offset} {size} {name}")]
	public sealed class ColumnInfo {
		readonly byte index;
		byte offset;
		readonly ColumnSize columnSize;
		byte size;
		readonly string name;

		/// <summary>
		/// Gets the column index
		/// </summary>
		public int Index {
			get { return index; }
		}

		/// <summary>
		/// Returns the column offset within the table row
		/// </summary>
		public int Offset {
			get { return offset; }
			internal set { offset = (byte)value; }
		}

		/// <summary>
		/// Returns the column size
		/// </summary>
		public int Size {
			get { return size; }
			internal set { size = (byte)value; }
		}

		/// <summary>
		/// Returns the column name
		/// </summary>
		public string Name {
			get { return name; }
		}

		/// <summary>
		/// Returns the ColumnSize enum value
		/// </summary>
		public ColumnSize ColumnSize {
			get { return columnSize; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="index">Column index</param>
		/// <param name="name">The column name</param>
		/// <param name="columnSize">Column size</param>
		public ColumnInfo(byte index, string name, ColumnSize columnSize) {
			this.index = index;
			this.name = name;
			this.columnSize = columnSize;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="index">Column index</param>
		/// <param name="name">The column name</param>
		/// <param name="columnSize">Column size</param>
		/// <param name="offset">Offset of column</param>
		/// <param name="size">Size of column</param>
		public ColumnInfo(byte index, string name, ColumnSize columnSize, byte offset, byte size) {
			this.index = index;
			this.name = name;
			this.columnSize = columnSize;
			this.offset = offset;
			this.size = size;
		}

		/// <summary>
		/// Reads the column
		/// </summary>
		/// <param name="reader">A reader positioned on this column</param>
		/// <returns>The column value</returns>
		public uint Read(IBinaryReader reader) {
			switch (size) {
			case 1: return reader.ReadByte();
			case 2: return reader.ReadUInt16();
			case 4: return reader.ReadUInt32();
			default: throw new InvalidOperationException("Invalid column size");
			}
		}

		/// <summary>
		/// Writes a column
		/// </summary>
		/// <param name="writer">The writer position on this column</param>
		/// <param name="value">The column value</param>
		public void Write(BinaryWriter writer, uint value) {
			switch (size) {
			case 1: writer.Write((byte)value); break;
			case 2: writer.Write((ushort)value); break;
			case 4: writer.Write(value); break;
			default: throw new InvalidOperationException("Invalid column size");
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/ColumnSize.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.MD {
	/// <summary>
	/// MD table column size
	/// </summary>
	public enum ColumnSize : byte {
		/// <summary>RID into Module table</summary>
		Module,
		/// <summary>RID into TypeRef table</summary>
		TypeRef,
		/// <summary>RID into TypeDef table</summary>
		TypeDef,
		/// <summary>RID into FieldPtr table</summary>
		FieldPtr,
		/// <summary>RID into Field table</summary>
		Field,
		/// <summary>RID into MethodPtr table</summary>
		MethodPtr,
		/// <summary>RID into Method table</summary>
		Method,
		/// <summary>RID into ParamPtr table</summary>
		ParamPtr,
		/// <summary>RID into Param table</summary>
		Param,
		/// <summary>RID into InterfaceImpl table</summary>
		InterfaceImpl,
		/// <summary>RID into MemberRef table</summary>
		MemberRef,
		/// <summary>RID into Constant table</summary>
		Constant,
		/// <summary>RID into CustomAttribute table</summary>
		CustomAttribute,
		/// <summary>RID into FieldMarshal table</summary>
		FieldMarshal,
		/// <summary>RID into DeclSecurity table</summary>
		DeclSecurity,
		/// <summary>RID into ClassLayout table</summary>
		ClassLayout,
		/// <summary>RID into FieldLayout table</summary>
		FieldLayout,
		/// <summary>RID into StandAloneSig table</summary>
		StandAloneSig,
		/// <summary>RID into EventMap table</summary>
		EventMap,
		/// <summary>RID into EventPtr table</summary>
		EventPtr,
		/// <summary>RID into Event table</summary>
		Event,
		/// <summary>RID into PropertyMap table</summary>
		PropertyMap,
		/// <summary>RID into PropertyPtr table</summary>
		PropertyPtr,
		/// <summary>RID into Property table</summary>
		Property,
		/// <summary>RID into MethodSemantics table</summary>
		MethodSemantics,
		/// <summary>RID into MethodImpl table</summary>
		MethodImpl,
		/// <summary>RID into ModuleRef table</summary>
		ModuleRef,
		/// <summary>RID into TypeSpec table</summary>
		TypeSpec,
		/// <summary>RID into ImplMap table</summary>
		ImplMap,
		/// <summary>RID into FieldRVA table</summary>
		FieldRVA,
		/// <summary>RID into ENCLog table</summary>
		ENCLog,
		/// <summary>RID into ENCMap table</summary>
		ENCMap,
		/// <summary>RID into Assembly table</summary>
		Assembly,
		/// <summary>RID into AssemblyProcessor table</summary>
		AssemblyProcessor,
		/// <summary>RID into AssemblyOS table</summary>
		AssemblyOS,
		/// <summary>RID into AssemblyRef table</summary>
		AssemblyRef,
		/// <summary>RID into AssemblyRefProcessor table</summary>
		AssemblyRefProcessor,
		/// <summary>RID into AssemblyRefOS table</summary>
		AssemblyRefOS,
		/// <summary>RID into File table</summary>
		File,
		/// <summary>RID into ExportedType table</summary>
		ExportedType,
		/// <summary>RID into ManifestResource table</summary>
		ManifestResource,
		/// <summary>RID into NestedClass table</summary>
		NestedClass,
		/// <summary>RID into GenericParam table</summary>
		GenericParam,
		/// <summary>RID into MethodSpec table</summary>
		MethodSpec,
		/// <summary>RID into GenericParamConstraint table</summary>
		GenericParamConstraint,
		/// <summary>RID into Document table</summary>
		Document = 0x30,
		/// <summary>RID into MethodDebugInformation table</summary>
		MethodDebugInformation,
		/// <summary>RID into LocalScope table</summary>
		LocalScope,
		/// <summary>RID into LocalVariable table</summary>
		LocalVariable,
		/// <summary>RID into LocalConstant table</summary>
		LocalConstant,
		/// <summary>RID into ImportScope table</summary>
		ImportScope,
		/// <summary>RID into StateMachineMethod table</summary>
		StateMachineMethod,
		/// <summary>RID into CustomDebugInformation table</summary>
		CustomDebugInformation,
		/// <summary>8-bit byte</summary>
		Byte = 0x40,
		/// <summary>16-bit signed int</summary>
		Int16,
		/// <summary>16-bit unsigned int</summary>
		UInt16,
		/// <summary>32-bit signed int</summary>
		Int32,
		/// <summary>32-bit unsigned int</summary>
		UInt32,
		/// <summary>Index into #Strings stream</summary>
		Strings,
		/// <summary>Index into #GUID stream</summary>
		GUID,
		/// <summary>Index into #Blob stream</summary>
		Blob,
		/// <summary>TypeDefOrRef encoded token</summary>
		TypeDefOrRef,
		/// <summary>HasConstant encoded token</summary>
		HasConstant,
		/// <summary>HasCustomAttribute encoded token</summary>
		HasCustomAttribute,
		/// <summary>HasFieldMarshal encoded token</summary>
		HasFieldMarshal,
		/// <summary>HasDeclSecurity encoded token</summary>
		HasDeclSecurity,
		/// <summary>MemberRefParent encoded token</summary>
		MemberRefParent,
		/// <summary>HasSemantic encoded token</summary>
		HasSemantic,
		/// <summary>MethodDefOrRef encoded token</summary>
		MethodDefOrRef,
		/// <summary>MemberForwarded encoded token</summary>
		MemberForwarded,
		/// <summary>Implementation encoded token</summary>
		Implementation,
		/// <summary>CustomAttributeType encoded token</summary>
		CustomAttributeType,
		/// <summary>ResolutionScope encoded token</summary>
		ResolutionScope,
		/// <summary>TypeOrMethodDef encoded token</summary>
		TypeOrMethodDef,
		/// <summary>HasCustomDebugInformation encoded token</summary>
		HasCustomDebugInformation,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/ComImageFlags.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// See COMIMAGE_FLAGS_XXX in CorHdr.h in the Windows SDK
	/// </summary>
	[Flags]
	public enum ComImageFlags : uint {
		/// <summary>
		/// See COMIMAGE_FLAGS_ILONLY in the Windows SDK
		/// </summary>
		ILOnly = 1,

		/// <summary>
		/// See COMIMAGE_FLAGS_32BITREQUIRED in the Windows SDK
		/// </summary>
		_32BitRequired = 2,

		/// <summary>
		/// Set if a native header exists (COMIMAGE_FLAGS_IL_LIBRARY)
		/// </summary>
		ILLibrary = 4,

		/// <summary>
		/// See COMIMAGE_FLAGS_STRONGNAMESIGNED in the Windows SDK
		/// </summary>
		StrongNameSigned = 8,

		/// <summary>
		/// See COMIMAGE_FLAGS_NATIVE_ENTRYPOINT in the Windows SDK
		/// </summary>
		NativeEntryPoint = 0x10,

		/// <summary>
		/// See COMIMAGE_FLAGS_TRACKDEBUGDATA in the Windows SDK
		/// </summary>
		TrackDebugData = 0x10000,

		/// <summary>
		/// See COMIMAGE_FLAGS_32BITPREFERRED in the Windows SDK
		/// </summary>
		_32BitPreferred = 0x20000,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/CompressedMetaData.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using dnlib.IO;
using dnlib.PE;
using dnlib.Threading;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Used when a #~ stream is present in the metadata
	/// </summary>
	sealed class CompressedMetaData : MetaData {
		/// <inheritdoc/>
		public override bool IsCompressed {
			get { return true; }
		}

		/// <inheritdoc/>
		public CompressedMetaData(IPEImage peImage, ImageCor20Header cor20Header, MetaDataHeader mdHeader)
			: base(peImage, cor20Header, mdHeader) {
		}

		/// <inheritdoc/>
		internal CompressedMetaData(MetaDataHeader mdHeader, bool isStandalonePortablePdb)
			: base(mdHeader, isStandalonePortablePdb) {
		}

		static CompressedMetaData() {
			var windir = Environment.GetEnvironmentVariable("WINDIR");
			if (!string.IsNullOrEmpty(windir)) {
				var baseDir = Path.Combine(windir, "assembly");
				nativeImages40 = Path.Combine(baseDir, "NativeImages_v4.0.30319");
			}
		}

		static string nativeImages40;
		static HotHeapVersion GetHotHeapVersion(string fileName, string version) {
			// Some .NET 2.0 assemblies are stored in the 4.0 GAC. The version is not easily
			// detectable from the data in the image so check the path.
			if (nativeImages40 != null && fileName != null && fileName.StartsWith(nativeImages40, StringComparison.OrdinalIgnoreCase))
				return HotHeapVersion.CLR40;

			if (version.StartsWith(MDHeaderRuntimeVersion.MS_CLR_20_PREFIX))
				return HotHeapVersion.CLR20;
			if (version.StartsWith(MDHeaderRuntimeVersion.MS_CLR_40_PREFIX))
				return HotHeapVersion.CLR40;

			return HotHeapVersion.CLR40;
		}

		/// <inheritdoc/>
		protected override void InitializeInternal(IImageStream mdStream) {
			var hotHeapVersion = peImage == null ? HotHeapVersion.CLR20 : GetHotHeapVersion(peImage.FileName, mdHeader.VersionString);

			bool disposeOfMdStream = false;
			IImageStream imageStream = null, fullStream = null;
			DotNetStream dns = null;
			List<HotStream> hotStreams = null;
			HotStream hotStream = null;
			var newAllStreams = new List<DotNetStream>(allStreams);
			try {
				if (peImage != null) {
					Debug.Assert(mdStream == null);
					Debug.Assert(cor20Header != null);
					var mdOffset = peImage.ToFileOffset(cor20Header.MetaData.VirtualAddress);
					mdStream = peImage.CreateStream(mdOffset, cor20Header.MetaData.Size);
					disposeOfMdStream = true;
				}
				else
					Debug.Assert(mdStream != null);
				for (int i = mdHeader.StreamHeaders.Count - 1; i >= 0; i--) {
					var sh = mdHeader.StreamHeaders[i];
					imageStream = mdStream.Create((FileOffset)sh.Offset, sh.StreamSize);
					switch (sh.Name) {
					case "#Strings":
						if (stringsStream == null) {
							stringsStream = new StringsStream(imageStream, sh);
							imageStream = null;
							newAllStreams.Add(stringsStream);
							continue;
						}
						break;

					case "#US":
						if (usStream == null) {
							usStream = new USStream(imageStream, sh);
							imageStream = null;
							newAllStreams.Add(usStream);
							continue;
						}
						break;

					case "#Blob":
						if (blobStream == null) {
							blobStream = new BlobStream(imageStream, sh);
							imageStream = null;
							newAllStreams.Add(blobStream);
							continue;
						}
						break;

					case "#GUID":
						if (guidStream == null) {
							guidStream = new GuidStream(imageStream, sh);
							imageStream = null;
							newAllStreams.Add(guidStream);
							continue;
						}
						break;

					case "#~":
						if (tablesStream == null) {
							tablesStream = new TablesStream(imageStream, sh);
							imageStream = null;
							newAllStreams.Add(tablesStream);
							continue;
						}
						break;

					case "#!":
						if (peImage == null)
							break;
						if (hotStreams == null)
							hotStreams = new List<HotStream>();
						fullStream = peImage.CreateFullStream();
						hotStream = HotStream.Create(hotHeapVersion, imageStream, sh, fullStream, mdStream.FileOffset + sh.Offset);
						fullStream = null;
						hotStreams.Add(hotStream);
						newAllStreams.Add(hotStream);
						hotStream = null;
						imageStream = null;
						continue;

					case "#Pdb":
						if (isStandalonePortablePdb && pdbStream == null) {
							pdbStream = new PdbStream(imageStream, sh);
							imageStream = null;
							allStreams.Add(pdbStream);
							continue;
						}
						break;
					}
					dns = new DotNetStream(imageStream, sh);
					imageStream = null;
					newAllStreams.Add(dns);
					dns = null;
				}
			}
			finally {
				if (disposeOfMdStream)
					mdStream.Dispose();
				if (imageStream != null)
					imageStream.Dispose();
				if (fullStream != null)
					fullStream.Dispose();
				if (dns != null)
					dns.Dispose();
				if (hotStream != null)
					hotStream.Dispose();
				newAllStreams.Reverse();
				allStreams = ThreadSafeListCreator.MakeThreadSafe(newAllStreams);
			}

			if (tablesStream == null)
				throw new BadImageFormatException("Missing MD stream");

			if (hotStreams != null) {
				hotStreams.Reverse();
				InitializeHotStreams(hotStreams);
			}

			if (pdbStream != null)
				tablesStream.Initialize(pdbStream.TypeSystemTableRows);
			else
				tablesStream.Initialize(null);
		}

		int GetPointerSize() {
			if (peImage == null)
				return 4;
			return peImage.ImageNTHeaders.OptionalHeader.Magic == 0x10B ? 4 : 8;
		}

		void InitializeHotStreams(IList<HotStream> hotStreams) {
			if (hotStreams == null || hotStreams.Count == 0)
				return;

			// If this is a 32-bit image, make sure that we emulate this by masking
			// all base offsets to 32 bits.
			long offsetMask = GetPointerSize() == 8 ? -1L : uint.MaxValue;

			// It's always the last one found that is used
			var hotTable = hotStreams[hotStreams.Count - 1].HotTableStream;
			if (hotTable != null) {
				hotTable.Initialize(offsetMask);
				tablesStream.HotTableStream = hotTable;
			}

			HotHeapStream hotStrings = null, hotBlob = null, hotGuid = null, hotUs = null;
			for (int i = hotStreams.Count - 1; i >= 0; i--) {
				var hotStream = hotStreams[i];
				var hotHeapStreams = hotStream.HotHeapStreams;
				if (hotHeapStreams == null)
					continue;

				// It's always the last one found that is used
				for (int j = hotHeapStreams.Count - 1; j >= 0; j--) {
					var hotHeap = hotHeapStreams[j];
					switch (hotHeap.HeapType) {
					case HeapType.Strings:
						if (hotStrings == null) {
							hotHeap.Initialize(offsetMask);
							hotStrings = hotHeap;
						}
						break;

					case HeapType.Guid:
						if (hotGuid == null) {
							hotHeap.Initialize(offsetMask);
							hotGuid = hotHeap;
						}
						break;

					case HeapType.Blob:
						if (hotBlob == null) {
							hotHeap.Initialize(offsetMask);
							hotBlob = hotHeap;
						}
						break;

					case HeapType.US:
						if (hotUs == null) {
							hotHeap.Initialize(offsetMask);
							hotUs = hotHeap;
						}
						break;
					}
				}
			}
			InitializeNonExistentHeaps();
			stringsStream.HotHeapStream = hotStrings;
			guidStream.HotHeapStream = hotGuid;
			blobStream.HotHeapStream = hotBlob;
			usStream.HotHeapStream = hotUs;
		}

		/// <inheritdoc/>
		public override RidList GetFieldRidList(uint typeDefRid) {
			return GetRidList(tablesStream.TypeDefTable, typeDefRid, 4, tablesStream.FieldTable);
		}

		/// <inheritdoc/>
		public override RidList GetMethodRidList(uint typeDefRid) {
			return GetRidList(tablesStream.TypeDefTable, typeDefRid, 5, tablesStream.MethodTable);
		}

		/// <inheritdoc/>
		public override RidList GetParamRidList(uint methodRid) {
			return GetRidList(tablesStream.MethodTable, methodRid, 5, tablesStream.ParamTable);
		}

		/// <inheritdoc/>
		public override RidList GetEventRidList(uint eventMapRid) {
			return GetRidList(tablesStream.EventMapTable, eventMapRid, 1, tablesStream.EventTable);
		}

		/// <inheritdoc/>
		public override RidList GetPropertyRidList(uint propertyMapRid) {
			return GetRidList(tablesStream.PropertyMapTable, propertyMapRid, 1, tablesStream.PropertyTable);
		}

		/// <summary>
		/// Gets a rid list (eg. field list)
		/// </summary>
		/// <param name="tableSource">Source table, eg. <c>TypeDef</c></param>
		/// <param name="tableSourceRid">Row ID in <paramref name="tableSource"/></param>
		/// <param name="colIndex">Column index in <paramref name="tableSource"/>, eg. 4 for <c>TypeDef.FieldList</c></param>
		/// <param name="tableDest">Destination table, eg. <c>Field</c></param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetRidList(MDTable tableSource, uint tableSourceRid, int colIndex, MDTable tableDest) {
			var column = tableSource.TableInfo.Columns[colIndex];
			uint startRid, nextListRid;
			bool hasNext;
#if THREAD_SAFE
			tablesStream.theLock.EnterWriteLock(); try {
#endif
			if (!tablesStream.ReadColumn_NoLock(tableSource, tableSourceRid, column, out startRid))
				return RidList.Empty;
			hasNext = tablesStream.ReadColumn_NoLock(tableSource, tableSourceRid + 1, column, out nextListRid);
#if THREAD_SAFE
			} finally { tablesStream.theLock.ExitWriteLock(); }
#endif
			uint lastRid = tableDest.Rows + 1;
			if (startRid == 0 || startRid >= lastRid)
				return RidList.Empty;
			uint endRid = hasNext ? nextListRid : lastRid;
			if (endRid < startRid)
				endRid = startRid;
			if (endRid > lastRid)
				endRid = lastRid;
			return new ContiguousRidList(startRid, endRid - startRid);
		}

		/// <inheritdoc/>
		protected override uint BinarySearch_NoLock(MDTable tableSource, int keyColIndex, uint key) {
			var keyColumn = tableSource.TableInfo.Columns[keyColIndex];
			uint ridLo = 1, ridHi = tableSource.Rows;
			while (ridLo <= ridHi) {
				uint rid = (ridLo + ridHi) / 2;
				uint key2;
				if (!tablesStream.ReadColumn_NoLock(tableSource, rid, keyColumn, out key2))
					break;	// Never happens since rid is valid
				if (key == key2)
					return rid;
				if (key2 > key)
					ridHi = rid - 1;
				else
					ridLo = rid + 1;
			}

			return 0;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/DotNetStream.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using dnlib.IO;
using dnlib.Threading;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// .NET metadata stream
	/// </summary>
	[DebuggerDisplay("{imageStream.Length} {streamHeader.Name}")]
	public class DotNetStream : IFileSection, IDisposable {
		/// <summary>
		/// Reader that can access the whole stream
		/// </summary>
		protected IImageStream imageStream;

		/// <summary>
		/// <c>null</c> if it wasn't present in the file
		/// </summary>
		StreamHeader streamHeader;

		/// <inheritdoc/>
		public FileOffset StartOffset {
			get { return imageStream.FileOffset; }
		}

		/// <inheritdoc/>
		public FileOffset EndOffset {
			get { return imageStream.FileOffset + imageStream.Length; }
		}

		/// <summary>
		/// Gets the length of the internal .NET blob stream
		/// </summary>
		public long ImageStreamLength {
			get { return imageStream.Length; }
		}

		/// <summary>
		/// Gets the stream header
		/// </summary>
		public StreamHeader StreamHeader {
			get { return streamHeader; }
		}

		/// <summary>
		/// Gets the name of the stream
		/// </summary>
		public string Name {
			get { return streamHeader == null ? string.Empty : streamHeader.Name; }
		}

		/// <summary>
		/// Returns a cloned <see cref="IImageStream"/> of the internal .NET blob stream.
		/// </summary>
		/// <returns>A new <see cref="IImageStream"/> instance</returns>
		public IImageStream GetClonedImageStream() {
			return imageStream.Clone();
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public DotNetStream() {
			this.imageStream = MemoryImageStream.CreateEmpty();
			this.streamHeader = null;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="imageStream">Stream data</param>
		/// <param name="streamHeader">The stream header</param>
		public DotNetStream(IImageStream imageStream, StreamHeader streamHeader) {
			this.imageStream = imageStream;
			this.streamHeader = streamHeader;
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (disposing) {
				var ims = imageStream;
				if (ims != null)
					ims.Dispose();
				imageStream = null;
				streamHeader = null;
			}
		}

		/// <summary>
		/// Checks whether an index is valid
		/// </summary>
		/// <param name="index">The index</param>
		/// <returns><c>true</c> if the index is valid</returns>
		public virtual bool IsValidIndex(uint index) {
			return IsValidOffset(index);
		}

		/// <summary>
		/// Check whether an offset is within the stream
		/// </summary>
		/// <param name="offset">Stream offset</param>
		/// <returns><c>true</c> if the offset is valid</returns>
		public bool IsValidOffset(uint offset) {
			return offset == 0 || offset < imageStream.Length;
		}

		/// <summary>
		/// Check whether an offset is within the stream
		/// </summary>
		/// <param name="offset">Stream offset</param>
		/// <param name="size">Size of data</param>
		/// <returns><c>true</c> if the offset is valid</returns>
		public bool IsValidOffset(uint offset, int size) {
			if (size == 0)
				return IsValidOffset(offset);
			return size > 0 && (long)offset + (uint)size <= imageStream.Length;
		}
	}

	/// <summary>
	/// Base class of #US, #Strings, #Blob, and #GUID classes
	/// </summary>
	public abstract class HeapStream : DotNetStream {
		HotHeapStream hotHeapStream;
#if THREAD_SAFE
		internal readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Gets/sets the <see cref="HotHeapStream"/> instance
		/// </summary>
		internal HotHeapStream HotHeapStream {
			set { hotHeapStream = value; }
		}

		/// <inheritdoc/>
		protected HeapStream() {
		}

		/// <inheritdoc/>
		protected HeapStream(IImageStream imageStream, StreamHeader streamHeader)
			: base(imageStream, streamHeader) {
		}

		/// <summary>
		/// Gets the heap reader and initializes its position
		/// </summary>
		/// <param name="offset">Offset in the heap. If it's the #GUID heap, this should
		/// be the offset of the GUID, not its index</param>
		/// <returns>The heap reader</returns>
		protected IImageStream GetReader_NoLock(uint offset) {
			var stream = hotHeapStream == null ? null : hotHeapStream.GetBlobReader(offset);
			if (stream == null) {
				stream = imageStream;
				stream.Position = offset;
			}
			return stream;
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			if (disposing) {
				var hhs = hotHeapStream;
				if (hhs != null)
					hhs.Dispose();
				hotHeapStream = null;
			}
			base.Dispose(disposing);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/DotNetTableSizes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Initializes .NET table row sizes
	/// </summary>
	public sealed class DotNetTableSizes {
		bool bigStrings;
		bool bigGuid;
		bool bigBlob;
		TableInfo[] tableInfos;

		internal static bool IsSystemTable(Table table) {
			return table < Table.Document;
		}

		/// <summary>
		/// Initializes the table sizes
		/// </summary>
		/// <param name="bigStrings"><c>true</c> if #Strings size >= 0x10000</param>
		/// <param name="bigGuid"><c>true</c> if #GUID size >= 0x10000</param>
		/// <param name="bigBlob"><c>true</c> if #Blob size >= 0x10000</param>
		/// <param name="systemRowCounts">Count of rows in each table</param>
		/// <param name="debugRowCounts">Count of rows in each table (debug tables)</param>
		public void InitializeSizes(bool bigStrings, bool bigGuid, bool bigBlob, IList<uint> systemRowCounts, IList<uint> debugRowCounts) {
			this.bigStrings = bigStrings;
			this.bigGuid = bigGuid;
			this.bigBlob = bigBlob;
			foreach (var tableInfo in tableInfos) {
				var rowCounts = IsSystemTable(tableInfo.Table) ? systemRowCounts : debugRowCounts;
				int colOffset = 0;
				foreach (var colInfo in tableInfo.Columns) {
					colInfo.Offset = colOffset;
					var colSize = GetSize(colInfo.ColumnSize, rowCounts);
					colInfo.Size = colSize;
					colOffset += colSize;
				}
				tableInfo.RowSize = colOffset;
			}
		}

		int GetSize(ColumnSize columnSize, IList<uint> rowCounts) {
			if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.CustomDebugInformation) {
				int table = (int)(columnSize - ColumnSize.Module);
				uint count = table >= rowCounts.Count ? 0 : rowCounts[table];
				return count > 0xFFFF ? 4 : 2;
			}
			else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.HasCustomDebugInformation) {
				CodedToken info;
				switch (columnSize) {
				case ColumnSize.TypeDefOrRef:		info = CodedToken.TypeDefOrRef; break;
				case ColumnSize.HasConstant:		info = CodedToken.HasConstant; break;
				case ColumnSize.HasCustomAttribute:	info = CodedToken.HasCustomAttribute; break;
				case ColumnSize.HasFieldMarshal:	info = CodedToken.HasFieldMarshal; break;
				case ColumnSize.HasDeclSecurity:	info = CodedToken.HasDeclSecurity; break;
				case ColumnSize.MemberRefParent:	info = CodedToken.MemberRefParent; break;
				case ColumnSize.HasSemantic:		info = CodedToken.HasSemantic; break;
				case ColumnSize.MethodDefOrRef:		info = CodedToken.MethodDefOrRef; break;
				case ColumnSize.MemberForwarded:	info = CodedToken.MemberForwarded; break;
				case ColumnSize.Implementation:		info = CodedToken.Implementation; break;
				case ColumnSize.CustomAttributeType:info = CodedToken.CustomAttributeType; break;
				case ColumnSize.ResolutionScope:	info = CodedToken.ResolutionScope; break;
				case ColumnSize.TypeOrMethodDef:	info = CodedToken.TypeOrMethodDef; break;
				case ColumnSize.HasCustomDebugInformation:info = CodedToken.HasCustomDebugInformation; break;
				default: throw new InvalidOperationException(string.Format("Invalid ColumnSize: {0}", columnSize));
				}
				uint maxRows = 0;
				foreach (var tableType in info.TableTypes) {
					int index = (int)tableType;
					var tableRows = index >= rowCounts.Count ? 0 : rowCounts[index];
					if (tableRows > maxRows)
						maxRows = tableRows;
				}
				// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8
				uint finalRows = maxRows << info.Bits;
				return finalRows > 0xFFFF ? 4 : 2;
			}
			else {
				switch (columnSize) {
				case ColumnSize.Byte:	return 1;
				case ColumnSize.Int16:	return 2;
				case ColumnSize.UInt16:	return 2;
				case ColumnSize.Int32:	return 4;
				case ColumnSize.UInt32:	return 4;
				case ColumnSize.Strings:return bigStrings ? 4 : 2;
				case ColumnSize.GUID:	return bigGuid ? 4 : 2;
				case ColumnSize.Blob:	return bigBlob ? 4 : 2;
				}
			}
			throw new InvalidOperationException(string.Format("Invalid ColumnSize: {0}", columnSize));
		}

		/// <summary>
		/// Creates the table infos
		/// </summary>
		/// <param name="majorVersion">Major table version</param>
		/// <param name="minorVersion">Minor table version</param>
		/// <returns>All table infos (not completely initialized)</returns>
		public TableInfo[] CreateTables(byte majorVersion, byte minorVersion) {
			int maxPresentTables;
			return CreateTables(majorVersion, minorVersion, out maxPresentTables);
		}

		internal const int normalMaxTables = (int)Table.CustomDebugInformation + 1;

		/// <summary>
		/// Creates the table infos
		/// </summary>
		/// <param name="majorVersion">Major table version</param>
		/// <param name="minorVersion">Minor table version</param>
		/// <param name="maxPresentTables">Initialized to max present tables (eg. 42 or 45)</param>
		/// <returns>All table infos (not completely initialized)</returns>
		public TableInfo[] CreateTables(byte majorVersion, byte minorVersion, out int maxPresentTables) {
			maxPresentTables = (majorVersion == 1 && minorVersion == 0) ? (int)Table.NestedClass + 1 : normalMaxTables;

			var tableInfos = new TableInfo[normalMaxTables];

			tableInfos[(int)Table.Module] = new TableInfo(Table.Module, "Module", new ColumnInfo[] {
				new ColumnInfo(0, "Generation", ColumnSize.UInt16),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Mvid", ColumnSize.GUID),
				new ColumnInfo(3, "EncId", ColumnSize.GUID),
				new ColumnInfo(4, "EncBaseId", ColumnSize.GUID),
			});
			tableInfos[(int)Table.TypeRef] = new TableInfo(Table.TypeRef, "TypeRef", new ColumnInfo[] {
				new ColumnInfo(0, "ResolutionScope", ColumnSize.ResolutionScope),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Namespace", ColumnSize.Strings),
			});
			tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef, "TypeDef", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt32),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Namespace", ColumnSize.Strings),
				new ColumnInfo(3, "Extends", ColumnSize.TypeDefOrRef),
				new ColumnInfo(4, "FieldList", ColumnSize.Field),
				new ColumnInfo(5, "MethodList", ColumnSize.Method),
			});
			tableInfos[(int)Table.FieldPtr] = new TableInfo(Table.FieldPtr, "FieldPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Field", ColumnSize.Field),
			});
			tableInfos[(int)Table.Field] = new TableInfo(Table.Field, "Field", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt16),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.MethodPtr] = new TableInfo(Table.MethodPtr, "MethodPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Method", ColumnSize.Method),
			});
			tableInfos[(int)Table.Method] = new TableInfo(Table.Method, "Method", new ColumnInfo[] {
				new ColumnInfo(0, "RVA", ColumnSize.UInt32),
				new ColumnInfo(1, "ImplFlags", ColumnSize.UInt16),
				new ColumnInfo(2, "Flags", ColumnSize.UInt16),
				new ColumnInfo(3, "Name", ColumnSize.Strings),
				new ColumnInfo(4, "Signature", ColumnSize.Blob),
				new ColumnInfo(5, "ParamList", ColumnSize.Param),
			});
			tableInfos[(int)Table.ParamPtr] = new TableInfo(Table.ParamPtr, "ParamPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Param", ColumnSize.Param),
			});
			tableInfos[(int)Table.Param] = new TableInfo(Table.Param, "Param", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt16),
				new ColumnInfo(1, "Sequence", ColumnSize.UInt16),
				new ColumnInfo(2, "Name", ColumnSize.Strings),
			});
			tableInfos[(int)Table.InterfaceImpl] = new TableInfo(Table.InterfaceImpl, "InterfaceImpl", new ColumnInfo[] {
				new ColumnInfo(0, "Class", ColumnSize.TypeDef),
				new ColumnInfo(1, "Interface", ColumnSize.TypeDefOrRef),
			});
			tableInfos[(int)Table.MemberRef] = new TableInfo(Table.MemberRef, "MemberRef", new ColumnInfo[] {
				new ColumnInfo(0, "Class", ColumnSize.MemberRefParent),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.Constant] = new TableInfo(Table.Constant, "Constant", new ColumnInfo[] {
				new ColumnInfo(0, "Type", ColumnSize.Byte),
				new ColumnInfo(1, "Padding", ColumnSize.Byte),
				new ColumnInfo(2, "Parent", ColumnSize.HasConstant),
				new ColumnInfo(3, "Value", ColumnSize.Blob),
			});
			tableInfos[(int)Table.CustomAttribute] = new TableInfo(Table.CustomAttribute, "CustomAttribute", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.HasCustomAttribute),
				new ColumnInfo(1, "Type", ColumnSize.CustomAttributeType),
				new ColumnInfo(2, "Value", ColumnSize.Blob),
			});
			tableInfos[(int)Table.FieldMarshal] = new TableInfo(Table.FieldMarshal, "FieldMarshal", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.HasFieldMarshal),
				new ColumnInfo(1, "NativeType", ColumnSize.Blob),
			});
			tableInfos[(int)Table.DeclSecurity] = new TableInfo(Table.DeclSecurity, "DeclSecurity", new ColumnInfo[] {
				new ColumnInfo(0, "Action", ColumnSize.Int16),
				new ColumnInfo(1, "Parent", ColumnSize.HasDeclSecurity),
				new ColumnInfo(2, "PermissionSet", ColumnSize.Blob),
			});
			tableInfos[(int)Table.ClassLayout] = new TableInfo(Table.ClassLayout, "ClassLayout", new ColumnInfo[] {
				new ColumnInfo(0, "PackingSize", ColumnSize.UInt16),
				new ColumnInfo(1, "ClassSize", ColumnSize.UInt32),
				new ColumnInfo(2, "Parent", ColumnSize.TypeDef),
			});
			tableInfos[(int)Table.FieldLayout] = new TableInfo(Table.FieldLayout, "FieldLayout", new ColumnInfo[] {
				new ColumnInfo(0, "OffSet", ColumnSize.UInt32),
				new ColumnInfo(1, "Field", ColumnSize.Field),
			});
			tableInfos[(int)Table.StandAloneSig] = new TableInfo(Table.StandAloneSig, "StandAloneSig", new ColumnInfo[] {
				new ColumnInfo(0, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.EventMap] = new TableInfo(Table.EventMap, "EventMap", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.TypeDef),
				new ColumnInfo(1, "EventList", ColumnSize.Event),
			});
			tableInfos[(int)Table.EventPtr] = new TableInfo(Table.EventPtr, "EventPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Event", ColumnSize.Event),
			});
			tableInfos[(int)Table.Event] = new TableInfo(Table.Event, "Event", new ColumnInfo[] {
				new ColumnInfo(0, "EventFlags", ColumnSize.UInt16),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "EventType", ColumnSize.TypeDefOrRef),
			});
			tableInfos[(int)Table.PropertyMap] = new TableInfo(Table.PropertyMap, "PropertyMap", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.TypeDef),
				new ColumnInfo(1, "PropertyList", ColumnSize.Property),
			});
			tableInfos[(int)Table.PropertyPtr] = new TableInfo(Table.PropertyPtr, "PropertyPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Property", ColumnSize.Property),
			});
			tableInfos[(int)Table.Property] = new TableInfo(Table.Property, "Property", new ColumnInfo[] {
				new ColumnInfo(0, "PropFlags", ColumnSize.UInt16),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Type", ColumnSize.Blob),
			});
			tableInfos[(int)Table.MethodSemantics] = new TableInfo(Table.MethodSemantics, "MethodSemantics", new ColumnInfo[] {
				new ColumnInfo(0, "Semantic", ColumnSize.UInt16),
				new ColumnInfo(1, "Method", ColumnSize.Method),
				new ColumnInfo(2, "Association", ColumnSize.HasSemantic),
			});
			tableInfos[(int)Table.MethodImpl] = new TableInfo(Table.MethodImpl, "MethodImpl", new ColumnInfo[] {
				new ColumnInfo(0, "Class", ColumnSize.TypeDef),
				new ColumnInfo(1, "MethodBody", ColumnSize.MethodDefOrRef),
				new ColumnInfo(2, "MethodDeclaration", ColumnSize.MethodDefOrRef),
			});
			tableInfos[(int)Table.ModuleRef] = new TableInfo(Table.ModuleRef, "ModuleRef", new ColumnInfo[] {
				new ColumnInfo(0, "Name", ColumnSize.Strings),
			});
			tableInfos[(int)Table.TypeSpec] = new TableInfo(Table.TypeSpec, "TypeSpec", new ColumnInfo[] {
				new ColumnInfo(0, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.ImplMap] = new TableInfo(Table.ImplMap, "ImplMap", new ColumnInfo[] {
				new ColumnInfo(0, "MappingFlags", ColumnSize.UInt16),
				new ColumnInfo(1, "MemberForwarded", ColumnSize.MemberForwarded),
				new ColumnInfo(2, "ImportName", ColumnSize.Strings),
				new ColumnInfo(3, "ImportScope", ColumnSize.ModuleRef),
			});
			tableInfos[(int)Table.FieldRVA] = new TableInfo(Table.FieldRVA, "FieldRVA", new ColumnInfo[] {
				new ColumnInfo(0, "RVA", ColumnSize.UInt32),
				new ColumnInfo(1, "Field", ColumnSize.Field),
			});
			tableInfos[(int)Table.ENCLog] = new TableInfo(Table.ENCLog, "ENCLog", new ColumnInfo[] {
				new ColumnInfo(0, "Token", ColumnSize.UInt32),
				new ColumnInfo(1, "FuncCode", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.ENCMap] = new TableInfo(Table.ENCMap, "ENCMap", new ColumnInfo[] {
				new ColumnInfo(0, "Token", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly, "Assembly", new ColumnInfo[] {
				new ColumnInfo(0, "HashAlgId", ColumnSize.UInt32),
				new ColumnInfo(1, "MajorVersion", ColumnSize.UInt16),
				new ColumnInfo(2, "MinorVersion", ColumnSize.UInt16),
				new ColumnInfo(3, "BuildNumber", ColumnSize.UInt16),
				new ColumnInfo(4, "RevisionNumber", ColumnSize.UInt16),
				new ColumnInfo(5, "Flags", ColumnSize.UInt32),
				new ColumnInfo(6, "PublicKey", ColumnSize.Blob),
				new ColumnInfo(7, "Name", ColumnSize.Strings),
				new ColumnInfo(8, "Locale", ColumnSize.Strings),
			});
			tableInfos[(int)Table.AssemblyProcessor] = new TableInfo(Table.AssemblyProcessor, "AssemblyProcessor", new ColumnInfo[] {
				new ColumnInfo(0, "Processor", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.AssemblyOS] = new TableInfo(Table.AssemblyOS, "AssemblyOS", new ColumnInfo[] {
				new ColumnInfo(0, "OSPlatformId", ColumnSize.UInt32),
				new ColumnInfo(1, "OSMajorVersion", ColumnSize.UInt32),
				new ColumnInfo(2, "OSMinorVersion", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef, "AssemblyRef", new ColumnInfo[] {
				new ColumnInfo(0, "MajorVersion", ColumnSize.UInt16),
				new ColumnInfo(1, "MinorVersion", ColumnSize.UInt16),
				new ColumnInfo(2, "BuildNumber", ColumnSize.UInt16),
				new ColumnInfo(3, "RevisionNumber", ColumnSize.UInt16),
				new ColumnInfo(4, "Flags", ColumnSize.UInt32),
				new ColumnInfo(5, "PublicKeyOrToken", ColumnSize.Blob),
				new ColumnInfo(6, "Name", ColumnSize.Strings),
				new ColumnInfo(7, "Locale", ColumnSize.Strings),
				new ColumnInfo(8, "HashValue", ColumnSize.Blob),
			});
			tableInfos[(int)Table.AssemblyRefProcessor] = new TableInfo(Table.AssemblyRefProcessor, "AssemblyRefProcessor", new ColumnInfo[] {
				new ColumnInfo(0, "Processor", ColumnSize.UInt32),
				new ColumnInfo(1, "AssemblyRef", ColumnSize.AssemblyRef),
			});
			tableInfos[(int)Table.AssemblyRefOS] = new TableInfo(Table.AssemblyRefOS, "AssemblyRefOS", new ColumnInfo[] {
				new ColumnInfo(0, "OSPlatformId", ColumnSize.UInt32),
				new ColumnInfo(1, "OSMajorVersion", ColumnSize.UInt32),
				new ColumnInfo(2, "OSMinorVersion", ColumnSize.UInt32),
				new ColumnInfo(3, "AssemblyRef", ColumnSize.AssemblyRef),
			});
			tableInfos[(int)Table.File] = new TableInfo(Table.File, "File", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt32),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "HashValue", ColumnSize.Blob),
			});
			tableInfos[(int)Table.ExportedType] = new TableInfo(Table.ExportedType, "ExportedType", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt32),
				new ColumnInfo(1, "TypeDefId", ColumnSize.UInt32),
				new ColumnInfo(2, "TypeName", ColumnSize.Strings),
				new ColumnInfo(3, "TypeNamespace", ColumnSize.Strings),
				new ColumnInfo(4, "Implementation", ColumnSize.Implementation),
			});
			tableInfos[(int)Table.ManifestResource] = new TableInfo(Table.ManifestResource, "ManifestResource", new ColumnInfo[] {
				new ColumnInfo(0, "Offset", ColumnSize.UInt32),
				new ColumnInfo(1, "Flags", ColumnSize.UInt32),
				new ColumnInfo(2, "Name", ColumnSize.Strings),
				new ColumnInfo(3, "Implementation", ColumnSize.Implementation),
			});
			tableInfos[(int)Table.NestedClass] = new TableInfo(Table.NestedClass, "NestedClass", new ColumnInfo[] {
				new ColumnInfo(0, "NestedClass", ColumnSize.TypeDef),
				new ColumnInfo(1, "EnclosingClass", ColumnSize.TypeDef),
			});
			if (majorVersion == 1 && minorVersion == 1) {
				tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam, "GenericParam", new ColumnInfo[] {
					new ColumnInfo(0, "Number", ColumnSize.UInt16),
					new ColumnInfo(1, "Flags", ColumnSize.UInt16),
					new ColumnInfo(2, "Owner", ColumnSize.TypeOrMethodDef),
					new ColumnInfo(3, "Name", ColumnSize.Strings),
					new ColumnInfo(4, "Kind", ColumnSize.TypeDefOrRef),
				});
			}
			else {
				tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam, "GenericParam", new ColumnInfo[] {
					new ColumnInfo(0, "Number", ColumnSize.UInt16),
					new ColumnInfo(1, "Flags", ColumnSize.UInt16),
					new ColumnInfo(2, "Owner", ColumnSize.TypeOrMethodDef),
					new ColumnInfo(3, "Name", ColumnSize.Strings),
				});
			}
			tableInfos[(int)Table.MethodSpec] = new TableInfo(Table.MethodSpec, "MethodSpec", new ColumnInfo[] {
				new ColumnInfo(0, "Method", ColumnSize.MethodDefOrRef),
				new ColumnInfo(1, "Instantiation", ColumnSize.Blob),
			});
			tableInfos[(int)Table.GenericParamConstraint] = new TableInfo(Table.GenericParamConstraint, "GenericParamConstraint", new ColumnInfo[] {
				new ColumnInfo(0, "Owner", ColumnSize.GenericParam),
				new ColumnInfo(1, "Constraint", ColumnSize.TypeDefOrRef),
			});
			tableInfos[0x2D] = new TableInfo((Table)0x2D, string.Empty, new ColumnInfo[] { });
			tableInfos[0x2E] = new TableInfo((Table)0x2E, string.Empty, new ColumnInfo[] { });
			tableInfos[0x2F] = new TableInfo((Table)0x2F, string.Empty, new ColumnInfo[] { });
			tableInfos[(int)Table.Document] = new TableInfo(Table.Document, "Document", new ColumnInfo[] {
				new ColumnInfo(0, "Name", ColumnSize.Blob),
				new ColumnInfo(1, "HashAlgorithm", ColumnSize.GUID),
				new ColumnInfo(2, "Hash", ColumnSize.Blob),
				new ColumnInfo(3, "Language", ColumnSize.GUID),
			});
			tableInfos[(int)Table.MethodDebugInformation] = new TableInfo(Table.MethodDebugInformation, "MethodDebugInformation", new ColumnInfo[] {
				new ColumnInfo(0, "Document", ColumnSize.Document),
				new ColumnInfo(1, "SequencePoints", ColumnSize.Blob),
			});
			tableInfos[(int)Table.LocalScope] = new TableInfo(Table.LocalScope, "LocalScope", new ColumnInfo[] {
				new ColumnInfo(0, "Method", ColumnSize.Method),
				new ColumnInfo(1, "ImportScope", ColumnSize.ImportScope),
				new ColumnInfo(2, "VariableList", ColumnSize.LocalVariable),
				new ColumnInfo(3, "ConstantList", ColumnSize.LocalConstant),
				new ColumnInfo(4, "StartOffset", ColumnSize.UInt32),
				new ColumnInfo(5, "Length", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.LocalVariable] = new TableInfo(Table.LocalVariable, "LocalVariable", new ColumnInfo[] {
				new ColumnInfo(0, "Attributes", ColumnSize.UInt16),
				new ColumnInfo(1, "Index", ColumnSize.UInt16),
				new ColumnInfo(2, "Name", ColumnSize.Strings),
			});
			tableInfos[(int)Table.LocalConstant] = new TableInfo(Table.LocalConstant, "LocalConstant", new ColumnInfo[] {
				new ColumnInfo(0, "Name", ColumnSize.Strings),
				new ColumnInfo(1, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.ImportScope] = new TableInfo(Table.ImportScope, "ImportScope", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.ImportScope),
				new ColumnInfo(1, "Imports", ColumnSize.Blob),
			});
			tableInfos[(int)Table.StateMachineMethod] = new TableInfo(Table.StateMachineMethod, "StateMachineMethod", new ColumnInfo[] {
				new ColumnInfo(0, "MoveNextMethod", ColumnSize.Method),
				new ColumnInfo(1, "KickoffMethod", ColumnSize.Method),
			});
			tableInfos[(int)Table.CustomDebugInformation] = new TableInfo(Table.CustomDebugInformation, "CustomDebugInformation", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.HasCustomDebugInformation),
				new ColumnInfo(1, "Kind", ColumnSize.GUID),
				new ColumnInfo(2, "Value", ColumnSize.Blob),
			});
			return this.tableInfos = tableInfos;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/ENCMetaData.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.IO;
using dnlib.PE;
using dnlib.Threading;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Used when a #- stream is present in the metadata
	/// </summary>
	sealed class ENCMetaData : MetaData {
		static readonly UTF8String DeletedName = "_Deleted";
		bool hasMethodPtr, hasFieldPtr, hasParamPtr, hasEventPtr, hasPropertyPtr;
		bool hasDeletedRows;
		readonly Dictionary<Table, SortedTable> sortedTables = new Dictionary<Table, SortedTable>();
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public override bool IsCompressed {
			get { return false; }
		}

		/// <inheritdoc/>
		public ENCMetaData(IPEImage peImage, ImageCor20Header cor20Header, MetaDataHeader mdHeader)
			: base(peImage, cor20Header, mdHeader) {
		}

		/// <inheritdoc/>
		internal ENCMetaData(MetaDataHeader mdHeader, bool isStandalonePortablePdb)
			: base(mdHeader, isStandalonePortablePdb) {
		}

		/// <inheritdoc/>
		protected override void InitializeInternal(IImageStream mdStream) {
			bool disposeOfMdStream = false;
			IImageStream imageStream = null;
			DotNetStream dns = null;
			try {
				if (peImage != null) {
					Debug.Assert(mdStream == null);
					Debug.Assert(cor20Header != null);
					var mdOffset = peImage.ToFileOffset(cor20Header.MetaData.VirtualAddress);
					mdStream = peImage.CreateStream(mdOffset, cor20Header.MetaData.Size);
					disposeOfMdStream = true;
				}
				else
					Debug.Assert(mdStream != null);
				foreach (var sh in mdHeader.StreamHeaders) {
					imageStream = mdStream.Create((FileOffset)sh.Offset, sh.StreamSize);
					switch (sh.Name.ToUpperInvariant()) {
					case "#STRINGS":
						if (stringsStream == null) {
							stringsStream = new StringsStream(imageStream, sh);
							imageStream = null;
							allStreams.Add(stringsStream);
							continue;
						}
						break;

					case "#US":
						if (usStream == null) {
							usStream = new USStream(imageStream, sh);
							imageStream = null;
							allStreams.Add(usStream);
							continue;
						}
						break;

					case "#BLOB":
						if (blobStream == null) {
							blobStream = new BlobStream(imageStream, sh);
							imageStream = null;
							allStreams.Add(blobStream);
							continue;
						}
						break;

					case "#GUID":
						if (guidStream == null) {
							guidStream = new GuidStream(imageStream, sh);
							imageStream = null;
							allStreams.Add(guidStream);
							continue;
						}
						break;

					case "#~":	// Only if #Schema is used
					case "#-":
						if (tablesStream == null) {
							tablesStream = new TablesStream(imageStream, sh);
							imageStream = null;
							allStreams.Add(tablesStream);
							continue;
						}
						break;

					case "#PDB":
						// Case sensitive comparison since it's a stream that's not read by the CLR,
						// only by other libraries eg. System.Reflection.Metadata.
						if (isStandalonePortablePdb && pdbStream == null && sh.Name == "#Pdb") {
							pdbStream = new PdbStream(imageStream, sh);
							imageStream = null;
							allStreams.Add(pdbStream);
							continue;
						}
						break;
					}
					dns = new DotNetStream(imageStream, sh);
					imageStream = null;
					allStreams.Add(dns);
					dns = null;
				}
			}
			finally {
				if (disposeOfMdStream)
					mdStream.Dispose();
				if (imageStream != null)
					imageStream.Dispose();
				if (dns != null)
					dns.Dispose();
			}

			if (tablesStream == null)
				throw new BadImageFormatException("Missing MD stream");

			if (pdbStream != null)
				tablesStream.Initialize(pdbStream.TypeSystemTableRows);
			else
				tablesStream.Initialize(null);

			// The pointer tables are used iff row count != 0
			hasFieldPtr = !tablesStream.FieldPtrTable.IsEmpty;
			hasMethodPtr = !tablesStream.MethodPtrTable.IsEmpty;
			hasParamPtr = !tablesStream.ParamPtrTable.IsEmpty;
			hasEventPtr = !tablesStream.EventPtrTable.IsEmpty;
			hasPropertyPtr = !tablesStream.PropertyPtrTable.IsEmpty;
			hasDeletedRows = tablesStream.HasDelete;
		}

		/// <inheritdoc/>
		public override RidList GetTypeDefRidList() {
			if (!hasDeletedRows)
				return base.GetTypeDefRidList();
			uint rows = tablesStream.TypeDefTable.Rows;
			var list = new RandomRidList((int)rows);
			for (uint rid = 1; rid <= rows; rid++) {
				var row = tablesStream.ReadTypeDefRow(rid);
				if (row == null)
					continue;	// Should never happen since rid is valid

				// RTSpecialName is ignored by the CLR. It's only the name that indicates
				// whether it's been deleted.
				if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
					continue;	// ignore this deleted row
				list.Add(rid);
			}
			return list;
		}

		/// <inheritdoc/>
		public override RidList GetExportedTypeRidList() {
			if (!hasDeletedRows)
				return base.GetExportedTypeRidList();
			uint rows = tablesStream.ExportedTypeTable.Rows;
			var list = new RandomRidList((int)rows);
			for (uint rid = 1; rid <= rows; rid++) {
				var row = tablesStream.ReadExportedTypeRow(rid);
				if (row == null)
					continue;	// Should never happen since rid is valid

				// RTSpecialName is ignored by the CLR. It's only the name that indicates
				// whether it's been deleted.
				if (stringsStream.ReadNoNull(row.TypeName).StartsWith(DeletedName))
					continue;	// ignore this deleted row
				list.Add(rid);
			}
			return list;
		}

		/// <summary>
		/// Converts a logical <c>Field</c> rid to a physical <c>Field</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToFieldRid(uint listRid) {
			if (!hasFieldPtr)
				return listRid;
			uint listValue;
			return tablesStream.ReadColumn(tablesStream.FieldPtrTable, listRid, 0, out listValue) ? listValue : 0;
		}

		/// <summary>
		/// Converts a logical <c>Method</c> rid to a physical <c>Method</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToMethodRid(uint listRid) {
			if (!hasMethodPtr)
				return listRid;
			uint listValue;
			return tablesStream.ReadColumn(tablesStream.MethodPtrTable, listRid, 0, out listValue) ? listValue : 0;
		}

		/// <summary>
		/// Converts a logical <c>Param</c> rid to a physical <c>Param</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToParamRid(uint listRid) {
			if (!hasParamPtr)
				return listRid;
			uint listValue;
			return tablesStream.ReadColumn(tablesStream.ParamPtrTable, listRid, 0, out listValue) ? listValue : 0;
		}

		/// <summary>
		/// Converts a logical <c>Event</c> rid to a physical <c>Event</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToEventRid(uint listRid) {
			if (!hasEventPtr)
				return listRid;
			uint listValue;
			return tablesStream.ReadColumn(tablesStream.EventPtrTable, listRid, 0, out listValue) ? listValue : 0;
		}

		/// <summary>
		/// Converts a logical <c>Property</c> rid to a physical <c>Property</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToPropertyRid(uint listRid) {
			if (!hasPropertyPtr)
				return listRid;
			uint listValue;
			return tablesStream.ReadColumn(tablesStream.PropertyPtrTable, listRid, 0, out listValue) ? listValue : 0;
		}

		/// <inheritdoc/>
		public override RidList GetFieldRidList(uint typeDefRid) {
			var list = GetRidList(tablesStream.TypeDefTable, typeDefRid, 4, tablesStream.FieldTable);
			if (list.Length == 0 || (!hasFieldPtr && !hasDeletedRows))
				return list;

			var destTable = tablesStream.FieldTable;
			var newList = new RandomRidList((int)list.Length);
			for (uint i = 0; i < list.Length; i++) {
				var rid = ToFieldRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				if (hasDeletedRows) {
					// It's a deleted row if RTSpecialName is set and name is "_Deleted"
					var row = tablesStream.ReadFieldRow(rid);
					if (row == null)
						continue;	// Should never happen since rid is valid
					if ((row.Flags & (uint)FieldAttributes.RTSpecialName) != 0) {
						if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
							continue;	// ignore this deleted row
					}
				}
				// It's a valid non-deleted rid so add it
				newList.Add(rid);
			}
			return newList;
		}

		/// <inheritdoc/>
		public override RidList GetMethodRidList(uint typeDefRid) {
			var list = GetRidList(tablesStream.TypeDefTable, typeDefRid, 5, tablesStream.MethodTable);
			if (list.Length == 0 || (!hasMethodPtr && !hasDeletedRows))
				return list;

			var destTable = tablesStream.MethodTable;
			var newList = new RandomRidList((int)list.Length);
			for (uint i = 0; i < list.Length; i++) {
				var rid = ToMethodRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				if (hasDeletedRows) {
					// It's a deleted row if RTSpecialName is set and name is "_Deleted"
					var row = tablesStream.ReadMethodRow(rid);
					if (row == null)
						continue;	// Should never happen since rid is valid
					if ((row.Flags & (uint)MethodAttributes.RTSpecialName) != 0) {
						if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
							continue;	// ignore this deleted row
					}
				}
				// It's a valid non-deleted rid so add it
				newList.Add(rid);
			}
			return newList;
		}

		/// <inheritdoc/>
		public override RidList GetParamRidList(uint methodRid) {
			var list = GetRidList(tablesStream.MethodTable, methodRid, 5, tablesStream.ParamTable);
			if (list.Length == 0 || !hasParamPtr)
				return list;

			var destTable = tablesStream.ParamTable;
			var newList = new RandomRidList((int)list.Length);
			for (uint i = 0; i < list.Length; i++) {
				var rid = ToParamRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				newList.Add(rid);
			}
			return newList;
		}

		/// <inheritdoc/>
		public override RidList GetEventRidList(uint eventMapRid) {
			var list = GetRidList(tablesStream.EventMapTable, eventMapRid, 1, tablesStream.EventTable);
			if (list.Length == 0 || (!hasEventPtr && !hasDeletedRows))
				return list;

			var destTable = tablesStream.EventTable;
			var newList = new RandomRidList((int)list.Length);
			for (uint i = 0; i < list.Length; i++) {
				var rid = ToEventRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				if (hasDeletedRows) {
					// It's a deleted row if RTSpecialName is set and name is "_Deleted"
					var row = tablesStream.ReadEventRow(rid);
					if (row == null)
						continue;	// Should never happen since rid is valid
					if ((row.EventFlags & (uint)EventAttributes.RTSpecialName) != 0) {
						if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
							continue;	// ignore this deleted row
					}
				}
				// It's a valid non-deleted rid so add it
				newList.Add(rid);
			}
			return newList;
		}

		/// <inheritdoc/>
		public override RidList GetPropertyRidList(uint propertyMapRid) {
			var list = GetRidList(tablesStream.PropertyMapTable, propertyMapRid, 1, tablesStream.PropertyTable);
			if (list.Length == 0 || (!hasPropertyPtr && !hasDeletedRows))
				return list;

			var destTable = tablesStream.PropertyTable;
			var newList = new RandomRidList((int)list.Length);
			for (uint i = 0; i < list.Length; i++) {
				var rid = ToPropertyRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				if (hasDeletedRows) {
					// It's a deleted row if RTSpecialName is set and name is "_Deleted"
					var row = tablesStream.ReadPropertyRow(rid);
					if (row == null)
						continue;	// Should never happen since rid is valid
					if ((row.PropFlags & (uint)PropertyAttributes.RTSpecialName) != 0) {
						if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
							continue;	// ignore this deleted row
					}
				}
				// It's a valid non-deleted rid so add it
				newList.Add(rid);
			}
			return newList;
		}

		/// <summary>
		/// Gets a rid list (eg. field list)
		/// </summary>
		/// <param name="tableSource">Source table, eg. <c>TypeDef</c></param>
		/// <param name="tableSourceRid">Row ID in <paramref name="tableSource"/></param>
		/// <param name="colIndex">Column index in <paramref name="tableSource"/>, eg. 4 for <c>TypeDef.FieldList</c></param>
		/// <param name="tableDest">Destination table, eg. <c>Field</c></param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetRidList(MDTable tableSource, uint tableSourceRid, int colIndex, MDTable tableDest) {
			var column = tableSource.TableInfo.Columns[colIndex];
			uint startRid, nextListRid;
			bool hasNext;
#if THREAD_SAFE
			tablesStream.theLock.EnterWriteLock(); try {
#endif
			if (!tablesStream.ReadColumn_NoLock(tableSource, tableSourceRid, column, out startRid))
				return RidList.Empty;
			hasNext = tablesStream.ReadColumn_NoLock(tableSource, tableSourceRid + 1, column, out nextListRid);
#if THREAD_SAFE
			} finally { tablesStream.theLock.ExitWriteLock(); }
#endif
			uint lastRid = tableDest.Rows + 1;
			if (startRid == 0 || startRid >= lastRid)
				return RidList.Empty;
			uint endRid = hasNext && nextListRid != 0 ? nextListRid : lastRid;
			if (endRid < startRid)
				endRid = startRid;
			if (endRid > lastRid)
				endRid = lastRid;
			return new ContiguousRidList(startRid, endRid - startRid);
		}

		/// <inheritdoc/>
		protected override uint BinarySearch_NoLock(MDTable tableSource, int keyColIndex, uint key) {
			var keyColumn = tableSource.TableInfo.Columns[keyColIndex];
			uint ridLo = 1, ridHi = tableSource.Rows;
			while (ridLo <= ridHi) {
				uint rid = (ridLo + ridHi) / 2;
				uint key2;
				if (!tablesStream.ReadColumn_NoLock(tableSource, rid, keyColumn, out key2))
					break;	// Never happens since rid is valid
				if (key == key2)
					return rid;
				if (key2 > key)
					ridHi = rid - 1;
				else
					ridLo = rid + 1;
			}

			if (tableSource.Table == Table.GenericParam && !tablesStream.IsSorted(tableSource))
				return LinearSearch_NoLock(tableSource, keyColIndex, key);

			return 0;
		}

		/// <summary>
		/// Linear searches the table (O(n)) for a <c>rid</c> whose key column at index
		/// <paramref name="keyColIndex"/> is equal to <paramref name="key"/>.
		/// </summary>
		/// <param name="tableSource">Table to search</param>
		/// <param name="keyColIndex">Key column index</param>
		/// <param name="key">Key</param>
		/// <returns>The <c>rid</c> of the found row, or 0 if none found</returns>
		uint LinearSearch_NoLock(MDTable tableSource, int keyColIndex, uint key) {
			if (tableSource == null)
				return 0;
			var keyColumn = tableSource.TableInfo.Columns[keyColIndex];
			for (uint rid = 1; rid <= tableSource.Rows; rid++) {
				uint key2;
				if (!tablesStream.ReadColumn_NoLock(tableSource, rid, keyColumn, out key2))
					break;	// Never happens since rid is valid
				if (key == key2)
					return rid;
			}
			return 0;
		}

		/// <inheritdoc/>
		protected override RidList FindAllRowsUnsorted(MDTable tableSource, int keyColIndex, uint key) {
			if (tablesStream.IsSorted(tableSource))
				return FindAllRows(tableSource, keyColIndex, key);
			SortedTable sortedTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (!sortedTables.TryGetValue(tableSource.Table, out sortedTable))
				sortedTables[tableSource.Table] = sortedTable = new SortedTable(tableSource, keyColIndex);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			return sortedTable.FindAllRows(key);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/GuidStream.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the #GUID stream
	/// </summary>
	public sealed class GuidStream : HeapStream {
		/// <inheritdoc/>
		public GuidStream() {
		}

		/// <inheritdoc/>
		public GuidStream(IImageStream imageStream, StreamHeader streamHeader)
			: base(imageStream, streamHeader) {
		}

		/// <inheritdoc/>
		public override bool IsValidIndex(uint index) {
			return index == 0 || (index <= 0x10000000 && IsValidOffset((index - 1) * 16, 16));
		}

		/// <summary>
		/// Read a <see cref="Guid"/>
		/// </summary>
		/// <param name="index">Index into this stream</param>
		/// <returns>A <see cref="Guid"/> or <c>null</c> if <paramref name="index"/> is 0 or invalid</returns>
		public Guid? Read(uint index) {
			if (index == 0 || !IsValidIndex(index))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock((index - 1) * 16);
			return new Guid(reader.ReadBytes(16));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/HeapType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Heap type. The values are set in stone by MS. Don't change.
	/// </summary>
	public enum HeapType : uint {
		/// <summary>#Strings heap</summary>
		Strings	= 0,
		/// <summary>#GUID heap</summary>
		Guid	= 1,
		/// <summary>#Blob heap</summary>
		Blob	= 2,
		/// <summary>#US heap</summary>
		US		= 3,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/HotHeapStream.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using System.Security;
using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Stores some/all heap data
	/// </summary>
	abstract class HotHeapStream : IDisposable {
		readonly HeapType heapType;
		protected readonly IImageStream reader;
		protected readonly long baseOffset;
		protected bool invalid;
		protected long posData;
		protected long posIndexes;
		protected long posRids;
		protected uint numRids;
		protected long offsetMask;

		/// <summary>
		/// Gets the heap type
		/// </summary>
		public HeapType HeapType {
			get { return heapType; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="heapType">Heap type</param>
		/// <param name="reader">Data stream</param>
		/// <param name="baseOffset">Offset in <paramref name="reader"/> of start of data</param>
		protected HotHeapStream(HeapType heapType, IImageStream reader, long baseOffset) {
			this.heapType = heapType;
			this.reader = reader;
			this.baseOffset = baseOffset;
		}

		/// <summary>
		/// Must be called once after creating it so it can initialize
		/// </summary>
		/// <param name="mask">Offset mask (<c>0xFFFFFFFF</c> or <c>0xFFFFFFFFFFFFFFFF</c>)</param>
		public abstract void Initialize(long mask);

		/// <summary>
		/// Returns a stream that can access a blob
		/// </summary>
		/// <param name="originalHeapOffset">Offset in the original heap. If it's the #GUID heap, it should
		/// be <c>(index - 1) * 16</c></param>
		/// <returns>The reader (owned by us) or <c>null</c> if the data isn't present</returns>
		public IImageStream GetBlobReader(uint originalHeapOffset) {
			long dataOffset;
			if (GetBlobOffset(originalHeapOffset, out dataOffset)) {
				reader.Position = dataOffset;
				return reader;
			}
			return null;
		}

		/// <summary>
		/// Returns the offset in <see cref="reader"/> of some data
		/// </summary>
		/// <param name="originalHeapOffset">Original heap offset</param>
		/// <param name="dataOffset">Updated with offset in <see cref="reader"/> of data</param>
		/// <returns><c>true</c> if data is present, <c>false</c> if data is not present</returns>
		protected abstract bool GetBlobOffset(uint originalHeapOffset, out long dataOffset);

		/// <summary>
		/// Binary searches the rids table for <paramref name="originalHeapOffset"/>
		/// </summary>
		/// <param name="originalHeapOffset">Original heap offset</param>
		/// <returns>The rids table index or <see cref="uint.MaxValue"/> if not found</returns>
		protected uint BinarySearch(uint originalHeapOffset) {
			uint lo = 0, hi = numRids - 1;
			while (lo <= hi && hi != uint.MaxValue) {
				uint index = (lo + hi) / 2;
				uint val = reader.ReadUInt32At(posRids + index * 4);
				if (originalHeapOffset == val)
					return index;
				if (originalHeapOffset > val)
					lo = index + 1;
				else
					hi = index - 1;
			}
			return uint.MaxValue;
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (disposing) {
				if (reader != null)
					reader.Dispose();
			}
		}
	}

	/// <summary>
	/// Hot heap stream (CLR 2.0)
	/// </summary>
	sealed class HotHeapStreamCLR20 : HotHeapStream {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="heapType">Heap type</param>
		/// <param name="reader">Data stream</param>
		/// <param name="baseOffset">Offset in <paramref name="reader"/> of start of data</param>
		public HotHeapStreamCLR20(HeapType heapType, IImageStream reader, long baseOffset)
			: base(heapType, reader, baseOffset) {
		}

		/// <inheritdoc/>
		[SecurityCritical]	// Req'd on .NET 4.0
		public override void Initialize(long mask) {
			try {
				offsetMask = mask;
				reader.Position = baseOffset;
				posData = (baseOffset - reader.ReadInt32()) & mask;
				posIndexes = (baseOffset - (reader.ReadInt32() & ~3)) & mask;
				uint ridsOffset = reader.ReadUInt32();
				numRids = ridsOffset / 4;
				posRids = (baseOffset - numRids * 4) & mask;
			}
			// Ignore exceptions. The CLR only reads these values when needed. Assume
			// that this was invalid data that the CLR will never read anyway.
			catch (AccessViolationException) {
				invalid = true;
			}
			catch (IOException) {
				invalid = true;
			}
		}

		/// <inheritdoc/>
		protected override bool GetBlobOffset(uint originalHeapOffset, out long dataOffset) {
			if (invalid) {
				dataOffset = 0;
				return false;
			}
			uint index = BinarySearch(originalHeapOffset);
			if (index == uint.MaxValue) {
				dataOffset = 0;
				return false;
			}

			if (index == 0)
				dataOffset = posData;
			else
				dataOffset = posData + reader.ReadUInt32At((posIndexes + (index - 1) * 4) & offsetMask);
			dataOffset &= offsetMask;
			return true;
		}
	}

	/// <summary>
	/// Hot heap stream (CLR 4.0)
	/// </summary>
	sealed class HotHeapStreamCLR40 : HotHeapStream {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="heapType">Heap type</param>
		/// <param name="reader">Data stream</param>
		/// <param name="baseOffset">Offset in <paramref name="reader"/> of start of data</param>
		public HotHeapStreamCLR40(HeapType heapType, IImageStream reader, long baseOffset)
			: base(heapType, reader, baseOffset) {
		}

		/// <inheritdoc/>
		[SecurityCritical]	// Req'd on .NET 4.0
		public override void Initialize(long mask) {
			try {
				offsetMask = mask;
				reader.Position = baseOffset;
				uint ridsOffset = reader.ReadUInt32();
				numRids = ridsOffset / 4;
				posRids = (baseOffset - ridsOffset) & mask;
				posIndexes = (baseOffset - reader.ReadInt32()) & mask;
				posData = (baseOffset - reader.ReadInt32()) & mask;
			}
			// Ignore exceptions. The CLR only reads these values when needed. Assume
			// that this was invalid data that the CLR will never read anyway.
			catch (AccessViolationException) {
				invalid = true;
			}
			catch (IOException) {
				invalid = true;
			}
		}

		/// <inheritdoc/>
		protected override bool GetBlobOffset(uint originalHeapOffset, out long dataOffset) {
			if (invalid) {
				dataOffset = 0;
				return false;
			}
			uint index = BinarySearch(originalHeapOffset);
			if (index == uint.MaxValue) {
				dataOffset = 0;
				return false;
			}

			dataOffset = posData + reader.ReadUInt32At((posIndexes + index * 4) & offsetMask);
			dataOffset &= offsetMask;
			return true;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/HotHeapVersion.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Hot heap version
	/// </summary>
	public enum HotHeapVersion {
		/// <summary>
		/// CLR 2.0 (.NET 2.0 - 3.5)
		/// </summary>
		CLR20,

		/// <summary>
		/// CLR 4.0 (.NET 4.0 - 4.5)
		/// </summary>
		CLR40,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/HotStream.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using System.Security;
using System.Threading;
using dnlib.IO;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the (undocumented) #! stream. The CLR only uses this stream if the
	/// normal compressed tables stream (#~) is used.
	/// </summary>
	abstract class HotStream : DotNetStream {
		protected readonly IImageStream fullStream;
		protected readonly long baseOffset;
		protected readonly long endOffset;
		protected HotTableStream hotTableStream;
		protected ThreadSafe.IList<HotHeapStream> hotHeapStreams;

		/// <summary>
		/// Gets the <see cref="dnlib.DotNet.MD.HotTableStream"/> or <c>null</c> if there's none
		/// </summary>
		public HotTableStream HotTableStream {
			get {
				if (hotTableStream == null) {
					var newHts = CreateHotTableStream();
					if (Interlocked.CompareExchange(ref hotTableStream, newHts, null) != null)
						newHts.Dispose();
				}
				return hotTableStream;
			}
		}

		/// <summary>
		/// Gets all <see cref="HotHeapStream"/>s
		/// </summary>
		public IList<HotHeapStream> HotHeapStreams {
			get {
				if (hotHeapStreams == null) {
					var newHhs = CreateHotHeapStreams();
					if (Interlocked.CompareExchange(ref hotHeapStreams, newHhs, null) != null) {
						foreach (var hhs in newHhs)
							hhs.Dispose();
					}
				}
				return hotHeapStreams;
			}
		}

		/// <summary>
		/// Creates a <see cref="HotStream"/> instance
		/// </summary>
		/// <param name="version">Hot heap version</param>
		/// <param name="imageStream">Heap stream</param>
		/// <param name="streamHeader">Stream header info</param>
		/// <param name="fullStream">Stream for the full PE file</param>
		/// <param name="baseOffset">Offset in <paramref name="fullStream"/> where the data starts</param>
		/// <returns>A <see cref="HotStream"/> instance or <c>null</c> if <paramref name="version"/>
		/// is invalid</returns>
		public static HotStream Create(HotHeapVersion version, IImageStream imageStream, StreamHeader streamHeader, IImageStream fullStream, FileOffset baseOffset) {
			switch (version) {
			case HotHeapVersion.CLR20: return new HotStreamCLR20(imageStream, streamHeader, fullStream, baseOffset);
			case HotHeapVersion.CLR40: return new HotStreamCLR40(imageStream, streamHeader, fullStream, baseOffset);
			default: return null;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="imageStream">Heap stream</param>
		/// <param name="streamHeader">Stream header info</param>
		/// <param name="fullStream">Stream for the full PE file</param>
		/// <param name="baseOffset">Offset in <paramref name="fullStream"/> where the data starts</param>
		protected HotStream(IImageStream imageStream, StreamHeader streamHeader, IImageStream fullStream, FileOffset baseOffset)
			: base(imageStream, streamHeader) {
			this.fullStream = fullStream;
			this.baseOffset = (long)baseOffset;
			this.endOffset = (long)baseOffset + imageStream.Length;
		}

		[SecurityCritical]	// Req'd on .NET 4.0
		HotTableStream CreateHotTableStream() {
			try {
				return CreateHotTableStreamImpl();
			}
			catch (AccessViolationException) {
				return null;
			}
			catch (IOException) {
				return null;
			}
		}

		[SecurityCritical]	// Req'd on .NET 4.0
		ThreadSafe.IList<HotHeapStream> CreateHotHeapStreams() {
			try {
				return CreateHotHeapStreams2();
			}
			catch (AccessViolationException) {
				return null;
			}
			catch (IOException) {
				return null;
			}
		}

		ThreadSafe.IList<HotHeapStream> CreateHotHeapStreams2() {
			var list = ThreadSafeListCreator.Create<HotHeapStream>();
			try {
				long dirBaseOffs = GetHotHeapDirectoryBaseOffset();
				for (long offs = dirBaseOffs; offs + 8 <= endOffset - 8; offs += 8) {
					fullStream.Position = offs;
					HeapType heapType;
					long hotHeapOffset;
					ReadHotHeapDirectory(fullStream, dirBaseOffs, out heapType, out hotHeapOffset);

					IImageStream dataStream = null;
					HotHeapStream hotHeapStream = null;
					try {
						dataStream = fullStream.Clone();
						list.Add(hotHeapStream = CreateHotHeapStream(heapType, dataStream, hotHeapOffset));
						dataStream = null;
						hotHeapStream = null;
					}
					catch {
						if (hotHeapStream != null)
							hotHeapStream.Dispose();
						if (dataStream != null)
							dataStream.Dispose();
						throw;
					}
				}
			}
			catch {
				foreach (var h in list)
					h.Dispose();
				throw;
			}
			return list;
		}

		/// <summary>
		/// Reads a hot heap directory
		/// </summary>
		/// <param name="reader">Reader stream</param>
		/// <param name="dirBaseOffs">Pool directory base offset</param>
		/// <param name="heapType">Updated with heap type</param>
		/// <param name="hotHeapOffs">Updated with heap offset</param>
		protected abstract void ReadHotHeapDirectory(IImageStream reader, long dirBaseOffs, out HeapType heapType, out long hotHeapOffs);

		/// <summary>
		/// Creates a <see cref="HotHeapStream"/>
		/// </summary>
		/// <param name="heapType">Heap type</param>
		/// <param name="stream">Data stream</param>
		/// <param name="baseOffset">Offset in <paramref name="stream"/> of start of data</param>
		/// <returns>A new <see cref="HotHeapStream"/> instance</returns>
		protected abstract HotHeapStream CreateHotHeapStream(HeapType heapType, IImageStream stream, long baseOffset);

		/// <summary>
		/// Creates the <see cref="dnlib.DotNet.MD.HotTableStream"/>
		/// </summary>
		/// <returns>A new instance or <c>null</c> if it doesn't exist</returns>
		protected abstract HotTableStream CreateHotTableStreamImpl();

		/// <summary>
		/// Gets the offset of the hot table directory in <see cref="fullStream"/>
		/// </summary>
		protected long GetHotTableBaseOffset() {
			// All bits in this dword are used
			return endOffset - 8 - HotTableStream.HOT_HEAP_DIR_SIZE - fullStream.ReadUInt32At(endOffset - 8);
		}

		/// <summary>
		/// Gets the offset of the hot pool directory in <see cref="fullStream"/>
		/// </summary>
		protected abstract long GetHotHeapDirectoryBaseOffset();

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			if (disposing) {
				IDisposable id = fullStream;
				if (id != null)
					id.Dispose();
				id = hotTableStream;
				if (id != null)
					id.Dispose();
				var hhs = hotHeapStreams;
				if (hhs != null) {
					foreach (var hs in hhs) {
						if (hs != null)
							hs.Dispose();
					}
				}
			}
			base.Dispose(disposing);
		}
	}

	/// <summary>
	/// Represents the #! stream. Should be used if the module uses CLR 2.0 (.NET 2.0 - 3.5)
	/// </summary>
	sealed class HotStreamCLR20 : HotStream {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="imageStream">Heap stream</param>
		/// <param name="streamHeader">Stream header info</param>
		/// <param name="fullStream">Stream for the full PE file</param>
		/// <param name="baseOffset">Offset in <paramref name="fullStream"/> where the data starts</param>
		public HotStreamCLR20(IImageStream imageStream, StreamHeader streamHeader, IImageStream fullStream, FileOffset baseOffset)
			: base(imageStream, streamHeader, fullStream, baseOffset) {
		}

		/// <inheritdoc/>
		protected override HotTableStream CreateHotTableStreamImpl() {
			IImageStream stream = null;
			try {
				stream = fullStream.Clone();
				return new HotTableStreamCLR20(stream, GetHotTableBaseOffset());
			}
			catch {
				if (stream != null)
					stream.Dispose();
				throw;
			}
		}

		/// <inheritdoc/>
		protected override long GetHotHeapDirectoryBaseOffset() {
			// Lower 2 bits are ignored
			return endOffset - 8 - (fullStream.ReadUInt32At(endOffset - 8 + 4) & ~3);
		}

		/// <inheritdoc/>
		protected override void ReadHotHeapDirectory(IImageStream reader, long dirBaseOffs, out HeapType heapType, out long hotHeapOffs) {
			heapType = (HeapType)reader.ReadUInt32();
			// Lower 2 bits are ignored
			hotHeapOffs = dirBaseOffs - (reader.ReadUInt32() & ~3);
		}

		/// <inheritdoc/>
		protected override HotHeapStream CreateHotHeapStream(HeapType heapType, IImageStream stream, long baseOffset) {
			return new HotHeapStreamCLR20(heapType, stream, baseOffset);
		}
	}

	/// <summary>
	/// Represents the #! stream. Should be used if the module uses CLR 4.0 (.NET 4.0 - 4.5)
	/// </summary>
	sealed class HotStreamCLR40 : HotStream {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="imageStream">Heap stream</param>
		/// <param name="streamHeader">Stream header info</param>
		/// <param name="fullStream">Stream for the full PE file</param>
		/// <param name="baseOffset">Offset in <paramref name="fullStream"/> where the data starts</param>
		public HotStreamCLR40(IImageStream imageStream, StreamHeader streamHeader, IImageStream fullStream, FileOffset baseOffset)
			: base(imageStream, streamHeader, fullStream, baseOffset) {
		}

		/// <inheritdoc/>
		protected override HotTableStream CreateHotTableStreamImpl() {
			IImageStream stream = null;
			try {
				stream = fullStream.Clone();
				return new HotTableStreamCLR40(stream, GetHotTableBaseOffset());
			}
			catch {
				if (stream != null)
					stream.Dispose();
				throw;
			}
		}

		/// <inheritdoc/>
		protected override long GetHotHeapDirectoryBaseOffset() {
			// All bits are used
			return endOffset - 8 - fullStream.ReadUInt32At(endOffset - 8 + 4);
		}

		/// <inheritdoc/>
		protected override void ReadHotHeapDirectory(IImageStream reader, long dirBaseOffs, out HeapType heapType, out long hotHeapOffs) {
			heapType = (HeapType)reader.ReadUInt32();
			// All bits are used
			hotHeapOffs = dirBaseOffs - reader.ReadUInt32();
		}

		/// <inheritdoc/>
		protected override HotHeapStream CreateHotHeapStream(HeapType heapType, IImageStream stream, long baseOffset) {
			return new HotHeapStreamCLR40(heapType, stream, baseOffset);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/HotTableStream.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using System.Security;
using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Stores some/all rows of a table
	/// </summary>
	abstract class HotTableStream : IDisposable {
		protected const int MAX_TABLES = (int)Table.GenericParamConstraint + 1;
		internal const uint HOT_HEAP_DIR_SIZE = 4 + MAX_TABLES * 4;

		protected readonly IImageStream fullStream;
		protected readonly long baseOffset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fullStream">Data stream</param>
		/// <param name="baseOffset">Offset in <paramref name="fullStream"/> of start of the
		/// hot table directory header</param>
		protected HotTableStream(IImageStream fullStream, long baseOffset) {
			this.fullStream = fullStream;
			this.baseOffset = baseOffset;
		}

		/// <summary>
		/// Must be called once after creating it so it can initialize
		/// </summary>
		/// <param name="mask">Offset mask (<c>0xFFFFFFFF</c> or <c>0xFFFFFFFFFFFFFFFF</c>)</param>
		public abstract void Initialize(long mask);

		/// <summary>
		/// Returns a reader positioned at a table row
		/// </summary>
		/// <param name="table">Table</param>
		/// <param name="rid">A valid row ID (i.e., &gt;= <c>1</c> and &lt;= number of rows)</param>
		/// <returns>The reader (owned by us) or <c>null</c> if the row isn't present</returns>
		public IImageStream GetTableReader(MDTable table, uint rid) {
			long offset;
			if (GetRowOffset(table, rid, out offset)) {
				fullStream.Position = offset;
				return fullStream;
			}

			return null;
		}

		/// <summary>
		/// Returns the offset (in <see cref="fullStream"/>) of a row
		/// </summary>
		/// <param name="table">Table</param>
		/// <param name="rid">A valid row ID (i.e., &gt;= <c>1</c> and &lt;= number of rows)</param>
		/// <param name="offset">Updated with the offset</param>
		/// <returns><c>true</c> if the row exists, <c>false</c> if the row doesn't exist</returns>
		protected abstract bool GetRowOffset(MDTable table, uint rid, out long offset);

		/// <summary>
		/// Add offsets
		/// </summary>
		/// <param name="mask">Mask</param>
		/// <param name="baseOffset">Base offset</param>
		/// <param name="displ">Displacement</param>
		/// <returns>Returns <c>0</c> if <paramref name="displ"/> is <c>0</c>, else returns
		/// the sum of <paramref name="baseOffset"/> and <paramref name="displ"/> masked
		/// by <paramref name="mask"/></returns>
		protected static long AddOffsets(long mask, long baseOffset, long displ) {
			if (displ == 0)
				return 0;
			return (baseOffset + displ) & mask;
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (disposing) {
				var fs = fullStream;
				if (fs != null)
					fs.Dispose();
			}
		}
	}

	/// <summary>
	/// Hot table stream (CLR 2.0)
	/// </summary>
	sealed class HotTableStreamCLR20 : HotTableStream {
		TableHeader[] tableHeaders;

		class TableHeader {
			public uint numRows;
			public long posTable1;
			public long posTable2;
			public long posData;
			public int shift;
			public uint mask;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fullStream">Data stream</param>
		/// <param name="baseOffset">Offset in <paramref name="fullStream"/> of start of the
		/// hot table directory header</param>
		public HotTableStreamCLR20(IImageStream fullStream, long baseOffset)
			: base(fullStream, baseOffset) {
		}

		/// <inheritdoc/>
		[SecurityCritical]	// Req'd on .NET 4.0
		public override void Initialize(long mask) {
			tableHeaders = new TableHeader[MAX_TABLES];
			for (int i = 0; i < tableHeaders.Length; i++) {
				fullStream.Position = baseOffset + 4 + i * 4;
				int headerOffs = fullStream.ReadInt32();
				if (headerOffs == 0)
					continue;
				var headerBaseOffs = (baseOffset + headerOffs) & mask;
				fullStream.Position = headerBaseOffs;
				try {
					var header = new TableHeader {
						numRows = fullStream.ReadUInt32(),
						posTable1 = AddOffsets(mask, headerBaseOffs, fullStream.ReadInt32()),
						posTable2 = (headerBaseOffs + fullStream.ReadInt32()) & mask,
						posData = (headerBaseOffs + fullStream.ReadInt32()) & mask,
						shift = fullStream.ReadUInt16(),
					};
					header.mask = (1U << header.shift) - 1;
					tableHeaders[i] = header;
				}
				// Ignore exceptions. The CLR only reads these values when needed. Assume
				// that this was invalid data that the CLR will never read anyway.
				catch (AccessViolationException) {
				}
				catch (IOException) {
				}
			}
		}

		/// <inheritdoc/>
		protected override bool GetRowOffset(MDTable table, uint rid, out long offset) {
			offset = 0;
			if ((uint)table.Table >= (uint)tableHeaders.Length)
				return false;
			var header = tableHeaders[(int)table.Table];
			if (header == null)
				return false;

			// Check whether the whole table is in memory
			if (header.posTable1 == 0) {
				offset = header.posData + (rid - 1) * table.RowSize;
				return true;
			}

			fullStream.Position = header.posTable1 + (rid & header.mask) * 2;
			int index = fullStream.ReadUInt16();
			int stop = fullStream.ReadUInt16();
			fullStream.Position = header.posTable2 + index;
			byte highBits = (byte)(rid >> header.shift);
			while (index < stop) {
				if (fullStream.ReadByte() == highBits) {
					offset = header.posData + index * table.RowSize;
					return true;
				}
				index++;
			}

			offset = 0;
			return false;
		}
	}

	/// <summary>
	/// Hot table stream (CLR 4.0)
	/// </summary>
	sealed class HotTableStreamCLR40 : HotTableStream {
		TableHeader[] tableHeaders;

		class TableHeader {
			public uint numRows;
			public long posTable1;
			public long posTable2;
			public long posIndexes;
			public long posData;
			public int shift;
			public uint mask;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fullStream">Data stream</param>
		/// <param name="baseOffset">Offset in <paramref name="fullStream"/> of start of the
		/// hot table directory header</param>
		public HotTableStreamCLR40(IImageStream fullStream, long baseOffset)
			: base(fullStream, baseOffset) {
		}

		/// <inheritdoc/>
		[SecurityCritical]	// Req'd on .NET 4.0
		public override void Initialize(long mask) {
			tableHeaders = new TableHeader[MAX_TABLES];
			for (int i = 0; i < tableHeaders.Length; i++) {
				fullStream.Position = baseOffset + 4 + i * 4;
				int headerOffs = fullStream.ReadInt32();
				if (headerOffs == 0)
					continue;
				var headerBaseOffs = (baseOffset + headerOffs) & mask;
				fullStream.Position = headerBaseOffs;
				try {
					var header = new TableHeader {
						numRows = fullStream.ReadUInt32(),
						posTable1 = AddOffsets(mask, headerBaseOffs, fullStream.ReadInt32()),
						posTable2 = (headerBaseOffs + fullStream.ReadInt32()) & mask,
						posIndexes = (headerBaseOffs + fullStream.ReadInt32()) & mask,
						posData = (headerBaseOffs + fullStream.ReadInt32()) & mask,
						shift = fullStream.ReadUInt16(),
					};
					header.mask = (1U << header.shift) - 1;
					tableHeaders[i] = header;
				}
				// Ignore exceptions. The CLR only reads these values when needed. Assume
				// that this was invalid data that the CLR will never read anyway.
				catch (AccessViolationException) {
				}
				catch (IOException) {
				}
			}
		}

		/// <inheritdoc/>
		protected override bool GetRowOffset(MDTable table, uint rid, out long offset) {
			offset = 0;
			if ((uint)table.Table >= (uint)tableHeaders.Length)
				return false;
			var header = tableHeaders[(int)table.Table];
			if (header == null)
				return false;

			// Check whether the whole table is in memory
			if (header.posTable1 == 0) {
				offset = header.posData + (rid - 1) * table.RowSize;
				return true;
			}

			fullStream.Position = header.posTable1 + (rid & header.mask) * 2;
			int index = fullStream.ReadUInt16();
			int stop = fullStream.ReadUInt16();
			fullStream.Position = header.posTable2 + index;
			byte highBits = (byte)(rid >> header.shift);
			while (index < stop) {
				if (fullStream.ReadByte() == highBits) {
					index = fullStream.ReadUInt16At(header.posIndexes + index * 2);
					offset = header.posData + index * table.RowSize;
					return true;
				}
				index++;
			}

			offset = 0;
			return false;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/IMetaData.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.PE;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Interface to access the .NET metadata
	/// </summary>
	public interface IMetaData : IDisposable {
		/// <summary>
		/// <c>true</c> if the compressed (normal) metadata is used, <c>false</c> if the non-compressed
		/// (Edit N' Continue) metadata is used. This can be <c>false</c> even if the table stream
		/// is <c>#~</c> but that's very uncommon.
		/// </summary>
		bool IsCompressed { get; }

		/// <summary>
		/// <c>true</c> if this is standalone Portable PDB metadata
		/// </summary>
		bool IsStandalonePortablePdb { get; }

		/// <summary>
		/// Gets the .NET header
		/// </summary>
		ImageCor20Header ImageCor20Header { get; }

		/// <summary>
		/// Gets the major version number found in the MetaData header
		/// </summary>
		ushort MajorVersion { get; }

		/// <summary>
		/// Gets the minor version number found in the MetaData header
		/// </summary>
		ushort MinorVersion { get; }

		/// <summary>
		/// Gets the version string found in the MetaData header
		/// </summary>
		string VersionString { get; }

		/// <summary>
		/// Gets the <see cref="IPEImage"/>
		/// </summary>
		IPEImage PEImage { get; }

		/// <summary>
		/// Gets the metadata header
		/// </summary>
		MetaDataHeader MetaDataHeader { get; }

		/// <summary>
		/// Returns the #Strings stream or a default empty one if it's not present
		/// </summary>
		StringsStream StringsStream { get; }

		/// <summary>
		/// Returns the #US stream or a default empty one if it's not present
		/// </summary>
		USStream USStream { get; }

		/// <summary>
		/// Returns the #Blob stream or a default empty one if it's not present
		/// </summary>
		BlobStream BlobStream { get; }

		/// <summary>
		/// Returns the #GUID stream or a default empty one if it's not present
		/// </summary>
		GuidStream GuidStream { get; }

		/// <summary>
		/// Returns the #~ or #- tables stream
		/// </summary>
		TablesStream TablesStream { get; }

		/// <summary>
		/// Returns the #Pdb stream or null if it's not a standalone portable PDB file
		/// </summary>
		PdbStream PdbStream { get; }

		/// <summary>
		/// Gets all streams
		/// </summary>
		ThreadSafe.IList<DotNetStream> AllStreams { get; }

		/// <summary>
		/// Gets a list of all the valid <c>TypeDef</c> rids. It's usually every rid in the
		/// <c>TypeDef</c> table, but could be less if a type has been deleted.
		/// </summary>
		RidList GetTypeDefRidList();

		/// <summary>
		/// Gets a list of all the valid <c>ExportedType</c> rids. It's usually every rid in the
		/// <c>ExportedType</c> table, but could be less if a type has been deleted.
		/// </summary>
		RidList GetExportedTypeRidList();

		/// <summary>
		/// Gets the <c>Field</c> rid list
		/// </summary>
		/// <param name="typeDefRid"><c>TypeDef</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetFieldRidList(uint typeDefRid);

		/// <summary>
		/// Gets the <c>Method</c> rid list
		/// </summary>
		/// <param name="typeDefRid"><c>TypeDef</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetMethodRidList(uint typeDefRid);

		/// <summary>
		/// Gets the <c>Param</c> rid list
		/// </summary>
		/// <param name="methodRid"><c>Method</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetParamRidList(uint methodRid);

		/// <summary>
		/// Gets the <c>Event</c> rid list
		/// </summary>
		/// <param name="eventMapRid"><c>EventMap</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetEventRidList(uint eventMapRid);

		/// <summary>
		/// Gets the <c>Property</c> rid list
		/// </summary>
		/// <param name="propertyMapRid"><c>PropertyMap</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetPropertyRidList(uint propertyMapRid);

		/// <summary>
		/// Finds all <c>InterfaceImpl</c> rids owned by <paramref name="typeDefRid"/>
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>InterfaceImpl</c> rids</returns>
		RidList GetInterfaceImplRidList(uint typeDefRid);

		/// <summary>
		/// Finds all <c>GenericParam</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>TypeOrMethodDef</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>GenericParam</c> rids</returns>
		RidList GetGenericParamRidList(Table table, uint rid);

		/// <summary>
		/// Finds all <c>GenericParamConstraint</c> rids owned by <paramref name="genericParamRid"/>
		/// </summary>
		/// <param name="genericParamRid">Owner <c>GenericParam</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>GenericParamConstraint</c> rids</returns>
		RidList GetGenericParamConstraintRidList(uint genericParamRid);

		/// <summary>
		/// Finds all <c>CustomAttribute</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>HasCustomAttribute</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>CustomAttribute</c> rids</returns>
		RidList GetCustomAttributeRidList(Table table, uint rid);

		/// <summary>
		/// Finds all <c>DeclSecurity</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>HasDeclSecurity</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>DeclSecurity</c> rids</returns>
		RidList GetDeclSecurityRidList(Table table, uint rid);

		/// <summary>
		/// Finds all <c>MethodSemantics</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>HasSemantic</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>MethodSemantics</c> rids</returns>
		RidList GetMethodSemanticsRidList(Table table, uint rid);

		/// <summary>
		/// Finds all <c>MethodImpl</c> rids owned by <paramref name="typeDefRid"/>
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>MethodImpl</c> rids</returns>
		RidList GetMethodImplRidList(uint typeDefRid);

		/// <summary>
		/// Finds a <c>ClassLayout</c> rid
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>The <c>ClassLayout</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
		/// or if it has no row in the <c>ClassLayout</c> table.</returns>
		uint GetClassLayoutRid(uint typeDefRid);

		/// <summary>
		/// Finds a <c>FieldLayout</c> rid
		/// </summary>
		/// <param name="fieldRid">Owner <c>Field</c> rid</param>
		/// <returns>The <c>FieldLayout</c> rid or 0 if <paramref name="fieldRid"/> is invalid
		/// or if it has no row in the <c>FieldLayout</c> table.</returns>
		uint GetFieldLayoutRid(uint fieldRid);

		/// <summary>
		/// Finds a <c>FieldMarshal</c> rid
		/// </summary>
		/// <param name="table">A <c>HasFieldMarshal</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>The <c>FieldMarshal</c> rid or 0 if <paramref name="rid"/> is invalid
		/// or if it has no row in the <c>FieldMarshal</c> table.</returns>
		uint GetFieldMarshalRid(Table table, uint rid);

		/// <summary>
		/// Finds a <c>FieldRVA</c> rid
		/// </summary>
		/// <param name="fieldRid">Owner <c>Field</c> rid</param>
		/// <returns>The <c>FieldRVA</c> rid or 0 if <paramref name="fieldRid"/> is invalid
		/// or if it has no row in the <c>FieldRVA</c> table.</returns>
		uint GetFieldRVARid(uint fieldRid);

		/// <summary>
		/// Finds an <c>ImplMap</c> rid
		/// </summary>
		/// <param name="table">A <c>MemberForwarded</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>The <c>ImplMap</c> rid or 0 if <paramref name="rid"/> is invalid
		/// or if it has no row in the <c>ImplMap</c> table.</returns>
		uint GetImplMapRid(Table table, uint rid);

		/// <summary>
		/// Finds a <c>NestedClass</c> rid
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>The <c>NestedClass</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
		/// or if it has no row in the <c>NestedClass</c> table.</returns>
		uint GetNestedClassRid(uint typeDefRid);

		/// <summary>
		/// Finds an <c>EventMap</c> rid
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>The <c>EventMap</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
		/// or if it has no row in the <c>EventMap</c> table.</returns>
		uint GetEventMapRid(uint typeDefRid);

		/// <summary>
		/// Finds a <c>PropertyMap</c> rid
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>The <c>PropertyMap</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
		/// or if it has no row in the <c>PropertyMap</c> table.</returns>
		uint GetPropertyMapRid(uint typeDefRid);

		/// <summary>
		/// Finds a <c>Constant</c> rid
		/// </summary>
		/// <param name="table">A <c>HasConstant</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>The <c>Constant</c> rid or 0 if <paramref name="rid"/> is invalid
		/// or if it has no row in the <c>Constant</c> table.</returns>
		uint GetConstantRid(Table table, uint rid);

		/// <summary>
		/// Returns the owner <c>TypeDef</c> rid
		/// </summary>
		/// <param name="fieldRid">A <c>Field</c> rid</param>
		/// <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="fieldRid"/> is invalid
		/// or if it has no owner.</returns>
		uint GetOwnerTypeOfField(uint fieldRid);

		/// <summary>
		/// Returns the owner <c>TypeDef</c> rid
		/// </summary>
		/// <param name="methodRid">A <c>Method</c> rid</param>
		/// <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="methodRid"/> is invalid
		/// or if it has no owner.</returns>
		uint GetOwnerTypeOfMethod(uint methodRid);

		/// <summary>
		/// Returns the owner <c>TypeDef</c> rid
		/// </summary>
		/// <param name="eventRid">A <c>Event</c> rid</param>
		/// <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="eventRid"/> is invalid
		/// or if it has no owner.</returns>
		uint GetOwnerTypeOfEvent(uint eventRid);

		/// <summary>
		/// Returns the owner <c>TypeDef</c> rid
		/// </summary>
		/// <param name="propertyRid">A <c>Property</c> rid</param>
		/// <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="propertyRid"/> is invalid
		/// or if it has no owner.</returns>
		uint GetOwnerTypeOfProperty(uint propertyRid);

		/// <summary>
		/// Returns the owner <c>TypeOrMethodDef</c> rid
		/// </summary>
		/// <param name="gpRid">A <c>GenericParam</c> rid</param>
		/// <returns>The owner <c>TypeOrMethodDef</c> rid or 0 if <paramref name="gpRid"/> is
		/// invalid or if it has no owner.</returns>
		uint GetOwnerOfGenericParam(uint gpRid);

		/// <summary>
		/// Returns the owner <c>GenericParam</c> rid
		/// </summary>
		/// <param name="gpcRid">A <c>GenericParamConstraint</c> rid</param>
		/// <returns>The owner <c>GenericParam</c> rid or 0 if <paramref name="gpcRid"/> is
		/// invalid or if it has no owner.</returns>
		uint GetOwnerOfGenericParamConstraint(uint gpcRid);

		/// <summary>
		/// Returns the owner <c>Method</c> rid
		/// </summary>
		/// <param name="paramRid">A <c>Param</c> rid</param>
		/// <returns>The owner <c>Method</c> rid or 0 if <paramref name="paramRid"/> is invalid
		/// or if it has no owner.</returns>
		uint GetOwnerOfParam(uint paramRid);

		/// <summary>
		/// Gets a list of all nested classes owned by <paramref name="typeDefRid"/>
		/// </summary>
		/// <param name="typeDefRid">A <c>TypeDef</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetNestedClassRidList(uint typeDefRid);

		/// <summary>
		/// Gets a list of all non-nested classes. A type is a non-nested type if
		/// <see cref="GetNestedClassRidList(uint)"/> returns an empty list.
		/// </summary>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetNonNestedClassRidList();

		/// <summary>
		/// Finds all <c>LocalScope</c> rids owned by <paramref name="methodRid"/>
		/// </summary>
		/// <param name="methodRid">Owner <c>Method</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>LocalScope</c> rids</returns>
		RidList GetLocalScopeRidList(uint methodRid);

		/// <summary>
		/// Gets the <c>StateMachineMethod</c> rid or 0 if it's not a state machine method
		/// </summary>
		/// <param name="methodRid">Owner <c>Method</c> rid</param>
		/// <returns></returns>
		uint GetStateMachineMethodRid(uint methodRid);

		/// <summary>
		/// Finds all <c>CustomDebugInformation</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>HasCustomDebugInformation</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>CustomDebugInformation</c> rids</returns>
		RidList GetCustomDebugInformationRidList(Table table, uint rid);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/IRowReaders.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.MD {
	/// <summary>
	/// Reads metadata table columns
	/// </summary>
	public interface IColumnReader {
		/// <summary>
		/// Reads a column
		/// </summary>
		/// <param name="table">The table to read from</param>
		/// <param name="rid">Table row id</param>
		/// <param name="column">The column to read</param>
		/// <param name="value">Result</param>
		/// <returns><c>true</c> if <paramref name="value"/> was updated, <c>false</c> if
		/// the column should be read from the original table.</returns>
		bool ReadColumn(MDTable table, uint rid, ColumnInfo column, out uint value);
	}

	/// <summary>
	/// Reads table rows
	/// </summary>
	/// <typeparam name="TRow">Raw row</typeparam>
	public interface IRowReader<TRow> where TRow : class, IRawRow {
		/// <summary>
		/// Reads a table row
		/// </summary>
		/// <param name="rid">Row id</param>
		/// <returns>The table row or <c>null</c> if its row should be read from the original
		/// table</returns>
		TRow ReadRow(uint rid);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/ImageCor20Header.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the IMAGE_COR20_HEADER structure
	/// </summary>
	public sealed class ImageCor20Header : FileSection {
		readonly uint cb;
		readonly ushort majorRuntimeVersion;
		readonly ushort minorRuntimeVersion;
		readonly ImageDataDirectory metaData;
		readonly ComImageFlags flags;
		readonly uint entryPointToken_or_RVA;
		readonly ImageDataDirectory resources;
		readonly ImageDataDirectory strongNameSignature;
		readonly ImageDataDirectory codeManagerTable;
		readonly ImageDataDirectory vtableFixups;
		readonly ImageDataDirectory exportAddressTableJumps;
		readonly ImageDataDirectory managedNativeHeader;

		/// <summary>
		/// Returns <c>true</c> if it has a native header
		/// </summary>
		public bool HasNativeHeader {
			get { return (flags & ComImageFlags.ILLibrary) != 0; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.cb field
		/// </summary>
		public uint CB {
			get { return cb; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.MajorRuntimeVersion field
		/// </summary>
		public ushort MajorRuntimeVersion {
			get { return majorRuntimeVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.MinorRuntimeVersion field
		/// </summary>
		public ushort MinorRuntimeVersion {
			get { return minorRuntimeVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.MetaData field
		/// </summary>
		public ImageDataDirectory MetaData {
			get { return metaData; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.Flags field
		/// </summary>
		public ComImageFlags Flags {
			get { return flags; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.EntryPointToken/EntryPointTokenRVA field
		/// </summary>
		public uint EntryPointToken_or_RVA {
			get { return entryPointToken_or_RVA; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.Resources field
		/// </summary>
		public ImageDataDirectory Resources {
			get { return resources; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.StrongNameSignature field
		/// </summary>
		public ImageDataDirectory StrongNameSignature {
			get { return strongNameSignature; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.CodeManagerTable field
		/// </summary>
		public ImageDataDirectory CodeManagerTable {
			get { return codeManagerTable; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.VTableFixups field
		/// </summary>
		public ImageDataDirectory VTableFixups {
			get { return vtableFixups; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.ExportAddressTableJumps field
		/// </summary>
		public ImageDataDirectory ExportAddressTableJumps {
			get { return exportAddressTableJumps; }
		}

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.ManagedNativeHeader field
		/// </summary>
		public ImageDataDirectory ManagedNativeHeader {
			get { return managedNativeHeader; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageCor20Header(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			this.cb = reader.ReadUInt32();
			if (verify && this.cb < 0x48)
				throw new BadImageFormatException("Invalid IMAGE_COR20_HEADER.cb value");
			this.majorRuntimeVersion = reader.ReadUInt16();
			this.minorRuntimeVersion = reader.ReadUInt16();
			this.metaData = new ImageDataDirectory(reader, verify);
			this.flags = (ComImageFlags)reader.ReadUInt32();
			this.entryPointToken_or_RVA = reader.ReadUInt32();
			this.resources = new ImageDataDirectory(reader, verify);
			this.strongNameSignature = new ImageDataDirectory(reader, verify);
			this.codeManagerTable = new ImageDataDirectory(reader, verify);
			this.vtableFixups = new ImageDataDirectory(reader, verify);
			this.exportAddressTableJumps = new ImageDataDirectory(reader, verify);
			this.managedNativeHeader = new ImageDataDirectory(reader, verify);
			SetEndoffset(reader);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/MDHeaderRuntimeVersion.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.MD {
	/// <summary>
	/// Version strings found in the meta data header
	/// </summary>
	public static class MDHeaderRuntimeVersion {
		/// <summary>
		/// MS CLR 1.0 version string (.NET 1.0)
		/// </summary>
		public const string MS_CLR_10 = "v1.0.3705";

		/// <summary>
		/// MS CLR 1.0 version string (.NET 1.0). This is an incorrect version that shouldn't be used.
		/// </summary>
		public const string MS_CLR_10_X86RETAIL = "v1.x86ret";

		/// <summary>
		/// MS CLR 1.0 version string (.NET 1.0). This is an incorrect version that shouldn't be used.
		/// </summary>
		public const string MS_CLR_10_RETAIL = "retail";

		/// <summary>
		/// MS CLR 1.0 version string (.NET 1.0). This is an incorrect version that shouldn't be used.
		/// </summary>
		public const string MS_CLR_10_COMPLUS = "COMPLUS";

		/// <summary>
		/// MS CLR 1.1 version string (.NET 1.1)
		/// </summary>
		public const string MS_CLR_11 = "v1.1.4322";

		/// <summary>
		/// MS CLR 2.0 version string (.NET 2.0-3.5)
		/// </summary>
		public const string MS_CLR_20 = "v2.0.50727";

		/// <summary>
		/// MS CLR 4.0 version string (.NET 4.0-4.5)
		/// </summary>
		public const string MS_CLR_40 = "v4.0.30319";

		/// <summary>
		/// MS CLR 1.0 any version
		/// </summary>
		public const string MS_CLR_10_PREFIX = "v1.0";

		/// <summary>
		/// MS CLR 1.0 any version
		/// </summary>
		public const string MS_CLR_10_PREFIX_X86RETAIL = "v1.x86";

		/// <summary>
		/// MS CLR 1.1 any version
		/// </summary>
		public const string MS_CLR_11_PREFIX = "v1.1";

		/// <summary>
		/// MS CLR 2.0 any version
		/// </summary>
		public const string MS_CLR_20_PREFIX = "v2.0";

		/// <summary>
		/// MS CLR 4.0 any version
		/// </summary>
		public const string MS_CLR_40_PREFIX = "v4.0";

		/// <summary>
		/// ECMA 2002 version string
		/// </summary>
		public const string ECMA_2002 = "Standard CLI 2002";

		/// <summary>
		/// ECMA 2005 version string
		/// </summary>
		public const string ECMA_2005 = "Standard CLI 2005";

		/// <summary>
		/// Portable PDB v1.0
		/// </summary>
		public const string PORTABLE_PDB_V1_0 = "PDB v1.0";
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/MDStreamFlags.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// MDStream flags
	/// </summary>
	[Flags]
	public enum MDStreamFlags : byte {
		/// <summary>#Strings stream is big and requires 4 byte offsets</summary>
		BigStrings = 1,
		/// <summary>#GUID stream is big and requires 4 byte offsets</summary>
		BigGUID = 2,
		/// <summary>#Blob stream is big and requires 4 byte offsets</summary>
		BigBlob = 4,
		/// <summary/>
		Padding = 8,
		/// <summary/>
		DeltaOnly = 0x20,
		/// <summary>Extra data follows the row counts</summary>
		ExtraData = 0x40,
		/// <summary>Set if certain tables can contain deleted rows. The name column (if present) is set to "_Deleted"</summary>
		HasDelete = 0x80,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/MDTable.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// A MD table (eg. Method table)
	/// </summary>
	[DebuggerDisplay("DL:{imageStream.Length} R:{numRows} RS:{tableInfo.RowSize} C:{Count} {tableInfo.Name}")]
	public sealed class MDTable : IDisposable, IFileSection {
		readonly Table table;
		uint numRows;
		TableInfo tableInfo;
		IImageStream imageStream;

		// Fix for VS2015 expression evaluator: "The debugger is unable to evaluate this expression"
		int Count {
			get { return tableInfo.Columns.Count; }
		}

		/// <inheritdoc/>
		public FileOffset StartOffset {
			get { return imageStream.FileOffset; }
		}

		/// <inheritdoc/>
		public FileOffset EndOffset {
			get { return imageStream.FileOffset + imageStream.Length; }
		}

		/// <summary>
		/// Gets the table
		/// </summary>
		public Table Table {
			get { return table; }
		}

		/// <summary>
		/// Gets the name of this table
		/// </summary>
		public string Name {
			get { return tableInfo.Name; }
		}

		/// <summary>
		/// Returns total number of rows
		/// </summary>
		public uint Rows {
			get { return numRows; }
		}

		/// <summary>
		/// Gets the total size in bytes of one row in this table
		/// </summary>
		public uint RowSize {
			get { return (uint)tableInfo.RowSize; }
		}

		/// <summary>
		/// Returns all the columns
		/// </summary>
		public IList<ColumnInfo> Columns {
			get { return tableInfo.Columns; }
		}

		/// <summary>
		/// Returns <c>true</c> if there are no valid rows
		/// </summary>
		public bool IsEmpty {
			get { return numRows == 0; }
		}

		/// <summary>
		/// Returns info about this table
		/// </summary>
		public TableInfo TableInfo {
			get { return tableInfo; }
		}

		/// <summary>
		/// The stream that can access all the rows in this table
		/// </summary>
		internal IImageStream ImageStream {
			get { return imageStream; }
			set {
				var ims = imageStream;
				if (ims == value)
					return;
				if (ims != null)
					ims.Dispose();
				imageStream = value;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">The table</param>
		/// <param name="numRows">Number of rows in this table</param>
		/// <param name="tableInfo">Info about this table</param>
		internal MDTable(Table table, uint numRows, TableInfo tableInfo) {
			this.table = table;
			this.numRows = numRows;
			this.tableInfo = tableInfo;
		}

		internal IImageStream CloneImageStream() {
			return imageStream.Clone();
		}

		/// <summary>
		/// Checks whether the row <paramref name="rid"/> exists
		/// </summary>
		/// <param name="rid">Row ID</param>
		public bool IsValidRID(uint rid) {
			return rid != 0 && rid <= numRows;
		}

		/// <summary>
		/// Checks whether the row <paramref name="rid"/> does not exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		public bool IsInvalidRID(uint rid) {
			return rid == 0 || rid > numRows;
		}

		/// <inheritdoc/>
		public void Dispose() {
			var ims = imageStream;
			if (ims != null)
				ims.Dispose();
			numRows = 0;
			tableInfo = null;
			imageStream = null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/MetaData.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using dnlib.IO;
using dnlib.PE;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Common base class for #~ and #- metadata classes
	/// </summary>
	abstract class MetaData : IMetaData {
		/// <summary>
		/// The PE image
		/// </summary>
		protected IPEImage peImage;

		/// <summary>
		/// The .NET header
		/// </summary>
		protected ImageCor20Header cor20Header;

		/// <summary>
		/// The MD header
		/// </summary>
		protected MetaDataHeader mdHeader;

		/// <summary>
		/// The #Strings stream
		/// </summary>
		protected StringsStream stringsStream;

		/// <summary>
		/// The #US stream
		/// </summary>
		protected USStream usStream;

		/// <summary>
		/// The #Blob stream
		/// </summary>
		protected BlobStream blobStream;

		/// <summary>
		/// The #GUID stream
		/// </summary>
		protected GuidStream guidStream;

		/// <summary>
		/// The #~ or #- stream
		/// </summary>
		protected TablesStream tablesStream;

		/// <summary>
		/// The #Pdb stream
		/// </summary>
		protected PdbStream pdbStream;

		/// <summary>
		/// All the streams that are present in the PE image
		/// </summary>
		protected ThreadSafe.IList<DotNetStream> allStreams;

		/// <inheritdoc/>
		public bool IsStandalonePortablePdb {
			get { return isStandalonePortablePdb; }
		}
		/// <summary><c>true</c> if this is standalone Portable PDB metadata</summary>
		protected readonly bool isStandalonePortablePdb;

		uint[] fieldRidToTypeDefRid;
		uint[] methodRidToTypeDefRid;
		uint[] eventRidToTypeDefRid;
		uint[] propertyRidToTypeDefRid;
		uint[] gpRidToOwnerRid;
		uint[] gpcRidToOwnerRid;
		uint[] paramRidToOwnerRid;
		Dictionary<uint, RandomRidList> typeDefRidToNestedClasses;
		RandomRidList nonNestedTypes;

		/// <summary>
		/// Sorts a table by key column
		/// </summary>
		protected sealed class SortedTable {
			RowInfo[] rows;

			/// <summary>
			/// Remembers <c>rid</c> and key
			/// </summary>
			[DebuggerDisplay("{rid} {key}")]
			struct RowInfo : IComparable<RowInfo> {
				public readonly uint rid;
				public readonly uint key;

				/// <summary>
				/// Constructor
				/// </summary>
				/// <param name="rid">Row ID</param>
				/// <param name="key">Key</param>
				public RowInfo(uint rid, uint key) {
					this.rid = rid;
					this.key = key;
				}

				/// <inheritdoc/>
				public int CompareTo(RowInfo other) {
					if (key < other.key)
						return -1;
					if (key > other.key)
						return 1;
					return rid.CompareTo(other.rid);
				}
			}

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="mdTable">The MD table</param>
			/// <param name="keyColIndex">Index of key column</param>
			public SortedTable(MDTable mdTable, int keyColIndex) {
				InitializeKeys(mdTable, keyColIndex);
				Array.Sort(rows);
			}

			void InitializeKeys(MDTable mdTable, int keyColIndex) {
				var keyColumn = mdTable.TableInfo.Columns[keyColIndex];
				rows = new RowInfo[mdTable.Rows + 1];
				if (mdTable.Rows == 0)
					return;
				using (var reader = mdTable.CloneImageStream()) {
					reader.Position = keyColumn.Offset;
					int increment = mdTable.TableInfo.RowSize - keyColumn.Size;
					for (uint i = 1; i <= mdTable.Rows; i++) {
						rows[i] = new RowInfo(i, keyColumn.Read(reader));
						if (i < mdTable.Rows)
							reader.Position += increment;
					}
				}
			}

			/// <summary>
			/// Binary searches for a row with a certain key
			/// </summary>
			/// <param name="key">The key</param>
			/// <returns>The row or 0 if not found</returns>
			int BinarySearch(uint key) {
				int lo = 1, hi = rows.Length - 1;
				while (lo <= hi && hi != -1) {
					int curr = (lo + hi) / 2;
					uint key2 = rows[curr].key;
					if (key == key2)
						return curr;
					if (key2 > key)
						hi = curr - 1;
					else
						lo = curr + 1;
				}

				return 0;
			}

			/// <summary>
			/// Find all rids that contain <paramref name="key"/>
			/// </summary>
			/// <param name="key">The key</param>
			/// <returns>A new <see cref="RidList"/> instance</returns>
			public RidList FindAllRows(uint key) {
				int startIndex = BinarySearch(key);
				if (startIndex == 0)
					return RidList.Empty;
				int endIndex = startIndex + 1;
				for (; startIndex > 1; startIndex--) {
					if (key != rows[startIndex - 1].key)
						break;
				}
				for (; endIndex < rows.Length; endIndex++) {
					if (key != rows[endIndex].key)
						break;
				}
				var list = new RandomRidList(endIndex - startIndex);
				for (int i = startIndex; i < endIndex; i++)
					list.Add(rows[i].rid);
				return list;
			}
		}
		SortedTable eventMapSortedTable;
		SortedTable propertyMapSortedTable;

		/// <inheritdoc/>
		public abstract bool IsCompressed { get; }

		/// <inheritdoc/>
		public ImageCor20Header ImageCor20Header {
			get { return cor20Header; }
		}

		/// <inheritdoc/>
		public ushort MajorVersion {
			get { return mdHeader.MajorVersion; }
		}

		/// <inheritdoc/>
		public ushort MinorVersion {
			get { return mdHeader.MinorVersion; }
		}

		/// <inheritdoc/>
		public string VersionString {
			get { return mdHeader.VersionString; }
		}

		/// <inheritdoc/>
		public IPEImage PEImage {
			get { return peImage; }
		}

		/// <inheritdoc/>
		public MetaDataHeader MetaDataHeader {
			get { return mdHeader; }
		}

		/// <inheritdoc/>
		public StringsStream StringsStream {
			get { return stringsStream; }
		}

		/// <inheritdoc/>
		public USStream USStream {
			get { return usStream; }
		}

		/// <inheritdoc/>
		public BlobStream BlobStream {
			get { return blobStream; }
		}

		/// <inheritdoc/>
		public GuidStream GuidStream {
			get { return guidStream; }
		}

		/// <inheritdoc/>
		public TablesStream TablesStream {
			get { return tablesStream; }
		}

		/// <inheritdoc/>
		public PdbStream PdbStream {
			get { return pdbStream; }
		}

		/// <inheritdoc/>
		public ThreadSafe.IList<DotNetStream> AllStreams {
			get { return allStreams; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="cor20Header">The .NET header</param>
		/// <param name="mdHeader">The MD header</param>
		protected MetaData(IPEImage peImage, ImageCor20Header cor20Header, MetaDataHeader mdHeader) {
			try {
				this.allStreams = ThreadSafeListCreator.Create<DotNetStream>();
				this.peImage = peImage;
				this.cor20Header = cor20Header;
				this.mdHeader = mdHeader;
				isStandalonePortablePdb = false;
			}
			catch {
				if (peImage != null)
					peImage.Dispose();
				throw;
			}
		}

		internal MetaData(MetaDataHeader mdHeader, bool isStandalonePortablePdb) {
			this.allStreams = ThreadSafeListCreator.Create<DotNetStream>();
			this.peImage = null;
			this.cor20Header = null;
			this.mdHeader = mdHeader;
			this.isStandalonePortablePdb = isStandalonePortablePdb;
		}

		/// <summary>
		/// Initializes the metadata, tables, streams
		/// </summary>
		public void Initialize(IImageStream mdStream) {
			InitializeInternal(mdStream);

			if (tablesStream == null)
				throw new BadImageFormatException("Missing MD stream");
			if (isStandalonePortablePdb && pdbStream == null)
				throw new BadImageFormatException("Missing #Pdb stream");
			InitializeNonExistentHeaps();
		}

		/// <summary>
		/// Creates empty heap objects if they're not present in the metadata
		/// </summary>
		protected void InitializeNonExistentHeaps() {
			if (stringsStream == null)
				stringsStream = new StringsStream();
			if (usStream == null)
				usStream = new USStream();
			if (blobStream == null)
				blobStream = new BlobStream();
			if (guidStream == null)
				guidStream = new GuidStream();
		}

		/// <summary>
		/// Called by <see cref="Initialize(IImageStream)"/>
		/// </summary>
		protected abstract void InitializeInternal(IImageStream mdStream);

		/// <inheritdoc/>
		public virtual RidList GetTypeDefRidList() {
			return new ContiguousRidList(1, tablesStream.TypeDefTable.Rows);
		}

		/// <inheritdoc/>
		public virtual RidList GetExportedTypeRidList() {
			return new ContiguousRidList(1, tablesStream.ExportedTypeTable.Rows);
		}

		/// <inheritdoc/>
		public abstract RidList GetFieldRidList(uint typeDefRid);

		/// <inheritdoc/>
		public abstract RidList GetMethodRidList(uint typeDefRid);

		/// <inheritdoc/>
		public abstract RidList GetParamRidList(uint methodRid);

		/// <inheritdoc/>
		public abstract RidList GetEventRidList(uint eventMapRid);

		/// <inheritdoc/>
		public abstract RidList GetPropertyRidList(uint propertyMapRid);

		/// <summary>
		/// Binary searches the table for a <c>rid</c> whose key column at index
		/// <paramref name="keyColIndex"/> is equal to <paramref name="key"/>. The
		/// <see cref="tablesStream"/> has acquired its lock so only <c>*_NoLock</c> methods
		/// may be called.
		/// </summary>
		/// <param name="tableSource">Table to search</param>
		/// <param name="keyColIndex">Key column index</param>
		/// <param name="key">Key</param>
		/// <returns>The <c>rid</c> of the found row, or 0 if none found</returns>
		protected abstract uint BinarySearch_NoLock(MDTable tableSource, int keyColIndex, uint key);

		/// <summary>
		/// Finds all rows owned by <paramref name="key"/> in table <paramref name="tableSource"/>
		/// whose index is <paramref name="keyColIndex"/>
		/// </summary>
		/// <param name="tableSource">Table to search</param>
		/// <param name="keyColIndex">Key column index</param>
		/// <param name="key">Key</param>
		/// <returns>A <see cref="RidList"/> instance</returns>
		protected RidList FindAllRows(MDTable tableSource, int keyColIndex, uint key) {
#if THREAD_SAFE
			tablesStream.theLock.EnterWriteLock(); try {
#endif
			uint startRid = BinarySearch_NoLock(tableSource, keyColIndex, key);
			if (tableSource.IsInvalidRID(startRid))
				return RidList.Empty;
			uint endRid = startRid + 1;
			var column = tableSource.TableInfo.Columns[keyColIndex];
			for (; startRid > 1; startRid--) {
				uint key2;
				if (!tablesStream.ReadColumn_NoLock(tableSource, startRid - 1, column, out key2))
					break;	// Should never happen since startRid is valid
				if (key != key2)
					break;
			}
			for (; endRid <= tableSource.Rows; endRid++) {
				uint key2;
				if (!tablesStream.ReadColumn_NoLock(tableSource, endRid, column, out key2))
					break;	// Should never happen since endRid is valid
				if (key != key2)
					break;
			}
			return new ContiguousRidList(startRid, endRid - startRid);
#if THREAD_SAFE
			} finally { tablesStream.theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Finds all rows owned by <paramref name="key"/> in table <paramref name="tableSource"/>
		/// whose index is <paramref name="keyColIndex"/>. Should be called if <paramref name="tableSource"/>
		/// could be unsorted.
		/// </summary>
		/// <param name="tableSource">Table to search</param>
		/// <param name="keyColIndex">Key column index</param>
		/// <param name="key">Key</param>
		/// <returns>A <see cref="RidList"/> instance</returns>
		protected virtual RidList FindAllRowsUnsorted(MDTable tableSource, int keyColIndex, uint key) {
			return FindAllRows(tableSource, keyColIndex, key);
		}

		/// <inheritdoc/>
		public RidList GetInterfaceImplRidList(uint typeDefRid) {
			return FindAllRowsUnsorted(tablesStream.InterfaceImplTable, 0, typeDefRid);
		}

		/// <inheritdoc/>
		public RidList GetGenericParamRidList(Table table, uint rid) {
			uint codedToken;
			if (!CodedToken.TypeOrMethodDef.Encode(new MDToken(table, rid), out codedToken))
				return RidList.Empty;
			return FindAllRowsUnsorted(tablesStream.GenericParamTable, 2, codedToken);
		}

		/// <inheritdoc/>
		public RidList GetGenericParamConstraintRidList(uint genericParamRid) {
			return FindAllRowsUnsorted(tablesStream.GenericParamConstraintTable, 0, genericParamRid);
		}

		/// <inheritdoc/>
		public RidList GetCustomAttributeRidList(Table table, uint rid) {
			uint codedToken;
			if (!CodedToken.HasCustomAttribute.Encode(new MDToken(table, rid), out codedToken))
				return RidList.Empty;
			return FindAllRowsUnsorted(tablesStream.CustomAttributeTable, 0, codedToken);
		}

		/// <inheritdoc/>
		public RidList GetDeclSecurityRidList(Table table, uint rid) {
			uint codedToken;
			if (!CodedToken.HasDeclSecurity.Encode(new MDToken(table, rid), out codedToken))
				return RidList.Empty;
			return FindAllRowsUnsorted(tablesStream.DeclSecurityTable, 1, codedToken);
		}

		/// <inheritdoc/>
		public RidList GetMethodSemanticsRidList(Table table, uint rid) {
			uint codedToken;
			if (!CodedToken.HasSemantic.Encode(new MDToken(table, rid), out codedToken))
				return RidList.Empty;
			return FindAllRowsUnsorted(tablesStream.MethodSemanticsTable, 2, codedToken);
		}

		/// <inheritdoc/>
		public RidList GetMethodImplRidList(uint typeDefRid) {
			return FindAllRowsUnsorted(tablesStream.MethodImplTable, 0, typeDefRid);
		}

		/// <inheritdoc/>
		public uint GetClassLayoutRid(uint typeDefRid) {
			var list = FindAllRowsUnsorted(tablesStream.ClassLayoutTable, 2, typeDefRid);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetFieldLayoutRid(uint fieldRid) {
			var list = FindAllRowsUnsorted(tablesStream.FieldLayoutTable, 1, fieldRid);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetFieldMarshalRid(Table table, uint rid) {
			uint codedToken;
			if (!CodedToken.HasFieldMarshal.Encode(new MDToken(table, rid), out codedToken))
				return 0;
			var list = FindAllRowsUnsorted(tablesStream.FieldMarshalTable, 0, codedToken);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetFieldRVARid(uint fieldRid) {
			var list = FindAllRowsUnsorted(tablesStream.FieldRVATable, 1, fieldRid);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetImplMapRid(Table table, uint rid) {
			uint codedToken;
			if (!CodedToken.MemberForwarded.Encode(new MDToken(table, rid), out codedToken))
				return 0;
			var list = FindAllRowsUnsorted(tablesStream.ImplMapTable, 1, codedToken);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetNestedClassRid(uint typeDefRid) {
			var list = FindAllRowsUnsorted(tablesStream.NestedClassTable, 0, typeDefRid);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetEventMapRid(uint typeDefRid) {
			// The EventMap and PropertyMap tables can only be trusted to be sorted if it's
			// an NGen image and it's the normal #- stream. The IsSorted bit must not be used
			// to check whether the tables are sorted. See coreclr: md/inc/metamodel.h / IsVerified()
			if (eventMapSortedTable == null)
				Interlocked.CompareExchange(ref eventMapSortedTable, new SortedTable(tablesStream.EventMapTable, 0), null);
			var list = eventMapSortedTable.FindAllRows(typeDefRid);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetPropertyMapRid(uint typeDefRid) {
			// Always unsorted, see comment in GetEventMapRid() above
			if (propertyMapSortedTable == null)
				Interlocked.CompareExchange(ref propertyMapSortedTable, new SortedTable(tablesStream.PropertyMapTable, 0), null);
			var list = propertyMapSortedTable.FindAllRows(typeDefRid);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetConstantRid(Table table, uint rid) {
			uint codedToken;
			if (!CodedToken.HasConstant.Encode(new MDToken(table, rid), out codedToken))
				return 0;
			var list = FindAllRowsUnsorted(tablesStream.ConstantTable, 2, codedToken);
			return list.Length == 0 ? 0 : list[0];
		}

		/// <inheritdoc/>
		public uint GetOwnerTypeOfField(uint fieldRid) {
			if (fieldRidToTypeDefRid == null)
				InitializeInverseFieldOwnerRidList();
			uint index = fieldRid - 1;
			if (index >= fieldRidToTypeDefRid.LongLength)
				return 0;
			return fieldRidToTypeDefRid[index];
		}

		void InitializeInverseFieldOwnerRidList() {
			if (fieldRidToTypeDefRid != null)
				return;
			var newFieldRidToTypeDefRid = new uint[tablesStream.FieldTable.Rows];
			var ownerList = GetTypeDefRidList();
			for (uint i = 0; i < ownerList.Length; i++) {
				var ownerRid = ownerList[i];
				var fieldList = GetFieldRidList(ownerRid);
				for (uint j = 0; j < fieldList.Length; j++) {
					uint ridIndex = fieldList[j] - 1;
					if (newFieldRidToTypeDefRid[ridIndex] != 0)
						continue;
					newFieldRidToTypeDefRid[ridIndex] = ownerRid;
				}
			}
			Interlocked.CompareExchange(ref fieldRidToTypeDefRid, newFieldRidToTypeDefRid, null);
		}

		/// <inheritdoc/>
		public uint GetOwnerTypeOfMethod(uint methodRid) {
			if (methodRidToTypeDefRid == null)
				InitializeInverseMethodOwnerRidList();
			uint index = methodRid - 1;
			if (index >= methodRidToTypeDefRid.LongLength)
				return 0;
			return methodRidToTypeDefRid[index];
		}

		void InitializeInverseMethodOwnerRidList() {
			if (methodRidToTypeDefRid != null)
				return;
			var newMethodRidToTypeDefRid = new uint[tablesStream.MethodTable.Rows];
			var ownerList = GetTypeDefRidList();
			for (uint i = 0; i < ownerList.Length; i++) {
				var ownerRid = ownerList[i];
				var methodList = GetMethodRidList(ownerRid);
				for (uint j = 0; j < methodList.Length; j++) {
					uint ridIndex = methodList[j] - 1;
					if (newMethodRidToTypeDefRid[ridIndex] != 0)
						continue;
					newMethodRidToTypeDefRid[ridIndex] = ownerRid;
				}
			}
			Interlocked.CompareExchange(ref methodRidToTypeDefRid, newMethodRidToTypeDefRid, null);
		}

		/// <inheritdoc/>
		public uint GetOwnerTypeOfEvent(uint eventRid) {
			if (eventRidToTypeDefRid == null)
				InitializeInverseEventOwnerRidList();
			uint index = eventRid - 1;
			if (index >= eventRidToTypeDefRid.LongLength)
				return 0;
			return eventRidToTypeDefRid[index];
		}

		void InitializeInverseEventOwnerRidList() {
			if (eventRidToTypeDefRid != null)
				return;
			var newEventRidToTypeDefRid = new uint[tablesStream.EventTable.Rows];
			var ownerList = GetTypeDefRidList();
			for (uint i = 0; i < ownerList.Length; i++) {
				var ownerRid = ownerList[i];
				var eventList = GetEventRidList(GetEventMapRid(ownerRid));
				for (uint j = 0; j < eventList.Length; j++) {
					uint ridIndex = eventList[j] - 1;
					if (newEventRidToTypeDefRid[ridIndex] != 0)
						continue;
					newEventRidToTypeDefRid[ridIndex] = ownerRid;
				}
			}
			Interlocked.CompareExchange(ref eventRidToTypeDefRid, newEventRidToTypeDefRid, null);
		}

		/// <inheritdoc/>
		public uint GetOwnerTypeOfProperty(uint propertyRid) {
			if (propertyRidToTypeDefRid == null)
				InitializeInversePropertyOwnerRidList();
			uint index = propertyRid - 1;
			if (index >= propertyRidToTypeDefRid.LongLength)
				return 0;
			return propertyRidToTypeDefRid[index];
		}

		void InitializeInversePropertyOwnerRidList() {
			if (propertyRidToTypeDefRid != null)
				return;
			var newPropertyRidToTypeDefRid = new uint[tablesStream.PropertyTable.Rows];
			var ownerList = GetTypeDefRidList();
			for (uint i = 0; i < ownerList.Length; i++) {
				var ownerRid = ownerList[i];
				var propertyList = GetPropertyRidList(GetPropertyMapRid(ownerRid));
				for (uint j = 0; j < propertyList.Length; j++) {
					uint ridIndex = propertyList[j] - 1;
					if (newPropertyRidToTypeDefRid[ridIndex] != 0)
						continue;
					newPropertyRidToTypeDefRid[ridIndex] = ownerRid;
				}
			}
			Interlocked.CompareExchange(ref propertyRidToTypeDefRid, newPropertyRidToTypeDefRid, null);
		}

		/// <inheritdoc/>
		public uint GetOwnerOfGenericParam(uint gpRid) {
			// Don't use GenericParam.Owner column. If the GP table is sorted, it's
			// possible to have two blocks of GPs with the same owner. Only one of the
			// blocks is the "real" generic params for the owner. Of course, rarely
			// if ever will this occur, but could happen if some obfuscator has
			// added it.

			if (gpRidToOwnerRid == null)
				InitializeInverseGenericParamOwnerRidList();
			uint index = gpRid - 1;
			if (index >= gpRidToOwnerRid.LongLength)
				return 0;
			return gpRidToOwnerRid[index];
		}

		void InitializeInverseGenericParamOwnerRidList() {
			if (gpRidToOwnerRid != null)
				return;
			var gpTable = tablesStream.GenericParamTable;
			var newGpRidToOwnerRid = new uint[gpTable.Rows];

			// Find all owners by reading the GenericParam.Owner column
			var ownerCol = gpTable.TableInfo.Columns[2];
			var ownersDict = new Dictionary<uint, bool>();
#if THREAD_SAFE
			tablesStream.theLock.EnterWriteLock(); try {
#endif
			for (uint rid = 1; rid <= gpTable.Rows; rid++) {
				uint owner;
				if (!tablesStream.ReadColumn_NoLock(gpTable, rid, ownerCol, out owner))
					continue;
				ownersDict[owner] = true;
			}
#if THREAD_SAFE
			} finally { tablesStream.theLock.ExitWriteLock(); }
#endif

			// Now that we have the owners, find all the generic params they own. An obfuscated
			// module could have 2+ owners pointing to the same generic param row.
			var owners = new List<uint>(ownersDict.Keys);
			owners.Sort();
			for (int i = 0; i < owners.Count; i++) {
				uint ownerToken;
				if (!CodedToken.TypeOrMethodDef.Decode(owners[i], out ownerToken))
					continue;
				var ridList = GetGenericParamRidList(MDToken.ToTable(ownerToken), MDToken.ToRID(ownerToken));
				for (uint j = 0; j < ridList.Length; j++) {
					uint ridIndex = ridList[j] - 1;
					if (newGpRidToOwnerRid[ridIndex] != 0)
						continue;
					newGpRidToOwnerRid[ridIndex] = owners[i];
				}
			}
			Interlocked.CompareExchange(ref gpRidToOwnerRid, newGpRidToOwnerRid, null);
		}

		/// <inheritdoc/>
		public uint GetOwnerOfGenericParamConstraint(uint gpcRid) {
			// Don't use GenericParamConstraint.Owner column for the same reason
			// as described in GetOwnerOfGenericParam().

			if (gpcRidToOwnerRid == null)
				InitializeInverseGenericParamConstraintOwnerRidList();
			uint index = gpcRid - 1;
			if (index >= gpcRidToOwnerRid.LongLength)
				return 0;
			return gpcRidToOwnerRid[index];
		}

		void InitializeInverseGenericParamConstraintOwnerRidList() {
			if (gpcRidToOwnerRid != null)
				return;
			var gpcTable = tablesStream.GenericParamConstraintTable;
			var newGpcRidToOwnerRid = new uint[gpcTable.Rows];

			var ownerCol = gpcTable.TableInfo.Columns[0];
			var ownersDict = new Dictionary<uint, bool>();
#if THREAD_SAFE
			tablesStream.theLock.EnterWriteLock(); try {
#endif
			for (uint rid = 1; rid <= gpcTable.Rows; rid++) {
				uint owner;
				if (!tablesStream.ReadColumn_NoLock(gpcTable, rid, ownerCol, out owner))
					continue;
				ownersDict[owner] = true;
			}
#if THREAD_SAFE
			} finally { tablesStream.theLock.ExitWriteLock(); }
#endif

			var owners = new List<uint>(ownersDict.Keys);
			owners.Sort();
			for (int i = 0; i < owners.Count; i++) {
				uint ownerToken = owners[i];
				var ridList = GetGenericParamConstraintRidList(ownerToken);
				for (uint j = 0; j < ridList.Length; j++) {
					uint ridIndex = ridList[j] - 1;
					if (newGpcRidToOwnerRid[ridIndex] != 0)
						continue;
					newGpcRidToOwnerRid[ridIndex] = ownerToken;
				}
			}
			Interlocked.CompareExchange(ref gpcRidToOwnerRid, newGpcRidToOwnerRid, null);
		}

		/// <inheritdoc/>
		public uint GetOwnerOfParam(uint paramRid) {
			if (paramRidToOwnerRid == null)
				InitializeInverseParamOwnerRidList();
			uint index = paramRid - 1;
			if (index >= paramRidToOwnerRid.LongLength)
				return 0;
			return paramRidToOwnerRid[index];
		}

		void InitializeInverseParamOwnerRidList() {
			if (paramRidToOwnerRid != null)
				return;

			var newParamRidToOwnerRid = new uint[tablesStream.ParamTable.Rows];
			var table = tablesStream.MethodTable;
			for (uint rid = 1; rid <= table.Rows; rid++) {
				var ridList = GetParamRidList(rid);
				for (uint j = 0; j < ridList.Length; j++) {
					uint ridIndex = ridList[j] - 1;
					if (newParamRidToOwnerRid[ridIndex] != 0)
						continue;
					newParamRidToOwnerRid[ridIndex] = rid;
				}
			}
			Interlocked.CompareExchange(ref paramRidToOwnerRid, newParamRidToOwnerRid, null);
		}

		/// <inheritdoc/>
		public RidList GetNestedClassRidList(uint typeDefRid) {
			if (typeDefRidToNestedClasses == null)
				InitializeNestedClassesDictionary();
			RandomRidList ridList;
			if (typeDefRidToNestedClasses.TryGetValue(typeDefRid, out ridList))
				return ridList;
			return RidList.Empty;
		}

		void InitializeNestedClassesDictionary() {
			var table = tablesStream.NestedClassTable;
			var destTable = tablesStream.TypeDefTable;

			Dictionary<uint, bool> validTypeDefRids = null;
			var typeDefRidList = GetTypeDefRidList();
			if (typeDefRidList.Length != destTable.Rows) {
				validTypeDefRids = new Dictionary<uint, bool>((int)typeDefRidList.Length);
				for (uint i = 0; i < typeDefRidList.Length; i++)
					validTypeDefRids[typeDefRidList[i]] = true;
			}

			var nestedRidsDict = new Dictionary<uint, bool>((int)table.Rows);
			var nestedRids = new List<uint>((int)table.Rows);	// Need it so we add the rids in correct order
			for (uint rid = 1; rid <= table.Rows; rid++) {
				if (validTypeDefRids != null && !validTypeDefRids.ContainsKey(rid))
					continue;
				var row = tablesStream.ReadNestedClassRow(rid);
				if (row == null)
					continue;	// Should never happen since rid is valid
				if (!destTable.IsValidRID(row.NestedClass) || !destTable.IsValidRID(row.EnclosingClass))
					continue;
				if (nestedRidsDict.ContainsKey(row.NestedClass))
					continue;
				nestedRidsDict[row.NestedClass] = true;
				nestedRids.Add(row.NestedClass);
			}

			var newTypeDefRidToNestedClasses = new Dictionary<uint, RandomRidList>();
			foreach (var nestedRid in nestedRids) {
				var row = tablesStream.ReadNestedClassRow(GetNestedClassRid(nestedRid));
				if (row == null)
					continue;
				RandomRidList ridList;
				if (!newTypeDefRidToNestedClasses.TryGetValue(row.EnclosingClass, out ridList))
					newTypeDefRidToNestedClasses[row.EnclosingClass] = ridList = new RandomRidList();
				ridList.Add(nestedRid);
			}

			var newNonNestedTypes = new RandomRidList((int)(destTable.Rows - nestedRidsDict.Count));
			for (uint rid = 1; rid <= destTable.Rows; rid++) {
				if (validTypeDefRids != null && !validTypeDefRids.ContainsKey(rid))
					continue;
				if (nestedRidsDict.ContainsKey(rid))
					continue;
				newNonNestedTypes.Add(rid);
			}

			Interlocked.CompareExchange(ref nonNestedTypes, newNonNestedTypes, null);

			// Initialize this one last since it's tested by the callers of this method
			Interlocked.CompareExchange(ref typeDefRidToNestedClasses, newTypeDefRidToNestedClasses, null);
		}

		public RidList GetNonNestedClassRidList() {
			// Check typeDefRidToNestedClasses and not nonNestedTypes since
			// InitializeNestedClassesDictionary() writes to typeDefRidToNestedClasses last.
			if (typeDefRidToNestedClasses == null)
				InitializeNestedClassesDictionary();
			return nonNestedTypes;
		}

		public RidList GetLocalScopeRidList(uint methodRid) {
			return FindAllRows(tablesStream.LocalScopeTable, 0, methodRid);
		}

		public uint GetStateMachineMethodRid(uint methodRid) {
			var list = FindAllRows(tablesStream.StateMachineMethodTable, 0, methodRid);
			return list.Length == 0 ? 0 : list[0];
		}

		public RidList GetCustomDebugInformationRidList(Table table, uint rid) {
			uint codedToken;
			if (!CodedToken.HasCustomDebugInformation.Encode(new MDToken(table, rid), out codedToken))
				return RidList.Empty;
			return FindAllRows(tablesStream.CustomDebugInformationTable, 0, codedToken);
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			Dispose(peImage);
			Dispose(stringsStream);
			Dispose(usStream);
			Dispose(blobStream);
			Dispose(guidStream);
			Dispose(tablesStream);
			var as2 = allStreams;
			if (as2 != null) {
				foreach (var stream in as2.GetSafeEnumerable())
					Dispose(stream);
			}
			peImage = null;
			cor20Header = null;
			mdHeader = null;
			stringsStream = null;
			usStream = null;
			blobStream = null;
			guidStream = null;
			tablesStream = null;
			allStreams = null;
			fieldRidToTypeDefRid = null;
			methodRidToTypeDefRid = null;
			typeDefRidToNestedClasses = null;
		}

		static void Dispose(IDisposable id) {
			if (id != null)
				id.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/MetaDataCreator.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Low level access to a .NET file's metadata
	/// </summary>
	public static class MetaDataCreator {
		enum MetaDataType {
			Unknown,
			Compressed,	// #~ (normal)
			ENC,		// #- (edit and continue)
		}

		/// <summary>
		/// Create a <see cref="MetaData"/> instance
		/// </summary>
		/// <param name="fileName">The file to load</param>
		/// <returns>A new <see cref="MetaData"/> instance</returns>
		internal static MetaData Load(string fileName) {
			IPEImage peImage = null;
			try {
				return Load(peImage = new PEImage(fileName));
			}
			catch {
				if (peImage != null)
					peImage.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Create a <see cref="MetaData"/> instance
		/// </summary>
		/// <param name="data">The .NET file data</param>
		/// <returns>A new <see cref="MetaData"/> instance</returns>
		internal static MetaData Load(byte[] data) {
			IPEImage peImage = null;
			try {
				return Load(peImage = new PEImage(data));
			}
			catch {
				if (peImage != null)
					peImage.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Create a <see cref="MetaData"/> instance
		/// </summary>
		/// <param name="addr">Address of a .NET file in memory</param>
		/// <returns>A new <see cref="MetaData"/> instance</returns>
		internal static MetaData Load(IntPtr addr) {
			IPEImage peImage = null;

			// We don't know what layout it is. Memory is more common so try that first.
			try {
				return Load(peImage = new PEImage(addr, ImageLayout.Memory, true));
			}
			catch {
				if (peImage != null)
					peImage.Dispose();
				peImage = null;
			}

			try {
				return Load(peImage = new PEImage(addr, ImageLayout.File, true));
			}
			catch {
				if (peImage != null)
					peImage.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Create a <see cref="MetaData"/> instance
		/// </summary>
		/// <param name="addr">Address of a .NET file in memory</param>
		/// <param name="imageLayout">Image layout of the file in memory</param>
		/// <returns>A new <see cref="MetaData"/> instance</returns>
		internal static MetaData Load(IntPtr addr, ImageLayout imageLayout) {
			IPEImage peImage = null;
			try {
				return Load(peImage = new PEImage(addr, imageLayout, true));
			}
			catch {
				if (peImage != null)
					peImage.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Create a <see cref="MetaData"/> instance
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <returns>A new <see cref="MetaData"/> instance</returns>
		internal static MetaData Load(IPEImage peImage) {
			return Create(peImage, true);
		}

		/// <summary>
		/// Create a <see cref="IMetaData"/> instance
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <returns>A new <see cref="IMetaData"/> instance</returns>
		public static IMetaData CreateMetaData(IPEImage peImage) {
			return Create(peImage, true);
		}

        /// <summary>
        /// Create a <see cref="IMetaData"/> instance
        /// </summary>
        /// <param name="peImage">The PE image</param>
        /// <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
        /// <returns>A new <see cref="IMetaData"/> instance</returns>
        public static IMetaData CreateMetaData(IPEImage peImage, bool verify) {
			return Create(peImage, verify);
		}

		/// <summary>
		/// Create a <see cref="MetaData"/> instance
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
		/// <returns>A new <see cref="MetaData"/> instance</returns>
		static MetaData Create(IPEImage peImage, bool verify) {
			IImageStream cor20HeaderStream = null, mdHeaderStream = null;
			MetaData md = null;
			try {
				var dotNetDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[14];
				if (dotNetDir.VirtualAddress == 0)
					throw new BadImageFormatException(".NET data directory RVA is 0");
				if (dotNetDir.Size < 0x48)
					throw new BadImageFormatException(".NET data directory size < 0x48");
				var cor20Header = new ImageCor20Header(cor20HeaderStream = peImage.CreateStream(dotNetDir.VirtualAddress, 0x48), verify);
				if (cor20Header.MetaData.VirtualAddress == 0)
					throw new BadImageFormatException(".NET MetaData RVA is 0");
				if (cor20Header.MetaData.Size < 16)
					throw new BadImageFormatException(".NET MetaData size is too small");
				var mdSize = cor20Header.MetaData.Size;
				var mdRva = cor20Header.MetaData.VirtualAddress;
				var mdHeader = new MetaDataHeader(mdHeaderStream = peImage.CreateStream(mdRva, mdSize), verify);
				if (verify) {
					foreach (var sh in mdHeader.StreamHeaders) {
						if (sh.Offset + sh.StreamSize < sh.Offset || sh.Offset + sh.StreamSize > mdSize)
							throw new BadImageFormatException("Invalid stream header");
					}
				}

				switch (GetMetaDataType(mdHeader.StreamHeaders)) {
				case MetaDataType.Compressed:
					md = new CompressedMetaData(peImage, cor20Header, mdHeader);
					break;

				case MetaDataType.ENC:
					md = new ENCMetaData(peImage, cor20Header, mdHeader);
					break;

				default:
					throw new BadImageFormatException("No #~ or #- stream found");
				}
				md.Initialize(null);

				return md;
			}
			catch {
				if (md != null)
					md.Dispose();
				throw;
			}
			finally {
				if (cor20HeaderStream != null)
					cor20HeaderStream.Dispose();
				if (mdHeaderStream != null)
					mdHeaderStream.Dispose();
			}
		}

        internal static MetaData Create(IPEImage peImage, bool verify, RVA mdRva, uint mdSize) {
            IImageStream cor20HeaderStream = null, mdHeaderStream = null;
            MetaData md = null;
            try
            {
                var dotNetDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[14];
                if (dotNetDir.VirtualAddress == 0)
                    throw new BadImageFormatException(".NET data directory RVA is 0");
                if (dotNetDir.Size < 0x48)
                    throw new BadImageFormatException(".NET data directory size < 0x48");
                var cor20Header = new ImageCor20Header(cor20HeaderStream = peImage.CreateStream(dotNetDir.VirtualAddress, 0x48), verify);
                //if (cor20Header.MetaData.VirtualAddress == 0)
                //    throw new BadImageFormatException(".NET MetaData RVA is 0");
                //if (cor20Header.MetaData.Size < 16)
                //    throw new BadImageFormatException(".NET MetaData size is too small");
                cor20Header.MetaData.Size = mdSize;
                cor20Header.MetaData.VirtualAddress = mdRva;
                var mdHeader = new MetaDataHeader(mdHeaderStream = peImage.CreateStream(mdRva, mdSize), verify);
                if (verify)
                {
                    foreach (var sh in mdHeader.StreamHeaders)
                    {
                        if (sh.Offset + sh.StreamSize < sh.Offset || sh.Offset + sh.StreamSize > mdSize)
                            throw new BadImageFormatException("Invalid stream header");
                    }
                }

                switch (GetMetaDataType(mdHeader.StreamHeaders))
                {
                    case MetaDataType.Compressed:
                        md = new CompressedMetaData(peImage, cor20Header, mdHeader);
                        break;

                    case MetaDataType.ENC:
                        md = new ENCMetaData(peImage, cor20Header, mdHeader);
                        break;

                    default:
                        throw new BadImageFormatException("No #~ or #- stream found");
                }
                md.Initialize(null);

                return md;
            }
            catch
            {
                if (md != null)
                    md.Dispose();
                throw;
            }
            finally
            {
                if (cor20HeaderStream != null)
                    cor20HeaderStream.Dispose();
                if (mdHeaderStream != null)
                    mdHeaderStream.Dispose();
            }
        }

        /// <summary>
        /// Create a standalone portable PDB <see cref="MetaData"/> instance
        /// </summary>
        /// <param name="mdStream">Metadata stream</param>
        /// <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
        /// <returns>A new <see cref="MetaData"/> instance</returns>
        internal static MetaData CreateStandalonePortablePDB(IImageStream mdStream, bool verify) {
			MetaData md = null;
			try {
				var mdHeader = new MetaDataHeader(mdStream, verify);
				if (verify) {
					foreach (var sh in mdHeader.StreamHeaders) {
						if (sh.Offset + sh.StreamSize < sh.Offset || sh.Offset + sh.StreamSize > mdStream.Length)
							throw new BadImageFormatException("Invalid stream header");
					}
				}

				switch (GetMetaDataType(mdHeader.StreamHeaders)) {
				case MetaDataType.Compressed:
					md = new CompressedMetaData(mdHeader, true);
					break;

				case MetaDataType.ENC:
					md = new ENCMetaData(mdHeader, true);
					break;

				default:
					throw new BadImageFormatException("No #~ or #- stream found");
				}
				md.Initialize(mdStream);

				return md;
			}
			catch {
				if (md != null)
					md.Dispose();
				throw;
			}
		}

		static MetaDataType GetMetaDataType(IList<StreamHeader> streamHeaders) {
			MetaDataType? mdType = null;
			foreach (var sh in streamHeaders) {
				if (mdType == null) {
					if (sh.Name == "#~")
						mdType = MetaDataType.Compressed;
					else if (sh.Name == "#-")
						mdType = MetaDataType.ENC;
				}
				if (sh.Name == "#Schema")
					mdType = MetaDataType.ENC;
			}
			if (mdType == null)
				return MetaDataType.Unknown;
			return mdType.Value;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/MetaDataHeader.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Text;
using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the .NET metadata header
	/// </summary>
	/// <remarks><c>IMAGE_COR20_HEADER.MetaData</c> points to this header</remarks>
	public sealed class MetaDataHeader : FileSection {
		readonly uint signature;
		readonly ushort majorVersion;
		readonly ushort minorVersion;
		readonly uint reserved1;
		readonly uint stringLength;
		readonly string versionString;
		readonly FileOffset offset2ndPart;
		readonly StorageFlags flags;
		readonly byte reserved2;
		readonly ushort streams;
		readonly IList<StreamHeader> streamHeaders;

		/// <summary>
		/// Returns the signature (should be 0x424A5342)
		/// </summary>
		public uint Signature {
			get { return signature; }
		}

		/// <summary>
		/// Returns the major version
		/// </summary>
		public ushort MajorVersion {
			get { return majorVersion; }
		}

		/// <summary>
		/// Returns the minor version
		/// </summary>
		public ushort MinorVersion {
			get { return minorVersion; }
		}

		/// <summary>
		/// Returns the reserved dword (pointer to extra header data)
		/// </summary>
		public uint Reserved1 {
			get { return reserved1; }
		}

		/// <summary>
		/// Returns the version string length value
		/// </summary>
		public uint StringLength {
			get { return stringLength; }
		}

		/// <summary>
		/// Returns the version string
		/// </summary>
		public string VersionString {
			get { return versionString; }
		}

		/// <summary>
		/// Returns the offset of <c>STORAGEHEADER</c>
		/// </summary>
		public FileOffset StorageHeaderOffset {
			get { return offset2ndPart; }
		}

		/// <summary>
		/// Returns the flags (reserved)
		/// </summary>
		public StorageFlags Flags {
			get { return flags; }
		}

		/// <summary>
		/// Returns the reserved byte (padding)
		/// </summary>
		public byte Reserved2 {
			get { return reserved2; }
		}

		/// <summary>
		/// Returns the number of streams
		/// </summary>
		public ushort Streams {
			get { return streams; }
		}

		/// <summary>
		/// Returns all stream headers
		/// </summary>
		public IList<StreamHeader> StreamHeaders {
			get { return streamHeaders; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public MetaDataHeader(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			this.signature = reader.ReadUInt32();
			if (verify && this.signature != 0x424A5342)
				throw new BadImageFormatException("Invalid MetaData header signature");
			this.majorVersion = reader.ReadUInt16();
			this.minorVersion = reader.ReadUInt16();
			if (verify && !((majorVersion == 1 && minorVersion == 1) || (majorVersion == 0 && minorVersion >= 19)))
				throw new BadImageFormatException(string.Format("Unknown MetaData header version: {0}.{1}", majorVersion, minorVersion));
			this.reserved1 = reader.ReadUInt32();
			this.stringLength = reader.ReadUInt32();
			this.versionString = ReadString(reader, stringLength);
			this.offset2ndPart = reader.FileOffset + reader.Position;
			this.flags = (StorageFlags)reader.ReadByte();
			this.reserved2 = reader.ReadByte();
			this.streams = reader.ReadUInt16();
			this.streamHeaders = new StreamHeader[streams];
			for (int i = 0; i < streamHeaders.Count; i++)
				streamHeaders[i] = new StreamHeader(reader, verify);
			SetEndoffset(reader);
		}

		static string ReadString(IImageStream reader, uint maxLength) {
			long endPos = reader.Position + maxLength;
			if (endPos < reader.Position || endPos > reader.Length)
				throw new BadImageFormatException("Invalid MD version string");
			byte[] utf8Bytes = new byte[maxLength];
			uint i;
			for (i = 0; i < maxLength; i++) {
				byte b = reader.ReadByte();
				if (b == 0)
					break;
				utf8Bytes[i] = b;
			}
			reader.Position = endPos;
			return Encoding.UTF8.GetString(utf8Bytes, 0, (int)i);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/PdbStream.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// #Pdb stream
	/// </summary>
	public sealed class PdbStream : HeapStream {
		/// <summary>
		/// Gets the PDB id
		/// </summary>
		public byte[] Id { get; private set; }

		/// <summary>
		/// Gets the entry point token or 0
		/// </summary>
		public MDToken EntryPoint { get; private set; }

		/// <summary>
		/// Gets the referenced type system tables in the PE metadata file
		/// </summary>
		public ulong ReferencedTypeSystemTables { get; private set; }

		/// <summary>
		/// Gets all type system table rows. This array has exactly 64 elements.
		/// </summary>
		public uint[] TypeSystemTableRows { get; private set; }

		/// <inheritdoc/>
		public PdbStream(IImageStream imageStream, StreamHeader streamHeader)
			: base(imageStream, streamHeader) {
			using (var stream = GetClonedImageStream()) {
				Id = stream.ReadBytes(20);
				EntryPoint = new MDToken(stream.ReadUInt32());
				var tables = stream.ReadUInt64();
				ReferencedTypeSystemTables = tables;
				var rows = new uint[64];
				for (int i = 0; i < rows.Length; i++, tables >>= 1) {
					if (((uint)tables & 1) != 0)
						rows[i] = stream.ReadUInt32();
				}
				TypeSystemTableRows = rows;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/RawRowEqualityComparer.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;

#pragma warning disable 1591	// XML doc comments

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Equality comparer for all raw rows
	/// </summary>
	public sealed class RawRowEqualityComparer : IEqualityComparer<RawModuleRow>,
		IEqualityComparer<RawTypeRefRow>, IEqualityComparer<RawTypeDefRow>,
		IEqualityComparer<RawFieldPtrRow>, IEqualityComparer<RawFieldRow>,
		IEqualityComparer<RawMethodPtrRow>, IEqualityComparer<RawMethodRow>,
		IEqualityComparer<RawParamPtrRow>, IEqualityComparer<RawParamRow>,
		IEqualityComparer<RawInterfaceImplRow>, IEqualityComparer<RawMemberRefRow>,
		IEqualityComparer<RawConstantRow>, IEqualityComparer<RawCustomAttributeRow>,
		IEqualityComparer<RawFieldMarshalRow>, IEqualityComparer<RawDeclSecurityRow>,
		IEqualityComparer<RawClassLayoutRow>, IEqualityComparer<RawFieldLayoutRow>,
		IEqualityComparer<RawStandAloneSigRow>, IEqualityComparer<RawEventMapRow>,
		IEqualityComparer<RawEventPtrRow>, IEqualityComparer<RawEventRow>,
		IEqualityComparer<RawPropertyMapRow>, IEqualityComparer<RawPropertyPtrRow>,
		IEqualityComparer<RawPropertyRow>, IEqualityComparer<RawMethodSemanticsRow>,
		IEqualityComparer<RawMethodImplRow>, IEqualityComparer<RawModuleRefRow>,
		IEqualityComparer<RawTypeSpecRow>, IEqualityComparer<RawImplMapRow>,
		IEqualityComparer<RawFieldRVARow>, IEqualityComparer<RawENCLogRow>,
		IEqualityComparer<RawENCMapRow>, IEqualityComparer<RawAssemblyRow>,
		IEqualityComparer<RawAssemblyProcessorRow>, IEqualityComparer<RawAssemblyOSRow>,
		IEqualityComparer<RawAssemblyRefRow>, IEqualityComparer<RawAssemblyRefProcessorRow>,
		IEqualityComparer<RawAssemblyRefOSRow>, IEqualityComparer<RawFileRow>,
		IEqualityComparer<RawExportedTypeRow>, IEqualityComparer<RawManifestResourceRow>,
		IEqualityComparer<RawNestedClassRow>, IEqualityComparer<RawGenericParamRow>,
		IEqualityComparer<RawMethodSpecRow>, IEqualityComparer<RawGenericParamConstraintRow>,
		IEqualityComparer<RawDocumentRow>, IEqualityComparer<RawMethodDebugInformationRow>,
		IEqualityComparer<RawLocalScopeRow>, IEqualityComparer<RawLocalVariableRow>,
		IEqualityComparer<RawLocalConstantRow>, IEqualityComparer<RawImportScopeRow>,
		IEqualityComparer<RawStateMachineMethodRow>, IEqualityComparer<RawCustomDebugInformationRow> {

		/// <summary>
		/// Default instance
		/// </summary>
		public static readonly RawRowEqualityComparer Instance = new RawRowEqualityComparer();

		static int rol(uint val, int shift) {
			return (int)((val << shift) | (val >> (32 - shift)));
		}

		public bool Equals(RawModuleRow x, RawModuleRow y) {
			return x.Generation == y.Generation &&
				x.Name == y.Name &&
				x.Mvid == y.Mvid &&
				x.EncId == y.EncId &&
				x.EncBaseId == y.EncBaseId;
		}

		public int GetHashCode(RawModuleRow obj) {
			return obj.Generation +
				rol(obj.Name, 3) +
				rol(obj.Mvid, 7) +
				rol(obj.EncId, 11) +
				rol(obj.EncBaseId, 15);
		}

		public bool Equals(RawTypeRefRow x, RawTypeRefRow y) {
			return x.ResolutionScope == y.ResolutionScope &&
				x.Name == y.Name &&
				x.Namespace == y.Namespace;
		}

		public int GetHashCode(RawTypeRefRow obj) {
			return (int)obj.ResolutionScope +
				rol(obj.Name, 3) +
				rol(obj.Namespace, 7);
		}

		public bool Equals(RawTypeDefRow x, RawTypeDefRow y) {
			return x.Flags == y.Flags &&
				x.Name == y.Name &&
				x.Namespace == y.Namespace &&
				x.Extends == y.Extends &&
				x.FieldList == y.FieldList &&
				x.MethodList == y.MethodList;
		}

		public int GetHashCode(RawTypeDefRow obj) {
			return (int)obj.Flags +
				rol(obj.Name, 3) +
				rol(obj.Namespace, 7) +
				rol(obj.Extends, 11) +
				rol(obj.FieldList, 15) +
				rol(obj.MethodList, 19);
		}

		public bool Equals(RawFieldPtrRow x, RawFieldPtrRow y) {
			return x.Field == y.Field;
		}

		public int GetHashCode(RawFieldPtrRow obj) {
			return (int)obj.Field;
		}

		public bool Equals(RawFieldRow x, RawFieldRow y) {
			return x.Flags == y.Flags &&
				x.Name == y.Name &&
				x.Signature == y.Signature;
		}

		public int GetHashCode(RawFieldRow obj) {
			return (int)obj.Flags +
				rol(obj.Name, 3) +
				rol(obj.Signature, 7);
		}

		public bool Equals(RawMethodPtrRow x, RawMethodPtrRow y) {
			return x.Method == y.Method;
		}

		public int GetHashCode(RawMethodPtrRow obj) {
			return (int)obj.Method;
		}

		public bool Equals(RawMethodRow x, RawMethodRow y) {
			return x.RVA == y.RVA &&
				x.ImplFlags == y.ImplFlags &&
				x.Flags == y.Flags &&
				x.Name == y.Name &&
				x.Signature == y.Signature &&
				x.ParamList == y.ParamList;
		}

		public int GetHashCode(RawMethodRow obj) {
			return (int)obj.RVA +
				rol(obj.ImplFlags, 3) +
				rol(obj.Flags, 7) +
				rol(obj.Name, 11) +
				rol(obj.Signature, 15) +
				rol(obj.ParamList, 19);
		}

		public bool Equals(RawParamPtrRow x, RawParamPtrRow y) {
			return x.Param == y.Param;
		}

		public int GetHashCode(RawParamPtrRow obj) {
			return (int)obj.Param;
		}

		public bool Equals(RawParamRow x, RawParamRow y) {
			return x.Flags == y.Flags &&
				x.Sequence == y.Sequence &&
				x.Name == y.Name;
		}

		public int GetHashCode(RawParamRow obj) {
			return (int)obj.Flags +
				rol(obj.Sequence, 3) +
				rol(obj.Name, 7);
		}

		public bool Equals(RawInterfaceImplRow x, RawInterfaceImplRow y) {
			return x.Class == y.Class &&
				x.Interface == y.Interface;
		}

		public int GetHashCode(RawInterfaceImplRow obj) {
			return (int)obj.Class +
				rol(obj.Interface, 3);
		}

		public bool Equals(RawMemberRefRow x, RawMemberRefRow y) {
			return x.Class == y.Class &&
				x.Name == y.Name &&
				x.Signature == y.Signature;
		}

		public int GetHashCode(RawMemberRefRow obj) {
			return (int)obj.Class +
				rol(obj.Name, 3) +
				rol(obj.Signature, 7);
		}

		public bool Equals(RawConstantRow x, RawConstantRow y) {
			return x.Type == y.Type &&
				x.Padding == y.Padding &&
				x.Parent == y.Parent &&
				x.Value == y.Value;
		}

		public int GetHashCode(RawConstantRow obj) {
			return (int)obj.Type +
				rol(obj.Padding, 3) +
				rol(obj.Parent, 7) +
				rol(obj.Value, 11);
		}

		public bool Equals(RawCustomAttributeRow x, RawCustomAttributeRow y) {
			return x.Parent == y.Parent &&
				x.Type == y.Type &&
				x.Value == y.Value;
		}

		public int GetHashCode(RawCustomAttributeRow obj) {
			return (int)obj.Parent +
				rol(obj.Type, 3) +
				rol(obj.Value, 7);
		}

		public bool Equals(RawFieldMarshalRow x, RawFieldMarshalRow y) {
			return x.Parent == y.Parent &&
				x.NativeType == y.NativeType;
		}

		public int GetHashCode(RawFieldMarshalRow obj) {
			return (int)obj.Parent +
				rol(obj.NativeType, 3);
		}

		public bool Equals(RawDeclSecurityRow x, RawDeclSecurityRow y) {
			return x.Action == y.Action &&
				x.Parent == y.Parent &&
				x.PermissionSet == y.PermissionSet;
		}

		public int GetHashCode(RawDeclSecurityRow obj) {
			return (int)obj.Action +
				rol(obj.Parent, 3) +
				rol(obj.PermissionSet, 7);
		}

		public bool Equals(RawClassLayoutRow x, RawClassLayoutRow y) {
			return x.PackingSize == y.PackingSize &&
				x.ClassSize == y.ClassSize &&
				x.Parent == y.Parent;
		}

		public int GetHashCode(RawClassLayoutRow obj) {
			return (int)obj.PackingSize +
				rol(obj.ClassSize, 3) +
				rol(obj.Parent, 7);
		}

		public bool Equals(RawFieldLayoutRow x, RawFieldLayoutRow y) {
			return x.OffSet == y.OffSet &&
				x.Field == y.Field;
		}

		public int GetHashCode(RawFieldLayoutRow obj) {
			return (int)obj.OffSet +
				rol(obj.Field, 3);
		}

		public bool Equals(RawStandAloneSigRow x, RawStandAloneSigRow y) {
			return x.Signature == y.Signature;
		}

		public int GetHashCode(RawStandAloneSigRow obj) {
			return (int)obj.Signature;
		}

		public bool Equals(RawEventMapRow x, RawEventMapRow y) {
			return x.Parent == y.Parent &&
				x.EventList == y.EventList;
		}

		public int GetHashCode(RawEventMapRow obj) {
			return (int)obj.Parent +
				rol(obj.EventList, 3);
		}

		public bool Equals(RawEventPtrRow x, RawEventPtrRow y) {
			return x.Event == y.Event;
		}

		public int GetHashCode(RawEventPtrRow obj) {
			return (int)obj.Event;
		}

		public bool Equals(RawEventRow x, RawEventRow y) {
			return x.EventFlags == y.EventFlags &&
				x.Name == y.Name &&
				x.EventType == y.EventType;
		}

		public int GetHashCode(RawEventRow obj) {
			return (int)obj.EventFlags +
				rol(obj.Name, 3) +
				rol(obj.EventType, 7);
		}

		public bool Equals(RawPropertyMapRow x, RawPropertyMapRow y) {
			return x.Parent == y.Parent &&
				x.PropertyList == y.PropertyList;
		}

		public int GetHashCode(RawPropertyMapRow obj) {
			return (int)obj.Parent +
				rol(obj.PropertyList, 3);
		}

		public bool Equals(RawPropertyPtrRow x, RawPropertyPtrRow y) {
			return x.Property == y.Property;
		}

		public int GetHashCode(RawPropertyPtrRow obj) {
			return (int)obj.Property;
		}

		public bool Equals(RawPropertyRow x, RawPropertyRow y) {
			return x.PropFlags == y.PropFlags &&
				x.Name == y.Name &&
				x.Type == y.Type;
		}

		public int GetHashCode(RawPropertyRow obj) {
			return (int)obj.PropFlags +
				rol(obj.Name, 3) +
				rol(obj.Type, 7);
		}

		public bool Equals(RawMethodSemanticsRow x, RawMethodSemanticsRow y) {
			return x.Semantic == y.Semantic &&
				x.Method == y.Method &&
				x.Association == y.Association;
		}

		public int GetHashCode(RawMethodSemanticsRow obj) {
			return (int)obj.Semantic +
				rol(obj.Method, 3) +
				rol(obj.Association, 7);
		}

		public bool Equals(RawMethodImplRow x, RawMethodImplRow y) {
			return x.Class == y.Class &&
				x.MethodBody == y.MethodBody &&
				x.MethodDeclaration == y.MethodDeclaration;
		}

		public int GetHashCode(RawMethodImplRow obj) {
			return (int)obj.Class +
				rol(obj.MethodBody, 3) +
				rol(obj.MethodDeclaration, 7);
		}

		public bool Equals(RawModuleRefRow x, RawModuleRefRow y) {
			return x.Name == y.Name;
		}

		public int GetHashCode(RawModuleRefRow obj) {
			return (int)obj.Name;
		}

		public bool Equals(RawTypeSpecRow x, RawTypeSpecRow y) {
			return x.Signature == y.Signature;
		}

		public int GetHashCode(RawTypeSpecRow obj) {
			return (int)obj.Signature;
		}

		public bool Equals(RawImplMapRow x, RawImplMapRow y) {
			return x.MappingFlags == y.MappingFlags &&
				x.MemberForwarded == y.MemberForwarded &&
				x.ImportName == y.ImportName &&
				x.ImportScope == y.ImportScope;
		}

		public int GetHashCode(RawImplMapRow obj) {
			return (int)obj.MappingFlags +
				rol(obj.MemberForwarded, 3) +
				rol(obj.ImportName, 7) +
				rol(obj.ImportScope, 11);
		}

		public bool Equals(RawFieldRVARow x, RawFieldRVARow y) {
			return x.RVA == y.RVA &&
				x.Field == y.Field;
		}

		public int GetHashCode(RawFieldRVARow obj) {
			return (int)obj.RVA +
				rol(obj.Field, 3);
		}

		public bool Equals(RawENCLogRow x, RawENCLogRow y) {
			return x.Token == y.Token &&
				x.FuncCode == y.FuncCode;
		}

		public int GetHashCode(RawENCLogRow obj) {
			return (int)obj.Token +
				rol(obj.FuncCode, 3);
		}

		public bool Equals(RawENCMapRow x, RawENCMapRow y) {
			return x.Token == y.Token;
		}

		public int GetHashCode(RawENCMapRow obj) {
			return (int)obj.Token;
		}

		public bool Equals(RawAssemblyRow x, RawAssemblyRow y) {
			return x.HashAlgId == y.HashAlgId &&
				x.MajorVersion == y.MajorVersion &&
				x.MinorVersion == y.MinorVersion &&
				x.BuildNumber == y.BuildNumber &&
				x.RevisionNumber == y.RevisionNumber &&
				x.Flags == y.Flags &&
				x.PublicKey == y.PublicKey &&
				x.Name == y.Name &&
				x.Locale == y.Locale;
		}

		public int GetHashCode(RawAssemblyRow obj) {
			return (int)obj.HashAlgId +
				rol(obj.MajorVersion, 3) +
				rol(obj.MinorVersion, 7) +
				rol(obj.BuildNumber, 11) +
				rol(obj.RevisionNumber, 15) +
				rol(obj.Flags, 19) +
				rol(obj.PublicKey, 23) +
				rol(obj.Name, 27) +
				rol(obj.Locale, 31);
		}

		public bool Equals(RawAssemblyProcessorRow x, RawAssemblyProcessorRow y) {
			return x.Processor == y.Processor;
		}

		public int GetHashCode(RawAssemblyProcessorRow obj) {
			return (int)obj.Processor;
		}

		public bool Equals(RawAssemblyOSRow x, RawAssemblyOSRow y) {
			return x.OSPlatformId == y.OSPlatformId &&
				x.OSMajorVersion == y.OSMajorVersion &&
				x.OSMinorVersion == y.OSMinorVersion;
		}

		public int GetHashCode(RawAssemblyOSRow obj) {
			return (int)obj.OSPlatformId +
				rol(obj.OSMajorVersion, 3) +
				rol(obj.OSMinorVersion, 7);
		}

		public bool Equals(RawAssemblyRefRow x, RawAssemblyRefRow y) {
			return x.MajorVersion == y.MajorVersion &&
				x.MinorVersion == y.MinorVersion &&
				x.BuildNumber == y.BuildNumber &&
				x.RevisionNumber == y.RevisionNumber &&
				x.Flags == y.Flags &&
				x.PublicKeyOrToken == y.PublicKeyOrToken &&
				x.Name == y.Name &&
				x.Locale == y.Locale &&
				x.HashValue == y.HashValue;
		}

		public int GetHashCode(RawAssemblyRefRow obj) {
			return (int)obj.MajorVersion +
				rol(obj.MinorVersion, 3) +
				rol(obj.BuildNumber, 7) +
				rol(obj.RevisionNumber, 11) +
				rol(obj.Flags, 15) +
				rol(obj.PublicKeyOrToken, 19) +
				rol(obj.Name, 23) +
				rol(obj.Locale, 27) +
				rol(obj.HashValue, 31);
		}

		public bool Equals(RawAssemblyRefProcessorRow x, RawAssemblyRefProcessorRow y) {
			return x.Processor == y.Processor &&
				x.AssemblyRef == y.AssemblyRef;
		}

		public int GetHashCode(RawAssemblyRefProcessorRow obj) {
			return (int)obj.Processor +
				rol(obj.AssemblyRef, 3);
		}

		public bool Equals(RawAssemblyRefOSRow x, RawAssemblyRefOSRow y) {
			return x.OSPlatformId == y.OSPlatformId &&
				x.OSMajorVersion == y.OSMajorVersion &&
				x.OSMinorVersion == y.OSMinorVersion &&
				x.AssemblyRef == y.AssemblyRef;
		}

		public int GetHashCode(RawAssemblyRefOSRow obj) {
			return (int)obj.OSPlatformId +
				rol(obj.OSMajorVersion, 3) +
				rol(obj.OSMinorVersion, 7) +
				rol(obj.AssemblyRef, 11);
		}

		public bool Equals(RawFileRow x, RawFileRow y) {
			return x.Flags == y.Flags &&
				x.Name == y.Name &&
				x.HashValue == y.HashValue;
		}

		public int GetHashCode(RawFileRow obj) {
			return (int)obj.Flags +
				rol(obj.Name, 3) +
				rol(obj.HashValue, 7);
		}

		public bool Equals(RawExportedTypeRow x, RawExportedTypeRow y) {
			return x.Flags == y.Flags &&
				x.TypeDefId == y.TypeDefId &&
				x.TypeName == y.TypeName &&
				x.TypeNamespace == y.TypeNamespace &&
				x.Implementation == y.Implementation;
		}

		public int GetHashCode(RawExportedTypeRow obj) {
			return (int)obj.Flags +
				rol(obj.TypeDefId, 3) +
				rol(obj.TypeName, 7) +
				rol(obj.TypeNamespace, 11) +
				rol(obj.Implementation, 15);
		}

		public bool Equals(RawManifestResourceRow x, RawManifestResourceRow y) {
			return x.Offset == y.Offset &&
				x.Flags == y.Flags &&
				x.Name == y.Name &&
				x.Implementation == y.Implementation;
		}

		public int GetHashCode(RawManifestResourceRow obj) {
			return (int)obj.Offset +
				rol(obj.Flags, 3) +
				rol(obj.Name, 7) +
				rol(obj.Implementation, 11);
		}

		public bool Equals(RawNestedClassRow x, RawNestedClassRow y) {
			return x.NestedClass == y.NestedClass &&
				x.EnclosingClass == y.EnclosingClass;
		}

		public int GetHashCode(RawNestedClassRow obj) {
			return (int)obj.NestedClass +
				rol(obj.EnclosingClass, 3);
		}

		public bool Equals(RawGenericParamRow x, RawGenericParamRow y) {
			return x.Number == y.Number &&
				x.Flags == y.Flags &&
				x.Owner == y.Owner &&
				x.Name == y.Name &&
				x.Kind == y.Kind;
		}

		public int GetHashCode(RawGenericParamRow obj) {
			return (int)obj.Number +
				rol(obj.Flags, 3) +
				rol(obj.Owner, 7) +
				rol(obj.Name, 11) +
				rol(obj.Kind, 15);
		}

		public bool Equals(RawMethodSpecRow x, RawMethodSpecRow y) {
			return x.Method == y.Method &&
				x.Instantiation == y.Instantiation;
		}

		public int GetHashCode(RawMethodSpecRow obj) {
			return (int)obj.Method +
				rol(obj.Instantiation, 3);
		}

		public bool Equals(RawGenericParamConstraintRow x, RawGenericParamConstraintRow y) {
			return x.Owner == y.Owner &&
				x.Constraint == y.Constraint;
		}

		public int GetHashCode(RawGenericParamConstraintRow obj) {
			return (int)obj.Owner +
				rol(obj.Constraint, 3);
		}

		public bool Equals(RawDocumentRow x, RawDocumentRow y) {
			return x.Name == y.Name &&
				x.HashAlgorithm == y.HashAlgorithm &&
				x.Hash == y.Hash &&
				x.Language == y.Language;
		}

		public int GetHashCode(RawDocumentRow obj) {
			return (int)obj.Name +
				rol(obj.HashAlgorithm, 3) +
				rol(obj.Hash, 7) +
				rol(obj.Language, 11);
		}

		public bool Equals(RawMethodDebugInformationRow x, RawMethodDebugInformationRow y) {
			return x.Document == y.Document &&
				x.SequencePoints == y.SequencePoints;
		}

		public int GetHashCode(RawMethodDebugInformationRow obj) {
			return (int)obj.Document +
				rol(obj.SequencePoints, 3);
		}

		public bool Equals(RawLocalScopeRow x, RawLocalScopeRow y) {
			return x.Method == y.Method &&
				x.ImportScope == y.ImportScope &&
				x.VariableList == y.VariableList &&
				x.ConstantList == y.ConstantList &&
				x.StartOffset == y.StartOffset &&
				x.Length == y.Length;
		}

		public int GetHashCode(RawLocalScopeRow obj) {
			return (int)obj.Method +
				rol(obj.ImportScope, 3) +
				rol(obj.VariableList, 7) +
				rol(obj.ConstantList, 11) +
				rol(obj.StartOffset, 15) +
				rol(obj.Length, 19);
		}

		public bool Equals(RawLocalVariableRow x, RawLocalVariableRow y) {
			return x.Attributes == y.Attributes &&
				x.Index == y.Index &&
				x.Name == y.Name;
		}

		public int GetHashCode(RawLocalVariableRow obj) {
			return obj.Attributes +
				rol(obj.Index, 3) +
				rol(obj.Name, 7);
		}

		public bool Equals(RawLocalConstantRow x, RawLocalConstantRow y) {
			return x.Name == y.Name &&
				x.Signature == y.Signature;
		}

		public int GetHashCode(RawLocalConstantRow obj) {
			return (int)obj.Name +
				rol(obj.Signature, 3);
		}

		public bool Equals(RawImportScopeRow x, RawImportScopeRow y) {
			return x.Parent == y.Parent &&
				x.Imports == y.Imports;
		}

		public int GetHashCode(RawImportScopeRow obj) {
			return (int)obj.Parent +
				rol(obj.Imports, 3);
		}

		public bool Equals(RawStateMachineMethodRow x, RawStateMachineMethodRow y) {
			return x.MoveNextMethod == y.MoveNextMethod &&
				x.KickoffMethod == y.KickoffMethod;
		}

		public int GetHashCode(RawStateMachineMethodRow obj) {
			return (int)obj.MoveNextMethod +
				rol(obj.KickoffMethod, 3);
		}

		public bool Equals(RawCustomDebugInformationRow x, RawCustomDebugInformationRow y) {
			return x.Parent == y.Parent &&
				x.Kind == y.Kind &&
				x.Value == y.Value;
		}

		public int GetHashCode(RawCustomDebugInformationRow obj) {
			return (int)obj.Parent +
				rol(obj.Kind, 3) +
				rol(obj.Value, 7);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/RawTableRows.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.MD {
	/// <summary>
	/// A raw table row
	/// </summary>
	public interface IRawRow {
		/// <summary>
		/// Reads a column
		/// </summary>
		/// <param name="index">Column index</param>
		/// <returns>Column value</returns>
		uint Read(int index);

		/// <summary>
		/// Writes a column
		/// </summary>
		/// <param name="index">Column index</param>
		/// <param name="value">New value</param>
		void Write(int index, uint value);
	}

	/// <summary>
	/// Raw contents of an uncompressed Module table row
	/// </summary>
	public sealed class RawModuleRow : IRawRow {
		/// <summary/>
		public ushort Generation;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Mvid;
		/// <summary/>
		public uint EncId;
		/// <summary/>
		public uint EncBaseId;

		/// <summary>Default constructor</summary>
		public RawModuleRow() {
		}

		/// <summary>Constructor</summary>
		public RawModuleRow(ushort Generation, uint Name, uint Mvid, uint EncId, uint EncBaseId) {
			this.Generation = Generation;
			this.Name = Name;
			this.Mvid = Mvid;
			this.EncId = EncId;
			this.EncBaseId = EncBaseId;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Generation;
			case 1: return Name;
			case 2: return Mvid;
			case 3: return EncId;
			case 4: return EncBaseId;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Generation = (ushort)value; break;
			case 1: Name = value; break;
			case 2: Mvid = value; break;
			case 3: EncId = value; break;
			case 4: EncBaseId = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed TypeRef table row
	/// </summary>
	public sealed class RawTypeRefRow : IRawRow {
		/// <summary/>
		public uint ResolutionScope;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Namespace;

		/// <summary>Default constructor</summary>
		public RawTypeRefRow() {
		}

		/// <summary>Constructor</summary>
		public RawTypeRefRow(uint ResolutionScope, uint Name, uint Namespace) {
			this.ResolutionScope = ResolutionScope;
			this.Name = Name;
			this.Namespace = Namespace;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return ResolutionScope;
			case 1: return Name;
			case 2: return Namespace;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: ResolutionScope = value; break;
			case 1: Name = value; break;
			case 2: Namespace = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed TypeDef table row
	/// </summary>
	public sealed class RawTypeDefRow : IRawRow {
		/// <summary/>
		public uint Flags;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Namespace;
		/// <summary/>
		public uint Extends;
		/// <summary/>
		public uint FieldList;
		/// <summary/>
		public uint MethodList;

		/// <summary>Default constructor</summary>
		public RawTypeDefRow() {
		}

		/// <summary>Constructor</summary>
		public RawTypeDefRow(uint Flags, uint Name, uint Namespace, uint Extends, uint FieldList, uint MethodList) {
			this.Flags = Flags;
			this.Name = Name;
			this.Namespace = Namespace;
			this.Extends = Extends;
			this.FieldList = FieldList;
			this.MethodList = MethodList;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Flags;
			case 1: return Name;
			case 2: return Namespace;
			case 3: return Extends;
			case 4: return FieldList;
			case 5: return MethodList;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Flags = value; break;
			case 1: Name = value; break;
			case 2: Namespace = value; break;
			case 3: Extends = value; break;
			case 4: FieldList = value; break;
			case 5: MethodList = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed FieldPtr table row
	/// </summary>
	public sealed class RawFieldPtrRow : IRawRow {
		/// <summary/>
		public uint Field;

		/// <summary>Default constructor</summary>
		public RawFieldPtrRow() {
		}

		/// <summary>Constructor</summary>
		public RawFieldPtrRow(uint Field) {
			this.Field = Field;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Field;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Field = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed Field table row
	/// </summary>
	public sealed class RawFieldRow : IRawRow {
		/// <summary/>
		public ushort Flags;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Signature;

		/// <summary>Default constructor</summary>
		public RawFieldRow() {
		}

		/// <summary>Constructor</summary>
		public RawFieldRow(ushort Flags, uint Name, uint Signature) {
			this.Flags = Flags;
			this.Name = Name;
			this.Signature = Signature;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Flags;
			case 1: return Name;
			case 2: return Signature;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Flags = (ushort)value; break;
			case 1: Name = value; break;
			case 2: Signature = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodPtr table row
	/// </summary>
	public sealed class RawMethodPtrRow : IRawRow {
		/// <summary/>
		public uint Method;

		/// <summary>Default constructor</summary>
		public RawMethodPtrRow() {
		}

		/// <summary>Constructor</summary>
		public RawMethodPtrRow(uint Method) {
			this.Method = Method;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Method;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Method = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed Method table row
	/// </summary>
	public sealed class RawMethodRow : IRawRow {
		/// <summary/>
		public uint RVA;
		/// <summary/>
		public ushort ImplFlags;
		/// <summary/>
		public ushort Flags;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Signature;
		/// <summary/>
		public uint ParamList;

		/// <summary>Default constructor</summary>
		public RawMethodRow() {
		}

		/// <summary>Constructor</summary>
		public RawMethodRow(uint RVA, ushort ImplFlags, ushort Flags, uint Name, uint Signature, uint ParamList) {
			this.RVA = RVA;
			this.ImplFlags = ImplFlags;
			this.Flags = Flags;
			this.Name = Name;
			this.Signature = Signature;
			this.ParamList = ParamList;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return RVA;
			case 1: return ImplFlags;
			case 2: return Flags;
			case 3: return Name;
			case 4: return Signature;
			case 5: return ParamList;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: RVA = value; break;
			case 1: ImplFlags = (ushort)value; break;
			case 2: Flags = (ushort)value; break;
			case 3: Name = value; break;
			case 4: Signature = value; break;
			case 5: ParamList = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ParamPtr table row
	/// </summary>
	public sealed class RawParamPtrRow : IRawRow {
		/// <summary/>
		public uint Param;

		/// <summary>Default constructor</summary>
		public RawParamPtrRow() {
		}

		/// <summary>Constructor</summary>
		public RawParamPtrRow(uint Param) {
			this.Param = Param;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Param;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Param = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed Param table row
	/// </summary>
	public sealed class RawParamRow : IRawRow {
		/// <summary/>
		public ushort Flags;
		/// <summary/>
		public ushort Sequence;
		/// <summary/>
		public uint Name;

		/// <summary>Default constructor</summary>
		public RawParamRow() {
		}

		/// <summary>Constructor</summary>
		public RawParamRow(ushort Flags, ushort Sequence, uint Name) {
			this.Flags = Flags;
			this.Sequence = Sequence;
			this.Name = Name;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Flags;
			case 1: return Sequence;
			case 2: return Name;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Flags = (ushort)value; break;
			case 1: Sequence = (ushort)value; break;
			case 2: Name = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed InterfaceImpl table row
	/// </summary>
	public sealed class RawInterfaceImplRow : IRawRow {
		/// <summary/>
		public uint Class;
		/// <summary/>
		public uint Interface;

		/// <summary>Default constructor</summary>
		public RawInterfaceImplRow() {
		}

		/// <summary>Constructor</summary>
		public RawInterfaceImplRow(uint Class, uint Interface) {
			this.Class = Class;
			this.Interface = Interface;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Class;
			case 1: return Interface;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Class = value; break;
			case 1: Interface = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed MemberRef table row
	/// </summary>
	public sealed class RawMemberRefRow : IRawRow {
		/// <summary/>
		public uint Class;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Signature;

		/// <summary>Default constructor</summary>
		public RawMemberRefRow() {
		}

		/// <summary>Constructor</summary>
		public RawMemberRefRow(uint Class, uint Name, uint Signature) {
			this.Class = Class;
			this.Name = Name;
			this.Signature = Signature;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Class;
			case 1: return Name;
			case 2: return Signature;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Class = value; break;
			case 1: Name = value; break;
			case 2: Signature = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed Constant table row
	/// </summary>
	public sealed class RawConstantRow : IRawRow {
		/// <summary/>
		public byte Type;
		/// <summary/>
		public byte Padding;
		/// <summary/>
		public uint Parent;
		/// <summary/>
		public uint Value;

		/// <summary>Default constructor</summary>
		public RawConstantRow() {
		}

		/// <summary>Constructor</summary>
		public RawConstantRow(byte Type, byte Padding, uint Parent, uint Value) {
			this.Type = Type;
			this.Padding = Padding;
			this.Parent = Parent;
			this.Value = Value;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Type;
			case 1: return Padding;
			case 2: return Parent;
			case 3: return Value;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Type = (byte)value; break;
			case 1: Padding = (byte)value; break;
			case 2: Parent = value; break;
			case 3: Value = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed CustomAttribute table row
	/// </summary>
	public sealed class RawCustomAttributeRow : IRawRow {
		/// <summary/>
		public uint Parent;
		/// <summary/>
		public uint Type;
		/// <summary/>
		public uint Value;

		/// <summary>Default constructor</summary>
		public RawCustomAttributeRow() {
		}

		/// <summary>Constructor</summary>
		public RawCustomAttributeRow(uint Parent, uint Type, uint Value) {
			this.Parent = Parent;
			this.Type = Type;
			this.Value = Value;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Parent;
			case 1: return Type;
			case 2: return Value;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Parent = value; break;
			case 1: Type = value; break;
			case 2: Value = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed FieldMarshal table row
	/// </summary>
	public sealed class RawFieldMarshalRow : IRawRow {
		/// <summary/>
		public uint Parent;
		/// <summary/>
		public uint NativeType;

		/// <summary>Default constructor</summary>
		public RawFieldMarshalRow() {
		}

		/// <summary>Constructor</summary>
		public RawFieldMarshalRow(uint Parent, uint NativeType) {
			this.Parent = Parent;
			this.NativeType = NativeType;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Parent;
			case 1: return NativeType;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Parent = value; break;
			case 1: NativeType = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed DeclSecurity table row
	/// </summary>
	public sealed class RawDeclSecurityRow : IRawRow {
		/// <summary/>
		public short Action;
		/// <summary/>
		public uint Parent;
		/// <summary/>
		public uint PermissionSet;

		/// <summary>Default constructor</summary>
		public RawDeclSecurityRow() {
		}

		/// <summary>Constructor</summary>
		public RawDeclSecurityRow(short Action, uint Parent, uint PermissionSet) {
			this.Action = Action;
			this.Parent = Parent;
			this.PermissionSet = PermissionSet;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return (uint)(int)Action;
			case 1: return Parent;
			case 2: return PermissionSet;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Action = (short)value; break;
			case 1: Parent = value; break;
			case 2: PermissionSet = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ClassLayout table row
	/// </summary>
	public sealed class RawClassLayoutRow : IRawRow {
		/// <summary/>
		public ushort PackingSize;
		/// <summary/>
		public uint ClassSize;
		/// <summary/>
		public uint Parent;

		/// <summary>Default constructor</summary>
		public RawClassLayoutRow() {
		}

		/// <summary>Constructor</summary>
		public RawClassLayoutRow(ushort PackingSize, uint ClassSize, uint Parent) {
			this.PackingSize = PackingSize;
			this.ClassSize = ClassSize;
			this.Parent = Parent;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return PackingSize;
			case 1: return ClassSize;
			case 2: return Parent;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: PackingSize = (ushort)value; break;
			case 1: ClassSize = value; break;
			case 2: Parent = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed FieldLayout table row
	/// </summary>
	public sealed class RawFieldLayoutRow : IRawRow {
		/// <summary/>
		public uint OffSet;
		/// <summary/>
		public uint Field;

		/// <summary>Default constructor</summary>
		public RawFieldLayoutRow() {
		}

		/// <summary>Constructor</summary>
		public RawFieldLayoutRow(uint OffSet, uint Field) {
			this.OffSet = OffSet;
			this.Field = Field;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return OffSet;
			case 1: return Field;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: OffSet = value; break;
			case 1: Field = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed StandAloneSig table row
	/// </summary>
	public sealed class RawStandAloneSigRow : IRawRow {
		/// <summary/>
		public uint Signature;

		/// <summary>Default constructor</summary>
		public RawStandAloneSigRow() {
		}

		/// <summary>Constructor</summary>
		public RawStandAloneSigRow(uint Signature) {
			this.Signature = Signature;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Signature;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Signature = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed EventMap table row
	/// </summary>
	public sealed class RawEventMapRow : IRawRow {
		/// <summary/>
		public uint Parent;
		/// <summary/>
		public uint EventList;

		/// <summary>Default constructor</summary>
		public RawEventMapRow() {
		}

		/// <summary>Constructor</summary>
		public RawEventMapRow(uint Parent, uint EventList) {
			this.Parent = Parent;
			this.EventList = EventList;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Parent;
			case 1: return EventList;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Parent = value; break;
			case 1: EventList = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed EventPtr table row
	/// </summary>
	public sealed class RawEventPtrRow : IRawRow {
		/// <summary/>
		public uint Event;

		/// <summary>Default constructor</summary>
		public RawEventPtrRow() {
		}

		/// <summary>Constructor</summary>
		public RawEventPtrRow(uint Event) {
			this.Event = Event;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Event;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Event = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed Event table row
	/// </summary>
	public sealed class RawEventRow : IRawRow {
		/// <summary/>
		public ushort EventFlags;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint EventType;

		/// <summary>Default constructor</summary>
		public RawEventRow() {
		}

		/// <summary>Constructor</summary>
		public RawEventRow(ushort EventFlags, uint Name, uint EventType) {
			this.EventFlags = EventFlags;
			this.Name = Name;
			this.EventType = EventType;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return EventFlags;
			case 1: return Name;
			case 2: return EventType;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: EventFlags = (ushort)value; break;
			case 1: Name = value; break;
			case 2: EventType = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed PropertyMap table row
	/// </summary>
	public sealed class RawPropertyMapRow : IRawRow {
		/// <summary/>
		public uint Parent;
		/// <summary/>
		public uint PropertyList;

		/// <summary>Default constructor</summary>
		public RawPropertyMapRow() {
		}

		/// <summary>Constructor</summary>
		public RawPropertyMapRow(uint Parent, uint PropertyList) {
			this.Parent = Parent;
			this.PropertyList = PropertyList;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Parent;
			case 1: return PropertyList;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Parent = value; break;
			case 1: PropertyList = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed PropertyPtr table row
	/// </summary>
	public sealed class RawPropertyPtrRow : IRawRow {
		/// <summary/>
		public uint Property;

		/// <summary>Default constructor</summary>
		public RawPropertyPtrRow() {
		}

		/// <summary>Constructor</summary>
		public RawPropertyPtrRow(uint Property) {
			this.Property = Property;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Property;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Property = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed Property table row
	/// </summary>
	public sealed class RawPropertyRow : IRawRow {
		/// <summary/>
		public ushort PropFlags;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Type;

		/// <summary>Default constructor</summary>
		public RawPropertyRow() {
		}

		/// <summary>Constructor</summary>
		public RawPropertyRow(ushort PropFlags, uint Name, uint Type) {
			this.PropFlags = PropFlags;
			this.Name = Name;
			this.Type = Type;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return PropFlags;
			case 1: return Name;
			case 2: return Type;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: PropFlags = (ushort)value; break;
			case 1: Name = value; break;
			case 2: Type = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodSemantics table row
	/// </summary>
	public sealed class RawMethodSemanticsRow : IRawRow {
		/// <summary/>
		public ushort Semantic;
		/// <summary/>
		public uint Method;
		/// <summary/>
		public uint Association;

		/// <summary>Default constructor</summary>
		public RawMethodSemanticsRow() {
		}

		/// <summary>Constructor</summary>
		public RawMethodSemanticsRow(ushort Semantic, uint Method, uint Association) {
			this.Semantic = Semantic;
			this.Method = Method;
			this.Association = Association;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Semantic;
			case 1: return Method;
			case 2: return Association;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Semantic = (ushort)value; break;
			case 1: Method = value; break;
			case 2: Association = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodImpl table row
	/// </summary>
	public sealed class RawMethodImplRow : IRawRow {
		/// <summary/>
		public uint Class;
		/// <summary/>
		public uint MethodBody;
		/// <summary/>
		public uint MethodDeclaration;

		/// <summary>Default constructor</summary>
		public RawMethodImplRow() {
		}

		/// <summary>Constructor</summary>
		public RawMethodImplRow(uint Class, uint MethodBody, uint MethodDeclaration) {
			this.Class = Class;
			this.MethodBody = MethodBody;
			this.MethodDeclaration = MethodDeclaration;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Class;
			case 1: return MethodBody;
			case 2: return MethodDeclaration;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Class = value; break;
			case 1: MethodBody = value; break;
			case 2: MethodDeclaration = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ModuleRef table row
	/// </summary>
	public sealed class RawModuleRefRow : IRawRow {
		/// <summary/>
		public uint Name;

		/// <summary>Default constructor</summary>
		public RawModuleRefRow() {
		}

		/// <summary>Constructor</summary>
		public RawModuleRefRow(uint Name) {
			this.Name = Name;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Name;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Name = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed TypeSpec table row
	/// </summary>
	public sealed class RawTypeSpecRow : IRawRow {
		/// <summary/>
		public uint Signature;

		/// <summary>Default constructor</summary>
		public RawTypeSpecRow() {
		}

		/// <summary>Constructor</summary>
		public RawTypeSpecRow(uint Signature) {
			this.Signature = Signature;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Signature;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Signature = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ImplMap table row
	/// </summary>
	public sealed class RawImplMapRow : IRawRow {
		/// <summary/>
		public ushort MappingFlags;
		/// <summary/>
		public uint MemberForwarded;
		/// <summary/>
		public uint ImportName;
		/// <summary/>
		public uint ImportScope;

		/// <summary>Default constructor</summary>
		public RawImplMapRow() {
		}

		/// <summary>Constructor</summary>
		public RawImplMapRow(ushort MappingFlags, uint MemberForwarded, uint ImportName, uint ImportScope) {
			this.MappingFlags = MappingFlags;
			this.MemberForwarded = MemberForwarded;
			this.ImportName = ImportName;
			this.ImportScope = ImportScope;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return MappingFlags;
			case 1: return MemberForwarded;
			case 2: return ImportName;
			case 3: return ImportScope;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: MappingFlags = (ushort)value; break;
			case 1: MemberForwarded = value; break;
			case 2: ImportName = value; break;
			case 3: ImportScope = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed FieldRVA table row
	/// </summary>
	public sealed class RawFieldRVARow : IRawRow {
		/// <summary/>
		public uint RVA;
		/// <summary/>
		public uint Field;

		/// <summary>Default constructor</summary>
		public RawFieldRVARow() {
		}

		/// <summary>Constructor</summary>
		public RawFieldRVARow(uint RVA, uint Field) {
			this.RVA = RVA;
			this.Field = Field;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return RVA;
			case 1: return Field;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: RVA = value; break;
			case 1: Field = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ENCLog table row
	/// </summary>
	public sealed class RawENCLogRow : IRawRow {
		/// <summary/>
		public uint Token;
		/// <summary/>
		public uint FuncCode;

		/// <summary>Default constructor</summary>
		public RawENCLogRow() {
		}

		/// <summary>Constructor</summary>
		public RawENCLogRow(uint Token, uint FuncCode) {
			this.Token = Token;
			this.FuncCode = FuncCode;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Token;
			case 1: return FuncCode;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Token = value; break;
			case 1: FuncCode = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ENCMap table row
	/// </summary>
	public sealed class RawENCMapRow : IRawRow {
		/// <summary/>
		public uint Token;

		/// <summary>Default constructor</summary>
		public RawENCMapRow() {
		}

		/// <summary>Constructor</summary>
		public RawENCMapRow(uint Token) {
			this.Token = Token;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Token;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Token = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed Assembly table row
	/// </summary>
	public sealed class RawAssemblyRow : IRawRow {
		/// <summary/>
		public uint HashAlgId;
		/// <summary/>
		public ushort MajorVersion;
		/// <summary/>
		public ushort MinorVersion;
		/// <summary/>
		public ushort BuildNumber;
		/// <summary/>
		public ushort RevisionNumber;
		/// <summary/>
		public uint Flags;
		/// <summary/>
		public uint PublicKey;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Locale;

		/// <summary>Default constructor</summary>
		public RawAssemblyRow() {
		}

		/// <summary>Constructor</summary>
		public RawAssemblyRow(uint HashAlgId, ushort MajorVersion, ushort MinorVersion, ushort BuildNumber, ushort RevisionNumber, uint Flags, uint PublicKey, uint Name, uint Locale) {
			this.HashAlgId = HashAlgId;
			this.MajorVersion = MajorVersion;
			this.MinorVersion = MinorVersion;
			this.BuildNumber = BuildNumber;
			this.RevisionNumber = RevisionNumber;
			this.Flags = Flags;
			this.PublicKey = PublicKey;
			this.Name = Name;
			this.Locale = Locale;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return HashAlgId;
			case 1: return MajorVersion;
			case 2: return MinorVersion;
			case 3: return BuildNumber;
			case 4: return RevisionNumber;
			case 5: return Flags;
			case 6: return PublicKey;
			case 7: return Name;
			case 8: return Locale;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: HashAlgId = value; break;
			case 1: MajorVersion = (ushort)value; break;
			case 2: MinorVersion = (ushort)value; break;
			case 3: BuildNumber = (ushort)value; break;
			case 4: RevisionNumber = (ushort)value; break;
			case 5: Flags = value; break;
			case 6: PublicKey = value; break;
			case 7: Name = value; break;
			case 8: Locale = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyProcessor table row
	/// </summary>
	public sealed class RawAssemblyProcessorRow : IRawRow {
		/// <summary/>
		public uint Processor;

		/// <summary>Default constructor</summary>
		public RawAssemblyProcessorRow() {
		}

		/// <summary>Constructor</summary>
		public RawAssemblyProcessorRow(uint Processor) {
			this.Processor = Processor;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Processor;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Processor = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyOS table row
	/// </summary>
	public sealed class RawAssemblyOSRow : IRawRow {
		/// <summary/>
		public uint OSPlatformId;
		/// <summary/>
		public uint OSMajorVersion;
		/// <summary/>
		public uint OSMinorVersion;

		/// <summary>Default constructor</summary>
		public RawAssemblyOSRow() {
		}

		/// <summary>Constructor</summary>
		public RawAssemblyOSRow(uint OSPlatformId, uint OSMajorVersion, uint OSMinorVersion) {
			this.OSPlatformId = OSPlatformId;
			this.OSMajorVersion = OSMajorVersion;
			this.OSMinorVersion = OSMinorVersion;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return OSPlatformId;
			case 1: return OSMajorVersion;
			case 2: return OSMinorVersion;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: OSPlatformId = value; break;
			case 1: OSMajorVersion = value; break;
			case 2: OSMinorVersion = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyRef table row
	/// </summary>
	public sealed class RawAssemblyRefRow : IRawRow {
		/// <summary/>
		public ushort MajorVersion;
		/// <summary/>
		public ushort MinorVersion;
		/// <summary/>
		public ushort BuildNumber;
		/// <summary/>
		public ushort RevisionNumber;
		/// <summary/>
		public uint Flags;
		/// <summary/>
		public uint PublicKeyOrToken;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Locale;
		/// <summary/>
		public uint HashValue;

		/// <summary>Default constructor</summary>
		public RawAssemblyRefRow() {
		}

		/// <summary>Constructor</summary>
		public RawAssemblyRefRow(ushort MajorVersion, ushort MinorVersion, ushort BuildNumber, ushort RevisionNumber, uint Flags, uint PublicKeyOrToken, uint Name, uint Locale, uint HashValue) {
			this.MajorVersion = MajorVersion;
			this.MinorVersion = MinorVersion;
			this.BuildNumber = BuildNumber;
			this.RevisionNumber = RevisionNumber;
			this.Flags = Flags;
			this.PublicKeyOrToken = PublicKeyOrToken;
			this.Name = Name;
			this.Locale = Locale;
			this.HashValue = HashValue;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return MajorVersion;
			case 1: return MinorVersion;
			case 2: return BuildNumber;
			case 3: return RevisionNumber;
			case 4: return Flags;
			case 5: return PublicKeyOrToken;
			case 6: return Name;
			case 7: return Locale;
			case 8: return HashValue;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: MajorVersion = (ushort)value; break;
			case 1: MinorVersion = (ushort)value; break;
			case 2: BuildNumber = (ushort)value; break;
			case 3: RevisionNumber = (ushort)value; break;
			case 4: Flags = value; break;
			case 5: PublicKeyOrToken = value; break;
			case 6: Name = value; break;
			case 7: Locale = value; break;
			case 8: HashValue = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyRefProcessor table row
	/// </summary>
	public sealed class RawAssemblyRefProcessorRow : IRawRow {
		/// <summary/>
		public uint Processor;
		/// <summary/>
		public uint AssemblyRef;

		/// <summary>Default constructor</summary>
		public RawAssemblyRefProcessorRow() {
		}

		/// <summary>Constructor</summary>
		public RawAssemblyRefProcessorRow(uint Processor, uint AssemblyRef) {
			this.Processor = Processor;
			this.AssemblyRef = AssemblyRef;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Processor;
			case 1: return AssemblyRef;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Processor = value; break;
			case 1: AssemblyRef = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyRefOS table row
	/// </summary>
	public sealed class RawAssemblyRefOSRow : IRawRow {
		/// <summary/>
		public uint OSPlatformId;
		/// <summary/>
		public uint OSMajorVersion;
		/// <summary/>
		public uint OSMinorVersion;
		/// <summary/>
		public uint AssemblyRef;

		/// <summary>Default constructor</summary>
		public RawAssemblyRefOSRow() {
		}

		/// <summary>Constructor</summary>
		public RawAssemblyRefOSRow(uint OSPlatformId, uint OSMajorVersion, uint OSMinorVersion, uint AssemblyRef) {
			this.OSPlatformId = OSPlatformId;
			this.OSMajorVersion = OSMajorVersion;
			this.OSMinorVersion = OSMinorVersion;
			this.AssemblyRef = AssemblyRef;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return OSPlatformId;
			case 1: return OSMajorVersion;
			case 2: return OSMinorVersion;
			case 3: return AssemblyRef;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: OSPlatformId = value; break;
			case 1: OSMajorVersion = value; break;
			case 2: OSMinorVersion = value; break;
			case 3: AssemblyRef = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed File table row
	/// </summary>
	public sealed class RawFileRow : IRawRow {
		/// <summary/>
		public uint Flags;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint HashValue;

		/// <summary>Default constructor</summary>
		public RawFileRow() {
		}

		/// <summary>Constructor</summary>
		public RawFileRow(uint Flags, uint Name, uint HashValue) {
			this.Flags = Flags;
			this.Name = Name;
			this.HashValue = HashValue;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Flags;
			case 1: return Name;
			case 2: return HashValue;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Flags = value; break;
			case 1: Name = value; break;
			case 2: HashValue = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ExportedType table row
	/// </summary>
	public sealed class RawExportedTypeRow : IRawRow {
		/// <summary/>
		public uint Flags;
		/// <summary/>
		public uint TypeDefId;
		/// <summary/>
		public uint TypeName;
		/// <summary/>
		public uint TypeNamespace;
		/// <summary/>
		public uint Implementation;

		/// <summary>Default constructor</summary>
		public RawExportedTypeRow() {
		}

		/// <summary>Constructor</summary>
		public RawExportedTypeRow(uint Flags, uint TypeDefId, uint TypeName, uint TypeNamespace, uint Implementation) {
			this.Flags = Flags;
			this.TypeDefId = TypeDefId;
			this.TypeName = TypeName;
			this.TypeNamespace = TypeNamespace;
			this.Implementation = Implementation;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Flags;
			case 1: return TypeDefId;
			case 2: return TypeName;
			case 3: return TypeNamespace;
			case 4: return Implementation;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Flags = value; break;
			case 1: TypeDefId = value; break;
			case 2: TypeName = value; break;
			case 3: TypeNamespace = value; break;
			case 4: Implementation = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ManifestResource table row
	/// </summary>
	public sealed class RawManifestResourceRow : IRawRow {
		/// <summary/>
		public uint Offset;
		/// <summary/>
		public uint Flags;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Implementation;

		/// <summary>Default constructor</summary>
		public RawManifestResourceRow() {
		}

		/// <summary>Constructor</summary>
		public RawManifestResourceRow(uint Offset, uint Flags, uint Name, uint Implementation) {
			this.Offset = Offset;
			this.Flags = Flags;
			this.Name = Name;
			this.Implementation = Implementation;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Offset;
			case 1: return Flags;
			case 2: return Name;
			case 3: return Implementation;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Offset = value; break;
			case 1: Flags = value; break;
			case 2: Name = value; break;
			case 3: Implementation = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed NestedClass table row
	/// </summary>
	public sealed class RawNestedClassRow : IRawRow {
		/// <summary/>
		public uint NestedClass;
		/// <summary/>
		public uint EnclosingClass;

		/// <summary>Default constructor</summary>
		public RawNestedClassRow() {
		}

		/// <summary>Constructor</summary>
		public RawNestedClassRow(uint NestedClass, uint EnclosingClass) {
			this.NestedClass = NestedClass;
			this.EnclosingClass = EnclosingClass;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return NestedClass;
			case 1: return EnclosingClass;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: NestedClass = value; break;
			case 1: EnclosingClass = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed GenericParam table row
	/// </summary>
	public sealed class RawGenericParamRow : IRawRow {
		/// <summary/>
		public ushort Number;
		/// <summary/>
		public ushort Flags;
		/// <summary/>
		public uint Owner;
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Kind;

		/// <summary>Default constructor</summary>
		public RawGenericParamRow() {
		}

		/// <summary>Constructor</summary>
		public RawGenericParamRow(ushort Number, ushort Flags, uint Owner, uint Name, uint Kind) {
			this.Number = Number;
			this.Flags = Flags;
			this.Owner = Owner;
			this.Name = Name;
			this.Kind = Kind;
		}

		/// <summary>Constructor</summary>
		public RawGenericParamRow(ushort Number, ushort Flags, uint Owner, uint Name) {
			this.Number = Number;
			this.Flags = Flags;
			this.Owner = Owner;
			this.Name = Name;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Number;
			case 1: return Flags;
			case 2: return Owner;
			case 3: return Name;
			case 4: return Kind;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Number = (ushort)value; break;
			case 1: Flags = (ushort)value; break;
			case 2: Owner = value; break;
			case 3: Name = value; break;
			case 4: Kind = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodSpec table row
	/// </summary>
	public sealed class RawMethodSpecRow : IRawRow {
		/// <summary/>
		public uint Method;
		/// <summary/>
		public uint Instantiation;

		/// <summary>Default constructor</summary>
		public RawMethodSpecRow() {
		}

		/// <summary>Constructor</summary>
		public RawMethodSpecRow(uint Method, uint Instantiation) {
			this.Method = Method;
			this.Instantiation = Instantiation;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Method;
			case 1: return Instantiation;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Method = value; break;
			case 1: Instantiation = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed GenericParamConstraint table row
	/// </summary>
	public sealed class RawGenericParamConstraintRow : IRawRow {
		/// <summary/>
		public uint Owner;
		/// <summary/>
		public uint Constraint;

		/// <summary>Default constructor</summary>
		public RawGenericParamConstraintRow() {
		}

		/// <summary>Constructor</summary>
		public RawGenericParamConstraintRow(uint Owner, uint Constraint) {
			this.Owner = Owner;
			this.Constraint = Constraint;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Owner;
			case 1: return Constraint;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Owner = value; break;
			case 1: Constraint = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed Document table row
	/// </summary>
	public sealed class RawDocumentRow : IRawRow {
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint HashAlgorithm;
		/// <summary/>
		public uint Hash;
		/// <summary/>
		public uint Language;

		/// <summary>Default constructor</summary>
		public RawDocumentRow() {
		}

		/// <summary>Constructor</summary>
		public RawDocumentRow(uint Name, uint HashAlgorithm, uint Hash, uint Language) {
			this.Name = Name;
			this.HashAlgorithm = HashAlgorithm;
			this.Hash = Hash;
			this.Language = Language;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Name;
			case 1: return HashAlgorithm;
			case 2: return Hash;
			case 3: return Language;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Name = value; break;
			case 1: HashAlgorithm = value; break;
			case 2: Hash = value; break;
			case 3: Language = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodDebugInformation table row
	/// </summary>
	public sealed class RawMethodDebugInformationRow : IRawRow {
		/// <summary/>
		public uint Document;
		/// <summary/>
		public uint SequencePoints;

		/// <summary>Default constructor</summary>
		public RawMethodDebugInformationRow() {
		}

		/// <summary>Constructor</summary>
		public RawMethodDebugInformationRow(uint Document, uint SequencePoints) {
			this.Document = Document;
			this.SequencePoints = SequencePoints;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Document;
			case 1: return SequencePoints;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Document = value; break;
			case 1: SequencePoints = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed LocalScope table row
	/// </summary>
	public sealed class RawLocalScopeRow : IRawRow {
		/// <summary/>
		public uint Method;
		/// <summary/>
		public uint ImportScope;
		/// <summary/>
		public uint VariableList;
		/// <summary/>
		public uint ConstantList;
		/// <summary/>
		public uint StartOffset;
		/// <summary/>
		public uint Length;

		/// <summary>Default constructor</summary>
		public RawLocalScopeRow() {
		}

		/// <summary>Constructor</summary>
		public RawLocalScopeRow(uint Method, uint ImportScope, uint VariableList, uint ConstantList, uint StartOffset, uint Length) {
			this.Method = Method;
			this.ImportScope = ImportScope;
			this.VariableList = VariableList;
			this.ConstantList = ConstantList;
			this.StartOffset = StartOffset;
			this.Length = Length;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Method;
			case 1: return ImportScope;
			case 2: return VariableList;
			case 3: return ConstantList;
			case 4: return StartOffset;
			case 5: return Length;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Method = value; break;
			case 1: ImportScope = value; break;
			case 2: VariableList = value; break;
			case 3: ConstantList = value; break;
			case 4: StartOffset = value; break;
			case 5: Length = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed LocalVariable table row
	/// </summary>
	public sealed class RawLocalVariableRow : IRawRow {
		/// <summary/>
		public ushort Attributes;
		/// <summary/>
		public ushort Index;
		/// <summary/>
		public uint Name;

		/// <summary>Default constructor</summary>
		public RawLocalVariableRow() {
		}

		/// <summary>Constructor</summary>
		public RawLocalVariableRow(ushort Attributes, ushort Index, uint Name) {
			this.Attributes = Attributes;
			this.Index = Index;
			this.Name = Name;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Attributes;
			case 1: return Index;
			case 2: return Name;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Attributes = (ushort)value; break;
			case 1: Index = (ushort)value; break;
			case 2: Name = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed LocalConstant table row
	/// </summary>
	public sealed class RawLocalConstantRow : IRawRow {
		/// <summary/>
		public uint Name;
		/// <summary/>
		public uint Signature;

		/// <summary>Default constructor</summary>
		public RawLocalConstantRow() {
		}

		/// <summary>Constructor</summary>
		public RawLocalConstantRow(uint Name, uint Signature) {
			this.Name = Name;
			this.Signature = Signature;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Name;
			case 1: return Signature;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Name = value; break;
			case 1: Signature = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed ImportScope table row
	/// </summary>
	public sealed class RawImportScopeRow : IRawRow {
		/// <summary/>
		public uint Parent;
		/// <summary/>
		public uint Imports;

		/// <summary>Default constructor</summary>
		public RawImportScopeRow() {
		}

		/// <summary>Constructor</summary>
		public RawImportScopeRow(uint Parent, uint Imports) {
			this.Parent = Parent;
			this.Imports = Imports;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Parent;
			case 1: return Imports;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Parent = value; break;
			case 1: Imports = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed StateMachineMethod table row
	/// </summary>
	public sealed class RawStateMachineMethodRow : IRawRow {
		/// <summary/>
		public uint MoveNextMethod;
		/// <summary/>
		public uint KickoffMethod;

		/// <summary>Default constructor</summary>
		public RawStateMachineMethodRow() {
		}

		/// <summary>Constructor</summary>
		public RawStateMachineMethodRow(uint MoveNextMethod, uint KickoffMethod) {
			this.MoveNextMethod = MoveNextMethod;
			this.KickoffMethod = KickoffMethod;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return MoveNextMethod;
			case 1: return KickoffMethod;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: MoveNextMethod = value; break;
			case 1: KickoffMethod = value; break;
			default: break;
			}
		}
	}

	/// <summary>
	/// Raw contents of an uncompressed CustomDebugInformation table row
	/// </summary>
	public sealed class RawCustomDebugInformationRow : IRawRow {
		/// <summary/>
		public uint Parent;
		/// <summary/>
		public uint Kind;
		/// <summary/>
		public uint Value;

		/// <summary>Default constructor</summary>
		public RawCustomDebugInformationRow() {
		}

		/// <summary>Constructor</summary>
		public RawCustomDebugInformationRow(uint Parent, uint Kind, uint Value) {
			this.Parent = Parent;
			this.Kind = Kind;
			this.Value = Value;
		}

		/// <inheritdoc/>
		public uint Read(int index) {
			switch (index) {
			case 0: return Parent;
			case 1: return Kind;
			case 2: return Value;
			default: return 0;
			}
		}

		/// <inheritdoc/>
		public void Write(int index, uint value) {
			switch (index) {
			case 0: Parent = value; break;
			case 1: Kind = value; break;
			case 2: Value = value; break;
			default: break;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/RidList.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using System.Diagnostics;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Stores a list of rids
	/// </summary>
	[DebuggerDisplay("Length = {Length}")]
	public abstract class RidList {
		/// <summary>
		/// The empty <see cref="RidList"/>
		/// </summary>
		public static readonly RidList Empty = new ContiguousRidList(0, 0);

		/// <summary>
		/// Gets the number of rids it will iterate over (UInt32)
		/// </summary>
		public abstract uint Length { get; }

		/// <summary>
		/// Gets the number of rids it will iterate over (Int32)
		/// </summary>
		public abstract int Count { get; }

		/// <summary>
		/// Gets the <paramref name="index"/>'th rid
		/// </summary>
		/// <param name="index">Index. Must be &lt; <see cref="Length"/></param>
		/// <returns>A rid or 0 if <paramref name="index"/> is invalid</returns>
		public abstract uint this[uint index] { get; }

		/// <summary>
		/// Gets the <paramref name="index"/>'th rid
		/// </summary>
		/// <param name="index">Index. Must be &lt; <see cref="Length"/></param>
		/// <returns>A rid or 0 if <paramref name="index"/> is invalid</returns>
		public abstract uint this[int index] { get; }
	}

	/// <summary>
	/// A <see cref="RidList"/> where the rids are contiguous
	/// </summary>
	sealed class ContiguousRidList : RidList {
		readonly uint startRid;
		readonly uint length;

		/// <summary>
		/// Gets the start rid
		/// </summary>
		public uint StartRID {
			get { return startRid; }
		}

		/// <inheritdoc/>
		public override uint Length {
			get { return length; }
		}

		/// <inheritdoc/>
		public override int Count {
			get { return (int)length; }
		}

		/// <inheritdoc/>
		public override uint this[uint index] {
			get {
				if (index >= length)
					return 0;
				return startRid + index;
			}
		}

		/// <inheritdoc/>
		public override uint this[int index] {
			get { return this[(uint)index]; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="startRid">First rid to return</param>
		/// <param name="length">Number of rids to return</param>
		public ContiguousRidList(uint startRid, uint length) {
			this.startRid = startRid;
			this.length = length;
		}
	}

	/// <summary>
	/// A <see cref="RidList"/> where the returned rids aren't necessarily contiguous.
	/// This should be used if eg. the pointer tables are present.
	/// </summary>
	sealed class RandomRidList : RidList {
		readonly IList<uint> indexToRid;

		/// <inheritdoc/>
		public override uint Length {
			get { return (uint)indexToRid.Count; }
		}

		/// <inheritdoc/>
		public override int Count {
			get { return indexToRid.Count; }
		}

		/// <inheritdoc/>
		public override uint this[uint index] {
			get {
				if (index >= (uint)indexToRid.Count)
					return 0;
				return indexToRid[(int)index];
			}
		}

		/// <inheritdoc/>
		public override uint this[int index] {
			get { return this[(uint)index]; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public RandomRidList() {
			this.indexToRid = new List<uint>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Approximate number of rids that will be returned</param>
		public RandomRidList(int capacity) {
			this.indexToRid = new List<uint>(capacity);
		}

		/// <summary>
		/// Add a new rid that should be returned
		/// </summary>
		/// <param name="rid">The rid</param>
		public void Add(uint rid) {
			indexToRid.Add(rid);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/StorageFlags.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Storage flags found in the MD header
	/// </summary>
	[Flags]
	public enum StorageFlags : byte {
		/// <summary>
		/// Normal flags
		/// </summary>
		Normal = 0,

		/// <summary>
		/// More data after the header but before the streams.
		/// </summary>
		/// <remarks>The CLR will fail to load the file if this flag (or any other bits) is set.</remarks>
		ExtraData = 1,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/StreamHeader.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.Text;
using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// A metadata stream header
	/// </summary>
	[DebuggerDisplay("O:{offset} L:{streamSize} {name}")]
	public sealed class StreamHeader : FileSection {
		readonly uint offset;
		readonly uint streamSize;
		readonly string name;

		/// <summary>
		/// The offset of the stream relative to the start of the MetaData header
		/// </summary>
		public uint Offset {
			get { return offset; }
		}

		/// <summary>
		/// The size of the stream
		/// </summary>
		public uint StreamSize {
			get { return streamSize; }
		}

		/// <summary>
		/// The name of the stream
		/// </summary>
		public string Name {
			get { return name; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public StreamHeader(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			this.offset = reader.ReadUInt32();
			this.streamSize = reader.ReadUInt32();
			this.name = ReadString(reader, 32, verify);
			SetEndoffset(reader);
			if (verify && offset + size < offset)
				throw new BadImageFormatException("Invalid stream header");
		}

		static string ReadString(IImageStream reader, int maxLen, bool verify) {
			var origPos = reader.Position;
			var sb = new StringBuilder(maxLen);
			int i;
			for (i = 0; i < maxLen; i++) {
				byte b = reader.ReadByte();
				if (b == 0)
					break;
				sb.Append((char)b);
			}
			if (verify && i == maxLen)
				throw new BadImageFormatException("Invalid stream name string");
			if (i != maxLen)
				reader.Position = origPos + ((i + 1 + 3) & ~3);
			return sb.ToString();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/StringsStream.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the #Strings stream
	/// </summary>
	public sealed class StringsStream : HeapStream {
		/// <inheritdoc/>
		public StringsStream() {
		}

		/// <inheritdoc/>
		public StringsStream(IImageStream imageStream, StreamHeader streamHeader)
			: base(imageStream, streamHeader) {
		}

		/// <summary>
		/// Reads a <see cref="UTF8String"/>
		/// </summary>
		/// <param name="offset">Offset of string</param>
		/// <returns>A <see cref="UTF8String"/> instance or <c>null</c> if invalid offset</returns>
		public UTF8String Read(uint offset) {
			if (offset >= ImageStreamLength)
				return null;
			byte[] data;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(offset);
			data = reader.ReadBytesUntilByte(0);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			if (data == null)
				return null;
			return new UTF8String(data);
		}

		/// <summary>
		/// Reads a <see cref="UTF8String"/>. The empty string is returned if <paramref name="offset"/>
		/// is invalid.
		/// </summary>
		/// <param name="offset">Offset of string</param>
		/// <returns>A <see cref="UTF8String"/> instance</returns>
		public UTF8String ReadNoNull(uint offset) {
			return Read(offset) ?? UTF8String.Empty;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/Table.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.MD {
	/// <summary>
	/// The metadata tables
	/// </summary>
	public enum Table : byte {
		/// <summary>Module table (00h)</summary>
		Module,
		/// <summary>TypeRef table (01h)</summary>
		TypeRef,
		/// <summary>TypeDef table (02h)</summary>
		TypeDef,
		/// <summary>FieldPtr table (03h)</summary>
		FieldPtr,
		/// <summary>Field table (04h)</summary>
		Field,
		/// <summary>MethodPtr table (05h)</summary>
		MethodPtr,
		/// <summary>Method table (06h)</summary>
		Method,
		/// <summary>ParamPtr table (07h)</summary>
		ParamPtr,
		/// <summary>Param table (08h)</summary>
		Param,
		/// <summary>InterfaceImpl table (09h)</summary>
		InterfaceImpl,
		/// <summary>MemberRef table (0Ah)</summary>
		MemberRef,
		/// <summary>Constant table (0Bh)</summary>
		Constant,
		/// <summary>CustomAttribute table (0Ch)</summary>
		CustomAttribute,
		/// <summary>FieldMarshal table (0Dh)</summary>
		FieldMarshal,
		/// <summary>DeclSecurity table (0Eh)</summary>
		DeclSecurity,
		/// <summary>ClassLayout table (0Fh)</summary>
		ClassLayout,
		/// <summary>FieldLayout table (10h)</summary>
		FieldLayout,
		/// <summary>StandAloneSig table (11h)</summary>
		StandAloneSig,
		/// <summary>EventMap table (12h)</summary>
		EventMap,
		/// <summary>EventPtr table (13h)</summary>
		EventPtr,
		/// <summary>Event table (14h)</summary>
		Event,
		/// <summary>PropertyMap table (15h)</summary>
		PropertyMap,
		/// <summary>PropertyPtr table (16h)</summary>
		PropertyPtr,
		/// <summary>Property table (17h)</summary>
		Property,
		/// <summary>MethodSemantics table (18h)</summary>
		MethodSemantics,
		/// <summary>MethodImpl table (19h)</summary>
		MethodImpl,
		/// <summary>ModuleRef table (1Ah)</summary>
		ModuleRef,
		/// <summary>TypeSpec table (1Bh)</summary>
		TypeSpec,
		/// <summary>ImplMap table (1Ch)</summary>
		ImplMap,
		/// <summary>FieldRVA table (1Dh)</summary>
		FieldRVA,
		/// <summary>ENCLog table (1Eh)</summary>
		ENCLog,
		/// <summary>ENCMap table (1Fh)</summary>
		ENCMap,
		/// <summary>Assembly table (20h)</summary>
		Assembly,
		/// <summary>AssemblyProcessor table (21h)</summary>
		AssemblyProcessor,
		/// <summary>AssemblyOS table (22h)</summary>
		AssemblyOS,
		/// <summary>AssemblyRef table (23h)</summary>
		AssemblyRef,
		/// <summary>AssemblyRefProcessor table (24h)</summary>
		AssemblyRefProcessor,
		/// <summary>AssemblyRefOS table (25h)</summary>
		AssemblyRefOS,
		/// <summary>File table (26h)</summary>
		File,
		/// <summary>ExportedType table (27h)</summary>
		ExportedType,
		/// <summary>ManifestResource table (28h)</summary>
		ManifestResource,
		/// <summary>NestedClass table (29h)</summary>
		NestedClass,
		/// <summary>GenericParam table (2Ah)</summary>
		GenericParam,
		/// <summary>MethodSpec table (2Bh)</summary>
		MethodSpec,
		/// <summary>GenericParamConstraint table (2Ch)</summary>
		GenericParamConstraint,

		/// <summary>(Portable PDB) Document table (30h)</summary>
		Document = 0x30,
		/// <summary>(Portable PDB) MethodDebugInformation table (31h)</summary>
		MethodDebugInformation,
		/// <summary>(Portable PDB) LocalScope table (32h)</summary>
		LocalScope,
		/// <summary>(Portable PDB) LocalVariable table (33h)</summary>
		LocalVariable,
		/// <summary>(Portable PDB) LocalConstant table (34h)</summary>
		LocalConstant,
		/// <summary>(Portable PDB) ImportScope table (35h)</summary>
		ImportScope,
		/// <summary>(Portable PDB) StateMachineMethod table (36h)</summary>
		StateMachineMethod,
		/// <summary>(Portable PDB) CustomDebugInformation table (37h)</summary>
		CustomDebugInformation,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/TableInfo.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using System.Diagnostics;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Info about one MD table
	/// </summary>
	[DebuggerDisplay("{rowSize} {name}")]
	public sealed class TableInfo {
		readonly Table table;
		int rowSize;
		readonly IList<ColumnInfo> columns;
		readonly string name;

		/// <summary>
		/// Returns the table type
		/// </summary>
		public Table Table {
			get { return table; }
		}

		/// <summary>
		/// Returns the total size of a row in bytes
		/// </summary>
		public int RowSize {
			get { return rowSize; }
			internal set { rowSize = value; }
		}

		/// <summary>
		/// Returns all the columns
		/// </summary>
		public IList<ColumnInfo> Columns {
			get { return columns; }
		}

		/// <summary>
		/// Returns the name of the table
		/// </summary>
		public string Name {
			get { return name; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">Table type</param>
		/// <param name="name">Table name</param>
		/// <param name="columns">All columns</param>
		public TableInfo(Table table, string name, IList<ColumnInfo> columns) {
			this.table = table;
			this.name = name;
			this.columns = columns;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">Table type</param>
		/// <param name="name">Table name</param>
		/// <param name="columns">All columns</param>
		/// <param name="rowSize">Row size</param>
		public TableInfo(Table table, string name, IList<ColumnInfo> columns, int rowSize) {
			this.table = table;
			this.name = name;
			this.columns = columns;
			this.rowSize = rowSize;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/TablesStream.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;
using dnlib.Threading;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// .NET metadata tables stream
	/// </summary>
	public sealed partial class TablesStream : DotNetStream {
		bool initialized;
		uint reserved1;
		byte majorVersion;
		byte minorVersion;
		MDStreamFlags flags;
		byte log2Rid;
		ulong validMask;
		ulong sortedMask;
		uint extraData;
		MDTable[] mdTables;

		HotTableStream hotTableStream;
		IColumnReader columnReader;
		IRowReader<RawMethodRow> methodRowReader;

#pragma warning disable 1591	// XML doc comment
		public MDTable ModuleTable { get; private set; }
		public MDTable TypeRefTable { get; private set; }
		public MDTable TypeDefTable { get; private set; }
		public MDTable FieldPtrTable { get; private set; }
		public MDTable FieldTable { get; private set; }
		public MDTable MethodPtrTable { get; private set; }
		public MDTable MethodTable { get; private set; }
		public MDTable ParamPtrTable { get; private set; }
		public MDTable ParamTable { get; private set; }
		public MDTable InterfaceImplTable { get; private set; }
		public MDTable MemberRefTable { get; private set; }
		public MDTable ConstantTable { get; private set; }
		public MDTable CustomAttributeTable { get; private set; }
		public MDTable FieldMarshalTable { get; private set; }
		public MDTable DeclSecurityTable { get; private set; }
		public MDTable ClassLayoutTable { get; private set; }
		public MDTable FieldLayoutTable { get; private set; }
		public MDTable StandAloneSigTable { get; private set; }
		public MDTable EventMapTable { get; private set; }
		public MDTable EventPtrTable { get; private set; }
		public MDTable EventTable { get; private set; }
		public MDTable PropertyMapTable { get; private set; }
		public MDTable PropertyPtrTable { get; private set; }
		public MDTable PropertyTable { get; private set; }
		public MDTable MethodSemanticsTable { get; private set; }
		public MDTable MethodImplTable { get; private set; }
		public MDTable ModuleRefTable { get; private set; }
		public MDTable TypeSpecTable { get; private set; }
		public MDTable ImplMapTable { get; private set; }
		public MDTable FieldRVATable { get; private set; }
		public MDTable ENCLogTable { get; private set; }
		public MDTable ENCMapTable { get; private set; }
		public MDTable AssemblyTable { get; private set; }
		public MDTable AssemblyProcessorTable { get; private set; }
		public MDTable AssemblyOSTable { get; private set; }
		public MDTable AssemblyRefTable { get; private set; }
		public MDTable AssemblyRefProcessorTable { get; private set; }
		public MDTable AssemblyRefOSTable { get; private set; }
		public MDTable FileTable { get; private set; }
		public MDTable ExportedTypeTable { get; private set; }
		public MDTable ManifestResourceTable { get; private set; }
		public MDTable NestedClassTable { get; private set; }
		public MDTable GenericParamTable { get; private set; }
		public MDTable MethodSpecTable { get; private set; }
		public MDTable GenericParamConstraintTable { get; private set; }
		public MDTable DocumentTable { get; private set; }
		public MDTable MethodDebugInformationTable { get; private set; }
		public MDTable LocalScopeTable { get; private set; }
		public MDTable LocalVariableTable { get; private set; }
		public MDTable LocalConstantTable { get; private set; }
		public MDTable ImportScopeTable { get; private set; }
		public MDTable StateMachineMethodTable { get; private set; }
		public MDTable CustomDebugInformationTable { get; private set; }
#pragma warning restore

#if THREAD_SAFE
		internal readonly Lock theLock = Lock.Create();
#endif

		internal HotTableStream HotTableStream {
			set { hotTableStream = value; }
		}

		/// <summary>
		/// Gets/sets the column reader
		/// </summary>
		public IColumnReader ColumnReader {
			get { return columnReader; }
			set { columnReader = value; }
		}

		/// <summary>
		/// Gets/sets the <c>Method</c> table reader
		/// </summary>
		public IRowReader<RawMethodRow> MethodRowReader {
			get { return methodRowReader; }
			set { methodRowReader = value; }
		}

		/// <summary>
		/// Gets the reserved field
		/// </summary>
		public uint Reserved1 {
			get { return reserved1; }
		}

		/// <summary>
		/// Gets the version. The major version is in the upper 8 bits, and the minor version
		/// is in the lower 8 bits.
		/// </summary>
		public ushort Version {
			get { return (ushort)((majorVersion << 8) | minorVersion); }
		}

		/// <summary>
		/// Gets <see cref="MDStreamFlags"/>
		/// </summary>
		public MDStreamFlags Flags {
			get { return flags; }
		}

		/// <summary>
		/// Gets the reserved log2 rid field
		/// </summary>
		public byte Log2Rid {
			get { return log2Rid; }
		}

		/// <summary>
		/// Gets the valid mask
		/// </summary>
		public ulong ValidMask {
			get { return validMask; }
		}

		/// <summary>
		/// Gets the sorted mask
		/// </summary>
		public ulong SortedMask {
			get { return sortedMask; }
		}

		/// <summary>
		/// Gets the extra data
		/// </summary>
		public uint ExtraData {
			get { return extraData; }
		}

		/// <summary>
		/// Gets the MD tables
		/// </summary>
		public MDTable[] MDTables {
			get { return mdTables; }
		}

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.BigStrings"/> bit
		/// </summary>
		public bool HasBigStrings {
			get { return (flags & MDStreamFlags.BigStrings) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.BigGUID"/> bit
		/// </summary>
		public bool HasBigGUID {
			get { return (flags & MDStreamFlags.BigGUID) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.BigBlob"/> bit
		/// </summary>
		public bool HasBigBlob {
			get { return (flags & MDStreamFlags.BigBlob) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.Padding"/> bit
		/// </summary>
		public bool HasPadding {
			get { return (flags & MDStreamFlags.Padding) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.DeltaOnly"/> bit
		/// </summary>
		public bool HasDeltaOnly {
			get { return (flags & MDStreamFlags.DeltaOnly) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.ExtraData"/> bit
		/// </summary>
		public bool HasExtraData {
			get { return (flags & MDStreamFlags.ExtraData) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.HasDelete"/> bit
		/// </summary>
		public bool HasDelete {
			get { return (flags & MDStreamFlags.HasDelete) != 0; }
		}

		/// <inheritdoc/>
		public TablesStream(IImageStream imageStream, StreamHeader streamHeader)
			: base(imageStream, streamHeader) {
		}

		/// <summary>
		/// Initializes MD tables
		/// </summary>
		/// <param name="typeSystemTableRows">Type system table rows (from #Pdb stream)</param>
		public void Initialize(uint[] typeSystemTableRows) {
			if (initialized)
				throw new Exception("Initialize() has already been called");
			initialized = true;

			reserved1 = imageStream.ReadUInt32();
			majorVersion = imageStream.ReadByte();
			minorVersion = imageStream.ReadByte();
			flags = (MDStreamFlags)imageStream.ReadByte();
			log2Rid = imageStream.ReadByte();
			validMask = imageStream.ReadUInt64();
			sortedMask = imageStream.ReadUInt64();

			int maxPresentTables;
			var dnTableSizes = new DotNetTableSizes();
			var tableInfos = dnTableSizes.CreateTables(majorVersion, minorVersion, out maxPresentTables);
			if (typeSystemTableRows != null)
				maxPresentTables = DotNetTableSizes.normalMaxTables;
			mdTables = new MDTable[tableInfos.Length];

			ulong valid = validMask;
			var sizes = new uint[64];
			for (int i = 0; i < 64; valid >>= 1, i++) {
				uint rows = (valid & 1) == 0 ? 0 : imageStream.ReadUInt32();
				if (i >= maxPresentTables)
					rows = 0;
				sizes[i] = rows;
				if (i < mdTables.Length)
					mdTables[i] = new MDTable((Table)i, rows, tableInfos[i]);
			}

			if (HasExtraData)
				extraData = imageStream.ReadUInt32();

			var debugSizes = sizes;
			if (typeSystemTableRows != null) {
				debugSizes = new uint[sizes.Length];
				for (int i = 0; i < 64; i++) {
					if (DotNetTableSizes.IsSystemTable((Table)i))
						debugSizes[i] = typeSystemTableRows[i];
					else
						debugSizes[i] = sizes[i];
				}
			}

			dnTableSizes.InitializeSizes(HasBigStrings, HasBigGUID, HasBigBlob, sizes, debugSizes);

			var currentPos = (FileOffset)imageStream.Position;
			foreach (var mdTable in mdTables) {
				var dataLen = (long)mdTable.TableInfo.RowSize * (long)mdTable.Rows;
				mdTable.ImageStream = imageStream.Create(currentPos, dataLen);
				var newPos = currentPos + (uint)dataLen;
				if (newPos < currentPos)
					throw new BadImageFormatException("Too big MD table");
				currentPos = newPos;
			}

			InitializeTables();
		}

		void InitializeTables() {
			ModuleTable = mdTables[(int)Table.Module];
			TypeRefTable = mdTables[(int)Table.TypeRef];
			TypeDefTable = mdTables[(int)Table.TypeDef];
			FieldPtrTable = mdTables[(int)Table.FieldPtr];
			FieldTable = mdTables[(int)Table.Field];
			MethodPtrTable = mdTables[(int)Table.MethodPtr];
			MethodTable = mdTables[(int)Table.Method];
			ParamPtrTable = mdTables[(int)Table.ParamPtr];
			ParamTable = mdTables[(int)Table.Param];
			InterfaceImplTable = mdTables[(int)Table.InterfaceImpl];
			MemberRefTable = mdTables[(int)Table.MemberRef];
			ConstantTable = mdTables[(int)Table.Constant];
			CustomAttributeTable = mdTables[(int)Table.CustomAttribute];
			FieldMarshalTable = mdTables[(int)Table.FieldMarshal];
			DeclSecurityTable = mdTables[(int)Table.DeclSecurity];
			ClassLayoutTable = mdTables[(int)Table.ClassLayout];
			FieldLayoutTable = mdTables[(int)Table.FieldLayout];
			StandAloneSigTable = mdTables[(int)Table.StandAloneSig];
			EventMapTable = mdTables[(int)Table.EventMap];
			EventPtrTable = mdTables[(int)Table.EventPtr];
			EventTable = mdTables[(int)Table.Event];
			PropertyMapTable = mdTables[(int)Table.PropertyMap];
			PropertyPtrTable = mdTables[(int)Table.PropertyPtr];
			PropertyTable = mdTables[(int)Table.Property];
			MethodSemanticsTable = mdTables[(int)Table.MethodSemantics];
			MethodImplTable = mdTables[(int)Table.MethodImpl];
			ModuleRefTable = mdTables[(int)Table.ModuleRef];
			TypeSpecTable = mdTables[(int)Table.TypeSpec];
			ImplMapTable = mdTables[(int)Table.ImplMap];
			FieldRVATable = mdTables[(int)Table.FieldRVA];
			ENCLogTable = mdTables[(int)Table.ENCLog];
			ENCMapTable = mdTables[(int)Table.ENCMap];
			AssemblyTable = mdTables[(int)Table.Assembly];
			AssemblyProcessorTable = mdTables[(int)Table.AssemblyProcessor];
			AssemblyOSTable = mdTables[(int)Table.AssemblyOS];
			AssemblyRefTable = mdTables[(int)Table.AssemblyRef];
			AssemblyRefProcessorTable = mdTables[(int)Table.AssemblyRefProcessor];
			AssemblyRefOSTable = mdTables[(int)Table.AssemblyRefOS];
			FileTable = mdTables[(int)Table.File];
			ExportedTypeTable = mdTables[(int)Table.ExportedType];
			ManifestResourceTable = mdTables[(int)Table.ManifestResource];
			NestedClassTable = mdTables[(int)Table.NestedClass];
			GenericParamTable = mdTables[(int)Table.GenericParam];
			MethodSpecTable = mdTables[(int)Table.MethodSpec];
			GenericParamConstraintTable = mdTables[(int)Table.GenericParamConstraint];
			DocumentTable = mdTables[(int)Table.Document];
			MethodDebugInformationTable = mdTables[(int)Table.MethodDebugInformation];
			LocalScopeTable = mdTables[(int)Table.LocalScope];
			LocalVariableTable = mdTables[(int)Table.LocalVariable];
			LocalConstantTable = mdTables[(int)Table.LocalConstant];
			ImportScopeTable = mdTables[(int)Table.ImportScope];
			StateMachineMethodTable = mdTables[(int)Table.StateMachineMethod];
			CustomDebugInformationTable = mdTables[(int)Table.CustomDebugInformation];
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			if (disposing) {
				var mt = mdTables;
				if (mt != null) {
					foreach (var mdTable in mt) {
						if (mdTable != null)
							mdTable.Dispose();
					}
					mdTables = null;
				}
			}
			base.Dispose(disposing);
		}

		/// <summary>
		/// Returns a MD table
		/// </summary>
		/// <param name="table">The table type</param>
		/// <returns>A <see cref="MDTable"/> or <c>null</c> if table doesn't exist</returns>
		public MDTable Get(Table table) {
			int index = (int)table;
			if ((uint)index >= (uint)mdTables.Length)
				return null;
			return mdTables[index];
		}

		/// <summary>
		/// Checks whether a table exists
		/// </summary>
		/// <param name="table">The table type</param>
		/// <returns><c>true</c> if the table exists</returns>
		public bool HasTable(Table table) {
			return (uint)table < (uint)mdTables.Length;
		}

		/// <summary>
		/// Checks whether table <paramref name="table"/> is sorted
		/// </summary>
		/// <param name="table">The table</param>
		public bool IsSorted(MDTable table) {
			int index = (int)table.Table;
			if ((uint)index >= 64)
				return false;
			return (sortedMask & (1UL << index)) != 0;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/TablesStream_Read.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;
using dnlib.PE;

ï»¿namespace dnlib.DotNet.MD {
	public partial class TablesStream {
		IBinaryReader GetReader_NoLock(MDTable table, uint rid) {
			IBinaryReader reader;
			if (hotTableStream != null) {
				reader = hotTableStream.GetTableReader(table, rid);
				if (reader != null)
					return reader;
			}
			reader = table.ImageStream;
			reader.Position = (rid - 1) * table.TableInfo.RowSize;
			return reader;
		}

		/// <summary>
		/// Reads a raw <c>Module</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawModuleRow ReadModuleRow(uint rid) {
			var table = ModuleTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawModuleRow(reader.ReadUInt16(),
				columns[1].Read(reader),
				columns[2].Read(reader),
				columns[3].Read(reader),
				columns[4].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Module</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="generation"></param>
		/// <param name="name"></param>
		/// <param name="mvid"></param>
		/// <param name="encId"></param>
		/// <returns></returns>
		internal uint ReadModuleRow(uint rid, out ushort generation, out uint name, out uint mvid, out uint encId) {
			var table = ModuleTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			generation = reader.ReadUInt16();
			name = columns[1].Read(reader);
			mvid = columns[2].Read(reader);
			encId = columns[3].Read(reader);
			return columns[4].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>TypeRef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawTypeRefRow ReadTypeRefRow(uint rid) {
			var table = TypeRefTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawTypeRefRow(columns[0].Read(reader),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>TypeRef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="resolutionScope"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadTypeRefRow(uint rid, out uint resolutionScope, out uint name) {
			var table = TypeRefTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			resolutionScope = columns[0].Read(reader);
			name = columns[1].Read(reader);
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>TypeDef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawTypeDefRow ReadTypeDefRow(uint rid) {
			var table = TypeDefTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawTypeDefRow(reader.ReadUInt32(),
				columns[1].Read(reader),
				columns[2].Read(reader),
				columns[3].Read(reader),
				columns[4].Read(reader),
				columns[5].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>TypeDef</c> row. Doesn't read field/method rid list.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="flags"></param>
		/// <param name="name"></param>
		/// <param name="namespace"></param>
		/// <returns></returns>
		internal uint ReadTypeDefRow(uint rid, out int flags, out uint name, out uint @namespace) {
			var table = TypeDefTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			flags = reader.ReadInt32();
			name = columns[1].Read(reader);
			@namespace = columns[2].Read(reader);
			return columns[3].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>FieldPtr</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawFieldPtrRow ReadFieldPtrRow(uint rid) {
			var table = FieldPtrTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawFieldPtrRow(columns[0].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Field</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawFieldRow ReadFieldRow(uint rid) {
			var table = FieldTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawFieldRow(reader.ReadUInt16(),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Field</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="flags"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadFieldRow(uint rid, out int flags, out uint name) {
			var table = FieldTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			flags = reader.ReadUInt16();
			name = columns[1].Read(reader);
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MethodPtr</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawMethodPtrRow ReadMethodPtrRow(uint rid) {
			var table = MethodPtrTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawMethodPtrRow(columns[0].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Method</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawMethodRow ReadMethodRow(uint rid) {
			var table = MethodTable;
			if (table.IsInvalidRID(rid))
				return null;
			var mrr = methodRowReader;
			if (mrr != null) {
				var row = mrr.ReadRow(rid);
				if (row != null)
					return row;
			}
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawMethodRow(reader.ReadUInt32(),
				reader.ReadUInt16(),
				reader.ReadUInt16(),
				columns[3].Read(reader),
				columns[4].Read(reader),
				columns[5].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Method</c> row but not ParamList
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="rva"></param>
		/// <param name="implFlags"></param>
		/// <param name="flags"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadMethodRow(uint rid, out RVA rva, out int implFlags, out int flags, out uint name) {
			var table = MethodTable;
			var mrr = methodRowReader;
			if (mrr != null) {
				var row = mrr.ReadRow(rid);
				if (row != null) {
					rva = (RVA)row.RVA;
					implFlags = row.ImplFlags;
					flags = row.Flags;
					name = row.Name;
					return row.Signature;
				}
			}
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			rva = (RVA)reader.ReadUInt32();
			implFlags = reader.ReadUInt16();
			flags = reader.ReadUInt16();
			name = columns[3].Read(reader);
			return columns[4].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ParamPtr</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawParamPtrRow ReadParamPtrRow(uint rid) {
			var table = ParamPtrTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawParamPtrRow(columns[0].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Param</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawParamRow ReadParamRow(uint rid) {
			var table = ParamTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawParamRow(reader.ReadUInt16(),
				reader.ReadUInt16(),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Param</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="flags"></param>
		/// <param name="sequence"></param>
		/// <returns></returns>
		internal uint ReadParamRow(uint rid, out int flags, out ushort sequence) {
			var table = ParamTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			flags = reader.ReadUInt16();
			sequence = reader.ReadUInt16();
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>InterfaceImpl</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawInterfaceImplRow ReadInterfaceImplRow(uint rid) {
			var table = InterfaceImplTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawInterfaceImplRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>InterfaceImpl</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The <c>Interface</c> field</returns>
		internal uint ReadInterfaceImplRow2(uint rid) {
			var table = InterfaceImplTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			reader.Position += columns[0].Size;
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MemberRef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawMemberRefRow ReadMemberRefRow(uint rid) {
			var table = MemberRefTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawMemberRefRow(columns[0].Read(reader),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MemberRef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="class"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadMemberRefRow(uint rid, out uint @class, out uint name) {
			var table = MemberRefTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			@class = columns[0].Read(reader);
			name = columns[1].Read(reader);
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Constant</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawConstantRow ReadConstantRow(uint rid) {
			var table = ConstantTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawConstantRow(reader.ReadByte(),
				reader.ReadByte(),
				columns[2].Read(reader),
				columns[3].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Constant</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="type"></param>
		/// <returns></returns>
		internal uint ReadConstantRow(uint rid, out ElementType type) {
			var table = ConstantTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			type = (ElementType)reader.ReadByte();
			reader.Position += 1 + columns[2].Size;
			return columns[3].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>CustomAttribute</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawCustomAttributeRow ReadCustomAttributeRow(uint rid) {
			var table = CustomAttributeTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawCustomAttributeRow(columns[0].Read(reader),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>FieldMarshal</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawFieldMarshalRow ReadFieldMarshalRow(uint rid) {
			var table = FieldMarshalTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawFieldMarshalRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>DeclSecurity</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawDeclSecurityRow ReadDeclSecurityRow(uint rid) {
			var table = DeclSecurityTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawDeclSecurityRow(reader.ReadInt16(),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>DeclSecurity</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="action"></param>
		/// <returns></returns>
		internal uint ReadDeclSecurityRow(uint rid, out SecurityAction action) {
			var table = DeclSecurityTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			action = (SecurityAction)reader.ReadInt16();
			reader.Position += columns[1].Size;
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ClassLayout</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawClassLayoutRow ReadClassLayoutRow(uint rid) {
			var table = ClassLayoutTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawClassLayoutRow(reader.ReadUInt16(),
				reader.ReadUInt32(),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ClassLayout</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="packingSize"></param>
		/// <returns></returns>
		internal uint ReadClassLayoutRow(uint rid, out ushort packingSize) {
			var table = ClassLayoutTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			packingSize = reader.ReadUInt16();
			return reader.ReadUInt32();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>FieldLayout</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawFieldLayoutRow ReadFieldLayoutRow(uint rid) {
			var table = FieldLayoutTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawFieldLayoutRow(reader.ReadUInt32(),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>FieldLayout</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns></returns>
		internal uint? ReadFieldLayoutRow2(uint rid) {
			var table = FieldLayoutTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return reader.ReadUInt32();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>StandAloneSig</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawStandAloneSigRow ReadStandAloneSigRow(uint rid) {
			var table = StandAloneSigTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawStandAloneSigRow(columns[0].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>StandAloneSig</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns></returns>
		internal uint ReadStandAloneSigRow2(uint rid) {
			var table = StandAloneSigTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return columns[0].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>EventMap</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawEventMapRow ReadEventMapRow(uint rid) {
			var table = EventMapTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawEventMapRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>EventPtr</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawEventPtrRow ReadEventPtrRow(uint rid) {
			var table = EventPtrTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawEventPtrRow(columns[0].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Event</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawEventRow ReadEventRow(uint rid) {
			var table = EventTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawEventRow(reader.ReadUInt16(),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Event</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="eventFlags"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadEventRow(uint rid, out int eventFlags, out uint name) {
			var table = EventTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			eventFlags = reader.ReadUInt16();
			name = columns[1].Read(reader);
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>PropertyMap</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawPropertyMapRow ReadPropertyMapRow(uint rid) {
			var table = PropertyMapTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawPropertyMapRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>PropertyPtr</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawPropertyPtrRow ReadPropertyPtrRow(uint rid) {
			var table = PropertyPtrTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawPropertyPtrRow(columns[0].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Property</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawPropertyRow ReadPropertyRow(uint rid) {
			var table = PropertyTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawPropertyRow(reader.ReadUInt16(),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Property</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="propFlags"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadPropertyRow(uint rid, out int propFlags, out uint name) {
			var table = PropertyTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			propFlags = reader.ReadUInt16();
			name = columns[1].Read(reader);
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MethodSemantics</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawMethodSemanticsRow ReadMethodSemanticsRow(uint rid) {
			var table = MethodSemanticsTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawMethodSemanticsRow(reader.ReadUInt16(),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MethodSemantics</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="semantic"></param>
		/// <returns></returns>
		internal uint ReadMethodSemanticsRow(uint rid, out MethodSemanticsAttributes semantic) {
			var table = MethodSemanticsTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			semantic = (MethodSemanticsAttributes)reader.ReadUInt16();
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MethodImpl</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawMethodImplRow ReadMethodImplRow(uint rid) {
			var table = MethodImplTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawMethodImplRow(columns[0].Read(reader),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MethodImpl</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="methodBody"></param>
		/// <returns></returns>
		internal uint ReadMethodImplRow(uint rid, out uint methodBody) {
			var table = MethodImplTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			reader.Position += columns[0].Size;
			methodBody = columns[1].Read(reader);
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ModuleRef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawModuleRefRow ReadModuleRefRow(uint rid) {
			var table = ModuleRefTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawModuleRefRow(columns[0].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ModuleRef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns></returns>
		internal uint ReadModuleRefRow2(uint rid) {
			var table = ModuleRefTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return columns[0].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>TypeSpec</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawTypeSpecRow ReadTypeSpecRow(uint rid) {
			var table = TypeSpecTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawTypeSpecRow(columns[0].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>TypeSpec</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns></returns>
		internal uint ReadTypeSpecRow2(uint rid) {
			var table = TypeSpecTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return columns[0].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ImplMap</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawImplMapRow ReadImplMapRow(uint rid) {
			var table = ImplMapTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawImplMapRow(reader.ReadUInt16(),
				columns[1].Read(reader),
				columns[2].Read(reader),
				columns[3].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ImplMap</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="attributes"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadImplMapRow(uint rid, out int attributes, out uint name) {
			var table = ImplMapTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			attributes = reader.ReadUInt16();
			reader.Position += columns[1].Size;
			name = columns[2].Read(reader);
			return columns[3].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>FieldRVA</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawFieldRVARow ReadFieldRVARow(uint rid) {
			var table = FieldRVATable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawFieldRVARow(reader.ReadUInt32(),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>FieldRVA</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="rva"></param>
		/// <returns></returns>
		internal bool ReadFieldRVARow(uint rid, out RVA rva) {
			var table = FieldRVATable;
			if (table.IsInvalidRID(rid)) {
				rva = 0;
				return false;
			}
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			rva = (RVA)reader.ReadUInt32();
			return true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ENCLog</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawENCLogRow ReadENCLogRow(uint rid) {
			var table = ENCLogTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			return new RawENCLogRow(reader.ReadUInt32(),
				reader.ReadUInt32());
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ENCMap</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawENCMapRow ReadENCMapRow(uint rid) {
			var table = ENCMapTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			return new RawENCMapRow(reader.ReadUInt32());
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Assembly</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawAssemblyRow ReadAssemblyRow(uint rid) {
			var table = AssemblyTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawAssemblyRow(reader.ReadUInt32(),
				reader.ReadUInt16(),
				reader.ReadUInt16(),
				reader.ReadUInt16(),
				reader.ReadUInt16(),
				reader.ReadUInt32(),
				columns[6].Read(reader),
				columns[7].Read(reader),
				columns[8].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Assembly</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="hashAlgId"></param>
		/// <param name="version"></param>
		/// <param name="attributes"></param>
		/// <param name="publicKey"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadAssemblyRow(uint rid, out AssemblyHashAlgorithm hashAlgId, out Version version, out int attributes, out uint publicKey, out uint name) {
			var table = AssemblyTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			hashAlgId = (AssemblyHashAlgorithm)reader.ReadUInt32();
			version = new Version(reader.ReadUInt16(), reader.ReadUInt16(), reader.ReadUInt16(), reader.ReadUInt16());
			attributes = reader.ReadInt32();
			publicKey = columns[6].Read(reader);
			name = columns[7].Read(reader);
			return columns[8].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>AssemblyProcessor</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawAssemblyProcessorRow ReadAssemblyProcessorRow(uint rid) {
			var table = AssemblyProcessorTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			return new RawAssemblyProcessorRow(reader.ReadUInt32());
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>AssemblyOS</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawAssemblyOSRow ReadAssemblyOSRow(uint rid) {
			var table = AssemblyOSTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			return new RawAssemblyOSRow(reader.ReadUInt32(),
				reader.ReadUInt32(),
				reader.ReadUInt32());
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>AssemblyRef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawAssemblyRefRow ReadAssemblyRefRow(uint rid) {
			var table = AssemblyRefTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawAssemblyRefRow(reader.ReadUInt16(),
				reader.ReadUInt16(),
				reader.ReadUInt16(),
				reader.ReadUInt16(),
				reader.ReadUInt32(),
				columns[5].Read(reader),
				columns[6].Read(reader),
				columns[7].Read(reader),
				columns[8].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>AssemblyRef</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="version"></param>
		/// <param name="attributes"></param>
		/// <param name="publicKeyOrToken"></param>
		/// <param name="name"></param>
		/// <param name="culture"></param>
		/// <returns></returns>
		internal uint ReadAssemblyRefRow(uint rid, out Version version, out int attributes, out uint publicKeyOrToken, out uint name, out uint culture) {
			var table = AssemblyRefTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			version = new Version(reader.ReadUInt16(), reader.ReadUInt16(), reader.ReadUInt16(), reader.ReadUInt16());
			attributes = reader.ReadInt32();
			publicKeyOrToken = columns[5].Read(reader);
			name = columns[6].Read(reader);
			culture = columns[7].Read(reader);
			return columns[8].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>AssemblyRefProcessor</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawAssemblyRefProcessorRow ReadAssemblyRefProcessorRow(uint rid) {
			var table = AssemblyRefProcessorTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawAssemblyRefProcessorRow(reader.ReadUInt32(),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>AssemblyRefOS</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawAssemblyRefOSRow ReadAssemblyRefOSRow(uint rid) {
			var table = AssemblyRefOSTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawAssemblyRefOSRow(reader.ReadUInt32(),
				reader.ReadUInt32(),
				reader.ReadUInt32(),
				columns[3].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>File</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawFileRow ReadFileRow(uint rid) {
			var table = FileTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawFileRow(reader.ReadUInt32(),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>File</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="attributes"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadFileRow(uint rid, out int attributes, out uint name) {
			var table = FileTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			attributes = reader.ReadInt32();
			name = columns[1].Read(reader);
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ExportedType</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawExportedTypeRow ReadExportedTypeRow(uint rid) {
			var table = ExportedTypeTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawExportedTypeRow(reader.ReadUInt32(),
				reader.ReadUInt32(),
				columns[2].Read(reader),
				columns[3].Read(reader),
				columns[4].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ExportedType</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="attributes"></param>
		/// <param name="typeDefId"></param>
		/// <param name="name"></param>
		/// <param name="namespace"></param>
		/// <returns></returns>
		internal uint ReadExportedTypeRow(uint rid, out int attributes, out uint typeDefId, out uint name, out uint @namespace) {
			var table = ExportedTypeTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			attributes = reader.ReadInt32();
			typeDefId = reader.ReadUInt32();
			name = columns[2].Read(reader);
			@namespace = columns[3].Read(reader);
			return columns[4].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ManifestResource</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawManifestResourceRow ReadManifestResourceRow(uint rid) {
			var table = ManifestResourceTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawManifestResourceRow(reader.ReadUInt32(),
				reader.ReadUInt32(),
				columns[2].Read(reader),
				columns[3].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ManifestResource</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="offset"></param>
		/// <param name="attributes"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadManifestResourceRow(uint rid, out uint offset, out int attributes, out uint name) {
			var table = ManifestResourceTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			offset = reader.ReadUInt32();
			attributes = reader.ReadInt32();
			name = columns[2].Read(reader);
			return columns[3].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>NestedClass</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawNestedClassRow ReadNestedClassRow(uint rid) {
			var table = NestedClassTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawNestedClassRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>NestedClass</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns></returns>
		internal uint ReadNestedClassRow2(uint rid) {
			var table = NestedClassTable;
			if (table.IsInvalidRID(rid))
				return 0;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			reader.Position += columns[0].Size;
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>GenericParam</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawGenericParamRow ReadGenericParamRow(uint rid) {
			var table = GenericParamTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			if (columns.Count == 4) {
				return new RawGenericParamRow(reader.ReadUInt16(),
					reader.ReadUInt16(),
					columns[2].Read(reader),
					columns[3].Read(reader));
			}
			return new RawGenericParamRow(reader.ReadUInt16(),
				reader.ReadUInt16(),
				columns[2].Read(reader),
				columns[3].Read(reader),
				columns[4].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>GenericParam</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="number"></param>
		/// <param name="attributes"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		internal uint ReadGenericParamRow(uint rid, out ushort number, out int attributes, out uint name) {
			var table = GenericParamTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			number = reader.ReadUInt16();
			attributes = reader.ReadUInt16();
			reader.Position += columns[2].Size;
			name = columns[3].Read(reader);
			if (columns.Count == 4)
				return 0;
			return columns[4].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MethodSpec</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawMethodSpecRow ReadMethodSpecRow(uint rid) {
			var table = MethodSpecTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawMethodSpecRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MethodSpec</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="method"></param>
		/// <returns></returns>
		internal uint ReadMethodSpecRow(uint rid, out uint method) {
			var table = MethodSpecTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			method = columns[0].Read(reader);
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>GenericParamConstraint</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawGenericParamConstraintRow ReadGenericParamConstraintRow(uint rid) {
			var table = GenericParamConstraintTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawGenericParamConstraintRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>GenericParamConstraint</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns></returns>
		internal uint ReadGenericParamConstraintRow2(uint rid) {
			var table = GenericParamConstraintTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			reader.Position += columns[0].Size;
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>Document</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawDocumentRow ReadDocumentRow(uint rid) {
			var table = DocumentTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawDocumentRow(columns[0].Read(reader),
				columns[1].Read(reader),
				columns[2].Read(reader),
				columns[3].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal uint ReadDocumentRow2(uint rid, out uint name, out uint hashAlgorithm, out uint hash) {
			var table = DocumentTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			name = columns[0].Read(reader);
			hashAlgorithm = columns[1].Read(reader);
			hash = columns[2].Read(reader);
			return columns[3].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>MethodDebugInformation</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawMethodDebugInformationRow ReadMethodDebugInformationRow(uint rid) {
			var table = MethodDebugInformationTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawMethodDebugInformationRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal uint ReadMethodDebugInformationRow2(uint rid, out uint document) {
			var table = MethodDebugInformationTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			document = columns[0].Read(reader);
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>LocalScope</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawLocalScopeRow ReadLocalScopeRow(uint rid) {
			var table = LocalScopeTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawLocalScopeRow(columns[0].Read(reader),
				columns[1].Read(reader),
				columns[2].Read(reader),
				columns[3].Read(reader),
				reader.ReadUInt32(),
				reader.ReadUInt32());
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal uint ReadLocalScopeRow2(uint rid, out uint importScope, out uint variableList, out uint constantList, out uint startOffset) {
			var table = LocalScopeTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			reader.Position += columns[0].Size;
			importScope = columns[1].Read(reader);
			variableList = columns[2].Read(reader);
			constantList = columns[3].Read(reader);
			startOffset = reader.ReadUInt32();
			return reader.ReadUInt32();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>LocalVariable</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawLocalVariableRow ReadLocalVariableRow(uint rid) {
			var table = LocalVariableTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawLocalVariableRow(reader.ReadUInt16(),
				reader.ReadUInt16(),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal uint ReadLocalVariableRow2(uint rid, out ushort attributes, out ushort index) {
			var table = LocalVariableTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			attributes = reader.ReadUInt16();
			index = reader.ReadUInt16();
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>LocalConstant</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawLocalConstantRow ReadLocalConstantRow(uint rid) {
			var table = LocalConstantTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawLocalConstantRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal uint ReadLocalConstantRow2(uint rid, out uint name) {
			var table = LocalConstantTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			name = columns[0].Read(reader);
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>ImportScope</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawImportScopeRow ReadImportScopeRow(uint rid) {
			var table = ImportScopeTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawImportScopeRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal uint ReadImportScopeRow2(uint rid, out uint parent) {
			var table = ImportScopeTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			parent = columns[0].Read(reader);
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>StateMachineMethod</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawStateMachineMethodRow ReadStateMachineMethodRow(uint rid) {
			var table = StateMachineMethodTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawStateMachineMethodRow(columns[0].Read(reader),
				columns[1].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal uint ReadStateMachineMethodRow2(uint rid) {
			var table = StateMachineMethodTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			reader.Position += columns[0].Size;
			return columns[1].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a raw <c>CustomDebugInformation</c> row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The row or <c>null</c> if table doesn't exist or if <paramref name="rid"/> is invalid</returns>
		public RawCustomDebugInformationRow ReadCustomDebugInformationRow(uint rid) {
			var table = CustomDebugInformationTable;
			if (table.IsInvalidRID(rid))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			return new RawCustomDebugInformationRow(columns[0].Read(reader),
				columns[1].Read(reader),
				columns[2].Read(reader));
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal uint ReadCustomDebugInformationRow2(uint rid, out uint kind) {
			var table = CustomDebugInformationTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			var columns = table.TableInfo.Columns;
			reader.Position += columns[0].Size;
			kind = columns[1].Read(reader);
			return columns[2].Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads a column
		/// </summary>
		/// <param name="table">The table</param>
		/// <param name="rid">Row ID</param>
		/// <param name="colIndex">Column index in <paramref name="table"/></param>
		/// <param name="value">Result is put here or 0 if we return <c>false</c></param>
		/// <returns><c>true</c> if we could read the column, <c>false</c> otherwise</returns>
		public bool ReadColumn(MDTable table, uint rid, int colIndex, out uint value) {
			return ReadColumn(table, rid, table.TableInfo.Columns[colIndex], out value);
		}

		/// <summary>
		/// Reads a column
		/// </summary>
		/// <param name="table">The table</param>
		/// <param name="rid">Row ID</param>
		/// <param name="column">Column</param>
		/// <param name="value">Result is put here or 0 if we return <c>false</c></param>
		/// <returns><c>true</c> if we could read the column, <c>false</c> otherwise</returns>
		public bool ReadColumn(MDTable table, uint rid, ColumnInfo column, out uint value) {
			if (table.IsInvalidRID(rid)) {
				value = 0;
				return false;
			}
			var cr = columnReader;
			if (cr != null && cr.ReadColumn(table, rid, column, out value))
				return true;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(table, rid);
			reader.Position += column.Offset;
			value = column.Read(reader);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			return true;
		}

		/// <summary>
		/// Reads a column
		/// </summary>
		/// <param name="table">The table</param>
		/// <param name="rid">Row ID</param>
		/// <param name="column">Column</param>
		/// <param name="value">Result is put here or 0 if we return <c>false</c></param>
		/// <returns><c>true</c> if we could read the column, <c>false</c> otherwise</returns>
		internal bool ReadColumn_NoLock(MDTable table, uint rid, ColumnInfo column, out uint value) {
			if (table.IsInvalidRID(rid)) {
				value = 0;
				return false;
			}
			var cr = columnReader;
			if (cr != null && cr.ReadColumn(table, rid, column, out value))
				return true;
			var reader = GetReader_NoLock(table, rid);
			reader.Position += column.Offset;
			value = column.Read(reader);
			return true;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/MD/USStream.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using dnlib.IO;

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the #US stream
	/// </summary>
	public sealed class USStream : HeapStream {
		/// <inheritdoc/>
		public USStream() {
		}

		/// <inheritdoc/>
		public USStream(IImageStream imageStream, StreamHeader streamHeader)
			: base(imageStream, streamHeader) {
		}

		/// <summary>
		/// Reads a unicode string
		/// </summary>
		/// <param name="offset">Offset of unicode string</param>
		/// <returns>A string or <c>null</c> if <paramref name="offset"/> is invalid</returns>
		public string Read(uint offset) {
			if (offset == 0)
				return string.Empty;
			if (!IsValidOffset(offset))
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var reader = GetReader_NoLock(offset);
			uint length;
			if (!reader.ReadCompressedUInt32(out length))
				return null;
			if (reader.Position + length < length || reader.Position + length > reader.Length)
				return null;
			try {
				return reader.ReadString((int)(length / 2));
			}
			catch (OutOfMemoryException) {
				throw;
			}
			catch {
				// It's possible that an exception is thrown when converting a char* to
				// a string. If so, return an empty string.
				return string.Empty;
			}
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Reads data just like <see cref="Read"/>, but returns an empty string if
		/// offset is invalid
		/// </summary>
		/// <param name="offset">Offset of unicode string</param>
		/// <returns>The string</returns>
		public string ReadNoNull(uint offset) {
			return Read(offset) ?? string.Empty;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/CustomDebugInfoGuids.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Custom debug info guids
	/// </summary>
	public static class CustomDebugInfoGuids {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		// Roslyn: PortableCustomDebugInfoKinds.cs
		public static readonly Guid AsyncMethodSteppingInformationBlob = new Guid("54FD2AC5-E925-401A-9C2A-F94F171072F8");
		public static readonly Guid DefaultNamespace = new Guid("58B2EAB6-209F-4E4E-A22C-B2D0F910C782");
		public static readonly Guid DynamicLocalVariables = new Guid("83C563C4-B4F3-47D5-B824-BA5441477EA8");
		public static readonly Guid EmbeddedSource = new Guid("0E8A571B-6926-466E-B4AD-8AB04611F5FE");
		public static readonly Guid EncLambdaAndClosureMap = new Guid("A643004C-0240-496F-A783-30D64F4979DE");
		public static readonly Guid EncLocalSlotMap = new Guid("755F52A8-91C5-45BE-B4B8-209571E552BD");
		public static readonly Guid SourceLink = new Guid("CC110556-A091-4D38-9FEC-25AB9A351A6A");
		public static readonly Guid StateMachineHoistedLocalScopes = new Guid("6DA9A61E-F8C7-4874-BE62-68BC5630DF71");
		public static readonly Guid TupleElementNames = new Guid("ED9FDF71-8879-4747-8ED3-FE5EDE3CE710");
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/IMAGE_DEBUG_DIRECTORY.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.PE;

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// IMAGE_DEBUG_DIRECTORY
	/// </summary>
	public struct IMAGE_DEBUG_DIRECTORY {
#pragma warning disable 1591
		public uint Characteristics;
		public uint TimeDateStamp;
		public ushort MajorVersion;
		public ushort MinorVersion;
		public ImageDebugType Type;
		public uint SizeOfData;
		public uint AddressOfRawData;
		public uint PointerToRawData;
#pragma warning restore 1591
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/ImageStreamUtils.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using System.Security;
using dnlib.IO;

namespace dnlib.DotNet.Pdb {
	static class ImageStreamUtils {
		public static IImageStream OpenImageStream(string fileName) {
			try {
				if (!File.Exists(fileName))
					return null;
				// Don't use memory mapped I/O
				return MemoryImageStream.Create(File.ReadAllBytes(fileName));
			}
			catch (IOException) {
			}
			catch (UnauthorizedAccessException) {
			}
			catch (SecurityException) {
			}
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/ManagedSymbolReaderCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.IO;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb {
	static class ManagedSymbolReaderCreator {
		public static SymbolReader CreateFromAssemblyFile(IMetaData metaData, string assemblyFileName) {
			return Create(metaData, Path.ChangeExtension(assemblyFileName, "pdb"));
		}

		public static SymbolReader Create(IMetaData metaData, string pdbFileName) {
			return Create(metaData, ImageStreamUtils.OpenImageStream(pdbFileName));
		}

		public static SymbolReader Create(IMetaData metaData, byte[] pdbData) {
			return Create(metaData, MemoryImageStream.Create(pdbData));
		}

		public static SymbolReader Create(IMetaData metaData, IImageStream pdbStream) {
			try {
				// Embedded pdbs have priority
				var res = Create(metaData);
				if (res != null) {
					if (pdbStream != null)
						pdbStream.Dispose();
					return res;
				}

				return CreateCore(pdbStream);
			}
			catch {
				if (pdbStream != null)
					pdbStream.Dispose();
				throw;
			}
		}

		static SymbolReader CreateCore(IImageStream pdbStream) {
			if (pdbStream == null)
				return null;
			try {
				uint sig = pdbStream.ReadUInt32();
				pdbStream.Position = 0;
				if (sig == 0x424A5342)
					return Portable.SymbolReaderCreator.TryCreate(pdbStream, false);
				return Managed.SymbolReaderCreator.Create(pdbStream);
			}
			catch (IOException) {
			}
			if (pdbStream != null)
				pdbStream.Dispose();
			return null;
		}

		internal static SymbolReader Create(IMetaData metaData) {
			return Portable.SymbolReaderCreator.TryCreate(metaData);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbConstant.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A constant in a method scope, eg. "const int SomeConstant = 123;"
	/// </summary>
	public sealed class PdbConstant : IHasCustomDebugInformation {
		string name;
		TypeSig type;
		object value;

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public string Name {
			get { return name; }
			set { name = value; }
		}

		/// <summary>
		/// Gets/sets the type of the constant
		/// </summary>
		public TypeSig Type {
			get { return type; }
			set { type = value; }
		}

		/// <summary>
		/// Gets/sets the value of the constant
		/// </summary>
		public object Value {
			get { return value; }
			set { this.value = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbConstant() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of constant</param>
		/// <param name="type">Type of constant</param>
		/// <param name="value">Constant value</param>
		public PdbConstant(string name, TypeSig type, object value) {
			this.name = name;
			this.type = type;
			this.value = value;
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 25; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get { return customDebugInfos; }
		}
		readonly ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();

		/// <summary>
		/// ToString()
		/// </summary>
		/// <returns></returns>
		public override string ToString() {
			var type = Type;
			return (type == null ? "" : type.ToString()) + " " + Name + " = " + (Value == null ? "null" : Value.ToString() + " (" + Value.GetType().FullName + ")");
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbCustomDebugInfo.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using dnlib.DotNet.Emit;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Custom debug info kind
	/// </summary>
	/// <remarks>See <c>CustomDebugInfoKind</c> in Roslyn source code</remarks>
	public enum PdbCustomDebugInfoKind {
		/// <summary>
		/// <see cref="PdbUsingGroupsCustomDebugInfo"/>
		/// </summary>
		UsingGroups,

		/// <summary>
		/// <see cref="PdbForwardMethodInfoCustomDebugInfo"/>
		/// </summary>
		ForwardMethodInfo,

		/// <summary>
		/// <see cref="PdbForwardModuleInfoCustomDebugInfo"/>
		/// </summary>
		ForwardModuleInfo,

		/// <summary>
		/// <see cref="PdbStateMachineHoistedLocalScopesCustomDebugInfo"/>
		/// </summary>
		StateMachineHoistedLocalScopes,

		/// <summary>
		/// <see cref="PdbStateMachineTypeNameCustomDebugInfo"/>
		/// </summary>
		StateMachineTypeName,

		/// <summary>
		/// <see cref="PdbDynamicLocalsCustomDebugInfo"/>
		/// </summary>
		DynamicLocals,

		/// <summary>
		/// <see cref="PdbEditAndContinueLocalSlotMapCustomDebugInfo"/>
		/// </summary>
		EditAndContinueLocalSlotMap,

		/// <summary>
		/// <see cref="PdbEditAndContinueLambdaMapCustomDebugInfo"/>
		/// </summary>
		EditAndContinueLambdaMap,

		/// <summary>
		/// <see cref="PdbTupleElementNamesCustomDebugInfo"/>
		/// </summary>
		TupleElementNames,

		// Values 0x00-0xFF are reserved for Windows PDB CDIs.

		/// <summary>
		/// Unknown
		/// </summary>
		Unknown = int.MinValue,

		/// <summary>
		/// <see cref="PortablePdbTupleElementNamesCustomDebugInfo"/>
		/// </summary>
		TupleElementNames_PortablePdb,

		/// <summary>
		/// <see cref="PdbDefaultNamespaceCustomDebugInfo"/>
		/// </summary>
		DefaultNamespace,

		/// <summary>
		/// <see cref="PdbDynamicLocalVariablesCustomDebugInfo"/>
		/// </summary>
		DynamicLocalVariables,

		/// <summary>
		/// <see cref="PdbEmbeddedSourceCustomDebugInfo"/>
		/// </summary>
		EmbeddedSource,

		/// <summary>
		/// <see cref="PdbSourceLinkCustomDebugInfo"/>
		/// </summary>
		SourceLink,

		/// <summary>
		/// <see cref="PdbAsyncMethodCustomDebugInfo"/>
		/// </summary>
		AsyncMethod,

		/// <summary>
		/// <see cref="PdbIteratorMethodCustomDebugInfo"/>
		/// </summary>
		IteratorMethod,
	}

	/// <summary>
	/// Base class of custom debug info added to the PDB file by the compiler
	/// </summary>
	public abstract class PdbCustomDebugInfo {
		/// <summary>
		/// Gets the custom debug info kind
		/// </summary>
		public abstract PdbCustomDebugInfoKind Kind { get; }

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public abstract Guid Guid { get; }
	}

	/// <summary>
	/// Unknown custom debug info. If you see an instance of this class, you're using an old dnlib version or
	/// dnlib hasn't been updated to support this new custom debug info kind.
	/// </summary>
	public sealed class PdbUnknownCustomDebugInfo : PdbCustomDebugInfo {
		readonly PdbCustomDebugInfoKind kind;
		readonly Guid guid;
		readonly byte[] data;

		/// <summary>
		/// Gets the custom debug info kind
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return kind; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return guid; }
		}

		/// <summary>
		/// Gets the data
		/// </summary>
		public byte[] Data {
			get { return data; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="kind">Custom debug info kind</param>
		/// <param name="data">Raw custom debug info data</param>
		public PdbUnknownCustomDebugInfo(PdbCustomDebugInfoKind kind, byte[] data) {
			if (data == null)
				throw new ArgumentNullException("data");
			this.kind = kind;
			this.data = data;
			guid = Guid.Empty;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">Custom debug info guid</param>
		/// <param name="data">Raw custom debug info data</param>
		public PdbUnknownCustomDebugInfo(Guid guid, byte[] data) {
			if (data == null)
				throw new ArgumentNullException("data");
			this.kind = PdbCustomDebugInfoKind.Unknown;
			this.data = data;
			this.guid = guid;
		}
	}

	/// <summary>
	/// Contains sizes of using groups
	/// </summary>
	public sealed class PdbUsingGroupsCustomDebugInfo : PdbCustomDebugInfo {
		readonly ThreadSafe.IList<ushort> usingCounts;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.UsingGroups"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.UsingGroups; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return Guid.Empty; }
		}

		/// <summary>
		/// Gets the using counts
		/// </summary>
		public ThreadSafe.IList<ushort> UsingCounts {
			get { return usingCounts; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbUsingGroupsCustomDebugInfo() {
			usingCounts = ThreadSafeListCreator.Create<ushort>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="UsingCounts"/></param>
		public PdbUsingGroupsCustomDebugInfo(int capacity) {
			usingCounts = ThreadSafeListCreator.Create<ushort>(capacity);
		}
	}

	/// <summary>
	/// Contains a reference to another method that contains the import strings
	/// </summary>
	public sealed class PdbForwardMethodInfoCustomDebugInfo : PdbCustomDebugInfo {
		IMethodDefOrRef method;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.ForwardMethodInfo"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.ForwardMethodInfo; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return Guid.Empty; }
		}

		/// <summary>
		/// Gets/sets the referenced method
		/// </summary>
		public IMethodDefOrRef Method {
			get { return method; }
			set { method = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbForwardMethodInfoCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The referenced method</param>
		public PdbForwardMethodInfoCustomDebugInfo(IMethodDefOrRef method) {
			this.method = method;
		}
	}

	/// <summary>
	/// Contains a reference to another method that contains the per-module debug info (assembly reference aliases)
	/// </summary>
	public sealed class PdbForwardModuleInfoCustomDebugInfo : PdbCustomDebugInfo {
		IMethodDefOrRef method;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.ForwardModuleInfo"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.ForwardModuleInfo; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return Guid.Empty; }
		}

		/// <summary>
		/// Gets/sets the referenced method
		/// </summary>
		public IMethodDefOrRef Method {
			get { return method; }
			set { method = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbForwardModuleInfoCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The referenced method</param>
		public PdbForwardModuleInfoCustomDebugInfo(IMethodDefOrRef method) {
			this.method = method;
		}
	}

	/// <summary>
	/// State machine hosted local scope info
	/// </summary>
	public struct StateMachineHoistedLocalScope {
		/// <summary>
		/// true if it's a syntesized local (<see cref="Start"/> and <see cref="End"/> are both null)
		/// </summary>
		public bool IsSynthesizedLocal {
			get { return Start == null && End == null; }
		}

		/// <summary>
		/// The instruction of the first operation in the scope. Can be null if it's a synthesized local
		/// </summary>
		public Instruction Start;

		/// <summary>
		/// The instruction of the first operation outside of the scope or null if it ends at the last instruction in the body.
		/// Can also be null if it's a synthesized local (in which case <see cref="Start"/> is also null, see <see cref="IsSynthesizedLocal"/>)
		/// </summary>
		public Instruction End;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="start">Start of the scope</param>
		/// <param name="end">First instruction after the end of the scope</param>
		public StateMachineHoistedLocalScope(Instruction start, Instruction end) {
			Start = start;
			End = end;
		}
	}

	/// <summary>
	/// Contains local scopes for state machine hoisted local variables.
	/// </summary>
	public sealed class PdbStateMachineHoistedLocalScopesCustomDebugInfo : PdbCustomDebugInfo {
		readonly ThreadSafe.IList<StateMachineHoistedLocalScope> scopes;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.StateMachineHoistedLocalScopes; }
		}

		/// <summary>
		/// Gets the scopes
		/// </summary>
		public ThreadSafe.IList<StateMachineHoistedLocalScope> Scopes {
			get { return scopes; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbStateMachineHoistedLocalScopesCustomDebugInfo() {
			scopes = ThreadSafeListCreator.Create<StateMachineHoistedLocalScope>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Scopes"/></param>
		public PdbStateMachineHoistedLocalScopesCustomDebugInfo(int capacity) {
			scopes = ThreadSafeListCreator.Create<StateMachineHoistedLocalScope>(capacity);
		}
	}

	/// <summary>
	/// Contains the state machine type
	/// </summary>
	public sealed class PdbStateMachineTypeNameCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.StateMachineTypeName"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.StateMachineTypeName; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return Guid.Empty; }
		}

		/// <summary>
		/// Gets/sets the state machine type
		/// </summary>
		public TypeDef Type { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbStateMachineTypeNameCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">State machine type</param>
		public PdbStateMachineTypeNameCustomDebugInfo(TypeDef type) {
			Type = type;
		}
	}

	/// <summary>
	/// Contains dynamic flags for local variables and constants
	/// </summary>
	public sealed class PdbDynamicLocalsCustomDebugInfo : PdbCustomDebugInfo {
		readonly ThreadSafe.IList<PdbDynamicLocal> locals;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.DynamicLocals"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.DynamicLocals; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return Guid.Empty; }
		}

		/// <summary>
		/// Gets the dynamic locals
		/// </summary>
		public ThreadSafe.IList<PdbDynamicLocal> Locals {
			get { return locals; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbDynamicLocalsCustomDebugInfo() {
			locals = ThreadSafeListCreator.Create<PdbDynamicLocal>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Locals"/></param>
		public PdbDynamicLocalsCustomDebugInfo(int capacity) {
			locals = ThreadSafeListCreator.Create<PdbDynamicLocal>(capacity);
		}
	}

	/// <summary>
	/// Dynamic local info
	/// </summary>
	public sealed class PdbDynamicLocal {
		readonly ThreadSafe.IList<byte> flags;
		string name;
		Local local;

		/// <summary>
		/// Gets the dynamic flags
		/// </summary>
		public ThreadSafe.IList<byte> Flags {
			get { return flags; }
		}

		/// <summary>
		/// Gets/sets the name of the local. The name must have at most 64 characters and no char can be NUL (0x0000).
		/// If null is written, <see cref="dnlib.DotNet.Emit.Local.Name"/> is returned instead.
		/// </summary>
		public string Name {
			get {
				var n = name;
				if (n != null)
					return n;
				var l = local;
				return l == null ? null : l.Name;
			}
			set { name = value; }
		}

		/// <summary>
		/// true if it's a constant and not a variable (<see cref="Local"/> is null)
		/// </summary>
		public bool IsConstant {
			get { return Local == null; }
		}

		/// <summary>
		/// true if it's a variable (<see cref="Local"/> is not null)
		/// </summary>
		public bool IsVariable {
			get { return Local != null; }
		}

		/// <summary>
		/// Gets/sets the local. Could be null if there's no local (it's a 'const' local).
		/// </summary>
		public Local Local {
			get { return local; }
			set { local = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbDynamicLocal() {
			flags = ThreadSafeListCreator.Create<byte>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Flags"/></param>
		public PdbDynamicLocal(int capacity) {
			flags = ThreadSafeListCreator.Create<byte>(capacity);
		}
	}

	/// <summary>
	/// Contains the EnC local variable slot map
	/// </summary>
	public sealed class PdbEditAndContinueLocalSlotMapCustomDebugInfo : PdbCustomDebugInfo {
		readonly byte[] data;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.EncLocalSlotMap; }
		}

		/// <summary>
		/// Gets the data. Spec: https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLocalSlotMap
		/// </summary>
		public byte[] Data {
			get { return data; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Raw custom debug info data</param>
		public PdbEditAndContinueLocalSlotMapCustomDebugInfo(byte[] data) {
			if (data == null)
				throw new ArgumentNullException("data");
			this.data = data;
		}
	}

	/// <summary>
	/// Contains the EnC lambda map
	/// </summary>
	public sealed class PdbEditAndContinueLambdaMapCustomDebugInfo : PdbCustomDebugInfo {
		readonly byte[] data;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.EditAndContinueLambdaMap"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.EditAndContinueLambdaMap; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.EncLambdaAndClosureMap; }
		}

		/// <summary>
		/// Gets the data. Spec: https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLambdaAndClosureMap
		/// </summary>
		public byte[] Data {
			get { return data; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Raw custom debug info data</param>
		public PdbEditAndContinueLambdaMapCustomDebugInfo(byte[] data) {
			if (data == null)
				throw new ArgumentNullException("data");
			this.data = data;
		}
	}

	/// <summary>
	/// Contains tuple element names for local variables and constants
	/// </summary>
	public sealed class PdbTupleElementNamesCustomDebugInfo : PdbCustomDebugInfo {
		readonly ThreadSafe.IList<PdbTupleElementNames> names;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.TupleElementNames"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.TupleElementNames; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return Guid.Empty; }
		}

		/// <summary>
		/// Gets the tuple element names
		/// </summary>
		public ThreadSafe.IList<PdbTupleElementNames> Names {
			get { return names; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbTupleElementNamesCustomDebugInfo() {
			names = ThreadSafeListCreator.Create<PdbTupleElementNames>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Names"/></param>
		public PdbTupleElementNamesCustomDebugInfo(int capacity) {
			names = ThreadSafeListCreator.Create<PdbTupleElementNames>(capacity);
		}
	}

	/// <summary>
	/// Tuple element name info
	/// </summary>
	public sealed class PdbTupleElementNames {
		readonly ThreadSafe.IList<string> tupleElementNames;
		string name;
		Local local;
		Instruction scopeStart, scopeEnd;

		/// <summary>
		/// Gets/sets the name of the local. If null is written, <see cref="dnlib.DotNet.Emit.Local.Name"/> is returned instead.
		/// </summary>
		public string Name {
			get {
				var n = name;
				if (n != null)
					return n;
				var l = local;
				return l == null ? null : l.Name;
			}
			set { name = value; }
		}

		/// <summary>
		/// Gets/sets the local. It's null if it's a constant, and non-null if it's a variable
		/// </summary>
		public Local Local {
			get { return local; }
			set { local = value; }
		}

		/// <summary>
		/// true if it's a constant. Constants have a scope (<see cref="ScopeStart"/> and <see cref="ScopeEnd"/>)
		/// </summary>
		public bool IsConstant {
			get { return local == null; }
		}

		/// <summary>
		/// true if it's a variable. Variables don't have a scope (<see cref="ScopeStart"/> and <see cref="ScopeEnd"/>)
		/// </summary>
		public bool IsVariable {
			get { return local != null; }
		}

		/// <summary>
		/// Gets/sets the start of the scope or null. Only constants have a scope.
		/// </summary>
		public Instruction ScopeStart {
			get { return scopeStart; }
			set { scopeStart = value; }
		}

		/// <summary>
		/// Gets/sets the end of the scope or null if it has no scope or if the scope ends at the end of the body. Only constants have a scope.
		/// </summary>
		public Instruction ScopeEnd {
			get { return scopeEnd; }
			set { scopeEnd = value; }
		}

		/// <summary>
		/// Gets the tuple element names
		/// </summary>
		public ThreadSafe.IList<string> TupleElementNames {
			get { return tupleElementNames; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbTupleElementNames() {
			tupleElementNames = ThreadSafeListCreator.Create<string>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="TupleElementNames"/></param>
		public PdbTupleElementNames(int capacity) {
			tupleElementNames = ThreadSafeListCreator.Create<string>(capacity);
		}
	}

	/// <summary>
	/// Contains tuple element names for local variables and constants
	/// </summary>
	public sealed class PortablePdbTupleElementNamesCustomDebugInfo : PdbCustomDebugInfo {
		readonly ThreadSafe.IList<string> names;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.TupleElementNames_PortablePdb"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.TupleElementNames_PortablePdb; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.TupleElementNames; }
		}

		/// <summary>
		/// Gets the tuple element names
		/// </summary>
		public ThreadSafe.IList<string> Names {
			get { return names; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PortablePdbTupleElementNamesCustomDebugInfo() {
			names = ThreadSafeListCreator.Create<string>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Names"/></param>
		public PortablePdbTupleElementNamesCustomDebugInfo(int capacity) {
			names = ThreadSafeListCreator.Create<string>(capacity);
		}
	}

	/// <summary>
	/// Async method stepping info
	/// 
	/// It's internal and translated to a <see cref="PdbAsyncMethodCustomDebugInfo"/>
	/// </summary>
	sealed class PdbAsyncMethodSteppingInformationCustomDebugInfo : PdbCustomDebugInfo {
		readonly ThreadSafe.IList<PdbAsyncStepInfo> asyncStepInfos;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.Unknown"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.Unknown; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.AsyncMethodSteppingInformationBlob; }
		}

		/// <summary>
		/// Gets the catch handler instruction or null
		/// </summary>
		public Instruction CatchHandler { get; set; }

		/// <summary>
		/// Gets all async step infos
		/// </summary>
		public ThreadSafe.IList<PdbAsyncStepInfo> AsyncStepInfos {
			get { return asyncStepInfos; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAsyncMethodSteppingInformationCustomDebugInfo() {
			asyncStepInfos = ThreadSafeListCreator.Create<PdbAsyncStepInfo>();
		}
	}

	/// <summary>
	/// Default namespace
	/// </summary>
	public sealed class PdbDefaultNamespaceCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.DefaultNamespace"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.DefaultNamespace; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.DefaultNamespace; }
		}

		/// <summary>
		/// Gets the default namespace
		/// </summary>
		public string Namespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbDefaultNamespaceCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="defaultNamespace">Default namespace</param>
		public PdbDefaultNamespaceCustomDebugInfo(string defaultNamespace) {
			Namespace = defaultNamespace;
		}
	}

	/// <summary>
	/// Dynamic flags
	/// </summary>
	public sealed class PdbDynamicLocalVariablesCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.DynamicLocalVariables"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.DynamicLocalVariables; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.DynamicLocalVariables; }
		}

		/// <summary>
		/// Gets/sets the dynamic flags
		/// </summary>
		public bool[] Flags { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbDynamicLocalVariablesCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Dynamic flags</param>
		public PdbDynamicLocalVariablesCustomDebugInfo(bool[] flags) {
			Flags = flags;
		}
	}

	/// <summary>
	/// Contains the source code
	/// </summary>
	public sealed class PdbEmbeddedSourceCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.EmbeddedSource"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.EmbeddedSource; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.EmbeddedSource; }
		}

		/// <summary>
		/// Gets the source code blob.
		/// 
		/// It's not decompressed and converted to a string because the encoding isn't specified.
		/// 
		/// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#embedded-source-c-and-vb-compilers
		/// </summary>
		public byte[] SourceCodeBlob { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbEmbeddedSourceCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sourceCodeBlob">Source code blob</param>
		public PdbEmbeddedSourceCustomDebugInfo(byte[] sourceCodeBlob) {
			SourceCodeBlob = sourceCodeBlob;
		}
	}

	/// <summary>
	/// Contains the source link file
	/// </summary>
	public sealed class PdbSourceLinkCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.SourceLink"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.SourceLink; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return CustomDebugInfoGuids.SourceLink; }
		}

		/// <summary>
		/// Gets the source link file contents
		/// </summary>
		public byte[] SourceLinkBlob { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbSourceLinkCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sourceLinkBlob">Source link file contents</param>
		public PdbSourceLinkCustomDebugInfo(byte[] sourceLinkBlob) {
			SourceLinkBlob = sourceLinkBlob;
		}
	}

	/// <summary>
	/// Async method info
	/// </summary>
	public sealed class PdbAsyncMethodCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.AsyncMethod"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.AsyncMethod; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return Guid.Empty; }
		}

		readonly ThreadSafe.IList<PdbAsyncStepInfo> asyncStepInfos;

		/// <summary>
		/// Gets/sets the starting method that initiates the async operation
		/// </summary>
		public MethodDef KickoffMethod { get; set; }

		/// <summary>
		/// Gets/sets the instruction for the compiler generated catch handler that wraps an async method.
		/// This can be null.
		/// </summary>
		public Instruction CatchHandlerInstruction { get; set; }

		/// <summary>
		/// Gets all step infos used by the debugger
		/// </summary>
		public ThreadSafe.IList<PdbAsyncStepInfo> StepInfos {
			get { return asyncStepInfos; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAsyncMethodCustomDebugInfo() {
			asyncStepInfos = ThreadSafeListCreator.Create<PdbAsyncStepInfo>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stepInfosCapacity">Default capacity for <see cref="StepInfos"/></param>
		public PdbAsyncMethodCustomDebugInfo(int stepInfosCapacity) {
			asyncStepInfos = ThreadSafeListCreator.Create<PdbAsyncStepInfo>(stepInfosCapacity);
		}
	}

	/// <summary>
	/// Async step info used by debuggers
	/// </summary>
	public struct PdbAsyncStepInfo {
		/// <summary>
		/// The yield instruction
		/// </summary>
		public Instruction YieldInstruction;

		/// <summary>
		/// Resume method
		/// </summary>
		public MethodDef BreakpointMethod;

		/// <summary>
		/// Resume instruction (where the debugger puts a breakpoint)
		/// </summary>
		public Instruction BreakpointInstruction;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="yieldInstruction">The yield instruction</param>
		/// <param name="breakpointMethod">Resume method</param>
		/// <param name="breakpointInstruction">Resume instruction (where the debugger puts a breakpoint)</param>
		public PdbAsyncStepInfo(Instruction yieldInstruction, MethodDef breakpointMethod, Instruction breakpointInstruction) {
			YieldInstruction = yieldInstruction;
			BreakpointMethod = breakpointMethod;
			BreakpointInstruction = breakpointInstruction;
		}
	}

	/// <summary>
	/// Iterator method
	/// </summary>
	public sealed class PdbIteratorMethodCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.IteratorMethod"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind {
			get { return PdbCustomDebugInfoKind.IteratorMethod; }
		}

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid {
			get { return Guid.Empty; }
		}

		/// <summary>
		/// Gets the kickoff method
		/// </summary>
		public MethodDef KickoffMethod { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbIteratorMethodCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="kickoffMethod">Kickoff method</param>
		public PdbIteratorMethodCustomDebugInfo(MethodDef kickoffMethod) {
			KickoffMethod = kickoffMethod;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbDocument.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A PDB document
	/// </summary>
	[DebuggerDisplay("{Url}")]
	public sealed class PdbDocument : IHasCustomDebugInformation {
		/// <summary>
		/// Gets/sets the document URL
		/// </summary>
		public string Url { get; set; }

		/// <summary>
		/// Gets/sets the language GUID. See <see cref="PdbDocumentConstants"/>
		/// </summary>
		public Guid Language { get; set; }

		/// <summary>
		/// Gets/sets the language vendor GUID. See <see cref="PdbDocumentConstants"/>
		/// </summary>
		public Guid LanguageVendor { get; set; }

		/// <summary>
		/// Gets/sets the document type GUID. See <see cref="PdbDocumentConstants"/>
		/// </summary>
		public Guid DocumentType { get; set; }

		/// <summary>
		/// Gets/sets the checksum algorithm ID. See <see cref="PdbDocumentConstants"/>
		/// </summary>
		public Guid CheckSumAlgorithmId { get; set; }

		/// <summary>
		/// Gets/sets the checksum
		/// </summary>
		public byte[] CheckSum { get; set; }

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 22; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get { return customDebugInfos; }
		}
		readonly ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();

		/// <summary>
		/// Default constructor
		/// </summary>
		public PdbDocument() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="symDoc">A <see cref="SymbolDocument"/> instance</param>
		public PdbDocument(SymbolDocument symDoc) {
			if (symDoc == null)
				throw new ArgumentNullException("symDoc");
			this.Url = symDoc.URL;
			this.Language = symDoc.Language;
			this.LanguageVendor = symDoc.LanguageVendor;
			this.DocumentType = symDoc.DocumentType;
			this.CheckSumAlgorithmId = symDoc.CheckSumAlgorithmId;
			this.CheckSum = symDoc.CheckSum;
			foreach (var cdi in symDoc.CustomDebugInfos)
				customDebugInfos.Add(cdi);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="url">Document URL</param>
		/// <param name="language">Language. See <see cref="PdbDocumentConstants"/></param>
		/// <param name="languageVendor">Language vendor. See <see cref="PdbDocumentConstants"/></param>
		/// <param name="documentType">Document type. See <see cref="PdbDocumentConstants"/></param>
		/// <param name="checkSumAlgorithmId">Checksum algorithm ID. See <see cref="PdbDocumentConstants"/></param>
		/// <param name="checkSum">Checksum</param>
		public PdbDocument(string url, Guid language, Guid languageVendor, Guid documentType, Guid checkSumAlgorithmId, byte[] checkSum) {
			this.Url = url;
			this.Language = language;
			this.LanguageVendor = languageVendor;
			this.DocumentType = documentType;
			this.CheckSumAlgorithmId = checkSumAlgorithmId;
			this.CheckSum = checkSum;
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			return (Url ?? string.Empty).ToUpperInvariant().GetHashCode();
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			var other = obj as PdbDocument;
			if (other == null)
				return false;
			return (Url ?? string.Empty).Equals(other.Url ?? string.Empty, StringComparison.OrdinalIgnoreCase);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbDocumentConstants.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB document constants
	/// </summary>
	public static class PdbDocumentConstants {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		public static readonly Guid LanguageCSharp = new Guid("3F5162F8-07C6-11D3-9053-00C04FA302A1");
		public static readonly Guid LanguageVisualBasic = new Guid("3A12D0B8-C26C-11D0-B442-00A0244A1DD2");
		public static readonly Guid LanguageFSharp = new Guid("AB4F38C9-B6E6-43BA-BE3B-58080B2CCCE3");

		public static readonly Guid HashSHA1 = new Guid("FF1816EC-AA5E-4D10-87F7-6F4963833460");
		public static readonly Guid HashSHA256 = new Guid("8829D00F-11B8-4213-878B-770E8597AC16");

		public static readonly Guid LanguageVendorMicrosoft = new Guid("994B45C4-E6E9-11D2-903F-00C04FA302A1");

		public static readonly Guid DocumentTypeText = new Guid("5A869D0B-6611-11D3-BD2A-0000F80849BD");
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbFileKind.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB file kind
	/// </summary>
	public enum PdbFileKind {
		/// <summary>
		/// Windows PDB
		/// </summary>
		WindowsPDB,

		/// <summary>
		/// Portable PDB
		/// </summary>
		PortablePDB,

		/// <summary>
		/// Embedded portable PDB
		/// </summary>
		EmbeddedPortablePDB,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbImplType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB implementation type
	/// </summary>
	public enum PdbImplType {
		/// <summary>
		/// Use Microsoft's COM DLL (diasymreader.dll). It's not recommended to use this reader since it can only be accessed on the COM thread.
		/// 
		/// This reader can only read the old PDB files (aka Windows PDB files). It does not support portable PDB files.
		/// </summary>
		MicrosoftCOM,

		/// <summary>
		/// Use the managed PDB reader. It supports Windows PDB files and portable PDB files and is the default PDB reader.
		/// </summary>
		Managed,

		/// <summary>
		/// Use the default PDB reader
		/// </summary>
		Default = Managed,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbImport.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Diagnostics;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Import scope
	/// </summary>
	public sealed class PdbImportScope : IHasCustomDebugInformation {
		readonly ThreadSafe.IList<PdbImport> imports = ThreadSafeListCreator.Create<PdbImport>();

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportScope() {
		}

		/// <summary>
		/// Gets/sets the parent import scope
		/// </summary>
		public PdbImportScope Parent { get; set; }

		/// <summary>
		/// Gets all imports
		/// </summary>
		public ThreadSafe.IList<PdbImport> Imports {
			get { return imports; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Imports"/> is not empty
		/// </summary>
		public bool HasImports {
			get { return imports.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 26; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get { return customDebugInfos; }
		}
		readonly ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
	}

	/// <summary>
	/// Import kind
	/// </summary>
	public enum PdbImportDefinitionKind {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		ImportNamespace,
		ImportAssemblyNamespace,
		ImportType,
		ImportXmlNamespace,
		ImportAssemblyReferenceAlias,
		AliasAssemblyReference,
		AliasNamespace,
		AliasAssemblyNamespace,
		AliasType,
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}

	/// <summary>
	/// PDB import base class
	/// </summary>
	public abstract class PdbImport {
		/// <summary>
		/// Gets the import kind
		/// </summary>
		public abstract PdbImportDefinitionKind Kind { get; }

		internal abstract void PreventNewClasses();
	}

	/// <summary>
	/// Import namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.ImportNamespace; }
		}

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="targetNamespace"></param>
		public PdbImportNamespace(string targetNamespace) {
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1}", Kind, TargetNamespace);
		}
	}

	/// <summary>
	/// Import assembly, namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportAssemblyNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportAssemblyNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.ImportAssemblyNamespace; }
		}

		/// <summary>
		/// Gets the target assembly
		/// </summary>
		public AssemblyRef TargetAssembly { get; set; }

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportAssemblyNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="targetAssembly"></param>
		/// <param name="targetNamespace"></param>
		public PdbImportAssemblyNamespace(AssemblyRef targetAssembly, string targetNamespace) {
			TargetAssembly = targetAssembly;
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1} {2}", Kind, TargetAssembly, TargetNamespace);
		}
	}

	/// <summary>
	/// Import type
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportType : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportType"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.ImportType; }
		}

		/// <summary>
		/// Gets the target type
		/// </summary>
		public ITypeDefOrRef TargetType { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportType() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="targetType"></param>
		public PdbImportType(ITypeDefOrRef targetType) {
			TargetType = targetType;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1}", Kind, TargetType);
		}
	}

	/// <summary>
	/// Import xml namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportXmlNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportXmlNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.ImportXmlNamespace; }
		}

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportXmlNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetNamespace"></param>
		public PdbImportXmlNamespace(string alias, string targetNamespace) {
			Alias = alias;
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1} = {2}", Kind, Alias, TargetNamespace);
		}
	}

	/// <summary>
	/// Import assembly reference alias
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportAssemblyReferenceAlias : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportAssemblyReferenceAlias"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.ImportAssemblyReferenceAlias; }
		}

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportAssemblyReferenceAlias() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		public PdbImportAssemblyReferenceAlias(string alias) {
			Alias = alias;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1}", Kind, Alias);
		}
	}

	/// <summary>
	/// Alias assembly reference
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbAliasAssemblyReference : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.AliasAssemblyReference"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.AliasAssemblyReference; }
		}

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target assembly
		/// </summary>
		public AssemblyRef TargetAssembly { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAliasAssemblyReference() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetAssembly"></param>
		public PdbAliasAssemblyReference(string alias, AssemblyRef targetAssembly) {
			Alias = alias;
			TargetAssembly = targetAssembly;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1} = {2}", Kind, Alias, TargetAssembly);
		}
	}

	/// <summary>
	/// Alias namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbAliasNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.AliasNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.AliasNamespace; }
		}

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAliasNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetNamespace"></param>
		public PdbAliasNamespace(string alias, string targetNamespace) {
			Alias = alias;
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1} = {2}", Kind, Alias, TargetNamespace);
		}
	}

	/// <summary>
	/// Alias assembly namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbAliasAssemblyNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.AliasAssemblyNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.AliasAssemblyNamespace; }
		}

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target assembly
		/// </summary>
		public AssemblyRef TargetAssembly { get; set; }

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAliasAssemblyNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetAssembly"></param>
		/// <param name="targetNamespace"></param>
		public PdbAliasAssemblyNamespace(string alias, AssemblyRef targetAssembly, string targetNamespace) {
			Alias = alias;
			TargetAssembly = targetAssembly;
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1} = {2} {3}", Kind, Alias, TargetAssembly, TargetNamespace);
		}
	}

	/// <summary>
	/// Alias type
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbAliasType : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.AliasType"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind {
			get { return PdbImportDefinitionKind.AliasType; }
		}

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target type
		/// </summary>
		public ITypeDefOrRef TargetType { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAliasType() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetType"></param>
		public PdbAliasType(string alias, ITypeDefOrRef targetType) {
			Alias = alias;
			TargetType = targetType;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() {
			return string.Format("{0}: {1} = {2}", Kind, Alias, TargetType);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbLocal.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.DotNet.Emit;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A local variable
	/// </summary>
	public sealed class PdbLocal : IHasCustomDebugInformation {
		/// <summary>
		/// Constructor
		/// </summary>
		public PdbLocal() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="local"></param>
		/// <param name="name"></param>
		/// <param name="attributes"></param>
		public PdbLocal(Local local, string name, PdbLocalAttributes attributes) {
			Local = local;
			Name = name;
			Attributes = attributes;
		}

		/// <summary>
		/// Gets/sets the local
		/// </summary>
		public Local Local { get; set; }

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// Gets/sets the attributes
		/// </summary>
		public PdbLocalAttributes Attributes { get; set; }

		/// <summary>
		/// Gets the index of the local
		/// </summary>
		public int Index {
			get { return Local.Index; }
		}

		/// <summary>
		/// true if it should be hidden in debugger variables windows. Not all compiler generated locals have this flag set.
		/// </summary>
		public bool IsDebuggerHidden {
			get { return (Attributes & PdbLocalAttributes.DebuggerHidden) != 0; }
			set {
				if (value)
					Attributes |= PdbLocalAttributes.DebuggerHidden;
				else
					Attributes &= ~PdbLocalAttributes.DebuggerHidden;
			}
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 24; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get { return customDebugInfos; }
		}
		readonly ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbLocalAttributes.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Local attributes
	/// </summary>
	[Flags]
	public enum PdbLocalAttributes {
		/// <summary>
		/// No bit is set
		/// </summary>
		None					= 0,

		/// <summary>
		/// Local should be hidden in debugger variables windows. Not all compiler generated locals have this flag set.
		/// </summary>
		DebuggerHidden			= 0x00000001,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbMethod.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A PDB method
	/// </summary>
	public sealed class PdbMethod {
		/// <summary>
		/// Gets/sets the root scope. It contains all scopes of the method, using namespaces, variables and constants
		/// </summary>
		public PdbScope Scope { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbMethod() {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbScope.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Diagnostics;
using dnlib.DotNet.Emit;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A PDB scope
	/// </summary>
	[DebuggerDisplay("{Start} - {End}")]
	public sealed class PdbScope : IHasCustomDebugInformation {
		readonly ThreadSafe.IList<PdbScope> scopes = ThreadSafeListCreator.Create<PdbScope>();
		readonly ThreadSafe.IList<PdbLocal> locals = ThreadSafeListCreator.Create<PdbLocal>();
		readonly ThreadSafe.IList<string> namespaces = ThreadSafeListCreator.Create<string>();
		readonly ThreadSafe.IList<PdbConstant> constants = ThreadSafeListCreator.Create<PdbConstant>();

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbScope() {
		}

		/// <summary>
		/// Gets/sets the first instruction
		/// </summary>
		public Instruction Start { get; set; }

		/// <summary>
		/// Gets/sets the last instruction. It's <c>null</c> if it ends at the end of the method.
		/// </summary>
		public Instruction End { get; set; }

		/// <summary>
		/// Gets all child scopes
		/// </summary>
		public ThreadSafe.IList<PdbScope> Scopes {
			get { return scopes; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Scopes"/> is not empty
		/// </summary>
		public bool HasScopes {
			get { return scopes.Count > 0; }
		}

		/// <summary>
		/// Gets all locals in this scope
		/// </summary>
		public ThreadSafe.IList<PdbLocal> Variables {
			get { return locals; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Variables"/> is not empty
		/// </summary>
		public bool HasVariables {
			get { return locals.Count > 0; }
		}

		/// <summary>
		/// Gets all namespaces (Windows PDBs). Portable PDBs use <see cref="ImportScope"/>
		/// </summary>
		public ThreadSafe.IList<string> Namespaces {
			get { return namespaces; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Namespaces"/> is not empty
		/// </summary>
		public bool HasNamespaces {
			get { return namespaces.Count > 0; }
		}

		/// <summary>
		/// Gets/sets the import scope (Portable PDBs). Windows PDBs use <see cref="Namespaces"/>
		/// </summary>
		public PdbImportScope ImportScope { get; set; }

		/// <summary>
		/// Gets all constants
		/// </summary>
		public ThreadSafe.IList<PdbConstant> Constants {
			get { return constants; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Constants"/> is not empty
		/// </summary>
		public bool HasConstants {
			get { return constants.Count > 0; }
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag {
			get { return 23; }
		}

		/// <inheritdoc/>
		public bool HasCustomDebugInfos {
			get { return CustomDebugInfos.Count > 0; }
		}

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public ThreadSafe.IList<PdbCustomDebugInfo> CustomDebugInfos {
			get { return customDebugInfos; }
		}
		readonly ThreadSafe.IList<PdbCustomDebugInfo> customDebugInfos = ThreadSafeListCreator.Create<PdbCustomDebugInfo>();
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/PdbState.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.Threading;

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB state for a <see cref="ModuleDef"/>
	/// </summary>
	public sealed class PdbState {
		readonly SymbolReader reader;
		readonly Dictionary<PdbDocument, PdbDocument> docDict = new Dictionary<PdbDocument, PdbDocument>();
		MethodDef userEntryPoint;
		readonly Compiler compiler;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Gets/sets the PDB file kind. You can change it from portable PDB to embedded portable PDB
		/// and vice versa. Converting a Windows PDB to a portable PDB isn't supported.
		/// </summary>
		public PdbFileKind PdbFileKind { get; set; }

		/// <summary>
		/// Gets/sets the user entry point method.
		/// </summary>
		public MethodDef UserEntryPoint {
			get { return userEntryPoint; }
			set { userEntryPoint = value; }
		}

		/// <summary>
		/// Gets all PDB documents
		/// </summary>
		public IEnumerable<PdbDocument> Documents {
			get {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
					return new List<PdbDocument>(docDict.Values);
				} finally { theLock.ExitWriteLock(); }
#else
				return docDict.Values;
#endif
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="Documents"/> is not empty
		/// </summary>
		public bool HasDocuments {
			get {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				return docDict.Count > 0;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
		
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="pdbFileKind">PDB file kind</param>
		public PdbState(ModuleDef module, PdbFileKind pdbFileKind) {
			if (module == null)
				throw new ArgumentNullException("module");
			this.compiler = CalculateCompiler(module);
			PdbFileKind = pdbFileKind;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">A <see cref="SymbolReader"/> instance</param>
		/// <param name="module">Owner module</param>
		public PdbState(SymbolReader reader, ModuleDefMD module) {
			if (reader == null)
				throw new ArgumentNullException("reader");
			if (module == null)
				throw new ArgumentNullException("module");
			this.reader = reader;
			reader.Initialize(module);
			PdbFileKind = reader.PdbFileKind;
			this.compiler = CalculateCompiler(module);

			this.userEntryPoint = module.ResolveToken(reader.UserEntryPoint) as MethodDef;

			foreach (var doc in reader.Documents)
				Add_NoLock(new PdbDocument(doc));
		}

		/// <summary>
		/// Adds <paramref name="doc"/>
		/// </summary>
		/// <param name="doc">New document</param>
		/// <returns><paramref name="doc"/> if it wasn't inserted, or the already existing document
		/// if it was already inserted.</returns>
		public PdbDocument Add(PdbDocument doc) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return Add_NoLock(doc);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		PdbDocument Add_NoLock(PdbDocument doc) {
			PdbDocument orig;
			if (docDict.TryGetValue(doc, out orig))
				return orig;
			docDict.Add(doc, doc);
			return doc;
		}

		/// <summary>
		/// Removes <paramref name="doc"/>
		/// </summary>
		/// <param name="doc">Document</param>
		/// <returns><c>true</c> if it was removed, <c>false</c> if it wasn't inserted.</returns>
		public bool Remove(PdbDocument doc) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return docDict.Remove(doc);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Returns an inserted <see cref="PdbDocument"/> instance or <c>null</c> if it's not been
		/// inserted yet.
		/// </summary>
		/// <param name="doc">A PDB document</param>
		/// <returns>The existing <see cref="PdbDocument"/> or <c>null</c> if it doesn't exist.</returns>
		public PdbDocument GetExisting(PdbDocument doc) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			PdbDocument orig;
			docDict.TryGetValue(doc, out orig);
			return orig;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Removes all documents
		/// </summary>
		/// <returns></returns>
		public void RemoveAllDocuments() {
			RemoveAllDocuments(false);
		}

		/// <summary>
		/// Removes all documents and optionally returns them
		/// </summary>
		/// <param name="returnDocs"><c>true</c> if all the original <see cref="PdbDocument"/>s
		/// should be returned.</param>
		/// <returns>All <see cref="PdbDocument"/>s if <paramref name="returnDocs"/> is <c>true</c>
		/// or <c>null</c> if <paramref name="returnDocs"/> is <c>false</c>.</returns>
		public List<PdbDocument> RemoveAllDocuments(bool returnDocs) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var docs = returnDocs ? new List<PdbDocument>(docDict.Values) : null;
			docDict.Clear();
			return docs;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal Compiler Compiler {
			get { return compiler; }
		}

		internal void InitializeMethodBody(ModuleDefMD module, MethodDef ownerMethod, CilBody body) {
			if (reader == null)
				return;

			var method = reader.GetMethod(ownerMethod, 1);
			if (method != null) {
				var pdbMethod = new PdbMethod();
				pdbMethod.Scope = CreateScope(module, GenericParamContext.Create(ownerMethod), body, method.RootScope);
				AddSequencePoints(body, method);
				body.PdbMethod = pdbMethod;
			}
		}

		internal void InitializeCustomDebugInfos(MethodDef ownerMethod, CilBody body, IList<PdbCustomDebugInfo> customDebugInfos) {
			if (reader == null)
				return;

			var method = reader.GetMethod(ownerMethod, 1);
			if (method != null)
				method.GetCustomDebugInfos(ownerMethod, body, customDebugInfos);
		}

		static Compiler CalculateCompiler(ModuleDef module) {
			if (module == null)
				return Compiler.Other;

			foreach (var asmRef in module.GetAssemblyRefs()) {
				if (asmRef.Name == nameAssemblyVisualBasic)
					return Compiler.VisualBasic;
			}

			// The VB runtime can also be embedded, and if so, it seems that "Microsoft.VisualBasic.Embedded"
			// attribute is added to the assembly's custom attributes.
			var asm = module.Assembly;
			if (asm != null && asm.CustomAttributes.IsDefined("Microsoft.VisualBasic.Embedded"))
				return Compiler.VisualBasic;

			return Compiler.Other;
		}
		static readonly UTF8String nameAssemblyVisualBasic = new UTF8String("Microsoft.VisualBasic");

		void AddSequencePoints(CilBody body, SymbolMethod method) {
			int instrIndex = 0;
			foreach (var sp in method.SequencePoints) {
				var instr = GetInstruction(body.Instructions, sp.Offset, ref instrIndex);
				if (instr == null)
					continue;
				var seqPoint = new SequencePoint() {
					Document = Add_NoLock(new PdbDocument(sp.Document)),
					StartLine = sp.Line,
					StartColumn = sp.Column,
					EndLine = sp.EndLine,
					EndColumn = sp.EndColumn,
				};
				instr.SequencePoint = seqPoint;
			}
		}

		struct CreateScopeState {
			public SymbolScope SymScope;
			public PdbScope PdbScope;
			public IList<SymbolScope> Children;
			public int ChildrenIndex;
		}

		PdbScope CreateScope(ModuleDefMD module, GenericParamContext gpContext, CilBody body, SymbolScope symScope) {
			if (symScope == null)
				return null;

			// Don't use recursive calls
			var stack = new Stack<CreateScopeState>();
			var state = new CreateScopeState() { SymScope = symScope };
recursive_call:
			int instrIndex = 0;
			int endIsInclusiveValue = Compiler == Compiler.VisualBasic ? 1 : 0;
			state.PdbScope = new PdbScope() {
				Start = GetInstruction(body.Instructions, state.SymScope.StartOffset, ref instrIndex),
				End   = GetInstruction(body.Instructions, state.SymScope.EndOffset + endIsInclusiveValue, ref instrIndex),
			};
			foreach (var cdi in state.SymScope.CustomDebugInfos)
				state.PdbScope.CustomDebugInfos.Add(cdi);

			foreach (var symLocal in state.SymScope.Locals) {
				int localIndex = symLocal.Index;
				if ((uint)localIndex >= (uint)body.Variables.Count) {
					// VB sometimes creates a PDB local without a metadata local
					continue;
				}
				var local = body.Variables[localIndex];
				var name = symLocal.Name;
				local.SetName(name);
				var attributes = symLocal.Attributes;
				local.SetAttributes(attributes);
				var pdbLocal = new PdbLocal(local, name, attributes);
				foreach (var cdi in symLocal.CustomDebugInfos)
					pdbLocal.CustomDebugInfos.Add(cdi);
				state.PdbScope.Variables.Add(pdbLocal);
			}

			foreach (var ns in state.SymScope.Namespaces)
				state.PdbScope.Namespaces.Add(ns.Name);
			state.PdbScope.ImportScope = state.SymScope.ImportScope;

			var constants = state.SymScope.GetConstants(module, gpContext);
			for (int i = 0; i < constants.Count; i++) {
				var constant = constants[i];
				var type = constant.Type.RemovePinnedAndModifiers();
				if (type != null) {
					// Fix a few values since they're stored as some other type in the PDB
					switch (type.ElementType) {
					case ElementType.Boolean:
						if (constant.Value is short)
							constant.Value = (short)constant.Value != 0;
						break;
					case ElementType.Char:
						if (constant.Value is ushort)
							constant.Value = (char)(ushort)constant.Value;
						break;
					case ElementType.I1:
						if (constant.Value is short)
							constant.Value = (sbyte)(short)constant.Value;
						break;
					case ElementType.U1:
						if (constant.Value is short)
							constant.Value = (byte)(short)constant.Value;
						break;
					case ElementType.I2:
					case ElementType.U2:
					case ElementType.I4:
					case ElementType.U4:
					case ElementType.I8:
					case ElementType.U8:
					case ElementType.R4:
					case ElementType.R8:
					case ElementType.Void:
					case ElementType.Ptr:
					case ElementType.ByRef:
					case ElementType.TypedByRef:
					case ElementType.I:
					case ElementType.U:
					case ElementType.FnPtr:
					case ElementType.ValueType:
						break;
					case ElementType.String:
						if (PdbFileKind == PdbFileKind.WindowsPDB) {
							// "" is stored as null, and null is stored as (int)0
							if (constant.Value is int && (int)constant.Value == 0)
								constant.Value = null;
							else if (constant.Value == null)
								constant.Value = string.Empty;
						}
						else
							Debug.Assert(PdbFileKind == PdbFileKind.PortablePDB || PdbFileKind == PdbFileKind.EmbeddedPortablePDB);
						break;
					case ElementType.Object:
					case ElementType.Class:
					case ElementType.SZArray:
					case ElementType.Array:
					default:
						if (constant.Value is int && (int)constant.Value == 0)
							constant.Value = null;
						break;
					case ElementType.GenericInst:
						var gis = (GenericInstSig)type;
						if (gis.GenericType is ValueTypeSig)
							break;
						goto case ElementType.Class;
					case ElementType.Var:
					case ElementType.MVar:
						var gp = ((GenericSig)type).GenericParam;
						if (gp != null) {
							if (gp.HasNotNullableValueTypeConstraint)
								break;
							if (gp.HasReferenceTypeConstraint)
								goto case ElementType.Class;
						}
						break;
					}
				}
				state.PdbScope.Constants.Add(constant);
			}

			// Here's the now somewhat obfuscated for loop
			state.ChildrenIndex = 0;
			state.Children = state.SymScope.Children;
do_return:
			if (state.ChildrenIndex < state.Children.Count) {
				var child = state.Children[state.ChildrenIndex];
				stack.Push(state);
				state = new CreateScopeState() { SymScope = child };
				goto recursive_call;
			}

			if (stack.Count == 0)
				return state.PdbScope;

			// Return from recursive call, and execute the last part of the for loop
			var newPdbScope = state.PdbScope;
			state = stack.Pop();
			state.PdbScope.Scopes.Add(newPdbScope);
			state.ChildrenIndex++;
			goto do_return;
		}

		static Instruction GetInstruction(IList<Instruction> instrs, int offset, ref int index) {
			if (instrs.Count > 0 && offset > instrs[instrs.Count - 1].Offset)
				return null;
			for (int i = index; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.Offset < offset)
					continue;
				if (instr.Offset == offset) {
					index = i;
					return instr;
				}
				break;
			}
			for (int i = 0; i < index; i++) {
				var instr = instrs[i];
				if (instr.Offset < offset)
					continue;
				if (instr.Offset == offset) {
					index = i;
					return instr;
				}
				break;
			}
			return null;
		}

		internal void InitializeCustomDebugInfos(MDToken token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
			Debug.Assert(token.Table != Table.Method, "Methods get initialized when reading the method bodies");
			if (reader != null)
				reader.GetCustomDebugInfos(token.ToInt32(), gpContext, result);
		}

		internal void Dispose() {
			if (reader != null)
				reader.Dispose();
		}
	}

	enum Compiler {
		Other,
		VisualBasic,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/SequencePoint.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Diagnostics;

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB sequence point
	/// </summary>
	[DebuggerDisplay("({StartLine}, {StartColumn}) - ({EndLine}, {EndColumn}) {Document.Url}")]
	public sealed class SequencePoint {
		/// <summary>
		/// PDB document
		/// </summary>
		public PdbDocument Document { get; set; }

		/// <summary>
		/// Start line
		/// </summary>
		public int StartLine { get; set; }

		/// <summary>
		/// Start column
		/// </summary>
		public int StartColumn { get; set; }

		/// <summary>
		/// End line
		/// </summary>
		public int EndLine { get; set; }

		/// <summary>
		/// End column
		/// </summary>
		public int EndColumn { get; set; }

		/// <summary>
		/// Clones this instance
		/// </summary>
		/// <returns>A new cloned instance</returns>
		public SequencePoint Clone() {
			return new SequencePoint() {
				Document = Document,
				StartLine = StartLine,
				StartColumn = StartColumn,
				EndLine = EndLine,
				EndColumn = EndColumn,
			};
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/SymbolReaderCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Creates a <see cref="SymbolReader"/> instance
	/// </summary>
	public static class SymbolReaderCreator {
		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="pdbImpl">PDB implementation to use</param>
		/// <param name="metaData">.NET metadata</param>
		/// <param name="assemblyFileName">Path to assembly</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if there's no PDB
		/// file on disk or if it's not possible to create a <see cref="SymbolReader"/>.</returns>
		public static SymbolReader CreateFromAssemblyFile(PdbImplType pdbImpl, IMetaData metaData, string assemblyFileName) {
			switch (pdbImpl) {
			case PdbImplType.MicrosoftCOM:
				return Dss.SymbolReaderCreator.CreateFromAssemblyFile(assemblyFileName);

			case PdbImplType.Managed:
				return ManagedSymbolReaderCreator.CreateFromAssemblyFile(metaData, assemblyFileName);

			default: throw new InvalidOperationException();
			}
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="pdbImpl">PDB implementation to use</param>
		/// <param name="metaData">.NET metadata</param>
		/// <param name="pdbFileName">Path to PDB file</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if there's no PDB
		/// file on disk or if it's not possible to create a <see cref="SymbolReader"/>.</returns>
		public static SymbolReader Create(PdbImplType pdbImpl, IMetaData metaData, string pdbFileName) {
			switch (pdbImpl) {
			case PdbImplType.MicrosoftCOM:
				return Dss.SymbolReaderCreator.Create(metaData, pdbFileName);

			case PdbImplType.Managed:
				return ManagedSymbolReaderCreator.Create(metaData, pdbFileName);

			default: throw new InvalidOperationException();
			}
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="pdbImpl">PDB implementation to use</param>
		/// <param name="metaData">.NET metadata</param>
		/// <param name="pdbData">PDB file data</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if it's not possible
		/// to create a <see cref="SymbolReader"/>.</returns>
		public static SymbolReader Create(PdbImplType pdbImpl, IMetaData metaData, byte[] pdbData) {
			switch (pdbImpl) {
			case PdbImplType.MicrosoftCOM:
				return Dss.SymbolReaderCreator.Create(metaData, pdbData);

			case PdbImplType.Managed:
				return ManagedSymbolReaderCreator.Create(metaData, pdbData);

			default: throw new InvalidOperationException();
			}
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="pdbImpl">PDB implementation to use</param>
		/// <param name="metaData">.NET metadata</param>
		/// <param name="pdbStream">PDB file stream which is now owned by us</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if it's not possible
		/// to create a <see cref="SymbolReader"/>.</returns>
		public static SymbolReader Create(PdbImplType pdbImpl, IMetaData metaData, IImageStream pdbStream) {
			switch (pdbImpl) {
			case PdbImplType.MicrosoftCOM:
				return Dss.SymbolReaderCreator.Create(metaData, pdbStream);

			case PdbImplType.Managed:
				return ManagedSymbolReaderCreator.Create(metaData, pdbStream);

			default:
				if (pdbStream != null)
					pdbStream.Dispose();
				throw new InvalidOperationException();
			}
		}

		internal static SymbolReader Create(PdbImplType pdbImpl, IMetaData metaData) {
			switch (pdbImpl) {
			case PdbImplType.MicrosoftCOM:
				return null;

			case PdbImplType.Managed:
				return ManagedSymbolReaderCreator.Create(metaData);

			default:
				throw new InvalidOperationException();
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/ComInterfaces.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;

// Dss = Diagnostics Symbol Store = http://msdn.microsoft.com/en-us/library/ms404519.aspx
namespace dnlib.DotNet.Pdb.Dss {
	[ComVisible(true),
	ComImport,
	Guid("809C652E-7396-11D2-9771-00A0C9B4D50C"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface IMetaDataDispenser {
		void DefineScope([In] ref Guid rclsid, [In] uint dwCreateFlags, [In] ref Guid riid, [Out, MarshalAs(UnmanagedType.IUnknown)] out object ppIUnk);
		void OpenScope([In, MarshalAs(UnmanagedType.LPWStr)] string szScope, [In] uint dwOpenFlags, [In] ref Guid riid, [Out, MarshalAs(UnmanagedType.IUnknown)] out object ppIUnk);
		void OpenScopeOnMemory([In] IntPtr pData, [In] uint cbData, [In] uint dwOpenFlags, [In] ref Guid riid, [Out, MarshalAs(UnmanagedType.IUnknown)] out object ppIUnk);
	}

	[ComVisible(true),
	ComImport,
	Guid("AA544D42-28CB-11D3-BD22-0000F80849BD"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedBinder {
		[PreserveSig]
		int GetReaderForFile([In, MarshalAs(UnmanagedType.IUnknown)] object importer, [In, MarshalAs(UnmanagedType.LPWStr)] string fileName, [In, MarshalAs(UnmanagedType.LPWStr)] string searchPath, [Out] out ISymUnmanagedReader pRetVal);
		[PreserveSig]
		int GetReaderFromStream([In, MarshalAs(UnmanagedType.IUnknown)] object importer, [In] IStream pstream, [Out] out ISymUnmanagedReader pRetVal);
	}

	[ComVisible(true),
	ComImport,
	Guid("B4CE6286-2A6B-3712-A3B7-1EE1DAD467B5"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedReader {
		void GetDocument([In, MarshalAs(UnmanagedType.LPWStr)] string url, [In] Guid language, [In] Guid languageVendor, [In] Guid documentType, [Out] out ISymUnmanagedDocument pRetVal);
		void GetDocuments([In] uint cDocs, [Out] out uint pcDocs, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedDocument[] pDocs);
		[PreserveSig]
		int GetUserEntryPoint([Out] out uint pToken);
		[PreserveSig]
		int GetMethod([In] uint token, [Out] out ISymUnmanagedMethod retVal);
		[PreserveSig]
		int GetMethodByVersion([In] uint token, [In] int version, [Out] out ISymUnmanagedMethod pRetVal);
		void GetVariables([In] uint parent, [In] uint cVars, [Out] out uint pcVars, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] ISymUnmanagedVariable[] pVars);
		void GetGlobalVariables([In] uint cVars, [Out] out uint pcVars, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] pVars);
		[PreserveSig]
		int GetMethodFromDocumentPosition([In] ISymUnmanagedDocument document, [In] uint line, [In] uint column, [Out] out ISymUnmanagedMethod pRetVal);
		void GetSymAttribute([In] uint parent, [In, MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint cBuffer, [Out] out uint pcBuffer, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] buffer);
		void GetNamespaces([In] uint cNameSpaces, [Out] out uint pcNameSpaces, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedNamespace[] namespaces);
		void Initialize([In, MarshalAs(UnmanagedType.IUnknown)] object importer, [In, MarshalAs(UnmanagedType.LPWStr)] string filename, [In, MarshalAs(UnmanagedType.LPWStr)] string searchPath, [In] IStream pIStream);
		void UpdateSymbolStore([In, MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream);
		void ReplaceSymbolStore([In, MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream);
		void GetSymbolStoreFileName([In] uint cchName, [Out] out uint pcchName, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szName);
		void GetMethodsFromDocumentPosition([In] ISymUnmanagedDocument document, [In] uint line, [In] uint column, [In] uint cMethod, [Out] out uint pcMethod, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] ISymUnmanagedMethod[] pRetVal);
		void GetDocumentVersion([In] ISymUnmanagedDocument pDoc, [Out] out int version, [Out] out bool pbCurrent);
		void GetMethodVersion([In] ISymUnmanagedMethod pMethod, [Out] out int version);
	}

	[ComVisible(true),
	ComImport,
	Guid("40DE4037-7C81-3E1E-B022-AE1ABFF2CA08"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedDocument {
		void GetURL([In] uint cchUrl, [Out] out uint pcchUrl, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szUrl);
		void GetDocumentType([Out] out Guid pRetVal);
		void GetLanguage([Out] out Guid pRetVal);
		void GetLanguageVendor([Out] out Guid pRetVal);
		void GetCheckSumAlgorithmId([Out] out Guid pRetVal);
		void GetCheckSum([In] uint cData, [Out] out uint pcData, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] data);
		void FindClosestLine([In] uint line, [Out] out uint pRetVal);
		void HasEmbeddedSource([Out] out bool pRetVal);
		void GetSourceLength([Out] out uint pRetVal);
		void GetSourceRange([In] uint startLine, [In] uint startColumn, [In] uint endLine, [In] uint endColumn, [In] uint cSourceBytes, [Out] out uint pcSourceBytes, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] byte[] source);
	}

	[ComVisible(true),
	ComImport,
	Guid("B62B923C-B500-3158-A543-24F307A8B7E1"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedMethod {
		void GetToken([Out] out uint pToken);
		void GetSequencePointCount([Out] out uint pRetVal);
		void GetRootScope([Out] out ISymUnmanagedScope pRetVal);
		void GetScopeFromOffset([In] uint offset, [Out] out ISymUnmanagedScope pRetVal);
		void GetOffset([In] ISymUnmanagedDocument document, [In] uint line, [In] uint column, [Out] out uint pRetVal);
		void GetRanges([In] ISymUnmanagedDocument document, [In] uint line, [In] uint column, [In] uint cRanges, [Out] out uint pcRanges, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] int[] ranges);
		void GetParameters([In] uint cParams, [Out] out uint pcParams, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] parameters);
		void GetNamespace([Out] out ISymUnmanagedNamespace pRetVal);
		void GetSourceStartEnd([In] ISymUnmanagedDocument[/*2*/] docs, [In] int[/*2*/] lines, [In] int[/*2*/] columns, [Out] out bool pRetVal);
		void GetSequencePoints([In] uint cPoints, [Out] out uint pcPoints, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] offsets, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedDocument[] documents, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] lines, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] columns, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] endLines, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] endColumns);
	}

	[ComVisible(true),
	ComImport,
	Guid("B20D55B3-532E-4906-87E7-25BD5734ABD2"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedAsyncMethod {
		bool IsAsyncMethod();
		uint GetKickoffMethod();
		bool HasCatchHandlerILOffset();
		uint GetCatchHandlerILOffset();
		uint GetAsyncStepInfoCount();
		void GetAsyncStepInfo([In] uint cStepInfo, [Out] out uint pcStepInfo, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] yieldOffsets, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] breakpointOffset, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] breakpointMethod);
	}

	[ComVisible(true),
	ComImport,
	Guid("9F60EEBE-2D9A-3F7C-BF58-80BC991C60BB"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedVariable {
		void GetName([In] uint cchName, [Out] out uint pcchName, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szName);
		void GetAttributes([Out] out uint pRetVal);
		void GetSignature([In] uint cSig, [Out] out uint pcSig, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] sig);
		void GetAddressKind([Out] out uint pRetVal);
		void GetAddressField1([Out] out uint pRetVal);
		void GetAddressField2([Out] out uint pRetVal);
		void GetAddressField3([Out] out uint pRetVal);
		void GetStartOffset([Out] out uint pRetVal);
		void GetEndOffset([Out] out uint pRetVal);
	}

	[ComVisible(true),
	ComImport,
	Guid("0DFF7289-54F8-11D3-BD28-0000F80849BD"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedNamespace {
		void GetName([In] uint cchName, [Out] out uint pcchName, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szName);
		void GetNamespaces([In] uint cNameSpaces, [Out] out uint pcNameSpaces, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedNamespace[] namespaces);
		void GetVariables([In] uint cVars, [Out] out uint pcVars, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] pVars);
	}

	[ComVisible(true),
	ComImport,
	Guid("68005D0F-B8E0-3B01-84D5-A11A94154942"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedScope {
		void GetMethod([Out] out ISymUnmanagedMethod pRetVal);
		void GetParent([Out] out ISymUnmanagedScope pRetVal);
		void GetChildren([In] uint cChildren, [Out] out uint pcChildren, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedScope[] children);
		void GetStartOffset([Out] out uint pRetVal);
		void GetEndOffset([Out] out uint pRetVal);
		void GetLocalCount([Out] out uint pRetVal);
		void GetLocals([In] uint cLocals, [Out] out uint pcLocals, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] locals);
		void GetNamespaces([In] uint cNameSpaces, [Out] out uint pcNameSpaces, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedNamespace[] namespaces);
	}

	[ComVisible(true),
	ComImport,
	Guid("AE932FBA-3FD8-4dba-8232-30A2309B02DB"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedScope2 : ISymUnmanagedScope {
#pragma warning disable 0108
		void GetMethod([Out] out ISymUnmanagedMethod pRetVal);
		void GetParent([Out] out ISymUnmanagedScope pRetVal);
		void GetChildren([In] uint cChildren, [Out] out uint pcChildren, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedScope[] children);
		void GetStartOffset([Out] out uint pRetVal);
		void GetEndOffset([Out] out uint pRetVal);
		void GetLocalCount([Out] out uint pRetVal);
		void GetLocals([In] uint cLocals, [Out] out uint pcLocals, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] locals);
		void GetNamespaces([In] uint cNameSpaces, [Out] out uint pcNameSpaces, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedNamespace[] namespaces);
#pragma warning restore 0108

		uint GetConstantCount();
		void GetConstants([In] uint cConstants, [Out] out uint pcConstants, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedConstant[] constants);
	}

	[ComVisible(true),
	ComImport,
	Guid("48B25ED8-5BAD-41bc-9CEE-CD62FABC74E9"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedConstant {
		void GetName([In] uint cchName, [Out] out uint pcchName, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szName);
		void GetValue(out object pValue);
		[PreserveSig]
		int GetSignature([In] uint cSig, [Out] out uint pcSig, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] sig);
	}

	[ComVisible(true),
	ComImport,
	Guid("7DAC8207-D3AE-4C75-9B67-92801A497D44"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface IMetaDataImport {
		void CloseEnum(IntPtr hEnum);
		void CountEnum(IntPtr hEnum, ref uint pulCount);
		void ResetEnum(IntPtr hEnum, uint ulPos);
		void EnumTypeDefs(IntPtr phEnum, uint[] rTypeDefs, uint cMax, out uint pcTypeDefs);
		void EnumInterfaceImpls(ref IntPtr phEnum, uint td, uint[] rImpls, uint cMax, ref uint pcImpls);
		void EnumTypeRefs(ref IntPtr phEnum, uint[] rTypeRefs, uint cMax, ref uint pcTypeRefs);
		void FindTypeDefByName([In, MarshalAs(UnmanagedType.LPWStr)] string szTypeDef, [In] uint tkEnclosingClass, [Out] out uint ptd);
		void GetScopeProps([Out] IntPtr szName, [In] uint cchName, [Out] out uint pchName, [Out] out Guid pmvid);
		void GetModuleFromScope([Out] out uint pmd);
		unsafe void GetTypeDefProps([In] uint td, [In] ushort* szTypeDef, [In] uint cchTypeDef, [Out] uint* pchTypeDef, [Out] uint* pdwTypeDefFlags, [Out] uint* ptkExtends);
		void GetInterfaceImplProps([In] uint iiImpl, [Out] out uint pClass, [Out] out uint ptkIface);
		void GetTypeRefProps([In] uint tr, [Out] out uint ptkResolutionScope, [Out] IntPtr szName, [In] uint cchName, [Out] out uint pchName);
		void ResolveTypeRef(uint tr, ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppIScope, out uint ptd);
		void EnumMembers([In, Out] ref IntPtr phEnum, [In] uint cl, [Out] uint[] rMembers, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMembersWithName([In, Out] ref IntPtr phEnum, [In] uint cl, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] uint[] rMembers, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMethods([In, Out] ref IntPtr phEnum, [In] uint cl, [Out] uint[] rMethods, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMethodsWithName([In, Out] ref IntPtr phEnum, [In] uint cl, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, uint[] rMethods, [In] uint cMax, [Out] out uint pcTokens);
		void EnumFields([In, Out] ref IntPtr phEnum, [In] uint cl, [Out] uint[] rFields, [In] uint cMax, [Out] out uint pcTokens);
		void EnumFieldsWithName([In, Out] ref IntPtr phEnum, [In] uint cl, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] uint[] rFields, [In] uint cMax, [Out] out uint pcTokens);
		void EnumParams([In, Out] ref IntPtr phEnum, [In] uint mb, [Out] uint[] rParams, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMemberRefs([In, Out] ref IntPtr phEnum, [In] uint tkParent, [Out] uint[] rMemberRefs, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMethodImpls([In, Out] ref IntPtr phEnum, [In] uint td, [Out] uint[] rMethodBody, [Out] uint[] rMethodDecl, [In] uint cMax, [Out] out uint pcTokens);
		void EnumPermissionSets([In, Out] ref IntPtr phEnum, [In] uint tk, [In] uint dwActions, [Out] uint[] rPermission, [In] uint cMax, [Out] out uint pcTokens);
		void FindMember([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmb);
		void FindMethod([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmb);
		void FindField([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmb);
		void FindMemberRef([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmr);
		unsafe void GetMethodProps(uint mb, uint* pClass, [In] ushort* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, [Out] IntPtr* ppvSigBlob, [Out] uint* pcbSigBlob, [Out] uint* pulCodeRVA, [Out] uint* pdwImplFlags);
		void GetMemberRefProps([In] uint mr, [Out] out uint ptk, [Out] IntPtr szMember, [In] uint cchMember, [Out] out uint pchMember, [Out] out IntPtr ppvSigBlob, [Out] out uint pbSig);
		void EnumProperties([In, Out] ref IntPtr phEnum, [In] uint td, [Out] uint[] rProperties, [In] uint cMax, [Out] out uint pcProperties);
		void EnumEvents([In, Out] ref IntPtr phEnum, [In] uint td, [Out] uint[] rEvents, [In] uint cMax, [Out] out uint pcEvents);
		void GetEventProps([In] uint ev, [Out] out uint pClass, [Out] [MarshalAs(UnmanagedType.LPWStr)] string szEvent, [In] uint cchEvent, [Out] out uint pchEvent, [Out] out uint pdwEventFlags, [Out] out uint ptkEventType, [Out] out uint pmdAddOn, [Out] out uint pmdRemoveOn, [Out] out uint pmdFire, [In, Out] uint[] rmdOtherMethod, [In] uint cMax, [Out] out uint pcOtherMethod);
		void EnumMethodSemantics([In, Out] ref IntPtr phEnum, [In] uint mb, [In, Out] uint[] rEventProp, [In] uint cMax, [Out] out uint pcEventProp);
		void GetMethodSemantics([In] uint mb, [In] uint tkEventProp, [Out] out uint pdwSemanticsFlags);
		void GetClassLayout([In] uint td, [Out] out uint pdwPackSize, [Out] out IntPtr rFieldOffset, [In] uint cMax, [Out] out uint pcFieldOffset, [Out] out uint pulClassSize);
		void GetFieldMarshal([In] uint tk, [Out] out IntPtr ppvNativeType, [Out] out uint pcbNativeType);
		void GetRVA(uint tk, out uint pulCodeRVA, out uint pdwImplFlags);
		void GetPermissionSetProps([In] uint pm, [Out] out uint pdwAction, [Out] out IntPtr ppvPermission, [Out] out uint pcbPermission);
		void GetSigFromToken([In] uint mdSig, [Out] out IntPtr ppvSig, [Out] out uint pcbSig);
		void GetModuleRefProps([In] uint mur, [Out] IntPtr szName, [In] uint cchName, [Out] out uint pchName);
		void EnumModuleRefs([In, Out] ref IntPtr phEnum, [Out] uint[] rModuleRefs, [In] uint cmax, [Out] out uint pcModuleRefs);
		void GetTypeSpecFromToken([In] uint typespec, [Out] out IntPtr ppvSig, [Out] out uint pcbSig);
		void GetNameFromToken([In] uint tk, [Out] out IntPtr pszUtf8NamePtr);
		void EnumUnresolvedMethods([In, Out] ref IntPtr phEnum, [Out] uint[] rMethods, [In] uint cMax, [Out] out uint pcTokens);
		void GetUserString([In] uint stk, [Out] IntPtr szString, [In] uint cchString, [Out] out uint pchString);
		void GetPinvokeMap([In] uint tk, [Out] out uint pdwMappingFlags, [Out] IntPtr szImportName, [In] uint cchImportName, [Out] out uint pchImportName, [Out] out uint pmrImportDLL);
		void EnumSignatures([In, Out] ref IntPtr phEnum, [Out] uint[] rSignatures, [In] uint cmax, [Out] out uint pcSignatures);
		void EnumTypeSpecs([In, Out] ref IntPtr phEnum, [Out] uint[] rTypeSpecs, [In] uint cmax, [Out] out uint pcTypeSpecs);
		void EnumUserStrings([In, Out] ref IntPtr phEnum, [Out] uint[] rStrings, [In] uint cmax, [Out] out uint pcStrings);
		void GetParamForMethodIndex([In] uint md, [In] uint ulParamSeq, [Out] out uint ppd);
		void EnumCustomAttributes([In, Out] IntPtr phEnum, [In] uint tk, [In] uint tkType, [Out] uint[] rCustomAttributes, [In] uint cMax, [Out] out uint pcCustomAttributes);
		void GetCustomAttributeProps([In] uint cv, [Out] out uint ptkObj, [Out] out uint ptkType, [Out] out IntPtr ppBlob, [Out] out uint pcbSize);
		void FindTypeRef([In] uint tkResolutionScope, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] out uint ptr);
		void GetMemberProps(uint mb, out uint pClass, IntPtr szMember, uint cchMember, out uint pchMember, out uint pdwAttr, [Out] out IntPtr ppvSigBlob, [Out] out uint pcbSigBlob, [Out] out uint pulCodeRVA, [Out] out uint pdwImplFlags, [Out] out uint pdwCPlusTypeFlag, [Out] out IntPtr ppValue, [Out] out uint pcchValue);
		void GetFieldProps(uint mb, out uint pClass, IntPtr szField, uint cchField, out uint pchField, out uint pdwAttr, [Out] out IntPtr ppvSigBlob, [Out] out uint pcbSigBlob, [Out] out uint pdwCPlusTypeFlag, [Out] out IntPtr ppValue, [Out] out uint pcchValue);
		void GetPropertyProps([In] uint prop, [Out] out uint pClass, [Out] IntPtr szProperty, [In] uint cchProperty, [Out] out uint pchProperty, [Out] out uint pdwPropFlags, [Out] out IntPtr ppvSig, [Out] out uint pbSig, [Out] out uint pdwCPlusTypeFlag, [Out] out IntPtr ppDefaultValue, [Out] out uint pcchDefaultValue, [Out] out uint pmdSetter, [Out] out uint pmdGetter, [In, Out] uint[] rmdOtherMethod, [In] uint cMax, [Out] out uint pcOtherMethod);
		void GetParamProps([In] uint tk, [Out] out uint pmd, [Out] out uint pulSequence, [Out] IntPtr szName, [Out] uint cchName, [Out] out uint pchName, [Out] out uint pdwAttr, [Out] out uint pdwCPlusTypeFlag, [Out] out IntPtr ppValue, [Out] out uint pcchValue);
		void GetCustomAttributeByName([In] uint tkObj, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] out IntPtr ppData, [Out] out uint pcbData);
		bool IsValidToken([In] uint tk);
		unsafe void GetNestedClassProps([In] uint tdNestedClass, [Out] uint* ptdEnclosingClass);
		void GetNativeCallConvFromSig([In] IntPtr pvSig, [In] uint cbSig, [Out] out uint pCallConv);
		void IsGlobal([In] uint pd, [Out] out int pbGlobal);
	}

	[ComVisible(true),
	ComImport,
	Guid("BA3FEE4C-ECB9-4E41-83B7-183FA41CD859"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface IMetaDataEmit {
		void SetModuleProps([In] [MarshalAs(UnmanagedType.LPWStr)] string szName);
		void Save([In] [MarshalAs(UnmanagedType.LPWStr)] string szFile, [In] uint dwSaveFlags);
		void SaveToStream([In] IStream pIStream, [In] uint dwSaveFlags);
		void GetSaveSize([In] int fSave, [Out] out uint pdwSaveSize);
		void DefineTypeDef([In] [MarshalAs(UnmanagedType.LPWStr)] string szTypeDef, [In] uint dwTypeDefFlags, [In] uint tkExtends, [In] uint[] rtkImplements, [Out] out uint ptd);
		void DefineNestedType([In] [MarshalAs(UnmanagedType.LPWStr)] string szTypeDef, [In] uint dwTypeDefFlags, [In] uint tkExtends, [In] uint[] rtkImplements, [In] uint tdEncloser, [Out] out uint ptd);
		void SetHandler([In, MarshalAs(UnmanagedType.IUnknown)] object pUnk);
		void DefineMethod(uint td, [MarshalAs(UnmanagedType.LPWStr)] string szName, uint dwMethodFlags, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, uint ulCodeRVA, uint dwImplFlags, out uint pmd);
		void DefineMethodImpl([In] uint td, [In] uint tkBody, [In] uint tkDecl);
		void DefineTypeRefByName([In] uint tkResolutionScope, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] out uint ptr);
		void DefineImportType([In] IntPtr pAssemImport, [In] IntPtr pbHashValue, [In] uint cbHashValue, [In] IMetaDataImport pImport, [In] uint tdImport, [In] IntPtr pAssemEmit, [Out] out uint ptr);
		void DefineMemberRef([In] uint tkImport, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmr);
		void DefineImportMember([In] IntPtr pAssemImport, [In] IntPtr pbHashValue, [In] uint cbHashValue, [In] IMetaDataImport pImport, [In] uint mbMember, [In] IntPtr pAssemEmit, [In] uint tkParent, [Out] out uint pmr);
		void DefineEvent([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szEvent, [In] uint dwEventFlags, [In] uint tkEventType, [In] uint mdAddOn, [In] uint mdRemoveOn, [In] uint mdFire, [In] uint[] rmdOtherMethods, [Out] out uint pmdEvent);
		void SetClassLayout([In] uint td, [In] uint dwPackSize, [In] IntPtr rFieldOffsets, [In] uint ulClassSize);
		void DeleteClassLayout([In] uint td);
		void SetFieldMarshal([In] uint tk, [In] IntPtr pvNativeType, [In] uint cbNativeType);
		void DeleteFieldMarshal([In] uint tk);
		void DefinePermissionSet([In] uint tk, [In] uint dwAction, [In] IntPtr pvPermission, [In] uint cbPermission, [Out] out uint ppm);
		void SetRVA([In] uint md, [In] uint ulRVA);
		void GetTokenFromSig([In] IntPtr pvSig, [In] uint cbSig, [Out] out uint pmsig);
		void DefineModuleRef([In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] out uint pmur);
		void SetParent([In] uint mr, [In] uint tk);
		void GetTokenFromTypeSpec([In] IntPtr pvSig, [In] uint cbSig, [Out] out uint ptypespec);
		void SaveToMemory([Out] out IntPtr pbData, [In] uint cbData);
		void DefineUserString([In] [MarshalAs(UnmanagedType.LPWStr)] string szString, [In] uint cchString, [Out] out uint pstk);
		void DeleteToken([In] uint tkObj);
		void SetMethodProps([In] uint md, [In] uint dwMethodFlags, [In] uint ulCodeRVA, [In] uint dwImplFlags);
		void SetTypeDefProps([In] uint td, [In] uint dwTypeDefFlags, [In] uint tkExtends, [In] uint[] rtkImplements);
		void SetEventProps([In] uint ev, [In] uint dwEventFlags, [In] uint tkEventType, [In] uint mdAddOn, [In] uint mdRemoveOn, [In] uint mdFire, [In] uint[] rmdOtherMethods);
		void SetPermissionSetProps([In] uint tk, [In] uint dwAction, [In] IntPtr pvPermission, [In] uint cbPermission, [Out] out uint ppm);
		void DefinePinvokeMap([In] uint tk, [In] uint dwMappingFlags, [In] [MarshalAs(UnmanagedType.LPWStr)] string szImportName, [In] uint mrImportDLL);
		void SetPinvokeMap([In] uint tk, [In] uint dwMappingFlags, [In] [MarshalAs(UnmanagedType.LPWStr)] string szImportName, [In] uint mrImportDLL);
		void DeletePinvokeMap([In] uint tk);
		void DefineCustomAttribute([In] uint tkOwner, [In] uint tkCtor, [In] IntPtr pCustomAttribute, [In] uint cbCustomAttribute, [Out] out uint pcv);
		void SetCustomAttributeValue([In] uint pcv, [In] IntPtr pCustomAttribute, [In] uint cbCustomAttribute);
		void DefineField(uint td, [MarshalAs(UnmanagedType.LPWStr)] string szName, uint dwFieldFlags, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue, [Out] out uint pmd);
		void DefineProperty([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szProperty, [In] uint dwPropFlags, [In] IntPtr pvSig, [In] uint cbSig, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue, [In] uint mdSetter, [In] uint mdGetter, [In] uint[] rmdOtherMethods, [Out] out uint pmdProp);
		void DefineParam([In] uint md, [In] uint ulParamSeq, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] uint dwParamFlags, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue, [Out] out uint ppd);
		void SetFieldProps([In] uint fd, [In] uint dwFieldFlags, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue);
		void SetPropertyProps([In] uint pr, [In] uint dwPropFlags, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue, [In] uint mdSetter, [In] uint mdGetter, [In] uint[] rmdOtherMethods);
		void SetParamProps([In] uint pd, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] uint dwParamFlags, [In] uint dwCPlusTypeFlag, [Out] IntPtr pValue, [In] uint cchValue);
		void DefineSecurityAttributeSet([In] uint tkObj, [In] IntPtr rSecAttrs, [In] uint cSecAttrs, [Out] out uint pulErrorAttr);
		void ApplyEditAndContinue([In, MarshalAs(UnmanagedType.IUnknown)] object pImport);
		void TranslateSigWithScope([In] IntPtr pAssemImport, [In] IntPtr pbHashValue, [In] uint cbHashValue, [In] IMetaDataImport import, [In] IntPtr pbSigBlob, [In] uint cbSigBlob, [In] IntPtr pAssemEmit, [In] IMetaDataEmit emit, [Out] IntPtr pvTranslatedSig, uint cbTranslatedSigMax, [Out] out uint pcbTranslatedSig);
		void SetMethodImplFlags([In] uint md, uint dwImplFlags);
		void SetFieldRVA([In] uint fd, [In] uint ulRVA);
		void Merge([In] IMetaDataImport pImport, [In] IntPtr pHostMapToken, [In, MarshalAs(UnmanagedType.IUnknown)] object pHandler);
		void MergeEnd();
	}

	[ComVisible(true),
	ComImport,
	Guid("ED14AA72-78E2-4884-84E2-334293AE5214"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter {
		void DefineDocument([In] [MarshalAs(UnmanagedType.LPWStr)] string url, [In] ref Guid language, [In] ref Guid languageVendor, [In] ref Guid documentType, [Out] out ISymUnmanagedDocumentWriter pRetVal);
		void SetUserEntryPoint([In] uint entryMethod);
		void OpenMethod([In] uint method);
		void CloseMethod();
		void OpenScope([In] uint startOffset, [Out] out uint pRetVal);
		void CloseScope([In] uint endOffset);
		void SetScopeRange([In] uint scopeID, [In] uint startOffset, [In] uint endOffset);
		void DefineLocalVariable([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3, [In] uint startOffset, [In] uint endOffset);
		void DefineParameter([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint sequence, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineField([In] uint parent, [In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineGlobalVariable([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void Close();
		void SetSymAttribute([In] uint parent, [In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint cData, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] data);
		void OpenNamespace([In] [MarshalAs(UnmanagedType.LPWStr)] string name);
		void CloseNamespace();
		void UsingNamespace([In] [MarshalAs(UnmanagedType.LPWStr)] string fullName);
		void SetMethodSourceRange([In] ISymUnmanagedDocumentWriter startDoc, [In] uint startLine, [In] uint startColumn, [In] ISymUnmanagedDocumentWriter endDoc, [In] uint endLine, [In] uint endColumn);
		void Initialize([In] IntPtr emitter, [In] [MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream, [In] bool fFullBuild);
		void GetDebugInfo([Out] out IMAGE_DEBUG_DIRECTORY pIDD, [In] uint cData, [Out] out uint pcData, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] data);
		void DefineSequencePoints([In] ISymUnmanagedDocumentWriter document, [In] uint spCount, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] offsets, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] lines, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] columns, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endLines, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endColumns);
		void RemapToken([In] uint oldToken, [In] uint newToken);
		void Initialize2([In, MarshalAs(UnmanagedType.IUnknown)] object emitter, [In] [MarshalAs(UnmanagedType.LPWStr)] string tempfilename, [In] IStream pIStream, [In] bool fFullBuild, [In] [MarshalAs(UnmanagedType.LPWStr)] string finalfilename);
		void DefineConstant([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] object value, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature);
		void Abort();
	}

#pragma warning disable 1591
	[ComVisible(true),
	ComImport,
	Guid("0B97726E-9E6D-4F05-9A26-424022093CAA"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ISymUnmanagedWriter2 {
		void DefineDocument([In] [MarshalAs(UnmanagedType.LPWStr)] string url, [In] ref Guid language, [In] ref Guid languageVendor, [In] ref Guid documentType, [Out] out ISymUnmanagedDocumentWriter pRetVal);
		void SetUserEntryPoint([In] uint entryMethod);
		void OpenMethod([In] uint method);
		void CloseMethod();
		void OpenScope([In] uint startOffset, [Out] out uint pRetVal);
		void CloseScope([In] uint endOffset);
		void SetScopeRange([In] uint scopeID, [In] uint startOffset, [In] uint endOffset);
		void DefineLocalVariable([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3, [In] uint startOffset, [In] uint endOffset);
		void DefineParameter([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint sequence, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineField([In] uint parent, [In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineGlobalVariable([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void Close();
		void SetSymAttribute([In] uint parent, [In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint cData, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] data);
		void OpenNamespace([In] [MarshalAs(UnmanagedType.LPWStr)] string name);
		void CloseNamespace();
		void UsingNamespace([In] [MarshalAs(UnmanagedType.LPWStr)] string fullName);
		void SetMethodSourceRange([In] ISymUnmanagedDocumentWriter startDoc, [In] uint startLine, [In] uint startColumn, [In] ISymUnmanagedDocumentWriter endDoc, [In] uint endLine, [In] uint endColumn);
		void Initialize([In, MarshalAs(UnmanagedType.IUnknown)] object emitter, [In] [MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream, [In] bool fFullBuild);
		void GetDebugInfo([Out] out IMAGE_DEBUG_DIRECTORY pIDD, [In] uint cData, [Out] out uint pcData, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] data);
		void DefineSequencePoints([In] ISymUnmanagedDocumentWriter document, [In] uint spCount, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] offsets, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] lines, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] columns, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endLines, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endColumns);
		void RemapToken([In] uint oldToken, [In] uint newToken);
		void Initialize2([In, MarshalAs(UnmanagedType.IUnknown)] object emitter, [In] [MarshalAs(UnmanagedType.LPWStr)] string tempfilename, [In] IStream pIStream, [In] bool fFullBuild, [In] [MarshalAs(UnmanagedType.LPWStr)] string finalfilename);
		void DefineConstant([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] object value, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature);
		void Abort();
		void DefineLocalVariable2([In, MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint sigToken, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3, [In] uint startOffset, [In] uint endOffset);
		void DefineGlobalVariable2([In, MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint sigToken, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineConstant2([In, MarshalAs(UnmanagedType.LPWStr)] string name, [In] object value, [In] uint sigToken);
	}
#pragma warning restore 1591

#pragma warning disable 1591
	[ComVisible(true),
	ComImport,
	Guid("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface ISymUnmanagedDocumentWriter {
		void SetSource([In] uint sourceSize, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] source);
		void SetCheckSum([In] Guid algorithmId, [In] uint checkSumSize, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] checkSum);
	}
#pragma warning restore 1591

	[ComVisible(true),
	ComImport,
	Guid("FC073774-1739-4232-BD56-A027294BEC15"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedAsyncMethodPropertiesWriter {
		void DefineKickoffMethod([In] uint kickoffMethod);
		void DefineCatchHandlerILOffset([In] uint catchHandlerOffset);
		void DefineAsyncStepInfo([In] uint count, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] yieldOffsets, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] breakpointOffset, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] breakpointMethod);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/ImageStreamIStream.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Dss {
	/// <summary>
	/// Implements <see cref="IStream"/> and uses an <see cref="IImageStream"/> as the underlying
	/// stream.
	/// </summary>
	sealed class ImageStreamIStream : IStream, IDisposable {
		readonly IImageStream stream;
		readonly string name;

		const int STG_E_INVALIDFUNCTION = unchecked((int)0x80030001);
		const int STG_E_CANTSAVE = unchecked((int)0x80030103);

		/// <summary>
		/// User can set this to anything he/she wants. If it implements <see cref="IDisposable"/>,
		/// its <see cref="IDisposable.Dispose()"/> method will get called when this instance
		/// is <see cref="IDisposable.Dispose()"/>'d.
		/// </summary>
		public object UserData { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Source stream</param>
		public ImageStreamIStream(IImageStream stream)
			: this(stream, string.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Source stream</param>
		/// <param name="name">Name of original file or <c>null</c> if unknown.</param>
		public ImageStreamIStream(IImageStream stream, string name) {
			if (stream == null)
				throw new ArgumentNullException("stream");
			this.stream = stream;
			this.name = name ?? string.Empty;
		}

		/// <inheritdoc/>
		public void Clone(out IStream ppstm) {
			var newStream = stream.Clone();
			newStream.Position = stream.Position;
			ppstm = new ImageStreamIStream(newStream, name);
		}

		/// <inheritdoc/>
		public void Commit(int grfCommitFlags) {
		}

		/// <inheritdoc/>
		public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten) {
			if (cb > int.MaxValue)
				cb = int.MaxValue;
			else if (cb < 0)
				cb = 0;
			int sizeToRead = (int)cb;

			if (stream.Position + sizeToRead < sizeToRead || stream.Position + sizeToRead > stream.Length)
				sizeToRead = (int)(stream.Length - Math.Min(stream.Position, stream.Length));

			var buffer = new byte[sizeToRead];
			Read(buffer, sizeToRead, pcbRead);
			if (pcbRead != IntPtr.Zero)
				Marshal.WriteInt64(pcbRead, Marshal.ReadInt32(pcbRead));
			pstm.Write(buffer, buffer.Length, pcbWritten);
			if (pcbWritten != IntPtr.Zero)
				Marshal.WriteInt64(pcbWritten, Marshal.ReadInt32(pcbWritten));
		}

		/// <inheritdoc/>
		public void LockRegion(long libOffset, long cb, int dwLockType) {
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);
		}

		/// <inheritdoc/>
		public void Read(byte[] pv, int cb, IntPtr pcbRead) {
			if (cb < 0)
				cb = 0;

			cb = stream.Read(pv, 0, cb);

			if (pcbRead != IntPtr.Zero)
				Marshal.WriteInt32(pcbRead, cb);
		}

		/// <inheritdoc/>
		public void Revert() {
		}

		enum STREAM_SEEK {
			SET = 0,
			CUR = 1,
			END = 2,
		}

		/// <inheritdoc/>
		public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition) {
			switch ((STREAM_SEEK)dwOrigin) {
			case STREAM_SEEK.SET:
				stream.Position = dlibMove;
				break;

			case STREAM_SEEK.CUR:
				stream.Position += dlibMove;
				break;

			case STREAM_SEEK.END:
				stream.Position = stream.Length + dlibMove;
				break;
			}

			if (plibNewPosition != IntPtr.Zero)
				Marshal.WriteInt64(plibNewPosition, stream.Position);
		}

		/// <inheritdoc/>
		public void SetSize(long libNewSize) {
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);
		}

		enum STATFLAG {
			DEFAULT = 0,
			NONAME = 1,
			NOOPEN = 2,
		}

		enum STGTY {
			STORAGE = 1,
			STREAM = 2,
			LOCKBYTES = 3,
			PROPERTY = 4,
		}

		/// <inheritdoc/>
		public void Stat(out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag) {
			var s = new System.Runtime.InteropServices.ComTypes.STATSTG();

			// s.atime = ???;
			s.cbSize = stream.Length;
			s.clsid = Guid.Empty;
			// s.ctime = ???;
			s.grfLocksSupported = 0;
			s.grfMode = 0;
			s.grfStateBits = 0;
			// s.mtime = ???;
			if ((grfStatFlag & (int)STATFLAG.NONAME) == 0)
				s.pwcsName = name;
			s.reserved = 0;
			s.type = (int)STGTY.STREAM;

			pstatstg = s;
		}

		/// <inheritdoc/>
		public void UnlockRegion(long libOffset, long cb, int dwLockType) {
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);
		}

		/// <inheritdoc/>
		public void Write(byte[] pv, int cb, IntPtr pcbWritten) {
			Marshal.ThrowExceptionForHR(STG_E_CANTSAVE);
		}

		/// <inheritdoc/>
		public void Dispose() {
			stream.Dispose();
			var id = UserData as IDisposable;
			if (id != null)
				id.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/MDEmitter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices.ComTypes;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet.Pdb.Dss {
	/// <summary>
	/// Pass this instance to <see cref="ISymUnmanagedWriter.Initialize"/> when writing the PDB file
	/// </summary>
	sealed class MDEmitter : IMetaDataImport, IMetaDataEmit {
		readonly MetaData metaData;
		readonly Dictionary<uint, TypeDef> tokenToTypeDef;
		readonly Dictionary<uint, MethodDef> tokenToMethodDef;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metaData">Metadata</param>
		public MDEmitter(MetaData metaData) {
			this.metaData = metaData;

			// We could get these from the metadata tables but it's just easier to get name,
			// declaring type etc using TypeDef and MethodDef.

			tokenToTypeDef = new Dictionary<uint, TypeDef>(metaData.TablesHeap.TypeDefTable.Rows);
			tokenToMethodDef = new Dictionary<uint, MethodDef>(metaData.TablesHeap.MethodTable.Rows);
			foreach (var type in metaData.Module.GetTypes()) {
				if (type == null)
					continue;
				tokenToTypeDef.Add(new MDToken(MD.Table.TypeDef, metaData.GetRid(type)).Raw, type);
				foreach (var method in type.Methods) {
					if (method == null)
						continue;
					tokenToMethodDef.Add(new MDToken(MD.Table.Method, metaData.GetRid(method)).Raw, method);
				}
			}
		}

		unsafe void IMetaDataImport.GetMethodProps(uint mb, uint* pClass, ushort* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, IntPtr* ppvSigBlob, uint* pcbSigBlob, uint* pulCodeRVA, uint* pdwImplFlags) {
			if ((mb >> 24) != 0x06)
				throw new ArgumentException();
			var method = tokenToMethodDef[mb];
			var row = metaData.TablesHeap.MethodTable[mb & 0x00FFFFFF];

			if (pClass != null)
				*pClass = new MDToken(MD.Table.TypeDef, metaData.GetRid(method.DeclaringType)).Raw;
			if (pdwAttr != null)
				*pdwAttr = row.Flags;
			if (ppvSigBlob != null)
				*ppvSigBlob = IntPtr.Zero;
			if (pcbSigBlob != null)
				*pcbSigBlob = 0;
			if (pulCodeRVA != null)
				*pulCodeRVA = row.RVA;
			if (pdwImplFlags != null)
				*pdwImplFlags = row.ImplFlags;

			string name = method.Name.String ?? string.Empty;
			int len = (int)Math.Min((uint)name.Length + 1, cchMethod);
			if (szMethod != null) {
				for (int i = 0; i < len - 1; i++, szMethod++)
					*szMethod = (ushort)name[i];
				if (len > 0)
					*szMethod = 0;
			}
			if (pchMethod != null)
				*pchMethod = (uint)len;
		}

		unsafe void IMetaDataImport.GetTypeDefProps(uint td, ushort* szTypeDef, uint cchTypeDef, uint* pchTypeDef, uint* pdwTypeDefFlags, uint* ptkExtends) {
			if ((td >> 24) != 0x02)
				throw new ArgumentException();
			var type = tokenToTypeDef[td];
			var row = metaData.TablesHeap.TypeDefTable[td & 0x00FFFFFF];
			if (pdwTypeDefFlags != null)
				*pdwTypeDefFlags = row.Flags;
			if (ptkExtends != null)
				*ptkExtends = row.Extends;

			string name = type.Name.String ?? string.Empty;
			int len = (int)Math.Min((uint)name.Length + 1, cchTypeDef);
			if (szTypeDef != null) {
				for (int i = 0; i < len - 1; i++, szTypeDef++)
					*szTypeDef = (ushort)name[i];
				if (len > 0)
					*szTypeDef = 0;
			}
			if (pchTypeDef != null)
				*pchTypeDef = (uint)len;
		}

		unsafe void IMetaDataImport.GetNestedClassProps(uint tdNestedClass, uint* ptdEnclosingClass) {
			if ((tdNestedClass >> 24) != 0x02)
				throw new ArgumentException();
			var type = tokenToTypeDef[tdNestedClass];
			var declType = type.DeclaringType;
			if (ptdEnclosingClass != null) {
				if (declType == null)
					*ptdEnclosingClass = 0;
				else
					*ptdEnclosingClass = new MDToken(MD.Table.TypeDef, metaData.GetRid(declType)).Raw;
			}
		}

		// The rest of the methods aren't called

		void IMetaDataImport.CloseEnum(IntPtr hEnum) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.CountEnum(IntPtr hEnum, ref uint pulCount) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.ResetEnum(IntPtr hEnum, uint ulPos) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumTypeDefs(IntPtr phEnum, uint[] rTypeDefs, uint cMax, out uint pcTypeDefs) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumInterfaceImpls(ref IntPtr phEnum, uint td, uint[] rImpls, uint cMax, ref uint pcImpls) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumTypeRefs(ref IntPtr phEnum, uint[] rTypeRefs, uint cMax, ref uint pcTypeRefs) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.FindTypeDefByName(string szTypeDef, uint tkEnclosingClass, out uint ptd) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetScopeProps(IntPtr szName, uint cchName, out uint pchName, out Guid pmvid) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetModuleFromScope(out uint pmd) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetInterfaceImplProps(uint iiImpl, out uint pClass, out uint ptkIface) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetTypeRefProps(uint tr, out uint ptkResolutionScope, IntPtr szName, uint cchName, out uint pchName) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.ResolveTypeRef(uint tr, ref Guid riid, out object ppIScope, out uint ptd) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumMembers(ref IntPtr phEnum, uint cl, uint[] rMembers, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumMembersWithName(ref IntPtr phEnum, uint cl, string szName, uint[] rMembers, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumMethods(ref IntPtr phEnum, uint cl, uint[] rMethods, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumMethodsWithName(ref IntPtr phEnum, uint cl, string szName, uint[] rMethods, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumFields(ref IntPtr phEnum, uint cl, uint[] rFields, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumFieldsWithName(ref IntPtr phEnum, uint cl, string szName, uint[] rFields, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumParams(ref IntPtr phEnum, uint mb, uint[] rParams, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumMemberRefs(ref IntPtr phEnum, uint tkParent, uint[] rMemberRefs, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumMethodImpls(ref IntPtr phEnum, uint td, uint[] rMethodBody, uint[] rMethodDecl, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumPermissionSets(ref IntPtr phEnum, uint tk, uint dwActions, uint[] rPermission, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.FindMember(uint td, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmb) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.FindMethod(uint td, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmb) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.FindField(uint td, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmb) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.FindMemberRef(uint td, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmr) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetMemberRefProps(uint mr, out uint ptk, IntPtr szMember, uint cchMember, out uint pchMember, out IntPtr ppvSigBlob, out uint pbSig) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumProperties(ref IntPtr phEnum, uint td, uint[] rProperties, uint cMax, out uint pcProperties) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumEvents(ref IntPtr phEnum, uint td, uint[] rEvents, uint cMax, out uint pcEvents) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetEventProps(uint ev, out uint pClass, string szEvent, uint cchEvent, out uint pchEvent, out uint pdwEventFlags, out uint ptkEventType, out uint pmdAddOn, out uint pmdRemoveOn, out uint pmdFire, uint[] rmdOtherMethod, uint cMax, out uint pcOtherMethod) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumMethodSemantics(ref IntPtr phEnum, uint mb, uint[] rEventProp, uint cMax, out uint pcEventProp) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetMethodSemantics(uint mb, uint tkEventProp, out uint pdwSemanticsFlags) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetClassLayout(uint td, out uint pdwPackSize, out IntPtr rFieldOffset, uint cMax, out uint pcFieldOffset, out uint pulClassSize) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetFieldMarshal(uint tk, out IntPtr ppvNativeType, out uint pcbNativeType) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetRVA(uint tk, out uint pulCodeRVA, out uint pdwImplFlags) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetPermissionSetProps(uint pm, out uint pdwAction, out IntPtr ppvPermission, out uint pcbPermission) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetSigFromToken(uint mdSig, out IntPtr ppvSig, out uint pcbSig) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetModuleRefProps(uint mur, IntPtr szName, uint cchName, out uint pchName) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumModuleRefs(ref IntPtr phEnum, uint[] rModuleRefs, uint cmax, out uint pcModuleRefs) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetTypeSpecFromToken(uint typespec, out IntPtr ppvSig, out uint pcbSig) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetNameFromToken(uint tk, out IntPtr pszUtf8NamePtr) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumUnresolvedMethods(ref IntPtr phEnum, uint[] rMethods, uint cMax, out uint pcTokens) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetUserString(uint stk, IntPtr szString, uint cchString, out uint pchString) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetPinvokeMap(uint tk, out uint pdwMappingFlags, IntPtr szImportName, uint cchImportName, out uint pchImportName, out uint pmrImportDLL) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumSignatures(ref IntPtr phEnum, uint[] rSignatures, uint cmax, out uint pcSignatures) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumTypeSpecs(ref IntPtr phEnum, uint[] rTypeSpecs, uint cmax, out uint pcTypeSpecs) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumUserStrings(ref IntPtr phEnum, uint[] rStrings, uint cmax, out uint pcStrings) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetParamForMethodIndex(uint md, uint ulParamSeq, out uint ppd) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.EnumCustomAttributes(IntPtr phEnum, uint tk, uint tkType, uint[] rCustomAttributes, uint cMax, out uint pcCustomAttributes) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetCustomAttributeProps(uint cv, out uint ptkObj, out uint ptkType, out IntPtr ppBlob, out uint pcbSize) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.FindTypeRef(uint tkResolutionScope, string szName, out uint ptr) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetMemberProps(uint mb, out uint pClass, IntPtr szMember, uint cchMember, out uint pchMember, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pulCodeRVA, out uint pdwImplFlags, out uint pdwCPlusTypeFlag, out IntPtr ppValue, out uint pcchValue) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetFieldProps(uint mb, out uint pClass, IntPtr szField, uint cchField, out uint pchField, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pdwCPlusTypeFlag, out IntPtr ppValue, out uint pcchValue) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetPropertyProps(uint prop, out uint pClass, IntPtr szProperty, uint cchProperty, out uint pchProperty, out uint pdwPropFlags, out IntPtr ppvSig, out uint pbSig, out uint pdwCPlusTypeFlag, out IntPtr ppDefaultValue, out uint pcchDefaultValue, out uint pmdSetter, out uint pmdGetter, uint[] rmdOtherMethod, uint cMax, out uint pcOtherMethod) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetParamProps(uint tk, out uint pmd, out uint pulSequence, IntPtr szName, uint cchName, out uint pchName, out uint pdwAttr, out uint pdwCPlusTypeFlag, out IntPtr ppValue, out uint pcchValue) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetCustomAttributeByName(uint tkObj, string szName, out IntPtr ppData, out uint pcbData) {
			throw new NotImplementedException();
		}

		bool IMetaDataImport.IsValidToken(uint tk) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.GetNativeCallConvFromSig(IntPtr pvSig, uint cbSig, out uint pCallConv) {
			throw new NotImplementedException();
		}

		void IMetaDataImport.IsGlobal(uint pd, out int pbGlobal) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetModuleProps(string szName) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.Save(string szFile, uint dwSaveFlags) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SaveToStream(IStream pIStream, uint dwSaveFlags) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.GetSaveSize(int fSave, out uint pdwSaveSize) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineTypeDef(string szTypeDef, uint dwTypeDefFlags, uint tkExtends, uint[] rtkImplements, out uint ptd) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineNestedType(string szTypeDef, uint dwTypeDefFlags, uint tkExtends, uint[] rtkImplements, uint tdEncloser, out uint ptd) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetHandler(object pUnk) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineMethod(uint td, string szName, uint dwMethodFlags, IntPtr pvSigBlob, uint cbSigBlob, uint ulCodeRVA, uint dwImplFlags, out uint pmd) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineMethodImpl(uint td, uint tkBody, uint tkDecl) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineTypeRefByName(uint tkResolutionScope, string szName, out uint ptr) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint tdImport, IntPtr pAssemEmit, out uint ptr) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineMemberRef(uint tkImport, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmr) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint mbMember, IntPtr pAssemEmit, uint tkParent, out uint pmr) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineEvent(uint td, string szEvent, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, uint[] rmdOtherMethods, out uint pmdEvent) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetClassLayout(uint td, uint dwPackSize, IntPtr rFieldOffsets, uint ulClassSize) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DeleteClassLayout(uint td) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetFieldMarshal(uint tk, IntPtr pvNativeType, uint cbNativeType) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DeleteFieldMarshal(uint tk) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefinePermissionSet(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission, out uint ppm) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetRVA(uint md, uint ulRVA) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.GetTokenFromSig(IntPtr pvSig, uint cbSig, out uint pmsig) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineModuleRef(string szName, out uint pmur) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetParent(uint mr, uint tk) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.GetTokenFromTypeSpec(IntPtr pvSig, uint cbSig, out uint ptypespec) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SaveToMemory(out IntPtr pbData, uint cbData) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineUserString(string szString, uint cchString, out uint pstk) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DeleteToken(uint tkObj) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetMethodProps(uint md, uint dwMethodFlags, uint ulCodeRVA, uint dwImplFlags) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetTypeDefProps(uint td, uint dwTypeDefFlags, uint tkExtends, uint[] rtkImplements) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetEventProps(uint ev, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, uint[] rmdOtherMethods) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetPermissionSetProps(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission, out uint ppm) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefinePinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetPinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DeletePinvokeMap(uint tk) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineCustomAttribute(uint tkOwner, uint tkCtor, IntPtr pCustomAttribute, uint cbCustomAttribute, out uint pcv) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetCustomAttributeValue(uint pcv, IntPtr pCustomAttribute, uint cbCustomAttribute) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineField(uint td, string szName, uint dwFieldFlags, IntPtr pvSigBlob, uint cbSigBlob, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, out uint pmd) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineProperty(uint td, string szProperty, uint dwPropFlags, IntPtr pvSig, uint cbSig, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, uint[] rmdOtherMethods, out uint pmdProp) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineParam(uint md, uint ulParamSeq, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, out uint ppd) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetFieldProps(uint fd, uint dwFieldFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetPropertyProps(uint pr, uint dwPropFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, uint[] rmdOtherMethods) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetParamProps(uint pd, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.DefineSecurityAttributeSet(uint tkObj, IntPtr rSecAttrs, uint cSecAttrs, out uint pulErrorAttr) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.ApplyEditAndContinue(object pImport) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, uint cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, uint cbTranslatedSigMax, out uint pcbTranslatedSig) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetMethodImplFlags(uint md, uint dwImplFlags) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.SetFieldRVA(uint fd, uint ulRVA) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler) {
			throw new NotImplementedException();
		}

		void IMetaDataEmit.MergeEnd() {
			throw new NotImplementedException();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/PinnedMetaData.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Runtime.InteropServices;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Dss {
	/// <summary>
	/// Pins a metadata stream in memory
	/// </summary>
	sealed class PinnedMetaData : IDisposable {
		GCHandle gcHandle;
		readonly IImageStream stream;
		readonly byte[] streamData;
		readonly IntPtr address;

		/// <summary>
		/// Gets the address
		/// </summary>
		public IntPtr Address {
			get { return address; }
		}

		/// <summary>
		/// Gets the size
		/// </summary>
		public int Size {
			get { return (int)stream.Length; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Metadata stream</param>
		public PinnedMetaData(IImageStream stream) {
			this.stream = stream;

			var umStream = stream as UnmanagedMemoryImageStream;
			if (umStream != null) {
				this.address = umStream.StartAddress;
				GC.SuppressFinalize(this);	// no GCHandle so finalizer isn't needed
			}
			else {
				var memStream = stream as MemoryImageStream;
				if (memStream != null) {
					this.streamData = memStream.DataArray;
					this.gcHandle = GCHandle.Alloc(this.streamData, GCHandleType.Pinned);
					this.address = new IntPtr(this.gcHandle.AddrOfPinnedObject().ToInt64() + memStream.DataOffset);
				}
				else {
					this.streamData = stream.ReadAllBytes();
					this.gcHandle = GCHandle.Alloc(this.streamData, GCHandleType.Pinned);
					this.address = this.gcHandle.AddrOfPinnedObject();
				}
			}
		}

		~PinnedMetaData() {
			Dispose(false);
		}

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		void Dispose(bool disposing) {
			if (gcHandle.IsAllocated) {
				try {
					gcHandle.Free();
				}
				catch (InvalidOperationException) {
				}
			}
			if (disposing)
				stream.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/StreamIStream.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;

namespace dnlib.DotNet.Pdb.Dss {
	/// <summary>
	/// Implements <see cref="IStream"/> and uses a <see cref="Stream"/> as the underlying
	/// stream.
	/// </summary>
	sealed class StreamIStream : IStream {
		readonly Stream stream;
		readonly string name;

		const int STG_E_INVALIDFUNCTION = unchecked((int)0x80030001);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Source stream</param>
		public StreamIStream(Stream stream)
			: this(stream, string.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Source stream</param>
		/// <param name="name">Name of original file or <c>null</c> if unknown.</param>
		public StreamIStream(Stream stream, string name) {
			if (stream == null)
				throw new ArgumentNullException("stream");
			this.stream = stream;
			this.name = name ?? string.Empty;
		}

		/// <inheritdoc/>
		public void Clone(out IStream ppstm) {
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);
			throw new Exception();
		}

		/// <inheritdoc/>
		public void Commit(int grfCommitFlags) {
			stream.Flush();
		}

		/// <inheritdoc/>
		public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten) {
			if (cb > int.MaxValue)
				cb = int.MaxValue;
			else if (cb < 0)
				cb = 0;
			int sizeToRead = (int)cb;

			if (stream.Position + sizeToRead < sizeToRead || stream.Position + sizeToRead > stream.Length)
				sizeToRead = (int)(stream.Length - Math.Min(stream.Position, stream.Length));

			var buffer = new byte[sizeToRead];
			Read(buffer, sizeToRead, pcbRead);
			if (pcbRead != IntPtr.Zero)
				Marshal.WriteInt64(pcbRead, Marshal.ReadInt32(pcbRead));
			pstm.Write(buffer, buffer.Length, pcbWritten);
			if (pcbWritten != IntPtr.Zero)
				Marshal.WriteInt64(pcbWritten, Marshal.ReadInt32(pcbWritten));
		}

		/// <inheritdoc/>
		public void LockRegion(long libOffset, long cb, int dwLockType) {
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);
		}

		/// <inheritdoc/>
		public void Read(byte[] pv, int cb, IntPtr pcbRead) {
			if (cb < 0)
				cb = 0;

			cb = stream.Read(pv, 0, cb);

			if (pcbRead != IntPtr.Zero)
				Marshal.WriteInt32(pcbRead, cb);
		}

		/// <inheritdoc/>
		public void Revert() {
		}

		enum STREAM_SEEK {
			SET = 0,
			CUR = 1,
			END = 2,
		}

		/// <inheritdoc/>
		public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition) {
			switch ((STREAM_SEEK)dwOrigin) {
			case STREAM_SEEK.SET:
				stream.Position = dlibMove;
				break;

			case STREAM_SEEK.CUR:
				stream.Position += dlibMove;
				break;

			case STREAM_SEEK.END:
				stream.Position = stream.Length + dlibMove;
				break;
			}

			if (plibNewPosition != IntPtr.Zero)
				Marshal.WriteInt64(plibNewPosition, stream.Position);
		}

		/// <inheritdoc/>
		public void SetSize(long libNewSize) {
			stream.SetLength(libNewSize);
		}

		enum STATFLAG {
			DEFAULT = 0,
			NONAME = 1,
			NOOPEN = 2,
		}

		enum STGTY {
			STORAGE = 1,
			STREAM = 2,
			LOCKBYTES = 3,
			PROPERTY = 4,
		}

		/// <inheritdoc/>
		public void Stat(out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag) {
			var s = new System.Runtime.InteropServices.ComTypes.STATSTG();

			// s.atime = ???;
			s.cbSize = stream.Length;
			s.clsid = Guid.Empty;
			// s.ctime = ???;
			s.grfLocksSupported = 0;
			s.grfMode = 2;
			s.grfStateBits = 0;
			// s.mtime = ???;
			if ((grfStatFlag & (int)STATFLAG.NONAME) == 0)
				s.pwcsName = name;
			s.reserved = 0;
			s.type = (int)STGTY.STREAM;

			pstatstg = s;
		}

		/// <inheritdoc/>
		public void UnlockRegion(long libOffset, long cb, int dwLockType) {
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);
		}

		/// <inheritdoc/>
		public void Write(byte[] pv, int cb, IntPtr pcbWritten) {
			stream.Write(pv, 0, cb);
			if (pcbWritten != IntPtr.Zero)
				Marshal.WriteInt32(pcbWritten, cb);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolDocumentImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolDocumentImpl : SymbolDocument {
		readonly ISymUnmanagedDocument document;

		public ISymUnmanagedDocument SymUnmanagedDocument {
			get { return document; }
		}

		public SymbolDocumentImpl(ISymUnmanagedDocument document) {
			this.document = document;
		}

		public override Guid CheckSumAlgorithmId {
			get {
				Guid guid;
				document.GetCheckSumAlgorithmId(out guid);
				return guid;
			}
		}

		public override Guid DocumentType {
			get {
				Guid guid;
				document.GetDocumentType(out guid);
				return guid;
			}
		}

		public override Guid Language {
			get {
				Guid guid;
				document.GetLanguage(out guid);
				return guid;
			}
		}

		public override Guid LanguageVendor {
			get {
				Guid guid;
				document.GetLanguageVendor(out guid);
				return guid;
			}
		}

		public override string URL {
			get {
				uint count;
				document.GetURL(0, out count, null);
				var chars = new char[count];
				document.GetURL((uint)chars.Length, out count, chars);
				if (chars.Length == 0)
					return string.Empty;
				return new string(chars, 0, chars.Length - 1);
			}
		}

		public override byte[] CheckSum {
			get {
				uint bufSize;
				document.GetCheckSum(0, out bufSize, null);
				var buffer = new byte[bufSize];
				document.GetCheckSum((uint)buffer.Length, out bufSize, buffer);
				return buffer;
			}
		}

		public override PdbCustomDebugInfo[] CustomDebugInfos {
			get { return emptyPdbCustomDebugInfos; }
		}
		static readonly PdbCustomDebugInfo[] emptyPdbCustomDebugInfos = new PdbCustomDebugInfo[0];
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolDocumentWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics.SymbolStore;

namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolDocumentWriter : ISymbolDocumentWriter {
		readonly ISymUnmanagedDocumentWriter writer;

		public ISymUnmanagedDocumentWriter SymUnmanagedDocumentWriter {
			get { return writer; }
		}

		public SymbolDocumentWriter(ISymUnmanagedDocumentWriter writer) {
			this.writer = writer;
		}

		public void SetCheckSum(Guid algorithmId, byte[] checkSum) {
			writer.SetCheckSum(algorithmId, (uint)(checkSum == null ? 0 : checkSum.Length), checkSum);
		}

		public void SetSource(byte[] source) {
			writer.SetSource((uint)source.Length, source);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolMethodImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Diagnostics.SymbolStore;
using System.Threading;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolMethodImpl : SymbolMethod {
		readonly SymbolReaderImpl reader;
		readonly ISymUnmanagedMethod method;
		readonly ISymUnmanagedAsyncMethod asyncMethod;

		public SymbolMethodImpl(SymbolReaderImpl reader, ISymUnmanagedMethod method) {
			this.reader = reader;
			this.method = method;
			asyncMethod = method as ISymUnmanagedAsyncMethod;
		}

		public override int Token {
			get {
				uint result;
				method.GetToken(out result);
				return (int)result;
			}
		}

		public override SymbolScope RootScope {
			get {
				if (rootScope == null) {
					ISymUnmanagedScope scope;
					method.GetRootScope(out scope);
					Interlocked.CompareExchange(ref rootScope, scope == null ? null : new SymbolScopeImpl(scope, this, null), null);
				}
				return rootScope;
			}
		}
		volatile SymbolScope rootScope;

		public override IList<SymbolSequencePoint> SequencePoints {
			get {
				if (sequencePoints == null) {
					uint seqPointCount;
					method.GetSequencePointCount(out seqPointCount);
					var seqPoints = new SymbolSequencePoint[seqPointCount];

					int[] offsets = new int[seqPoints.Length];
					ISymbolDocument[] documents = new ISymbolDocument[seqPoints.Length];
					int[] lines = new int[seqPoints.Length];
					int[] columns = new int[seqPoints.Length];
					int[] endLines = new int[seqPoints.Length];
					int[] endColumns = new int[seqPoints.Length];
					var unDocs = new ISymUnmanagedDocument[seqPoints.Length];
					if (seqPoints.Length != 0) {
						uint size;
						method.GetSequencePoints((uint)seqPoints.Length, out size, offsets, unDocs, lines, columns, endLines, endColumns);
					}
					for (int i = 0; i < seqPoints.Length; i++) {
						seqPoints[i] = new SymbolSequencePoint {
							Offset = offsets[i],
							Document = new SymbolDocumentImpl(unDocs[i]),
							Line = lines[i],
							Column = columns[i],
							EndLine = endLines[i],
							EndColumn = endColumns[i],
						};
					}
					sequencePoints = seqPoints;
				}
				return sequencePoints;
			}
		}
		volatile SymbolSequencePoint[] sequencePoints;

		public int AsyncKickoffMethod {
			get {
				if (asyncMethod == null || !asyncMethod.IsAsyncMethod())
					return 0;
				return (int)asyncMethod.GetKickoffMethod();
			}
		}

		public uint? AsyncCatchHandlerILOffset {
			get {
				if (asyncMethod == null || !asyncMethod.IsAsyncMethod())
					return null;
				if (!asyncMethod.HasCatchHandlerILOffset())
					return null;
				return asyncMethod.GetCatchHandlerILOffset();
			}
		}

		public IList<SymbolAsyncStepInfo> AsyncStepInfos {
			get {
				if (asyncMethod == null || !asyncMethod.IsAsyncMethod())
					return null;
				if (asyncStepInfos == null) {
					var stepInfoCount = asyncMethod.GetAsyncStepInfoCount();
					var yieldOffsets = new uint[stepInfoCount];
					var breakpointOffsets = new uint[stepInfoCount];
					var breakpointMethods = new uint[stepInfoCount];
					asyncMethod.GetAsyncStepInfo(stepInfoCount, out stepInfoCount, yieldOffsets, breakpointOffsets, breakpointMethods);
					var res = new SymbolAsyncStepInfo[stepInfoCount];
					for (int i = 0; i < res.Length; i++)
						res[i] = new SymbolAsyncStepInfo(yieldOffsets[i], breakpointOffsets[i], breakpointMethods[i]);
					asyncStepInfos = res;
				}
				return asyncStepInfos;
			}
		}
		volatile SymbolAsyncStepInfo[] asyncStepInfos;

		public override void GetCustomDebugInfos(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			reader.GetCustomDebugInfos(this, method, body, result);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolNamespaceImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolNamespaceImpl : SymbolNamespace {
		readonly ISymUnmanagedNamespace ns;

		public SymbolNamespaceImpl(ISymUnmanagedNamespace @namespace) {
			this.ns = @namespace;
		}

		public override string Name {
			get {
				uint count;
				ns.GetName(0, out count, null);
				var chars = new char[count];
				ns.GetName((uint)chars.Length, out count, chars);
				if (chars.Length == 0)
					return string.Empty;
				return new string(chars, 0, chars.Length - 1);
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolReaderCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using dnlib.DotNet.MD;
using dnlib.IO;
using dnlib.PE;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Dss {
	/// <summary>
	/// Creates a <see cref="SymbolReader"/> instance
	/// </summary>
	static class SymbolReaderCreator {
		[DllImport("ole32")]
		static extern int CoCreateInstance([In] ref Guid rclsid, IntPtr pUnkOuter, [In] uint dwClsContext, [In] ref Guid riid, [Out, MarshalAs(UnmanagedType.IUnknown)] out object ppv);

		static readonly Guid CLSID_CorSymBinder_SxS = new Guid(0x0A29FF9E, 0x7F9C, 0x4437, 0x8B, 0x11, 0xF4, 0x24, 0x49, 0x1E, 0x39, 0x31);

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="assemblyFileName">Path to assembly</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if there's no PDB
		/// file on disk or if any of the COM methods fail.</returns>
		public static SymbolReader CreateFromAssemblyFile(string assemblyFileName) {
			try {
				object mdDispObj;
				Guid CLSID_CorMetaDataDispenser = new Guid(0xE5CB7A31, 0x7512, 0x11D2, 0x89, 0xCE, 0x0, 0x80, 0xC7, 0x92, 0xE5, 0xD8);
				Guid IID_IMetaDataDispenser = new Guid(0x809C652E, 0x7396, 0x11D2, 0x97, 0x71, 0x00, 0xA0, 0xC9, 0xB4, 0xD5, 0x0C);
				int hr = CoCreateInstance(ref CLSID_CorMetaDataDispenser, IntPtr.Zero, 1, ref IID_IMetaDataDispenser, out mdDispObj);
				if (hr < 0)
					return null;

				object mdImportObj;
				var mdDisp = (IMetaDataDispenser)mdDispObj;
				Guid IID_IMetaDataImport = new Guid(0x7DAC8207, 0xD3AE, 0x4C75, 0x9B, 0x67, 0x92, 0x80, 0x1A, 0x49, 0x7D, 0x44);
				mdDisp.OpenScope(assemblyFileName, 0, ref IID_IMetaDataImport, out mdImportObj);
				Marshal.FinalReleaseComObject(mdDispObj);

				ISymUnmanagedReader symReader;
				var binder = (ISymUnmanagedBinder)Activator.CreateInstance(Type.GetTypeFromCLSID(CLSID_CorSymBinder_SxS));
				hr = binder.GetReaderForFile((IMetaDataImport)mdImportObj, assemblyFileName, null, out symReader);
				Marshal.FinalReleaseComObject(mdImportObj);
				Marshal.FinalReleaseComObject(binder);
				if (hr >= 0)
					return new SymbolReaderImpl(symReader);
			}
			catch (IOException) {
			}
			catch (UnauthorizedAccessException) {
			}
			catch (SecurityException) {
			}
			catch (InvalidCastException) {
			}
			catch (COMException) {
			}
			return null;
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="metaData">.NET metadata</param>
		/// <param name="pdbFileName">Path to PDB file</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if there's no PDB
		/// file on disk or if any of the COM methods fail.</returns>
		public static SymbolReader Create(IMetaData metaData, string pdbFileName) {
			var mdStream = CreateMetaDataStream(metaData);
			try {
				return Create(mdStream, ImageStreamUtils.OpenImageStream(pdbFileName));
			}
			catch {
				if (mdStream != null)
					mdStream.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="metaData">.NET metadata</param>
		/// <param name="pdbData">PDB file data</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if any of the COM
		/// methods fail.</returns>
		public static SymbolReader Create(IMetaData metaData, byte[] pdbData) {
			if (pdbData == null)
				return null;
			var mdStream = CreateMetaDataStream(metaData);
			try {
				return Create(mdStream, MemoryImageStream.Create(pdbData));
			}
			catch {
				if (mdStream != null)
					mdStream.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="metaData">.NET metadata</param>
		/// <param name="pdbStream">PDB file stream which is now owned by this method</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if any of the COM
		/// methods fail.</returns>
		public static SymbolReader Create(IMetaData metaData, IImageStream pdbStream) {
			try {
				return Create(CreateMetaDataStream(metaData), pdbStream);
			}
			catch {
				if (pdbStream != null)
					pdbStream.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="mdStream">.NET metadata stream which is now owned by this method</param>
		/// <param name="pdbFileName">Path to PDB file</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if there's no PDB
		/// file on disk or if any of the COM methods fail.</returns>
		public static SymbolReader Create(IImageStream mdStream, string pdbFileName) {
			try {
				return Create(mdStream, ImageStreamUtils.OpenImageStream(pdbFileName));
			}
			catch {
				if (mdStream != null)
					mdStream.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="mdStream">.NET metadata stream which is now owned by this method</param>
		/// <param name="pdbData">PDB file data</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if any of the COM
		/// methods fail.</returns>
		public static SymbolReader Create(IImageStream mdStream, byte[] pdbData) {
			if (pdbData == null) {
				if (mdStream != null)
					mdStream.Dispose();
				return null;
			}
			try {
				return Create(mdStream, MemoryImageStream.Create(pdbData));
			}
			catch {
				if (mdStream != null)
					mdStream.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="mdStream">.NET metadata stream which is now owned by this method</param>
		/// <param name="pdbStream">PDB file stream which is now owned by this method</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if any of the COM
		/// methods fail.</returns>
		public static SymbolReader Create(IImageStream mdStream, IImageStream pdbStream) {
			ImageStreamIStream stream = null;
			PinnedMetaData pinnedMd = null;
			bool error = true;
			try {
				if (pdbStream == null || mdStream == null)
					return null;

				object mdDispObj;
				Guid CLSID_CorMetaDataDispenser = new Guid(0xE5CB7A31, 0x7512, 0x11D2, 0x89, 0xCE, 0x0, 0x80, 0xC7, 0x92, 0xE5, 0xD8);
				Guid IID_IMetaDataDispenser = new Guid(0x809C652E, 0x7396, 0x11D2, 0x97, 0x71, 0x00, 0xA0, 0xC9, 0xB4, 0xD5, 0x0C);
				int hr = CoCreateInstance(ref CLSID_CorMetaDataDispenser, IntPtr.Zero, 1, ref IID_IMetaDataDispenser, out mdDispObj);
				if (hr < 0)
					return null;

				object mdImportObj;
				var mdDisp = (IMetaDataDispenser)mdDispObj;
				Guid IID_IMetaDataImport = new Guid(0x7DAC8207, 0xD3AE, 0x4C75, 0x9B, 0x67, 0x92, 0x80, 0x1A, 0x49, 0x7D, 0x44);
				pinnedMd = new PinnedMetaData(mdStream);
				mdDisp.OpenScopeOnMemory(pinnedMd.Address, (uint)pinnedMd.Size, 0x10, ref IID_IMetaDataImport, out mdImportObj);
				Marshal.FinalReleaseComObject(mdDispObj);

				ISymUnmanagedReader symReader;
				var binder = (ISymUnmanagedBinder)Activator.CreateInstance(Type.GetTypeFromCLSID(CLSID_CorSymBinder_SxS));
				stream = new ImageStreamIStream(pdbStream, null) { UserData = pinnedMd };
				hr = binder.GetReaderFromStream((IMetaDataImport)mdImportObj, stream, out symReader);
				Marshal.FinalReleaseComObject(mdImportObj);
				Marshal.FinalReleaseComObject(binder);
				if (hr >= 0) {
					error = false;
					return new SymbolReaderImpl(symReader);
				}
			}
			catch (IOException) {
			}
			catch (InvalidCastException) {
			}
			catch (COMException) {
			}
			finally {
				if (error) {
					if (stream != null)
						stream.Dispose();
					if (pinnedMd != null)
						pinnedMd.Dispose();
					if (mdStream != null)
						mdStream.Dispose();
					if (pdbStream != null)
						pdbStream.Dispose();
				}
			}
			return null;
		}

		static IImageStream CreateMetaDataStream(IMetaData metaData) {
			var peImage = metaData.PEImage;
			var mdDataDir = metaData.ImageCor20Header.MetaData;
			return peImage.CreateStream(mdDataDir.VirtualAddress, mdDataDir.Size);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolReaderImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.DotNet.Pdb.WindowsPdb;

namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolReaderImpl : SymbolReader {
		ModuleDef module;
		readonly ISymUnmanagedReader reader;

		const int E_FAIL = unchecked((int)0x80004005);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">An unmanaged symbol reader</param>
		public SymbolReaderImpl(ISymUnmanagedReader reader) {
			if (reader == null)
				throw new ArgumentNullException("reader");
			this.reader = reader;
		}

		public override PdbFileKind PdbFileKind {
			get { return PdbFileKind.WindowsPDB; }
		}

		public override int UserEntryPoint {
			get {
				uint token;
				int hr = reader.GetUserEntryPoint(out token);
				if (hr == E_FAIL)
					token = 0;
				else
					Marshal.ThrowExceptionForHR(hr);
				return (int)token;
			}
		}

		public override IList<SymbolDocument> Documents {
			get {
				if (documents == null) {
					uint numDocs;
					reader.GetDocuments(0, out numDocs, null);
					var unDocs = new ISymUnmanagedDocument[numDocs];
					reader.GetDocuments((uint)unDocs.Length, out numDocs, unDocs);
					var docs = new SymbolDocument[numDocs];
					for (uint i = 0; i < numDocs; i++)
						docs[i] = new SymbolDocumentImpl(unDocs[i]);
					documents = docs;
				}
				return documents;
			}
		}
		volatile SymbolDocument[] documents;

		public override void Initialize(ModuleDef module) {
			this.module = module;
		}

		public override SymbolMethod GetMethod(MethodDef method, int version) {
			ISymUnmanagedMethod unMethod;
			int hr = reader.GetMethodByVersion(method.MDToken.Raw, version, out unMethod);
			if (hr == E_FAIL)
				return null;
			Marshal.ThrowExceptionForHR(hr);
			return unMethod == null ? null : new SymbolMethodImpl(this, unMethod);
		}

		internal void GetCustomDebugInfos(SymbolMethodImpl symMethod, MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			var asyncMethod = PseudoCustomDebugInfoFactory.TryCreateAsyncMethod(method.Module, method, body, symMethod.AsyncKickoffMethod, symMethod.AsyncStepInfos, symMethod.AsyncCatchHandlerILOffset);
			if (asyncMethod != null)
				result.Add(asyncMethod);

			const string CDI_NAME = "MD2";
			uint bufSize;
			reader.GetSymAttribute(method.MDToken.Raw, CDI_NAME, 0, out bufSize, null);
			if (bufSize == 0)
				return;
			var cdiData = new byte[bufSize];
			reader.GetSymAttribute(method.MDToken.Raw, CDI_NAME, (uint)cdiData.Length, out bufSize, cdiData);
			PdbCustomDebugInfoReader.Read(method, body, result, cdiData);
		}

		public override void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolScopeImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolScopeImpl : SymbolScope {
		readonly ISymUnmanagedScope scope;
		readonly SymbolMethod method;
		readonly SymbolScope parent;

		public SymbolScopeImpl(ISymUnmanagedScope scope, SymbolMethod method, SymbolScope parent) {
			this.scope = scope;
			this.method = method;
			this.parent = parent;
		}

		public override SymbolMethod Method {
			get { return method; }
		}

		public override SymbolScope Parent {
			get { return parent; }
		}

		public override int StartOffset {
			get {
				uint result;
				scope.GetStartOffset(out result);
				return (int)result;
			}
		}

		public override int EndOffset {
			get {
				uint result;
				scope.GetEndOffset(out result);
				return (int)result;
			}
		}

		public override IList<SymbolScope> Children {
			get {
				if (children == null) {
					uint numScopes;
					scope.GetChildren(0, out numScopes, null);
					var unScopes = new ISymUnmanagedScope[numScopes];
					scope.GetChildren((uint)unScopes.Length, out numScopes, unScopes);
					var scopes = new SymbolScope[numScopes];
					for (uint i = 0; i < numScopes; i++)
						scopes[i] = new SymbolScopeImpl(unScopes[i], method, this);
					children = scopes;
				}
				return children;
			}
		}
		volatile SymbolScope[] children;

		public override IList<SymbolVariable> Locals {
			get {
				if (locals == null) {
					uint numVars;
					scope.GetLocals(0, out numVars, null);
					var unVars = new ISymUnmanagedVariable[numVars];
					scope.GetLocals((uint)unVars.Length, out numVars, unVars);
					var vars = new SymbolVariable[numVars];
					for (uint i = 0; i < numVars; i++)
						vars[i] = new SymbolVariableImpl(unVars[i]);
					locals = vars;
				}
				return locals;
			}
		}
		volatile SymbolVariable[] locals;

		public override IList<SymbolNamespace> Namespaces {
			get {
				if (namespaces == null) {
					uint numNss;
					scope.GetNamespaces(0, out numNss, null);
					var unNss = new ISymUnmanagedNamespace[numNss];
					scope.GetNamespaces((uint)unNss.Length, out numNss, unNss);
					var nss = new SymbolNamespace[numNss];
					for (uint i = 0; i < numNss; i++)
						nss[i] = new SymbolNamespaceImpl(unNss[i]);
					namespaces = nss;
				}
				return namespaces;
			}
		}
		volatile SymbolNamespace[] namespaces;

		public override IList<PdbCustomDebugInfo> CustomDebugInfos {
			get { return emptyPdbCustomDebugInfos; }
		}
		static readonly PdbCustomDebugInfo[] emptyPdbCustomDebugInfos = new PdbCustomDebugInfo[0];

		public override PdbImportScope ImportScope {
			get { return null; }
		}

		public override IList<PdbConstant> GetConstants(ModuleDef module, GenericParamContext gpContext) {
			var scope2 = scope as ISymUnmanagedScope2;
			if (scope2 == null)
				return emptySymbolConstants;
			uint numCs;
			scope2.GetConstants(0, out numCs, null);
			if (numCs == 0)
				return emptySymbolConstants;
			var unCs = new ISymUnmanagedConstant[numCs];
			scope2.GetConstants((uint)unCs.Length, out numCs, unCs);
			var nss = new PdbConstant[numCs];
			for (uint i = 0; i < numCs; i++) {
				var unc = unCs[i];
				var name = GetName(unc);
				object value;
				unc.GetValue(out value);
				var sigBytes = GetSignatureBytes(unc);
				TypeSig signature;
				if (sigBytes.Length == 0)
					signature = null;
				else
					signature = SignatureReader.ReadTypeSig(module, module.CorLibTypes, sigBytes, gpContext);
				nss[i] = new PdbConstant(name, signature, value);
			}
			return nss;
		}
		static readonly PdbConstant[] emptySymbolConstants = new PdbConstant[0];

		string GetName(ISymUnmanagedConstant unc) {
			uint count;
			unc.GetName(0, out count, null);
			var chars = new char[count];
			unc.GetName((uint)chars.Length, out count, chars);
			if (chars.Length == 0)
				return string.Empty;
			return new string(chars, 0, chars.Length - 1);
		}

		byte[] GetSignatureBytes(ISymUnmanagedConstant unc) {
			const int E_FAIL = unchecked((int)0x80004005);
			const int E_NOTIMPL = unchecked((int)0x80004001);
			uint bufSize;
			int hr = unc.GetSignature(0, out bufSize, null);
			if (bufSize == 0 || (hr < 0 && hr != E_FAIL && hr != E_NOTIMPL))
				return emptyByteArray;
			var buffer = new byte[bufSize];
			hr = unc.GetSignature((uint)buffer.Length, out bufSize, buffer);
			Debug.Assert(hr == 0);
			if (hr != 0)
				return emptyByteArray;
			return buffer;
		}
		static readonly byte[] emptyByteArray = new byte[0];
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolVariableImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.DotNet.Pdb.Symbols;
using dnlib.DotNet.Pdb.WindowsPdb;

namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolVariableImpl : SymbolVariable {
		readonly ISymUnmanagedVariable variable;

		public SymbolVariableImpl(ISymUnmanagedVariable variable) {
			this.variable = variable;
		}

		public override int Index {
			get {
				uint result;
				variable.GetAddressField1(out result);
				return (int)result;
			}
		}

		public override PdbLocalAttributes Attributes {
			get {
				uint result;
				variable.GetAttributes(out result);
				if ((result & (uint)CorSymVarFlag.VAR_IS_COMP_GEN) != 0)
					return PdbLocalAttributes.DebuggerHidden;
				return PdbLocalAttributes.None;
			}
		}

		public override string Name {
			get {
				uint count;
				variable.GetName(0, out count, null);
				var chars = new char[count];
				variable.GetName((uint)chars.Length, out count, chars);
				if (chars.Length == 0)
					return string.Empty;
				return new string(chars, 0, chars.Length - 1);
			}
		}

		public override PdbCustomDebugInfo[] CustomDebugInfos {
			get { return emptyPdbCustomDebugInfos; }
		}
		static readonly PdbCustomDebugInfo[] emptyPdbCustomDebugInfos = new PdbCustomDebugInfo[0];
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics.SymbolStore;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using dnlib.DotNet.Pdb.WindowsPdb;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolWriter : ISymbolWriter3 {
		readonly ISymUnmanagedWriter2 writer;
		readonly ISymUnmanagedAsyncMethodPropertiesWriter asyncMethodWriter;
		readonly string pdbFileName;
		readonly Stream pdbStream;
		bool closeCalled;

		public bool SupportsAsyncMethods {
			get { return asyncMethodWriter != null; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="pdbFileName">PDB file name</param>
		public SymbolWriter(ISymUnmanagedWriter2 writer, string pdbFileName) {
			if (writer == null)
				throw new ArgumentNullException("writer");
			if (pdbFileName == null)
				throw new ArgumentNullException("pdbFileName");
			this.writer = writer;
			this.asyncMethodWriter = writer as ISymUnmanagedAsyncMethodPropertiesWriter;
			this.pdbFileName = pdbFileName;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="pdbFileName">PDB file name</param>
		/// <param name="pdbStream">PDB output stream</param>
		public SymbolWriter(ISymUnmanagedWriter2 writer, string pdbFileName, Stream pdbStream) {
			if (writer == null)
				throw new ArgumentNullException("writer");
			if (pdbStream == null)
				throw new ArgumentNullException("pdbStream");
			this.writer = writer;
			this.asyncMethodWriter = writer as ISymUnmanagedAsyncMethodPropertiesWriter;
			this.pdbStream = pdbStream;
			this.pdbFileName = pdbFileName;
		}

		public void Abort() {
			writer.Abort();
		}

		public void Close() {
			if (closeCalled)
				return;
			closeCalled = true;
			writer.Close();
		}

		public void CloseMethod() {
			writer.CloseMethod();
		}

		public void CloseNamespace() {
			writer.CloseNamespace();
		}

		public void CloseScope(int endOffset) {
			writer.CloseScope((uint)endOffset);
		}

		public void DefineAsyncStepInfo(uint[] yieldOffsets, uint[] breakpointOffset, uint[] breakpointMethod) {
			if (asyncMethodWriter == null)
				throw new InvalidOperationException();
			if (yieldOffsets.Length != breakpointOffset.Length || yieldOffsets.Length != breakpointMethod.Length)
				throw new ArgumentException();
			asyncMethodWriter.DefineAsyncStepInfo((uint)yieldOffsets.Length, yieldOffsets, breakpointOffset, breakpointMethod);
		}

		public void DefineCatchHandlerILOffset(uint catchHandlerOffset) {
			if (asyncMethodWriter == null)
				throw new InvalidOperationException();
			asyncMethodWriter.DefineCatchHandlerILOffset(catchHandlerOffset);
		}

		public void DefineConstant(string name, object value, byte[] signature) {
			writer.DefineConstant(name, value, (uint)signature.Length, signature);
		}

		public void DefineConstant2(string name, object value, uint sigToken) {
			writer.DefineConstant2(name, value, sigToken);
		}

		public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType) {
			ISymUnmanagedDocumentWriter unDocWriter;
			writer.DefineDocument(url, ref language, ref languageVendor, ref documentType, out unDocWriter);
			return unDocWriter == null ? null : new SymbolDocumentWriter(unDocWriter);
		}

		public void DefineField(SymbolToken parent, string name, System.Reflection.FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3) {
			writer.DefineField((uint)parent.GetToken(), name, (uint)attributes, (uint)signature.Length, signature, (uint)addrKind, (uint)addr1, (uint)addr2, (uint)addr3);
		}

		public void DefineGlobalVariable(string name, System.Reflection.FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3) {
			writer.DefineGlobalVariable(name, (uint)attributes, (uint)signature.Length, signature, (uint)addrKind, (uint)addr1, (uint)addr2, (uint)addr3);
		}

		public void DefineGlobalVariable2(string name, uint attributes, uint sigToken, uint addrKind, uint addr1, uint addr2, uint addr3) {
			writer.DefineGlobalVariable2(name, attributes, sigToken, addrKind, addr1, addr2, addr3);
		}

		public void DefineKickoffMethod(uint kickoffMethod) {
			if (asyncMethodWriter == null)
				throw new InvalidOperationException();
			asyncMethodWriter.DefineKickoffMethod(kickoffMethod);
		}

		public void DefineLocalVariable(string name, System.Reflection.FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset) {
			writer.DefineLocalVariable(name, (uint)attributes, (uint)signature.Length, signature, (uint)addrKind, (uint)addr1, (uint)addr2, (uint)addr3, (uint)startOffset, (uint)endOffset);
		}

		public void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3) {
			writer.DefineParameter(name, (uint)attributes, (uint)sequence, (uint)addrKind, (uint)addr1, (uint)addr2, (uint)addr3);
		}

		public void DefineSequencePoints(ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns) {
			var doc = document as SymbolDocumentWriter;
			if (doc == null)
				throw new ArgumentException("document isn't a non-null SymbolDocumentWriter instance");
			if (offsets == null || lines == null || columns == null ||
				endLines == null || endColumns == null ||
				offsets.Length != lines.Length ||
				offsets.Length != columns.Length ||
				offsets.Length != endLines.Length ||
				offsets.Length != endColumns.Length)
				throw new ArgumentException("Invalid arrays");
			writer.DefineSequencePoints(doc.SymUnmanagedDocumentWriter, (uint)offsets.Length, offsets, lines, columns, endLines, endColumns);
		}

		public void DefineSequencePoints(ISymbolDocumentWriter document, uint arraySize, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns) {
			var doc = document as SymbolDocumentWriter;
			if (doc == null)
				throw new ArgumentException("document isn't a non-null SymbolDocumentWriter instance");
			writer.DefineSequencePoints(doc.SymUnmanagedDocumentWriter, arraySize, offsets, lines, columns, endLines, endColumns);
		}

		public void Initialize(IntPtr emitter, string filename, bool fFullBuild) {
			writer.Initialize(emitter, filename, null, fFullBuild);
		}

		public void OpenMethod(SymbolToken method) {
			writer.OpenMethod((uint)method.GetToken());
		}

		public void OpenNamespace(string name) {
			writer.OpenNamespace(name);
		}

		public int OpenScope(int startOffset) {
			uint result;
			writer.OpenScope((uint)startOffset, out result);
			return (int)result;
		}

		public void RemapToken(uint oldToken, uint newToken) {
			writer.RemapToken(oldToken, newToken);
		}

		public void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn) {
			var sdoc = startDoc as SymbolDocumentWriter;
			if (sdoc == null)
				throw new ArgumentException("startDoc isn't a non-null SymbolDocumentWriter instance");
			var edoc = endDoc as SymbolDocumentWriter;
			if (edoc == null)
				throw new ArgumentException("endDoc isn't a non-null SymbolDocumentWriter instance");
			writer.SetMethodSourceRange(sdoc.SymUnmanagedDocumentWriter, (uint)startLine, (uint)startColumn, edoc.SymUnmanagedDocumentWriter, (uint)endLine, (uint)endColumn);
		}

		public void SetScopeRange(int scopeID, int startOffset, int endOffset) {
			writer.SetScopeRange((uint)scopeID, (uint)startOffset, (uint)endOffset);
		}

		public void SetSymAttribute(SymbolToken parent, string name, byte[] data) {
			writer.SetSymAttribute((uint)parent.GetToken(), name, (uint)data.Length, data);
		}

		public void SetUnderlyingWriter(IntPtr underlyingWriter) {
			throw new NotSupportedException();
		}

		public void SetUserEntryPoint(SymbolToken entryMethod) {
			writer.SetUserEntryPoint((uint)entryMethod.GetToken());
		}

		public void UsingNamespace(string fullName) {
			writer.UsingNamespace(fullName);
		}

		public byte[] GetDebugInfo(out IMAGE_DEBUG_DIRECTORY pIDD) {
			uint size;
			writer.GetDebugInfo(out pIDD, 0, out size, null);
			var buffer = new byte[size];
			writer.GetDebugInfo(out pIDD, size, out size, buffer);
			return buffer;
		}

		public void DefineLocalVariable2(string name, uint attributes, uint sigToken, uint addrKind, uint addr1, uint addr2, uint addr3, uint startOffset, uint endOffset) {
			writer.DefineLocalVariable2(name, attributes, sigToken, addrKind, addr1, addr2, addr3, startOffset, endOffset);
		}

		public void Initialize(MetaData metaData) {
			if (pdbStream != null)
				writer.Initialize(new MDEmitter(metaData), pdbFileName, new StreamIStream(pdbStream), true);
			else if (!string.IsNullOrEmpty(pdbFileName))
				writer.Initialize(new MDEmitter(metaData), pdbFileName, null, true);
			else
				throw new InvalidOperationException();
		}

		public void Dispose() {
			Marshal.FinalReleaseComObject(writer);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Dss/SymbolWriterCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using dnlib.DotNet.Pdb.WindowsPdb;

namespace dnlib.DotNet.Pdb.Dss {
	/// <summary>
	/// Creates a <see cref="ISymbolWriter2"/>
	/// </summary>
	static class SymbolWriterCreator {
		static readonly Guid CLSID_CorSymWriter_SxS = new Guid(0x0AE2DEB0, 0xF901, 0x478B, 0xBB, 0x9F, 0x88, 0x1E, 0xE8, 0x06, 0x67, 0x88);

		/// <summary>
		/// Creates a <see cref="ISymUnmanagedWriter2"/> instance
		/// </summary>
		/// <returns>A new <see cref="ISymUnmanagedWriter2"/> instance</returns>
		public static ISymUnmanagedWriter2 CreateSymUnmanagedWriter2() {
			return (ISymUnmanagedWriter2)Activator.CreateInstance(Type.GetTypeFromCLSID(CLSID_CorSymWriter_SxS));
		}

		/// <summary>
		/// Creates a new <see cref="ISymbolWriter2"/> instance
		/// </summary>
		/// <param name="pdbFileName">PDB file name</param>
		/// <returns>A new <see cref="ISymbolWriter2"/> instance</returns>
		public static ISymbolWriter2 Create(string pdbFileName) {
			if (File.Exists(pdbFileName))
				File.Delete(pdbFileName);
			return new SymbolWriter(CreateSymUnmanagedWriter2(), pdbFileName);
		}

		/// <summary>
		/// Creates a new <see cref="ISymbolWriter2"/> instance
		/// </summary>
		/// <param name="pdbStream">PDB output stream</param>
		/// <param name="pdbFileName">PDB file name</param>
		/// <returns>A new <see cref="ISymbolWriter2"/> instance</returns>
		public static ISymbolWriter2 Create(Stream pdbStream, string pdbFileName) {
			return new SymbolWriter(CreateSymUnmanagedWriter2(), pdbFileName, pdbStream);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/DbiDocument.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Diagnostics.SymbolStore;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiDocument : SymbolDocument {
		readonly string url;
		Guid language;
		Guid languageVendor;
		Guid documentType;
		Guid checkSumAlgorithmId;
		byte[] checkSum;

		public override string URL {
			get { return url; }
		}
		public override Guid Language {
			get { return language; }
		}
		public override Guid LanguageVendor {
			get { return languageVendor; }
		}
		public override Guid DocumentType {
			get { return documentType; }
		}
		public override Guid CheckSumAlgorithmId {
			get { return checkSumAlgorithmId; }
		}
		public override byte[] CheckSum {
			get { return checkSum; }
		}
		public override PdbCustomDebugInfo[] CustomDebugInfos {
			get { return emptyPdbCustomDebugInfos; }
		}
		static readonly PdbCustomDebugInfo[] emptyPdbCustomDebugInfos = new PdbCustomDebugInfo[0];

		public DbiDocument(string url) {
			this.url = url;
			documentType = SymDocumentType.Text;
		}

		public void Read(IImageStream stream) {
			stream.Position = 0;
			language = new Guid(stream.ReadBytes(0x10));
			languageVendor = new Guid(stream.ReadBytes(0x10));
			documentType = new Guid(stream.ReadBytes(0x10));
			checkSumAlgorithmId = new Guid(stream.ReadBytes(0x10));

			var len = stream.ReadInt32();
			if (stream.ReadUInt32() != 0)
				throw new PdbException("Unexpected value");

			checkSum = stream.ReadBytes(len);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/DbiFunction.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiFunction : SymbolMethod {
		public override int Token {
			get { return token; }
		}
		internal int token;

		internal PdbReader reader;

		public string Name { get; private set; }
		public PdbAddress Address { get; private set; }
		public DbiScope Root { get; private set; }
		public List<SymbolSequencePoint> Lines {
			get { return lines; }
			set { lines = value; }
		}
		List<SymbolSequencePoint> lines;

		public void Read(IImageStream stream, long recEnd) {
			stream.Position += 4;
			var end = stream.ReadUInt32();
			stream.Position += 4;
			var len = stream.ReadUInt32();
			stream.Position += 8;
			token = stream.ReadInt32();
			Address = PdbAddress.ReadAddress(stream);
			stream.Position += 1 + 2;
			Name = PdbReader.ReadCString(stream);

			stream.Position = recEnd;
			Root = new DbiScope(this, null, "", Address.Offset, len);
			Root.Read(new RecursionCounter(), stream, end);
			FixOffsets(new RecursionCounter(), Root);
		}

		void FixOffsets(RecursionCounter counter, DbiScope scope) {
			if (!counter.Increment())
				return;

			scope.startOffset -= (int)Address.Offset;
			scope.endOffset -= (int)Address.Offset;
			foreach (var child in scope.Children)
				FixOffsets(counter, (DbiScope)child);

			counter.Decrement();
		}

		public override SymbolScope RootScope {
			get { return Root; }
		}

		public override IList<SymbolSequencePoint> SequencePoints {
			get {
				var l = lines;
				if (l == null)
					return emptySymbolSequencePoints;
				return l;
			}
		}
		static readonly SymbolSequencePoint[] emptySymbolSequencePoints = new SymbolSequencePoint[0];

		const string asyncMethodInfoAttributeName = "asyncMethodInfo";
		public int AsyncKickoffMethod {
			get {
				var data = Root.GetSymAttribute(asyncMethodInfoAttributeName);
				if (data == null)
					return 0;
				return BitConverter.ToInt32(data, 0);
			}
		}

		public uint? AsyncCatchHandlerILOffset {
			get {
				var data = Root.GetSymAttribute(asyncMethodInfoAttributeName);
				if (data == null)
					return null;
				uint token = BitConverter.ToUInt32(data, 4);
				return token == uint.MaxValue ? (uint?)null : token;
			}
		}

		public IList<SymbolAsyncStepInfo> AsyncStepInfos {
			get {
				if (asyncStepInfos == null)
					asyncStepInfos = CreateSymbolAsyncStepInfos();
				return asyncStepInfos;
			}
		}
		volatile SymbolAsyncStepInfo[] asyncStepInfos;

		SymbolAsyncStepInfo[] CreateSymbolAsyncStepInfos() {
			var data = Root.GetSymAttribute(asyncMethodInfoAttributeName);
			if (data == null)
				return emptySymbolAsyncStepInfos;
			int pos = 8;
			int count = BitConverter.ToInt32(data, pos);
			pos += 4;
			if (pos + (long)count * 12 > data.Length)
				return emptySymbolAsyncStepInfos;
			if (count == 0)
				return emptySymbolAsyncStepInfos;
			var res = new SymbolAsyncStepInfo[count];
			for (int i = 0; i < res.Length; i++) {
				res[i] = new SymbolAsyncStepInfo(BitConverter.ToUInt32(data, pos), BitConverter.ToUInt32(data, pos + 8), BitConverter.ToUInt32(data, pos + 4));
				pos += 12;
			}
			return res;
		}
		static readonly SymbolAsyncStepInfo[] emptySymbolAsyncStepInfos = new SymbolAsyncStepInfo[0];

		public override void GetCustomDebugInfos(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			reader.GetCustomDebugInfos(this, method, body, result);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/DbiModule.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiModule {
		public DbiModule() {
			Functions = new List<DbiFunction>();
			Documents = new List<DbiDocument>();
		}

		public ushort StreamId { get; private set; }
		uint cbSyms;
		uint cbOldLines;
		uint cbLines;

		public string ModuleName { get; private set; }
		public string ObjectName { get; private set; }

		public IList<DbiFunction> Functions { get; private set; }
		public IList<DbiDocument> Documents { get; private set; }

		public void Read(IImageStream stream) {
			stream.Position += 34;
			StreamId = stream.ReadUInt16();
			cbSyms = stream.ReadUInt32();
			cbOldLines = stream.ReadUInt32();
			cbLines = stream.ReadUInt32();
			stream.Position += 16;

			if ((int)cbSyms < 0)
				cbSyms = 0;
			if ((int)cbOldLines < 0)
				cbOldLines = 0;
			if ((int)cbLines < 0)
				cbLines = 0;

			ModuleName = PdbReader.ReadCString(stream);
			ObjectName = PdbReader.ReadCString(stream);

			stream.Position = (stream.Position + 3) & (~3);
		}

		public void LoadFunctions(PdbReader reader, IImageStream stream) {
			stream.Position = 0;
			using (var substream = stream.Create(stream.FileOffset + stream.Position, cbSyms))
				ReadFunctions(substream);

			if (Functions.Count > 0) {
				stream.Position += cbSyms + cbOldLines;
				using (var substream = stream.Create(stream.FileOffset + stream.Position, cbLines))
					ReadLines(reader, substream);
			}
		}

		void ReadFunctions(IImageStream stream) {
			if (stream.ReadUInt32() != 4)
				throw new PdbException("Invalid signature");

			while (stream.Position < stream.Length) {
				var size = stream.ReadUInt16();
				var begin = stream.Position;
				var end = begin + size;

				var type = (SymbolType)stream.ReadUInt16();
				switch (type) {
					case SymbolType.S_GMANPROC:
					case SymbolType.S_LMANPROC:
						var func = new DbiFunction();
						func.Read(stream, end);
						Functions.Add(func);
						break;
					default:
						stream.Position = end;
						break;
				}
			}
		}

		void ReadLines(PdbReader reader, IImageStream stream) {
			var docs = new Dictionary<long, DbiDocument>();

			stream.Position = 0;
			while (stream.Position < stream.Length) {
				var sig = (ModuleStreamType)stream.ReadUInt32();
				var size = stream.ReadUInt32();
				var begin = stream.Position;
				var end = (begin + size + 3) & ~3;

				if (sig == ModuleStreamType.FileInfo)
					ReadFiles(reader, docs, stream, end);

				stream.Position = end;
			}

			var sortedFuncs = new DbiFunction[Functions.Count];
			Functions.CopyTo(sortedFuncs, 0);
			Array.Sort(sortedFuncs, (a, b) => a.Address.CompareTo(b.Address));

			stream.Position = 0;
			while (stream.Position < stream.Length) {
				var sig = (ModuleStreamType)stream.ReadUInt32();
				var size = stream.ReadUInt32();
				var begin = stream.Position;
				var end = begin + size;

				if (sig == ModuleStreamType.Lines)
					ReadLines(sortedFuncs, docs, stream, end);

				stream.Position = end;
			}
		}

		void ReadFiles(PdbReader reader, Dictionary<long, DbiDocument> documents, IImageStream stream, long end) {
			var begin = stream.Position;
			while (stream.Position < end) {
				var id = stream.Position - begin;

				var nameId = stream.ReadUInt32();
				var len = stream.ReadByte();
				/*var type = */stream.ReadByte();
				var doc = reader.GetDocument(nameId);
				documents.Add(id, doc);

				stream.Position += len;
				stream.Position = (stream.Position + 3) & (~3);
			}
		}

		void ReadLines(DbiFunction[] funcs, Dictionary<long, DbiDocument> documents, IImageStream stream, long end) {
			var address = PdbAddress.ReadAddress(stream);

			int first = 0;
			int last = funcs.Length - 1;
			int found = -1;
			while (first <= last) {
				var index = first + ((last - first) >> 1);
				var addr = funcs[index].Address;
				if (addr < address) {
					first = index + 1;
				}
				else if (addr > address) {
					last = index - 1;
				}
				else {
					found = index;
					break;
				}
			}
			if (found == -1)
				return;

			var flags = stream.ReadUInt16();
			stream.Position += 4;

			if (funcs[found].Lines == null) {
				while (found > 0) {
					var prevFunc = funcs[found - 1];
					if (prevFunc != null || prevFunc.Address != address)
						break;
					found--;
				}
			}
			else {
				while (found < funcs.Length - 1 && funcs[found] != null) {
					var nextFunc = funcs[found + 1];
					if (nextFunc.Address != address)
						break;
					found++;
				}
			}
			var func = funcs[found];
			if (func.Lines != null)
				return;
			func.Lines = new List<SymbolSequencePoint>();

			while (stream.Position < end) {
				var document = documents[stream.ReadUInt32()];
				var count = stream.ReadUInt32();
				stream.Position += 4;

				const int LINE_ENTRY_SIZE = 8;
				const int COL_ENTRY_SIZE = 4;
				var lineTablePos = stream.Position;
				var colTablePos = stream.Position + count * LINE_ENTRY_SIZE;

				for (uint i = 0; i < count; i++) {
					stream.Position = lineTablePos + i * LINE_ENTRY_SIZE;

					var line = new SymbolSequencePoint {
						Document = document
					};
					line.Offset = stream.ReadInt32();
					var lineFlags = stream.ReadUInt32();

					line.Line = (int)(lineFlags & 0x00ffffff);
					line.EndLine = line.Line + (int)((lineFlags >> 24) & 0x7F);
					if ((flags & 1) != 0) {
						stream.Position = colTablePos + i * COL_ENTRY_SIZE;
						line.Column = stream.ReadUInt16();
						line.EndColumn = stream.ReadUInt16();
					}

					func.Lines.Add(line);
				}
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/DbiNamespace.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiNamespace : SymbolNamespace {
		public override string Name {
			get { return name; }
		}
		readonly string name;

		public DbiNamespace(string ns) {
			name = ns;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/DbiScope.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiScope : SymbolScope {
		readonly SymbolMethod method;
		readonly SymbolScope parent;
		internal int startOffset;
		internal int endOffset;
		readonly List<SymbolScope> childrenList;
		readonly List<SymbolVariable> localsList;
		readonly List<SymbolNamespace> namespacesList;

		public override SymbolMethod Method {
			get { return method; }
		}

		public override SymbolScope Parent {
			get { return parent; }
		}

		public override int StartOffset {
			get { return startOffset; }
		}

		public override int EndOffset {
			get { return endOffset; }
		}

		public override IList<SymbolScope> Children {
			get { return childrenList; }
		}

		public override IList<SymbolVariable> Locals {
			get { return localsList; }
		}

		public override IList<SymbolNamespace> Namespaces {
			get { return namespacesList; }
		}

		public override IList<PdbCustomDebugInfo> CustomDebugInfos {
			get { return emptyPdbCustomDebugInfos; }
		}
		static readonly PdbCustomDebugInfo[] emptyPdbCustomDebugInfos = new PdbCustomDebugInfo[0];

		public override PdbImportScope ImportScope {
			get { return null; }
		}

		public DbiScope(SymbolMethod method, SymbolScope parent, string name, uint offset, uint length) {
			this.method = method;
			this.parent = parent;
			Name = name;
			startOffset = (int)offset;
			endOffset = (int)(offset + length);

			childrenList = new List<SymbolScope>();
			localsList = new List<SymbolVariable>();
			namespacesList = new List<SymbolNamespace>();
		}

		public string Name { get; private set; }

		List<OemInfo> oemInfos;
		List<ConstantInfo> constants;

		struct ConstantInfo {
			public string Name;
			public uint SignatureToken;
			public object Value;
			public ConstantInfo(string name, uint signatureToken, object value) {
				Name = name;
				SignatureToken = signatureToken;
				Value = value;
			}
		}

		internal struct OemInfo {
			public readonly string Name;
			public readonly byte[] Data;
			public OemInfo(string name, byte[] data) {
				Name = name;
				Data = data;
			}
			public override string ToString() {
				return Name + " = (" + Data.Length.ToString() + " bytes)";
			}
		}

		static readonly byte[] dotNetOemGuid = new byte[] {
			0xC9, 0x3F, 0xEA, 0xC6, 0xB3, 0x59, 0xD6, 0x49, 0xBC, 0x25, 0x09, 0x02, 0xBB, 0xAB, 0xB4, 0x60
		};

		public void Read(RecursionCounter counter, IImageStream stream, uint scopeEnd) {
			if (!counter.Increment())
				throw new PdbException("Scopes too deep");

			while (stream.Position < scopeEnd) {
				var size = stream.ReadUInt16();
				var begin = stream.Position;
				var end = begin + size;

				var type = (SymbolType)stream.ReadUInt16();
				DbiScope child = null;
				uint? childEnd = null;
				string name;
				switch (type) {
					case SymbolType.S_BLOCK32: {
						stream.Position += 4;
						childEnd = stream.ReadUInt32();
						var len = stream.ReadUInt32();
						var addr = PdbAddress.ReadAddress(stream);
						name = PdbReader.ReadCString(stream);
						child = new DbiScope(method, this, name, addr.Offset, len);
						break;
					}
					case SymbolType.S_UNAMESPACE:
						namespacesList.Add(new DbiNamespace(PdbReader.ReadCString(stream)));
						break;
					case SymbolType.S_MANSLOT: {
						var variable = new DbiVariable();
						variable.Read(stream);
						localsList.Add(variable);
						break;
					}
					case SymbolType.S_OEM:
						if (stream.Position + 20 > end)
							break;
						if (!ReadAndCompareBytes(stream, end, dotNetOemGuid)) {
							Debug.Fail("Unknown OEM record GUID, not .NET GUID");
							break;
						}
						stream.Position += 4;// typeIndex or 0
						name = ReadUnicodeString(stream, end);
						Debug.Assert(name != null);
						if (name == null)
							break;
						var data = stream.ReadBytes((int)(end - stream.Position));
						if (oemInfos == null)
							oemInfos = new List<OemInfo>(1);
						oemInfos.Add(new OemInfo(name, data));	
						break;
					case SymbolType.S_MANCONSTANT:
						uint signatureToken = stream.ReadUInt32();
						object value;
						if (!NumericReader.TryReadNumeric(stream, end, out value))
							break;
						name = PdbReader.ReadCString(stream);
						if (constants == null)
							constants = new List<ConstantInfo>();
						constants.Add(new ConstantInfo(name, signatureToken, value));
						break;
					case SymbolType.S_END:
						break;
					default:
						break;
				}

				stream.Position = end;
				if (child != null) {
					child.Read(counter, stream, childEnd.Value);
					childrenList.Add(child);
					child = null;
				}
			}
			counter.Decrement();
			if (stream.Position != scopeEnd)
				Debugger.Break();
		}

		static string ReadUnicodeString(IImageStream stream, long end) {
			var sb = new StringBuilder();
			for (;;) {
				if (stream.Position + 2 > end)
					return null;
				var c = (char)stream.ReadUInt16();
				if (c == 0)
					break;
				sb.Append(c);
			}
			return sb.ToString();
		}

		static bool ReadAndCompareBytes(IImageStream stream, long end, byte[] bytes) {
			if (stream.Position + bytes.Length > end)
				return false;
			for (int i = 0; i < bytes.Length; i++) {
				if (stream.ReadByte() != bytes[i])
					return false;
			}
			return true;
		}

		public override IList<PdbConstant> GetConstants(ModuleDef module, GenericParamContext gpContext) {
			if (constants == null)
				return emptySymbolConstants;
			var res = new PdbConstant[constants.Count];
			for (int i = 0; i < res.Length; i++) {
				var info = constants[i];
				TypeSig signature;
				var saSig = module.ResolveToken(info.SignatureToken, gpContext) as StandAloneSig;
				var fieldSig = saSig == null ? null : saSig.Signature as FieldSig;
				if (fieldSig == null) {
					Debug.Fail("Constant without a signature");
					signature = null;
				}
				else
					signature = fieldSig.Type;
				res[i] = new PdbConstant(info.Name, signature, info.Value);
			}
			return res;
		}
		static readonly PdbConstant[] emptySymbolConstants = new PdbConstant[0];

		internal byte[] GetSymAttribute(string name) {
			if (oemInfos == null)
				return null;
			foreach (var info in oemInfos) {
				if (info.Name == name)
					return info.Data;
			}
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/DbiVariable.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiVariable : SymbolVariable {
		public override string Name {
			get { return name; }
		}
		string name;

		public override PdbLocalAttributes Attributes {
			get { return attributes; }
		}
		PdbLocalAttributes attributes;

		public override int Index {
			get { return index; }
		}
		int index;

		public override PdbCustomDebugInfo[] CustomDebugInfos {
			get { return emptyPdbCustomDebugInfos; }
		}
		static readonly PdbCustomDebugInfo[] emptyPdbCustomDebugInfos = new PdbCustomDebugInfo[0];

		public void Read(IImageStream stream) {
			index = stream.ReadInt32();
			stream.Position += 10;
			attributes = GetAttributes(stream.ReadUInt16());
			name = PdbReader.ReadCString(stream);
		}

		static PdbLocalAttributes GetAttributes(uint flags) {
			PdbLocalAttributes res = 0;
			const int fCompGenx = 4;
			if ((flags & fCompGenx) != 0)
				res |= PdbLocalAttributes.DebuggerHidden;
			return res;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/ModuleStreamType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb.Managed {
	enum ModuleStreamType : uint {
		Symbols = 0xF1,
		Lines = 0xF2,
		StringTable = 0xF3,
		FileInfo = 0xF4,
		FrameData = 0xF5,
		InlineeLines = 0xF6,
		CrossScopeImports = 0xF7,
		CrossScopeExports = 0xF8,
		ILLines = 0xF9,
		FuncMDTokenMap = 0xFA,
		TypeMDTokenMap = 0xFB,
		MergedAssemblyInput = 0xFC,
	}
}


================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/MsfStream.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

ï»¿using System;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	sealed class MsfStream {
		public MsfStream(IImageStream[] pages, uint length) {
			byte[] buf = new byte[length];
			int offset = 0;
			foreach (var page in pages) {
				page.Position = 0;
				int len = Math.Min((int)page.Length, (int)(length - offset));
				offset += page.Read(buf, offset, len);
			}
			Content = new MemoryImageStream(0, buf, 0, buf.Length);
		}

		public IImageStream Content { get; set; }
	}
}


================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/NumericLeaf.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb.Managed {
	enum NumericLeaf : ushort {
		LF_NUMERIC			= 0x8000,
		LF_CHAR				= 0x8000,
		LF_SHORT			= 0x8001,
		LF_USHORT			= 0x8002,
		LF_LONG				= 0x8003,
		LF_ULONG			= 0x8004,
		LF_REAL32			= 0x8005,
		LF_REAL64			= 0x8006,
		LF_REAL80			= 0x8007,
		LF_REAL128			= 0x8008,
		LF_QUADWORD			= 0x8009,
		LF_UQUADWORD		= 0x800A,
		LF_REAL48			= 0x800B,
		LF_COMPLEX32		= 0x800C,
		LF_COMPLEX64		= 0x800D,
		LF_COMPLEX80		= 0x800E,
		LF_COMPLEX128		= 0x800F,
		LF_VARSTRING		= 0x8010,
		LF_RESERVED_8011	= 0x8011,
		LF_RESERVED_8012	= 0x8012,
		LF_RESERVED_8013	= 0x8013,
		LF_RESERVED_8014	= 0x8014,
		LF_RESERVED_8015	= 0x8015,
		LF_RESERVED_8016	= 0x8016,
		LF_OCTWORD			= 0x8017,
		LF_UOCTWORD			= 0x8018,
		LF_VARIANT			= 0x8019,
		LF_DATE				= 0x801A,
		LF_UTF8STRING		= 0x801B,
		LF_REAL16			= 0x801C,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/NumericReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Text;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	static class NumericReader {
		public static bool TryReadNumeric(IImageStream stream, long end, out object value) {
			value = null;
			if (stream.Position + 2 > end)
				return false;
			var numLeaf = (NumericLeaf)stream.ReadUInt16();
			if (numLeaf < NumericLeaf.LF_NUMERIC) {
				value = (short)numLeaf;
				return true;
			}

			switch (numLeaf) {
			case NumericLeaf.LF_CHAR:
				if (stream.Position > end)
					return false;
				value = stream.ReadSByte();
				return true;

			case NumericLeaf.LF_SHORT:
				if (stream.Position + 2 > end)
					return false;
				value = stream.ReadInt16();
				return true;

			case NumericLeaf.LF_USHORT:
				if (stream.Position + 2 > end)
					return false;
				value = stream.ReadUInt16();
				return true;

			case NumericLeaf.LF_LONG:
				if (stream.Position + 4 > end)
					return false;
				value = stream.ReadInt32();
				return true;

			case NumericLeaf.LF_ULONG:
				if (stream.Position + 4 > end)
					return false;
				value = stream.ReadUInt32();
				return true;

			case NumericLeaf.LF_REAL32:
				if (stream.Position + 4 > end)
					return false;
				value = stream.ReadSingle();
				return true;

			case NumericLeaf.LF_REAL64:
				if (stream.Position + 8 > end)
					return false;
				value = stream.ReadDouble();
				return true;

			case NumericLeaf.LF_QUADWORD:
				if (stream.Position + 8 > end)
					return false;
				value = stream.ReadInt64();
				return true;

			case NumericLeaf.LF_UQUADWORD:
				if (stream.Position + 8 > end)
					return false;
				value = stream.ReadUInt64();
				return true;

			case NumericLeaf.LF_VARSTRING:
				if (stream.Position + 2 > end)
					return false;
				int varStrLen = stream.ReadUInt16();
				if (stream.Position + varStrLen > end)
					return false;
				value = Encoding.UTF8.GetString(stream.ReadBytes(varStrLen));
				return true;

			case NumericLeaf.LF_VARIANT:
				if (stream.Position + 0x10 > end)
					return false;
				int v0 = stream.ReadInt32();
				int v1 = stream.ReadInt32();
				int v2 = stream.ReadInt32();
				int v3 = stream.ReadInt32();
				byte scale = (byte)(v0 >> 16);
				if (scale <= 28)
					value = new decimal(v2, v3, v1, v0 < 0, scale);
				else
					value = null;
				return true;

			default:
				return false;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/PdbAddress.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	/// <summary>
	/// An address in the image
	/// </summary>
	[DebuggerDisplay("{Section}:{Offset}")]
	struct PdbAddress : IEquatable<PdbAddress>, IComparable<PdbAddress> {
		/// <summary>
		/// Section
		/// </summary>
		public readonly ushort Section;

		/// <summary>
		/// Offset in <see cref="Section"/>
		/// </summary>
		public readonly uint Offset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="section">Section</param>
		/// <param name="offset">Offset in <paramref name="section"/></param>
		public PdbAddress(ushort section, int offset) {
			this.Section = section;
			this.Offset = (uint)offset;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="section">Section</param>
		/// <param name="offset">Offset in <paramref name="section"/></param>
		public PdbAddress(ushort section, uint offset) {
			this.Section = section;
			this.Offset = offset;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is less than or equal to <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator <=(PdbAddress a, PdbAddress b) {
			return a.CompareTo(b) <= 0;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is less than <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator <(PdbAddress a, PdbAddress b) {
			return a.CompareTo(b) < 0;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is greater than or equal to <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator >=(PdbAddress a, PdbAddress b) {
			return a.CompareTo(b) >= 0;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is greater than <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator >(PdbAddress a, PdbAddress b) {
			return a.CompareTo(b) > 0;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is equal to <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator ==(PdbAddress a, PdbAddress b) {
			return a.Equals(b);
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is not equal to <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator !=(PdbAddress a, PdbAddress b) {
			return !a.Equals(b);
		}

		/// <summary>
		/// Compares this instance with <paramref name="other"/> and returns less than 0 if it's
		/// less than <paramref name="other"/>, 0 if it's equal to <paramref name="other"/> and
		/// greater than 0 if it's greater than <paramref name="other"/>
		/// </summary>
		/// <param name="other">Other instance</param>
		/// <returns></returns>
		public int CompareTo(PdbAddress other) {
			if (Section != other.Section)
				return Section.CompareTo(other.Section);
			return Offset.CompareTo(other.Offset);
		}

		/// <summary>
		/// Compares this to another instance
		/// </summary>
		/// <param name="other">The other one</param>
		/// <returns><c>true</c> if they're equal</returns>
		public bool Equals(PdbAddress other) {
			return Section == other.Section &&
					Offset == other.Offset;
		}

		/// <summary>
		/// Compares this to another instance
		/// </summary>
		/// <param name="obj">The other one</param>
		/// <returns><c>true</c> if they're equal</returns>
		public override bool Equals(object obj) {
			if (!(obj is PdbAddress))
				return false;
			return Equals((PdbAddress)obj);
		}

		/// <summary>
		/// Gets the hash code
		/// </summary>
		/// <returns>Hash code</returns>
		public override int GetHashCode() {
			return (Section << 16) ^ (int)Offset;
		}

		/// <summary>
		/// ToString() override
		/// </summary>
		/// <returns></returns>
		public override string ToString() {
			return string.Format("{0:X4}:{1:X8}", Section, Offset);
		}

		/// <summary>
		/// Reads a 32-bit offset followed by a 16-bit section and creates a new <see cref="PdbAddress"/>
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <returns></returns>
		public static PdbAddress ReadAddress(IBinaryReader reader) {
			uint offs = reader.ReadUInt32();
			return new PdbAddress(reader.ReadUInt16(), offs);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/PdbException.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Runtime.Serialization;

namespace dnlib.DotNet.Pdb.Managed {
	/// <summary>
	/// Exception that is thrown when <see cref="PdbReader"/> encounters an error.
	/// </summary>
	[Serializable]
	sealed class PdbException : Exception {
		/// <summary>
		/// Constructor
		/// </summary>
		public PdbException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public PdbException(string message)
			: base("Failed to read PDB: " + message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="innerException">Inner exception</param>
		public PdbException(Exception innerException)
			: base("Failed to read PDB: " + innerException.Message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		public PdbException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/PdbReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.DotNet.Pdb.WindowsPdb;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	/// <summary>
	/// A managed PDB reader implementation for .NET modules.
	/// </summary>
	sealed class PdbReader : SymbolReader {
		MsfStream[] streams;
		Dictionary<string, uint> names;
		Dictionary<uint, string> strings;
		List<DbiModule> modules;
		ModuleDef module;

		const int STREAM_ROOT = 0;
		const int STREAM_NAMES = 1;
		const int STREAM_TPI = 2;
		const int STREAM_DBI = 3;
		const ushort STREAM_INVALID_INDEX = ushort.MaxValue;

		Dictionary<string, DbiDocument> documents;
		Dictionary<int, DbiFunction> functions;
		uint entryPt;

		public override PdbFileKind PdbFileKind {
			get { return PdbFileKind.WindowsPDB; }
		}

		/// <summary>
		/// The age of PDB file.
		/// </summary>
		public uint Age { get; private set; }
		/// <summary>
		/// The GUID of PDB file.
		/// </summary>
		public Guid Guid { get; private set; }

		public override void Initialize(ModuleDef module) {
			this.module = module;
		}

		/// <summary>
		/// Read the PDB in the specified stream.
		/// </summary>
		/// <param name="stream">The stream that contains the PDB file</param>
		public void Read(IImageStream stream) {
			try {
				ReadInternal(stream);
			}
			catch (Exception ex) {
				if (ex is PdbException)
					throw;
				throw new PdbException(ex);
			}
			finally {
				streams = null;
				names = null;
				strings = null;
				modules = null;
			}
		}

		static uint RoundUpDiv(uint value, uint divisor) {
			return (value + divisor - 1) / divisor;
		}

		void ReadInternal(IImageStream stream) {
			stream.Position = 0;
			string sig = Encoding.ASCII.GetString(stream.ReadBytes(30));
			if (sig != "Microsoft C/C++ MSF 7.00\r\n\u001ADS\0")
				throw new PdbException("Invalid signature");
			stream.Position += 2;

			uint pageSize = stream.ReadUInt32();
			/*uint fpm = */stream.ReadUInt32();
			uint pageCount = stream.ReadUInt32();
			uint rootSize = stream.ReadUInt32();
			stream.ReadUInt32();
			var numOfRootPages = RoundUpDiv(rootSize, pageSize);
			var numOfPtrPages = RoundUpDiv(numOfRootPages * 4, pageSize);
			if (pageCount * pageSize != stream.Length)
				throw new PdbException("File size mismatch");

			var pages = new IImageStream[pageCount];
			try {
				FileOffset offset = 0;
				for (uint i = 0; i < pageCount; i++) {
					pages[i] = stream.Create(offset, pageSize);
					offset += pageSize;
				}

				var rootPages = new IImageStream[numOfRootPages];
				int pageIndex = 0;
				for (int i = 0; i < numOfPtrPages && pageIndex < numOfRootPages; i++) {
					var ptrPage = pages[stream.ReadUInt32()];
					ptrPage.Position = 0;
					for (; ptrPage.Position < ptrPage.Length && pageIndex < numOfRootPages; pageIndex++)
						rootPages[pageIndex] = pages[ptrPage.ReadUInt32()];
				}

				ReadRootDirectory(new MsfStream(rootPages, rootSize), pages, pageSize);
			}
			finally {
				foreach (var page in pages) {
					if (page != null)
						page.Dispose();
				}
			}

			ReadNames();
			ReadStringTable();
			var tokenMapStream = ReadModules();

			documents = new Dictionary<string, DbiDocument>(StringComparer.OrdinalIgnoreCase);
			foreach (var module in modules) {
				if (IsValidStreamIndex(module.StreamId))
					module.LoadFunctions(this, streams[module.StreamId].Content);
			}

			if (IsValidStreamIndex(tokenMapStream ?? STREAM_INVALID_INDEX))
				ApplyRidMap(streams[tokenMapStream.Value].Content);

			functions = new Dictionary<int, DbiFunction>();
			foreach (var module in modules) {
				foreach (var func in module.Functions) {
					func.reader = this;
					functions.Add(func.Token, func);
				}
			}
		}

		bool IsValidStreamIndex(ushort index) {
			return index != STREAM_INVALID_INDEX && index < streams.Length;
		}

		void ReadRootDirectory(MsfStream stream, IImageStream[] pages, uint pageSize) {
			uint streamNum = stream.Content.ReadUInt32();
			uint[] streamSizes = new uint[streamNum];
			for (int i = 0; i < streamSizes.Length; i++)
				streamSizes[i] = stream.Content.ReadUInt32();

			streams = new MsfStream[streamNum];
			for (int i = 0; i < streamSizes.Length; i++) {
				if (streamSizes[i] == 0xffffffff) {
					streams[i] = null;
					continue;
				}
				var pageCount = RoundUpDiv(streamSizes[i], pageSize);
				var streamPages = new IImageStream[pageCount];
				for (int j = 0; j < streamPages.Length; j++)
					streamPages[j] = pages[stream.Content.ReadUInt32()];
				streams[i] = new MsfStream(streamPages, streamSizes[i]);
			}
		}

		void ReadNames() {
			var stream = streams[STREAM_NAMES].Content;
			stream.Position = 8;
			Age = stream.ReadUInt32();
			Guid = new Guid(stream.ReadBytes(0x10));

			uint nameSize = stream.ReadUInt32();
			using (var nameData = stream.Create(stream.FileOffset + stream.Position, nameSize)) {
				stream.Position += nameSize;

				/*uint entryCount = */stream.ReadUInt32();
				uint entryCapacity = stream.ReadUInt32();
				var entryOk = new BitArray(stream.ReadBytes(stream.ReadInt32() * 4));
				if (stream.ReadUInt32() != 0)
					throw new NotSupportedException();

				names = new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase);
				entryCapacity = Math.Min(entryCapacity, (uint)entryOk.Count);
				for (int i = 0; i < entryCapacity; i++) {
					if (!entryOk[i])
						continue;

					var pos = stream.ReadUInt32();
					var streamId = stream.ReadUInt32();
					nameData.Position = pos;
					var streamName = ReadCString(nameData);
					names[streamName] = streamId;
				}
			}
		}

		void ReadStringTable() {
			uint streamId;
			if (!names.TryGetValue("/names", out streamId))
				throw new PdbException("String table not found");

			var stream = streams[streamId].Content;
			stream.Position = 8;

			uint strSize = stream.ReadUInt32();
			using (var strData = stream.Create(stream.FileOffset + stream.Position, strSize)) {
				stream.Position += strSize;

				strings = new Dictionary<uint, string>();
				uint count = stream.ReadUInt32();
				for (uint i = 0; i < count; i++) {
					var pos = stream.ReadUInt32();
					if (pos == 0)
						continue;
					strData.Position = pos;
					strings[pos] = ReadCString(strData);
				}
			}
		}

		static uint ReadSizeField(IBinaryReader reader) {
			int size = reader.ReadInt32();
			return size <= 0 ? 0 : (uint)size;
		}

		ushort? ReadModules() {
			var stream = streams[STREAM_DBI].Content;
			stream.Position = 20;
			ushort symrecStream = stream.ReadUInt16();
			stream.Position += 2;
			uint gpmodiSize = ReadSizeField(stream); // gpmodiSize
			uint otherSize = 0;
			otherSize += ReadSizeField(stream); // secconSize
			otherSize += ReadSizeField(stream); // secmapSize
			otherSize += ReadSizeField(stream); // filinfSize
			otherSize += ReadSizeField(stream); // tsmapSize
			stream.ReadUInt32(); // mfcIndex
			uint dbghdrSize = ReadSizeField(stream);
			otherSize += ReadSizeField(stream); // ecinfoSize
			stream.Position += 8;

			modules = new List<DbiModule>();
			using (var moduleStream = stream.Create((FileOffset)stream.Position, gpmodiSize)) {
				while (moduleStream.Position < moduleStream.Length) {
					var module = new DbiModule();
					module.Read(moduleStream);
					modules.Add(module);
				}
			}

			if (IsValidStreamIndex(symrecStream))
				ReadGlobalSymbols(streams[symrecStream].Content);

			if (dbghdrSize != 0) {
				stream.Position += gpmodiSize;
				stream.Position += otherSize;
				stream.Position += 12;
				return stream.ReadUInt16();
			}
			return null;
		}

		internal DbiDocument GetDocument(uint nameId) {
			var name = strings[nameId];

			DbiDocument doc;
			if (!documents.TryGetValue(name, out doc)) {
				doc = new DbiDocument(name);

				uint streamId;
				if (names.TryGetValue("/src/files/" + name, out streamId))
					doc.Read(streams[streamId].Content);
				documents.Add(name, doc);
			}
			return doc;
		}

		void ReadGlobalSymbols(IImageStream stream) {
			stream.Position = 0;
			while (stream.Position < stream.Length) {
				var size = stream.ReadUInt16();
				var begin = stream.Position;
				var end = begin + size;

				if ((SymbolType)stream.ReadUInt16() == SymbolType.S_PUB32) {
					stream.Position += 4;
					var offset = stream.ReadUInt32();
					stream.Position += 2;
					var name = ReadCString(stream);

					if (name == "COM+_Entry_Point") {
						entryPt = offset;
						break;
					}
				}

				stream.Position = end;
			}
		}

		void ApplyRidMap(IImageStream stream) {
			stream.Position = 0;
			var map = new uint[stream.Length / 4];
			for (int i = 0; i < map.Length; i++)
				map[i] = stream.ReadUInt32();

			foreach (var module in modules) {
				foreach (var func in module.Functions) {
					var rid = (uint)func.Token & 0x00ffffff;
					rid = map[rid];
					func.token = (int)((func.Token & 0xff000000) | rid);
				}
			}

			if (entryPt != 0) {
				var rid = entryPt & 0x00ffffff;
				rid = map[rid];
				entryPt = (entryPt & 0xff000000) | rid;
			}
		}

		internal static string ReadCString(IImageStream stream) {
			var bytes = stream.ReadBytesUntilByte(0);
			if (bytes == null)
				return string.Empty;
			var value = Encoding.UTF8.GetString(bytes);
			stream.Position++;
			return value;
		}

		public override SymbolMethod GetMethod(MethodDef method, int version) {
			DbiFunction symMethod;
			if (functions.TryGetValue(method.MDToken.ToInt32(), out symMethod))
				return symMethod;
			return null;
		}

		public override IList<SymbolDocument> Documents {
			get {
				if (documentsResult == null) {
					var docs = new SymbolDocument[documents.Count];
					int i = 0;
					foreach (var doc in documents.Values)
						docs[i++] = doc;
					documentsResult = docs;
				}
				return documentsResult;
			}
		}
		volatile SymbolDocument[] documentsResult;

		public override int UserEntryPoint {
			get { return (int)entryPt; }
		}

		internal void GetCustomDebugInfos(DbiFunction symMethod, MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			const string CDI_NAME = "MD2";
			var asyncMethod = PseudoCustomDebugInfoFactory.TryCreateAsyncMethod(method.Module, method, body, symMethod.AsyncKickoffMethod, symMethod.AsyncStepInfos, symMethod.AsyncCatchHandlerILOffset);
			if (asyncMethod != null)
				result.Add(asyncMethod);

			var cdiData = symMethod.Root.GetSymAttribute(CDI_NAME);
			if (cdiData == null)
				return;
			PdbCustomDebugInfoReader.Read(method, body, result, cdiData);
		}

		public override void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/SymbolReaderCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.IO;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Managed {
	/// <summary>
	/// Creates a <see cref="SymbolReader"/> instance
	/// </summary>
	static class SymbolReaderCreator {
		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="assemblyFileName">Path to assembly</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if there's no PDB
		/// file.</returns>
		public static SymbolReader CreateFromAssemblyFile(string assemblyFileName) {
			return Create(Path.ChangeExtension(assemblyFileName, "pdb"));
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="pdbFileName">Path to PDB file</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c> if there's no PDB
		/// file on disk.</returns>
		public static SymbolReader Create(string pdbFileName) {
			return Create(ImageStreamUtils.OpenImageStream(pdbFileName));
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="pdbData">PDB file data</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c>.</returns>
		public static SymbolReader Create(byte[] pdbData) {
			return Create(MemoryImageStream.Create(pdbData));
		}

		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="pdbStream">PDB file stream which is now owned by this method</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c>.</returns>
		public static SymbolReader Create(IImageStream pdbStream) {
			if (pdbStream == null)
				return null;
			try {
				var pdbReader = new PdbReader();
				pdbReader.Read(pdbStream);
				return pdbReader;
			}
			catch (PdbException) {
			}
			catch (IOException) {
			}
			finally {
				if (pdbStream != null)
					pdbStream.Dispose();
			}
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Managed/SymbolType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb.Managed {
	enum SymbolType : ushort {
		S_COMPILE = 0x0001,
		S_REGISTER_16t = 0x0002,
		S_CONSTANT_16t = 0x0003,
		S_UDT_16t = 0x0004,
		S_SSEARCH = 0x0005,
		S_END = 0x0006,
		S_SKIP = 0x0007,
		S_CVRESERVE = 0x0008,
		S_OBJNAME_ST = 0x0009,
		S_ENDARG = 0x000A,
		S_COBOLUDT_16t = 0x000B,
		S_MANYREG_16t = 0x000C,
		S_RETURN = 0x000D,
		S_ENTRYTHIS = 0x000E,

		S_BPREL16 = 0x0100,
		S_LDATA16 = 0x0101,
		S_GDATA16 = 0x0102,
		S_PUB16 = 0x0103,
		S_LPROC16 = 0x0104,
		S_GPROC16 = 0x0105,
		S_THUNK16 = 0x0106,
		S_BLOCK16 = 0x0107,
		S_WITH16 = 0x0108,
		S_LABEL16 = 0x0109,
		S_CEXMODEL16 = 0x010A,
		S_VFTABLE16 = 0x010B,
		S_REGREL16 = 0x010C,

		S_BPREL32_16t = 0x0200,
		S_LDATA32_16t = 0x0201,
		S_GDATA32_16t = 0x0202,
		S_PUB32_16t = 0x0203,
		S_LPROC32_16t = 0x0204,
		S_GPROC32_16t = 0x0205,
		S_THUNK32_ST = 0x0206,
		S_BLOCK32_ST = 0x0207,
		S_WITH32_ST = 0x0208,
		S_LABEL32_ST = 0x0209,
		S_CEXMODEL32 = 0x020A,
		S_VFTABLE32_16t = 0x020B,
		S_REGREL32_16t = 0x020C,
		S_LTHREAD32_16t = 0x020D,
		S_GTHREAD32_16t = 0x020E,
		S_SLINK32 = 0x020F,

		S_LPROCMIPS_16t = 0x0300,
		S_GPROCMIPS_16t = 0x0301,

		S_PROCREF_ST = 0x0400,
		S_DATAREF_ST = 0x0401,
		S_ALIGN = 0x0402,
		S_LPROCREF_ST = 0x0403,
		S_OEM = 0x0404,

		S_TI16_MAX = 0x1000,
		S_REGISTER_ST = 0x1001,
		S_CONSTANT_ST = 0x1002,
		S_UDT_ST = 0x1003,
		S_COBOLUDT_ST = 0x1004,
		S_MANYREG_ST = 0x1005,
		S_BPREL32_ST = 0x1006,
		S_LDATA32_ST = 0x1007,
		S_GDATA32_ST = 0x1008,
		S_PUB32_ST = 0x1009,
		S_LPROC32_ST = 0x100A,
		S_GPROC32_ST = 0x100B,
		S_VFTABLE32 = 0x100C,
		S_REGREL32_ST = 0x100D,
		S_LTHREAD32_ST = 0x100E,
		S_GTHREAD32_ST = 0x100F,
		S_LPROCMIPS_ST = 0x1010,
		S_GPROCMIPS_ST = 0x1011,
		S_FRAMEPROC = 0x1012,
		S_COMPILE2_ST = 0x1013,
		S_MANYREG2_ST = 0x1014,
		S_LPROCIA64_ST = 0x1015,
		S_GPROCIA64_ST = 0x1016,
		S_LOCALSLOT_ST = 0x1017,
		S_PARAMSLOT_ST = 0x1018,
		S_ANNOTATION = 0x1019,
		S_GMANPROC_ST = 0x101A,
		S_LMANPROC_ST = 0x101B,
		S_RESERVED1 = 0x101C,
		S_RESERVED2 = 0x101D,
		S_RESERVED3 = 0x101E,
		S_RESERVED4 = 0x101F,
		S_LMANDATA_ST = 0x1020,
		S_GMANDATA_ST = 0x1021,
		S_MANFRAMEREL_ST = 0x1022,
		S_MANREGISTER_ST = 0x1023,
		S_MANSLOT_ST = 0x1024,
		S_MANMANYREG_ST = 0x1025,
		S_MANREGREL_ST = 0x1026,
		S_MANMANYREG2_ST = 0x1027,
		S_MANTYPREF = 0x1028,
		S_UNAMESPACE_ST = 0x1029,

		S_ST_MAX = 0x1100,
		S_OBJNAME = 0x1101,
		S_THUNK32 = 0x1102,
		S_BLOCK32 = 0x1103,
		S_WITH32 = 0x1104,
		S_LABEL32 = 0x1105,
		S_REGISTER = 0x1106,
		S_CONSTANT = 0x1107,
		S_UDT = 0x1108,
		S_COBOLUDT = 0x1109,
		S_MANYREG = 0x110A,
		S_BPREL32 = 0x110B,
		S_LDATA32 = 0x110C,
		S_GDATA32 = 0x110D,
		S_PUB32 = 0x110E,
		S_LPROC32 = 0x110F,
		S_GPROC32 = 0x1110,
		S_REGREL32 = 0x1111,
		S_LTHREAD32 = 0x1112,
		S_GTHREAD32 = 0x1113,
		S_LPROCMIPS = 0x1114,
		S_GPROCMIPS = 0x1115,
		S_COMPILE2 = 0x1116,
		S_MANYREG2 = 0x1117,
		S_LPROCIA64 = 0x1118,
		S_GPROCIA64 = 0x1119,
		S_LOCALSLOT = 0x111A,
		S_PARAMSLOT = 0x111B,
		S_LMANDATA = 0x111C,
		S_GMANDATA = 0x111D,
		S_MANFRAMEREL = 0x111E,
		S_MANREGISTER = 0x111F,
		S_MANSLOT = 0x1120,
		S_MANMANYREG = 0x1121,
		S_MANREGREL = 0x1122,
		S_MANMANYREG2 = 0x1123,
		S_UNAMESPACE = 0x1124,
		S_PROCREF = 0x1125,
		S_DATAREF = 0x1126,
		S_LPROCREF = 0x1127,
		S_ANNOTATIONREF = 0x1128,
		S_TOKENREF = 0x1129,
		S_GMANPROC = 0x112A,
		S_LMANPROC = 0x112B,
		S_TRAMPOLINE = 0x112C,
		S_MANCONSTANT = 0x112D,
		S_ATTR_FRAMEREL = 0x112E,
		S_ATTR_REGISTER = 0x112F,
		S_ATTR_REGREL = 0x1130,
		S_ATTR_MANYREG = 0x1131,
		S_SEPCODE = 0x1132,
		S_LOCAL_2005 = 0x1133,
		S_DEFRANGE_2005 = 0x1134,
		S_DEFRANGE2_2005 = 0x1135,
		S_SECTION = 0x1136,
		S_COFFGROUP = 0x1137,
		S_EXPORT = 0x1138,
		S_CALLSITEINFO = 0x1139,
		S_FRAMECOOKIE = 0x113A,
		S_DISCARDED = 0x113B,
		S_COMPILE3 = 0x113C,
		S_ENVBLOCK = 0x113D,
		S_LOCAL = 0x113E,
		S_DEFRANGE = 0x113F,
		S_DEFRANGE_SUBFIELD = 0x1140,
		S_DEFRANGE_REGISTER = 0x1141,
		S_DEFRANGE_FRAMEPOINTER_REL = 0x1142,
		S_DEFRANGE_SUBFIELD_REGISTER = 0x1143,
		S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE = 0x1144,
		S_DEFRANGE_REGISTER_REL = 0x1145,
		S_LPROC32_ID = 0x1146,
		S_GPROC32_ID = 0x1147,
		S_LPROCMIPS_ID = 0x1148,
		S_GPROCMIPS_ID = 0x1149,
		S_LPROCIA64_ID = 0x114A,
		S_GPROCIA64_ID = 0x114B,
		S_BUILDINFO = 0x114C,
		S_INLINESITE = 0x114D,
		S_INLINESITE_END = 0x114E,
		S_PROC_ID_END = 0x114F,
		S_DEFRANGE_HLSL = 0x1150,
		S_GDATA_HLSL = 0x1151,
		S_LDATA_HLSL = 0x1152,
		S_FILESTATIC = 0x1153,
		S_LOCAL_DPC_GROUPSHARED = 0x1154,
		S_LPROC32_DPC = 0x1155,
		S_LPROC32_DPC_ID = 0x1156,
		S_DEFRANGE_DPC_PTR_TAG = 0x1157,
		S_DPC_SYM_TAG_MAP = 0x1158,
		S_ARMSWITCHTABLE = 0x1159,
		S_CALLEES = 0x115A,
		S_CALLERS = 0x115B,
		S_POGODATA = 0x115C,
		S_INLINESITE2 = 0x115D,
		S_HEAPALLOCSITE = 0x115E,

		S_RECTYPE_MAX,
	}
}


================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/DocumentNameReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Text;
using dnlib.DotNet.MD;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Portable {
	struct DocumentNameReader {
		const int MAX_NAME_LENGTH = 64 * 1024;
		readonly Dictionary<uint, string> docNamePartDict;
		readonly BlobStream blobStream;
		readonly StringBuilder sb;

		char[] prevSepChars;
		int prevSepCharsLength;
		byte[] prevSepCharBytes;
		int prevSepCharBytesCount;

		public DocumentNameReader(BlobStream blobStream) {
			docNamePartDict = new Dictionary<uint, string>();
			this.blobStream = blobStream;
			sb = new StringBuilder();

			prevSepChars = new char[2];
			prevSepCharsLength = 0;
			prevSepCharBytes = new byte[3];
			prevSepCharBytesCount = 0;
		}

		public string ReadDocumentName(uint offset) {
			sb.Length = 0;
			using (var stream = blobStream.CreateStream(offset)) {
				int sepCharsLength;
				var sepChars = ReadSeparatorChar(stream, out sepCharsLength);
				bool needSep = false;
				while (stream.Position < stream.Length) {
					if (needSep)
						sb.Append(sepChars, 0, sepCharsLength);
					needSep = !(sepCharsLength == 1 && sepChars[0] == '\0');
					var part = ReadDocumentNamePart(stream.ReadCompressedUInt32());
					sb.Append(part);
					if (sb.Length > MAX_NAME_LENGTH) {
						sb.Length = MAX_NAME_LENGTH;
						break;
					}
				}
			}
			return sb.ToString();
		}

		string ReadDocumentNamePart(uint offset) {
			string name;
			if (docNamePartDict.TryGetValue(offset, out name))
				return name;
			var data = blobStream.ReadNoNull(offset);
			name = Encoding.UTF8.GetString(data);
			docNamePartDict.Add(offset, name);
			return name;
		}

		char[] ReadSeparatorChar(IImageStream stream, out int charLength) {
			if (prevSepCharBytesCount != 0 && prevSepCharBytesCount <= stream.Length) {
				var pos = stream.Position;
				bool ok = true;
				for (int i = 0; i < prevSepCharBytesCount; i++) {
					if (i >= prevSepCharBytes.Length || stream.ReadByte() != prevSepCharBytes[i]) {
						ok = false;
						break;
					}
				}
				if (ok) {
					charLength = prevSepCharsLength;
					return prevSepChars;
				}
				stream.Position = pos;
			}

			var decoder = Encoding.UTF8.GetDecoder();
			var bytes = new byte[1];
			prevSepCharBytesCount = 0;
			for (int i = 0; ; i++) {
				byte b = stream.ReadByte();
				prevSepCharBytesCount++;
				if (i == 0 && b == 0)
					break;
				if (i < prevSepCharBytes.Length)
					prevSepCharBytes[i] = b;
				bytes[0] = b;
				bool isLastByte = stream.Position + 1 == stream.Length;
				int bytesUsed;
				bool completed;
				decoder.Convert(bytes, 0, 1, prevSepChars, 0, prevSepChars.Length, isLastByte, out bytesUsed, out prevSepCharsLength, out completed);
				if (prevSepCharsLength > 0)
					break;
			}
			charLength = prevSepCharsLength;
			return prevSepChars;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/ImportDefinitionKindUtils.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Diagnostics;

namespace dnlib.DotNet.Pdb.Portable {
	static class ImportDefinitionKindUtils {
		public const PdbImportDefinitionKind UNKNOWN_IMPORT_KIND = (PdbImportDefinitionKind)(-1);

		public static PdbImportDefinitionKind ToPdbImportDefinitionKind(uint value) {
			// See System.Reflection.Metadata.ImportDefinitionKind
			switch (value) {
			case 1:		return PdbImportDefinitionKind.ImportNamespace;
			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;
			case 3:		return PdbImportDefinitionKind.ImportType;
			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;
			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;
			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;
			case 7:		return PdbImportDefinitionKind.AliasNamespace;
			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;
			case 9:		return PdbImportDefinitionKind.AliasType;
			default:
				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));
				return UNKNOWN_IMPORT_KIND;
			}
		}

		public static bool ToImportDefinitionKind(PdbImportDefinitionKind kind, out uint rawKind) {
			switch (kind) {
			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;
			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;
			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;
			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;
			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;
			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;
			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;
			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;
			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;
			default:													rawKind = uint.MaxValue; return false;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/ImportScopeBlobReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using dnlib.DotNet.MD;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Portable {
	// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#imports-blob
	struct ImportScopeBlobReader {
		readonly ModuleDef module;
		readonly BlobStream blobStream;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module that resolves assembly and type references</param>
		/// <param name="blobStream">Portable PDB blob stream</param>
		public ImportScopeBlobReader(ModuleDef module, BlobStream blobStream) {
			this.module = module;
			this.blobStream = blobStream;
		}

		public void Read(uint imports, IList<PdbImport> result) {
			if (imports == 0)
				return;
			using (var stream = blobStream.CreateStream(imports)) {
				while (stream.Position < stream.Length) {
					var kind = ImportDefinitionKindUtils.ToPdbImportDefinitionKind(stream.ReadCompressedUInt32());
					string targetNamespace, alias;
					AssemblyRef targetAssembly;
					PdbImport import;
					ITypeDefOrRef targetType;
					switch (kind) {
					case PdbImportDefinitionKind.ImportNamespace:
						// <import> ::= ImportNamespace <target-namespace>
						targetNamespace = ReadUTF8(stream.ReadCompressedUInt32());
						import = new PdbImportNamespace(targetNamespace);
						break;

					case PdbImportDefinitionKind.ImportAssemblyNamespace:
						// <import> ::= ImportAssemblyNamespace <target-assembly> <target-namespace>
						targetAssembly = TryReadAssemblyRef(stream.ReadCompressedUInt32());
						targetNamespace = ReadUTF8(stream.ReadCompressedUInt32());
						import = new PdbImportAssemblyNamespace(targetAssembly, targetNamespace);
						break;

					case PdbImportDefinitionKind.ImportType:
						// <import> ::= ImportType <target-type>
						targetType = TryReadType(stream.ReadCompressedUInt32());
						import = new PdbImportType(targetType);
						break;

					case PdbImportDefinitionKind.ImportXmlNamespace:
						// <import> ::= ImportXmlNamespace <alias> <target-namespace>
						alias = ReadUTF8(stream.ReadCompressedUInt32());
						targetNamespace = ReadUTF8(stream.ReadCompressedUInt32());
						import = new PdbImportXmlNamespace(alias, targetNamespace);
						break;

					case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:
						// <import> ::= ImportReferenceAlias <alias>
						alias = ReadUTF8(stream.ReadCompressedUInt32());
						import = new PdbImportAssemblyReferenceAlias(alias);
						break;

					case PdbImportDefinitionKind.AliasAssemblyReference:
						// <import> ::= AliasAssemblyReference <alias> <target-assembly>
						alias = ReadUTF8(stream.ReadCompressedUInt32());
						targetAssembly = TryReadAssemblyRef(stream.ReadCompressedUInt32());
						import = new PdbAliasAssemblyReference(alias, targetAssembly);
						break;

					case PdbImportDefinitionKind.AliasNamespace:
						// <import> ::= AliasNamespace <alias> <target-namespace>
						alias = ReadUTF8(stream.ReadCompressedUInt32());
						targetNamespace = ReadUTF8(stream.ReadCompressedUInt32());
						import = new PdbAliasNamespace(alias, targetNamespace);
						break;

					case PdbImportDefinitionKind.AliasAssemblyNamespace:
						// <import> ::= AliasAssemblyNamespace <alias> <target-assembly> <target-namespace>
						alias = ReadUTF8(stream.ReadCompressedUInt32());
						targetAssembly = TryReadAssemblyRef(stream.ReadCompressedUInt32());
						targetNamespace = ReadUTF8(stream.ReadCompressedUInt32());
						import = new PdbAliasAssemblyNamespace(alias, targetAssembly, targetNamespace);
						break;

					case PdbImportDefinitionKind.AliasType:
						// <import> ::= AliasType <alias> <target-type>
						alias = ReadUTF8(stream.ReadCompressedUInt32());
						targetType = TryReadType(stream.ReadCompressedUInt32());
						import = new PdbAliasType(alias, targetType);
						break;

					case ImportDefinitionKindUtils.UNKNOWN_IMPORT_KIND:
						import = null;
						break;

					default:
						Debug.Fail("Unknown import definition kind: " + kind.ToString());
						import = null;
						break;
					}
					if (import != null)
						result.Add(import);
				}
				Debug.Assert(stream.Position == stream.Length);
			}
		}

		ITypeDefOrRef TryReadType(uint codedToken) {
			uint token;
			bool b = CodedToken.TypeDefOrRef.Decode(codedToken, out token);
			Debug.Assert(b);
			if (!b)
				return null;
			var type = module.ResolveToken(token) as ITypeDefOrRef;
			Debug.Assert(type != null);
			return type;
		}

		AssemblyRef TryReadAssemblyRef(uint rid) {
			var asmRef = module.ResolveToken(0x23000000 + rid) as AssemblyRef;
			Debug.Assert(asmRef != null);
			return asmRef;
		}

		string ReadUTF8(uint offset) {
			var bytes = blobStream.ReadNoNull(offset);
			return Encoding.UTF8.GetString(bytes);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/ImportScopeBlobWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet.Pdb.Portable {
	// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#imports-blob
	struct ImportScopeBlobWriter {
		readonly IWriterError helper;
		readonly MetaData systemMetaData;
		readonly BlobHeap blobHeap;

		ImportScopeBlobWriter(IWriterError helper, MetaData systemMetaData, BlobHeap blobHeap) {
			this.helper = helper;
			this.systemMetaData = systemMetaData;
			this.blobHeap = blobHeap;
		}

		public static void Write(IWriterError helper, MetaData systemMetaData, BinaryWriter writer, BlobHeap blobHeap, IList<PdbImport> imports) {
			var blobWriter = new ImportScopeBlobWriter(helper, systemMetaData, blobHeap);
			blobWriter.Write(writer, imports);
		}

		uint WriteUTF8(string s) {
			if (s == null) {
				helper.Error("String is null");
				s = string.Empty;
			}
			var bytes = Encoding.UTF8.GetBytes(s);
			return blobHeap.Add(bytes);
		}

		void Write(BinaryWriter writer, IList<PdbImport> imports) {
			foreach (var import in imports) {
				uint rawKind;
				if (!ImportDefinitionKindUtils.ToImportDefinitionKind(import.Kind, out rawKind)) {
					helper.Error("Unknown import definition kind: " + import.Kind.ToString());
					return;
				}
				writer.WriteCompressedUInt32(rawKind);
				switch (import.Kind) {
				case PdbImportDefinitionKind.ImportNamespace:
					// <import> ::= ImportNamespace <target-namespace>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.ImportAssemblyNamespace:
					// <import> ::= ImportAssemblyNamespace <target-assembly> <target-namespace>
					writer.WriteCompressedUInt32(systemMetaData.GetToken(((PdbImportAssemblyNamespace)import).TargetAssembly).Rid);
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportAssemblyNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.ImportType:
					// <import> ::= ImportType <target-type>
					writer.WriteCompressedUInt32(GetTypeDefOrRefEncodedToken(((PdbImportType)import).TargetType));
					break;

				case PdbImportDefinitionKind.ImportXmlNamespace:
					// <import> ::= ImportXmlNamespace <alias> <target-namespace>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportXmlNamespace)import).Alias));
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportXmlNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:
					// <import> ::= ImportReferenceAlias <alias>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportAssemblyReferenceAlias)import).Alias));
					break;

				case PdbImportDefinitionKind.AliasAssemblyReference:
					// <import> ::= AliasAssemblyReference <alias> <target-assembly>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasAssemblyReference)import).Alias));
					writer.WriteCompressedUInt32(systemMetaData.GetToken(((PdbAliasAssemblyReference)import).TargetAssembly).Rid);
					break;

				case PdbImportDefinitionKind.AliasNamespace:
					// <import> ::= AliasNamespace <alias> <target-namespace>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasNamespace)import).Alias));
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.AliasAssemblyNamespace:
					// <import> ::= AliasAssemblyNamespace <alias> <target-assembly> <target-namespace>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasAssemblyNamespace)import).Alias));
					writer.WriteCompressedUInt32(systemMetaData.GetToken(((PdbAliasAssemblyNamespace)import).TargetAssembly).Rid);
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasAssemblyNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.AliasType:
					// <import> ::= AliasType <alias> <target-type>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasType)import).Alias));
					writer.WriteCompressedUInt32(GetTypeDefOrRefEncodedToken(((PdbAliasType)import).TargetType));
					break;

				default:
					helper.Error("Unknown import definition kind: " + import.Kind.ToString());
					return;
				}
			}
		}

		uint GetTypeDefOrRefEncodedToken(ITypeDefOrRef tdr) {
			if (tdr == null) {
				helper.Error("ITypeDefOrRef is null");
				return 0;
			}
			var token = systemMetaData.GetToken(tdr);
			uint codedToken;
			if (MD.CodedToken.TypeDefOrRef.Encode(token, out codedToken))
				return codedToken;
			helper.Error(string.Format("Could not encode token 0x{0:X8}", token.Raw));
			return 0;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/ListCache.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Threading;

namespace dnlib.DotNet.Pdb.Portable {
	static class ListCache<T> {
		static volatile List<T> cachedList;
		public static List<T> AllocList() {
			return Interlocked.Exchange(ref cachedList, null) ?? new List<T>();
		}
		public static void Free(ref List<T> list) {
			list.Clear();
			cachedList = list;
		}
		public static T[] FreeAndToArray(ref List<T> list) {
			var res = list.ToArray();
			Free(ref list);
			return res;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/LocalConstantSigBlobReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.Text;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Portable {
	struct LocalConstantSigBlobReader {
		readonly ModuleDef module;
		readonly IImageStream reader;
		/*readonly*/ GenericParamContext gpContext;
		RecursionCounter recursionCounter;

		public LocalConstantSigBlobReader(ModuleDef module, IImageStream reader, GenericParamContext gpContext) {
			this.module = module;
			this.reader = reader;
			this.gpContext = gpContext;
			recursionCounter = default(RecursionCounter);
		}

		public bool Read(out TypeSig type, out object value) {
			try {
				return ReadCore(out type, out value);
			}
			catch {
			}
			type = null;
			value = null;
			return false;
		}

		bool ReadCore(out TypeSig type, out object value) {
			if (!recursionCounter.Increment()) {
				type = null;
				value = null;
				return false;
			}

			bool res;
			ITypeDefOrRef tdr;
			UTF8String ns, name;
			var et = (ElementType)reader.ReadByte();
			switch (et) {
			case ElementType.Boolean:
				type = module.CorLibTypes.Boolean;
				value = reader.ReadBoolean();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.Char:
				type = module.CorLibTypes.Char;
				value = (char)reader.ReadUInt16();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.I1:
				type = module.CorLibTypes.SByte;
				value = reader.ReadSByte();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.U1:
				type = module.CorLibTypes.Byte;
				value = reader.ReadByte();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.I2:
				type = module.CorLibTypes.Int16;
				value = reader.ReadInt16();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.U2:
				type = module.CorLibTypes.UInt16;
				value = reader.ReadUInt16();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.I4:
				type = module.CorLibTypes.Int32;
				value = reader.ReadInt32();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.U4:
				type = module.CorLibTypes.UInt32;
				value = reader.ReadUInt32();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.I8:
				type = module.CorLibTypes.Int64;
				value = reader.ReadInt64();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.U8:
				type = module.CorLibTypes.UInt64;
				value = reader.ReadUInt64();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.R4:
				type = module.CorLibTypes.Single;
				value = reader.ReadSingle();
				res = true;
				break;

			case ElementType.R8:
				type = module.CorLibTypes.Double;
				value = reader.ReadDouble();
				res = true;
				break;

			case ElementType.String:
				type = module.CorLibTypes.String;
				value = ReadString();
				res = true;
				break;

			case ElementType.Ptr:
				res = Read(out type, out value);
				if (res)
					type = new PtrSig(type);
				break;

			case ElementType.ByRef:
				res = Read(out type, out value);
				if (res)
					type = new ByRefSig(type);
				break;

			case ElementType.Object:
				type = module.CorLibTypes.Object;
				value = null;
				res = true;
				break;

			case ElementType.ValueType:
				tdr = ReadTypeDefOrRef();
				type = tdr.ToTypeSig();
				value = null;
				if (GetName(tdr, out ns, out name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {
					if (name == stringDecimal) {
						if (reader.Length - reader.Position != 13)
							goto default;
						try {
							byte b = reader.ReadByte();
							value = new Decimal(reader.ReadInt32(), reader.ReadInt32(), reader.ReadInt32(), (b & 0x80) != 0, (byte)(b & 0x7F));
						}
						catch {
							goto default;
						}
					}
					else if (name == stringDateTime) {
						if (reader.Length - reader.Position != 8)
							goto default;
						try {
							value = new DateTime(reader.ReadInt64());
						}
						catch {
							goto default;
						}
					}
				}
				if (value == null && reader.Position != reader.Length)
					value = reader.ReadRemainingBytes();
				res = true;
				break;

			case ElementType.Class:
				type = new ClassSig(ReadTypeDefOrRef());
				value = reader.Position == reader.Length ? null : reader.ReadRemainingBytes();
				res = true;
				break;

			case ElementType.CModReqd:
				tdr = ReadTypeDefOrRef();
				res = Read(out type, out value);
				if (res)
					type = new CModReqdSig(tdr, type);
				break;

			case ElementType.CModOpt:
				tdr = ReadTypeDefOrRef();
				res = Read(out type, out value);
				if (res)
					type = new CModOptSig(tdr, type);
				break;

			case ElementType.Var:
			case ElementType.Array:
			case ElementType.GenericInst:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.FnPtr:
			case ElementType.SZArray:
			case ElementType.MVar:
			case ElementType.End:
			case ElementType.Void:
			case ElementType.ValueArray:
			case ElementType.R:
			case ElementType.Internal:
			case ElementType.Module:
			case ElementType.Sentinel:
			case ElementType.Pinned:
			default:
				Debug.Fail("Unsupported element type in LocalConstant sig blob: " + et.ToString());
				res = false;
				type = null;
				value = null;
				break;
			}

			recursionCounter.Decrement();
			return res;
		}
		static readonly UTF8String stringSystem = new UTF8String("System");
		static readonly UTF8String stringDecimal = new UTF8String("Decimal");
		static readonly UTF8String stringDateTime = new UTF8String("DateTime");

		static bool GetName(ITypeDefOrRef tdr, out UTF8String @namespace, out UTF8String name) {
			var tr = tdr as TypeRef;
			if (tr != null) {
				@namespace = tr.Namespace;
				name = tr.Name;
				return true;
			}

			var td = tdr as TypeDef;
			if (td != null) {
				@namespace = td.Namespace;
				name = td.Name;
				return true;
			}

			@namespace = null;
			name = null;
			return false;
		}

		TypeSig ReadTypeDefOrRefSig() {
			uint codedToken;
			if (!reader.ReadCompressedUInt32(out codedToken))
				return null;
			ISignatureReaderHelper helper = module;
			var tdr = helper.ResolveTypeDefOrRef(codedToken, gpContext);
			return tdr.ToTypeSig();
		}

		ITypeDefOrRef ReadTypeDefOrRef() {
			uint codedToken;
			if (!reader.ReadCompressedUInt32(out codedToken))
				return null;
			ISignatureReaderHelper helper = module;
			var tdr = helper.ResolveTypeDefOrRef(codedToken, gpContext);
			var corType = module.CorLibTypes.GetCorLibTypeSig(tdr);
			if (corType != null)
				return corType.TypeDefOrRef;
			return tdr;
		}

		string ReadString() {
			if (reader.Position == reader.Length)
				return string.Empty;
			byte b = reader.ReadByte();
			if (b == 0xFF && reader.Position == reader.Length)
				return null;
			reader.Position--;
			return Encoding.Unicode.GetString(reader.ReadRemainingBytes());
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/LocalConstantSigBlobWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using System.Text;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet.Pdb.Portable {
	struct LocalConstantSigBlobWriter {
		readonly IWriterError helper;
		readonly MetaData systemMetaData;

		LocalConstantSigBlobWriter(IWriterError helper, MetaData systemMetaData) {
			this.helper = helper;
			this.systemMetaData = systemMetaData;
		}

		public static void Write(IWriterError helper, MetaData systemMetaData, BinaryWriter writer, TypeSig type, object value) {
			var sigWriter = new LocalConstantSigBlobWriter(helper, systemMetaData);
			sigWriter.Write(writer, type, value);
		}

		void Write(BinaryWriter writer, TypeSig type, object value) {
			for (; ; type = type.Next) {
				if (type == null)
					return;

				var et = type.ElementType;
				writer.Write((byte)et);
				switch (et) {
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
					WritePrimitiveValue(writer, et, value);
					return;

				case ElementType.R4:
					if (value is float)
						writer.Write((float)value);
					else {
						helper.Error("Expected a Single constant");
						writer.Write((float)0);
					}
					return;

				case ElementType.R8:
					if (value is double)
						writer.Write((double)value);
					else {
						helper.Error("Expected a Double constant");
						writer.Write((double)0);
					}
					return;

				case ElementType.String:
					if (value == null)
						writer.Write((byte)0xFF);
					else if (value is string)
						writer.Write(Encoding.Unicode.GetBytes((string)value));
					else
						helper.Error("Expected a String constant");
					return;

				case ElementType.Ptr:
				case ElementType.ByRef:
					WriteTypeDefOrRef(writer, new TypeSpecUser(type));
					return;

				case ElementType.Object:
					return;

				case ElementType.ValueType:
					var tdr = ((ValueTypeSig)type).TypeDefOrRef;
					var td = tdr.ResolveTypeDef();
					if (td == null)
						helper.Error(string.Format("Couldn't resolve type 0x{0:X8}", tdr == null ? 0 : tdr.MDToken.Raw));
					else if (td.IsEnum) {
						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();
						switch (underlyingType.GetElementType()) {
						case ElementType.Boolean:
						case ElementType.Char:
						case ElementType.I1:
						case ElementType.U1:
						case ElementType.I2:
						case ElementType.U2:
						case ElementType.I4:
						case ElementType.U4:
						case ElementType.I8:
						case ElementType.U8:
							writer.BaseStream.Position--;
							writer.Write((byte)underlyingType.GetElementType());
							WritePrimitiveValue(writer, underlyingType.GetElementType(), value);
							WriteTypeDefOrRef(writer, tdr);
							return;
						default:
							helper.Error("Invalid enum underlying type");
							return;
						}
					}
					else {
						WriteTypeDefOrRef(writer, tdr);
						UTF8String ns, name;
						bool valueWritten = false;
						if (GetName(tdr, out ns, out name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {
							if (name == stringDecimal) {
								if (value is decimal) {
									var bits = decimal.GetBits((decimal)value);
									writer.Write((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));
									writer.Write(bits[0]);
									writer.Write(bits[1]);
									writer.Write(bits[2]);
								}
								else {
									helper.Error("Expected a Decimal constant");
									writer.Write(new byte[13]);
								}
								valueWritten = true;
							}
							else if (name == stringDateTime) {
								if (value is DateTime)
									writer.Write(((DateTime)value).Ticks);
								else {
									helper.Error("Expected a DateTime constant");
									writer.Write(0L);
								}
								valueWritten = true;
							}
						}
						if (!valueWritten) {
							if (value is byte[])
								writer.Write((byte[])value);
							else if (value != null) {
								helper.Error("Unsupported constant: " + value.GetType().FullName);
								return;
							}
						}
					}
					return;

				case ElementType.Class:
					WriteTypeDefOrRef(writer, ((ClassSig)type).TypeDefOrRef);
					if (value is byte[])
						writer.Write((byte[])value);
					else if (value != null)
						helper.Error("Expected a null constant");
					return;

				case ElementType.CModReqd:
				case ElementType.CModOpt:
					WriteTypeDefOrRef(writer, ((ModifierSig)type).Modifier);
					break;

				case ElementType.Var:
				case ElementType.Array:
				case ElementType.GenericInst:
				case ElementType.TypedByRef:
				case ElementType.I:
				case ElementType.U:
				case ElementType.FnPtr:
				case ElementType.SZArray:
				case ElementType.MVar:
					WriteTypeDefOrRef(writer, new TypeSpecUser(type));
					return;

				case ElementType.End:
				case ElementType.Void:
				case ElementType.ValueArray:
				case ElementType.R:
				case ElementType.Internal:
				case ElementType.Module:
				case ElementType.Sentinel:
				case ElementType.Pinned:
				default:
					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());
					return;
				}
			}
		}
		static readonly UTF8String stringSystem = new UTF8String("System");
		static readonly UTF8String stringDecimal = new UTF8String("Decimal");
		static readonly UTF8String stringDateTime = new UTF8String("DateTime");

		static bool GetName(ITypeDefOrRef tdr, out UTF8String @namespace, out UTF8String name) {
			var tr = tdr as TypeRef;
			if (tr != null) {
				@namespace = tr.Namespace;
				name = tr.Name;
				return true;
			}

			var td = tdr as TypeDef;
			if (td != null) {
				@namespace = td.Namespace;
				name = td.Name;
				return true;
			}

			@namespace = null;
			name = null;
			return false;
		}

		void WritePrimitiveValue(BinaryWriter writer, ElementType et, object value) {
			switch (et) {
			case ElementType.Boolean:
				if (value is bool)
					writer.Write((bool)value);
				else {
					helper.Error("Expected a Boolean constant");
					writer.Write(false);
				}
				break;

			case ElementType.Char:
				if (value is char)
					writer.Write((ushort)(char)value);
				else {
					helper.Error("Expected a Char constant");
					writer.Write((ushort)0);
				}
				break;

			case ElementType.I1:
				if (value is sbyte)
					writer.Write((sbyte)value);
				else {
					helper.Error("Expected a SByte constant");
					writer.Write((sbyte)0);
				}
				break;

			case ElementType.U1:
				if (value is byte)
					writer.Write((byte)value);
				else {
					helper.Error("Expected a Byte constant");
					writer.Write((byte)0);
				}
				break;

			case ElementType.I2:
				if (value is short)
					writer.Write((short)value);
				else {
					helper.Error("Expected an Int16 constant");
					writer.Write((short)0);
				}
				break;

			case ElementType.U2:
				if (value is ushort)
					writer.Write((ushort)value);
				else {
					helper.Error("Expected a UInt16 constant");
					writer.Write((ushort)0);
				}
				break;

			case ElementType.I4:
				if (value is int)
					writer.Write((int)value);
				else {
					helper.Error("Expected an Int32 constant");
					writer.Write((int)0);
				}
				break;

			case ElementType.U4:
				if (value is uint)
					writer.Write((uint)value);
				else {
					helper.Error("Expected a UInt32 constant");
					writer.Write((uint)0);
				}
				break;

			case ElementType.I8:
				if (value is long)
					writer.Write((long)value);
				else {
					helper.Error("Expected an Int64 constant");
					writer.Write((long)0);
				}
				break;

			case ElementType.U8:
				if (value is ulong)
					writer.Write((ulong)value);
				else {
					helper.Error("Expected a UInt64 constant");
					writer.Write((ulong)0);
				}
				break;

			default:
				throw new InvalidOperationException();
			}
		}

		void WriteTypeDefOrRef(BinaryWriter writer, ITypeDefOrRef tdr) {
			uint codedToken;
			if (!MD.CodedToken.TypeDefOrRef.Encode(systemMetaData.GetToken(tdr), out codedToken)) {
				helper.Error("Couldn't encode a TypeDefOrRef");
				return;
			}
			writer.WriteCompressedUInt32(codedToken);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/PortablePdbCustomDebugInfoReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

// See Roslyn files: MethodDebugInfo.Portable.cs, MetadataWriter.PortablePdb.cs

using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Portable {
	struct PortablePdbCustomDebugInfoReader : IDisposable {
		public static PdbCustomDebugInfo Read(ModuleDef module, TypeDef typeOpt, CilBody bodyOpt, GenericParamContext gpContext, Guid kind, byte[] data) {
			try {
				using (var reader = new PortablePdbCustomDebugInfoReader(module, typeOpt, bodyOpt, gpContext, MemoryImageStream.Create(data))) {
					var cdi = reader.Read(kind);
					Debug.Assert(reader.reader.Position == reader.reader.Length);
					return cdi;
				}
			}
			catch (ArgumentException) {
			}
			catch (OutOfMemoryException) {
			}
			catch (IOException) {
			}
			return null;
		}

		readonly ModuleDef module;
		readonly TypeDef typeOpt;
		readonly CilBody bodyOpt;
		readonly GenericParamContext gpContext;
		readonly IBinaryReader reader;

		PortablePdbCustomDebugInfoReader(ModuleDef module, TypeDef typeOpt, CilBody bodyOpt, GenericParamContext gpContext, IBinaryReader reader) {
			this.module = module;
			this.typeOpt = typeOpt;
			this.bodyOpt = bodyOpt;
			this.gpContext = gpContext;
			this.reader = reader;
		}

		PdbCustomDebugInfo Read(Guid kind) {
			if (kind == CustomDebugInfoGuids.AsyncMethodSteppingInformationBlob)
				return ReadAsyncMethodSteppingInformationBlob();
			if (kind == CustomDebugInfoGuids.DefaultNamespace)
				return ReadDefaultNamespace();
			if (kind == CustomDebugInfoGuids.DynamicLocalVariables)
				return ReadDynamicLocalVariables(reader.Length);
			if (kind == CustomDebugInfoGuids.EmbeddedSource)
				return ReadEmbeddedSource();
			if (kind == CustomDebugInfoGuids.EncLambdaAndClosureMap)
				return ReadEncLambdaAndClosureMap(reader.Length);
			if (kind == CustomDebugInfoGuids.EncLocalSlotMap)
				return ReadEncLocalSlotMap(reader.Length);
			if (kind == CustomDebugInfoGuids.SourceLink)
				return ReadSourceLink();
			if (kind == CustomDebugInfoGuids.StateMachineHoistedLocalScopes)
				return ReadStateMachineHoistedLocalScopes();
			if (kind == CustomDebugInfoGuids.TupleElementNames)
				return ReadTupleElementNames();
			Debug.Fail("Unknown custom debug info guid: " + kind.ToString());
			return new PdbUnknownCustomDebugInfo(kind, reader.ReadRemainingBytes());
		}

		PdbCustomDebugInfo ReadAsyncMethodSteppingInformationBlob() {
			if (bodyOpt == null)
				return null;
			uint catchHandlerOffset = reader.ReadUInt32() - 1;
			Instruction catchHandler;
			if (catchHandlerOffset == uint.MaxValue)
				catchHandler = null;
			else {
				catchHandler = GetInstruction(catchHandlerOffset);
				Debug.Assert(catchHandler != null);
				if (catchHandler == null)
					return null;
			}
			var asyncInfo = new PdbAsyncMethodSteppingInformationCustomDebugInfo();
			asyncInfo.CatchHandler = catchHandler;
			while (reader.Position < reader.Length) {
				var yieldInstr = GetInstruction(reader.ReadUInt32());
				Debug.Assert(yieldInstr != null);
				if (yieldInstr == null)
					return null;
				uint resumeOffset = reader.ReadUInt32();
				var moveNextRid = reader.ReadCompressedUInt32();
				var moveNextToken = new MDToken(Table.Method, moveNextRid);
				MethodDef moveNextMethod;
				Instruction resumeInstr;
				if (gpContext.Method != null && moveNextToken == gpContext.Method.MDToken) {
					moveNextMethod = gpContext.Method;
					resumeInstr = GetInstruction(resumeOffset);
				}
				else {
					moveNextMethod = module.ResolveToken(moveNextToken, gpContext) as MethodDef;
					Debug.Assert(moveNextMethod != null);
					if (moveNextMethod == null)
						return null;
					resumeInstr = GetInstruction(moveNextMethod, resumeOffset);
				}
				Debug.Assert(resumeInstr != null);
				if (resumeInstr == null)
					return null;
				asyncInfo.AsyncStepInfos.Add(new PdbAsyncStepInfo(yieldInstr, moveNextMethod, resumeInstr));
			}
			return asyncInfo;
		}

		PdbCustomDebugInfo ReadDefaultNamespace() {
			var defaultNs = Encoding.UTF8.GetString(reader.ReadRemainingBytes());
			return new PdbDefaultNamespaceCustomDebugInfo(defaultNs);
		}

		PdbCustomDebugInfo ReadDynamicLocalVariables(long recPosEnd) {
			var flags = new bool[(int)reader.Length * 8];
			int w = 0;
			while (reader.Position < reader.Length) {
				int b = reader.ReadByte();
				for (int i = 1; i < 0x100; i <<= 1)
					flags[w++] = (b & i) != 0;
			}
			return new PdbDynamicLocalVariablesCustomDebugInfo(flags);
		}

		PdbCustomDebugInfo ReadEmbeddedSource() {
			return new PdbEmbeddedSourceCustomDebugInfo(reader.ReadRemainingBytes());
		}

		PdbCustomDebugInfo ReadEncLambdaAndClosureMap(long recPosEnd) {
			var data = reader.ReadBytes((int)(recPosEnd - reader.Position));
			return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);
		}

		PdbCustomDebugInfo ReadEncLocalSlotMap(long recPosEnd) {
			var data = reader.ReadBytes((int)(recPosEnd - reader.Position));
			return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);
		}

		PdbCustomDebugInfo ReadSourceLink() {
			return new PdbSourceLinkCustomDebugInfo(reader.ReadRemainingBytes());
		}

		PdbCustomDebugInfo ReadStateMachineHoistedLocalScopes() {
			if (bodyOpt == null)
				return null;
			int count = (int)(reader.Length / 8);
			var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);
			for (int i = 0; i < count; i++) {
				uint startOffset = reader.ReadUInt32();
				uint length = reader.ReadUInt32();
				if (startOffset == 0 && length == 0)
					smScope.Scopes.Add(new StateMachineHoistedLocalScope());
				else {
					var start = GetInstruction(startOffset);
					var end = GetInstruction(startOffset + length);
					Debug.Assert(start != null);
					if (start == null)
						return null;
					smScope.Scopes.Add(new StateMachineHoistedLocalScope(start, end));
				}
			}
			return smScope;
		}

		PdbCustomDebugInfo ReadTupleElementNames() {
			var tupleListRec = new PortablePdbTupleElementNamesCustomDebugInfo();
			while (reader.Position < reader.Length) {
				var name = ReadUTF8Z(reader.Length);
				tupleListRec.Names.Add(name);
			}
			return tupleListRec;
		}

		string ReadUTF8Z(long recPosEnd) {
			if (reader.Position > recPosEnd)
				return null;
			var bytes = reader.ReadBytesUntilByte(0);
			if (bytes == null)
				return null;
			var s = Encoding.UTF8.GetString(bytes);
			reader.Position++;
			return s;
		}

		Instruction GetInstruction(uint offset) {
			var instructions = bodyOpt.Instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}

		static Instruction GetInstruction(MethodDef method, uint offset) {
			if (method == null)
				return null;
			var body = method.Body;
			if (body == null)
				return null;
			var instructions = body.Instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}

		public void Dispose() {
			reader.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/PortablePdbCustomDebugInfoWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.IO;
using System.Text;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet.Pdb.Portable {
	interface IPortablePdbCustomDebugInfoWriterHelper : IWriterError {
	}

	struct PortablePdbCustomDebugInfoWriter {
		readonly IPortablePdbCustomDebugInfoWriterHelper helper;
		readonly SerializerMethodContext methodContext;
		readonly MetaData systemMetaData;
		readonly MemoryStream outStream;
		readonly BinaryWriter writer;

		public static byte[] Write(IPortablePdbCustomDebugInfoWriterHelper helper, SerializerMethodContext methodContext, MetaData systemMetaData, PdbCustomDebugInfo cdi, BinaryWriterContext context) {
			var writer = new PortablePdbCustomDebugInfoWriter(helper, methodContext, systemMetaData, context);
			return writer.Write(cdi);
		}

		PortablePdbCustomDebugInfoWriter(IPortablePdbCustomDebugInfoWriterHelper helper, SerializerMethodContext methodContext, MetaData systemMetaData, BinaryWriterContext context) {
			this.helper = helper;
			this.methodContext = methodContext;
			this.systemMetaData = systemMetaData;
			this.outStream = context.OutStream;
			this.writer = context.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;
		}

		byte[] Write(PdbCustomDebugInfo cdi) {
			switch (cdi.Kind) {
			case PdbCustomDebugInfoKind.UsingGroups:
			case PdbCustomDebugInfoKind.ForwardMethodInfo:
			case PdbCustomDebugInfoKind.ForwardModuleInfo:
			case PdbCustomDebugInfoKind.StateMachineTypeName:
			case PdbCustomDebugInfoKind.DynamicLocals:
			case PdbCustomDebugInfoKind.TupleElementNames:
			case PdbCustomDebugInfoKind.IteratorMethod:
			default:
				helper.Error("Unreachable code, caller should filter these out");
				return null;

			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:
				WriteStateMachineHoistedLocalScopes((PdbStateMachineHoistedLocalScopesCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:
				WriteEditAndContinueLocalSlotMap((PdbEditAndContinueLocalSlotMapCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:
				WriteEditAndContinueLambdaMap((PdbEditAndContinueLambdaMapCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.Unknown:
				WriteUnknown((PdbUnknownCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.TupleElementNames_PortablePdb:
				WriteTupleElementNames((PortablePdbTupleElementNamesCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.DefaultNamespace:
				WriteDefaultNamespace((PdbDefaultNamespaceCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.DynamicLocalVariables:
				WriteDynamicLocalVariables((PdbDynamicLocalVariablesCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.EmbeddedSource:
				WriteEmbeddedSource((PdbEmbeddedSourceCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.SourceLink:
				WriteSourceLink((PdbSourceLinkCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.AsyncMethod:
				WriteAsyncMethodSteppingInformation((PdbAsyncMethodCustomDebugInfo)cdi);
				break;
			}
			return outStream.ToArray();
		}

		void WriteUTF8Z(string s) {
			var bytes = Encoding.UTF8.GetBytes(s);
			writer.Write(bytes);
			writer.Write((byte)0);
		}

		void WriteStateMachineHoistedLocalScopes(PdbStateMachineHoistedLocalScopesCustomDebugInfo cdi) {
			if (!methodContext.HasBody) {
				helper.Error("Method has no body, can't write custom debug info: " + cdi.Kind);
				return;
			}
			foreach (var scope in cdi.Scopes) {
				uint startOffset, endOffset;
				if (scope.IsSynthesizedLocal) {
					startOffset = 0;
					endOffset = 0;
				}
				else {
					var startInstr = scope.Start;
					if (startInstr == null) {
						helper.Error("Instruction is null");
						return;
					}
					startOffset = methodContext.GetOffset(startInstr);
					endOffset = methodContext.GetOffset(scope.End);
				}
				if (startOffset > endOffset) {
					helper.Error("End instruction is before start instruction");
					return;
				}
				writer.Write(startOffset);
				writer.Write(endOffset - startOffset);
			}
		}

		void WriteEditAndContinueLocalSlotMap(PdbEditAndContinueLocalSlotMapCustomDebugInfo cdi) {
			var d = cdi.Data;
			if (d == null) {
				helper.Error("Data blob is null");
				return;
			}
			writer.Write(d);
		}

		void WriteEditAndContinueLambdaMap(PdbEditAndContinueLambdaMapCustomDebugInfo cdi) {
			var d = cdi.Data;
			if (d == null) {
				helper.Error("Data blob is null");
				return;
			}
			writer.Write(d);
		}

		void WriteUnknown(PdbUnknownCustomDebugInfo cdi) {
			var d = cdi.Data;
			if (d == null) {
				helper.Error("Data blob is null");
				return;
			}
			writer.Write(d);
		}

		void WriteTupleElementNames(PortablePdbTupleElementNamesCustomDebugInfo cdi) {
			foreach (var name in cdi.Names) {
				if (name == null) {
					helper.Error("Tuple name is null");
					return;
				}
				WriteUTF8Z(name);
			}
		}

		void WriteDefaultNamespace(PdbDefaultNamespaceCustomDebugInfo cdi) {
			var ns = cdi.Namespace;
			if (ns == null) {
				helper.Error("Default namespace is null");
				return;
			}
			var bytes = Encoding.UTF8.GetBytes(ns);
			writer.Write(bytes);
		}

		void WriteDynamicLocalVariables(PdbDynamicLocalVariablesCustomDebugInfo cdi) {
			var flags = cdi.Flags;
			for (int i = 0; i < flags.Length; i += 8)
				writer.Write(ToByte(flags, i));
		}

		static byte ToByte(bool[] flags, int index) {
			int res = 0;
			int bit = 1;
			for (int i = index; i < flags.Length; i++, bit <<= 1) {
				if (flags[i])
					res |= bit;
			}
			return (byte)res;
		}

		void WriteEmbeddedSource(PdbEmbeddedSourceCustomDebugInfo cdi) {
			var d = cdi.SourceCodeBlob;
			if (d == null) {
				helper.Error("Source code blob is null");
				return;
			}
			writer.Write(d);
		}

		void WriteSourceLink(PdbSourceLinkCustomDebugInfo cdi) {
			var d = cdi.SourceLinkBlob;
			if (d == null) {
				helper.Error("Source link blob is null");
				return;
			}
			writer.Write(d);
		}

		void WriteAsyncMethodSteppingInformation(PdbAsyncMethodCustomDebugInfo cdi) {
			if (!methodContext.HasBody) {
				helper.Error("Method has no body, can't write custom debug info: " + cdi.Kind);
				return;
			}

			uint catchHandlerOffset;
			if (cdi.CatchHandlerInstruction == null)
				catchHandlerOffset = 0;
			else
				catchHandlerOffset = methodContext.GetOffset(cdi.CatchHandlerInstruction) + 1;
			writer.Write(catchHandlerOffset);

			foreach (var info in cdi.StepInfos) {
				if (info.YieldInstruction == null) {
					helper.Error("YieldInstruction is null");
					return;
				}
				if (info.BreakpointMethod == null) {
					helper.Error("BreakpointMethod is null");
					return;
				}
				if (info.BreakpointInstruction == null) {
					helper.Error("BreakpointInstruction is null");
					return;
				}
				uint yieldOffset = methodContext.GetOffset(info.YieldInstruction);
				uint resumeOffset;
				if (methodContext.IsSameMethod(info.BreakpointMethod))
					resumeOffset = methodContext.GetOffset(info.BreakpointInstruction);
				else
					resumeOffset = GetOffsetSlow(info.BreakpointMethod, info.BreakpointInstruction);
				uint resumeMethodRid = systemMetaData.GetRid(info.BreakpointMethod);
				writer.Write(yieldOffset);
				writer.Write(resumeOffset);
				writer.WriteCompressedUInt32(resumeMethodRid);
			}
		}

		uint GetOffsetSlow(MethodDef method, Instruction instr) {
			var body = method.Body;
			if (body == null) {
				helper.Error("Method has no body");
				return uint.MaxValue;
			}
			var instrs = body.Instructions;
			uint offset = 0;
			for (int i = 0; i < instrs.Count; i++) {
				var instr2 = instrs[i];
				if (instr2 == instr)
					return offset;
				offset += (uint)instr2.GetSize();
			}
			helper.Error("Couldn't find an instruction, maybe it was removed. It's still being referenced by some code or by the PDB");
			return uint.MaxValue;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/PortablePdbReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md

using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;

namespace dnlib.DotNet.Pdb.Portable {
	sealed class PortablePdbReader : SymbolReader {
		readonly PdbFileKind pdbFileKind;
		ModuleDef module;
		readonly IMetaData pdbMetaData;
		SymbolDocument[] documents;

		public override PdbFileKind PdbFileKind {
			get { return pdbFileKind; }
		}

		public override int UserEntryPoint {
			get { return pdbMetaData.PdbStream.EntryPoint.ToInt32(); }
		}

		public override IList<SymbolDocument> Documents {
			get { return documents; }
		}

		public PortablePdbReader(IImageStream pdbStream, PdbFileKind pdbFileKind) {
			this.pdbFileKind = pdbFileKind;
			pdbMetaData = MetaDataCreator.CreateStandalonePortablePDB(pdbStream, true);
		}

		public override void Initialize(ModuleDef module) {
			this.module = module;
			documents = ReadDocuments();
		}

		static Guid GetLanguageVendor(Guid language) {
			if (language == PdbDocumentConstants.LanguageCSharp || language == PdbDocumentConstants.LanguageVisualBasic || language == PdbDocumentConstants.LanguageFSharp)
				return PdbDocumentConstants.LanguageVendorMicrosoft;
			return Guid.Empty;
		}

		SymbolDocument[] ReadDocuments() {
			Debug.Assert(module != null);
			var docTbl = pdbMetaData.TablesStream.DocumentTable;
			var docs = new SymbolDocument[docTbl.Rows];
			var nameReader = new DocumentNameReader(pdbMetaData.BlobStream);
			var custInfos = ListCache<PdbCustomDebugInfo>.AllocList();
			var gpContext = new GenericParamContext();
			for (int i = 0; i < docs.Length; i++) {
				uint nameOffset, hashAlgorithmIndex, hashOffset;
				uint languageIndex = pdbMetaData.TablesStream.ReadDocumentRow2((uint)i + 1, out nameOffset, out hashAlgorithmIndex, out hashOffset);
				var url = nameReader.ReadDocumentName(nameOffset);
				var language = pdbMetaData.GuidStream.Read(languageIndex) ?? Guid.Empty;
				var languageVendor = GetLanguageVendor(language);
				var documentType = PdbDocumentConstants.DocumentTypeText;
				var checkSumAlgorithmId = pdbMetaData.GuidStream.Read(hashAlgorithmIndex) ?? Guid.Empty;
				var checkSum = pdbMetaData.BlobStream.ReadNoNull(hashOffset);

				var token = new MDToken(Table.Document, i + 1).ToInt32();
				custInfos.Clear();
				GetCustomDebugInfos(token, gpContext, custInfos);
				var custInfosArray = custInfos.Count == 0 ? emptyPdbCustomDebugInfos : custInfos.ToArray();

				docs[i] = new SymbolDocumentImpl(url, language, languageVendor, documentType, checkSumAlgorithmId, checkSum, custInfosArray);
			}
			ListCache<PdbCustomDebugInfo>.Free(ref custInfos);
			return docs;
		}
		static readonly PdbCustomDebugInfo[] emptyPdbCustomDebugInfos = new PdbCustomDebugInfo[0];

		bool TryGetSymbolDocument(uint rid, out SymbolDocument document) {
			int index = (int)rid - 1;
			if ((uint)index >= (uint)documents.Length) {
				Debug.Fail("Couldn't find document with rid 0x" + rid.ToString("X6"));
				document = null;
				return false;
			}
			document = documents[index];
			return true;
		}

		public override SymbolMethod GetMethod(MethodDef method, int version) {
			var mdTable = pdbMetaData.TablesStream.MethodDebugInformationTable;
			uint methodRid = method.Rid;
			if (!mdTable.IsValidRID(methodRid))
				return null;

			var sequencePoints = ReadSequencePoints(methodRid) ?? emptySymbolSequencePoints;
			var gpContext = GenericParamContext.Create(method);
			var rootScope = ReadScope(methodRid, gpContext);

			var kickoffMethod = GetKickoffMethod(methodRid);
			var symbolMethod = new SymbolMethodImpl(this, method.MDToken.ToInt32(), rootScope, sequencePoints, kickoffMethod);
			rootScope.method = symbolMethod;
			return symbolMethod;
		}
		static readonly SymbolAsyncStepInfo[] emptySymbolAsyncStepInfos = new SymbolAsyncStepInfo[0];

		int GetKickoffMethod(uint methodRid) {
			uint rid = pdbMetaData.GetStateMachineMethodRid(methodRid);
			if (rid == 0)
				return 0;
			if (!pdbMetaData.TablesStream.StateMachineMethodTable.IsValidRID(rid))
				return 0;
			return 0x06000000 + (int)pdbMetaData.TablesStream.ReadStateMachineMethodRow2(rid);
		}

		SymbolSequencePoint[] ReadSequencePoints(uint methodRid) {
			if (!pdbMetaData.TablesStream.MethodDebugInformationTable.IsValidRID(methodRid))
				return null;
			uint documentRid;
			uint sequencePointsOffset = pdbMetaData.TablesStream.ReadMethodDebugInformationRow2(methodRid, out documentRid);
			if (sequencePointsOffset == 0)
				return null;

			var seqPointsBuilder = ListCache<SymbolSequencePoint>.AllocList();
			using (var seqPointsStream = pdbMetaData.BlobStream.CreateStream(sequencePointsOffset)) {
				uint localSig = seqPointsStream.ReadCompressedUInt32();
				if (documentRid == 0)
					documentRid = seqPointsStream.ReadCompressedUInt32();

				SymbolDocument document;
				TryGetSymbolDocument(documentRid, out document);

				uint ilOffset = uint.MaxValue;
				int line = -1, column = 0;
				bool canReadDocumentRecord = false;
				while (seqPointsStream.Position < seqPointsStream.Length) {
					uint data = seqPointsStream.ReadCompressedUInt32();
					if (data == 0 && canReadDocumentRecord) {
						// document-record

						documentRid = seqPointsStream.ReadCompressedUInt32();
						TryGetSymbolDocument(documentRid, out document);
					}
					else {
						// SequencePointRecord

						Debug.Assert(document != null);
						if (document == null)
							return null;

						var symSeqPoint = new SymbolSequencePoint {
							Document = document,
						};

						if (ilOffset == uint.MaxValue)
							ilOffset = data;
						else {
							Debug.Assert(data != 0);
							if (data == 0)
								return null;
							ilOffset += data;
						}
						symSeqPoint.Offset = (int)ilOffset;

						uint dlines = seqPointsStream.ReadCompressedUInt32();
						int dcolumns = dlines == 0 ? (int)seqPointsStream.ReadCompressedUInt32() : seqPointsStream.ReadCompressedInt32();

						if (dlines == 0 && dcolumns == 0) {
							// hidden-sequence-point-record

							symSeqPoint.Line = SequencePointConstants.HIDDEN_LINE;
							symSeqPoint.EndLine = SequencePointConstants.HIDDEN_LINE;
							symSeqPoint.Column = SequencePointConstants.HIDDEN_COLUMN;
							symSeqPoint.EndColumn = SequencePointConstants.HIDDEN_COLUMN;
						}
						else {
							// sequence-point-record

							if (line < 0) {
								line = (int)seqPointsStream.ReadCompressedUInt32();
								column = (int)seqPointsStream.ReadCompressedUInt32();
							}
							else {
								line += seqPointsStream.ReadCompressedInt32();
								column += seqPointsStream.ReadCompressedInt32();
							}

							symSeqPoint.Line = line;
							symSeqPoint.EndLine = line + (int)dlines;
							symSeqPoint.Column = column;
							symSeqPoint.EndColumn = column + dcolumns;
						}

						seqPointsBuilder.Add(symSeqPoint);
					}

					canReadDocumentRecord = true;
				}
				Debug.Assert(seqPointsStream.Position == seqPointsStream.Length);
			}

			return ListCache<SymbolSequencePoint>.FreeAndToArray(ref seqPointsBuilder);
		}
		static readonly SymbolSequencePoint[] emptySymbolSequencePoints = new SymbolSequencePoint[0];

		SymbolScopeImpl ReadScope(uint methodRid, GenericParamContext gpContext) {
			var scopesRidList = pdbMetaData.GetLocalScopeRidList(methodRid);
			SymbolScopeImpl rootScopeOrNull = null;
			if (scopesRidList.Count != 0) {
				var custInfos = ListCache<PdbCustomDebugInfo>.AllocList();
				var stack = ListCache<SymbolScopeImpl>.AllocList();
				var importScopeBlobReader = new ImportScopeBlobReader(module, pdbMetaData.BlobStream);
				for (int i = 0; i < scopesRidList.Count; i++) {
					var rid = scopesRidList[i];
					uint importScope, variableList, constantList, startOffset;
					int token = new MDToken(Table.LocalScope, rid).ToInt32();
					uint length = pdbMetaData.TablesStream.ReadLocalScopeRow2(rid, out importScope, out variableList, out constantList, out startOffset);
					uint endOffset = startOffset + length;

					SymbolScopeImpl parent = null;
					while (stack.Count > 0) {
						var nextParent = stack[stack.Count - 1];
						if (startOffset >= nextParent.StartOffset && endOffset <= nextParent.EndOffset) {
							parent = nextParent;
							break;
						}
						stack.RemoveAt(stack.Count - 1);
					}

					Debug.Assert(parent != null || rootScopeOrNull == null);
					custInfos.Clear();
					GetCustomDebugInfos(token, gpContext, custInfos);
					var customDebugInfos = custInfos.Count == 0 ? emptyPdbCustomDebugInfos : custInfos.ToArray();
					var scope = new SymbolScopeImpl(this, parent, (int)startOffset, (int)endOffset, customDebugInfos);
					if (rootScopeOrNull == null)
						rootScopeOrNull = scope;
					stack.Add(scope);
					if (parent != null)
						parent.childrenList.Add(scope);

					scope.importScope = ReadPdbImportScope(ref importScopeBlobReader, importScope, gpContext);
					uint variableListEnd, constantListEnd;
					GetEndOfLists(rid, out variableListEnd, out constantListEnd);
					ReadVariables(scope, gpContext, variableList, variableListEnd);
					ReadConstants(scope, constantList, constantListEnd);
				}

				ListCache<SymbolScopeImpl>.Free(ref stack);
				ListCache<PdbCustomDebugInfo>.Free(ref custInfos);
			}
			return rootScopeOrNull ?? new SymbolScopeImpl(this, null, 0, int.MaxValue, emptyPdbCustomDebugInfos);
		}

		void GetEndOfLists(uint scopeRid, out uint variableListEnd, out uint constantListEnd) {
			var localScopeTable = pdbMetaData.TablesStream.LocalScopeTable;
			var nextRid = scopeRid + 1;
			if (!localScopeTable.IsValidRID(nextRid)) {
				variableListEnd = pdbMetaData.TablesStream.LocalVariableTable.Rows + 1;
				constantListEnd = pdbMetaData.TablesStream.LocalConstantTable.Rows + 1;
			}
			else {
				uint nextImportScope, nextVariableList, nextConstantList, nextStartOffset;
				pdbMetaData.TablesStream.ReadLocalScopeRow2(nextRid, out nextImportScope, out nextVariableList, out nextConstantList, out nextStartOffset);
				variableListEnd = nextVariableList;
				constantListEnd = nextConstantList;
			}
		}

		PdbImportScope ReadPdbImportScope(ref ImportScopeBlobReader importScopeBlobReader, uint importScope, GenericParamContext gpContext) {
			if (importScope == 0)
				return null;
			const int MAX = 1000;
			PdbImportScope result = null;
			PdbImportScope prevScope = null;
			for (int i = 0; importScope != 0; i++) {
				Debug.Assert(i < MAX);
				if (i >= MAX)
					return null;
				int token = new MDToken(Table.ImportScope, importScope).ToInt32();
				if (!pdbMetaData.TablesStream.ImportScopeTable.IsValidRID(importScope))
					return null;
				uint imports = pdbMetaData.TablesStream.ReadImportScopeRow2(importScope, out importScope);
				var scope = new PdbImportScope();
				GetCustomDebugInfos(token, gpContext, scope.CustomDebugInfos);
				if (result == null)
					result = scope;
				if (prevScope != null)
					prevScope.Parent = scope;
				importScopeBlobReader.Read(imports, scope.Imports);
				prevScope = scope;
			}

			return result;
		}

		void ReadVariables(SymbolScopeImpl scope, GenericParamContext gpContext, uint variableList, uint variableListEnd) {
			if (variableList == 0)
				return;
			Debug.Assert(variableList <= variableListEnd);
			if (variableList >= variableListEnd)
				return;
			var table = pdbMetaData.TablesStream.LocalVariableTable;
			Debug.Assert(table.IsValidRID(variableListEnd - 1));
			if (!table.IsValidRID(variableListEnd - 1))
				return;
			Debug.Assert(table.IsValidRID(variableList));
			if (!table.IsValidRID(variableList))
				return;
			var custInfos = ListCache<PdbCustomDebugInfo>.AllocList();
			for (uint rid = variableList; rid < variableListEnd; rid++) {
				int token = new MDToken(Table.LocalVariable, rid).ToInt32();
				custInfos.Clear();
				GetCustomDebugInfos(token, gpContext, custInfos);
				var customDebugInfos = custInfos.Count == 0 ? emptyPdbCustomDebugInfos : custInfos.ToArray();
				ushort attributes, index;
				var nameOffset = pdbMetaData.TablesStream.ReadLocalVariableRow2(rid, out attributes, out index);
				var name = pdbMetaData.StringsStream.Read(nameOffset);
				scope.localsList.Add(new SymbolVariableImpl(name, ToSymbolVariableAttributes(attributes), index, customDebugInfos));
			}
			ListCache<PdbCustomDebugInfo>.Free(ref custInfos);
		}

		static PdbLocalAttributes ToSymbolVariableAttributes(ushort attributes) {
			var res = PdbLocalAttributes.None;
			const ushort DebuggerHidden = 0x0001;
			if ((attributes & DebuggerHidden) != 0)
				res |= PdbLocalAttributes.DebuggerHidden;
			return res;
		}

		void ReadConstants(SymbolScopeImpl scope, uint constantList, uint constantListEnd) {
			if (constantList == 0)
				return;
			Debug.Assert(constantList <= constantListEnd);
			if (constantList >= constantListEnd)
				return;
			var table = pdbMetaData.TablesStream.LocalConstantTable;
			Debug.Assert(table.IsValidRID(constantListEnd - 1));
			if (!table.IsValidRID(constantListEnd - 1))
				return;
			Debug.Assert(table.IsValidRID(constantList));
			if (!table.IsValidRID(constantList))
				return;
			scope.SetConstants(pdbMetaData, constantList, constantListEnd);
		}

		internal void GetCustomDebugInfos(SymbolMethodImpl symMethod, MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			Debug.Assert(method.Module == module);
			PdbAsyncMethodSteppingInformationCustomDebugInfo asyncStepInfo;
			GetCustomDebugInfos(method.MDToken.ToInt32(), GenericParamContext.Create(method), result, method, body, out asyncStepInfo);
			if (asyncStepInfo != null) {
				var asyncMethod = TryCreateAsyncMethod(module, symMethod.KickoffMethod, asyncStepInfo.AsyncStepInfos, asyncStepInfo.CatchHandler);
				Debug.Assert(asyncMethod != null);
				if (asyncMethod != null)
					result.Add(asyncMethod);
			}
			else if (symMethod.KickoffMethod != 0) {
				var iteratorMethod = TryCreateIteratorMethod(module, symMethod.KickoffMethod);
				Debug.Assert(iteratorMethod != null);
				if (iteratorMethod != null)
					result.Add(iteratorMethod);
			}
		}

		PdbAsyncMethodCustomDebugInfo TryCreateAsyncMethod(ModuleDef module, int asyncKickoffMethod, IList<PdbAsyncStepInfo> asyncStepInfos, Instruction asyncCatchHandler) {
			var kickoffToken = new MDToken(asyncKickoffMethod);
			if (kickoffToken.Table != Table.Method)
				return null;

			var asyncMethod = new PdbAsyncMethodCustomDebugInfo(asyncStepInfos.Count);
			asyncMethod.KickoffMethod = module.ResolveToken(kickoffToken) as MethodDef;
			asyncMethod.CatchHandlerInstruction = asyncCatchHandler;
			foreach (var info in asyncStepInfos)
				asyncMethod.StepInfos.Add(info);
			return asyncMethod;
		}

		PdbIteratorMethodCustomDebugInfo TryCreateIteratorMethod(ModuleDef module, int iteratorKickoffMethod) {
			var kickoffToken = new MDToken(iteratorKickoffMethod);
			if (kickoffToken.Table != Table.Method)
				return null;
			var kickoffMethod = module.ResolveToken(kickoffToken) as MethodDef;
			return new PdbIteratorMethodCustomDebugInfo(kickoffMethod);
		}

		public override void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
			PdbAsyncMethodSteppingInformationCustomDebugInfo asyncStepInfo;
			GetCustomDebugInfos(token, gpContext, result, null, null, out asyncStepInfo);
			Debug.Assert(asyncStepInfo == null);
		}

		void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result, MethodDef methodOpt, CilBody bodyOpt, out PdbAsyncMethodSteppingInformationCustomDebugInfo asyncStepInfo) {
			asyncStepInfo = null;
			var mdToken = new MDToken(token);
			var ridList = pdbMetaData.GetCustomDebugInformationRidList(mdToken.Table, mdToken.Rid);
			if (ridList.Count == 0)
				return;
			var typeOpt = methodOpt == null ? null : methodOpt.DeclaringType;
			for (int i = 0; i < ridList.Count; i++) {
				var rid = ridList[i];
				uint kind;
				uint value = pdbMetaData.TablesStream.ReadCustomDebugInformationRow2(rid, out kind);
				var guid = pdbMetaData.GuidStream.Read(kind);
				var data = pdbMetaData.BlobStream.Read(value);
				Debug.Assert(guid != null && data != null);
				if (guid == null || data == null)
					continue;
				var cdi = PortablePdbCustomDebugInfoReader.Read(module, typeOpt, bodyOpt, gpContext, guid.Value, data);
				Debug.Assert(cdi != null);
				if (cdi != null) {
					var asyncStepInfoTmp = cdi as PdbAsyncMethodSteppingInformationCustomDebugInfo;
					if (asyncStepInfoTmp != null) {
						Debug.Assert(asyncStepInfo == null);
						asyncStepInfo = asyncStepInfoTmp;
					}
					else
						result.Add(cdi);
				}
			}
		}

		public override void Dispose() {
			pdbMetaData.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/SequencePointConstants.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb.Portable {
	static class SequencePointConstants {
		public const int HIDDEN_LINE = 0xFEEFEE;
		public const int HIDDEN_COLUMN = 0;
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/SymbolDocumentImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.Text;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Portable {
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	sealed class SymbolDocumentImpl : SymbolDocument {
		readonly string url;
		/*readonly*/ Guid language;
		/*readonly*/ Guid languageVendor;
		/*readonly*/ Guid documentType;
		/*readonly*/ Guid checkSumAlgorithmId;
		readonly byte[] checkSum;
		readonly PdbCustomDebugInfo[] customDebugInfos;

		string GetDebuggerString() {
			var sb = new StringBuilder();
			if (language == PdbDocumentConstants.LanguageCSharp)
				sb.Append("C#");
			else if (language == PdbDocumentConstants.LanguageVisualBasic)
				sb.Append("VB");
			else if (language == PdbDocumentConstants.LanguageFSharp)
				sb.Append("F#");
			else
				sb.Append(language.ToString());
			sb.Append(", ");
			if (checkSumAlgorithmId == PdbDocumentConstants.HashSHA1)
				sb.Append("SHA-1");
			else if (checkSumAlgorithmId == PdbDocumentConstants.HashSHA256)
				sb.Append("SHA-256");
			else
				sb.Append(checkSumAlgorithmId.ToString());
			sb.Append(": ");
			sb.Append(url);
			return sb.ToString();
		}

		public override string URL {
			get { return url; }
		}

		public override Guid Language {
			get { return language; }
		}

		public override Guid LanguageVendor {
			get { return languageVendor; }
		}

		public override Guid DocumentType {
			get { return documentType; }
		}

		public override Guid CheckSumAlgorithmId {
			get { return checkSumAlgorithmId; }
		}

		public override byte[] CheckSum {
			get { return checkSum; }
		}

		public override PdbCustomDebugInfo[] CustomDebugInfos {
			get { return customDebugInfos; }
		}

		public SymbolDocumentImpl(string url, Guid language, Guid languageVendor, Guid documentType, Guid checkSumAlgorithmId, byte[] checkSum, PdbCustomDebugInfo[] customDebugInfos) {
			this.url = url;
			this.language = language;
			this.languageVendor = languageVendor;
			this.documentType = documentType;
			this.checkSumAlgorithmId = checkSumAlgorithmId;
			this.checkSum = checkSum;
			this.customDebugInfos = customDebugInfos;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/SymbolMethodImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Portable {
	sealed class SymbolMethodImpl : SymbolMethod {
		readonly PortablePdbReader reader;
		readonly int token;
		readonly SymbolScope rootScope;
		readonly SymbolSequencePoint[] sequencePoints;
		readonly int kickoffMethod;

		public override int Token {
			get { return token; }
		}

		public override SymbolScope RootScope {
			get { return rootScope; }
		}

		public override IList<SymbolSequencePoint> SequencePoints {
			get { return sequencePoints; }
		}

		public int KickoffMethod {
			get { return kickoffMethod; }
		}

		public SymbolMethodImpl(PortablePdbReader reader, int token, SymbolScope rootScope, SymbolSequencePoint[] sequencePoints, int kickoffMethod) {
			this.reader = reader;
			this.token = token;
			this.rootScope = rootScope;
			this.sequencePoints = sequencePoints;
			this.kickoffMethod = kickoffMethod;
		}

		public override void GetCustomDebugInfos(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			reader.GetCustomDebugInfos(this, method, body, result);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/SymbolReaderCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb.Symbols;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Pdb.Portable {
	static class SymbolReaderCreator {
		public static SymbolReader TryCreate(IImageStream pdbStream, bool isEmbeddedPortablePdb) {
			try {
				if (pdbStream != null) {
					pdbStream.Position = 0;
					if (pdbStream.ReadUInt32() == 0x424A5342) {
						pdbStream.Position = 0;
						return new PortablePdbReader(pdbStream, isEmbeddedPortablePdb ? PdbFileKind.EmbeddedPortablePDB : PdbFileKind.PortablePDB);
					}
				}
			}
			catch (IOException) {
			}
			if (pdbStream != null)
				pdbStream.Dispose();
			return null;
		}

		public static SymbolReader TryCreate(IMetaData metaData) {
			if (metaData == null)
				return null;
			try {
				var peImage = metaData.PEImage;
				if (peImage == null)
					return null;
				var embeddedDir = TryGetEmbeddedDebugDirectory(peImage);
				if (embeddedDir == null)
					return null;
				using (var reader = peImage.CreateStream(embeddedDir.PointerToRawData, embeddedDir.SizeOfData)) {
					// "MPDB" = 0x4244504D
					if (reader.ReadUInt32() != 0x4244504D)
						return null;
					uint uncompressedSize = reader.ReadUInt32();
					// If this fails, see the (hopefully) updated spec:
					//		https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#embedded-portable-pdb-debug-directory-entry-type-17
					bool newVersion = (uncompressedSize & 0x80000000) != 0;
					Debug.Assert(!newVersion);
					if (newVersion)
						return null;
					var decompressedBytes = new byte[uncompressedSize];
					using (var deflateStream = new DeflateStream(new MemoryStream(reader.ReadRemainingBytes()), CompressionMode.Decompress)) {
						int pos = 0;
						while (pos < decompressedBytes.Length) {
							int read = deflateStream.Read(decompressedBytes, pos, decompressedBytes.Length - pos);
							if (read == 0)
								break;
							pos += read;
						}
						if (pos != decompressedBytes.Length)
							return null;
						var stream = MemoryImageStream.Create(decompressedBytes);
						return TryCreate(stream, true);
					}
				}
			}
			catch (IOException) {
			}
			return null;
		}

		static ImageDebugDirectory TryGetEmbeddedDebugDirectory(IPEImage peImage) {
			foreach (var idd in peImage.ImageDebugDirectories) {
				if (idd.Type == ImageDebugType.EmbeddedPortablePdb)
					return idd;
			}
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/SymbolScopeImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Portable {
	sealed class SymbolScopeImpl : SymbolScope {
		readonly PortablePdbReader owner;
		internal SymbolMethod method;
		readonly SymbolScopeImpl parent;
		readonly int startOffset;
		readonly int endOffset;
		internal readonly List<SymbolScope> childrenList;
		internal readonly List<SymbolVariable> localsList;
		internal PdbImportScope importScope;
		readonly PdbCustomDebugInfo[] customDebugInfos;

		public override SymbolMethod Method {
			get {
				if (method != null)
					return method;
				var p = parent;
				if (p == null)
					return method;
				for (;;) {
					if (p.parent == null)
						return method = p.method;
					p = p.parent;
				}
			}
		}

		public override SymbolScope Parent {
			get { return parent; }
		}

		public override int StartOffset {
			get { return startOffset; }
		}

		public override int EndOffset {
			get { return endOffset; }
		}

		public override IList<SymbolScope> Children {
			get { return childrenList; }
		}

		public override IList<SymbolVariable> Locals {
			get { return localsList; }
		}

		public override IList<SymbolNamespace> Namespaces {
			get { return emptySymbolNamespaces; }
		}
		static readonly SymbolNamespace[] emptySymbolNamespaces = new SymbolNamespace[0];

		public override IList<PdbCustomDebugInfo> CustomDebugInfos {
			get { return customDebugInfos; }
		}

		public override PdbImportScope ImportScope {
			get { return importScope; }
		}

		public SymbolScopeImpl(PortablePdbReader owner, SymbolScopeImpl parent, int startOffset, int endOffset, PdbCustomDebugInfo[] customDebugInfos) {
			this.owner = owner;
			method = null;
			this.parent = parent;
			this.startOffset = startOffset;
			this.endOffset = endOffset;
			childrenList = new List<SymbolScope>();
			localsList = new List<SymbolVariable>();
			this.customDebugInfos = customDebugInfos;
		}

		IMetaData constantsMetaData;
		uint constantList;
		uint constantListEnd;

		internal void SetConstants(IMetaData metaData, uint constantList, uint constantListEnd) {
			constantsMetaData = metaData;
			this.constantList = constantList;
			this.constantListEnd = constantListEnd;
		}

		public override IList<PdbConstant> GetConstants(ModuleDef module, GenericParamContext gpContext) {
			if (constantList >= constantListEnd)
				return emptyPdbConstants;
			Debug.Assert(constantsMetaData != null);

			var res = new PdbConstant[constantListEnd - constantList];
			int w = 0;
			for (int i = 0; i < res.Length; i++) {
				uint rid = constantList + (uint)i;
				uint nameOffset;
				uint signature = constantsMetaData.TablesStream.ReadLocalConstantRow2(rid, out nameOffset);
				var name = constantsMetaData.StringsStream.Read(nameOffset);
				using (var stream = constantsMetaData.BlobStream.CreateStream(signature)) {
					var localConstantSigBlobReader = new LocalConstantSigBlobReader(module, stream, gpContext);
					TypeSig type;
					object value;
					bool b = localConstantSigBlobReader.Read(out type, out value);
					Debug.Assert(b);
					if (b) {
						var pdbConstant = new PdbConstant(name, type, value);
						int token = new MDToken(Table.LocalConstant, rid).ToInt32();
						owner.GetCustomDebugInfos(token, gpContext, pdbConstant.CustomDebugInfos);
						res[w++] = pdbConstant;
					}
					Debug.Assert(stream.Position == stream.Length);
				}
			}
			if (res.Length != w)
				Array.Resize(ref res, w);
			return res;
		}
		static readonly PdbConstant[] emptyPdbConstants = new PdbConstant[0];
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Portable/SymbolVariableImpl.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.Portable {
	sealed class SymbolVariableImpl : SymbolVariable {
		readonly string name;
		readonly PdbLocalAttributes attributes;
		readonly int index;
		readonly PdbCustomDebugInfo[] customDebugInfos;

		public override string Name {
			get { return name; }
		}

		public override PdbLocalAttributes Attributes {
			get { return attributes; }
		}

		public override int Index {
			get { return index; }
		}

		public override PdbCustomDebugInfo[] CustomDebugInfos {
			get { return customDebugInfos; }
		}

		public SymbolVariableImpl(string name, PdbLocalAttributes attributes, int index, PdbCustomDebugInfo[] customDebugInfos) {
			this.name = name;
			this.attributes = attributes;
			this.index = index;
			this.customDebugInfos = customDebugInfos;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Symbols/SymbolAsyncStepInfo.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// Async step info
	/// </summary>
	public struct SymbolAsyncStepInfo {
		/// <summary>
		/// Yield offset
		/// </summary>
		public uint YieldOffset;

		/// <summary>
		/// Breakpoint offset
		/// </summary>
		public uint BreakpointOffset;

		/// <summary>
		/// Breakpoint method token
		/// </summary>
		public uint BreakpointMethod;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="yieldOffset">Yield offset</param>
		/// <param name="breakpointOffset">Breakpoint offset</param>
		/// <param name="breakpointMethod">Breakpoint method token</param>
		public SymbolAsyncStepInfo(uint yieldOffset, uint breakpointOffset, uint breakpointMethod) {
			YieldOffset = yieldOffset;
			BreakpointOffset = breakpointOffset;
			BreakpointMethod = breakpointMethod;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Symbols/SymbolDocument.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A document
	/// </summary>
	public abstract class SymbolDocument {
		/// <summary>
		/// Gets the URL
		/// </summary>
		public abstract string URL { get; }

		/// <summary>
		/// Gets the language
		/// </summary>
		public abstract Guid Language { get; }

		/// <summary>
		/// Gets the language vendor
		/// </summary>
		public abstract Guid LanguageVendor { get; }

		/// <summary>
		/// Gets the document type
		/// </summary>
		public abstract Guid DocumentType { get; }

		/// <summary>
		/// Gets the checksum algorithm id
		/// </summary>
		public abstract Guid CheckSumAlgorithmId { get; }

		/// <summary>
		/// Gets the checksum
		/// </summary>
		public abstract byte[] CheckSum { get; }

		/// <summary>
		/// Gets the custom debug infos
		/// </summary>
		public abstract PdbCustomDebugInfo[] CustomDebugInfos { get; }
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Symbols/SymbolMethod.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A method
	/// </summary>
	public abstract class SymbolMethod {
		/// <summary>
		/// Gets the method token
		/// </summary>
		public abstract int Token { get; }

		/// <summary>
		/// Gets the root scope
		/// </summary>
		public abstract SymbolScope RootScope { get; }

		/// <summary>
		/// Gets all sequence points
		/// </summary>
		public abstract IList<SymbolSequencePoint> SequencePoints { get; }

		/// <summary>
		/// Reads custom debug info
		/// </summary>
		/// <param name="method">Method</param>
		/// <param name="body">Method body</param>
		/// <param name="result">Updated with custom debug info</param>
		public abstract void GetCustomDebugInfos(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Symbols/SymbolNamespace.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A namespace
	/// </summary>
	public abstract class SymbolNamespace {
		/// <summary>
		/// Gets the name
		/// </summary>
		public abstract string Name { get; }
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Symbols/SymbolReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// Reads symbols from a PDB file
	/// </summary>
	public abstract class SymbolReader : IDisposable {
		/// <summary>
		/// Called by the owner module before any other methods and properties are called
		/// </summary>
		/// <param name="module">Owner module</param>
		public abstract void Initialize(ModuleDef module);

		/// <summary>
		/// Gets the PDB file kind
		/// </summary>
		public abstract PdbFileKind PdbFileKind { get; }

		/// <summary>
		/// Gets the user entry point token or 0 if none
		/// </summary>
		public abstract int UserEntryPoint { get; }

		/// <summary>
		/// Gets all documents
		/// </summary>
		public abstract IList<SymbolDocument> Documents { get; }

		/// <summary>
		/// Gets a method or returns null if the method doesn't exist in the PDB file
		/// </summary>
		/// <param name="method">Method</param>
		/// <param name="version">Edit and continue version</param>
		/// <returns></returns>
		public abstract SymbolMethod GetMethod(MethodDef method, int version);

		/// <summary>
		/// Reads custom debug info
		/// </summary>
		/// <param name="token">Token of a <see cref="IHasCustomDebugInformation"/> instance</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="result">Updated with custom debug info</param>
		public abstract void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result);

		/// <summary>
		/// Cleans up resources
		/// </summary>
		public virtual void Dispose() {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Symbols/SymbolScope.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;

namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A scope
	/// </summary>
	public abstract class SymbolScope {
		/// <summary>
		/// Gets the method
		/// </summary>
		public abstract SymbolMethod Method { get; }

		/// <summary>
		/// Gets the parent scope
		/// </summary>
		public abstract SymbolScope Parent { get; }

		/// <summary>
		/// Gets the start offset of the scope in the method
		/// </summary>
		public abstract int StartOffset { get; }

		/// <summary>
		/// Gets the end offset of the scope in the method
		/// </summary>
		public abstract int EndOffset { get; }

		/// <summary>
		/// Gets all child scopes
		/// </summary>
		public abstract IList<SymbolScope> Children { get; }

		/// <summary>
		/// Gets all locals defined in this scope
		/// </summary>
		public abstract IList<SymbolVariable> Locals { get; }

		/// <summary>
		/// Gets all namespaces in this scope
		/// </summary>
		public abstract IList<SymbolNamespace> Namespaces { get; }

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public abstract IList<PdbCustomDebugInfo> CustomDebugInfos { get; }

		/// <summary>
		/// Gets the import scope or null if none
		/// </summary>
		public abstract PdbImportScope ImportScope { get; }

		/// <summary>
		/// Gets all the constants
		/// </summary>
		/// <param name="module">Owner module if a signature must be read from the #Blob</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns></returns>
		public abstract IList<PdbConstant> GetConstants(ModuleDef module, GenericParamContext gpContext);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Symbols/SymbolSequencePoint.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Diagnostics;
using System.Text;

namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// Sequence point
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public struct SymbolSequencePoint {
		/// <summary>
		/// IL offset
		/// </summary>
		public int Offset;

		/// <summary>
		/// Document
		/// </summary>
		public SymbolDocument Document;

		/// <summary>
		/// Start line
		/// </summary>
		public int Line;

		/// <summary>
		/// Start column
		/// </summary>
		public int Column;

		/// <summary>
		/// End line
		/// </summary>
		public int EndLine;

		/// <summary>
		/// End column
		/// </summary>
		public int EndColumn;

		string GetDebuggerString() {
			var sb = new StringBuilder();
			if (Line == 0xFEEFEE && EndLine == 0xFEEFEE)
				sb.Append("<hidden>");
			else {
				sb.Append("(");
				sb.Append(Line);
				sb.Append(",");
				sb.Append(Column);
				sb.Append(")-(");
				sb.Append(EndLine);
				sb.Append(",");
				sb.Append(EndColumn);
				sb.Append(")");
			}
			sb.Append(": ");
			sb.Append(Document.URL);
			return sb.ToString();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/Symbols/SymbolVariable.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A variable
	/// </summary>
	public abstract class SymbolVariable {
		/// <summary>
		/// Gets the name
		/// </summary>
		public abstract string Name { get; }

		/// <summary>
		/// Gets the attributes
		/// </summary>
		public abstract PdbLocalAttributes Attributes { get; }

		/// <summary>
		/// Gets the index of the variable
		/// </summary>
		public abstract int Index { get; }

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public abstract PdbCustomDebugInfo[] CustomDebugInfos { get; }
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/WindowsPdb/CorSymVarFlag.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.DotNet.Pdb.WindowsPdb {
	[Flags]
	enum CorSymVarFlag : uint {
		VAR_IS_COMP_GEN			= 0x00000001,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/WindowsPdb/CustomDebugInfoConstants.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Pdb.WindowsPdb {
	static class CustomDebugInfoConstants {
		public const int Version = 4;
		public const int RecordVersion = 4;
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/WindowsPdb/ISymbolWriter2.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics.SymbolStore;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet.Pdb.WindowsPdb {
	/// <summary>
	/// Implements <see cref="ISymbolWriter"/> and adds a few extra methods we need that are part of
	/// <c>ISymUnmanagedWriter</c> and <c>ISymUnmanagedWriter2</c> but not present in
	/// <see cref="ISymbolWriter"/>.
	/// </summary>
	public interface ISymbolWriter2 : ISymbolWriter, IDisposable {
		/// <summary>
		/// Same as <see cref="ISymbolWriter.DefineSequencePoints"/> except that this method has an
		/// extra <paramref name="arraySize"/> that specifies the size of all the arrays.
		/// </summary>
		/// <param name="document">Document</param>
		/// <param name="arraySize">Size of the arrays</param>
		/// <param name="offsets">Offsets</param>
		/// <param name="lines">Start lines</param>
		/// <param name="columns">Start columns</param>
		/// <param name="endLines">End lines</param>
		/// <param name="endColumns">End columns</param>
		void DefineSequencePoints(ISymbolDocumentWriter document, uint arraySize, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);

		/// <summary>
		/// Gets debug info. See <c>ISymUnmanagedWriter.GetDebugInfo()</c>
		/// </summary>
		/// <param name="pIDD">Updated by writer</param>
		/// <returns>Debug data for the symbol store</returns>
		byte[] GetDebugInfo(out IMAGE_DEBUG_DIRECTORY pIDD);

		/// <summary>
		/// Define a local. See <c>ISymUnmanagedWriter2.DefineLocalVariable2()</c>
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="attributes">Attributes</param>
		/// <param name="sigToken">Signature token</param>
		/// <param name="addrKind">Address kind</param>
		/// <param name="addr1">Address #1</param>
		/// <param name="addr2">Address #2</param>
		/// <param name="addr3">Address #3</param>
		/// <param name="startOffset">Start offset</param>
		/// <param name="endOffset">End offset</param>
		void DefineLocalVariable2(string name, uint attributes, uint sigToken, uint addrKind, uint addr1, uint addr2, uint addr3, uint startOffset, uint endOffset);

		/// <summary>
		/// Initializes this instance. This must be called before any other method.
		/// </summary>
		/// <param name="metaData">Metadata</param>
		void Initialize(MetaData metaData);
	}

	/// <summary>
	/// Implements <see cref="ISymbolWriter"/> and adds a few extra methods we need that are part of
	/// <c>ISymUnmanagedWriter</c> and <c>ISymUnmanagedWriter2</c> but not present in
	/// <see cref="ISymbolWriter"/>.
	/// </summary>
	public interface ISymbolWriter3 : ISymbolWriter2 {
		/// <summary>
		/// Defines a constant
		/// </summary>
		/// <param name="name">Name of constant</param>
		/// <param name="value">Constant value</param>
		/// <param name="sigToken">StandAloneSig token of constant field type</param>
		void DefineConstant2(string name, object value, uint sigToken);

		/// <summary>
		/// true if it supports <see cref="DefineKickoffMethod(uint)"/>, <see cref="DefineCatchHandlerILOffset(uint)"/>
		/// and <see cref="DefineAsyncStepInfo(uint[], uint[], uint[])"/>
		/// </summary>
		bool SupportsAsyncMethods { get; }

		/// <summary>
		/// Defines an async kickoff method
		/// </summary>
		/// <param name="kickoffMethod">Kickoff method token</param>
		void DefineKickoffMethod(uint kickoffMethod);

		/// <summary>
		/// Defines an async catch handler
		/// </summary>
		/// <param name="catchHandlerOffset">Catch handler IL offset</param>
		void DefineCatchHandlerILOffset(uint catchHandlerOffset);

		/// <summary>
		/// Defines async step info
		/// </summary>
		/// <param name="yieldOffsets">Yield IL offsets</param>
		/// <param name="breakpointOffset">Breakpoint method IL offset</param>
		/// <param name="breakpointMethod">Breakpoint method</param>
		void DefineAsyncStepInfo(uint[] yieldOffsets, uint[] breakpointOffset, uint[] breakpointMethod);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/WindowsPdb/PdbCustomDebugInfoReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

// C# & Visual Basic compiler's Custom Debug Info is "documented" in source code only, see Roslyn classes:
//	CustomDebugInfoReader, CustomDebugInfoWriter, CustomDebugInfoEncoder

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using dnlib.DotNet.Emit;
using dnlib.IO;
using dnlib.Threading;

namespace dnlib.DotNet.Pdb.WindowsPdb {
	/// <summary>
	/// Reads custom debug infos produced by the C# and Visual Basic compilers. They're stored in PDB files
	/// as PDB method custom attributes with the name "MD2".
	/// </summary>
	struct PdbCustomDebugInfoReader : IDisposable {
		/// <summary>
		/// Reads custom debug info
		/// </summary>
		/// <param name="method">Method</param>
		/// <param name="body">The method's body. Needs to be provided by the caller since we're called from
		/// PDB-init code when the Body property hasn't been initialized yet</param>
		/// <param name="result">Place all custom debug info in this list</param>
		/// <param name="data">Custom debug info from the PDB file</param>
		public static void Read(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result, byte[] data) {
			try {
				using (var reader = new PdbCustomDebugInfoReader(method, body, MemoryImageStream.Create(data)))
					reader.Read(result);
			}
			catch (ArgumentException) {
			}
			catch (OutOfMemoryException) {
			}
			catch (IOException) {
			}
		}

		readonly ModuleDef module;
		readonly TypeDef typeOpt;
		readonly CilBody bodyOpt;
		readonly GenericParamContext gpContext;
		readonly IBinaryReader reader;

		PdbCustomDebugInfoReader(MethodDef method, CilBody body, IBinaryReader reader) {
			module = method.Module;
			typeOpt = method.DeclaringType;
			bodyOpt = body;
			gpContext = GenericParamContext.Create(method);
			this.reader = reader;
		}

		void Read(IList<PdbCustomDebugInfo> result) {
			if (reader.Length < 4)
				return;
			int version = reader.ReadByte();
			Debug.Assert(version == CustomDebugInfoConstants.Version);
			if (version != CustomDebugInfoConstants.Version)
				return;
			int count = reader.ReadByte();
			reader.Position += 2;

			while (reader.Position + 8 <= reader.Length) {
				int recVersion = reader.ReadByte();
				Debug.Assert(recVersion == CustomDebugInfoConstants.RecordVersion);
				var recKind = (PdbCustomDebugInfoKind)reader.ReadByte();
				reader.Position++;
				int alignmentSize = reader.ReadByte();
				int recSize = reader.ReadInt32();
				if (recSize < 8 || reader.Position - 8 + (uint)recSize > reader.Length)
					return;
				if (recKind <= PdbCustomDebugInfoKind.DynamicLocals)
					alignmentSize = 0;
				if (alignmentSize > 3)
					return;
				var nextRecPos = reader.Position - 8 + recSize;

				if (recVersion == CustomDebugInfoConstants.RecordVersion) {
					var recPosEnd = reader.Position - 8 + recSize - alignmentSize;
					var cdi = ReadRecord(recKind, recPosEnd);
					Debug.Assert(cdi != null);
					Debug.Assert(reader.Position <= recPosEnd);
					if (reader.Position > recPosEnd)
						return;
					if (cdi != null) {
						Debug.Assert(cdi.Kind == recKind);
						result.Add(cdi);
					}
				}

				reader.Position = nextRecPos;
			}
		}

		PdbCustomDebugInfo ReadRecord(PdbCustomDebugInfoKind recKind, long recPosEnd) {
			IMethodDefOrRef method;
			byte[] data;
			Local local;
			int count;
			int localIndex;
			switch (recKind) {
			case PdbCustomDebugInfoKind.UsingGroups:
				count = reader.ReadUInt16();
				if (count < 0)
					return null;
				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);
				for (int i = 0; i < count; i++)
					usingCountRec.UsingCounts.Add(reader.ReadUInt16());
				return usingCountRec;

			case PdbCustomDebugInfoKind.ForwardMethodInfo:
				method = module.ResolveToken(reader.ReadUInt32(), gpContext) as IMethodDefOrRef;
				if (method == null)
					return null;
				return new PdbForwardMethodInfoCustomDebugInfo(method);

			case PdbCustomDebugInfoKind.ForwardModuleInfo:
				method = module.ResolveToken(reader.ReadUInt32(), gpContext) as IMethodDefOrRef;
				if (method == null)
					return null;
				return new PdbForwardModuleInfoCustomDebugInfo(method);

			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:
				if (bodyOpt == null)
					return null;
				count = reader.ReadInt32();
				if (count < 0)
					return null;
				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);
				for (int i = 0; i < count; i++) {
					uint startOffset = reader.ReadUInt32();
					uint endOffset = reader.ReadUInt32();
					if (startOffset > endOffset)
						return null;
					// Try to detect synthesized locals, whose start==end==0. The problem is that endOffset
					// read from the PDB is inclusive (add 1 to get 'end'), so a synthesized local and a
					// local at [0, 1) will be encoded the same {0, 0}.
					if (endOffset == 0)
						smScope.Scopes.Add(new StateMachineHoistedLocalScope());
					else {
						var start = GetInstruction(startOffset);
						var end = GetInstruction(endOffset + 1);
						if (start == null)
							return null;
						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start, end));
					}
				}
				return smScope;

			case PdbCustomDebugInfoKind.StateMachineTypeName:
				var name = ReadUnicodeZ(recPosEnd, needZeroChar: true);
				if (name == null)
					return null;
				var type = GetNestedType(name);
				if (type == null)
					return null;
				return new PdbStateMachineTypeNameCustomDebugInfo(type);

			case PdbCustomDebugInfoKind.DynamicLocals:
				if (bodyOpt == null)
					return null;
				count = reader.ReadInt32();
				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;
				if (reader.Position + (long)(uint)count * dynLocalRecSize > recPosEnd)
					return null;
				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);
				for (int i = 0; i < count; i++) {
					reader.Position += 64;
					int flagsCount = reader.ReadInt32();
					if ((uint)flagsCount > 64)
						return null;
					var dynLocRec = new PdbDynamicLocal(flagsCount);
					var afterPos = reader.Position;

					reader.Position -= 64 + 4;
					for (int j = 0; j < flagsCount; j++)
						dynLocRec.Flags.Add(reader.ReadByte());
					reader.Position = afterPos;

					localIndex = reader.ReadInt32();
					// 'const' locals have index -1 but they're encoded as 0 by Roslyn
					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)
						return null;

					var nameEndPos = reader.Position + 2 * 64;
					name = ReadUnicodeZ(nameEndPos, needZeroChar: false);
					reader.Position = nameEndPos;

					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;
					// Roslyn writes 0 to localIndex if it's a 'const' local, try to undo that now
					if (localIndex == 0 && local != null && local.Name != name)
						local = null;
					if (local != null && local.Name == name)
						name = null;
					dynLocRec.Name = name;
					dynLocRec.Local = local;
					dynLocListRec.Locals.Add(dynLocRec);
				}
				return dynLocListRec;

			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:
				data = reader.ReadBytes((int)(recPosEnd - reader.Position));
				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);

			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:
				data = reader.ReadBytes((int)(recPosEnd - reader.Position));
				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);

			case PdbCustomDebugInfoKind.TupleElementNames:
				if (bodyOpt == null)
					return null;
				count = reader.ReadInt32();
				if (count < 0)
					return null;
				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);
				for (int i = 0; i < count; i++) {
					int nameCount = reader.ReadInt32();
					if ((uint)nameCount >= 10000)
						return null;
					var tupleInfo = new PdbTupleElementNames(nameCount);

					for (int j = 0; j < nameCount; j++) {
						var s = ReadUTF8Z(recPosEnd);
						if (s == null)
							return null;
						tupleInfo.TupleElementNames.Add(s);
					}

					localIndex = reader.ReadInt32();
					uint scopeStart = reader.ReadUInt32();
					uint scopeEnd = reader.ReadUInt32();
					name = ReadUTF8Z(recPosEnd);
					if (name == null)
						return null;
					Debug.Assert(localIndex >= -1);
					// -1 = 'const' local. Only 'const' locals have a scope
					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));

					if (localIndex == -1) {
						local = null;
						tupleInfo.ScopeStart = GetInstruction(scopeStart);
						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);
						if (tupleInfo.ScopeStart == null)
							return null;
					}
					else {
						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)
							return null;
						local = bodyOpt.Variables[localIndex];
					}

					if (local != null && local.Name == name)
						name = null;
					tupleInfo.Local = local;
					tupleInfo.Name = name;

					tupleListRec.Names.Add(tupleInfo);
				}
				return tupleListRec;

			default:
				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));
				data = reader.ReadBytes((int)(recPosEnd - reader.Position));
				return new PdbUnknownCustomDebugInfo(recKind, data);
			}
		}

		TypeDef GetNestedType(string name) {
			if (typeOpt == null)
				return null;
			foreach (var type in typeOpt.NestedTypes.GetSafeEnumerable()) {
				if (UTF8String.IsNullOrEmpty(type.Namespace)) {
					if (type.Name == name)
						return type;
					var typeName = type.Name.String;
					if (typeName.StartsWith(name) && typeName.Length >= name.Length + 2) {
						int i = name.Length;
						if (typeName[i] == '`') {
							Debug.Assert(i + 1 < typeName.Length);
							bool ok = true;
							i++;
							while (i < typeName.Length) {
								if (!char.IsDigit(typeName[i])) {
									ok = false;
									break;
								}
								i++;
							}
							if (ok)
								return type;
						}
					}
				}
			}
			return null;
		}

		string ReadUnicodeZ(long recPosEnd, bool needZeroChar) {
			var sb = new StringBuilder();

			for (;;) {
				if (reader.Position >= recPosEnd)
					return needZeroChar ? null : sb.ToString();
				var c = (char)reader.ReadUInt16();
				if (c == 0)
					return sb.ToString();
				sb.Append(c);
			}
		}

		string ReadUTF8Z(long recPosEnd) {
			if (reader.Position > recPosEnd)
				return null;
			var bytes = reader.ReadBytesUntilByte(0);
			if (bytes == null)
				return null;
			var s = Encoding.UTF8.GetString(bytes);
			reader.Position++;
			return s;
		}

		Instruction GetInstruction(uint offset) {
			var instructions = bodyOpt.Instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}

		public void Dispose() {
			reader.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/WindowsPdb/PdbCustomDebugInfoWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

// C# & Visual Basic compiler's Custom Debug Info is "documented" in source code only, see Roslyn classes:
//	CustomDebugInfoReader, CustomDebugInfoWriter, CustomDebugInfoEncoder

using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet.Pdb.WindowsPdb {
	sealed class PdbCustomDebugInfoWriterContext {
		public ILogger Logger;
		public readonly MemoryStream MemoryStream;
		public readonly BinaryWriter Writer;
		public readonly Dictionary<Instruction, uint> InstructionToOffsetDict;

		public PdbCustomDebugInfoWriterContext() {
			MemoryStream = new MemoryStream();
			Writer = new BinaryWriter(MemoryStream);
			InstructionToOffsetDict = new Dictionary<Instruction, uint>();
		}
	}

	/// <summary>
	/// Writes custom debug infos produced by the C# and Visual Basic compilers. They're stored in PDB files
	/// as PDB method custom attributes with the name "MD2".
	/// </summary>
	struct PdbCustomDebugInfoWriter {
		readonly MetaData metaData;
		readonly MethodDef method;
		readonly ILogger logger;
		readonly MemoryStream memoryStream;
		readonly BinaryWriter writer;
		readonly Dictionary<Instruction, uint> instructionToOffsetDict;
		uint bodySize;
		bool instructionToOffsetDictInitd;

		/// <summary>
		/// Returns the raw custom debug info or null if there was an error
		/// </summary>
		/// <param name="metaData">Metadata</param>
		/// <param name="context">Writer context</param>
		/// <param name="method">Method</param>
		/// <param name="customDebugInfos">Custom debug infos to write</param>
		/// <returns></returns>
		public static byte[] Write(MetaData metaData, MethodDef method, PdbCustomDebugInfoWriterContext context, IList<PdbCustomDebugInfo> customDebugInfos) {
			var writer = new PdbCustomDebugInfoWriter(metaData, method, context);
			return writer.Write(customDebugInfos);
		}

		PdbCustomDebugInfoWriter(MetaData metaData, MethodDef method, PdbCustomDebugInfoWriterContext context) {
			this.metaData = metaData;
			this.method = method;
			this.logger = context.Logger;
			this.memoryStream = context.MemoryStream;
			this.writer = context.Writer;
			this.instructionToOffsetDict = context.InstructionToOffsetDict;
			this.bodySize = 0;
			this.instructionToOffsetDictInitd = false;
			memoryStream.SetLength(0);
			memoryStream.Position = 0;
		}

		void InitializeInstructionDictionary() {
			Debug.Assert(!instructionToOffsetDictInitd);
			instructionToOffsetDict.Clear();
			var body = method.Body;
			if (body == null)
				return;
			var instrs = body.Instructions;
			uint offset = 0;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				instructionToOffsetDict[instr] = offset;
				offset += (uint)instr.GetSize();
			}
			bodySize = offset;
			instructionToOffsetDictInitd = true;
		}

		uint GetInstructionOffset(Instruction instr, bool nullIsEndOfMethod) {
			if (!instructionToOffsetDictInitd)
				InitializeInstructionDictionary();
			if (instr == null) {
				if (nullIsEndOfMethod)
					return bodySize;
				Error("Instruction is null");
				return uint.MaxValue;
			}
			uint offset;
			if (instructionToOffsetDict.TryGetValue(instr, out offset))
				return offset;
			Error("Instruction is missing in body but it's still being referenced by PDB data. Method {0} (0x{1:X8}), instruction: {2}", method, method.MDToken.Raw, instr);
			return uint.MaxValue;
		}

		void Error(string message, params object[] args) {
			logger.Log(this, LoggerEvent.Error, message, args);
		}

		byte[] Write(IList<PdbCustomDebugInfo> customDebugInfos) {
			if (customDebugInfos.Count == 0)
				return null;
			if (customDebugInfos.Count > byte.MaxValue) {
				Error("Too many custom debug infos. Count must be <= 255");
				return null;
			}

			writer.Write((byte)CustomDebugInfoConstants.Version);
			writer.Write((byte)customDebugInfos.Count);
			writer.Write((ushort)0);

			for (int i = 0; i < customDebugInfos.Count; i++) {
				var info = customDebugInfos[i];
				if (info == null) {
					Error("Custom debug info is null");
					return null;
				}
				if ((uint)info.Kind > byte.MaxValue) {
					Error("Invalid custom debug info kind");
					return null;
				}

				var recordPos = writer.BaseStream.Position;
				writer.Write((byte)CustomDebugInfoConstants.RecordVersion);
				writer.Write((byte)info.Kind);
				writer.Write((ushort)0);
				writer.Write((uint)0);

				int count, j, k;
				uint token;
				switch (info.Kind) {
				case PdbCustomDebugInfoKind.UsingGroups:
					var usingRec = info as PdbUsingGroupsCustomDebugInfo;
					if (usingRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					count = usingRec.UsingCounts.Count;
					if (count > ushort.MaxValue) {
						Error("UsingCounts contains more than 0xFFFF elements");
						return null;
					}
					writer.Write((ushort)count);
					for (j = 0; j < count; j++)
						writer.Write(usingRec.UsingCounts[j]);
					break;

				case PdbCustomDebugInfoKind.ForwardMethodInfo:
					var fwdMethodRec = info as PdbForwardMethodInfoCustomDebugInfo;
					if (fwdMethodRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					token = GetMethodToken(fwdMethodRec.Method);
					if (token == 0)
						return null;
					writer.Write(token);
					break;

				case PdbCustomDebugInfoKind.ForwardModuleInfo:
					var fwdModRec = info as PdbForwardModuleInfoCustomDebugInfo;
					if (fwdModRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					token = GetMethodToken(fwdModRec.Method);
					if (token == 0)
						return null;
					writer.Write(token);
					break;

				case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:
					var smLocalScopesRec = info as PdbStateMachineHoistedLocalScopesCustomDebugInfo;
					if (smLocalScopesRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					count = smLocalScopesRec.Scopes.Count;
					writer.Write(count);
					for (j = 0; j < count; j++) {
						var scope = smLocalScopesRec.Scopes[j];
						if (scope.IsSynthesizedLocal) {
							writer.Write(0);
							writer.Write(0);
						}
						else {
							writer.Write(GetInstructionOffset(scope.Start, nullIsEndOfMethod: false));
							writer.Write(GetInstructionOffset(scope.End, nullIsEndOfMethod: true) - 1);
						}
					}
					break;

				case PdbCustomDebugInfoKind.StateMachineTypeName:
					var smTypeRec = info as PdbStateMachineTypeNameCustomDebugInfo;
					if (smTypeRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					var type = smTypeRec.Type;
					if (type == null) {
						Error("State machine type is null");
						return null;
					}
					WriteUnicodeZ(MetadataNameToRoslynName(type.Name));
					break;

				case PdbCustomDebugInfoKind.DynamicLocals:
					var dynLocListRec = info as PdbDynamicLocalsCustomDebugInfo;
					if (dynLocListRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					count = dynLocListRec.Locals.Count;
					writer.Write(count);
					for (j = 0; j < count; j++) {
						var dynLoc = dynLocListRec.Locals[j];
						if (dynLoc == null) {
							Error("Dynamic local is null");
							return null;
						}
						if (dynLoc.Flags.Count > 64) {
							Error("Dynamic local flags is longer than 64 bytes");
							return null;
						}
						var name = dynLoc.Name;
						if (name == null)
							name = string.Empty;
						if (name.Length > 64) {
							Error("Dynamic local name is longer than 64 chars");
							return null;
						}
						if (name.IndexOf('\0') >= 0) {
							Error("Dynamic local name contains a NUL char");
							return null;
						}

						for (k = 0; k < dynLoc.Flags.Count; k++)
							writer.Write(dynLoc.Flags[k]);
						while (k++ < 64)
							writer.Write((byte)0);
						writer.Write(dynLoc.Flags.Count);

						if (dynLoc.Local == null)
							writer.Write(0);
						else
							writer.Write(dynLoc.Local.Index);

						for (k = 0; k < name.Length; k++)
							writer.Write((ushort)name[k]);
						while (k++ < 64)
							writer.Write((ushort)0);
					}
					break;

				case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:
					var encLocalMapRec = info as PdbEditAndContinueLocalSlotMapCustomDebugInfo;
					if (encLocalMapRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					writer.Write(encLocalMapRec.Data);
					break;

				case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:
					var encLambdaRec = info as PdbEditAndContinueLambdaMapCustomDebugInfo;
					if (encLambdaRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					writer.Write(encLambdaRec.Data);
					break;

				case PdbCustomDebugInfoKind.TupleElementNames:
					var tupleListRec = info as PdbTupleElementNamesCustomDebugInfo;
					if (tupleListRec == null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					count = tupleListRec.Names.Count;
					writer.Write(count);
					for (j = 0; j < count; j++) {
						var tupleInfo = tupleListRec.Names[j];
						if (tupleInfo == null) {
							Error("Tuple name info is null");
							return null;
						}
						writer.Write(tupleInfo.TupleElementNames.Count);
						for (k = 0; k < tupleInfo.TupleElementNames.Count; k++)
							WriteUTF8Z(tupleInfo.TupleElementNames[k]);

						if (tupleInfo.Local == null) {
							writer.Write(-1);
							writer.Write(GetInstructionOffset(tupleInfo.ScopeStart, nullIsEndOfMethod: false));
							writer.Write(GetInstructionOffset(tupleInfo.ScopeEnd, nullIsEndOfMethod: true));
						}
						else {
							writer.Write(tupleInfo.Local.Index);
							writer.Write(0L);
						}
						WriteUTF8Z(tupleInfo.Name);
					}
					break;

				default:
					var unkRec = info as PdbUnknownCustomDebugInfo;
					if (unkRec == null) {
						Error("Unsupported custom debug info class {0}", info.GetType());
						return null;
					}
					writer.Write(unkRec.Data);
					break;
				}

				var pos = writer.BaseStream.Position;
				var recLen = (pos - recordPos);
				var alignedLen = (recLen + 3) & ~3;
				if (alignedLen > uint.MaxValue) {
					Error("Custom debug info record is too big");
					return null;
				}
				writer.BaseStream.Position = recordPos + 3;
				if (info.Kind <= PdbCustomDebugInfoKind.DynamicLocals)
					writer.Write((byte)0);
				else
					writer.Write((byte)(alignedLen - recLen));
				writer.Write((uint)alignedLen);

				writer.BaseStream.Position = pos;
				while (writer.BaseStream.Position < recordPos + alignedLen)
					writer.Write((byte)0);
			}

			return memoryStream.ToArray();
		}

		string MetadataNameToRoslynName(string name) {
			if (name == null)
				return name;
			int index = name.LastIndexOf('`');
			if (index < 0)
				return name;
			return name.Substring(0, index);
		}

		void WriteUnicodeZ(string s) {
			if (s == null) {
				Error("String is null");
				return;
			}

			if (s.IndexOf('\0') >= 0) {
				Error("String contains a NUL char: {0}", s);
				return;
			}

			for (int i = 0; i < s.Length; i++)
				writer.Write((ushort)s[i]);
			writer.Write((ushort)0);
		}

		void WriteUTF8Z(string s) {
			if (s == null) {
				Error("String is null");
				return;
			}

			if (s.IndexOf('\0') >= 0) {
				Error("String contains a NUL char: {0}", s);
				return;
			}

			writer.Write(Encoding.UTF8.GetBytes(s));
			writer.Write((byte)0);
		}

		uint GetMethodToken(IMethodDefOrRef method) {
			if (method == null) {
				Error("Method is null");
				return 0;
			}

			var md = method as MethodDef;
			if (md != null) {
				uint rid = metaData.GetRid(md);
				if (rid == 0) {
					Error("Method {0} ({1:X8}) is not defined in this module ({2})", method, method.MDToken.Raw, metaData.Module);
					return 0;
				}
				return new MDToken(md.MDToken.Table, rid).Raw;
			}

			var mr = method as MemberRef;
			if (mr != null && mr.IsMethodRef)
				return metaData.GetToken(mr).Raw;

			Error("Not a method");
			return 0;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/WindowsPdb/PseudoCustomDebugInfoFactory.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.Emit;
using dnlib.DotNet.MD;
using dnlib.DotNet.Pdb.Symbols;

namespace dnlib.DotNet.Pdb.WindowsPdb {
	static class PseudoCustomDebugInfoFactory {
		public static PdbAsyncMethodCustomDebugInfo TryCreateAsyncMethod(ModuleDef module, MethodDef method, CilBody body, int asyncKickoffMethod, IList<SymbolAsyncStepInfo> asyncStepInfos, uint? asyncCatchHandlerILOffset) {
			var kickoffToken = new MDToken(asyncKickoffMethod);
			if (kickoffToken.Table != Table.Method)
				return null;
			var kickoffMethod = module.ResolveToken(kickoffToken) as MethodDef;

			var asyncMethod = new PdbAsyncMethodCustomDebugInfo(asyncStepInfos.Count);
			asyncMethod.KickoffMethod = kickoffMethod;

			if (asyncCatchHandlerILOffset != null) {
				asyncMethod.CatchHandlerInstruction = GetInstruction(body, asyncCatchHandlerILOffset.Value);
				Debug.Assert(asyncMethod.CatchHandlerInstruction != null);
			}

			foreach (var rawInfo in asyncStepInfos) {
				var yieldInstruction = GetInstruction(body, rawInfo.YieldOffset);
				Debug.Assert(yieldInstruction != null);
				if (yieldInstruction == null)
					continue;
				MethodDef breakpointMethod;
				Instruction breakpointInstruction;
				if (method.MDToken.Raw == rawInfo.BreakpointMethod) {
					breakpointMethod = method;
					breakpointInstruction = GetInstruction(body, rawInfo.BreakpointOffset);
				}
				else {
					var breakpointMethodToken = new MDToken(rawInfo.BreakpointMethod);
					Debug.Assert(breakpointMethodToken.Table == Table.Method);
					if (breakpointMethodToken.Table != Table.Method)
						continue;
					breakpointMethod = module.ResolveToken(breakpointMethodToken) as MethodDef;
					Debug.Assert(breakpointMethod != null);
					if (breakpointMethod == null)
						continue;
					breakpointInstruction = GetInstruction(breakpointMethod.Body, rawInfo.BreakpointOffset);
				}
				Debug.Assert(breakpointInstruction != null);
				if (breakpointInstruction == null)
					continue;

				asyncMethod.StepInfos.Add(new PdbAsyncStepInfo(yieldInstruction, breakpointMethod, breakpointInstruction));
			}

			return asyncMethod;
		}

		static Instruction GetInstruction(CilBody body, uint offset) {
			if (body == null)
				return null;
			var instructions = body.Instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/WindowsPdb/SymbolWriterCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.IO;

namespace dnlib.DotNet.Pdb.WindowsPdb {
	/// <summary>
	/// Creates a <see cref="ISymbolWriter2"/>
	/// </summary>
	static class SymbolWriterCreator {
		/// <summary>
		/// Creates a new <see cref="ISymbolWriter2"/> instance
		/// </summary>
		/// <param name="pdbFileName">PDB file name</param>
		/// <returns>A new <see cref="ISymbolWriter2"/> instance</returns>
		public static ISymbolWriter2 Create(string pdbFileName) {
			return Dss.SymbolWriterCreator.Create(pdbFileName);
		}

		/// <summary>
		/// Creates a new <see cref="ISymbolWriter2"/> instance
		/// </summary>
		/// <param name="pdbStream">PDB output stream</param>
		/// <param name="pdbFileName">PDB file name</param>
		/// <returns>A new <see cref="ISymbolWriter2"/> instance</returns>
		public static ISymbolWriter2 Create(Stream pdbStream, string pdbFileName) {
			return Dss.SymbolWriterCreator.Create(pdbStream, pdbFileName);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Pdb/WindowsPdb/WindowsPdbWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.SymbolStore;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;

namespace dnlib.DotNet.Pdb.WindowsPdb {
	/// <summary>
	/// PDB writer
	/// </summary>
	/// <remarks>This class is not thread safe because it's a writer class</remarks>
	public sealed class WindowsPdbWriter : IDisposable {
		ISymbolWriter2 writer;
		ISymbolWriter3 writer3;
		readonly PdbState pdbState;
		readonly ModuleDef module;
		readonly MetaData metaData;
		readonly Dictionary<PdbDocument, ISymbolDocumentWriter> pdbDocs = new Dictionary<PdbDocument, ISymbolDocumentWriter>();
		readonly SequencePointHelper seqPointsHelper = new SequencePointHelper();
		readonly Dictionary<Instruction, uint> instrToOffset;
		readonly PdbCustomDebugInfoWriterContext customDebugInfoWriterContext;
		readonly int localsEndScopeIncValue;

		/// <summary>
		/// Gets/sets the logger
		/// </summary>
		public ILogger Logger { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="writer">Symbol writer, it should implement <see cref="ISymbolWriter3"/></param>
		/// <param name="pdbState">PDB state</param>
		/// <param name="metaData">Meta data</param>
		public WindowsPdbWriter(ISymbolWriter2 writer, PdbState pdbState, MetaData metaData)
			: this(pdbState, metaData) {
			if (writer == null)
				throw new ArgumentNullException("writer");
			if (pdbState == null)
				throw new ArgumentNullException("pdbState");
			if (metaData == null)
				throw new ArgumentNullException("metaData");
			this.writer = writer;
			this.writer3 = writer as ISymbolWriter3;
			Debug.Assert(writer3 != null, "Symbol writer doesn't implement interface ISymbolWriter3");
			writer.Initialize(metaData);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="writer">Symbol writer</param>
		/// <param name="pdbState">PDB state</param>
		/// <param name="metaData">Meta data</param>
		public WindowsPdbWriter(ISymbolWriter3 writer, PdbState pdbState, MetaData metaData)
			: this(pdbState, metaData) {
			if (writer == null)
				throw new ArgumentNullException("writer");
			if (pdbState == null)
				throw new ArgumentNullException("pdbState");
			if (metaData == null)
				throw new ArgumentNullException("metaData");
			this.writer = writer;
			this.writer3 = writer;
			writer.Initialize(metaData);
		}

		WindowsPdbWriter(PdbState pdbState, MetaData metaData) {
			this.pdbState = pdbState;
			this.metaData = metaData;
			this.module = metaData.Module;
			this.instrToOffset = new Dictionary<Instruction, uint>();
			this.customDebugInfoWriterContext = new PdbCustomDebugInfoWriterContext();
			this.localsEndScopeIncValue = pdbState.Compiler == Compiler.VisualBasic ? 1 : 0;
		}

		/// <summary>
		/// Adds <paramref name="pdbDoc"/> if it doesn't exist
		/// </summary>
		/// <param name="pdbDoc">PDB document</param>
		/// <returns>A <see cref="ISymbolDocumentWriter"/> instance</returns>
		ISymbolDocumentWriter Add(PdbDocument pdbDoc) {
			ISymbolDocumentWriter docWriter;
			if (pdbDocs.TryGetValue(pdbDoc, out docWriter))
				return docWriter;
			docWriter = writer.DefineDocument(pdbDoc.Url, pdbDoc.Language, pdbDoc.LanguageVendor, pdbDoc.DocumentType);
			docWriter.SetCheckSum(pdbDoc.CheckSumAlgorithmId, pdbDoc.CheckSum);
			pdbDocs.Add(pdbDoc, docWriter);
			return docWriter;
		}

		/// <summary>
		/// Writes the PDB file
		/// </summary>
		public void Write() {
			writer.SetUserEntryPoint(new SymbolToken(GetUserEntryPointToken()));

			var cdiBuilder = new List<PdbCustomDebugInfo>();
			foreach (var type in module.GetTypes()) {
				if (type == null)
					continue;
				foreach (var method in type.Methods) {
					if (method == null)
						continue;
					if (!ShouldAddMethod(method))
						continue;
					Write(method, cdiBuilder);
				}
			}
		}

		bool ShouldAddMethod(MethodDef method) {
			var body = method.Body;
			if (body == null)
				return false;

			if (body.HasPdbMethod)
				return true;

			foreach (var local in body.Variables) {
				// Don't check whether it's the empty string. Only check for null.
				if (local.Name != null)
					return true;
				if (local.Attributes != 0)
					return true;
			}

			foreach (var instr in body.Instructions) {
				if (instr.SequencePoint != null)
					return true;
			}

			return false;
		}

		sealed class SequencePointHelper {
			readonly Dictionary<PdbDocument, bool> checkedPdbDocs = new Dictionary<PdbDocument, bool>();
			int[] instrOffsets = new int[0];
			int[] startLines;
			int[] startColumns;
			int[] endLines;
			int[] endColumns;

			public void Write(WindowsPdbWriter pdbWriter, IList<Instruction> instrs) {
				checkedPdbDocs.Clear();
				while (true) {
					PdbDocument currPdbDoc = null;
					bool otherDocsAvailable = false;
					int index = 0, instrOffset = 0;
					Instruction instr = null;
					for (int i = 0; i < instrs.Count; i++, instrOffset += instr.GetSize()) {
						instr = instrs[i];
						var seqp = instr.SequencePoint;
						if (seqp == null || seqp.Document == null)
							continue;
						if (checkedPdbDocs.ContainsKey(seqp.Document))
							continue;
						if (currPdbDoc == null)
							currPdbDoc = seqp.Document;
						else if (currPdbDoc != seqp.Document) {
							otherDocsAvailable = true;
							continue;
						}

						if (index >= instrOffsets.Length) {
							int newSize = index * 2;
							if (newSize < 64)
								newSize = 64;
							Array.Resize(ref instrOffsets, newSize);
							Array.Resize(ref startLines, newSize);
							Array.Resize(ref startColumns, newSize);
							Array.Resize(ref endLines, newSize);
							Array.Resize(ref endColumns, newSize);
						}

						instrOffsets[index]	= instrOffset;
						startLines[index]	= seqp.StartLine;
						startColumns[index]	= seqp.StartColumn;
						endLines[index]		= seqp.EndLine;
						endColumns[index]	= seqp.EndColumn;
						index++;
					}
					if (index != 0)
						pdbWriter.writer.DefineSequencePoints(pdbWriter.Add(currPdbDoc), (uint)index, instrOffsets, startLines, startColumns, endLines, endColumns);

					if (!otherDocsAvailable)
						break;
					if (currPdbDoc != null)
						checkedPdbDocs.Add(currPdbDoc, true);
				}
			}
		}

		struct CurrentMethod {
			readonly WindowsPdbWriter pdbWriter;
			public readonly MethodDef Method;
			readonly Dictionary<Instruction, uint> toOffset;
			public readonly uint BodySize;

			public CurrentMethod(WindowsPdbWriter pdbWriter, MethodDef method, Dictionary<Instruction, uint> toOffset) {
				this.pdbWriter = pdbWriter;
				Method = method;
				this.toOffset = toOffset;
				toOffset.Clear();
				uint offset = 0;
				foreach (var instr in method.Body.Instructions) {
					toOffset[instr] = offset;
					offset += (uint)instr.GetSize();
				}
				BodySize = offset;
			}

			public int GetOffset(Instruction instr) {
				if (instr == null)
					return (int)BodySize;
				uint offset;
				if (toOffset.TryGetValue(instr, out offset))
					return (int)offset;
				pdbWriter.Error("Instruction was removed from the body but is referenced from PdbScope: {0}", instr);
				return (int)BodySize;
			}
		}

		void Write(MethodDef method, List<PdbCustomDebugInfo> cdiBuilder) {
			uint rid = metaData.GetRid(method);
			if (rid == 0) {
				Error("Method {0} ({1:X8}) is not defined in this module ({2})", method, method.MDToken.Raw, module);
				return;
			}

			var info = new CurrentMethod(this, method, instrToOffset);
			var body = method.Body;
			var symbolToken = new SymbolToken((int)new MDToken(MD.Table.Method, metaData.GetRid(method)).Raw);
			writer.OpenMethod(symbolToken);
			seqPointsHelper.Write(this, info.Method.Body.Instructions);

			var pdbMethod = body.PdbMethod;
			if (pdbMethod == null)
				body.PdbMethod = pdbMethod = new PdbMethod();
			var scope = pdbMethod.Scope;
			if (scope == null)
				pdbMethod.Scope = scope = new PdbScope();
			if (scope.Namespaces.Count == 0 && scope.Variables.Count == 0 && scope.Constants.Count == 0) {
				if (scope.Scopes.Count == 0) {
					// We must open at least one sub scope (the sym writer creates the 'method' scope
					// which covers the whole method) or the native PDB reader will fail to read all
					// sequence points.
					writer.OpenScope(0);
					writer.CloseScope((int)info.BodySize);
				}
				else {
					foreach (var childScope in scope.Scopes)
						WriteScope(ref info, childScope, 0);
				}
			}
			else {
				Debug.Fail("Root scope isn't empty");
				WriteScope(ref info, scope, 0);
			}

			PdbAsyncMethodCustomDebugInfo asyncMethod;
			GetPseudoCustomDebugInfos(method.CustomDebugInfos, cdiBuilder, out asyncMethod);
			if (cdiBuilder.Count != 0) {
				customDebugInfoWriterContext.Logger = GetLogger();
				var cdiData = PdbCustomDebugInfoWriter.Write(metaData, method, customDebugInfoWriterContext, cdiBuilder);
				if (cdiData != null)
					writer.SetSymAttribute(symbolToken, "MD2", cdiData);
			}

			if (asyncMethod != null) {
				if (writer3 == null || !writer3.SupportsAsyncMethods)
					Error("PDB symbol writer doesn't support writing async methods");
				else
					WriteAsyncMethod(ref info, asyncMethod);
			}

			writer.CloseMethod();
		}

		void GetPseudoCustomDebugInfos(IList<PdbCustomDebugInfo> customDebugInfos, List<PdbCustomDebugInfo> cdiBuilder, out PdbAsyncMethodCustomDebugInfo asyncMethod) {
			cdiBuilder.Clear();
			asyncMethod = null;
			foreach (var cdi in customDebugInfos) {
				switch (cdi.Kind) {
				case PdbCustomDebugInfoKind.AsyncMethod:
					if (asyncMethod != null)
						Error("Duplicate async method custom debug info");
					else
						asyncMethod = (PdbAsyncMethodCustomDebugInfo)cdi;
					break;

				default:
					if ((uint)cdi.Kind > byte.MaxValue)
						Error("Custom debug info {0} isn't supported by Windows PDB files", cdi.Kind);
					else
						cdiBuilder.Add(cdi);
					break;
				}
			}
		}

		uint GetMethodToken(MethodDef method) {
			uint rid = metaData.GetRid(method);
			if (rid == 0)
				Error("Method {0} ({1:X8}) is not defined in this module ({2})", method, method.MDToken.Raw, module);
			return new MDToken(MD.Table.Method, rid).Raw;
		}

		void WriteAsyncMethod(ref CurrentMethod info, PdbAsyncMethodCustomDebugInfo asyncMethod) {
			if (asyncMethod.KickoffMethod == null) {
				Error("KickoffMethod is null");
				return;
			}

			uint kickoffMethod = GetMethodToken(asyncMethod.KickoffMethod);
			writer3.DefineKickoffMethod(kickoffMethod);

			if (asyncMethod.CatchHandlerInstruction != null) {
				int catchHandlerILOffset = info.GetOffset(asyncMethod.CatchHandlerInstruction);
				writer3.DefineCatchHandlerILOffset((uint)catchHandlerILOffset);
			}

			var stepInfos = asyncMethod.StepInfos;
			var yieldOffsets = new uint[stepInfos.Count];
			var breakpointOffset = new uint[stepInfos.Count];
			var breakpointMethods = new uint[stepInfos.Count];
			for (int i = 0; i < yieldOffsets.Length; i++) {
				var stepInfo = stepInfos[i];
				if (stepInfo.YieldInstruction == null) {
					Error("YieldInstruction is null");
					return;
				}
				if (stepInfo.BreakpointMethod == null) {
					Error("BreakpointInstruction is null");
					return;
				}
				if (stepInfo.BreakpointInstruction == null) {
					Error("BreakpointInstruction is null");
					return;
				}
				yieldOffsets[i] = (uint)info.GetOffset(stepInfo.YieldInstruction);
				breakpointOffset[i] = (uint)GetExternalInstructionOffset(ref info, stepInfo.BreakpointMethod, stepInfo.BreakpointInstruction);
				breakpointMethods[i] = GetMethodToken(stepInfo.BreakpointMethod);
			}
			writer3.DefineAsyncStepInfo(yieldOffsets, breakpointOffset, breakpointMethods);
		}

		int GetExternalInstructionOffset(ref CurrentMethod info, MethodDef method, Instruction instr) {
			if (info.Method == method)
				return info.GetOffset(instr);
			var body = method.Body;
			if (body == null) {
				Error("Method body is null");
				return 0;
			}

			var instrs = body.Instructions;
			int offset = 0;
			for (int i = 0; i < instrs.Count; i++) {
				var currInstr = instrs[i];
				if (currInstr == instr)
					return offset;
				offset += currInstr.GetSize();
			}
			if (instr == null)
				return offset;
			Error("Async method instruction has been removed but it's still being referenced by PDB info: BP Instruction: {0}, BP Method: {1} (0x{2:X8}), Current Method: {3} (0x{4:X8})", instr, method, method.MDToken.Raw, info.Method, info.Method.MDToken.Raw);
			return 0;
		}

		void WriteScope(ref CurrentMethod info, PdbScope scope, int recursionCounter) {
			if (recursionCounter >= 1000) {
				Error("Too many PdbScopes");
				return;
			}

			int startOffset = info.GetOffset(scope.Start);
			int endOffset = info.GetOffset(scope.End);
			writer.OpenScope(startOffset);
			AddLocals(info.Method, scope.Variables, (uint)startOffset, (uint)endOffset);
			if (scope.Constants.Count > 0) {
				if (writer3 == null)
					Error("Symbol writer doesn't implement ISymbolWriter3: no constants can be written to the PDB file");
				else {
					var constants = scope.Constants;
					var sig = new FieldSig();
					for (int i = 0; i < constants.Count; i++) {
						var constant = constants[i];
						sig.Type = constant.Type;
						var token = metaData.GetToken(sig);
						writer3.DefineConstant2(constant.Name, constant.Value ?? 0, token.Raw);
					}
				}
			}
			foreach (var ns in scope.Namespaces)
				writer.UsingNamespace(ns);
			foreach (var childScope in scope.Scopes)
				WriteScope(ref info, childScope, recursionCounter + 1);
			writer.CloseScope(startOffset == 0 && endOffset == info.BodySize ? endOffset : endOffset - localsEndScopeIncValue);
		}

		void AddLocals(MethodDef method, IList<PdbLocal> locals, uint startOffset, uint endOffset) {
			if (locals.Count == 0)
				return;
			uint token = metaData.GetLocalVarSigToken(method);
			if (token == 0) {
				Error("Method {0} ({1:X8}) has no local signature token", method, method.MDToken.Raw);
				return;
			}
			foreach (var local in locals) {
				uint attrs = GetPdbLocalFlags(local.Attributes);
				if (attrs == 0 && local.Name == null)
					continue;
				writer.DefineLocalVariable2(local.Name ?? string.Empty, attrs,
								token, 1, (uint)local.Index, 0, 0, startOffset, endOffset);
			}
		}

		static uint GetPdbLocalFlags(PdbLocalAttributes attributes) {
			if ((attributes & PdbLocalAttributes.DebuggerHidden) != 0)
				return (uint)CorSymVarFlag.VAR_IS_COMP_GEN;
			return 0;
		}

		int GetUserEntryPointToken() {
			var ep = pdbState.UserEntryPoint;
			if (ep == null)
				return 0;
			uint rid = metaData.GetRid(ep);
			if (rid == 0) {
				Error("PDB user entry point method {0} ({1:X8}) is not defined in this module ({2})", ep, ep.MDToken.Raw, module);
				return 0;
			}
			return new MDToken(MD.Table.Method, rid).ToInt32();
		}

		/// <summary>
		/// Gets the <see cref="IMAGE_DEBUG_DIRECTORY"/> and debug data that should be written to
		/// the PE file.
		/// </summary>
		/// <param name="idd">Updated with new values</param>
		/// <returns>Debug data</returns>
		public byte[] GetDebugInfo(out IMAGE_DEBUG_DIRECTORY idd) {
			return writer.GetDebugInfo(out idd);
		}

		/// <summary>
		/// Closes the PDB writer
		/// </summary>
		public void Close() {
			writer.Close();
		}

		ILogger GetLogger() {
			return Logger ?? DummyLogger.ThrowModuleWriterExceptionOnErrorInstance;
		}

		void Error(string message, params object[] args) {
			GetLogger().Log(this, LoggerEvent.Error, message, args);
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (writer != null)
				Close();
			writer = null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/BuiltInResourceData.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;
using System.Runtime.Serialization;
using dnlib.IO;

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Built-in resource data
	/// </summary>
	public sealed class BuiltInResourceData : IResourceData {
		readonly ResourceTypeCode code;
		readonly object data;

		/// <summary>
		/// Gets the data
		/// </summary>
		public object Data {
			get { return data; }
		}

		/// <inheritdoc/>
		public ResourceTypeCode Code {
			get { return code; }
		}

		/// <inheritdoc/>
		public FileOffset StartOffset { get; set; }

		/// <inheritdoc/>
		public FileOffset EndOffset { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="code">Type of data</param>
		/// <param name="data">Data</param>
		public BuiltInResourceData(ResourceTypeCode code, object data) {
			this.code = code;
			this.data = data;
		}

		/// <inheritdoc/>
		public void WriteData(BinaryWriter writer, IFormatter formatter) {
			switch (code) {
			case ResourceTypeCode.Null:
				break;

			case ResourceTypeCode.String:
				writer.Write((string)data);
				break;

			case ResourceTypeCode.Boolean:
				writer.Write((bool)data);
				break;

			case ResourceTypeCode.Char:
				writer.Write((ushort)(char)data);
				break;

			case ResourceTypeCode.Byte:
				writer.Write((byte)data);
				break;

			case ResourceTypeCode.SByte:
				writer.Write((sbyte)data);
				break;

			case ResourceTypeCode.Int16:
				writer.Write((short)data);
				break;

			case ResourceTypeCode.UInt16:
				writer.Write((ushort)data);
				break;

			case ResourceTypeCode.Int32:
				writer.Write((int)data);
				break;

			case ResourceTypeCode.UInt32:
				writer.Write((uint)data);
				break;

			case ResourceTypeCode.Int64:
				writer.Write((long)data);
				break;

			case ResourceTypeCode.UInt64:
				writer.Write((ulong)data);
				break;

			case ResourceTypeCode.Single:
				writer.Write((float)data);
				break;

			case ResourceTypeCode.Double:
				writer.Write((double)data);
				break;

			case ResourceTypeCode.Decimal:
				writer.Write((decimal)data);
				break;

			case ResourceTypeCode.DateTime:
				writer.Write(((DateTime)data).ToBinary());
				break;

			case ResourceTypeCode.TimeSpan:
				writer.Write(((TimeSpan)data).Ticks);
				break;

			case ResourceTypeCode.ByteArray:
			case ResourceTypeCode.Stream:
				var ary = (byte[])data;
				writer.Write(ary.Length);
				writer.Write(ary);
				break;

			default:
				throw new InvalidOperationException("Unknown resource type code");
			}
		}

		/// <inheritdoc/>
		public override string ToString() {
			switch (code) {
			case ResourceTypeCode.Null:
				return "null";

			case ResourceTypeCode.String:
			case ResourceTypeCode.Boolean:
			case ResourceTypeCode.Char:
			case ResourceTypeCode.Byte:
			case ResourceTypeCode.SByte:
			case ResourceTypeCode.Int16:
			case ResourceTypeCode.UInt16:
			case ResourceTypeCode.Int32:
			case ResourceTypeCode.UInt32:
			case ResourceTypeCode.Int64:
			case ResourceTypeCode.UInt64:
			case ResourceTypeCode.Single:
			case ResourceTypeCode.Double:
			case ResourceTypeCode.Decimal:
			case ResourceTypeCode.DateTime:
			case ResourceTypeCode.TimeSpan:
				return string.Format("{0}: '{1}'", code, data);

			case ResourceTypeCode.ByteArray:
			case ResourceTypeCode.Stream:
				var ary = data as byte[];
				if (ary != null)
					return string.Format("{0}: Length: {1}", code, ary.Length);
				return string.Format("{0}: '{1}'", code, data);

			default:
				return string.Format("{0}: '{1}'", code, data);
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/IResourceData.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.IO;
using System.Runtime.Serialization;
using dnlib.IO;

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Implemented by all resource data
	/// </summary>
	public interface IResourceData : IFileSection {
		/// <summary>
		/// Gets the type of data
		/// </summary>
		ResourceTypeCode Code { get; }

		/// <summary>
		/// Start offset of the section in the file
		/// </summary>
		new FileOffset StartOffset { get; set; }

		/// <summary>
		/// End offset of the section in the file. This is one byte after the last
		/// valid offset in the section.
		/// </summary>
		new FileOffset EndOffset { get; set; }

		/// <summary>
		/// Writes the data
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="formatter">Formatter if needed by implementer</param>
		void WriteData(BinaryWriter writer, IFormatter formatter);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/ResourceDataCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Creates resource data
	/// </summary>
	public class ResourceDataCreator {
		readonly ModuleDef module;
		readonly ModuleDefMD moduleMD;
		readonly Dictionary<string, UserResourceType> dict = new Dictionary<string, UserResourceType>(StringComparer.Ordinal);
		readonly Dictionary<string, string> asmNameToAsmFullName = new Dictionary<string, string>(StringComparer.Ordinal);

		/// <summary>
		/// Gets the owner module
		/// </summary>
		protected ModuleDef Module {
			get { return module; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		public ResourceDataCreator(ModuleDef module) {
			this.module = module;
			this.moduleMD = module as ModuleDefMD;
		}

		/// <summary>
		/// Gets number of user data types
		/// </summary>
		public int Count {
			get { return dict.Count; }
		}

		/// <summary>
		/// Create null data
		/// </summary>
		/// <returns></returns>
		public BuiltInResourceData CreateNull() {
			return new BuiltInResourceData(ResourceTypeCode.Null, null);
		}

		/// <summary>
		/// Creates <see cref="string"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(string value) {
			return new BuiltInResourceData(ResourceTypeCode.String, value);
		}

		/// <summary>
		/// Creates <see cref="bool"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(bool value) {
			return new BuiltInResourceData(ResourceTypeCode.Boolean, value);
		}

		/// <summary>
		/// Creates <see cref="char"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(char value) {
			return new BuiltInResourceData(ResourceTypeCode.Char, value);
		}

		/// <summary>
		/// Creates <see cref="byte"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(byte value) {
			return new BuiltInResourceData(ResourceTypeCode.Byte, value);
		}

		/// <summary>
		/// Creates <see cref="sbyte"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(sbyte value) {
			return new BuiltInResourceData(ResourceTypeCode.SByte, value);
		}

		/// <summary>
		/// Creates <see cref="short"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(short value) {
			return new BuiltInResourceData(ResourceTypeCode.Int16, value);
		}

		/// <summary>
		/// Creates <see cref="ushort"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(ushort value) {
			return new BuiltInResourceData(ResourceTypeCode.UInt16, value);
		}

		/// <summary>
		/// Creates <see cref="int"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(int value) {
			return new BuiltInResourceData(ResourceTypeCode.Int32, value);
		}

		/// <summary>
		/// Creates <see cref="uint"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(uint value) {
			return new BuiltInResourceData(ResourceTypeCode.UInt32, value);
		}

		/// <summary>
		/// Creates <see cref="long"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(long value) {
			return new BuiltInResourceData(ResourceTypeCode.Int64, value);
		}

		/// <summary>
		/// Creates <see cref="ulong"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(ulong value) {
			return new BuiltInResourceData(ResourceTypeCode.UInt64, value);
		}

		/// <summary>
		/// Creates <see cref="float"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(float value) {
			return new BuiltInResourceData(ResourceTypeCode.Single, value);
		}

		/// <summary>
		/// Creates <see cref="double"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(double value) {
			return new BuiltInResourceData(ResourceTypeCode.Double, value);
		}

		/// <summary>
		/// Creates <see cref="decimal"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(decimal value) {
			return new BuiltInResourceData(ResourceTypeCode.Decimal, value);
		}

		/// <summary>
		/// Creates <see cref="DateTime"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(DateTime value) {
			return new BuiltInResourceData(ResourceTypeCode.DateTime, value);
		}

		/// <summary>
		/// Creates <see cref="TimeSpan"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(TimeSpan value) {
			return new BuiltInResourceData(ResourceTypeCode.TimeSpan, value);
		}

		/// <summary>
		/// Creates <see cref="byte"/> array data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(byte[] value) {
			return new BuiltInResourceData(ResourceTypeCode.ByteArray, value);
		}

		/// <summary>
		/// Creates <see cref="Stream"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData CreateStream(byte[] value) {
			return new BuiltInResourceData(ResourceTypeCode.Stream, value);
		}

		/// <summary>
		/// Creates serialized data
		/// </summary>
		/// <param name="value">Serialized data</param>
		/// <param name="type">Type of serialized data</param>
		/// <returns></returns>
		public BinaryResourceData CreateSerialized(byte[] value, UserResourceType type) {
			return new BinaryResourceData(CreateUserResourceType(type.Name, true), value);
		}

		/// <summary>
		/// Creates serialized data
		/// </summary>
		/// <param name="value">Serialized data</param>
		/// <returns></returns>
		public BinaryResourceData CreateSerialized(byte[] value) {
			string assemblyName, typeName;
			if (!GetSerializedTypeAndAssemblyName(value, out assemblyName, out typeName))
				throw new ApplicationException("Could not get serialized type name");
			string fullName = string.Format("{0}, {1}", typeName, assemblyName);
			return new BinaryResourceData(CreateUserResourceType(fullName), value);
		}

		sealed class MyBinder : SerializationBinder {
			public class OkException : Exception {
				public string AssemblyName { get; set; }
				public string TypeName { get; set; }
			}

			public override Type BindToType(string assemblyName, string typeName) {
				throw new OkException {
					AssemblyName = assemblyName,
					TypeName = typeName,
				};
			}
		}

		bool GetSerializedTypeAndAssemblyName(byte[] value, out string assemblyName, out string typeName) {
			try {
				var formatter = new BinaryFormatter();
				formatter.Binder = new MyBinder();
				formatter.Deserialize(new MemoryStream(value));
			}
			catch (MyBinder.OkException ex) {
				assemblyName = ex.AssemblyName;
				typeName = ex.TypeName;
				return true;
			}
			catch {
			}

			assemblyName = null;
			typeName = null;
			return false;
		}

		/// <summary>
		/// Creates a user type. If the type already exists, the existing value is returned.
		/// </summary>
		/// <param name="fullName">Full name of type</param>
		/// <returns></returns>
		public UserResourceType CreateUserResourceType(string fullName) {
			return CreateUserResourceType(fullName, false);
		}

		/// <summary>
		/// Creates a user type. If the type already exists, the existing value is returned.
		/// </summary>
		/// <param name="fullName">Full name of type</param>
		/// <param name="useFullName">Use <paramref name="fullName"/> without converting it to a
		/// type in an existing assembly reference</param>
		/// <returns></returns>
		UserResourceType CreateUserResourceType(string fullName, bool useFullName) {
			UserResourceType type;
			if (dict.TryGetValue(fullName, out type))
				return type;

			var newFullName = useFullName ? fullName : GetRealTypeFullName(fullName);
			type = new UserResourceType(newFullName, ResourceTypeCode.UserTypes + dict.Count);
			dict[fullName] = type;
			dict[newFullName] = type;
			return type;
		}

		string GetRealTypeFullName(string fullName) {
			var tr = TypeNameParser.ParseReflection(module, fullName, null);
			if (tr == null)
				return fullName;
			var asmRef = tr.DefinitionAssembly;
			if (asmRef == null)
				return fullName;

			var newFullName = fullName;

			string assemblyName = GetRealAssemblyName(asmRef);
			if (!string.IsNullOrEmpty(assemblyName))
				newFullName = string.Format("{0}, {1}", tr.ReflectionFullName, assemblyName);

			return newFullName;
		}

		string GetRealAssemblyName(IAssembly asm) {
			string assemblyName = asm.FullName;
			string newAsmName;
			if (!asmNameToAsmFullName.TryGetValue(assemblyName, out newAsmName))
				asmNameToAsmFullName[assemblyName] = newAsmName = TryGetRealAssemblyName(asm);
			return newAsmName;
		}

		string TryGetRealAssemblyName(IAssembly asm) {
			var simpleName = asm.Name;
			if (simpleName == module.CorLibTypes.AssemblyRef.Name)
				return module.CorLibTypes.AssemblyRef.FullName;

			if (moduleMD != null) {
				var asmRef = moduleMD.GetAssemblyRef(simpleName);
				if (asmRef != null)
					return asmRef.FullName;
			}

			return GetAssemblyFullName(simpleName);
		}

		/// <summary>
		/// Converts an assembly simple name (eg. mscorlib) to the full name of the assembly,
		/// which includes the version, public key token, etc. Returns <c>null</c> if it's
		/// unknown.
		/// </summary>
		/// <param name="simpleName">Simple name of assembly</param>
		/// <returns></returns>
		protected virtual string GetAssemblyFullName(string simpleName) {
			return null;
		}

		/// <summary>
		/// Gets all types sorted by <see cref="UserResourceType"/>
		/// </summary>
		/// <returns></returns>
		public List<UserResourceType> GetSortedTypes() {
			var list = new List<UserResourceType>(dict.Values);
			list.Sort((a, b) => ((int)a.Code).CompareTo((int)b.Code));
			return list;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/ResourceElement.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Resource element
	/// </summary>
	public sealed class ResourceElement {
		/// <summary>
		/// Name of resource
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// Data of resource
		/// </summary>
		public IResourceData ResourceData { get; set; }

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("N: {0}, V: {1}", Name, ResourceData);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/ResourceElementSet.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Resource element set
	/// </summary>
	public sealed class ResourceElementSet {
		readonly Dictionary<string, ResourceElement> dict = new Dictionary<string, ResourceElement>(StringComparer.Ordinal);

		/// <summary>
		/// Gets the number of elements in the set
		/// </summary>
		public int Count {
			get { return dict.Count; }
		}

		/// <summary>
		/// Gets all resource elements
		/// </summary>
		public IEnumerable<ResourceElement> ResourceElements {
			get { return dict.Values; }
		}

		/// <summary>
		/// Adds a new resource to the set, overwriting any existing resource
		/// </summary>
		/// <param name="elem"></param>
		public void Add(ResourceElement elem) {
			dict[elem.Name] = elem;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/ResourceReader.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using dnlib.IO;

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Thrown by <see cref="ResourceReader"/>
	/// </summary>
	[Serializable]
	public sealed class ResourceReaderException : Exception {
		/// <summary>
		/// Constructor
		/// </summary>
		public ResourceReaderException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">Message</param>
		public ResourceReaderException(string msg)
			: base(msg) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		public ResourceReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Gets called to create a <see cref="IResourceData"/> from serialized data. Returns <c>null</c>
	/// if a default <see cref="IResourceData"/> instance should be created.
	/// </summary>
	/// <param name="resourceDataCreator">ResourceDataCreator</param>
	/// <param name="type">Serialized type</param>
	/// <param name="serializedData">Serialized data</param>
	/// <returns></returns>
	public delegate IResourceData CreateResourceDataDelegate(ResourceDataCreator resourceDataCreator, UserResourceType type, byte[] serializedData);

	/// <summary>
	/// Reads .NET resources
	/// </summary>
	public struct ResourceReader {
		readonly IBinaryReader reader;
		readonly long baseFileOffset;
		readonly ResourceDataCreator resourceDataCreator;
		readonly CreateResourceDataDelegate createResourceDataDelegate;

		ResourceReader(ModuleDef module, IBinaryReader reader, CreateResourceDataDelegate createResourceDataDelegate) {
			this.reader = reader;
			this.resourceDataCreator = new ResourceDataCreator(module);
			this.createResourceDataDelegate = createResourceDataDelegate;

			var stream = reader as IImageStream;
			this.baseFileOffset = stream == null ? 0 : (long)stream.FileOffset;
		}

		/// <summary>
		/// Returns true if it's possibly resources file data
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <returns></returns>
		public static bool CouldBeResourcesFile(IBinaryReader reader) {
			return reader.CanRead(4) && reader.ReadUInt32() == 0xBEEFCACE;
		}

		/// <summary>
		/// Reads a .NET resource
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">Data of resource</param>
		/// <returns></returns>
		public static ResourceElementSet Read(ModuleDef module, IBinaryReader reader) {
			return Read(module, reader, null);
		}

		/// <summary>
		/// Reads a .NET resource
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">Data of resource</param>
		/// <param name="createResourceDataDelegate">Call back that gets called to create a <see cref="IResourceData"/> instance. Can be null.</param>
		/// <returns></returns>
		public static ResourceElementSet Read(ModuleDef module, IBinaryReader reader, CreateResourceDataDelegate createResourceDataDelegate) {
			return new ResourceReader(module, reader, createResourceDataDelegate).Read();
		}

		ResourceElementSet Read() {
			ResourceElementSet resources = new ResourceElementSet();

			uint sig = reader.ReadUInt32();
			if (sig != 0xBEEFCACE)
				throw new ResourceReaderException(string.Format("Invalid resource sig: {0:X8}", sig));
			if (!CheckReaders())
				throw new ResourceReaderException("Invalid resource reader");
			int version = reader.ReadInt32();
			if (version != 2)//TODO: Support version 1
				throw new ResourceReaderException(string.Format("Invalid resource version: {0}", version));
			int numResources = reader.ReadInt32();
			if (numResources < 0)
				throw new ResourceReaderException(string.Format("Invalid number of resources: {0}", numResources));
			int numUserTypes = reader.ReadInt32();
			if (numUserTypes < 0)
				throw new ResourceReaderException(string.Format("Invalid number of user types: {0}", numUserTypes));

			var userTypes = new List<UserResourceType>();
			for (int i = 0; i < numUserTypes; i++)
				userTypes.Add(new UserResourceType(reader.ReadString(), ResourceTypeCode.UserTypes + i));
			reader.Position = (reader.Position + 7) & ~7;

			var hashes = new int[numResources];
			for (int i = 0; i < numResources; i++)
				hashes[i] = reader.ReadInt32();
			var offsets = new int[numResources];
			for (int i = 0; i < numResources; i++)
				offsets[i] = reader.ReadInt32();

			long baseOffset = reader.Position;
			long dataBaseOffset = reader.ReadInt32();
			long nameBaseOffset = reader.Position;
			long end = reader.Length;

			var infos = new List<ResourceInfo>(numResources);

			for (int i = 0; i < numResources; i++) {
				reader.Position = nameBaseOffset + offsets[i];
				var name = reader.ReadString(Encoding.Unicode);
				long offset = dataBaseOffset + reader.ReadInt32();
				infos.Add(new ResourceInfo(name, offset));
			}

			infos.Sort((a, b) => a.offset.CompareTo(b.offset));
			for (int i = 0; i < infos.Count; i++) {
				var info = infos[i];
				var element = new ResourceElement();
				element.Name = info.name;
				reader.Position = info.offset;
				long nextDataOffset = i == infos.Count - 1 ? end : infos[i + 1].offset;
				int size = (int)(nextDataOffset - info.offset);
				element.ResourceData = ReadResourceData(userTypes, size);
				element.ResourceData.StartOffset = this.baseFileOffset + (FileOffset)info.offset;
				element.ResourceData.EndOffset = this.baseFileOffset + (FileOffset)reader.Position;

				resources.Add(element);
			}

			return resources;
		}

		sealed class ResourceInfo {
			public string name;
			public long offset;
			public ResourceInfo(string name, long offset) {
				this.name = name;
				this.offset = offset;
			}
			public override string ToString() {
				return string.Format("{0:X8} - {1}", offset, name);
			}
		}

		IResourceData ReadResourceData(List<UserResourceType> userTypes, int size) {
			uint code = ReadUInt32(reader);
			switch ((ResourceTypeCode)code) {
			case ResourceTypeCode.Null:		return resourceDataCreator.CreateNull();
			case ResourceTypeCode.String:	return resourceDataCreator.Create(reader.ReadString());
			case ResourceTypeCode.Boolean:	return resourceDataCreator.Create(reader.ReadBoolean());
			case ResourceTypeCode.Char:		return resourceDataCreator.Create((char)reader.ReadUInt16());
			case ResourceTypeCode.Byte:		return resourceDataCreator.Create(reader.ReadByte());
			case ResourceTypeCode.SByte:	return resourceDataCreator.Create(reader.ReadSByte());
			case ResourceTypeCode.Int16:	return resourceDataCreator.Create(reader.ReadInt16());
			case ResourceTypeCode.UInt16:	return resourceDataCreator.Create(reader.ReadUInt16());
			case ResourceTypeCode.Int32:	return resourceDataCreator.Create(reader.ReadInt32());
			case ResourceTypeCode.UInt32:	return resourceDataCreator.Create(reader.ReadUInt32());
			case ResourceTypeCode.Int64:	return resourceDataCreator.Create(reader.ReadInt64());
			case ResourceTypeCode.UInt64:	return resourceDataCreator.Create(reader.ReadUInt64());
			case ResourceTypeCode.Single:	return resourceDataCreator.Create(reader.ReadSingle());
			case ResourceTypeCode.Double:	return resourceDataCreator.Create(reader.ReadDouble());
			case ResourceTypeCode.Decimal:	return resourceDataCreator.Create(reader.ReadDecimal());
			case ResourceTypeCode.DateTime: return resourceDataCreator.Create(DateTime.FromBinary(reader.ReadInt64()));
			case ResourceTypeCode.TimeSpan:	return resourceDataCreator.Create(new TimeSpan(reader.ReadInt64()));
			case ResourceTypeCode.ByteArray:return resourceDataCreator.Create(reader.ReadBytes(reader.ReadInt32()));
			case ResourceTypeCode.Stream:	return resourceDataCreator.CreateStream(reader.ReadBytes(reader.ReadInt32()));
			default:
				int userTypeIndex = (int)(code - (uint)ResourceTypeCode.UserTypes);
				if (userTypeIndex < 0 || userTypeIndex >= userTypes.Count)
					throw new ResourceReaderException(string.Format("Invalid resource data code: {0}", code));
				var userType = userTypes[userTypeIndex];
				var serializedData = reader.ReadBytes(size);
				if (createResourceDataDelegate != null) {
					var res = createResourceDataDelegate(resourceDataCreator, userType, serializedData);
					if (res != null)
						return res;
				}
				return resourceDataCreator.CreateSerialized(serializedData, userType);
			}
		}

		static uint ReadUInt32(IBinaryReader reader) {
			try {
				return reader.Read7BitEncodedUInt32();
			}
			catch {
				throw new ResourceReaderException("Invalid encoded int32");
			}
		}

		bool CheckReaders() {
			bool validReader = false;

			int numReaders = reader.ReadInt32();
			if (numReaders < 0)
				throw new ResourceReaderException(string.Format("Invalid number of readers: {0}", numReaders));
			int readersSize = reader.ReadInt32();
			if (readersSize < 0)
				throw new ResourceReaderException(string.Format("Invalid readers size: {0:X8}", readersSize));

			for (int i = 0; i < numReaders; i++) {
				var resourceReaderFullName = reader.ReadString();
				/*var resourceSetFullName = */reader.ReadString();
				if (Regex.IsMatch(resourceReaderFullName, @"^System\.Resources\.ResourceReader,\s*mscorlib,"))
					validReader = true;
			}

			return validReader;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/ResourceTypeCode.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Type of resource
	/// </summary>
	public enum ResourceTypeCode {
		/// <summary>
		/// null
		/// </summary>
		Null		= 0,

		/// <summary>
		/// <see cref="string"/>
		/// </summary>
		String		= 1,

		/// <summary>
		/// <see cref="bool"/>
		/// </summary>
		Boolean		= 2,

		/// <summary>
		/// <see cref="char"/>
		/// </summary>
		Char		= 3,

		/// <summary>
		/// <see cref="byte"/>
		/// </summary>
		Byte		= 4,

		/// <summary>
		/// <see cref="sbyte"/>
		/// </summary>
		SByte		= 5,

		/// <summary>
		/// <see cref="short"/>
		/// </summary>
		Int16		= 6,

		/// <summary>
		/// <see cref="ushort"/>
		/// </summary>
		UInt16		= 7,

		/// <summary>
		/// <see cref="int"/>
		/// </summary>
		Int32		= 8,

		/// <summary>
		/// <see cref="uint"/>
		/// </summary>
		UInt32		= 9,

		/// <summary>
		/// <see cref="long"/>
		/// </summary>
		Int64		= 0x0A,

		/// <summary>
		/// <see cref="ulong"/>
		/// </summary>
		UInt64		= 0x0B,

		/// <summary>
		/// <see cref="float"/>
		/// </summary>
		Single		= 0x0C,

		/// <summary>
		/// <see cref="double"/>
		/// </summary>
		Double		= 0x0D,

		/// <summary>
		/// <see cref="decimal"/>
		/// </summary>
		Decimal		= 0x0E,

		/// <summary>
		/// <see cref="DateTime"/>
		/// </summary>
		DateTime	= 0x0F,

		/// <summary>
		/// <see cref="TimeSpan"/>
		/// </summary>
		TimeSpan	= 0x10,

		/// <summary>
		/// <see cref="byte"/> array
		/// </summary>
		ByteArray	= 0x20,

		/// <summary>
		/// <see cref="Stream"/>
		/// </summary>
		Stream		= 0x21,

		/// <summary>
		/// Start of user types
		/// </summary>
		UserTypes	= 0x40,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/ResourceWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Writes .NET resources
	/// </summary>
	public sealed class ResourceWriter {
		ModuleDef module;
		BinaryWriter writer;
		ResourceElementSet resources;
		ResourceDataCreator typeCreator;
		Dictionary<UserResourceData, UserResourceType> dataToNewType = new Dictionary<UserResourceData, UserResourceType>();

		ResourceWriter(ModuleDef module, Stream stream, ResourceElementSet resources) {
			this.module = module;
			this.typeCreator = new ResourceDataCreator(module);
			this.writer = new BinaryWriter(stream);
			this.resources = resources;
		}

		/// <summary>
		/// Write .NET resources
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="stream">Output stream</param>
		/// <param name="resources">.NET resources</param>
		public static void Write(ModuleDef module, Stream stream, ResourceElementSet resources) {
			new ResourceWriter(module, stream, resources).Write();
		}

		void Write() {
			InitializeUserTypes();

			writer.Write(0xBEEFCACE);
			writer.Write(1);
			WriteReaderType();
			writer.Write(2);//TODO: Support version 1
			writer.Write(resources.Count);
			writer.Write(typeCreator.Count);
			foreach (var userType in typeCreator.GetSortedTypes())
				writer.Write(userType.Name);
			int extraBytes = 8 - ((int)writer.BaseStream.Position & 7);
			if (extraBytes != 8) {
				for (int i = 0; i < extraBytes; i++)
					writer.Write((byte)'X');
			}

			var nameOffsetStream = new MemoryStream();
			var nameOffsetWriter = new BinaryWriter(nameOffsetStream, Encoding.Unicode);
			var dataStream = new MemoryStream();
			var dataWriter = new BinaryWriter(dataStream);
			var hashes = new int[resources.Count];
			var offsets = new int[resources.Count];
			var formatter = new BinaryFormatter(null, new StreamingContext(StreamingContextStates.File | StreamingContextStates.Persistence));
			int index = 0;
			foreach (var info in resources.ResourceElements) {
				offsets[index] = (int)nameOffsetWriter.BaseStream.Position;
				hashes[index] = (int)Hash(info.Name);
				index++;
				nameOffsetWriter.Write(info.Name);
				nameOffsetWriter.Write((int)dataWriter.BaseStream.Position);
				WriteData(dataWriter, info, formatter);
			}

			Array.Sort(hashes, offsets);
			foreach (var hash in hashes)
				writer.Write(hash);
			foreach (var offset in offsets)
				writer.Write(offset);
			writer.Write((int)writer.BaseStream.Position + (int)nameOffsetStream.Length + 4);
			writer.Write(nameOffsetStream.ToArray());
			writer.Write(dataStream.ToArray());
		}

		void WriteData(BinaryWriter writer, ResourceElement info, IFormatter formatter) {
			var code = GetResourceType(info.ResourceData);
			WriteUInt32(writer, (uint)code);
			info.ResourceData.WriteData(writer, formatter);
		}

		static void WriteUInt32(BinaryWriter writer, uint value) {
			while (value >= 0x80) {
				writer.Write((byte)(value | 0x80));
				value >>= 7;
			}
			writer.Write((byte)value);
		}

		ResourceTypeCode GetResourceType(IResourceData data) {
			if (data is BuiltInResourceData)
				return data.Code;

			var userData = (UserResourceData)data;
			return dataToNewType[userData].Code;
		}

		static uint Hash(string key) {
			uint val = 0x1505;
			foreach (var c in key)
				val = ((val << 5) + val) ^ (uint)c;
			return val;
		}

		void InitializeUserTypes() {
			foreach (var resource in resources.ResourceElements) {
				var data = resource.ResourceData as UserResourceData;
				if (data == null)
					continue;
				var newType = typeCreator.CreateUserResourceType(data.TypeName);
				dataToNewType[data] = newType;
			}
		}

		void WriteReaderType() {
			var memStream = new MemoryStream();
			var headerWriter = new BinaryWriter(memStream);
			var mscorlibFullName = GetMscorlibFullname();
			headerWriter.Write("System.Resources.ResourceReader, " + mscorlibFullName);
			headerWriter.Write("System.Resources.RuntimeResourceSet");
			writer.Write((int)memStream.Position);
			writer.Write(memStream.ToArray());
		}

		string GetMscorlibFullname() {
			if (module.CorLibTypes.AssemblyRef.Name == "mscorlib")
				return module.CorLibTypes.AssemblyRef.FullName;
			return "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/UserResourceData.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.IO;
using System.Runtime.Serialization;
using dnlib.IO;

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Base class of all user data
	/// </summary>
	public abstract class UserResourceData : IResourceData {
		readonly UserResourceType type;

		/// <summary>
		/// Full name including assembly of type
		/// </summary>
		public string TypeName {
			get { return type.Name; }
		}

		/// <summary>
		/// User type code
		/// </summary>
		public ResourceTypeCode Code {
			get { return type.Code; }
		}

		/// <inheritdoc/>
		public FileOffset StartOffset { get; set; }

		/// <inheritdoc/>
		public FileOffset EndOffset { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">User resource type</param>
		public UserResourceData(UserResourceType type) {
			this.type = type;
		}

		/// <inheritdoc/>
		public abstract void WriteData(BinaryWriter writer, IFormatter formatter);
	}

	/// <summary>
	/// Binary data
	/// </summary>
	public sealed class BinaryResourceData : UserResourceData {
		byte[] data;

		/// <summary>
		/// Gets the raw data
		/// </summary>
		public byte[] Data {
			get { return data; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">User resource type</param>
		/// <param name="data">Raw serialized data</param>
		public BinaryResourceData(UserResourceType type, byte[] data)
			: base(type) {
			this.data = data;
		}

		/// <inheritdoc/>
		public override void WriteData(BinaryWriter writer, IFormatter formatter) {
			writer.Write(data);
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("Binary: Length: {0}", data.Length);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Resources/UserResourceType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Resources {
	/// <summary>
	/// User resource type
	/// </summary>
	public sealed class UserResourceType {
		readonly string name;
		readonly ResourceTypeCode code;

		/// <summary>
		/// Full name including assembly of type
		/// </summary>
		public string Name {
			get { return name; }
		}

		/// <summary>
		/// User type code
		/// </summary>
		public ResourceTypeCode Code {
			get { return code; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Full name including assembly of type</param>
		/// <param name="code">User type code</param>
		public UserResourceType(string name, ResourceTypeCode code) {
			this.name = name;
			this.code = code;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return string.Format("{0:X2} {1}", (int)code, name);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/BinaryReaderChunk.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// A <see cref="IBinaryReader"/> chunk
	/// </summary>
	public class BinaryReaderChunk : IChunk {
		FileOffset offset;
		RVA rva;
		readonly IBinaryReader data;
		readonly uint virtualSize;

		/// <summary>
		/// Gets the data
		/// </summary>
		public IBinaryReader Data {
			get { return data; }
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The data</param>
		public BinaryReaderChunk(IBinaryReader data)
			: this(data, (uint)data.Length) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The data</param>
		/// <param name="virtualSize">Virtual size of <paramref name="data"/></param>
		public BinaryReaderChunk(IBinaryReader data, uint virtualSize) {
			this.data = data;
			this.virtualSize = virtualSize;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return (uint)data.Length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return virtualSize;
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			data.Position = 0;
			data.WriteTo(writer);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/BlobHeap.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #Blob heap
	/// </summary>
	public sealed class BlobHeap : HeapBase, IOffsetHeap<byte[]> {
		readonly Dictionary<byte[], uint> cachedDict = new Dictionary<byte[], uint>(ByteArrayEqualityComparer.Instance);
		readonly List<byte[]> cached = new List<byte[]>();
		uint nextOffset = 1;
		byte[] originalData;
		Dictionary<uint, byte[]> userRawData;

		/// <inheritdoc/>
		public override string Name {
			get { return "#Blob"; }
		}

		/// <summary>
		/// Populates blobs from an existing <see cref="BlobStream"/> (eg. to preserve
		/// blob offsets)
		/// </summary>
		/// <param name="blobStream">The #Blob stream with the original content</param>
		public void Populate(BlobStream blobStream) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Blob when it's read-only");
			if (originalData != null)
				throw new InvalidOperationException("Can't call method twice");
			if (nextOffset != 1)
				throw new InvalidOperationException("Add() has already been called");
			if (blobStream == null || blobStream.ImageStreamLength == 0)
				return;

			using (var reader = blobStream.GetClonedImageStream()) {
				originalData = reader.ReadAllBytes();
				nextOffset = (uint)originalData.Length;
				Populate(reader);
			}
		}

		void Populate(IImageStream reader) {
			reader.Position = 1;
			while (reader.Position < reader.Length) {
				uint offset = (uint)reader.Position;
				uint len;
				if (!reader.ReadCompressedUInt32(out len)) {
					if (offset == reader.Position)
						reader.Position++;
					continue;
				}
				if (len == 0 || reader.Position + len > reader.Length)
					continue;

				var data = reader.ReadBytes((int)len);
				if (!cachedDict.ContainsKey(data))
					cachedDict[data] = offset;
			}
		}

		/// <summary>
		/// Adds data to the #Blob heap
		/// </summary>
		/// <param name="data">The data</param>
		/// <returns>The offset of the data in the #Blob heap</returns>
		public uint Add(byte[] data) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Blob when it's read-only");
			if (data == null || data.Length == 0)
				return 0;

			uint offset;
			if (cachedDict.TryGetValue(data, out offset))
				return offset;
			return AddToCache(data);
		}

		/// <summary>
		/// Adds data to the #Blob heap, but does not re-use an existing position
		/// </summary>
		/// <param name="data">The data</param>
		/// <returns>The offset of the data in the #Blob heap</returns>
		public uint Create(byte[] data) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Blob when it's read-only");
			return AddToCache(data ?? new byte[0]);
		}

		uint AddToCache(byte[] data) {
			uint offset;
			cached.Add(data);
			cachedDict[data] = offset = nextOffset;
			nextOffset += (uint)GetRawDataSize(data);
			return offset;
		}

		/// <inheritdoc/>
		public override uint GetRawLength() {
			return nextOffset;
		}

		/// <inheritdoc/>
		protected override void WriteToImpl(BinaryWriter writer) {
			if (originalData != null)
				writer.Write(originalData);
			else
				writer.Write((byte)0);

			uint offset = originalData != null ? (uint)originalData.Length : 1;
			foreach (var data in cached) {
				int rawLen = GetRawDataSize(data);
				byte[] rawData;
				if (userRawData != null && userRawData.TryGetValue(offset, out rawData)) {
					if (rawData.Length != rawLen)
						throw new InvalidOperationException("Invalid length of raw data");
					writer.Write(rawData);
				}
				else {
					writer.WriteCompressedUInt32((uint)data.Length);
					writer.Write(data);
				}
				offset += (uint)rawLen;
			}
		}

		/// <inheritdoc/>
		public int GetRawDataSize(byte[] data) {
			return Utils.GetCompressedUInt32Length((uint)data.Length) + data.Length;
		}

		/// <inheritdoc/>
		public void SetRawData(uint offset, byte[] rawData) {
			if (rawData == null)
				throw new ArgumentNullException("rawData");
			if (userRawData == null)
				userRawData = new Dictionary<uint, byte[]>();
			userRawData[offset] = rawData;
		}

		/// <inheritdoc/>
		public IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData() {
			var memStream = new MemoryStream();
			var writer = new BinaryWriter(memStream);
			uint offset = originalData != null ? (uint)originalData.Length : 1;
			foreach (var data in cached) {
				memStream.Position = 0;
				memStream.SetLength(0);
				writer.WriteCompressedUInt32((uint)data.Length);
				writer.Write(data);
				yield return new KeyValuePair<uint, byte[]>(offset, memStream.ToArray());
				offset += (uint)memStream.Length;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ByteArrayChunk.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Stores a byte array
	/// </summary>
	public sealed class ByteArrayChunk : IChunk {
		readonly byte[] array;
		FileOffset offset;
		RVA rva;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets the data
		/// </summary>
		public byte[] Data {
			get { return array; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="array">The data. It will be owned by this instance and can't be modified by
		/// other code if this instance is inserted as a <c>key</c> in a dictionary (because
		/// <see cref="GetHashCode"/> return value will be different if you modify the array). If
		/// it's never inserted as a <c>key</c> in a dictionary, then the contents can be modified,
		/// but shouldn't be resized after <see cref="SetOffset"/> has been called.</param>
		public ByteArrayChunk(byte[] array) {
			this.array = array ?? new byte[0];
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return (uint)array.Length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			writer.Write(array);
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			return Utils.GetHashCode(array);
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			var other = obj as ByteArrayChunk;
			return other != null && Utils.Equals(array, other.array);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ChunkList.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Contains a list of <see cref="IChunk"/>s
	/// </summary>
	public class ChunkList<T> : ChunkListBase<T> where T : class, IChunk {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ChunkList() {
			this.chunks = new List<Elem>();
		}

		/// <summary>
		/// Add a <see cref="IChunk"/>
		/// </summary>
		/// <param name="chunk">The chunk to add or <c>null</c> if none</param>
		/// <param name="alignment">Chunk alignment</param>
		public void Add(T chunk, uint alignment) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (chunk != null)
				chunks.Add(new Elem(chunk, alignment));
		}

		/// <summary>
		/// Remove a <see cref="IChunk"/>
		/// </summary>
		/// <param name="chunk">The chunk to remove or <c>null</c> if none</param>
		/// <returns>Alignment of the chunk, or <c>null</c> if the chunk cannot be removed.</returns>
		public uint? Remove(T chunk) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (chunk != null) {
				for (int i = 0; i < chunks.Count; i++) {
					if (chunks[i].chunk == chunk) {
						uint alignment = chunks[i].alignment;
						chunks.RemoveAt(i);
						return alignment;
					}
				}
			}
			return null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ChunkListBase.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Base class of chunk list types
	/// </summary>
	/// <typeparam name="T">Chunk type</typeparam>
	public abstract class ChunkListBase<T> : IChunk where T : IChunk {
		/// <summary>All chunks</summary>
		protected List<Elem> chunks;
		uint length;
		uint virtualSize;
		/// <summary><c>true</c> if <see cref="SetOffset"/> has been called</summary>
		protected bool setOffsetCalled;
		FileOffset offset;
		RVA rva;

		/// <summary>
		/// Helper struct
		/// </summary>
		protected struct Elem {
			/// <summary>Data</summary>
			public readonly T chunk;
			/// <summary>Alignment</summary>
			public readonly uint alignment;

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="chunk">Chunk</param>
			/// <param name="alignment">Alignment</param>
			public Elem(T chunk, uint alignment) {
				this.chunk = chunk;
				this.alignment = alignment;
			}
		}

		/// <summary>
		/// Equality comparer for <see cref="Elem"/>
		/// </summary>
		protected sealed class ElemEqualityComparer : IEqualityComparer<Elem> {
			IEqualityComparer<T> chunkComparer;

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="chunkComparer">Compares the chunk type</param>
			public ElemEqualityComparer(IEqualityComparer<T> chunkComparer) {
				this.chunkComparer = chunkComparer;
			}

			/// <inheritdoc/>
			public bool Equals(Elem x, Elem y) {
				return x.alignment == y.alignment &&
					chunkComparer.Equals(x.chunk, y.chunk);
			}

			/// <inheritdoc/>
			public int GetHashCode(Elem obj) {
				return (int)obj.alignment + chunkComparer.GetHashCode(obj.chunk);
			}
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <inheritdoc/>
		public virtual void SetOffset(FileOffset offset, RVA rva) {
			setOffsetCalled = true;
			this.offset = offset;
			this.rva = rva;
			length = 0;
			virtualSize = 0;
			foreach (var elem in chunks) {
				uint paddingF = (uint)offset.AlignUp(elem.alignment) - (uint)offset;
				uint paddingV = (uint)rva.AlignUp(elem.alignment) - (uint)rva;
				offset += paddingF;
				rva += paddingV;
				elem.chunk.SetOffset(offset, rva);
				if (elem.chunk.GetVirtualSize() == 0) {
					offset -= paddingF;
					rva -= paddingV;
				}
				else {
					uint chunkLenF = elem.chunk.GetFileLength();
					uint chunkLenV = elem.chunk.GetVirtualSize();
					offset += chunkLenF;
					rva += chunkLenV;
					length += paddingF + chunkLenF;
					virtualSize += paddingV + chunkLenV;
				}
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return virtualSize;
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			FileOffset offset2 = offset;
			foreach (var elem in chunks) {
				if (elem.chunk.GetVirtualSize() == 0)
					continue;
				int paddingF = (int)offset2.AlignUp(elem.alignment) - (int)offset2;
				writer.WriteZeros(paddingF);
				elem.chunk.VerifyWriteTo(writer);
				offset2 += (uint)paddingF + elem.chunk.GetFileLength();
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/CustomAttributeWriter.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Helps <see cref="CustomAttributeWriter"/> write custom attributes
	/// </summary>
	public interface ICustomAttributeWriterHelper : IWriterError, IFullNameCreatorHelper {
	}

	/// <summary>
	/// Writes <see cref="CustomAttribute"/>s
	/// </summary>
	public struct CustomAttributeWriter : IDisposable {
		readonly ICustomAttributeWriterHelper helper;
		RecursionCounter recursionCounter;
		readonly MemoryStream outStream;
		readonly BinaryWriter writer;
		readonly bool disposeStream;
		GenericArguments genericArguments;

		/// <summary>
		/// Writes a custom attribute
		/// </summary>
		/// <param name="helper">Helper class</param>
		/// <param name="ca">The custom attribute</param>
		/// <returns>Custom attribute blob</returns>
		public static byte[] Write(ICustomAttributeWriterHelper helper, CustomAttribute ca) {
			using (var writer = new CustomAttributeWriter(helper)) {
				writer.Write(ca);
				return writer.GetResult();
			}
		}

		internal static byte[] Write(ICustomAttributeWriterHelper helper, CustomAttribute ca, BinaryWriterContext context) {
			using (var writer = new CustomAttributeWriter(helper, context)) {
				writer.Write(ca);
				return writer.GetResult();
			}
		}

		/// <summary>
		/// Writes custom attribute named arguments
		/// </summary>
		/// <param name="helper">Helper class</param>
		/// <param name="namedArgs">Named arguments</param>
		/// <returns>The named args blob</returns>
		internal static byte[] Write(ICustomAttributeWriterHelper helper, IList<CANamedArgument> namedArgs) {
			using (var writer = new CustomAttributeWriter(helper)) {
				writer.Write(namedArgs);
				return writer.GetResult();
			}
		}

		internal static byte[] Write(ICustomAttributeWriterHelper helper, IList<CANamedArgument> namedArgs, BinaryWriterContext context) {
			using (var writer = new CustomAttributeWriter(helper, context)) {
				writer.Write(namedArgs);
				return writer.GetResult();
			}
		}

		CustomAttributeWriter(ICustomAttributeWriterHelper helper) {
			this.helper = helper;
			this.recursionCounter = new RecursionCounter();
			this.outStream = new MemoryStream();
			this.writer = new BinaryWriter(outStream);
			this.genericArguments = null;
			this.disposeStream = true;
		}

		CustomAttributeWriter(ICustomAttributeWriterHelper helper, BinaryWriterContext context) {
			this.helper = helper;
			this.recursionCounter = new RecursionCounter();
			this.outStream = context.OutStream;
			this.writer = context.Writer;
			this.genericArguments = null;
			this.disposeStream = false;
			outStream.SetLength(0);
			outStream.Position = 0;
		}

		byte[] GetResult() {
			return outStream.ToArray();
		}

		void Write(CustomAttribute ca) {
			if (ca == null) {
				helper.Error("The custom attribute is null");
				return;
			}

			// Check whether it's raw first. If it is, we don't care whether the ctor is
			// invalid. Just use the raw data.
			if (ca.IsRawBlob) {
				if ((ca.ConstructorArguments != null && ca.ConstructorArguments.Count > 0) || (ca.NamedArguments != null && ca.NamedArguments.Count > 0))
					helper.Error("Raw custom attribute contains arguments and/or named arguments");
				writer.Write(ca.RawData);
				return;
			}

			if (ca.Constructor == null) {
				helper.Error("Custom attribute ctor is null");
				return;
			}

			var methodSig = GetMethodSig(ca.Constructor);
			if (methodSig == null) {
				helper.Error("Custom attribute ctor's method signature is invalid");
				return;
			}

			if (ca.ConstructorArguments.Count != methodSig.Params.Count)
				helper.Error("Custom attribute arguments count != method sig arguments count");
			if (methodSig.ParamsAfterSentinel != null && methodSig.ParamsAfterSentinel.Count > 0)
				helper.Error("Custom attribute ctor has parameters after the sentinel");
			if (ca.NamedArguments.Count > ushort.MaxValue)
				helper.Error("Custom attribute has too many named arguments");

			// A generic custom attribute isn't allowed by most .NET languages (eg. C#) but
			// the CLR probably supports it.
			var mrCtor = ca.Constructor as MemberRef;
			if (mrCtor != null) {
				var owner = mrCtor.Class as TypeSpec;
				if (owner != null) {
					var gis = owner.TypeSig as GenericInstSig;
					if (gis != null) {
						genericArguments = new GenericArguments();
						genericArguments.PushTypeArgs(gis.GenericArguments);
					}
				}
			}

			writer.Write((ushort)1);

			int numArgs = Math.Min(methodSig.Params.Count, ca.ConstructorArguments.Count);
			for (int i = 0; i < numArgs; i++)
				WriteValue(FixTypeSig(methodSig.Params[i]), ca.ConstructorArguments[i]);

			int numNamedArgs = Math.Min((int)ushort.MaxValue, ca.NamedArguments.Count);
			writer.Write((ushort)numNamedArgs);
			for (int i = 0; i < numNamedArgs; i++)
				Write(ca.NamedArguments[i]);
		}

		void Write(IList<CANamedArgument> namedArgs) {
			if (namedArgs == null || namedArgs.Count > 0x1FFFFFFF) {
				helper.Error("Too many custom attribute named arguments");
				namedArgs = new CANamedArgument[0];
			}
			writer.WriteCompressedUInt32((uint)namedArgs.Count);
			for (int i = 0; i < namedArgs.Count; i++)
				Write(namedArgs[i]);
		}

		TypeSig FixTypeSig(TypeSig type) {
			return SubstituteGenericParameter(type.RemoveModifiers()).RemoveModifiers();
		}

		TypeSig SubstituteGenericParameter(TypeSig type) {
			if (genericArguments == null)
				return type;
			return genericArguments.Resolve(type);
		}

		void WriteValue(TypeSig argType, CAArgument value) {
			if (argType == null || value.Type == null) {
				helper.Error("Custom attribute argument type is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			var arrayType = argType as SZArraySig;
			if (arrayType != null) {
				var argsArray = value.Value as IList<CAArgument>;
				if (argsArray == null && value.Value != null)
					helper.Error("CAArgument.Value is not null or an array");
				WriteArrayValue(arrayType, argsArray);
			}
			else
				WriteElem(argType, value);

			recursionCounter.Decrement();
		}

		void WriteArrayValue(SZArraySig arrayType, IList<CAArgument> args) {
			if (arrayType == null) {
				helper.Error("Custom attribute: Array type is null");
				return;
			}

			if (args == null)
				writer.Write(uint.MaxValue);
			else {
				writer.Write((uint)args.Count);
				var arrayElementType = FixTypeSig(arrayType.Next);
				for (int i = 0; i < args.Count; i++)
					WriteValue(arrayElementType, args[i]);
			}
		}

		bool VerifyTypeAndValue(CAArgument value, ElementType etype) {
			if (!VerifyType(value.Type, etype)) {
				helper.Error("Custom attribute arg type != value.Type");
				return false;
			}
			if (!VerifyValue(value.Value, etype)) {
				helper.Error("Custom attribute value.Value's type != value.Type");
				return false;
			}
			return true;
		}

		bool VerifyTypeAndValue(CAArgument value, ElementType etype, Type valueType) {
			if (!VerifyType(value.Type, etype)) {
				helper.Error("Custom attribute arg type != value.Type");
				return false;
			}
			return value.Value == null || value.Value.GetType() == valueType;
		}

		static bool VerifyType(TypeSig type, ElementType etype) {
			type = type.RemoveModifiers();
			// Assume it's an enum if it's a ValueType
			return type != null && (etype == type.ElementType || type.ElementType == ElementType.ValueType);
		}

		static bool VerifyValue(object o, ElementType etype) {
			if (o == null)
				return false;

			switch (Type.GetTypeCode(o.GetType())) {
			case TypeCode.Boolean:	return etype == ElementType.Boolean;
			case TypeCode.Char:		return etype == ElementType.Char;
			case TypeCode.SByte:	return etype == ElementType.I1;
			case TypeCode.Byte:		return etype == ElementType.U1;
			case TypeCode.Int16:	return etype == ElementType.I2;
			case TypeCode.UInt16:	return etype == ElementType.U2;
			case TypeCode.Int32:	return etype == ElementType.I4;
			case TypeCode.UInt32:	return etype == ElementType.U4;
			case TypeCode.Int64:	return etype == ElementType.I8;
			case TypeCode.UInt64:	return etype == ElementType.U8;
			case TypeCode.Single:	return etype == ElementType.R4;
			case TypeCode.Double:	return etype == ElementType.R8;
			default: return false;
			}
		}

		static ulong ToUInt64(object o) {
			ulong result;
			ToUInt64(o, out result);
			return result;
		}

		static bool ToUInt64(object o, out ulong result) {
			if (o == null) {
				result = 0;
				return false;
			}

			switch (Type.GetTypeCode(o.GetType())) {
			case TypeCode.Boolean:
				result = (bool)o ? 1UL : 0UL;
				return true;

			case TypeCode.Char:
				result = (ushort)(char)o;
				return true;

			case TypeCode.SByte:
				result = (ulong)(sbyte)o;
				return true;

			case TypeCode.Byte:
				result = (byte)o;
				return true;

			case TypeCode.Int16:
				result = (ulong)(short)o;
				return true;

			case TypeCode.UInt16:
				result = (ushort)o;
				return true;

			case TypeCode.Int32:
				result = (ulong)(int)o;
				return true;

			case TypeCode.UInt32:
				result = (uint)o;
				return true;

			case TypeCode.Int64:
				result = (ulong)(long)o;
				return true;

			case TypeCode.UInt64:
				result = (ulong)o;
				return true;

			case TypeCode.Single:
				result = (ulong)(float)o;
				return true;

			case TypeCode.Double:
				result = (ulong)(double)o;
				return true;
			}

			result = 0;
			return false;
		}

		static double ToDouble(object o) {
			double result;
			ToDouble(o, out result);
			return result;
		}

		static bool ToDouble(object o, out double result) {
			if (o == null) {
				result = double.NaN;
				return false;
			}

			switch (Type.GetTypeCode(o.GetType())) {
			case TypeCode.Boolean:
				result = (bool)o ? 1 : 0;
				return true;

			case TypeCode.Char:
				result = (ushort)(char)o;
				return true;

			case TypeCode.SByte:
				result = (sbyte)o;
				return true;

			case TypeCode.Byte:
				result = (byte)o;
				return true;

			case TypeCode.Int16:
				result = (short)o;
				return true;

			case TypeCode.UInt16:
				result = (ushort)o;
				return true;

			case TypeCode.Int32:
				result = (int)o;
				return true;

			case TypeCode.UInt32:
				result = (uint)o;
				return true;

			case TypeCode.Int64:
				result = (long)o;
				return true;

			case TypeCode.UInt64:
				result = (ulong)o;
				return true;

			case TypeCode.Single:
				result = (float)o;
				return true;

			case TypeCode.Double:
				result = (double)o;
				return true;
			}

			result = double.NaN;
			return false;
		}

		/// <summary>
		/// Write a value
		/// </summary>
		/// <param name="argType">The ctor arg type, field type, or property type</param>
		/// <param name="value">The value to write</param>
		void WriteElem(TypeSig argType, CAArgument value) {
			if (argType == null) {
				helper.Error("Custom attribute: Arg type is null");
				argType = value.Type;
				if (argType == null)
					return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			TypeSig underlyingType;
			ITypeDefOrRef tdr;
			switch (argType.ElementType) {
			case ElementType.Boolean:
				if (!VerifyTypeAndValue(value, ElementType.Boolean))
					writer.Write(ToUInt64(value.Value) != 0);
				else
					writer.Write((bool)value.Value);
				break;

			case ElementType.Char:
				if (!VerifyTypeAndValue(value, ElementType.Char))
					writer.Write((ushort)ToUInt64(value.Value));
				else
					writer.Write((ushort)(char)value.Value);
				break;

			case ElementType.I1:
				if (!VerifyTypeAndValue(value, ElementType.I1))
					writer.Write((sbyte)ToUInt64(value.Value));
				else
					writer.Write((sbyte)value.Value);
				break;

			case ElementType.U1:
				if (!VerifyTypeAndValue(value, ElementType.U1))
					writer.Write((byte)ToUInt64(value.Value));
				else
					writer.Write((byte)value.Value);
				break;

			case ElementType.I2:
				if (!VerifyTypeAndValue(value, ElementType.I2))
					writer.Write((short)ToUInt64(value.Value));
				else
					writer.Write((short)value.Value);
				break;

			case ElementType.U2:
				if (!VerifyTypeAndValue(value, ElementType.U2))
					writer.Write((ushort)ToUInt64(value.Value));
				else
					writer.Write((ushort)value.Value);
				break;

			case ElementType.I4:
				if (!VerifyTypeAndValue(value, ElementType.I4))
					writer.Write((int)ToUInt64(value.Value));
				else
					writer.Write((int)value.Value);
				break;

			case ElementType.U4:
				if (!VerifyTypeAndValue(value, ElementType.U4))
					writer.Write((uint)ToUInt64(value.Value));
				else
					writer.Write((uint)value.Value);
				break;

			case ElementType.I8:
				if (!VerifyTypeAndValue(value, ElementType.I8))
					writer.Write((long)ToUInt64(value.Value));
				else
					writer.Write((long)value.Value);
				break;

			case ElementType.U8:
				if (!VerifyTypeAndValue(value, ElementType.U8))
					writer.Write(ToUInt64(value.Value));
				else
					writer.Write((ulong)value.Value);
				break;

			case ElementType.R4:
				if (!VerifyTypeAndValue(value, ElementType.R4))
					writer.Write((float)ToDouble(value.Value));
				else
					writer.Write((float)value.Value);
				break;

			case ElementType.R8:
				if (!VerifyTypeAndValue(value, ElementType.R8))
					writer.Write(ToDouble(value.Value));
				else
					writer.Write((double)value.Value);
				break;

			case ElementType.String:
				if (VerifyTypeAndValue(value, ElementType.String, typeof(UTF8String)))
					WriteUTF8String((UTF8String)value.Value);
				else if (VerifyTypeAndValue(value, ElementType.String, typeof(string)))
					WriteUTF8String((string)value.Value);
				else
					WriteUTF8String(UTF8String.Empty);
				break;

			case ElementType.ValueType:
				tdr = ((TypeDefOrRefSig)argType).TypeDefOrRef;
				underlyingType = GetEnumUnderlyingType(argType);
				if (underlyingType != null)
					WriteElem(underlyingType, value);
				else if (tdr is TypeRef && TryWriteEnumUnderlyingTypeValue(value.Value)) {
					// No error. Assume it's an enum that couldn't be resolved.
				}
				else
					helper.Error("Custom attribute value is not an enum");
				break;

			case ElementType.Class:
				tdr = ((TypeDefOrRefSig)argType).TypeDefOrRef;
				if (CheckCorLibType(argType, "Type")) {
					if (CheckCorLibType(value.Type, "Type")) {
						var ts = value.Value as TypeSig;
						if (ts != null)
							WriteType(ts);
						else if (value.Value == null)
							WriteUTF8String(null);
						else {
							helper.Error("Custom attribute value is not a type");
							WriteUTF8String(UTF8String.Empty);
						}
					}
					else {
						helper.Error("Custom attribute value type is not System.Type");
						WriteUTF8String(UTF8String.Empty);
					}
					break;
				}
				else if (tdr is TypeRef && TryWriteEnumUnderlyingTypeValue(value.Value)) {
					// No error. Assume it's an enum that couldn't be resolved.
					break;
				}
				goto default;

			case ElementType.SZArray:
				WriteValue(argType, value);
				break;

			case ElementType.Object:
				WriteFieldOrPropType(value.Type);
				WriteElem(value.Type, value);
				break;

			case ElementType.End:
			case ElementType.Void:
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Var:
			case ElementType.Array:
			case ElementType.GenericInst:
			case ElementType.TypedByRef:
			case ElementType.ValueArray:
			case ElementType.I:
			case ElementType.U:
			case ElementType.R:
			case ElementType.FnPtr:
			case ElementType.MVar:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Internal:
			case ElementType.Module:
			case ElementType.Sentinel:
			case ElementType.Pinned:
			default:
				helper.Error("Invalid or unsupported element type in custom attribute");
				break;
			}

			recursionCounter.Decrement();
		}

		bool TryWriteEnumUnderlyingTypeValue(object o) {
			if (o == null)
				return false;
			switch (Type.GetTypeCode(o.GetType())) {
			case TypeCode.Boolean:	writer.Write((bool)o); break;
			case TypeCode.Char:		writer.Write((ushort)(char)o); break;
			case TypeCode.SByte:	writer.Write((sbyte)o); break;
			case TypeCode.Byte:		writer.Write((byte)o); break;
			case TypeCode.Int16:	writer.Write((short)o); break;
			case TypeCode.UInt16:	writer.Write((ushort)o); break;
			case TypeCode.Int32:	writer.Write((int)o); break;
			case TypeCode.UInt32:	writer.Write((uint)o); break;
			case TypeCode.Int64:	writer.Write((long)o); break;
			case TypeCode.UInt64:	writer.Write((ulong)o); break;
			default: return false;
			}
			return true;
		}

		/// <summary>
		/// Gets the enum's underlying type
		/// </summary>
		/// <param name="type">An enum type</param>
		/// <returns>The underlying type or <c>null</c> if we couldn't resolve the type ref</returns>
		static TypeSig GetEnumUnderlyingType(TypeSig type) {
			var td = GetEnumTypeDef(type);
			if (td == null)
				return null;
			return td.GetEnumUnderlyingType().RemoveModifiers();
		}

		static TypeDef GetEnumTypeDef(TypeSig type) {
			if (type == null)
				return null;
			var td = GetTypeDef(type);
			if (td == null)
				return null;
			if (!td.IsEnum)
				return null;
			return td;
		}

		/// <summary>
		/// Converts <paramref name="type"/> to a <see cref="TypeDef"/>, possibly resolving
		/// a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if we couldn't resolve the
		/// <see cref="TypeRef"/> or if <paramref name="type"/> is a type spec</returns>
		static TypeDef GetTypeDef(TypeSig type) {
			var tdr = type as TypeDefOrRefSig;
			if (tdr != null) {
				var td = tdr.TypeDef;
				if (td != null)
					return td;

				var tr = tdr.TypeRef;
				if (tr != null)
					return tr.Resolve();
			}

			return null;
		}

		void Write(CANamedArgument namedArg) {
			if (namedArg == null) {
				helper.Error("Custom attribute named arg is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			if (namedArg.IsProperty)
				writer.Write((byte)SerializationType.Property);
			else
				writer.Write((byte)SerializationType.Field);

			WriteFieldOrPropType(namedArg.Type);
			WriteUTF8String(namedArg.Name);
			WriteValue(namedArg.Type, namedArg.Argument);

			recursionCounter.Decrement();
		}

		void WriteFieldOrPropType(TypeSig type) {
			type = type.RemoveModifiers();
			if (type == null) {
				helper.Error("Custom attribute: Field/property type is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			ITypeDefOrRef tdr;
			switch (type.ElementType) {
			case ElementType.Boolean:	writer.Write((byte)SerializationType.Boolean); break;
			case ElementType.Char:		writer.Write((byte)SerializationType.Char); break;
			case ElementType.I1:		writer.Write((byte)SerializationType.I1); break;
			case ElementType.U1:		writer.Write((byte)SerializationType.U1); break;
			case ElementType.I2:		writer.Write((byte)SerializationType.I2); break;
			case ElementType.U2:		writer.Write((byte)SerializationType.U2); break;
			case ElementType.I4:		writer.Write((byte)SerializationType.I4); break;
			case ElementType.U4:		writer.Write((byte)SerializationType.U4); break;
			case ElementType.I8:		writer.Write((byte)SerializationType.I8); break;
			case ElementType.U8:		writer.Write((byte)SerializationType.U8); break;
			case ElementType.R4:		writer.Write((byte)SerializationType.R4); break;
			case ElementType.R8:		writer.Write((byte)SerializationType.R8); break;
			case ElementType.String:	writer.Write((byte)SerializationType.String); break;
			case ElementType.Object:	writer.Write((byte)SerializationType.TaggedObject); break;

			case ElementType.SZArray:
				writer.Write((byte)SerializationType.SZArray);
				WriteFieldOrPropType(type.Next);
				break;

			case ElementType.Class:
				tdr = ((TypeDefOrRefSig)type).TypeDefOrRef;
				if (CheckCorLibType(type, "Type"))
					writer.Write((byte)SerializationType.Type);
				else if (tdr is TypeRef) {
					// Could be an enum TypeRef that couldn't be resolved, so the code
					// assumed it's a class and created a ClassSig.
					writer.Write((byte)SerializationType.Enum);
					WriteType(tdr);
				}
				else
					goto default;
				break;

			case ElementType.ValueType:
				tdr = ((TypeDefOrRefSig)type).TypeDefOrRef;
				var enumType = GetEnumTypeDef(type);
				// If TypeRef => assume it's an enum that couldn't be resolved
				if (enumType != null || tdr is TypeRef) {
					writer.Write((byte)SerializationType.Enum);
					WriteType(tdr);
				}
				else {
					helper.Error("Custom attribute type doesn't seem to be an enum.");
					writer.Write((byte)SerializationType.Enum);
					WriteType(tdr);
				}
				break;

			default:
				helper.Error("Custom attribute: Invalid type");
				writer.Write((byte)0xFF);
				break;
			}

			recursionCounter.Decrement();
		}

		void WriteType(IType type) {
			if (type == null) {
				helper.Error("Custom attribute: Type is null");
				WriteUTF8String(UTF8String.Empty);
			}
			else
				WriteUTF8String(FullNameCreator.AssemblyQualifiedName(type, helper));
		}

		static bool CheckCorLibType(TypeSig ts, string name) {
			var tdrs = ts as TypeDefOrRefSig;
			if (tdrs == null)
				return false;
			return CheckCorLibType(tdrs.TypeDefOrRef, name);
		}

		static bool CheckCorLibType(ITypeDefOrRef tdr, string name) {
			if (tdr == null)
				return false;
			if (!tdr.DefinitionAssembly.IsCorLib())
				return false;
			if (tdr is TypeSpec)
				return false;
			return tdr.TypeName == name && tdr.Namespace == "System";
		}

		static MethodSig GetMethodSig(ICustomAttributeType ctor) {
			return ctor == null ? null : ctor.MethodSig;
		}

		void WriteUTF8String(UTF8String s) {
			if ((object)s == null || s.Data == null)
				writer.Write((byte)0xFF);
			else {
				writer.WriteCompressedUInt32((uint)s.Data.Length);
				writer.Write(s.Data);
			}
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (!disposeStream)
				return;
			if (outStream != null)
				outStream.Dispose();
			if (writer != null)
				((IDisposable)writer).Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/DebugDirectory.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.IO;
using dnlib.DotNet.Pdb;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Debug directory entry
	/// </summary>
	public sealed class DebugDirectoryEntry {
		/// <summary>
		/// Gets the header
		/// </summary>
		public IMAGE_DEBUG_DIRECTORY DebugDirectory;

		/// <summary>
		/// Gets the data
		/// </summary>
		public readonly IChunk Chunk;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="chunk">Data</param>
		public DebugDirectoryEntry(IChunk chunk) {
			Chunk = chunk;
		}
	}

	/// <summary>
	/// Debug directory chunk
	/// </summary>
	public sealed class DebugDirectory : IChunk {
		/// <summary>Default debug directory alignment</summary>
		public const uint DEFAULT_DEBUGDIRECTORY_ALIGNMENT = 4;
		const int HEADER_SIZE = 28;

		FileOffset offset;
		RVA rva;
		uint length;
		readonly List<DebugDirectoryEntry> entries;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public DebugDirectory() {
			entries = new List<DebugDirectoryEntry>();
		}

		/// <summary>
		/// Adds data
		/// </summary>
		/// <param name="data">Data</param>
		/// <returns></returns>
		public DebugDirectoryEntry Add(byte[] data) {
			return Add(new ByteArrayChunk(data));
		}

		/// <summary>
		/// Adds data
		/// </summary>
		/// <param name="chunk">Data</param>
		/// <returns></returns>
		public DebugDirectoryEntry Add(IChunk chunk) {
			var entry = new DebugDirectoryEntry(chunk);
			entries.Add(entry);
			return entry;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			length = HEADER_SIZE * (uint)entries.Count;
			foreach (var entry in entries) {
				length = Utils.AlignUp(length, DEFAULT_DEBUGDIRECTORY_ALIGNMENT);
				entry.Chunk.SetOffset(offset + length, rva + length);
				length += entry.Chunk.GetFileLength();
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			uint offset = 0;
			foreach (var entry in entries) {
				writer.Write(entry.DebugDirectory.Characteristics);
				writer.Write(entry.DebugDirectory.TimeDateStamp);
				writer.Write(entry.DebugDirectory.MajorVersion);
				writer.Write(entry.DebugDirectory.MinorVersion);
				writer.Write((uint)entry.DebugDirectory.Type);
				writer.Write(entry.Chunk.GetFileLength());
				writer.Write((uint)entry.Chunk.RVA);
				writer.Write((uint)entry.Chunk.FileOffset);
				offset += HEADER_SIZE;
			}

			foreach (var entry in entries) {
				WriteAlign(writer, ref offset);
				entry.Chunk.VerifyWriteTo(writer);
				offset += entry.Chunk.GetFileLength();
			}
		}

		static void WriteAlign(BinaryWriter writer, ref uint offs) {
			uint align = Utils.AlignUp(offs, DEFAULT_DEBUGDIRECTORY_ALIGNMENT) - offs;
			offs += align;
			writer.WriteZeros((int)align);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/DeclSecurityWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.IO;
using System.Text;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes <c>DeclSecurity</c> blobs
	/// </summary>
	public struct DeclSecurityWriter : ICustomAttributeWriterHelper {
		readonly ModuleDef module;
		readonly IWriterError helper;
		readonly BinaryWriterContext context;

		/// <summary>
		/// Creates a <c>DeclSecurity</c> blob from <paramref name="secAttrs"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="secAttrs">List of <see cref="SecurityAttribute"/>s</param>
		/// <param name="helper">Helps this class</param>
		/// <returns>A <c>DeclSecurity</c> blob</returns>
		public static byte[] Write(ModuleDef module, IList<SecurityAttribute> secAttrs, IWriterError helper) {
			return new DeclSecurityWriter(module, helper, null).Write(secAttrs);
		}

		internal static byte[] Write(ModuleDef module, IList<SecurityAttribute> secAttrs, IWriterError helper, BinaryWriterContext context) {
			return new DeclSecurityWriter(module, helper, context).Write(secAttrs);
		}

		DeclSecurityWriter(ModuleDef module, IWriterError helper, BinaryWriterContext context) {
			this.module = module;
			this.helper = helper;
			this.context = context;
		}

		byte[] Write(IList<SecurityAttribute> secAttrs) {
			if (secAttrs == null)
				secAttrs = new SecurityAttribute[0];

			var xml = DeclSecurity.GetNet1xXmlStringInternal(secAttrs);
			if (xml != null)
				return WriteFormat1(xml);
			return WriteFormat2(secAttrs);
		}

		byte[] WriteFormat1(string xml) {
			return Encoding.Unicode.GetBytes(xml);
		}

		byte[] WriteFormat2(IList<SecurityAttribute> secAttrs) {
			using (var stream = new MemoryStream())
			using (var writer = new BinaryWriter(stream)) {
				writer.Write((byte)'.');
				WriteCompressedUInt32(writer, (uint)secAttrs.Count);

				foreach (var sa in secAttrs) {
					if (sa == null) {
						helper.Error("SecurityAttribute is null");
						Write(writer, UTF8String.Empty);
						WriteCompressedUInt32(writer, 1);
						WriteCompressedUInt32(writer, 0);
						continue;
					}
					var attrType = sa.AttributeType;
					string fqn;
					if (attrType == null) {
						helper.Error("SecurityAttribute attribute type is null");
						fqn = string.Empty;
					}
					else
						fqn = attrType.AssemblyQualifiedName;
					Write(writer, fqn);

					var namedArgsBlob = context == null ?
						CustomAttributeWriter.Write(this, sa.NamedArguments) :
						CustomAttributeWriter.Write(this, sa.NamedArguments, context);
					if (namedArgsBlob.Length > 0x1FFFFFFF) {
						helper.Error("Named arguments blob size doesn't fit in 29 bits");
						namedArgsBlob = new byte[0];
					}
					WriteCompressedUInt32(writer, (uint)namedArgsBlob.Length);
					writer.Write(namedArgsBlob);
				}

				return stream.ToArray();
			}
		}

		uint WriteCompressedUInt32(BinaryWriter writer, uint value) {
			return writer.WriteCompressedUInt32(helper, value);
		}

		void Write(BinaryWriter writer, UTF8String s) {
			writer.Write(helper, s);
		}

		void IWriterError.Error(string message) {
			helper.Error(message);
		}

		bool IFullNameCreatorHelper.MustUseAssemblyName(IType type) {
			return FullNameCreator.MustUseAssemblyName(module, type);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/Extensions.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class Extensions {
		/// <summary>
		/// Write zeros
		/// </summary>
		/// <param name="writer">this</param>
		/// <param name="count">Number of zeros</param>
		public static void WriteZeros(this BinaryWriter writer, int count) {
			if (count <= 0x20) {
				for (int i = 0; i < count; i++)
					writer.Write((byte)0);
			}
			else
				writer.Write(new byte[count]);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/GuidHeap.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #GUID heap
	/// </summary>
	public sealed class GuidHeap : HeapBase, IOffsetHeap<Guid> {
		readonly Dictionary<Guid, uint> guids = new Dictionary<Guid, uint>();
		Dictionary<uint, byte[]> userRawData;

		/// <inheritdoc/>
		public override string Name {
			get { return "#GUID"; }
		}

		/// <summary>
		/// Adds a guid to the #GUID heap
		/// </summary>
		/// <param name="guid">The guid</param>
		/// <returns>The index of the guid in the #GUID heap</returns>
		public uint Add(Guid? guid) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #GUID when it's read-only");
			if (guid == null)
				return 0;

			uint index;
			if (guids.TryGetValue(guid.Value, out index))
				return index;

			index = (uint)guids.Count + 1;
			guids.Add(guid.Value, index);
			return index;
		}

		/// <inheritdoc/>
		public override uint GetRawLength() {
			return (uint)guids.Count * 16;
		}

		/// <inheritdoc/>
		protected override void WriteToImpl(BinaryWriter writer) {
			uint offset = 0;
			foreach (var kv in guids) {
				byte[] rawData;
				if (userRawData == null || !userRawData.TryGetValue(offset, out rawData))
					rawData = kv.Key.ToByteArray();
				writer.Write(rawData);
				offset += 16;
			}
		}

		/// <inheritdoc/>
		public int GetRawDataSize(Guid data) {
			return 16;
		}

		/// <inheritdoc/>
		public void SetRawData(uint offset, byte[] rawData) {
			if (rawData == null || rawData.Length != 16)
				throw new ArgumentException("Invalid size of GUID raw data");
			if (userRawData == null)
				userRawData = new Dictionary<uint, byte[]>();
			userRawData[offset] = rawData;
		}

		/// <inheritdoc/>
		public IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData() {
			uint offset = 0;
			foreach (var kv in guids) {
				yield return new KeyValuePair<uint, byte[]>(offset, kv.Key.ToByteArray());
				offset += 16;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/HeapBase.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Base class of most heaps
	/// </summary>
	public abstract class HeapBase : IHeap {
		internal const uint ALIGNMENT = 4;
		FileOffset offset;
		RVA rva;

		/// <summary>
		/// <c>true</c> if <see cref="SetReadOnly"/> has been called
		/// </summary>
		protected bool isReadOnly;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <inheritdoc/>
		public abstract string Name { get; }

		/// <inheritdoc/>
		public bool IsEmpty {
			get { return GetRawLength() <= 1; }
		}

		/// <summary>
		/// <c>true</c> if offsets require 4 bytes instead of 2 bytes.
		/// </summary>
		public bool IsBig {
			get { return GetFileLength() > 0xFFFF; }
		}

		/// <inheritdoc/>
		public void SetReadOnly() {
			isReadOnly = true;
		}

		/// <inheritdoc/>
		public virtual void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return Utils.AlignUp(GetRawLength(), ALIGNMENT);
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <summary>
		/// Gets the raw length of the heap
		/// </summary>
		/// <returns>Raw length of the heap</returns>
		public abstract uint GetRawLength();

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			WriteToImpl(writer);
			writer.WriteZeros((int)(Utils.AlignUp(GetRawLength(), ALIGNMENT) - GetRawLength()));
		}

		/// <summary>
		/// Writes all data to <paramref name="writer"/> at its current location.
		/// </summary>
		/// <param name="writer">Destination</param>
		protected abstract void WriteToImpl(BinaryWriter writer);

		/// <inheritdoc/>
		public override string ToString() {
			return Name;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/HotHeap.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet.MD;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// The hot metadata heap: <c>#!</c>. MS' CLR 2.0+ can read this heap. It's used by native
	/// images (NGEN'd) only, but if you patch the CLR, you can use it with normal non-NGEN'd
	/// images as well.
	/// It's only used by the CLR when the compressed heap (<c>#~</c>) is present, not when
	/// the ENC heap (<c>#-</c>) is present.
	/// </summary>
	abstract class HotHeap : HeapBase {
		const uint HOT_HEAP_MAGIC = 0x484F4E44;	// "HOND"
		const int MAX_TABLES = (int)Table.GenericParamConstraint + 1;
		const uint HOT_HEAP_DIR_SIZE = 4 + MAX_TABLES * 4;
		const uint HH_ALIGNMENT = 4;

		protected readonly MetaData metadata;
		uint totalLength;
		readonly HotTable[] headers = new HotTable[MAX_TABLES];
		readonly List<HotPool> hotPools = new List<HotPool>();

		/// <summary>
		/// Gets the hot heap version
		/// </summary>
		public abstract HotHeapVersion HotHeapVersion { get; }

		/// <inheritdoc/>
		public override string Name {
			get { return "#!"; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		protected HotHeap(MetaData metadata) {
			this.metadata = metadata;
		}

		/// <summary>
		/// Creates a <see cref="HotTable"/> instance
		/// </summary>
		/// <param name="mdTable">The MD table</param>
		public abstract HotTable CreateHotTable(IMDTable mdTable);

		/// <summary>
		/// Creates a <see cref="HotPool"/> instance
		/// </summary>
		/// <param name="heapType">Pool type</param>
		public abstract HotPool CreateHotPool(HeapType heapType);

		/// <summary>
		/// Creates a hot heap instance
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		/// <param name="module">Target module</param>
		public static HotHeap Create(MetaData metadata, ModuleDef module) {
			return Create(metadata, GetHotHeapVersion(module));
		}

		/// <summary>
		/// Creates a hot heap instance
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		/// <param name="version">Hot heap version</param>
		public static HotHeap Create(MetaData metadata, HotHeapVersion version) {
			switch (version) {
			case HotHeapVersion.CLR20: return new HotHeap20(metadata);
			case HotHeapVersion.CLR40: return new HotHeap40(metadata);
			default: throw new ArgumentException("Invalid version");
			}
		}

		/// <summary>
		/// Returns the correct hot heap version that should be used
		/// </summary>
		/// <param name="module">Target module</param>
		public static HotHeapVersion GetHotHeapVersion(ModuleDef module) {
			if (module.IsClr20)
				return HotHeapVersion.CLR20;
			return HotHeapVersion.CLR40;
		}

		/// <summary>
		/// Adds a hot table
		/// </summary>
		/// <param name="hotTable">The hot table</param>
		public void Add(HotTable hotTable) {
			var table = hotTable.Table;
			if ((uint)table >= (uint)headers.Length)
				throw new ArgumentException("Invalid table type");
			headers[(int)table] = hotTable;
		}

		/// <summary>
		/// Adds a hot pool
		/// </summary>
		/// <param name="hotPool">The hot pool</param>
		public void Add(HotPool hotPool) {
			hotPools.Add(hotPool);
		}

		/// <inheritdoc/>
		public override void SetOffset(FileOffset offset, RVA rva) {
			base.SetOffset(offset, rva);

			uint startOffs = (uint)offset;

			offset += HOT_HEAP_DIR_SIZE;
			rva += HOT_HEAP_DIR_SIZE;
			foreach (var header in headers) {
				if (header == null)
					continue;
				header.SetOffset(offset, rva);
				uint len = header.GetFileLength();
				offset += len;
				rva += len;
				Align(ref offset, ref rva);
			}

			foreach (var hotPool in hotPools) {
				Align(ref offset, ref rva);
				hotPool.SetOffset(offset, rva);
				uint len = hotPool.GetFileLength();
				offset += len;
				rva += len;
			}

			Align(ref offset, ref rva);
			offset += hotPools.Count * 8;
			rva += (uint)hotPools.Count * 8;

			offset += 8;
			rva += 8;

			totalLength = (uint)offset - startOffs;
		}

		static void Align(ref FileOffset offset, ref RVA rva) {
			offset = offset.AlignUp(HH_ALIGNMENT);
			rva = rva.AlignUp(HH_ALIGNMENT);
		}

		/// <inheritdoc/>
		public override uint GetRawLength() {
			return totalLength;
		}

		/// <inheritdoc/>
		protected override void WriteToImpl(BinaryWriter writer) {
			// The CLR doesn't verify this magic value
			writer.Write(HOT_HEAP_MAGIC);
			uint offs = HOT_HEAP_DIR_SIZE;
			foreach (var header in headers) {
				if (header == null)
					writer.Write(0);
				else {
					writer.Write(offs);	// any alignment, all bits are used
					offs += header.GetFileLength();
					offs = Utils.AlignUp(offs, HH_ALIGNMENT);
				}
			}

			offs = HOT_HEAP_DIR_SIZE;

			foreach (var header in headers) {
				if (header == null)
					continue;
				header.VerifyWriteTo(writer);
				offs += header.GetFileLength();
				WriteAlign(writer, ref offs);
			}

			var hotPoolOffset = new List<long>();
			foreach (var hotPool in hotPools) {
				WriteAlign(writer, ref offs);
				hotPoolOffset.Add(writer.BaseStream.Position);
				hotPool.VerifyWriteTo(writer);
				offs += hotPool.GetFileLength();
			}

			WriteAlign(writer, ref offs);
			long poolDBOffs = writer.BaseStream.Position;
			for (int i = 0; i < hotPools.Count; i++) {
				var hotPool = hotPools[i];
				writer.Write((uint)hotPool.HeapType);
				// CLR 2.0: low 2 bits are ignored
				// CLR 4.0: any alignment, all bits are used
				writer.Write((uint)(poolDBOffs - hotPoolOffset[i] - hotPool.HeaderOffset));
			}
			offs += (uint)hotPools.Count * 8;

			long hotMDDirOffs = writer.BaseStream.Position;
			// any alignment
			writer.Write((uint)(offs - HOT_HEAP_DIR_SIZE));
			// CLR 2.0: low 2 bits are ignored
			// CLR 4.0: any alignment, all bits are used
			writer.Write((uint)(hotMDDirOffs - poolDBOffs));
		}

		static void WriteAlign(BinaryWriter writer, ref uint offs) {
			uint align = Utils.AlignUp(offs, HH_ALIGNMENT) - offs;
			offs += align;
			writer.WriteZeros((int)align);
		}
	}

	/// <summary>
	/// CLR 2.0 (.NET 2.0 - 3.5) hot heap (#!)
	/// </summary>
	sealed class HotHeap20 : HotHeap {
		/// <inheritdoc/>
		public override HotHeapVersion HotHeapVersion {
			get { return HotHeapVersion.CLR20; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		public HotHeap20(MetaData metadata) : base(metadata) {
		}

		/// <inheritdoc/>
		public override HotTable CreateHotTable(IMDTable mdTable) {
			return new HotTable20(metadata, mdTable);
		}

		/// <inheritdoc/>
		public override HotPool CreateHotPool(HeapType heapType) {
			return new HotPool20(heapType);
		}
	}

	/// <summary>
	/// CLR 4.0 (.NET 4.0 - 4.5) hot heap (#!)
	/// </summary>
	sealed class HotHeap40 : HotHeap {
		/// <inheritdoc/>
		public override HotHeapVersion HotHeapVersion {
			get { return HotHeapVersion.CLR40; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		public HotHeap40(MetaData metadata) : base(metadata) {
		}

		/// <inheritdoc/>
		public override HotTable CreateHotTable(IMDTable mdTable) {
			return new HotTable40(metadata, mdTable);
		}

		/// <inheritdoc/>
		public override HotPool CreateHotPool(HeapType heapType) {
			return new HotPool40(heapType);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/HotPool.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet.MD;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Hot pool
	/// </summary>
	abstract class HotPool : IChunk {
		internal const uint HP_ALIGNMENT = 4;
		FileOffset offset;
		RVA rva;
		readonly HeapType heapType;
		Dictionary<uint, byte[]> allData;
		internal DataInfo[] dataList;
		int[] sortedIndexes;
		internal uint dataOffset;
		internal uint indexesOffset;
		internal uint ridsOffset;
		internal uint headerOffset;
		uint totalLength;
		bool indexesIsSorted;

		internal class DataInfo {
			public readonly uint HeapOffset;
			public uint PoolOffset;
			public readonly byte[] Data;
			public DataInfo(uint heapOffset, byte[] data) {
				this.HeapOffset = heapOffset;
				this.Data = data;
			}
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets the offset of the data relative to the start of this chunk. This is valid only
		/// after <see cref="SetOffset(FileOffset,RVA)"/> has been called.
		/// </summary>
		public uint DataOffset {
			get { return dataOffset; }
		}

		/// <summary>
		/// Gets the offset of the indexes relative to the start of this chunk. This is valid only
		/// after <see cref="SetOffset(FileOffset,RVA)"/> has been called.
		/// </summary>
		public uint IndexesOffset {
			get { return indexesOffset; }
		}

		/// <summary>
		/// Gets the offset of the rids relative to the start of this chunk. This is valid only
		/// after <see cref="SetOffset(FileOffset,RVA)"/> has been called.
		/// </summary>
		public uint RidsOffset {
			get { return ridsOffset; }
		}

		/// <summary>
		/// Gets the offset of the header relative to the start of this chunk. This is valid only
		/// after <see cref="SetOffset(FileOffset,RVA)"/> has been called.
		/// </summary>
		public uint HeaderOffset {
			get { return headerOffset; }
		}

		/// <summary>
		/// Gets the pool type
		/// </summary>
		public HeapType HeapType {
			get { return heapType; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="heapType">Pool type</param>
		internal HotPool(HeapType heapType) {
			this.heapType = heapType;
			this.allData = new Dictionary<uint, byte[]>();
		}

		/// <summary>
		/// Adds raw data
		/// </summary>
		/// <param name="offset">Offset of data in the original heap. If it's the #GUID, this
		/// should be <c>(index - 1) * 16</c>.</param>
		/// <param name="rawData"></param>
		public void Add(uint offset, byte[] rawData) {
			if (dataList != null)
				throw new InvalidOperationException("Can't Add() after CreateData() has been called");
			allData[offset] = rawData;
		}

		/// <summary>
		/// Creates <see cref="dataList"/> if it hasn't been created yet
		/// </summary>
		void CreateData() {
			if (dataList != null)
				return;

			dataList = new DataInfo[allData.Count];
			int i = 0;
			foreach (var kv in allData)
				dataList[i++] = new DataInfo(kv.Key, kv.Value);
			// Make sure it's sorted by heap offset
			Array.Sort(dataList, (a, b) => a.HeapOffset.CompareTo(b.HeapOffset));

			sortedIndexes = new int[allData.Count];
			for (i = 0; i < sortedIndexes.Length; i++)
				sortedIndexes[i] = i;

			allData = null;
			indexesIsSorted = false;
		}

		/// <summary>
		/// Creates the data and sorts it according to the original data's heap offsets
		/// </summary>
		public void SortData() {
			CreateData();
			Array.Sort(sortedIndexes, (a, b) => a.CompareTo(b));
			indexesIsSorted = true;
		}

		/// <summary>
		/// Creates the data and shuffles it
		/// </summary>
		public void ShuffleData() {
			ShuffleData(new Random());
		}

		/// <summary>
		/// Creates the data and shuffles it
		/// </summary>
		/// <param name="rand">Random number generator instance that should be used</param>
		public void ShuffleData(Random rand) {
			CreateData();

			int start = 0, len = sortedIndexes.Length;
			GetValidShuffleRange(ref start, ref len);
			Shuffle(rand, sortedIndexes, start, len);

			indexesIsSorted = true;
		}

		/// <summary>
		/// Returns the range that can be shuffled
		/// </summary>
		/// <param name="start">Start index</param>
		/// <param name="length">Length</param>
		internal virtual void GetValidShuffleRange(ref int start, ref int length) {
		}

		static void Shuffle<T>(Random rand, IList<T> list, int start, int count) {
			if (list == null || count <= 1)
				return;

			// Fisher-Yates algo, see http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
			for (int i = count - 1; i > 0; i--) {
				int j = rand.Next(i + 1);
				T tmp = list[start + i];
				list[start + i] = list[start + j];
				list[start + j] = tmp;
			}
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			CreateData();
			totalLength = SetOffsetImpl();
		}

		/// <summary>
		/// Initializes all offsets
		/// </summary>
		/// <returns>Total size of data</returns>
		internal abstract uint SetOffsetImpl();

		internal uint GetDataSize() {
			uint size = 0;
			foreach (var data in dataList)
				size += (uint)data.Data.Length;
			return size;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return totalLength;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			// Sort it unless it's already been sorted. Don't want random order
			// unless the user wants it.
			if (!indexesIsSorted)
				SortData();

			WriteToImpl(writer);
			dataList = null;
			sortedIndexes = null;
		}

		/// <summary>
		/// Writes all data
		/// </summary>
		internal abstract void WriteToImpl(BinaryWriter writer);

		internal DataInfo[] GetPoolDataOrder() {
			var dataList2 = (DataInfo[])dataList.Clone();
			Array.Sort(sortedIndexes, dataList2);
			uint offset = 0;
			foreach (var info in dataList2) {
				info.PoolOffset = offset;
				offset += (uint)info.Data.Length;
			}
			return dataList2;
		}
	}

	/// <summary>
	/// CLR 2.0 (.NET 2.0 - 3.5) hot pool writer
	/// </summary>
	sealed class HotPool20 : HotPool {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="heapType">Pool type</param>
		public HotPool20(HeapType heapType)
			: base(heapType) {
		}

		/// <inheritdoc/>
		internal override void GetValidShuffleRange(ref int start, ref int length) {
			// First one must always be first
			start++;
			length--;
		}

		/// <inheritdoc/>
		internal override uint SetOffsetImpl() {
			uint offs = 0;

			// data can be anywhere except where rids can be
			offs = Utils.AlignUp(offs, HP_ALIGNMENT);
			dataOffset = offs;
			offs += GetDataSize();

			// indexes can be anywhere except where rids can be
			offs = Utils.AlignUp(offs, HP_ALIGNMENT);
			indexesOffset = offs;
			offs += ((uint)dataList.Length - 1) * 4;

			// rids must be right before the header
			offs = Utils.AlignUp(offs, HP_ALIGNMENT);
			ridsOffset = offs;
			offs += (uint)dataList.Length * 4;

			offs = Utils.AlignUp(offs, HP_ALIGNMENT);
			headerOffset = offs;
			offs += 3 * 4;

			return offs;
		}

		/// <inheritdoc/>
		internal override void WriteToImpl(BinaryWriter writer) {
			uint offs = 0;
			long startPos = writer.BaseStream.Position;
			var dataList2 = GetPoolDataOrder();

			// Write data
			writer.WriteZeros((int)(dataOffset - offs));
			foreach (var kv in dataList2)
				writer.Write(kv.Data);
			offs = (uint)(writer.BaseStream.Position - startPos);

			// Write indexes (hot pool offsets)
			writer.WriteZeros((int)(indexesOffset - offs));
			if (dataList.Length > 1) {
				for (int i = 1; i < dataList.Length; i++)
					writer.Write(dataList[i].PoolOffset);
			}
			offs = (uint)(writer.BaseStream.Position - startPos);

			// Write rids (heap offsets)
			writer.WriteZeros((int)(ridsOffset - offs));
			foreach (var kv in dataList)
				writer.Write(kv.HeapOffset);
			offs = (uint)(writer.BaseStream.Position - startPos);

			// Write header
			writer.WriteZeros((int)(headerOffset - offs));
			writer.Write(headerOffset - dataOffset);	// any alignment
			writer.Write(headerOffset - indexesOffset);	// low 2 bits are ignored
			writer.Write(headerOffset - ridsOffset);	// low 2 bits are ignored
		}
	}

	/// <summary>
	/// CLR 4.0 (.NET 4.0 - 4.5) hot pool writer
	/// </summary>
	sealed class HotPool40 : HotPool {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="heapType">Pool type</param>
		public HotPool40(HeapType heapType)
			: base(heapType) {
		}

		/// <inheritdoc/>
		internal override uint SetOffsetImpl() {
			uint offs = 0;

			// data can be anywhere except where rids can be
			offs = Utils.AlignUp(offs, HP_ALIGNMENT);
			dataOffset = offs;
			offs += GetDataSize();

			// indexes can be anywhere except where rids can be
			offs = Utils.AlignUp(offs, HP_ALIGNMENT);
			indexesOffset = offs;
			offs += (uint)dataList.Length * 4;

			// rids must be right before the header
			offs = Utils.AlignUp(offs, HP_ALIGNMENT);
			ridsOffset = offs;
			offs += (uint)dataList.Length * 4;

			offs = Utils.AlignUp(offs, HP_ALIGNMENT);
			headerOffset = offs;
			offs += 3 * 4;

			return offs;
		}

		/// <inheritdoc/>
		internal override void WriteToImpl(BinaryWriter writer) {
			uint offs = 0;
			long startPos = writer.BaseStream.Position;
			var dataList2 = GetPoolDataOrder();

			// Write data
			writer.WriteZeros((int)(dataOffset - offs));
			foreach (var info in dataList2)
				writer.Write(info.Data);
			offs = (uint)(writer.BaseStream.Position - startPos);

			// Write indexes (hot pool offsets)
			writer.WriteZeros((int)(indexesOffset - offs));
			foreach (var info in dataList)
				writer.Write(info.PoolOffset);
			offs = (uint)(writer.BaseStream.Position - startPos);

			// Write rids (heap offsets)
			writer.WriteZeros((int)(ridsOffset - offs));
			foreach (var kv in dataList)
				writer.Write(kv.HeapOffset);
			offs = (uint)(writer.BaseStream.Position - startPos);

			// Write header
			writer.WriteZeros((int)(headerOffset - offs));
			writer.Write(headerOffset - ridsOffset);	// must be 4-byte aligned
			writer.Write(headerOffset - indexesOffset);	// must be 4-byte aligned
			writer.Write(headerOffset - dataOffset);	// any alignment
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/HotTable.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.DotNet.MD;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Hot metadata table base class
	/// </summary>
	public abstract class HotTable : IChunk {
		/// <summary>
		/// At most 64K rows can be used when only a partial table is stored in the
		/// hot table. The first level table indexes into the second level table,
		/// and the index is 16 bits.
		/// </summary>
		public const int MAX_ROWS = 0x10000;
		internal const uint HT_ALIGNMENT = 4;

		FileOffset offset;
		RVA rva;

		readonly MetaData metadata;
		internal readonly IMDTable mdTable;
		readonly HotHeapVersion version;
		readonly int hotTableHeaderSize;
		internal readonly int alignedHotTableHeaderSize;
		uint totalLength;

		// full table fields
		byte[] data;

		// partial table fields
		internal List<uint> rids;
		internal Dictionary<uint, byte[]> partialData;
		internal int shift;
		uint mask;
		internal ushort[] firstLevelTable;
		internal byte[] secondLevelTable;
		internal uint dataOffset;
		internal uint firstLevelOffset;
		internal uint secondLevelOffset;

		/// <summary>
		/// <c>true</c> if we can write a partial table, <c>false</c> if we must write
		/// the full table.
		/// </summary>
		public bool CanWritePartialTable {
			get {
				return data == null && rids != null && rids.Count <= MAX_ROWS;
			}
		}

		/// <summary>
		/// Gets the full size of the table
		/// </summary>
		uint FullTableSize {
			get { return (uint)(mdTable.Rows * mdTable.TableInfo.RowSize); }
		}

		/// <summary>
		/// Gets the table type
		/// </summary>
		public Table Table {
			get { return mdTable.Table; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		/// <param name="version">Hot heap version</param>
		/// <param name="mdTable">The MD table</param>
		internal HotTable(MetaData metadata, HotHeapVersion version, IMDTable mdTable) {
			this.metadata = metadata;
			this.mdTable = mdTable;
			this.version = version;

			switch (version) {
			case HotHeapVersion.CLR20:
				hotTableHeaderSize = 0x12;
				break;
			case HotHeapVersion.CLR40:
				hotTableHeaderSize = 0x16;
				break;
			default:
				throw new ArgumentException("Invalid hot heap version");
			}

			this.alignedHotTableHeaderSize = Utils.AlignUp(this.hotTableHeaderSize, HT_ALIGNMENT);
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			mdTable.SetReadOnly();
			if (CanWritePartialTable) {
				InitializePartialData();
				totalLength = CalculatePartialTableLength();
			}
			else
				totalLength = CalculateFullTableLength();
		}

		/// <summary>
		/// Calculates the total size required to write a partial table. It is only called if
		/// the partial table will be written.
		/// </summary>
		internal abstract uint CalculatePartialTableLength();

		/// <summary>
		/// Calculates the total size required to write a full table. It is only called if
		/// the full table will be written.
		/// </summary>
		uint CalculateFullTableLength() {
			return (uint)alignedHotTableHeaderSize + FullTableSize;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return totalLength;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <summary>
		/// Adds a row. This method must be called to write a partial table. If too many rows
		/// are added (see <see cref="MAX_ROWS"/>), then the full table will be written. If this
		/// method is never called, a full table will be written.
		/// </summary>
		/// <param name="rid">The row ID. This must be the new rid, so this method can only be
		/// called after the table row has been assigned a new rid.</param>
		public void Add(uint rid) {
			if (totalLength != 0)
				throw new InvalidOperationException("Can't call Add() after SetOffset() has been called");
			if (partialData != null || data != null)
				throw new InvalidOperationException("Can't add data when full/partial data has been created");
			if (rid == 0 || rid > (uint)mdTable.Rows)
				return;
			if (rids == null)
				rids = new List<uint>();
			rids.Add(rid);
		}

		/// <summary>
		/// Calls the <see cref="IMDTable"/> to write all its rows to a buffer. This is the data
		/// that will be written to this hot table. If this is not explicitly called, it will
		/// be implicitly called later when all data must be written. The table will be set to
		/// read-only. If this method is called, all data will be written to the heap even if
		/// <see cref="Add(uint)"/> has been called.
		/// </summary>
		public void CreateFullData() {
			mdTable.SetReadOnly();
			rids = null;
			if (data != null)
				return;

			data = new byte[FullTableSize];
			var writer = new BinaryWriter(new MemoryStream(data));
			writer.Write(metadata, mdTable);
			if (writer.BaseStream.Position != data.Length)
				throw new InvalidOperationException("Didn't write all MD table data");
		}

		/// <summary>
		/// Creates the partial data of all rows that have been <see cref="Add"/>'d so far.
		/// If a partial table can't be created, <see cref="CreateFullData"/> is automatically
		/// called instead. If this method isn't explicitly called, it will be implicitly called
		/// later when the partial data must be written. The table will be set to read-only.
		/// </summary>
		public void CreatePartialData() {
			mdTable.SetReadOnly();
			if (!CanWritePartialTable) {
				CreateFullData();
				return;
			}
			InitializePartialData();
			var memStream = new MemoryStream(mdTable.TableInfo.RowSize);
			var writer = new BinaryWriter(memStream);
			foreach (var rid in rids) {
				memStream.Position = 0;
				var row = mdTable.Get(rid);
				writer.Write(metadata, mdTable, row);
				partialData[rid] = memStream.ToArray();
			}
		}

		void InitializePartialData() {
			if (partialData != null)
				return;

			partialData = new Dictionary<uint, byte[]>(rids.Count);
			foreach (var rid in rids)
				partialData[rid] = null;
			InitializePartialRids();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			if (CanWritePartialTable)
				PartialWriteTo(writer);
			else
				FullWriteTo(writer);

			firstLevelTable = null;
			secondLevelTable = null;
			partialData = null;
			rids = null;
			data = null;
		}

		/// <summary>
		/// Writes the full table to the hot table
		/// </summary>
		/// <param name="writer">Writer</param>
		void FullWriteTo(BinaryWriter writer) {
			CreateFullData();

			var startPos = writer.BaseStream.Position;
			writer.Write(mdTable.Rows);	// hot records
			writer.Write(0);			// offset of 1st level table
			writer.Write(0);			// offset of 2nd level table
			if (version == HotHeapVersion.CLR40)
				writer.Write(0);		// offset of indexes table
			writer.Write(alignedHotTableHeaderSize);	// offset of hot data (4-byte aligned)
			writer.Write((ushort)0);	// shift count
			writer.WriteZeros(alignedHotTableHeaderSize - (int)(writer.BaseStream.Position - startPos));
			writer.Write(data);
		}

		/// <summary>
		/// Writes the partial table to the hot table
		/// </summary>
		/// <param name="writer">Writer</param>
		internal abstract void PartialWriteTo(BinaryWriter writer);

		static int CountMaxBits(uint val) {
			int bits = 0;
			while (val != 0) {
				val >>= 1;
				bits++;
			}
			return bits;
		}

		void InitializePartialRids() {
			shift = CalculateShift();
			mask = (1U << shift) - 1;
			SortRids();
			CreateFirstAndSecondLevelTables();
		}

		int CalculateShift() {
			mdTable.SetReadOnly();
			int maxBits = CountMaxBits((uint)mdTable.Rows);
			if (maxBits >= 16)
				return maxBits - 8;
			else
				return maxBits / 2;
		}

		void SortRids() {
			// Make sure dupes are removed
			rids.Clear();
			rids.AddRange(partialData.Keys);

			rids.Sort((a, b) => {
				uint la = a & mask;
				uint lb = b & mask;
				if (la != lb)
					return la.CompareTo(lb);
				return (a >> shift).CompareTo(b >> shift);
			});
		}

		void CreateFirstAndSecondLevelTables() {
			// rids has already been sorted, first on lower bits, then on upper bits
			firstLevelTable = new ushort[(1 << shift) + 1];
			int prevRid = 0, i2 = 0;
			for (; i2 < partialData.Count; i2++) {
				int rid = (int)(rids[i2] & mask);
				while (prevRid <= rid)
					firstLevelTable[prevRid++] = (ushort)i2;
			}
			while (prevRid < firstLevelTable.Length)
				firstLevelTable[prevRid++] = (ushort)i2;

			secondLevelTable = new byte[partialData.Count];
			for (int i = 0; i < secondLevelTable.Length; i++)
				secondLevelTable[i] = (byte)(rids[i] >> shift);
		}

		/// <summary>
		/// Writes the data
		/// </summary>
		/// <param name="writer">Writer</param>
		internal void WritePartialData(BinaryWriter writer) {
			foreach (var rid in rids)
				writer.Write(partialData[rid]);
		}

		/// <summary>
		/// Writes the first level table
		/// </summary>
		/// <param name="writer">Writer</param>
		internal void WriteFirstLevelTable(BinaryWriter writer) {
			foreach (var s in firstLevelTable)
				writer.Write(s);
		}

		/// <summary>
		/// Writes the second level table
		/// </summary>
		/// <param name="writer">Writer</param>
		internal void WriteSecondLevelTable(BinaryWriter writer) {
			writer.Write(secondLevelTable);
		}
	}

	/// <summary>
	/// CLR 2.0 (.NET 2.0 - 3.5) hot table
	/// </summary>
	sealed class HotTable20 : HotTable {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		/// <param name="mdTable">The MD table</param>
		public HotTable20(MetaData metadata, IMDTable mdTable)
			: base(metadata, HotHeapVersion.CLR20, mdTable) {
		}

		/// <inheritdoc/>
		internal override uint CalculatePartialTableLength() {
			uint len = 0;

			len += (uint)alignedHotTableHeaderSize;

			// Data
			len = Utils.AlignUp(len, HT_ALIGNMENT);
			dataOffset = len;
			len += (uint)(partialData.Count * mdTable.TableInfo.RowSize);

			// First level table
			len = Utils.AlignUp(len, HT_ALIGNMENT);
			firstLevelOffset = len;
			len += (uint)(firstLevelTable.Length * 2);

			// Second level table
			len = Utils.AlignUp(len, HT_ALIGNMENT);
			secondLevelOffset = len;
			len += (uint)secondLevelTable.Length;

			return len;
		}

		/// <inheritdoc/>
		internal override void PartialWriteTo(BinaryWriter writer) {
			var startPos = writer.BaseStream.Position;
			writer.Write(partialData.Count);// hot records
			writer.Write(firstLevelOffset);	// any alignment, all bits are used
			writer.Write(secondLevelOffset);// any alignment, all bits are used
			writer.Write(dataOffset);	// any alignment, all bits are used
			writer.Write((ushort)shift);// shift count
			writer.WriteZeros(alignedHotTableHeaderSize - (int)(writer.BaseStream.Position - startPos));

			uint offs;

			// Data
			offs = (uint)(writer.BaseStream.Position - startPos);
			writer.WriteZeros((int)(dataOffset - offs));
			WritePartialData(writer);

			// First level table
			offs = (uint)(writer.BaseStream.Position - startPos);
			writer.WriteZeros((int)(firstLevelOffset - offs));
			WriteFirstLevelTable(writer);

			// Second level table
			offs = (uint)(writer.BaseStream.Position - startPos);
			writer.WriteZeros((int)(secondLevelOffset - offs));
			WriteSecondLevelTable(writer);
		}
	}

	/// <summary>
	/// CLR 4.0 (.NET 4.0 - 4.5) partial hot table
	/// </summary>
	sealed class HotTable40 : HotTable {
		uint indexesOffset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		/// <param name="mdTable">The MD table</param>
		public HotTable40(MetaData metadata, IMDTable mdTable)
			: base(metadata, HotHeapVersion.CLR40, mdTable) {
		}

		/// <inheritdoc/>
		internal override uint CalculatePartialTableLength() {
			uint len = 0;

			len += (uint)alignedHotTableHeaderSize;

			// Data
			len = Utils.AlignUp(len, HT_ALIGNMENT);
			dataOffset = len;
			len += (uint)(partialData.Count * mdTable.TableInfo.RowSize);

			// First level table
			len = Utils.AlignUp(len, HT_ALIGNMENT);
			firstLevelOffset = len;
			len += (uint)(firstLevelTable.Length * 2);

			// Second level table
			len = Utils.AlignUp(len, HT_ALIGNMENT);
			secondLevelOffset = len;
			len += (uint)secondLevelTable.Length;

			// Indexes table
			len = Utils.AlignUp(len, HT_ALIGNMENT);
			indexesOffset = len;
			len += (uint)(partialData.Count * 2);

			return len;
		}

		/// <inheritdoc/>
		internal override void PartialWriteTo(BinaryWriter writer) {
			var startPos = writer.BaseStream.Position;
			writer.Write(partialData.Count);// hot records
			writer.Write(firstLevelOffset);	// any alignment, all bits are used
			writer.Write(secondLevelOffset);// any alignment, all bits are used
			writer.Write(indexesOffset);// any alignment, all bits are used
			writer.Write(dataOffset);	// any alignment, all bits are used
			writer.Write((ushort)shift);// shift count
			writer.WriteZeros(alignedHotTableHeaderSize - (int)(writer.BaseStream.Position - startPos));

			uint offs;

			// Data
			offs = (uint)(writer.BaseStream.Position - startPos);
			writer.WriteZeros((int)(dataOffset - offs));
			WritePartialData(writer);

			// First level table
			offs = (uint)(writer.BaseStream.Position - startPos);
			writer.WriteZeros((int)(firstLevelOffset - offs));
			WriteFirstLevelTable(writer);

			// Second level table
			offs = (uint)(writer.BaseStream.Position - startPos);
			writer.WriteZeros((int)(secondLevelOffset - offs));
			WriteSecondLevelTable(writer);

			// Indexes table
			offs = (uint)(writer.BaseStream.Position - startPos);
			writer.WriteZeros((int)(indexesOffset - offs));
			WriteIndexesTable(writer);
		}

		void WriteIndexesTable(BinaryWriter writer) {
			for (int i = 0; i < partialData.Count; i++)
				writer.Write((ushort)i);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/IChunk.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Data that gets written to the file
	/// </summary>
	public interface IChunk {
		/// <summary>
		/// Gets the file offset. This is valid only after <see cref="SetOffset"/> has been called.
		/// </summary>
		FileOffset FileOffset { get; }

		/// <summary>
		/// Gets the RVA. This is valid only after <see cref="SetOffset"/> has been called.
		/// </summary>
		RVA RVA { get; }

		/// <summary>
		/// Called when the file offset and RVA are known
		/// </summary>
		/// <param name="offset">File offset of this chunk</param>
		/// <param name="rva">RVA of this chunk</param>
		void SetOffset(FileOffset offset, RVA rva);

		/// <summary>
		/// Gets the raw file length of this chunk. Must only be called after <see cref="SetOffset"/>
		/// has been called.
		/// </summary>
		/// <returns>Length of this chunk</returns>
		uint GetFileLength();

		/// <summary>
		/// Gets the virtual size of this chunk. Must only be called after <see cref="SetOffset"/>
		/// has been called.
		/// </summary>
		/// <returns>Virtual size of this chunk</returns>
		uint GetVirtualSize();

		/// <summary>
		/// Writes all data to <paramref name="writer"/> at its current location. It's only
		/// called after <see cref="SetOffset"/> and <see cref="GetFileLength"/> have been called.
		/// You cannot assume that <paramref name="writer"/>'s file position is the same as this
		/// chunk's file position.
		/// </summary>
		/// <param name="writer">Destination</param>
		void WriteTo(BinaryWriter writer);
	}

	public static partial class Extensions {
		/// <summary>
		/// Writes all data to <paramref name="writer"/> and verifies that all bytes were written
		/// </summary>
		/// <param name="chunk">this</param>
		/// <param name="writer">Destination</param>
		/// <exception cref="IOException">Not all bytes were written</exception>
		public static void VerifyWriteTo(this IChunk chunk, BinaryWriter writer) {
			long pos = writer.BaseStream.Position;
			// Uncomment this to add some debug info, useful when comparing old vs new version
			//System.Diagnostics.Debug.WriteLine(string.Format(" RVA 0x{0:X8} OFFS 0x{1:X8} VSIZE 0x{2:X8} {3}", (uint)chunk.RVA, (uint)chunk.FileOffset, chunk.GetVirtualSize(), chunk.GetType().FullName));
			chunk.WriteTo(writer);
			if (writer.BaseStream.Position - pos != chunk.GetFileLength())
				throw new IOException("Did not write all bytes");
		}

		/// <summary>
		/// Writes a data directory
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="chunk">The data</param>
		internal static void WriteDataDirectory(this BinaryWriter writer, IChunk chunk) {
			if (chunk == null || chunk.GetVirtualSize() == 0)
				writer.Write(0UL);
			else {
				writer.Write((uint)chunk.RVA);
				writer.Write(chunk.GetVirtualSize());
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/IHeap.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Writer {
	/// <summary>
	/// .NET Heap interface
	/// </summary>
	public interface IHeap : IChunk {
		/// <summary>
		/// Gets the name of the heap
		/// </summary>
		string Name { get; }

		/// <summary>
		/// Checks whether the heap is empty
		/// </summary>
		bool IsEmpty { get; }

		/// <summary>
		/// Called when the heap should be set to read-only mode
		/// </summary>
		void SetReadOnly();
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/IMetaDataListener.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Gets notified of various events when writing the metadata
	/// </summary>
	public interface IMetaDataListener {
		/// <summary>
		/// Called by <see cref="MetaData"/>
		/// </summary>
		/// <param name="metaData">The metadata</param>
		/// <param name="evt">Type of metadata event</param>
		void OnMetaDataEvent(MetaData metaData, MetaDataEvent evt);
	}

	/// <summary>
	/// A <see cref="IMetaDataListener"/> which does nothing
	/// </summary>
	public sealed class DummyMetaDataListener : IMetaDataListener {
		/// <summary>
		/// An instance of this dummy listener
		/// </summary>
		public static readonly DummyMetaDataListener Instance = new DummyMetaDataListener();

		/// <inheritdoc/>
		public void OnMetaDataEvent(MetaData metaData, MetaDataEvent evt) {
		}
	}

	/// <summary>
	/// All <see cref="MetaData"/> events
	/// </summary>
	public enum MetaDataEvent {
		/// <summary>
		/// Creating the tables has just begun
		/// </summary>
		BeginCreateTables,

		/// <summary>
		/// Before allocating all TypeDef RIDs
		/// </summary>
		AllocateTypeDefRids,

		/// <summary>
		/// Before allocating all MemberDef RIDs
		/// </summary>
		AllocateMemberDefRids,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		AllocateMemberDefRids0,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		AllocateMemberDefRids1,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		AllocateMemberDefRids2,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		AllocateMemberDefRids3,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		AllocateMemberDefRids4,

		/// <summary>
		/// The <c>rid</c>s of types, fields, methods, events, properties and parameters are
		/// now known.
		/// </summary>
		MemberDefRidsAllocated,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		InitializeTypeDefsAndMemberDefs0,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		InitializeTypeDefsAndMemberDefs1,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		InitializeTypeDefsAndMemberDefs2,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		InitializeTypeDefsAndMemberDefs3,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		InitializeTypeDefsAndMemberDefs4,

		/// <summary>
		/// The tables and rows of all types, fields, methods, events, properties and parameters
		/// have been initialized. Method body RVAs are still not known, and no method has been
		/// written yet.
		/// </summary>
		MemberDefsInitialized,

		/// <summary>
		/// Before sorting most tables
		/// </summary>
		BeforeSortTables,

		/// <summary>
		/// Most of the tables that should be sorted have been sorted. The <c>CustomAttribute</c>
		/// table is still unsorted since it's not been created yet.
		/// </summary>
		MostTablesSorted,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteTypeDefAndMemberDefCustomAttributes0,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteTypeDefAndMemberDefCustomAttributes1,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteTypeDefAndMemberDefCustomAttributes2,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteTypeDefAndMemberDefCustomAttributes3,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteTypeDefAndMemberDefCustomAttributes4,

		/// <summary>
		/// Custom attributes of all types, fields, methods, events, properties and parameters
		/// have now been written.
		/// </summary>
		MemberDefCustomAttributesWritten,

		/// <summary>
		/// All resources are about to be added to the .NET resources table
		/// </summary>
		BeginAddResources,

		/// <summary>
		/// All resources have been added to the .NET resources table
		/// </summary>
		EndAddResources,

		/// <summary>
		/// All method bodies are about to be written
		/// </summary>
		BeginWriteMethodBodies,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies0,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies1,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies2,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies3,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies4,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies5,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies6,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies7,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies8,

		/// <summary>
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		WriteMethodBodies9,

		/// <summary>
		/// All method bodies have been written. Their RVAs are still not known.
		/// </summary>
		EndWriteMethodBodies,

		/// <summary>
		/// All tables are now sorted, including the <c>CustomAttribute</c> table.
		/// </summary>
		OnAllTablesSorted,

		/// <summary>
		/// All tables have been created and all rows populated. The only columns that haven't
		/// been initialized yet are the ones that are RVAs.
		/// </summary>
		EndCreateTables,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/IModuleWriterListener.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Gets notified of various events when writing a module
	/// </summary>
	public interface IModuleWriterListener {
		/// <summary>
		/// Called by <see cref="ModuleWriterBase"/> and its sub classes.
		/// </summary>
		/// <param name="writer">The module writer</param>
		/// <param name="evt">Type of writer event</param>
		void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt);
	}

	/// <summary>
	/// A <see cref="IModuleWriterListener"/> which does nothing
	/// </summary>
	public sealed class DummyModuleWriterListener : IModuleWriterListener {
		/// <summary>
		/// An instance of this dummy listener
		/// </summary>
		public static readonly DummyModuleWriterListener Instance = new DummyModuleWriterListener();

		/// <inheritdoc/>
		public void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt) {
		}
	}

	/// <summary>
	/// All <see cref="ModuleWriter"/> / <see cref="NativeModuleWriter"/> events
	/// </summary>
	public enum ModuleWriterEvent {
		/// <summary>
		/// Writing has just begun
		/// </summary>
		Begin,

		/// <summary>
		/// All PE sections have been created
		/// </summary>
		PESectionsCreated,

		/// <summary>
		/// All chunks have been created
		/// </summary>
		ChunksCreated,

		/// <summary>
		/// All chunks have been added to their sections
		/// </summary>
		ChunksAddedToSections,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.BeginCreateTables"/>.
		/// Creating the metadata tables has just begun
		/// </summary>
		MDBeginCreateTables,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.AllocateTypeDefRids"/>.
		/// Before allocating all TypeDef RIDs
		/// </summary>
		MDAllocateTypeDefRids,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.AllocateMemberDefRids"/>.
		/// Before allocating all MemberDef RIDs
		/// </summary>
		MDAllocateMemberDefRids,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.AllocateMemberDefRids0"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDAllocateMemberDefRids0,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.AllocateMemberDefRids1"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDAllocateMemberDefRids1,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.AllocateMemberDefRids2"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDAllocateMemberDefRids2,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.AllocateMemberDefRids3"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDAllocateMemberDefRids3,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.AllocateMemberDefRids4"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDAllocateMemberDefRids4,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.MemberDefRidsAllocated"/>.
		/// The <c>rid</c>s of types, fields, methods, events, properties and parameters are
		/// now known.
		/// </summary>
		MDMemberDefRidsAllocated,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.InitializeTypeDefsAndMemberDefs0"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDInitializeTypeDefsAndMemberDefs0,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.InitializeTypeDefsAndMemberDefs1"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDInitializeTypeDefsAndMemberDefs1,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.InitializeTypeDefsAndMemberDefs2"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDInitializeTypeDefsAndMemberDefs2,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.InitializeTypeDefsAndMemberDefs3"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDInitializeTypeDefsAndMemberDefs3,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.InitializeTypeDefsAndMemberDefs4"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDInitializeTypeDefsAndMemberDefs4,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.MemberDefsInitialized"/>.
		/// The tables and rows of all types, fields, methods, events, properties and parameters
		/// have been initialized. Method body RVAs are still not known, and no method has been
		/// written yet.
		/// </summary>
		MDMemberDefsInitialized,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.BeforeSortTables"/>.
		/// Before sorting most tables
		/// </summary>
		MDBeforeSortTables,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.MostTablesSorted"/>.
		/// Most of the tables that should be sorted have been sorted. The <c>CustomAttribute</c>
		/// table is still unsorted since it's not been created yet.
		/// </summary>
		MDMostTablesSorted,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes0"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteTypeDefAndMemberDefCustomAttributes0,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes1"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteTypeDefAndMemberDefCustomAttributes1,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes2"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteTypeDefAndMemberDefCustomAttributes2,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes3"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteTypeDefAndMemberDefCustomAttributes3,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes4"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteTypeDefAndMemberDefCustomAttributes4,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.MemberDefCustomAttributesWritten"/>.
		/// Custom attributes of all types, fields, methods, events, properties and parameters
		/// have now been written.
		/// </summary>
		MDMemberDefCustomAttributesWritten,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.BeginAddResources"/>.
		/// All resources are about to be added to the .NET resources table
		/// </summary>
		MDBeginAddResources,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.EndAddResources"/>.
		/// All resources have been added to the .NET resources table
		/// </summary>
		MDEndAddResources,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.BeginWriteMethodBodies"/>.
		/// All method bodies are about to be written
		/// </summary>
		MDBeginWriteMethodBodies,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies0"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies0,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies1"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies1,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies2"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies2,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies3"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies3,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies4"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies4,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies5"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies5,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies6"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies6,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies7"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies7,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies8"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies8,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.WriteMethodBodies9"/>.
		/// Sent by the metadata writer so a UI can update its progress bar
		/// </summary>
		MDWriteMethodBodies9,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.EndWriteMethodBodies"/>.
		/// All method bodies have been written. Their RVAs are still not known.
		/// </summary>
		MDEndWriteMethodBodies,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.OnAllTablesSorted"/>.
		/// All tables are now sorted, including the <c>CustomAttribute</c> table.
		/// </summary>
		MDOnAllTablesSorted,

		/// <summary>
		/// Original event: <see cref="MetaDataEvent.EndCreateTables"/>.
		/// All tables have been created and all rows populated. The only columns that haven't
		/// been initialized yet are the ones that are RVAs.
		/// </summary>
		MDEndCreateTables,

		/// <summary>
		/// This event occurs before the PDB file is written. This event occurs even if no PDB file
		/// will be written.
		/// </summary>
		BeginWritePdb,

		/// <summary>
		/// The PDB file has been written. This event occurs even if no PDB file has been written.
		/// </summary>
		EndWritePdb,

		/// <summary>
		/// This event occurs just before all RVAs and file offsets of the chunks are calculated.
		/// </summary>
		BeginCalculateRvasAndFileOffsets,

		/// <summary>
		/// File offsets and RVAs of all chunks are now known. This includes method body and
		/// field RVAs. Nothing has been written to the destination stream yet.
		/// </summary>
		EndCalculateRvasAndFileOffsets,

		/// <summary>
		/// This event occurs before all chunks are written to the destination stream, and after
		/// all RVAs and file offsets are known.
		/// </summary>
		BeginWriteChunks,

		/// <summary>
		/// All chunks have been written to the destination stream.
		/// </summary>
		EndWriteChunks,

		/// <summary>
		/// This event occurs before the strong name signature is calculated. This event
		/// occurs even if the assembly isn't strong name signed.
		/// </summary>
		BeginStrongNameSign,

		/// <summary>
		/// This event occurs after the strong name signature has been calculated. This event
		/// occurs even if the assembly isn't strong name signed.
		/// </summary>
		EndStrongNameSign,

		/// <summary>
		/// This event occurs before the checksum in the PE header is updated. This event
		/// occurs even if the checksum isn't updated.
		/// </summary>
		BeginWritePEChecksum,

		/// <summary>
		/// This event occurs after the checksum in the PE header has been updated. This event
		/// occurs even if the checksum isn't updated.
		/// </summary>
		EndWritePEChecksum,

		/// <summary>
		/// Writing has ended
		/// </summary>
		End,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/IOffsetHeap.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Interface to get and set raw heap data. Implemented by the offset heaps: #Strings,
	/// #GUID, #Blob, and #US.
	/// </summary>
	/// <typeparam name="TValue">Type of cooked data</typeparam>
	public interface IOffsetHeap<TValue> {
		/// <summary>
		/// Gets the size of the data as raw data when written to the heap
		/// </summary>
		/// <param name="data">The data</param>
		/// <returns>Size of the data as raw data when written to the heap</returns>
		int GetRawDataSize(TValue data);

		/// <summary>
		/// Overrides what value should be written to the heap.
		/// </summary>
		/// <param name="offset">Offset of value. Must match an offset returned by
		/// <see cref="GetAllRawData()"/></param>
		/// <param name="rawData">The new raw data. The size must match the raw size exactly.</param>
		void SetRawData(uint offset, byte[] rawData);

		/// <summary>
		/// Gets all inserted raw data and their offsets. The returned <see cref="byte"/> array
		/// is owned by the caller.
		/// </summary>
		/// <returns>An enumerable of all raw data and their offsets</returns>
		IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData();
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/IWriterError.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Gets notified of errors. The default handler should normally throw since the written data
	/// will probably be invalid. Any error can be ignored.
	/// </summary>
	public interface IWriterError {
		/// <summary>
		/// Called when an error is detected (eg. a null pointer or other invalid value). The error
		/// can be ignored but the written data won't be valid.
		/// </summary>
		/// <param name="message">Error message</param>
		void Error(string message);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ImageCor20Header.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using dnlib.IO;
using dnlib.PE;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Options to <see cref="ImageCor20Header"/>
	/// </summary>
	public sealed class Cor20HeaderOptions {
		/// <summary>
		/// Default major runtime version
		/// </summary>
		public const ushort DEFAULT_MAJOR_RT_VER = 2;

		/// <summary>
		/// Default minor runtime version
		/// </summary>
		public const ushort DEFAULT_MINOR_RT_VER = 5;

		/// <summary>
		/// Major runtime version
		/// </summary>
		public ushort? MajorRuntimeVersion;

		/// <summary>
		/// Minor runtime version
		/// </summary>
		public ushort? MinorRuntimeVersion;

		/// <summary>
		/// Flags
		/// </summary>
		public ComImageFlags? Flags;

		/// <summary>
		/// Entry point or <c>null</c>. Either a Method/File token or an RVA.
		/// </summary>
		public uint? EntryPoint;

		/// <summary>
		/// Default constructor
		/// </summary>
		public Cor20HeaderOptions() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Flags</param>
		public Cor20HeaderOptions(ComImageFlags flags) {
			this.Flags = flags;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="major">Major runtime version (default is <see cref="DEFAULT_MAJOR_RT_VER"/>)</param>
		/// <param name="minor">Minor runtime version (default is <see cref="DEFAULT_MINOR_RT_VER"/>)</param>
		/// <param name="flags">Flags</param>
		public Cor20HeaderOptions(ushort major, ushort minor, ComImageFlags flags) {
			this.MajorRuntimeVersion = major;
			this.MinorRuntimeVersion = minor;
			this.Flags = flags;
		}
	}

	/// <summary>
	/// .NET header
	/// </summary>
	public sealed class ImageCor20Header : IChunk {
		FileOffset offset;
		RVA rva;
		Cor20HeaderOptions options;

		/// <summary>
		/// Gets/sets the <see cref="MetaData"/>
		/// </summary>
		public MetaData MetaData { get; set; }

		/// <summary>
		/// Gets/sets the .NET resources
		/// </summary>
		public NetResources NetResources { get; set; }

		/// <summary>
		/// Gets/sets the strong name signature
		/// </summary>
		public StrongNameSignature StrongNameSignature { get; set; }

		internal IChunk VtableFixups { get; set; }

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Options</param>
		public ImageCor20Header(Cor20HeaderOptions options) {
			this.options = options;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return 0x48;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			writer.Write(0x48);	// cb
			writer.Write(options.MajorRuntimeVersion ?? Cor20HeaderOptions.DEFAULT_MAJOR_RT_VER);
			writer.Write(options.MinorRuntimeVersion ?? Cor20HeaderOptions.DEFAULT_MINOR_RT_VER);
			writer.WriteDataDirectory(MetaData);
			writer.Write((uint)(options.Flags ?? ComImageFlags.ILOnly));
			writer.Write(options.EntryPoint ?? 0);
			writer.WriteDataDirectory(NetResources);
			writer.WriteDataDirectory(StrongNameSignature);
			writer.WriteDataDirectory(null);	// Code manager table
			writer.WriteDataDirectory(VtableFixups);
			writer.WriteDataDirectory(null);	// Export address table jumps
			writer.WriteDataDirectory(null);	// Managed native header
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ImportAddressTable.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Import address table chunk
	/// </summary>
	public sealed class ImportAddressTable : IChunk {
		readonly bool is64bit;
		FileOffset offset;
		RVA rva;

		/// <summary>
		/// Gets/sets the <see cref="ImportDirectory"/>
		/// </summary>
		public ImportDirectory ImportDirectory { get; set; }

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		internal bool Enable { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="is64bit">true if it's a 64-bit PE file, false if it's a 32-bit PE file</param>
		public ImportAddressTable(bool is64bit) {
			this.is64bit = is64bit;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			if (!Enable)
				return 0;
			return is64bit ? 16U : 8;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			if (!Enable)
				return;
			if (is64bit) {
				writer.Write((ulong)(uint)ImportDirectory.CorXxxMainRVA);
				writer.Write(0UL);
			}
			else {
				writer.Write((uint)ImportDirectory.CorXxxMainRVA);
				writer.Write(0);
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ImportDirectory.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using System.Text;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Import directory chunk
	/// </summary>
	public sealed class ImportDirectory : IChunk {
		readonly bool is64bit;
		FileOffset offset;
		RVA rva;
		bool isExeFile;
		uint length;
		RVA importLookupTableRVA;
		RVA corXxxMainRVA;
		RVA mscoreeDllRVA;
		int stringsPadding;

		/// <summary>
		/// Gets/sets the <see cref="ImportAddressTable"/>
		/// </summary>
		public ImportAddressTable ImportAddressTable { get; set; }

		/// <summary>
		/// Gets the RVA of _CorDllMain/_CorExeMain in the import lookup table
		/// </summary>
		public RVA CorXxxMainRVA {
			get { return corXxxMainRVA; }
		}

		/// <summary>
		/// Gets RVA of _CorExeMain/_CorDllMain in the IAT
		/// </summary>
		public RVA IatCorXxxMainRVA {
			get { return ImportAddressTable.RVA; }
		}

		/// <summary>
		/// Gets/sets a value indicating whether this is a EXE or a DLL file
		/// </summary>
		public bool IsExeFile {
			get { return isExeFile; }
			set { isExeFile = value; }
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		internal bool Enable { get; set; }

		const uint STRINGS_ALIGNMENT = 16;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="is64bit">true if it's a 64-bit PE file, false if it's a 32-bit PE file</param>
		public ImportDirectory(bool is64bit) {
			this.is64bit = is64bit;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			length = 0x28;
			importLookupTableRVA = rva + length;
			length += is64bit ? 16U : 8;

			stringsPadding = (int)(rva.AlignUp(STRINGS_ALIGNMENT) - rva);
			length += (uint)stringsPadding;
			corXxxMainRVA = rva + length;
			length += 0xE;
			mscoreeDllRVA = rva + length;
			length += 0xC;
			length++;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			if (!Enable)
				return 0;
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			if (!Enable)
				return;
			writer.Write((uint)importLookupTableRVA);
			writer.Write(0);	// DateTimeStamp
			writer.Write(0);	// ForwarderChain
			writer.Write((uint)mscoreeDllRVA);	// Name
			writer.Write((uint)ImportAddressTable.RVA);
			writer.Write(0UL);
			writer.Write(0UL);
			writer.Write(0);

			// ImportLookupTable
			if (is64bit) {
				writer.Write((ulong)(uint)corXxxMainRVA);
				writer.Write(0UL);
			}
			else {
				writer.Write((uint)corXxxMainRVA);
				writer.Write(0);
			}

			writer.WriteZeros(stringsPadding);
			writer.Write((ushort)0);
			writer.Write(Encoding.UTF8.GetBytes(IsExeFile ? "_CorExeMain\0" : "_CorDllMain\0"));
			writer.Write(Encoding.UTF8.GetBytes("mscoree.dll\0"));

			writer.Write((byte)0);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MDTable.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// MD table interface
	/// </summary>
	public interface IMDTable {
		/// <summary>
		/// Gets the table type
		/// </summary>
		Table Table { get; }

		/// <summary>
		/// <c>true</c> if the table is empty
		/// </summary>
		bool IsEmpty { get; }

		/// <summary>
		/// Gets the number of rows in this table
		/// </summary>
		int Rows { get; }

		/// <summary>
		/// Gets/sets a value indicating whether it's sorted
		/// </summary>
		bool IsSorted { get; set; }

		/// <summary>
		/// <c>true</c> if <see cref="SetReadOnly()"/> has been called
		/// </summary>
		bool IsReadOnly { get; }

		/// <summary>
		/// Gets/sets the <see cref="TableInfo"/>
		/// </summary>
		TableInfo TableInfo { get; set; }

		/// <summary>
		/// Called when the table can't be modified any more
		/// </summary>
		void SetReadOnly();

		/// <summary>
		/// Gets a raw row
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>The raw row</returns>
		IRawRow Get(uint rid);

		/// <summary>
		/// Gets all raw rows
		/// </summary>
		IEnumerable<IRawRow> GetRawRows();
	}

	/// <summary>
	/// Creates rows in a table. Rows can optionally be shared to create a compact table.
	/// </summary>
	/// <typeparam name="T">The raw row type</typeparam>
	public sealed class MDTable<T> : IMDTable, IEnumerable<T> where T : IRawRow {
		readonly Table table;
		readonly Dictionary<T, uint> cachedDict;
		readonly List<T> cached;
		TableInfo tableInfo;
		bool isSorted;
		bool isReadOnly;

		/// <inheritdoc/>
		public Table Table {
			get { return table; }
		}

		/// <inheritdoc/>
		public bool IsEmpty {
			get { return cached.Count == 0; }
		}

		/// <inheritdoc/>
		public int Rows {
			get { return cached.Count; }
		}

		/// <inheritdoc/>
		public bool IsSorted {
			get { return isSorted; }
			set { isSorted = value; }
		}

		/// <inheritdoc/>
		public bool IsReadOnly {
			get { return isReadOnly; }
		}

		/// <inheritdoc/>
		public TableInfo TableInfo {
			get { return tableInfo; }
			set { tableInfo = value; }
		}

		/// <summary>
		/// Gets the value with rid <paramref name="rid"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		public T this[uint rid] {
			get { return cached[(int)rid - 1]; }
		}

		/// <inheritdoc/>
		public IRawRow Get(uint rid) {
			return this[rid];
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">The table type</param>
		/// <param name="equalityComparer">Equality comparer</param>
		public MDTable(Table table, IEqualityComparer<T> equalityComparer) {
			this.table = table;
			this.cachedDict = new Dictionary<T, uint>(equalityComparer);
			this.cached = new List<T>();
		}

		/// <inheritdoc/>
		public void SetReadOnly() {
			isReadOnly = true;
		}

		/// <summary>
		/// Adds a row. If the row already exists, returns a rid to the existing one, else
		/// it's created and a new rid is returned.
		/// </summary>
		/// <param name="row">The row. It's now owned by us and must NOT be modified by the caller.</param>
		/// <returns>The RID (row ID) of the row</returns>
		public uint Add(T row) {
			if (isReadOnly)
				throw new ModuleWriterException(string.Format("Trying to modify table {0} after it's been set to read-only", table));
			uint rid;
			if (cachedDict.TryGetValue(row, out rid))
				return rid;
			return Create(row);
		}

		/// <summary>
		/// Creates a new row even if this row already exists.
		/// </summary>
		/// <param name="row">The row. It's now owned by us and must NOT be modified by the caller.</param>
		/// <returns>The RID (row ID) of the row</returns>
		public uint Create(T row) {
			if (isReadOnly)
				throw new ModuleWriterException(string.Format("Trying to modify table {0} after it's been set to read-only", table));
			uint rid = (uint)cached.Count + 1;
			if (!cachedDict.ContainsKey(row))
				cachedDict[row] = rid;
			cached.Add(row);
			return rid;
		}

		/// <summary>
		/// Re-adds all added rows. Should be called if rows have been modified after being
		/// inserted.
		/// </summary>
		public void ReAddRows() {
			if (isReadOnly)
				throw new ModuleWriterException(string.Format("Trying to modify table {0} after it's been set to read-only", table));
			cachedDict.Clear();
			for (int i = 0; i < cached.Count; i++) {
				uint rid = (uint)i + 1;
				var row = cached[i];
				if (!cachedDict.ContainsKey(row))
					cachedDict[row] = rid;
			}
		}

		/// <summary>
		/// Reset the table.
		/// </summary>
		public void Reset() {
			if (isReadOnly)
				throw new ModuleWriterException(string.Format("Trying to modify table {0} after it's been set to read-only", table));
			cachedDict.Clear();
			cached.Clear();
		}

		/// <inheritdoc/>
		public IEnumerator<T> GetEnumerator() {
			return cached.GetEnumerator();
		}

		/// <inheritdoc/>
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}

		/// <inheritdoc/>
		public IEnumerable<IRawRow> GetRawRows() {
			foreach (var rawRow in cached)
				yield return rawRow;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MDTableWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Diagnostics;
using System.IO;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes <see cref="MDTable{T}"/>s
	/// </summary>
	public static class MDTableWriter {
		/// <summary>
		/// Writes a raw row
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		/// <param name="row">Row</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, IMDTable table, IRawRow row) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var col in cols) {
				if (col.ColumnSize == ColumnSize.Strings)
					col.Write(writer, stringsHeap.GetOffset(row.Read(col.Index)));
				else
					col.Write(writer, row.Read(col.Index));
			}
		}

		/// <summary>
		/// Writes a metadata table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, IMDTable table) {
			switch (table.Table) {
			case Table.Module:			writer.Write(metadata, (MDTable<RawModuleRow>)table); break;
			case Table.TypeRef:			writer.Write(metadata, (MDTable<RawTypeRefRow>)table); break;
			case Table.TypeDef:			writer.Write(metadata, (MDTable<RawTypeDefRow>)table); break;
			case Table.FieldPtr:		writer.Write(metadata, (MDTable<RawFieldPtrRow>)table); break;
			case Table.Field:			writer.Write(metadata, (MDTable<RawFieldRow>)table); break;
			case Table.MethodPtr:		writer.Write(metadata, (MDTable<RawMethodPtrRow>)table); break;
			case Table.Method:			writer.Write(metadata, (MDTable<RawMethodRow>)table); break;
			case Table.ParamPtr:		writer.Write(metadata, (MDTable<RawParamPtrRow>)table); break;
			case Table.Param:			writer.Write(metadata, (MDTable<RawParamRow>)table); break;
			case Table.InterfaceImpl:	writer.Write(metadata, (MDTable<RawInterfaceImplRow>)table); break;
			case Table.MemberRef:		writer.Write(metadata, (MDTable<RawMemberRefRow>)table); break;
			case Table.Constant:		writer.Write(metadata, (MDTable<RawConstantRow>)table); break;
			case Table.CustomAttribute:	writer.Write(metadata, (MDTable<RawCustomAttributeRow>)table); break;
			case Table.FieldMarshal:	writer.Write(metadata, (MDTable<RawFieldMarshalRow>)table); break;
			case Table.DeclSecurity:	writer.Write(metadata, (MDTable<RawDeclSecurityRow>)table); break;
			case Table.ClassLayout:		writer.Write(metadata, (MDTable<RawClassLayoutRow>)table); break;
			case Table.FieldLayout:		writer.Write(metadata, (MDTable<RawFieldLayoutRow>)table); break;
			case Table.StandAloneSig:	writer.Write(metadata, (MDTable<RawStandAloneSigRow>)table); break;
			case Table.EventMap:		writer.Write(metadata, (MDTable<RawEventMapRow>)table); break;
			case Table.EventPtr:		writer.Write(metadata, (MDTable<RawEventPtrRow>)table); break;
			case Table.Event:			writer.Write(metadata, (MDTable<RawEventRow>)table); break;
			case Table.PropertyMap:		writer.Write(metadata, (MDTable<RawPropertyMapRow>)table); break;
			case Table.PropertyPtr:		writer.Write(metadata, (MDTable<RawPropertyPtrRow>)table); break;
			case Table.Property:		writer.Write(metadata, (MDTable<RawPropertyRow>)table); break;
			case Table.MethodSemantics:	writer.Write(metadata, (MDTable<RawMethodSemanticsRow>)table); break;
			case Table.MethodImpl:		writer.Write(metadata, (MDTable<RawMethodImplRow>)table); break;
			case Table.ModuleRef:		writer.Write(metadata, (MDTable<RawModuleRefRow>)table); break;
			case Table.TypeSpec:		writer.Write(metadata, (MDTable<RawTypeSpecRow>)table); break;
			case Table.ImplMap:			writer.Write(metadata, (MDTable<RawImplMapRow>)table); break;
			case Table.FieldRVA:		writer.Write(metadata, (MDTable<RawFieldRVARow>)table); break;
			case Table.ENCLog:			writer.Write(metadata, (MDTable<RawENCLogRow>)table); break;
			case Table.ENCMap:			writer.Write(metadata, (MDTable<RawENCMapRow>)table); break;
			case Table.Assembly:		writer.Write(metadata, (MDTable<RawAssemblyRow>)table); break;
			case Table.AssemblyProcessor: writer.Write(metadata, (MDTable<RawAssemblyProcessorRow>)table); break;
			case Table.AssemblyOS:		writer.Write(metadata, (MDTable<RawAssemblyOSRow>)table); break;
			case Table.AssemblyRef:		writer.Write(metadata, (MDTable<RawAssemblyRefRow>)table); break;
			case Table.AssemblyRefProcessor: writer.Write(metadata, (MDTable<RawAssemblyRefProcessorRow>)table); break;
			case Table.AssemblyRefOS:	writer.Write(metadata, (MDTable<RawAssemblyRefOSRow>)table); break;
			case Table.File:			writer.Write(metadata, (MDTable<RawFileRow>)table); break;
			case Table.ExportedType:	writer.Write(metadata, (MDTable<RawExportedTypeRow>)table); break;
			case Table.ManifestResource:writer.Write(metadata, (MDTable<RawManifestResourceRow>)table); break;
			case Table.NestedClass:		writer.Write(metadata, (MDTable<RawNestedClassRow>)table); break;
			case Table.GenericParam:	writer.Write(metadata, (MDTable<RawGenericParamRow>)table); break;
			case Table.MethodSpec:		writer.Write(metadata, (MDTable<RawMethodSpecRow>)table); break;
			case Table.GenericParamConstraint: writer.Write(metadata, (MDTable<RawGenericParamConstraintRow>)table); break;
			case Table.Document:		writer.Write(metadata, (MDTable<RawDocumentRow>)table); break;
			case Table.MethodDebugInformation: writer.Write(metadata, (MDTable<RawMethodDebugInformationRow>)table); break;
			case Table.LocalScope:		writer.Write(metadata, (MDTable<RawLocalScopeRow>)table); break;
			case Table.LocalVariable:	writer.Write(metadata, (MDTable<RawLocalVariableRow>)table); break;
			case Table.LocalConstant:	writer.Write(metadata, (MDTable<RawLocalConstantRow>)table); break;
			case Table.ImportScope:		writer.Write(metadata, (MDTable<RawImportScopeRow>)table); break;
			case Table.StateMachineMethod: writer.Write(metadata, (MDTable<RawStateMachineMethodRow>)table); break;
			case Table.CustomDebugInformation: writer.Write(metadata, (MDTable<RawCustomDebugInformationRow>)table); break;

			default:
				Debug.Fail(string.Format("Unknown table: {0}, add a new method overload", table.Table));
				var cols = table.TableInfo.Columns;
				var stringsHeap = metadata.StringsHeap;
				foreach (var row in table.GetRawRows()) {
					foreach (var col in cols) {
						if (col.ColumnSize == ColumnSize.Strings)
							col.Write(writer, stringsHeap.GetOffset(row.Read(col.Index)));
						else
							col.Write(writer, row.Read(col.Index));
					}
				}
				break;
			}
		}

		/// <summary>
		/// Writes a <c>Module</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawModuleRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.Generation);
				cols[1].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[2].Write(writer, row.Mvid);
				cols[3].Write(writer, row.EncId);
				cols[4].Write(writer, row.EncBaseId);
			}
		}

		/// <summary>
		/// Writes a <c>TypeRef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawTypeRefRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				cols[0].Write(writer, row.ResolutionScope);
				cols[1].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[2].Write(writer, stringsHeap.GetOffset(row.Namespace));
			}
		}

		/// <summary>
		/// Writes a <c>TypeDef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawTypeDefRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.Flags);
				cols[1].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[2].Write(writer, stringsHeap.GetOffset(row.Namespace));
				cols[3].Write(writer, row.Extends);
				cols[4].Write(writer, row.FieldList);
				cols[5].Write(writer, row.MethodList);
			}
		}

		/// <summary>
		/// Writes a <c>FieldPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawFieldPtrRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table)
				cols[0].Write(writer, row.Field);
		}

		/// <summary>
		/// Writes a <c>Field</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawFieldRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.Flags);
				cols[1].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[2].Write(writer, row.Signature);
			}
		}

		/// <summary>
		/// Writes a <c>MethodPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawMethodPtrRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table)
				cols[0].Write(writer, row.Method);
		}

		/// <summary>
		/// Writes a <c>Method</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawMethodRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.RVA);
				writer.Write(row.ImplFlags);
				writer.Write(row.Flags);
				cols[3].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[4].Write(writer, row.Signature);
				cols[5].Write(writer, row.ParamList);
			}
		}

		/// <summary>
		/// Writes a <c>ParamPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawParamPtrRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table)
				cols[0].Write(writer, row.Param);
		}

		/// <summary>
		/// Writes a <c>Param</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawParamRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.Flags);
				writer.Write(row.Sequence);
				cols[2].Write(writer, stringsHeap.GetOffset(row.Name));
			}
		}

		/// <summary>
		/// Writes a <c>InterfaceImpl</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawInterfaceImplRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Class);
				cols[1].Write(writer, row.Interface);
			}
		}

		/// <summary>
		/// Writes a <c>MemberRef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawMemberRefRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				cols[0].Write(writer, row.Class);
				cols[1].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[2].Write(writer, row.Signature);
			}
		}

		/// <summary>
		/// Writes a <c>Constant</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawConstantRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				writer.Write(row.Type);
				writer.Write(row.Padding);
				cols[2].Write(writer, row.Parent);
				cols[3].Write(writer, row.Value);
			}
		}

		/// <summary>
		/// Writes a <c>CustomAttribute</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawCustomAttributeRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Parent);
				cols[1].Write(writer, row.Type);
				cols[2].Write(writer, row.Value);
			}
		}

		/// <summary>
		/// Writes a <c>FieldMarshal</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawFieldMarshalRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Parent);
				cols[1].Write(writer, row.NativeType);
			}
		}

		/// <summary>
		/// Writes a <c>DeclSecurity</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawDeclSecurityRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				writer.Write(row.Action);
				cols[1].Write(writer, row.Parent);
				cols[2].Write(writer, row.PermissionSet);
			}
		}

		/// <summary>
		/// Writes a <c>ClassLayout</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawClassLayoutRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				writer.Write(row.PackingSize);
				writer.Write(row.ClassSize);
				cols[2].Write(writer, row.Parent);
			}
		}

		/// <summary>
		/// Writes a <c>FieldLayout</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawFieldLayoutRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				writer.Write(row.OffSet);
				cols[1].Write(writer, row.Field);
			}
		}

		/// <summary>
		/// Writes a <c>StandAloneSig</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawStandAloneSigRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table)
				cols[0].Write(writer, row.Signature);
		}

		/// <summary>
		/// Writes a <c>EventMap</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawEventMapRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Parent);
				cols[1].Write(writer, row.EventList);
			}
		}

		/// <summary>
		/// Writes a <c>EventPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawEventPtrRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table)
				cols[0].Write(writer, row.Event);
		}

		/// <summary>
		/// Writes a <c>Event</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawEventRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.EventFlags);
				cols[1].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[2].Write(writer, row.EventType);
			}
		}

		/// <summary>
		/// Writes a <c>PropertyMap</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawPropertyMapRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Parent);
				cols[1].Write(writer, row.PropertyList);
			}
		}

		/// <summary>
		/// Writes a <c>PropertyPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawPropertyPtrRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table)
				cols[0].Write(writer, row.Property);
		}

		/// <summary>
		/// Writes a <c>Property</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawPropertyRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.PropFlags);
				cols[1].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[2].Write(writer, row.Type);
			}
		}

		/// <summary>
		/// Writes a <c>MethodSemantics</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawMethodSemanticsRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				writer.Write(row.Semantic);
				cols[1].Write(writer, row.Method);
				cols[2].Write(writer, row.Association);
			}
		}

		/// <summary>
		/// Writes a <c>MethodImpl</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawMethodImplRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Class);
				cols[1].Write(writer, row.MethodBody);
				cols[2].Write(writer, row.MethodDeclaration);
			}
		}

		/// <summary>
		/// Writes a <c>ModuleRef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawModuleRefRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table)
				cols[0].Write(writer, stringsHeap.GetOffset(row.Name));
		}

		/// <summary>
		/// Writes a <c>TypeSpec</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawTypeSpecRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table)
				cols[0].Write(writer, row.Signature);
		}

		/// <summary>
		/// Writes a <c>ImplMap</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawImplMapRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.MappingFlags);
				cols[1].Write(writer, row.MemberForwarded);
				cols[2].Write(writer, stringsHeap.GetOffset(row.ImportName));
				cols[3].Write(writer, row.ImportScope);
			}
		}

		/// <summary>
		/// Writes a <c>FieldRVA</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawFieldRVARow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				writer.Write(row.RVA);
				cols[1].Write(writer, row.Field);
			}
		}

		/// <summary>
		/// Writes a <c>ENCLog</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawENCLogRow> table) {
			foreach (var row in table) {
				writer.Write(row.Token);
				writer.Write(row.FuncCode);
			}
		}

		/// <summary>
		/// Writes a <c>ENCMap</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawENCMapRow> table) {
			foreach (var row in table)
				writer.Write(row.Token);
		}

		/// <summary>
		/// Writes a <c>Assembly</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawAssemblyRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.HashAlgId);
				writer.Write(row.MajorVersion);
				writer.Write(row.MinorVersion);
				writer.Write(row.BuildNumber);
				writer.Write(row.RevisionNumber);
				writer.Write(row.Flags);
				cols[6].Write(writer, row.PublicKey);
				cols[7].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[8].Write(writer, stringsHeap.GetOffset(row.Locale));
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyProcessor</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawAssemblyProcessorRow> table) {
			foreach (var row in table)
				writer.Write(row.Processor);
		}

		/// <summary>
		/// Writes a <c>AssemblyOS</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawAssemblyOSRow> table) {
			foreach (var row in table) {
				writer.Write(row.OSPlatformId);
				writer.Write(row.OSMajorVersion);
				writer.Write(row.OSMinorVersion);
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyRef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawAssemblyRefRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.MajorVersion);
				writer.Write(row.MinorVersion);
				writer.Write(row.BuildNumber);
				writer.Write(row.RevisionNumber);
				writer.Write(row.Flags);
				cols[5].Write(writer, row.PublicKeyOrToken);
				cols[6].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[7].Write(writer, stringsHeap.GetOffset(row.Locale));
				cols[8].Write(writer, row.HashValue);
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyRefProcessor</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawAssemblyRefProcessorRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				writer.Write(row.Processor);
				cols[1].Write(writer, row.AssemblyRef);
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyRefOS</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawAssemblyRefOSRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				writer.Write(row.OSPlatformId);
				writer.Write(row.OSMajorVersion);
				writer.Write(row.OSMinorVersion);
				cols[3].Write(writer, row.AssemblyRef);
			}
		}

		/// <summary>
		/// Writes a <c>File</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawFileRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.Flags);
				cols[1].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[2].Write(writer, row.HashValue);
			}
		}

		/// <summary>
		/// Writes a <c>ExportedType</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawExportedTypeRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.Flags);
				writer.Write(row.TypeDefId);
				cols[2].Write(writer, stringsHeap.GetOffset(row.TypeName));
				cols[3].Write(writer, stringsHeap.GetOffset(row.TypeNamespace));
				cols[4].Write(writer, row.Implementation);
			}
		}

		/// <summary>
		/// Writes a <c>ManifestResource</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawManifestResourceRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				writer.Write(row.Offset);
				writer.Write(row.Flags);
				cols[2].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[3].Write(writer, row.Implementation);
			}
		}

		/// <summary>
		/// Writes a <c>NestedClass</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawNestedClassRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.NestedClass);
				cols[1].Write(writer, row.EnclosingClass);
			}
		}

		/// <summary>
		/// Writes a <c>GenericParam</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawGenericParamRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			if (cols.Count >= 5) {
				foreach (var row in table) {
					writer.Write(row.Number);
					writer.Write(row.Flags);
					cols[2].Write(writer, row.Owner);
					cols[3].Write(writer, stringsHeap.GetOffset(row.Name));
					cols[4].Write(writer, row.Kind);
				}
			}
			else {
				foreach (var row in table) {
					writer.Write(row.Number);
					writer.Write(row.Flags);
					cols[2].Write(writer, row.Owner);
					cols[3].Write(writer, stringsHeap.GetOffset(row.Name));
				}
			}
		}

		/// <summary>
		/// Writes a <c>MethodSpec</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawMethodSpecRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Method);
				cols[1].Write(writer, row.Instantiation);
			}
		}

		/// <summary>
		/// Writes a <c>GenericParamConstraint</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawGenericParamConstraintRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Owner);
				cols[1].Write(writer, row.Constraint);
			}
		}

		/// <summary>
		/// Writes a <c>Document</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawDocumentRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Name);
				cols[1].Write(writer, row.HashAlgorithm);
				cols[2].Write(writer, row.Hash);
				cols[3].Write(writer, row.Language);
			}
		}

		/// <summary>
		/// Writes a <c>MethodDebugInformation</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawMethodDebugInformationRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Document);
				cols[1].Write(writer, row.SequencePoints);
			}
		}

		/// <summary>
		/// Writes a <c>LocalScope</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawLocalScopeRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Method);
				cols[1].Write(writer, row.ImportScope);
				cols[2].Write(writer, row.VariableList);
				cols[3].Write(writer, row.ConstantList);
				cols[4].Write(writer, row.StartOffset);
				cols[5].Write(writer, row.Length);
			}
		}

		/// <summary>
		/// Writes a <c>LocalVariable</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawLocalVariableRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				cols[0].Write(writer, row.Attributes);
				cols[1].Write(writer, row.Index);
				cols[2].Write(writer, stringsHeap.GetOffset(row.Name));
			}
		}

		/// <summary>
		/// Writes a <c>LocalConstant</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawLocalConstantRow> table) {
			var cols = table.TableInfo.Columns;
			var stringsHeap = metadata.StringsHeap;
			foreach (var row in table) {
				cols[0].Write(writer, stringsHeap.GetOffset(row.Name));
				cols[1].Write(writer, row.Signature);
			}
		}

		/// <summary>
		/// Writes a <c>ImportScope</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawImportScopeRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Parent);
				cols[1].Write(writer, row.Imports);
			}
		}

		/// <summary>
		/// Writes a <c>StateMachineMethod</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawStateMachineMethodRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.MoveNextMethod);
				cols[1].Write(writer, row.KickoffMethod);
			}
		}

		/// <summary>
		/// Writes a <c>CustomDebugInformation</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this BinaryWriter writer, MetaData metadata, MDTable<RawCustomDebugInformationRow> table) {
			var cols = table.TableInfo.Columns;
			foreach (var row in table) {
				cols[0].Write(writer, row.Parent);
				cols[1].Write(writer, row.Kind);
				cols[2].Write(writer, row.Value);
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ManagedExportsWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	sealed class ManagedExportsWriter {
		const uint DEFAULT_VTBL_FIXUPS_ALIGNMENT = 4;
		const uint DEFAULT_SDATA_ALIGNMENT = 8;
		const StubType stubType = StubType.Export;
		readonly string moduleName;
		readonly Machine machine;
		readonly RelocDirectory relocDirectory;
		readonly MetaData metaData;
		readonly PEHeaders peHeaders;
		readonly LogError logError;
		readonly VtableFixupsChunk vtableFixups;
		readonly StubsChunk stubsChunk;
		readonly SdataChunk sdataChunk;
		readonly ExportDir exportDir;
		readonly List<VTableInfo> vtables;
		readonly List<MethodInfo> allMethodInfos;
		readonly List<MethodInfo> sortedOrdinalMethodInfos;
		readonly List<MethodInfo> sortedNameMethodInfos;
		readonly CpuArch cpuArch;
		uint exportDirOffset;

		bool Is64Bit {
			get { return machine == Machine.IA64 || machine == Machine.AMD64 || machine == Machine.ARM64; }
		}

		FileOffset ExportDirOffset {
			get { return sdataChunk.FileOffset + exportDirOffset; }
		}

		RVA ExportDirRVA {
			get { return sdataChunk.RVA + exportDirOffset; }
		}

		uint ExportDirSize {
			get { return 0x28; }
		}

		internal bool HasExports {
			get { return vtables.Count != 0; }
		}

		sealed class ExportDir : IChunk {
			readonly ManagedExportsWriter owner;

			public FileOffset FileOffset {
				get { return owner.ExportDirOffset; }
			}

			public RVA RVA {
				get { return owner.ExportDirRVA; }
			}

			public ExportDir(ManagedExportsWriter owner) {
				this.owner = owner;
			}

			void IChunk.SetOffset(FileOffset offset, RVA rva) {
				throw new NotSupportedException();
			}

			public uint GetFileLength() {
				return owner.ExportDirSize;
			}

			public uint GetVirtualSize() {
				return GetFileLength();
			}

			void IChunk.WriteTo(BinaryWriter writer) {
				throw new NotSupportedException();
			}
		}

		sealed class VtableFixupsChunk : IChunk {
			readonly ManagedExportsWriter owner;
			FileOffset offset;
			RVA rva;
			internal uint length;

			public FileOffset FileOffset {
				get { return offset; }
			}

			public RVA RVA {
				get { return rva; }
			}

			public VtableFixupsChunk(ManagedExportsWriter owner) {
				this.owner = owner;
			}

			public void SetOffset(FileOffset offset, RVA rva) {
				this.offset = offset;
				this.rva = rva;
			}

			public uint GetFileLength() {
				return length;
			}

			public uint GetVirtualSize() {
				return GetFileLength();
			}

			public void WriteTo(BinaryWriter writer) {
				owner.WriteVtableFixups(writer);
			}
		}

		sealed class StubsChunk : IChunk {
			readonly ManagedExportsWriter owner;
			FileOffset offset;
			RVA rva;
			internal uint length;

			public FileOffset FileOffset {
				get { return offset; }
			}

			public RVA RVA {
				get { return rva; }
			}

			public StubsChunk(ManagedExportsWriter owner) {
				this.owner = owner;
			}

			public void SetOffset(FileOffset offset, RVA rva) {
				this.offset = offset;
				this.rva = rva;
			}

			public uint GetFileLength() {
				return length;
			}

			public uint GetVirtualSize() {
				return GetFileLength();
			}

			public void WriteTo(BinaryWriter writer) {
				owner.WriteStubs(writer);
			}
		}

		sealed class SdataChunk : IChunk {
			readonly ManagedExportsWriter owner;
			FileOffset offset;
			RVA rva;
			internal uint length;

			public FileOffset FileOffset {
				get { return offset; }
			}

			public RVA RVA {
				get { return rva; }
			}

			public SdataChunk(ManagedExportsWriter owner) {
				this.owner = owner;
			}

			public void SetOffset(FileOffset offset, RVA rva) {
				this.offset = offset;
				this.rva = rva;
			}

			public uint GetFileLength() {
				return length;
			}

			public uint GetVirtualSize() {
				return GetFileLength();
			}

			public void WriteTo(BinaryWriter writer) {
				owner.WriteSdata(writer);
			}
		}

		internal delegate void LogError(string format, params object[] args);

		public ManagedExportsWriter(string moduleName, Machine machine, RelocDirectory relocDirectory, MetaData metaData, PEHeaders peHeaders, LogError logError) {
			this.moduleName = moduleName;
			this.machine = machine;
			this.relocDirectory = relocDirectory;
			this.metaData = metaData;
			this.peHeaders = peHeaders;
			this.logError = logError;
			vtableFixups = new VtableFixupsChunk(this);
			stubsChunk = new StubsChunk(this);
			sdataChunk = new SdataChunk(this);
			exportDir = new ExportDir(this);
			vtables = new List<VTableInfo>();
			allMethodInfos = new List<MethodInfo>();
			sortedOrdinalMethodInfos = new List<MethodInfo>();
			sortedNameMethodInfos = new List<MethodInfo>();
			// The error is reported later when we know that there's at least one exported method
			CpuArch.TryGetCpuArch(machine, out cpuArch);
		}

		internal void AddTextChunks(PESection textSection) {
			textSection.Add(vtableFixups, DEFAULT_VTBL_FIXUPS_ALIGNMENT);
			if (cpuArch != null)
				textSection.Add(stubsChunk, cpuArch.GetStubAlignment(stubType));
		}

		internal void AddSdataChunks(PESection sdataSection) {
			sdataSection.Add(sdataChunk, DEFAULT_SDATA_ALIGNMENT);
		}

		internal void InitializeChunkProperties() {
			if (allMethodInfos.Count == 0)
				return;
			peHeaders.ExportDirectory = exportDir;
			peHeaders.ImageCor20Header.VtableFixups = vtableFixups;
		}

		internal void AddExportedMethods(List<MethodDef> methods, uint timestamp) {
			if (methods.Count == 0)
				return;

			// Only check for an unsupported machine when we know there's at least one exported method
			if (cpuArch == null) {
				logError("The module has exported methods but the CPU architecture isn't supported: {0} (0x{1:X4})", machine, (ushort)machine);
				return;
			}
			if (methods.Count > 0x10000) {
				logError("Too many methods have been exported. No more than 2^16 methods can be exported. Number of exported methods: {0}", methods.Count);
				return;
			}

			Initialize(methods, timestamp);
		}

		sealed class MethodInfo {
			public readonly MethodDef Method;
			public readonly uint StubChunkOffset;
			public int FunctionIndex;
			public uint ManagedVtblOffset;
			public uint NameOffset;
			public int NameIndex;
			public byte[] NameBytes;
			public MethodInfo(MethodDef method, uint stubChunkOffset) {
				Method = method;
				StubChunkOffset = stubChunkOffset;
			}
		}

		sealed class VTableInfo {
			public uint SdataChunkOffset { get; set; }
			public readonly VTableFlags Flags;
			public readonly List<MethodInfo> Methods;
			public VTableInfo(VTableFlags flags) {
				Flags = flags;
				Methods = new List<MethodInfo>();
			}
		}

		void Initialize(List<MethodDef> methods, uint timestamp) {
			var dict = new Dictionary<int, List<VTableInfo>>();
			var baseFlags = Is64Bit ? VTableFlags._64Bit : VTableFlags._32Bit;
			uint stubOffset = 0;
			uint stubAlignment = cpuArch.GetStubAlignment(stubType);
			uint stubCodeOffset = cpuArch.GetStubCodeOffset(stubType);
			uint stubSize = cpuArch.GetStubSize(stubType);
			foreach (var method in methods) {
				var exportInfo = method.ExportInfo;
				Debug.Assert(exportInfo != null);
				if (exportInfo == null)
					continue;

				var flags = baseFlags;
				if ((exportInfo.Options & MethodExportInfoOptions.FromUnmanaged) != 0)
					flags |= VTableFlags.FromUnmanaged;
				if ((exportInfo.Options & MethodExportInfoOptions.FromUnmanagedRetainAppDomain) != 0)
					flags |= VTableFlags.FromUnmanagedRetainAppDomain;
				if ((exportInfo.Options & MethodExportInfoOptions.CallMostDerived) != 0)
					flags |= VTableFlags.CallMostDerived;

				List<VTableInfo> list;
				if (!dict.TryGetValue((int)flags, out list))
					dict.Add((int)flags, list = new List<VTableInfo>());
				if (list.Count == 0 || list[list.Count - 1].Methods.Count >= ushort.MaxValue)
					list.Add(new VTableInfo(flags));
				var info = new MethodInfo(method, stubOffset + stubCodeOffset);
				allMethodInfos.Add(info);
				list[list.Count - 1].Methods.Add(info);
				stubOffset = (stubOffset + stubSize + stubAlignment - 1) & ~(stubAlignment - 1);
			}

			foreach (var kv in dict)
				vtables.AddRange(kv.Value);

			WriteSdataBlob(timestamp);

			vtableFixups.length = (uint)vtables.Count * 8;
			stubsChunk.length = stubOffset;
			sdataChunk.length = (uint)sdataBytesInfo.Data.Length;

			uint expectedOffset = 0;
			foreach (var info in allMethodInfos) {
				uint currentOffset = info.StubChunkOffset - stubCodeOffset;
				if (expectedOffset != currentOffset)
					throw new InvalidOperationException();
				cpuArch.WriteStubRelocs(stubType, relocDirectory, stubsChunk, currentOffset);
				expectedOffset = (currentOffset + stubSize + stubAlignment - 1) & ~(stubAlignment - 1);
			}
			if (expectedOffset != stubOffset)
				throw new InvalidOperationException();
		}

		struct NamesBlob {
			readonly Dictionary<string, NameInfo> nameOffsets;
			readonly List<byte[]> names;
			readonly List<uint> methodNameOffsets;
			uint currentOffset;
			int methodNamesCount;
			bool methodNamesIsFrozen;

			public int MethodNamesCount {
				get { return methodNamesCount; }
			}

			struct NameInfo {
				public readonly uint Offset;
				public readonly byte[] Bytes;
				public NameInfo(uint offset, byte[] bytes) {
					Offset = offset;
					Bytes = bytes;
				}
			}

			public NamesBlob(bool dummy) {
				nameOffsets = new Dictionary<string, NameInfo>(StringComparer.Ordinal);
				names = new List<byte[]>();
				methodNameOffsets = new List<uint>();
				currentOffset = 0;
				methodNamesCount = 0;
				methodNamesIsFrozen = false;
			}

			public uint GetMethodNameOffset(string name, out byte[] bytes) {
				if (methodNamesIsFrozen)
					throw new InvalidOperationException();
				methodNamesCount++;
				uint offset = GetOffset(name, out bytes);
				methodNameOffsets.Add(offset);
				return offset;
			}

			public uint GetOtherNameOffset(string name) {
				methodNamesIsFrozen = true;
				byte[] bytes;
				return GetOffset(name, out bytes);
			}

			uint GetOffset(string name, out byte[] bytes) {
				NameInfo nameInfo;
				if (nameOffsets.TryGetValue(name, out nameInfo)) {
					bytes = nameInfo.Bytes;
					return nameInfo.Offset;
				}
				bytes = GetNameASCIIZ(name);
				names.Add(bytes);
				uint offset = currentOffset;
				nameOffsets.Add(name, new NameInfo(offset, bytes));
				currentOffset += (uint)bytes.Length;
				return offset;
			}

			// If this method gets updated, also update the reader (MethodExportInfoProvider)
			static byte[] GetNameASCIIZ(string name) {
				Debug.Assert(name != null);
				int size = Encoding.UTF8.GetByteCount(name);
				var bytes = new byte[size + 1];
				Encoding.UTF8.GetBytes(name, 0, name.Length, bytes, 0);
				if (bytes[bytes.Length - 1] != 0)
					throw new ModuleWriterException();
				return bytes;
			}

			public void Write(BinaryWriter writer) {
				foreach (var name in names)
					writer.Write(name);
			}

			public uint[] GetMethodNameOffsets() {
				return methodNameOffsets.ToArray();
			}
		}

		struct SdataBytesInfo {
			public byte[] Data;
			public uint namesBlobStreamOffset;
			public uint moduleNameOffset;
			public uint exportDirModuleNameStreamOffset;
			public uint exportDirAddressOfFunctionsStreamOffset;
			public uint addressOfFunctionsStreamOffset;
			public uint addressOfNamesStreamOffset;
			public uint addressOfNameOrdinalsStreamOffset;
			public uint[] MethodNameOffsets;
		}
		SdataBytesInfo sdataBytesInfo;

		/// <summary>
		/// Writes the .sdata blob. We could write the data in any order, but we write the data in the same order as ILASM
		/// </summary>
		/// <param name="timestamp">PE timestamp</param>
		void WriteSdataBlob(uint timestamp) {
			var stream = new MemoryStream();
			var writer = new BinaryWriter(stream);

			// Write all vtables (referenced from the .text section)
			Debug.Assert((writer.BaseStream.Position & 7) == 0);
			foreach (var vtbl in vtables) {
				vtbl.SdataChunkOffset = (uint)writer.BaseStream.Position;
				foreach (var info in vtbl.Methods) {
					info.ManagedVtblOffset = (uint)writer.BaseStream.Position;
					writer.Write(0x06000000 + metaData.GetRid(info.Method));
					if ((vtbl.Flags & VTableFlags._64Bit) != 0)
						writer.Write(0U);
				}
			}

			var namesBlob = new NamesBlob(1 == 2);
			int nameIndex = 0;
			bool error = false;
			foreach (var info in allMethodInfos) {
				var exportInfo = info.Method.ExportInfo;
				var name = exportInfo.Name;
				if (name == null) {
					if (exportInfo.Ordinal != null) {
						sortedOrdinalMethodInfos.Add(info);
						continue;
					}
					name = info.Method.Name;
				}
				if (string.IsNullOrEmpty(name)) {
					error = true;
					logError("Exported method name is null or empty, method: {0} (0x{1:X8})", info.Method, info.Method.MDToken.Raw);
					continue;
				}
				info.NameOffset = namesBlob.GetMethodNameOffset(name, out info.NameBytes);
				info.NameIndex = nameIndex++;
				sortedNameMethodInfos.Add(info);
			}
			Debug.Assert(error || sortedOrdinalMethodInfos.Count + sortedNameMethodInfos.Count == allMethodInfos.Count);
			sdataBytesInfo.MethodNameOffsets = namesBlob.GetMethodNameOffsets();
			Debug.Assert(sortedNameMethodInfos.Count == sdataBytesInfo.MethodNameOffsets.Length);
			sdataBytesInfo.moduleNameOffset = namesBlob.GetOtherNameOffset(moduleName);

			sortedOrdinalMethodInfos.Sort((a, b) => a.Method.ExportInfo.Ordinal.Value.CompareTo(b.Method.ExportInfo.Ordinal.Value));
			sortedNameMethodInfos.Sort((a, b) => CompareTo(a.NameBytes, b.NameBytes));

			int ordinalBase, nextFreeOrdinal;
			if (sortedOrdinalMethodInfos.Count == 0) {
				ordinalBase = 0;
				nextFreeOrdinal = 0;
			}
			else {
				ordinalBase = sortedOrdinalMethodInfos[0].Method.ExportInfo.Ordinal.Value;
				nextFreeOrdinal = sortedOrdinalMethodInfos[sortedOrdinalMethodInfos.Count - 1].Method.ExportInfo.Ordinal.Value + 1;
			}
			int nameFuncBaseIndex = nextFreeOrdinal - ordinalBase;
			int lastFuncIndex = 0;
			for (int i = 0; i < sortedOrdinalMethodInfos.Count; i++) {
				int index = sortedOrdinalMethodInfos[i].Method.ExportInfo.Ordinal.Value - ordinalBase;
				sortedOrdinalMethodInfos[i].FunctionIndex = index;
				lastFuncIndex = index;
			}
			for (int i = 0; i < sortedNameMethodInfos.Count; i++) {
				lastFuncIndex = nameFuncBaseIndex + i;
				sortedNameMethodInfos[i].FunctionIndex = lastFuncIndex;
			}
			int funcSize = lastFuncIndex + 1;
			if (funcSize > 0x10000) {
				logError("Exported function array is too big");
				return;
			}

			// Write IMAGE_EXPORT_DIRECTORY
			Debug.Assert((writer.BaseStream.Position & 3) == 0);
			exportDirOffset = (uint)writer.BaseStream.Position;
			writer.Write(0U); // Characteristics
			writer.Write(timestamp);
			writer.Write(0U); // MajorVersion, MinorVersion
			sdataBytesInfo.exportDirModuleNameStreamOffset = (uint)writer.BaseStream.Position;
			writer.Write(0U); // Name
			writer.Write(ordinalBase); // Base
			writer.Write((uint)funcSize); // NumberOfFunctions
			writer.Write(sdataBytesInfo.MethodNameOffsets.Length); // NumberOfNames
			sdataBytesInfo.exportDirAddressOfFunctionsStreamOffset = (uint)writer.BaseStream.Position;
			writer.Write(0U); // AddressOfFunctions
			writer.Write(0U); // AddressOfNames
			writer.Write(0U); // AddressOfNameOrdinals

			sdataBytesInfo.addressOfFunctionsStreamOffset = (uint)writer.BaseStream.Position;
			WriteZeroes(writer, funcSize * 4);
			sdataBytesInfo.addressOfNamesStreamOffset = (uint)writer.BaseStream.Position;
			WriteZeroes(writer, sdataBytesInfo.MethodNameOffsets.Length * 4);
			sdataBytesInfo.addressOfNameOrdinalsStreamOffset = (uint)writer.BaseStream.Position;
			WriteZeroes(writer, sdataBytesInfo.MethodNameOffsets.Length * 2);
			sdataBytesInfo.namesBlobStreamOffset = (uint)writer.BaseStream.Position;
			namesBlob.Write(writer);

			sdataBytesInfo.Data = stream.ToArray();
		}

		void WriteSdata(BinaryWriter writer) {
			if (sdataBytesInfo.Data == null)
				return;
			PatchSdataBytesBlob();
			writer.Write(sdataBytesInfo.Data);
		}

		void PatchSdataBytesBlob() {
			uint rva = (uint)sdataChunk.RVA;
			uint namesBaseOffset = rva + sdataBytesInfo.namesBlobStreamOffset;

			var writer = new BinaryWriter(new MemoryStream(sdataBytesInfo.Data));

			writer.BaseStream.Position = sdataBytesInfo.exportDirModuleNameStreamOffset;
			writer.Write(namesBaseOffset + sdataBytesInfo.moduleNameOffset);

			writer.BaseStream.Position = sdataBytesInfo.exportDirAddressOfFunctionsStreamOffset;
			writer.Write(rva + sdataBytesInfo.addressOfFunctionsStreamOffset); // AddressOfFunctions
			if (sdataBytesInfo.MethodNameOffsets.Length != 0) {
				writer.Write(rva + sdataBytesInfo.addressOfNamesStreamOffset); // AddressOfNames
				writer.Write(rva + sdataBytesInfo.addressOfNameOrdinalsStreamOffset); // AddressOfNameOrdinals
			}

			uint funcBaseRva = (uint)stubsChunk.RVA;
			writer.BaseStream.Position = sdataBytesInfo.addressOfFunctionsStreamOffset;
			int currentFuncIndex = 0;
			foreach (var info in sortedOrdinalMethodInfos) {
				int zeroes = info.FunctionIndex - currentFuncIndex;
				if (zeroes < 0)
					throw new InvalidOperationException();
				while (zeroes-- > 0)
					writer.Write(0);
				writer.Write(funcBaseRva + info.StubChunkOffset);
				currentFuncIndex = info.FunctionIndex + 1;
			}
			foreach (var info in sortedNameMethodInfos) {
				if (info.FunctionIndex != currentFuncIndex++)
					throw new InvalidOperationException();
				writer.Write(funcBaseRva + info.StubChunkOffset);
			}

			var nameOffsets = sdataBytesInfo.MethodNameOffsets;
			if (nameOffsets.Length != 0) {
				writer.BaseStream.Position = sdataBytesInfo.addressOfNamesStreamOffset;
				foreach (var info in sortedNameMethodInfos)
					writer.Write(namesBaseOffset + nameOffsets[info.NameIndex]);

				writer.BaseStream.Position = sdataBytesInfo.addressOfNameOrdinalsStreamOffset;
				foreach (var info in sortedNameMethodInfos)
					writer.Write((ushort)info.FunctionIndex);
			}
		}

		static void WriteZeroes(BinaryWriter writer, int count) {
			while (count >= 8) {
				writer.Write(0UL);
				count -= 8;
			}
			for (int i = 0; i < count; i++)
				writer.Write((byte)0);
		}

		void WriteVtableFixups(BinaryWriter writer) {
			if (vtables.Count == 0)
				return;

			foreach (var vtbl in vtables) {
				Debug.Assert(vtbl.Methods.Count <= ushort.MaxValue);
				writer.Write((uint)sdataChunk.RVA + vtbl.SdataChunkOffset);
				writer.Write((ushort)vtbl.Methods.Count);
				writer.Write((ushort)vtbl.Flags);
			}
		}

		void WriteStubs(BinaryWriter writer) {
			if (vtables.Count == 0)
				return;
			if (cpuArch == null)
				return;

			ulong imageBase = peHeaders.ImageBase;
			uint stubsBaseRva = (uint)stubsChunk.RVA;
			uint vtblBaseRva = (uint)sdataChunk.RVA;
			uint expectedOffset = 0;
			uint stubCodeOffset = cpuArch.GetStubCodeOffset(stubType);
			uint stubSize = cpuArch.GetStubSize(stubType);
			uint stubAlignment = cpuArch.GetStubAlignment(stubType);
			int zeroes = (int)((stubSize + stubAlignment - 1 & ~(stubAlignment - 1)) - stubSize);
			foreach (var info in allMethodInfos) {
				uint currentOffset = info.StubChunkOffset - stubCodeOffset;
				if (expectedOffset != currentOffset)
					throw new InvalidOperationException();
				var pos = writer.BaseStream.Position;
				cpuArch.WriteStub(stubType, writer, imageBase, stubsBaseRva + currentOffset, vtblBaseRva + info.ManagedVtblOffset);
				Debug.Assert(pos + stubSize == writer.BaseStream.Position, "The full stub wasn't written");
				if (pos + stubSize != writer.BaseStream.Position)
					throw new InvalidOperationException();
				if (zeroes != 0)
					WriteZeroes(writer, zeroes);
				expectedOffset = (currentOffset + stubSize + stubAlignment - 1) & ~(stubAlignment - 1);
			}
			if (expectedOffset != stubsChunk.length)
				throw new InvalidOperationException();
		}

		static int CompareTo(byte[] a, byte[] b) {
			if (a == b)
				return 0;
			int max = Math.Min(a.Length, b.Length);
			for (int i = 0; i < max; i++) {
				int c = a[i] - b[i];
				if (c != 0)
					return c;
			}
			return a.Length - b.Length;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MarshalBlobWriter.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes field marshal blobs
	/// </summary>
	public struct MarshalBlobWriter : IDisposable, IFullNameCreatorHelper {
		readonly ModuleDef module;
		readonly MemoryStream outStream;
		readonly BinaryWriter writer;
		readonly IWriterError helper;

		/// <summary>
		/// Creates a field marshal blob from <paramref name="marshalType"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="marshalType">Marshal type</param>
		/// <param name="helper">Helps this class</param>
		/// <returns>A field marshal blob or <c>null</c> if <paramref name="marshalType"/> is
		/// <c>null</c></returns>
		public static byte[] Write(ModuleDef module, MarshalType marshalType, IWriterError helper) {
			using (var writer = new MarshalBlobWriter(module, helper))
				return writer.Write(marshalType);
		}

		MarshalBlobWriter(ModuleDef module, IWriterError helper) {
			this.module = module;
			this.outStream = new MemoryStream();
			this.writer = new BinaryWriter(outStream);
			this.helper = helper;
		}

		byte[] Write(MarshalType marshalType) {
			if (marshalType == null)
				return null;

			var type = marshalType.NativeType;
			if (type != NativeType.RawBlob) {
				if ((uint)type > byte.MaxValue)
					helper.Error("Invalid MarshalType.NativeType");
				writer.Write((byte)type);
			}
			bool canWrite = true;
			switch (type) {
			case NativeType.FixedSysString:
				var fixedSysString = (FixedSysStringMarshalType)marshalType;
				if (fixedSysString.IsSizeValid)
					WriteCompressedUInt32((uint)fixedSysString.Size);
				break;

			case NativeType.SafeArray:
				var safeArray = (SafeArrayMarshalType)marshalType;
				if (UpdateCanWrite(safeArray.IsVariantTypeValid, "VariantType", ref canWrite))
					WriteCompressedUInt32((uint)safeArray.VariantType);
				if (UpdateCanWrite(safeArray.IsUserDefinedSubTypeValid, "UserDefinedSubType", ref canWrite))
					Write(safeArray.UserDefinedSubType.AssemblyQualifiedName);
				break;

			case NativeType.FixedArray:
				var fixedArray = (FixedArrayMarshalType)marshalType;
				if (UpdateCanWrite(fixedArray.IsSizeValid, "Size", ref canWrite))
					WriteCompressedUInt32((uint)fixedArray.Size);
				if (UpdateCanWrite(fixedArray.IsElementTypeValid, "ElementType", ref canWrite))
					WriteCompressedUInt32((uint)fixedArray.ElementType);
				break;

			case NativeType.Array:
				var array = (ArrayMarshalType)marshalType;
				if (UpdateCanWrite(array.IsElementTypeValid, "ElementType", ref canWrite))
					WriteCompressedUInt32((uint)array.ElementType);
				if (UpdateCanWrite(array.IsParamNumberValid, "ParamNumber", ref canWrite))
					WriteCompressedUInt32((uint)array.ParamNumber);
				if (UpdateCanWrite(array.IsSizeValid, "Size", ref canWrite))
					WriteCompressedUInt32((uint)array.Size);
				if (UpdateCanWrite(array.IsFlagsValid, "Flags", ref canWrite))
					WriteCompressedUInt32((uint)array.Flags);
				break;

			case NativeType.CustomMarshaler:
				var custMarshaler = (CustomMarshalType)marshalType;
				Write(custMarshaler.Guid);
				Write(custMarshaler.NativeTypeName);
				var cm = custMarshaler.CustomMarshaler;
				var cmName = cm == null ? string.Empty : FullNameCreator.AssemblyQualifiedName(cm, this);
				Write(cmName);
				Write(custMarshaler.Cookie);
				break;

			case NativeType.IUnknown:
			case NativeType.IDispatch:
			case NativeType.IntF:
				var iface = (InterfaceMarshalType)marshalType;
				if (iface.IsIidParamIndexValid)
					WriteCompressedUInt32((uint)iface.IidParamIndex);
				break;

			case NativeType.RawBlob:
				var data = ((RawMarshalType)marshalType).Data;
				if (data != null)
					writer.Write(data);
				break;

			default:
				break;
			}

			writer.Flush();
			return outStream.ToArray();
		}

		bool UpdateCanWrite(bool isValid, string field, ref bool canWriteMore) {
			if (!canWriteMore) {
				if (isValid)
					helper.Error(string.Format("MarshalType field {0} is valid even though a previous field was invalid", field));
				return canWriteMore;
			}

			if (!isValid)
				canWriteMore = false;

			return canWriteMore;
		}

		uint WriteCompressedUInt32(uint value) {
			return writer.WriteCompressedUInt32(helper, value);
		}

		void Write(UTF8String s) {
			writer.Write(helper, s);
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (outStream != null)
				outStream.Dispose();
		}

		bool IFullNameCreatorHelper.MustUseAssemblyName(IType type) {
			return FullNameCreator.MustUseAssemblyName(module, type);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MaxStackCalculator.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using dnlib.DotNet.Emit;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Calculates max stack usage by using a simple pass over all instructions. This value
	/// can be placed in the fat method header's MaxStack field.
	/// </summary>
	public struct MaxStackCalculator {
		IList<Instruction> instructions;
		IList<ExceptionHandler> exceptionHandlers;
		readonly Dictionary<Instruction, int> stackHeights;
		int errors;

		/// <summary>
		/// Gets max stack value
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <param name="exceptionHandlers">All exception handlers</param>
		/// <returns>Max stack value</returns>
		public static uint GetMaxStack(IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers) {
			uint maxStack;
			new MaxStackCalculator(instructions, exceptionHandlers).Calculate(out maxStack);
			return maxStack;
		}

		/// <summary>
		/// Gets max stack value
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <param name="exceptionHandlers">All exception handlers</param>
		/// <param name="maxStack">Updated with max stack value</param>
		/// <returns><c>true</c> if no errors were detected, <c>false</c> otherwise</returns>
		public static bool GetMaxStack(IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers, out uint maxStack) {
			return new MaxStackCalculator(instructions, exceptionHandlers).Calculate(out maxStack);
		}

		internal static MaxStackCalculator Create() {
			return new MaxStackCalculator(true);
		}

		MaxStackCalculator(bool dummy) {
			this.instructions = null;
			this.exceptionHandlers = null;
			this.stackHeights = new Dictionary<Instruction, int>();
			this.errors = 0;
		}

		MaxStackCalculator(IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
			this.stackHeights = new Dictionary<Instruction, int>();
			this.errors = 0;
		}

		internal void Reset(IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
			stackHeights.Clear();
			errors = 0;
		}

		internal bool Calculate(out uint maxStack) {
			foreach (var eh in exceptionHandlers) {
				if (eh == null)
					continue;
				if (eh.TryStart != null)
					stackHeights[eh.TryStart] = 0;
				if (eh.FilterStart != null)
					stackHeights[eh.FilterStart] = 1;
				if (eh.HandlerStart != null) {
					bool pushed = eh.HandlerType == ExceptionHandlerType.Catch || eh.HandlerType == ExceptionHandlerType.Filter;
					stackHeights[eh.HandlerStart] = pushed ? 1 : 0;
				}
			}

			int stack = 0;
			bool resetStack = false;
			foreach (var instr in instructions) {
				if (instr == null)
					continue;

				if (resetStack) {
					stackHeights.TryGetValue(instr, out stack);
					resetStack = false;
				}
				stack = WriteStack(instr, stack);

				if (instr.OpCode.Code == Code.Jmp) {
					if (stack != 0)
						errors++;
				}
				else {
					int pushes, pops;
					instr.CalculateStackUsage(out pushes, out pops);
					if (pops == -1)
						stack = 0;
					else {
						stack -= pops;
						if (stack < 0) {
							errors++;
							stack = 0;
						}
						stack += pushes;
					}
				}
				if (stack < 0) {
					errors++;
					stack = 0;
				}

				switch (instr.OpCode.FlowControl) {
				case FlowControl.Branch:
					WriteStack(instr.Operand as Instruction, stack);
					resetStack = true;
					break;

				case FlowControl.Call:
					if (instr.OpCode.Code == Code.Jmp)
						resetStack = true;
					break;

				case FlowControl.Cond_Branch:
					if (instr.OpCode.Code == Code.Switch) {
						var targets = instr.Operand as IList<Instruction>;
						if (targets != null) {
							foreach (var target in targets)
								WriteStack(target, stack);
						}
					}
					else
						WriteStack(instr.Operand as Instruction, stack);
					break;

				case FlowControl.Return:
				case FlowControl.Throw:
					resetStack = true;
					break;
				}
			}

			stack = 0;
			foreach (var v in stackHeights.Values)
				stack = Math.Max(stack, v);
			maxStack = (uint)stack;
			return errors == 0;
		}

		int WriteStack(Instruction instr, int stack) {
			if (instr == null) {
				errors++;
				return stack;
			}
			int stack2;
			if (stackHeights.TryGetValue(instr, out stack2)) {
				if (stack != stack2)
					errors++;
				return stack2;
			}
			stackHeights[instr] = stack;
			return stack;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MetaData.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.IO;
using dnlib.PE;
using dnlib.DotNet.MD;
using dnlib.DotNet.Emit;
using System.Diagnostics;
using dnlib.DotNet.Pdb;
using dnlib.DotNet.Pdb.Portable;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="MetaData"/> flags
	/// </summary>
	[Flags]
	public enum MetaDataFlags : uint {
		/// <summary>
		/// Preserves all rids in the <c>TypeRef</c> table
		/// </summary>
		PreserveTypeRefRids = 1,

		/// <summary>
		/// Preserves all rids in the <c>TypeDef</c> table
		/// </summary>
		PreserveTypeDefRids = 2,

		/// <summary>
		/// Preserves all rids in the <c>Field</c> table
		/// </summary>
		PreserveFieldRids = 4,

		/// <summary>
		/// Preserves all rids in the <c>Method</c> table
		/// </summary>
		PreserveMethodRids = 8,

		/// <summary>
		/// Preserves all rids in the <c>Param</c> table
		/// </summary>
		PreserveParamRids = 0x10,

		/// <summary>
		/// Preserves all rids in the <c>MemberRef</c> table
		/// </summary>
		PreserveMemberRefRids = 0x20,

		/// <summary>
		/// Preserves all rids in the <c>StandAloneSig</c> table
		/// </summary>
		PreserveStandAloneSigRids = 0x40,

		/// <summary>
		/// Preserves all rids in the <c>Event</c> table
		/// </summary>
		PreserveEventRids = 0x80,

		/// <summary>
		/// Preserves all rids in the <c>Property</c> table
		/// </summary>
		PreservePropertyRids = 0x100,

		/// <summary>
		/// Preserves all rids in the <c>TypeSpec</c> table
		/// </summary>
		PreserveTypeSpecRids = 0x200,

		/// <summary>
		/// Preserves all rids in the <c>MethodSpec</c> table
		/// </summary>
		PreserveMethodSpecRids = 0x400,

		/// <summary>
		/// Preserves all method rids, i.e., <c>Method</c>, <c>MemberRef</c> and
		/// <c>MethodSpec</c> rids.
		/// </summary>
		PreserveAllMethodRids = PreserveMethodRids | PreserveMemberRefRids | PreserveMethodSpecRids,

		/// <summary>
		/// Preserves all rids in the following tables: <c>TypeRef</c>, <c>TypeDef</c>,
		/// <c>Field</c>, <c>Method</c>, <c>Param</c>, <c>MemberRef</c>, <c>StandAloneSig</c>,
		/// <c>Event</c>, <c>Property</c>, <c>TypeSpec</c>, <c>MethodSpec</c>
		/// </summary>
		PreserveRids =	PreserveTypeRefRids |
						PreserveTypeDefRids |
						PreserveFieldRids |
						PreserveMethodRids |
						PreserveParamRids |
						PreserveMemberRefRids |
						PreserveStandAloneSigRids |
						PreserveEventRids |
						PreservePropertyRids |
						PreserveTypeSpecRids |
						PreserveMethodSpecRids,

		/// <summary>
		/// Preserves all offsets in the #Strings heap (the original #Strings heap will be saved
		/// in the new file). Type names, field names, and other non-user strings are stored
		/// in the #Strings heap.
		/// </summary>
		PreserveStringsOffsets = 0x800,

		/// <summary>
		/// Preserves all offsets in the #US heap (the original #US heap will be saved
		/// in the new file). User strings (referenced by the ldstr instruction) are stored in
		/// the #US heap.
		/// </summary>
		PreserveUSOffsets = 0x1000,

		/// <summary>
		/// Preserves all offsets in the #Blob heap (the original #Blob heap will be saved
		/// in the new file). Custom attributes, signatures and other blobs are stored in the
		/// #Blob heap.
		/// </summary>
		PreserveBlobOffsets = 0x2000,

		/// <summary>
		/// Preserves the extra data that is present after the original signature in the #Blob
		/// heap. This extra data shouldn't be present but might be present if an obfuscator
		/// has added this extra data and is eg. using it to decrypt stuff.
		/// </summary>
		PreserveExtraSignatureData = 0x4000,

		/// <summary>
		/// Preserves as much as possible
		/// </summary>
		PreserveAll = PreserveRids | PreserveStringsOffsets | PreserveUSOffsets |
					PreserveBlobOffsets | PreserveExtraSignatureData,

		/// <summary>
		/// The original method body's max stack field should be used and a new one should not
		/// be calculated.
		/// </summary>
		KeepOldMaxStack = 0x8000,

		/// <summary>
		/// Always create the #GUID heap even if it's empty
		/// </summary>
		AlwaysCreateGuidHeap = 0x10000,

		/// <summary>
		/// Always create the #Strings heap even if it's empty
		/// </summary>
		AlwaysCreateStringsHeap = 0x20000,

		/// <summary>
		/// Always create the #US heap even if it's empty
		/// </summary>
		AlwaysCreateUSHeap = 0x40000,

		/// <summary>
		/// Always create the #Blob heap even if it's empty
		/// </summary>
		AlwaysCreateBlobHeap = 0x80000,

		/// <summary>
		/// Sort the InterfaceImpl table the same way Roslyn sorts it. Roslyn doesn't sort it
		/// according to the ECMA spec, see https://github.com/dotnet/roslyn/issues/3905
		/// </summary>
		RoslynSortInterfaceImpl = 0x100000,
	}

	/// <summary>
	/// <see cref="MetaData"/> options
	/// </summary>
	public sealed class MetaDataOptions {
		MetaDataHeaderOptions metaDataHeaderOptions;
		MetaDataHeaderOptions debugMetaDataHeaderOptions;
		TablesHeapOptions tablesHeapOptions;
		List<IHeap> otherHeaps;
		List<IHeap> otherHeapsEnd;

		/// <summary>
		/// Gets/sets the <see cref="MetaDataHeader"/> options. This is never <c>null</c>.
		/// </summary>
		public MetaDataHeaderOptions MetaDataHeaderOptions {
			get { return metaDataHeaderOptions ?? (metaDataHeaderOptions = new MetaDataHeaderOptions()); }
			set { metaDataHeaderOptions = value; }
		}

		/// <summary>
		/// Gets/sets the debug (portable PDB) <see cref="MetaDataHeader"/> options. This is never <c>null</c>.
		/// </summary>
		public MetaDataHeaderOptions DebugMetaDataHeaderOptions {
			get { return debugMetaDataHeaderOptions ?? (debugMetaDataHeaderOptions = MetaDataHeaderOptions.CreatePortablePdbV1_0()); }
			set { debugMetaDataHeaderOptions = value; }
		}

		/// <summary>
		/// Gets/sets the <see cref="TablesHeap"/> options. This is never <c>null</c>.
		/// </summary>
		public TablesHeapOptions TablesHeapOptions {
			get { return tablesHeapOptions ?? (tablesHeapOptions = new TablesHeapOptions()); }
			set { tablesHeapOptions = value; }
		}

		/// <summary>
		/// Gets/sets the debug (portable PDB) <see cref="TablesHeap"/> options. This is never <c>null</c>.
		/// </summary>
		public TablesHeapOptions DebugTablesHeapOptions {
			get { return tablesHeapOptions ?? (tablesHeapOptions = TablesHeapOptions.CreatePortablePdbV1_0()); }
			set { tablesHeapOptions = value; }
		}

		/// <summary>
		/// Various options
		/// </summary>
		public MetaDataFlags Flags;

		/// <summary>
		/// Any additional heaps that should be added to the beginning of the heaps list
		/// </summary>
		public List<IHeap> OtherHeaps {
			get { return otherHeaps ?? (otherHeaps = new List<IHeap>()); }
		}

		/// <summary>
		/// Any additional heaps that should be added to end of the heaps list
		/// </summary>
		public List<IHeap> OtherHeapsEnd {
			get { return otherHeapsEnd ?? (otherHeapsEnd = new List<IHeap>()); }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public MetaDataOptions() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Flags</param>
		public MetaDataOptions(MetaDataFlags flags) {
			this.Flags = flags;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mdhOptions">Meta data header options</param>
		public MetaDataOptions(MetaDataHeaderOptions mdhOptions) {
			this.metaDataHeaderOptions = mdhOptions;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mdhOptions">Meta data header options</param>
		/// <param name="flags">Flags</param>
		public MetaDataOptions(MetaDataHeaderOptions mdhOptions, MetaDataFlags flags) {
			this.Flags = flags;
			this.metaDataHeaderOptions = mdhOptions;
		}
	}

	sealed class BinaryWriterContext {
		public readonly MemoryStream OutStream;
		public readonly BinaryWriter Writer;
		public BinaryWriterContext() {
			OutStream = new MemoryStream();
			Writer = new BinaryWriter(OutStream);
		}
	}

	/// <summary>
	/// Portable PDB metadata kind
	/// </summary>
	public enum DebugMetaDataKind {
		/// <summary>
		/// No debugging metadata
		/// </summary>
		None,

		/// <summary>
		/// Standalone / embedded portable PDB metadata
		/// </summary>
		Standalone,
	}

	/// <summary>
	/// .NET meta data
	/// </summary>
	public abstract class MetaData : IChunk, ISignatureWriterHelper, ITokenCreator, ICustomAttributeWriterHelper, IPortablePdbCustomDebugInfoWriterHelper {
		uint length;
		FileOffset offset;
		RVA rva;
		readonly MetaDataOptions options;
		IMetaDataListener listener;
		ILogger logger;
		readonly NormalMetaData debugMetaData;
		readonly bool isStandaloneDebugMetadata;
		internal readonly ModuleDef module;
		internal readonly UniqueChunkList<ByteArrayChunk> constants;
		internal readonly MethodBodyChunks methodBodies;
		internal readonly NetResources netResources;
		internal readonly MetaDataHeader metaDataHeader;
		internal HotHeap hotHeap;
		internal readonly PdbHeap pdbHeap;
		internal readonly TablesHeap tablesHeap;
		internal readonly StringsHeap stringsHeap;
		internal readonly USHeap usHeap;
		internal readonly GuidHeap guidHeap;
		internal readonly BlobHeap blobHeap;
		internal List<TypeDef> allTypeDefs;
		internal readonly Rows<ModuleDef> moduleDefInfos = new Rows<ModuleDef>();
		internal readonly SortedRows<InterfaceImpl, RawInterfaceImplRow> interfaceImplInfos = new SortedRows<InterfaceImpl, RawInterfaceImplRow>();
		internal readonly SortedRows<IHasConstant, RawConstantRow> hasConstantInfos = new SortedRows<IHasConstant, RawConstantRow>();
		internal readonly SortedRows<CustomAttribute, RawCustomAttributeRow> customAttributeInfos = new SortedRows<CustomAttribute, RawCustomAttributeRow>();
		internal readonly SortedRows<IHasFieldMarshal, RawFieldMarshalRow> fieldMarshalInfos = new SortedRows<IHasFieldMarshal, RawFieldMarshalRow>();
		internal readonly SortedRows<DeclSecurity, RawDeclSecurityRow> declSecurityInfos = new SortedRows<DeclSecurity, RawDeclSecurityRow>();
		internal readonly SortedRows<TypeDef, RawClassLayoutRow> classLayoutInfos = new SortedRows<TypeDef, RawClassLayoutRow>();
		internal readonly SortedRows<FieldDef, RawFieldLayoutRow> fieldLayoutInfos = new SortedRows<FieldDef, RawFieldLayoutRow>();
		internal readonly Rows<TypeDef> eventMapInfos = new Rows<TypeDef>();
		internal readonly Rows<TypeDef> propertyMapInfos = new Rows<TypeDef>();
		internal readonly SortedRows<MethodDef, RawMethodSemanticsRow> methodSemanticsInfos = new SortedRows<MethodDef, RawMethodSemanticsRow>();
		internal readonly SortedRows<MethodDef, RawMethodImplRow> methodImplInfos = new SortedRows<MethodDef, RawMethodImplRow>();
		internal readonly Rows<ModuleRef> moduleRefInfos = new Rows<ModuleRef>();
		internal readonly SortedRows<IMemberForwarded, RawImplMapRow> implMapInfos = new SortedRows<IMemberForwarded, RawImplMapRow>();
		internal readonly SortedRows<FieldDef, RawFieldRVARow> fieldRVAInfos = new SortedRows<FieldDef, RawFieldRVARow>();
		internal readonly Rows<AssemblyDef> assemblyInfos = new Rows<AssemblyDef>();
		internal readonly Rows<AssemblyRef> assemblyRefInfos = new Rows<AssemblyRef>();
		internal readonly Rows<FileDef> fileDefInfos = new Rows<FileDef>();
		internal readonly Rows<ExportedType> exportedTypeInfos = new Rows<ExportedType>();
		internal readonly Rows<Resource> manifestResourceInfos = new Rows<Resource>();
		internal readonly SortedRows<TypeDef, RawNestedClassRow> nestedClassInfos = new SortedRows<TypeDef, RawNestedClassRow>();
		internal readonly SortedRows<GenericParam, RawGenericParamRow> genericParamInfos = new SortedRows<GenericParam, RawGenericParamRow>();
		internal readonly SortedRows<GenericParamConstraint, RawGenericParamConstraintRow> genericParamConstraintInfos = new SortedRows<GenericParamConstraint, RawGenericParamConstraintRow>();
		internal readonly Dictionary<MethodDef, MethodBody> methodToBody = new Dictionary<MethodDef, MethodBody>();
		internal readonly Dictionary<MethodDef, NativeMethodBody> methodToNativeBody = new Dictionary<MethodDef, NativeMethodBody>();
		internal readonly Dictionary<EmbeddedResource, ByteArrayChunk> embeddedResourceToByteArray = new Dictionary<EmbeddedResource, ByteArrayChunk>();
		readonly Dictionary<FieldDef, ByteArrayChunk> fieldToInitialValue = new Dictionary<FieldDef, ByteArrayChunk>();
		readonly Rows<PdbDocument> pdbDocumentInfos = new Rows<PdbDocument>();
		bool methodDebugInformationInfosUsed;
		readonly SortedRows<PdbScope, RawLocalScopeRow> localScopeInfos = new SortedRows<PdbScope, RawLocalScopeRow>();
		readonly Rows<PdbLocal> localVariableInfos = new Rows<PdbLocal>();
		readonly Rows<PdbConstant> localConstantInfos = new Rows<PdbConstant>();
		readonly Rows<PdbImportScope> importScopeInfos = new Rows<PdbImportScope>();
		readonly SortedRows<PdbCustomDebugInfo, RawStateMachineMethodRow> stateMachineMethodInfos = new SortedRows<PdbCustomDebugInfo, RawStateMachineMethodRow>();
		readonly SortedRows<PdbCustomDebugInfo, RawCustomDebugInformationRow> customDebugInfos = new SortedRows<PdbCustomDebugInfo, RawCustomDebugInformationRow>();
		readonly List<BinaryWriterContext> binaryWriterContexts = new List<BinaryWriterContext>();
		readonly List<SerializerMethodContext> serializerMethodContexts = new List<SerializerMethodContext>();
		readonly List<MethodDef> exportedMethods = new List<MethodDef>();

		/// <summary>
		/// Gets/sets the listener
		/// </summary>
		public IMetaDataListener Listener {
			get { return listener ?? (listener = DummyMetaDataListener.Instance); }
			set { listener = value; }
		}

		/// <summary>
		/// Gets/sets the logger
		/// </summary>
		public ILogger Logger {
			get { return logger; }
			set { logger = value; }
		}

		/// <summary>
		/// Gets the module
		/// </summary>
		public ModuleDef Module {
			get { return module; }
		}

		/// <summary>
		/// Gets the constants
		/// </summary>
		public UniqueChunkList<ByteArrayChunk> Constants {
			get { return constants; }
		}

		/// <summary>
		/// Gets the method body chunks
		/// </summary>
		public MethodBodyChunks MethodBodyChunks {
			get { return methodBodies; }
		}

		/// <summary>
		/// Gets the .NET resources
		/// </summary>
		public NetResources NetResources {
			get { return netResources; }
		}

		/// <summary>
		/// Gets the MD header
		/// </summary>
		public MetaDataHeader MetaDataHeader {
			get { return metaDataHeader; }
		}

		/// <summary>
		/// Gets/sets the hot heap (<c>#!</c>)
		/// </summary>
		HotHeap HotHeap {
			get { return hotHeap; }
			set { hotHeap = value; }
		}

		/// <summary>
		/// Gets the tables heap. Access to this heap is not recommended, but is useful if you
		/// want to add random table entries.
		/// </summary>
		public TablesHeap TablesHeap {
			get { return tablesHeap; }
		}

		/// <summary>
		/// Gets the #Strings heap. Access to this heap is not recommended, but is useful if you
		/// want to add random strings.
		/// </summary>
		public StringsHeap StringsHeap {
			get { return stringsHeap; }
		}

		/// <summary>
		/// Gets the #US heap. Access to this heap is not recommended, but is useful if
		/// you want to add random user strings.
		/// </summary>
		public USHeap USHeap {
			get { return usHeap; }
		}

		/// <summary>
		/// Gets the #GUID heap. Access to this heap is not recommended, but is useful if you
		/// want to add random GUIDs.
		/// </summary>
		public GuidHeap GuidHeap {
			get { return guidHeap; }
		}

		/// <summary>
		/// Gets the #Blob heap. Access to this heap is not recommended, but is useful if you
		/// want to add random blobs.
		/// </summary>
		public BlobHeap BlobHeap {
			get { return blobHeap; }
		}

		/// <summary>
		/// Gets the #Pdb heap. It's only used if it's portable PDB metadata
		/// </summary>
		public PdbHeap PdbHeap {
			get { return pdbHeap; }
		}

		/// <summary>
		/// Gets all exported methods
		/// </summary>
		public List<MethodDef> ExportedMethods {
			get { return exportedMethods; }
		}

		/// <summary>
		/// The public key that should be used instead of the one in <see cref="AssemblyDef"/>.
		/// </summary>
		internal byte[] AssemblyPublicKey { get; set; }

		internal sealed class SortedRows<T, TRow> where T : class where TRow : class {
			public List<Info> infos = new List<Info>();
			Dictionary<T, uint> toRid = new Dictionary<T, uint>();
			bool isSorted;

			public struct Info {
				public T data;
				public TRow row;
				public Info(T data, TRow row) {
					this.data = data;
					this.row = row;
				}
			}

			public void Add(T data, TRow row) {
				if (isSorted)
					throw new ModuleWriterException(string.Format("Adding a row after it's been sorted. Table: {0}", row.GetType()));
				infos.Add(new Info(data, row));
				toRid[data] = (uint)toRid.Count + 1;
			}

			public void Sort(Comparison<Info> comparison) {
				infos.Sort(CreateComparison(comparison));
				toRid.Clear();
				for (int i = 0; i < infos.Count; i++)
					toRid[infos[i].data] = (uint)i + 1;
				isSorted = true;
			}

			Comparison<Info> CreateComparison(Comparison<Info> comparison) {
				return (a, b) => {
					int c = comparison(a, b);
					if (c != 0)
						return c;
					// Make sure it's a stable sort
					return toRid[a.data].CompareTo(toRid[b.data]);
				};
			}

			public uint Rid(T data) {
				return toRid[data];
			}

			public bool TryGetRid(T data, out uint rid) {
				if (data == null) {
					rid = 0;
					return false;
				}
				return toRid.TryGetValue(data, out rid);
			}
		}

		internal sealed class Rows<T> where T : class {
			Dictionary<T, uint> dict = new Dictionary<T, uint>();

			public int Count {
				get { return dict.Count; }
			}

			public bool TryGetRid(T value, out uint rid) {
				if (value == null) {
					rid = 0;
					return false;
				}
				return dict.TryGetValue(value, out rid);
			}

			public bool Exists(T value) {
				return dict.ContainsKey(value);
			}

			public void Add(T value, uint rid) {
				dict.Add(value, rid);
			}

			public uint Rid(T value) {
				return dict[value];
			}

			public void SetRid(T value, uint rid) {
				dict[value] = rid;
			}
		}

		/// <summary>
		/// Creates a <see cref="MetaData"/> instance
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="constants">Constants list</param>
		/// <param name="methodBodies">Method bodies list</param>
		/// <param name="netResources">.NET resources list</param>
		/// <param name="options">Options</param>
		/// <param name="debugKind">Debug metadata kind</param>
		/// <returns>A new <see cref="MetaData"/> instance</returns>
		public static MetaData Create(ModuleDef module, UniqueChunkList<ByteArrayChunk> constants, MethodBodyChunks methodBodies, NetResources netResources, MetaDataOptions options = null, DebugMetaDataKind debugKind = DebugMetaDataKind.None) {
			if (options == null)
				options = new MetaDataOptions();
			if ((options.Flags & MetaDataFlags.PreserveRids) != 0 && module is ModuleDefMD)
				return new PreserveTokensMetaData(module, constants, methodBodies, netResources, options, debugKind, false);
			return new NormalMetaData(module, constants, methodBodies, netResources, options, debugKind, false);
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveTypeRefRids"/> bit
		/// </summary>
		public bool PreserveTypeRefRids {
			get { return (options.Flags & MetaDataFlags.PreserveTypeRefRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveTypeDefRids"/> bit
		/// </summary>
		public bool PreserveTypeDefRids {
			get { return (options.Flags & MetaDataFlags.PreserveTypeDefRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveFieldRids"/> bit
		/// </summary>
		public bool PreserveFieldRids {
			get { return (options.Flags & MetaDataFlags.PreserveFieldRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveMethodRids"/> bit
		/// </summary>
		public bool PreserveMethodRids {
			get { return (options.Flags & MetaDataFlags.PreserveMethodRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveParamRids"/> bit
		/// </summary>
		public bool PreserveParamRids {
			get { return (options.Flags & MetaDataFlags.PreserveParamRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveMemberRefRids"/> bit
		/// </summary>
		public bool PreserveMemberRefRids {
			get { return (options.Flags & MetaDataFlags.PreserveMemberRefRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveStandAloneSigRids"/> bit
		/// </summary>
		public bool PreserveStandAloneSigRids {
			get { return (options.Flags & MetaDataFlags.PreserveStandAloneSigRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveEventRids"/> bit
		/// </summary>
		public bool PreserveEventRids {
			get { return (options.Flags & MetaDataFlags.PreserveEventRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreservePropertyRids"/> bit
		/// </summary>
		public bool PreservePropertyRids {
			get { return (options.Flags & MetaDataFlags.PreservePropertyRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveTypeSpecRids"/> bit
		/// </summary>
		public bool PreserveTypeSpecRids {
			get { return (options.Flags & MetaDataFlags.PreserveTypeSpecRids) != 0; }
		}

		/// <summary>
		/// Gets the <see cref="MetaDataFlags.PreserveMethodSpecRids"/> bit
		/// </summary>
		public bool PreserveMethodSpecRids {
			get { return (options.Flags & MetaDataFlags.PreserveMethodSpecRids) != 0; }
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.PreserveStringsOffsets"/> bit
		/// </summary>
		public bool PreserveStringsOffsets {
			get { return (options.Flags & MetaDataFlags.PreserveStringsOffsets) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.PreserveStringsOffsets;
				else
					options.Flags &= ~MetaDataFlags.PreserveStringsOffsets;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.PreserveUSOffsets"/> bit
		/// </summary>
		public bool PreserveUSOffsets {
			get { return (options.Flags & MetaDataFlags.PreserveUSOffsets) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.PreserveUSOffsets;
				else
					options.Flags &= ~MetaDataFlags.PreserveUSOffsets;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.PreserveBlobOffsets"/> bit
		/// </summary>
		public bool PreserveBlobOffsets {
			get { return (options.Flags & MetaDataFlags.PreserveBlobOffsets) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.PreserveBlobOffsets;
				else
					options.Flags &= ~MetaDataFlags.PreserveBlobOffsets;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.PreserveExtraSignatureData"/> bit
		/// </summary>
		public bool PreserveExtraSignatureData {
			get { return (options.Flags & MetaDataFlags.PreserveExtraSignatureData) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.PreserveExtraSignatureData;
				else
					options.Flags &= ~MetaDataFlags.PreserveExtraSignatureData;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.KeepOldMaxStack"/> bit
		/// </summary>
		public bool KeepOldMaxStack {
			get { return (options.Flags & MetaDataFlags.KeepOldMaxStack) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.KeepOldMaxStack;
				else
					options.Flags &= ~MetaDataFlags.KeepOldMaxStack;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.AlwaysCreateGuidHeap"/> bit
		/// </summary>
		public bool AlwaysCreateGuidHeap {
			get { return (options.Flags & MetaDataFlags.AlwaysCreateGuidHeap) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.AlwaysCreateGuidHeap;
				else
					options.Flags &= ~MetaDataFlags.AlwaysCreateGuidHeap;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.AlwaysCreateStringsHeap"/> bit
		/// </summary>
		public bool AlwaysCreateStringsHeap {
			get { return (options.Flags & MetaDataFlags.AlwaysCreateStringsHeap) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.AlwaysCreateStringsHeap;
				else
					options.Flags &= ~MetaDataFlags.AlwaysCreateStringsHeap;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.AlwaysCreateUSHeap"/> bit
		/// </summary>
		public bool AlwaysCreateUSHeap {
			get { return (options.Flags & MetaDataFlags.AlwaysCreateUSHeap) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.AlwaysCreateUSHeap;
				else
					options.Flags &= ~MetaDataFlags.AlwaysCreateUSHeap;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.AlwaysCreateBlobHeap"/> bit
		/// </summary>
		public bool AlwaysCreateBlobHeap {
			get { return (options.Flags & MetaDataFlags.AlwaysCreateBlobHeap) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.AlwaysCreateBlobHeap;
				else
					options.Flags &= ~MetaDataFlags.AlwaysCreateBlobHeap;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaDataFlags.RoslynSortInterfaceImpl"/> bit
		/// </summary>
		public bool RoslynSortInterfaceImpl {
			get { return (options.Flags & MetaDataFlags.RoslynSortInterfaceImpl) != 0; }
			set {
				if (value)
					options.Flags |= MetaDataFlags.RoslynSortInterfaceImpl;
				else
					options.Flags &= ~MetaDataFlags.RoslynSortInterfaceImpl;
			}
		}

		/// <summary>
		/// If <c>true</c>, use the original Field RVAs. If it has no RVA, assume it's a new
		/// field value and create a new Field RVA.
		/// </summary>
		internal bool KeepFieldRVA { get; set; }

		/// <summary>
		/// Gets the number of methods that will be written.
		/// </summary>
		protected abstract int NumberOfMethods { get; }

		internal MetaData(ModuleDef module, UniqueChunkList<ByteArrayChunk> constants, MethodBodyChunks methodBodies, NetResources netResources, MetaDataOptions options, DebugMetaDataKind debugKind, bool isStandaloneDebugMetadata) {
			this.module = module;
			this.constants = constants;
			this.methodBodies = methodBodies;
			this.netResources = netResources;
			this.options = options ?? new MetaDataOptions();
			this.metaDataHeader = new MetaDataHeader(isStandaloneDebugMetadata ? this.options.DebugMetaDataHeaderOptions : this.options.MetaDataHeaderOptions);
			this.tablesHeap = new TablesHeap(this, isStandaloneDebugMetadata ? this.options.DebugTablesHeapOptions : this.options.TablesHeapOptions);
			this.stringsHeap = new StringsHeap();
			this.usHeap = new USHeap();
			this.guidHeap = new GuidHeap();
			this.blobHeap = new BlobHeap();
			this.pdbHeap = new PdbHeap();

			this.isStandaloneDebugMetadata = isStandaloneDebugMetadata;
			switch (debugKind) {
			case DebugMetaDataKind.None:
				break;

			case DebugMetaDataKind.Standalone:
				Debug.Assert(!isStandaloneDebugMetadata);
				//TODO: Refactor this into a smaller class
				debugMetaData = new NormalMetaData(module, constants, methodBodies, netResources, options, DebugMetaDataKind.None, true);
				break;

			default:
				throw new ArgumentOutOfRangeException("debugKind");
			}
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="module">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(ModuleDef module) {
			uint rid;
			moduleDefInfos.TryGetRid(module, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="tr">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(TypeRef tr);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(TypeDef td);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="fd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(FieldDef fd);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="md">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(MethodDef md);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="pd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(ParamDef pd);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ii">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(InterfaceImpl ii) {
			uint rid;
			interfaceImplInfos.TryGetRid(ii, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="mr">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(MemberRef mr);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="hc">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetConstantRid(IHasConstant hc) {
			uint rid;
			hasConstantInfos.TryGetRid(hc, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ca">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetCustomAttributeRid(CustomAttribute ca) {
			uint rid;
			customAttributeInfos.TryGetRid(ca, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="hfm">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetFieldMarshalRid(IHasFieldMarshal hfm) {
			uint rid;
			fieldMarshalInfos.TryGetRid(hfm, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ds">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(DeclSecurity ds) {
			uint rid;
			declSecurityInfos.TryGetRid(ds, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetClassLayoutRid(TypeDef td) {
			uint rid;
			classLayoutInfos.TryGetRid(td, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="fd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetFieldLayoutRid(FieldDef fd) {
			uint rid;
			fieldLayoutInfos.TryGetRid(fd, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="sas">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(StandAloneSig sas);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetEventMapRid(TypeDef td) {
			uint rid;
			eventMapInfos.TryGetRid(td, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ed">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(EventDef ed);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetPropertyMapRid(TypeDef td) {
			uint rid;
			propertyMapInfos.TryGetRid(td, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="pd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(PropertyDef pd);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="md">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetMethodSemanticsRid(MethodDef md) {
			uint rid;
			methodSemanticsInfos.TryGetRid(md, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="mr">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(ModuleRef mr) {
			uint rid;
			moduleRefInfos.TryGetRid(mr, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ts">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(TypeSpec ts);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="mf">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetImplMapRid(IMemberForwarded mf) {
			uint rid;
			implMapInfos.TryGetRid(mf, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="fd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetFieldRVARid(FieldDef fd) {
			uint rid;
			fieldRVAInfos.TryGetRid(fd, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="asm">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(AssemblyDef asm) {
			uint rid;
			assemblyInfos.TryGetRid(asm, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="asmRef">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(AssemblyRef asmRef) {
			uint rid;
			assemblyRefInfos.TryGetRid(asmRef, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="fd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(FileDef fd) {
			uint rid;
			fileDefInfos.TryGetRid(fd, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="et">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(ExportedType et) {
			uint rid;
			exportedTypeInfos.TryGetRid(et, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="resource">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetManifestResourceRid(Resource resource) {
			uint rid;
			manifestResourceInfos.TryGetRid(resource, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetNestedClassRid(TypeDef td) {
			uint rid;
			nestedClassInfos.TryGetRid(td, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="gp">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(GenericParam gp) {
			uint rid;
			genericParamInfos.TryGetRid(gp, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ms">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(MethodSpec ms);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="gpc">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(GenericParamConstraint gpc) {
			uint rid;
			genericParamConstraintInfos.TryGetRid(gpc, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="doc">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbDocument doc) {
			if (debugMetaData == null)
				return 0;
			uint rid;
			debugMetaData.pdbDocumentInfos.TryGetRid(doc, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="scope">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbScope scope) {
			if (debugMetaData == null)
				return 0;
			uint rid;
			debugMetaData.localScopeInfos.TryGetRid(scope, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="local">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbLocal local) {
			if (debugMetaData == null)
				return 0;
			uint rid;
			debugMetaData.localVariableInfos.TryGetRid(local, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="constant">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbConstant constant) {
			if (debugMetaData == null)
				return 0;
			uint rid;
			debugMetaData.localConstantInfos.TryGetRid(constant, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="importScope">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbImportScope importScope) {
			if (debugMetaData == null)
				return 0;
			uint rid;
			debugMetaData.importScopeInfos.TryGetRid(importScope, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="asyncMethod">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetStateMachineMethodRid(PdbAsyncMethodCustomDebugInfo asyncMethod) {
			if (debugMetaData == null)
				return 0;
			uint rid;
			debugMetaData.stateMachineMethodInfos.TryGetRid(asyncMethod, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="iteratorMethod">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetStateMachineMethodRid(PdbIteratorMethodCustomDebugInfo iteratorMethod) {
			if (debugMetaData == null)
				return 0;
			uint rid;
			debugMetaData.stateMachineMethodInfos.TryGetRid(iteratorMethod, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="cdi">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetCustomDebugInfoRid(PdbCustomDebugInfo cdi) {
			if (debugMetaData == null)
				return 0;
			uint rid;
			debugMetaData.customDebugInfos.TryGetRid(cdi, out rid);
			return rid;
		}

		/// <summary>
		/// Gets the <see cref="MethodBody"/>
		/// </summary>
		/// <param name="md">Method</param>
		/// <returns>The <see cref="MethodBody"/> or <c>null</c> if <paramref name="md"/> is
		/// <c>null</c> or not a method defined in this module.</returns>
		public MethodBody GetMethodBody(MethodDef md) {
			if (md == null)
				return null;
			MethodBody mb;
			methodToBody.TryGetValue(md, out mb);
			return mb;
		}

		/// <summary>
		/// Gets a method's local variable signature token
		/// </summary>
		/// <param name="md">Method</param>
		/// <returns>Locals sig token or <c>0</c></returns>
		public uint GetLocalVarSigToken(MethodDef md) {
			var mb = GetMethodBody(md);
			return mb == null ? 0 : mb.LocalVarSigTok;
		}

		/// <summary>
		/// Gets the <see cref="ByteArrayChunk"/> where the resource data will be stored
		/// </summary>
		/// <param name="er">Embedded resource</param>
		/// <returns>A <see cref="ByteArrayChunk"/> instance or <c>null</c> if <paramref name="er"/>
		/// is invalid</returns>
		public ByteArrayChunk GetChunk(EmbeddedResource er) {
			if (er == null)
				return null;
			ByteArrayChunk chunk;
			embeddedResourceToByteArray.TryGetValue(er, out chunk);
			return chunk;
		}

		/// <summary>
		/// Gets the <see cref="ByteArrayChunk"/> where the initial value is stored
		/// </summary>
		/// <param name="fd">Field</param>
		/// <returns>A <see cref="ByteArrayChunk"/> instance or <c>null</c> if <paramref name="fd"/>
		/// is invalid</returns>
		public ByteArrayChunk GetInitialValueChunk(FieldDef fd) {
			if (fd == null)
				return null;
			ByteArrayChunk chunk;
			fieldToInitialValue.TryGetValue(fd, out chunk);
			return chunk;
		}

		ILogger GetLogger() {
			return logger ?? DummyLogger.ThrowModuleWriterExceptionOnErrorInstance;
		}

		/// <summary>
		/// Called when an error is detected
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="args">Optional message arguments</param>
		protected void Error(string message, params object[] args) {
			GetLogger().Log(this, LoggerEvent.Error, message, args);
		}

		/// <summary>
		/// Called to warn of something
		/// </summary>
		/// <param name="message">Warning message</param>
		/// <param name="args">Optional message arguments</param>
		protected void Warning(string message, params object[] args) {
			GetLogger().Log(this, LoggerEvent.Warning, message, args);
		}

		/// <summary>
		/// Creates the .NET metadata tables
		/// </summary>
		public void CreateTables() {
			Listener.OnMetaDataEvent(this, MetaDataEvent.BeginCreateTables);

			if (module.Types.Count == 0 || module.Types[0] == null)
				throw new ModuleWriterException("Missing global <Module> type");

			var moduleDefMD = module as ModuleDefMD;
			if (moduleDefMD != null) {
				if (PreserveStringsOffsets)
					stringsHeap.Populate(moduleDefMD.StringsStream);
				if (PreserveUSOffsets)
					usHeap.Populate(moduleDefMD.USStream);
				if (PreserveBlobOffsets)
					blobHeap.Populate(moduleDefMD.BlobStream);
			}

			Create();
		}

		/// <summary>
		/// Updates each <c>Method</c> row's <c>RVA</c> column if it has any code
		/// </summary>
		void UpdateMethodRvas() {
			foreach (var kv in methodToBody) {
				var method = kv.Key;
				var body = kv.Value;
				var row = tablesHeap.MethodTable[GetRid(method)];
				row.RVA = (uint)body.RVA;
			}
			foreach (var kv in methodToNativeBody) {
				var method = kv.Key;
				var body = kv.Value;
				var row = tablesHeap.MethodTable[GetRid(method)];
				row.RVA = (uint)body.RVA;
			}
		}

		/// <summary>
		/// Updates the <c>FieldRVA</c> rows
		/// </summary>
		void UpdateFieldRvas() {
			foreach (var kv in fieldToInitialValue) {
				var field = kv.Key;
				var iv = kv.Value;
				var row = tablesHeap.FieldRVATable[fieldRVAInfos.Rid(field)];
				row.RVA = (uint)iv.RVA;
			}
		}

		void Create() {
			Debug.Assert(!isStandaloneDebugMetadata);
			Initialize();
			allTypeDefs = GetAllTypeDefs();
			Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateTypeDefRids);
			AllocateTypeDefRids();
			Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateMemberDefRids);
			AllocateMemberDefRids();
			Listener.OnMetaDataEvent(this, MetaDataEvent.MemberDefRidsAllocated);

			AddModule(module);
			AddPdbDocuments();
			InitializeMethodDebugInformation();
			InitializeTypeDefsAndMemberDefs();
			Listener.OnMetaDataEvent(this, MetaDataEvent.MemberDefsInitialized);

			InitializeVTableFixups();

			AddExportedTypes();
			InitializeEntryPoint();
			if (module.Assembly != null)
				AddAssembly(module.Assembly, AssemblyPublicKey);

			Listener.OnMetaDataEvent(this, MetaDataEvent.BeforeSortTables);
			SortTables();
			InitializeGenericParamConstraintTable();
			Listener.OnMetaDataEvent(this, MetaDataEvent.MostTablesSorted);

			WriteTypeDefAndMemberDefCustomAttributesAndCustomDebugInfos();
			Listener.OnMetaDataEvent(this, MetaDataEvent.MemberDefCustomAttributesWritten);

			Listener.OnMetaDataEvent(this, MetaDataEvent.BeginAddResources);
			AddResources(module.Resources);
			Listener.OnMetaDataEvent(this, MetaDataEvent.EndAddResources);

			Listener.OnMetaDataEvent(this, MetaDataEvent.BeginWriteMethodBodies);
			WriteMethodBodies();
			Listener.OnMetaDataEvent(this, MetaDataEvent.EndWriteMethodBodies);

			BeforeSortingCustomAttributes();
			InitializeCustomAttributeAndCustomDebugInfoTables();
			Listener.OnMetaDataEvent(this, MetaDataEvent.OnAllTablesSorted);

			EverythingInitialized();
			Listener.OnMetaDataEvent(this, MetaDataEvent.EndCreateTables);
		}

		/// <summary>
		/// Initializes all <c>TypeDef</c>, <c>Field</c>, <c>Method</c>, <c>Event</c>,
		/// <c>Property</c> and <c>Param</c> rows. Other tables that are related to these six
		/// tables are also updated. No custom attributes are written yet, though. Method bodies
		/// aren't written either.
		/// </summary>
		void InitializeTypeDefsAndMemberDefs() {
			int numTypes = allTypeDefs.Count;
			int typeNum = 0;
			int notifyNum = 0;
			const int numNotifyEvents = 5; // InitializeTypeDefsAndMemberDefs0 - InitializeTypeDefsAndMemberDefs4
			int notifyAfter = numTypes / numNotifyEvents;

			foreach (var type in allTypeDefs) {
				if (typeNum++ == notifyAfter && notifyNum < numNotifyEvents) {
					Listener.OnMetaDataEvent(this, MetaDataEvent.InitializeTypeDefsAndMemberDefs0 + notifyNum++);
					notifyAfter += numTypes / numNotifyEvents;
				}

				if (type == null) {
					Error("TypeDef is null");
					continue;
				}
				uint typeRid = GetRid(type);
				var typeRow = tablesHeap.TypeDefTable[typeRid];
				typeRow.Flags = (uint)type.Attributes;
				typeRow.Name = stringsHeap.Add(type.Name);
				typeRow.Namespace = stringsHeap.Add(type.Namespace);
				typeRow.Extends = type.BaseType == null ? 0 : AddTypeDefOrRef(type.BaseType);
				AddGenericParams(new MDToken(Table.TypeDef, typeRid), type.GenericParameters);
				AddDeclSecurities(new MDToken(Table.TypeDef, typeRid), type.DeclSecurities);
				AddInterfaceImpls(typeRid, type.Interfaces);
				AddClassLayout(type);
				AddNestedType(type, type.DeclaringType);

				foreach (var field in type.Fields) {
					if (field == null) {
						Error("Field is null. TypeDef {0} ({1:X8})", type, type.MDToken.Raw);
						continue;
					}
					uint rid = GetRid(field);
					var row = tablesHeap.FieldTable[rid];
					row.Flags = (ushort)field.Attributes;
					row.Name = stringsHeap.Add(field.Name);
					row.Signature = GetSignature(field.Signature);
					AddFieldLayout(field);
					AddFieldMarshal(new MDToken(Table.Field, rid), field);
					AddFieldRVA(field);
					AddImplMap(new MDToken(Table.Field, rid), field);
					AddConstant(new MDToken(Table.Field, rid), field);
				}

				foreach (var method in type.Methods) {
					if (method == null) {
						Error("Method is null. TypeDef {0} ({1:X8})", type, type.MDToken.Raw);
						continue;
					}
					if (method.ExportInfo != null)
						ExportedMethods.Add(method);
					uint rid = GetRid(method);
					var row = tablesHeap.MethodTable[rid];
					row.ImplFlags = (ushort)method.ImplAttributes;
					row.Flags = (ushort)method.Attributes;
					row.Name = stringsHeap.Add(method.Name);
					row.Signature = GetSignature(method.Signature);
					AddGenericParams(new MDToken(Table.Method, rid), method.GenericParameters);
					AddDeclSecurities(new MDToken(Table.Method, rid), method.DeclSecurities);
					AddImplMap(new MDToken(Table.Method, rid), method);
					AddMethodImpls(method, method.Overrides);
					foreach (var pd in method.ParamDefs) {
						if (pd == null) {
							Error("Param is null. Method {0} ({1:X8})", method, method.MDToken.Raw);
							continue;
						}
						uint pdRid = GetRid(pd);
						var pdRow = tablesHeap.ParamTable[pdRid];
						pdRow.Flags = (ushort)pd.Attributes;
						pdRow.Sequence = pd.Sequence;
						pdRow.Name = stringsHeap.Add(pd.Name);
						AddConstant(new MDToken(Table.Param, pdRid), pd);
						AddFieldMarshal(new MDToken(Table.Param, pdRid), pd);
					}
				}

				if (!IsEmpty(type.Events)) {
					foreach (var evt in type.Events) {
						if (evt == null) {
							Error("Event is null. TypeDef {0} ({1:X8})", type, type.MDToken.Raw);
							continue;
						}
						uint rid = GetRid(evt);
						var row = tablesHeap.EventTable[rid];
						row.EventFlags = (ushort)evt.Attributes;
						row.Name = stringsHeap.Add(evt.Name);
						row.EventType = AddTypeDefOrRef(evt.EventType);
						AddMethodSemantics(evt);
					}
				}

				if (!IsEmpty(type.Properties)) {
					foreach (var prop in type.Properties) {
						if (prop == null) {
							Error("Property is null. TypeDef {0} ({1:X8})", type, type.MDToken.Raw);
							continue;
						}
						uint rid = GetRid(prop);
						var row = tablesHeap.PropertyTable[rid];
						row.PropFlags = (ushort)prop.Attributes;
						row.Name = stringsHeap.Add(prop.Name);
						row.Type = GetSignature(prop.Type);
						AddConstant(new MDToken(Table.Property, rid), prop);
						AddMethodSemantics(prop);
					}
				}
			}
			while (notifyNum < numNotifyEvents)
				Listener.OnMetaDataEvent(this, MetaDataEvent.InitializeTypeDefsAndMemberDefs0 + notifyNum++);
		}

		/// <summary>
		/// Writes <c>TypeDef</c>, <c>Field</c>, <c>Method</c>, <c>Event</c>,
		/// <c>Property</c> and <c>Param</c> custom attributes and custom debug infos.
		/// </summary>
		void WriteTypeDefAndMemberDefCustomAttributesAndCustomDebugInfos() {
			int numTypes = allTypeDefs.Count;
			int typeNum = 0;
			int notifyNum = 0;
			const int numNotifyEvents = 5; // WriteTypeDefAndMemberDefCustomAttributes0 - WriteTypeDefAndMemberDefCustomAttributes4
			int notifyAfter = numTypes / numNotifyEvents;

			uint rid;
			foreach (var type in allTypeDefs) {
				if (typeNum++ == notifyAfter && notifyNum < numNotifyEvents) {
					Listener.OnMetaDataEvent(this, MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes0 + notifyNum++);
					notifyAfter += numTypes / numNotifyEvents;
				}

				if (type == null)
					continue;
				rid = GetRid(type);
				AddCustomAttributes(Table.TypeDef, rid, type);
				AddCustomDebugInformationList(Table.TypeDef, rid, type);

				foreach (var field in type.Fields) {
					if (field == null)
						continue;
					rid = GetRid(field);
					AddCustomAttributes(Table.Field, rid, field);
					AddCustomDebugInformationList(Table.Field, rid, field);
				}

				foreach (var method in type.Methods) {
					if (method == null)
						continue;
					AddCustomAttributes(Table.Method, GetRid(method), method);
					// Method custom debug info is added later when writing method bodies
					foreach (var pd in method.ParamDefs) {
						if (pd == null)
							continue;
						rid = GetRid(pd);
						AddCustomAttributes(Table.Param, rid, pd);
						AddCustomDebugInformationList(Table.Param, rid, pd);
					}
				}
				foreach (var evt in type.Events) {
					if (evt == null)
						continue;
					rid = GetRid(evt);
					AddCustomAttributes(Table.Event, rid, evt);
					AddCustomDebugInformationList(Table.Event, rid, evt);
				}
				foreach (var prop in type.Properties) {
					if (prop == null)
						continue;
					rid = GetRid(prop);
					AddCustomAttributes(Table.Property, rid, prop);
					AddCustomDebugInformationList(Table.Property, rid, prop);
				}
			}
			while (notifyNum < numNotifyEvents)
				Listener.OnMetaDataEvent(this, MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes0 + notifyNum++);
		}

		/// <summary>
		/// Adds the tokens of all methods in all vtables, if any
		/// </summary>
		void InitializeVTableFixups() {
			var fixups = module.VTableFixups;
			if (fixups == null || fixups.VTables.Count == 0)
				return;

			foreach (var vtable in fixups) {
				if (vtable == null) {
					Error("VTable is null");
					continue;
				}
				foreach (var method in vtable) {
					if (method == null)
						continue;
					AddMDTokenProvider(method);
				}
			}
		}

		void AddExportedTypes() {
			foreach (var et in module.ExportedTypes)
				AddExportedType(et);
		}

		/// <summary>
		/// Adds the entry point. It's only needed if it's a <see cref="FileDef"/> since if it's
		/// a <see cref="MethodDef"/>, it will have already been added.
		/// </summary>
		void InitializeEntryPoint() {
			var epFile = module.ManagedEntryPoint as FileDef;
			if (epFile != null)
				AddFile(epFile);
		}

		/// <summary>
		/// Sorts all unsorted tables except <c>GenericParamConstraint</c> and <c>CustomAttribute</c>
		/// </summary>
		void SortTables() {
			classLayoutInfos.Sort((a, b)	=> a.row.Parent.CompareTo(b.row.Parent));
			hasConstantInfos.Sort((a, b)	=> a.row.Parent.CompareTo(b.row.Parent));
			declSecurityInfos.Sort((a, b)	=> a.row.Parent.CompareTo(b.row.Parent));
			fieldLayoutInfos.Sort((a, b)	=> a.row.Field.CompareTo(b.row.Field));
			fieldMarshalInfos.Sort((a, b)	=> a.row.Parent.CompareTo(b.row.Parent));
			fieldRVAInfos.Sort((a, b)		=> a.row.Field.CompareTo(b.row.Field));
			implMapInfos.Sort((a, b)		=> a.row.MemberForwarded.CompareTo(b.row.MemberForwarded));
			methodImplInfos.Sort((a, b)		=> a.row.Class.CompareTo(b.row.Class));
			methodSemanticsInfos.Sort((a, b)=> a.row.Association.CompareTo(b.row.Association));
			nestedClassInfos.Sort((a, b)	=> a.row.NestedClass.CompareTo(b.row.NestedClass));
			genericParamInfos.Sort((a, b) => {
				if (a.row.Owner != b.row.Owner)
					return a.row.Owner.CompareTo(b.row.Owner);
				return a.row.Number.CompareTo(b.row.Number);
			});
			if (RoslynSortInterfaceImpl)
				interfaceImplInfos.Sort((a, b) => a.row.Class.CompareTo(b.row.Class));
			else {
				interfaceImplInfos.Sort((a, b) => {
					if (a.row.Class != b.row.Class)
						return a.row.Class.CompareTo(b.row.Class);
					return a.row.Interface.CompareTo(b.row.Interface);
				});
			}

			tablesHeap.ClassLayoutTable.IsSorted = true;
			tablesHeap.ConstantTable.IsSorted = true;
			tablesHeap.DeclSecurityTable.IsSorted = true;
			tablesHeap.FieldLayoutTable.IsSorted = true;
			tablesHeap.FieldMarshalTable.IsSorted = true;
			tablesHeap.FieldRVATable.IsSorted = true;
			tablesHeap.GenericParamTable.IsSorted = true;
			tablesHeap.ImplMapTable.IsSorted = true;
			tablesHeap.InterfaceImplTable.IsSorted = true;
			tablesHeap.MethodImplTable.IsSorted = true;
			tablesHeap.MethodSemanticsTable.IsSorted = true;
			tablesHeap.NestedClassTable.IsSorted = true;

			// These two are also sorted
			tablesHeap.EventMapTable.IsSorted = true;
			tablesHeap.PropertyMapTable.IsSorted = true;

			foreach (var info in classLayoutInfos.infos) tablesHeap.ClassLayoutTable.Create(info.row);
			foreach (var info in hasConstantInfos.infos) tablesHeap.ConstantTable.Create(info.row);
			foreach (var info in declSecurityInfos.infos) tablesHeap.DeclSecurityTable.Create(info.row);
			foreach (var info in fieldLayoutInfos.infos) tablesHeap.FieldLayoutTable.Create(info.row);
			foreach (var info in fieldMarshalInfos.infos) tablesHeap.FieldMarshalTable.Create(info.row);
			foreach (var info in fieldRVAInfos.infos) tablesHeap.FieldRVATable.Create(info.row);
			foreach (var info in genericParamInfos.infos) tablesHeap.GenericParamTable.Create(info.row);
			foreach (var info in implMapInfos.infos) tablesHeap.ImplMapTable.Create(info.row);
			foreach (var info in interfaceImplInfos.infos) tablesHeap.InterfaceImplTable.Create(info.row);
			foreach (var info in methodImplInfos.infos) tablesHeap.MethodImplTable.Create(info.row);
			foreach (var info in methodSemanticsInfos.infos) tablesHeap.MethodSemanticsTable.Create(info.row);
			foreach (var info in nestedClassInfos.infos) tablesHeap.NestedClassTable.Create(info.row);

			foreach (var info in interfaceImplInfos.infos) {
				uint rid = interfaceImplInfos.Rid(info.data);
				AddCustomAttributes(Table.InterfaceImpl, rid, info.data);
				AddCustomDebugInformationList(Table.InterfaceImpl, rid, info.data);
			}
			foreach (var info in declSecurityInfos.infos) {
				uint rid = declSecurityInfos.Rid(info.data);
				AddCustomAttributes(Table.DeclSecurity, rid, info.data);
				AddCustomDebugInformationList(Table.DeclSecurity, rid, info.data);
			}
			foreach (var info in genericParamInfos.infos) {
				uint rid = genericParamInfos.Rid(info.data);
				AddCustomAttributes(Table.GenericParam, rid, info.data);
				AddCustomDebugInformationList(Table.GenericParam, rid, info.data);
			}
		}

		/// <summary>
		/// Initializes the <c>GenericParamConstraint</c> table
		/// </summary>
		void InitializeGenericParamConstraintTable() {
			foreach (var type in allTypeDefs) {
				if (type == null)
					continue;
				AddGenericParamConstraints(type.GenericParameters);
				foreach (var method in type.Methods) {
					if (method == null)
						continue;
					AddGenericParamConstraints(method.GenericParameters);
				}
			}
			genericParamConstraintInfos.Sort((a, b) => a.row.Owner.CompareTo(b.row.Owner));
			tablesHeap.GenericParamConstraintTable.IsSorted = true;
			foreach (var info in genericParamConstraintInfos.infos)
				tablesHeap.GenericParamConstraintTable.Create(info.row);
			foreach (var info in genericParamConstraintInfos.infos) {
				uint rid = genericParamConstraintInfos.Rid(info.data);
				AddCustomAttributes(Table.GenericParamConstraint, rid, info.data);
				AddCustomDebugInformationList(Table.GenericParamConstraint, rid, info.data);
			}
		}

		/// <summary>
		/// Inserts all custom attribute / custom debug info rows in the tables and sort them
		/// </summary>
		void InitializeCustomAttributeAndCustomDebugInfoTables() {
			customAttributeInfos.Sort((a, b) => a.row.Parent.CompareTo(b.row.Parent));
			tablesHeap.CustomAttributeTable.IsSorted = true;
			foreach (var info in customAttributeInfos.infos)
				tablesHeap.CustomAttributeTable.Create(info.row);

			if (debugMetaData != null) {
				debugMetaData.stateMachineMethodInfos.Sort((a, b) => a.row.MoveNextMethod.CompareTo(b.row.MoveNextMethod));
				debugMetaData.tablesHeap.StateMachineMethodTable.IsSorted = true;
				foreach (var info in debugMetaData.stateMachineMethodInfos.infos)
					debugMetaData.tablesHeap.StateMachineMethodTable.Create(info.row);

				debugMetaData.customDebugInfos.Sort((a, b) => a.row.Parent.CompareTo(b.row.Parent));
				debugMetaData.tablesHeap.CustomDebugInformationTable.IsSorted = true;
				foreach (var info in debugMetaData.customDebugInfos.infos)
					debugMetaData.tablesHeap.CustomDebugInformationTable.Create(info.row);
			}
		}

		struct MethodScopeDebugInfo {
			public uint MethodRid;
			public PdbScope Scope;
			public uint ScopeStart;
			public uint ScopeLength;
		}

		/// <summary>
		/// Writes all method bodies
		/// </summary>
		void WriteMethodBodies() {
			Debug.Assert(!isStandaloneDebugMetadata);
			int numMethods = NumberOfMethods;
			int methodNum = 0;
			int notifyNum = 0;
			const int numNotifyEvents = 10; // WriteMethodBodies0 - WriteMethodBodies9
			int notifyAfter = numMethods / numNotifyEvents;

			List<MethodScopeDebugInfo> methodScopeDebugInfos;
			List<PdbScope> scopeStack;
			SerializerMethodContext serializerMethodContext;
			if (debugMetaData == null) {
				methodScopeDebugInfos = null;
				scopeStack = null;
				serializerMethodContext = null;
			}
			else {
				methodScopeDebugInfos = new List<MethodScopeDebugInfo>();
				scopeStack = new List<PdbScope>();
				serializerMethodContext = AllocSerializerMethodContext();
			}

			bool keepMaxStack = KeepOldMaxStack;
			var writer = new MethodBodyWriter(this);
			foreach (var type in allTypeDefs) {
				if (type == null)
					continue;

				foreach (var method in type.Methods) {
					if (method == null)
						continue;

					if (methodNum++ == notifyAfter && notifyNum < numNotifyEvents) {
						Listener.OnMetaDataEvent(this, MetaDataEvent.WriteMethodBodies0 + notifyNum++);
						notifyAfter += numMethods / numNotifyEvents;
					}

					uint localVarSigTok = 0;
					uint rid = GetRid(method);

					var cilBody = method.Body;
					if (cilBody != null) {
						if (!(cilBody.Instructions.Count == 0 && cilBody.Variables.Count == 0)) {
							writer.Reset(cilBody, keepMaxStack || cilBody.KeepOldMaxStack);
							writer.Write();
							var mb = methodBodies.Add(new MethodBody(writer.Code, writer.ExtraSections, writer.LocalVarSigTok));
							methodToBody[method] = mb;
							localVarSigTok = writer.LocalVarSigTok;
						}
					}
					else {
						var nativeBody = method.NativeBody;
						if (nativeBody != null)
							methodToNativeBody[method] = nativeBody;
						else if (method.MethodBody != null)
							Error("Unsupported method body");
					}

					if (debugMetaData != null) {
						if (cilBody != null) {
							var pdbMethod = cilBody.PdbMethod;
							if (pdbMethod != null) {
								// We don't need to write empty scopes
								if (!IsEmptyRootScope(cilBody, pdbMethod.Scope)) {
									serializerMethodContext.SetBody(method);
									scopeStack.Add(pdbMethod.Scope);
									while (scopeStack.Count > 0) {
										var scope = scopeStack[scopeStack.Count - 1];
										scopeStack.RemoveAt(scopeStack.Count - 1);
										scopeStack.AddRange(scope.Scopes);
										uint scopeStart = serializerMethodContext.GetOffset(scope.Start);
										uint scopeEnd = serializerMethodContext.GetOffset(scope.End);
										methodScopeDebugInfos.Add(new MethodScopeDebugInfo() {
											MethodRid = rid,
											Scope = scope,
											ScopeStart = scopeStart,
											ScopeLength = scopeEnd - scopeStart,
										});
									}
								}
							}
						}
					}
					// Always add CDIs even if it has no managed method body
					AddCustomDebugInformationList(method, rid, localVarSigTok);
				}
			}
			if (debugMetaData != null) {
				methodScopeDebugInfos.Sort((a, b) => {
					int c = a.MethodRid.CompareTo(b.MethodRid);
					if (c != 0)
						return c;
					c = a.ScopeStart.CompareTo(b.ScopeStart);
					if (c != 0)
						return c;
					return b.ScopeLength.CompareTo(a.ScopeLength);
				});
				foreach (var info in methodScopeDebugInfos) {
					var row = new RawLocalScopeRow();
					debugMetaData.localScopeInfos.Add(info.Scope, row);
					uint localScopeRid = (uint)debugMetaData.localScopeInfos.infos.Count;
					row.Method = info.MethodRid;
					row.ImportScope = AddImportScope(info.Scope.ImportScope);
					row.VariableList = (uint)debugMetaData.tablesHeap.LocalVariableTable.Rows + 1;
					row.ConstantList = (uint)debugMetaData.tablesHeap.LocalConstantTable.Rows + 1;
					row.StartOffset = info.ScopeStart;
					row.Length = info.ScopeLength;
					foreach (var local in info.Scope.Variables)
						AddLocalVariable(local);
					foreach (var constant in info.Scope.Constants)
						AddLocalConstant(constant);
					AddCustomDebugInformationList(Table.LocalScope, localScopeRid, info.Scope.CustomDebugInfos);
				}

				debugMetaData.tablesHeap.LocalScopeTable.IsSorted = true;
				foreach (var info in debugMetaData.localScopeInfos.infos)
					debugMetaData.tablesHeap.LocalScopeTable.Create(info.row);
			}
			if (serializerMethodContext != null)
				Free(ref serializerMethodContext);
			while (notifyNum < numNotifyEvents)
				Listener.OnMetaDataEvent(this, MetaDataEvent.WriteMethodBodies0 + notifyNum++);
		}

		static bool IsEmptyRootScope(CilBody cilBody, PdbScope scope) {
			if (scope.Variables.Count != 0)
				return false;
			if (scope.Constants.Count != 0)
				return false;
			if (scope.Namespaces.Count != 0)
				return false;
			if (scope.ImportScope != null)
				return false;
			if (scope.Scopes.Count != 0)
				return false;
			if (scope.CustomDebugInfos.Count != 0)
				return false;
			if (scope.End != null)
				return false;
			if (cilBody.Instructions.Count != 0 && cilBody.Instructions[0] != scope.Start)
				return false;

			return true;
		}

		/// <summary>
		/// Checks whether a list is empty or whether it contains only <c>null</c>s
		/// </summary>
		/// <typeparam name="T">Any type</typeparam>
		/// <param name="list">The list</param>
		/// <returns><c>true</c> if the list is empty or if it contains only <c>null</c>s, <c>false</c> otherwise</returns>
		protected static bool IsEmpty<T>(IList<T> list) where T : class {
			if (list == null)
				return true;
			foreach (var e in list) {
				if (e != null)
					return false;
			}
			return true;
		}

		/// <inheritdoc/>
		public MDToken GetToken(object o) {
			var tp = o as IMDTokenProvider;
			if (tp != null)
				return new MDToken(tp.MDToken.Table, AddMDTokenProvider(tp));

			var s = o as string;
			if (s != null)
				return new MDToken((Table)0x70, usHeap.Add(s));

			var methodSig = o as MethodSig;
			if (methodSig != null)
				return new MDToken(Table.StandAloneSig, AddStandAloneSig(methodSig, methodSig.OriginalToken));

			var fieldSig = o as FieldSig;
			if (fieldSig != null)
				return new MDToken(Table.StandAloneSig, AddStandAloneSig(fieldSig, 0));

			if (o == null)
				Error("Instruction operand is null");
			else
				Error("Invalid instruction operand");
			return new MDToken((Table)0xFF, 0x00FFFFFF);
		}

		/// <inheritdoc/>
		public virtual MDToken GetToken(IList<TypeSig> locals, uint origToken) {
			if (locals == null || locals.Count == 0)
				return new MDToken((Table)0, 0);

			var row = new RawStandAloneSigRow(GetSignature(new LocalSig(locals, false)));
			uint rid = tablesHeap.StandAloneSigTable.Add(row);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return new MDToken(Table.StandAloneSig, rid);
		}

		/// <summary>
		/// Adds a <see cref="StandAloneSig"/>
		/// </summary>
		/// <param name="methodSig">Method signature</param>
		/// <param name="origToken">Original <c>StandAloneSig</c> token or 0 if none</param>
		/// <returns>Its new rid</returns>
		protected virtual uint AddStandAloneSig(MethodSig methodSig, uint origToken) {
			if (methodSig == null) {
				Error("StandAloneSig: MethodSig is null");
				return 0;
			}

			var row = new RawStandAloneSigRow(GetSignature(methodSig));
			uint rid = tablesHeap.StandAloneSigTable.Add(row);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return rid;
		}

		/// <summary>
		/// Adds a <see cref="StandAloneSig"/>
		/// </summary>
		/// <param name="fieldSig">FIeld signature</param>
		/// <param name="origToken">Original <c>StandAloneSig</c> token or 0 if none</param>
		/// <returns>Its new rid</returns>
		protected virtual uint AddStandAloneSig(FieldSig fieldSig, uint origToken) {
			if (fieldSig == null) {
				Error("StandAloneSig: FieldSig is null");
				return 0;
			}

			var row = new RawStandAloneSigRow(GetSignature(fieldSig));
			uint rid = tablesHeap.StandAloneSigTable.Add(row);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return rid;
		}

		uint AddMDTokenProvider(IMDTokenProvider tp) {
			if (tp != null) {
				switch (tp.MDToken.Table) {
				case Table.Module:
					return AddModule((ModuleDef)tp);

				case Table.TypeRef:
					return AddTypeRef((TypeRef)tp);

				case Table.TypeDef:
					return GetRid((TypeDef)tp);

				case Table.Field:
					return GetRid((FieldDef)tp);

				case Table.Method:
					return GetRid((MethodDef)tp);

				case Table.Param:
					return GetRid((ParamDef)tp);

				case Table.MemberRef:
					return AddMemberRef((MemberRef)tp);

				case Table.StandAloneSig:
					return AddStandAloneSig((StandAloneSig)tp);

				case Table.Event:
					return GetRid((EventDef)tp);

				case Table.Property:
					return GetRid((PropertyDef)tp);

				case Table.ModuleRef:
					return AddModuleRef((ModuleRef)tp);

				case Table.TypeSpec:
					return AddTypeSpec((TypeSpec)tp);

				case Table.Assembly:
					return AddAssembly((AssemblyDef)tp, null);

				case Table.AssemblyRef:
					return AddAssemblyRef((AssemblyRef)tp);

				case Table.File:
					return AddFile((FileDef)tp);

				case Table.ExportedType:
					return AddExportedType((ExportedType)tp);

				case Table.MethodSpec:
					return AddMethodSpec((MethodSpec)tp);

				case Table.FieldPtr:
				case Table.MethodPtr:
				case Table.ParamPtr:
				case Table.InterfaceImpl:
				case Table.Constant:
				case Table.CustomAttribute:
				case Table.FieldMarshal:
				case Table.DeclSecurity:
				case Table.ClassLayout:
				case Table.FieldLayout:
				case Table.EventMap:
				case Table.EventPtr:
				case Table.PropertyMap:
				case Table.PropertyPtr:
				case Table.MethodSemantics:
				case Table.MethodImpl:
				case Table.ImplMap:
				case Table.FieldRVA:
				case Table.ENCLog:
				case Table.ENCMap:
				case Table.AssemblyProcessor:
				case Table.AssemblyOS:
				case Table.AssemblyRefProcessor:
				case Table.AssemblyRefOS:
				case Table.ManifestResource:
				case Table.NestedClass:
				case Table.GenericParam:
				case Table.GenericParamConstraint:
				case Table.Document:
				case Table.MethodDebugInformation:
				case Table.LocalScope:
				case Table.LocalVariable:
				case Table.LocalConstant:
				case Table.ImportScope:
				case Table.StateMachineMethod:
				case Table.CustomDebugInformation:
				default:
					break;
				}
			}

			if (tp == null)
				Error("IMDTokenProvider is null");
			else
				Error("Invalid IMDTokenProvider");
			return 0;
		}

		/// <summary>
		/// Adds a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="tdr">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddTypeDefOrRef(ITypeDefOrRef tdr) {
			if (tdr == null) {
				Error("TypeDefOrRef is null");
				return 0;
			}

			var token = new MDToken(tdr.MDToken.Table, AddMDTokenProvider(tdr));
			uint encodedToken;
			if (!CodedToken.TypeDefOrRef.Encode(token, out encodedToken)) {
				Error("Can't encode TypeDefOrRef token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="IResolutionScope"/>
		/// </summary>
		/// <param name="rs">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddResolutionScope(IResolutionScope rs) {
			if (rs == null) {
				Error("ResolutionScope is null");
				return 0;
			}

			var token = new MDToken(rs.MDToken.Table, AddMDTokenProvider(rs));
			uint encodedToken;
			if (!CodedToken.ResolutionScope.Encode(token, out encodedToken)) {
				Error("Can't encode ResolutionScope token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="IMethodDefOrRef"/>
		/// </summary>
		/// <param name="mdr">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddMethodDefOrRef(IMethodDefOrRef mdr) {
			if (mdr == null) {
				Error("MethodDefOrRef is null");
				return 0;
			}

			var token = new MDToken(mdr.MDToken.Table, AddMDTokenProvider(mdr));
			uint encodedToken;
			if (!CodedToken.MethodDefOrRef.Encode(token, out encodedToken)) {
				Error("Can't encode MethodDefOrRef token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="IMemberRefParent"/>
		/// </summary>
		/// <param name="parent">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddMemberRefParent(IMemberRefParent parent) {
			if (parent == null) {
				Error("MemberRefParent is null");
				return 0;
			}

			var token = new MDToken(parent.MDToken.Table, AddMDTokenProvider(parent));
			uint encodedToken;
			if (!CodedToken.MemberRefParent.Encode(token, out encodedToken)) {
				Error("Can't encode MemberRefParent token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="IImplementation"/>
		/// </summary>
		/// <param name="impl">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddImplementation(IImplementation impl) {
			if (impl == null) {
				Error("Implementation is null");
				return 0;
			}

			var token = new MDToken(impl.MDToken.Table, AddMDTokenProvider(impl));
			uint encodedToken;
			if (!CodedToken.Implementation.Encode(token, out encodedToken)) {
				Error("Can't encode Implementation token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="ICustomAttributeType"/>
		/// </summary>
		/// <param name="cat">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddCustomAttributeType(ICustomAttributeType cat) {
			if (cat == null) {
				Error("CustomAttributeType is null");
				return 0;
			}

			var token = new MDToken(cat.MDToken.Table, AddMDTokenProvider(cat));
			uint encodedToken;
			if (!CodedToken.CustomAttributeType.Encode(token, out encodedToken)) {
				Error("Can't encode CustomAttributeType token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <c>NestedType</c> row
		/// </summary>
		/// <param name="nestedType">Nested type</param>
		/// <param name="declaringType">Declaring type</param>
		protected void AddNestedType(TypeDef nestedType, TypeDef declaringType) {
			if (nestedType == null || declaringType == null)
				return;
			uint nestedRid = GetRid(nestedType);
			uint dtRid = GetRid(declaringType);
			if (nestedRid == 0 || dtRid == 0)
				return;
			var row = new RawNestedClassRow(nestedRid, dtRid);
			nestedClassInfos.Add(declaringType, row);
		}

		/// <summary>
		/// Adds a <c>Module</c> row
		/// </summary>
		/// <param name="module">Module</param>
		/// <returns>Its new rid</returns>
		protected uint AddModule(ModuleDef module) {
			if (module == null) {
				Error("Module is null");
				return 0;
			}
			if (this.module != module)
				Error("Module {0} must be referenced with a ModuleRef, not a ModuleDef", module);
			uint rid;
			if (moduleDefInfos.TryGetRid(module, out rid))
				return rid;
			var row = new RawModuleRow(module.Generation,
								stringsHeap.Add(module.Name),
								guidHeap.Add(module.Mvid),
								guidHeap.Add(module.EncId),
								guidHeap.Add(module.EncBaseId));
			rid = tablesHeap.ModuleTable.Add(row);
			moduleDefInfos.Add(module, rid);
			AddCustomAttributes(Table.Module, rid, module);
			AddCustomDebugInformationList(Table.Module, rid, module);
			return rid;
		}

		/// <summary>
		/// Adds a <c>ModuleRef</c> row
		/// </summary>
		/// <param name="modRef">Module ref</param>
		/// <returns>Its new rid</returns>
		protected uint AddModuleRef(ModuleRef modRef) {
			if (modRef == null) {
				Error("ModuleRef is null");
				return 0;
			}
			uint rid;
			if (moduleRefInfos.TryGetRid(modRef, out rid))
				return rid;
			var row = new RawModuleRefRow(stringsHeap.Add(modRef.Name));
			rid = tablesHeap.ModuleRefTable.Add(row);
			moduleRefInfos.Add(modRef, rid);
			AddCustomAttributes(Table.ModuleRef, rid, modRef);
			AddCustomDebugInformationList(Table.ModuleRef, rid, modRef);
			return rid;
		}

		/// <summary>
		/// Adds an <c>AssemblyRef</c> row
		/// </summary>
		/// <param name="asmRef">Assembly ref</param>
		/// <returns>Its new rid</returns>
		protected uint AddAssemblyRef(AssemblyRef asmRef) {
			if (asmRef == null) {
				Error("AssemblyRef is null");
				return 0;
			}
			uint rid;
			if (assemblyRefInfos.TryGetRid(asmRef, out rid))
				return rid;
			var version = Utils.CreateVersionWithNoUndefinedValues(asmRef.Version);
			var row = new RawAssemblyRefRow((ushort)version.Major,
							(ushort)version.Minor,
							(ushort)version.Build,
							(ushort)version.Revision,
							(uint)asmRef.Attributes,
							blobHeap.Add(PublicKeyBase.GetRawData(asmRef.PublicKeyOrToken)),
							stringsHeap.Add(asmRef.Name),
							stringsHeap.Add(asmRef.Culture),
							blobHeap.Add(asmRef.Hash));
			rid = tablesHeap.AssemblyRefTable.Add(row);
			assemblyRefInfos.Add(asmRef, rid);
			AddCustomAttributes(Table.AssemblyRef, rid, asmRef);
			AddCustomDebugInformationList(Table.AssemblyRef, rid, asmRef);
			return rid;
		}

		/// <summary>
		/// Adds an <c>Assembly</c> row
		/// </summary>
		/// <param name="asm">Assembly</param>
		/// <param name="publicKey">The public key that should be used</param>
		/// <returns>Its new rid</returns>
		protected uint AddAssembly(AssemblyDef asm, byte[] publicKey) {
			if (asm == null) {
				Error("Assembly is null");
				return 0;
			}
			uint rid;
			if (assemblyInfos.TryGetRid(asm, out rid))
				return rid;

			var asmAttrs = asm.Attributes;
			if (publicKey != null)
				asmAttrs |= AssemblyAttributes.PublicKey;
			else
				publicKey = PublicKeyBase.GetRawData(asm.PublicKeyOrToken);

			var version = Utils.CreateVersionWithNoUndefinedValues(asm.Version);
			var row = new RawAssemblyRow((uint)asm.HashAlgorithm,
							(ushort)version.Major,
							(ushort)version.Minor,
							(ushort)version.Build,
							(ushort)version.Revision,
							(uint)asmAttrs,
							blobHeap.Add(publicKey),
							stringsHeap.Add(asm.Name),
							stringsHeap.Add(asm.Culture));
			rid = tablesHeap.AssemblyTable.Add(row);
			assemblyInfos.Add(asm, rid);
			AddDeclSecurities(new MDToken(Table.Assembly, rid), asm.DeclSecurities);
			AddCustomAttributes(Table.Assembly, rid, asm);
			AddCustomDebugInformationList(Table.Assembly, rid, asm);
			return rid;
		}

		/// <summary>
		/// Adds generic parameters
		/// </summary>
		/// <param name="token">New token of owner</param>
		/// <param name="gps">All generic params</param>
		protected void AddGenericParams(MDToken token, IList<GenericParam> gps) {
			if (gps == null)
				return;
			foreach (var gp in gps)
				AddGenericParam(token, gp);
		}

		/// <summary>
		/// Adds a generic param
		/// </summary>
		/// <param name="owner">New token of owner</param>
		/// <param name="gp">Generic paramater</param>
		protected void AddGenericParam(MDToken owner, GenericParam gp) {
			if (gp == null) {
				Error("GenericParam is null");
				return;
			}
			uint encodedOwner;
			if (!CodedToken.TypeOrMethodDef.Encode(owner, out encodedOwner)) {
				Error("Can't encode TypeOrMethodDef token {0:X8}", owner.Raw);
				encodedOwner = 0;
			}
			var row = new RawGenericParamRow(gp.Number,
							(ushort)gp.Flags,
							encodedOwner,
							stringsHeap.Add(gp.Name),
							gp.Kind == null ? 0 : AddTypeDefOrRef(gp.Kind));
			genericParamInfos.Add(gp, row);
		}

		void AddGenericParamConstraints(IList<GenericParam> gps) {
			if (gps == null)
				return;
			foreach (var gp in gps) {
				if (gp == null)
					continue;
				uint rid = genericParamInfos.Rid(gp);
				AddGenericParamConstraints(rid, gp.GenericParamConstraints);
			}
		}

		/// <summary>
		/// Adds generic parameter constraints
		/// </summary>
		/// <param name="gpRid">New rid of owner generic param</param>
		/// <param name="constraints">Its constraints</param>
		protected void AddGenericParamConstraints(uint gpRid, IList<GenericParamConstraint> constraints) {
			if (constraints == null)
				return;
			foreach (var gpc in constraints)
				AddGenericParamConstraint(gpRid, gpc);
		}

		/// <summary>
		/// Adds a generic parameter constraint
		/// </summary>
		/// <param name="gpRid">New rid of owner generic param</param>
		/// <param name="gpc">Generic parameter constraint</param>
		protected void AddGenericParamConstraint(uint gpRid, GenericParamConstraint gpc) {
			if (gpc == null) {
				Error("GenericParamConstraint is null");
				return;
			}
			var row = new RawGenericParamConstraintRow(gpRid, AddTypeDefOrRef(gpc.Constraint));
			genericParamConstraintInfos.Add(gpc, row);
		}

		/// <summary>
		/// Adds a <c>InterfaceImpl</c> row
		/// </summary>
		/// <param name="typeDefRid">New rid of owner</param>
		/// <param name="ifaces">All interfaces</param>
		protected void AddInterfaceImpls(uint typeDefRid, IList<InterfaceImpl> ifaces) {
			foreach (var iface in ifaces) {
				if (iface == null)
					continue;
				var row = new RawInterfaceImplRow(typeDefRid,
							AddTypeDefOrRef(iface.Interface));
				interfaceImplInfos.Add(iface, row);
			}
		}

		/// <summary>
		/// Adds a <c>FieldLayout</c> row
		/// </summary>
		/// <param name="field">Owner field</param>
		protected void AddFieldLayout(FieldDef field) {
			if (field == null || field.FieldOffset == null)
				return;
			var rid = GetRid(field);
			var row = new RawFieldLayoutRow(field.FieldOffset.Value, rid);
			fieldLayoutInfos.Add(field, row);
		}

		/// <summary>
		/// Adds a <c>FieldMarshal</c> row
		/// </summary>
		/// <param name="parent">New owner token</param>
		/// <param name="hfm">Owner</param>
		protected void AddFieldMarshal(MDToken parent, IHasFieldMarshal hfm) {
			if (hfm == null || hfm.MarshalType == null)
				return;
			var fieldMarshal = hfm.MarshalType;
			uint encodedParent;
			if (!CodedToken.HasFieldMarshal.Encode(parent, out encodedParent)) {
				Error("Can't encode HasFieldMarshal token {0:X8}", parent.Raw);
				encodedParent = 0;
			}
			var row = new RawFieldMarshalRow(encodedParent,
						blobHeap.Add(MarshalBlobWriter.Write(module, fieldMarshal, this)));
			fieldMarshalInfos.Add(hfm, row);
		}

		/// <summary>
		/// Adds a <c>FieldRVA</c> row
		/// </summary>
		/// <param name="field">The field</param>
		protected void AddFieldRVA(FieldDef field) {
			Debug.Assert(!isStandaloneDebugMetadata);
			if (field.RVA != 0 && KeepFieldRVA) {
				uint rid = GetRid(field);
				var row = new RawFieldRVARow((uint)field.RVA, rid);
				fieldRVAInfos.Add(field, row);
			}
			else {
				if (field == null || field.InitialValue == null)
					return;
				var ivBytes = field.InitialValue;
				if (!VerifyFieldSize(field, ivBytes.Length))
					Error("Field {0} ({1:X8}) initial value size != size of field type", field, field.MDToken.Raw);
				uint rid = GetRid(field);
				var iv = constants.Add(new ByteArrayChunk(ivBytes), ModuleWriterBase.DEFAULT_CONSTANTS_ALIGNMENT);
				fieldToInitialValue[field] = iv;
				var row = new RawFieldRVARow(0, rid);
				fieldRVAInfos.Add(field, row);
			}
		}

		static bool VerifyFieldSize(FieldDef field, int size) {
			if (field == null)
				return false;
			var sig = field.FieldSig;
			if (sig == null)
				return false;
			return field.GetFieldSize() == size;
		}

		/// <summary>
		/// Adds a <c>ImplMap</c> row
		/// </summary>
		/// <param name="parent">New owner token</param>
		/// <param name="mf">Owner</param>
		protected void AddImplMap(MDToken parent, IMemberForwarded mf) {
			if (mf == null || mf.ImplMap == null)
				return;
			var implMap = mf.ImplMap;
			uint encodedParent;
			if (!CodedToken.MemberForwarded.Encode(parent, out encodedParent)) {
				Error("Can't encode MemberForwarded token {0:X8}", parent.Raw);
				encodedParent = 0;
			}
			var row = new RawImplMapRow((ushort)implMap.Attributes,
						encodedParent,
						stringsHeap.Add(implMap.Name),
						AddModuleRef(implMap.Module));
			implMapInfos.Add(mf, row);
		}

		/// <summary>
		/// Adds a <c>Constant</c> row
		/// </summary>
		/// <param name="parent">New owner token</param>
		/// <param name="hc">Owner</param>
		protected void AddConstant(MDToken parent, IHasConstant hc) {
			if (hc == null || hc.Constant == null)
				return;
			var constant = hc.Constant;
			uint encodedParent;
			if (!CodedToken.HasConstant.Encode(parent, out encodedParent)) {
				Error("Can't encode HasConstant token {0:X8}", parent.Raw);
				encodedParent = 0;
			}
			var row = new RawConstantRow((byte)constant.Type, 0,
						encodedParent,
						blobHeap.Add(GetConstantValueAsByteArray(constant.Type, constant.Value)));
			hasConstantInfos.Add(hc, row);
		}

		static readonly byte[] constantClassByteArray = new byte[4];
		static readonly byte[] constantDefaultByteArray = new byte[8];
		byte[] GetConstantValueAsByteArray(ElementType etype, object o) {
			if (o == null) {
				if (etype == ElementType.Class)
					return constantClassByteArray;
				Error("Constant is null");
				return constantDefaultByteArray;
			}

			var typeCode = Type.GetTypeCode(o.GetType());
			switch (typeCode) {
			case TypeCode.Boolean:
				VerifyConstantType(etype, ElementType.Boolean);
				return BitConverter.GetBytes((bool)o);

			case TypeCode.Char:
				VerifyConstantType(etype, ElementType.Char);
				return BitConverter.GetBytes((char)o);

			case TypeCode.SByte:
				VerifyConstantType(etype, ElementType.I1);
				return new byte[1] { (byte)(sbyte)o };

			case TypeCode.Byte:
				VerifyConstantType(etype, ElementType.U1);
				return new byte[1] { (byte)o };

			case TypeCode.Int16:
				VerifyConstantType(etype, ElementType.I2);
				return BitConverter.GetBytes((short)o);

			case TypeCode.UInt16:
				VerifyConstantType(etype, ElementType.U2);
				return BitConverter.GetBytes((ushort)o);

			case TypeCode.Int32:
				VerifyConstantType(etype, ElementType.I4);
				return BitConverter.GetBytes((int)o);

			case TypeCode.UInt32:
				VerifyConstantType(etype, ElementType.U4);
				return BitConverter.GetBytes((uint)o);

			case TypeCode.Int64:
				VerifyConstantType(etype, ElementType.I8);
				return BitConverter.GetBytes((long)o);

			case TypeCode.UInt64:
				VerifyConstantType(etype, ElementType.U8);
				return BitConverter.GetBytes((ulong)o);

			case TypeCode.Single:
				VerifyConstantType(etype, ElementType.R4);
				return BitConverter.GetBytes((float)o);

			case TypeCode.Double:
				VerifyConstantType(etype, ElementType.R8);
				return BitConverter.GetBytes((double)o);

			case TypeCode.String:
				VerifyConstantType(etype, ElementType.String);
				return Encoding.Unicode.GetBytes((string)o);

			default:
				Error("Invalid constant type: {0}", typeCode);
				return constantDefaultByteArray;
			}
		}

		void VerifyConstantType(ElementType realType, ElementType expectedType) {
			if (realType != expectedType)
				Error("Constant value's type is the wrong type: {0} != {1}", realType, expectedType);
		}

		/// <summary>
		/// Adds a <c>DeclSecurity</c> row
		/// </summary>
		/// <param name="parent">New owner token</param>
		/// <param name="declSecurities">All <c>DeclSecurity</c> rows</param>
		protected void AddDeclSecurities(MDToken parent, IList<DeclSecurity> declSecurities) {
			if (declSecurities == null)
				return;
			uint encodedParent;
			if (!CodedToken.HasDeclSecurity.Encode(parent, out encodedParent)) {
				Error("Can't encode HasDeclSecurity token {0:X8}", parent.Raw);
				encodedParent = 0;
			}
			var bwctx = AllocBinaryWriterContext();
			foreach (var decl in declSecurities) {
				if (decl == null)
					continue;
				var row = new RawDeclSecurityRow((short)decl.Action,
							encodedParent,
							blobHeap.Add(DeclSecurityWriter.Write(module, decl.SecurityAttributes, this, bwctx)));
				declSecurityInfos.Add(decl, row);
			}
			Free(ref bwctx);
		}

		/// <summary>
		/// Adds <c>MethodSemantics</c> rows
		/// </summary>
		/// <param name="evt">Event</param>
		protected void AddMethodSemantics(EventDef evt) {
			if (evt == null) {
				Error("Event is null");
				return;
			}
			uint rid = GetRid(evt);
			if (rid == 0)
				return;
			var token = new MDToken(Table.Event, rid);
			AddMethodSemantics(token, evt.AddMethod, MethodSemanticsAttributes.AddOn);
			AddMethodSemantics(token, evt.RemoveMethod, MethodSemanticsAttributes.RemoveOn);
			AddMethodSemantics(token, evt.InvokeMethod, MethodSemanticsAttributes.Fire);
			AddMethodSemantics(token, evt.OtherMethods, MethodSemanticsAttributes.Other);
		}

		/// <summary>
		/// Adds <c>MethodSemantics</c> rows
		/// </summary>
		/// <param name="prop">Property</param>
		protected void AddMethodSemantics(PropertyDef prop) {
			if (prop == null) {
				Error("Property is null");
				return;
			}
			uint rid = GetRid(prop);
			if (rid == 0)
				return;
			var token = new MDToken(Table.Property, rid);
			AddMethodSemantics(token, prop.GetMethods, MethodSemanticsAttributes.Getter);
			AddMethodSemantics(token, prop.SetMethods, MethodSemanticsAttributes.Setter);
			AddMethodSemantics(token, prop.OtherMethods, MethodSemanticsAttributes.Other);
		}

		void AddMethodSemantics(MDToken owner, IList<MethodDef> methods, MethodSemanticsAttributes attrs) {
			if (methods == null)
				return;
			foreach (var method in methods)
				AddMethodSemantics(owner, method, attrs);
		}

		void AddMethodSemantics(MDToken owner, MethodDef method, MethodSemanticsAttributes flags) {
			if (method == null)
				return;
			uint methodRid = GetRid(method);
			if (methodRid == 0)
				return;
			uint encodedOwner;
			if (!CodedToken.HasSemantic.Encode(owner, out encodedOwner)) {
				Error("Can't encode HasSemantic token {0:X8}", owner.Raw);
				encodedOwner = 0;
			}
			var row = new RawMethodSemanticsRow((ushort)flags, methodRid, encodedOwner);
			methodSemanticsInfos.Add(method, row);
		}

		void AddMethodImpls(MethodDef method, IList<MethodOverride> overrides) {
			if (overrides == null)
				return;
			if (method.DeclaringType == null) {
				Error("Method declaring type == null. Method {0} ({1:X8})", method, method.MDToken.Raw);
				return;
			}
			uint rid = GetRid(method.DeclaringType);
			foreach (var ovr in overrides) {
				var row = new RawMethodImplRow(rid,
							AddMethodDefOrRef(ovr.MethodBody),
							AddMethodDefOrRef(ovr.MethodDeclaration));
				methodImplInfos.Add(method, row);
			}
		}

		/// <summary>
		/// Adds a <c>ClassLayout</c> row
		/// </summary>
		/// <param name="type">Type</param>
		protected void AddClassLayout(TypeDef type) {
			if (type == null || type.ClassLayout == null)
				return;
			var rid = GetRid(type);
			var classLayout = type.ClassLayout;
			var row = new RawClassLayoutRow(classLayout.PackingSize, classLayout.ClassSize, rid);
			classLayoutInfos.Add(type, row);
		}

		void AddResources(IList<Resource> resources) {
			if (resources == null)
				return;
			foreach (var resource in resources)
				AddResource(resource);
		}

		void AddResource(Resource resource) {
			var er = resource as EmbeddedResource;
			if (er != null) {
				AddEmbeddedResource(er);
				return;
			}

			var alr = resource as AssemblyLinkedResource;
			if (alr != null) {
				AddAssemblyLinkedResource(alr);
				return;
			}

			var lr = resource as LinkedResource;
			if (lr != null) {
				AddLinkedResource(lr);
				return;
			}

			if (resource == null)
				Error("Resource is null");
			else
				Error("Invalid resource type: {0}", resource.GetType());
		}

		uint AddEmbeddedResource(EmbeddedResource er) {
			Debug.Assert(!isStandaloneDebugMetadata);
			if (er == null) {
				Error("EmbeddedResource is null");
				return 0;
			}
			uint rid;
			if (manifestResourceInfos.TryGetRid(er, out rid))
				return rid;
			var row = new RawManifestResourceRow(netResources.NextOffset,
						(uint)er.Attributes,
						stringsHeap.Add(er.Name),
						0);
			rid = tablesHeap.ManifestResourceTable.Add(row);
			manifestResourceInfos.Add(er, rid);
			embeddedResourceToByteArray[er] = netResources.Add(er.Data);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return rid;
		}

		uint AddAssemblyLinkedResource(AssemblyLinkedResource alr) {
			if (alr == null) {
				Error("AssemblyLinkedResource is null");
				return 0;
			}
			uint rid;
			if (manifestResourceInfos.TryGetRid(alr, out rid))
				return rid;
			var row = new RawManifestResourceRow(0,
						(uint)alr.Attributes,
						stringsHeap.Add(alr.Name),
						AddImplementation(alr.Assembly));
			rid = tablesHeap.ManifestResourceTable.Add(row);
			manifestResourceInfos.Add(alr, rid);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return rid;
		}

		uint AddLinkedResource(LinkedResource lr) {
			if (lr == null) {
				Error("LinkedResource is null");
				return 0;
			}
			uint rid;
			if (manifestResourceInfos.TryGetRid(lr, out rid))
				return rid;
			var row = new RawManifestResourceRow(0,
						(uint)lr.Attributes,
						stringsHeap.Add(lr.Name),
						AddImplementation(lr.File));
			rid = tablesHeap.ManifestResourceTable.Add(row);
			manifestResourceInfos.Add(lr, rid);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return rid;
		}

		/// <summary>
		/// Adds a <c>File</c> row
		/// </summary>
		/// <param name="file">File</param>
		/// <returns>Its new rid</returns>
		protected uint AddFile(FileDef file) {
			if (file == null) {
				Error("FileDef is null");
				return 0;
			}
			uint rid;
			if (fileDefInfos.TryGetRid(file, out rid))
				return rid;
			var row = new RawFileRow((uint)file.Flags,
						stringsHeap.Add(file.Name),
						blobHeap.Add(file.HashValue));	//TODO: Re-calculate the hash value if possible
			rid = tablesHeap.FileTable.Add(row);
			fileDefInfos.Add(file, rid);
			AddCustomAttributes(Table.File, rid, file);
			AddCustomDebugInformationList(Table.File, rid, file);
			return rid;
		}

		/// <summary>
		/// Adds a <c>ExportedType</c> row
		/// </summary>
		/// <param name="et">Exported type</param>
		/// <returns>Its new rid</returns>
		protected uint AddExportedType(ExportedType et) {
			if (et == null) {
				Error("ExportedType is null");
				return 0;
			}
			uint rid;
			if (exportedTypeInfos.TryGetRid(et, out rid))
				return rid;
			exportedTypeInfos.Add(et, 0);	// Prevent inf recursion
			var row = new RawExportedTypeRow((uint)et.Attributes,
						et.TypeDefId,	//TODO: Should be updated with the new rid
						stringsHeap.Add(et.TypeName),
						stringsHeap.Add(et.TypeNamespace),
						AddImplementation(et.Implementation));
			rid = tablesHeap.ExportedTypeTable.Add(row);
			exportedTypeInfos.SetRid(et, rid);
			AddCustomAttributes(Table.ExportedType, rid, et);
			AddCustomDebugInformationList(Table.ExportedType, rid, et);
			return rid;
		}

		/// <summary>
		/// Gets a #Blob offset of a type signature
		/// </summary>
		/// <param name="ts">Type sig</param>
		/// <param name="extraData">Extra data to append the signature if
		/// <see cref="PreserveExtraSignatureData"/> is <c>true</c>.</param>
		/// <returns>#Blob offset</returns>
		protected uint GetSignature(TypeSig ts, byte[] extraData) {
			byte[] blob;
			if (ts == null) {
				Error("TypeSig is null");
				blob = null;
			}
			else {
				var bwctx = AllocBinaryWriterContext();
				blob = SignatureWriter.Write(this, ts, bwctx);
				Free(ref bwctx);
			}
			AppendExtraData(ref blob, extraData);
			return blobHeap.Add(blob);
		}

		/// <summary>
		/// Gets a #Blob offset of a calling convention signature
		/// </summary>
		/// <param name="sig">Signature</param>
		/// <returns>#Blob offset</returns>
		protected uint GetSignature(CallingConventionSig sig) {
			if (sig == null) {
				Error("CallingConventionSig is null");
				return 0;
			}

			var bwctx = AllocBinaryWriterContext();
			var blob = SignatureWriter.Write(this, sig, bwctx);
			Free(ref bwctx);
			AppendExtraData(ref blob, sig.ExtraData);
			return blobHeap.Add(blob);
		}

		void AppendExtraData(ref byte[] blob, byte[] extraData) {
			if (PreserveExtraSignatureData && extraData != null && extraData.Length > 0) {
				int blen = blob == null ? 0 : blob.Length;
				Array.Resize(ref blob, blen + extraData.Length);
				Array.Copy(extraData, 0, blob, blen, extraData.Length);
			}
		}

		/// <summary>
		/// Adds a <c>CustomAttribute</c> row
		/// </summary>
		/// <param name="table">Owner table</param>
		/// <param name="rid">New owner rid</param>
		/// <param name="hca">Onwer</param>
		protected void AddCustomAttributes(Table table, uint rid, IHasCustomAttribute hca) {
			AddCustomAttributes(table, rid, hca.CustomAttributes);
		}

		void AddCustomAttributes(Table table, uint rid, CustomAttributeCollection caList) {
			var token = new MDToken(table, rid);
			foreach (var ca in caList)
				AddCustomAttribute(token, ca);
		}

		void AddCustomAttribute(MDToken token, CustomAttribute ca) {
			if (ca == null) {
				Error("Custom attribute is null");
				return;
			}
			uint encodedToken;
			if (!CodedToken.HasCustomAttribute.Encode(token, out encodedToken)) {
				Error("Can't encode HasCustomAttribute token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			var bwctx = AllocBinaryWriterContext();
			var caBlob = CustomAttributeWriter.Write(this, ca, bwctx);
			Free(ref bwctx);
			var row = new RawCustomAttributeRow(encodedToken,
						AddCustomAttributeType(ca.Constructor),
						blobHeap.Add(caBlob));
			customAttributeInfos.Add(ca, row);
		}

		void AddCustomDebugInformationList(MethodDef method, uint rid, uint localVarSigToken) {
			if (debugMetaData == null)
				return;
			var serializerMethodContext = AllocSerializerMethodContext();
			serializerMethodContext.SetBody(method);
			if (method.CustomDebugInfos.Count != 0)
				AddCustomDebugInformationCore(serializerMethodContext, Table.Method, rid, method.CustomDebugInfos);
			AddMethodDebugInformation(method, rid, localVarSigToken);
			Free(ref serializerMethodContext);
		}

		void AddMethodDebugInformation(MethodDef method, uint rid, uint localVarSigToken) {
			Debug.Assert(debugMetaData != null);
			var body = method.Body;
			if (body == null)
				return;

			bool hasNoSeqPoints;
			PdbDocument singleDoc, firstDoc;
			GetSingleDocument(body, out singleDoc, out firstDoc, out hasNoSeqPoints);
			if (hasNoSeqPoints)
				return;

			var bwctx = AllocBinaryWriterContext();
			var outStream = bwctx.OutStream;
			var writer = bwctx.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;

			writer.WriteCompressedUInt32(localVarSigToken);
			if (singleDoc == null)
				writer.WriteCompressedUInt32(VerifyGetRid(firstDoc));

			var instrs = body.Instructions;
			var currentDoc = firstDoc;
			uint ilOffset = uint.MaxValue;
			int line = -1, column = 0;
			uint instrOffset = 0;
			Instruction instr = null;
			for (int i = 0; i < instrs.Count; i++, instrOffset += (uint)instr.GetSize()) {
				instr = instrs[i];
				var seqPoint = instr.SequencePoint;
				if (seqPoint == null)
					continue;
				if (seqPoint.Document == null) {
					Error("PDB document is null");
					return;
				}
				if (currentDoc != seqPoint.Document) {
					// document-record

					currentDoc = seqPoint.Document;
					writer.WriteCompressedUInt32(0);
					writer.WriteCompressedUInt32(VerifyGetRid(currentDoc));
				}

				// SequencePointRecord

				if (ilOffset == uint.MaxValue)
					writer.WriteCompressedUInt32(instrOffset);
				else
					writer.WriteCompressedUInt32(instrOffset - ilOffset);
				ilOffset = instrOffset;

				if (seqPoint.StartLine == SequencePointConstants.HIDDEN_LINE && seqPoint.EndLine == SequencePointConstants.HIDDEN_LINE) {
					// hidden-sequence-point-record

					writer.WriteCompressedUInt32(0);
					writer.WriteCompressedUInt32(0);
				}
				else {
					// sequence-point-record

					uint dlines = (uint)(seqPoint.EndLine - seqPoint.StartLine);
					int dcolumns = seqPoint.EndColumn - seqPoint.StartColumn;
					writer.WriteCompressedUInt32(dlines);
					if (dlines == 0)
						writer.WriteCompressedUInt32((uint)dcolumns);
					else
						writer.WriteCompressedInt32(dcolumns);

					if (line < 0) {
						writer.WriteCompressedUInt32((uint)seqPoint.StartLine);
						writer.WriteCompressedUInt32((uint)seqPoint.StartColumn);
					}
					else {
						writer.WriteCompressedInt32(seqPoint.StartLine - line);
						writer.WriteCompressedInt32(seqPoint.StartColumn - column);
					}
					line = seqPoint.StartLine;
					column = seqPoint.StartColumn;
				}
			}

			var seqPointsBlob = outStream.ToArray();
			var row = debugMetaData.tablesHeap.MethodDebugInformationTable[rid];
			row.Document = singleDoc == null ? 0 : AddPdbDocument(singleDoc);
			row.SequencePoints = debugMetaData.blobHeap.Add(seqPointsBlob);
			debugMetaData.methodDebugInformationInfosUsed = true;
			Free(ref bwctx);
		}

		uint VerifyGetRid(PdbDocument doc) {
			Debug.Assert(debugMetaData != null);
			uint rid;
			if (!debugMetaData.pdbDocumentInfos.TryGetRid(doc, out rid)) {
				Error("PDB document has been removed");
				return 0;
			}
			return rid;
		}

		static void GetSingleDocument(CilBody body, out PdbDocument singleDoc, out PdbDocument firstDoc, out bool hasNoSeqPoints) {
			var instrs = body.Instructions;
			int docCount = 0;
			singleDoc = null;
			firstDoc = null;
			for (int i = 0; i < instrs.Count; i++) {
				var seqPt = instrs[i].SequencePoint;
				if (seqPt == null)
					continue;
				var doc = seqPt.Document;
				if (doc == null)
					continue;
				if (firstDoc == null)
					firstDoc = doc;
				if (singleDoc != doc) {
					singleDoc = doc;
					docCount++;
					if (docCount > 1)
						break;
				}
			}
			hasNoSeqPoints = docCount == 0;
			if (docCount != 1)
				singleDoc = null;
		}

		/// <summary>
		/// Adds a <c>CustomDebugInformation</c> row
		/// </summary>
		/// <param name="table">Owner table</param>
		/// <param name="rid">New owner rid</param>
		/// <param name="hcdi">Onwer</param>
		protected void AddCustomDebugInformationList(Table table, uint rid, IHasCustomDebugInformation hcdi) {
			Debug.Assert(table != Table.Method);
			if (debugMetaData == null)
				return;
			if (hcdi.CustomDebugInfos.Count == 0)
				return;
			var serializerMethodContext = AllocSerializerMethodContext();
			serializerMethodContext.SetBody(null);
			AddCustomDebugInformationCore(serializerMethodContext, table, rid, hcdi.CustomDebugInfos);
			Free(ref serializerMethodContext);
		}

		void AddCustomDebugInformationList(Table table, uint rid, IList<PdbCustomDebugInfo> cdis) {
			Debug.Assert(table != Table.Method);
			if (debugMetaData == null)
				return;
			if (cdis.Count == 0)
				return;
			var serializerMethodContext = AllocSerializerMethodContext();
			serializerMethodContext.SetBody(null);
			AddCustomDebugInformationCore(serializerMethodContext, table, rid, cdis);
			Free(ref serializerMethodContext);
		}

		void AddCustomDebugInformationCore(SerializerMethodContext serializerMethodContext, Table table, uint rid, IList<PdbCustomDebugInfo> cdis) {
			Debug.Assert(debugMetaData != null);
			Debug.Assert(cdis.Count != 0);

			var token = new MDToken(table, rid);
			uint encodedToken;
			if (!CodedToken.HasCustomDebugInformation.Encode(token, out encodedToken)) {
				Error("Couldn't encode HasCustomDebugInformation token {0:X8}", token.Raw);
				return;
			}

			for (int i = 0; i < cdis.Count; i++) {
				var cdi = cdis[i];
				if (cdi == null) {
					Error("Custom debug info is null");
					continue;
				}

				AddCustomDebugInformation(serializerMethodContext, token.Raw, encodedToken, cdi);
			}
		}

		void AddCustomDebugInformation(SerializerMethodContext serializerMethodContext, uint token, uint encodedToken, PdbCustomDebugInfo cdi) {
			Debug.Assert(debugMetaData != null);

			switch (cdi.Kind) {
			case PdbCustomDebugInfoKind.UsingGroups:
			case PdbCustomDebugInfoKind.ForwardMethodInfo:
			case PdbCustomDebugInfoKind.ForwardModuleInfo:
			case PdbCustomDebugInfoKind.StateMachineTypeName:
			case PdbCustomDebugInfoKind.DynamicLocals:
			case PdbCustomDebugInfoKind.TupleElementNames:
				// These are Windows PDB CDIs
				Error("Unsupported custom debug info {0}", cdi.Kind);
				break;

			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:
			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:
			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:
			case PdbCustomDebugInfoKind.Unknown:
			case PdbCustomDebugInfoKind.TupleElementNames_PortablePdb:
			case PdbCustomDebugInfoKind.DefaultNamespace:
			case PdbCustomDebugInfoKind.DynamicLocalVariables:
			case PdbCustomDebugInfoKind.EmbeddedSource:
			case PdbCustomDebugInfoKind.SourceLink:
				AddCustomDebugInformationCore(serializerMethodContext, encodedToken, cdi, cdi.Guid);
				break;

			case PdbCustomDebugInfoKind.AsyncMethod:
				// This is a portable PDB pseudo CDI
				AddCustomDebugInformationCore(serializerMethodContext, encodedToken, cdi, CustomDebugInfoGuids.AsyncMethodSteppingInformationBlob);
				AddStateMachineMethod(cdi, token, ((PdbAsyncMethodCustomDebugInfo)cdi).KickoffMethod);
				break;

			case PdbCustomDebugInfoKind.IteratorMethod:
				// This is a portable PDB pseudo CDI
				AddStateMachineMethod(cdi, token, ((PdbIteratorMethodCustomDebugInfo)cdi).KickoffMethod);
				break;

			default:
				Error("Unknown custom debug info {0}", cdi.Kind.ToString());
				break;
			}
		}

		void AddStateMachineMethod(PdbCustomDebugInfo cdi, uint moveNextMethodToken, MethodDef kickoffMethod) {
			Debug.Assert(new MDToken(moveNextMethodToken).Table == Table.Method);
			Debug.Assert(debugMetaData != null);
			if (kickoffMethod == null) {
				Error("KickoffMethod is null");
				return;
			}
			var row = new RawStateMachineMethodRow(new MDToken(moveNextMethodToken).Rid, GetRid(kickoffMethod));
			debugMetaData.stateMachineMethodInfos.Add(cdi, row);
		}

		void AddCustomDebugInformationCore(SerializerMethodContext serializerMethodContext, uint encodedToken, PdbCustomDebugInfo cdi, Guid cdiGuid) {
			Debug.Assert(debugMetaData != null);

			var bwctx = AllocBinaryWriterContext();
			var cdiBlob = PortablePdbCustomDebugInfoWriter.Write(this, serializerMethodContext, this, cdi, bwctx);
			Debug.Assert(cdiGuid != Guid.Empty);
			Free(ref bwctx);
			var row = new RawCustomDebugInformationRow(encodedToken,
						debugMetaData.guidHeap.Add(cdiGuid),
						debugMetaData.blobHeap.Add(cdiBlob));
			debugMetaData.customDebugInfos.Add(cdi, row);
		}

		void InitializeMethodDebugInformation() {
			if (debugMetaData == null)
				return;
			int numMethods = NumberOfMethods;
			for (int i = 0; i < numMethods; i++)
				debugMetaData.tablesHeap.MethodDebugInformationTable.Create(new RawMethodDebugInformationRow());
		}

		void AddPdbDocuments() {
			if (debugMetaData == null)
				return;
			foreach (var doc in module.PdbState.Documents)
				AddPdbDocument(doc);
		}

		uint AddPdbDocument(PdbDocument doc) {
			Debug.Assert(debugMetaData != null);
			if (doc == null) {
				Error("PdbDocument is null");
				return 0;
			}
			uint rid;
			if (debugMetaData.pdbDocumentInfos.TryGetRid(doc, out rid))
				return rid;
			var row = new RawDocumentRow(GetDocumentNameBlobOffset(doc.Url),
							debugMetaData.guidHeap.Add(doc.CheckSumAlgorithmId),
							debugMetaData.blobHeap.Add(doc.CheckSum),
							debugMetaData.guidHeap.Add(doc.Language));
			rid = debugMetaData.tablesHeap.DocumentTable.Add(row);
			debugMetaData.pdbDocumentInfos.Add(doc, rid);
			AddCustomDebugInformationList(Table.Document, rid, doc.CustomDebugInfos);
			return rid;
		}

		uint GetDocumentNameBlobOffset(string name) {
			Debug.Assert(debugMetaData != null);
			if (name == null) {
				Error("Document name is null");
				name = string.Empty;
			}

			var bwctx = AllocBinaryWriterContext();
			var outStream = bwctx.OutStream;
			var writer = bwctx.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;
			var parts = name.Split(directorySeparatorCharArray);
			if (parts.Length == 1)
				writer.Write((byte)0);
			else
				writer.Write(directorySeparatorCharUtf8);
			for (int i = 0; i < parts.Length; i++) {
				var part = parts[i];
				uint partOffset = debugMetaData.blobHeap.Add(Encoding.UTF8.GetBytes(part));
				writer.WriteCompressedUInt32(partOffset);
			}

			var res = debugMetaData.blobHeap.Add(outStream.ToArray());
			Free(ref bwctx);
			return res;
		}
		static readonly byte[] directorySeparatorCharUtf8 = Encoding.UTF8.GetBytes(Path.DirectorySeparatorChar.ToString());
		static readonly char[] directorySeparatorCharArray = new char[] { Path.DirectorySeparatorChar };

		uint AddImportScope(PdbImportScope scope) {
			Debug.Assert(debugMetaData != null);
			if (scope == null)
				return 0;
			uint rid;
			if (debugMetaData.importScopeInfos.TryGetRid(scope, out rid)) {
				if (rid == 0)
					Error("PdbImportScope has an infinite Parent loop");
				return rid;
			}
			debugMetaData.importScopeInfos.Add(scope, 0);   // Prevent inf recursion

			var bwctx = AllocBinaryWriterContext();
			var outStream = bwctx.OutStream;
			var writer = bwctx.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;
			ImportScopeBlobWriter.Write(this, this, writer, debugMetaData.blobHeap, scope.Imports);
			var importsData = outStream.ToArray();
			Free(ref bwctx);

			var row = new RawImportScopeRow(AddImportScope(scope.Parent), debugMetaData.blobHeap.Add(importsData));
			rid = debugMetaData.tablesHeap.ImportScopeTable.Add(row);
			debugMetaData.importScopeInfos.SetRid(scope, rid);

			AddCustomDebugInformationList(Table.ImportScope, rid, scope.CustomDebugInfos);
			return rid;
		}

		void AddLocalVariable(PdbLocal local) {
			Debug.Assert(debugMetaData != null);
			if (local == null) {
				Error("PDB local is null");
				return;
			}
			var row = new RawLocalVariableRow((ushort)local.Attributes, (ushort)local.Index, debugMetaData.stringsHeap.Add(local.Name));
			uint rid = debugMetaData.tablesHeap.LocalVariableTable.Create(row);
			debugMetaData.localVariableInfos.Add(local, rid);
			AddCustomDebugInformationList(Table.LocalVariable, rid, local.CustomDebugInfos);
		}

		void AddLocalConstant(PdbConstant constant) {
			Debug.Assert(debugMetaData != null);
			if (constant == null) {
				Error("PDB constant is null");
				return;
			}

			var bwctx = AllocBinaryWriterContext();
			var outStream = bwctx.OutStream;
			var writer = bwctx.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;
			LocalConstantSigBlobWriter.Write(this, this, writer, constant.Type, constant.Value);
			var signature = outStream.ToArray();
			Free(ref bwctx);

			var row = new RawLocalConstantRow(debugMetaData.stringsHeap.Add(constant.Name), debugMetaData.blobHeap.Add(signature));
			uint rid = debugMetaData.tablesHeap.LocalConstantTable.Create(row);
			debugMetaData.localConstantInfos.Add(constant, rid);
			AddCustomDebugInformationList(Table.LocalConstant, rid, constant.CustomDebugInfos);
		}

		/// <summary>
		/// Writes the portable PDB to <paramref name="output"/>.
		/// </summary>
		/// <param name="output">Output stream</param>
		/// <param name="entryPointToken">Entry point token</param>
		/// <param name="pdbId">PDB ID, exactly 20 bytes</param>
		internal void WritePortablePdb(Stream output, uint entryPointToken, byte[] pdbId) {
			if (debugMetaData == null)
				throw new InvalidOperationException();
			if (pdbId.Length != 20)
				throw new InvalidOperationException();
			var pdbHeap = debugMetaData.PdbHeap;
			pdbHeap.EntryPoint = entryPointToken;
			for (int i = 0; i < pdbId.Length; i++)
				pdbHeap.PdbId[i] = pdbId[i];

			ulong systemTablesMask;
			tablesHeap.GetSystemTableRows(out systemTablesMask, pdbHeap.TypeSystemTableRows);
			debugMetaData.tablesHeap.SetSystemTableRows(pdbHeap.TypeSystemTableRows);
			if (!debugMetaData.methodDebugInformationInfosUsed)
				debugMetaData.tablesHeap.MethodDebugInformationTable.Reset();
			pdbHeap.ReferencedTypeSystemTables = systemTablesMask;
			var writer = new BinaryWriter(output);
			debugMetaData.SetOffset(0, 0);
			debugMetaData.GetFileLength();
			debugMetaData.VerifyWriteTo(writer);
		}

		/// <inheritdoc/>
		uint ISignatureWriterHelper.ToEncodedToken(ITypeDefOrRef typeDefOrRef) {
			return AddTypeDefOrRef(typeDefOrRef);
		}

		/// <inheritdoc/>
		void IWriterError.Error(string message) {
			Error(message);
		}

		/// <inheritdoc/>
		bool IFullNameCreatorHelper.MustUseAssemblyName(IType type) {
			return FullNameCreator.MustUseAssemblyName(module, type);
		}

		/// <summary>
		/// Called before any other methods
		/// </summary>
		protected virtual void Initialize() {
		}

		/// <summary>
		/// Gets all <see cref="TypeDef"/>s that should be saved in the meta data
		/// </summary>
		protected abstract List<TypeDef> GetAllTypeDefs();

		/// <summary>
		/// Initializes <c>TypeDef</c> rids and creates raw rows, but does not initialize
		/// any columns.
		/// </summary>
		protected abstract void AllocateTypeDefRids();

		/// <summary>
		/// Allocates <c>Field</c>, <c>Method</c>, <c>Property</c>, <c>Event</c>, <c>Param</c>:
		/// rid and raw row, but doesn't initialize the raw row.
		/// Initializes <c>TypeDef</c> columns: <c>FieldList</c>, <c>MethodList</c>.
		/// Initializes <c>Method</c> column: <c>ParamList</c>.
		/// Initializes <see cref="MetaData.eventMapInfos"/> and <see cref="MetaData.propertyMapInfos"/>.
		/// </summary>
		protected abstract void AllocateMemberDefRids();

		/// <summary>
		/// Adds a <see cref="TypeRef"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="tr">Type reference</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddTypeRef(TypeRef tr);

		/// <summary>
		/// Adds a <see cref="TypeSpec"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="ts">Type spec</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddTypeSpec(TypeSpec ts);

		/// <summary>
		/// Adds a <see cref="MemberRef"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="mr">Member ref</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddMemberRef(MemberRef mr);

		/// <summary>
		/// Adds a <see cref="StandAloneSig"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="sas">Stand alone sig</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddStandAloneSig(StandAloneSig sas);

		/// <summary>
		/// Adds a <see cref="MethodSpec"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="ms">Method spec</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddMethodSpec(MethodSpec ms);

		/// <summary>
		/// Called before sorting the <c>CustomAttribute</c> table. This is the last time anything
		/// can be inserted into this table.
		/// </summary>
		protected virtual void BeforeSortingCustomAttributes() {
		}

		/// <summary>
		/// Called after everything has been initialized. The sub class can initialize more
		/// rows if necessary or do nothing. After this method has been called, nothing else
		/// can be added.
		/// </summary>
		protected virtual void EverythingInitialized() {
		}

		const uint HEAP_ALIGNMENT = 4;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			stringsHeap.AddOptimizedStrings();
			stringsHeap.SetReadOnly();
			blobHeap.SetReadOnly();
			guidHeap.SetReadOnly();
			tablesHeap.SetReadOnly();
			pdbHeap.SetReadOnly();
			tablesHeap.BigStrings = stringsHeap.IsBig;
			tablesHeap.BigBlob = blobHeap.IsBig;
			tablesHeap.BigGuid = guidHeap.IsBig;

			metaDataHeader.Heaps = GetHeaps();

			metaDataHeader.SetOffset(offset, rva);
			uint len = metaDataHeader.GetFileLength();
			offset += len;
			rva += len;

			foreach (var heap in metaDataHeader.Heaps) {
				offset = offset.AlignUp(HEAP_ALIGNMENT);
				rva = rva.AlignUp(HEAP_ALIGNMENT);
				heap.SetOffset(offset, rva);
				len = heap.GetFileLength();
				offset += len;
				rva += len;
			}
			length = rva - this.rva;

			if (!isStandaloneDebugMetadata) {
				UpdateMethodRvas();
				UpdateFieldRvas();
			}
		}

		IList<IHeap> GetHeaps() {
			var heaps = new List<IHeap>();

			if (isStandaloneDebugMetadata) {
				heaps.Add(pdbHeap);
				heaps.Add(tablesHeap);
				if (!stringsHeap.IsEmpty)
					heaps.Add(stringsHeap);
				if (!usHeap.IsEmpty)
					heaps.Add(usHeap);
				if (!guidHeap.IsEmpty)
					heaps.Add(guidHeap);
				if (!blobHeap.IsEmpty)
					heaps.Add(blobHeap);
			}
			else {
				if (options.OtherHeaps != null)
					heaps.AddRange(options.OtherHeaps);

				// The #! heap must be added before the other heaps or the CLR can
				// sometimes flag an error. Eg., it can check whether a pointer is valid.
				// It does this by comparing the pointer to the last valid address for
				// the particular heap. If this pointer really is in the #! heap and the
				// #! heap is at an address > than the other heap, then the CLR will think
				// it's an invalid pointer.
				if (hotHeap != null)  // Don't check whether it's empty
					heaps.Add(hotHeap);

				heaps.Add(tablesHeap);
				if (!stringsHeap.IsEmpty || AlwaysCreateStringsHeap)
					heaps.Add(stringsHeap);
				if (!usHeap.IsEmpty || AlwaysCreateUSHeap)
					heaps.Add(usHeap);
				if (!guidHeap.IsEmpty || AlwaysCreateGuidHeap)
					heaps.Add(guidHeap);
				if (!blobHeap.IsEmpty || AlwaysCreateBlobHeap)
					heaps.Add(blobHeap);

				if (options.OtherHeapsEnd != null)
					heaps.AddRange(options.OtherHeapsEnd);
			}

			return heaps;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			var rva2 = rva;
			metaDataHeader.VerifyWriteTo(writer);
			rva2 += metaDataHeader.GetFileLength();

			foreach (var heap in metaDataHeader.Heaps) {
				writer.WriteZeros((int)(rva2.AlignUp(HEAP_ALIGNMENT) - rva2));
				rva2 = rva2.AlignUp(HEAP_ALIGNMENT);
				heap.VerifyWriteTo(writer);
				rva2 += heap.GetFileLength();
			}
		}

		/// <summary>
		/// Sorts the <see cref="ParamDef"/>s
		/// </summary>
		/// <param name="pds">All <see cref="ParamDef"/>s</param>
		/// <returns>A sorted <see cref="ParamDef"/> list</returns>
		protected static List<ParamDef> Sort(IEnumerable<ParamDef> pds) {
			var sorted = new List<ParamDef>(pds);
			sorted.Sort((a, b) => {
				if (a == null)
					return -1;
				if (b == null)
					return 1;
				return a.Sequence.CompareTo(b.Sequence);
			});
			return sorted;
		}

		BinaryWriterContext AllocBinaryWriterContext() {
			if (binaryWriterContexts.Count == 0)
				return new BinaryWriterContext();
			var res = binaryWriterContexts[binaryWriterContexts.Count - 1];
			binaryWriterContexts.RemoveAt(binaryWriterContexts.Count - 1);
			return res;
		}

		void Free(ref BinaryWriterContext ctx) {
			binaryWriterContexts.Add(ctx);
			ctx = null;
		}

		SerializerMethodContext AllocSerializerMethodContext() {
			if (serializerMethodContexts.Count == 0)
				return new SerializerMethodContext(this);
			var res = serializerMethodContexts[serializerMethodContexts.Count - 1];
			serializerMethodContexts.RemoveAt(serializerMethodContexts.Count - 1);
			return res;
		}

		void Free(ref SerializerMethodContext ctx) {
			serializerMethodContexts.Add(ctx);
			ctx = null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MetaDataHeader.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.IO;
using dnlib.PE;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="MetaDataHeader"/> options
	/// </summary>
	public sealed class MetaDataHeaderOptions {
		/// <summary>
		/// Default version string
		/// </summary>
		public const string DEFAULT_VERSION_STRING = MDHeaderRuntimeVersion.MS_CLR_20;

		/// <summary>
		/// Default header signature
		/// </summary>
		public const uint DEFAULT_SIGNATURE = 0x424A5342;

		/// <summary>
		/// MD header signature. Default value is <see cref="DEFAULT_SIGNATURE"/>
		/// </summary>
		public uint? Signature;

		/// <summary>
		/// Major version. Default is 1. MS' CLR supports v0.x (x >= 19) and v1.1, nothing else.
		/// </summary>
		public ushort? MajorVersion;

		/// <summary>
		/// Minor version. Default is 1.
		/// </summary>
		public ushort? MinorVersion;

		/// <summary>
		/// Reserved and should be 0.
		/// </summary>
		public uint? Reserved1;

		/// <summary>
		/// Version string. Default is <see cref="DEFAULT_VERSION_STRING"/>. It's stored as a
		/// zero-terminated UTF-8 string. Length should be &lt;= 255 bytes.
		/// </summary>
		public string VersionString;

		/// <summary>
		/// Storage flags should be 0
		/// </summary>
		public StorageFlags? StorageFlags;

		/// <summary>
		/// Reserved and should be 0
		/// </summary>
		public byte? Reserved2;

		/// <summary>
		/// Creates portable PDB v1.0 options
		/// </summary>
		/// <returns></returns>
		public static MetaDataHeaderOptions CreatePortablePdbV1_0() {
			return new MetaDataHeaderOptions() {
				Signature = DEFAULT_SIGNATURE,
				MajorVersion = 1,
				MinorVersion = 1,
				Reserved1 = 0,
				VersionString = MDHeaderRuntimeVersion.PORTABLE_PDB_V1_0,
				StorageFlags = 0,
				Reserved2 = 0,
			};
		}
	}

	/// <summary>
	/// Meta data header. IMAGE_COR20_HEADER.MetaData points to this header.
	/// </summary>
	public sealed class MetaDataHeader : IChunk {
		IList<IHeap> heaps;
		readonly MetaDataHeaderOptions options;
		uint length;
		FileOffset offset;
		RVA rva;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets/sets the heaps
		/// </summary>
		public IList<IHeap> Heaps {
			get { return heaps; }
			set { heaps = value; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public MetaDataHeader()
			: this(null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Options</param>
		public MetaDataHeader(MetaDataHeaderOptions options) {
			this.options = options ?? new MetaDataHeaderOptions();
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			length = 16;
			length += (uint)GetVersionString().Length;
			length = Utils.AlignUp(length, 4);
			length += 4;
			foreach (var heap in heaps) {
				length += 8;
				length += (uint)GetAsciizName(heap.Name).Length;
				length = Utils.AlignUp(length, 4);
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			writer.Write(options.Signature ?? MetaDataHeaderOptions.DEFAULT_SIGNATURE);
			writer.Write(options.MajorVersion ?? 1);
			writer.Write(options.MinorVersion ?? 1);
			writer.Write(options.Reserved1 ?? 0);
			var s = GetVersionString();
			writer.Write(Utils.AlignUp(s.Length, 4));
			writer.Write(s);
			writer.WriteZeros(Utils.AlignUp(s.Length, 4) - s.Length);
			writer.Write((byte)(options.StorageFlags ?? 0));
			writer.Write(options.Reserved2 ?? 0);
			writer.Write((ushort)heaps.Count);
			foreach (var heap in heaps) {
				writer.Write((uint)(heap.FileOffset - offset));
				writer.Write(heap.GetFileLength());
				writer.Write(s = GetAsciizName(heap.Name));
				if (s.Length > 32)
					throw new ModuleWriterException(string.Format("Heap name '{0}' is > 32 bytes", heap.Name));
				writer.WriteZeros(Utils.AlignUp(s.Length, 4) - s.Length);
			}
		}

		byte[] GetVersionString() {
			return Encoding.UTF8.GetBytes((options.VersionString ?? MetaDataHeaderOptions.DEFAULT_VERSION_STRING) + "\0");
		}

		byte[] GetAsciizName(string s) {
			return Encoding.ASCII.GetBytes(s + "\0");
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MethodBody.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Method body chunk
	/// </summary>
	public sealed class MethodBody : IChunk {
		const uint EXTRA_SECTIONS_ALIGNMENT = 4;

		readonly bool isTiny;
		readonly byte[] code;
		readonly byte[] extraSections;
		uint length;
		FileOffset offset;
		RVA rva;
		uint localVarSigTok;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets the code
		/// </summary>
		public byte[] Code {
			get { return code; }
		}

		/// <summary>
		/// Gets the extra sections (exception handlers) or <c>null</c>
		/// </summary>
		public byte[] ExtraSections {
			get { return extraSections; }
		}

		/// <summary>
		/// Gets the token of the locals
		/// </summary>
		public uint LocalVarSigTok {
			get { return localVarSigTok; }
		}

		/// <summary>
		/// <c>true</c> if it's a fat body
		/// </summary>
		public bool IsFat {
			get { return !isTiny; }
		}

		/// <summary>
		/// <c>true</c> if it's a tiny body
		/// </summary>
		public bool IsTiny {
			get { return isTiny; }
		}

		/// <summary>
		/// <c>true</c> if there's an extra section
		/// </summary>
		public bool HasExtraSections {
			get { return extraSections != null && extraSections.Length > 0; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="code">Code</param>
		public MethodBody(byte[] code)
			: this(code, null, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="code">Code</param>
		/// <param name="extraSections">Extra sections or <c>null</c></param>
		public MethodBody(byte[] code, byte[] extraSections)
			: this(code, extraSections, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="code">Code</param>
		/// <param name="extraSections">Extra sections or <c>null</c></param>
		/// <param name="localVarSigTok">Token of locals</param>
		public MethodBody(byte[] code, byte[] extraSections, uint localVarSigTok) {
			this.isTiny = (code[0] & 3) == 2;
			this.code = code;
			this.extraSections = extraSections;
			this.localVarSigTok = localVarSigTok;
		}

		/// <summary>
		/// Gets the approximate size of the method body (code + exception handlers)
		/// </summary>
		public int GetSizeOfMethodBody() {
			int len = code.Length;
			if (extraSections != null) {
				len = Utils.AlignUp(len, EXTRA_SECTIONS_ALIGNMENT);
				len += extraSections.Length;
				len = Utils.AlignUp(len, EXTRA_SECTIONS_ALIGNMENT);
			}
			return len;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
			if (HasExtraSections) {
				RVA rva2 = rva + (uint)code.Length;
				rva2 = rva2.AlignUp(EXTRA_SECTIONS_ALIGNMENT);
				rva2 += (uint)extraSections.Length;
				length = (uint)rva2 - (uint)rva;
			}
			else
				length = (uint)code.Length;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			writer.Write(code);
			if (HasExtraSections) {
				RVA rva2 = rva + (uint)code.Length;
				writer.WriteZeros((int)rva2.AlignUp(EXTRA_SECTIONS_ALIGNMENT) - (int)rva2);
				writer.Write(extraSections);
			}
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			return Utils.GetHashCode(code) + Utils.GetHashCode(extraSections);
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			var other = obj as MethodBody;
			if (other == null)
				return false;
			return Utils.Equals(code, other.code) &&
				Utils.Equals(extraSections, other.extraSections);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MethodBodyChunks.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Stores all method body chunks
	/// </summary>
	public sealed class MethodBodyChunks : IChunk {
		const uint FAT_BODY_ALIGNMENT = 4;
		Dictionary<MethodBody, MethodBody> tinyMethodsDict;
		Dictionary<MethodBody, MethodBody> fatMethodsDict;
		readonly List<MethodBody> tinyMethods;
		readonly List<MethodBody> fatMethods;
		readonly bool shareBodies;
		FileOffset offset;
		RVA rva;
		uint length;
		bool setOffsetCalled;
		readonly bool alignFatBodies;
		uint savedBytes;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets the number of bytes saved by re-using method bodies
		/// </summary>
		public uint SavedBytes {
			get { return savedBytes; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="shareBodies"><c>true</c> if bodies can be shared</param>
		public MethodBodyChunks(bool shareBodies) {
			this.shareBodies = shareBodies;
			this.alignFatBodies = true;
			if (shareBodies) {
				tinyMethodsDict = new Dictionary<MethodBody, MethodBody>();
				fatMethodsDict = new Dictionary<MethodBody, MethodBody>();
			}
			tinyMethods = new List<MethodBody>();
			fatMethods = new List<MethodBody>();
		}

		/// <summary>
		/// Adds a <see cref="MethodBody"/> and returns the one that has been cached
		/// </summary>
		/// <param name="methodBody">The method body</param>
		/// <returns>The cached method body</returns>
		public MethodBody Add(MethodBody methodBody) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (shareBodies) {
				var dict = methodBody.IsFat ? fatMethodsDict : tinyMethodsDict;
				MethodBody cached;
				if (dict.TryGetValue(methodBody, out cached)) {
					savedBytes += (uint)methodBody.GetSizeOfMethodBody();
					return cached;
				}
				dict[methodBody] = methodBody;
			}
			var list = methodBody.IsFat ? fatMethods : tinyMethods;
			list.Add(methodBody);
			return methodBody;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			setOffsetCalled = true;
			this.offset = offset;
			this.rva = rva;

			tinyMethodsDict = null;
			fatMethodsDict = null;

			var rva2 = rva;
			foreach (var mb in tinyMethods) {
				mb.SetOffset(offset, rva2);
				uint len = mb.GetFileLength();
				rva2 += len;
				offset += len;
			}

			foreach (var mb in fatMethods) {
				if (alignFatBodies) {
					uint padding = (uint)rva2.AlignUp(FAT_BODY_ALIGNMENT) - (uint)rva2;
					rva2 += padding;
					offset += padding;
				}
				mb.SetOffset(offset, rva2);
				uint len = mb.GetFileLength();
				rva2 += len;
				offset += len;
			}

			length = (uint)rva2 - (uint)rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			var rva2 = rva;
			foreach (var mb in tinyMethods) {
				mb.VerifyWriteTo(writer);
				rva2 += mb.GetFileLength();
			}

			foreach (var mb in fatMethods) {
				if (alignFatBodies) {
					int padding = (int)rva2.AlignUp(FAT_BODY_ALIGNMENT) - (int)rva2;
					writer.WriteZeros(padding);
					rva2 += (uint)padding;
				}
				mb.VerifyWriteTo(writer);
				rva2 += mb.GetFileLength();
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MethodBodyWriter.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.DotNet.Emit;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Returns tokens of token types, strings and signatures
	/// </summary>
	public interface ITokenCreator : IWriterError {
		/// <summary>
		/// Gets the token of <paramref name="o"/>
		/// </summary>
		/// <param name="o">A token type or a string or a signature</param>
		/// <returns>The token</returns>
		MDToken GetToken(object o);

		/// <summary>
		/// Gets a <c>StandAloneSig</c> token
		/// </summary>
		/// <param name="locals">All locals</param>
		/// <param name="origToken">The original token or <c>0</c> if none</param>
		/// <returns>A <c>StandAloneSig</c> token or <c>0</c> if <paramref name="locals"/> is
		/// empty.</returns>
		MDToken GetToken(IList<TypeSig> locals, uint origToken);
	}

	/// <summary>
	/// Writes CIL method bodies
	/// </summary>
	public sealed class MethodBodyWriter : MethodBodyWriterBase {
		readonly ITokenCreator helper;
		CilBody cilBody;
		bool keepMaxStack;
		uint codeSize;
		uint maxStack;
		byte[] code;
		byte[] extraSections;
		uint localVarSigTok;

		/// <summary>
		/// Gets the code as a byte array. This is valid only after calling <see cref="Write()"/>.
		/// The size of this array is not necessarily a multiple of 4, even if there are exception
		/// handlers present. See also <see cref="GetFullMethodBody()"/>
		/// </summary>
		public byte[] Code {
			get { return code; }
		}

		/// <summary>
		/// Gets the extra sections (exception handlers) as a byte array or <c>null</c> if there
		/// are no exception handlers. This is valid only after calling <see cref="Write()"/>
		/// </summary>
		public byte[] ExtraSections {
			get { return extraSections; }
		}

		/// <summary>
		/// Gets the token of the locals
		/// </summary>
		public uint LocalVarSigTok {
			get { return localVarSigTok; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="helper">Helps this instance</param>
		/// <param name="cilBody">The CIL method body</param>
		public MethodBodyWriter(ITokenCreator helper, CilBody cilBody)
			: this(helper, cilBody, false) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="helper">Helps this instance</param>
		/// <param name="cilBody">The CIL method body</param>
		/// <param name="keepMaxStack">Keep the original max stack value that has been initialized
		/// in <paramref name="cilBody"/></param>
		public MethodBodyWriter(ITokenCreator helper, CilBody cilBody, bool keepMaxStack)
			: base(cilBody.Instructions, cilBody.ExceptionHandlers) {
			this.helper = helper;
			this.cilBody = cilBody;
			this.keepMaxStack = keepMaxStack;
		}

		internal MethodBodyWriter(ITokenCreator helper) {
			this.helper = helper;
		}

		internal void Reset(CilBody cilBody, bool keepMaxStack) {
			Reset(cilBody.Instructions, cilBody.ExceptionHandlers);
			this.cilBody = cilBody;
			this.keepMaxStack = keepMaxStack;
			codeSize = 0;
			maxStack = 0;
			code = null;
			extraSections = null;
			localVarSigTok = 0;
		}

		/// <summary>
		/// Writes the method body
		/// </summary>
		public void Write() {
			codeSize = InitializeInstructionOffsets();
			maxStack = keepMaxStack ? cilBody.MaxStack : GetMaxStack();
			if (NeedFatHeader())
				WriteFatHeader();
			else
				WriteTinyHeader();
			if (exceptionHandlers.Count > 0)
				WriteExceptionHandlers();
		}

		/// <summary>
		/// Gets the code and (possible) exception handlers in one array. The exception handlers
		/// are 4-byte aligned.
		/// </summary>
		/// <returns>The code and any exception handlers</returns>
		public byte[] GetFullMethodBody() {
			int padding = Utils.AlignUp(code.Length, 4) - code.Length;
			var bytes = new byte[code.Length + (extraSections == null ? 0 : padding + extraSections.Length)];
			Array.Copy(code, 0, bytes, 0, code.Length);
			if (extraSections != null)
				Array.Copy(extraSections, 0, bytes, code.Length + padding, extraSections.Length);
			return bytes;
		}

		bool NeedFatHeader() {
			//TODO: If locals has cust attrs, we also need a fat header
			return codeSize > 0x3F ||
					exceptionHandlers.Count > 0 ||
					cilBody.HasVariables ||
					maxStack > 8;
		}

		void WriteFatHeader() {
			if (maxStack > ushort.MaxValue) {
				Error("MaxStack is too big");
				maxStack = ushort.MaxValue;
			}

			ushort flags = 0x3003;
			if (exceptionHandlers.Count > 0)
				flags |= 8;
			if (cilBody.InitLocals)
				flags |= 0x10;

			code = new byte[12 + codeSize];
			var writer = new BinaryWriter(new MemoryStream(code), Encoding.UTF8);
			writer.Write(flags);
			writer.Write((ushort)maxStack);
			writer.Write(codeSize);
			writer.Write(localVarSigTok = helper.GetToken(GetLocals(), cilBody.LocalVarSigTok).Raw);
			if (WriteInstructions(writer) != codeSize)
				Error("Didn't write all code bytes");
		}

		IList<TypeSig> GetLocals() {
			var localsSig = new TypeSig[cilBody.Variables.Count];
			for (int i = 0; i < cilBody.Variables.Count; i++)
				localsSig[i] = cilBody.Variables[i].Type;
			return localsSig;
		}

		void WriteTinyHeader() {
			localVarSigTok = 0;
			code = new byte[1 + codeSize];
			var writer = new BinaryWriter(new MemoryStream(code), Encoding.UTF8);
			writer.Write((byte)((codeSize << 2) | 2));
			if (WriteInstructions(writer) != codeSize)
				Error("Didn't write all code bytes");
		}

		void WriteExceptionHandlers() {
			var outStream = new MemoryStream();
			var writer = new BinaryWriter(outStream, Encoding.UTF8);
			if (NeedFatExceptionClauses())
				WriteFatExceptionClauses(writer);
			else
				WriteSmallExceptionClauses(writer);
			extraSections = outStream.ToArray();
		}

		bool NeedFatExceptionClauses() {
			// Size must fit in a byte, and since one small exception record is 12 bytes
			// and header is 4 bytes: x*12+4 <= 255 ==> x <= 20
			if (exceptionHandlers.Count > 20)
				return true;

			foreach (var eh in exceptionHandlers) {
				if (!FitsInSmallExceptionClause(eh.TryStart, eh.TryEnd))
					return true;
				if (!FitsInSmallExceptionClause(eh.HandlerStart, eh.HandlerEnd))
					return true;
			}

			return false;
		}

		bool FitsInSmallExceptionClause(Instruction start, Instruction end) {
			uint offs1 = GetOffset2(start);
			uint offs2 = GetOffset2(end);
			if (offs2 < offs1)
				return false;
			return offs1 <= ushort.MaxValue && offs2 - offs1 <= byte.MaxValue;
		}

		uint GetOffset2(Instruction instr) {
			if (instr == null)
				return codeSize;
			return GetOffset(instr);
		}

		void WriteFatExceptionClauses(BinaryWriter writer) {
			const int maxExceptionHandlers = (0x00FFFFFF - 4) / 24;
			int numExceptionHandlers = exceptionHandlers.Count;
			if (numExceptionHandlers > maxExceptionHandlers) {
				Error("Too many exception handlers");
				numExceptionHandlers = maxExceptionHandlers;
			}

			writer.Write((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);
			for (int i = 0; i < numExceptionHandlers; i++) {
				var eh = exceptionHandlers[i];
				uint offs1, offs2;

				writer.Write((uint)eh.HandlerType);

				offs1 = GetOffset2(eh.TryStart);
				offs2 = GetOffset2(eh.TryEnd);
				if (offs2 <= offs1)
					Error("Exception handler: TryEnd <= TryStart");
				writer.Write(offs1);
				writer.Write(offs2 - offs1);

				offs1 = GetOffset2(eh.HandlerStart);
				offs2 = GetOffset2(eh.HandlerEnd);
				if (offs2 <= offs1)
					Error("Exception handler: HandlerEnd <= HandlerStart");
				writer.Write(offs1);
				writer.Write(offs2 - offs1);

				if (eh.HandlerType == ExceptionHandlerType.Catch)
					writer.Write(helper.GetToken(eh.CatchType).Raw);
				else if (eh.HandlerType == ExceptionHandlerType.Filter)
					writer.Write(GetOffset2(eh.FilterStart));
				else
					writer.Write(0);
			}
		}

		void WriteSmallExceptionClauses(BinaryWriter writer) {
			const int maxExceptionHandlers = (0xFF - 4) / 12;
			int numExceptionHandlers = exceptionHandlers.Count;
			if (numExceptionHandlers > maxExceptionHandlers) {
				Error("Too many exception handlers");
				numExceptionHandlers = maxExceptionHandlers;
			}

			writer.Write((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);
			for (int i = 0; i < numExceptionHandlers; i++) {
				var eh = exceptionHandlers[i];
				uint offs1, offs2;

				writer.Write((ushort)eh.HandlerType);

				offs1 = GetOffset2(eh.TryStart);
				offs2 = GetOffset2(eh.TryEnd);
				if (offs2 <= offs1)
					Error("Exception handler: TryEnd <= TryStart");
				writer.Write((ushort)offs1);
				writer.Write((byte)(offs2 - offs1));

				offs1 = GetOffset2(eh.HandlerStart);
				offs2 = GetOffset2(eh.HandlerEnd);
				if (offs2 <= offs1)
					Error("Exception handler: HandlerEnd <= HandlerStart");
				writer.Write((ushort)offs1);
				writer.Write((byte)(offs2 - offs1));

				if (eh.HandlerType == ExceptionHandlerType.Catch)
					writer.Write(helper.GetToken(eh.CatchType).Raw);
				else if (eh.HandlerType == ExceptionHandlerType.Filter)
					writer.Write(GetOffset2(eh.FilterStart));
				else
					writer.Write(0);
			}
		}

		/// <inheritdoc/>
		protected override void ErrorImpl(string message) {
			helper.Error(message);
		}

		/// <inheritdoc/>
		protected override void WriteInlineField(BinaryWriter writer, Instruction instr) {
			writer.Write(helper.GetToken(instr.Operand).Raw);
		}

		/// <inheritdoc/>
		protected override void WriteInlineMethod(BinaryWriter writer, Instruction instr) {
			writer.Write(helper.GetToken(instr.Operand).Raw);
		}

		/// <inheritdoc/>
		protected override void WriteInlineSig(BinaryWriter writer, Instruction instr) {
			writer.Write(helper.GetToken(instr.Operand).Raw);
		}

		/// <inheritdoc/>
		protected override void WriteInlineString(BinaryWriter writer, Instruction instr) {
			writer.Write(helper.GetToken(instr.Operand).Raw);
		}

		/// <inheritdoc/>
		protected override void WriteInlineTok(BinaryWriter writer, Instruction instr) {
			writer.Write(helper.GetToken(instr.Operand).Raw);
		}

		/// <inheritdoc/>
		protected override void WriteInlineType(BinaryWriter writer, Instruction instr) {
			writer.Write(helper.GetToken(instr.Operand).Raw);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/MethodBodyWriterBase.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using System.IO;
using dnlib.DotNet.Emit;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Base class of all CIL method body writers
	/// </summary>
	public abstract class MethodBodyWriterBase {
		/// <summary/>
		protected IList<Instruction> instructions;
		/// <summary/>
		protected IList<ExceptionHandler> exceptionHandlers;
		readonly Dictionary<Instruction, uint> offsets = new Dictionary<Instruction, uint>();
		uint firstInstructionOffset;
		int errors;
		MaxStackCalculator maxStackCalculator = MaxStackCalculator.Create();

		/// <summary>
		/// <c>true</c> if there was at least one error
		/// </summary>
		public bool ErrorDetected {
			get { return errors > 0; }
		}

		internal MethodBodyWriterBase() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <param name="exceptionHandlers">All exception handlers</param>
		protected MethodBodyWriterBase(IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
		}

		internal void Reset(IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
			offsets.Clear();
			firstInstructionOffset = 0;
			errors = 0;
		}

		/// <summary>
		/// Called when an error is detected (eg. a null pointer). The error can be
		/// ignored but the method won't be valid.
		/// </summary>
		/// <param name="message">Error message</param>
		protected void Error(string message) {
			errors++;
			ErrorImpl(message);
		}

		/// <summary>
		/// Called when an error is detected (eg. a null pointer). The error can be
		/// ignored but the method won't be valid.
		/// </summary>
		/// <param name="message">Error message</param>
		protected virtual void ErrorImpl(string message) {
		}

		/// <summary>
		/// Gets max stack value
		/// </summary>
		protected uint GetMaxStack() {
			if (instructions.Count == 0)
				return 0;
			uint maxStack;
			maxStackCalculator.Reset(instructions, exceptionHandlers);
			if (!maxStackCalculator.Calculate(out maxStack)) {
				Error("Error calculating max stack value. If the method's obfuscated, set CilBody.KeepOldMaxStack or MetaDataOptions.Flags (KeepOldMaxStack, global option) to ignore this error. Otherwise fix your generated CIL code so it conforms to the ECMA standard.");
				maxStack += 8;
			}
			return maxStack;
		}

		/// <summary>
		/// Gets the offset of an instruction
		/// </summary>
		/// <param name="instr">The instruction</param>
		/// <returns>The offset or <c>0</c> if <paramref name="instr"/> is <c>null</c> or not
		/// present in the list of all instructions.</returns>
		protected uint GetOffset(Instruction instr) {
			if (instr == null) {
				Error("Instruction is null");
				return 0;
			}
			uint offset;
			if (offsets.TryGetValue(instr, out offset))
				return offset;
			Error("Found some other method's instruction or a removed instruction. You probably removed an instruction that is the target of a branch instruction or an instruction that's the first/last instruction in an exception handler.");
			return 0;
		}

		/// <summary>
		/// Initializes instruction offsets and returns the total code size
		/// </summary>
		/// <returns>Size of code</returns>
		protected uint InitializeInstructionOffsets() {
			uint offset = 0;
			foreach (var instr in instructions) {
				if (instr == null)
					continue;
				offsets[instr] = offset;
				offset += GetSizeOfInstruction(instr);
			}
			return offset;
		}

		/// <summary>
		/// Gets the size of an instruction
		/// </summary>
		/// <param name="instr">The instruction</param>
		/// <returns>Size of the instruction in bytes</returns>
		protected virtual uint GetSizeOfInstruction(Instruction instr) {
			return (uint)instr.GetSize();
		}

		/// <summary>
		/// Writes all instructions to <paramref name="writer"/> at its current offset
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <returns>Number of bytes written</returns>
		protected uint WriteInstructions(BinaryWriter writer) {
			firstInstructionOffset = (uint)writer.BaseStream.Position;
			foreach (var instr in instructions) {
				if (instr == null)
					continue;
				WriteInstruction(writer, instr);
			}
			return ToInstructionOffset(writer);
		}

		/// <summary>
		/// Gets the current offset in the instruction stream. This offset is relative to
		/// the first written instruction.
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <returns>Current offset, relative to the first written instruction</returns>
		protected uint ToInstructionOffset(BinaryWriter writer) {
			return (uint)writer.BaseStream.Position - firstInstructionOffset;
		}

		/// <summary>
		/// Writes an instruction
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <param name="instr">The instruction</param>
		protected virtual void WriteInstruction(BinaryWriter writer, Instruction instr) {
			WriteOpCode(writer, instr);
			WriteOperand(writer, instr);
		}

		/// <summary>
		/// Writes an instruction's opcode
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <param name="instr">The instruction</param>
		protected virtual void WriteOpCode(BinaryWriter writer, Instruction instr) {
			var code = instr.OpCode.Code;
			if ((ushort)code <= 0xFF)
				writer.Write((byte)code);
			else if (((ushort)code >> 8) == 0xFE) {
				writer.Write((byte)((ushort)code >> 8));
				writer.Write((byte)code);
			}
			else if (code == Code.UNKNOWN1)
				writer.Write((byte)Code.Nop);
			else if (code == Code.UNKNOWN2)
				writer.Write((ushort)(((ushort)Code.Nop << 8) | Code.Nop));
			else {
				Error("Unknown instruction");
				writer.Write((byte)Code.Nop);
			}
		}

		/// <summary>
		/// Writes an instruction's operand
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <param name="instr">The instruction</param>
		protected virtual void WriteOperand(BinaryWriter writer, Instruction instr) {
			switch (instr.OpCode.OperandType) {
			case OperandType.InlineBrTarget:	WriteInlineBrTarget(writer, instr); break;
			case OperandType.InlineField:		WriteInlineField(writer, instr); break;
			case OperandType.InlineI:			WriteInlineI(writer, instr); break;
			case OperandType.InlineI8:			WriteInlineI8(writer, instr); break;
			case OperandType.InlineMethod:		WriteInlineMethod(writer, instr); break;
			case OperandType.InlineNone:		WriteInlineNone(writer, instr); break;
			case OperandType.InlinePhi:			WriteInlinePhi(writer, instr); break;
			case OperandType.InlineR:			WriteInlineR(writer, instr); break;
			case OperandType.InlineSig:			WriteInlineSig(writer, instr); break;
			case OperandType.InlineString:		WriteInlineString(writer, instr); break;
			case OperandType.InlineSwitch:		WriteInlineSwitch(writer, instr); break;
			case OperandType.InlineTok:			WriteInlineTok(writer, instr); break;
			case OperandType.InlineType:		WriteInlineType(writer, instr); break;
			case OperandType.InlineVar:			WriteInlineVar(writer, instr); break;
			case OperandType.ShortInlineBrTarget: WriteShortInlineBrTarget(writer, instr); break;
			case OperandType.ShortInlineI:		WriteShortInlineI(writer, instr); break;
			case OperandType.ShortInlineR:		WriteShortInlineR(writer, instr); break;
			case OperandType.ShortInlineVar:	WriteShortInlineVar(writer, instr); break;

			default:
				Error("Unknown operand type");
				break;
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineBrTarget"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineBrTarget(BinaryWriter writer, Instruction instr) {
			uint displ = GetOffset(instr.Operand as Instruction) - (ToInstructionOffset(writer) + 4);
			writer.Write(displ);
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineField"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineField(BinaryWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineI"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineI(BinaryWriter writer, Instruction instr) {
			if (instr.Operand is int)
				writer.Write((int)instr.Operand);
			else {
				Error("Operand is not an Int32");
				writer.Write(0);
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineI8"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineI8(BinaryWriter writer, Instruction instr) {
			if (instr.Operand is long)
				writer.Write((long)instr.Operand);
			else {
				Error("Operand is not an Int64");
				writer.Write(0L);
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineMethod"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineMethod(BinaryWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineNone"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineNone(BinaryWriter writer, Instruction instr) {
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlinePhi"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlinePhi(BinaryWriter writer, Instruction instr) {
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineR"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineR(BinaryWriter writer, Instruction instr) {
			if (instr.Operand is double)
				writer.Write((double)instr.Operand);
			else {
				Error("Operand is not a Double");
				writer.Write(0D);
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineSig"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineSig(BinaryWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineString"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineString(BinaryWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineSwitch"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineSwitch(BinaryWriter writer, Instruction instr) {
			var targets = instr.Operand as IList<Instruction>;
			if (targets == null) {
				Error("switch operand is not a list of instructions");
				writer.Write(0);
			}
			else {
				uint offsetAfter = (uint)(ToInstructionOffset(writer) + 4 + targets.Count * 4);
				writer.Write(targets.Count);
				foreach (var target in targets)
					writer.Write(GetOffset(target) - offsetAfter);
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineTok"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineTok(BinaryWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineType"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineType(BinaryWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineVar"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineVar(BinaryWriter writer, Instruction instr) {
			var variable = instr.Operand as IVariable;
			if (variable == null) {
				Error("Operand is not a local/arg");
				writer.Write((ushort)0);
			}
			else if (ushort.MinValue <= variable.Index && variable.Index <= ushort.MaxValue)
				writer.Write((ushort)variable.Index);
			else {
				Error("Local/arg index doesn't fit in a UInt16");
				writer.Write((ushort)0);
			}
		}

		/// <summary>
		/// Writes a <see cref="OperandType.ShortInlineBrTarget"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteShortInlineBrTarget(BinaryWriter writer, Instruction instr) {
			int displ = (int)(GetOffset(instr.Operand as Instruction) - (ToInstructionOffset(writer) + 1));
			if (sbyte.MinValue <= displ && displ <= sbyte.MaxValue)
				writer.Write((sbyte)displ);
			else {
				Error("Target instruction is too far away for a short branch. Use the long branch or call CilBody.SimplifyBranches() and CilBody.OptimizeBranches()");
				writer.Write((byte)0);
			}
		}

		/// <summary>
		/// Writes a <see cref="OperandType.ShortInlineI"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteShortInlineI(BinaryWriter writer, Instruction instr) {
			if (instr.Operand is sbyte)
				writer.Write((sbyte)instr.Operand);
			else if (instr.Operand is byte)
				writer.Write((byte)instr.Operand);
			else {
				Error("Operand is not a Byte or a SByte");
				writer.Write((byte)0);
			}
		}

		/// <summary>
		/// Writes a <see cref="OperandType.ShortInlineR"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteShortInlineR(BinaryWriter writer, Instruction instr) {
			if (instr.Operand is float)
				writer.Write((float)instr.Operand);
			else {
				Error("Operand is not a Single");
				writer.Write(0F);
			}
		}

		/// <summary>
		/// Writes a <see cref="OperandType.ShortInlineVar"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteShortInlineVar(BinaryWriter writer, Instruction instr) {
			var variable = instr.Operand as IVariable;
			if (variable == null) {
				Error("Operand is not a local/arg");
				writer.Write((byte)0);
			}
			else if (byte.MinValue <= variable.Index && variable.Index <= byte.MaxValue)
				writer.Write((byte)variable.Index);
			else {
				Error("Local/arg index doesn't fit in a Byte. Use the longer ldloc/ldarg/stloc/starg instruction.");
				writer.Write((byte)0);
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ModuleWriter.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.IO;
using dnlib.DotNet.MD;
using dnlib.PE;
using dnlib.W32Resources;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="ModuleWriter"/> options
	/// </summary>
	public sealed class ModuleWriterOptions : ModuleWriterOptionsBase {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleWriterOptions() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		public ModuleWriterOptions(ModuleDef module)
			: this(module, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		/// <param name="listener">Module writer listener</param>
		public ModuleWriterOptions(ModuleDef module, IModuleWriterListener listener)
			: base(module, listener) {
		}
	}

	/// <summary>
	/// Writes a .NET PE file. See also <see cref="NativeModuleWriter"/>
	/// </summary>
	public sealed class ModuleWriter : ModuleWriterBase {
		const uint DEFAULT_RELOC_ALIGNMENT = 4;

		readonly ModuleDef module;
		ModuleWriterOptions options;

		List<PESection> sections;
		PESection textSection;
		PESection sdataSection;
		PESection rsrcSection;
		PESection relocSection;

		PEHeaders peHeaders;
		ImportAddressTable importAddressTable;
		ImageCor20Header imageCor20Header;
		ImportDirectory importDirectory;
		StartupStub startupStub;
		RelocDirectory relocDirectory;
		ManagedExportsWriter managedExportsWriter;
		bool needStartupStub;

		/// <inheritdoc/>
		public override ModuleDef Module {
			get { return module; }
		}

		/// <inheritdoc/>
		public override ModuleWriterOptionsBase TheOptions {
			get { return Options; }
		}

		/// <summary>
		/// Gets/sets the writer options. This is never <c>null</c>
		/// </summary>
		public ModuleWriterOptions Options {
			get { return options ?? (options = new ModuleWriterOptions(module)); }
			set { options = value; }
		}

		/// <summary>
		/// Gets all <see cref="PESection"/>s
		/// </summary>
		public override List<PESection> Sections {
			get { return sections; }
		}

		/// <summary>
		/// Gets the <c>.text</c> section
		/// </summary>
		public override PESection TextSection {
			get { return textSection; }
		}

		/// <summary>
		/// Gets the <c>.sdata</c> section
		/// </summary>
		internal PESection SdataSection {
			get { return sdataSection; }
		}

		/// <summary>
		/// Gets the <c>.rsrc</c> section or null if none
		/// </summary>
		public override PESection RsrcSection {
			get { return rsrcSection; }
		}

		/// <summary>
		/// Gets the <c>.reloc</c> section
		/// </summary>
		public PESection RelocSection {
			get { return relocSection; }
		}

		/// <summary>
		/// Gets the PE headers
		/// </summary>
		public PEHeaders PEHeaders {
			get { return peHeaders; }
		}

		/// <summary>
		/// Gets the IAT or <c>null</c> if there's none
		/// </summary>
		public ImportAddressTable ImportAddressTable {
			get { return importAddressTable; }
		}

		/// <summary>
		/// Gets the .NET header
		/// </summary>
		public ImageCor20Header ImageCor20Header {
			get { return imageCor20Header; }
		}

		/// <summary>
		/// Gets the import directory or <c>null</c> if there's none
		/// </summary>
		public ImportDirectory ImportDirectory {
			get { return importDirectory; }
		}

		/// <summary>
		/// Gets the startup stub or <c>null</c> if there's none
		/// </summary>
		public StartupStub StartupStub {
			get { return startupStub; }
		}

		/// <summary>
		/// Gets the reloc directory or <c>null</c> if there's none
		/// </summary>
		public RelocDirectory RelocDirectory {
			get { return relocDirectory; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		public ModuleWriter(ModuleDef module)
			: this(module, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		/// <param name="options">Options or <c>null</c></param>
		public ModuleWriter(ModuleDef module, ModuleWriterOptions options) {
			this.module = module;
			this.options = options;
		}

		/// <inheritdoc/>
		protected override long WriteImpl() {
			Initialize();
			metaData.CreateTables();
			return WriteFile();
		}

		void Initialize() {
			CreateSections();
			Listener.OnWriterEvent(this, ModuleWriterEvent.PESectionsCreated);

			CreateChunks();
			Listener.OnWriterEvent(this, ModuleWriterEvent.ChunksCreated);

			AddChunksToSections();
			Listener.OnWriterEvent(this, ModuleWriterEvent.ChunksAddedToSections);
		}

		/// <inheritdoc/>
		protected override Win32Resources GetWin32Resources() {
			return Options.Win32Resources ?? module.Win32Resources;
		}

		void CreateSections() {
			sections = new List<PESection>();
			sections.Add(textSection = new PESection(".text", 0x60000020));
			sections.Add(sdataSection = new PESection(".sdata", 0xC0000040));
			if (GetWin32Resources() != null)
				sections.Add(rsrcSection = new PESection(".rsrc", 0x40000040));
			// Should be last so any data in a previous section can add relocations
			sections.Add(relocSection = new PESection(".reloc", 0x42000040));
		}

		void CreateChunks() {
			peHeaders = new PEHeaders(Options.PEHeadersOptions);

			var machine = Options.PEHeadersOptions.Machine ?? Machine.I386;
			bool is64bit = machine == Machine.AMD64 || machine == Machine.IA64 || machine == Machine.ARM64;
			relocDirectory = new RelocDirectory(machine);
			if (machine == Machine.I386)
				needStartupStub = true;

			importAddressTable = new ImportAddressTable(is64bit);
			importDirectory = new ImportDirectory(is64bit);
			startupStub = new StartupStub(relocDirectory, machine, (format, args) => Error(format, args));

			CreateStrongNameSignature();

			imageCor20Header = new ImageCor20Header(Options.Cor20HeaderOptions);
			CreateMetaDataChunks(module);
			managedExportsWriter = new ManagedExportsWriter(UTF8String.ToSystemStringOrEmpty(module.Name), machine, relocDirectory, metaData, peHeaders, (format, args) => Error(format, args));

			CreateDebugDirectory();

			importDirectory.IsExeFile = Options.IsExeFile;
			peHeaders.IsExeFile = Options.IsExeFile;
		}

		void AddChunksToSections() {
			var machine = Options.PEHeadersOptions.Machine ?? Machine.I386;
			bool is64bit = machine == Machine.AMD64 || machine == Machine.IA64 || machine == Machine.ARM64;
			uint pointerAlignment = is64bit ? 8U : 4;

			textSection.Add(importAddressTable, pointerAlignment);
			textSection.Add(imageCor20Header, DEFAULT_COR20HEADER_ALIGNMENT);
			textSection.Add(strongNameSignature, DEFAULT_STRONGNAMESIG_ALIGNMENT);
			managedExportsWriter.AddTextChunks(textSection);
			textSection.Add(constants, DEFAULT_CONSTANTS_ALIGNMENT);
			textSection.Add(methodBodies, DEFAULT_METHODBODIES_ALIGNMENT);
			textSection.Add(netResources, DEFAULT_NETRESOURCES_ALIGNMENT);
			textSection.Add(metaData, DEFAULT_METADATA_ALIGNMENT);
			textSection.Add(debugDirectory, DebugDirectory.DEFAULT_DEBUGDIRECTORY_ALIGNMENT);
			textSection.Add(importDirectory, pointerAlignment);
			textSection.Add(startupStub, startupStub.Alignment);
			managedExportsWriter.AddSdataChunks(sdataSection);
			if (GetWin32Resources() != null)
				rsrcSection.Add(win32Resources, DEFAULT_WIN32_RESOURCES_ALIGNMENT);
			relocSection.Add(relocDirectory, DEFAULT_RELOC_ALIGNMENT);
		}

		long WriteFile() {
			managedExportsWriter.AddExportedMethods(metaData.ExportedMethods, GetTimeDateStamp());
			if (managedExportsWriter.HasExports)
				needStartupStub = true;

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginWritePdb);
			WritePdbFile();
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndWritePdb);

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginCalculateRvasAndFileOffsets);
			var chunks = new List<IChunk>();
			chunks.Add(peHeaders);
			if (!managedExportsWriter.HasExports)
				sections.Remove(sdataSection);
			if (!(relocDirectory.NeedsRelocSection || managedExportsWriter.HasExports || needStartupStub))
				sections.Remove(relocSection);

			importAddressTable.Enable = needStartupStub;
			importDirectory.Enable = needStartupStub;
			startupStub.Enable = needStartupStub;

			foreach (var section in sections)
				chunks.Add(section);
			peHeaders.PESections = sections;
			CalculateRvasAndFileOffsets(chunks, 0, 0, peHeaders.FileAlignment, peHeaders.SectionAlignment);
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndCalculateRvasAndFileOffsets);

			InitializeChunkProperties();

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginWriteChunks);
			var writer = new BinaryWriter(destStream);
			WriteChunks(writer, chunks, 0, peHeaders.FileAlignment);
			long imageLength = writer.BaseStream.Position - destStreamBaseOffset;
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndWriteChunks);

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginStrongNameSign);
			if (Options.StrongNameKey != null)
				StrongNameSign((long)strongNameSignature.FileOffset);
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndStrongNameSign);

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginWritePEChecksum);
			if (Options.AddCheckSum)
				peHeaders.WriteCheckSum(writer, imageLength);
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndWritePEChecksum);

			return imageLength;
		}

		void InitializeChunkProperties() {
			Options.Cor20HeaderOptions.EntryPoint = GetEntryPoint();

			importAddressTable.ImportDirectory = importDirectory;
			importDirectory.ImportAddressTable = importAddressTable;
			startupStub.ImportDirectory = importDirectory;
			startupStub.PEHeaders = peHeaders;
			peHeaders.StartupStub = startupStub;
			peHeaders.ImageCor20Header = imageCor20Header;
			peHeaders.ImportAddressTable = importAddressTable;
			peHeaders.ImportDirectory = importDirectory;
			peHeaders.Win32Resources = win32Resources;
			peHeaders.RelocDirectory = relocDirectory;
			peHeaders.DebugDirectory = debugDirectory;
			imageCor20Header.MetaData = metaData;
			imageCor20Header.NetResources = netResources;
			imageCor20Header.StrongNameSignature = strongNameSignature;
			managedExportsWriter.InitializeChunkProperties();
		}

		uint GetEntryPoint() {
			var methodEntryPoint = module.ManagedEntryPoint as MethodDef;
			if (methodEntryPoint != null)
				return new MDToken(Table.Method, metaData.GetRid(methodEntryPoint)).Raw;

			var fileEntryPoint = module.ManagedEntryPoint as FileDef;
			if (fileEntryPoint != null)
				return new MDToken(Table.File, metaData.GetRid(fileEntryPoint)).Raw;

			uint nativeEntryPoint = (uint)module.NativeEntryPoint;
			if (nativeEntryPoint != 0)
				return nativeEntryPoint;

			return 0;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ModuleWriterBase.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.DotNet.Pdb;
using dnlib.PE;
using dnlib.W32Resources;
using dnlib.DotNet.MD;
using System.Diagnostics;
using dnlib.DotNet.Pdb.WindowsPdb;
using System.Text;
using System.IO.Compression;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Common module writer options base class
	/// </summary>
	public class ModuleWriterOptionsBase {
		IModuleWriterListener listener;
		PEHeadersOptions peHeadersOptions;
		Cor20HeaderOptions cor20HeaderOptions;
		MetaDataOptions metaDataOptions;
		ILogger logger;
		ILogger metaDataLogger;
		Win32Resources win32Resources;
		StrongNameKey strongNameKey;
		StrongNamePublicKey strongNamePublicKey;
		bool delaySign;

		/// <summary>
		/// Gets/sets the listener
		/// </summary>
		public IModuleWriterListener Listener {
			get { return listener; }
			set { listener = value; }
		}

		/// <summary>
		/// Gets/sets the logger. If this is <c>null</c>, any errors result in a
		/// <see cref="ModuleWriterException"/> being thrown. To disable this behavior, either
		/// create your own logger or use <see cref="DummyLogger.NoThrowInstance"/>.
		/// </summary>
		public ILogger Logger {
			get { return logger; }
			set { logger = value; }
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaData"/> writer logger. If this is <c>null</c>, use
		/// <see cref="Logger"/>.
		/// </summary>
		public ILogger MetaDataLogger {
			get { return metaDataLogger; }
			set { metaDataLogger = value; }
		}

		/// <summary>
		/// Gets/sets the <see cref="PEHeaders"/> options. This is never <c>null</c>.
		/// </summary>
		public PEHeadersOptions PEHeadersOptions {
			get { return peHeadersOptions ?? (peHeadersOptions = new PEHeadersOptions()); }
			set { peHeadersOptions = value; }
		}

		/// <summary>
		/// Gets/sets the <see cref="ImageCor20Header"/> options. This is never <c>null</c>.
		/// </summary>
		public Cor20HeaderOptions Cor20HeaderOptions {
			get { return cor20HeaderOptions ?? (cor20HeaderOptions = new Cor20HeaderOptions()); }
			set { cor20HeaderOptions = value; }
		}

		/// <summary>
		/// Gets/sets the <see cref="MetaData"/> options. This is never <c>null</c>.
		/// </summary>
		public MetaDataOptions MetaDataOptions {
			get { return metaDataOptions ?? (metaDataOptions = new MetaDataOptions()); }
			set { metaDataOptions = value; }
		}

		/// <summary>
		/// Gets/sets the Win32 resources. If this is <c>null</c>, use the module's
		/// Win32 resources if any.
		/// </summary>
		public Win32Resources Win32Resources {
			get { return win32Resources; }
			set { win32Resources = value; }
		}

		/// <summary>
		/// true to delay sign the assembly. Initialize <see cref="StrongNamePublicKey"/> to the
		/// public key to use, and don't initialize <see cref="StrongNameKey"/>. To generate the
		/// public key from your strong name key file, execute <c>sn -p mykey.snk mypublickey.snk</c>
		/// </summary>
		public bool DelaySign {
			get { return delaySign; }
			set { delaySign = value; }
		}

		/// <summary>
		/// Gets/sets the strong name key. When you enhance strong name sign an assembly,
		/// this instance's HashAlgorithm must be initialized to its public key's HashAlgorithm.
		/// You should call <see cref="InitializeStrongNameSigning(ModuleDef,StrongNameKey)"/>
		/// to initialize this property if you use normal strong name signing.
		/// You should call <see cref="InitializeEnhancedStrongNameSigning(ModuleDef,StrongNameKey,StrongNamePublicKey)"/>
		/// or <see cref="InitializeEnhancedStrongNameSigning(ModuleDef,StrongNameKey,StrongNamePublicKey,StrongNameKey,StrongNamePublicKey)"/>
		/// to initialize this property if you use enhanced strong name signing.
		/// </summary>
		public StrongNameKey StrongNameKey {
			get { return strongNameKey; }
			set { strongNameKey = value; }
		}

		/// <summary>
		/// Gets/sets the new public key that should be used. If this is <c>null</c>, use
		/// the public key generated from <see cref="StrongNameKey"/>. If it is also <c>null</c>,
		/// use the module's Assembly's public key.
		/// You should call <see cref="InitializeEnhancedStrongNameSigning(ModuleDef,StrongNameKey,StrongNamePublicKey)"/>
		/// or <see cref="InitializeEnhancedStrongNameSigning(ModuleDef,StrongNameKey,StrongNamePublicKey,StrongNameKey,StrongNamePublicKey)"/>
		/// to initialize this property if you use enhanced strong name signing.
		/// </summary>
		public StrongNamePublicKey StrongNamePublicKey {
			get { return strongNamePublicKey; }
			set { strongNamePublicKey = value; }
		}

		/// <summary>
		/// <c>true</c> if method bodies can be shared (two or more method bodies can share the
		/// same RVA), <c>false</c> if method bodies can't be shared. Don't enable it if there
		/// must be a 1:1 relationship with method bodies and their RVAs.
		/// </summary>
		public bool ShareMethodBodies { get; set; }

		/// <summary>
		/// <c>true</c> if the PE header CheckSum field should be updated, <c>false</c> if the
		/// CheckSum field isn't updated.
		/// </summary>
		public bool AddCheckSum { get; set; }

		/// <summary>
		/// <c>true</c> if it's a 64-bit module, <c>false</c> if it's a 32-bit or AnyCPU module.
		/// </summary>
		public bool Is64Bit {
			get {
				if (!PEHeadersOptions.Machine.HasValue)
					return false;
				return PEHeadersOptions.Machine == Machine.IA64 ||
					PEHeadersOptions.Machine == Machine.AMD64 ||
					PEHeadersOptions.Machine == Machine.ARM64;
			}
		}

		/// <summary>
		/// Gets/sets the module kind
		/// </summary>
		public ModuleKind ModuleKind { get; set; }

		/// <summary>
		/// <c>true</c> if it should be written as an EXE file, <c>false</c> if it should be
		/// written as a DLL file.
		/// </summary>
		public bool IsExeFile {
			get {
				return ModuleKind != ModuleKind.Dll &&
					ModuleKind != ModuleKind.NetModule;
			}
		}

		/// <summary>
		/// Set it to <c>true</c> to enable writing a PDB file. Default is <c>false</c> (a PDB file
		/// won't be written to disk).
		/// </summary>
		public bool WritePdb { get; set; }

		/// <summary>
		/// PDB file name. If it's <c>null</c> a PDB file with the same name as the output assembly
		/// will be created but with a PDB extension. <see cref="WritePdb"/> must be <c>true</c> or
		/// this property is ignored.
		/// </summary>
		public string PdbFileName { get; set; }

		/// <summary>
		/// PDB stream. If this is initialized, then you should also set <see cref="PdbFileName"/>
		/// to the name of the PDB file since the file name must be written to the PE debug directory.
		/// <see cref="WritePdb"/> must be <c>true</c> or this property is ignored.
		/// </summary>
		public Stream PdbStream { get; set; }

		/// <summary>
		/// GUID used by some PDB writers, eg. portable PDB writer. It's initialized to a random GUID.
		/// </summary>
		public Guid PdbGuid { get; set; }

		/// <summary>
		/// Default constructor
		/// </summary>
		protected ModuleWriterOptionsBase() {
			ShareMethodBodies = true;
			ModuleKind = ModuleKind.Windows;
			PdbGuid = Guid.NewGuid();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		protected ModuleWriterOptionsBase(ModuleDef module)
			: this(module, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		/// <param name="listener">Module writer listener</param>
		protected ModuleWriterOptionsBase(ModuleDef module, IModuleWriterListener listener) {
			this.listener = listener;
			PdbGuid = Guid.NewGuid();
			ShareMethodBodies = true;
			MetaDataOptions.MetaDataHeaderOptions.VersionString = module.RuntimeVersion;
			ModuleKind = module.Kind;
			PEHeadersOptions.Machine = module.Machine;
			PEHeadersOptions.Characteristics = module.Characteristics;
			PEHeadersOptions.DllCharacteristics = module.DllCharacteristics;
			if (module.Kind == ModuleKind.Windows)
				PEHeadersOptions.Subsystem = Subsystem.WindowsGui;
			else
				PEHeadersOptions.Subsystem = Subsystem.WindowsCui;
			PEHeadersOptions.NumberOfRvaAndSizes = 0x10;
			Cor20HeaderOptions.Flags = module.Cor20HeaderFlags;

			if (module.Assembly != null && !PublicKeyBase.IsNullOrEmpty2(module.Assembly.PublicKey))
				Cor20HeaderOptions.Flags |= ComImageFlags.StrongNameSigned;

			if (module.Cor20HeaderRuntimeVersion != null) {
				Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);
				Cor20HeaderOptions.MinorRuntimeVersion = (ushort)module.Cor20HeaderRuntimeVersion.Value;
			}
			else if (module.IsClr1x) {
				Cor20HeaderOptions.MajorRuntimeVersion = 2;
				Cor20HeaderOptions.MinorRuntimeVersion = 0;
			}
			else {
				Cor20HeaderOptions.MajorRuntimeVersion = 2;
				Cor20HeaderOptions.MinorRuntimeVersion = 5;
			}

			if (module.TablesHeaderVersion != null) {
				MetaDataOptions.TablesHeapOptions.MajorVersion = (byte)(module.TablesHeaderVersion.Value >> 8);
				MetaDataOptions.TablesHeapOptions.MinorVersion = (byte)module.TablesHeaderVersion.Value;
			}
			else if (module.IsClr1x) {
				// Generics aren't supported
				MetaDataOptions.TablesHeapOptions.MajorVersion = 1;
				MetaDataOptions.TablesHeapOptions.MinorVersion = 0;
			}
			else {
				// Generics are supported
				MetaDataOptions.TablesHeapOptions.MajorVersion = 2;
				MetaDataOptions.TablesHeapOptions.MinorVersion = 0;
			}

			// Some tools crash if #GUID is missing so always create it by default
			MetaDataOptions.Flags |= MetaDataFlags.AlwaysCreateGuidHeap;

			var modDefMD = module as ModuleDefMD;
			if (modDefMD != null) {
				var ntHeaders = modDefMD.MetaData.PEImage.ImageNTHeaders;
				PEHeadersOptions.TimeDateStamp = ntHeaders.FileHeader.TimeDateStamp;
				PEHeadersOptions.MajorLinkerVersion = ntHeaders.OptionalHeader.MajorLinkerVersion;
				PEHeadersOptions.MinorLinkerVersion = ntHeaders.OptionalHeader.MinorLinkerVersion;
				PEHeadersOptions.ImageBase = ntHeaders.OptionalHeader.ImageBase;
				PEHeadersOptions.MajorOperatingSystemVersion = ntHeaders.OptionalHeader.MajorOperatingSystemVersion;
				PEHeadersOptions.MinorOperatingSystemVersion = ntHeaders.OptionalHeader.MinorOperatingSystemVersion;
				PEHeadersOptions.MajorImageVersion = ntHeaders.OptionalHeader.MajorImageVersion;
				PEHeadersOptions.MinorImageVersion = ntHeaders.OptionalHeader.MinorImageVersion;
				PEHeadersOptions.MajorSubsystemVersion = ntHeaders.OptionalHeader.MajorSubsystemVersion;
				PEHeadersOptions.MinorSubsystemVersion = ntHeaders.OptionalHeader.MinorSubsystemVersion;
				PEHeadersOptions.Win32VersionValue = ntHeaders.OptionalHeader.Win32VersionValue;
				AddCheckSum = ntHeaders.OptionalHeader.CheckSum != 0;
			}

			if (Is64Bit) {
				PEHeadersOptions.Characteristics &= ~Characteristics._32BitMachine;
				PEHeadersOptions.Characteristics |= Characteristics.LargeAddressAware;
			}
			else if (modDefMD == null)
				PEHeadersOptions.Characteristics |= Characteristics._32BitMachine;
		}

		/// <summary>
		/// Initializes <see cref="StrongNameKey"/> and <see cref="StrongNamePublicKey"/>
		/// for normal strong name signing.
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="signatureKey">Signature strong name key pair</param>
		public void InitializeStrongNameSigning(ModuleDef module, StrongNameKey signatureKey) {
			StrongNameKey = signatureKey;
			StrongNamePublicKey = null;
			if (module.Assembly != null)
				module.Assembly.CustomAttributes.RemoveAll("System.Reflection.AssemblySignatureKeyAttribute");
		}

		/// <summary>
		/// Initializes <see cref="StrongNameKey"/> and <see cref="StrongNamePublicKey"/>
		/// for enhanced strong name signing (without key migration). See
		/// http://msdn.microsoft.com/en-us/library/hh415055.aspx
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="signatureKey">Signature strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		public void InitializeEnhancedStrongNameSigning(ModuleDef module, StrongNameKey signatureKey, StrongNamePublicKey signaturePubKey) {
			InitializeStrongNameSigning(module, signatureKey);
			StrongNameKey.HashAlgorithm = signaturePubKey.HashAlgorithm;
		}

		/// <summary>
		/// Initializes <see cref="StrongNameKey"/> and <see cref="StrongNamePublicKey"/>
		/// for enhanced strong name signing (with key migration). See
		/// http://msdn.microsoft.com/en-us/library/hh415055.aspx
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="signatureKey">Signature strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		/// <param name="identityKey">Identity strong name key pair</param>
		/// <param name="identityPubKey">Identity public key</param>
		public void InitializeEnhancedStrongNameSigning(ModuleDef module, StrongNameKey signatureKey, StrongNamePublicKey signaturePubKey, StrongNameKey identityKey, StrongNamePublicKey identityPubKey) {
			StrongNameKey = signatureKey;
			StrongNameKey.HashAlgorithm = signaturePubKey.HashAlgorithm;
			StrongNamePublicKey = identityPubKey;
			if (module.Assembly != null)
				module.Assembly.UpdateOrCreateAssemblySignatureKeyAttribute(identityPubKey, identityKey, signaturePubKey);
		}
	}

	/// <summary>
	/// Module writer base class
	/// </summary>
	public abstract class ModuleWriterBase : IMetaDataListener, ILogger {
		/// <summary>Default alignment of all constants</summary>
		protected internal const uint DEFAULT_CONSTANTS_ALIGNMENT = 8;
		/// <summary>Default alignment of all method bodies</summary>
		protected const uint DEFAULT_METHODBODIES_ALIGNMENT = 4;
		/// <summary>Default alignment of all .NET resources</summary>
		protected const uint DEFAULT_NETRESOURCES_ALIGNMENT = 8;
		/// <summary>Default alignment of the .NET metadata</summary>
		protected const uint DEFAULT_METADATA_ALIGNMENT = 4;
		/// <summary>Default Win32 resources alignment</summary>
		protected internal const uint DEFAULT_WIN32_RESOURCES_ALIGNMENT = 8;
		/// <summary>Default strong name signature alignment</summary>
		protected const uint DEFAULT_STRONGNAMESIG_ALIGNMENT = 16;
		/// <summary>Default COR20 header alignment</summary>
		protected const uint DEFAULT_COR20HEADER_ALIGNMENT = 4;

		/// <summary>See <see cref="DestinationStream"/></summary>
		protected Stream destStream;
		/// <summary>See <see cref="Constants"/></summary>
		protected UniqueChunkList<ByteArrayChunk> constants;
		/// <summary>See <see cref="MethodBodies"/></summary>
		protected MethodBodyChunks methodBodies;
		/// <summary>See <see cref="NetResources"/></summary>
		protected NetResources netResources;
		/// <summary>See <see cref="MetaData"/></summary>
		protected MetaData metaData;
		/// <summary>See <see cref="Win32Resources"/></summary>
		protected Win32ResourcesChunk win32Resources;
		/// <summary>Offset where the module is written. Usually 0.</summary>
		protected long destStreamBaseOffset;
		IModuleWriterListener listener;
		/// <summary>Debug directory</summary>
		protected DebugDirectory debugDirectory;

		string createdPdbFileName;

		/// <summary>
		/// Strong name signature
		/// </summary>
		protected StrongNameSignature strongNameSignature;

		/// <summary>
		/// Returns the module writer options
		/// </summary>
		public abstract ModuleWriterOptionsBase TheOptions { get; }

		/// <summary>
		/// Gets/sets the module writer listener
		/// </summary>
		protected IModuleWriterListener Listener {
			get { return listener ?? DummyModuleWriterListener.Instance; }
			set { listener = value; }
		}

		/// <summary>
		/// Gets the destination stream
		/// </summary>
		public Stream DestinationStream {
			get { return destStream; }
		}

		/// <summary>
		/// Gets the constants
		/// </summary>
		public UniqueChunkList<ByteArrayChunk> Constants {
			get { return constants; }
		}

		/// <summary>
		/// Gets the method bodies
		/// </summary>
		public MethodBodyChunks MethodBodies {
			get { return methodBodies; }
		}

		/// <summary>
		/// Gets the .NET resources
		/// </summary>
		public NetResources NetResources {
			get { return netResources; }
		}

		/// <summary>
		/// Gets the .NET metadata
		/// </summary>
		public MetaData MetaData {
			get { return metaData; }
		}

		/// <summary>
		/// Gets the Win32 resources or <c>null</c> if there's none
		/// </summary>
		public Win32ResourcesChunk Win32Resources {
			get { return win32Resources; }
		}

		/// <summary>
		/// Gets the strong name signature or <c>null</c> if there's none
		/// </summary>
		public StrongNameSignature StrongNameSignature {
			get { return strongNameSignature; }
		}

		/// <summary>
		/// Gets all <see cref="PESection"/>s
		/// </summary>
		public abstract List<PESection> Sections { get; }

		/// <summary>
		/// Gets the <c>.text</c> section
		/// </summary>
		public abstract PESection TextSection { get; }

		/// <summary>
		/// Gets the <c>.rsrc</c> section or <c>null</c> if there's none
		/// </summary>
		public abstract PESection RsrcSection { get; }

		/// <summary>
		/// Gets the debug directory or <c>null</c> if there's none
		/// </summary>
		public DebugDirectory DebugDirectory {
			get { return debugDirectory; }
		}

		/// <summary>
		/// <c>true</c> if <c>this</c> is a <see cref="NativeModuleWriter"/>, <c>false</c> if
		/// <c>this</c> is a <see cref="ModuleWriter"/>.
		/// </summary>
		public bool IsNativeWriter {
			get { return this is NativeModuleWriter; }
		}

		/// <summary>
		/// null if we're not writing a PDB
		/// </summary>
		PdbState pdbState;

		/// <summary>
		/// Writes the module to a file
		/// </summary>
		/// <param name="fileName">File name. The file will be truncated if it exists.</param>
		public void Write(string fileName) {
			using (var dest = new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite)) {
				dest.SetLength(0);
				try {
					Write(dest);
				}
				catch {
					// Writing failed. Delete the file since it's useless.
					dest.Close();
					DeleteFileNoThrow(fileName);
					throw;
				}
			}
		}

		static void DeleteFileNoThrow(string fileName) {
			if (string.IsNullOrEmpty(fileName))
				return;
			try {
				File.Delete(fileName);
			}
			catch {
			}
		}

		/// <summary>
		/// Writes the module to a <see cref="Stream"/>
		/// </summary>
		/// <param name="dest">Destination stream</param>
		public void Write(Stream dest) {
			pdbState = TheOptions.WritePdb && Module.PdbState != null ? Module.PdbState : null;
			if (TheOptions.DelaySign) {
				Debug.Assert(TheOptions.StrongNamePublicKey != null, "Options.StrongNamePublicKey must be initialized when delay signing the assembly");
				Debug.Assert(TheOptions.StrongNameKey == null, "Options.StrongNameKey must be null when delay signing the assembly");
				TheOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.StrongNameSigned;
			}
			else if (TheOptions.StrongNameKey != null || TheOptions.StrongNamePublicKey != null)
				TheOptions.Cor20HeaderOptions.Flags |= ComImageFlags.StrongNameSigned;

			Listener = TheOptions.Listener ?? DummyModuleWriterListener.Instance;
			destStream = dest;
			destStreamBaseOffset = destStream.Position;
			Listener.OnWriterEvent(this, ModuleWriterEvent.Begin);
			var imageLength = WriteImpl();
			destStream.Position = destStreamBaseOffset + imageLength;
			Listener.OnWriterEvent(this, ModuleWriterEvent.End);
		}

		/// <summary>
		/// Returns the module that is written
		/// </summary>
		public abstract ModuleDef Module { get; }

		/// <summary>
		/// Writes the module to <see cref="destStream"/>. <see cref="Listener"/> and
		/// <see cref="destStream"/> have been initialized when this method is called.
		/// </summary>
		/// <returns>Number of bytes written</returns>
		protected abstract long WriteImpl();

		/// <summary>
		/// Creates the strong name signature if the module has one of the strong name flags
		/// set or wants to sign the assembly.
		/// </summary>
		protected void CreateStrongNameSignature() {
			if (TheOptions.DelaySign && TheOptions.StrongNamePublicKey != null) {
				int len = TheOptions.StrongNamePublicKey.CreatePublicKey().Length - 0x20;
				strongNameSignature = new StrongNameSignature(len > 0 ? len : 0x80);
			}
			else if (TheOptions.StrongNameKey != null)
				strongNameSignature = new StrongNameSignature(TheOptions.StrongNameKey.SignatureSize);
			else if (Module.Assembly != null && !PublicKeyBase.IsNullOrEmpty2(Module.Assembly.PublicKey)) {
				int len = Module.Assembly.PublicKey.Data.Length - 0x20;
				strongNameSignature = new StrongNameSignature(len > 0 ? len : 0x80);
			}
			else if (((TheOptions.Cor20HeaderOptions.Flags ?? Module.Cor20HeaderFlags) & ComImageFlags.StrongNameSigned) != 0)
				strongNameSignature = new StrongNameSignature(0x80);
		}

		/// <summary>
		/// Creates the .NET metadata chunks (constants, method bodies, .NET resources,
		/// the metadata, and Win32 resources)
		/// </summary>
		/// <param name="module"></param>
		protected void CreateMetaDataChunks(ModuleDef module) {
			constants = new UniqueChunkList<ByteArrayChunk>();
			methodBodies = new MethodBodyChunks(TheOptions.ShareMethodBodies);
			netResources = new NetResources(DEFAULT_NETRESOURCES_ALIGNMENT);

			DebugMetaDataKind debugKind;
			if (pdbState != null && (pdbState.PdbFileKind == PdbFileKind.PortablePDB || pdbState.PdbFileKind == PdbFileKind.EmbeddedPortablePDB))
				debugKind = DebugMetaDataKind.Standalone;
			else
				debugKind = DebugMetaDataKind.None;
			metaData = MetaData.Create(module, constants, methodBodies, netResources, TheOptions.MetaDataOptions, debugKind);
			metaData.Logger = TheOptions.MetaDataLogger ?? this;
			metaData.Listener = this;

			// StrongNamePublicKey is used if the user wants to override the assembly's
			// public key or when enhanced strong naming the assembly.
			var pk = TheOptions.StrongNamePublicKey;
			if (pk != null)
				metaData.AssemblyPublicKey = pk.CreatePublicKey();
			else if (TheOptions.StrongNameKey != null)
				metaData.AssemblyPublicKey = TheOptions.StrongNameKey.PublicKey;

			var w32Resources = GetWin32Resources();
			if (w32Resources != null)
				win32Resources = new Win32ResourcesChunk(w32Resources);
		}

		/// <summary>
		/// Gets the Win32 resources that should be written to the new image or <c>null</c> if none
		/// </summary>
		protected abstract Win32Resources GetWin32Resources();

		/// <summary>
		/// Calculates <see cref="RVA"/> and <see cref="FileOffset"/> of all <see cref="IChunk"/>s
		/// </summary>
		/// <param name="chunks">All chunks</param>
		/// <param name="offset">Starting file offset</param>
		/// <param name="rva">Starting RVA</param>
		/// <param name="fileAlignment">File alignment</param>
		/// <param name="sectionAlignment">Section alignment</param>
		protected void CalculateRvasAndFileOffsets(List<IChunk> chunks, FileOffset offset, RVA rva, uint fileAlignment, uint sectionAlignment) {
			foreach (var chunk in chunks) {
				chunk.SetOffset(offset, rva);
				// If it has zero size, it's not present in the file (eg. a section that wasn't needed)
				if (chunk.GetVirtualSize() != 0) {
					offset += chunk.GetFileLength();
					rva += chunk.GetVirtualSize();
					offset = offset.AlignUp(fileAlignment);
					rva = rva.AlignUp(sectionAlignment);
				}
			}
		}

		/// <summary>
		/// Writes all chunks to <paramref name="writer"/>
		/// </summary>
		/// <param name="writer">The writer</param>
		/// <param name="chunks">All chunks</param>
		/// <param name="offset">File offset of first chunk</param>
		/// <param name="fileAlignment">File alignment</param>
		protected void WriteChunks(BinaryWriter writer, List<IChunk> chunks, FileOffset offset, uint fileAlignment) {
			foreach (var chunk in chunks) {
				chunk.VerifyWriteTo(writer);
				// If it has zero size, it's not present in the file (eg. a section that wasn't needed)
				if (chunk.GetVirtualSize() != 0) {
					offset += chunk.GetFileLength();
					var newOffset = offset.AlignUp(fileAlignment);
					writer.WriteZeros((int)(newOffset - offset));
					offset = newOffset;
				}
			}
		}

		/// <summary>
		/// Strong name sign the assembly
		/// </summary>
		/// <param name="snSigOffset">Strong name signature offset</param>
		protected void StrongNameSign(long snSigOffset) {
			var snSigner = new StrongNameSigner(destStream, destStreamBaseOffset);
			snSigner.WriteSignature(TheOptions.StrongNameKey, snSigOffset);
		}

		bool CanWritePdb() {
			return pdbState != null;
		}

		/// <summary>
		/// Creates the debug directory if a PDB file should be written
		/// </summary>
		protected void CreateDebugDirectory() {
			if (CanWritePdb())
				debugDirectory = new DebugDirectory();
		}

		/// <summary>
		/// Write the PDB file. The caller should send the PDB events before and after calling this
		/// method.
		/// </summary>
		protected void WritePdbFile() {
			if (!CanWritePdb())
				return;
			if (debugDirectory == null)
				throw new InvalidOperationException("debugDirectory is null but WritePdb is true");

			if (pdbState == null) {
				Error("TheOptions.WritePdb is true but module has no PdbState");
				return;
			}

			try {
				switch (pdbState.PdbFileKind) {
				case PdbFileKind.WindowsPDB:
					WriteWindowsPdb(pdbState);
					break;

				case PdbFileKind.PortablePDB:
					WritePortablePdb(pdbState, false);
					break;

				case PdbFileKind.EmbeddedPortablePDB:
					WritePortablePdb(pdbState, true);
					break;

				default:
					Error("Invalid PDB file kind {0}", pdbState.PdbFileKind);
					break;
				}
			}
			catch {
				DeleteFileNoThrow(createdPdbFileName);
				throw;
			}
		}

		void WriteWindowsPdb(PdbState pdbState) {
			var symWriter = GetWindowsPdbSymbolWriter();
			if (symWriter == null) {
				Error("Could not create a PDB symbol writer. A Windows OS might be required.");
				return;
			}

			using (var pdbWriter = new WindowsPdbWriter(symWriter, pdbState, metaData)) {
				pdbWriter.Logger = TheOptions.Logger;
				pdbWriter.Write();

				IMAGE_DEBUG_DIRECTORY idd;
				var data = pdbWriter.GetDebugInfo(out idd);
				var entry = debugDirectory.Add(data);
				entry.DebugDirectory = idd;
				entry.DebugDirectory.TimeDateStamp = GetTimeDateStamp();
			}
		}

		/// <summary>
		/// Gets the timestamp stored in the PE header
		/// </summary>
		/// <returns></returns>
		protected uint GetTimeDateStamp() {
			var td = TheOptions.PEHeadersOptions.TimeDateStamp;
			if (td.HasValue)
				return (uint)td;
			TheOptions.PEHeadersOptions.TimeDateStamp = PEHeadersOptions.CreateNewTimeDateStamp();
			return (uint)TheOptions.PEHeadersOptions.TimeDateStamp;
		}

		ISymbolWriter2 GetWindowsPdbSymbolWriter() {
			if (TheOptions.PdbStream != null) {
				return SymbolWriterCreator.Create(TheOptions.PdbStream,
							TheOptions.PdbFileName ??
							GetStreamName(TheOptions.PdbStream) ??
							GetDefaultPdbFileName());
			}

			if (!string.IsNullOrEmpty(TheOptions.PdbFileName)) {
				createdPdbFileName = TheOptions.PdbFileName;
				return SymbolWriterCreator.Create(createdPdbFileName);
			}

			createdPdbFileName = GetDefaultPdbFileName();
			if (createdPdbFileName == null)
				return null;
			return SymbolWriterCreator.Create(createdPdbFileName);
		}

		static string GetStreamName(Stream stream) {
			var fs = stream as FileStream;
			return fs == null ? null : fs.Name;
		}

		static string GetModuleName(ModuleDef module) {
			var name = module.Name ?? string.Empty;
			if (string.IsNullOrEmpty(name))
				return null;
			if (name.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) || name.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) || name.EndsWith(".netmodule", StringComparison.OrdinalIgnoreCase))
				return name;
			return name + ".pdb";
		}

		string GetDefaultPdbFileName() {
			var destFileName = GetStreamName(destStream) ?? GetModuleName(Module);
			if (string.IsNullOrEmpty(destFileName)) {
				Error("TheOptions.WritePdb is true but it's not possible to guess the default PDB file name. Set PdbFileName to the name of the PDB file.");
				return null;
			}

			return Path.ChangeExtension(destFileName, "pdb");
		}

		void WritePortablePdb(PdbState pdbState, bool isEmbeddedPortablePdb) {
			bool ownsStream = false;
			Stream pdbStream = null;
			try {
				MemoryStream embeddedMemoryStream = null;
				if (isEmbeddedPortablePdb) {
					pdbStream = embeddedMemoryStream = new MemoryStream();
					ownsStream = true;
				}
				else
					pdbStream = GetStandalonePortablePdbStream(out ownsStream);

				var pdbFilename = TheOptions.PdbFileName ?? GetStreamName(pdbStream) ?? GetDefaultPdbFileName();
				if (isEmbeddedPortablePdb)
					pdbFilename = Path.GetFileName(pdbFilename);

				uint entryPointToken;
				if (pdbState.UserEntryPoint == null)
					entryPointToken = 0;
				else
					entryPointToken = new MDToken(Table.Method, metaData.GetRid(pdbState.UserEntryPoint)).Raw;

				var pdbId = new byte[20];
				var pdbIdWriter = new BinaryWriter(new MemoryStream(pdbId));
				var pdbGuid = TheOptions.PdbGuid;
				pdbIdWriter.Write(pdbGuid.ToByteArray());
				pdbIdWriter.Write(GetTimeDateStamp());
				Debug.Assert(pdbIdWriter.BaseStream.Position == pdbId.Length);

				metaData.WritePortablePdb(pdbStream, entryPointToken, pdbId);

				const uint age = 1;
				var cvEntry = debugDirectory.Add(GetCodeViewData(pdbGuid, age, pdbFilename));
				cvEntry.DebugDirectory.TimeDateStamp = GetTimeDateStamp();
				cvEntry.DebugDirectory.MajorVersion = PortablePdbConstants.FormatVersion;
				cvEntry.DebugDirectory.MinorVersion = PortablePdbConstants.PortableCodeViewVersionMagic;
				cvEntry.DebugDirectory.Type = ImageDebugType.CodeView;

				if (isEmbeddedPortablePdb) {
					Debug.Assert(embeddedMemoryStream != null);
					var embedEntry = debugDirectory.Add(CreateEmbeddedPortablePdbBlob(embeddedMemoryStream));
					embedEntry.DebugDirectory.TimeDateStamp = 0;
					embedEntry.DebugDirectory.MajorVersion = PortablePdbConstants.FormatVersion;
					embedEntry.DebugDirectory.MinorVersion = PortablePdbConstants.EmbeddedVersion;
					embedEntry.DebugDirectory.Type = ImageDebugType.EmbeddedPortablePdb;
				}
			}
			finally {
				if (ownsStream && pdbStream != null)
					pdbStream.Dispose();
			}
		}

		static byte[] CreateEmbeddedPortablePdbBlob(MemoryStream portablePdbStream) {
			var compressedData = Compress(portablePdbStream);
			var data = new byte[4 + 4 + compressedData.Length];
			var stream = new MemoryStream(data);
			var writer = new BinaryWriter(stream);
			writer.Write(0x4244504D);//"MPDB"
			writer.Write((uint)portablePdbStream.Length);
			writer.Write(compressedData);
			Debug.Assert(stream.Position == data.Length);
			return data;
		}

		static byte[] Compress(MemoryStream sourceStream) {
			sourceStream.Position = 0;
			var destStream = new MemoryStream();
			using (var deflate = new DeflateStream(destStream, CompressionMode.Compress)) {
				var source = sourceStream.ToArray();
				deflate.Write(source, 0, source.Length);
			}
			return destStream.ToArray();
		}

		static byte[] GetCodeViewData(Guid guid, uint age, string filename) {
			var stream = new MemoryStream();
			var writer = new BinaryWriter(stream);
			writer.Write(0x53445352);
			writer.Write(guid.ToByteArray());
			writer.Write(age);
			writer.Write(Encoding.UTF8.GetBytes(filename));
			writer.Write((byte)0);
			return stream.ToArray();
		}

		Stream GetStandalonePortablePdbStream(out bool ownsStream) {
			if (TheOptions.PdbStream != null) {
				ownsStream = false;
				return TheOptions.PdbStream;
			}

			if (!string.IsNullOrEmpty(TheOptions.PdbFileName))
				createdPdbFileName = TheOptions.PdbFileName;
			else
				createdPdbFileName = GetDefaultPdbFileName();
			if (createdPdbFileName == null) {
				ownsStream = false;
				return null;
			}
			ownsStream = true;
			return File.Create(createdPdbFileName);
		}

		/// <inheritdoc/>
		void IMetaDataListener.OnMetaDataEvent(MetaData metaData, MetaDataEvent evt) {
			switch (evt) {
			case MetaDataEvent.BeginCreateTables:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDBeginCreateTables);
				break;

			case MetaDataEvent.AllocateTypeDefRids:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDAllocateTypeDefRids);
				break;

			case MetaDataEvent.AllocateMemberDefRids:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDAllocateMemberDefRids);
				break;

			case MetaDataEvent.AllocateMemberDefRids0:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDAllocateMemberDefRids0);
				break;

			case MetaDataEvent.AllocateMemberDefRids1:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDAllocateMemberDefRids1);
				break;

			case MetaDataEvent.AllocateMemberDefRids2:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDAllocateMemberDefRids2);
				break;

			case MetaDataEvent.AllocateMemberDefRids3:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDAllocateMemberDefRids3);
				break;

			case MetaDataEvent.AllocateMemberDefRids4:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDAllocateMemberDefRids4);
				break;

			case MetaDataEvent.MemberDefRidsAllocated:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDMemberDefRidsAllocated);
				break;

			case MetaDataEvent.InitializeTypeDefsAndMemberDefs0:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDInitializeTypeDefsAndMemberDefs0);
				break;

			case MetaDataEvent.InitializeTypeDefsAndMemberDefs1:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDInitializeTypeDefsAndMemberDefs1);
				break;

			case MetaDataEvent.InitializeTypeDefsAndMemberDefs2:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDInitializeTypeDefsAndMemberDefs2);
				break;

			case MetaDataEvent.InitializeTypeDefsAndMemberDefs3:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDInitializeTypeDefsAndMemberDefs3);
				break;

			case MetaDataEvent.InitializeTypeDefsAndMemberDefs4:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDInitializeTypeDefsAndMemberDefs4);
				break;

			case MetaDataEvent.MemberDefsInitialized:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDMemberDefsInitialized);
				break;

			case MetaDataEvent.BeforeSortTables:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDBeforeSortTables);
				break;

			case MetaDataEvent.MostTablesSorted:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDMostTablesSorted);
				break;

			case MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes0:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteTypeDefAndMemberDefCustomAttributes0);
				break;

			case MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes1:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteTypeDefAndMemberDefCustomAttributes1);
				break;

			case MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes2:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteTypeDefAndMemberDefCustomAttributes2);
				break;

			case MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes3:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteTypeDefAndMemberDefCustomAttributes3);
				break;

			case MetaDataEvent.WriteTypeDefAndMemberDefCustomAttributes4:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteTypeDefAndMemberDefCustomAttributes4);
				break;

			case MetaDataEvent.MemberDefCustomAttributesWritten:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDMemberDefCustomAttributesWritten);
				break;

			case MetaDataEvent.BeginAddResources:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDBeginAddResources);
				break;

			case MetaDataEvent.EndAddResources:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDEndAddResources);
				break;

			case MetaDataEvent.BeginWriteMethodBodies:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDBeginWriteMethodBodies);
				break;

			case MetaDataEvent.WriteMethodBodies0:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies0);
				break;

			case MetaDataEvent.WriteMethodBodies1:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies1);
				break;

			case MetaDataEvent.WriteMethodBodies2:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies2);
				break;

			case MetaDataEvent.WriteMethodBodies3:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies3);
				break;

			case MetaDataEvent.WriteMethodBodies4:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies4);
				break;

			case MetaDataEvent.WriteMethodBodies5:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies5);
				break;

			case MetaDataEvent.WriteMethodBodies6:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies6);
				break;

			case MetaDataEvent.WriteMethodBodies7:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies7);
				break;

			case MetaDataEvent.WriteMethodBodies8:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies8);
				break;

			case MetaDataEvent.WriteMethodBodies9:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDWriteMethodBodies9);
				break;

			case MetaDataEvent.EndWriteMethodBodies:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDEndWriteMethodBodies);
				break;

			case MetaDataEvent.OnAllTablesSorted:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDOnAllTablesSorted);
				break;

			case MetaDataEvent.EndCreateTables:
				Listener.OnWriterEvent(this, ModuleWriterEvent.MDEndCreateTables);
				break;

			default:
				break;
			}
		}

		ILogger GetLogger() {
			return TheOptions.Logger ?? DummyLogger.ThrowModuleWriterExceptionOnErrorInstance;
		}

		/// <inheritdoc/>
		void ILogger.Log(object sender, LoggerEvent loggerEvent, string format, params object[] args) {
			GetLogger().Log(this, loggerEvent, format, args);
		}

		/// <inheritdoc/>
		bool ILogger.IgnoresEvent(LoggerEvent loggerEvent) {
			return GetLogger().IgnoresEvent(loggerEvent);
		}

		/// <summary>
		/// Logs an error message
		/// </summary>
		/// <param name="format">Format</param>
		/// <param name="args">Format args</param>
		protected void Error(string format, params object[] args) {
			GetLogger().Log(this, LoggerEvent.Error, format, args);
		}

		/// <summary>
		/// Logs a warning message
		/// </summary>
		/// <param name="format">Format</param>
		/// <param name="args">Format args</param>
		protected void Warning(string format, params object[] args) {
			GetLogger().Log(this, LoggerEvent.Warning, format, args);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/ModuleWriterException.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Runtime.Serialization;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Thrown when the module writer encounters an unrecoverable error
	/// </summary>
	[Serializable]
	public class ModuleWriterException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleWriterException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		public ModuleWriterException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="innerException">Other exception</param>
		public ModuleWriterException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected ModuleWriterException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/NativeModuleWriter.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.PE;
using dnlib.W32Resources;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="NativeModuleWriter"/> options
	/// </summary>
	public sealed class NativeModuleWriterOptions : ModuleWriterOptionsBase {
		/// <summary>
		/// If <c>true</c>, any extra data after the PE data in the original file is also saved
		/// at the end of the new file. Enable this option if some protector has written data to
		/// the end of the file and uses it at runtime.
		/// </summary>
		public bool KeepExtraPEData { get; set; }

		/// <summary>
		/// If <c>true</c>, keep the original Win32 resources
		/// </summary>
		public bool KeepWin32Resources { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module</param>
		public NativeModuleWriterOptions(ModuleDefMD module)
			: this(module, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="listener">Module writer listener</param>
		public NativeModuleWriterOptions(ModuleDefMD module, IModuleWriterListener listener)
			: base(module, listener) {

			// C++ .NET mixed mode assemblies sometimes/often call Module.ResolveMethod(),
			// so method metadata tokens must be preserved.
			MetaDataOptions.Flags |= MetaDataFlags.PreserveAllMethodRids;
		}
	}

	/// <summary>
	/// A module writer that supports saving mixed-mode modules (modules with native code).
	/// The original image will be re-used. See also <see cref="ModuleWriter"/>
	/// </summary>
	public sealed class NativeModuleWriter : ModuleWriterBase {
		/// <summary>The original .NET module</summary>
		readonly ModuleDefMD module;

		/// <summary>All options</summary>
		NativeModuleWriterOptions options;

		/// <summary>
		/// Any extra data found at the end of the original file. This is <c>null</c> if there's
		/// no extra data or if <see cref="NativeModuleWriterOptions.KeepExtraPEData"/> is
		/// <c>false</c>.
		/// </summary>
		BinaryReaderChunk extraData;

		/// <summary>The original PE headers</summary>
		BinaryReaderChunk headerSection;

		/// <summary>The original PE sections and their data</summary>
		List<OrigSection> origSections;

		/// <summary>Original PE image</summary>
		readonly IPEImage peImage;

		/// <summary>New sections we've added and their data</summary>
		List<PESection> sections;

		/// <summary>New .text section where we put some stuff, eg. .NET metadata</summary>
		PESection textSection;

		/// <summary>The new COR20 header</summary>
		ByteArrayChunk imageCor20Header;

		/// <summary>
		/// New .rsrc section where we put the new Win32 resources. This is <c>null</c> if there
		/// are no Win32 resources or if <see cref="NativeModuleWriterOptions.KeepWin32Resources"/>
		/// is <c>true</c>
		/// </summary>
		PESection rsrcSection;

		/// <summary>
		/// Offset in <see cref="ModuleWriterBase.destStream"/> of the PE checksum field.
		/// </summary>
		long checkSumOffset;

		/// <summary>
		/// Original PE section
		/// </summary>
		public sealed class OrigSection : IDisposable {
			/// <summary>PE section</summary>
			public ImageSectionHeader PESection;
			/// <summary>PE section data</summary>
			public BinaryReaderChunk Chunk;

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="peSection">PE section</param>
			public OrigSection(ImageSectionHeader peSection) {
				this.PESection = peSection;
			}

			/// <inheritdoc/>
			public void Dispose() {
				if (Chunk != null)
					Chunk.Data.Dispose();
				Chunk = null;
				PESection = null;
			}

			/// <inheritdoc/>
			public override string ToString() {
				uint offs = Chunk.Data is IImageStream ? (uint)((IImageStream)Chunk.Data).FileOffset : 0;
				return string.Format("{0} FO:{1:X8} L:{2:X8}", PESection.DisplayName, offs, (uint)Chunk.Data.Length);
			}
		}

		/// <summary>
		/// Gets the module
		/// </summary>
		public ModuleDefMD ModuleDefMD {
			get { return module; }
		}

		/// <inheritdoc/>
		public override ModuleDef Module {
			get { return module; }
		}

		/// <inheritdoc/>
		public override ModuleWriterOptionsBase TheOptions {
			get { return Options; }
		}

		/// <summary>
		/// Gets/sets the writer options. This is never <c>null</c>
		/// </summary>
		public NativeModuleWriterOptions Options {
			get { return options ?? (options = new NativeModuleWriterOptions(module)); }
			set { options = value; }
		}

		/// <summary>
		/// Gets all <see cref="PESection"/>s
		/// </summary>
		public override List<PESection> Sections {
			get { return sections; }
		}

		/// <summary>
		/// Gets the original PE sections and their data
		/// </summary>
		public List<OrigSection> OrigSections {
			get { return origSections; }
		}

		/// <summary>
		/// Gets the <c>.text</c> section
		/// </summary>
		public override PESection TextSection {
			get { return textSection; }
		}

		/// <summary>
		/// Gets the <c>.rsrc</c> section or <c>null</c> if there's none
		/// </summary>
		public override PESection RsrcSection {
			get { return rsrcSection; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		/// <param name="options">Options or <c>null</c></param>
		public NativeModuleWriter(ModuleDefMD module, NativeModuleWriterOptions options) {
			this.module = module;
			this.options = options;
			this.peImage = module.MetaData.PEImage;
		}

		/// <inheritdoc/>
		protected override long WriteImpl() {
			try {
				return Write();
			}
			finally {
				if (origSections != null) {
					foreach (var section in origSections)
						section.Dispose();
				}
				if (headerSection != null)
					headerSection.Data.Dispose();
				if (extraData != null)
					extraData.Data.Dispose();
			}
		}

		long Write() {
			Initialize();

			// It's not safe to create new Field RVAs so re-use them all. The user can override
			// this by setting field.RVA = 0 when creating a new field.InitialValue.
			metaData.KeepFieldRVA = true;

			metaData.CreateTables();
			return WriteFile();
		}

		void Initialize() {
			CreateSections();
			Listener.OnWriterEvent(this, ModuleWriterEvent.PESectionsCreated);

			CreateChunks();
			Listener.OnWriterEvent(this, ModuleWriterEvent.ChunksCreated);

			AddChunksToSections();
			Listener.OnWriterEvent(this, ModuleWriterEvent.ChunksAddedToSections);
		}

		void CreateSections() {
			CreatePESections();
			CreateRawSections();
			CreateHeaderSection();
			CreateExtraData();
		}

		void CreateChunks() {
			CreateMetaDataChunks(module);

			CreateDebugDirectory();

			imageCor20Header = new ByteArrayChunk(new byte[0x48]);
			CreateStrongNameSignature();
		}

		void AddChunksToSections() {
			textSection.Add(imageCor20Header, DEFAULT_COR20HEADER_ALIGNMENT);
			textSection.Add(strongNameSignature, DEFAULT_STRONGNAMESIG_ALIGNMENT);
			textSection.Add(constants, DEFAULT_CONSTANTS_ALIGNMENT);
			textSection.Add(methodBodies, DEFAULT_METHODBODIES_ALIGNMENT);
			textSection.Add(netResources, DEFAULT_NETRESOURCES_ALIGNMENT);
			textSection.Add(metaData, DEFAULT_METADATA_ALIGNMENT);
			textSection.Add(debugDirectory, DebugDirectory.DEFAULT_DEBUGDIRECTORY_ALIGNMENT);
			if (rsrcSection != null)
				rsrcSection.Add(win32Resources, DEFAULT_WIN32_RESOURCES_ALIGNMENT);
		}

		/// <inheritdoc/>
		protected override Win32Resources GetWin32Resources() {
			if (Options.KeepWin32Resources)
				return null;
			return Options.Win32Resources ?? module.Win32Resources;
		}

		void CreatePESections() {
			sections = new List<PESection>();
			sections.Add(textSection = new PESection(".text", 0x60000020));
			if (GetWin32Resources() != null)
				sections.Add(rsrcSection = new PESection(".rsrc", 0x40000040));
		}

		/// <summary>
		/// Gets the raw section data of the image. The sections are saved in
		/// <see cref="origSections"/>.
		/// </summary>
		void CreateRawSections() {
			var fileAlignment = peImage.ImageNTHeaders.OptionalHeader.FileAlignment;
			origSections = new List<OrigSection>(peImage.ImageSectionHeaders.Count);

			foreach (var peSection in peImage.ImageSectionHeaders) {
				var newSection = new OrigSection(peSection);
				origSections.Add(newSection);
				uint sectionSize = Utils.AlignUp(peSection.SizeOfRawData, fileAlignment);
				newSection.Chunk = new BinaryReaderChunk(peImage.CreateStream(peSection.VirtualAddress, sectionSize), peSection.VirtualSize);
			}
		}

		/// <summary>
		/// Creates the PE header "section"
		/// </summary>
		void CreateHeaderSection() {
			uint afterLastSectHeader = GetOffsetAfterLastSectionHeader() + (uint)sections.Count * 0x28;
			uint firstRawOffset = Math.Min(GetFirstRawDataFileOffset(), peImage.ImageNTHeaders.OptionalHeader.SectionAlignment);
			uint headerLen = afterLastSectHeader;
			if (firstRawOffset > headerLen)
				headerLen = firstRawOffset;
			headerLen = Utils.AlignUp(headerLen, peImage.ImageNTHeaders.OptionalHeader.FileAlignment);
			if (headerLen <= peImage.ImageNTHeaders.OptionalHeader.SectionAlignment) {
				headerSection = new BinaryReaderChunk(peImage.CreateStream(0, headerLen));
				return;
			}

			//TODO: Support this too
			throw new ModuleWriterException("Could not create header");
		}

		uint GetOffsetAfterLastSectionHeader() {
			var lastSect = peImage.ImageSectionHeaders[peImage.ImageSectionHeaders.Count - 1];
			return (uint)lastSect.EndOffset;
		}

		uint GetFirstRawDataFileOffset() {
			uint len = uint.MaxValue;
			foreach (var section in peImage.ImageSectionHeaders)
				len = Math.Min(len, section.PointerToRawData);
			return len;
		}

		/// <summary>
		/// Saves any data that is appended to the original PE file
		/// </summary>
		void CreateExtraData() {
			if (!Options.KeepExtraPEData)
				return;
			var lastOffs = GetLastFileSectionOffset();
			extraData = new BinaryReaderChunk(peImage.CreateStream((FileOffset)lastOffs));
			if (extraData.Data.Length == 0) {
				extraData.Data.Dispose();
				extraData = null;
			}
		}

		uint GetLastFileSectionOffset() {
			uint rva = 0;
			foreach (var sect in origSections)
				rva = Math.Max(rva, (uint)sect.PESection.VirtualAddress + sect.PESection.SizeOfRawData);
			return (uint)peImage.ToFileOffset((RVA)(rva - 1)) + 1;
		}

		long WriteFile() {
			uint entryPointToken;
			bool entryPointIsManagedOrNoEntryPoint = GetEntryPoint(out entryPointToken);

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginWritePdb);
			WritePdbFile();
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndWritePdb);

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginCalculateRvasAndFileOffsets);

			var chunks = new List<IChunk>();
			chunks.Add(headerSection);
			foreach (var origSection in origSections)
				chunks.Add(origSection.Chunk);
			foreach (var section in sections)
				chunks.Add(section);
			if (extraData != null)
				chunks.Add(extraData);

			CalculateRvasAndFileOffsets(chunks, 0, 0, peImage.ImageNTHeaders.OptionalHeader.FileAlignment, peImage.ImageNTHeaders.OptionalHeader.SectionAlignment);
			foreach (var section in origSections) {
				if (section.Chunk.RVA != section.PESection.VirtualAddress)
					throw new ModuleWriterException("Invalid section RVA");
			}
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndCalculateRvasAndFileOffsets);

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginWriteChunks);
			var writer = new BinaryWriter(destStream);
			WriteChunks(writer, chunks, 0, peImage.ImageNTHeaders.OptionalHeader.FileAlignment);
			long imageLength = writer.BaseStream.Position - destStreamBaseOffset;
			UpdateHeaderFields(writer, entryPointIsManagedOrNoEntryPoint, entryPointToken);
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndWriteChunks);

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginStrongNameSign);
			if (Options.StrongNameKey != null)
				StrongNameSign((long)strongNameSignature.FileOffset);
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndStrongNameSign);

			Listener.OnWriterEvent(this, ModuleWriterEvent.BeginWritePEChecksum);
			if (Options.AddCheckSum) {
				destStream.Position = destStreamBaseOffset;
				uint newCheckSum = new BinaryReader(destStream).CalculatePECheckSum(imageLength, checkSumOffset);
				writer.BaseStream.Position = checkSumOffset;
				writer.Write(newCheckSum);
			}
			Listener.OnWriterEvent(this, ModuleWriterEvent.EndWritePEChecksum);

			return imageLength;
		}

		/// <summary>
		/// <c>true</c> if image is 64-bit
		/// </summary>
		bool Is64Bit() {
			return peImage.ImageNTHeaders.OptionalHeader is ImageOptionalHeader64;
		}

		Characteristics GetCharacteristics() {
			var ch = module.Characteristics;
			if (Is64Bit())
				ch &= ~Characteristics._32BitMachine;
			else
				ch |= Characteristics._32BitMachine;
			if (Options.IsExeFile)
				ch &= ~Characteristics.Dll;
			else
				ch |= Characteristics.Dll;
			return ch;
		}

		/// <summary>
		/// Updates the PE header and COR20 header fields that need updating. All sections are
		/// also updated, and the new ones are added.
		/// </summary>
		void UpdateHeaderFields(BinaryWriter writer, bool entryPointIsManagedOrNoEntryPoint, uint entryPointToken) {
			long fileHeaderOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.FileHeader.StartOffset;
			long optionalHeaderOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.OptionalHeader.StartOffset;
			long sectionsOffset = destStreamBaseOffset + (long)peImage.ImageSectionHeaders[0].StartOffset;
			long dataDirOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.OptionalHeader.EndOffset - 16 * 8;
			long cor20Offset = destStreamBaseOffset + (long)imageCor20Header.FileOffset;

			uint fileAlignment = peImage.ImageNTHeaders.OptionalHeader.FileAlignment;
			uint sectionAlignment = peImage.ImageNTHeaders.OptionalHeader.SectionAlignment;

			// Update PE file header
			var peOptions = Options.PEHeadersOptions;
			writer.BaseStream.Position = fileHeaderOffset;
			writer.Write((ushort)(peOptions.Machine ?? module.Machine));
			writer.Write((ushort)(origSections.Count + sections.Count));
			WriteUInt32(writer, peOptions.TimeDateStamp);
			WriteUInt32(writer, peOptions.PointerToSymbolTable);
			WriteUInt32(writer, peOptions.NumberOfSymbols);
			writer.BaseStream.Position += 2;    // sizeof(SizeOfOptionalHeader)
			writer.Write((ushort)(peOptions.Characteristics ?? GetCharacteristics()));

			// Update optional header
			var sectionSizes = new SectionSizes(fileAlignment, sectionAlignment, headerSection.GetVirtualSize(), GetSectionSizeInfos);
			writer.BaseStream.Position = optionalHeaderOffset;
			bool is32BitOptionalHeader = peImage.ImageNTHeaders.OptionalHeader is ImageOptionalHeader32;
			if (is32BitOptionalHeader) {
				writer.BaseStream.Position += 2;
				WriteByte(writer, peOptions.MajorLinkerVersion);
				WriteByte(writer, peOptions.MinorLinkerVersion);
				writer.Write(sectionSizes.SizeOfCode);
				writer.Write(sectionSizes.SizeOfInitdData);
				writer.Write(sectionSizes.SizeOfUninitdData);
				writer.BaseStream.Position += 4;	// EntryPoint
				writer.Write(sectionSizes.BaseOfCode);
				writer.Write(sectionSizes.BaseOfData);
				WriteUInt32(writer, peOptions.ImageBase);
				writer.BaseStream.Position += 8;	// SectionAlignment, FileAlignment
				WriteUInt16(writer, peOptions.MajorOperatingSystemVersion);
				WriteUInt16(writer, peOptions.MinorOperatingSystemVersion);
				WriteUInt16(writer, peOptions.MajorImageVersion);
				WriteUInt16(writer, peOptions.MinorImageVersion);
				WriteUInt16(writer, peOptions.MajorSubsystemVersion);
				WriteUInt16(writer, peOptions.MinorSubsystemVersion);
				WriteUInt32(writer, peOptions.Win32VersionValue);
				writer.Write(sectionSizes.SizeOfImage);
				writer.Write(sectionSizes.SizeOfHeaders);
				checkSumOffset = writer.BaseStream.Position;
				writer.Write(0);	// CheckSum
				WriteUInt16(writer, peOptions.Subsystem);
				WriteUInt16(writer, peOptions.DllCharacteristics);
				WriteUInt32(writer, peOptions.SizeOfStackReserve);
				WriteUInt32(writer, peOptions.SizeOfStackCommit);
				WriteUInt32(writer, peOptions.SizeOfHeapReserve);
				WriteUInt32(writer, peOptions.SizeOfHeapCommit);
				WriteUInt32(writer, peOptions.LoaderFlags);
				WriteUInt32(writer, peOptions.NumberOfRvaAndSizes);
			}
			else {
				writer.BaseStream.Position += 2;
				WriteByte(writer, peOptions.MajorLinkerVersion);
				WriteByte(writer, peOptions.MinorLinkerVersion);
				writer.Write(sectionSizes.SizeOfCode);
				writer.Write(sectionSizes.SizeOfInitdData);
				writer.Write(sectionSizes.SizeOfUninitdData);
				writer.BaseStream.Position += 4;	// EntryPoint
				writer.Write(sectionSizes.BaseOfCode);
				WriteUInt64(writer, peOptions.ImageBase);
				writer.BaseStream.Position += 8;	// SectionAlignment, FileAlignment
				WriteUInt16(writer, peOptions.MajorOperatingSystemVersion);
				WriteUInt16(writer, peOptions.MinorOperatingSystemVersion);
				WriteUInt16(writer, peOptions.MajorImageVersion);
				WriteUInt16(writer, peOptions.MinorImageVersion);
				WriteUInt16(writer, peOptions.MajorSubsystemVersion);
				WriteUInt16(writer, peOptions.MinorSubsystemVersion);
				WriteUInt32(writer, peOptions.Win32VersionValue);
				writer.Write(sectionSizes.SizeOfImage);
				writer.Write(sectionSizes.SizeOfHeaders);
				checkSumOffset = writer.BaseStream.Position;
				writer.Write(0);	// CheckSum
				WriteUInt16(writer, peOptions.Subsystem ?? GetSubsystem());
				WriteUInt16(writer, peOptions.DllCharacteristics ?? module.DllCharacteristics);
				WriteUInt64(writer, peOptions.SizeOfStackReserve);
				WriteUInt64(writer, peOptions.SizeOfStackCommit);
				WriteUInt64(writer, peOptions.SizeOfHeapReserve);
				WriteUInt64(writer, peOptions.SizeOfHeapCommit);
				WriteUInt32(writer, peOptions.LoaderFlags);
				WriteUInt32(writer, peOptions.NumberOfRvaAndSizes);
			}

			// Update Win32 resources data directory, if we wrote a new one
			if (win32Resources != null) {
				writer.BaseStream.Position = dataDirOffset + 2 * 8;
				writer.WriteDataDirectory(win32Resources);
			}

			// Clear the security descriptor directory
			writer.BaseStream.Position = dataDirOffset + 4 * 8;
			writer.WriteDataDirectory(null);

			// Write a new debug directory
			writer.BaseStream.Position = dataDirOffset + 6 * 8;
			writer.WriteDataDirectory(debugDirectory);

			// Write a new Metadata data directory
			writer.BaseStream.Position = dataDirOffset + 14 * 8;
			writer.WriteDataDirectory(imageCor20Header);

			// Update old sections, and add new sections
			writer.BaseStream.Position = sectionsOffset;
			foreach (var section in origSections) {
				writer.BaseStream.Position += 0x14;
				writer.Write((uint)section.Chunk.FileOffset);	// PointerToRawData
				writer.BaseStream.Position += 0x10;
			}
			foreach (var section in sections)
				section.WriteHeaderTo(writer, fileAlignment, sectionAlignment, (uint)section.RVA);

			// Write the .NET header
			writer.BaseStream.Position = cor20Offset;
			writer.Write(0x48);		// cb
			WriteUInt16(writer, Options.Cor20HeaderOptions.MajorRuntimeVersion);
			WriteUInt16(writer, Options.Cor20HeaderOptions.MinorRuntimeVersion);
			writer.WriteDataDirectory(metaData);
			writer.Write((uint)GetComImageFlags(entryPointIsManagedOrNoEntryPoint));
			writer.Write(entryPointToken);
			writer.WriteDataDirectory(netResources);
			writer.WriteDataDirectory(strongNameSignature);
			WriteDataDirectory(writer, module.MetaData.ImageCor20Header.CodeManagerTable);
			WriteDataDirectory(writer, module.MetaData.ImageCor20Header.VTableFixups);
			WriteDataDirectory(writer, module.MetaData.ImageCor20Header.ExportAddressTableJumps);
			WriteDataDirectory(writer, module.MetaData.ImageCor20Header.ManagedNativeHeader);

			UpdateVTableFixups(writer);
		}

		static void WriteDataDirectory(BinaryWriter writer, ImageDataDirectory dataDir) {
			writer.Write((uint)dataDir.VirtualAddress);
			writer.Write(dataDir.Size);
		}

		static void WriteByte(BinaryWriter writer, byte? value) {
			if (value == null)
				writer.BaseStream.Position++;
			else
				writer.Write(value.Value);
		}

		static void WriteUInt16(BinaryWriter writer, ushort? value) {
			if (value == null)
				writer.BaseStream.Position += 2;
			else
				writer.Write(value.Value);
		}

		static void WriteUInt16(BinaryWriter writer, Subsystem? value) {
			if (value == null)
				writer.BaseStream.Position += 2;
			else
				writer.Write((ushort)value.Value);
		}

		static void WriteUInt16(BinaryWriter writer, DllCharacteristics? value) {
			if (value == null)
				writer.BaseStream.Position += 2;
			else
				writer.Write((ushort)value.Value);
		}

		static void WriteUInt32(BinaryWriter writer, uint? value) {
			if (value == null)
				writer.BaseStream.Position += 4;
			else
				writer.Write(value.Value);
		}

		static void WriteUInt32(BinaryWriter writer, ulong? value) {
			if (value == null)
				writer.BaseStream.Position += 4;
			else
				writer.Write((uint)value.Value);
		}

		static void WriteUInt64(BinaryWriter writer, ulong? value) {
			if (value == null)
				writer.BaseStream.Position += 8;
			else
				writer.Write(value.Value);
		}

		ComImageFlags GetComImageFlags(bool isManagedEntryPoint) {
			var flags = Options.Cor20HeaderOptions.Flags ?? module.Cor20HeaderFlags;
			if (Options.Cor20HeaderOptions.EntryPoint != null)
				return flags;
			if (isManagedEntryPoint)
				return flags & ~ComImageFlags.NativeEntryPoint;
			return flags | ComImageFlags.NativeEntryPoint;
		}

		Subsystem GetSubsystem() {
			if (module.Kind == ModuleKind.Windows)
				return Subsystem.WindowsGui;
			return Subsystem.WindowsCui;
		}

		/// <summary>
		/// Converts <paramref name="rva"/> to a file offset in the destination stream
		/// </summary>
		/// <param name="rva">RVA</param>
		long ToWriterOffset(RVA rva) {
			if (rva == 0)
				return 0;
			foreach (var sect in origSections) {
				var section = sect.PESection;
				if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max(section.VirtualSize, section.SizeOfRawData))
					return destStreamBaseOffset + (long)sect.Chunk.FileOffset + (rva - section.VirtualAddress);
			}
			return 0;
		}

		IEnumerable<SectionSizeInfo> GetSectionSizeInfos() {
			foreach (var section in origSections)
				yield return new SectionSizeInfo(section.Chunk.GetVirtualSize(), section.PESection.Characteristics);
			foreach (var section in sections)
				yield return new SectionSizeInfo(section.GetVirtualSize(), section.Characteristics);
		}

		void UpdateVTableFixups(BinaryWriter writer) {
			var vtableFixups = module.VTableFixups;
			if (vtableFixups == null || vtableFixups.VTables.Count == 0)
				return;

			writer.BaseStream.Position = ToWriterOffset(vtableFixups.RVA);
			if (writer.BaseStream.Position == 0) {
				Error("Could not convert RVA to file offset");
				return;
			}
			foreach (var vtable in vtableFixups) {
				if (vtable.Methods.Count > ushort.MaxValue)
					throw new ModuleWriterException("Too many methods in vtable");
				writer.Write((uint)vtable.RVA);
				writer.Write((ushort)vtable.Methods.Count);
				writer.Write((ushort)vtable.Flags);

				long pos = writer.BaseStream.Position;
				writer.BaseStream.Position = ToWriterOffset(vtable.RVA);
				if (writer.BaseStream.Position == 0) {
					if (vtable.RVA != 0 || vtable.Methods.Count > 0)
						Error("Could not convert RVA to file offset");
				}
				else {
					foreach (var method in vtable.Methods) {
						writer.Write(GetMethodToken(method));
						if (vtable.Is64Bit)
							writer.Write(0);
					}
				}
				writer.BaseStream.Position = pos;
			}
		}

		uint GetMethodToken(IMethod method) {
			var md = method as MethodDef;
			if (md != null)
				return new MDToken(Table.Method, metaData.GetRid(md)).Raw;

			var mr = method as MemberRef;
			if (mr != null)
				return new MDToken(Table.MemberRef, metaData.GetRid(mr)).Raw;

			var ms = method as MethodSpec;
			if (ms != null)
				return new MDToken(Table.MethodSpec, metaData.GetRid(ms)).Raw;

			if (method == null)
				return 0;

			Error("Invalid VTable method type: {0}", method.GetType());
			return 0;
		}

		/// <summary>
		/// Gets the entry point
		/// </summary>
		/// <param name="ep">Updated with entry point (either a token or RVA of native method)</param>
		/// <returns><c>true</c> if it's a managed entry point or there's no entry point,
		/// <c>false</c> if it's a native entry point</returns>
		bool GetEntryPoint(out uint ep) {
			var tok = Options.Cor20HeaderOptions.EntryPoint;
			if (tok != null) {
				ep = tok.Value;
				return ep == 0 || ((Options.Cor20HeaderOptions.Flags ?? 0) & ComImageFlags.NativeEntryPoint) == 0;
			}

			var epMethod = module.ManagedEntryPoint as MethodDef;
			if (epMethod != null) {
				ep = new MDToken(Table.Method, metaData.GetRid(epMethod)).Raw;
				return true;
			}
			var file = module.ManagedEntryPoint as FileDef;
			if (file != null) {
				ep = new MDToken(Table.File, metaData.GetRid(file)).Raw;
				return true;
			}
			ep = (uint)module.NativeEntryPoint;
			return ep == 0;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/NetResources.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// .NET resources
	/// </summary>
	public sealed class NetResources : IChunk {
		readonly List<ByteArrayChunk> resources = new List<ByteArrayChunk>();
		readonly uint alignment;
		uint length;
		bool setOffsetCalled;
		FileOffset offset;
		RVA rva;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets offset of next resource. This offset is relative to the start of
		/// the .NET resources and is always aligned.
		/// </summary>
		public uint NextOffset {
			get { return length; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alignment">Alignment of all resources</param>
		public NetResources(uint alignment) {
			this.alignment = alignment;
		}

		/// <summary>
		/// Adds a resource
		/// </summary>
		/// <param name="stream">The resource data</param>
		/// <returns>The resource data</returns>
		public ByteArrayChunk Add(IImageStream stream) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			var rawData = stream.ReadAllBytes();
			length = Utils.AlignUp(length + 4 + (uint)rawData.Length, alignment);
			var data = new ByteArrayChunk(rawData);
			resources.Add(data);
			return data;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			setOffsetCalled = true;
			this.offset = offset;
			this.rva = rva;
			foreach (var resource in resources) {
				resource.SetOffset(offset + 4, rva + 4);
				uint len = 4 + resource.GetFileLength();
				offset = (offset + len).AlignUp(alignment);
				rva = (rva + len).AlignUp(alignment);
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			RVA rva2 = rva;
			foreach (var resourceData in resources) {
				writer.Write(resourceData.GetFileLength());
				resourceData.VerifyWriteTo(writer);
				rva2 += 4 + resourceData.GetFileLength();
				int padding = (int)rva2.AlignUp(alignment) - (int)rva2;
				writer.WriteZeros(padding);
				rva2 += (uint)padding;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/NormalMetaData.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Does not preserve metadata tokens
	/// </summary>
	sealed class NormalMetaData : MetaData {
		readonly Rows<TypeRef> typeRefInfos = new Rows<TypeRef>();
		readonly Rows<TypeDef> typeDefInfos = new Rows<TypeDef>();
		readonly Rows<FieldDef> fieldDefInfos = new Rows<FieldDef>();
		readonly Rows<MethodDef> methodDefInfos = new Rows<MethodDef>();
		readonly Rows<ParamDef> paramDefInfos = new Rows<ParamDef>();
		readonly Rows<MemberRef> memberRefInfos = new Rows<MemberRef>();
		readonly Rows<StandAloneSig> standAloneSigInfos = new Rows<StandAloneSig>();
		readonly Rows<EventDef> eventDefInfos = new Rows<EventDef>();
		readonly Rows<PropertyDef> propertyDefInfos = new Rows<PropertyDef>();
		readonly Rows<TypeSpec> typeSpecInfos = new Rows<TypeSpec>();
		readonly Rows<MethodSpec> methodSpecInfos = new Rows<MethodSpec>();

		protected override int NumberOfMethods {
			get { return methodDefInfos.Count; }
		}

		public NormalMetaData(ModuleDef module, UniqueChunkList<ByteArrayChunk> constants, MethodBodyChunks methodBodies, NetResources netResources, MetaDataOptions options, DebugMetaDataKind debugKind, bool isStandaloneDebugMetadata)
			: base(module, constants, methodBodies, netResources, options, debugKind, isStandaloneDebugMetadata) {
		}

		/// <inheritdoc/>
		protected override List<TypeDef> GetAllTypeDefs() {
			// All nested types must be after their enclosing type. This is exactly
			// what module.GetTypes() does.
			return new List<TypeDef>(module.GetTypes());
		}

		/// <inheritdoc/>
		protected override void AllocateTypeDefRids() {
			foreach (var type in allTypeDefs) {
				if (type == null)
					continue;
				uint rid = tablesHeap.TypeDefTable.Create(new RawTypeDefRow());
				typeDefInfos.Add(type, rid);
			}
		}

		/// <inheritdoc/>
		protected override void AllocateMemberDefRids() {
			int numTypes = allTypeDefs.Count;
			int typeNum = 0;
			int notifyNum = 0;
			const int numNotifyEvents = 5; // AllocateMemberDefRids0 - AllocateMemberDefRids4
			int notifyAfter = numTypes / numNotifyEvents;

			uint fieldListRid = 1, methodListRid = 1;
			uint eventListRid = 1, propertyListRid = 1;
			uint paramListRid = 1;
			foreach (var type in allTypeDefs) {
				if (typeNum++ == notifyAfter && notifyNum < numNotifyEvents) {
					Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateMemberDefRids0 + notifyNum++);
					notifyAfter += numTypes / numNotifyEvents;
				}

				if (type == null)
					continue;
				uint typeRid = GetRid(type);
				var typeRow = tablesHeap.TypeDefTable[typeRid];
				typeRow.FieldList = fieldListRid;
				typeRow.MethodList = methodListRid;

				foreach (var field in type.Fields) {
					if (field == null)
						continue;
					uint rid = fieldListRid++;
					if (rid != tablesHeap.FieldTable.Create(new RawFieldRow()))
						throw new ModuleWriterException("Invalid field rid");
					fieldDefInfos.Add(field, rid);
				}

				foreach (var method in type.Methods) {
					if (method == null)
						continue;
					uint rid = methodListRid++;
					var row = new RawMethodRow(0, 0, 0, 0, 0, paramListRid);
					if (rid != tablesHeap.MethodTable.Create(row))
						throw new ModuleWriterException("Invalid method rid");
					methodDefInfos.Add(method, rid);
					foreach (var pd in Sort(method.ParamDefs)) {
						if (pd == null)
							continue;
						uint pdRid = paramListRid++;
						if (pdRid != tablesHeap.ParamTable.Create(new RawParamRow()))
							throw new ModuleWriterException("Invalid param rid");
						paramDefInfos.Add(pd, pdRid);
					}
				}

				if (!IsEmpty(type.Events)) {
					uint eventMapRid = tablesHeap.EventMapTable.Create(new RawEventMapRow(typeRid, eventListRid));
					eventMapInfos.Add(type, eventMapRid);
					foreach (var evt in type.Events) {
						if (evt == null)
							continue;
						uint rid = eventListRid++;
						if (rid != tablesHeap.EventTable.Create(new RawEventRow()))
							throw new ModuleWriterException("Invalid event rid");
						eventDefInfos.Add(evt, rid);
					}
				}

				if (!IsEmpty(type.Properties)) {
					uint propertyMapRid = tablesHeap.PropertyMapTable.Create(new RawPropertyMapRow(typeRid, propertyListRid));
					propertyMapInfos.Add(type, propertyMapRid);
					foreach (var prop in type.Properties) {
						if (prop == null)
							continue;
						uint rid = propertyListRid++;
						if (rid != tablesHeap.PropertyTable.Create(new RawPropertyRow()))
							throw new ModuleWriterException("Invalid property rid");
						propertyDefInfos.Add(prop, rid);
					}
				}
			}
			while (notifyNum < numNotifyEvents)
				Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateMemberDefRids0 + notifyNum++);
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeRef tr) {
			uint rid;
			typeRefInfos.TryGetRid(tr, out rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeDef td) {
			uint rid;
			if (typeDefInfos.TryGetRid(td, out rid))
				return rid;
			if (td == null)
				Error("TypeDef is null");
			else
				Error("TypeDef {0} ({1:X8}) is not defined in this module ({2}). A type was removed that is still referenced by this module.", td, td.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(FieldDef fd) {
			uint rid;
			if (fieldDefInfos.TryGetRid(fd, out rid))
				return rid;
			if (fd == null)
				Error("Field is null");
			else
				Error("Field {0} ({1:X8}) is not defined in this module ({2}). A field was removed that is still referenced by this module.", fd, fd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(MethodDef md) {
			uint rid;
			if (methodDefInfos.TryGetRid(md, out rid))
				return rid;
			if (md == null)
				Error("Method is null");
			else
				Error("Method {0} ({1:X8}) is not defined in this module ({2}). A method was removed that is still referenced by this module.", md, md.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(ParamDef pd) {
			uint rid;
			if (paramDefInfos.TryGetRid(pd, out rid))
				return rid;
			if (pd == null)
				Error("Param is null");
			else
				Error("Param {0} ({1:X8}) is not defined in this module ({2}). A parameter was removed that is still referenced by this module.", pd, pd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(MemberRef mr) {
			uint rid;
			memberRefInfos.TryGetRid(mr, out rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(StandAloneSig sas) {
			uint rid;
			standAloneSigInfos.TryGetRid(sas, out rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(EventDef ed) {
			uint rid;
			if (eventDefInfos.TryGetRid(ed, out rid))
				return rid;
			if (ed == null)
				Error("Event is null");
			else
				Error("Event {0} ({1:X8}) is not defined in this module ({2}). An event was removed that is still referenced by this module.", ed, ed.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(PropertyDef pd) {
			uint rid;
			if (propertyDefInfos.TryGetRid(pd, out rid))
				return rid;
			if (pd == null)
				Error("Property is null");
			else
				Error("Property {0} ({1:X8}) is not defined in this module ({2}). A property was removed that is still referenced by this module.", pd, pd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeSpec ts) {
			uint rid;
			typeSpecInfos.TryGetRid(ts, out rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(MethodSpec ms) {
			uint rid;
			methodSpecInfos.TryGetRid(ms, out rid);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddTypeRef(TypeRef tr) {
			if (tr == null) {
				Error("TypeRef is null");
				return 0;
			}
			uint rid;
			if (typeRefInfos.TryGetRid(tr, out rid)) {
				if (rid == 0)
					Error("TypeRef {0:X8} has an infinite ResolutionScope loop", tr.MDToken.Raw);
				return rid;
			}
			typeRefInfos.Add(tr, 0);	// Prevent inf recursion
			var row = new RawTypeRefRow(AddResolutionScope(tr.ResolutionScope),
						stringsHeap.Add(tr.Name),
						stringsHeap.Add(tr.Namespace));
			rid = tablesHeap.TypeRefTable.Add(row);
			typeRefInfos.SetRid(tr, rid);
			AddCustomAttributes(Table.TypeRef, rid, tr);
			AddCustomDebugInformationList(Table.TypeRef, rid, tr);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddTypeSpec(TypeSpec ts) {
			if (ts == null) {
				Error("TypeSpec is null");
				return 0;
			}
			uint rid;
			if (typeSpecInfos.TryGetRid(ts, out rid)) {
				if (rid == 0)
					Error("TypeSpec {0:X8} has an infinite TypeSig loop", ts.MDToken.Raw);
				return rid;
			}
			typeSpecInfos.Add(ts, 0);	// Prevent inf recursion
			var row = new RawTypeSpecRow(GetSignature(ts.TypeSig, ts.ExtraData));
			rid = tablesHeap.TypeSpecTable.Add(row);
			typeSpecInfos.SetRid(ts, rid);
			AddCustomAttributes(Table.TypeSpec, rid, ts);
			AddCustomDebugInformationList(Table.TypeSpec, rid, ts);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddMemberRef(MemberRef mr) {
			if (mr == null) {
				Error("MemberRef is null");
				return 0;
			}
			uint rid;
			if (memberRefInfos.TryGetRid(mr, out rid))
				return rid;
			var row = new RawMemberRefRow(AddMemberRefParent(mr.Class),
							stringsHeap.Add(mr.Name),
							GetSignature(mr.Signature));
			rid = tablesHeap.MemberRefTable.Add(row);
			memberRefInfos.Add(mr, rid);
			AddCustomAttributes(Table.MemberRef, rid, mr);
			AddCustomDebugInformationList(Table.MemberRef, rid, mr);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddStandAloneSig(StandAloneSig sas) {
			if (sas == null) {
				Error("StandAloneSig is null");
				return 0;
			}
			uint rid;
			if (standAloneSigInfos.TryGetRid(sas, out rid))
				return rid;
			var row = new RawStandAloneSigRow(GetSignature(sas.Signature));
			rid = tablesHeap.StandAloneSigTable.Add(row);
			standAloneSigInfos.Add(sas, rid);
			AddCustomAttributes(Table.StandAloneSig, rid, sas);
			AddCustomDebugInformationList(Table.StandAloneSig, rid, sas);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddMethodSpec(MethodSpec ms) {
			if (ms == null) {
				Error("MethodSpec is null");
				return 0;
			}
			uint rid;
			if (methodSpecInfos.TryGetRid(ms, out rid))
				return rid;
			var row = new RawMethodSpecRow(AddMethodDefOrRef(ms.Method),
						GetSignature(ms.Instantiation));
			rid = tablesHeap.MethodSpecTable.Add(row);
			methodSpecInfos.Add(ms, rid);
			AddCustomAttributes(Table.MethodSpec, rid, ms);
			AddCustomDebugInformationList(Table.MethodSpec, rid, ms);
			return rid;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/PEHeaders.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="PEHeaders"/> options
	/// </summary>
	public sealed class PEHeadersOptions {
		/// <summary>
		/// Default DLL characteristics
		/// </summary>
		public const DllCharacteristics DefaultDllCharacteristics = dnlib.PE.DllCharacteristics.TerminalServerAware | dnlib.PE.DllCharacteristics.NoSeh | dnlib.PE.DllCharacteristics.NxCompat | dnlib.PE.DllCharacteristics.DynamicBase;

		/// <summary>
		/// Default subsystem value
		/// </summary>
		public const Subsystem DEFAULT_SUBSYSTEM = dnlib.PE.Subsystem.WindowsGui;

		/// <summary>
		/// Default major linker version
		/// </summary>
		public const byte DEFAULT_MAJOR_LINKER_VERSION = 11;

		/// <summary>
		/// Default minor linker version
		/// </summary>
		public const byte DEFAULT_MINOR_LINKER_VERSION = 0;

		/// <summary>
		/// IMAGE_FILE_HEADER.Machine value
		/// </summary>
		public Machine? Machine;

		/// <summary>
		/// IMAGE_FILE_HEADER.TimeDateStamp value
		/// </summary>
		public uint? TimeDateStamp;

		/// <summary>
		/// IMAGE_FILE_HEADER.PointerToSymbolTable value
		/// </summary>
		public uint? PointerToSymbolTable;

		/// <summary>
		/// IMAGE_FILE_HEADER.NumberOfSymbols value
		/// </summary>
		public uint? NumberOfSymbols;

		/// <summary>
		/// IMAGE_FILE_HEADER.Characteristics value. <see cref="dnlib.PE.Characteristics.Dll"/> bit
		/// is ignored and set/cleared depending on whether it's a EXE or a DLL file.
		/// </summary>
		public Characteristics? Characteristics;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MajorLinkerVersion value
		/// </summary>
		public byte? MajorLinkerVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MinorLinkerVersion value
		/// </summary>
		public byte? MinorLinkerVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.ImageBase value
		/// </summary>
		public ulong? ImageBase;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SectionAlignment value
		/// </summary>
		public uint? SectionAlignment;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.FileAlignment value
		/// </summary>
		public uint? FileAlignment;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MajorOperatingSystemVersion value
		/// </summary>
		public ushort? MajorOperatingSystemVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MinorOperatingSystemVersion value
		/// </summary>
		public ushort? MinorOperatingSystemVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MajorImageVersion value
		/// </summary>
		public ushort? MajorImageVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MinorImageVersion value
		/// </summary>
		public ushort? MinorImageVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MajorSubsystemVersion value
		/// </summary>
		public ushort? MajorSubsystemVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MinorSubsystemVersion value
		/// </summary>
		public ushort? MinorSubsystemVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.Win32VersionValue value
		/// </summary>
		public uint? Win32VersionValue;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.Subsystem value
		/// </summary>
		public Subsystem? Subsystem;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.DllCharacteristics value
		/// </summary>
		public DllCharacteristics? DllCharacteristics;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SizeOfStackReserve value
		/// </summary>
		public ulong? SizeOfStackReserve;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SizeOfStackCommit value
		/// </summary>
		public ulong? SizeOfStackCommit;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SizeOfHeapReserve value
		/// </summary>
		public ulong? SizeOfHeapReserve;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SizeOfHeapCommit value
		/// </summary>
		public ulong? SizeOfHeapCommit;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.LoaderFlags value
		/// </summary>
		public uint? LoaderFlags;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes value
		/// </summary>
		public uint? NumberOfRvaAndSizes;

		/// <summary>
		/// Creates a new time date stamp using current time
		/// </summary>
		/// <returns>A new time date stamp</returns>
		public static uint CreateNewTimeDateStamp() {
			return (uint)(DateTime.UtcNow - Epoch).TotalSeconds;
		}
		static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
	}

	/// <summary>
	/// DOS and PE headers
	/// </summary>
	public sealed class PEHeaders : IChunk {
		IList<PESection> sections;
		readonly PEHeadersOptions options;
		FileOffset offset;
		RVA rva;
		uint length;
		readonly uint sectionAlignment;
		readonly uint fileAlignment;
		ulong imageBase;
		long startOffset;
		long checkSumOffset;
		bool isExeFile;

		// Copied from Partition II.25.2.1
		static readonly byte[] dosHeader = new byte[0x80] {
			0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,
			0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
			0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
			0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
			0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
			0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72,
			0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
			0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E,
			0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
			0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
			0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		};

		/// <summary>
		/// Gets/sets the native entry point
		/// </summary>
		public StartupStub StartupStub { get; set; }

		/// <summary>
		/// Gets/sets the COR20 header
		/// </summary>
		public ImageCor20Header ImageCor20Header { get; set; }

		/// <summary>
		/// Gets/sets the IAT
		/// </summary>
		public ImportAddressTable ImportAddressTable { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="ImportDirectory"/>
		/// </summary>
		public ImportDirectory ImportDirectory { get; set; }

		/// <summary>
		/// Gets/sets the Win32 resources
		/// </summary>
		public Win32ResourcesChunk Win32Resources { get; set; }

		/// <summary>
		/// Gets/sets the relocation directory
		/// </summary>
		public RelocDirectory RelocDirectory { get; set; }

		/// <summary>
		/// Gets/sets the debug directory
		/// </summary>
		public DebugDirectory DebugDirectory { get; set; }

		internal IChunk ExportDirectory { get; set; }

		/// <summary>
		/// Gets the image base
		/// </summary>
		public ulong ImageBase {
			get { return imageBase; }
		}

		/// <summary>
		/// Gets/sets a value indicating whether this is a EXE or a DLL file
		/// </summary>
		public bool IsExeFile {
			get { return isExeFile; }
			set { isExeFile = value; }
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets the section alignment
		/// </summary>
		public uint SectionAlignment {
			get { return sectionAlignment; }
		}

		/// <summary>
		/// Gets the file alignment
		/// </summary>
		public uint FileAlignment {
			get { return fileAlignment; }
		}

		/// <summary>
		/// Gets/sets the <see cref="PESection"/>s
		/// </summary>
		public IList<PESection> PESections {
			get { return sections; }
			set { sections = value; }
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public PEHeaders()
			: this(new PEHeadersOptions()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Options</param>
		public PEHeaders(PEHeadersOptions options) {
			this.options = options ?? new PEHeadersOptions();
			this.sectionAlignment = this.options.SectionAlignment ?? 0x2000;
			this.fileAlignment = this.options.FileAlignment ?? 0x200;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			length = (uint)dosHeader.Length;
			length += 4 + 0x14;
			length += Use32BitOptionalHeader() ? 0xE0U : 0xF0;
			length += (uint)sections.Count * 0x28;

			if (Use32BitOptionalHeader())
				imageBase = options.ImageBase ?? 0x00400000;
			else
				imageBase = options.ImageBase ?? 0x0000000140000000;
		}

		int SectionsCount {
			get {
				int count = 0;
				foreach (var section in sections) {
					if (section.GetVirtualSize() != 0)
						count++;
				}
				return count;
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		IEnumerable<SectionSizeInfo> GetSectionSizeInfos() {
			foreach (var section in sections) {
				uint virtSize = section.GetVirtualSize();
				if (virtSize != 0)
					yield return new SectionSizeInfo(virtSize, section.Characteristics);
			}
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			startOffset = writer.BaseStream.Position;

			// DOS header
			writer.Write(dosHeader);

			// PE magic
			writer.Write(0x00004550);

			// Image file header
			writer.Write((ushort)GetMachine());
			writer.Write((ushort)SectionsCount);
			Debug.Assert(SectionsCount == sections.Count, "One or more sections are empty! The PE file could be bigger than it should be. Empty sections should be removed.");
			writer.Write(options.TimeDateStamp ?? PEHeadersOptions.CreateNewTimeDateStamp());
			writer.Write(options.PointerToSymbolTable ?? 0);
			writer.Write(options.NumberOfSymbols ?? 0);
			writer.Write((ushort)(Use32BitOptionalHeader() ? 0xE0U : 0xF0));
			writer.Write((ushort)GetCharacteristics());

			var sectionSizes = new SectionSizes(fileAlignment, sectionAlignment, length, () => GetSectionSizeInfos());

			// Image optional header
			uint ep = StartupStub == null ? 0 : (uint)StartupStub.EntryPointRVA;
			if (Use32BitOptionalHeader()) {
				writer.Write((ushort)0x010B);
				writer.Write(options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);
				writer.Write(options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);
				writer.Write(sectionSizes.SizeOfCode);
				writer.Write(sectionSizes.SizeOfInitdData);
				writer.Write(sectionSizes.SizeOfUninitdData);
				writer.Write(ep);
				writer.Write(sectionSizes.BaseOfCode);
				writer.Write(sectionSizes.BaseOfData);
				writer.Write((uint)imageBase);
				writer.Write(sectionAlignment);
				writer.Write(fileAlignment);
				writer.Write(options.MajorOperatingSystemVersion ?? 4);
				writer.Write(options.MinorOperatingSystemVersion ?? 0);
				writer.Write(options.MajorImageVersion ?? 0);
				writer.Write(options.MinorImageVersion ?? 0);
				writer.Write(options.MajorSubsystemVersion ?? 4);
				writer.Write(options.MinorSubsystemVersion ?? 0);
				writer.Write(options.Win32VersionValue ?? 0);
				writer.Write(sectionSizes.SizeOfImage);
				writer.Write(sectionSizes.SizeOfHeaders);
				checkSumOffset = writer.BaseStream.Position;
				writer.Write(0);	// CheckSum
				writer.Write((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));
				writer.Write((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));
				writer.Write((uint)(options.SizeOfStackReserve ?? 0x00100000));
				writer.Write((uint)(options.SizeOfStackCommit ?? 0x00001000));
				writer.Write((uint)(options.SizeOfHeapReserve ?? 0x00100000));
				writer.Write((uint)(options.SizeOfHeapCommit ?? 0x00001000));
				writer.Write(options.LoaderFlags ?? 0x00000000);
				writer.Write(options.NumberOfRvaAndSizes ?? 0x00000010);
			}
			else {
				writer.Write((ushort)0x020B);
				writer.Write(options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);
				writer.Write(options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);
				writer.Write(sectionSizes.SizeOfCode);
				writer.Write(sectionSizes.SizeOfInitdData);
				writer.Write(sectionSizes.SizeOfUninitdData);
				writer.Write(ep);
				writer.Write(sectionSizes.BaseOfCode);
				writer.Write(imageBase);
				writer.Write(sectionAlignment);
				writer.Write(fileAlignment);
				writer.Write(options.MajorOperatingSystemVersion ?? 4);
				writer.Write(options.MinorOperatingSystemVersion ?? 0);
				writer.Write(options.MajorImageVersion ?? 0);
				writer.Write(options.MinorImageVersion ?? 0);
				writer.Write(options.MajorSubsystemVersion ?? 4);
				writer.Write(options.MinorSubsystemVersion ?? 0);
				writer.Write(options.Win32VersionValue ?? 0);
				writer.Write(sectionSizes.SizeOfImage);
				writer.Write(sectionSizes.SizeOfHeaders);
				checkSumOffset = writer.BaseStream.Position;
				writer.Write(0);	// CheckSum
				writer.Write((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));
				writer.Write((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));
				writer.Write(options.SizeOfStackReserve ?? 0x0000000000400000);
				writer.Write(options.SizeOfStackCommit ?? 0x0000000000004000);
				writer.Write(options.SizeOfHeapReserve ?? 0x0000000000100000);
				writer.Write(options.SizeOfHeapCommit ?? 0x0000000000002000);
				writer.Write(options.LoaderFlags ?? 0x00000000);
				writer.Write(options.NumberOfRvaAndSizes ?? 0x00000010);
			}

			writer.WriteDataDirectory(ExportDirectory);
			writer.WriteDataDirectory(ImportDirectory);
			writer.WriteDataDirectory(Win32Resources);
			writer.WriteDataDirectory(null);	// Exception table
			writer.WriteDataDirectory(null);	// Certificate table
			writer.WriteDataDirectory(RelocDirectory);
			writer.WriteDataDirectory(DebugDirectory);
			writer.WriteDataDirectory(null);	// Architecture-specific data
			writer.WriteDataDirectory(null);	// Global pointer register RVA
			writer.WriteDataDirectory(null);	// Thread local storage
			writer.WriteDataDirectory(null);	// Load configuration table
			writer.WriteDataDirectory(null);	// Bound import table
			writer.WriteDataDirectory(ImportAddressTable);
			writer.WriteDataDirectory(null);	// Delay import descriptor
			writer.WriteDataDirectory(ImageCor20Header);
			writer.WriteDataDirectory(null);	// Reserved

			// Sections
			uint rva = Utils.AlignUp(sectionSizes.SizeOfHeaders, sectionAlignment);
			int emptySections = 0;
			foreach (var section in sections) {
				if (section.GetVirtualSize() != 0)
					rva += section.WriteHeaderTo(writer, fileAlignment, sectionAlignment, rva);
				else
					emptySections++;
			}
			if (emptySections != 0)
				writer.BaseStream.Position += emptySections * 0x28;
		}

		/// <summary>
		/// Calculates the PE checksum and writes it to the checksum field
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="length">Length of PE file</param>
		public void WriteCheckSum(BinaryWriter writer, long length) {
			writer.BaseStream.Position = startOffset;
			uint checkSum = new BinaryReader(writer.BaseStream).CalculatePECheckSum(length, checkSumOffset);
			writer.BaseStream.Position = checkSumOffset;
			writer.Write(checkSum);
		}

		Machine GetMachine() {
			return options.Machine ?? Machine.I386;
		}

		bool Use32BitOptionalHeader() {
			var mach = GetMachine();
			return mach != Machine.IA64 && mach != Machine.AMD64 && mach != Machine.ARM64;
		}

		Characteristics GetCharacteristics() {
			var chr = options.Characteristics ?? GetDefaultCharacteristics();
			if (IsExeFile)
				chr &= ~Characteristics.Dll;
			else
				chr |= Characteristics.Dll;
			return chr;
		}

		Characteristics GetDefaultCharacteristics() {
			if (Use32BitOptionalHeader())
				return Characteristics._32BitMachine | Characteristics.ExecutableImage;
			return Characteristics.ExecutableImage | Characteristics.LargeAddressAware;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/PESection.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using System.Text;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// A PE section
	/// </summary>
	public sealed class PESection : ChunkList<IChunk> {
		string name;
		uint characteristics;

		/// <summary>
		/// Gets the name
		/// </summary>
		public string Name {
			get { return name; }
			set { name = value; }
		}

		/// <summary>
		/// Gets the Characteristics
		/// </summary>
		public uint Characteristics {
			get { return characteristics; }
			set { characteristics = value; }
		}

		/// <summary>
		/// <c>true</c> if this is a code section
		/// </summary>
		public bool IsCode {
			get { return (characteristics & 0x20) != 0; }
		}

		/// <summary>
		/// <c>true</c> if this is an initialized data section
		/// </summary>
		public bool IsInitializedData {
			get { return (characteristics & 0x40) != 0; }
		}

		/// <summary>
		/// <c>true</c> if this is an uninitialized data section
		/// </summary>
		public bool IsUninitializedData {
			get { return (characteristics & 0x80) != 0; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Section name</param>
		/// <param name="characteristics">Section characteristics</param>
		public PESection(string name, uint characteristics) {
			this.name = name;
			this.characteristics = characteristics;
		}

		/// <summary>
		/// Writes the section header to <paramref name="writer"/> at its current position.
		/// Returns aligned virtual size (aligned to <paramref name="sectionAlignment"/>)
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="fileAlignment">File alignment</param>
		/// <param name="sectionAlignment">Section alignment</param>
		/// <param name="rva">Current <see cref="RVA"/></param>
		public uint WriteHeaderTo(BinaryWriter writer, uint fileAlignment, uint sectionAlignment, uint rva) {
			uint vs = GetVirtualSize();
			uint fileLen = GetFileLength();
			uint alignedVs = Utils.AlignUp(vs, sectionAlignment);
			uint rawSize = Utils.AlignUp(fileLen, fileAlignment);
			uint dataOffset = (uint)FileOffset;

			writer.Write(Encoding.UTF8.GetBytes(Name + "\0\0\0\0\0\0\0\0"), 0, 8);
			writer.Write(vs);			// VirtualSize
			writer.Write((uint)rva);	// VirtualAddress
			writer.Write(rawSize);		// SizeOfRawData
			writer.Write(dataOffset);	// PointerToRawData
			writer.Write(0);			// PointerToRelocations
			writer.Write(0);			// PointerToLinenumbers
			writer.Write((ushort)0);	// NumberOfRelocations
			writer.Write((ushort)0);	// NumberOfLinenumbers
			writer.Write(Characteristics);

			return alignedVs;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/PdbHeap.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #Pdb heap
	/// </summary>
	public sealed class PdbHeap : HeapBase {
		/// <inheritdoc/>
		public override string Name {
			get { return "#Pdb"; }
		}

		/// <summary>
		/// Gets the PDB ID. This is always 20 bytes in size.
		/// </summary>
		public byte[] PdbId {
			get { return pdbId; }
		}
		readonly byte[] pdbId;

		/// <summary>
		/// Gets/sets the entry point token
		/// </summary>
		public uint EntryPoint {
			get { return entryPoint; }
			set { entryPoint = value; }
		}
		uint entryPoint;

		/// <summary>
		/// Gets/sets the referenced type system tables
		/// </summary>
		public ulong ReferencedTypeSystemTables {
			get {
				if (!referencedTypeSystemTablesInitd)
					throw new InvalidOperationException("ReferencedTypeSystemTables hasn't been initialized yet");
				return referencedTypeSystemTables;
			}
			set {
				if (isReadOnly)
					throw new InvalidOperationException("Size has already been calculated, can't write a new value");
				referencedTypeSystemTables = value;
				referencedTypeSystemTablesInitd = true;

				typeSystemTablesCount = 0;
				ulong l = value;
				while (l != 0) {
					if (((int)l & 1) != 0)
						typeSystemTablesCount++;
					l >>= 1;
				}
			}
		}
		ulong referencedTypeSystemTables;
		bool referencedTypeSystemTablesInitd;
		int typeSystemTablesCount;

		/// <summary>
		/// Gets the type system table rows. This table has 64 elements.
		/// </summary>
		public uint[] TypeSystemTableRows {
			get { return typeSystemTableRows; }
		}
		readonly uint[] typeSystemTableRows;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbHeap() {
			pdbId = new byte[20];
			typeSystemTableRows = new uint[64];
		}

		/// <inheritdoc/>
		public override uint GetRawLength() {
			if (!referencedTypeSystemTablesInitd)
				throw new InvalidOperationException("ReferencedTypeSystemTables hasn't been initialized yet");
			return (uint)(pdbId.Length + 4 + 8 + 4 * typeSystemTablesCount);
		}

		/// <inheritdoc/>
		protected override void WriteToImpl(BinaryWriter writer) {
			if (!referencedTypeSystemTablesInitd)
				throw new InvalidOperationException("ReferencedTypeSystemTables hasn't been initialized yet");
			writer.Write(pdbId);
			writer.Write(entryPoint);
			writer.Write(referencedTypeSystemTables);
			ulong t = referencedTypeSystemTables;
			for (int i = 0; i < typeSystemTableRows.Length; i++, t >>= 1) {
				if (((int)t & 1) != 0)
					writer.Write(typeSystemTableRows[i]);
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/PortablePdbConstants.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.DotNet.Writer {
	static class PortablePdbConstants {
		// See System.Reflection.Metadata.PortablePdbVersions

		// Portable PDB version (v1.0)
		// Format version is stored in DebugDirectory.MajorVersion
		//	SRM: DefaultFormatVersion, MinFormatVersion
		public const ushort FormatVersion = 0x0100;

		// Embedded Portable PDB Blob verison (v1.0)
		// Embedded version is stored in DebugDirectory.MinorVersion
		//	SRM: MinEmbeddedVersion, DefaultEmbeddedVersion, MinUnsupportedEmbeddedVersion
		public const ushort EmbeddedVersion = 0x0100;

		// Stored in DebugDirectory.MinorVersion and indicates that it's a portable PDB file
		// and not a Windows PDB file
		public const ushort PortableCodeViewVersionMagic = 0x504D;
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/PreserveTokensMetaData.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Preserves metadata tokens
	/// </summary>
	sealed class PreserveTokensMetaData : MetaData {
		readonly ModuleDefMD mod;
		readonly Rows<TypeRef> typeRefInfos = new Rows<TypeRef>();
		readonly Dictionary<TypeDef, uint> typeToRid = new Dictionary<TypeDef, uint>();
		MemberDefDict<FieldDef> fieldDefInfos;
		MemberDefDict<MethodDef> methodDefInfos;
		MemberDefDict<ParamDef> paramDefInfos;
		readonly Rows<MemberRef> memberRefInfos = new Rows<MemberRef>();
		readonly Rows<StandAloneSig> standAloneSigInfos = new Rows<StandAloneSig>();
		MemberDefDict<EventDef> eventDefInfos;
		MemberDefDict<PropertyDef> propertyDefInfos;
		readonly Rows<TypeSpec> typeSpecInfos = new Rows<TypeSpec>();
		readonly Rows<MethodSpec> methodSpecInfos = new Rows<MethodSpec>();
		readonly Dictionary<uint, uint> callConvTokenToSignature = new Dictionary<uint, uint>();

		[DebuggerDisplay("{Rid} -> {NewRid} {Def}")]
		sealed class MemberDefInfo<T> where T : IMDTokenProvider {
			public readonly T Def;

			/// <summary>
			/// Its real rid
			/// </summary>
			public uint Rid;

			/// <summary>
			/// Its logical rid or real rid. If the ptr table exists (eg. MethodPtr), then it's
			/// an index into it, else it's the real rid.
			/// </summary>
			public uint NewRid;

			public MemberDefInfo(T def, uint rid) {
				this.Def = def;
				this.Rid = rid;
				this.NewRid = rid;
			}
		}

		[DebuggerDisplay("Count = {Count}")]
		sealed class MemberDefDict<T> where T : IMDTokenProvider {
			readonly Type defMDType;
			uint userRid = 0x01000000;
			uint newRid = 1;
			int numDefMDs;
			int numDefUsers;
			int tableSize;
			bool wasSorted;
			readonly bool preserveRids;
			readonly bool enableRidToInfo;
			readonly Dictionary<T, MemberDefInfo<T>> defToInfo = new Dictionary<T, MemberDefInfo<T>>();
			Dictionary<uint, MemberDefInfo<T>> ridToInfo;
			readonly List<MemberDefInfo<T>> defs = new List<MemberDefInfo<T>>();
			List<MemberDefInfo<T>> sortedDefs;
			readonly Dictionary<T, int> collectionPositions = new Dictionary<T, int>();

			/// <summary>
			/// Gets total number of defs in the list. It does <c>not</c> necessarily return
			/// the table size. Use <see cref="TableSize"/> for that.
			/// </summary>
			public int Count {
				get { return defs.Count; }
			}

			/// <summary>
			/// Gets the number of rows that need to be created in the table
			/// </summary>
			public int TableSize {
				get { return tableSize; }
			}

			/// <summary>
			/// Returns <c>true</c> if the ptr table (eg. <c>MethodPtr</c>) is needed
			/// </summary>
			public bool NeedPtrTable {
				get { return preserveRids && !wasSorted; }
			}

			public MemberDefDict(Type defMDType, bool preserveRids)
				: this(defMDType, preserveRids, false) {
			}

			public MemberDefDict(Type defMDType, bool preserveRids, bool enableRidToInfo) {
				this.defMDType = defMDType;
				this.preserveRids = preserveRids;
				this.enableRidToInfo = enableRidToInfo;
			}

			public uint Rid(T def) {
				return defToInfo[def].Rid;
			}

			public bool TryGetRid(T def, out uint rid) {
				MemberDefInfo<T> info;
				if (def == null || !defToInfo.TryGetValue(def, out info)) {
					rid = 0;
					return false;
				}
				rid = info.Rid;
				return true;
			}

			/// <summary>
			/// Sorts the table
			/// </summary>
			/// <param name="comparer">Comparer</param>
			public void Sort(Comparison<MemberDefInfo<T>> comparer) {
				if (!preserveRids) {
					// It's already sorted
					sortedDefs = defs;
					return;
				}

				sortedDefs = new List<MemberDefInfo<T>>(defs);
				sortedDefs.Sort(comparer);
				wasSorted = true;
				for (int i = 0; i < sortedDefs.Count; i++) {
					var def = sortedDefs[i];
					uint newRid = (uint)i + 1;
					def.NewRid = newRid;
					if (def.Rid != newRid)
						wasSorted = false;
				}
			}

			public MemberDefInfo<T> Get(int i) {
				return defs[i];
			}

			public MemberDefInfo<T> GetSorted(int i) {
				return sortedDefs[i];
			}

			public MemberDefInfo<T> GetByRid(uint rid) {
				MemberDefInfo<T> info;
				ridToInfo.TryGetValue(rid, out info);
				return info;
			}

			/// <summary>
			/// Adds a def. <see cref="SortDefs()"/> must be called after adding the last def.
			/// </summary>
			/// <param name="def">The def</param>
			/// <param name="collPos">Collection position</param>
			public void Add(T def, int collPos) {
				uint rid;
				if (def.GetType() == defMDType) {
					numDefMDs++;
					rid = preserveRids ? def.Rid : newRid++;
				}
				else {
					numDefUsers++;
					rid = preserveRids ? userRid++ : newRid++;
				}

				var info = new MemberDefInfo<T>(def, rid);
				defToInfo[def] = info;
				defs.Add(info);
				collectionPositions.Add(def, collPos);
			}

			/// <summary>
			/// Must be called after <see cref="Add"/>'ing the last def
			/// </summary>
			public void SortDefs() {
				// It's already sorted if we don't preserve rids
				if (preserveRids) {
					// Sort all def MDs before user defs
					defs.Sort((a, b) => a.Rid.CompareTo(b.Rid));

					// Fix user created defs' rids
					uint newRid = numDefMDs == 0 ? 1 : defs[numDefMDs - 1].Rid + 1;
					for (int i = numDefMDs; i < defs.Count; i++)
						defs[i].Rid = newRid++;

					// Now we know total table size
					tableSize = (int)newRid - 1;
				}
				else
					tableSize = defs.Count;

				if (enableRidToInfo) {
					ridToInfo = new Dictionary<uint, MemberDefInfo<T>>(defs.Count);
					foreach (var info in defs)
						ridToInfo.Add(info.Rid, info);
				}

				if ((uint)tableSize > 0x00FFFFFF)
					throw new ModuleWriterException("Table is too big");
			}

			public int GetCollectionPosition(T def) {
				return collectionPositions[def];
			}
		}

		protected override int NumberOfMethods {
			get { return methodDefInfos.Count; }
		}

		public PreserveTokensMetaData(ModuleDef module, UniqueChunkList<ByteArrayChunk> constants, MethodBodyChunks methodBodies, NetResources netResources, MetaDataOptions options, DebugMetaDataKind debugKind, bool isStandaloneDebugMetadata)
			: base(module, constants, methodBodies, netResources, options, debugKind, isStandaloneDebugMetadata) {
			mod = module as ModuleDefMD;
			if (mod == null)
				throw new ModuleWriterException("Not a ModuleDefMD");
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeRef tr) {
			uint rid;
			typeRefInfos.TryGetRid(tr, out rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeDef td) {
			if (td == null) {
				Error("TypeDef is null");
				return 0;
			}
			uint rid;
			if (typeToRid.TryGetValue(td, out rid))
				return rid;
			Error("TypeDef {0} ({1:X8}) is not defined in this module ({2}). A type was removed that is still referenced by this module.", td, td.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(FieldDef fd) {
			uint rid;
			if (fieldDefInfos.TryGetRid(fd, out rid))
				return rid;
			if (fd == null)
				Error("Field is null");
			else
				Error("Field {0} ({1:X8}) is not defined in this module ({2}). A field was removed that is still referenced by this module.", fd, fd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(MethodDef md) {
			uint rid;
			if (methodDefInfos.TryGetRid(md, out rid))
				return rid;
			if (md == null)
				Error("Method is null");
			else
				Error("Method {0} ({1:X8}) is not defined in this module ({2}). A method was removed that is still referenced by this module.", md, md.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(ParamDef pd) {
			uint rid;
			if (paramDefInfos.TryGetRid(pd, out rid))
				return rid;
			if (pd == null)
				Error("Param is null");
			else
				Error("Param {0} ({1:X8}) is not defined in this module ({2}). A parameter was removed that is still referenced by this module.", pd, pd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(MemberRef mr) {
			uint rid;
			memberRefInfos.TryGetRid(mr, out rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(StandAloneSig sas) {
			uint rid;
			standAloneSigInfos.TryGetRid(sas, out rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(EventDef ed) {
			uint rid;
			if (eventDefInfos.TryGetRid(ed, out rid))
				return rid;
			if (ed == null)
				Error("Event is null");
			else
				Error("Event {0} ({1:X8}) is not defined in this module ({2}). An event was removed that is still referenced by this module.", ed, ed.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(PropertyDef pd) {
			uint rid;
			if (propertyDefInfos.TryGetRid(pd, out rid))
				return rid;
			if (pd == null)
				Error("Property is null");
			else
				Error("Property {0} ({1:X8}) is not defined in this module ({2}). A property was removed that is still referenced by this module.", pd, pd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeSpec ts) {
			uint rid;
			typeSpecInfos.TryGetRid(ts, out rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(MethodSpec ms) {
			uint rid;
			methodSpecInfos.TryGetRid(ms, out rid);
			return rid;
		}

		/// <inheritdoc/>
		protected override void Initialize() {
			fieldDefInfos = new MemberDefDict<FieldDef>(typeof(FieldDefMD), PreserveFieldRids);
			methodDefInfos = new MemberDefDict<MethodDef>(typeof(MethodDefMD), PreserveMethodRids, true);
			paramDefInfos = new MemberDefDict<ParamDef>(typeof(ParamDefMD), PreserveParamRids);
			eventDefInfos = new MemberDefDict<EventDef>(typeof(EventDefMD), PreserveEventRids);
			propertyDefInfos = new MemberDefDict<PropertyDef>(typeof(PropertyDefMD), PreservePropertyRids);

			CreateEmptyTableRows();
		}

		/// <inheritdoc/>
		protected override List<TypeDef> GetAllTypeDefs() {
			if (!PreserveTypeDefRids) {
				var types2 = new List<TypeDef>(module.GetTypes());
				InitializeTypeToRid(types2);
				return types2;
			}

			var typeToIndex = new Dictionary<TypeDef, uint>();
			var types = new List<TypeDef>();
			uint index = 0;
			const uint IS_TYPEDEFMD = 0x80000000;
			const uint INDEX_BITS = 0x00FFFFFF;
			foreach (var type in module.GetTypes()) {
				if (type == null)
					continue;
				types.Add(type);
				uint val = (uint)index++;
				if (type.GetType() == typeof(TypeDefMD))
					val |= IS_TYPEDEFMD;
				typeToIndex[type] = val;
			}

			var globalType = types[0];
			types.Sort((a, b) => {
				if (a == b)
					return 0;
				// Make sure the global <Module> type is always sorted first, even if it's
				// a TypeDefUser
				if (a == globalType)
					return -1;
				if (b == globalType)
					return 1;

				// Sort all TypeDefMDs before all TypeDefUsers
				uint ai = typeToIndex[a];
				uint bi = typeToIndex[b];
				bool amd = (ai & IS_TYPEDEFMD) != 0;
				bool bmd = (bi & IS_TYPEDEFMD) != 0;
				if (amd == bmd) {	// Both are TypeDefMDs or both are TypeDefUsers
					// If TypeDefMDs, only compare rids since rids are preserved
					if (amd)
						return a.Rid.CompareTo(b.Rid);

					// If TypeDefUsers, rids aren't preserved so compare by index
					return (ai & INDEX_BITS).CompareTo(bi & INDEX_BITS);
				}
				if (amd)
					return -1;
				return 1;
			});

			// Some of the original types may have been removed. Create dummy types
			// so TypeDef rids can be preserved.
			var newTypes = new List<TypeDef>(types.Count);
			uint prevRid = 1;
			newTypes.Add(globalType);
			for (int i = 1; i < types.Count; i++) {
				var type = types[i];

				// TypeDefUsers were sorted last so when we reach one, we can stop
				if (type.GetType() != typeof(TypeDefMD)) {
					while (i < types.Count)
						newTypes.Add(types[i++]);
					break;
				}

				uint currRid = type.Rid;
				int extraTypes = (int)(currRid - prevRid - 1);
				if (extraTypes != 0) { // always >= 0 since currRid > prevRid
					// At least one type has been removed. Create dummy types.
					for (int j = 0; j < extraTypes; j++)
						newTypes.Add(new TypeDefUser("dummy", Guid.NewGuid().ToString("B"), module.CorLibTypes.Object.TypeDefOrRef));
				}
				newTypes.Add(type);
				prevRid = currRid;
			}

			InitializeTypeToRid(newTypes);
			return newTypes;
		}

		void InitializeTypeToRid(IEnumerable<TypeDef> types) {
			uint rid = 1;
			foreach (var type in types) {
				if (type == null)
					continue;
				if (typeToRid.ContainsKey(type))
					continue;
				typeToRid[type] = rid++;
			}
		}

		/// <inheritdoc/>
		protected override void AllocateTypeDefRids() {
			foreach (var type in allTypeDefs) {
				uint rid = tablesHeap.TypeDefTable.Create(new RawTypeDefRow());
				if (typeToRid[type] != rid)
					throw new ModuleWriterException("Got a different rid than expected");
			}
		}

		/// <summary>
		/// Reserves rows in <c>TypeRef</c>, <c>MemberRef</c>, <c>StandAloneSig</c>,
		/// <c>TypeSpec</c> and <c>MethodSpec</c> where we will store the original rows
		/// to make sure they get the same rid. Any user created rows will be stored at
		/// the end of each table.
		/// </summary>
		void CreateEmptyTableRows() {
			uint rows;

			if (PreserveTypeRefRids) {
				rows = mod.TablesStream.TypeRefTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.TypeRefTable.Create(new RawTypeRefRow());
			}

			if (PreserveMemberRefRids) {
				rows = mod.TablesStream.MemberRefTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.MemberRefTable.Create(new RawMemberRefRow());
			}

			if (PreserveStandAloneSigRids) {
				rows = mod.TablesStream.StandAloneSigTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.StandAloneSigTable.Create(new RawStandAloneSigRow());
			}

			if (PreserveTypeSpecRids) {
				rows = mod.TablesStream.TypeSpecTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.TypeSpecTable.Create(new RawTypeSpecRow());
			}

			if (PreserveMethodSpecRids) {
				rows = mod.TablesStream.MethodSpecTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.MethodSpecTable.Create(new RawMethodSpecRow());
			}
		}

		/// <summary>
		/// Adds any non-referenced rows that haven't been added yet but are present in
		/// the original file. If there are any non-referenced rows, it's usually a sign
		/// that an obfuscator has encrypted one or more methods or that it has added
		/// some rows it uses to decrypt something.
		/// </summary>
		void InitializeUninitializedTableRows() {
			InitializeTypeRefTableRows();
			InitializeMemberRefTableRows();
			InitializeStandAloneSigTableRows();
			InitializeTypeSpecTableRows();
			InitializeMethodSpecTableRows();
		}

		bool initdTypeRef = false;
		void InitializeTypeRefTableRows() {
			if (!PreserveTypeRefRids || initdTypeRef)
				return;
			initdTypeRef = true;

			uint rows = mod.TablesStream.TypeRefTable.Rows;
			for (uint rid = 1; rid <= rows; rid++)
				AddTypeRef(mod.ResolveTypeRef(rid));
			tablesHeap.TypeRefTable.ReAddRows();
		}

		bool initdMemberRef = false;
		void InitializeMemberRefTableRows() {
			if (!PreserveMemberRefRids || initdMemberRef)
				return;
			initdMemberRef = true;

			uint rows = mod.TablesStream.MemberRefTable.Rows;
			for (uint rid = 1; rid <= rows; rid++)
				AddMemberRef(mod.ResolveMemberRef(rid), true);
			tablesHeap.MemberRefTable.ReAddRows();
		}

		bool initdStandAloneSig = false;
		void InitializeStandAloneSigTableRows() {
			if (!PreserveStandAloneSigRids || initdStandAloneSig)
				return;
			initdStandAloneSig = true;

			uint rows = mod.TablesStream.StandAloneSigTable.Rows;
			for (uint rid = 1; rid <= rows; rid++)
				AddStandAloneSig(mod.ResolveStandAloneSig(rid), true);
			tablesHeap.StandAloneSigTable.ReAddRows();
		}

		bool initdTypeSpec = false;
		void InitializeTypeSpecTableRows() {
			if (!PreserveTypeSpecRids || initdTypeSpec)
				return;
			initdTypeSpec = true;

			uint rows = mod.TablesStream.TypeSpecTable.Rows;
			for (uint rid = 1; rid <= rows; rid++)
				AddTypeSpec(mod.ResolveTypeSpec(rid), true);
			tablesHeap.TypeSpecTable.ReAddRows();
		}

		bool initdMethodSpec = false;
		void InitializeMethodSpecTableRows() {
			if (!PreserveMethodSpecRids || initdMethodSpec)
				return;
			initdMethodSpec = true;

			uint rows = mod.TablesStream.MethodSpecTable.Rows;
			for (uint rid = 1; rid <= rows; rid++)
				AddMethodSpec(mod.ResolveMethodSpec(rid), true);
			tablesHeap.MethodSpecTable.ReAddRows();
		}

		/// <inheritdoc/>
		protected override void AllocateMemberDefRids() {
			FindMemberDefs();

			Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateMemberDefRids0);

			for (int i = 1; i <= fieldDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.FieldTable.Create(new RawFieldRow()))
					throw new ModuleWriterException("Invalid field rid");
			}

			for (int i = 1; i <= methodDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.MethodTable.Create(new RawMethodRow()))
					throw new ModuleWriterException("Invalid method rid");
			}

			for (int i = 1; i <= paramDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.ParamTable.Create(new RawParamRow()))
					throw new ModuleWriterException("Invalid param rid");
			}

			for (int i = 1; i <= eventDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.EventTable.Create(new RawEventRow()))
					throw new ModuleWriterException("Invalid event rid");
			}

			for (int i = 1; i <= propertyDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.PropertyTable.Create(new RawPropertyRow()))
					throw new ModuleWriterException("Invalid property rid");
			}

			SortFields();
			SortMethods();
			SortParameters();
			SortEvents();
			SortProperties();

			Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateMemberDefRids1);

			if (fieldDefInfos.NeedPtrTable) {
				for (int i = 0; i < fieldDefInfos.Count; i++) {
					var info = fieldDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.FieldPtrTable.Add(new RawFieldPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid field ptr rid");
				}
				ReUseDeletedFieldRows();
			}

			if (methodDefInfos.NeedPtrTable) {
				for (int i = 0; i < methodDefInfos.Count; i++) {
					var info = methodDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.MethodPtrTable.Add(new RawMethodPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid method ptr rid");
				}
				ReUseDeletedMethodRows();
			}

			if (paramDefInfos.NeedPtrTable) {
				// NOTE: peverify does not support the ParamPtr table. It's a bug.
				for (int i = 0; i < paramDefInfos.Count; i++) {
					var info = paramDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.ParamPtrTable.Add(new RawParamPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid param ptr rid");
				}
				ReUseDeletedParamRows();
			}

			if (eventDefInfos.NeedPtrTable) {
				for (int i = 0; i < eventDefInfos.Count; i++) {
					var info = eventDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.EventPtrTable.Add(new RawEventPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid event ptr rid");
				}
			}

			if (propertyDefInfos.NeedPtrTable) {
				for (int i = 0; i < propertyDefInfos.Count; i++) {
					var info = propertyDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.PropertyPtrTable.Add(new RawPropertyPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid property ptr rid");
				}
			}

			Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateMemberDefRids2);

			InitializeMethodAndFieldList();
			InitializeParamList();
			InitializeEventMap();
			InitializePropertyMap();

			Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateMemberDefRids3);

			// We must re-use deleted event/property rows after we've initialized
			// the event/prop map tables.
			if (eventDefInfos.NeedPtrTable)
				ReUseDeletedEventRows();
			if (propertyDefInfos.NeedPtrTable)
				ReUseDeletedPropertyRows();

			Listener.OnMetaDataEvent(this, MetaDataEvent.AllocateMemberDefRids4);

			InitializeTypeRefTableRows();
			InitializeTypeSpecTableRows();
			InitializeMemberRefTableRows();
			InitializeMethodSpecTableRows();
		}

		/// <summary>
		/// Re-uses all <c>Field</c> rows which aren't owned by any type due to the fields
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>FieldPtr</c> and <c>Field</c> tables must be the same size.
		/// </summary>
		void ReUseDeletedFieldRows() {
			if (tablesHeap.FieldPtrTable.IsEmpty)
				return;
			if (fieldDefInfos.TableSize == tablesHeap.FieldPtrTable.Rows)
				return;

			var hasOwner = new bool[fieldDefInfos.TableSize];
			for (int i = 0; i < fieldDefInfos.Count; i++)
				hasOwner[(int)fieldDefInfos.Get(i).Rid - 1] = true;

			CreateDummyPtrTableType();

			uint fieldSig = GetSignature(new FieldSig(module.CorLibTypes.Byte));
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint frid = (uint)i + 1;

				var frow = tablesHeap.FieldTable[frid];
				frow.Flags = (ushort)(FieldAttributes.Public | FieldAttributes.Static);
				frow.Name = stringsHeap.Add(string.Format("f{0:X6}", frid));
				frow.Signature = fieldSig;
				tablesHeap.FieldPtrTable.Create(new RawFieldPtrRow(frid));
			}

			if (fieldDefInfos.TableSize != tablesHeap.FieldPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy fields");
		}

		/// <summary>
		/// Re-uses all <c>Method</c> rows which aren't owned by any type due to the methods
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>MethodPtr</c> and <c>Method</c> tables must be the same size.
		/// </summary>
		void ReUseDeletedMethodRows() {
			if (tablesHeap.MethodPtrTable.IsEmpty)
				return;
			if (methodDefInfos.TableSize == tablesHeap.MethodPtrTable.Rows)
				return;

			var hasOwner = new bool[methodDefInfos.TableSize];
			for (int i = 0; i < methodDefInfos.Count; i++)
				hasOwner[(int)methodDefInfos.Get(i).Rid - 1] = true;

			CreateDummyPtrTableType();

			uint methodSig = GetSignature(MethodSig.CreateInstance(module.CorLibTypes.Void));
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint mrid = (uint)i + 1;

				var mrow = tablesHeap.MethodTable[mrid];
				mrow.RVA = 0;
				mrow.ImplFlags = (ushort)(MethodImplAttributes.IL | MethodImplAttributes.Managed);
				mrow.Flags = (ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract);
				mrow.Name = stringsHeap.Add(string.Format("m{0:X6}", mrid));
				mrow.Signature = methodSig;
				mrow.ParamList = (uint)paramDefInfos.Count;
				tablesHeap.MethodPtrTable.Create(new RawMethodPtrRow(mrid));
			}

			if (methodDefInfos.TableSize != tablesHeap.MethodPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy methods");
		}

		/// <summary>
		/// Re-uses all <c>Param</c> rows which aren't owned by any type due to the params
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>ParamPtr</c> and <c>Param</c> tables must be the same size.
		/// This method must be called after <see cref="ReUseDeletedMethodRows()"/> since
		/// this method will create more methods at the end of the <c>Method</c> table.
		/// </summary>
		void ReUseDeletedParamRows() {
			if (tablesHeap.ParamPtrTable.IsEmpty)
				return;
			if (paramDefInfos.TableSize == tablesHeap.ParamPtrTable.Rows)
				return;

			var hasOwner = new bool[paramDefInfos.TableSize];
			for (int i = 0; i < paramDefInfos.Count; i++)
				hasOwner[(int)paramDefInfos.Get(i).Rid - 1] = true;

			CreateDummyPtrTableType();

			// For each param, attach it to a new method. Another alternative would be to create
			// one (or a few) methods with tons of parameters.
			uint methodSig = GetSignature(MethodSig.CreateInstance(module.CorLibTypes.Void));
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint prid = (uint)i + 1;

				var prow = tablesHeap.ParamTable[prid];
				prow.Flags = 0;
				prow.Sequence = 0;	// Return type parameter
				prow.Name = stringsHeap.Add(string.Format("p{0:X6}", prid));
				uint ptrRid = tablesHeap.ParamPtrTable.Create(new RawParamPtrRow(prid));

				var mrow = new RawMethodRow(0,
					(ushort)(MethodImplAttributes.IL | MethodImplAttributes.Managed),
					(ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract),
					stringsHeap.Add(string.Format("mp{0:X6}", prid)),
					methodSig,
					ptrRid);
				uint mrid = tablesHeap.MethodTable.Create(mrow);
				if (tablesHeap.MethodPtrTable.Rows > 0)
					tablesHeap.MethodPtrTable.Create(new RawMethodPtrRow(mrid));
			}

			if (paramDefInfos.TableSize != tablesHeap.ParamPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy params");
		}

		/// <summary>
		/// Re-uses all <c>Event</c> rows which aren't owned by any type due to the events
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>EventPtr</c> and <c>Event</c> tables must be the same size.
		/// </summary>
		void ReUseDeletedEventRows() {
			if (tablesHeap.EventPtrTable.IsEmpty)
				return;
			if (eventDefInfos.TableSize == tablesHeap.EventPtrTable.Rows)
				return;

			var hasOwner = new bool[eventDefInfos.TableSize];
			for (int i = 0; i < eventDefInfos.Count; i++)
				hasOwner[(int)eventDefInfos.Get(i).Rid - 1] = true;

			uint typeRid = CreateDummyPtrTableType();
			tablesHeap.EventMapTable.Create(new RawEventMapRow(typeRid, (uint)tablesHeap.EventPtrTable.Rows + 1));

			uint eventType = AddTypeDefOrRef(module.CorLibTypes.Object.TypeDefOrRef);
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint erid = (uint)i + 1;

				var frow = tablesHeap.EventTable[erid];
				frow.EventFlags = 0;
				frow.Name = stringsHeap.Add(string.Format("E{0:X6}", erid));
				frow.EventType = eventType;
				tablesHeap.EventPtrTable.Create(new RawEventPtrRow(erid));
			}

			if (eventDefInfos.TableSize != tablesHeap.EventPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy events");
		}

		/// <summary>
		/// Re-uses all <c>Property</c> rows which aren't owned by any type due to the properties
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>PropertyPtr</c> and <c>Property</c> tables must be the same size.
		/// </summary>
		void ReUseDeletedPropertyRows() {
			if (tablesHeap.PropertyPtrTable.IsEmpty)
				return;
			if (propertyDefInfos.TableSize == tablesHeap.PropertyPtrTable.Rows)
				return;

			var hasOwner = new bool[propertyDefInfos.TableSize];
			for (int i = 0; i < propertyDefInfos.Count; i++)
				hasOwner[(int)propertyDefInfos.Get(i).Rid - 1] = true;

			uint typeRid = CreateDummyPtrTableType();
			tablesHeap.PropertyMapTable.Create(new RawPropertyMapRow(typeRid, (uint)tablesHeap.PropertyPtrTable.Rows + 1));

			uint propertySig = GetSignature(PropertySig.CreateStatic(module.CorLibTypes.Object));
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint prid = (uint)i + 1;

				var frow = tablesHeap.PropertyTable[prid];
				frow.PropFlags = 0;
				frow.Name = stringsHeap.Add(string.Format("P{0:X6}", prid));
				frow.Type = propertySig;
				tablesHeap.PropertyPtrTable.Create(new RawPropertyPtrRow(prid));
			}

			if (propertyDefInfos.TableSize != tablesHeap.PropertyPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy properties");
		}

		/// <summary>
		/// Creates a dummy <c>TypeDef</c> at the end of the <c>TypeDef</c> table that will own
		/// dummy methods and fields. These dummy methods and fields are only created if the size
		/// of the ptr table is less than the size of the non-ptr table (eg. size MethodPtr table
		/// is less than size Method table). The only reason the ptr table would be smaller than
		/// the non-ptr table is when some field/method has been deleted and we must preserve
		/// all method/field rids.
		/// </summary>
		uint CreateDummyPtrTableType() {
			if (dummyPtrTableTypeRid != 0)
				return dummyPtrTableTypeRid;

			var flags = TypeAttributes.NotPublic | TypeAttributes.AutoLayout |
				TypeAttributes.Class | TypeAttributes.Abstract | TypeAttributes.AnsiClass;
			int numFields = fieldDefInfos.NeedPtrTable ? fieldDefInfos.Count : fieldDefInfos.TableSize;
			int numMethods = methodDefInfos.NeedPtrTable ? methodDefInfos.Count : methodDefInfos.TableSize;
			var row = new RawTypeDefRow((uint)flags,
						stringsHeap.Add(Guid.NewGuid().ToString("B")),
						stringsHeap.Add("dummy_ptr"),
						AddTypeDefOrRef(module.CorLibTypes.Object.TypeDefOrRef),
						(uint)numFields + 1,
						(uint)numMethods + 1);
			dummyPtrTableTypeRid = tablesHeap.TypeDefTable.Create(row);
			if (dummyPtrTableTypeRid == 1)
				throw new ModuleWriterException("Dummy ptr type is the first type");
			return dummyPtrTableTypeRid;
		}
		uint dummyPtrTableTypeRid;

		void FindMemberDefs() {
			var added = new Dictionary<object, bool>();
			int pos;
			foreach (var type in allTypeDefs) {
				if (type == null)
					continue;

				pos = 0;
				foreach (var field in type.Fields) {
					if (field == null)
						continue;
					fieldDefInfos.Add(field, pos++);
				}

				pos = 0;
				foreach (var method in type.Methods) {
					if (method == null)
						continue;
					methodDefInfos.Add(method, pos++);
				}

				pos = 0;
				foreach (var evt in type.Events) {
					if (evt == null || added.ContainsKey(evt))
						continue;
					added[evt] = true;
					eventDefInfos.Add(evt, pos++);
				}

				pos = 0;
				foreach (var prop in type.Properties) {
					if (prop == null || added.ContainsKey(prop))
						continue;
					added[prop] = true;
					propertyDefInfos.Add(prop, pos++);
				}
			}

			fieldDefInfos.SortDefs();
			methodDefInfos.SortDefs();
			eventDefInfos.SortDefs();
			propertyDefInfos.SortDefs();

			for (int i = 0; i < methodDefInfos.Count; i++) {
				var method = methodDefInfos.Get(i).Def;
				pos = 0;
				foreach (var param in Sort(method.ParamDefs)) {
					if (param == null)
						continue;
					paramDefInfos.Add(param, pos++);
				}
			}
			paramDefInfos.SortDefs();
		}

		void SortFields() {
			fieldDefInfos.Sort((a, b) => {
				var dta = a.Def.DeclaringType == null ? 0 : typeToRid[a.Def.DeclaringType];
				var dtb = b.Def.DeclaringType == null ? 0 : typeToRid[b.Def.DeclaringType];
				if (dta == 0 || dtb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dta != dtb)
					return dta.CompareTo(dtb);
				return fieldDefInfos.GetCollectionPosition(a.Def).CompareTo(fieldDefInfos.GetCollectionPosition(b.Def));
			});
		}

		void SortMethods() {
			methodDefInfos.Sort((a, b) => {
				var dta = a.Def.DeclaringType == null ? 0 : typeToRid[a.Def.DeclaringType];
				var dtb = b.Def.DeclaringType == null ? 0 : typeToRid[b.Def.DeclaringType];
				if (dta == 0 || dtb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dta != dtb)
					return dta.CompareTo(dtb);
				return methodDefInfos.GetCollectionPosition(a.Def).CompareTo(methodDefInfos.GetCollectionPosition(b.Def));
			});
		}

		void SortParameters() {
			paramDefInfos.Sort((a, b) => {
				var dma = a.Def.DeclaringMethod == null ? 0 : methodDefInfos.Rid(a.Def.DeclaringMethod);
				var dmb = b.Def.DeclaringMethod == null ? 0 : methodDefInfos.Rid(b.Def.DeclaringMethod);
				if (dma == 0 || dmb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dma != dmb)
					return dma.CompareTo(dmb);
				return paramDefInfos.GetCollectionPosition(a.Def).CompareTo(paramDefInfos.GetCollectionPosition(b.Def));
			});
		}

		void SortEvents() {
			eventDefInfos.Sort((a, b) => {
				var dta = a.Def.DeclaringType == null ? 0 : typeToRid[a.Def.DeclaringType];
				var dtb = b.Def.DeclaringType == null ? 0 : typeToRid[b.Def.DeclaringType];
				if (dta == 0 || dtb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dta != dtb)
					return dta.CompareTo(dtb);
				return eventDefInfos.GetCollectionPosition(a.Def).CompareTo(eventDefInfos.GetCollectionPosition(b.Def));
			});
		}

		void SortProperties() {
			propertyDefInfos.Sort((a, b) => {
				var dta = a.Def.DeclaringType == null ? 0 : typeToRid[a.Def.DeclaringType];
				var dtb = b.Def.DeclaringType == null ? 0 : typeToRid[b.Def.DeclaringType];
				if (dta == 0 || dtb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dta != dtb)
					return dta.CompareTo(dtb);
				return propertyDefInfos.GetCollectionPosition(a.Def).CompareTo(propertyDefInfos.GetCollectionPosition(b.Def));
			});
		}

		void InitializeMethodAndFieldList() {
			uint fieldList = 1, methodList = 1;
			foreach (var type in allTypeDefs) {
				var typeRow = tablesHeap.TypeDefTable[typeToRid[type]];
				typeRow.FieldList = fieldList;
				typeRow.MethodList = methodList;
				fieldList += (uint)type.Fields.Count;
				methodList += (uint)type.Methods.Count;
			}
		}

		void InitializeParamList() {
			uint ridList = 1;
			for (uint methodRid = 1; methodRid <= methodDefInfos.TableSize; methodRid++) {
				var methodInfo = methodDefInfos.GetByRid(methodRid);
				var row = tablesHeap.MethodTable[methodRid];
				row.ParamList = ridList;
				if (methodInfo != null)
					ridList += (uint)methodInfo.Def.ParamDefs.Count;
			}
		}

		void InitializeEventMap() {
			if (!tablesHeap.EventMapTable.IsEmpty)
				throw new ModuleWriterException("EventMap table isn't empty");
			TypeDef type = null;
			for (int i = 0; i < eventDefInfos.Count; i++) {
				var info = eventDefInfos.GetSorted(i);
				if (type == info.Def.DeclaringType)
					continue;
				type = info.Def.DeclaringType;
				var row = new RawEventMapRow(typeToRid[type], info.NewRid);
				uint eventMapRid = tablesHeap.EventMapTable.Create(row);
				eventMapInfos.Add(type, eventMapRid);
			}
		}

		void InitializePropertyMap() {
			if (!tablesHeap.PropertyMapTable.IsEmpty)
				throw new ModuleWriterException("PropertyMap table isn't empty");
			TypeDef type = null;
			for (int i = 0; i < propertyDefInfos.Count; i++) {
				var info = propertyDefInfos.GetSorted(i);
				if (type == info.Def.DeclaringType)
					continue;
				type = info.Def.DeclaringType;
				var row = new RawPropertyMapRow(typeToRid[type], info.NewRid);
				uint propertyMapRid = tablesHeap.PropertyMapTable.Create(row);
				propertyMapInfos.Add(type, propertyMapRid);
			}
		}

		/// <inheritdoc/>
		protected override uint AddTypeRef(TypeRef tr) {
			if (tr == null) {
				Error("TypeRef is null");
				return 0;
			}
			uint rid;
			if (typeRefInfos.TryGetRid(tr, out rid)) {
				if (rid == 0)
					Error("TypeRef {0:X8} has an infinite ResolutionScope loop", tr.MDToken.Raw);
				return rid;
			}
			typeRefInfos.Add(tr, 0);	// Prevent inf recursion

			bool isOld = PreserveTypeRefRids && mod.ResolveTypeRef(tr.Rid) == tr;
			var row = isOld ? tablesHeap.TypeRefTable[tr.Rid] : new RawTypeRefRow();
			row.ResolutionScope = AddResolutionScope(tr.ResolutionScope);
			row.Name = stringsHeap.Add(tr.Name);
			row.Namespace = stringsHeap.Add(tr.Namespace);

			rid = isOld ? tr.Rid : tablesHeap.TypeRefTable.Add(row);
			typeRefInfos.SetRid(tr, rid);
			AddCustomAttributes(Table.TypeRef, rid, tr);
			AddCustomDebugInformationList(Table.TypeRef, rid, tr);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddTypeSpec(TypeSpec ts) {
			return AddTypeSpec(ts, false);
		}

		uint AddTypeSpec(TypeSpec ts, bool forceIsOld) {
			if (ts == null) {
				Error("TypeSpec is null");
				return 0;
			}
			uint rid;
			if (typeSpecInfos.TryGetRid(ts, out rid)) {
				if (rid == 0)
					Error("TypeSpec {0:X8} has an infinite TypeSig loop", ts.MDToken.Raw);
				return rid;
			}
			typeSpecInfos.Add(ts, 0);	// Prevent inf recursion

			bool isOld = forceIsOld || (PreserveTypeSpecRids && mod.ResolveTypeSpec(ts.Rid) == ts);
			var row = isOld ? tablesHeap.TypeSpecTable[ts.Rid] : new RawTypeSpecRow();
			row.Signature = GetSignature(ts.TypeSig, ts.ExtraData);

			rid = isOld ? ts.Rid : tablesHeap.TypeSpecTable.Add(row);
			typeSpecInfos.SetRid(ts, rid);
			AddCustomAttributes(Table.TypeSpec, rid, ts);
			AddCustomDebugInformationList(Table.TypeSpec, rid, ts);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddMemberRef(MemberRef mr) {
			return AddMemberRef(mr, false);
		}

		uint AddMemberRef(MemberRef mr, bool forceIsOld) {
			if (mr == null) {
				Error("MemberRef is null");
				return 0;
			}
			uint rid;
			if (memberRefInfos.TryGetRid(mr, out rid))
				return rid;

			bool isOld = forceIsOld || (PreserveMemberRefRids && mod.ResolveMemberRef(mr.Rid) == mr);
			var row = isOld ? tablesHeap.MemberRefTable[mr.Rid] : new RawMemberRefRow();
			row.Class = AddMemberRefParent(mr.Class);
			row.Name = stringsHeap.Add(mr.Name);
			row.Signature = GetSignature(mr.Signature);

			rid = isOld ? mr.Rid : tablesHeap.MemberRefTable.Add(row);
			memberRefInfos.Add(mr, rid);
			AddCustomAttributes(Table.MemberRef, rid, mr);
			AddCustomDebugInformationList(Table.MemberRef, rid, mr);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddStandAloneSig(StandAloneSig sas) {
			return AddStandAloneSig(sas, false);
		}

		uint AddStandAloneSig(StandAloneSig sas, bool forceIsOld) {
			if (sas == null) {
				Error("StandAloneSig is null");
				return 0;
			}
			uint rid;
			if (standAloneSigInfos.TryGetRid(sas, out rid))
				return rid;

			bool isOld = forceIsOld || (PreserveStandAloneSigRids && mod.ResolveStandAloneSig(sas.Rid) == sas);
			var row = isOld ? tablesHeap.StandAloneSigTable[sas.Rid] : new RawStandAloneSigRow();
			row.Signature = GetSignature(sas.Signature);

			rid = isOld ? sas.Rid : tablesHeap.StandAloneSigTable.Add(row);
			standAloneSigInfos.Add(sas, rid);
			AddCustomAttributes(Table.StandAloneSig, rid, sas);
			AddCustomDebugInformationList(Table.StandAloneSig, rid, sas);
			return rid;
		}

		/// <inheritdoc/>
		public override MDToken GetToken(IList<TypeSig> locals, uint origToken) {
			if (!PreserveStandAloneSigRids || !IsValidStandAloneSigToken(origToken))
				return base.GetToken(locals, origToken);

			uint rid = AddStandAloneSig(new LocalSig(locals, false), origToken);
			if (rid == 0)
				return base.GetToken(locals, origToken);
			return new MDToken(Table.StandAloneSig, rid);
		}

		/// <inheritdoc/>
		protected override uint AddStandAloneSig(MethodSig methodSig, uint origToken) {
			if (!PreserveStandAloneSigRids || !IsValidStandAloneSigToken(origToken))
				return base.AddStandAloneSig(methodSig, origToken);

			uint rid = AddStandAloneSig(methodSig, origToken);
			if (rid == 0)
				return base.AddStandAloneSig(methodSig, origToken);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddStandAloneSig(FieldSig fieldSig, uint origToken) {
			if (!PreserveStandAloneSigRids || !IsValidStandAloneSigToken(origToken))
				return base.AddStandAloneSig(fieldSig, origToken);

			uint rid = AddStandAloneSig(fieldSig, origToken);
			if (rid == 0)
				return base.AddStandAloneSig(fieldSig, origToken);
			return rid;
		}

		uint AddStandAloneSig(CallingConventionSig callConvSig, uint origToken) {
			uint sig = GetSignature(callConvSig);
			uint otherSig;
			if (callConvTokenToSignature.TryGetValue(origToken, out otherSig)) {
				if (sig == otherSig)
					return MDToken.ToRID(origToken);
				Warning("Could not preserve StandAloneSig token {0:X8}", origToken);
				return 0;
			}

			uint rid = MDToken.ToRID(origToken);
			var sas = mod.ResolveStandAloneSig(rid);
			if (standAloneSigInfos.Exists(sas)) {
				Warning("StandAloneSig {0:X8} already exists", origToken);
				return 0;
			}

			// Make sure it uses the updated sig
			var oldSig = sas.Signature;
			try {
				sas.Signature = callConvSig;
				AddStandAloneSig(sas, true);
			}
			finally {
				sas.Signature = oldSig;
			}

			callConvTokenToSignature.Add(origToken, sig);
			return MDToken.ToRID(origToken);
		}

		bool IsValidStandAloneSigToken(uint token) {
			if (MDToken.ToTable(token) != Table.StandAloneSig)
				return false;
			uint rid = MDToken.ToRID(token);
			return mod.TablesStream.StandAloneSigTable.IsValidRID(rid);
		}

		/// <inheritdoc/>
		protected override uint AddMethodSpec(MethodSpec ms) {
			return AddMethodSpec(ms, false);
		}

		uint AddMethodSpec(MethodSpec ms, bool forceIsOld) {
			if (ms == null) {
				Error("MethodSpec is null");
				return 0;
			}
			uint rid;
			if (methodSpecInfos.TryGetRid(ms, out rid))
				return rid;

			bool isOld = forceIsOld || (PreserveMethodSpecRids && mod.ResolveMethodSpec(ms.Rid) == ms);
			var row = isOld ? tablesHeap.MethodSpecTable[ms.Rid] : new RawMethodSpecRow();
			row.Method = AddMethodDefOrRef(ms.Method);
			row.Instantiation = GetSignature(ms.Instantiation);

			rid = isOld ? ms.Rid : tablesHeap.MethodSpecTable.Add(row);
			methodSpecInfos.Add(ms, rid);
			AddCustomAttributes(Table.MethodSpec, rid, ms);
			AddCustomDebugInformationList(Table.MethodSpec, rid, ms);
			return rid;
		}

		/// <inheritdoc/>
		protected override void BeforeSortingCustomAttributes() {
			InitializeUninitializedTableRows();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/RelocDirectory.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Relocations directory
	/// </summary>
	public sealed class RelocDirectory : IChunk {
		readonly Machine machine;
		readonly List<RelocInfo> allRelocRvas = new List<RelocInfo>();
		readonly List<List<uint>> relocSections = new List<List<uint>>();
		bool isReadOnly;
		FileOffset offset;
		RVA rva;
		uint totalSize;

		struct RelocInfo {
			public readonly IChunk Chunk;
			public readonly uint OffsetOrRva;
			public RelocInfo(IChunk chunk, uint offset) {
				Chunk = chunk;
				OffsetOrRva = offset;
			}
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		internal bool NeedsRelocSection {
			get { return allRelocRvas.Count != 0; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="machine">Machine</param>
		public RelocDirectory(Machine machine) {
			this.machine = machine;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			isReadOnly = true;
			this.offset = offset;
			this.rva = rva;

			var allRvas = new List<uint>(allRelocRvas.Count);
			foreach (var info in allRelocRvas) {
				uint relocRva;
				if (info.Chunk != null)
					relocRva = (uint)info.Chunk.RVA + info.OffsetOrRva;
				else
					relocRva = info.OffsetOrRva;
				allRvas.Add(relocRva);
			}
			allRvas.Sort();

			uint prevPage = uint.MaxValue;
			List<uint> pageList = null;
			foreach (var relocRva in allRvas) {
				uint page = relocRva & ~0xFFFU;
				if (page != prevPage) {
					prevPage = page;
					if (pageList != null)
						totalSize += (uint)(8 + ((pageList.Count + 1) & ~1) * 2);
					pageList = new List<uint>();
					relocSections.Add(pageList);
				}
				pageList.Add(relocRva);
			}
			if (pageList != null)
				totalSize += (uint)(8 + ((pageList.Count + 1) & ~1) * 2);
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return totalSize;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			bool is64bit = machine == Machine.AMD64 || machine == Machine.IA64 || machine == Machine.ARM64;
			// 3 = IMAGE_REL_BASED_HIGHLOW, A = IMAGE_REL_BASED_DIR64
			uint relocType = is64bit ? 0xA000U : 0x3000;
			foreach (var pageList in relocSections) {
				writer.Write(pageList[0] & ~0xFFFU);
				writer.Write((uint)(8 + ((pageList.Count + 1) & ~1) * 2));
				foreach (var rva in pageList)
					writer.Write((ushort)(relocType | (rva & 0xFFF)));
				if ((pageList.Count & 1) != 0)
					writer.Write((ushort)0);
			}
		}

		/// <summary>
		/// Adds a relocation
		/// </summary>
		/// <param name="rva">RVA of location</param>
		public void Add(RVA rva) {
			if (isReadOnly)
				throw new InvalidOperationException("Can't add a relocation when the relocs section is read-only");
			allRelocRvas.Add(new RelocInfo(null, (uint)rva));
		}

		/// <summary>
		/// Adds a relocation
		/// </summary>
		/// <param name="chunk">Chunk or null. If it's null, <paramref name="offset"/> is the RVA</param>
		/// <param name="offset">Offset relative to the start of <paramref name="chunk"/>, or if <paramref name="chunk"/> is null, this is the RVA</param>
		public void Add(IChunk chunk, uint offset) {
			if (isReadOnly)
				throw new InvalidOperationException("Can't add a relocation when the relocs section is read-only");
			allRelocRvas.Add(new RelocInfo(chunk, offset));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/SectionSizes.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Collections.Generic;
using dnlib.Utils;

namespace dnlib.DotNet.Writer {
	struct SectionSizeInfo {
		/// <summary>
		/// Length of section
		/// </summary>
		public readonly uint length;

		/// <summary>
		/// Section characteristics
		/// </summary>
		public readonly uint characteristics;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Length of section</param>
		/// <param name="characteristics">Section characteristics</param>
		public SectionSizeInfo(uint length, uint characteristics) {
			this.length = length;
			this.characteristics = characteristics;
		}
	}

	/// <summary>
	/// Calculates the optional header section sizes
	/// </summary>
	struct SectionSizes {
		public readonly uint SizeOfHeaders;
		public readonly uint SizeOfImage;
		public readonly uint BaseOfData, BaseOfCode;
		public readonly uint SizeOfCode, SizeOfInitdData, SizeOfUninitdData;

		public SectionSizes(uint fileAlignment, uint sectionAlignment, uint headerLen, MFunc<IEnumerable<SectionSizeInfo>> getSectionSizeInfos) {
			SizeOfHeaders = Utils.AlignUp(headerLen, fileAlignment);
			SizeOfImage = Utils.AlignUp(SizeOfHeaders, sectionAlignment);
			BaseOfData = 0;
			BaseOfCode = 0;
			SizeOfCode = 0;
			SizeOfInitdData = 0;
			SizeOfUninitdData = 0;
			foreach (var section in getSectionSizeInfos()) {
				uint sectAlignedVs = Utils.AlignUp(section.length, sectionAlignment);
				uint fileAlignedVs = Utils.AlignUp(section.length, fileAlignment);

				bool isCode = (section.characteristics & 0x20) != 0;
				bool isInitdData = (section.characteristics & 0x40) != 0;
				bool isUnInitdData = (section.characteristics & 0x80) != 0;

				if (BaseOfCode == 0 && isCode)
					BaseOfCode = SizeOfImage;
				if (BaseOfData == 0 && (isInitdData || isUnInitdData))
					BaseOfData = SizeOfImage;
				if (isCode)
					SizeOfCode += fileAlignedVs;
				if (isInitdData)
					SizeOfInitdData += fileAlignedVs;
				if (isUnInitdData)
					SizeOfUninitdData += fileAlignedVs;

				SizeOfImage += sectAlignedVs;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/SerializerMethodContext.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet.Emit;

namespace dnlib.DotNet.Writer {
	sealed class SerializerMethodContext {
		readonly Dictionary<Instruction, uint> toOffset;
		readonly IWriterError helper;
		MethodDef method;
		CilBody body;
		uint bodySize;
		bool dictInitd;

		public bool HasBody {
			get { return body != null; }
		}

		public SerializerMethodContext(IWriterError helper) {
			toOffset = new Dictionary<Instruction, uint>();
			this.helper = helper;
		}

		internal void SetBody(MethodDef method) {
			if (this.method != method) {
				toOffset.Clear();
				this.method = method;
				this.body = method == null ? null : method.Body;
				dictInitd = false;
			}
		}

		public uint GetOffset(Instruction instr) {
			if (!dictInitd) {
				Debug.Assert(body != null);
				if (body == null)
					return 0;
				InitializeDict();
			}
			if (instr == null)
				return bodySize;
			uint offset;
			if (toOffset.TryGetValue(instr, out offset))
				return offset;
			helper.Error("Couldn't find an instruction, maybe it was removed. It's still being referenced by some code or by the PDB");
			return bodySize;
		}

		public bool IsSameMethod(MethodDef method) {
			return this.method == method;
		}

		void InitializeDict() {
			Debug.Assert(body != null);
			Debug.Assert(toOffset.Count == 0);
			uint offset = 0;
			var instrs = body.Instructions;
			for(int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				toOffset[instr] = offset;
				offset += (uint)instr.GetSize();
			}
			bodySize = offset;
			dictInitd = true;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/SignatureWriter.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.IO;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Helps <see cref="SignatureWriter"/> map <see cref="ITypeDefOrRef"/>s to tokens
	/// </summary>
	public interface ISignatureWriterHelper : IWriterError {
		/// <summary>
		/// Returns a <c>TypeDefOrRef</c> encoded token
		/// </summary>
		/// <param name="typeDefOrRef">A <c>TypeDefOrRef</c> type</param>
		uint ToEncodedToken(ITypeDefOrRef typeDefOrRef);
	}

	/// <summary>
	/// Writes signatures
	/// </summary>
	public struct SignatureWriter : IDisposable {
		readonly ISignatureWriterHelper helper;
		RecursionCounter recursionCounter;
		readonly MemoryStream outStream;
		readonly BinaryWriter writer;
		readonly bool disposeStream;

		/// <summary>
		/// Write a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Helper</param>
		/// <param name="typeSig">The type</param>
		/// <returns>The signature as a byte array</returns>
		public static byte[] Write(ISignatureWriterHelper helper, TypeSig typeSig) {
			using (var writer = new SignatureWriter(helper)) {
				writer.Write(typeSig);
				return writer.GetResult();
			}
		}

		internal static byte[] Write(ISignatureWriterHelper helper, TypeSig typeSig, BinaryWriterContext context) {
			using (var writer = new SignatureWriter(helper, context)) {
				writer.Write(typeSig);
				return writer.GetResult();
			}
		}

		/// <summary>
		/// Write a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Helper</param>
		/// <param name="sig">The signature</param>
		/// <returns>The signature as a byte array</returns>
		public static byte[] Write(ISignatureWriterHelper helper, CallingConventionSig sig) {
			using (var writer = new SignatureWriter(helper)) {
				writer.Write(sig);
				return writer.GetResult();
			}
		}

		internal static byte[] Write(ISignatureWriterHelper helper, CallingConventionSig sig, BinaryWriterContext context) {
			using (var writer = new SignatureWriter(helper, context)) {
				writer.Write(sig);
				return writer.GetResult();
			}
		}

		SignatureWriter(ISignatureWriterHelper helper) {
			this.helper = helper;
			this.recursionCounter = new RecursionCounter();
			this.outStream = new MemoryStream();
			this.writer = new BinaryWriter(outStream);
			this.disposeStream = true;
		}

		SignatureWriter(ISignatureWriterHelper helper, BinaryWriterContext context) {
			this.helper = helper;
			this.recursionCounter = new RecursionCounter();
			this.outStream = context.OutStream;
			this.writer = context.Writer;
			this.disposeStream = false;
			outStream.SetLength(0);
			outStream.Position = 0;
		}

		byte[] GetResult() {
			return outStream.ToArray();
		}

		uint WriteCompressedUInt32(uint value) {
			return writer.WriteCompressedUInt32(helper, value);
		}

		int WriteCompressedInt32(int value) {
			return writer.WriteCompressedInt32(helper, value);
		}

		void Write(TypeSig typeSig) {
			const ElementType DEFAULT_ELEMENT_TYPE = ElementType.Boolean;
			if (typeSig == null) {
				helper.Error("TypeSig is null");
				writer.Write((byte)DEFAULT_ELEMENT_TYPE);
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				writer.Write((byte)DEFAULT_ELEMENT_TYPE);
				return;
			}

			uint count;
			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.Sentinel:
				writer.Write((byte)typeSig.ElementType);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.SZArray:
			case ElementType.Pinned:
				writer.Write((byte)typeSig.ElementType);
				Write(typeSig.Next);
				break;

			case ElementType.ValueType:
			case ElementType.Class:
				writer.Write((byte)typeSig.ElementType);
				Write(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
				writer.Write((byte)typeSig.ElementType);
				WriteCompressedUInt32(((GenericSig)typeSig).Number);
				break;

			case ElementType.Array:
				writer.Write((byte)typeSig.ElementType);
				var ary = (ArraySig)typeSig;
				Write(ary.Next);
				WriteCompressedUInt32(ary.Rank);
				if (ary.Rank == 0)
					break;
				count = WriteCompressedUInt32((uint)ary.Sizes.Count);
				for (uint i = 0; i < count; i++)
					WriteCompressedUInt32(ary.Sizes[(int)i]);
				count = WriteCompressedUInt32((uint)ary.LowerBounds.Count);
				for (uint i = 0; i < count; i++)
					WriteCompressedInt32(ary.LowerBounds[(int)i]);
				break;

			case ElementType.GenericInst:
				writer.Write((byte)typeSig.ElementType);
				var gis = (GenericInstSig)typeSig;
				Write(gis.GenericType);
				count = WriteCompressedUInt32((uint)gis.GenericArguments.Count);
				for (uint i = 0; i < count; i++)
					Write(gis.GenericArguments[(int)i]);
				break;

			case ElementType.ValueArray:
				writer.Write((byte)typeSig.ElementType);
				Write(typeSig.Next);
				WriteCompressedUInt32((typeSig as ValueArraySig).Size);
				break;

			case ElementType.FnPtr:
				writer.Write((byte)typeSig.ElementType);
				Write((typeSig as FnPtrSig).Signature);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				writer.Write((byte)typeSig.ElementType);
				Write((typeSig as ModifierSig).Modifier);
				Write(typeSig.Next);
				break;

			case ElementType.Module:
				writer.Write((byte)typeSig.ElementType);
				WriteCompressedUInt32((typeSig as ModuleSig).Index);
				Write(typeSig.Next);
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				helper.Error("Unknown or unsupported element type");
				writer.Write((byte)DEFAULT_ELEMENT_TYPE);
				break;
			}

			recursionCounter.Decrement();
		}

		void Write(ITypeDefOrRef tdr) {
			if (tdr == null) {
				helper.Error("TypeDefOrRef is null");
				WriteCompressedUInt32(0);
				return;
			}

			uint encodedToken = helper.ToEncodedToken(tdr);
			if (encodedToken > 0x1FFFFFFF) {
				helper.Error("Encoded token doesn't fit in 29 bits");
				encodedToken = 0;
			}
			WriteCompressedUInt32(encodedToken);
		}

		void Write(CallingConventionSig sig) {
			if (sig == null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			MethodBaseSig mbs;
			FieldSig fs;
			LocalSig ls;
			GenericInstMethodSig gim;

			if ((mbs = sig as MethodBaseSig) != null)
				Write(mbs);
			else if ((fs = sig as FieldSig) != null)
				Write(fs);
			else if ((ls = sig as LocalSig) != null)
				Write(ls);
			else if ((gim = sig as GenericInstMethodSig) != null)
				Write(gim);
			else {
				helper.Error("Unknown calling convention sig");
				writer.Write((byte)sig.GetCallingConvention());
			}

			recursionCounter.Decrement();
		}

		void Write(MethodBaseSig sig) {
			if (sig == null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			writer.Write((byte)sig.GetCallingConvention());
			if (sig.Generic)
				WriteCompressedUInt32(sig.GenParamCount);

			uint numParams = (uint)sig.Params.Count;
			if (sig.ParamsAfterSentinel != null)
				numParams += (uint)sig.ParamsAfterSentinel.Count;

			uint count = WriteCompressedUInt32(numParams);
			Write(sig.RetType);
			for (uint i = 0; i < count && i < (uint)sig.Params.Count; i++)
				Write(sig.Params[(int)i]);

			if (sig.ParamsAfterSentinel != null && sig.ParamsAfterSentinel.Count > 0) {
				writer.Write((byte)ElementType.Sentinel);
				for (uint i = 0, j = (uint)sig.Params.Count; i < (uint)sig.ParamsAfterSentinel.Count && j < count; i++, j++)
					Write(sig.ParamsAfterSentinel[(int)i]);
			}

			recursionCounter.Decrement();
		}

		void Write(FieldSig sig) {
			if (sig == null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			writer.Write((byte)sig.GetCallingConvention());
			Write(sig.Type);

			recursionCounter.Decrement();
		}

		void Write(LocalSig sig) {
			if (sig == null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			writer.Write((byte)sig.GetCallingConvention());
			uint count = WriteCompressedUInt32((uint)sig.Locals.Count);
			if (count >= 0x10000) {
				// ldloc 0xFFFF is invalid, see the ldloc documentation
				helper.Error("Too many locals, max number of locals is 65535 (0xFFFF)");
			}
			for (uint i = 0; i < count; i++)
				Write(sig.Locals[(int)i]);

			recursionCounter.Decrement();
		}

		void Write(GenericInstMethodSig sig) {
			if (sig == null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			writer.Write((byte)sig.GetCallingConvention());
			uint count = WriteCompressedUInt32((uint)sig.GenericArguments.Count);
			for (uint i = 0; i < count; i++)
				Write(sig.GenericArguments[(int)i]);

			recursionCounter.Decrement();
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (!disposeStream)
				return;
			if (outStream != null)
				outStream.Dispose();
			if (writer != null)
				((IDisposable)writer).Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/StartupStub.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Stores the instruction that jumps to _CorExeMain/_CorDllMain
	/// </summary>
	public sealed class StartupStub : IChunk {
		const StubType stubType = StubType.EntryPoint;
		readonly RelocDirectory relocDirectory;
		readonly Machine machine;
		readonly CpuArch cpuArch;
		readonly LogError logError;
		FileOffset offset;
		RVA rva;

		/// <summary>
		/// Gets/sets the <see cref="ImportDirectory"/>
		/// </summary>
		public ImportDirectory ImportDirectory { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="PEHeaders"/>
		/// </summary>
		public PEHeaders PEHeaders { get; set; }

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Gets the address of the JMP instruction
		/// </summary>
		public RVA EntryPointRVA {
			get { return rva + (cpuArch == null ? 0 : cpuArch.GetStubCodeOffset(stubType)); }
		}

		internal bool Enable { get; set; }

		internal uint Alignment {
			get { return cpuArch == null ? 1 : cpuArch.GetStubAlignment(stubType); }
		}

		internal delegate void LogError(string format, params object[] args);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="relocDirectory">Reloc directory</param>
		/// <param name="machine">Machine</param>
		/// <param name="logError">Error logger</param>
		internal StartupStub(RelocDirectory relocDirectory, Machine machine, LogError logError) {
			this.relocDirectory = relocDirectory;
			this.machine = machine;
			this.logError = logError;
			CpuArch.TryGetCpuArch(machine, out cpuArch);
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			if (!Enable)
				return;

			if (cpuArch == null) {
				logError("The module needs an unmanaged entry point but the CPU architecture isn't supported: {0} (0x{1:X4})", machine, (ushort)machine);
				return;
			}

			cpuArch.WriteStubRelocs(stubType, relocDirectory, this, 0);
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			if (!Enable)
				return 0;
			if (cpuArch == null)
				return 0;
			return cpuArch.GetStubSize(stubType);
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			if (!Enable)
				return;
			if (cpuArch == null)
				return;
			cpuArch.WriteStub(stubType, writer, PEHeaders.ImageBase, (uint)rva, (uint)ImportDirectory.IatCorXxxMainRVA);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/StringsHeap.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.DotNet.MD;
using System.Diagnostics;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #Strings heap
	/// </summary>
	public sealed class StringsHeap : HeapBase, IOffsetHeap<UTF8String> {
		readonly Dictionary<UTF8String, uint> cachedDict = new Dictionary<UTF8String, uint>(UTF8StringEqualityComparer.Instance);
		readonly List<UTF8String> cached = new List<UTF8String>();
		uint nextOffset = 1;
		byte[] originalData;
		Dictionary<uint, byte[]> userRawData;
		readonly Dictionary<UTF8String, StringsOffsetInfo> toStringsOffsetInfo = new Dictionary<UTF8String, StringsOffsetInfo>(UTF8StringEqualityComparer.Instance);
		readonly Dictionary<uint, StringsOffsetInfo> offsetIdToInfo = new Dictionary<uint, StringsOffsetInfo>();
		readonly List<StringsOffsetInfo> stringsOffsetInfos = new List<StringsOffsetInfo>();
		const uint STRINGS_ID_FLAG = 0x80000000;
		uint stringsId = STRINGS_ID_FLAG | 0;

		sealed class StringsOffsetInfo {
			public StringsOffsetInfo(UTF8String value, uint stringsId) {
				Value = value;
				StringsId = stringsId;
				Debug.Assert((stringsId & STRINGS_ID_FLAG) != 0);
			}
			public readonly UTF8String Value;
			public readonly uint StringsId;
			public uint StringsOffset;
			public override string ToString() {
				return string.Format("{0:X8} {1:X4} {2}", StringsId, StringsOffset, Value.String);
			}
		}

		/// <inheritdoc/>
		public override string Name {
			get { return "#Strings"; }
		}

		/// <summary>
		/// Populates strings from an existing <see cref="StringsStream"/> (eg. to preserve
		/// string offsets)
		/// </summary>
		/// <param name="stringsStream">The #Strings stream with the original content</param>
		public void Populate(StringsStream stringsStream) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Strings when it's read-only");
			if (originalData != null)
				throw new InvalidOperationException("Can't call method twice");
			if (nextOffset != 1)
				throw new InvalidOperationException("Add() has already been called");
			if (stringsStream == null || stringsStream.ImageStreamLength == 0)
				return;

			using (var reader = stringsStream.GetClonedImageStream()) {
				originalData = reader.ReadAllBytes();
				nextOffset = (uint)originalData.Length;
				Populate(reader);
			}
		}

		void Populate(IImageStream reader) {
			reader.Position = 1;
			while (reader.Position < reader.Length) {
				uint offset = (uint)reader.Position;
				var bytes = reader.ReadBytesUntilByte(0);
				if (bytes == null)
					break;

				reader.ReadByte();	// terminating zero
				if (bytes.Length == 0)
					continue;

				var s = new UTF8String(bytes);
				if (!cachedDict.ContainsKey(s))
					cachedDict[s] = offset;
			}
		}

		internal void AddOptimizedStrings() {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Strings when it's read-only");

			stringsOffsetInfos.Sort(Comparison_StringsOffsetInfoSorter);

			StringsOffsetInfo prevInfo = null;
			foreach (var info in stringsOffsetInfos) {
				if (prevInfo != null && EndsWith(prevInfo.Value, info.Value))
					info.StringsOffset = prevInfo.StringsOffset + (uint)(prevInfo.Value.Data.Length - info.Value.Data.Length);
				else
					info.StringsOffset = AddToCache(info.Value);
				prevInfo = info;
			}
		}

		static bool EndsWith(UTF8String s, UTF8String value) {
			var d = s.Data;
			var vd = value.Data;
			int i = d.Length - vd.Length;
			if (i < 0)
				return false;
			for (int vi = 0; vi < vd.Length; vi++) {
				if (d[i] != vd[vi])
					return false;
				i++;
			}
			return true;
		}

		static readonly Comparison<StringsOffsetInfo> Comparison_StringsOffsetInfoSorter = StringsOffsetInfoSorter;
		static int StringsOffsetInfoSorter(StringsOffsetInfo a, StringsOffsetInfo b) {
			var da = a.Value.Data;
			var db = b.Value.Data;
			int ai = da.Length - 1;
			int bi = db.Length - 1;
			int len = Math.Min(da.Length, db.Length);
			while (len > 0) {
				int c = da[ai] - db[bi];
				if (c != 0)
					return c;
				ai--;
				bi--;
				len--;
			}
			return db.Length - da.Length;
		}

		/// <summary>
		/// Adds a string to the #Strings heap. The returned value is not necessarily an offset in
		/// the #Strings heap. Call <see cref="GetOffset(uint)"/> to get the offset.
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>The offset id. This is not a #Strings offset. Call <see cref="GetOffset(uint)"/> to get the #Strings offset</returns>
		public uint Add(UTF8String s) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Strings when it's read-only");
			if (UTF8String.IsNullOrEmpty(s))
				return 0;

			StringsOffsetInfo info;
			if (toStringsOffsetInfo.TryGetValue(s, out info))
				return info.StringsId;
			uint offset;
			if (cachedDict.TryGetValue(s, out offset))
				return offset;

			if (Array.IndexOf(s.Data, (byte)0) >= 0)
				throw new ArgumentException("Strings in the #Strings heap can't contain NUL bytes");
			info = new StringsOffsetInfo(s, stringsId++);
			Debug.Assert(!toStringsOffsetInfo.ContainsKey(s));
			Debug.Assert(!offsetIdToInfo.ContainsKey(info.StringsId));
			toStringsOffsetInfo[s] = info;
			offsetIdToInfo[info.StringsId] = info;
			stringsOffsetInfos.Add(info);
			return info.StringsId;
		}

		/// <summary>
		/// Gets the offset of a string in the #Strings heap. This method can only be called after
		/// all strings have been added.
		/// </summary>
		/// <param name="offsetId">Offset id returned by <see cref="Add(UTF8String)"/></param>
		/// <returns></returns>
		public uint GetOffset(uint offsetId) {
			if (!isReadOnly)
				throw new ModuleWriterException("This method can only be called after all strings have been added and this heap is read-only");
			if ((offsetId & STRINGS_ID_FLAG) == 0)
				return offsetId;
			StringsOffsetInfo info;
			if (offsetIdToInfo.TryGetValue(offsetId, out info)) {
				Debug.Assert(info.StringsOffset != 0);
				return info.StringsOffset;
			}
			throw new ArgumentOutOfRangeException("offsetId");
		}

		/// <summary>
		/// Adds a string to the #Strings heap, but does not re-use an existing position
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>The offset of the string in the #Strings heap</returns>
		public uint Create(UTF8String s) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Strings when it's read-only");
			if (UTF8String.IsNullOrEmpty(s))
				s = UTF8String.Empty;
			if (Array.IndexOf(s.Data, (byte)0) >= 0)
				throw new ArgumentException("Strings in the #Strings heap can't contain NUL bytes");
			return AddToCache(s);
		}

		uint AddToCache(UTF8String s) {
			uint offset;
			cached.Add(s);
			cachedDict[s] = offset = nextOffset;
			nextOffset += (uint)s.Data.Length + 1;
			return offset;
		}

		/// <inheritdoc/>
		public override uint GetRawLength() {
			return nextOffset;
		}

		/// <inheritdoc/>
		protected override void WriteToImpl(BinaryWriter writer) {
			if (originalData != null)
				writer.Write(originalData);
			else
				writer.Write((byte)0);

			uint offset = originalData != null ? (uint)originalData.Length : 1;
			foreach (var s in cached) {
				byte[] rawData;
				if (userRawData != null && userRawData.TryGetValue(offset, out rawData)) {
					if (rawData.Length != s.Data.Length + 1)
						throw new InvalidOperationException("Invalid length of raw data");
					writer.Write(rawData);
				}
				else {
					writer.Write(s.Data);
					writer.Write((byte)0);
				}
				offset += (uint)s.Data.Length + 1;
			}
		}

		/// <inheritdoc/>
		public int GetRawDataSize(UTF8String data) {
			return data.Data.Length + 1;
		}

		/// <inheritdoc/>
		public void SetRawData(uint offset, byte[] rawData) {
			if (rawData == null)
				throw new ArgumentNullException("rawData");
			if (userRawData == null)
				userRawData = new Dictionary<uint, byte[]>();
			userRawData[offset] = rawData;
		}

		/// <inheritdoc/>
		public IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData() {
			uint offset = originalData != null ? (uint)originalData.Length : 1;
			foreach (var s in cached) {
				var rawData = new byte[s.Data.Length + 1];
				Array.Copy(s.Data, rawData, s.Data.Length);
				yield return new KeyValuePair<uint, byte[]>(offset, rawData);
				offset += (uint)rawData.Length;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/StrongNameSignature.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Strong name signature chunk
	/// </summary>
	public sealed class StrongNameSignature : IChunk {
		FileOffset offset;
		RVA rva;
		int size;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="size">Size of strong name signature</param>
		public StrongNameSignature(int size) {
			this.size = size;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return (uint)this.size;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			writer.WriteZeros(size);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/TablesHeap.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.IO;
using dnlib.IO;
using dnlib.PE;
using dnlib.DotNet.MD;
using System;
using System.Collections.Generic;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="TablesHeap"/> options
	/// </summary>
	public sealed class TablesHeapOptions {
		/// <summary>
		/// Should be 0
		/// </summary>
		public uint? Reserved1;

		/// <summary>
		/// Major version number. Default is 2. Valid versions are v1.0 (no generics),
		/// v1.1 (generics are supported), or v2.0 (recommended).
		/// </summary>
		public byte? MajorVersion;

		/// <summary>
		/// Minor version number. Default is 0.
		/// </summary>
		public byte? MinorVersion;

		/// <summary>
		/// Force #- or #~ stream. Default value is <c>null</c> and recommended because the correct
		/// tables stream will be used. <c>true</c> will force <c>#-</c> (Edit N' Continue)
		/// stream, and <c>false</c> will force <c>#~</c> (normal compressed) stream.
		/// </summary>
		public bool? UseENC;

		/// <summary>
		/// Extra data to write
		/// </summary>
		public uint? ExtraData;

		/// <summary>
		/// <c>true</c> if there are deleted <see cref="TypeDef"/>s, <see cref="ExportedType"/>s,
		/// <see cref="FieldDef"/>s, <see cref="MethodDef"/>s, <see cref="EventDef"/>s and/or
		/// <see cref="PropertyDef"/>s.
		/// </summary>
		public bool? HasDeletedRows;

		/// <summary>
		/// Creates portable PDB v1.0 options
		/// </summary>
		/// <returns></returns>
		public static TablesHeapOptions CreatePortablePdbV1_0() {
			return new TablesHeapOptions {
				Reserved1 = 0,
				MajorVersion = 2,
				MinorVersion = 0,
				UseENC = null,
				ExtraData = null,
				HasDeletedRows = null,
			};
		}
	}

	/// <summary>
	/// Contains all .NET tables
	/// </summary>
	public sealed class TablesHeap : IHeap {
		uint length;
		byte majorVersion;
		byte minorVersion;
		bool bigStrings;
		bool bigGuid;
		bool bigBlob;
		bool hasDeletedRows;
		readonly MetaData metadata;
		readonly TablesHeapOptions options;
		FileOffset offset;
		RVA rva;

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

#pragma warning disable 1591	// XML doc comment
		public readonly MDTable<RawModuleRow> ModuleTable = new MDTable<RawModuleRow>(Table.Module, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawTypeRefRow> TypeRefTable = new MDTable<RawTypeRefRow>(Table.TypeRef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawTypeDefRow> TypeDefTable = new MDTable<RawTypeDefRow>(Table.TypeDef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldPtrRow> FieldPtrTable = new MDTable<RawFieldPtrRow>(Table.FieldPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldRow> FieldTable = new MDTable<RawFieldRow>(Table.Field, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodPtrRow> MethodPtrTable = new MDTable<RawMethodPtrRow>(Table.MethodPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodRow> MethodTable = new MDTable<RawMethodRow>(Table.Method, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawParamPtrRow> ParamPtrTable = new MDTable<RawParamPtrRow>(Table.ParamPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawParamRow> ParamTable = new MDTable<RawParamRow>(Table.Param, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawInterfaceImplRow> InterfaceImplTable = new MDTable<RawInterfaceImplRow>(Table.InterfaceImpl, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMemberRefRow> MemberRefTable = new MDTable<RawMemberRefRow>(Table.MemberRef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawConstantRow> ConstantTable = new MDTable<RawConstantRow>(Table.Constant, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawCustomAttributeRow> CustomAttributeTable = new MDTable<RawCustomAttributeRow>(Table.CustomAttribute, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldMarshalRow> FieldMarshalTable = new MDTable<RawFieldMarshalRow>(Table.FieldMarshal, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawDeclSecurityRow> DeclSecurityTable = new MDTable<RawDeclSecurityRow>(Table.DeclSecurity, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawClassLayoutRow> ClassLayoutTable = new MDTable<RawClassLayoutRow>(Table.ClassLayout, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldLayoutRow> FieldLayoutTable = new MDTable<RawFieldLayoutRow>(Table.FieldLayout, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawStandAloneSigRow> StandAloneSigTable = new MDTable<RawStandAloneSigRow>(Table.StandAloneSig, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawEventMapRow> EventMapTable = new MDTable<RawEventMapRow>(Table.EventMap, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawEventPtrRow> EventPtrTable = new MDTable<RawEventPtrRow>(Table.EventPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawEventRow> EventTable = new MDTable<RawEventRow>(Table.Event, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawPropertyMapRow> PropertyMapTable = new MDTable<RawPropertyMapRow>(Table.PropertyMap, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawPropertyPtrRow> PropertyPtrTable = new MDTable<RawPropertyPtrRow>(Table.PropertyPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawPropertyRow> PropertyTable = new MDTable<RawPropertyRow>(Table.Property, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodSemanticsRow> MethodSemanticsTable = new MDTable<RawMethodSemanticsRow>(Table.MethodSemantics, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodImplRow> MethodImplTable = new MDTable<RawMethodImplRow>(Table.MethodImpl, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawModuleRefRow> ModuleRefTable = new MDTable<RawModuleRefRow>(Table.ModuleRef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawTypeSpecRow> TypeSpecTable = new MDTable<RawTypeSpecRow>(Table.TypeSpec, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawImplMapRow> ImplMapTable = new MDTable<RawImplMapRow>(Table.ImplMap, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldRVARow> FieldRVATable = new MDTable<RawFieldRVARow>(Table.FieldRVA, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawENCLogRow> ENCLogTable = new MDTable<RawENCLogRow>(Table.ENCLog, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawENCMapRow> ENCMapTable = new MDTable<RawENCMapRow>(Table.ENCMap, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyRow> AssemblyTable = new MDTable<RawAssemblyRow>(Table.Assembly, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyProcessorRow> AssemblyProcessorTable = new MDTable<RawAssemblyProcessorRow>(Table.AssemblyProcessor, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyOSRow> AssemblyOSTable = new MDTable<RawAssemblyOSRow>(Table.AssemblyOS, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyRefRow> AssemblyRefTable = new MDTable<RawAssemblyRefRow>(Table.AssemblyRef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyRefProcessorRow> AssemblyRefProcessorTable = new MDTable<RawAssemblyRefProcessorRow>(Table.AssemblyRefProcessor, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyRefOSRow> AssemblyRefOSTable = new MDTable<RawAssemblyRefOSRow>(Table.AssemblyRefOS, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFileRow> FileTable = new MDTable<RawFileRow>(Table.File, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawExportedTypeRow> ExportedTypeTable = new MDTable<RawExportedTypeRow>(Table.ExportedType, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawManifestResourceRow> ManifestResourceTable = new MDTable<RawManifestResourceRow>(Table.ManifestResource, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawNestedClassRow> NestedClassTable = new MDTable<RawNestedClassRow>(Table.NestedClass, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawGenericParamRow> GenericParamTable = new MDTable<RawGenericParamRow>(Table.GenericParam, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodSpecRow> MethodSpecTable = new MDTable<RawMethodSpecRow>(Table.MethodSpec, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawGenericParamConstraintRow> GenericParamConstraintTable = new MDTable<RawGenericParamConstraintRow>(Table.GenericParamConstraint, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawDocumentRow> DocumentTable = new MDTable<RawDocumentRow>(Table.Document, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodDebugInformationRow> MethodDebugInformationTable = new MDTable<RawMethodDebugInformationRow>(Table.MethodDebugInformation, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawLocalScopeRow> LocalScopeTable = new MDTable<RawLocalScopeRow>(Table.LocalScope, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawLocalVariableRow> LocalVariableTable = new MDTable<RawLocalVariableRow>(Table.LocalVariable, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawLocalConstantRow> LocalConstantTable = new MDTable<RawLocalConstantRow>(Table.LocalConstant, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawImportScopeRow> ImportScopeTable = new MDTable<RawImportScopeRow>(Table.ImportScope, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawStateMachineMethodRow> StateMachineMethodTable = new MDTable<RawStateMachineMethodRow>(Table.StateMachineMethod, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawCustomDebugInformationRow> CustomDebugInformationTable = new MDTable<RawCustomDebugInformationRow>(Table.CustomDebugInformation, RawRowEqualityComparer.Instance);
#pragma warning restore

		/// <summary>
		/// All tables
		/// </summary>
		public readonly IMDTable[] Tables;

		/// <inheritdoc/>
		public string Name {
			get { return IsENC ? "#-" : "#~"; }
		}

		/// <inheritdoc/>
		public bool IsEmpty {
			get { return false; }
		}

		/// <summary>
		/// <c>true</c> if the Edit 'N Continue name will be used (#-)
		/// </summary>
		public bool IsENC {
			get {
				if (options.UseENC.HasValue)
					return options.UseENC.Value;
				return hasDeletedRows ||
						!FieldPtrTable.IsEmpty ||
						!MethodPtrTable.IsEmpty ||
						!ParamPtrTable.IsEmpty ||
						!EventPtrTable.IsEmpty ||
						!PropertyPtrTable.IsEmpty ||
						!(InterfaceImplTable.IsEmpty || InterfaceImplTable.IsSorted) ||
						!(ConstantTable.IsEmpty || ConstantTable.IsSorted) ||
						!(CustomAttributeTable.IsEmpty || CustomAttributeTable.IsSorted) ||
						!(FieldMarshalTable.IsEmpty || FieldMarshalTable.IsSorted) ||
						!(DeclSecurityTable.IsEmpty || DeclSecurityTable.IsSorted) ||
						!(ClassLayoutTable.IsEmpty || ClassLayoutTable.IsSorted) ||
						!(FieldLayoutTable.IsEmpty || FieldLayoutTable.IsSorted) ||
						!(EventMapTable.IsEmpty || EventMapTable.IsSorted) ||
						!(PropertyMapTable.IsEmpty || PropertyMapTable.IsSorted) ||
						!(MethodSemanticsTable.IsEmpty || MethodSemanticsTable.IsSorted) ||
						!(MethodImplTable.IsEmpty || MethodImplTable.IsSorted) ||
						!(ImplMapTable.IsEmpty || ImplMapTable.IsSorted) ||
						!(FieldRVATable.IsEmpty || FieldRVATable.IsSorted) ||
						!(NestedClassTable.IsEmpty || NestedClassTable.IsSorted) ||
						!(GenericParamTable.IsEmpty || GenericParamTable.IsSorted) ||
						!(GenericParamConstraintTable.IsEmpty || GenericParamConstraintTable.IsSorted);
			}
		}

		/// <summary>
		/// <c>true</c> if any rows have been deleted (eg. a deleted TypeDef, Method, Field, etc.
		/// Its name has been renamed to _Deleted).
		/// </summary>
		public bool HasDeletedRows {
			get { return hasDeletedRows; }
			set { hasDeletedRows = value; }
		}

		/// <summary>
		/// <c>true</c> if #Strings heap size > <c>0xFFFF</c>
		/// </summary>
		public bool BigStrings {
			get { return bigStrings; }
			set { bigStrings = value; }
		}

		/// <summary>
		/// <c>true</c> if #GUID heap size > <c>0xFFFF</c>
		/// </summary>
		public bool BigGuid {
			get { return bigGuid; }
			set { bigGuid = value; }
		}

		/// <summary>
		/// <c>true</c> if #Blob heap size > <c>0xFFFF</c>
		/// </summary>
		public bool BigBlob {
			get { return bigBlob; }
			set { bigBlob = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		/// <param name="options">Options</param>
		public TablesHeap(MetaData metadata, TablesHeapOptions options) {
			this.metadata = metadata;
			this.options = options ?? new TablesHeapOptions();
			this.hasDeletedRows = this.options.HasDeletedRows ?? false;
			this.Tables = new IMDTable[] {
				ModuleTable,
				TypeRefTable,
				TypeDefTable,
				FieldPtrTable,
				FieldTable,
				MethodPtrTable,
				MethodTable,
				ParamPtrTable,
				ParamTable,
				InterfaceImplTable,
				MemberRefTable,
				ConstantTable,
				CustomAttributeTable,
				FieldMarshalTable,
				DeclSecurityTable,
				ClassLayoutTable,
				FieldLayoutTable,
				StandAloneSigTable,
				EventMapTable,
				EventPtrTable,
				EventTable,
				PropertyMapTable,
				PropertyPtrTable,
				PropertyTable,
				MethodSemanticsTable,
				MethodImplTable,
				ModuleRefTable,
				TypeSpecTable,
				ImplMapTable,
				FieldRVATable,
				ENCLogTable,
				ENCMapTable,
				AssemblyTable,
				AssemblyProcessorTable,
				AssemblyOSTable,
				AssemblyRefTable,
				AssemblyRefProcessorTable,
				AssemblyRefOSTable,
				FileTable,
				ExportedTypeTable,
				ManifestResourceTable,
				NestedClassTable,
				GenericParamTable,
				MethodSpecTable,
				GenericParamConstraintTable,
				new MDTable<RawDummyRow>((Table)0x2D, RawDummyRow.Comparer),
				new MDTable<RawDummyRow>((Table)0x2E, RawDummyRow.Comparer),
				new MDTable<RawDummyRow>((Table)0x2F, RawDummyRow.Comparer),
				DocumentTable,
				MethodDebugInformationTable,
				LocalScopeTable,
				LocalVariableTable,
				LocalConstantTable,
				ImportScopeTable,
				StateMachineMethodTable,
				CustomDebugInformationTable,
			};
		}

		sealed class RawDummyRow : IRawRow {
			public static readonly IEqualityComparer<RawDummyRow> Comparer = new RawDummyRowEqualityComparer();
			sealed class RawDummyRowEqualityComparer : IEqualityComparer<RawDummyRow> {
				public bool Equals(RawDummyRow x, RawDummyRow y) {
					throw new NotSupportedException();
				}

				public int GetHashCode(RawDummyRow obj) {
					throw new NotSupportedException();
				}
			}

			public uint Read(int index) {
				throw new NotSupportedException();
			}

			public void Write(int index, uint value) {
				throw new NotSupportedException();
			}
		}

		/// <inheritdoc/>
		public void SetReadOnly() {
			foreach (var mdt in Tables)
				mdt.SetReadOnly();
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			if (length == 0)
				CalculateLength();
			return Utils.AlignUp(length, HeapBase.ALIGNMENT);
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <summary>
		/// Calculates the length. This will set all MD tables to read-only.
		/// </summary>
		public void CalculateLength() {
			if (length != 0)
				return;
			SetReadOnly();

			majorVersion = options.MajorVersion ?? 2;
			minorVersion = options.MinorVersion ?? 0;

			if (((majorVersion << 8) | minorVersion) <= 0x100) {
				if (!GenericParamTable.IsEmpty || !MethodSpecTable.IsEmpty || !GenericParamConstraintTable.IsEmpty)
					throw new ModuleWriterException("Tables heap version <= v1.0 but generic tables are not empty");
			}

			var dnTableSizes = new DotNetTableSizes();
			var tableInfos = dnTableSizes.CreateTables(majorVersion, minorVersion);
			var rowCounts = GetRowCounts();
			dnTableSizes.InitializeSizes(bigStrings, bigGuid, bigBlob, systemTables ?? rowCounts, rowCounts);
			for (int i = 0; i < Tables.Length; i++)
				Tables[i].TableInfo = tableInfos[i];

			length = 24;
			foreach (var mdt in Tables) {
				if (mdt.IsEmpty)
					continue;
				length += (uint)(4 + mdt.TableInfo.RowSize * mdt.Rows);
			}
			if (options.ExtraData.HasValue)
				length += 4;
		}

		uint[] GetRowCounts() {
			var sizes = new uint[Tables.Length];
			for (int i = 0; i < sizes.Length; i++)
				sizes[i] = (uint)Tables[i].Rows;
			return sizes;
		}

		internal void GetSystemTableRows(out ulong mask, uint[] tables) {
			if (tables.Length != 0x40)
				throw new InvalidOperationException();
			var tablesMask = GetValidMask();
			ulong bit = 1;
			mask = 0;
			for (int i = 0; i < 0x40; i++, bit <<= 1) {
				var table = (Table)i;
				if (DotNetTableSizes.IsSystemTable(table)) {
					if ((tablesMask & bit) != 0) {
						tables[i] = (uint)Tables[i].Rows;
						mask |= bit;
					}
					else
						tables[i] = 0;
				}
				else
					tables[i] = 0;
			}
		}

		internal void SetSystemTableRows(uint[] systemTables) {
			this.systemTables = (uint[])systemTables.Clone();
		}
		uint[] systemTables;

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			writer.Write(options.Reserved1 ?? 0);
			writer.Write(majorVersion);
			writer.Write(minorVersion);
			writer.Write((byte)GetMDStreamFlags());
			writer.Write(GetLog2Rid());
			writer.Write(GetValidMask());
			writer.Write(GetSortedMask());
			foreach (var mdt in Tables) {
				if (!mdt.IsEmpty)
					writer.Write(mdt.Rows);
			}
			if (options.ExtraData.HasValue)
				writer.Write(options.ExtraData.Value);

			writer.Write(metadata, ModuleTable);
			writer.Write(metadata, TypeRefTable);
			writer.Write(metadata, TypeDefTable);
			writer.Write(metadata, FieldPtrTable);
			writer.Write(metadata, FieldTable);
			writer.Write(metadata, MethodPtrTable);
			writer.Write(metadata, MethodTable);
			writer.Write(metadata, ParamPtrTable);
			writer.Write(metadata, ParamTable);
			writer.Write(metadata, InterfaceImplTable);
			writer.Write(metadata, MemberRefTable);
			writer.Write(metadata, ConstantTable);
			writer.Write(metadata, CustomAttributeTable);
			writer.Write(metadata, FieldMarshalTable);
			writer.Write(metadata, DeclSecurityTable);
			writer.Write(metadata, ClassLayoutTable);
			writer.Write(metadata, FieldLayoutTable);
			writer.Write(metadata, StandAloneSigTable);
			writer.Write(metadata, EventMapTable);
			writer.Write(metadata, EventPtrTable);
			writer.Write(metadata, EventTable);
			writer.Write(metadata, PropertyMapTable);
			writer.Write(metadata, PropertyPtrTable);
			writer.Write(metadata, PropertyTable);
			writer.Write(metadata, MethodSemanticsTable);
			writer.Write(metadata, MethodImplTable);
			writer.Write(metadata, ModuleRefTable);
			writer.Write(metadata, TypeSpecTable);
			writer.Write(metadata, ImplMapTable);
			writer.Write(metadata, FieldRVATable);
			writer.Write(metadata, ENCLogTable);
			writer.Write(metadata, ENCMapTable);
			writer.Write(metadata, AssemblyTable);
			writer.Write(metadata, AssemblyProcessorTable);
			writer.Write(metadata, AssemblyOSTable);
			writer.Write(metadata, AssemblyRefTable);
			writer.Write(metadata, AssemblyRefProcessorTable);
			writer.Write(metadata, AssemblyRefOSTable);
			writer.Write(metadata, FileTable);
			writer.Write(metadata, ExportedTypeTable);
			writer.Write(metadata, ManifestResourceTable);
			writer.Write(metadata, NestedClassTable);
			writer.Write(metadata, GenericParamTable);
			writer.Write(metadata, MethodSpecTable);
			writer.Write(metadata, GenericParamConstraintTable);
			writer.Write(metadata, DocumentTable);
			writer.Write(metadata, MethodDebugInformationTable);
			writer.Write(metadata, LocalScopeTable);
			writer.Write(metadata, LocalVariableTable);
			writer.Write(metadata, LocalConstantTable);
			writer.Write(metadata, ImportScopeTable);
			writer.Write(metadata, StateMachineMethodTable);
			writer.Write(metadata, CustomDebugInformationTable);
			writer.WriteZeros((int)(Utils.AlignUp(length, HeapBase.ALIGNMENT) - length));
		}

		MDStreamFlags GetMDStreamFlags() {
			MDStreamFlags flags = 0;
			if (bigStrings)
				flags |= MDStreamFlags.BigStrings;
			if (bigGuid)
				flags |= MDStreamFlags.BigGUID;
			if (bigBlob)
				flags |= MDStreamFlags.BigBlob;
			if (options.ExtraData.HasValue)
				flags |= MDStreamFlags.ExtraData;
			if (hasDeletedRows)
				flags |= MDStreamFlags.HasDelete;
			return flags;
		}

		byte GetLog2Rid() {
			//TODO: Sometimes this is 16. Probably when at least one of the table indexes requires 4 bytes.
			return 1;
		}

		ulong GetValidMask() {
			ulong mask = 0;
			foreach (var mdt in Tables) {
				if (!mdt.IsEmpty)
					mask |= 1UL << (int)mdt.Table;
			}
			return mask;
		}

		ulong GetSortedMask() {
			ulong mask = 0;
			foreach (var mdt in Tables) {
				if (mdt.IsSorted)
					mask |= 1UL << (int)mdt.Table;
			}
			return mask;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return Name;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/USHeap.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.DotNet.MD;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #US heap
	/// </summary>
	public sealed class USHeap : HeapBase, IOffsetHeap<string> {
		readonly Dictionary<string, uint> cachedDict = new Dictionary<string, uint>(StringComparer.Ordinal);
		readonly List<string> cached = new List<string>();
		uint nextOffset = 1;
		byte[] originalData;
		Dictionary<uint, byte[]> userRawData;

		/// <inheritdoc/>
		public override string Name {
			get { return "#US"; }
		}

		/// <summary>
		/// Populates strings from an existing <see cref="USStream"/> (eg. to preserve
		/// string tokens)
		/// </summary>
		/// <param name="usStream">The #US stream with the original content</param>
		public void Populate(USStream usStream) {
			if (originalData != null)
				throw new InvalidOperationException("Can't call method twice");
			if (nextOffset != 1)
				throw new InvalidOperationException("Add() has already been called");
			if (usStream == null || usStream.ImageStreamLength == 0)
				return;

			using (var reader = usStream.GetClonedImageStream()) {
				originalData = reader.ReadAllBytes();
				nextOffset = (uint)originalData.Length;
				Populate(reader);
			}
		}

		void Populate(IImageStream reader) {
			var chars = new char[0x200];
			reader.Position = 1;
			while (reader.Position < reader.Length) {
				uint offset = (uint)reader.Position;
				uint len;
				if (!reader.ReadCompressedUInt32(out len)) {
					if (offset == reader.Position)
						reader.Position++;
					continue;
				}
				if (len == 0 || reader.Position + len > reader.Length)
					continue;

				int stringLen = (int)len / 2;
				if (stringLen > chars.Length)
					Array.Resize(ref chars, stringLen);
				for (int i = 0; i < stringLen; i++)
					chars[i] = (char)reader.ReadUInt16();
				if ((len & 1) != 0)
					reader.ReadByte();
				var s = new string(chars, 0, stringLen);

				if (!cachedDict.ContainsKey(s))
					cachedDict[s] = offset;
			}
		}

		/// <summary>
		/// Adds a string to the #US heap
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>The offset of the string in the #US heap</returns>
		public uint Add(string s) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #US when it's read-only");
			if (s == null)
				s = string.Empty;

			uint offset;
			if (cachedDict.TryGetValue(s, out offset))
				return offset;
			return AddToCache(s);
		}

		/// <summary>
		/// Adds a string to the #US heap
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>The offset of the string in the #US heap</returns>
		public uint Create(string s) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #US when it's read-only");
			return AddToCache(s ?? string.Empty);
		}

		uint AddToCache(string s) {
			uint offset;
			cached.Add(s);
			cachedDict[s] = offset = nextOffset;
			nextOffset += (uint)GetRawDataSize(s);
			if (offset > 0x00FFFFFF)
				throw new ModuleWriterException("#US heap is too big");
			return offset;
		}

		/// <inheritdoc/>
		public override uint GetRawLength() {
			return nextOffset;
		}

		/// <inheritdoc/>
		protected override void WriteToImpl(BinaryWriter writer) {
			if (originalData != null)
				writer.Write(originalData);
			else
				writer.Write((byte)0);

			uint offset = originalData != null ? (uint)originalData.Length : 1;
			foreach (var s in cached) {
				int rawLen = GetRawDataSize(s);
				byte[] rawData;
				if (userRawData != null && userRawData.TryGetValue(offset, out rawData)) {
					if (rawData.Length != rawLen)
						throw new InvalidOperationException("Invalid length of raw data");
					writer.Write(rawData);
				}
				else
					WriteString(writer, s);
				offset += (uint)rawLen;
			}
		}

		void WriteString(BinaryWriter writer, string s) {
			writer.WriteCompressedUInt32((uint)s.Length * 2 + 1);
			byte last = 0;
			for (int i = 0; i < s.Length; i++) {
				ushort c = (ushort)s[i];
				writer.Write(c);
				if (c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F)
					last = 1;
			}
			writer.Write(last);
		}

		/// <inheritdoc/>
		public int GetRawDataSize(string data) {
			return Utils.GetCompressedUInt32Length((uint)data.Length * 2 + 1) + data.Length * 2 + 1;
		}

		/// <inheritdoc/>
		public void SetRawData(uint offset, byte[] rawData) {
			if (rawData == null)
				throw new ArgumentNullException("rawData");
			if (userRawData == null)
				userRawData = new Dictionary<uint, byte[]>();
			userRawData[offset] = rawData;
		}

		/// <inheritdoc/>
		public IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData() {
			var memStream = new MemoryStream();
			var writer = new BinaryWriter(memStream);
			uint offset = originalData != null ? (uint)originalData.Length : 1;
			foreach (var s in cached) {
				memStream.Position = 0;
				memStream.SetLength(0);
				WriteString(writer, s);
				yield return new KeyValuePair<uint, byte[]>(offset, memStream.ToArray());
				offset += (uint)memStream.Length;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/UniqueChunkList.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.PE;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Re-uses existing chunks to save space
	/// </summary>
	/// <typeparam name="T">Chunk type</typeparam>
	public sealed class UniqueChunkList<T> : ChunkListBase<T> where T : class, IChunk {
		Dictionary<Elem, Elem> dict;

		/// <summary>
		/// Default constructor
		/// </summary>
		public UniqueChunkList()
			: this(EqualityComparer<T>.Default) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="chunkComparer">Compares the chunk type</param>
		public UniqueChunkList(IEqualityComparer<T> chunkComparer) {
			this.chunks = new List<Elem>();
			this.dict = new Dictionary<Elem, Elem>(new ElemEqualityComparer(chunkComparer));
		}

		/// <inheritdoc/>
		public override void SetOffset(FileOffset offset, RVA rva) {
			dict = null;
			base.SetOffset(offset, rva);
		}

		/// <summary>
		/// Adds a <see cref="IChunk"/> if not already present
		/// </summary>
		/// <param name="chunk">The chunk to add or <c>null</c> if none</param>
		/// <param name="alignment">Chunk alignment</param>
		/// <returns>The original input if it wasn't present, or the cached one</returns>
		public T Add(T chunk, uint alignment) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (chunk == null)
				return null;
			var elem = new Elem(chunk, alignment);
			Elem other;
			if (dict.TryGetValue(elem, out other))
				return other.chunk;
			dict[elem] = elem;
			chunks.Add(elem);
			return elem.chunk;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/Win32ResourcesChunk.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using dnlib.IO;
using dnlib.PE;
using dnlib.W32Resources;

namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes Win32 resources
	/// </summary>
	public sealed class Win32ResourcesChunk : IChunk {
		readonly Win32Resources win32Resources;
		FileOffset offset;
		RVA rva;
		uint length;
		readonly Dictionary<ResourceDirectory, uint> dirDict = new Dictionary<ResourceDirectory, uint>();
		readonly List<ResourceDirectory> dirList = new List<ResourceDirectory>();
		readonly Dictionary<ResourceData, uint> dataHeaderDict = new Dictionary<ResourceData, uint>();
		readonly List<ResourceData> dataHeaderList = new List<ResourceData>();
		readonly Dictionary<string, uint> stringsDict = new Dictionary<string, uint>(StringComparer.Ordinal);
		readonly List<string> stringsList = new List<string>();
		readonly Dictionary<IBinaryReader, uint> dataDict = new Dictionary<IBinaryReader, uint>();
		readonly List<IBinaryReader> dataList = new List<IBinaryReader>();

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return offset; }
		}

		/// <inheritdoc/>
		public RVA RVA {
			get { return rva; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="win32Resources">Win32 resources</param>
		public Win32ResourcesChunk(Win32Resources win32Resources) {
			this.win32Resources = win32Resources;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of a
		/// <see cref="ResourceDirectoryEntry"/>. <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dirEntry">A <see cref="ResourceDirectoryEntry"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="dirEntry"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="dirEntry"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(ResourceDirectoryEntry dirEntry, out FileOffset fileOffset, out RVA rva) {
			var dir = dirEntry as ResourceDirectory;
			if (dir != null)
				return GetFileOffsetAndRvaOf(dir, out fileOffset, out rva);

			var dataHeader = dirEntry as ResourceData;
			if (dataHeader != null)
				return GetFileOffsetAndRvaOf(dataHeader, out fileOffset, out rva);

			fileOffset = 0;
			rva = 0;
			return false;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of a <see cref="ResourceDirectoryEntry"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dirEntry">A <see cref="ResourceDirectoryEntry"/></param>
		/// <returns>The file offset or 0 if <paramref name="dirEntry"/> is invalid</returns>
		public FileOffset GetFileOffset(ResourceDirectoryEntry dirEntry) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(dirEntry, out fileOffset, out rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of a <see cref="ResourceDirectoryEntry"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dirEntry">A <see cref="ResourceDirectoryEntry"/></param>
		/// <returns>The RVA or 0 if <paramref name="dirEntry"/> is invalid</returns>
		public RVA GetRVA(ResourceDirectoryEntry dirEntry) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(dirEntry, out fileOffset, out rva);
			return rva;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of a
		/// <see cref="ResourceDirectory"/>. <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dir">A <see cref="ResourceDirectory"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="dir"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="dir"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(ResourceDirectory dir, out FileOffset fileOffset, out RVA rva) {
			uint offs;
			if (dir == null || !dirDict.TryGetValue(dir, out offs)) {
				fileOffset = 0;
				rva = 0;
				return false;
			}

			fileOffset = offset + offs;
			rva = this.rva + offs;
			return true;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of a <see cref="ResourceDirectory"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dir">A <see cref="ResourceDirectory"/></param>
		/// <returns>The file offset or 0 if <paramref name="dir"/> is invalid</returns>
		public FileOffset GetFileOffset(ResourceDirectory dir) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(dir, out fileOffset, out rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of a <see cref="ResourceDirectory"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dir">A <see cref="ResourceDirectory"/></param>
		/// <returns>The RVA or 0 if <paramref name="dir"/> is invalid</returns>
		public RVA GetRVA(ResourceDirectory dir) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(dir, out fileOffset, out rva);
			return rva;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of a
		/// <see cref="ResourceData"/>. <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dataHeader">A <see cref="ResourceData"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="dataHeader"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="dataHeader"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(ResourceData dataHeader, out FileOffset fileOffset, out RVA rva) {
			uint offs;
			if (dataHeader == null || !dataHeaderDict.TryGetValue(dataHeader, out offs)) {
				fileOffset = 0;
				rva = 0;
				return false;
			}

			fileOffset = offset + offs;
			rva = this.rva + offs;
			return true;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of a <see cref="ResourceData"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dataHeader">A <see cref="ResourceData"/></param>
		/// <returns>The file offset or 0 if <paramref name="dataHeader"/> is invalid</returns>
		public FileOffset GetFileOffset(ResourceData dataHeader) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(dataHeader, out fileOffset, out rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of a <see cref="ResourceData"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dataHeader">A <see cref="ResourceData"/></param>
		/// <returns>The RVA or 0 if <paramref name="dataHeader"/> is invalid</returns>
		public RVA GetRVA(ResourceData dataHeader) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(dataHeader, out fileOffset, out rva);
			return rva;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of the raw data
		/// owned by a <see cref="ResourceData"/>. <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="data">A <see cref="ResourceData"/>'s <see cref="IBinaryReader"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="data"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="data"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(IBinaryReader data, out FileOffset fileOffset, out RVA rva) {
			uint offs;
			if (data == null || !dataDict.TryGetValue(data, out offs)) {
				fileOffset = 0;
				rva = 0;
				return false;
			}

			fileOffset = offset + offs;
			rva = this.rva + offs;
			return true;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of the raw data owned by a
		/// <see cref="ResourceData"/>. <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="data">A <see cref="ResourceData"/>'s <see cref="IBinaryReader"/></param>
		/// <returns>The file offset or 0 if <paramref name="data"/> is invalid</returns>
		public FileOffset GetFileOffset(IBinaryReader data) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(data, out fileOffset, out rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of the raw data owned by a <see cref="ResourceData"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="data">A <see cref="ResourceData"/>'s <see cref="IBinaryReader"/></param>
		/// <returns>The RVA or 0 if <paramref name="data"/> is invalid</returns>
		public RVA GetRVA(IBinaryReader data) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(data, out fileOffset, out rva);
			return rva;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of a
		/// <see cref="ResourceDirectoryEntry"/>'s name. <see cref="SetOffset"/> must have been
		/// called.
		/// </summary>
		/// <param name="name">The name of a <see cref="ResourceDirectoryEntry"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="name"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="name"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(string name, out FileOffset fileOffset, out RVA rva) {
			uint offs;
			if (name == null || !stringsDict.TryGetValue(name, out offs)) {
				fileOffset = 0;
				rva = 0;
				return false;
			}

			fileOffset = offset + offs;
			rva = this.rva + offs;
			return true;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of a <see cref="ResourceDirectoryEntry"/>'s name.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="name">The name of a <see cref="ResourceDirectoryEntry"/></param>
		/// <returns>The file offset or 0 if <paramref name="name"/> is invalid</returns>
		public FileOffset GetFileOffset(string name) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(name, out fileOffset, out rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of a <see cref="ResourceDirectoryEntry"/>'s name.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="name">The name of a <see cref="ResourceDirectoryEntry"/></param>
		/// <returns>The RVA or 0 if <paramref name="name"/> is invalid</returns>
		public RVA GetRVA(string name) {
			FileOffset fileOffset;
			RVA rva;
			GetFileOffsetAndRvaOf(name, out fileOffset, out rva);
			return rva;
		}

		const uint RESOURCE_DIR_ALIGNMENT = 4;
		const uint RESOURCE_DATA_HEADER_ALIGNMENT = 4;
		const uint RESOURCE_STRING_ALIGNMENT = 2;
		const uint RESOURCE_DATA_ALIGNMENT = 4;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
			if (win32Resources == null)
				return;

			FindDirectoryEntries();

			// Place everything in the following order:
			//	1. All resource directories. The root is always first.
			//	2. All resource data headers.
			//	3. All the strings.
			//	4. All resource data.

			uint rsrcOffset = 0;

			uint maxAlignment = 1;
			maxAlignment = Math.Max(maxAlignment, RESOURCE_DIR_ALIGNMENT);
			maxAlignment = Math.Max(maxAlignment, RESOURCE_DATA_HEADER_ALIGNMENT);
			maxAlignment = Math.Max(maxAlignment, RESOURCE_STRING_ALIGNMENT);
			maxAlignment = Math.Max(maxAlignment, RESOURCE_DATA_ALIGNMENT);
			if (((uint)offset & (maxAlignment - 1)) != 0)
				throw new ModuleWriterException(string.Format("Win32 resources section isn't {0}-byte aligned", maxAlignment));
			if (maxAlignment > ModuleWriterBase.DEFAULT_WIN32_RESOURCES_ALIGNMENT)
				throw new ModuleWriterException("maxAlignment > DEFAULT_WIN32_RESOURCES_ALIGNMENT");

			foreach (var dir in dirList) {
				rsrcOffset = Utils.AlignUp(rsrcOffset, RESOURCE_DIR_ALIGNMENT);
				dirDict[dir] = rsrcOffset;
				if (dir != dirList[0])
					AddString(dir.Name);
				rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;
			}

			foreach (var data in dataHeaderList) {
				rsrcOffset = Utils.AlignUp(rsrcOffset, RESOURCE_DATA_HEADER_ALIGNMENT);
				dataHeaderDict[data] = rsrcOffset;
				AddString(data.Name);
				AddData(data.Data);
				rsrcOffset += 16;
			}

			foreach (var s in stringsList) {
				rsrcOffset = Utils.AlignUp(rsrcOffset, RESOURCE_STRING_ALIGNMENT);
				stringsDict[s] = rsrcOffset;
				rsrcOffset += 2 + (uint)(s.Length * 2);
			}

			foreach (var data in dataList) {
				rsrcOffset = Utils.AlignUp(rsrcOffset, RESOURCE_DATA_ALIGNMENT);
				dataDict[data] = rsrcOffset;
				rsrcOffset += (uint)data.Length;
			}

			length = rsrcOffset;
		}

		void AddData(IBinaryReader data) {
			if (dataDict.ContainsKey(data))
				return;
			dataList.Add(data);
			dataDict.Add(data, 0);
		}

		void AddString(ResourceName name) {
			if (!name.HasName || stringsDict.ContainsKey(name.Name))
				return;
			stringsList.Add(name.Name);
			stringsDict.Add(name.Name, 0);
		}

		void FindDirectoryEntries() {
			FindDirectoryEntries(win32Resources.Root);
		}

		void FindDirectoryEntries(ResourceDirectory dir) {
			if (dirDict.ContainsKey(dir))
				return;
			dirList.Add(dir);
			dirDict[dir] = 0;
			foreach (var dir2 in dir.Directories)
				FindDirectoryEntries(dir2);
			foreach (var data in dir.Data) {
				if (dataHeaderDict.ContainsKey(data))
					continue;
				dataHeaderList.Add(data);
				dataHeaderDict[data] = 0;
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			return Utils.AlignUp(length, ModuleWriterBase.DEFAULT_WIN32_RESOURCES_ALIGNMENT);
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() {
			return GetFileLength();
		}

		/// <inheritdoc/>
		public void WriteTo(BinaryWriter writer) {
			uint offset = 0;

			// The order here must be the same as in SetOffset()

			foreach (var dir in dirList) {
				uint padding = Utils.AlignUp(offset, RESOURCE_DIR_ALIGNMENT) - offset;
				writer.WriteZeros((int)padding);
				offset += padding;
				if (dirDict[dir] != offset)
					throw new ModuleWriterException("Invalid Win32 resource directory offset");
				offset += WriteTo(writer, dir);
			}

			foreach (var dataHeader in dataHeaderList) {
				uint padding = Utils.AlignUp(offset, RESOURCE_DATA_HEADER_ALIGNMENT) - offset;
				writer.WriteZeros((int)padding);
				offset += padding;
				if (dataHeaderDict[dataHeader] != offset)
					throw new ModuleWriterException("Invalid Win32 resource data header offset");
				offset += WriteTo(writer, dataHeader);
			}

			foreach (var s in stringsList) {
				uint padding = Utils.AlignUp(offset, RESOURCE_STRING_ALIGNMENT) - offset;
				writer.WriteZeros((int)padding);
				offset += padding;
				if (stringsDict[s] != offset)
					throw new ModuleWriterException("Invalid Win32 resource string offset");

				var bytes = Encoding.Unicode.GetBytes(s);
				if (bytes.Length / 2 > ushort.MaxValue)
					throw new ModuleWriterException("Win32 resource entry name is too long");
				writer.Write((ushort)(bytes.Length / 2));
				writer.Write(bytes);
				offset += 2 + (uint)bytes.Length;
			}

			byte[] dataBuffer = new byte[0x2000];
			foreach (var data in dataList) {
				uint padding = Utils.AlignUp(offset, RESOURCE_DATA_ALIGNMENT) - offset;
				writer.WriteZeros((int)padding);
				offset += padding;
				if (dataDict[data] != offset)
					throw new ModuleWriterException("Invalid Win32 resource data offset");

				data.Position = 0;
				offset += data.WriteTo(writer, dataBuffer);
			}

			writer.WriteZeros((int)(Utils.AlignUp(length, ModuleWriterBase.DEFAULT_WIN32_RESOURCES_ALIGNMENT) - length));
		}

		uint WriteTo(BinaryWriter writer, ResourceDirectory dir) {
			writer.Write(dir.Characteristics);
			writer.Write(dir.TimeDateStamp);
			writer.Write(dir.MajorVersion);
			writer.Write(dir.MinorVersion);

			List<ResourceDirectoryEntry> named;
			List<ResourceDirectoryEntry> ids;
			GetNamedAndIds(dir, out named, out ids);
			if (named.Count > ushort.MaxValue || ids.Count > ushort.MaxValue)
				throw new ModuleWriterException("Too many named/id Win32 resource entries");
			writer.Write((ushort)named.Count);
			writer.Write((ushort)ids.Count);

			// These must be sorted in ascending order. Names are case insensitive.
			named.Sort((a, b) => a.Name.Name.ToUpperInvariant().CompareTo(b.Name.Name.ToUpperInvariant()));
			ids.Sort((a, b) => a.Name.Id.CompareTo(b.Name.Id));

			foreach (var d in named) {
				writer.Write(0x80000000 | stringsDict[d.Name.Name]);
				writer.Write(GetDirectoryEntryOffset(d));
			}

			foreach (var d in ids) {
				writer.Write(d.Name.Id);
				writer.Write(GetDirectoryEntryOffset(d));
			}

			return 16 + (uint)(named.Count + ids.Count) * 8;
		}

		uint GetDirectoryEntryOffset(ResourceDirectoryEntry e) {
			if (e is ResourceData)
				return dataHeaderDict[(ResourceData)e];
			return 0x80000000 | dirDict[(ResourceDirectory)e];
		}

		static void GetNamedAndIds(ResourceDirectory dir, out List<ResourceDirectoryEntry> named, out List<ResourceDirectoryEntry> ids) {
			named = new List<ResourceDirectoryEntry>();
			ids = new List<ResourceDirectoryEntry>();
			foreach (var d in dir.Directories) {
				if (d.Name.HasId)
					ids.Add(d);
				else
					named.Add(d);
			}
			foreach (var d in dir.Data) {
				if (d.Name.HasId)
					ids.Add(d);
				else
					named.Add(d);
			}
		}

		uint WriteTo(BinaryWriter writer, ResourceData dataHeader) {
			writer.Write((uint)rva + dataDict[dataHeader.Data]);
			writer.Write((uint)dataHeader.Data.Length);
			writer.Write(dataHeader.CodePage);
			writer.Write(dataHeader.Reserved);
			return 16;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/DotNet/Writer/WriterUtils.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.IO;

namespace dnlib.DotNet.Writer {
	static class WriterUtils {
		public static uint WriteCompressedUInt32(this BinaryWriter writer, IWriterError helper, uint value) {
			if (value > 0x1FFFFFFF) {
				helper.Error("UInt32 value is too big and can't be compressed");
				value = 0x1FFFFFFF;
			}
			writer.WriteCompressedUInt32(value);
			return value;
		}

		public static int WriteCompressedInt32(this BinaryWriter writer, IWriterError helper, int value) {
			if (value < -0x10000000) {
				helper.Error("Int32 value is too small and can't be compressed.");
				value = -0x10000000;
			}
			else if (value > 0x0FFFFFFF) {
				helper.Error("Int32 value is too big and can't be compressed.");
				value = 0x0FFFFFFF;
			}
			writer.WriteCompressedInt32(value);
			return value;
		}

		public static void Write(this BinaryWriter writer, IWriterError helper, UTF8String s) {
			if (UTF8String.IsNull(s)) {
				helper.Error("UTF8String is null");
				s = UTF8String.Empty;
			}

			writer.WriteCompressedUInt32(helper, (uint)s.DataLength);
			writer.Write(s.Data);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/BinaryReaderStream.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.IO;

namespace dnlib.IO {
	/// <summary>
	/// A <see cref="Stream"/> class that can be used when you have a <see cref="IBinaryReader"/>
	/// but must use a <see cref="Stream"/>
	/// </summary>
	sealed class BinaryReaderStream : Stream {
		IBinaryReader reader;
		readonly bool ownsReader;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">Reader. This instance does <c>NOT</c> own this reader.</param>
		public BinaryReaderStream(IBinaryReader reader)
			: this(reader, false) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <param name="ownsReader"><c>true</c> if this instance owns <paramref name="reader"/></param>
		public BinaryReaderStream(IBinaryReader reader, bool ownsReader) {
			this.reader = reader;
			this.ownsReader = ownsReader;
		}

		/// <inheritdoc/>
		public override bool CanRead {
			get { return true; }
		}

		/// <inheritdoc/>
		public override bool CanSeek {
			get { return true; }
		}

		/// <inheritdoc/>
		public override bool CanWrite {
			get { return false; }
		}

		/// <inheritdoc/>
		public override void Flush() {
		}

		/// <inheritdoc/>
		public override long Length {
			get { return reader.Length; }
		}

		/// <inheritdoc/>
		public override long Position {
			get { return reader.Position; }
			set { reader.Position = value; }
		}

		/// <inheritdoc/>
		public override int Read(byte[] buffer, int offset, int count) {
			return reader.Read(buffer, offset, count);
		}

		/// <inheritdoc/>
		public override int ReadByte() {
			try {
				return reader.ReadByte();
			}
			catch (IOException) {
				return -1;
			}
		}

		/// <inheritdoc/>
		public override long Seek(long offset, SeekOrigin origin) {
			switch (origin) {
			case SeekOrigin.Begin:	Position = offset; break;
			case SeekOrigin.Current:Position += offset; break;
			case SeekOrigin.End:	Position = Length + offset; break;
			}
			return Position;
		}

		/// <inheritdoc/>
		public override void SetLength(long value) {
			throw new NotImplementedException();
		}

		/// <inheritdoc/>
		public override void Write(byte[] buffer, int offset, int count) {
			throw new NotImplementedException();
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			if (disposing) {
				var r = reader;
				if (ownsReader && r != null)
					r.Dispose();
				reader = null;
			}
			base.Dispose(disposing);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/FileOffset.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.IO {
	/// <summary>
	/// Represents a file offset
	/// </summary>
	public enum FileOffset : long {
	}

	partial class IOExtensions {
		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="offset">this</param>
		/// <param name="alignment">Alignment</param>
		public static FileOffset AlignUp(this FileOffset offset, uint alignment) {
			return (FileOffset)(((uint)offset + alignment - 1) & ~(alignment - 1));
		}

		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="offset">this</param>
		/// <param name="alignment">Alignment</param>
		public static FileOffset AlignUp(this FileOffset offset, int alignment) {
			return (FileOffset)(((uint)offset + alignment - 1) & ~(alignment - 1));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/FileSection.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Diagnostics;

namespace dnlib.IO {
	/// <summary>
	/// Base class for classes needing to implement IFileSection
	/// </summary>
	[DebuggerDisplay("O:{startOffset} L:{size} {GetType().Name}")]
	public class FileSection : IFileSection {
		/// <summary>
		/// The start file offset of this section
		/// </summary>
		protected FileOffset startOffset;

		/// <summary>
		/// Size of the section
		/// </summary>
		protected uint size;

		/// <inheritdoc/>
		public FileOffset StartOffset {
			get { return startOffset; }
		}

		/// <inheritdoc/>
		public FileOffset EndOffset {
			get { return startOffset + size; }
		}

		/// <summary>
		/// Set <see cref="startOffset"/> to <paramref name="reader"/>'s current position
		/// </summary>
		/// <param name="reader">The reader</param>
		protected void SetStartOffset(IImageStream reader) {
			startOffset = (FileOffset)reader.Position;
		}

		/// <summary>
		/// Set <see cref="size"/> according to <paramref name="reader"/>'s current position
		/// </summary>
		/// <param name="reader">The reader</param>
		protected void SetEndoffset(IImageStream reader) {
			size = (uint)(reader.Position - startOffset);
			startOffset = reader.FileOffset + (long)startOffset;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/IBinaryReader.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.IO;
using System.Text;

namespace dnlib.IO {
	/// <summary>
	/// Reads binary data
	/// </summary>
	public interface IBinaryReader : IDisposable {
		/// <summary>
		/// Returns the length of the stream
		/// </summary>
		long Length { get; }

		/// <summary>
		/// Gets/sets the position
		/// </summary>
		long Position { get; set; }

		/// <summary>
		/// Reads <paramref name="size"/> bytes from the current <see cref="Position"/>
		/// and increments <see cref="Position"/> by <paramref name="size"/> bytes
		/// </summary>
		/// <param name="size">Number of bytes to read</param>
		/// <returns>All available bytes. This can be less than <paramref name="size"/> bytes
		/// if there's not enough bytes left.</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		byte[] ReadBytes(int size);

		/// <summary>
		/// Reads <paramref name="length"/> bytes to <paramref name="buffer"/> and increments
		/// <see cref="Position"/> by the number of bytes read.
		/// </summary>
		/// <param name="buffer">Buffer</param>
		/// <param name="offset">Offset in buffer where to place all read bytes</param>
		/// <param name="length">Number of bytes to read</param>
		/// <returns>Number of bytes read, and can be less than <paramref name="length"/> if
		/// there's no more bytes to read.</returns>
		int Read(byte[] buffer, int offset, int length);

		/// <summary>
		/// Reads bytes until byte <paramref name="b"/> is found. <see cref="Position"/> is
		/// incremented by the number of bytes read (size of return value).
		/// </summary>
		/// <param name="b">The terminating byte</param>
		/// <returns>All the bytes (not including <paramref name="b"/>) or <c>null</c> if
		/// <paramref name="b"/> wasn't found.</returns>
		byte[] ReadBytesUntilByte(byte b);

		/// <summary>
		/// Reads a <see cref="sbyte"/> from the current position and increments <see cref="Position"/> by 1
		/// </summary>
		/// <returns>The 8-bit signed byte</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		sbyte ReadSByte();

		/// <summary>
		/// Reads a <see cref="byte"/> from the current position and increments <see cref="Position"/> by 1
		/// </summary>
		/// <returns>The 8-bit unsigned byte</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		byte ReadByte();

		/// <summary>
		/// Reads a <see cref="Int16"/> from the current position and increments <see cref="Position"/> by 2
		/// </summary>
		/// <returns>The 16-bit signed integer</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		short ReadInt16();

		/// <summary>
		/// Reads a <see cref="UInt16"/> from the current position and increments <see cref="Position"/> by 2
		/// </summary>
		/// <returns>The 16-bit unsigned integer</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		ushort ReadUInt16();

		/// <summary>
		/// Reads a <see cref="Int32"/> from the current position and increments <see cref="Position"/> by 4
		/// </summary>
		/// <returns>The 32-bit signed integer</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		int ReadInt32();

		/// <summary>
		/// Reads a <see cref="UInt32"/> from the current position and increments <see cref="Position"/> by 4
		/// </summary>
		/// <returns>The 32-bit unsigned integer</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		uint ReadUInt32();

		/// <summary>
		/// Reads a <see cref="Int64"/> from the current position and increments <see cref="Position"/> by 8
		/// </summary>
		/// <returns>The 64-bit signed integer</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		long ReadInt64();

		/// <summary>
		/// Reads a <see cref="UInt64"/> from the current position and increments <see cref="Position"/> by 8
		/// </summary>
		/// <returns>The 64-bit unsigned integer</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		ulong ReadUInt64();

		/// <summary>
		/// Reads a <see cref="Single"/> from the current position and increments <see cref="Position"/> by 4
		/// </summary>
		/// <returns>The 32-bit single</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		float ReadSingle();

		/// <summary>
		/// Reads a <see cref="Double"/> from the current position and increments <see cref="Position"/> by 8
		/// </summary>
		/// <returns>The 64-bit double</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		double ReadDouble();

		/// <summary>
		/// Reads a <see cref="String"/> from the current position and increments <see cref="Position"/>
		/// by the number of bytes read.
		/// </summary>
		/// <param name="chars">Number of characters to read</param>
		/// <returns>The string</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		string ReadString(int chars);
	}

	public static partial class IOExtensions {
		/// <summary>
		/// Reads a <see cref="Boolean"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Boolean"/></returns>
		public static bool ReadBooleanAt(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadBoolean();
		}

		/// <summary>
		/// Reads a <see cref="Byte"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Byte"/></returns>
		public static byte ReadByteAt(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadByte();
		}

		/// <summary>
		/// Reads a <see cref="SByte"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="SByte"/></returns>
		public static sbyte ReadSByteAt(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadSByte();
		}

		/// <summary>
		/// Reads a <see cref="Int16"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Int16"/></returns>
		public static short ReadInt16At(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadInt16();
		}

		/// <summary>
		/// Reads a <see cref="UInt16"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="UInt16"/></returns>
		public static ushort ReadUInt16At(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadUInt16();
		}

		/// <summary>
		/// Reads a <see cref="Int32"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Int32"/></returns>
		public static int ReadInt32At(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadInt32();
		}

		/// <summary>
		/// Reads a <see cref="UInt32"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="UInt32"/></returns>
		public static uint ReadUInt32At(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadUInt32();
		}

		/// <summary>
		/// Reads a <see cref="Int64"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Int64"/></returns>
		public static long ReadInt64At(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadInt64();
		}

		/// <summary>
		/// Reads a <see cref="UInt64"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="UInt64"/></returns>
		public static ulong ReadUInt64At(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadUInt64();
		}

		/// <summary>
		/// Reads a <see cref="Single"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Single"/></returns>
		public static float ReadSingleAt(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadSingle();
		}

		/// <summary>
		/// Reads a <see cref="Double"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Double"/></returns>
		public static double ReadDoubleAt(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadDouble();
		}

		/// <summary>
		/// Reads a <see cref="Byte"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Byte"/></returns>
		public static string ReadStringAt(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadString();
		}

		/// <summary>
		/// Reads a <see cref="Byte"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <param name="encoding">Encoding</param>
		/// <returns>The <see cref="Byte"/></returns>
		public static string ReadStringAt(this IBinaryReader reader, long offset, Encoding encoding) {
			reader.Position = offset;
			return reader.ReadString(encoding);
		}

		/// <summary>
		/// Reads a <see cref="Char"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Char"/></returns>
		public static char ReadCharAt(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadChar();
		}

		/// <summary>
		/// Reads a <see cref="Char"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <param name="encoding">Encoding</param>
		/// <returns>The <see cref="Char"/></returns>
		public static char ReadCharAt(this IBinaryReader reader, long offset, Encoding encoding) {
			reader.Position = offset;
			return reader.ReadChar(encoding);
		}

		/// <summary>
		/// Reads a <see cref="Decimal"/> at offset <paramref name="offset"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="offset">Offset</param>
		/// <returns>The <see cref="Decimal"/></returns>
		public static decimal ReadDecimalAt(this IBinaryReader reader, long offset) {
			reader.Position = offset;
			return reader.ReadDecimal();
		}

		/// <summary>
		/// Reads all remaining bytes
		/// </summary>
		/// <param name="reader">this</param>
		/// <returns>All remaining bytes</returns>
		public static byte[] ReadRemainingBytes(this IBinaryReader reader) {
			if (reader.Position >= reader.Length)
				return new byte[0];
			return reader.ReadBytes((int)(reader.Length - reader.Position));
		}

		/// <summary>
		/// Reads all bytes
		/// </summary>
		/// <param name="reader">this</param>
		/// <returns>All bytes</returns>
		public static byte[] ReadAllBytes(this IBinaryReader reader) {
			reader.Position = 0;
			return reader.ReadBytes((int)reader.Length);
		}

		/// <summary>
		/// Reads a <see cref="Boolean"/> from the current position and increments <see cref="IBinaryReader.Position"/> by 1
		/// </summary>
		/// <param name="self">this</param>
		/// <returns>The boolean</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		public static bool ReadBoolean(this IBinaryReader self) {
			return self.ReadByte() != 0;
		}

		/// <summary>
		/// Reads a <see cref="Char"/> from the current position and increments <see cref="IBinaryReader.Position"/> by 2
		/// </summary>
		/// <param name="self">this</param>
		/// <returns>The char</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		public static char ReadChar(this IBinaryReader self) {
			return self.ReadChar(Encoding.UTF8);
		}

		/// <summary>
		/// Reads a <see cref="Char"/> from the current position and increments <see cref="IBinaryReader.Position"/> by 2
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="encoding">Encoding</param>
		/// <returns>The char</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		public static char ReadChar(this IBinaryReader self, Encoding encoding) {
			// This is slow but this method should rarely be called...
			var decoder = encoding.GetDecoder();
			bool twoBytes = encoding is UnicodeEncoding;
			byte[] bytes = new byte[2];
			char[] chars = new char[1];
			while (true) {
				bytes[0] = self.ReadByte();
				if (twoBytes)
					bytes[1] = self.ReadByte();
				int x = decoder.GetChars(bytes, 0, twoBytes ? 2 : 1, chars, 0);
				if (x != 0)
					break;
			}
			return chars[0];
		}

		/// <summary>
		/// Reads a UTF-8 <see cref="string"/> from the current position and increments
		/// <see cref="IBinaryReader.Position"/> by the length of the string.
		/// </summary>
		/// <param name="reader">this</param>
		/// <returns>The string</returns>
		public static string ReadString(this IBinaryReader reader) {
			return reader.ReadString(Encoding.UTF8);
		}

		/// <summary>
		/// Reads a <see cref="string"/> from the current position and increments
		/// <see cref="IBinaryReader.Position"/> by the length of the string.
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="encoding">Encoding</param>
		/// <returns>The string</returns>
		public static string ReadString(this IBinaryReader reader, Encoding encoding) {
			int len = reader.Read7BitEncodedInt32();
			return encoding.GetString(reader.ReadBytes(len));
		}

		/// <summary>
		/// Reads a <see cref="Decimal"/> from the current position and increments
		/// <see cref="IBinaryReader.Position"/> by 16
		/// </summary>
		/// <param name="reader">this</param>
		/// <returns>The decmial</returns>
		/// <exception cref="IOException">An I/O error occurs</exception>
		public static decimal ReadDecimal(this IBinaryReader reader) {
			var bits = new int[4] {
				reader.ReadInt32(),	// lo
				reader.ReadInt32(),	// mid
				reader.ReadInt32(),	// hi
				reader.ReadInt32(),	// flags
			};
			return new decimal(bits);
		}

		/// <summary>
		/// Reads chars
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="length">Number of <see cref="char"/>s to read</param>
		/// <returns>All the chars</returns>
		public static char[] ReadChars(this IBinaryReader reader, int length) {
			var chars = new char[length];
			for (int i = 0; i < length; i++)
				chars[i] = reader.ReadChar();
			return chars;
		}

		/// <summary>
		/// Reads a compressed <see cref="uint"/> from the current position in <paramref name="reader"/>
		/// </summary>
		/// <remarks>Max value it can return is <c>0x1FFFFFFF</c></remarks>
		/// <param name="reader">The reader</param>
		/// <param name="val">Decompressed value</param>
		/// <returns><c>true</c> if successful, <c>false</c> on failure</returns>
		public static bool ReadCompressedUInt32(this IBinaryReader reader, out uint val) {
			var pos = reader.Position;
			var len = reader.Length;
			if (pos >= len) {
				val = 0;
				return false;
			}

			byte b = reader.ReadByte();
			if ((b & 0x80) == 0) {
				val = b;
				return true;
			}

			if ((b & 0xC0) == 0x80) {
				if (pos + 1 < pos || pos + 1 >= len) {
					val = 0;
					return false;
				}
				val = (uint)(((b & 0x3F) << 8) | reader.ReadByte());
				return true;
			}

			// The encoding 111x isn't allowed but the CLR sometimes doesn't verify this
			// and just assumes it's 110x. Don't fail if it's 111x, just assume it's 110x.

			if (pos + 3 < pos || pos + 3 >= len) {
				val = 0;
				return false;
			}
			val = (uint)(((b & 0x1F) << 24) | (reader.ReadByte() << 16) |
					(reader.ReadByte() << 8) | reader.ReadByte());
			return true;
		}

		/// <summary>
		/// Reads a compressed <see cref="int"/> from the current position in <paramref name="reader"/>
		/// </summary>
		/// <param name="reader">The reader</param>
		/// <param name="val">Decompressed value</param>
		/// <returns><c>true</c> if successful, <c>false</c> on failure</returns>
		public static bool ReadCompressedInt32(this IBinaryReader reader, out int val) {
			var pos = reader.Position;
			var len = reader.Length;
			if (pos >= len) {
				val = 0;
				return false;
			}

			byte b = reader.ReadByte();
			if ((b & 0x80) == 0) {
				if ((b & 1) != 0)
					val = -0x40 | (b >> 1);
				else
					val = (b >> 1);
				return true;
			}

			if ((b & 0xC0) == 0x80) {
				if (pos + 1 < pos || pos + 1 >= len) {
					val = 0;
					return false;
				}
				uint tmp = (uint)(((b & 0x3F) << 8) | reader.ReadByte());
				if ((tmp & 1) != 0)
					val = -0x2000 | (int)(tmp >> 1);
				else
					val = (int)(tmp >> 1);
				return true;
			}

			if ((b & 0xE0) == 0xC0) {
				if (pos + 3 < pos || pos + 3 >= len) {
					val = 0;
					return false;
				}
				uint tmp = (uint)(((b & 0x1F) << 24) | (reader.ReadByte() << 16) |
						(reader.ReadByte() << 8) | reader.ReadByte());
				if ((tmp & 1) != 0)
					val = -0x10000000 | (int)(tmp >> 1);
				else
					val = (int)(tmp >> 1);
				return true;
			}

			val = 0;
			return false;
		}

		/// <summary>
		/// Reads a compressed <see cref="uint"/> from the current position in <paramref name="reader"/>
		/// </summary>
		/// <param name="reader">The reader</param>
		/// <returns>The value</returns>
		public static uint ReadCompressedUInt32(this IBinaryReader reader) {
			uint val;
			if (!reader.ReadCompressedUInt32(out val))
				throw new IOException("Could not read a compressed UInt32");
			return val;
		}

		/// <summary>
		/// Reads a compressed <see cref="int"/> from the current position in <paramref name="reader"/>
		/// </summary>
		/// <param name="reader">The reader</param>
		/// <returns>The value</returns>
		public static int ReadCompressedInt32(this IBinaryReader reader) {
			int val;
			if (!reader.ReadCompressedInt32(out val))
				throw new IOException("Could not read a compressed Int32");
			return val;
		}

		/// <summary>
		/// Reads a 7-bit encoded integer
		/// </summary>
		/// <param name="reader">this</param>
		/// <returns>The decoded integer</returns>
		public static uint Read7BitEncodedUInt32(this IBinaryReader reader) {
			uint val = 0;
			int bits = 0;
			for (int i = 0; i < 5; i++) {
				byte b = reader.ReadByte();
				val |= (uint)(b & 0x7F) << bits;
				if ((b & 0x80) == 0)
					return val;
				bits += 7;
			}
			throw new IOException("Invalid encoded UInt32");
		}

		/// <summary>
		/// Reads a 7-bit encoded integer
		/// </summary>
		/// <param name="reader">this</param>
		/// <returns>The decoded integer</returns>
		public static int Read7BitEncodedInt32(this IBinaryReader reader) {
			return (int)reader.Read7BitEncodedUInt32();
		}

		/// <summary>
		/// Creates a <see cref="Stream"/> using <paramref name="reader"/>. The created
		/// <see cref="Stream"/> doesn't own <paramref name="reader"/>, so it's not
		/// <see cref="IDisposable.Dispose()"/>'d.
		/// </summary>
		/// <param name="reader">this</param>
		/// <returns>A new <see cref="Stream"/> instance</returns>
		public static Stream CreateStream(this IBinaryReader reader) {
			return new BinaryReaderStream(reader);
		}

		/// <summary>
		/// Creates a <see cref="Stream"/> using <paramref name="reader"/>
		/// </summary>
		/// <param name="reader">this</param>
		/// <param name="ownsReader"><c>true</c> if the created <see cref="Stream"/> owns
		/// <paramref name="reader"/></param>
		/// <returns>A new <see cref="Stream"/> instance</returns>
		public static Stream CreateStream(this IBinaryReader reader, bool ownsReader) {
			return new BinaryReaderStream(reader, ownsReader);
		}

		/// <summary>
		/// Checks whether we can read <paramref name="size"/> bytes
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <param name="size">Size in bytes</param>
		public static bool CanRead(this IBinaryReader reader, int size) {
			return (reader.Position + size <= reader.Length && reader.Position + size >= reader.Position) || size == 0;
		}

		/// <summary>
		/// Checks whether we can read <paramref name="size"/> bytes
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <param name="size">Size in bytes</param>
		public static bool CanRead(this IBinaryReader reader, uint size) {
			return (reader.Position + size <= reader.Length && reader.Position + size >= reader.Position) || size == 0;
		}

		/// <summary>
		/// Writes <paramref name="reader"/>, starting at <paramref name="reader"/>'s current
		/// position, to <paramref name="writer"/> starting at <paramref name="writer"/>'s
		/// current position. Returns the number of bytes written.
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <param name="writer">Writer</param>
		/// <returns>Number of bytes written</returns>
		/// <exception cref="IOException">Could not write all bytes or data is too big</exception>
		public static uint WriteTo(this IBinaryReader reader, BinaryWriter writer) {
			if (reader.Position >= reader.Length)
				return 0;
			return reader.WriteTo(writer, new byte[0x2000]);
		}

		/// <summary>
		/// Writes <paramref name="reader"/>, starting at <paramref name="reader"/>'s current
		/// position, to <paramref name="writer"/> starting at <paramref name="writer"/>'s
		/// current position. Returns the number of bytes written.
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <param name="writer">Writer</param>
		/// <param name="dataBuffer">Temp buffer during writing</param>
		/// <returns>Number of bytes written</returns>
		/// <exception cref="IOException">Could not write all bytes or data is too big</exception>
		public static uint WriteTo(this IBinaryReader reader, BinaryWriter writer, byte[] dataBuffer) {
			if (reader.Position >= reader.Length)
				return 0;
			long longLenLeft = reader.Length - reader.Position;
			if (longLenLeft > uint.MaxValue)
				throw new IOException("Data is too big");
			uint lenLeft = (uint)longLenLeft;
			uint writtenBytes = lenLeft;
			while (lenLeft > 0) {
				int num = (int)Math.Min((uint)dataBuffer.Length, lenLeft);
				lenLeft -= (uint)num;
				if (num != reader.Read(dataBuffer, 0, num))
					throw new IOException("Could not read all reader bytes");
				writer.Write(dataBuffer, 0, num);
			}
			return writtenBytes;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/IFileSection.cs
================================================
// dnlib: See LICENSE.txt for more info

namespace dnlib.IO {
	/// <summary>
	/// Represents a section in a file
	/// </summary>
	public interface IFileSection {
		/// <summary>
		/// Start offset of the section in the file
		/// </summary>
		FileOffset StartOffset { get; }

		/// <summary>
		/// End offset of the section in the file. This is one byte after the last
		/// valid offset in the section.
		/// </summary>
		FileOffset EndOffset { get; }
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/IImageStream.cs
================================================
// dnlib: See LICENSE.txt for more info

namespace dnlib.IO {
	/// <summary>
	/// Interface to access part of some data
	/// </summary>
	public interface IImageStream : IBinaryReader {
		/// <summary>
		/// Returns the file offset of the stream
		/// </summary>
		FileOffset FileOffset { get; }

		/// <summary>
		/// Creates a sub stream that can access parts of this stream
		/// </summary>
		/// <param name="offset">File offset relative to the start of this stream</param>
		/// <param name="length">Length</param>
		/// <returns>A new stream</returns>
		IImageStream Create(FileOffset offset, long length);
	}

	static partial class IOExtensions {
		/// <summary>
		/// Creates a stream that can access all data starting from <paramref name="offset"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="offset">Offset relative to the beginning of the stream</param>
		/// <returns>A new stream</returns>
		public static IImageStream Create(this IImageStream self, FileOffset offset) {
			return self.Create(offset, long.MaxValue);
		}

		/// <summary>
		/// Clones this <see cref="IImageStream"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns>A new <see cref="IImageStream"/> instance</returns>
		public static IImageStream Clone(this IImageStream self) {
			return self.Create(0, long.MaxValue);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/IImageStreamCreator.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.IO {
	/// <summary>
	/// Creates a new stream that accesses part of some data
	/// </summary>
	public interface IImageStreamCreator : IDisposable {
		/// <summary>
		/// The file name or <c>null</c> if data is not from a file
		/// </summary>
		string FileName { get; }

		/// <summary>
		/// Returns the total length of the original data
		/// </summary>
		long Length { get; }

		/// <summary>
		/// Creates a stream that can access only part of the data
		/// </summary>
		/// <param name="offset">Offset within the original data</param>
		/// <param name="length">Length of section within the original data</param>
		/// <returns>A new stream</returns>
		IImageStream Create(FileOffset offset, long length);

		/// <summary>
		/// Creates a stream that can access all data
		/// </summary>
		/// <returns>A new stream</returns>
		IImageStream CreateFull();
	}

	static partial class IOExtensions {
		/// <summary>
		/// Creates a stream that can access all data starting from <paramref name="offset"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="offset">Offset within the original data</param>
		/// <returns>A new stream</returns>
		public static IImageStream Create(this IImageStreamCreator self, FileOffset offset) {
			return self.Create(offset, long.MaxValue);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/IOExtensions.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.IO {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class IOExtensions {
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/ImageStreamCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.IO;

namespace dnlib.IO {
	/// <summary>
	/// Creates a <see cref="IImageStreamCreator"/> instance
	/// </summary>
	public static class ImageStreamCreator {
		static readonly bool isUnix;

		static ImageStreamCreator() {
			// See http://mono-project.com/FAQ:_Technical#Mono_Platforms for platform detection.
			int p = (int)Environment.OSVersion.Platform;
			if (p == 4 || p == 6 || p == 128)
				isUnix = true;
		}

		/// <summary>
		/// Creates a <see cref="IImageStreamCreator"/>. It will be a
		/// <see cref="MemoryMappedFileStreamCreator"/> if the operating system supports the memory
		/// mapped file methods we use, else <see cref="MemoryStreamCreator"/>.
		/// </summary>
		/// <param name="fileName">Filename</param>
		/// <returns>A new <see cref="ImageStreamCreator"/> instance</returns>
		public static IImageStreamCreator Create(string fileName) {
			return Create(fileName, false);
		}

		/// <summary>
		/// Creates a <see cref="IImageStreamCreator"/>. It will be a
		/// <see cref="MemoryMappedFileStreamCreator"/> if the operating system supports the memory
		/// mapped file methods we use, else <see cref="MemoryStreamCreator"/>.
		/// </summary>
		/// <param name="fileName">Filename</param>
		/// <param name="mapAsImage"><c>true</c> if we should map it as an executable. Not supported
		/// on Linux/Mac</param>
		/// <returns>A new <see cref="ImageStreamCreator"/> instance</returns>
		public static IImageStreamCreator Create(string fileName, bool mapAsImage) {
			var creator = CreateMemoryMappedFileStreamCreator(fileName, mapAsImage);
			if (creator != null)
				return creator;

			return new MemoryStreamCreator(File.ReadAllBytes(fileName)) { FileName = fileName };
		}

		static MemoryMappedFileStreamCreator CreateMemoryMappedFileStreamCreator(string fileName, bool mapAsImage) {
			if (!isUnix)
				return MemoryMappedFileStreamCreator.CreateWindows(fileName, mapAsImage);
			else
				return MemoryMappedFileStreamCreator.CreateUnix(fileName, mapAsImage);
		}

		/// <summary>
		/// Creates a <see cref="IImageStream"/>
		/// </summary>
		/// <param name="fileName">Filename</param>
		/// <returns>A new <see cref="IImageStream"/> instance</returns>
		public static IImageStream CreateImageStream(string fileName) {
			return CreateImageStream(fileName, false);
		}

		/// <summary>
		/// Creates a <see cref="IImageStream"/>
		/// </summary>
		/// <param name="fileName">Filename</param>
		/// <param name="mapAsImage"><c>true</c> if we should map it as an executable. Not supported
		/// on Linux/Mac</param>
		/// <returns>A new <see cref="IImageStream"/> instance</returns>
		public static IImageStream CreateImageStream(string fileName, bool mapAsImage) {
			var creator = CreateMemoryMappedFileStreamCreator(fileName, mapAsImage);
			try {
				if (creator != null)
					return new UnmanagedMemoryImageStream(creator);
				return MemoryImageStream.Create(File.ReadAllBytes(fileName));
			}
			catch {
				if (creator != null)
					creator.Dispose();
				throw;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/MemoryImageStream.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.IO;

namespace dnlib.IO {
	/// <summary>
	/// IImageStream for byte[]
	/// </summary>
	[DebuggerDisplay("FO:{fileOffset} S:{Length}")]
	public sealed class MemoryImageStream : IImageStream {
		FileOffset fileOffset;
		byte[] data;
		int dataOffset;
		int dataEnd;
		int position;

		/// <summary>
		/// Creates a new <see cref="MemoryImageStream"/> instance
		/// </summary>
		/// <param name="data">Data</param>
		/// <returns>A new <see cref="MemoryImageStream"/> instance</returns>
		public static MemoryImageStream Create(byte[] data) {
			return new MemoryImageStream(0, data, 0, data.Length);
		}

		/// <summary>
		/// Creates a new <see cref="MemoryImageStream"/> instance
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="offset">Start offset in <paramref name="data"/></param>
		/// <param name="len">Length of data</param>
		/// <returns>A new <see cref="MemoryImageStream"/> instance</returns>
		public static MemoryImageStream Create(byte[] data, int offset, int len) {
			return new MemoryImageStream(0, data, offset, len);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fileOffset">File offset of data</param>
		/// <param name="data">The data</param>
		/// <param name="dataOffset">Start offset in <paramref name="data"/></param>
		/// <param name="dataLength">Length of data</param>
		public MemoryImageStream(FileOffset fileOffset, byte[] data, int dataOffset, int dataLength) {
			this.fileOffset = fileOffset;
			this.data = data;
			this.dataOffset = dataOffset;
			this.dataEnd = dataOffset + dataLength;
			this.position = dataOffset;
		}

		/// <summary>
		/// Gets the data
		/// </summary>
		internal byte[] DataArray {
			get { return data; }
		}

		/// <summary>
		/// Gets the start of the data in <see cref="DataArray"/> used by this stream
		/// </summary>
		internal int DataOffset {
			get { return dataOffset; }
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return fileOffset; }
		}

		/// <inheritdoc/>
		public long Length {
			get { return dataEnd - dataOffset; }
		}

		/// <inheritdoc/>
		public long Position {
			get { return position - dataOffset; }
			set {
				long newPos = dataOffset + value;
				if (newPos < dataOffset || newPos > int.MaxValue)
					newPos = int.MaxValue;
				position = (int)newPos;
			}
		}

		/// <summary>
		/// Creates an empty <see cref="MemoryImageStream"/> instance
		/// </summary>
		public static MemoryImageStream CreateEmpty() {
			return new MemoryImageStream(0, new byte[0], 0, 0);
		}

		/// <inheritdoc/>
		public IImageStream Create(FileOffset offset, long length) {
			if ((long)offset < 0 || length < 0)
				return MemoryImageStream.CreateEmpty();

			int offs = (int)Math.Min((long)Length, (long)offset);
			int len = (int)Math.Min((long)Length - offs, length);
			return new MemoryImageStream((FileOffset)((long)fileOffset + (long)offset), data, dataOffset + offs, len);
		}

		/// <inheritdoc/>
		public byte[] ReadBytes(int size) {
			if (size < 0)
				throw new IOException("Invalid size");
			size = Math.Min(size, (int)Length - Math.Min((int)Length, (int)Position));
			var newData = new byte[size];
			Array.Copy(data, position, newData, 0, size);
			position += size;
			return newData;
		}

		/// <inheritdoc/>
		public int Read(byte[] buffer, int offset, int length) {
			if (length < 0)
				throw new IOException("Invalid size");
			length = Math.Min(length, (int)Length - Math.Min((int)Length, (int)Position));
			Array.Copy(data, position, buffer, offset, length);
			position += length;
			return length;
		}

		/// <inheritdoc/>
		public byte[] ReadBytesUntilByte(byte b) {
			int pos = GetPositionOf(b);
			if (pos < 0)
				return null;
			return ReadBytes(pos - position);
		}

		int GetPositionOf(byte b) {
			int pos = position;
			while (pos < dataEnd) {
				if (data[pos] == b)
					return pos;
				pos++;
			}
			return -1;
		}

		/// <inheritdoc/>
		public sbyte ReadSByte() {
			if (position >= dataEnd)
				throw new IOException("Can't read one SByte");
			return (sbyte)data[position++];
		}

		/// <inheritdoc/>
		public byte ReadByte() {
			if (position >= dataEnd)
				throw new IOException("Can't read one Byte");
			return data[position++];
		}

		/// <inheritdoc/>
		public short ReadInt16() {
			if (position + 1 >= dataEnd)
				throw new IOException("Can't read one Int16");
			return (short)(data[position++] | (data[position++] << 8));
		}

		/// <inheritdoc/>
		public ushort ReadUInt16() {
			if (position + 1 >= dataEnd)
				throw new IOException("Can't read one UInt16");
			return (ushort)(data[position++] | (data[position++] << 8));
		}

		/// <inheritdoc/>
		public int ReadInt32() {
			if (position + 3 >= dataEnd)
				throw new IOException("Can't read one Int32");
			return data[position++] |
					(data[position++] << 8) |
					(data[position++] << 16) |
					(data[position++] << 24);
		}

		/// <inheritdoc/>
		public uint ReadUInt32() {
			if (position + 3 >= dataEnd)
				throw new IOException("Can't read one UInt32");
			return (uint)(data[position++] |
					(data[position++] << 8) |
					(data[position++] << 16) |
					(data[position++] << 24));
		}

		/// <inheritdoc/>
		public long ReadInt64() {
			if (position + 7 >= dataEnd)
				throw new IOException("Can't read one Int64");
			return (long)data[position++] |
					((long)data[position++] << 8) |
					((long)data[position++] << 16) |
					((long)data[position++] << 24) |
					((long)data[position++] << 32) |
					((long)data[position++] << 40) |
					((long)data[position++] << 48) |
					((long)data[position++] << 56);
		}

		/// <inheritdoc/>
		public ulong ReadUInt64() {
			if (position + 7 >= dataEnd)
				throw new IOException("Can't read one UInt64");
			return (ulong)data[position++] |
					((ulong)data[position++] << 8) |
					((ulong)data[position++] << 16) |
					((ulong)data[position++] << 24) |
					((ulong)data[position++] << 32) |
					((ulong)data[position++] << 40) |
					((ulong)data[position++] << 48) |
					((ulong)data[position++] << 56);
		}

		/// <inheritdoc/>
		public float ReadSingle() {
			if (position + 3 >= dataEnd)
				throw new IOException("Can't read one Single");
			var val = BitConverter.ToSingle(data, position);
			position += 4;
			return val;
		}

		/// <inheritdoc/>
		public double ReadDouble() {
			if (position + 7 >= dataEnd)
				throw new IOException("Can't read one Double");
			var val = BitConverter.ToDouble(data, position);
			position += 8;
			return val;
		}

		/// <inheritdoc/>
		public unsafe string ReadString(int chars) {
			if ((uint)chars > (uint)int.MaxValue)
				throw new IOException("Not enough space to read the string");
			if (position + chars * 2 < position || (chars != 0 && position + chars * 2 - 1 >= dataEnd))
				throw new IOException("Not enough space to read the string");
			string res;
			fixed (byte* p = data)
				res = new string((char*)(p + position), 0, chars);
			position += chars * 2;
			return res;
		}

		/// <inheritdoc/>
		public void Dispose() {
			fileOffset = 0;
			data = null;
			dataOffset = 0;
			dataEnd = 0;
			position = 0;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/MemoryMappedFileStreamCreator.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Threading;
using Microsoft.Win32.SafeHandles;

namespace dnlib.IO {
	/// <summary>
	/// Maps a file into memory using MapViewOfFile() and creates streams
	/// that can access part of it in memory.
	/// </summary>
	/// <remarks>Since this class maps a file into memory, the user should call
	/// <see cref="UnmanagedMemoryStreamCreator.Dispose()"/> to free any resources
	/// used by the class when it's no longer needed.</remarks>
	[DebuggerDisplay("mmap: A:{data} L:{dataLength} {theFileName}")]
	sealed class MemoryMappedFileStreamCreator : UnmanagedMemoryStreamCreator {

		OSType osType = OSType.Unknown;
		long origDataLength;

		enum OSType : byte {
			Unknown,
			Windows,
			Unix,
		}

		[Serializable]
		sealed class MemoryMappedIONotSupportedException : IOException {
			public MemoryMappedIONotSupportedException() {
			}

			public MemoryMappedIONotSupportedException(string s)
				: base(s) {
			}

			public MemoryMappedIONotSupportedException(SerializationInfo info, StreamingContext context)
				: base(info, context) {
			}
		}

		static class Windows {
			const uint GENERIC_READ = 0x80000000;
			const uint FILE_SHARE_READ = 0x00000001;
			const uint OPEN_EXISTING = 3;
			const uint FILE_ATTRIBUTE_NORMAL = 0x00000080;
			const uint PAGE_READONLY = 0x02;
			const uint SEC_IMAGE = 0x1000000;
			const uint SECTION_MAP_READ = 0x0004;
			const uint FILE_MAP_READ = SECTION_MAP_READ;

			[DllImport("kernel32", SetLastError = true, CharSet = CharSet.Auto)]
			static extern SafeFileHandle CreateFile(string lpFileName, uint dwDesiredAccess, uint dwShareMode, IntPtr lpSecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);

			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			static extern SafeFileHandle CreateFileMapping(SafeFileHandle hFile, IntPtr lpAttributes, uint flProtect, uint dwMaximumSizeHigh, uint dwMaximumSizeLow, string lpName);

			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			static extern IntPtr MapViewOfFile(SafeFileHandle hFileMappingObject, uint dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, UIntPtr dwNumberOfBytesToMap);

			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			static extern bool UnmapViewOfFile(IntPtr lpBaseAddress);

			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			static extern uint GetFileSize(SafeFileHandle hFile, out uint lpFileSizeHigh);
			const uint INVALID_FILE_SIZE = 0xFFFFFFFF;
			const int NO_ERROR = 0;

			public static void Mmap(MemoryMappedFileStreamCreator creator, bool mapAsImage) {
				using (var fileHandle = CreateFile(creator.theFileName, GENERIC_READ, FILE_SHARE_READ, IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero)) {
					if (fileHandle.IsInvalid)
						throw new IOException(string.Format("Could not open file {0} for reading. Error: {1:X8}", creator.theFileName, Marshal.GetLastWin32Error()));

					uint sizeHi;
					uint sizeLo = GetFileSize(fileHandle, out sizeHi);
					int hr;
					if (sizeLo == INVALID_FILE_SIZE && (hr = Marshal.GetLastWin32Error()) != NO_ERROR)
						throw new IOException(string.Format("Could not get file size. File: {0}, error: {1:X8}", creator.theFileName, hr));
					var fileSize = ((long)sizeHi << 32) | sizeLo;

					using (var fileMapping = CreateFileMapping(fileHandle, IntPtr.Zero, PAGE_READONLY | (mapAsImage ? SEC_IMAGE : 0), 0, 0, null)) {
						if (fileMapping.IsInvalid)
							throw new MemoryMappedIONotSupportedException(string.Format("Could not create a file mapping object. File: {0}, error: {1:X8}", creator.theFileName, Marshal.GetLastWin32Error()));
						creator.data = MapViewOfFile(fileMapping, FILE_MAP_READ, 0, 0, UIntPtr.Zero);
						if (creator.data == IntPtr.Zero)
							throw new MemoryMappedIONotSupportedException(string.Format("Could not map file {0}. Error: {1:X8}", creator.theFileName, Marshal.GetLastWin32Error()));
						creator.dataLength = fileSize;
						creator.osType = OSType.Windows;
					}
				}
			}

			public static void Dispose(IntPtr addr) {
				if (addr != IntPtr.Zero)
					UnmapViewOfFile(addr);
			}
		}

		static class Unix {
			// Can't use SafeFileHandle. Seems like a bug in mono. You'll get
			// "_wapi_handle_unref_full: Attempting to unref unused handle 0xYYY" when Dispose() is called.
			[DllImport("libc")]
			static extern int open(string pathname, int flags);
			const int O_RDONLY = 0;

			[DllImport("libc")]
			static extern int close(int fd);

			[DllImport("libc", EntryPoint = "lseek", SetLastError = true)]
			static extern int lseek32(int fd, int offset, int whence);
			[DllImport("libc", EntryPoint = "lseek", SetLastError = true)]
			static extern long lseek64(int fd, long offset, int whence);
			const int SEEK_END = 2;

			[DllImport("libc", EntryPoint = "mmap", SetLastError = true)]
			static extern IntPtr mmap32(IntPtr addr, IntPtr length, int prot, int flags, int fd, int offset);
			[DllImport("libc", EntryPoint = "mmap", SetLastError = true)]
			static extern IntPtr mmap64(IntPtr addr, IntPtr length, int prot, int flags, int fd, long offset);
			const int PROT_READ = 1;
			const int MAP_PRIVATE = 0x02;

			[DllImport("libc")]
			static extern int munmap(IntPtr addr, IntPtr length);

			public static void Mmap(MemoryMappedFileStreamCreator creator, bool mapAsImage) {
				int fd = open(creator.theFileName, O_RDONLY);
				try {
					if (fd < 0)
						throw new IOException(string.Format("Could not open file {0} for reading. Error: {1}", creator.theFileName, fd));

					long size;
					IntPtr data;

					if (IntPtr.Size == 4) {
						size = lseek32(fd, 0, SEEK_END);
						if (size == -1)
							throw new MemoryMappedIONotSupportedException(string.Format("Could not get length of {0} (lseek failed): {1}", creator.theFileName, Marshal.GetLastWin32Error()));

						data = mmap32(IntPtr.Zero, (IntPtr)size, PROT_READ, MAP_PRIVATE, fd, 0);
						if (data == new IntPtr(-1) || data == IntPtr.Zero)
							throw new MemoryMappedIONotSupportedException(string.Format("Could not map file {0}. Error: {1}", creator.theFileName, Marshal.GetLastWin32Error()));
					}
					else {
						size = lseek64(fd, 0, SEEK_END);
						if (size == -1)
							throw new MemoryMappedIONotSupportedException(string.Format("Could not get length of {0} (lseek failed): {1}", creator.theFileName, Marshal.GetLastWin32Error()));

						data = mmap64(IntPtr.Zero, (IntPtr)size, PROT_READ, MAP_PRIVATE, fd, 0);
						if (data == new IntPtr(-1) || data == IntPtr.Zero)
							throw new MemoryMappedIONotSupportedException(string.Format("Could not map file {0}. Error: {1}", creator.theFileName, Marshal.GetLastWin32Error()));
					}

					creator.data = data;
					creator.dataLength = size;
					creator.origDataLength = creator.dataLength;
					creator.osType = OSType.Unix;
				}
				finally {
					if (fd >= 0)
						close(fd);
				}
			}

			public static void Dispose(IntPtr addr, long size) {
				if (addr != IntPtr.Zero)
					munmap(addr, new IntPtr(size));
			}
		}

		static bool canTryWindows = true;
		static bool canTryUnix = true;

		/// <summary>
		/// Creates a new <see cref="MemoryMappedFileStreamCreator"/> if supported or returns
		/// <c>null</c> if the OS functions aren't supported.
		/// </summary>
		/// <remarks>If <paramref name="mapAsImage"/> is <c>true</c>, then the created
		/// <see cref="UnmanagedMemoryStreamCreator"/> that is used internally by the class,
		/// can only access bytes up to the file size, not to the end of the mapped image. You must
		/// set <see cref="UnmanagedMemoryStreamCreator.Length"/> to the correct image length to access the full image.</remarks>
		/// <param name="fileName">Name of the file</param>
		/// <param name="mapAsImage"><c>true</c> if we should map it as an executable</param>
		/// <exception cref="IOException">If we can't open/map the file</exception>
		internal static MemoryMappedFileStreamCreator CreateWindows(string fileName, bool mapAsImage) {
			if (!canTryWindows)
				return null;

			var creator = new MemoryMappedFileStreamCreator();
			creator.theFileName = GetFullPath(fileName);
			try {
				Windows.Mmap(creator, mapAsImage);
				return creator;
			}
			catch (EntryPointNotFoundException) {
			}
			catch (DllNotFoundException) {
			}
			canTryWindows = false;
			return null;
		}

		/// <summary>
		/// Creates a new <see cref="MemoryMappedFileStreamCreator"/> if supported or returns
		/// <c>null</c> if the OS functions aren't supported.
		/// </summary>
		/// <remarks>If <paramref name="mapAsImage"/> is <c>true</c>, then the created
		/// <see cref="UnmanagedMemoryStreamCreator"/> that is used internally by the class,
		/// can only access bytes up to the file size, not to the end of the mapped image. You must
		/// set <see cref="UnmanagedMemoryStreamCreator.Length"/> to the correct image length to access the full image.</remarks>
		/// <param name="fileName">Name of the file</param>
		/// <param name="mapAsImage">NOT SUPPORTED. <c>true</c> if we should map it as an executable</param>
		/// <exception cref="IOException">If we can't open/map the file</exception>
		internal static MemoryMappedFileStreamCreator CreateUnix(string fileName, bool mapAsImage) {
			if (!canTryUnix)
				return null;

			var creator = new MemoryMappedFileStreamCreator();
			creator.theFileName = GetFullPath(fileName);
			try {
				Unix.Mmap(creator, mapAsImage);
				if (mapAsImage) { // Only check this if we know that mmap() works, i.e., if above call succeeds
					creator.Dispose();
					throw new ArgumentException("mapAsImage == true is not supported on this OS");
				}
				return creator;
			}
			catch (MemoryMappedIONotSupportedException ex) {
				Debug.WriteLine(string.Format("mmap'd IO didn't work: {0}", ex.Message));
			}
			catch (EntryPointNotFoundException) {
			}
			catch (DllNotFoundException) {
			}
			canTryUnix = false;
			return null;
		}

		static string GetFullPath(string fileName) {
			try {
				return Path.GetFullPath(fileName);
			}
			catch {
				return fileName;
			}
		}

		/// <inheritdoc/>
		~MemoryMappedFileStreamCreator() {
			Dispose(false);
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			FreeMemoryMappedIoData();
			base.Dispose(disposing);
		}

		/// <summary>
		/// <c>true</c> if memory mapped I/O is enabled
		/// </summary>
		public bool IsMemoryMappedIO {
			get { return dataAry == null; }
		}

		/// <summary>
		/// Call this to disable memory mapped I/O. This must only be called if no other code is
		/// trying to access the memory since that could lead to an exception.
		/// </summary>
		public void UnsafeDisableMemoryMappedIO() {
			if (dataAry != null)
				return;
			if (unsafeUseAddress)
				throw new InvalidOperationException("Can't convert to non-memory mapped I/O because the PDB reader uses the address. Use the managed PDB reader instead.");
			var newAry = new byte[Length];
			Marshal.Copy(data, newAry, 0, newAry.Length);
			FreeMemoryMappedIoData();
			dataLength = newAry.Length;
			dataAry = newAry;
			gcHandle = GCHandle.Alloc(dataAry, GCHandleType.Pinned);
			this.data = gcHandle.AddrOfPinnedObject();
		}
		GCHandle gcHandle;
		byte[] dataAry;

		void FreeMemoryMappedIoData() {
			if (dataAry == null) {
				var origData = Interlocked.Exchange(ref data, IntPtr.Zero);
				if (origData != IntPtr.Zero) {
					dataLength = 0;
					switch (osType) {
					case OSType.Windows:
						Windows.Dispose(origData);
						break;

					case OSType.Unix:
						Unix.Dispose(origData, origDataLength);
						break;

					default:
						throw new InvalidOperationException("Shouldn't be here");
					}
				}
			}

			if (gcHandle.IsAllocated) {
				try {
					gcHandle.Free();
				}
				catch (InvalidOperationException) {
				}
			}
			dataAry = null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/MemoryStreamCreator.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Diagnostics;
using System.IO;

namespace dnlib.IO {
	/// <summary>
	/// Creates <see cref="MemoryStream"/>s to partially access a byte[]
	/// </summary>
	/// <seealso cref="UnmanagedMemoryStreamCreator"/>
	[DebuggerDisplay("byte[]: O:{dataOffset} L:{dataLength} {theFileName}")]
	sealed class MemoryStreamCreator : IImageStreamCreator {
		byte[] data;
		int dataOffset;
		int dataLength;
		string theFileName;

		/// <summary>
		/// The file name
		/// </summary>
		public string FileName {
			get { return theFileName; }
			set { theFileName = value; }
		}

		/// <inheritdoc/>
		public long Length {
			get { return dataLength; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The data</param>
		public MemoryStreamCreator(byte[] data)
			: this(data, 0, data.Length) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The data</param>
		/// <param name="offset">Start offset in <paramref name="data"/></param>
		/// <param name="length">Length of data starting from <paramref name="offset"/></param>
		/// <exception cref="ArgumentOutOfRangeException">If one of the args is invalid</exception>
		public MemoryStreamCreator(byte[] data, int offset, int length) {
			if (offset < 0)
				throw new ArgumentOutOfRangeException("offset");
			if (length < 0 || offset + length < offset)
				throw new ArgumentOutOfRangeException("length");
			if (offset + length > data.Length)
				throw new ArgumentOutOfRangeException("length");
			this.data = data;
			this.dataOffset = offset;
			this.dataLength = length;
		}

		/// <inheritdoc/>
		public IImageStream Create(FileOffset offset, long length) {
			if (offset < 0 || length < 0)
				return MemoryImageStream.CreateEmpty();

			int offs = (int)Math.Min((long)dataLength, (long)offset);
			int len = (int)Math.Min((long)dataLength - offs, length);
			return new MemoryImageStream(offset, data, dataOffset + offs, len);
		}

		/// <inheritdoc/>
		public IImageStream CreateFull() {
			return new MemoryImageStream(0, data, dataOffset, dataLength);
		}

		/// <inheritdoc/>
		public void Dispose() {
			data = null;
			dataOffset = 0;
			dataLength = 0;
			theFileName = null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/UnmanagedMemoryImageStream.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

namespace dnlib.IO {
	/// <summary>
	/// IImageStream for unmanaged memory
	/// </summary>
	[DebuggerDisplay("FO:{fileOffset} S:{Length} A:{startAddr}")]
	sealed unsafe class UnmanagedMemoryImageStream : IImageStream {
		FileOffset fileOffset;
		long startAddr;
		long endAddr;
		long currentAddr;
		UnmanagedMemoryStreamCreator owner;
		bool ownOwner;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="owner">Owner of memory</param>
		/// <param name="fileOffset">File offset of data</param>
		/// <param name="baseAddr">Address of data</param>
		/// <param name="length">Length of data</param>
		public unsafe UnmanagedMemoryImageStream(UnmanagedMemoryStreamCreator owner, FileOffset fileOffset, long baseAddr, long length) {
			this.fileOffset = fileOffset;
			this.startAddr = baseAddr;
			this.endAddr = baseAddr + length;
			this.currentAddr = this.startAddr;
			this.owner = owner;
		}

		/// <summary>
		/// Saves <paramref name="creator"/> in this instance so it doesn't get garbage collected.
		/// </summary>
		/// <param name="creator">A <see cref="UnmanagedMemoryStreamCreator"/> instance</param>
		internal UnmanagedMemoryImageStream(UnmanagedMemoryStreamCreator creator)
			: this(creator, 0, 0, creator.Length) {
			this.ownOwner = true;
		}

		/// <inheritdoc/>
		public FileOffset FileOffset {
			get { return fileOffset; }
		}

		/// <summary>
		/// Gets the start address of the memory this instance uses
		/// </summary>
		internal unsafe IntPtr StartAddress {
			get { return new IntPtr((byte*)owner.UnsafeUseAddress + startAddr); }
		}

		/// <inheritdoc/>
		public unsafe long Length {
			get { return endAddr - startAddr; }
		}

		/// <inheritdoc/>
		public unsafe long Position {
			get { return currentAddr - startAddr; }
			set {
				if (IntPtr.Size == 4 && (ulong)value > int.MaxValue)
					value = int.MaxValue;
				long newAddr = startAddr + value;
				if (newAddr < startAddr)
					newAddr = endAddr;
				currentAddr = newAddr;
			}
		}

		/// <inheritdoc/>
		public unsafe IImageStream Create(FileOffset offset, long length) {
			if ((long)offset < 0 || length < 0)
				return MemoryImageStream.CreateEmpty();

			long offs = Math.Min(Length, (long)offset);
			long len = Math.Min(Length - offs, length);
			return new UnmanagedMemoryImageStream(owner, (FileOffset)((long)fileOffset + (long)offset), startAddr + (long)offs, len);
		}

		/// <inheritdoc/>
		public unsafe byte[] ReadBytes(int size) {
			if (size < 0)
				throw new IOException("Invalid size");
			size = (int)Math.Min(size, Length - Math.Min(Length, Position));
			var newData = new byte[size];
			Marshal.Copy(new IntPtr((byte*)owner.Address + currentAddr), newData, 0, size);
			currentAddr += size;
			return newData;
		}

		/// <inheritdoc/>
		public int Read(byte[] buffer, int offset, int length) {
			if (length < 0)
				throw new IOException("Invalid size");
			length = (int)Math.Min(length, Length - Math.Min(Length, Position));
			Marshal.Copy(new IntPtr((byte*)owner.Address + currentAddr), buffer, offset, length);
			currentAddr += length;
			return length;
		}

		/// <inheritdoc/>
		public byte[] ReadBytesUntilByte(byte b) {
			long pos = GetPositionOf(b);
			if (pos == -1)
				return null;
			return ReadBytes((int)(pos - currentAddr));
		}

		unsafe long GetPositionOf(byte b) {
			byte* pos = (byte*)owner.Address + currentAddr;
			byte* posStart = pos;
			var endPos = (byte*)owner.Address + endAddr;
			while (pos < endPos) {
				if (*pos == b)
					return currentAddr + (pos - posStart);
				pos++;
			}
			return -1;
		}

		/// <inheritdoc/>
		public unsafe sbyte ReadSByte() {
			if (currentAddr >= endAddr)
				throw new IOException("Can't read one SByte");
			return (sbyte)*((byte*)owner.Address + currentAddr++);
		}

		/// <inheritdoc/>
		public unsafe byte ReadByte() {
			if (currentAddr >= endAddr)
				throw new IOException("Can't read one Byte");
			return *((byte*)owner.Address + currentAddr++);
		}

		/// <inheritdoc/>
		public unsafe short ReadInt16() {
			if (currentAddr + 1 >= endAddr)
				throw new IOException("Can't read one Int16");
			short val = *(short*)((byte*)owner.Address + currentAddr);
			currentAddr += 2;
			return val;
		}

		/// <inheritdoc/>
		public unsafe ushort ReadUInt16() {
			if (currentAddr + 1 >= endAddr)
				throw new IOException("Can't read one UInt16");
			ushort val = *(ushort*)((byte*)owner.Address + currentAddr);
			currentAddr += 2;
			return val;
		}

		/// <inheritdoc/>
		public unsafe int ReadInt32() {
			if (currentAddr + 3 >= endAddr)
				throw new IOException("Can't read one Int32");
			int val = *(int*)((byte*)owner.Address + currentAddr);
			currentAddr += 4;
			return val;
		}

		/// <inheritdoc/>
		public unsafe uint ReadUInt32() {
			if (currentAddr + 3 >= endAddr)
				throw new IOException("Can't read one UInt32");
			uint val = *(uint*)((byte*)owner.Address + currentAddr);
			currentAddr += 4;
			return val;
		}

		/// <inheritdoc/>
		public unsafe long ReadInt64() {
			if (currentAddr + 7 >= endAddr)
				throw new IOException("Can't read one Int64");
			long val = *(long*)((byte*)owner.Address + currentAddr);
			currentAddr += 8;
			return val;
		}

		/// <inheritdoc/>
		public unsafe ulong ReadUInt64() {
			if (currentAddr + 7 >= endAddr)
				throw new IOException("Can't read one UInt64");
			ulong val = *(ulong*)((byte*)owner.Address + currentAddr);
			currentAddr += 8;
			return val;
		}

		/// <inheritdoc/>
		public unsafe float ReadSingle() {
			if (currentAddr + 3 >= endAddr)
				throw new IOException("Can't read one Single");
			var val = *(float*)((byte*)owner.Address + currentAddr);
			currentAddr += 4;
			return val;
		}

		/// <inheritdoc/>
		public unsafe double ReadDouble() {
			if (currentAddr + 7 >= endAddr)
				throw new IOException("Can't read one Double");
			var val = *(double*)((byte*)owner.Address + currentAddr);
			currentAddr += 8;
			return val;
		}

		/// <inheritdoc/>
		public unsafe string ReadString(int chars) {
			if (IntPtr.Size == 4 && (uint)chars > (uint)int.MaxValue)
				throw new IOException("Not enough space to read the string");
			if (currentAddr + chars * 2 < currentAddr || (chars != 0 && currentAddr + chars * 2 - 1 >= endAddr))
				throw new IOException("Not enough space to read the string");
			var s = new string((char*)((byte*)owner.Address + currentAddr), 0, chars);
			currentAddr += chars * 2;
			return s;
		}

		/// <inheritdoc/>
		public void Dispose() {
			fileOffset = 0;
			startAddr = 0;
			endAddr = 0;
			currentAddr = 0;
			if (ownOwner && owner != null)
				owner.Dispose();
			owner = null;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/IO/UnmanagedMemoryStreamCreator.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Diagnostics;
using System.IO;

namespace dnlib.IO {
	/// <summary>
	/// Creates <see cref="UnmanagedMemoryStream"/>s to partially access an
	/// unmanaged memory range
	/// </summary>
	/// <seealso cref="MemoryStreamCreator"/>
	[DebuggerDisplay("mem: D:{data} L:{dataLength} {theFileName}")]
	class UnmanagedMemoryStreamCreator : IImageStreamCreator {
		/// <summary>
		/// Address of data
		/// </summary>
		protected IntPtr data;

		/// <summary>
		/// Length of data
		/// </summary>
		protected long dataLength;

		/// <summary>
		/// Name of file
		/// </summary>
		protected string theFileName;

		/// <summary>
		/// The file name
		/// </summary>
		public string FileName {
			get { return theFileName; }
			set { theFileName = value; }
		}

		/// <summary>
		/// Size of the data
		/// </summary>
		public long Length {
			get { return dataLength; }
			set { dataLength = value; }
		}

		/// <summary>
		/// Returns the base address of the data
		/// </summary>
		public IntPtr Address {
			get { return data; }
		}

		public IntPtr UnsafeUseAddress {
			get {
				unsafeUseAddress = true;
				return data;
			}
		}
		protected bool unsafeUseAddress;

		/// <summary>
		/// Default constructor
		/// </summary>
		protected UnmanagedMemoryStreamCreator() {
		}

		/// <summary>
		/// Constructor for 0 bytes of data
		/// </summary>
		/// <param name="data">Pointer to the data</param>
		public UnmanagedMemoryStreamCreator(IntPtr data)
			: this(data, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Pointer to the data</param>
		/// <param name="dataLength">Length of data</param>
		/// <exception cref="ArgumentOutOfRangeException">If one of the args is invalid</exception>
		public UnmanagedMemoryStreamCreator(IntPtr data, long dataLength) {
			if (dataLength < 0)
				throw new ArgumentOutOfRangeException("dataLength");
			this.data = data;
			this.dataLength = dataLength;
		}

		/// <inheritdoc/>
		public unsafe IImageStream Create(FileOffset offset, long length) {
			if (offset < 0 || length < 0)
				return MemoryImageStream.CreateEmpty();

			long offs = Math.Min((long)dataLength, (long)offset);
			long len = Math.Min((long)dataLength - offs, length);
			return new UnmanagedMemoryImageStream(this, offset, offs, len);
		}

		/// <inheritdoc/>
		public IImageStream CreateFull() {
			return new UnmanagedMemoryImageStream(this, 0, 0, dataLength);
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (disposing) {
				data = IntPtr.Zero;
				dataLength = 0;
				theFileName = null;
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/Characteristics.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.PE {
	/// <summary>
	/// IMAGE_FILE_HEADER.Characteristics flags
	/// </summary>
	[Flags]
	public enum Characteristics : ushort {
		/// <summary>Relocation info stripped from file.</summary>
		RelocsStripped		= 0x0001,
		/// <summary>File is executable  (i.e. no unresolved externel references).</summary>
		ExecutableImage		= 0x0002,
		/// <summary>Line nunbers stripped from file.</summary>
		LineNumsStripped	= 0x0004,
		/// <summary>Local symbols stripped from file.</summary>
		LocalSymsStripped	= 0x0008,
		/// <summary>Agressively trim working set</summary>
		AggressiveWsTrim	= 0x0010,
		/// <summary>App can handle >2gb addresses</summary>
		LargeAddressAware	= 0x0020,
		/// <summary/>
		Reserved1			= 0x0040,
		/// <summary>Bytes of machine word are reversed.</summary>
		BytesReversedLo		= 0x0080,
		/// <summary>32 bit word machine.</summary>
		_32BitMachine		= 0x0100,
		/// <summary>Debugging info stripped from file in .DBG file</summary>
		DebugStripped		= 0x0200,
		/// <summary>If Image is on removable media, copy and run from the swap file.</summary>
		RemovableRunFromSwap= 0x0400,
		/// <summary>If Image is on Net, copy and run from the swap file.</summary>
		NetRunFromSwap		= 0x0800,
		/// <summary>System File.</summary>
		System				= 0x1000,
		/// <summary>File is a DLL.</summary>
		Dll					= 0x2000,
		/// <summary>File should only be run on a UP machine</summary>
		UpSystemOnly		= 0x4000,
		/// <summary>Bytes of machine word are reversed.</summary>
		BytesReversedHi		= 0x8000,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/DllCharacteristics.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.PE {
	/// <summary>
	/// IMAGE_OPTIONAL_HEADER.DllCharacteristics
	/// </summary>
	[Flags]
	public enum DllCharacteristics : ushort {
		/// <summary/>
		Reserved1			= 0x0001,
		/// <summary/>
		Reserved2			= 0x0002,
		/// <summary/>
		Reserved3			= 0x0004,
		/// <summary/>
		Reserved4			= 0x0008,
		/// <summary/>
		Reserved5			= 0x0010,
		/// <summary>Image can handle a high entropy 64-bit virtual address space.</summary>
		HighEntropyVA		= 0x0020,
		/// <summary>DLL can move.</summary>
		DynamicBase			= 0x0040,
		/// <summary>Code Integrity Image</summary>
		ForceIntegrity		= 0x0080,
		/// <summary>Image is NX compatible</summary>
		NxCompat			= 0x0100,
		/// <summary>Image understands isolation and doesn't want it</summary>
		NoIsolation			= 0x0200,
		/// <summary>Image does not use SEH.  No SE handler may reside in this image</summary>
		NoSeh				= 0x0400,
		/// <summary>Do not bind this image.</summary>
		NoBind				= 0x0800,
		/// <summary>Image should execute in an AppContainer</summary>
		AppContainer		= 0x1000,
		/// <summary>Driver uses WDM model</summary>
		WdmDriver			= 0x2000,
		/// <summary>Image supports Control Flow Guard.</summary>
		GuardCf				= 0x4000,
		/// <summary/>
		TerminalServerAware	= 0x8000,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/IImageOptionalHeader.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Interface for PE optional header classes
	/// </summary>
	public interface IImageOptionalHeader : IFileSection {
		/// <summary>
		/// Returns the Magic field
		/// </summary>
		ushort Magic { get; }

		/// <summary>
		/// Returns the MajorLinkerVersion field
		/// </summary>
		byte MajorLinkerVersion { get; }

		/// <summary>
		/// Returns the MinorLinkerVersion field
		/// </summary>
		byte MinorLinkerVersion { get; }

		/// <summary>
		/// Returns the SizeOfCode field
		/// </summary>
		uint SizeOfCode { get; }

		/// <summary>
		/// Returns the SizeOfInitializedData field
		/// </summary>
		uint SizeOfInitializedData { get; }

		/// <summary>
		/// Returns the SizeOfUninitializedData field
		/// </summary>
		uint SizeOfUninitializedData { get; }

		/// <summary>
		/// Returns the AddressOfEntryPoint field
		/// </summary>
		RVA AddressOfEntryPoint { get; }

		/// <summary>
		/// Returns the BaseOfCode field
		/// </summary>
		RVA BaseOfCode { get; }

		/// <summary>
		/// Returns the BaseOfData field
		/// </summary>
		RVA BaseOfData { get; }

		/// <summary>
		/// Returns the ImageBase field
		/// </summary>
		ulong ImageBase { get; }

		/// <summary>
		/// Returns the SectionAlignment field
		/// </summary>
		uint SectionAlignment { get; }

		/// <summary>
		/// Returns the FileAlignment field
		/// </summary>
		uint FileAlignment { get; }

		/// <summary>
		/// Returns the MajorOperatingSystemVersion field
		/// </summary>
		ushort MajorOperatingSystemVersion { get; }

		/// <summary>
		/// Returns the MinorOperatingSystemVersion field
		/// </summary>
		ushort MinorOperatingSystemVersion { get; }

		/// <summary>
		/// Returns the MajorImageVersion field
		/// </summary>
		ushort MajorImageVersion { get; }

		/// <summary>
		/// Returns the MinorImageVersion field
		/// </summary>
		ushort MinorImageVersion { get; }

		/// <summary>
		/// Returns the MajorSubsystemVersion field
		/// </summary>
		ushort MajorSubsystemVersion { get; }

		/// <summary>
		/// Returns the MinorSubsystemVersion field
		/// </summary>
		ushort MinorSubsystemVersion { get; }

		/// <summary>
		/// Returns the Win32VersionValue field
		/// </summary>
		uint Win32VersionValue { get; }

		/// <summary>
		/// Returns the SizeOfImage field
		/// </summary>
		uint SizeOfImage { get; }

		/// <summary>
		/// Returns the SizeOfHeaders field
		/// </summary>
		uint SizeOfHeaders { get; }

		/// <summary>
		/// Returns the CheckSum field
		/// </summary>
		uint CheckSum { get; }

		/// <summary>
		/// Returns the Subsystem field
		/// </summary>
		Subsystem Subsystem { get; }

		/// <summary>
		/// Returns the DllCharacteristics field
		/// </summary>
		DllCharacteristics DllCharacteristics { get; }

		/// <summary>
		/// Returns the SizeOfStackReserve field
		/// </summary>
		ulong SizeOfStackReserve { get; }

		/// <summary>
		/// Returns the SizeOfStackCommit field
		/// </summary>
		ulong SizeOfStackCommit { get; }

		/// <summary>
		/// Returns the SizeOfHeapReserve field
		/// </summary>
		ulong SizeOfHeapReserve { get; }

		/// <summary>
		/// Returns the SizeOfHeapCommit field
		/// </summary>
		ulong SizeOfHeapCommit { get; }

		/// <summary>
		/// Returns the LoaderFlags field
		/// </summary>
		uint LoaderFlags { get; }

		/// <summary>
		/// Returns the NumberOfRvaAndSizes field
		/// </summary>
		uint NumberOfRvaAndSizes { get; }

		/// <summary>
		/// Returns the DataDirectories field
		/// </summary>
		ImageDataDirectory[] DataDirectories { get; }
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/IPEImage.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using dnlib.IO;
using dnlib.W32Resources;

namespace dnlib.PE {
	/// <summary>
	/// Converts <see cref="RVA"/>s to/from <see cref="FileOffset"/>s
	/// </summary>
	public interface IRvaFileOffsetConverter {
		/// <summary>
		/// Converts a <see cref="FileOffset"/> to an <see cref="RVA"/>
		/// </summary>
		/// <param name="offset">The file offset to convert</param>
		/// <returns>The RVA</returns>
		RVA ToRVA(FileOffset offset);

		/// <summary>
		/// Converts an <see cref="RVA"/> to a <see cref="FileOffset"/>
		/// </summary>
		/// <param name="rva">The RVA to convert</param>
		/// <returns>The file offset</returns>
		FileOffset ToFileOffset(RVA rva);
	}

	/// <summary>
	/// Interface to access a PE image
	/// </summary>
	public interface IPEImage : IRvaFileOffsetConverter, IDisposable {
		/// <summary>
		/// <c>true</c> if image layout is the same as the raw PE image layout, <c>false</c>
		/// if it's the same layout as a PE image loaded by the OS PE loader.
		/// </summary>
		bool IsFileImageLayout { get; }

		/// <summary>
		/// <c>true</c> if some of the memory where the image is located could be unavailable.
		/// This could happen if it's been loaded by the OS loader.
		/// </summary>
		bool MayHaveInvalidAddresses { get; }

		/// <summary>
		/// The file name or <c>null</c> if data is not from a file
		/// </summary>
		string FileName { get; }

		/// <summary>
		/// Returns the DOS header
		/// </summary>
		ImageDosHeader ImageDosHeader { get; }

		/// <summary>
		/// Returns the NT headers
		/// </summary>
		ImageNTHeaders ImageNTHeaders { get; }

		/// <summary>
		/// Returns the section headers
		/// </summary>
		IList<ImageSectionHeader> ImageSectionHeaders { get; }

		/// <summary>
		/// Returns the debug directories
		/// </summary>
		IList<ImageDebugDirectory> ImageDebugDirectories { get; }

		/// <summary>
		/// Gets/sets the Win32 resources. This is <c>null</c> if there are no Win32 resources.
		/// </summary>
		Win32Resources Win32Resources { get; set; }

		/// <summary>
		/// Creates a stream to access part of the PE image from <paramref name="offset"/>
		/// to the end of the image
		/// </summary>
		/// <param name="offset">File offset</param>
		/// <returns>A new stream</returns>
		/// <exception cref="ArgumentOutOfRangeException">If the arg is invalid</exception>
		IImageStream CreateStream(FileOffset offset);

		/// <summary>
		/// Creates a stream to access part of the PE image from <paramref name="offset"/>
		/// with length <paramref name="length"/>
		/// </summary>
		/// <param name="offset">File offset</param>
		/// <param name="length">Length of data</param>
		/// <returns>A new stream</returns>
		/// <exception cref="ArgumentOutOfRangeException">If any arg is invalid</exception>
		IImageStream CreateStream(FileOffset offset, long length);

		/// <summary>
		/// Creates a stream to access the full PE image
		/// </summary>
		/// <returns>A new stream</returns>
		IImageStream CreateFullStream();

		/// <summary>
		/// Call this to disable memory mapped I/O if it was used to open the file. This must only
		/// be called if no other code is trying to access the memory since that could lead to an
		/// exception.
		/// </summary>
		void UnsafeDisableMemoryMappedIO();

		/// <summary>
		/// <c>true</c> if memory mapped I/O is enabled
		/// </summary>
		bool IsMemoryMappedIO { get; }
	}

	public static partial class PEExtensions {
		/// <summary>
		/// Creates a stream to access part of the PE image from <paramref name="rva"/>
		/// to the end of the image
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="rva">RVA</param>
		/// <returns>A new stream</returns>
		/// <exception cref="ArgumentOutOfRangeException">If the arg is invalid</exception>
		public static IImageStream CreateStream(this IPEImage self, RVA rva) {
			return self.CreateStream(self.ToFileOffset(rva));
		}

		/// <summary>
		/// Creates a stream to access part of the PE image from <paramref name="rva"/>
		/// with length <paramref name="length"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="rva">RVA</param>
		/// <param name="length">Length of data</param>
		/// <returns>A new stream</returns>
		/// <exception cref="ArgumentOutOfRangeException">If any arg is invalid</exception>
		public static IImageStream CreateStream(this IPEImage self, RVA rva, long length) {
			return self.CreateStream(self.ToFileOffset(rva), length);
		}

		/// <summary>
		/// Reads all bytes from the PE image. This may fail if the PE image has been loaded
		/// by the OS loader since there may be memory holes.
		/// </summary>
		/// <param name="self">this</param>
		/// <returns>All bytes of the PE image</returns>
		public static byte[] GetImageAsByteArray(this IPEImage self) {
			using (var reader = self.CreateFullStream())
				return reader.ReadAllBytes();
		}

		/// <summary>
		/// Finds a <see cref="ResourceData"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="type">Type</param>
		/// <param name="name">Name</param>
		/// <param name="langId">Language ID</param>
		/// <returns>The <see cref="ResourceData"/> or <c>null</c> if none found</returns>
		public static ResourceData FindWin32ResourceData(this IPEImage self, ResourceName type, ResourceName name, ResourceName langId) {
			var w32Resources = self.Win32Resources;
			return w32Resources == null ? null : w32Resources.Find(type, name, langId);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/IPEType.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Converts a <see cref="FileOffset"/> to/from an <see cref="RVA"/>
	/// </summary>
	interface IPEType {
		/// <summary>
		/// Converts a <see cref="FileOffset"/> to an <see cref="RVA"/>
		/// </summary>
		/// <param name="peInfo">The PEInfo context</param>
		/// <param name="offset">The file offset to convert</param>
		/// <returns>The RVA</returns>
		RVA ToRVA(PEInfo peInfo, FileOffset offset);

		/// <summary>
		/// Converts an <see cref="RVA"/> to a <see cref="FileOffset"/>
		/// </summary>
		/// <param name="peInfo">The PEInfo context</param>
		/// <param name="rva">The RVA to convert</param>
		/// <returns>The file offset</returns>
		FileOffset ToFileOffset(PEInfo peInfo, RVA rva);
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageDataDirectory.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_DATA_DIRECTORY PE section
	/// </summary>
	[DebuggerDisplay("{virtualAddress} {dataSize}")]
	public sealed class ImageDataDirectory : FileSection {
        /// <summary>
        /// Returns the IMAGE_DATA_DIRECTORY.VirtualAddress field
        /// </summary>
        public RVA VirtualAddress { get; internal set; }

        /// <summary>
        /// Returns the IMAGE_DATA_DIRECTORY.Size field
        /// </summary>
        public uint Size { get; internal set; }

        /// <summary>
        /// Default constructor
        /// </summary>
        public ImageDataDirectory() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageDataDirectory(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			this.VirtualAddress = (RVA)reader.ReadUInt32();
			this.Size = reader.ReadUInt32();
			SetEndoffset(reader);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageDebugDirectory.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// A <c>IMAGE_DEBUG_DIRECTORY</c>
	/// </summary>
	[DebuggerDisplay("{type}: TS:{timeDateStamp,h} V:{majorVersion,d}.{minorVersion,d} SZ:{sizeOfData} RVA:{addressOfRawData,h} FO:{pointerToRawData,h}")]
	public sealed class ImageDebugDirectory : FileSection {
		readonly uint characteristics;
		readonly uint timeDateStamp;
		readonly ushort majorVersion;
		readonly ushort minorVersion;
		readonly ImageDebugType type;
		readonly uint sizeOfData;
		readonly uint addressOfRawData;
		readonly uint pointerToRawData;

		/// <summary>
		/// Gets the characteristics (reserved)
		/// </summary>
		public uint Characteristics {
			get { return characteristics; }
		}

		/// <summary>
		/// Gets the timestamp
		/// </summary>
		public uint TimeDateStamp {
			get { return timeDateStamp; }
		}

		/// <summary>
		/// Gets the major version
		/// </summary>
		public ushort MajorVersion {
			get { return majorVersion; }
		}

		/// <summary>
		/// Gets the minor version
		/// </summary>
		public ushort MinorVersion {
			get { return minorVersion; }
		}

		/// <summary>
		/// Gets the type
		/// </summary>
		public ImageDebugType Type {
			get { return type; }
		}

		/// <summary>
		/// Gets the size of data
		/// </summary>
		public uint SizeOfData {
			get { return sizeOfData; }
		}

		/// <summary>
		/// RVA of the data
		/// </summary>
		public RVA AddressOfRawData {
			get { return (RVA)addressOfRawData; }
		}

		/// <summary>
		/// File offset of the data
		/// </summary>
		public FileOffset PointerToRawData {
			get { return (FileOffset)pointerToRawData; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageDebugDirectory(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			characteristics = reader.ReadUInt32();
			timeDateStamp = reader.ReadUInt32();
			majorVersion = reader.ReadUInt16();
			minorVersion = reader.ReadUInt16();
			type = (ImageDebugType)reader.ReadUInt32();
			sizeOfData = reader.ReadUInt32();
			addressOfRawData = reader.ReadUInt32();
			pointerToRawData = reader.ReadUInt32();
			SetEndoffset(reader);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageDebugType.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

namespace dnlib.PE {
	/// <summary>
	/// Image debug type, see <c>IMAGE_DEBUG_TYPE_*</c> in winnt.n
	/// </summary>
	public enum ImageDebugType : uint {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		Unknown = 0,
		Coff = 1,

		/// <summary>
		/// Contains PDB info
		/// </summary>
		CodeView = 2,

		FPO = 3,
		Misc = 4,
		Exception = 5,
		Fixup = 6,
		OmapToSrc = 7,
		OmapFromSrc = 8,
		Borland = 9,
		Reserved10 = 10,
		CLSID = 11,
		VcFeature = 12,
		POGO = 13,
		ILTCG = 14,
		MPX = 15,

		/// <summary>
		/// It's a deterministic (reproducible) PE file
		/// </summary>
		Repro = 16,

		/// <summary>
		/// Embedded portable PDB data
		/// </summary>
		EmbeddedPortablePdb = 17,
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageDosHeader.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_DOS_HEADER PE section
	/// </summary>
	public sealed class ImageDosHeader : FileSection {
		readonly uint ntHeadersOffset;

		/// <summary>
		/// File offset of the NT headers
		/// </summary>
		public uint NTHeadersOffset {
			get { return ntHeadersOffset; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageDosHeader(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			ushort sig = reader.ReadUInt16();
			if (verify && sig != 0x5A4D)
				throw new BadImageFormatException("Invalid DOS signature");
			reader.Position = (long)startOffset + 0x3C;
			this.ntHeadersOffset = reader.ReadUInt32();
			SetEndoffset(reader);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageFileHeader.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_FILE_HEADER PE section
	/// </summary>
	public sealed class ImageFileHeader : FileSection {
		readonly Machine machine;
		readonly ushort numberOfSections;
		readonly uint timeDateStamp;
		readonly uint pointerToSymbolTable;
		readonly uint numberOfSymbols;
		readonly ushort sizeOfOptionalHeader;
		readonly Characteristics characteristics;

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.Machine field
		/// </summary>
		public Machine Machine {
			get { return machine; }
		}

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.NumberOfSections field
		/// </summary>
		public int NumberOfSections {
			get { return numberOfSections; }
		}

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.TimeDateStamp field
		/// </summary>
		public uint TimeDateStamp {
			get { return timeDateStamp; }
		}

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.PointerToSymbolTable field
		/// </summary>
		public uint PointerToSymbolTable {
			get { return pointerToSymbolTable; }
		}

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.NumberOfSymbols field
		/// </summary>
		public uint NumberOfSymbols {
			get { return numberOfSymbols; }
		}

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.SizeOfOptionalHeader field
		/// </summary>
		public uint SizeOfOptionalHeader {
			get { return sizeOfOptionalHeader; }
		}

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.Characteristics field
		/// </summary>
		public Characteristics Characteristics {
			get { return characteristics; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageFileHeader(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			this.machine = (Machine)reader.ReadUInt16();
			this.numberOfSections = reader.ReadUInt16();
			this.timeDateStamp = reader.ReadUInt32();
			this.pointerToSymbolTable = reader.ReadUInt32();
			this.numberOfSymbols = reader.ReadUInt32();
			this.sizeOfOptionalHeader = reader.ReadUInt16();
			this.characteristics = (Characteristics)reader.ReadUInt16();
			SetEndoffset(reader);
			if (verify && this.sizeOfOptionalHeader == 0)
				throw new BadImageFormatException("Invalid SizeOfOptionalHeader");
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageNTHeaders.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_NT_HEADERS PE section
	/// </summary>
	public sealed class ImageNTHeaders : FileSection {
		readonly uint signature;
		readonly ImageFileHeader imageFileHeader;
		readonly IImageOptionalHeader imageOptionalHeader;

		/// <summary>
		/// Returns the IMAGE_NT_HEADERS.Signature field
		/// </summary>
		public uint Signature {
			get { return signature; }
		}

		/// <summary>
		/// Returns the IMAGE_NT_HEADERS.FileHeader field
		/// </summary>
		public ImageFileHeader FileHeader {
			get { return imageFileHeader; }
		}

		/// <summary>
		/// Returns the IMAGE_NT_HEADERS.OptionalHeader field
		/// </summary>
		public IImageOptionalHeader OptionalHeader {
			get { return imageOptionalHeader; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageNTHeaders(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			this.signature = reader.ReadUInt32();
			if (verify && this.signature != 0x4550)
				throw new BadImageFormatException("Invalid NT headers signature");
			this.imageFileHeader = new ImageFileHeader(reader, verify);
			this.imageOptionalHeader = CreateImageOptionalHeader(reader, verify);
			SetEndoffset(reader);
		}

		/// <summary>
		/// Creates an IImageOptionalHeader
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of the optional header</param>
		/// <param name="verify">Verify section</param>
		/// <returns>The created IImageOptionalHeader</returns>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		IImageOptionalHeader CreateImageOptionalHeader(IImageStream reader, bool verify) {
			ushort magic = reader.ReadUInt16();
			reader.Position -= 2;
			switch (magic) {
			case 0x010B: return new ImageOptionalHeader32(reader, imageFileHeader.SizeOfOptionalHeader, verify);
			case 0x020B: return new ImageOptionalHeader64(reader, imageFileHeader.SizeOfOptionalHeader, verify);
			default: throw new BadImageFormatException("Invalid optional header magic");
			}
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageOptionalHeader32.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_OPTIONAL_HEADER (32-bit) PE section
	/// </summary>
	public sealed class ImageOptionalHeader32 : FileSection, IImageOptionalHeader {
		readonly ushort magic;
		readonly byte majorLinkerVersion;
		readonly byte minorLinkerVersion;
		readonly uint sizeOfCode;
		readonly uint sizeOfInitializedData;
		readonly uint sizeOfUninitializedData;
		readonly RVA addressOfEntryPoint;
		readonly RVA baseOfCode;
		readonly RVA baseOfData;
		readonly uint imageBase;
		readonly uint sectionAlignment;
		readonly uint fileAlignment;
		readonly ushort majorOperatingSystemVersion;
		readonly ushort minorOperatingSystemVersion;
		readonly ushort majorImageVersion;
		readonly ushort minorImageVersion;
		readonly ushort majorSubsystemVersion;
		readonly ushort minorSubsystemVersion;
		readonly uint win32VersionValue;
		readonly uint sizeOfImage;
		readonly uint sizeOfHeaders;
		readonly uint checkSum;
		readonly Subsystem subsystem;
		readonly DllCharacteristics dllCharacteristics;
		readonly uint sizeOfStackReserve;
		readonly uint sizeOfStackCommit;
		readonly uint sizeOfHeapReserve;
		readonly uint sizeOfHeapCommit;
		readonly uint loaderFlags;
		readonly uint numberOfRvaAndSizes;
		readonly ImageDataDirectory[] dataDirectories = new ImageDataDirectory[16];

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.Magic field
		/// </summary>
		public ushort Magic {
			get { return magic; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MajorLinkerVersion field
		/// </summary>
		public byte MajorLinkerVersion {
			get { return majorLinkerVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MinorLinkerVersion field
		/// </summary>
		public byte MinorLinkerVersion {
			get { return minorLinkerVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfCode field
		/// </summary>
		public uint SizeOfCode {
			get { return sizeOfCode; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfInitializedData field
		/// </summary>
		public uint SizeOfInitializedData {
			get { return sizeOfInitializedData; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfUninitializedData field
		/// </summary>
		public uint SizeOfUninitializedData {
			get { return sizeOfUninitializedData; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.AddressOfEntryPoint field
		/// </summary>
		public RVA AddressOfEntryPoint {
			get { return addressOfEntryPoint; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.BaseOfCode field
		/// </summary>
		public RVA BaseOfCode {
			get { return baseOfCode; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.BaseOfData field
		/// </summary>
		public RVA BaseOfData {
			get { return baseOfData; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.ImageBase field
		/// </summary>
		public ulong ImageBase {
			get { return imageBase; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SectionAlignment field
		/// </summary>
		public uint SectionAlignment {
			get { return sectionAlignment; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.FileAlignment field
		/// </summary>
		public uint FileAlignment {
			get { return fileAlignment; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MajorOperatingSystemVersion field
		/// </summary>
		public ushort MajorOperatingSystemVersion {
			get { return majorOperatingSystemVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MinorOperatingSystemVersion field
		/// </summary>
		public ushort MinorOperatingSystemVersion {
			get { return minorOperatingSystemVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MajorImageVersion field
		/// </summary>
		public ushort MajorImageVersion {
			get { return majorImageVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MinorImageVersion field
		/// </summary>
		public ushort MinorImageVersion {
			get { return minorImageVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MajorSubsystemVersion field
		/// </summary>
		public ushort MajorSubsystemVersion {
			get { return majorSubsystemVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MinorSubsystemVersion field
		/// </summary>
		public ushort MinorSubsystemVersion {
			get { return minorSubsystemVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.Win32VersionValue field
		/// </summary>
		public uint Win32VersionValue {
			get { return win32VersionValue; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfImage field
		/// </summary>
		public uint SizeOfImage {
			get { return sizeOfImage; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeaders field
		/// </summary>
		public uint SizeOfHeaders {
			get { return sizeOfHeaders; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.CheckSum field
		/// </summary>
		public uint CheckSum {
			get { return checkSum; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.Subsystem field
		/// </summary>
		public Subsystem Subsystem {
			get { return subsystem; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.DllCharacteristics field
		/// </summary>
		public DllCharacteristics DllCharacteristics {
			get { return dllCharacteristics; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfStackReserve field
		/// </summary>
		public ulong SizeOfStackReserve {
			get { return sizeOfStackReserve; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfStackCommit field
		/// </summary>
		public ulong SizeOfStackCommit {
			get { return sizeOfStackCommit; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeapReserve field
		/// </summary>
		public ulong SizeOfHeapReserve {
			get { return sizeOfHeapReserve; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeapCommit field
		/// </summary>
		public ulong SizeOfHeapCommit {
			get { return sizeOfHeapCommit; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.LoaderFlags field
		/// </summary>
		public uint LoaderFlags {
			get { return loaderFlags; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes field
		/// </summary>
		public uint NumberOfRvaAndSizes {
			get { return numberOfRvaAndSizes; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.DataDirectories field
		/// </summary>
		public ImageDataDirectory[] DataDirectories {
			get { return dataDirectories; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="totalSize">Total size of this optional header (from the file header)</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageOptionalHeader32(IImageStream reader, uint totalSize, bool verify) {
			if (totalSize < 0x60)
				throw new BadImageFormatException("Invalid optional header size");
			if (verify && reader.Position + totalSize > reader.Length)
				throw new BadImageFormatException("Invalid optional header size");
			SetStartOffset(reader);
			this.magic = reader.ReadUInt16();
			this.majorLinkerVersion = reader.ReadByte();
			this.minorLinkerVersion = reader.ReadByte();
			this.sizeOfCode = reader.ReadUInt32();
			this.sizeOfInitializedData = reader.ReadUInt32();
			this.sizeOfUninitializedData = reader.ReadUInt32();
			this.addressOfEntryPoint = (RVA)reader.ReadUInt32();
			this.baseOfCode = (RVA)reader.ReadUInt32();
			this.baseOfData = (RVA)reader.ReadUInt32();
			this.imageBase = reader.ReadUInt32();
			this.sectionAlignment = reader.ReadUInt32();
			this.fileAlignment = reader.ReadUInt32();
			this.majorOperatingSystemVersion = reader.ReadUInt16();
			this.minorOperatingSystemVersion = reader.ReadUInt16();
			this.majorImageVersion = reader.ReadUInt16();
			this.minorImageVersion = reader.ReadUInt16();
			this.majorSubsystemVersion = reader.ReadUInt16();
			this.minorSubsystemVersion = reader.ReadUInt16();
			this.win32VersionValue = reader.ReadUInt32();
			this.sizeOfImage = reader.ReadUInt32();
			this.sizeOfHeaders = reader.ReadUInt32();
			this.checkSum = reader.ReadUInt32();
			this.subsystem = (Subsystem)reader.ReadUInt16();
			this.dllCharacteristics = (DllCharacteristics)reader.ReadUInt16();
			this.sizeOfStackReserve = reader.ReadUInt32();
			this.sizeOfStackCommit = reader.ReadUInt32();
			this.sizeOfHeapReserve = reader.ReadUInt32();
			this.sizeOfHeapCommit = reader.ReadUInt32();
			this.loaderFlags = reader.ReadUInt32();
			this.numberOfRvaAndSizes = reader.ReadUInt32();
			for (int i = 0; i < dataDirectories.Length; i++) {
				uint len = (uint)(reader.Position - startOffset);
				if (len + 8 <= totalSize)
					dataDirectories[i] = new ImageDataDirectory(reader, verify);
				else
					dataDirectories[i] = new ImageDataDirectory();
			}
			reader.Position = (long)startOffset + totalSize;
			SetEndoffset(reader);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageOptionalHeader64.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_OPTIONAL_HEADER64 PE section
	/// </summary>
	public sealed class ImageOptionalHeader64 : FileSection, IImageOptionalHeader {
		readonly ushort magic;
		readonly byte majorLinkerVersion;
		readonly byte minorLinkerVersion;
		readonly uint sizeOfCode;
		readonly uint sizeOfInitializedData;
		readonly uint sizeOfUninitializedData;
		readonly RVA addressOfEntryPoint;
		readonly RVA baseOfCode;
		readonly ulong imageBase;
		readonly uint sectionAlignment;
		readonly uint fileAlignment;
		readonly ushort majorOperatingSystemVersion;
		readonly ushort minorOperatingSystemVersion;
		readonly ushort majorImageVersion;
		readonly ushort minorImageVersion;
		readonly ushort majorSubsystemVersion;
		readonly ushort minorSubsystemVersion;
		readonly uint win32VersionValue;
		readonly uint sizeOfImage;
		readonly uint sizeOfHeaders;
		readonly uint checkSum;
		readonly Subsystem subsystem;
		readonly DllCharacteristics dllCharacteristics;
		readonly ulong sizeOfStackReserve;
		readonly ulong sizeOfStackCommit;
		readonly ulong sizeOfHeapReserve;
		readonly ulong sizeOfHeapCommit;
		readonly uint loaderFlags;
		readonly uint numberOfRvaAndSizes;
		readonly ImageDataDirectory[] dataDirectories = new ImageDataDirectory[16];

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.Magic field
		/// </summary>
		public ushort Magic {
			get { return magic; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MajorLinkerVersion field
		/// </summary>
		public byte MajorLinkerVersion {
			get { return majorLinkerVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MinorLinkerVersion field
		/// </summary>
		public byte MinorLinkerVersion {
			get { return minorLinkerVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfCode field
		/// </summary>
		public uint SizeOfCode {
			get { return sizeOfCode; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfInitializedData field
		/// </summary>
		public uint SizeOfInitializedData {
			get { return sizeOfInitializedData; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfUninitializedData field
		/// </summary>
		public uint SizeOfUninitializedData {
			get { return sizeOfUninitializedData; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.AddressOfEntryPoint field
		/// </summary>
		public RVA AddressOfEntryPoint {
			get { return addressOfEntryPoint; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.BaseOfCode field
		/// </summary>
		public RVA BaseOfCode {
			get { return baseOfCode; }
		}

		/// <summary>
		/// Returns 0 since BaseOfData is not present in IMAGE_OPTIONAL_HEADER64
		/// </summary>
		public RVA BaseOfData {
			get { return 0; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.ImageBase field
		/// </summary>
		public ulong ImageBase {
			get { return imageBase; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SectionAlignment field
		/// </summary>
		public uint SectionAlignment {
			get { return sectionAlignment; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.FileAlignment field
		/// </summary>
		public uint FileAlignment {
			get { return fileAlignment; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MajorOperatingSystemVersion field
		/// </summary>
		public ushort MajorOperatingSystemVersion {
			get { return majorOperatingSystemVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MinorOperatingSystemVersion field
		/// </summary>
		public ushort MinorOperatingSystemVersion {
			get { return minorOperatingSystemVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MajorImageVersion field
		/// </summary>
		public ushort MajorImageVersion {
			get { return majorImageVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MinorImageVersion field
		/// </summary>
		public ushort MinorImageVersion {
			get { return minorImageVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MajorSubsystemVersion field
		/// </summary>
		public ushort MajorSubsystemVersion {
			get { return majorSubsystemVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MinorSubsystemVersion field
		/// </summary>
		public ushort MinorSubsystemVersion {
			get { return minorSubsystemVersion; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.Win32VersionValue field
		/// </summary>
		public uint Win32VersionValue {
			get { return win32VersionValue; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfImage field
		/// </summary>
		public uint SizeOfImage {
			get { return sizeOfImage; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeaders field
		/// </summary>
		public uint SizeOfHeaders {
			get { return sizeOfHeaders; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.CheckSum field
		/// </summary>
		public uint CheckSum {
			get { return checkSum; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.Subsystem field
		/// </summary>
		public Subsystem Subsystem {
			get { return subsystem; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.DllCharacteristics field
		/// </summary>
		public DllCharacteristics DllCharacteristics {
			get { return dllCharacteristics; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfStackReserve field
		/// </summary>
		public ulong SizeOfStackReserve {
			get { return sizeOfStackReserve; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfStackCommit field
		/// </summary>
		public ulong SizeOfStackCommit {
			get { return sizeOfStackCommit; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeapReserve field
		/// </summary>
		public ulong SizeOfHeapReserve {
			get { return sizeOfHeapReserve; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeapCommit field
		/// </summary>
		public ulong SizeOfHeapCommit {
			get { return sizeOfHeapCommit; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.LoaderFlags field
		/// </summary>
		public uint LoaderFlags {
			get { return loaderFlags; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.NumberOfRvaAndSizes field
		/// </summary>
		public uint NumberOfRvaAndSizes {
			get { return numberOfRvaAndSizes; }
		}

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.DataDirectories field
		/// </summary>
		public ImageDataDirectory[] DataDirectories {
			get { return dataDirectories; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="totalSize">Total size of this optional header (from the file header)</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageOptionalHeader64(IImageStream reader, uint totalSize, bool verify) {
			if (totalSize < 0x70)
				throw new BadImageFormatException("Invalid optional header size");
			if (verify && reader.Position + totalSize > reader.Length)
				throw new BadImageFormatException("Invalid optional header size");
			SetStartOffset(reader);
			this.magic = reader.ReadUInt16();
			this.majorLinkerVersion = reader.ReadByte();
			this.minorLinkerVersion = reader.ReadByte();
			this.sizeOfCode = reader.ReadUInt32();
			this.sizeOfInitializedData = reader.ReadUInt32();
			this.sizeOfUninitializedData = reader.ReadUInt32();
			this.addressOfEntryPoint = (RVA)reader.ReadUInt32();
			this.baseOfCode = (RVA)reader.ReadUInt32();
			this.imageBase = reader.ReadUInt64();
			this.sectionAlignment = reader.ReadUInt32();
			this.fileAlignment = reader.ReadUInt32();
			this.majorOperatingSystemVersion = reader.ReadUInt16();
			this.minorOperatingSystemVersion = reader.ReadUInt16();
			this.majorImageVersion = reader.ReadUInt16();
			this.minorImageVersion = reader.ReadUInt16();
			this.majorSubsystemVersion = reader.ReadUInt16();
			this.minorSubsystemVersion = reader.ReadUInt16();
			this.win32VersionValue = reader.ReadUInt32();
			this.sizeOfImage = reader.ReadUInt32();
			this.sizeOfHeaders = reader.ReadUInt32();
			this.checkSum = reader.ReadUInt32();
			this.subsystem = (Subsystem)reader.ReadUInt16();
			this.dllCharacteristics = (DllCharacteristics)reader.ReadUInt16();
			this.sizeOfStackReserve = reader.ReadUInt64();
			this.sizeOfStackCommit = reader.ReadUInt64();
			this.sizeOfHeapReserve = reader.ReadUInt64();
			this.sizeOfHeapCommit = reader.ReadUInt64();
			this.loaderFlags = reader.ReadUInt32();
			this.numberOfRvaAndSizes = reader.ReadUInt32();
			for (int i = 0; i < dataDirectories.Length; i++) {
				uint len = (uint)(reader.Position - startOffset);
				if (len + 8 <= totalSize)
					dataDirectories[i] = new ImageDataDirectory(reader, verify);
				else
					dataDirectories[i] = new ImageDataDirectory();
			}
			reader.Position = (long)startOffset + totalSize;
			SetEndoffset(reader);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/ImageSectionHeader.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Diagnostics;
using System.Text;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_SECTION_HEADER PE section
	/// </summary>
	[DebuggerDisplay("RVA:{virtualAddress} VS:{virtualSize} FO:{pointerToRawData} FS:{sizeOfRawData} {displayName}")]
	public sealed class ImageSectionHeader : FileSection {
		readonly string displayName;
		readonly byte[] name;
		readonly uint virtualSize;
		readonly RVA virtualAddress;
		readonly uint sizeOfRawData;
		readonly uint pointerToRawData;
		readonly uint pointerToRelocations;
		readonly uint pointerToLinenumbers;
		readonly ushort numberOfRelocations;
		readonly ushort numberOfLinenumbers;
		readonly uint characteristics;

		/// <summary>
		/// Returns the human readable section name, ignoring everything after
		/// the first nul byte
		/// </summary>
		public string DisplayName {
			get { return displayName; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.Name field
		/// </summary>
		public byte[] Name {
			get { return name; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.VirtualSize field
		/// </summary>
		public uint VirtualSize {
			get { return virtualSize; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.VirtualAddress field
		/// </summary>
		public RVA VirtualAddress {
			get { return virtualAddress; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.SizeOfRawData field
		/// </summary>
		public uint SizeOfRawData {
			get { return sizeOfRawData; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.PointerToRawData field
		/// </summary>
		public uint PointerToRawData {
			get { return pointerToRawData; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.PointerToRelocations field
		/// </summary>
		public uint PointerToRelocations {
			get { return pointerToRelocations; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.PointerToLinenumbers field
		/// </summary>
		public uint PointerToLinenumbers {
			get { return pointerToLinenumbers; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.NumberOfRelocations field
		/// </summary>
		public ushort NumberOfRelocations {
			get { return numberOfRelocations; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.NumberOfLinenumbers field
		/// </summary>
		public ushort NumberOfLinenumbers {
			get { return numberOfLinenumbers; }
		}

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.Characteristics field
		/// </summary>
		public uint Characteristics {
			get { return characteristics; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageSectionHeader(IImageStream reader, bool verify) {
			SetStartOffset(reader);
			this.name = reader.ReadBytes(8);
			this.virtualSize = reader.ReadUInt32();
			this.virtualAddress = (RVA)reader.ReadUInt32();
			this.sizeOfRawData = reader.ReadUInt32();
			this.pointerToRawData = reader.ReadUInt32();
			this.pointerToRelocations = reader.ReadUInt32();
			this.pointerToLinenumbers = reader.ReadUInt32();
			this.numberOfRelocations = reader.ReadUInt16();
			this.numberOfLinenumbers = reader.ReadUInt16();
			this.characteristics = reader.ReadUInt32();
			SetEndoffset(reader);
			displayName = ToString(name);
		}

		static string ToString(byte[] name) {
			var sb = new StringBuilder(name.Length);
			foreach (var b in name) {
				if (b == 0)
					break;
				sb.Append((char)b);
			}
			return sb.ToString();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/Machine.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.PE {
	/// <summary>
	/// IMAGE_FILE_HEADER.Machine enum
	/// </summary>
	public enum Machine : ushort {
		/// <summary>Unknown machine</summary>
		Unknown		= 0,
		/// <summary>x86</summary>
		I386		= 0x014C,
		/// <summary>MIPS little-endian, 0x160 big-endian</summary>
		R3000		= 0x0162,
		/// <summary>MIPS little-endian</summary>
		R4000		= 0x0166,
		/// <summary>MIPS little-endian</summary>
		R10000		= 0x0168,
		/// <summary>MIPS little-endian WCE v2</summary>
		WCEMIPSV2	= 0x0169,
		/// <summary>Alpha_AXP</summary>
		ALPHA		= 0x0184,
		/// <summary>SH3 little-endian</summary>
		SH3			= 0x01A2,
		/// <summary></summary>
		SH3DSP		= 0x01A3,
		/// <summary>SH3E little-endian</summary>
		SH3E		= 0x01A4,
		/// <summary>SH4 little-endian</summary>
		SH4			= 0x01A6,
		/// <summary>SH5</summary>
		SH5			= 0x01A8,
		/// <summary>ARM Little-Endian</summary>
		ARM			= 0x01C0,
		/// <summary>ARM Thumb/Thumb-2 Little-Endian</summary>
		THUMB		= 0x01C2,
		/// <summary>ARM Thumb-2 Little-Endian</summary>
		ARMNT		= 0x01C4,
		/// <summary></summary>
		AM33		= 0x01D3,
		/// <summary>IBM PowerPC Little-Endian</summary>
		POWERPC		= 0x01F0,
		/// <summary></summary>
		POWERPCFP	= 0x01F1,
		/// <summary>IA-64</summary>
		IA64		= 0x0200,
		/// <summary></summary>
		MIPS16		= 0x0266,
		/// <summary></summary>
		ALPHA64		= 0x0284,
		/// <summary></summary>
		MIPSFPU		= 0x0366,
		/// <summary></summary>
		MIPSFPU16	= 0x0466,
		/// <summary>Infineon</summary>
		TRICORE		= 0x0520,
		/// <summary></summary>
		CEF			= 0x0CEF,
		/// <summary>EFI Byte Code</summary>
		EBC			= 0x0EBC,
		/// <summary>x64</summary>
		AMD64		= 0x8664,
		/// <summary>M32R little-endian</summary>
		M32R		= 0x9041,
		/// <summary></summary>
		ARM64		= 0xAA64,
		/// <summary></summary>
		CEE			= 0xC0EE,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/PEExtensions.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.IO;

namespace dnlib.PE {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class PEExtensions {
		/// <summary>
		/// Calculates a PE checksum
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <param name="length">Length of image</param>
		/// <param name="checkSumOffset">Offset of checksum</param>
		/// <returns>PE checksum</returns>
		internal static uint CalculatePECheckSum(this BinaryReader reader, long length, long checkSumOffset) {
			uint checkSum = 0;
			for (long i = 0; i < length; i += 2) {
				if (i == checkSumOffset) {
					reader.ReadUInt32();
					i += 2;
					continue;
				}
				checkSum += reader.ReadUInt16();
				checkSum = (ushort)(checkSum + (checkSum >> 16));
			}
			ulong cks = (ulong)checkSum + (ulong)length;
			return (uint)cks + (uint)(cks >> 32);
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/PEImage.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.IO;
using dnlib.IO;
using dnlib.Utils;
using dnlib.W32Resources;
using dnlib.Threading;

namespace dnlib.PE {
	/// <summary>
	/// Image layout
	/// </summary>
	public enum ImageLayout {
		/// <summary>
		/// Use this if the PE file has a normal structure (eg. it's been read from a file on disk)
		/// </summary>
		File,

		/// <summary>
		/// Use this if the PE file has been loaded into memory by the OS PE file loader
		/// </summary>
		Memory,
	}

	/// <summary>
	/// Accesses a PE file
	/// </summary>
	public sealed class PEImage : IPEImage {
		// Default to false because an OS loaded PE image may contain memory holes. If there
		// are memory holes, other code (eg. .NET resource creator) must verify that all memory
		// is available, which will be slower.
		const bool USE_MEMORY_LAYOUT_WITH_MAPPED_FILES = false;

		static readonly IPEType MemoryLayout = new MemoryPEType();
		static readonly IPEType FileLayout = new FilePEType();

		IImageStream imageStream;
		IImageStreamCreator imageStreamCreator;
		IPEType peType;
		PEInfo peInfo;
		UserValue<Win32Resources> win32Resources;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		sealed class FilePEType : IPEType {
			/// <inheritdoc/>
			public RVA ToRVA(PEInfo peInfo, FileOffset offset) {
				return peInfo.ToRVA(offset);
			}

			/// <inheritdoc/>
			public FileOffset ToFileOffset(PEInfo peInfo, RVA rva) {
				return peInfo.ToFileOffset(rva);
			}
		}

		sealed class MemoryPEType : IPEType {
			/// <inheritdoc/>
			public RVA ToRVA(PEInfo peInfo, FileOffset offset) {
				return (RVA)offset;
			}

			/// <inheritdoc/>
			public FileOffset ToFileOffset(PEInfo peInfo, RVA rva) {
				return (FileOffset)rva;
			}
		}

		/// <inheritdoc/>
		public bool IsFileImageLayout {
			get { return peType is FilePEType; }
		}

		/// <inheritdoc/>
		public bool MayHaveInvalidAddresses {
			get { return !IsFileImageLayout; }
		}

		/// <inheritdoc/>
		public string FileName {
			get { return imageStreamCreator.FileName; }
		}

		/// <inheritdoc/>
		public ImageDosHeader ImageDosHeader {
			get { return peInfo.ImageDosHeader; }
		}

		/// <inheritdoc/>
		public ImageNTHeaders ImageNTHeaders {
			get { return peInfo.ImageNTHeaders; }
		}

		/// <inheritdoc/>
		public IList<ImageSectionHeader> ImageSectionHeaders {
			get { return peInfo.ImageSectionHeaders; }
		}

		/// <inheritdoc/>
		public IList<ImageDebugDirectory> ImageDebugDirectories {
			get {
				if (imageDebugDirectories == null)
					imageDebugDirectories = ReadImageDebugDirectories();
				return imageDebugDirectories;
			}
		}
		ImageDebugDirectory[] imageDebugDirectories;

		/// <inheritdoc/>
		public Win32Resources Win32Resources {
			get { return win32Resources.Value; }
			set {
				IDisposable origValue = null;
				if (win32Resources.IsValueInitialized) {
					origValue = win32Resources.Value;
					if (origValue == value)
						return;
				}
				win32Resources.Value = value;

				if (origValue != null)
					origValue.Dispose();
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="imageStreamCreator">The PE stream creator</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(IImageStreamCreator imageStreamCreator, ImageLayout imageLayout, bool verify) {
			try {
				this.imageStreamCreator = imageStreamCreator;
				this.peType = ConvertImageLayout(imageLayout);
				ResetReader();
				this.peInfo = new PEInfo(imageStream, verify);
				Initialize();
			}
			catch {
				Dispose();
				throw;
			}
		}

		void Initialize() {
			win32Resources.ReadOriginalValue = () => {
				var dataDir = peInfo.ImageNTHeaders.OptionalHeader.DataDirectories[2];
				if (dataDir.VirtualAddress == 0 || dataDir.Size == 0)
					return null;
				return new Win32ResourcesPE(this);
			};
#if THREAD_SAFE
			win32Resources.Lock = theLock;
#endif
		}

		static IPEType ConvertImageLayout(ImageLayout imageLayout) {
			switch (imageLayout) {
			case ImageLayout.File: return FileLayout;
			case ImageLayout.Memory: return MemoryLayout;
			default: throw new ArgumentException("imageLayout");
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fileName">Name of the file</param>
		/// <param name="mapAsImage"><c>true</c> if we should map it as an executable</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(string fileName, bool mapAsImage, bool verify)
			: this(ImageStreamCreator.Create(fileName, mapAsImage), mapAsImage ? ImageLayout.Memory : ImageLayout.File, verify) {
			try {
				if (mapAsImage && imageStreamCreator is MemoryMappedFileStreamCreator) {
					((MemoryMappedFileStreamCreator)imageStreamCreator).Length = peInfo.GetImageSize();
					ResetReader();
				}
			}
			catch {
				Dispose();
				throw;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fileName">Name of the file</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(string fileName, bool verify)
			: this(fileName, USE_MEMORY_LAYOUT_WITH_MAPPED_FILES, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fileName">Name of the file</param>
		public PEImage(string fileName)
			: this(fileName, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="filename">Filename or null</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(byte[] data, string filename, ImageLayout imageLayout, bool verify)
			: this(new MemoryStreamCreator(data) { FileName = filename }, imageLayout, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(byte[] data, ImageLayout imageLayout, bool verify)
			: this(data, null, imageLayout, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(byte[] data, bool verify)
			: this(data, null, ImageLayout.File, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="filename">Filename or null</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(byte[] data, string filename, bool verify)
			: this(data, filename, ImageLayout.File, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		public PEImage(byte[] data)
			: this(data, null, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="filename">Filename or null</param>
		public PEImage(byte[] data, string filename)
			: this(data, filename, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="length">Length of PE image</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(IntPtr baseAddr, long length, ImageLayout imageLayout, bool verify)
			: this(new UnmanagedMemoryStreamCreator(baseAddr, length), imageLayout, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="length">Length of PE image</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(IntPtr baseAddr, long length, bool verify)
			: this(baseAddr, length, ImageLayout.Memory, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="length">Length of PE image</param>
		public PEImage(IntPtr baseAddr, long length)
			: this(baseAddr, length, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(IntPtr baseAddr, ImageLayout imageLayout, bool verify)
			: this(new UnmanagedMemoryStreamCreator(baseAddr, 0x10000), imageLayout, verify) {
			try {
				((UnmanagedMemoryStreamCreator)imageStreamCreator).Length = peInfo.GetImageSize();
				ResetReader();
			}
			catch {
				Dispose();
				throw;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(IntPtr baseAddr, bool verify)
			: this(baseAddr, ImageLayout.Memory, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		public PEImage(IntPtr baseAddr)
			: this(baseAddr, true) {
		}

		void ResetReader() {
			if (imageStream != null) {
				imageStream.Dispose();
				imageStream = null;
			}
			imageStream = imageStreamCreator.CreateFull();
		}

		/// <inheritdoc/>
		public RVA ToRVA(FileOffset offset) {
			return peType.ToRVA(peInfo, offset);
		}

		/// <inheritdoc/>
		public FileOffset ToFileOffset(RVA rva) {
			return peType.ToFileOffset(peInfo, rva);
		}

		/// <inheritdoc/>
		public void Dispose() {
			IDisposable id;
			if (win32Resources.IsValueInitialized && (id = win32Resources.Value) != null)
				id.Dispose();
			if ((id = imageStream) != null)
				id.Dispose();
			if ((id = imageStreamCreator) != null)
				id.Dispose();
			win32Resources.Value = null;
			imageStream = null;
			imageStreamCreator = null;
			peType = null;
			peInfo = null;
		}

		/// <inheritdoc/>
		public IImageStream CreateStream(FileOffset offset) {
			if ((long)offset > imageStreamCreator.Length)
				throw new ArgumentOutOfRangeException("offset");
			long length = imageStreamCreator.Length - (long)offset;
			return CreateStream(offset, length);
		}

		/// <inheritdoc/>
		public IImageStream CreateStream(FileOffset offset, long length) {
			return imageStreamCreator.Create(offset, length);
		}

		/// <inheritdoc/>
		public IImageStream CreateFullStream() {
			return imageStreamCreator.CreateFull();
		}

		/// <inheritdoc/>
		public void UnsafeDisableMemoryMappedIO() {
			var creator = imageStreamCreator as MemoryMappedFileStreamCreator;
			if (creator != null)
				creator.UnsafeDisableMemoryMappedIO();
		}

		/// <inheritdoc/>
		public bool IsMemoryMappedIO {
			get {
				var creator = imageStreamCreator as MemoryMappedFileStreamCreator;
				return creator == null ? false : creator.IsMemoryMappedIO;
			}
		}

		ImageDebugDirectory[] ReadImageDebugDirectories() {
			try {
				if (6 >= ImageNTHeaders.OptionalHeader.DataDirectories.Length)
					return emptyImageDebugDirectories;
				var dataDir = ImageNTHeaders.OptionalHeader.DataDirectories[6];
				if (dataDir.VirtualAddress == 0)
					return emptyImageDebugDirectories;
				using (var reader = imageStream.Clone()) {
					if (dataDir.Size > reader.Length)
						return emptyImageDebugDirectories;
					int count = (int)(dataDir.Size / 0x1C);
					if (count == 0)
						return emptyImageDebugDirectories;
					reader.Position = (long)ToFileOffset(dataDir.VirtualAddress);
					if (reader.Position + dataDir.Size > reader.Length)
						return emptyImageDebugDirectories;
					var res = new ImageDebugDirectory[count];
					for (int i = 0; i < res.Length; i++)
						res[i] = new ImageDebugDirectory(reader, true);
					return res;
				}
			}
			catch (IOException) {
			}
			return emptyImageDebugDirectories;
		}
		static readonly ImageDebugDirectory[] emptyImageDebugDirectories = new ImageDebugDirectory[0];
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/PEInfo.cs
================================================
// dnlib: See LICENSE.txt for more info

using System;
using dnlib.IO;

namespace dnlib.PE {
	/// <summary>
	/// Reads all PE sections from a PE stream
	/// </summary>
	sealed class PEInfo {
		readonly ImageDosHeader imageDosHeader;
		readonly ImageNTHeaders imageNTHeaders;
		readonly ImageSectionHeader[] imageSectionHeaders;

		/// <summary>
		/// Returns the DOS header
		/// </summary>
		public ImageDosHeader ImageDosHeader {
			get { return imageDosHeader; }
		}

		/// <summary>
		/// Returns the NT headers
		/// </summary>
		public ImageNTHeaders ImageNTHeaders {
			get { return imageNTHeaders; }
		}

		/// <summary>
		/// Returns the section headers
		/// </summary>
		public ImageSectionHeader[] ImageSectionHeaders {
			get { return imageSectionHeaders; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify sections</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public PEInfo(IImageStream reader, bool verify) {
			reader.Position = 0;
			this.imageDosHeader = new ImageDosHeader(reader, verify);

			if (verify && this.imageDosHeader.NTHeadersOffset == 0)
				throw new BadImageFormatException("Invalid NT headers offset");
			reader.Position = this.imageDosHeader.NTHeadersOffset;
			this.imageNTHeaders = new ImageNTHeaders(reader, verify);

			reader.Position = (long)this.imageNTHeaders.OptionalHeader.StartOffset + this.imageNTHeaders.FileHeader.SizeOfOptionalHeader;
			this.imageSectionHeaders = new ImageSectionHeader[this.imageNTHeaders.FileHeader.NumberOfSections];
			for (int i = 0; i < this.imageSectionHeaders.Length; i++)
				this.imageSectionHeaders[i] = new ImageSectionHeader(reader, verify);
		}

		/// <summary>
		/// Returns the first <see cref="ImageSectionHeader"/> that has data at file offset
		/// <paramref name="offset"/>
		/// </summary>
		/// <param name="offset">The file offset</param>
		/// <returns></returns>
		public ImageSectionHeader ToImageSectionHeader(FileOffset offset) {
			foreach (var section in imageSectionHeaders) {
				if ((long)offset >= section.PointerToRawData && (long)offset < section.PointerToRawData + section.SizeOfRawData)
					return section;
			}
			return null;
		}

		/// <summary>
		/// Returns the first <see cref="ImageSectionHeader"/> that has data at RVA
		/// <paramref name="rva"/>
		/// </summary>
		/// <param name="rva">The RVA</param>
		/// <returns></returns>
		public ImageSectionHeader ToImageSectionHeader(RVA rva) {
			foreach (var section in imageSectionHeaders) {
				if (rva >= section.VirtualAddress && rva < section.VirtualAddress + Math.Max(section.VirtualSize, section.SizeOfRawData))
					return section;
			}
			return null;
		}

		/// <summary>
		/// Converts a <see cref="FileOffset"/> to an <see cref="RVA"/>
		/// </summary>
		/// <param name="offset">The file offset to convert</param>
		/// <returns>The RVA</returns>
		public RVA ToRVA(FileOffset offset) {
			var section = ToImageSectionHeader(offset);
			if (section != null)
				return (uint)(offset - section.PointerToRawData) + section.VirtualAddress;
			return (RVA)offset;
		}

		/// <summary>
		/// Converts an <see cref="RVA"/> to a <see cref="FileOffset"/>
		/// </summary>
		/// <param name="rva">The RVA to convert</param>
		/// <returns>The file offset</returns>
		public FileOffset ToFileOffset(RVA rva) {
			var section = ToImageSectionHeader(rva);
			if (section != null)
				return (FileOffset)((long)(rva - section.VirtualAddress) + section.PointerToRawData);
			return (FileOffset)rva;
		}

		static ulong AlignUp(ulong val, uint alignment) {
			return (val + alignment - 1) & ~(ulong)(alignment - 1);
		}

		/// <summary>
		/// Returns size of image rounded up to <see cref="IImageOptionalHeader.SectionAlignment"/>
		/// </summary>
		/// <remarks>It calculates the size itself, and does not return <see cref="IImageOptionalHeader.SizeOfImage"/></remarks>
		/// <returns>Size of image in bytes</returns>
		public long GetImageSize() {
			var optHdr = ImageNTHeaders.OptionalHeader;
			uint alignment = optHdr.SectionAlignment;
			ulong len = AlignUp(optHdr.SizeOfHeaders, alignment);
			foreach (var section in imageSectionHeaders) {
				ulong len2 = AlignUp((ulong)section.VirtualAddress + Math.Max(section.VirtualSize, section.SizeOfRawData), alignment);
				if (len2 > len)
					len = len2;
			}
			return (long)len;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/RVA.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.PE {
	/// <summary>
	/// Represents an RVA (relative virtual address)
	/// </summary>
	public enum RVA : uint {
	}

	partial class PEExtensions {
		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="rva">this</param>
		/// <param name="alignment">Alignment</param>
		public static RVA AlignUp(this RVA rva, uint alignment) {
			return (RVA)(((uint)rva + alignment - 1) & ~(alignment - 1));
		}

		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="rva">this</param>
		/// <param name="alignment">Alignment</param>
		public static RVA AlignUp(this RVA rva, int alignment) {
			return (RVA)(((uint)rva + alignment - 1) & ~(alignment - 1));
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/PE/Subsystem.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.PE {
	/// <summary>
	/// IMAGE_OPTIONAL_HEADER.Subsystem
	/// </summary>
	public enum Subsystem : ushort {
		/// <summary>Unknown subsystem.</summary>
		Unknown = 0,
		/// <summary>Image doesn't require a subsystem.</summary>
		Native = 1,
		/// <summary>Image runs in the Windows GUI subsystem.</summary>
		WindowsGui = 2,
		/// <summary>Image runs in the Windows character subsystem.</summary>
		WindowsCui = 3,
		/// <summary>image runs in the OS/2 character subsystem.</summary>
		Os2Cui = 5,
		/// <summary>image runs in the Posix character subsystem.</summary>
		PosixCui = 7,
		/// <summary>image is a native Win9x driver.</summary>
		NativeWindows = 8,
		/// <summary>Image runs in the Windows CE subsystem.</summary>
		WindowsCeGui = 9,
		/// <summary/>
		EfiApplication = 10,
		/// <summary/>
		EfiBootServiceDriver = 11,
		/// <summary/>
		EfiRuntimeDriver = 12,
		/// <summary/>
		EfiRom = 13,
		/// <summary/>
		Xbox = 14,
		/// <summary/>
		WindowsBootApplication = 16,
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Threading/Extensions.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.Threading {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class Extensions {
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Threading/ICancellationToken.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;

namespace dnlib.Threading {
	/// <summary>
	/// Cancellation token interface
	/// </summary>
	public interface ICancellationToken {
		/// <summary>
		/// Throws a <see cref="OperationCanceledException"/> if the operation should be canceled
		/// </summary>
		void ThrowIfCancellationRequested();
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Threading/IThreadSafeList.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.Threading.Collections {
#if THREAD_SAFE
	/// <summary>
	/// Thread-safe <see cref="System.Collections.Generic.IList{T}"/> interface
	/// </summary>
	/// <typeparam name="T">List type</typeparam>
	public interface IList<T> : System.Collections.Generic.IList<T> {
		/// <summary>
		/// Must only be called when the list lock is held. Gets the index of <paramref name="item"/>
		/// </summary>
		/// <param name="item">Item</param>
		/// <returns>Index of <paramref name="item"/> or <c>-1</c> if it's not present in the list</returns>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		int IndexOf_NoLock(T item);

		/// <summary>
		/// Must only be called when the list lock is held. Inserts <paramref name="item"/> at index
		/// <paramref name="index"/>
		/// </summary>
		/// <param name="index">Index</param>
		/// <param name="item">Item to insert</param>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		void Insert_NoLock(int index, T item);

		/// <summary>
		/// Must only be called when the list lock is held. Removes the item at index
		/// <paramref name="index"/>
		/// </summary>
		/// <param name="index"></param>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		void RemoveAt_NoLock(int index);

		/// <summary>
		/// Must only be called when the list lock is held. Returns the value at a specified index.
		/// </summary>
		/// <param name="index">Index</param>
		/// <returns>Value</returns>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		T Get_NoLock(int index);

		/// <summary>
		/// Must only be called when the list lock is held. Writes to the list at a specified index.
		/// </summary>
		/// <param name="index">Index</param>
		/// <param name="value">Value</param>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		void Set_NoLock(int index, T value);

		/// <summary>
		/// Must only be called when the list lock is held. Adds a new element to the end of the
		/// list.
		/// </summary>
		/// <param name="item">Item</param>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		void Add_NoLock(T item);

		/// <summary>
		/// Must only be called when the list lock is held. Clears the list.
		/// </summary>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		void Clear_NoLock();

		/// <summary>
		/// Must only be called when the list lock is held. Checks whether <paramref name="item"/>
		/// exists in the list.
		/// </summary>
		/// <param name="item">Item</param>
		/// <returns><c>true</c> if <paramref name="item"/> exists in the list, else <c>false</c></returns>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		bool Contains_NoLock(T item);

		/// <summary>
		/// Must only be called when the list lock is held. Copies the list to an array.
		/// </summary>
		/// <param name="array">Destination array</param>
		/// <param name="arrayIndex">Destination array index</param>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		void CopyTo_NoLock(T[] array, int arrayIndex);

		/// <summary>
		/// Must only be called when the list lock is held. Returns the size of the list.
		/// </summary>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		int Count_NoLock { get; }

		/// <summary>
		/// Must only be called when the list lock is held. Returns <c>true</c> if the list is
		/// read-only, <c>false</c> if it's writable.
		/// </summary>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		bool IsReadOnly_NoLock { get; }

		/// <summary>
		/// Must only be called when the list lock is held. Removes <paramref name="item"/> from the
		/// list.
		/// </summary>
		/// <param name="item">Item</param>
		/// <returns><c>true</c> if <paramref name="item"/> was removed, <c>false</c> if
		/// <paramref name="item"/> was never inserted in the list.</returns>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		bool Remove_NoLock(T item);

		/// <summary>
		/// Must only be called when the list lock is held. Gets the enumerator.
		/// </summary>
		/// <returns>A new enumerator instance</returns>
		/// <seealso cref="ExecuteLocked{TArgType, TRetType}(TArgType, ExecuteLockedDelegate{T, TArgType, TRetType})"/>
		IEnumerator<T> GetEnumerator_NoLock();

		/// <summary>
		/// Locks the list and then calls <paramref name="handler"/>. <paramref name="handler"/>
		/// must only call <c>*_NoLock()</c> methods. The list is unlocked once this method returns.
		/// </summary>
		/// <typeparam name="TArgType">Argument type</typeparam>
		/// <typeparam name="TRetType">Return type</typeparam>
		/// <param name="arg">Passed to <paramref name="handler"/></param>
		/// <param name="handler">Handler that should execute when the lock is held</param>
		/// <returns>The value <paramref name="handler"/> returns</returns>
		/// <seealso cref="IndexOf_NoLock"/>
		/// <seealso cref="Insert_NoLock"/>
		/// <seealso cref="RemoveAt_NoLock"/>
		/// <seealso cref="Get_NoLock"/>
		/// <seealso cref="Set_NoLock"/>
		/// <seealso cref="Add_NoLock"/>
		/// <seealso cref="Clear_NoLock"/>
		/// <seealso cref="Contains_NoLock"/>
		/// <seealso cref="CopyTo_NoLock"/>
		/// <seealso cref="Count_NoLock"/>
		/// <seealso cref="IsReadOnly_NoLock"/>
		/// <seealso cref="Remove_NoLock"/>
		/// <seealso cref="GetEnumerator_NoLock"/>
		TRetType ExecuteLocked<TArgType, TRetType>(TArgType arg, ExecuteLockedDelegate<T, TArgType, TRetType> handler);
	}
#endif
}

namespace dnlib.Threading {
	/// <summary>
	/// Passed to <c>ExecuteLocked()</c>
	/// </summary>
	/// <typeparam name="T">Type to store in list</typeparam>
	/// <typeparam name="TArgType">Argument type</typeparam>
	/// <typeparam name="TRetType">Return type</typeparam>
	/// <param name="tsList">A thread-safe list</param>
	/// <param name="arg">The argument</param>
	/// <returns>Any value the user wants to return</returns>
	public delegate TRetType ExecuteLockedDelegate<T, TArgType, TRetType>(ThreadSafe.IList<T> tsList, TArgType arg);

#if THREAD_SAFE
	/// <summary>
	/// Called by <see cref="Extensions.Iterate{T}(ThreadSafe.IList{T},int,int,bool,IterateDelegate{T})"/>
	/// </summary>
	/// <typeparam name="T">Type to store in list</typeparam>
	/// <param name="tsList">A thread-safe list</param>
	/// <param name="index">Index of <paramref name="value"/></param>
	/// <param name="value">Value at <paramref name="index"/> in the list</param>
	/// <returns><c>false</c> to break out of the iterator loop and return</returns>
	public delegate bool IterateDelegate<T>(ThreadSafe.IList<T> tsList, int index, T value);

	/// <summary>
	/// Called by <see cref="Extensions.IterateAll{T}(ThreadSafe.IList{T},IterateAllDelegate{T})"/>
	/// and <see cref="Extensions.IterateAllReverse{T}(ThreadSafe.IList{T},IterateAllDelegate{T})"/>
	/// </summary>
	/// <typeparam name="T">Type to store in list</typeparam>
	/// <param name="tsList">A thread-safe list</param>
	/// <param name="index">Index of <paramref name="value"/></param>
	/// <param name="value">Value at <paramref name="index"/> in the list</param>
	public delegate void IterateAllDelegate<T>(ThreadSafe.IList<T> tsList, int index, T value);
#endif

	/// <summary>
	/// Called by <see cref="Extensions.Iterate{T}(IList{T},int,int,bool,ListIterateDelegate{T})"/>
	/// </summary>
	/// <typeparam name="T">Type to store in list</typeparam>
	/// <param name="list">A list</param>
	/// <param name="index">Index of <paramref name="value"/></param>
	/// <param name="value">Value at <paramref name="index"/> in the list</param>
	/// <returns><c>false</c> to break out of the iterator loop and return</returns>
	public delegate bool ListIterateDelegate<T>(IList<T> list, int index, T value);

	/// <summary>
	/// Called by <see cref="Extensions.IterateAll{T}(IList{T},ListIterateAllDelegate{T})"/>
	/// and <see cref="Extensions.IterateAllReverse{T}(IList{T},ListIterateAllDelegate{T})"/>
	/// </summary>
	/// <typeparam name="T">Type to store in list</typeparam>
	/// <param name="list">A list</param>
	/// <param name="index">Index of <paramref name="value"/></param>
	/// <param name="value">Value at <paramref name="index"/> in the list</param>
	/// <returns><c>false</c> to break out of the iterator loop and return</returns>
	public delegate void ListIterateAllDelegate<T>(IList<T> list, int index, T value);

	/// <summary>
	/// Called by <see cref="Extensions.Iterate{T}(IEnumerable{T},EnumerableIterateDelegate{T})"/>
	/// </summary>
	/// <typeparam name="T">Type stored in enumerable</typeparam>
	/// <param name="index">Index of <paramref name="value"/></param>
	/// <param name="value">Value at <paramref name="index"/> in the collection</param>
	/// <returns><c>false</c> to break out of the iterator loop and return</returns>
	public delegate bool EnumerableIterateDelegate<T>(int index, T value);

	/// <summary>
	/// Called by <see cref="Extensions.IterateAll{T}(IEnumerable{T},EnumerableIterateAllDelegate{T})"/>
	/// </summary>
	/// <typeparam name="T">Type stored in enumerable</typeparam>
	/// <param name="index">Index of <paramref name="value"/></param>
	/// <param name="value">Value at <paramref name="index"/> in the collection</param>
	/// <returns><c>false</c> to break out of the iterator loop and return</returns>
	public delegate void EnumerableIterateAllDelegate<T>(int index, T value);

	public static partial class Extensions {
		/// <summary>
		/// Locks the list and then calls <paramref name="handler"/>. <paramref name="handler"/>
		/// must only call <c>*_NoLock()</c> methods. The list is unlocked once this method returns.
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <typeparam name="TArgType">Argument type</typeparam>
		/// <typeparam name="TRetType">Return type</typeparam>
		/// <param name="tsList">A list</param>
		/// <param name="arg">Passed to <paramref name="handler"/></param>
		/// <param name="handler">Handler that should execute when the lock is held</param>
		/// <returns>The value <paramref name="handler"/> returns</returns>
		public static TRetType ExecuteLocked<T, TArgType, TRetType>(this ThreadSafe.IList<T> tsList, TArgType arg, ExecuteLockedDelegate<T, TArgType, TRetType> handler) {
#if THREAD_SAFE
			return tsList.ExecuteLocked<TArgType, TRetType>(arg, handler);
#else
			return handler(tsList, arg);
#endif
		}

#if THREAD_SAFE
		/// <summary>
		/// Iterates over elements in <paramref name="tsList"/> and calls <paramref name="handler"/>
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="tsList">A thread-safe list</param>
		/// <param name="handler">Called for each element</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="endIndex">End index. <c>-1</c> means <see cref="ThreadSafe.IList{T}.Count_NoLock"/></param>
		/// <param name="reverseOrder"><c>true</c> if we should iterate in the reverse order</param>
		public static void Iterate<T>(this ThreadSafe.IList<T> tsList, int startIndex, int endIndex, bool reverseOrder, IterateDelegate<T> handler) {
			tsList.ExecuteLocked<object, object>(null, (tsList2, arg) => {
				if (reverseOrder) {
					int i = (endIndex < 0 ? tsList2.Count_NoLock : endIndex) - 1;
					for (; i >= startIndex; i--) {
						if (!handler(tsList2, i, tsList2.Get_NoLock(i)))
							break;
					}
				}
				else {
					// Count property can change so check it each time in the loop
					for (int i = startIndex; i < (endIndex < 0 ? tsList2.Count_NoLock : endIndex); i++) {
						if (!handler(tsList2, i, tsList2.Get_NoLock(i)))
							break;
					}
				}
				return null;
			});
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="tsList"/> and calls <paramref name="handler"/>
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="tsList">A thread-safe list</param>
		/// <param name="handler">Called for each element</param>
		public static void Iterate<T>(this ThreadSafe.IList<T> tsList, IterateDelegate<T> handler) {
			tsList.Iterate(0, -1, false, handler);
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="tsList"/> and calls <paramref name="handler"/>
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="tsList">A thread-safe list</param>
		/// <param name="handler">Called for each element</param>
		public static void IterateAll<T>(this ThreadSafe.IList<T> tsList, IterateAllDelegate<T> handler) {
			tsList.Iterate(0, -1, false, (tsList2, index, value) => {
				handler(tsList2, index, value);
				return true;
			});
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="tsList"/> in the reverse order and calls
		/// <paramref name="handler"/>
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="tsList">A thread-safe list</param>
		/// <param name="handler">Called for each element</param>
		public static void IterateReverse<T>(this ThreadSafe.IList<T> tsList, IterateDelegate<T> handler) {
			tsList.Iterate(0, -1, true, handler);
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="tsList"/> in the reverse order and calls
		/// <paramref name="handler"/>
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="tsList">A thread-safe list</param>
		/// <param name="handler">Called for each element</param>
		public static void IterateAllReverse<T>(this ThreadSafe.IList<T> tsList, IterateAllDelegate<T> handler) {
			tsList.Iterate(0, -1, true, (tsList2, index, value) => {
				handler(tsList2, index, value);
				return true;
			});
		}
#endif

		/// <summary>
		/// Iterates over elements in <paramref name="list"/> and calls <paramref name="handler"/>.
		/// If <paramref name="list"/> implements <see cref="ThreadSafe.IList{T}"/>, only thread safe
		/// methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="handler">Called for each element</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="endIndex">End index. <c>-1</c> means <c>Count_NoLock</c></param>
		/// <param name="reverseOrder"><c>true</c> if we should iterate in the reverse order</param>
		public static void Iterate<T>(this IList<T> list, int startIndex, int endIndex, bool reverseOrder, ListIterateDelegate<T> handler) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				tsList.Iterate(startIndex, endIndex, reverseOrder, (tsList2, index, value) => handler(tsList2, index, value));
			else {
#endif
				if (reverseOrder) {
					int i = (endIndex < 0 ? list.Count : endIndex) - 1;
					for (; i >= startIndex; i--) {
						if (!handler(list, i, list[i]))
							break;
					}
				}
				else {
					// Count property can change so check it each time in the loop
					for (int i = startIndex; i < (endIndex < 0 ? list.Count : endIndex); i++) {
						if (!handler(list, i, list[i]))
							break;
					}
				}
#if THREAD_SAFE
			}
#endif
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="list"/> and calls
		/// <paramref name="handler"/>. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="handler">Called for each element</param>
		public static void Iterate<T>(this IList<T> list, ListIterateDelegate<T> handler) {
			list.Iterate(0, -1, false, handler);
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="list"/> and calls
		/// <paramref name="handler"/>. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="handler">Called for each element</param>
		public static void IterateAll<T>(this IList<T> list, ListIterateAllDelegate<T> handler) {
			list.Iterate(0, -1, false, (list2, index, value) => {
				handler(list2, index, value);
				return true;
			});
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="list"/> in the reverse order and calls
		/// <paramref name="handler"/>. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="handler">Called for each element</param>
		public static void IterateReverse<T>(this IList<T> list, ListIterateDelegate<T> handler) {
			list.Iterate(0, -1, true, handler);
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="list"/> in the reverse order and calls
		/// <paramref name="handler"/>. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="handler">Called for each element</param>
		public static void IterateAllReverse<T>(this IList<T> list, ListIterateAllDelegate<T> handler) {
			list.Iterate(0, -1, true, (list2, index, value) => {
				handler(list2, index, value);
				return true;
			});
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="list"/> and calls
		/// <paramref name="handler"/>. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="handler">Called for each element</param>
		public static void Iterate<T>(this IEnumerable<T> list, EnumerableIterateDelegate<T> handler) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				tsList.Iterate((tsList2, index, value) => handler(index, value));
			else {
#endif
				int i = 0;
				foreach (var value in list) {
					if (!handler(i, value))
						break;
					i++;
				}
#if THREAD_SAFE
			}
#endif
		}

		/// <summary>
		/// Iterates over all elements in <paramref name="list"/> and calls
		/// <paramref name="handler"/>. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="handler">Called for each element</param>
		public static void IterateAll<T>(this IEnumerable<T> list, EnumerableIterateAllDelegate<T> handler) {
			list.Iterate((index, value) => {
				handler(index, value);
				return true;
			});
		}

		/// <summary>
		/// Reads an element from the list. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="index">Index</param>
		/// <param name="value">Updated with value</param>
		/// <returns><c>true</c> if <paramref name="value"/> was updated with the element in the
		/// list or <c>false</c> if <paramref name="index"/> was invalid.</returns>
		public static bool Get<T>(this IList<T> list, int index, out T value) {
#if THREAD_SAFE
			try {
#endif
				if ((uint)index < (uint)list.Count) {
					value = list[index];
					return true;
				}
#if THREAD_SAFE
			}
			catch (IndexOutOfRangeException) {
			}
			catch (ArgumentOutOfRangeException) {
			}
#endif
			value = default(T);
			return false;
		}

		/// <summary>
		/// Reads an element from the list. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="index">Index</param>
		/// <param name="defaultValue">Default value if <paramref name="index"/> is invalid</param>
		/// <returns>The value in the list or <paramref name="defaultValue"/> if
		/// <paramref name="index"/> was invalid</returns>
		public static T Get<T>(this IList<T> list, int index, T defaultValue) {
			T value;
			return list.Get(index, out value) ? value : defaultValue;
		}

		/// <summary>
		/// Writes an element to the list. If <paramref name="list"/> implements
		/// <see cref="ThreadSafe.IList{T}"/>, only thread safe methods are called.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <param name="index">Index</param>
		/// <param name="value">Value</param>
		/// <returns><c>true</c> if <paramref name="value"/> was written to the list or <c>false</c>
		/// if <paramref name="index"/> was invalid.</returns>
		public static bool Set<T>(this IList<T> list, int index, T value) {
#if THREAD_SAFE
			try {
#endif
				if ((uint)index < (uint)list.Count) {
					list[index] = value;
					return true;
				}
#if THREAD_SAFE
			}
			catch (IndexOutOfRangeException) {
			}
			catch (ArgumentOutOfRangeException) {
			}
#endif
			return false;
		}

#if THREAD_SAFE
		/// <summary>
		/// Calls <see cref="ThreadSafe.IList{T}.Count_NoLock"/>
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="tsList">A thread-safe list</param>
		/// <returns>Number of elements in the list</returns>
		public static int Count_NoLock<T>(this ThreadSafe.IList<T> tsList) {
			return tsList.Count_NoLock;
		}

		/// <summary>
		/// Calls <see cref="ThreadSafe.IList{T}.IsReadOnly_NoLock"/>
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="tsList">A thread-safe list</param>
		public static bool IsReadOnly_NoLock<T>(this ThreadSafe.IList<T> tsList) {
			return tsList.IsReadOnly_NoLock;
		}
#endif

		/// <summary>
		/// Calls the thread-safe <c>IndexOf_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="IList{T}.IndexOf"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="item">Item</param>
		/// <returns>Index of <paramref name="item"/></returns>
		public static int IndexOf_NoLock<T>(this IList<T> list, T item) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				return tsList.IndexOf_NoLock(item);
			else
#endif
				return list.IndexOf(item);
		}

		/// <summary>
		/// Calls the thread-safe <c>Insert_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="IList{T}.Insert"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="index">Index</param>
		/// <param name="item">Item</param>
		public static void Insert_NoLock<T>(this IList<T> list, int index, T item) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				tsList.Insert_NoLock(index, item);
			else
#endif
				list.Insert(index, item);
		}

		/// <summary>
		/// Calls the thread-safe <c>RemoveAt_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="IList{T}.RemoveAt"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="index">Index</param>
		public static void RemoveAt_NoLock<T>(this IList<T> list, int index) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				tsList.RemoveAt_NoLock(index);
			else
#endif
				list.RemoveAt(index);
		}

		/// <summary>
		/// Calls the thread-safe <c>Get_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="IList{T}.get_Item"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="index">Index</param>
		/// <returns>Value at index <paramref name="index"/></returns>
		public static T Get_NoLock<T>(this IList<T> list, int index) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				return tsList.Get_NoLock(index);
			else
#endif
				return list[index];
		}

		/// <summary>
		/// Calls the thread-safe <c>Set_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="IList{T}.set_Item"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="index">Index</param>
		/// <param name="value">Value</param>
		public static void Set_NoLock<T>(this IList<T> list, int index, T value) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				tsList.Set_NoLock(index, value);
			else
#endif
				list[index] = value;
		}

		/// <summary>
		/// Calls the thread-safe <c>Add_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="ICollection{T}.Add"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="item">Item</param>
		public static void Add_NoLock<T>(this ICollection<T> list, T item) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				tsList.Add_NoLock(item);
			else
#endif
				list.Add(item);
		}

		/// <summary>
		/// Calls the thread-safe <c>Clear_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="ICollection{T}.Clear"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		public static void Clear_NoLock<T>(this ICollection<T> list) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				tsList.Clear_NoLock();
			else
#endif
				list.Clear();
		}

		/// <summary>
		/// Calls the thread-safe <c>Contains_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="ICollection{T}.Contains"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="item">Item</param>
		/// <returns><c>true</c> if <paramref name="item"/> is in the list, else <c>false</c></returns>
		public static bool Contains_NoLock<T>(this ICollection<T> list, T item) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				return tsList.Contains_NoLock(item);
			else
#endif
				return list.Contains(item);
		}

		/// <summary>
		/// Calls the thread-safe <c>CopyTo_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="ICollection{T}.CopyTo"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="array">Destination array</param>
		/// <param name="arrayIndex">Destination index</param>
		public static void CopyTo_NoLock<T>(this ICollection<T> list, T[] array, int arrayIndex) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				tsList.CopyTo_NoLock(array, arrayIndex);
			else
#endif
				list.CopyTo(array, arrayIndex);
		}

		/// <summary>
		/// Calls the thread-safe <c>Count_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="ICollection{T}.Count"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <returns>Number of elements in the list</returns>
		public static int Count_NoLock<T>(this ICollection<T> list) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				return tsList.Count_NoLock;
			else
#endif
				return list.Count;
		}

		/// <summary>
		/// Calls the thread-safe <c>IsReadOnly_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="ICollection{T}.IsReadOnly"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		public static bool IsReadOnly_NoLock<T>(this ICollection<T> list) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				return tsList.IsReadOnly_NoLock;
			else
#endif
				return list.IsReadOnly;
		}

		/// <summary>
		/// Calls the thread-safe <c>Remove_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="ICollection{T}.Remove"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <param name="item">Item</param>
		/// <returns><c>true</c> if <paramref name="item"/> was removed, else <c>false</c></returns>
		public static bool Remove_NoLock<T>(this ICollection<T> list, T item) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				return tsList.Remove_NoLock(item);
			else
#endif
				return list.Remove(item);
		}

		/// <summary>
		/// Calls the thread-safe <c>GetEnumerator_NoLock()</c> method if <paramref name="list"/> implements
		/// a thread-safe list interface, else calls <see cref="IEnumerable{T}.GetEnumerator"/> setter
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <returns>A new <see cref="IEnumerator{T}"/> instance</returns>
		public static IEnumerator<T> GetEnumerator_NoLock<T>(this IEnumerable<T> list) {
#if THREAD_SAFE
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				return tsList.GetEnumerator_NoLock();
			else
#endif
				return list.GetEnumerator();
		}

		/// <summary>
		/// Calls <see cref="GetEnumerator_NoLock{T}(IEnumerable{T})"/> to get an
		/// <see cref="IEnumerator{T}"/> which is used to iterate over the whole list. Each item is
		/// then returned to the caller.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">An <see cref="IList{T}"/></param>
		/// <returns>All items of the list</returns>
		public static IEnumerable<T> GetEnumerable_NoLock<T>(this ICollection<T> list) {
			using (var enumerator = list.GetEnumerator_NoLock()) {
				while (enumerator.MoveNext())
					yield return enumerator.Current;
			}
		}

		/// <summary>
		/// Iterates over the whole list but doesn't keep the lock. It doesn't use any enumerator
		/// so no exception can be thrown if another thread modifies the list.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="list">A list</param>
		/// <returns>A list enumerable</returns>
		public static IEnumerable<T> GetSafeEnumerable<T>(this IList<T> list) {
			for (int i = 0; i < list.Count; i++) {
				T value;
#if THREAD_SAFE
				try {
#endif
				value = list[i];
#if THREAD_SAFE
				}
				catch (IndexOutOfRangeException) {
					break;
				}
				catch (ArgumentOutOfRangeException) {
					break;
				}
#endif
				yield return value;
			}
		}

		/// <summary>
		/// Iterates over the whole list but doesn't keep the lock. It doesn't use any enumerator
		/// so no exception can be thrown if another thread modifies the list.
		/// </summary>
		/// <typeparam name="T">Type to store in list</typeparam>
		/// <param name="coll">A collection</param>
		/// <returns>A list enumerable</returns>
		public static IEnumerable<T> GetSafeEnumerable<T>(this IEnumerable<T> coll) {
			var list = coll as IList<T>;
			if (list != null)
				return GetSafeEnumerable(list);

			return coll;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Threading/Lock.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Runtime.Serialization;
using System.Threading;

namespace dnlib.Threading {
#if THREAD_SAFE
	[Serializable]
	class LockException : Exception {
		public LockException() {
		}

		public LockException(string msg)
			: base(msg) {
		}

		protected LockException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Simple class using <see cref="Monitor.Enter"/> and <see cref="Monitor.Exit"/>
	/// and just like <c>ReaderWriterLockSlim</c> it prevents recursive locks. It doesn't support
	/// multiple readers. A reader lock is the same as a writer lock.
	/// </summary>
	class Lock {
		readonly object lockObj;
		int recurseCount;

		/// <summary>
		/// Creates a new instance of this class
		/// </summary>
		/// <returns></returns>
		public static Lock Create() {
			return new Lock();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		Lock() {
			this.lockObj = new object();
			this.recurseCount = 0;
		}

		/// <summary>
		/// Enter read mode
		/// </summary>
		public void EnterReadLock() {
			Monitor.Enter(lockObj);
			if (recurseCount != 0) {
				Monitor.Exit(lockObj);
				throw new LockException("Recursive locks aren't supported");
			}
			recurseCount++;
		}

		/// <summary>
		/// Exit read mode
		/// </summary>
		public void ExitReadLock() {
			if (recurseCount <= 0)
				throw new LockException("Too many exit lock method calls");
			recurseCount--;
			Monitor.Exit(lockObj);
		}

		/// <summary>
		/// Enter write mode
		/// </summary>
		public void EnterWriteLock() {
			Monitor.Enter(lockObj);
			if (recurseCount != 0) {
				Monitor.Exit(lockObj);
				throw new LockException("Recursive locks aren't supported");
			}
			recurseCount--;
		}

		/// <summary>
		/// Exit write mode
		/// </summary>
		public void ExitWriteLock() {
			if (recurseCount >= 0)
				throw new LockException("Too many exit lock method calls");
			recurseCount++;
			Monitor.Exit(lockObj);
		}
	}
#endif
}



================================================
File: Libraries/dnlib/dnlib.Shared/Threading/ThreadSafeListCreator.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System.Collections.Generic;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.Threading {
	/// <summary>
	/// Creates thread-safe lists
	/// </summary>
	public static class ThreadSafeListCreator {
		/// <summary>
		/// Creates a thread safe <see cref="IList{T}"/>
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <returns>A new thread-safe list instance</returns>
		public static ThreadSafe.IList<T> Create<T>() {
			var list = new List<T>();
#if THREAD_SAFE
			return new ThreadSafeListWrapper<T>(list);
#else
			return list;
#endif
		}

		/// <summary>
		/// Creates a thread safe <see cref="IList{T}"/>
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <param name="value">Value to add to the list</param>
		/// <returns>A new thread-safe list instance</returns>
		public static ThreadSafe.IList<T> Create<T>(T value) {
			var list = new List<T>() { value };
#if THREAD_SAFE
			return new ThreadSafeListWrapper<T>(list);
#else
			return list;
#endif
		}

		/// <summary>
		/// Creates a thread safe <see cref="IList{T}"/>
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <param name="value1">Value #1 to add to the list</param>
		/// <param name="value2">Value #2 to add to the list</param>
		/// <returns>A new thread-safe list instance</returns>
		public static ThreadSafe.IList<T> Create<T>(T value1, T value2) {
			var list = new List<T>() { value1, value2 };
#if THREAD_SAFE
			return new ThreadSafeListWrapper<T>(list);
#else
			return list;
#endif
		}

		/// <summary>
		/// Creates a thread safe <see cref="IList{T}"/>
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <param name="value1">Value #1 to add to the list</param>
		/// <param name="value2">Value #2 to add to the list</param>
		/// <param name="value3">Value #3 to add to the list</param>
		/// <returns>A new thread-safe list instance</returns>
		public static ThreadSafe.IList<T> Create<T>(T value1, T value2, T value3) {
			var list = new List<T>() { value1, value2, value3 };
#if THREAD_SAFE
			return new ThreadSafeListWrapper<T>(list);
#else
			return list;
#endif
		}

		/// <summary>
		/// Creates a thread safe <see cref="IList{T}"/>
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <param name="args">Values to add to the list</param>
		/// <returns>A new thread-safe list instance</returns>
		public static ThreadSafe.IList<T> Create<T>(params T[] args) {
			var list = new List<T>(args);
#if THREAD_SAFE
			return new ThreadSafeListWrapper<T>(list);
#else
			return list;
#endif
		}

		/// <summary>
		/// Creates a thread safe <see cref="IList{T}"/>
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <param name="capacity">List capacity</param>
		/// <returns>A new thread-safe list instance</returns>
		public static ThreadSafe.IList<T> Create<T>(int capacity) {
			var list = new List<T>(capacity);
#if THREAD_SAFE
			return new ThreadSafeListWrapper<T>(list);
#else
			return list;
#endif
		}

		/// <summary>
		/// Creates a thread safe <see cref="IList{T}"/>
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <param name="collection">Values to copy to the new list</param>
		/// <returns>A new thread-safe list instance</returns>
		public static ThreadSafe.IList<T> Create<T>(IEnumerable<T> collection) {
			var list = new List<T>(collection);
#if THREAD_SAFE
			return new ThreadSafeListWrapper<T>(list);
#else
			return list;
#endif
		}

		/// <summary>
		/// Makes a list thread-safe by using a thread-safe wrapper list
		/// </summary>
		/// <typeparam name="T">List type</typeparam>
		/// <param name="list">The list that should be made thread-safe</param>
		/// <returns>A thread-safe list using <paramref name="list"/> as the underlying list</returns>
		public static ThreadSafe.IList<T> MakeThreadSafe<T>(IList<T> list) {
#if THREAD_SAFE
			if (list == null)
				return null;
			var tsList = list as ThreadSafe.IList<T>;
			if (tsList != null)
				return tsList;
			return new ThreadSafeListWrapper<T>(list);
#else
			return list;
#endif
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Threading/ThreadSafeListWrapper.cs
================================================
ï»¿// dnlib: See LICENSE.txt for more info

using System;
using System.Collections.Generic;
using System.Diagnostics;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.Threading {
#if THREAD_SAFE
	/// <summary>
	/// Protects an <see cref="IList{T}"/> from being accessed by multiple threads at the same time
	/// </summary>
	/// <typeparam name="T">List type</typeparam>
	[DebuggerDisplay("Count = {Count}")]
	sealed class ThreadSafeListWrapper<T> : ThreadSafe.IList<T> {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly Lock theLock = Lock.Create();

		readonly IList<T> list;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="list">A list</param>
		public ThreadSafeListWrapper(IList<T> list) {
			if (list == null)
				throw new ArgumentNullException("list");
			this.list = list;
		}

		/// <inheritdoc/>
		public int IndexOf(T item) {
			// We need a write lock since we don't know whether 'list' modifies any internal fields.
			theLock.EnterWriteLock(); try {
				return list.IndexOf(item);
			} finally { theLock.ExitWriteLock(); }
		}

		/// <inheritdoc/>
		public void Insert(int index, T item) {
			theLock.EnterWriteLock(); try {
				list.Insert(index, item);
			} finally { theLock.ExitWriteLock(); }
		}

		/// <inheritdoc/>
		public void RemoveAt(int index) {
			theLock.EnterWriteLock(); try {
				list.RemoveAt(index);
			} finally { theLock.ExitWriteLock(); }
		}

		/// <inheritdoc/>
		public T this[int index] {
			get {
				theLock.EnterWriteLock(); try {
					return list[index];
				} finally { theLock.ExitWriteLock(); }
			}
			set {
				theLock.EnterWriteLock(); try {
					list[index] = value;
				} finally { theLock.ExitWriteLock(); }
			}
		}

		/// <inheritdoc/>
		public void Add(T item) {
			theLock.EnterWriteLock(); try {
				list.Add(item);
			} finally { theLock.ExitWriteLock(); }
		}

		/// <inheritdoc/>
		public void Clear() {
			theLock.EnterWriteLock(); try {
				list.Clear();
			} finally { theLock.ExitWriteLock(); }
		}

		/// <inheritdoc/>
		public bool Contains(T item) {
			theLock.EnterWriteLock(); try {
				return list.Contains(item);
			} finally { theLock.ExitWriteLock(); }
		}

		/// <inheritdoc/>
		public void CopyTo(T[] array, int arrayIndex) {
			theLock.EnterWriteLock(); try {
				list.CopyTo(array, arrayIndex);
			} finally { theLock.ExitWriteLock(); }
		}

		/// <inheritdoc/>
		public int Count {
			get {
				theLock.EnterWriteLock(); try {
					return list.Count;
				} finally { theLock.ExitWriteLock(); }
			}
		}

		/// <inheritdoc/>
		public bool IsReadOnly {
			get {
				theLock.EnterWriteLock(); try {
					return list.IsReadOnly;
				} finally { theLock.ExitWriteLock(); }
			}
		}

		/// <inheritdoc/>
		public bool Remove(T item) {
			theLock.EnterWriteLock(); try {
				return list.Remove(item);
			} finally { theLock.ExitWriteLock(); }
		}

		/// <inheritdoc/>
		public IEnumerator<T> GetEnumerator() {
			theLock.EnterWriteLock(); try {
				return list.GetEnumerator();
			} finally { theLock.ExitWriteLock(); }
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}

		/// <inheritdoc/>
		public int Count_NoLock {
			get { return list.Count; }
		}

		/// <inheritdoc/>
		public bool IsReadOnly_NoLock {
			get { return list.IsReadOnly; }
		}

		/// <inheritdoc/>
		public int IndexOf_NoLock(T item) {
			return list.IndexOf(item);
		}

		/// <inheritdoc/>
		public void Insert_NoLock(int index, T item) {
			list.Insert(index, item);
		}

		/// <inheritdoc/>
		public void RemoveAt_NoLock(int index) {
			list.RemoveAt(index);
		}

		/// <inheritdoc/>
		public T Get_NoLock(int index) {
			return list[index];
		}

		/// <inheritdoc/>
		public void Set_NoLock(int index, T value) {
			list[index] = value;
		}

		/// <inheritdoc/>
		public void Add_NoLock(T item) {
			list.Add(item);
		}

		/// <inheritdoc/>
		public void Clear_NoLock() {
			list.Clear();
		}

		/// <inheritdoc/>
		public bool Contains_NoLock(T item) {
			return list.Contains(item);
		}

		/// <inheritdoc/>
		public void CopyTo_NoLock(T[] array, int arrayIndex) {
			list.CopyTo(array, arrayIndex);
		}

		/// <inheritdoc/>
		public bool Remove_NoLock(T item) {
			return list.Remove(item);
		}

		/// <inheritdoc/>
		public IEnumerator<T> GetEnumerator_NoLock() {
			return list.GetEnumerator();
		}

		/// <inheritdoc/>
		public TRetType ExecuteLocked<TArgType, TRetType>(TArgType arg, ExecuteLockedDelegate<T, TArgType, TRetType> handler) {
			theLock.EnterWriteLock(); try {
				return handler(this, arg);
			} finally { theLock.ExitWriteLock(); }
		}
	}
#endif
}



================================================
File: Libraries/dnlib/dnlib.Shared/Utils/Extensions.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.Utils {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class Extensions {
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Utils/ILazyList.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.Utils {
	/// <summary>
	/// Interface to access a lazily initialized list
	/// </summary>
	/// <typeparam name="TValue">Type to store in list</typeparam>
	public interface ILazyList<TValue> : ThreadSafe.IList<TValue> {
		/// <summary>
		/// Checks whether an element at <paramref name="index"/> has been initialized.
		/// </summary>
		/// <param name="index">Index of element</param>
		/// <returns><c>true</c> if the element has been initialized, <c>false</c> otherwise</returns>
		bool IsInitialized(int index);

		/// <summary>
		/// Checks whether an element at <paramref name="index"/> has been initialized.
		/// </summary>
		/// <param name="index">Index of element</param>
		/// <returns><c>true</c> if the element has been initialized, <c>false</c> otherwise</returns>
		bool IsInitialized_NoLock(int index);

		/// <summary>
		/// Gets all initialized elements
		/// </summary>
		/// <param name="clearList"><c>true</c> if the list should be cleared before returning,
		/// <c>false</c> if the list should not cleared.</param>
		List<TValue> GetInitializedElements(bool clearList);
	}

	public static partial class Extensions {
		/// <summary>
		/// Disposes all initialized elements
		/// </summary>
		/// <typeparam name="TValue">Element type</typeparam>
		/// <param name="list">this</param>
		public static void DisposeAll<TValue>(this ILazyList<TValue> list) where TValue : IDisposable {
			list.ExecuteLocked<TValue, object, object>(null, (tsList, arg) => {
				for (int i = 0; i < list.Count_NoLock(); i++) {
					if (list.IsInitialized_NoLock(i)) {
						var elem = list.Get_NoLock(i);
						if (elem != null)
							elem.Dispose();
					}
				}
				return null;
			});
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Utils/LazyList.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.Threading;

namespace dnlib.Utils {
	/// <summary>
	/// Gets notified of list events
	/// </summary>
	/// <typeparam name="TListValue">List value</typeparam>
	public interface IListListener<TListValue> {
		/// <summary>
		/// Called before a new value is lazily added to the list.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		/// <param name="index">Index where the value will be added</param>
		/// <param name="value">Value that will be added to the list. It can be modified by
		/// the callee.</param>
		void OnLazyAdd(int index, ref TListValue value);

		/// <summary>
		/// Called before a new value is added to the list.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		/// <param name="index">Index where the value will be added</param>
		/// <param name="value">Value that will be added to the list</param>
		void OnAdd(int index, TListValue value);

		/// <summary>
		/// Called before a value is removed from the list. If all elements are removed,
		/// <see cref="OnClear()"/> is called, and this method is not called.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		/// <param name="index">Index of value</param>
		/// <param name="value">The value that will be removed</param>
		void OnRemove(int index, TListValue value);

		/// <summary>
		/// Called after the list has been resized (eg. an element has been added/removed). It's not
		/// called when an element is replaced.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		/// <param name="index">Index where the change occurred.</param>
		void OnResize(int index);

		/// <summary>
		/// Called before the whole list is cleared.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		void OnClear();
	}

	/// <summary>
	/// Implements a <see cref="IList{T}"/> that is lazily initialized
	/// </summary>
	/// <typeparam name="TValue">Type to store in list</typeparam>
	[DebuggerDisplay("Count = {Count}")]
	public class LazyList<TValue> : ILazyList<TValue> where TValue : class {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly object context;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly MFunc<object, uint, TValue> readOriginalValue;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		readonly List<Element> list;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		int id = 0;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly IListListener<TValue> listener;

#if THREAD_SAFE
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Stores a simple value
		/// </summary>
		class Element {
			protected TValue value;

			/// <summary>
			/// <c>true</c> if it has been initialized, <c>false</c> otherwise
			/// </summary>
			public virtual bool IsInitialized_NoLock {
				get { return true; }
			}

			/// <summary>
			/// Default constructor
			/// </summary>
			protected Element() {
			}

			/// <summary>
			/// Constructor that should be used when new elements are inserted into <see cref="LazyList{T}"/>
			/// </summary>
			/// <param name="data">User data</param>
			public Element(TValue data) {
				this.value = data;
			}

			/// <summary>
			/// Gets the value
			/// </summary>
			/// <param name="index">Index in the list</param>
			public virtual TValue GetValue_NoLock(int index) {
				return value;
			}

			/// <summary>
			/// Sets the value
			/// </summary>
			/// <param name="index">Index in the list</param>
			/// <param name="value">New value</param>
			public virtual void SetValue_NoLock(int index, TValue value) {
				this.value = value;
			}

			/// <inheritdoc/>
			public override string ToString() {
				return value == null ? string.Empty : value.ToString();
			}
		}

		/// <summary>
		/// Stores data and keeps track of the original index and whether the data has been
		/// initialized or not.
		/// </summary>
		sealed class LazyElement : Element {
			internal readonly uint origIndex;
			LazyList<TValue> lazyList;

			/// <inheritdoc/>
			public override bool IsInitialized_NoLock {
				get { return lazyList == null; }
			}

			/// <inheritdoc/>
			public override TValue GetValue_NoLock(int index) {
				if (lazyList != null) {
					value = lazyList.ReadOriginalValue_NoLock(index, origIndex);
					lazyList = null;
				}
				return value;
			}

			/// <inheritdoc/>
			public override void SetValue_NoLock(int index, TValue value) {
				this.value = value;
				lazyList = null;
			}

			/// <summary>
			/// Constructor that should only be called when <see cref="LazyList{T}"/> is initialized.
			/// </summary>
			/// <param name="origIndex">Original index of this element</param>
			/// <param name="lazyList">LazyList instance</param>
			public LazyElement(int origIndex, LazyList<TValue> lazyList) {
				this.origIndex = (uint)origIndex;
				this.lazyList = lazyList;
			}

			/// <inheritdoc/>
			public override string ToString() {
				if (lazyList != null) {
					value = lazyList.ReadOriginalValue_NoLock(this);
					lazyList = null;
				}
				return value == null ? string.Empty : value.ToString();
			}
		}

		/// <inheritdoc/>
		[DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
		public int Count {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return Count_NoLock;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
		}

		/// <inheritdoc/>
		[DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
		public int Count_NoLock {
			get { return list.Count; }
		}

		/// <inheritdoc/>
		[DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
		public bool IsReadOnly {
			get { return false; }
		}

		/// <inheritdoc/>
		[DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
		public bool IsReadOnly_NoLock {
			get { return false; }
		}

		/// <inheritdoc/>
		public TValue this[int index] {
			get {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				return Get_NoLock(index);
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				Set_NoLock(index, value);
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <inheritdoc/>
		public TValue Get_NoLock(int index) {
			return list[index].GetValue_NoLock(index);
		}

		/// <inheritdoc/>
		public void Set_NoLock(int index, TValue value) {
			if (listener != null) {
				listener.OnRemove(index, list[index].GetValue_NoLock(index));
				listener.OnAdd(index, value);
			}
			list[index].SetValue_NoLock(index, value);
			id++;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public LazyList()
			: this(null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="listener">List listener</param>
		public LazyList(IListListener<TValue> listener) {
			this.listener = listener;
			this.list = new List<Element>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Initial length of the list</param>
		/// <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
		/// <param name="readOriginalValue">Delegate instance that returns original values</param>
		public LazyList(int length, object context, MFunc<object, uint, TValue> readOriginalValue)
			: this(length, null, context, readOriginalValue) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Initial length of the list</param>
		/// <param name="listener">List listener</param>
		/// <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
		/// <param name="readOriginalValue">Delegate instance that returns original values</param>
		public LazyList(int length, IListListener<TValue> listener, object context, MFunc<object, uint, TValue> readOriginalValue) {
			this.listener = listener;
			this.context = context;
			this.readOriginalValue = readOriginalValue;
			this.list = new List<Element>(length);
			for (int i = 0; i < length; i++)
				list.Add(new LazyElement(i, this));
		}

		TValue ReadOriginalValue_NoLock(LazyElement elem) {
			return ReadOriginalValue_NoLock(list.IndexOf(elem), elem.origIndex);
		}

		TValue ReadOriginalValue_NoLock(int index, uint origIndex) {
			var newValue = readOriginalValue(context, origIndex);
			if (listener != null)
				listener.OnLazyAdd(index, ref newValue);
			return newValue;
		}

		/// <inheritdoc/>
		public int IndexOf(TValue item) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return IndexOf_NoLock(item);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public int IndexOf_NoLock(TValue item) {
			for (int i = 0; i < list.Count; i++) {
				if (list[i].GetValue_NoLock(i) == item)
					return i;
			}
			return -1;
		}

		/// <inheritdoc/>
		public void Insert(int index, TValue item) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			Insert_NoLock(index, item);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public void Insert_NoLock(int index, TValue item) {
			if (listener != null)
				listener.OnAdd(index, item);
			list.Insert(index, new Element(item));
			if (listener != null)
				listener.OnResize(index);
			id++;
		}

		/// <inheritdoc/>
		public void RemoveAt(int index) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			RemoveAt_NoLock(index);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public void RemoveAt_NoLock(int index) {
			if (listener != null)
				listener.OnRemove(index, list[index].GetValue_NoLock(index));
			list.RemoveAt(index);
			if (listener != null)
				listener.OnResize(index);
			id++;
		}

		/// <inheritdoc/>
		public void Add(TValue item) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			Add_NoLock(item);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public void Add_NoLock(TValue item) {
			int index = list.Count;
			if (listener != null)
				listener.OnAdd(index, item);
			list.Add(new Element(item));
			if (listener != null)
				listener.OnResize(index);
			id++;
		}

		/// <inheritdoc/>
		public void Clear() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			Clear_NoLock();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public void Clear_NoLock() {
			if (listener != null)
				listener.OnClear();
			list.Clear();
			if (listener != null)
				listener.OnResize(0);
			id++;
		}

		/// <inheritdoc/>
		public bool Contains(TValue item) {
			return IndexOf(item) >= 0;
		}

		/// <inheritdoc/>
		public bool Contains_NoLock(TValue item) {
			return IndexOf_NoLock(item) >= 0;
		}

		/// <inheritdoc/>
		public void CopyTo(TValue[] array, int arrayIndex) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			CopyTo_NoLock(array, arrayIndex);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public void CopyTo_NoLock(TValue[] array, int arrayIndex) {
			for (int i = 0; i < list.Count; i++)
				array[arrayIndex + i] = list[i].GetValue_NoLock(i);
		}

		/// <inheritdoc/>
		public bool Remove(TValue item) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return Remove_NoLock(item);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public bool Remove_NoLock(TValue item) {
			int index = IndexOf_NoLock(item);
			if (index < 0)
				return false;
			RemoveAt_NoLock(index);
			return true;
		}

		/// <inheritdoc/>
		public bool IsInitialized(int index) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			return IsInitialized_NoLock(index);
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
		}

		/// <inheritdoc/>
		public bool IsInitialized_NoLock(int index) {
			if ((uint)index >= (uint)list.Count)
				return false;
			return list[index].IsInitialized_NoLock;
		}

		/// <inheritdoc/>
		public IEnumerator<TValue> GetEnumerator() {
			int id2;
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			id2 = id;
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
			for (int i = 0; ; i++) {
				TValue value;
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				if (id != id2)
					throw new InvalidOperationException("List was modified");
				if (i >= list.Count)
					break;
				value = list[i].GetValue_NoLock(i);
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
				yield return value;
			}
		}

		/// <inheritdoc/>
		public IEnumerator<TValue> GetEnumerator_NoLock() {
			int id2 = id;
			for (int i = 0; i < list.Count; i++) {
				if (id != id2)
					throw new InvalidOperationException("List was modified");
				yield return list[i].GetValue_NoLock(i);
			}
		}

		/// <inheritdoc/>
		public List<TValue> GetInitializedElements(bool clearList) {
			List<TValue> newList;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			newList = new List<TValue>(list.Count);
			int id2 = id;
			for (int i = 0; i < list.Count; i++) {
				if (id != id2)
					throw new InvalidOperationException("List was modified");
				var elem = list[i];
				if (!elem.IsInitialized_NoLock)
					continue;
				newList.Add(elem.GetValue_NoLock(i));
			}
			if (clearList)
				Clear_NoLock();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			return newList;
		}

		/// <inheritdoc/>
		IEnumerator IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}

#if THREAD_SAFE
		/// <inheritdoc/>
		public TRetType ExecuteLocked<TArgType, TRetType>(TArgType arg, ExecuteLockedDelegate<TValue, TArgType, TRetType> handler) {
			theLock.EnterWriteLock(); try {
				return handler(this, arg);
			} finally { theLock.ExitWriteLock(); }
		}
#endif
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Utils/MFunc.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.Utils {
	delegate T MFunc<T>();
	delegate U MFunc<T, U>(T t);

	/// <summary>
	/// Same as Func delegate
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <typeparam name="U"></typeparam>
	/// <typeparam name="V"></typeparam>
	/// <param name="t"></param>
	/// <param name="u"></param>
	/// <returns></returns>
	public delegate V MFunc<T, U, V>(T t, U u);
}



================================================
File: Libraries/dnlib/dnlib.Shared/Utils/SimpleLazyList.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System.Diagnostics;
using System.Threading;
using dnlib.DotNet;

namespace dnlib.Utils {
	/// <summary>
	/// A readonly list that gets initialized lazily
	/// </summary>
	/// <typeparam name="T">Any class type</typeparam>
	[DebuggerDisplay("Count = {Length}")]
	sealed class SimpleLazyList<T> where T : class {
		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		readonly T[] elements;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly MFunc<uint, T> readElementByRID;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly uint length;

		/// <summary>
		/// Gets the length of this list
		/// </summary>
		public uint Length {
			get { return length; }
		}

		/// <summary>
		/// Access the list
		/// </summary>
		/// <param name="index">Index</param>
		/// <returns>The element or <c>null</c> if <paramref name="index"/> is invalid</returns>
		public T this[uint index] {
			get {
				if (index >= length)
					return null;
				if (elements[index] == null)
					Interlocked.CompareExchange(ref elements[index], readElementByRID(index + 1), null);
				return elements[index];
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Length of the list</param>
		/// <param name="readElementByRID">Delegate instance that lazily reads an element. It might
		/// be called more than once for each <c>rid</c> in rare cases. It must never return
		/// <c>null</c>.</param>
		public SimpleLazyList(uint length, MFunc<uint, T> readElementByRID) {
			this.length = length;
			this.readElementByRID = readElementByRID;
			this.elements = new T[length];
		}
	}

	/// <summary>
	/// A readonly list that gets initialized lazily
	/// </summary>
	/// <typeparam name="T">Any class type</typeparam>
	[DebuggerDisplay("Count = {Length}")]
	sealed class SimpleLazyList2<T> where T : class, IContainsGenericParameter {
		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		readonly T[] elements;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly MFunc<uint, GenericParamContext, T> readElementByRID;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly uint length;

		/// <summary>
		/// Gets the length of this list
		/// </summary>
		public uint Length {
			get { return length; }
		}

		/// <summary>
		/// Access the list
		/// </summary>
		/// <param name="index">Index</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>The element or <c>null</c> if <paramref name="index"/> is invalid</returns>
		public T this[uint index, GenericParamContext gpContext] {
			get {
				if (index >= length)
					return null;
				if (elements[index] == null) {
					var elem = readElementByRID(index + 1, gpContext);
					// Don't cache it if it contains GPs since each GP could hold a reference
					// to the type/method context. These GPs can't be shared.
					if (elem.ContainsGenericParameter)
						return elem;
					Interlocked.CompareExchange(ref elements[index], elem, null);
				}
				return elements[index];
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Length of the list</param>
		/// <param name="readElementByRID">Delegate instance that lazily reads an element. It might
		/// be called more than once for each <c>rid</c>. It must never return <c>null</c>.</param>
		public SimpleLazyList2(uint length, MFunc<uint, GenericParamContext, T> readElementByRID) {
			this.length = length;
			this.readElementByRID = readElementByRID;
			this.elements = new T[length];
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/Utils/UserValue.cs
================================================
// dnlib: See LICENSE.txt for more info

using System.Diagnostics;
using dnlib.Threading;

namespace dnlib.Utils {
	/// <summary>
	/// Lazily returns the original value if the user hasn't overwritten the value
	/// </summary>
	/// <typeparam name="TValue">Value type</typeparam>
	[DebuggerDisplay("{value}")]
	struct UserValue<TValue> {
#if THREAD_SAFE
		Lock theLock;
#endif
		MFunc<TValue> readOriginalValue;
		TValue value;
		bool isUserValue;
		bool isValueInitialized;

#if THREAD_SAFE
		/// <summary>
		/// Sets the lock that protects the data
		/// </summary>
		public Lock Lock {
			set { theLock = value; }
		}
#endif

		/// <summary>
		/// Set a delegate instance that will return the original value
		/// </summary>
		public MFunc<TValue> ReadOriginalValue {
			set { readOriginalValue = value; }
		}

		/// <summary>
		/// Gets/sets the value
		/// </summary>
		/// <remarks>The getter returns the original value if the value hasn't been initialized.</remarks>
		public TValue Value {
			get {
#if THREAD_SAFE
				if (theLock != null) theLock.EnterWriteLock(); try {
#endif
				if (!isValueInitialized) {
					value = readOriginalValue();
					readOriginalValue = null;
					isValueInitialized = true;
				}
				return value;
#if THREAD_SAFE
				} finally { if (theLock != null) theLock.ExitWriteLock(); }
#endif
			}
			set {
#if THREAD_SAFE
				if (theLock != null) theLock.EnterWriteLock(); try {
#endif
				this.value = value;
				readOriginalValue = null;
				isUserValue = true;
				isValueInitialized = true;
#if THREAD_SAFE
				} finally { if (theLock != null) theLock.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Returns <c>true</c> if the value has been initialized
		/// </summary>
		public bool IsValueInitialized {
#if THREAD_SAFE
			get {
				if (theLock != null)
					theLock.EnterReadLock();
				try {
					return isValueInitialized;
				}
				finally { if (theLock != null) theLock.ExitReadLock(); }
			}
#else
			get { return isValueInitialized; }
#endif
		}

		/// <summary>
		/// Returns <c>true</c> if the value was set by the user
		/// </summary>
		public bool IsUserValue {
#if THREAD_SAFE
			get {
				if (theLock != null)
					theLock.EnterReadLock();
				try {
					return isUserValue;
				}
				finally { if (theLock != null) theLock.ExitReadLock(); }
			}
#else
			get { return isUserValue; }
#endif
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/W32Resources/ResourceData.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.IO;
using System.Threading;
using dnlib.IO;

namespace dnlib.W32Resources {
	/// <summary>
	/// A resource blob
	/// </summary>
	public sealed class ResourceData : ResourceDirectoryEntry, IDisposable {
		IBinaryReader reader;
		uint codePage;
		uint reserved;

		/// <summary>
		/// Gets/sets the data reader. This instance owns the reader.
		/// </summary>
		public IBinaryReader Data {
			get { return reader; }
			set {
				var oldValue = Interlocked.Exchange(ref reader, value);
				if (oldValue != value && oldValue != null)
					oldValue.Dispose();
			}
		}

		/// <summary>
		/// Gets/sets the code page
		/// </summary>
		public uint CodePage {
			get { return codePage; }
			set { codePage = value; }
		}

		/// <summary>
		/// Gets/sets the reserved field
		/// </summary>
		public uint Reserved {
			get { return reserved; }
			set { reserved = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public ResourceData(ResourceName name)
			: base(name) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">Raw data. This instance owns this reader.</param>
		/// <param name="name">Name</param>
		public ResourceData(ResourceName name, IBinaryReader reader)
			: base(name) {
			this.reader = reader;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">Raw data. This instance owns this reader.</param>
		/// <param name="name">Name</param>
		/// <param name="codePage">Code page</param>
		/// <param name="reserved">Reserved value</param>
		public ResourceData(ResourceName name, IBinaryReader reader, uint codePage, uint reserved)
			: base(name) {
			this.reader = reader;
			this.codePage = codePage;
			this.reserved = reserved;
		}

		/// <summary>
		/// Gets the data as a <see cref="Stream"/>. It shares the file position with <see cref="Data"/>
		/// </summary>
		public Stream ToDataStream() {
			return Data.CreateStream();
		}

		/// <inheritdoc/>
		public void Dispose() {
			var oldValue = Interlocked.Exchange(ref reader, null);
			if (oldValue != null)
				oldValue.Dispose();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/W32Resources/ResourceDirectory.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Collections.Generic;
using System.Text;
using dnlib.Utils;
using dnlib.IO;
using dnlib.PE;
using dnlib.Threading;

#if THREAD_SAFE
using ThreadSafe = dnlib.Threading.Collections;
#else
using ThreadSafe = System.Collections.Generic;
#endif

namespace dnlib.W32Resources {
	/// <summary>
	/// A Win32 resource directory (see IMAGE_RESOURCE_DIRECTORY in the Windows SDK)
	/// </summary>
	public abstract class ResourceDirectory : ResourceDirectoryEntry, IDisposable {
		/// <summary>See <see cref="Characteristics"/></summary>
		protected uint characteristics;
		/// <summary>See <see cref="TimeDateStamp"/></summary>
		protected uint timeDateStamp;
		/// <summary>See <see cref="MajorVersion"/></summary>
		protected ushort majorVersion;
		/// <summary>See <see cref="MinorVersion"/></summary>
		protected ushort minorVersion;
		/// <summary>See <see cref="Directories"/></summary>
		protected ILazyList<ResourceDirectory> directories;
		/// <summary>See <see cref="Data"/></summary>
		protected ILazyList<ResourceData> data;

		/// <summary>
		/// Gets/sets the characteristics
		/// </summary>
		public uint Characteristics {
			get { return characteristics; }
			set { characteristics = value; }
		}

		/// <summary>
		/// Gets/sets the time date stamp
		/// </summary>
		public uint TimeDateStamp {
			get { return timeDateStamp; }
			set { timeDateStamp = value; }
		}

		/// <summary>
		/// Gets/sets the major version number
		/// </summary>
		public ushort MajorVersion {
			get { return majorVersion; }
			set { majorVersion = value; }
		}

		/// <summary>
		/// Gets/sets the minor version number
		/// </summary>
		public ushort MinorVersion {
			get { return minorVersion; }
			set { minorVersion = value; }
		}

		/// <summary>
		/// Gets all directory entries
		/// </summary>
		public ThreadSafe.IList<ResourceDirectory> Directories {
			get { return directories; }
		}

		/// <summary>
		/// Gets all resource data
		/// </summary>
		public ThreadSafe.IList<ResourceData> Data {
			get { return data; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		protected ResourceDirectory(ResourceName name)
			: base(name) {
		}

		/// <summary>
		/// Finds a <see cref="ResourceDirectory"/> by name
		/// </summary>
		/// <param name="name">Name</param>
		/// <returns>A <see cref="ResourceDirectory"/> or <c>null</c> if it wasn't found</returns>
		public ResourceDirectory FindDirectory(ResourceName name) {
			foreach (var dir in directories.GetSafeEnumerable()) {
				if (dir.Name == name)
					return dir;
			}
			return null;
		}

		/// <summary>
		/// Finds a <see cref="ResourceData"/> by name
		/// </summary>
		/// <param name="name">Name</param>
		/// <returns>A <see cref="ResourceData"/> or <c>null</c> if it wasn't found</returns>
		public ResourceData FindData(ResourceName name) {
			foreach (var d in data.GetSafeEnumerable()) {
				if (d.Name == name)
					return d;
			}
			return null;
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			directories.DisposeAll();
			data.DisposeAll();
			directories = null;
			data = null;
		}
	}

	/// <summary>
	/// A Win32 resource directory created by the user
	/// </summary>
	public class ResourceDirectoryUser : ResourceDirectory {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public ResourceDirectoryUser(ResourceName name)
			: base(name) {
			this.directories = new LazyList<ResourceDirectory>();
			this.data = new LazyList<ResourceData>();
		}
	}

	/// <summary>
	/// A Win32 resource directory created from a PE file
	/// </summary>
	public sealed class ResourceDirectoryPE : ResourceDirectory {
		/// <summary>
		/// To make sure we don't get stuck in an infinite loop, don't allow more than this
		/// many sub directories.
		/// </summary>
		const uint MAX_DIR_DEPTH = 10;

		/// <summary>Owner</summary>
		readonly Win32ResourcesPE resources;
		/// <summary>Directory depth. When creating more <see cref="ResourceDirectoryPE"/>'s,
		/// the instances get this value + 1</summary>
		uint depth;

		/// <summary>
		/// Info about all <see cref="ResourceData"/>'s we haven't created yet
		/// </summary>
		List<EntryInfo> dataInfos;

		/// <summary>
		/// Info about all <see cref="ResourceDirectory"/>'s we haven't created yet
		/// </summary>
		List<EntryInfo> dirInfos;

		struct EntryInfo {
			public readonly ResourceName name;

			/// <summary>Offset of resource directory / data</summary>
			public readonly uint offset;

			public EntryInfo(ResourceName name, uint offset) {
				this.name = name;
				this.offset = offset;
			}

			public override string ToString() {
				return string.Format("{0:X8} {1}", offset, name);
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="depth">Starts from 0. If it's big enough, we'll stop reading more data.</param>
		/// <param name="name">Name</param>
		/// <param name="resources">Resources</param>
		/// <param name="reader">Reader positioned at the start of this resource directory</param>
		public ResourceDirectoryPE(uint depth, ResourceName name, Win32ResourcesPE resources, IBinaryReader reader)
			: base(name) {
			this.resources = resources;
			this.depth = depth;
			Initialize(reader);
		}

		/// <summary>
		/// Reads the directory header and initializes <see cref="ResourceDirectory.directories"/> and
		/// <see cref="ResourceDirectory.data"/>.
		/// </summary>
		/// <param name="reader"></param>
		void Initialize(IBinaryReader reader) {
			if (depth > MAX_DIR_DEPTH || !reader.CanRead(16)) {
				InitializeDefault();
				return;
			}

			characteristics = reader.ReadUInt32();
			timeDateStamp = reader.ReadUInt32();
			majorVersion = reader.ReadUInt16();
			minorVersion = reader.ReadUInt16();
			ushort numNamed = reader.ReadUInt16();
			ushort numIds = reader.ReadUInt16();

			int total = numNamed + numIds;
			if (!reader.CanRead(total * 8)) {
				InitializeDefault();
				return;
			}

			dataInfos = new List<EntryInfo>();
			dirInfos = new List<EntryInfo>();
			long offset = reader.Position;
			for (int i = 0; i < total; i++, offset += 8) {
				reader.Position = offset;
				uint nameOrId = reader.ReadUInt32();
				uint dataOrDirectory = reader.ReadUInt32();
				ResourceName name;
				if ((nameOrId & 0x80000000) != 0)
					name = new ResourceName(ReadString(reader, nameOrId & 0x7FFFFFFF) ?? string.Empty);
				else
					name = new ResourceName((int)nameOrId);

				if ((dataOrDirectory & 0x80000000) == 0)
					dataInfos.Add(new EntryInfo(name, dataOrDirectory));
				else
					dirInfos.Add(new EntryInfo(name, dataOrDirectory & 0x7FFFFFFF));
			}

			directories = new LazyList<ResourceDirectory>(dirInfos.Count, null, (ctx, i) => ReadResourceDirectory((int)i));
			data = new LazyList<ResourceData>(dataInfos.Count, null, (ctx, i) => ReadResourceData((int)i));
		}

		/// <summary>
		/// Reads a string
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <param name="offset">Offset of string</param>
		/// <returns>The string or <c>null</c> if we could not read it</returns>
		static string ReadString(IBinaryReader reader, uint offset) {
			reader.Position = offset;
			if (!reader.CanRead(2))
				return null;
			int size = reader.ReadUInt16();
			int sizeInBytes = size * 2;
			if (!reader.CanRead(sizeInBytes))
				return null;
			var stringData = reader.ReadBytes(sizeInBytes);
			try {
				return Encoding.Unicode.GetString(stringData);
			}
			catch {
				return null;
			}
		}

		ResourceDirectory ReadResourceDirectory(int i) {
#if THREAD_SAFE
			resources.theLock.EnterWriteLock(); try {
#endif
			var info = dirInfos[i];
			var reader = resources.ResourceReader;
			var oldPos = reader.Position;
			reader.Position = info.offset;

			var dir = new ResourceDirectoryPE(depth + 1, info.name, resources, reader);

			reader.Position = oldPos;
			return dir;
#if THREAD_SAFE
			} finally { resources.theLock.ExitWriteLock(); }
#endif
		}

		ResourceData ReadResourceData(int i) {
#if THREAD_SAFE
			resources.theLock.EnterWriteLock(); try {
#endif
			var info = dataInfos[i];
			var reader = resources.ResourceReader;
			var oldPos = reader.Position;
			reader.Position = info.offset;

			ResourceData data;
			if (reader.CanRead(16)) {
				RVA rva = (RVA)reader.ReadUInt32();
				uint size = reader.ReadUInt32();
				uint codePage = reader.ReadUInt32();
				uint reserved = reader.ReadUInt32();
				var dataReader = resources.CreateDataReader_NoLock(rva, size);
				data = new ResourceData(info.name, dataReader, codePage, reserved);
			}
			else
				data = new ResourceData(info.name, MemoryImageStream.CreateEmpty());

			reader.Position = oldPos;
			return data;
#if THREAD_SAFE
			} finally { resources.theLock.ExitWriteLock(); }
#endif
		}

		void InitializeDefault() {
			directories = new LazyList<ResourceDirectory>();
			data = new LazyList<ResourceData>();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/W32Resources/ResourceDirectoryEntry.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿namespace dnlib.W32Resources {
	/// <summary>
	/// Base class of <see cref="ResourceDirectory"/> and <see cref="ResourceData"/>
	/// </summary>
	public abstract class ResourceDirectoryEntry {
		ResourceName name;

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public ResourceName Name {
			get { return name; }
			set { name = value; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		protected ResourceDirectoryEntry(ResourceName name) {
			this.name = name;
		}

		/// <inheritdoc/>
		public override string ToString() {
			return name.ToString();
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/W32Resources/ResourceName.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;

namespace dnlib.W32Resources {
	/// <summary>
	/// A Win32 resource name. It can be either an integer or a string.
	/// </summary>
	public struct ResourceName : IComparable<ResourceName>, IEquatable<ResourceName> {
		readonly int id;
		readonly string name;

		/// <summary>
		/// <c>true</c> if <see cref="Id"/> is valid
		/// </summary>
		public bool HasId {
			get { return name == null; }
		}

		/// <summary>
		/// <c>true</c> if <see cref="Name"/> is valid
		/// </summary>
		public bool HasName {
			get { return name != null; }
		}

		/// <summary>
		/// The ID. It's only valid if <see cref="HasId"/> is <c>true</c>
		/// </summary>
		public int Id {
			get { return id; }
		}

		/// <summary>
		/// The name. It's only valid if <see cref="HasName"/> is <c>true</c>
		/// </summary>
		public string Name {
			get { return name; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="id">ID</param>
		public ResourceName(int id) {
			this.id = id;
			this.name = null;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public ResourceName(string name) {
			this.id = 0;
			this.name = name;
		}

		/// <summary>Converts input to a <see cref="ResourceName"/></summary>
		public static implicit operator ResourceName(int id) {
			return new ResourceName(id);
		}

		/// <summary>Converts input to a <see cref="ResourceName"/></summary>
		public static implicit operator ResourceName(string name) {
			return new ResourceName(name);
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator <(ResourceName left, ResourceName right) {
			return left.CompareTo(right) < 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator <=(ResourceName left, ResourceName right) {
			return left.CompareTo(right) <= 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator >(ResourceName left, ResourceName right) {
			return left.CompareTo(right) > 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator >=(ResourceName left, ResourceName right) {
			return left.CompareTo(right) >= 0;
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(ResourceName left, ResourceName right) {
			return left.Equals(right);
		}

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(ResourceName left, ResourceName right) {
			return !left.Equals(right);
		}

		/// <inheritdoc/>
		public int CompareTo(ResourceName other) {
			if (HasId != other.HasId) {
				// Sort names before ids
				return HasName ? -1 : 1;
			}
			if (HasId)
				return id.CompareTo(other.id);
			else
				return name.ToUpperInvariant().CompareTo(other.name.ToUpperInvariant());
		}

		/// <inheritdoc/>
		public bool Equals(ResourceName other) {
			return CompareTo(other) == 0;
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			if (!(obj is ResourceName))
				return false;
			return Equals((ResourceName)obj);
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			if (HasId)
				return id;
			return name.GetHashCode();
		}

		/// <inheritdoc/>
		public override string ToString() {
			return HasId ? id.ToString() : name;
		}
	}
}



================================================
File: Libraries/dnlib/dnlib.Shared/W32Resources/Win32Resources.cs
================================================
// dnlib: See LICENSE.txt for more info

ï»¿using System;
using System.Threading;
using dnlib.Utils;
using dnlib.IO;
using dnlib.PE;
using dnlib.Threading;

namespace dnlib.W32Resources {
	/// <summary>
	/// Win32 resources base class
	/// </summary>
	public abstract class Win32Resources : IDisposable {
		/// <summary>
		/// Gets/sets the root directory
		/// </summary>
		public abstract ResourceDirectory Root { get; set; }

		/// <summary>
		/// Finds a <see cref="ResourceDirectory"/>
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns>The <see cref="ResourceDirectory"/> or <c>null</c> if none found</returns>
		public ResourceDirectory Find(ResourceName type) {
			var dir = Root;
			if (dir == null)
				return null;
			return dir.FindDirectory(type);
		}

		/// <summary>
		/// Finds a <see cref="ResourceDirectory"/>
		/// </summary>
		/// <param name="type">Type</param>
		/// <param name="name">Name</param>
		/// <returns>The <see cref="ResourceDirectory"/> or <c>null</c> if none found</returns>
		public ResourceDirectory Find(ResourceName type, ResourceName name) {
			var dir = Find(type);
			if (dir == null)
				return null;
			return dir.FindDirectory(name);
		}

		/// <summary>
		/// Finds a <see cref="ResourceData"/>
		/// </summary>
		/// <param name="type">Type</param>
		/// <param name="name">Name</param>
		/// <param name="langId">Language ID</param>
		/// <returns>The <see cref="ResourceData"/> or <c>null</c> if none found</returns>
		public ResourceData Find(ResourceName type, ResourceName name, ResourceName langId) {
			var dir = Find(type, name);
			if (dir == null)
				return null;
			return dir.FindData(langId);
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			Root = null;	// Property handler will call Dispose()
		}
	}

	/// <summary>
	/// Win32 resources class created by the user
	/// </summary>
	public class Win32ResourcesUser : Win32Resources {
		ResourceDirectory root = new ResourceDirectoryUser(new ResourceName("root"));

		/// <inheritdoc/>
		public override ResourceDirectory Root {
			get { return root; }
			set {
				var oldValue = Interlocked.Exchange(ref root, value);
				if (oldValue != value && oldValue != null)
					oldValue.Dispose();
			}
		}
	}

	/// <summary>
	/// Win32 resources class created from a PE file
	/// </summary>
	public sealed class Win32ResourcesPE : Win32Resources {
		/// <summary>
		/// Converts data RVAs to file offsets in <see cref="dataReader"/>
		/// </summary>
		readonly IRvaFileOffsetConverter rvaConverter;

		/// <summary>
		/// This reader only reads the raw data. The data RVA is found in the data header and
		/// it's first converted to a file offset using <see cref="rvaConverter"/>. This file
		/// offset is where we'll read from using this reader.
		/// </summary>
		IImageStream dataReader;

		/// <summary>
		/// This reader only reads the directory entries and data headers. The data is read
		/// by <see cref="dataReader"/>
		/// </summary>
		IBinaryReader rsrcReader;

		UserValue<ResourceDirectory> root;

#if THREAD_SAFE
		internal readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public override ResourceDirectory Root {
			get { return root.Value; }
			set {
				IDisposable origValue = null;
				if (root.IsValueInitialized) {
					origValue = root.Value;
					if (origValue == value)
						return;
				}
				root.Value = value;

				if (origValue != null)
					origValue.Dispose();
			}
		}

		/// <summary>
		/// Gets the resource reader
		/// </summary>
		internal IBinaryReader ResourceReader {
			get { return rsrcReader; }
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rvaConverter"><see cref="RVA"/>/<see cref="FileOffset"/> converter</param>
		/// <param name="dataReader">Data reader (it's used after converting an <see cref="RVA"/>
		/// to a <see cref="FileOffset"/>). This instance owns the reader.</param>
		/// <param name="rsrcReader">Reader for the whole Win32 resources section (usually
		/// the .rsrc section). It's used to read <see cref="ResourceDirectory"/>'s and
		/// <see cref="ResourceData"/>'s but not the actual data blob. This instance owns the
		/// reader.</param>
		public Win32ResourcesPE(IRvaFileOffsetConverter rvaConverter, IImageStream dataReader, IBinaryReader rsrcReader) {
			if (dataReader == rsrcReader)
				rsrcReader = dataReader.Clone();	// Must not be the same readers
			this.rvaConverter = rvaConverter;
			this.dataReader = dataReader;
			this.rsrcReader = rsrcReader;
			Initialize();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="peImage">The PE image</param>
		public Win32ResourcesPE(IPEImage peImage)
			: this(peImage, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="rsrcReader">Reader for the whole Win32 resources section (usually
		/// the .rsrc section) or <c>null</c> if we should create one from the resource data
		/// directory in the optional header. This instance owns the reader.</param>
		public Win32ResourcesPE(IPEImage peImage, IBinaryReader rsrcReader) {
			this.rvaConverter = peImage;
			this.dataReader = peImage.CreateFullStream();
			if (rsrcReader != null)
				this.rsrcReader = rsrcReader;
			else {
				var dataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[2];
				if (dataDir.VirtualAddress != 0 && dataDir.Size != 0)
					this.rsrcReader = peImage.CreateStream(dataDir.VirtualAddress, dataDir.Size);
				else
					this.rsrcReader = MemoryImageStream.CreateEmpty();
			}
			Initialize();
		}

		void Initialize() {
			root.ReadOriginalValue = () => {
				if (rsrcReader == null)
					return null;	// It's disposed
				long oldPos = rsrcReader.Position;
				rsrcReader.Position = 0;
				var dir = new ResourceDirectoryPE(0, new ResourceName("root"), this, rsrcReader);
				rsrcReader.Position = oldPos;
				return dir;
			};
#if THREAD_SAFE
			root.Lock = theLock;
#endif
		}

		/// <summary>
		/// Creates a new data reader
		/// </summary>
		/// <param name="rva">RVA of data</param>
		/// <param name="size">Size of data</param>
		/// <returns>A new <see cref="IBinaryReader"/> for this data</returns>
		public IBinaryReader CreateDataReader(RVA rva, uint size) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return CreateDataReader_NoLock(rva, size);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal IBinaryReader CreateDataReader_NoLock(RVA rva, uint size) {
			var reader = dataReader.Create(rvaConverter.ToFileOffset(rva), size);
			if (reader.Length == size)
				return reader;
			reader.Dispose();
			return MemoryImageStream.CreateEmpty();
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			if (!disposing)
				return;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (dataReader != null)
				dataReader.Dispose();
			if (rsrcReader != null)
				rsrcReader.Dispose();
			dataReader = null;
			rsrcReader = null;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			base.Dispose(disposing);
		}
	}
}



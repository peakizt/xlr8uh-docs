Directory structure:
└── chaplin89-clarifierex/
    ├── README.md
    ├── Clarifier.sln
    ├── SettingsDescription.json
    ├── build.bat
    ├── Clarifier.CLI/
    │   ├── App.config
    │   ├── Clarifier.CLI.csproj
    │   ├── Program.cs
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── Clarifier.Core/
    │   ├── BaseStaticProtection.cs
    │   ├── BodyComparison.cs
    │   ├── BodyModifier.cs
    │   ├── Clarifier.Core.csproj
    │   ├── ClarifierContext.cs
    │   ├── ClarifierInjectHelper.cs
    │   ├── DnlibExtensionMethods.cs
    │   ├── MacroBodyComparison.cs
    │   ├── MacroContainer.cs
    │   └── Properties/
    │       └── AssemblyInfo.cs
    ├── Clarifier.Protections/
    │   ├── Clarifier.Protections.Impl/
    │   │   ├── AntiDebug.cs
    │   │   ├── AntiDump.cs
    │   │   ├── AntiTamper.cs
    │   │   ├── Clarifier.Protection.Impl.csproj
    │   │   ├── Class1.cs
    │   │   ├── Constants.cs
    │   │   ├── ControlFlow.cs
    │   │   ├── IClarifierContext.cs
    │   │   ├── IProtectionIdentificator.cs
    │   │   ├── IProtectionRemover.cs
    │   │   ├── Inliner.cs
    │   │   └── Properties/
    │   │       └── AssemblyInfo.cs
    │   └── Clarifier.Protections.Interface/
    │       ├── Clarifier.Protection.Interface.csproj
    │       ├── IProtectionIdentificator.cs
    │       ├── IProtectionRemover.cs
    │       └── Properties/
    │           └── AssemblyInfo.cs
    ├── Clarifier.Test/
    │   ├── SimpleConsoleApplication/
    │   │   ├── App.config
    │   │   ├── Clarifier.Test.SimpleConsoleApplication.csproj
    │   │   ├── Program.cs
    │   │   └── Properties/
    │   │       └── AssemblyInfo.cs
    │   ├── TestGenerator/
    │   │   ├── App.config
    │   │   ├── Clarifier.Test.ConfuserProjectsGenerator.csproj
    │   │   ├── ConfuserProtection.cs
    │   │   ├── Program.cs
    │   │   ├── packages.config
    │   │   └── Properties/
    │   │       └── AssemblyInfo.cs
    │   └── TestRunner/
    │       ├── Clarifier.Test.TestRunner.csproj
    │       ├── OutputCompare.cs
    │       └── Properties/
    │           └── AssemblyInfo.cs
    ├── ConfuserEx/
    └── FuzzyEngine/
        ├── ComparisonContext.cs
        ├── ILMetaInfo.xml
        ├── SherlockEngine.csproj
        ├── SherlockLoader.cs
        ├── SherlockNode.cs
        ├── packages.config
        ├── Compiler/
        │   ├── ASTNode.cs
        │   ├── ILexer.cs
        │   ├── SherlockCompiler.cs
        │   ├── SherlockLexer.cs
        │   ├── SherlockParser.cs
        │   ├── SherlockParserState.cs
        │   └── SherlockToken.cs
        └── Properties/
            └── AssemblyInfo.cs

================================================
File: README.md
================================================
# Overview

**This is only a PoC and it needs some major refactoring.**

ClarifierEx is a deobfuscator for ConfuserEx.
ConfuserEx is an obfuscator that support the following features:
  - Constants ofbuscation
  - Anti-dump
  - Anti-debug
  - Reference proxy
  - Anti-ildasm
  - Anti-tamper
  - Control flow obfuscation
  - Invalid metadata
  - Resource protection
  - Name obfuscation
  - Packer

## Supported protections
  - Anti-dump
  - Anti-debug

## Partially supported protections
These protection are only supported with standard configuration of ConfuserEx (see [wiki](https://github.com/chaplin89/ClarifierEx/wiki/ConfuserEx-settings) ):

  - Constants obfuscation
  - Reference proxy

## Plan to support other protections
Provided that the goal of a deobfuscator is not to "win the competion for the best looking assemblies" but to ease the job of the reverse engineer, as long as there is at least a reverse engineering tool capable of handling the metadata malformation or the other protections, it's not important for ClarifierEx to support those protections. From this starting point, here follow the plan to add the other protections.

### High priority
  - Anti-tamper
  - Control flow obfuscation
  - Packer

### Medium priority
  - Resource protection

### Low Priority
  - Name obfuscation

### Very Low Priority
  - Anti-ildasm
  - Invalid metadata

# Compiling
## Requirements
Visual Studio 2015
## Steps
1. Clone the repository and launch "build.bat" in order to build ConfuserEx 
2. Open Clarifier.sln and build the solution



================================================
File: Clarifier.sln
================================================
ï»¿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Clarifier.CLI", "Clarifier.CLI\Clarifier.CLI.csproj", "{E5F6BFF9-949D-459E-B650-335E81BB096F}"
	ProjectSection(ProjectDependencies) = postProject
		{4D692406-CBC1-4C99-B274-65B96DEA2539} = {4D692406-CBC1-4C99-B274-65B96DEA2539}
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7} = {914878AC-4A12-4BB3-A4A0-68B1F74132A7}
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Clarifier.Core", "Clarifier.Core\Clarifier.Core.csproj", "{49C5E059-FA32-440F-B4C7-E69E32296AC0}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Test", "Test", "{C5B2D5AB-1AC0-42B4-812F-57E97A8A0866}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Clarifier.Test.SimpleConsoleApplication", "Clarifier.Test\SimpleConsoleApplication\Clarifier.Test.SimpleConsoleApplication.csproj", "{9DE45910-AB12-45DC-A8C9-0A51F412913E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Clarifier.Test.ConfuserProjectsGenerator", "Clarifier.Test\TestGenerator\Clarifier.Test.ConfuserProjectsGenerator.csproj", "{5742BACA-691D-4D49-8B92-C3C62C40B430}"
	ProjectSection(ProjectDependencies) = postProject
		{49C5E059-FA32-440F-B4C7-E69E32296AC0} = {49C5E059-FA32-440F-B4C7-E69E32296AC0}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Protection", "Protection", "{F08BCB45-09E4-4D4B-9767-03212CDB2C2C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Clarifier.Protection.Impl", "Clarifier.Protections\Clarifier.Protections.Impl\Clarifier.Protection.Impl.csproj", "{4D692406-CBC1-4C99-B274-65B96DEA2539}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Clarifier.Protection.Interface", "Clarifier.Protections\Clarifier.Protections.Interface\Clarifier.Protection.Interface.csproj", "{914878AC-4A12-4BB3-A4A0-68B1F74132A7}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "dnlib", "ConfuserEx\dnlib\src\dnlib.csproj", "{FDFC1237-143F-4919-8318-4926901F4639}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Clarifier.Test.TestRunner", "Clarifier.Test\TestRunner\Clarifier.Test.TestRunner.csproj", "{6E387375-4086-49B9-809B-41E23266695B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SherlockEngine", "FuzzyEngine\SherlockEngine.csproj", "{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{EB895D34-9907-4D46-897F-C8AAB9EEF4D5}"
	ProjectSection(SolutionItems) = preProject
		README.md = README.md
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug_ThreadSafe|Any CPU = Debug_ThreadSafe|Any CPU
		Debug|Any CPU = Debug|Any CPU
		Release_ThreadSafe|Any CPU = Release_ThreadSafe|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E5F6BFF9-949D-459E-B650-335E81BB096F}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{E5F6BFF9-949D-459E-B650-335E81BB096F}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{E5F6BFF9-949D-459E-B650-335E81BB096F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E5F6BFF9-949D-459E-B650-335E81BB096F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E5F6BFF9-949D-459E-B650-335E81BB096F}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{E5F6BFF9-949D-459E-B650-335E81BB096F}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{E5F6BFF9-949D-459E-B650-335E81BB096F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E5F6BFF9-949D-459E-B650-335E81BB096F}.Release|Any CPU.Build.0 = Release|Any CPU
		{49C5E059-FA32-440F-B4C7-E69E32296AC0}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{49C5E059-FA32-440F-B4C7-E69E32296AC0}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{49C5E059-FA32-440F-B4C7-E69E32296AC0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{49C5E059-FA32-440F-B4C7-E69E32296AC0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{49C5E059-FA32-440F-B4C7-E69E32296AC0}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{49C5E059-FA32-440F-B4C7-E69E32296AC0}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{49C5E059-FA32-440F-B4C7-E69E32296AC0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{49C5E059-FA32-440F-B4C7-E69E32296AC0}.Release|Any CPU.Build.0 = Release|Any CPU
		{9DE45910-AB12-45DC-A8C9-0A51F412913E}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{9DE45910-AB12-45DC-A8C9-0A51F412913E}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{9DE45910-AB12-45DC-A8C9-0A51F412913E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9DE45910-AB12-45DC-A8C9-0A51F412913E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9DE45910-AB12-45DC-A8C9-0A51F412913E}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{9DE45910-AB12-45DC-A8C9-0A51F412913E}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{9DE45910-AB12-45DC-A8C9-0A51F412913E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9DE45910-AB12-45DC-A8C9-0A51F412913E}.Release|Any CPU.Build.0 = Release|Any CPU
		{5742BACA-691D-4D49-8B92-C3C62C40B430}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{5742BACA-691D-4D49-8B92-C3C62C40B430}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{5742BACA-691D-4D49-8B92-C3C62C40B430}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5742BACA-691D-4D49-8B92-C3C62C40B430}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5742BACA-691D-4D49-8B92-C3C62C40B430}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{5742BACA-691D-4D49-8B92-C3C62C40B430}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{5742BACA-691D-4D49-8B92-C3C62C40B430}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5742BACA-691D-4D49-8B92-C3C62C40B430}.Release|Any CPU.Build.0 = Release|Any CPU
		{4D692406-CBC1-4C99-B274-65B96DEA2539}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{4D692406-CBC1-4C99-B274-65B96DEA2539}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{4D692406-CBC1-4C99-B274-65B96DEA2539}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{4D692406-CBC1-4C99-B274-65B96DEA2539}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{4D692406-CBC1-4C99-B274-65B96DEA2539}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{4D692406-CBC1-4C99-B274-65B96DEA2539}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{4D692406-CBC1-4C99-B274-65B96DEA2539}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{4D692406-CBC1-4C99-B274-65B96DEA2539}.Release|Any CPU.Build.0 = Release|Any CPU
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7}.Release|Any CPU.Build.0 = Release|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug_ThreadSafe|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug_ThreadSafe|Any CPU.Build.0 = Debug_ThreadSafe|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release_ThreadSafe|Any CPU.ActiveCfg = Release_ThreadSafe|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release_ThreadSafe|Any CPU.Build.0 = Release_ThreadSafe|Any CPU
		{FDFC1237-143F-4919-8318-4926901F4639}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6E387375-4086-49B9-809B-41E23266695B}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{6E387375-4086-49B9-809B-41E23266695B}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{6E387375-4086-49B9-809B-41E23266695B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6E387375-4086-49B9-809B-41E23266695B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6E387375-4086-49B9-809B-41E23266695B}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{6E387375-4086-49B9-809B-41E23266695B}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{6E387375-4086-49B9-809B-41E23266695B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6E387375-4086-49B9-809B-41E23266695B}.Release|Any CPU.Build.0 = Release|Any CPU
		{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}.Debug_ThreadSafe|Any CPU.ActiveCfg = Debug|Any CPU
		{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}.Debug_ThreadSafe|Any CPU.Build.0 = Debug|Any CPU
		{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}.Release_ThreadSafe|Any CPU.ActiveCfg = Release|Any CPU
		{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}.Release_ThreadSafe|Any CPU.Build.0 = Release|Any CPU
		{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{9DE45910-AB12-45DC-A8C9-0A51F412913E} = {C5B2D5AB-1AC0-42B4-812F-57E97A8A0866}
		{5742BACA-691D-4D49-8B92-C3C62C40B430} = {C5B2D5AB-1AC0-42B4-812F-57E97A8A0866}
		{4D692406-CBC1-4C99-B274-65B96DEA2539} = {F08BCB45-09E4-4D4B-9767-03212CDB2C2C}
		{914878AC-4A12-4BB3-A4A0-68B1F74132A7} = {F08BCB45-09E4-4D4B-9767-03212CDB2C2C}
		{6E387375-4086-49B9-809B-41E23266695B} = {C5B2D5AB-1AC0-42B4-812F-57E97A8A0866}
	EndGlobalSection
EndGlobal



================================================
File: SettingsDescription.json
================================================
{
	"AntiDebug": {
		"Name": "anti debug",
		"AllowedSettings": {
			"mode": {
				"Values": [
					"safe",
					"win32",
					"antinet"
				],
				"Type": "Exclusive"
			}
		}
	},
	"AntiILDasm": {
		"Name": "anti ildasm",
		"AllowedSettings": null
	},	
	"AntiDump": {
		"Name": "anti dump",
		"AllowedSettings": null
	},
	"InvalidMetadata": {
		"Name": "invalid metadata",
		"AllowedSettings": null
	},
	"AntiTamper": {
		"Name": "anti tamper",
		"AllowedSettings": {
			"mode": {
				"Values": [
					"normal",
					"jit"
				],
				"Type": "Exclusive"
			},
			"key": {
				"value": [
					"normal",
					"dynamic"
				],
				"Type": "Exclusive"
			},
		}
	},
	"Constants": {
		"Name": "constants",
		"AllowedSettings": {
			"mode": {
				"Values": [
					"normal",
					"dynamic",
					"x86"
				  ],
				"Type": "Exclusive"
			},
			"decoderCount": {
				"Values":[],
				"Type": "Integer"
			},
			"elements": {
				"Values":[
					"S","N","P","I"
				],
				"Type": "Combine"
			},
			"cfg": {
				"Values": [],
				"Type": "Boolean"
			}
		}
	},
	"ControlFlow": {
		"Name": "ctrl flow",
		"AllowedSettings": {
			"Type": {
				"Values": [
					"switch",
					"jump"
				],
				"Type": "Exclusive"
			},
			"predicate": {
				"Values": [
					"normal",
					"expression",
					"x86"
				],
				"Type": "Exclusive"
			},
			"intensity": {
				"Values": [],
				"Type": "Integer"
			},
			"depth": {
				"Values": [],
				"Type": "Integer"
			},
			"junk": {
				"Values": [],
				"Type": "Boolean"
			}
		}
	},
    "ReferenceProxy": {
		"Name": "ref proxy",
		"AllowedSettings": {
			"mode": {
				"Values": [
					"mild",
					"strong",
					"ftn"
				],
				"Type": "Exclusive"
			},
			"encoding": {
				"Values": [
					"normal",
					"expression",
					"x86"
				],
				"Type": "Exclusive"
			},
			"internal": {
				"Values": [],
				"Type": "Boolean"
			},
			"typeErasure": {
				"Values": [],
				"Type": "Boolean"
			},
			"depth": {
				"Values": [],
				"Type": "Integer"
			},
			"initCount": {
				"Values": [],
				"Type": "Integer"
			}
		}
	},
    "Resources": {
		"Name": "resources",
		"AllowedSettings": {
			"mode": {
				"Values": [
					"normal",
					"dynamic"
				],
				"Type": "Exclusive"
			}
		}
	},
    "Rename": {
		"Name": "rename",
		"AllowedSettings": {
			"mode": {
				"Values": [
					"empty",
					"unicode",
					"ascii",
					"letters",
					"decodable",
					"sequential",
					"reversible",
					"debug"
				],
				"Type": "Exclusive"
			},
			"password": {
				"Values": [],
				"Type": "String"
			},
			"renameArgs": {
				"Values": [],
				"Type": "Boolean"
			},
			"flatten": {
				"Values": [],
				"Type": "Boolean"
			},
			"forceRen": {
				"Values": [],
				"Type": "Boolean"
			},
			"renPublic": {
				"Values": [],
				"Type": "Boolean"
			},
			"renPdb": {
				"Values": [],
				"Type": "Boolean"
			}
		}
	}
}


================================================
File: build.bat
================================================
@echo off
call "%VS140COMNTOOLS%\VsDevCmd.bat"
msbuild .\ConfuserEx\Confuser2.sln /t:Build /p:Configuration=Debug
msbuild .\ConfuserEx\Confuser2.sln /t:Build /p:Configuration=Release
pause


================================================
File: Clarifier.CLI/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: Clarifier.CLI/Clarifier.CLI.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{E5F6BFF9-949D-459E-B650-335E81BB096F}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Clarifier.CLI</RootNamespace>
    <AssemblyName>Clarifier.CLI</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>Clarifier.CLI.Program</StartupObject>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Confuser.Core">
      <HintPath>..\deps\Confuser.Core.dll</HintPath>
    </Reference>
    <Reference Include="Confuser.Runtime">
      <HintPath>..\deps\Confuser.Runtime.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\Clarifier.Core\Clarifier.Core.csproj">
      <Project>{49c5e059-fa32-440f-b4c7-e69e32296ac0}</Project>
      <Name>Clarifier.Core</Name>
    </ProjectReference>
    <ProjectReference Include="..\Clarifier.Protections\Clarifier.Protections.Impl\Clarifier.Protection.Impl.csproj">
      <Project>{4d692406-cbc1-4c99-b274-65b96dea2539}</Project>
      <Name>Clarifier.Protection.Impl</Name>
    </ProjectReference>
    <ProjectReference Include="..\Clarifier.Protections\Clarifier.Protections.Interface\Clarifier.Protection.Interface.csproj">
      <Project>{914878ac-4a12-4bb3-a4a0-68b1f74132a7}</Project>
      <Name>Clarifier.Protection.Interface</Name>
    </ProjectReference>
    <ProjectReference Include="..\ConfuserEx\dnlib\src\dnlib.csproj">
      <Project>{fdfc1237-143f-4919-8318-4926901f4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
    <ProjectReference Include="..\FuzzyEngine\SherlockEngine.csproj">
      <Project>{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}</Project>
      <Name>SherlockEngine</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Target Name="AfterBuild">
    <Exec WorkingDirectory="$(SolutionDir)\$(ConfigurationName)\bin\Test\" Command="TestGenerator.exe $(SolutionDir)\ConfuserEx\Release\bin" Timeout="60000" Condition=" '$(OS)' == 'Windows_NT' " />
  </Target>
</Project>


================================================
File: Clarifier.CLI/Program.cs
================================================
ï»¿using Clarifier.Core;
using Clarifier.Protection.Impl;
using dnlib.DotNet;
using System.Diagnostics;
using System.IO;
using SherlockEngine;

namespace Clarifier.CLI
{
    class Program
    {
        static void Main(string[] args)
        {
            Debug.Assert(args.Length > 0);
            ModuleDefMD targetModule = ModuleDefMD.Load(args[0]);
            ModuleDefMD runtimeModule = ModuleDefMD.Load("Confuser.Runtime.dll");

            ClarifierContext ctx = new ClarifierContext
            {
                CurrentModule = targetModule,
                WriterListener = new MWListener(),
                //ILLanguage = il
            };

            AntiDump antiDump = new AntiDump();
            AntiDebug antiDebug = new AntiDebug();
            Constants constants = new Constants();
            AntiTamper antiTamper = new AntiTamper();
            Inliner inliner = new Inliner();

            inliner.PerformIdentification(ctx);
            inliner.PerformRemoval(ctx);

            antiTamper.Initialize();
            antiTamper.PerformIdentification(ctx);
            antiTamper.PerformRemoval(ctx);

            antiDump.Initialize(ctx);
            antiDump.PerformIdentification(ctx);
            antiDump.PerformRemoval(ctx);
            
            antiDebug.Initialize(ctx);
            antiDebug.PerformIdentification(ctx);
            antiDebug.PerformRemoval(ctx);

            constants.Initialize(ctx);
            constants.PerformIdentification(ctx);
            constants.PerformRemoval(ctx);

            int lastBackslash = args[0].LastIndexOf('\\');
            string targetExecutable = args[0].Substring(lastBackslash+1, args[0].Length-1-lastBackslash);
            string parentDir = Directory.GetParent(Directory.GetParent(args[0]).FullName).FullName;
            parentDir = Path.Combine(parentDir, "Deobfuscated");

            string destinationFile = Path.Combine(parentDir, targetExecutable);

            targetModule.Write(destinationFile);
            return;
        }
    }
}



================================================
File: Clarifier.CLI/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Le informazioni generali relative a un assembly sono controllate dal seguente 
// set di attributi. Modificare i valori di questi attributi per modificare le informazioni
// associate a un assembly.
[assembly: AssemblyTitle("Clarifier.CLI")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Clarifier.CLI")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Se si imposta ComVisible su false, i tipi in questo assembly non saranno visibili 
// ai componenti COM. Se Ã¨ necessario accedere a un tipo in questo assembly da 
// COM, impostare su true l'attributo ComVisible per tale tipo.
[assembly: ComVisible(false)]

// Se il progetto viene esposto a COM, il GUID seguente verrÃ  utilizzato come ID della libreria dei tipi
[assembly: Guid("e5f6bff9-949d-459e-b650-335e81bb096f")]

// Le informazioni sulla versione di un assembly sono costituite dai seguenti quattro valori:
//
//      Versione principale
//      Versione secondaria 
//      Numero di build
//      Revisione
//
// Ãˆ possibile specificare tutti i valori oppure impostare valori predefiniti per i numeri relativi alla revisione e alla build 
// usando l'asterisco '*' come illustrato di seguito:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: Clarifier.Core/BaseStaticProtection.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using System.IO;
using System.Diagnostics;
using System.Diagnostics.Contracts;

namespace Clarifier.Core
{
    public class PatternMatchingInfo
    {
        public string module;
        public string @namespace;
        public string name;
        public List<MethodDef> matchingMethods;
    };

    /// <summary>
    /// This manage the simplest form of protection, the one that 
    /// is based on injecting some methods inside the target assembly.
    /// This class is capable of either finding these methods (even if they
    /// are slightly modified) and either removing all the references 
    /// inside the assembly.
    /// </summary>
    public class BasicStaticProtection
    {
        private const string defaultSourceModule = "Confuser.Runtime.dll";
        private double fuzzyThreshold = 0.70;
        private List<PatternMatchingInfo> sourceMap = new List<PatternMatchingInfo>();
        private List<PatternMatchingInfo> destinationMap = new List<PatternMatchingInfo>();
        private bool typesLoadedCorrectly = false;

        public double FuzzyThreshold
        {
            set
            {
                fuzzyThreshold = value;
            }
        }

        public List<PatternMatchingInfo> SourceMap
        {
            get
            {
                return sourceMap;
            }
        }

        public List<PatternMatchingInfo> DestinationMap
        {
            get
            {
                return destinationMap;
            }
        }

        public BasicStaticProtection()
        {
        }

        public void AddPatternMatchingMethod(string namespaceToAdd, string nameToAdd, string moduleToAdd = defaultSourceModule)
        {
            sourceMap.Add(new PatternMatchingInfo() { @namespace = namespaceToAdd, name = nameToAdd, module = moduleToAdd });
        }

        /// <summary>
        /// This load the types from the source assembly.
        /// </summary>
        /// <param name="ctx"></param>
        /// <returns>true if it manage to load all the types correctly; false otherwise</returns>
        public bool LoadTypes()
        {
            try
            {
                ModuleDef module = null;

                for (var i = 0; i < sourceMap.Count; ++i)
                {
                    if (module == null || (module != null && module.Name != sourceMap[i].module))
                    {
                        if (!File.Exists(sourceMap[i].module))
                            return (typesLoadedCorrectly = false);
                        module = AssemblyDef.Load(sourceMap[i].module).ManifestModule;
                    }

                    MethodDef foundMethod = module.Find(sourceMap[i].@namespace, true).FindMethod(sourceMap[i].name);

                    sourceMap[i].matchingMethods = new List<MethodDef>() { foundMethod };
                }
            }
            catch (Exception ex)
            {
                GC.KeepAlive(ex);
                return (typesLoadedCorrectly = false);
            }
            return (typesLoadedCorrectly = true);
        }

        /// <summary>
        /// Iterate over all the methods of a given assembly and try to remove 
        /// all the references to the found methods.
        /// </summary>
        /// <param name="ctx"></param>
        /// <returns></returns>
        public bool PerformRemoval(ModuleDef module)
        {
            bool returnValue = true;

            foreach (var identifiedMethods in destinationMap)
            {
                foreach (var currentIdentifiedMethod in identifiedMethods.matchingMethods)
                {
                    foreach (var currentMethod in module.GetMethods())
                    {
                        if (!identifiedMethods.matchingMethods.Contains(currentMethod))
                            returnValue |= BodyModifier.RemoveRefence(currentMethod, currentIdentifiedMethod);
                    }
                    BodyModifier.NullifyMethod(currentIdentifiedMethod);
                }
            }
            return returnValue;
        }

        /// <summary>
        /// This takes the types loaded in LoadTypes and try to map them 
        /// in the target module using a fuzzy search.
        /// </summary>
        /// <param name="currentModule"></param>
        /// <returns></returns>
        public double MapSourceInDestination(ModuleDef currentModule)
        {
            Contract.Ensures(typesLoadedCorrectly);

            double step = 1.0 / sourceMap.Count;
            double returnValue = 0.0;

            foreach (var v in sourceMap)
            {
                Debug.Assert(v.matchingMethods.Count == 1);
                var currentSimilarMethods = BodyComparison.GetSimilarMethods(currentModule, v.matchingMethods[0], true, fuzzyThreshold);
                if (currentSimilarMethods.Any())
                {
                    returnValue += step;

                    PatternMatchingInfo pmToAdd = new PatternMatchingInfo()
                    {
                        @namespace = v.@namespace,
                        name = v.name,
                        module = v.module,
                        matchingMethods = currentSimilarMethods.ToList()
                    };
                    destinationMap.Add(pmToAdd);
                }
            }
            return returnValue;
        }
    }
}



================================================
File: Clarifier.Core/BodyComparison.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Diagnostics.Contracts;

namespace Clarifier.Core
{
    static public class BodyComparison
    {
        public enum ComparisonMode
        {
            PreferFirst,
            PreferSecond,
            Mean
        }

        /// <summary>
        /// Simple comparison of two methods with fuzzy logic,
        /// used as fall back when a match is not found with boolean logic.
        /// This function should be capable of handling some (basic) situations in which:
        /// 1) The second method contains the same instruction of the first except from some
        ///     missing or modified instruction.
        /// 2) The second method contains repeated blocks taken from the first method.
        /// 3) The second method contains blocks taken from the first in shuffled order.
        /// <see cref="BooleanMethodsComparison"/>
        /// </summary>
        /// <param name="md1">First method to compare</param>
        /// <param name="md2">Second method to compare</param>
        /// <param name="threshold">Threshold above which methods are considered equals</param>
        /// <param name="mode">Tell how to do the comparison</param>
        /// <returns>True if the methods are matching, false otherwise</returns>
        static public bool FuzzyMethodsComparison(MethodDef md1, MethodDef md2, double threshold, ComparisonMode mode)
        {
            Contract.Ensures(md1.HasBody);

            if (!md2.HasBody)
                return false;

            bool[] matchedFirstMethod = new bool[md1.Body.Instructions.Count];
            bool[] matchedSecondMethod = new bool[md2.Body.Instructions.Count];

            Dictionary<OpCode, List<int>> mapSecondMethod = new Dictionary<OpCode, List<int>>();

            double thresholdToCommit = md1.Body.Instructions.Count * 0.15;

            // Step #1:
            // Reorganize all the instruction of the second method in order to create a dictionary opcode <==> positions
            // (where the instructions are found)
            for (var currentFirstIndex = 0; currentFirstIndex < md2.Body.Instructions.Count; ++currentFirstIndex)
            {
                if (!mapSecondMethod.ContainsKey(md2.Body.Instructions[currentFirstIndex].OpCode))
                    mapSecondMethod[md2.Body.Instructions[currentFirstIndex].OpCode] = new List<int>();

                mapSecondMethod[md2.Body.Instructions[currentFirstIndex].OpCode].Add(currentFirstIndex);
            }

            // Step #2:
            // For each instruction X of the first method, start a comparison between the instructions that follows X
            // in the first method and the instructions that follow an instruction with the same opcode of X (if any)
            // in the second method.
            //
            // In order to do this, the previous created dictionary is used.
            // The maximum range of instruction that match is taken.
            for (var currentFirstIndex = 0; currentFirstIndex < md1.Body.Instructions.Count; ++currentFirstIndex)
            {
                Instruction currentInstruction = md1.Body.Instructions[currentFirstIndex];
                List<Tuple<int, int>> rangeFirst = null;
                List<Tuple<int, int>> rangeSecond = null;
                int maxMatching = 0;

                if (!mapSecondMethod.ContainsKey(currentInstruction.OpCode))
                    continue;

                if (matchedFirstMethod[currentFirstIndex])
                    continue;

                foreach (var currentSecondIndex in mapSecondMethod[currentInstruction.OpCode])
                {
                    var firstMethodIndex = currentFirstIndex + 1;
                    var secondMethodIndex = currentSecondIndex + 1;
                    var currentMatching = 0;

                    while (firstMethodIndex < md1.Body.Instructions.Count &&
                           secondMethodIndex < md2.Body.Instructions.Count &&
                           md1.Body.Instructions[firstMethodIndex++].OpCode ==
                           md2.Body.Instructions[secondMethodIndex++].OpCode)
                    {
                        currentMatching++;
                    }

                    if (currentMatching > maxMatching)
                    {
                        rangeFirst = new List<Tuple<int, int>> { Tuple.Create(currentFirstIndex, firstMethodIndex) };
                        rangeSecond = new List<Tuple<int, int>> { Tuple.Create(currentSecondIndex, secondMethodIndex) };
                        maxMatching = currentMatching;
                    }
                    else if (maxMatching != 0 && currentMatching == maxMatching)
                    {
                        rangeFirst.Add(Tuple.Create(currentFirstIndex, firstMethodIndex));
                        rangeSecond.Add(Tuple.Create(currentSecondIndex, secondMethodIndex));
                    }
                }

                // Step #2.1
                // When a range is chosen, if the length of this range is > of thresholdToCommit, the range is used to populate
                // a list of boolean (matchedFirstMethod and matchedSecondMethod).
                if (maxMatching > thresholdToCommit)
                {
                    foreach (var currentRange in rangeFirst)
                        foreach (var v in Enumerable.Range(currentRange.Item1, currentRange.Item2 - currentRange.Item1))
                            matchedFirstMethod[v] = true;
                    foreach (var currentRange in rangeSecond)
                        foreach (var v in Enumerable.Range(currentRange.Item1, currentRange.Item2 - currentRange.Item1))
                            matchedSecondMethod[v] = true;
                }
            }

            // Step #3: A value between 0,1 that indicate how much the two methods are matching
            // Depending on the mode parameter, the return value can indicate:
            // 1) What percentage of the first method overlap to the second (ComparisonMode.PreferFirst)
            // 2) What percentage of the second method overlap to the first (ComparisonMode.PreferSecond)
            // 3) The mean of the previous two values
            double computedThresholdFirst = 0.0;
            double computedThresholdSecond = 0.0;
            if (mode == ComparisonMode.PreferFirst || mode == ComparisonMode.Mean)
                computedThresholdFirst= (double)matchedFirstMethod.Where(x => x).Count() / md1.Body.Instructions.Count;
            if (mode == ComparisonMode.PreferSecond || mode == ComparisonMode.Mean)
                computedThresholdSecond = (double)matchedSecondMethod.Where(x => x).Count() / md2.Body.Instructions.Count;

            if (mode == ComparisonMode.PreferFirst)
                return computedThresholdFirst > threshold;
            else if (mode == ComparisonMode.PreferSecond)
                return computedThresholdSecond > threshold;
            else // (mode == ComparisonMode.Mean)
                return (computedThresholdFirst + computedThresholdSecond)/2 > threshold;
        }

        /// <summary>
        /// Compare the instruction of two methods, operands are ignored.
        /// </summary>
        /// <param name="md1">First method</param>
        /// <param name="md2">Second method</param>
        /// <returns>True if the two methods have the same instruction.</returns>
        static public bool BooleanMethodsComparison(MethodDef md1, MethodDef md2)
        {
            if (md1.Body == null || md2.Body == null || md1.Body.Instructions.Count != md2.Body.Instructions.Count)
                return false;

            foreach (int i in Enumerable.Range(0, md1.Body.Instructions.Count))
            {
                if (md1.Body.Instructions[i].OpCode != md2.Body.Instructions[i].OpCode)
                    return false;

                if (md1.Body.Instructions[i].Operand.GetType() != md2.Body.Instructions[i].Operand.GetType())
                    return false;
            }

            return true;
        }

        /// <summary>
        /// Find a method inside a module.
        /// </summary>
        /// <param name="module">Module</param>
        /// <param name="methodToMatch">Method</param>
        /// <param name="fuzzy">Matching mode</param>
        /// <param name="threshold">Threshold of the fuzzy comparison (ignored if not fuzzy)</param>
        /// <returns>Returns all the method that matches.</returns>
        static public IEnumerable<MethodDef> GetSimilarMethods(ModuleDef module, MethodDef methodToMatch, bool fuzzy = false, double threshold = 0.0, ComparisonMode mode = ComparisonMode.PreferFirst)
        {
            foreach (var v in AllTypesHelper.Types(module.Types))
            {
                foreach (var vv in FindMethod(v, methodToMatch, fuzzy, threshold))
                    yield return vv;
            }
        }

        /// <summary>
        /// Find a method inside a type. Ignore nested type.
        /// </summary>
        /// <param name="type">The type</param>
        /// <param name="methodToMatch">The method</param>
        /// <param name="fuzzy">Matching mode</param>
        /// <param name="threshold">Threshold of the fuzzy comparison (ignored if not fuzzy)</param>
        /// <returns>Returns all the method that matches.</returns>
        static public IEnumerable<MethodDef> FindMethod(TypeDef type, MethodDef methodToMatch, bool fuzzy = false, double threshold = 0.0, ComparisonMode mode = ComparisonMode.PreferFirst)
        {
            foreach (var v in type.Methods)
            {
                if (fuzzy)
                    if (FuzzyMethodsComparison(methodToMatch, v, threshold, mode))
                        yield return v;
                else
                    if (BooleanMethodsComparison(v, methodToMatch))
                        yield return v;
            }
        }
    }
}



================================================
File: Clarifier.Core/BodyModifier.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;
using System.IO;
using Confuser.Core.Helpers;
using System.Linq;
using System;
using System.Reflection;

namespace Clarifier.Core
{
    static public class BodyModifier
    {
        static public void FindAndReplaceWithResult(List<MethodDef> toFind, ModuleDefMD whereToFind, 
                                                    Dictionary<string, MethodInfo> usableType, object instance)
        {
            List<MethodDef> methodsToCopy = new List<MethodDef>();
            toFind.ForEach(x => methodsToCopy.AddRange(BodyComparison.GetSimilarMethods(whereToFind, x, true, 0.70).ToList()));
            
            foreach (var v in toFind)
            {
                foreach (var toReplace in BodyComparison.GetSimilarMethods(whereToFind, v, true, 0.70))
                {
                    foreach (var currentType in AllTypesHelper.Types(whereToFind.Types))
                    {
                        foreach (var currentMethod in currentType.Methods)
                        {
                            if (!currentMethod.HasBody)
                                continue;

                            for (var i = 0; i < currentMethod.Body.Instructions.Count; ++i)
                            {
                                if (currentMethod.Body.Instructions[i].Operand == null)
                                    continue;

                                if (currentMethod.Body.Instructions[i].Operand is MethodDef && currentMethod.Body.Instructions[i].Operand == toReplace)
                                {
                                    if (toReplace.Body.Instructions[i].OpCode == OpCodes.Call)
                                    { 
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        static public bool RemoveRefence(MethodDef methodToInspect, MethodDef methodToLookFor)
        {
            bool cantPurge = false;

            if (methodToInspect.Body == null)
                return true;

            for (var i = 0; i < methodToInspect.Body.Instructions.Count; ++i)
            {
                if (methodToInspect.Body.Instructions[i].Operand is MethodDef && methodToInspect.Body.Instructions[i].Operand == methodToLookFor)
                {
                    if (methodToInspect.Body.Instructions[i].OpCode == OpCodes.Call)
                    {
                        int j = i;
                        for (; j >= i - methodToLookFor.Parameters.Count; j--)
                        {
                            methodToInspect.Body.Instructions.RemoveAt(j);
                        }
                        i = j;
                        continue;
                    }
                    else
                    {
                        cantPurge = true;
                    }
                }
            }

            return cantPurge;
        }

        static public void NullifyMethod(MethodDef method)
        {
            if (method.ReturnType.FullName == "System.Void")
            {
                method.Body.Instructions.Clear();
                method.Body.Instructions.Add(new Instruction(OpCodes.Ret));
            }
            else if (method.ReturnType.IsValueType)
            {

            }
            else if (method.ReturnType.IsByRef)
            {

            }
        }
    }
}



================================================
File: Clarifier.Core/Clarifier.Core.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{49C5E059-FA32-440F-B4C7-E69E32296AC0}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Clarifier.Core</RootNamespace>
    <AssemblyName>Clarifier.Core</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Confuser.Core">
      <HintPath>..\deps\Confuser.Core.dll</HintPath>
    </Reference>
    <Reference Include="Confuser.Runtime">
      <HintPath>..\deps\Confuser.Runtime.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="BaseStaticProtection.cs" />
    <Compile Include="BodyComparison.cs" />
    <Compile Include="ClarifierContext.cs" />
    <Compile Include="ClarifierInjectHelper.cs" />
    <Compile Include="DnlibExtensionMethods.cs" />
    <Compile Include="BodyModifier.cs" />
    <Compile Include="MacroContainer.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="MacroBodyComparison.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\ConfuserEx\dnlib\src\dnlib.csproj">
      <Project>{fdfc1237-143f-4919-8318-4926901f4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
    <ProjectReference Include="..\FuzzyEngine\SherlockEngine.csproj">
      <Project>{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}</Project>
      <Name>SherlockEngine</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PreBuildEvent>
    </PreBuildEvent>
  </PropertyGroup>
  <Target Name="BeforeBuild">
    <Copy SourceFiles="$(SolutionDir)ConfuserEx\$(ConfigurationName)\bin\Confuser.Core.dll;$(SolutionDir)ConfuserEx\$(ConfigurationName)\bin\Confuser.Runtime.dll;$(SolutionDir)ConfuserEx\$(ConfigurationName)\bin\dnlib.dll" DestinationFolder="$(SolutionDir)deps\" OverwriteReadOnlyFiles="true" SkipUnchangedFiles="true" />
  </Target>
</Project>


================================================
File: Clarifier.Core/ClarifierContext.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Writer;
using SherlockEngine;
using System;

namespace Clarifier.Core
{
    public class MWListener : IModuleWriterListener
    {
        public void OnWriterEvent(ModuleWriterBase writer, ModuleWriterEvent evt)
        {
            OnWriter?.Invoke(writer, evt);
        }

        public event EventHandler<ModuleWriterEvent> OnWriter;
    }

    public class ClarifierContext
    {
        public ModuleDefMD CurrentModule { get; set; }
        public SherlockNode ILLanguage { get; set; }

        public MWListener WriterListener;
    }
}


================================================
File: Clarifier.Core/ClarifierInjectHelper.cs
================================================
ï»¿using Confuser.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.DotNet.Writer;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace Clarifier.Core
{
    /// <summary>
    ///     Provides methods to inject a <see cref="TypeDef" /> into another module.
    ///     This is an improved version of the InjectHelper present in ConfuserEx.
    /// </summary>
    public class ClarifierInjectHelper
    {
        Dictionary<long, TypeDef> sizeToArrayType = new Dictionary<long, TypeDef>();
        TypeDef ourType;
        TypeDefOrRefSig valueType;
        int unique = 0;
        Dictionary<MethodDef, dnlib.DotNet.Writer.MethodBody> code = new Dictionary<MethodDef, dnlib.DotNet.Writer.MethodBody>();
        ClarifierContext ctx;
        private bool eventAdded = false;
        #region "Array inject helper"
        public void InjectArray(Array arrayToInject, MethodDef method, ITypeDefOrRef arrayType, int elementSize, int instructionIndex)
        {
            var runtimeHelpersRef = method.Module.UpdateRowId(new TypeRefUser(method.Module, "System.Runtime.CompilerServices", "RuntimeHelpers", method.Module.CorLibTypes.AssemblyRef));
            var runtimeHelpersSig = new ClassSig(runtimeHelpersRef);
            var arrayRef = method.Module.UpdateRowId(new TypeRefUser(method.Module, "System", "Array", method.Module.CorLibTypes.AssemblyRef));
            var arrayRefSig = new ClassSig(arrayRef);
            var runtimeFieldHandleRef = method.Module.UpdateRowId(new TypeRefUser(method.Module, "System", "RuntimeFieldHandle", method.Module.CorLibTypes.AssemblyRef));
            var RuntimeFieldHandleSig = new ValueTypeSig(runtimeFieldHandleRef);
            var initArraySig = MethodSig.CreateStatic(method.Module.CorLibTypes.Void, arrayRefSig, RuntimeFieldHandleSig);
            MemberRefUser initArrayRef = method.Module.UpdateRowId(new MemberRefUser(method.Module, "InitializeArray", initArraySig, runtimeHelpersSig.TypeDefOrRef));

            // The following will insert these instructions:
            // Ldc_I4 arraySize
            // Newarr arrayType
            // Dup
            // Ldtoken initArrayToken

            method.Body.Instructions[instructionIndex] = new Instruction(OpCodes.Call, initArrayRef);
            method.Body.Instructions.Insert(instructionIndex, new Instruction(OpCodes.Ldtoken, Create(arrayToInject, method.Module, elementSize)));
            method.Body.Instructions.Insert(instructionIndex, new Instruction(OpCodes.Dup));
            method.Body.Instructions.Insert(instructionIndex, new Instruction(OpCodes.Newarr, arrayType));
            method.Body.Instructions.Insert(instructionIndex, new Instruction(OpCodes.Ldc_I4, arrayToInject.Length));
        }
        void CreateOurType(ModuleDef ctx)
        {
            if (ourType != null)
                return;

            ourType = new TypeDefUser("", string.Format("<PrivateImplementationDetails>{0}", GetModuleId(ctx)), ctx.CorLibTypes.Object.TypeDefOrRef);
            ourType.Attributes = dnlib.DotNet.TypeAttributes.NotPublic | dnlib.DotNet.TypeAttributes.AutoLayout |
                            dnlib.DotNet.TypeAttributes.Class | dnlib.DotNet.TypeAttributes.AnsiClass;
            ctx.UpdateRowId(ourType);
            ctx.Types.Add(ourType);
        }

        object GetModuleId(ModuleDef ctx)
        {
            var memoryStream = new MemoryStream();
            var writer = new BinaryWriter(memoryStream);
            if (ctx.Assembly != null)
                writer.Write(ctx.Assembly.FullName);
            writer.Write((ctx.Mvid ?? Guid.Empty).ToByteArray());
            var hash = new System.Security.Cryptography.SHA1Managed().ComputeHash(memoryStream.GetBuffer());
            var guid = new Guid(BitConverter.ToInt32(hash, 0),
                                BitConverter.ToInt16(hash, 4),
                                BitConverter.ToInt16(hash, 6),
                                hash[8], hash[9], hash[10], hash[11],
                                hash[12], hash[13], hash[14], hash[15]);
            return guid.ToString("B");
        }

        TypeDef GetArrayType(long size, ModuleDef ctx)
        {
            CreateOurType(ctx);

            TypeDef arrayType;
            if (sizeToArrayType.TryGetValue(size, out arrayType))
                return arrayType;

            if (valueType == null)
            {
                var typeRef = ctx.UpdateRowId(new TypeRefUser(ctx, "System", "ValueType", ctx.CorLibTypes.AssemblyRef));
                valueType = new ClassSig(typeRef);
            }

            arrayType = new TypeDefUser("", string.Format("__StaticArrayInitTypeSize={0}", size), valueType.TypeDefOrRef);
            ctx.UpdateRowId(arrayType);
            arrayType.Attributes = dnlib.DotNet.TypeAttributes.NestedPrivate |
                                    dnlib.DotNet.TypeAttributes.ExplicitLayout |
                                    dnlib.DotNet.TypeAttributes.Class |
                                    dnlib.DotNet.TypeAttributes.Sealed |
                                    dnlib.DotNet.TypeAttributes.AnsiClass;

            ourType.NestedTypes.Add(arrayType);
            sizeToArrayType[size] = arrayType;
            arrayType.ClassLayout = new ClassLayoutUser(1, (uint)size);
            return arrayType;
        }

        FieldDef Create(Array data, ModuleDef ctx, int elementSize)
        {
            int arrayLenght = data.Length;

            var arrayType = GetArrayType(arrayLenght * elementSize, ctx);
            var fieldSig = new FieldSig(new ValueTypeSig(arrayType));
            var attrs = dnlib.DotNet.FieldAttributes.Assembly |
                        dnlib.DotNet.FieldAttributes.Static;

            var field = new FieldDefUser(string.Format("field_{0}", unique++), fieldSig, attrs);
            ctx.UpdateRowId(field);
            field.HasFieldRVA = true;
            ourType.Fields.Add(field);
            var iv = new byte[arrayLenght * elementSize];
            Buffer.BlockCopy(data, 0, iv, 0, arrayLenght * elementSize);
            field.InitialValue = iv;
            return field;
        }
        #endregion

        public ClarifierInjectHelper (ClarifierContext ctx)
        {
            this.ctx = ctx;
        }

        #region Cloning services
        /// <summary>
        ///     Clones the specified origin TypeDef.
        /// </summary>
        /// <param name="origin">The origin TypeDef.</param>
        /// <returns>The cloned TypeDef.</returns>
        static TypeDefUser Clone(TypeDef origin)
        {
            var ret = new TypeDefUser(origin.Namespace, origin.Name);
            ret.Attributes = origin.Attributes;

            if (origin.ClassLayout != null)
                ret.ClassLayout = new ClassLayoutUser(origin.ClassLayout.PackingSize, origin.ClassSize);

            foreach (GenericParam genericParam in origin.GenericParameters)
                ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

            return ret;
        }

        /// <summary>
        ///     Clones the specified origin MethodDef.
        /// </summary>
        /// <param name="origin">The origin MethodDef.</param>
        /// <returns>The cloned MethodDef.</returns>
        static MethodDefUser Clone(MethodDef origin)
        {
            string name;
            if (origin.IsSpecialName)
                name = origin.Name;
            else
                name = origin.Name;// string.Format("Method{0}", ixxx++);

            var ret = new MethodDefUser(name, null, origin.ImplAttributes, origin.Attributes);

            foreach (GenericParam genericParam in origin.GenericParameters)
                ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

            ret.Access = MethodAttributes.Public;
            return ret;
        }

        /// <summary>
        ///     Clones the specified origin FieldDef.
        /// </summary>
        /// <param name="origin">The origin FieldDef.</param>
        /// <returns>The cloned FieldDef.</returns>
        static FieldDefUser Clone(FieldDef origin)
        {
            var ret = new FieldDefUser(origin.Name, null, origin.Attributes);
            ret.HasFieldRVA = origin.HasFieldRVA;
            return ret;
        }

        public unsafe object CloneAndInstantiateType(TypeDef typeToInstantiate)
        {
            byte[] newAssembly = GetBrandNewAssemblyFromType(typeToInstantiate);

            if (Debugger.IsAttached)
            {
                if (File.Exists("DumpNewAssembly"))
                    File.WriteAllBytes("TestAssembly.dll", newAssembly);
            }

            System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(newAssembly);
            Type dummyType = assembly.ManifestModule.GetType("DummyNamespace.DummyType");
            object dummyInstance = Activator.CreateInstance(dummyType);
            return dummyInstance;
        }

        public byte[] GetBrandNewAssemblyFromType(TypeDef typeToInject)
        {
            // First of all, a temporary assembly is created and methods are injected into this assembly.
            // Once this assembly is ready, this try to execute the method in order to replace all the references in
            // the original assembly with its result.
            // This is probably the weakest part of the deobfuscator but I doubt there's an easier way to do this.

            AssemblyDef dummyAssembly = new AssemblyDefUser("DummyAssembly", new System.Version(1, 0, 0, 0), null);
            ModuleDefUser dummyModule = new ModuleDefUser("DummyModule") { Kind = ModuleKind.Dll };
            TypeDef dummyType = new TypeDefUser("DummyNamespace", "DummyType", dummyModule.CorLibTypes.Object.TypeDefOrRef);
            dummyType.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout |
                                    TypeAttributes.Class | TypeAttributes.AnsiClass;

            dummyModule.Types.Add(dummyType);
            dummyAssembly.Modules.Add(dummyModule);

            // Copy everything in dummyType
            Inject(typeToInject, dummyType, dummyModule, null);

            // Provide a default constructor
            if (dummyType.FindDefaultConstructor() == null)
            {
                var ctor = new MethodDefUser(".ctor",
                    MethodSig.CreateInstance(dummyModule.CorLibTypes.Void),
                    MethodImplAttributes.Managed,
                    MethodAttributes.HideBySig | MethodAttributes.Public |
                    MethodAttributes.SpecialName | MethodAttributes.RTSpecialName);
                ctor.Body = new CilBody();
                ctor.Body.MaxStack = 0;
                ctor.Body.Instructions.Add(OpCodes.Ret.ToInstruction());
                dummyType.Methods.Add(ctor);
            }

            // Save the assembly to a memorystream
            using (MemoryStream stream = new MemoryStream())
            {
                dummyModule.Write(stream);
                return stream.ToArray();
            }
        }

        void InjectNativeCode(object sender, ModuleWriterEvent e)
        {
            var writer = (ModuleWriterBase)sender;
            if (e == ModuleWriterEvent.MDBeginWriteMethodBodies)
            {
                for (var v = 0; v<code.Keys.Count; v++)
                { 
                    code[code.Keys.ElementAt(v)] = writer.MethodBodies.Add(code[code.Keys.ElementAt(v)]);
                }
            }
            else if (e  == ModuleWriterEvent.EndCalculateRvasAndFileOffsets)
            {
                for (var v = 0; v < code.Keys.Count; v++)
                {
                    uint rid = writer.MetaData.GetRid(code.Keys.ElementAt(v));
                    writer.MetaData.TablesHeap.MethodTable[rid].RVA = (uint)code[code.Keys.ElementAt(v)].RVA;
                }
            }
        }

        /// <summary>
        ///     Populates the context mappings.
        /// </summary>
        /// <param name="typeDef">The origin TypeDef.</param>
        /// <param name="ctx">The injection context.</param>
        /// <returns>The new TypeDef.</returns>
        static TypeDef PopulateContext(TypeDef typeDef, InjectContext ctx)
        {
            TypeDef ret;
            IDnlibDef existing;
            if (!ctx.Map.TryGetValue(typeDef, out existing))
            {
                ret = Clone(typeDef);
                ctx.Map[typeDef] = ret;
            }
            else
                ret = (TypeDef)existing;

            foreach (TypeDef nestedType in typeDef.NestedTypes)
                ret.NestedTypes.Add(PopulateContext(nestedType, ctx));

            foreach (MethodDef method in typeDef.Methods)
            {
                if (ctx.Filter != null && !ctx.Filter.Contains(method))
                    continue;

                ret.Methods.Add((MethodDef)(ctx.Map[method] = Clone(method)));
            }

            foreach (FieldDef field in typeDef.Fields)
                ret.Fields.Add((FieldDef)(ctx.Map[field] = Clone(field)));

            return ret;
        }

        /// <summary>
        ///     Copies the information from the origin type to injected type.
        /// </summary>
        /// <param name="typeDef">The origin TypeDef.</param>
        /// <param name="ctx">The injection context.</param>
        static void CopyTypeDef(TypeDef typeDef, InjectContext ctx)
        {
            var newTypeDef = (TypeDef)ctx.Map[typeDef];

            newTypeDef.BaseType = (ITypeDefOrRef)ctx.Importer.Import(typeDef.BaseType);

            foreach (InterfaceImpl iface in typeDef.Interfaces)
                newTypeDef.Interfaces.Add(new InterfaceImplUser((ITypeDefOrRef)ctx.Importer.Import(iface.Interface)));
        }

        /// <summary>
        ///     Copies the information from the origin method to injected method.
        /// </summary>
        /// <param name="methodDef">The origin MethodDef.</param>
        /// <param name="ctx">The injection context.</param>
        void CopyMethodDef(MethodDef methodDef, InjectContext ctx)
        {
            if (ctx.Filter != null && !ctx.Filter.Contains(methodDef))
                return;

            var newMethodDef = (MethodDef)ctx.Map[methodDef];

            newMethodDef.Signature = ctx.Importer.Import(methodDef.Signature);
            newMethodDef.Parameters.UpdateParameterTypes();

            if (methodDef.ImplMap != null)
                newMethodDef.ImplMap = new ImplMapUser(new ModuleRefUser(ctx.TargetModule, methodDef.ImplMap.Module.Name), methodDef.ImplMap.Name, methodDef.ImplMap.Attributes);

            foreach (CustomAttribute ca in methodDef.CustomAttributes)
                newMethodDef.CustomAttributes.Add(new CustomAttribute((ICustomAttributeType)ctx.Importer.Import(ca.Constructor)));

            if (methodDef.CodeType == MethodImplAttributes.Native)
            {
                dnlib.PE.RVA methodRVA = methodDef.NativeBody.RVA;
                List<byte> methodBody = new List<byte>();
                
                ModuleDefMD moduleMD = (ModuleDefMD)methodDef.Module;
                var stream = moduleMD.MetaData.PEImage.CreateStream(moduleMD.MetaData.PEImage.ToFileOffset(methodRVA));
                byte byteToAdd;
                do
                {
                    byteToAdd = stream.ReadByte();
                    methodBody.Add(byteToAdd);
                } while (byteToAdd != 0xc3);

                code[newMethodDef] = new dnlib.DotNet.Writer.MethodBody(methodBody.ToArray());
                
                if (!eventAdded)
                {
                    this.ctx.WriterListener.OnWriter += InjectNativeCode;
                    eventAdded = true;
                }
                return;
            }

            if (methodDef.HasBody)
            {
                newMethodDef.Body = new CilBody(methodDef.Body.InitLocals, new List<Instruction>(), new List<ExceptionHandler>(), new List<Local>());
                newMethodDef.Body.MaxStack = methodDef.Body.MaxStack;

                var bodyMap = new Dictionary<object, object>();

                foreach (Local local in methodDef.Body.Variables)
                {
                    var newLocal = new Local(ctx.Importer.Import(local.Type));
                    newMethodDef.Body.Variables.Add(newLocal);
                    newLocal.Name = local.Name;
                    newLocal.PdbAttributes = local.PdbAttributes;

                    bodyMap[local] = newLocal;
                }

                foreach (Instruction instr in methodDef.Body.Instructions)
                {
                    var newInstr = new Instruction(instr.OpCode, instr.Operand);
                    newInstr.SequencePoint = instr.SequencePoint;

                    if (newInstr.Operand is IType)
                        newInstr.Operand = ctx.Importer.Import((IType)newInstr.Operand);

                    else if (newInstr.Operand is IMethod)
                        newInstr.Operand = ctx.Importer.Import((IMethod)newInstr.Operand);

                    else if (newInstr.Operand is IField)
                        newInstr.Operand = ctx.Importer.Import((IField)newInstr.Operand);

                    newMethodDef.Body.Instructions.Add(newInstr);
                    bodyMap[instr] = newInstr;
                }

                foreach (Instruction instr in newMethodDef.Body.Instructions)
                {
                    if (instr.Operand != null && bodyMap.ContainsKey(instr.Operand))
                        instr.Operand = bodyMap[instr.Operand];

                    else if (instr.Operand is Instruction[])
                        instr.Operand = ((Instruction[])instr.Operand).Select(target => (Instruction)bodyMap[target]).ToArray();
                }

                foreach (ExceptionHandler eh in methodDef.Body.ExceptionHandlers)
                    newMethodDef.Body.ExceptionHandlers.Add(new ExceptionHandler(eh.HandlerType)
                    {
                        CatchType = eh.CatchType == null ? null : (ITypeDefOrRef)ctx.Importer.Import(eh.CatchType),
                        TryStart = (Instruction)bodyMap[eh.TryStart],
                        TryEnd = (Instruction)bodyMap[eh.TryEnd],
                        HandlerStart = (Instruction)bodyMap[eh.HandlerStart],
                        HandlerEnd = (Instruction)bodyMap[eh.HandlerEnd],
                        FilterStart = eh.FilterStart == null ? null : (Instruction)bodyMap[eh.FilterStart]
                    });

                newMethodDef.Body.SimplifyMacros(newMethodDef.Parameters);
            }
        }

        /// <summary>
        ///     Copies the information from the origin field to injected field.
        /// </summary>
        /// <param name="fieldDef">The origin FieldDef.</param>
        /// <param name="ctx">The injection context.</param>
        void CopyFieldDef(FieldDef fieldDef, InjectContext ctx)
        {
            var newFieldDef = (FieldDef)ctx.Map[fieldDef];

            newFieldDef.Signature = ctx.Importer.Import(fieldDef.Signature);
            if (newFieldDef.HasFieldRVA)
                newFieldDef.InitialValue = fieldDef.InitialValue;
        }

        /// <summary>
        ///     Copies the information to the injected definitions.
        /// </summary>
        /// <param name="typeDef">The origin TypeDef.</param>
        /// <param name="ctx">The injection context.</param>
        /// <param name="copySelf">if set to <c>true</c>, copy information of <paramref name="typeDef" />.</param>
        void Copy(TypeDef typeDef, InjectContext ctx, bool copySelf)
        {
            if (copySelf)
                CopyTypeDef(typeDef, ctx);

            foreach (TypeDef nestedType in typeDef.NestedTypes)
                Copy(nestedType, ctx, true);

            foreach (MethodDef method in typeDef.Methods)
                CopyMethodDef(method, ctx);

            foreach (FieldDef field in typeDef.Fields)
                CopyFieldDef(field, ctx);
        }

        /// <summary>
        ///     Injects the specified TypeDef to another module.
        /// </summary>
        /// <param name="typeDef">The source TypeDef.</param>
        /// <param name="target">The target module.</param>
        /// <returns>The injected TypeDef.</returns>
        public TypeDef Inject(TypeDef typeDef, ModuleDef target)
        {
            var ctx = new InjectContext(typeDef.Module, target);
            PopulateContext(typeDef, ctx);
            Copy(typeDef, ctx, true);
            return (TypeDef)ctx.Map[typeDef];
        }

        /// <summary>
        ///     Injects the specified MethodDef to another module.
        /// </summary>
        /// <param name="methodDef">The source MethodDef.</param>
        /// <param name="target">The target module.</param>
        /// <returns>The injected MethodDef.</returns>
        public MethodDef Inject(MethodDef methodDef, ModuleDef target)
        {
            var ctx = new InjectContext(methodDef.Module, target);
            ctx.Map[methodDef] = Clone(methodDef);
            CopyMethodDef(methodDef, ctx);
            return (MethodDef)ctx.Map[methodDef];
        }

        /// <summary>
        ///     Injects the members of specified TypeDef to another module.
        /// </summary>
        /// <param name="typeDef">The source TypeDef.</param>
        /// <param name="newType">The new type.</param>
        /// <param name="target">The target module.</param>
        /// <returns>Injected members.</returns>
        public IEnumerable<IDnlibDef> Inject(TypeDef typeDef, TypeDef newType, ModuleDef target, List<MethodDef> filter)
        {
            var ctx = new InjectContext(typeDef.Module, target) { Filter = filter };
            ctx.Map[typeDef] = newType;
            PopulateContext(typeDef, ctx);
            Copy(typeDef, ctx, false);
            return ctx.Map.Values.Except(new[] { newType });
        }

        /// <summary>
        ///     Context of the injection process.
        /// </summary>
        class InjectContext : ImportResolver
        {
            /// <summary>
            ///     The mapping of origin definitions to injected definitions.
            /// </summary>
            public readonly Dictionary<IDnlibDef, IDnlibDef> Map = new Dictionary<IDnlibDef, IDnlibDef>();

            /// <summary>
            ///     The module which source type originated from.
            /// </summary>
            public readonly ModuleDef OriginModule;

            /// <summary>
            ///     The module which source type is being injected to.
            /// </summary>
            public readonly ModuleDef TargetModule;

            /// <summary>
            ///     The importer.
            /// </summary>
            readonly Importer importer;

            /// <summary>
            ///     Initializes a new instance of the <see cref="InjectContext" /> class.
            /// </summary>
            /// <param name="module">The origin module.</param>
            /// <param name="target">The target module.</param>
            public InjectContext(ModuleDef module, ModuleDef target)
            {
                OriginModule = module;
                TargetModule = target;
                importer = new Importer(target, ImporterOptions.TryToUseTypeDefs);
                importer.Resolver = this;
                Filter = null;
            }

            public List<MethodDef> Filter { get; internal set; }

            /// <summary>
            ///     Gets the importer.
            /// </summary>
            /// <value>The importer.</value>
            public Importer Importer
            {
                get { return importer; }
            }

            /// <inheritdoc />
            public override TypeDef Resolve(TypeDef typeDef)
            {
                if (Map.ContainsKey(typeDef))
                    return (TypeDef)Map[typeDef];
                return null;
            }

            /// <inheritdoc />
            public override MethodDef Resolve(MethodDef methodDef)
            {
                if (Map.ContainsKey(methodDef))
                    return (MethodDef)Map[methodDef];
                return null;
            }

            /// <inheritdoc />
            public override FieldDef Resolve(FieldDef fieldDef)
            {
                if (Map.ContainsKey(fieldDef))
                    return (FieldDef)Map[fieldDef];
                return null;
            }
        }
        #endregion
    }
}


================================================
File: Clarifier.Core/DnlibExtensionMethods.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Clarifier.Core
{
    public static class DnlibExtensionMethods
    {
        public static IList<Instruction> GetInstructions(this MethodDef method)
        {
            if (!method.HasBody)
                return new List<Instruction>();
            if (!method.IsIL)
                return new List<Instruction>();

            return method.Body.Instructions;
        }

        public static IEnumerable<MethodDef> GetMethods(this ModuleDef module)
        {
            foreach(var type in AllTypesHelper.Types(module.Types))
            {
                foreach (var method in type.Methods)
                    yield return method;
            }
        }
    }
}



================================================
File: Clarifier.Core/MacroBodyComparison.cs
================================================
ï»¿using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Clarifier.Core
{
    public class InstructionGroup
    {
        List<OpCode> recognizedInstructions = null;
        int? howMany = null;
        bool isOptional = false;
        List<int> foundInstructions = new List<int>();

        public override string ToString()
        {
            return Name;
        }

        public string Name { get; set; }
        public int? HowMany
        {
            get { return howMany; }
            set { howMany = value; }
        }
        public List<OpCode> RecognizedInstructions
        {
            get { return recognizedInstructions; }
            set { recognizedInstructions = value; }
        }
        public bool IsOptional
        {
            get { return isOptional; }
            set { isOptional = value; }
        }
        public List<int> FoundInstructions
        {
            get { return foundInstructions; }
            set { foundInstructions = value; }
        }
    }

    public class MacroBodyComparison
    {
        List<InstructionGroup> instructionGroups = new List<InstructionGroup>();

        public List<InstructionGroup> InstructionGroups
        {
            get { return instructionGroups; }
            set { instructionGroups = value; }
        }

        public bool PerformComparison(MethodDef method, bool preserveOrder = true, bool allowOtherInstruction = false)
        {











            int groupIndex = 0;
            for (var i = 0; i < method.GetInstructions().Count; ++i)
            {
                var instruction = method.Body.Instructions[i];
                if (InstructionGroups.Count <= groupIndex && !allowOtherInstruction)
                    return false;
                else if (InstructionGroups.Count <= groupIndex)
                    break;

                bool hasLimit = InstructionGroups[groupIndex].HowMany.HasValue;
                int limit = InstructionGroups[groupIndex].HowMany.GetValueOrDefault();

                //At this moment this algorithm doesn't manage:
                // unrecognized -> optional -> non optional
                //But only:
                // optional -> unrecognized -> non optional
                //(Not planning to add this use case, though)
                bool isRecognized = InstructionGroups[groupIndex].RecognizedInstructions.Contains(instruction.OpCode);

                while (!isRecognized && ((InstructionGroups[groupIndex].IsOptional) ||
                                         (hasLimit && InstructionGroups[groupIndex].FoundInstructions.Count == limit) || 
                                         (!hasLimit && InstructionGroups[groupIndex].FoundInstructions.Count>0)))
                {
                    //If you're here:
                    // Either you're skipping a not found, optional instruction,
                    // or you're skipping a group of instruction you've already matched in a 
                    // previous iteration.
                    groupIndex++;
                    isRecognized = InstructionGroups[groupIndex].RecognizedInstructions.Contains(instruction.OpCode);
                }

                //If you're here:
                // Not optional, found
                // Not optional, not found
                // Optional, found
                if (isRecognized)
                    InstructionGroups[groupIndex].FoundInstructions.Add(i);
                else if (allowOtherInstruction)
                    continue;
                else if (!InstructionGroups[groupIndex].IsOptional)
                    return false;
            }

            foreach (var group in instructionGroups)
            {
                if (!group.HowMany.HasValue)
                {
                    if (!group.IsOptional && group.FoundInstructions.Count == 0)
                        return false;
                }
                else
                {
                    if (!group.IsOptional && group.FoundInstructions.Count!=group.HowMany.Value)
                        return false;
                }
            }

            return true;
        }
    }
}



================================================
File: Clarifier.Core/MacroContainer.cs
================================================
ï»¿using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Clarifier.Core
{
    class GroupContainer
    {
        private InstructionGroup loadArgumentsInstructions;
        private InstructionGroup callInstructions;
        private InstructionGroup returnInstructions;

        public InstructionGroup CallInstructions
        {
            get
            {
                if (callInstructions == null)
                {
                    callInstructions = new InstructionGroup()
                    {
                        RecognizedInstructions = new List<OpCode>
                        {
                            OpCodes.Call,
                            OpCodes.Calli,
                            OpCodes.Callvirt,
                        },
                        HowMany = 1,
                        Name = "Call"
                    };
                }
                return callInstructions;
            }
        }

        public InstructionGroup ReturnInstructions
        {
            get
            {
                if (returnInstructions == null)
                {
                    returnInstructions = new InstructionGroup()
                    {
                        RecognizedInstructions = new List<OpCode>
                        {
                            OpCodes.Ret
                        },
                        HowMany = 1,
                        Name = "Return"
                    };
                }
                return returnInstructions;
            }
        }

        public InstructionGroup LoadArgumentsInstructions
        {
            get
            {
                if (loadArgumentsInstructions == null)
                {
                    loadArgumentsInstructions = new InstructionGroup()
                    {
                        RecognizedInstructions = new List<OpCode>
                        {
                            OpCodes.Ldarg,
                            OpCodes.Ldarga,
                            OpCodes.Ldarga_S,
                            OpCodes.Ldarg_0,
                            OpCodes.Ldarg_1,
                            OpCodes.Ldarg_2,
                            OpCodes.Ldarg_3,
                            OpCodes.Ldarg_S,
                        },
                        Name = "LoadArguments"
                    };
                }
                return loadArgumentsInstructions;
            }
        }
    }

    public class MacroContainer
    {
        GroupContainer groupContainer = new GroupContainer();
        private List<InstructionGroup> callMacro;

        public List<InstructionGroup> CallMacro
        {
            get
            {
                if (callMacro == null)
                {
                    callMacro = new List<InstructionGroup>
                    {
                        groupContainer.LoadArgumentsInstructions,
                        groupContainer.CallInstructions,
                        groupContainer.ReturnInstructions
                    };
                }
                return callMacro;
            }
        }
    }
}



================================================
File: Clarifier.Core/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Le informazioni generali relative a un assembly sono controllate dal seguente 
// set di attributi. Modificare i valori di questi attributi per modificare le informazioni
// associate a un assembly.
[assembly: AssemblyTitle("Clarifier.Core")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Clarifier.Core")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Se si imposta ComVisible su false, i tipi in questo assembly non saranno visibili 
// ai componenti COM. Se Ã¨ necessario accedere a un tipo in questo assembly da 
// COM, impostare su true l'attributo ComVisible per tale tipo.
[assembly: ComVisible(false)]

// Se il progetto viene esposto a COM, il GUID seguente verrÃ  utilizzato come ID della libreria dei tipi
[assembly: Guid("49c5e059-fa32-440f-b4c7-e69e32296ac0")]

// Le informazioni sulla versione di un assembly sono costituite dai seguenti quattro valori:
//
//      Versione principale
//      Versione secondaria 
//      Numero di build
//      Revisione
//
// Ãˆ possibile specificare tutti i valori oppure impostare valori predefiniti per i numeri relativi alla revisione e alla build 
// usando l'asterisco '*' come illustrato di seguito:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/AntiDebug.cs
================================================
ï»¿using Clarifier.Core;
using System.Linq;

namespace Clarifier.Protection.Impl
{
    /// <summary>
    /// Anti-debug is a very simple protection.
    /// It is based on injecting a function inside the target assembly.
    /// This function is then called inside the constructor of the GlobalType.
    /// Removal of this protection is entirely based on pattern-matching.
    /// </summary>
    public class AntiDebug
    {
        BasicStaticProtection antiDebugSafe = new BasicStaticProtection();
        BasicStaticProtection antiDebugNet = new BasicStaticProtection();
        BasicStaticProtection antiDebugWin32 = new BasicStaticProtection();

        public AntiDebug()
        {
        }

        public bool Initialize(ClarifierContext ctx)
        {
            antiDebugSafe.AddPatternMatchingMethod("Confuser.Runtime.AntiDebugSafe", "Initialize");
            antiDebugSafe.AddPatternMatchingMethod("Confuser.Runtime.AntiDebugSafe", "Worker");

            antiDebugNet.AddPatternMatchingMethod("Confuser.Runtime.AntiDebugAntinet", "Initialize");

            antiDebugWin32.AddPatternMatchingMethod("Confuser.Runtime.AntiDebugWin32", "Initialize");
            antiDebugWin32.AddPatternMatchingMethod("Confuser.Runtime.AntiDebugWin32", "Worker");

            return antiDebugSafe.LoadTypes() && antiDebugNet.LoadTypes() && antiDebugWin32.LoadTypes();
        }

        public double PerformIdentification(ClarifierContext ctx)
        {
            double[] result = new double[3];
            result[0] = antiDebugSafe.MapSourceInDestination(ctx.CurrentModule);
            result[1] = antiDebugNet.MapSourceInDestination(ctx.CurrentModule);
            result[2] = antiDebugWin32.MapSourceInDestination(ctx.CurrentModule);
            return result.Max();
        }

        public bool PerformRemoval(ClarifierContext ctx)
        {
            return antiDebugSafe.PerformRemoval(ctx.CurrentModule) || 
                   antiDebugNet.PerformRemoval(ctx.CurrentModule)  || 
                   antiDebugWin32.PerformRemoval(ctx.CurrentModule);
        }
    }
}



================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/AntiDump.cs
================================================
ï»¿using Clarifier.Core;

namespace Clarifier.Protection.Impl
{
    /// <summary>
    /// Anti-dump is a very simple protection.
    /// It is based on injecting a function inside the target assembly.
    /// This function is then called inside the constructor of the GlobalType.
    /// Removal of this protection is entirely based on pattern-matching.
    /// </summary>
    public class AntiDump
    {
        private BasicStaticProtection staticProtectionsManager = new BasicStaticProtection();
        public AntiDump()
        {
        }

        /// <summary>
        /// Add and load the blacklisted method
        /// </summary>
        /// <param name="ctx">Context</param>
        /// <returns></returns>
        public bool Initialize(ClarifierContext ctx)
        {
            staticProtectionsManager.AddPatternMatchingMethod("Confuser.Runtime.AntiDump", "Initialize");
            return staticProtectionsManager.LoadTypes();
        }
        /// <summary>
        /// Search in the module for similar methods.
        /// </summary>
        /// <param name="ctx"></param>
        /// <returns></returns>
        public double PerformIdentification(ClarifierContext ctx)
        {
            return staticProtectionsManager.MapSourceInDestination(ctx.CurrentModule);            
        }

        /// <summary>
        /// Remove every reference and nullify the blacklisted method
        /// </summary>
        /// <param name="ctx"></param>
        /// <returns></returns>
        public bool PerformRemoval(ClarifierContext ctx)
        {
            return staticProtectionsManager.PerformRemoval(ctx.CurrentModule);
        }
    }
}



================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/AntiTamper.cs
================================================
ï»¿using Clarifier.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Clarifier.Protection.Impl
{
    public class AntiTamper
    {
        BasicStaticProtection staticProtectionsManager = new BasicStaticProtection();

        public void PerformRemoval(ClarifierContext ctx)
        {
            foreach(var v in staticProtectionsManager.DestinationMap)
            {
                foreach (var vv in v.matchingMethods)
                {
                    var typeRef = ctx.CurrentModule.UpdateRowId(new TypeRefUser(ctx.CurrentModule, "System.Diagnostics", "Debugger", ctx.CurrentModule.CorLibTypes.AssemblyRef));
                    var classSignature = new ClassSig(typeRef);

                    var methodSig = MethodSig.CreateStatic(ctx.CurrentModule.CorLibTypes.Void);
                    MemberRefUser mff = ctx.CurrentModule.UpdateRowId(new MemberRefUser(ctx.CurrentModule, "Break", methodSig, classSignature.TypeDefOrRef));

                    vv.Body.Instructions.Insert(vv.Body.Instructions.Count-1,Instruction.Create(OpCodes.Call, mff));
                }
            }
        }
        public double PerformIdentification(ClarifierContext ctx)
        {
            return staticProtectionsManager.MapSourceInDestination(ctx.CurrentModule);
        }

        public  void Initialize()
        {
            staticProtectionsManager.AddPatternMatchingMethod("Confuser.Runtime.AntiTamperNormal", "Initialize");
            staticProtectionsManager.LoadTypes();
        }
    }
}



================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/Clarifier.Protection.Impl.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{4D692406-CBC1-4C99-B274-65B96DEA2539}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Clarifier.Identification.Impl</RootNamespace>
    <AssemblyName>Clarifier.Identification.Impl</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Confuser.Core">
      <HintPath>..\..\deps\Confuser.Core.dll</HintPath>
    </Reference>
    <Reference Include="Confuser.Runtime">
      <HintPath>..\..\deps\Confuser.Runtime.dll</HintPath>
    </Reference>
    <Reference Include="dnlib">
      <HintPath>..\..\deps\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AntiDebug.cs" />
    <Compile Include="AntiDump.cs" />
    <Compile Include="AntiTamper.cs" />
    <Compile Include="Constants.cs" />
    <Compile Include="ControlFlow.cs" />
    <Compile Include="Inliner.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\Clarifier.Core\Clarifier.Core.csproj">
      <Project>{49c5e059-fa32-440f-b4c7-e69e32296ac0}</Project>
      <Name>Clarifier.Core</Name>
    </ProjectReference>
    <ProjectReference Include="..\..\FuzzyEngine\SherlockEngine.csproj">
      <Project>{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}</Project>
      <Name>SherlockEngine</Name>
    </ProjectReference>
    <ProjectReference Include="..\Clarifier.Protections.Interface\Clarifier.Protection.Interface.csproj">
      <Project>{914878ac-4a12-4bb3-a4a0-68b1f74132a7}</Project>
      <Name>Clarifier.Protection.Interface</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/Class1.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clarifier.Identification.Impl
{
    public class Class1
    {
    }
}



================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/Constants.cs
================================================
ï»¿using Clarifier.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;

namespace Clarifier.Protection.Impl
{
    class ArrayType
    {
        int elementSize;
        ITypeDefOrRef typeDefOrRef;
    }
    /// <summary>
    /// This class manage the constants obfuscation.
    /// </summary>
    public class Constants
    {
        BasicStaticProtection staticProtectionsManager = new BasicStaticProtection();
        ClarifierInjectHelper injectHelper = null;
        public Constants()
        {
        }

        public bool Initialize(ClarifierContext ctx)
        {
            injectHelper = new ClarifierInjectHelper(ctx);
            staticProtectionsManager.AddPatternMatchingMethod("Confuser.Runtime.Constant", "Get");
            staticProtectionsManager.AddPatternMatchingMethod("Confuser.Runtime.Constant", "Initialize");
            return staticProtectionsManager.LoadTypes();
        }

        public bool PerformRemoval(ClarifierContext ctx)
        {
            ClarifierInjectHelper inject = new ClarifierInjectHelper(ctx);
            object instantiatedObject = inject.CloneAndInstantiateType(ctx.CurrentModule.GlobalType);
            Type dummyType = instantiatedObject.GetType();

            Dictionary<string, MethodInfo> mapNewMethodsToName = new Dictionary<string, MethodInfo>();
            List<MethodDef> onlyMethodsToSubstitute = staticProtectionsManager.DestinationMap.Where(x => x.name == "Get").First().matchingMethods;

            foreach (var v in staticProtectionsManager.DestinationMap)
            {
                foreach (var vv in v.matchingMethods)
                {
                    mapNewMethodsToName[vv.Name] = dummyType.GetMethod(vv.Name);
                }
            }

            foreach (var currentMethod in ctx.CurrentModule.GetMethods())
            {
                if (onlyMethodsToSubstitute.Exists(x => x == currentMethod))
                    continue;

                if (!currentMethod.HasBody)
                    continue;

                // Look for calls to blacklisted methods
                for (var i = 0; i < currentMethod.Body.Instructions.Count; ++i)
                {
                    Instruction currentInstruction = currentMethod.Body.Instructions[i];

                    if (currentInstruction.OpCode != OpCodes.Call)
                        continue;

                    IMethod targetMethod = (IMethod)currentInstruction.Operand;
                    MethodInfo methodToInvoke;

                    if (!onlyMethodsToSubstitute.Exists(x => x.Name == targetMethod.Name))
                        continue;

                    if (mapNewMethodsToName.TryGetValue(targetMethod.Name, out methodToInvoke))
                    {
                        // Here we are sure we are in presence of a call to a blacklisted methods;
                        // Kill ye olde damn bastard!
                        int inputParameters = methodToInvoke.GetParameters().Count();
                        object[] parameters = new object[inputParameters];

                        // Close the generic type before invoking
                        if (methodToInvoke.IsGenericMethod)
                        {
                            MethodSpec genericMethod = (MethodSpec)targetMethod;
                            Type[] genericTypes = genericMethod.GenericInstMethodSig.GenericArguments.Select(x => Type.GetType(x.ReflectionFullName)).ToArray();
                            methodToInvoke = methodToInvoke.MakeGenericMethod(genericTypes);
                        }

                        // Iterate backward in order to retrieve input parameters and removing instructions.
                        int j = i;
                        for (; j > i - inputParameters; j--)
                        {
                            Type targetType = methodToInvoke.GetParameters()[parameters.Length - (i - j) - 1].ParameterType;
                            object operand = currentMethod.Body.Instructions[j - 1].Operand;

                            if (targetType.IsValueType)
                            {
                                try
                                {
                                    // Most common situation here is that the operand is an uint.
                                    // dnlib fail to assign the right type (int instead of uint)
                                    // so we force the cast...
                                    parameters[parameters.Length - (i - j) - 1] = (uint)(int)operand;
                                }
                                catch
                                {
                                    // ...If the cast fail we try a conversion with value semantic. If even
                                    // this cast fail, we lift the white flag. 
                                    parameters[parameters.Length - (i - j) - 1] = Convert.ChangeType(operand, targetType);
                                }
                            }
                            else
                            {
                                parameters[parameters.Length - (i - j) - 1] = operand;
                            }

                            currentMethod.Body.Instructions.RemoveAt(j - 1);
                        }
                        i = j;

                        object returnedObject = methodToInvoke.Invoke(null, parameters);
                        Type returnedType = returnedObject.GetType();

                        if (returnedType == typeof(string))
                        {
                            currentMethod.Body.Instructions[i] = new Instruction(OpCodes.Ldstr, returnedObject);
                        }
                        else if (returnedType.IsArray)
                        {
                            ITypeDefOrRef arrayType = null;
                            int elementSize = 0;
                            if (returnedType.Name == typeof(int[]).Name || returnedType.Name == typeof(float[]).Name)
                            {
                                elementSize = 4;
                                if (returnedType.Name == typeof(int[]).Name)
                                    arrayType = ctx.CurrentModule.CorLibTypes.Int32.TypeDefOrRef;
                                else
                                    arrayType = ctx.CurrentModule.CorLibTypes.Double.TypeDefOrRef;
                            }
                            else if (returnedType.Name == typeof(long[]).Name || returnedType.Name == typeof(double[]).Name)
                            {
                                elementSize = 8;

                                if (returnedType.Name == typeof(long[]).Name)
                                    arrayType = ctx.CurrentModule.CorLibTypes.Int64.TypeDefOrRef;
                                else
                                    arrayType = ctx.CurrentModule.CorLibTypes.Double.TypeDefOrRef;
                            }
                            else if (returnedType.Name == typeof(char[]).Name)
                            {
                                elementSize = 2;
                                arrayType = ctx.CurrentModule.CorLibTypes.Char.TypeDefOrRef;
                            }
                            else
                            {
                                Debugger.Break();
                            }

                            injectHelper.InjectArray((Array)returnedObject, currentMethod, arrayType, elementSize, i);
                        }
                        else
                        {
                            Debugger.Break();
                        }
                    }
                }
            }

            return true;
        }

        public double PerformIdentification(ClarifierContext ctx)
        {
            return staticProtectionsManager.MapSourceInDestination(ctx.CurrentModule);
        }
    }
}



================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/ControlFlow.cs
================================================
ï»¿using Clarifier.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clarifier.Identification.Impl
{
    class ControlFlow
    {
        public bool Initialize(ClarifierContext ctx)
        {
            return true;
        }

        public double PerformIdentification(ClarifierContext ctx)
        {
            return 0.0;
        }

        public bool PerformRemoval(ClarifierContext ctx)
        {
            return true;
        }

    }
}



================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/IClarifierContext.cs
================================================
ï»¿namespace Clarifier.Identification.Impl
{
    internal interface IClarifierContext
    {
    }
}


================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/IProtectionIdentificator.cs
================================================
ï»¿using dnlib.DotNet;

namespace Clarifier.Identification.Impl
{
    internal interface IProtectionIdentificator
    {
        bool Initialize(ClarifierContext ctx);
        double PerformIdentification(ClarifierContext ctx);
    }
}


================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/IProtectionRemover.cs
================================================
ï»¿namespace Clarifier.Identification.Impl
{
    internal interface IProtectionRemover
    {
        bool PerformRemoval(ClarifierContext ctx);
    }
}


================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/Inliner.cs
================================================
ï»¿using Clarifier.Core;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using SherlockEngine;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Clarifier.Protection.Impl
{
    /// <summary>
    /// This class manage the "reference proxy" protection.
    /// This protection is based on creating proxy function that should hide
    /// the real function.
    /// Approach here is based on replacing all the calls to these proxy methods
    /// with calls to the real method.
    /// </summary>
    public class Inliner
    {
        BasicStaticProtection staticProtectionsManager = new BasicStaticProtection();

        Dictionary<MethodDef, List<InstructionGroup>> referenceProxyMethods = new Dictionary<MethodDef, List<InstructionGroup>>();

        public void PerformRemoval(ClarifierContext ctx)
        {
            foreach (var method in ctx.CurrentModule.GetMethods())
            {
                if (referenceProxyMethods.Keys.Contains(method))
                    continue;
                foreach (var instruction in method.GetInstructions())
                {
                    if (instruction.OpCode != OpCodes.Call)
                        continue;

                    MethodDef targetMethod = null;
                    if (instruction.Operand is MethodDef)
                    {
                        targetMethod = instruction.Operand as MethodDef;
                    }
                    else if (instruction.Operand is MethodSpec)
                    {
                        MethodSpec tempMethod = instruction.Operand as MethodSpec;
                        targetMethod = tempMethod.Method as MethodDef;
                    }
                    else if (instruction.Operand is MemberRef)
                    {
                        continue;
                    }

                    Debug.Assert(targetMethod != null);

                    List<InstructionGroup> currentInstructionGroup;
                    if (referenceProxyMethods.TryGetValue(targetMethod, out currentInstructionGroup))
                    {
                        int callIndex = currentInstructionGroup.Where(x => x.Name == "Call").First().FoundInstructions[0];
                        instruction.Operand = targetMethod.Body.Instructions[callIndex].Operand;
                    }
                }
            }
        }
        public double PerformIdentification(ClarifierContext ctx)
        {
            SherlockNode loadStage = new SherlockNode(ctx.ILLanguage["ArgumentLoad"].Childs)
            {
                Name = "LoadStage",
                MaxNumber = null,
                MinNumber = 1,
                Mode = TestMode.InRange
            };
            SherlockNode callStage = new SherlockNode(ctx.ILLanguage["Call"].Childs)
            {
                Name = "CallStage",
                MaxNumber = 1,
                MinNumber = 1,
                Mode = TestMode.InRange
            };
            SherlockNode returnStage = new SherlockNode(ctx.ILLanguage["Return"].Childs)
            {
                Name = "ReturnStage",
                MaxNumber = 1,
                MinNumber = 1,
                Mode = TestMode.InRange
            };

            SherlockNode proxyCall = new SherlockNode(new SherlockNode[] { loadStage, callStage, returnStage })
            {
                Name = "ProxyCall",
                MinNumber = 1,
                MaxNumber = 1,
                Mode = TestMode.MatchEverything
            };

            foreach (var method in ctx.CurrentModule.GetMethods())
            { 
                if (!method.HasBody)
                {
                    continue;
                }

                ComparisonContext compCtx = new ComparisonContext()
                {
                    InstructionList = method.Body.Instructions.ToList()
                };

                if (proxyCall.Test(compCtx) == ConditionOutcome.Matched)
                {
                    referenceProxyMethods[method] = null;
                }
            }

            if (referenceProxyMethods.Count != 0)
                return 1.0;
            return 0.0;
        }

        public void Initialize()
        {
        }
    }
}



================================================
File: Clarifier.Protections/Clarifier.Protections.Impl/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Le informazioni generali relative a un assembly sono controllate dal seguente 
// set di attributi. Modificare i valori di questi attributi per modificare le informazioni
// associate a un assembly.
[assembly: AssemblyTitle("Clarifier.Identification.Impl")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Clarifier.Identification.Impl")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Se si imposta ComVisible su false, i tipi in questo assembly non saranno visibili 
// ai componenti COM. Se Ã¨ necessario accedere a un tipo in questo assembly da 
// COM, impostare su true l'attributo ComVisible per tale tipo.
[assembly: ComVisible(false)]

// Se il progetto viene esposto a COM, il GUID seguente verrÃ  utilizzato come ID della libreria dei tipi
[assembly: Guid("4d692406-cbc1-4c99-b274-65b96dea2539")]

// Le informazioni sulla versione di un assembly sono costituite dai seguenti quattro valori:
//
//      Versione principale
//      Versione secondaria 
//      Numero di build
//      Revisione
//
// Ãˆ possibile specificare tutti i valori oppure impostare valori predefiniti per i numeri relativi alla revisione e alla build 
// usando l'asterisco '*' come illustrato di seguito:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: Clarifier.Protections/Clarifier.Protections.Interface/Clarifier.Protection.Interface.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{914878AC-4A12-4BB3-A4A0-68B1F74132A7}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Clarifier.Identification.Interface</RootNamespace>
    <AssemblyName>Clarifier.Identification.Interface</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Debug\bin\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Release\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Confuser.Core">
      <HintPath>..\..\deps\Confuser.Core.dll</HintPath>
    </Reference>
    <Reference Include="Confuser.Runtime">
      <HintPath>..\..\deps\Confuser.Runtime.dll</HintPath>
    </Reference>
    <Reference Include="dnlib">
      <HintPath>..\..\deps\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="IProtectionIdentificator.cs" />
    <Compile Include="IProtectionRemover.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\Clarifier.Core\Clarifier.Core.csproj">
      <Project>{49c5e059-fa32-440f-b4c7-e69e32296ac0}</Project>
      <Name>Clarifier.Core</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Clarifier.Protections/Clarifier.Protections.Interface/IProtectionIdentificator.cs
================================================
ï»¿using Clarifier.Core;

namespace Clarifier.Identification.Interface
{
    public interface IProtectionIdentificator
    {
        bool Initialize(ClarifierContext ctx);
        double PerformIdentification(ClarifierContext ctx);
    }
}


================================================
File: Clarifier.Protections/Clarifier.Protections.Interface/IProtectionRemover.cs
================================================
ï»¿using Clarifier.Core;

namespace Clarifier.Identification.Interface
{
    public interface IProtectionRemover
    {
        bool PerformRemoval(ClarifierContext ctx);
    }
}


================================================
File: Clarifier.Protections/Clarifier.Protections.Interface/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Le informazioni generali relative a un assembly sono controllate dal seguente 
// set di attributi. Modificare i valori di questi attributi per modificare le informazioni
// associate a un assembly.
[assembly: AssemblyTitle("Clarifier.Identification.Interface")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Clarifier.Identification.Interface")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Se si imposta ComVisible su false, i tipi in questo assembly non saranno visibili 
// ai componenti COM. Se Ã¨ necessario accedere a un tipo in questo assembly da 
// COM, impostare su true l'attributo ComVisible per tale tipo.
[assembly: ComVisible(false)]

// Se il progetto viene esposto a COM, il GUID seguente verrÃ  utilizzato come ID della libreria dei tipi
[assembly: Guid("914878ac-4a12-4bb3-a4a0-68b1f74132a7")]

// Le informazioni sulla versione di un assembly sono costituite dai seguenti quattro valori:
//
//      Versione principale
//      Versione secondaria 
//      Numero di build
//      Revisione
//
// Ãˆ possibile specificare tutti i valori oppure impostare valori predefiniti per i numeri relativi alla revisione e alla build 
// usando l'asterisco '*' come illustrato di seguito:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: Clarifier.Test/SimpleConsoleApplication/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: Clarifier.Test/SimpleConsoleApplication/Clarifier.Test.SimpleConsoleApplication.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{9DE45910-AB12-45DC-A8C9-0A51F412913E}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Clarifier.Test.SimpleConsoleApplication</RootNamespace>
    <AssemblyName>SimpleConsoleApplication</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\..\Debug\bin\Test\Unobfuscated\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\..\Release\bin\Test\Unobfuscated\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PreBuildEvent>
    </PreBuildEvent>
  </PropertyGroup>
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Clarifier.Test/SimpleConsoleApplication/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clarifier.Test.SimpleConsoleApplication
{

    public struct DummyStruct
    {
        public int i;
        public float f;
        public string wtf;

    }
    class Program
    {
        static void Main(string[] args)
        {
            char[] charArrayTest = { 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a' };
            int[] testArray = { 0, 1, 1, 1, 2, 2, 3, 4 };

            Console.WriteLine("This is an obfuscated program! De obfuscate me!");
            testArray[0] = 10;
            testArray[1] = 11;
            Console.WriteLine(testArray[0]);

            GC.KeepAlive(charArrayTest);
            GC.KeepAlive(testArray);
        }
    }
}



================================================
File: Clarifier.Test/SimpleConsoleApplication/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SimpleConsoleApplication")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("SimpleConsoleApplication")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9de45910-ab12-45dc-a8c9-0a51f412913e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: Clarifier.Test/TestGenerator/App.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>


================================================
File: Clarifier.Test/TestGenerator/Clarifier.Test.ConfuserProjectsGenerator.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{5742BACA-691D-4D49-8B92-C3C62C40B430}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Clarifier.Test.TestGenerator</RootNamespace>
    <AssemblyName>TestGenerator</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\..\Debug\bin\Test\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\..\Release\bin\Test\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Confuser.Core">
      <HintPath>..\..\deps\Confuser.Core.dll</HintPath>
    </Reference>
    <Reference Include="Confuser.Runtime">
      <HintPath>..\..\deps\Confuser.Runtime.dll</HintPath>
    </Reference>
    <Reference Include="dnlib">
      <HintPath>..\..\deps\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json, Version=8.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>..\..\packages\Newtonsoft.Json.8.0.3\lib\net45\Newtonsoft.Json.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="ConfuserProtection.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="packages.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <PropertyGroup>
    <PreBuildEvent>
    </PreBuildEvent>
  </PropertyGroup>
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Clarifier.Test/TestGenerator/ConfuserProtection.cs
================================================
ï»¿using Newtonsoft.Json;
using System.Collections.Generic;

namespace Clarifier.Test.TestGenerator
{
    public enum ProtectionType
    {
        AntiDebug,
        AntiILDasm,
        AntiTamper,
        Constants,
        ControlFlow,
        AntiDump,
        InvalidMetadata,
        ReferenceProxy,
        Resources,
        Rename
    }

    public enum SettingType
    {
        Exclusive,
        Combine,
        String,
        Integer,
        Boolean
    }

    public class ProtectionSettings
    {
        private string[] values;
        private SettingType type;

        public string[] Values
        {
            get
            {
                return values;
            }

            set
            {
                values = value;
            }
        }

        public SettingType Type
        {
            get
            {
                return type;
            }

            set
            {
                type = value;
            }
        }
    }

    public class ProtectionDescription
    {
        private string name;
        private Dictionary<string, ProtectionSettings> allowedSettings;

        public string Name
        {
            get
            {
                return name;
            }

            set
            {
                name = value;
            }
        }

        public Dictionary<string, ProtectionSettings> AllowedSettings
        {
            get
            {
                return allowedSettings;
            }

            set
            {
                allowedSettings = value;
            }
        }
    }
    public class ConfuserProtection
    {
        private static Dictionary<ProtectionType, ProtectionDescription> mapProtectionType;

        public static Dictionary<ProtectionType, ProtectionDescription> MapProtectionType
        {
            get
            {
                return mapProtectionType;
            }
            set
            {
                mapProtectionType = value;
            }
        }
    };
}



================================================
File: Clarifier.Test/TestGenerator/Program.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using Confuser.Core.Project;
using System.Xml;
using Confuser.Core;
using System.IO;
using System.Diagnostics;
using Newtonsoft.Json;

namespace Clarifier.Test.TestGenerator
{
    internal class ModuleDescriptor
    {
        public string inputFileName;
        public Dictionary<ProtectionType, Dictionary<string, string>> protections;
        public string outputFileName;
        public ModuleDescriptor(string inputFileName)
        {
            this.inputFileName = inputFileName;
            outputFileName = "Obfuscated" + inputFileName;
            protections = new Dictionary<ProtectionType, Dictionary<string, string>>();
        }
    }

    class Program
    {
        static string outputPath = Path.Combine(Directory.GetCurrentDirectory(),"Obfuscated");
        static string inputPath = Path.Combine(Directory.GetCurrentDirectory(),"Unobfuscated");
        static string outputProject = Path.Combine(Directory.GetCurrentDirectory(),"OutputConfuserProject.crproj");
        static bool invokeObfuscator = true;
        static string confuserPath;

        static List<ModuleDescriptor> registeredApplications = new List<ModuleDescriptor>()
        {
            new ModuleDescriptor("SimpleConsoleApplication.exe")
            {
                protections = new Dictionary<ProtectionType, Dictionary<string, string>>
                {
                    {ProtectionType.Constants, new Dictionary<string,string>{ { "mode", "dynamic" } } },
                    //{ProtectionType.Rename, new Dictionary<string, string> { { "mode", "debug" } } }
                    //{ ProtectionType.AntiDebug,null },
                    //{ ProtectionType.AntiDump, null},
                    { ProtectionType.ReferenceProxy, new Dictionary<string,string>{ { "mode", "mild" } }},
                    //{ ProtectionType.ControlFlow, null}
                }
            }
        };

        static void Main(string[] args)
        {
            //This is reserved for the moment that a well structured test will be needed.
            ConfuserProtection.MapProtectionType = JsonConvert.DeserializeObject<Dictionary<ProtectionType, ProtectionDescription>>(File.ReadAllText("SettingsDescription.json"));
            
            if (args.Length > 0)
                confuserPath = Path.Combine(args[0],"Confuser.CLI.exe");
            if (args.Length > 1)
                inputPath = args[1];
            if (args.Length > 2)
                outputPath = args[2];
            if (args.Length > 3)
                outputProject = args[3];
            if (args.Length > 4)
                bool.TryParse(args[4], out invokeObfuscator);

            try { 
                Directory.CreateDirectory(inputPath);
                Directory.CreateDirectory(outputPath);
                Directory.GetParent(outputProject).Create();
            }
            catch (Exception ex)
            {
                Console.WriteLine("Unable to create directory: {0}", ex.ToString());
                return;
            }

            Debug.Assert(Directory.Exists(inputPath));
            Debug.Assert(Directory.Exists(outputPath));
            Debug.Assert(Directory.GetParent(outputProject).Exists);
            Debug.Assert(!invokeObfuscator  || File.Exists(confuserPath));

            ConfuserProject module = new ConfuserProject()
            {
                OutputDirectory = outputPath,
                BaseDirectory = inputPath
            };

            foreach (var v in registeredApplications)
            {
                Console.WriteLine("Processing {0}", v.inputFileName);
                ProjectModule project = new ProjectModule() { Path = v.inputFileName };
                Rule moduleRule = new Rule();

                foreach (var vv in v.protections)
                {
                    string protection = ConfuserProtection.MapProtectionType[vv.Key].Name;
                    SettingItem<Protection> currentProtection = new SettingItem<Protection>(protection);

                    if (vv.Value != null)
                    {
                        foreach (var vvv in vv.Value)
                            currentProtection.Add(vvv.Key, vvv.Value);
                    }
                    moduleRule.Add(currentProtection);
                    Console.WriteLine("\tAdded protection: {0}", protection);
                }

                project.Rules.Add(moduleRule);
                module.Add(project);
            }

            Console.WriteLine("Saving project: {0}", outputProject);
            XmlDocument document = module.Save();

            using (XmlWriter xmlWrite = XmlWriter.Create(outputProject))
                document.WriteContentTo(xmlWrite);

            if (invokeObfuscator)
            {
                Console.WriteLine("");
                Console.WriteLine("Invoke obfuscator required. Invoking.");
                Process.Start(confuserPath, outputProject).WaitForExit();
                Console.WriteLine("Done. Exiting.");
            }
        }
    }
}



================================================
File: Clarifier.Test/TestGenerator/packages.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Newtonsoft.Json" version="8.0.3" targetFramework="net452" />
</packages>


================================================
File: Clarifier.Test/TestGenerator/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TestGenerator")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TestGenerator")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5742baca-691d-4d49-8b92-c3c62c40b430")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
File: Clarifier.Test/TestRunner/Clarifier.Test.TestRunner.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{6E387375-4086-49B9-809B-41E23266695B}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>TestRunner</RootNamespace>
    <AssemblyName>TestRunner</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{3AC096D0-A1C2-E12C-1390-A8335801FDAB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <VisualStudioVersion Condition="'$(VisualStudioVersion)' == ''">10.0</VisualStudioVersion>
    <VSToolsPath Condition="'$(VSToolsPath)' == ''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
    <ReferencePath>$(ProgramFiles)\Common Files\microsoft shared\VSTT\$(VisualStudioVersion)\UITestExtensionPackages</ReferencePath>
    <IsCodedUITest>False</IsCodedUITest>
    <TestProjectType>UnitTest</TestProjectType>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\..\Debug\bin\Test\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\..\Release\bin\Test\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
  </ItemGroup>
  <Choose>
    <When Condition="('$(VisualStudioVersion)' == '10.0' or '$(VisualStudioVersion)' == '') and '$(TargetFrameworkVersion)' == 'v3.5'">
      <ItemGroup>
        <Reference Include="Microsoft.VisualStudio.QualityTools.UnitTestFramework, Version=10.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" />
      </ItemGroup>
    </When>
    <Otherwise>
      <ItemGroup>
        <Reference Include="Microsoft.VisualStudio.QualityTools.UnitTestFramework" />
      </ItemGroup>
    </Otherwise>
  </Choose>
  <ItemGroup>
    <Compile Include="OutputCompare.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <Choose>
    <When Condition="'$(VisualStudioVersion)' == '10.0' And '$(IsCodedUITest)' == 'True'">
      <ItemGroup>
        <Reference Include="Microsoft.VisualStudio.QualityTools.CodedUITestFramework, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
          <Private>False</Private>
        </Reference>
        <Reference Include="Microsoft.VisualStudio.TestTools.UITest.Common, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
          <Private>False</Private>
        </Reference>
        <Reference Include="Microsoft.VisualStudio.TestTools.UITest.Extension, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
          <Private>False</Private>
        </Reference>
        <Reference Include="Microsoft.VisualStudio.TestTools.UITesting, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
          <Private>False</Private>
        </Reference>
      </ItemGroup>
    </When>
  </Choose>
  <Import Project="$(VSToolsPath)\TeamTest\Microsoft.TestTools.targets" Condition="Exists('$(VSToolsPath)\TeamTest\Microsoft.TestTools.targets')" />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: Clarifier.Test/TestRunner/OutputCompare.cs
================================================
ï»¿using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.IO;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace TestRunner
{
    [TestClass]
    public class OutputCompare
    {
        const string unobfuscatedPath = "Unobfuscated";
        const string obfuscatedPath = "Obfuscated";
        const string deobfuscatedPath = "Deobfuscated";
        const string testcasePath = "TestCase";

        const string deobfuscatoPath = @"..\Clarifier.CLI.exe";

        class TestCase
        {
            public string standardOutputExpect = null;
            public string standardErrorExpect = null;
            public string standardInput = null;
            public Dictionary<string,byte[]> fileStream = null;
        }

        /// <summary>
        /// This test ensure that applications are created correctly 
        /// and they produce an expected output.
        /// </summary>
        [TestMethod]
        public void RunTests()
        {
            string testCaseFolder = Path.Combine(Directory.GetCurrentDirectory(), testcasePath);
            string obfuscatedFolder = Path.Combine(Directory.GetCurrentDirectory(), obfuscatedPath);
            string deobfuscatedFolder = Path.Combine(Directory.GetCurrentDirectory(), deobfuscatedPath);
            string unobfuscatedFolder = Path.Combine(Directory.GetCurrentDirectory(), unobfuscatedPath);

            Dictionary<string, TestCase> testCaseList = new Dictionary<string, TestCase>();
            List<string> ignored = new List<string>();

            foreach (var v in Directory.GetFiles(testCaseFolder))
            {
                int firstDot = 0, lastBackslash = 0;
                string appName;
                string streamType;
                TestCase currentTestCase;

                if ((firstDot = v.IndexOf('.')) == -1)
                    continue;

                lastBackslash = v.LastIndexOf('\\');
                appName = Path.Combine(deobfuscatedFolder, string.Format("{0}.exe",v.Substring(lastBackslash+1, firstDot-1-lastBackslash)));

                if (!testCaseList.TryGetValue(appName, out currentTestCase))
                    currentTestCase = testCaseList[appName] = new TestCase();

                streamType = v.Substring(firstDot+1, v.Length-1 - firstDot);

                if(streamType == "StdOut")
                    currentTestCase.standardOutputExpect = File.ReadAllText(v);
                else if (streamType == "StdIn")
                    currentTestCase.standardInput = File.ReadAllText(v);
                else if (streamType == "StdErr")
                    currentTestCase.standardErrorExpect = File.ReadAllText(v);
                else
                    currentTestCase.fileStream[streamType] = File.ReadAllBytes(v);
            }

            foreach(var currentDeobfuscatedFile in Directory.GetFiles(deobfuscatedFolder))
            {
                TestCase currentTestCase;
                string standardOutput, standardError;
                if (!testCaseList.TryGetValue(currentDeobfuscatedFile, out currentTestCase))
                    continue;

                ProcessStartInfo startInfo = new ProcessStartInfo(currentDeobfuscatedFile)
                {
                    RedirectStandardError = true,
                    RedirectStandardOutput = true,
                    UseShellExecute = false
                };
                Process testCaseProcess = new Process() { StartInfo = startInfo };
                testCaseProcess.Start();
                standardOutput = testCaseProcess.StandardOutput.ReadToEnd();
                standardError = testCaseProcess.StandardError.ReadToEnd();

                testCaseProcess.WaitForExit();

                if (currentTestCase.standardOutputExpect != null)
                    Assert.AreEqual(standardOutput, currentTestCase.standardOutputExpect);
                if (currentTestCase.standardErrorExpect != null)
                    Assert.AreEqual(standardError, currentTestCase.standardErrorExpect);

                if(currentTestCase.fileStream != null)
                {
                    foreach (var file in currentTestCase.fileStream)
                    {
                        Assert.IsTrue(File.Exists(file.Key));
                        Assert.IsTrue(file.Value.SequenceEqual(File.ReadAllBytes(file.Key)));
                    }
                }
            }
        }
    }
}



================================================
File: Clarifier.Test/TestRunner/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Le informazioni generali relative a un assembly sono controllate dal seguente 
// set di attributi. Modificare i valori di questi attributi per modificare le informazioni
// associate a un assembly.
[assembly: AssemblyTitle("TestRunner")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("TestRunner")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Se si imposta ComVisible su false, i tipi in questo assembly non saranno visibili 
// ai componenti COM. Se Ã¨ necessario accedere a un tipo in questo assembly da 
// COM, impostare su true l'attributo ComVisible per tale tipo.
[assembly: ComVisible(false)]

// Se il progetto viene esposto a COM, il GUID seguente verrÃ  utilizzato come ID della libreria dei tipi
[assembly: Guid("6e387375-4086-49b9-809b-41e23266695b")]

// Le informazioni sulla versione di un assembly sono costituite dai seguenti quattro valori:
//
//      Numero di versione principale
//      Numero di versione secondario 
//      Numero build
//      Revisione
//
// Ãˆ possibile specificare tutti i valori oppure impostare valori predefiniti per i numeri relativi alla revisione e alla build 
// usando l'asterisco '*' come illustrato di seguito:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]




================================================
File: FuzzyEngine/ComparisonContext.cs
================================================
ï»¿using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace SherlockEngine
{
    public class ComparisonContext
    {
        int currentIndex;
        IList<Instruction> instructionList;
        bool[] alreadyMatched;
        bool[] lastIterationMatch;

        public IList<Instruction> InstructionList
        {
            get
            {
                return instructionList;
            }

            set
            {
                instructionList = value;
                AlreadyMatched = new bool[instructionList.Count];
                CurrentIndex = 0;
            }
        }

        public bool[] AlreadyMatched
        {
            get
            {
                return alreadyMatched;
            }

            set
            {
                alreadyMatched = value;
            }
        }

        public int CurrentIndex
        {
            get
            {
                return currentIndex;
            }

            set
            {
                currentIndex = value;
            }
        }
    }
}


================================================
File: FuzzyEngine/ILMetaInfo.xml
================================================
ï»¿<?xml version="1.0" encoding="utf-8" ?>
<InstructionSet LanguageName="IL">
  
  <!-- Start arithmetical -->
  <Instruction Name="Add">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Add_Ovf">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Add_Ovf_Un">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Sub">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Sub_Ovf">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Sub_Ovf_Un">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Div">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Div_Un">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Mul">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Mul_Ovf">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Mul_Ovf_Un">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Rem">
    <Group Name="Arithmetical"/>
  </Instruction>
  <Instruction Name="Rem_Un">
    <Group Name="Arithmetical"/>
  </Instruction>
  <!-- End arithmetical -->
  
  <!-- Start logical -->
  <Instruction Name="And">
    <Group Name="Logical"/>
  </Instruction>
  <Instruction Name="Or">
    <Group Name="Logical"/>
  </Instruction>
  <Instruction Name="Not">
    <Group Name="Logical"/>
  </Instruction>
  <Instruction Name="Xor">
    <Group Name="Logical"/>
  </Instruction>
  <Instruction Name="Neg">
    <Group Name="Logical"/>
  </Instruction>
  <Instruction Name="Shl">
    <Group Name="Logical"/>
  </Instruction>
  <Instruction Name="Shr">
    <Group Name="Logical"/>
  </Instruction>
  <Instruction Name="Shr_Un">
    <Group Name="Logical"/>
  </Instruction>
  <!-- End logical -->
    
  <!-- Start branch -->
  <Instruction Name="Beq">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Beq_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bge">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bge_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bge_Un">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bge_Un_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bgt">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bgt_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bgt_Un">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bgt_Un_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Ble">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Ble_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Ble_Un">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Ble_Un_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Blt">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Blt_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Blt_Un">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Blt_Un_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bne_Un">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Bne_Un_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Brfalse">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Brfalse_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Brtrue">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Brtrue_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Br_S">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <Instruction Name="Br">
    <Group Name="ControlFlow"/>
    <Group Name="Branch"/>
  </Instruction>
  <!-- End branch -->

  <!-- Start other CF -->
  <Instruction Name="Break">
    <Group Name="ControlFlow"/>
  </Instruction>
  <Instruction Name="Jmp">
    <Group Name="ControlFlow"/>
  </Instruction>
  <Instruction Name="Switch">
    <Group Name="ControlFlow"/>
  </Instruction>
  <!-- End other CF -->

  <!-- Start function related -->
  <Instruction Name="Call">
    <Group Name="ControlFlow"/>
    <Group Name="Call"/>
    <Group Name="Function"/>
  </Instruction>
  <Instruction Name="Calli">
    <Group Name="ControlFlow"/>
    <Group Name="Call"/>
    <Group Name="Function"/>
  </Instruction>
  <Instruction Name="Callvirt">
    <Group Name="ControlFlow"/>
    <Group Name="Call"/>
    <Group Name="Function"/>
  </Instruction>
  <Instruction Name="Ret">
    <Group Name="ControlFlow"/>
    <Group Name="Function"/>
    <Group Name="Return"/>
  </Instruction>
  <!-- End function related -->

  <!-- Start Exception handling -->
  <Instruction Name="Throw">
    <Group Name="ControlFlow"/>
    <Group Name="ExceptionHandling"/>
  </Instruction>
  <Instruction Name="Rethrow">
    <Group Name="ControlFlow"/>
    <Group Name="ExceptionHandling"/>
  </Instruction>
  <Instruction Name="Endfilter">
    <Group Name="ExceptionHandling"/>
  </Instruction>
  <Instruction Name="Endfinally">
    <Group Name="ExceptionHandling"/>
  </Instruction>
  <!-- End Exception handling -->

  <!-- Start object model -->
  <Instruction Name="Box">
    <Group Name="ObjectModel"/>
  </Instruction>
  <Instruction Name="Unbox">
    <Group Name="ObjectModel"/>
  </Instruction>
  <Instruction Name="Unbox_Any">
    <Group Name="ObjectModel"/>
  </Instruction>
  <Instruction Name="Castclass">
    <Group Name="ObjectModel"/>
  </Instruction>
  <Instruction Name="Cpobj">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Initobj">
    <Group Name="ObjectModel"/>
  </Instruction>
  <Instruction Name="Isinst">
    <Group Name="ObjectModel"/>
  </Instruction>
  <!-- End object model -->
  
  <!-- Start comparison -->
  <Instruction Name="Ceq">
    <Group Name="Comparison"/>
  </Instruction>
  <Instruction Name="Cgt">
    <Group Name="Comparison"/>
  </Instruction>
  <Instruction Name="Cgt_Un">
    <Group Name="Comparison"/>
  </Instruction>
  <Instruction Name="Ckfinite">
    <Group Name="Comparison"/>
  </Instruction>
  <Instruction Name="Clt">
    <Group Name="Comparison"/>
  </Instruction>
  <Instruction Name="Clt_Un">
    <Group Name="Comparison"/>
  </Instruction>
  <!-- End comparison -->
  
  <!-- Start prefixes -->
  <Instruction Name="Constrained">
    <Group Name="Prefix"/>
  </Instruction>
  <Instruction Name="Leave">
    <Group Name="Prefix"/>
  </Instruction>
  <Instruction Name="Leave_S">
    <Group Name="Prefix"/>
  </Instruction>
  <Instruction Name="Unaligned">
    <Group Name="Prefix"/>
  </Instruction>
  <Instruction Name="Volatile">
    <Group Name="Prefix"/>
  </Instruction>
  <!-- End prefixes -->
  
  <!-- Start number Conversion-->
  <Instruction Name="Conv_I">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_I1">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_I2">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_I4">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_I8">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I1">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I1_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I2">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I2_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I4">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I4_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I8">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I8_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_I_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U1">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U1_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U2">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U2_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U4">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U4_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U8">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U8_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_Ovf_U_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_R4">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_R8">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_R_Un">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_U">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_U1">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_U2">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_U4">
    <Group Name="NumberConversion"/>
  </Instruction>
  <Instruction Name="Conv_U8">
    <Group Name="NumberConversion"/>
  </Instruction>
  <!-- End number Conversion-->
  
  <!-- Start low level memory access -->
  <Instruction Name="Cpblk">
    <Group Name="MemoryAccess"/>
  </Instruction>
  <Instruction Name="Initblk">
    <Group Name="MemoryAccess"/>
  </Instruction>
  <!-- End low level memory access -->
  
  <Instruction Name="Dup">
    <Group Name="StackManipulator"/>
  </Instruction>

  <!-- Start argument access -->
  <Instruction Name="Ldarg">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentLoad"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldarga">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentLoad"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldarga_S">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentLoad"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldarg_0">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentLoad"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldarg_1">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentLoad"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldarg_2">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentLoad"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldarg_3">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentLoad"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldarg_S">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentLoad"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Starg">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentStore"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Starg_S">
    <Group Name="StackManipulator"/>
    <Group Name="ArgumentAccess"/>
    <Group Name="ArgumentStore"/>
    <Group Name="Store"/>
  </Instruction>
  <!-- End argument access -->
  
  <!-- Start constants -->
  <Instruction Name="Ldc_I4">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_0">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_1">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_2">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_3">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_4">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_5">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_6">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_7">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_8">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_M1">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I4_S">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_I8">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_R4">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldc_R8">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
    <Instruction Name="Ldnull">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <!-- End constants -->

  <!-- Start array access -->
    <Instruction Name="Ldlen">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
  </Instruction>
  <Instruction Name="Ldelem">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelema">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_I">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_I1">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_I2">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_I4">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_I8">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_R4">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_R8">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_Ref">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_U1">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_U2">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldelem_U4">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Stelem">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stelem_I">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stelem_I1">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stelem_I2">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stelem_I4">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stelem_I8">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stelem_R4">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stelem_R8">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stelem_Ref">
    <Group Name="StackManipulator"/>
    <Group Name="ArrayAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <!-- End array access -->
  
  <!-- Start member access -->
  <Instruction Name="Ldfld">
    <Group Name="StackManipulator"/>
    <Group Name="ObjectModel"/>
    <Group Name="FieldAccess"/>
    <Group Name="Load"/>
  </Instruction>  
  <Instruction Name="Ldflda">
    <Group Name="StackManipulator"/>
    <Group Name="ObjectModel"/>
    <Group Name="FieldAccess"/>
    <Group Name="Load"/>
  </Instruction>  
  <Instruction Name="Ldsfld">
    <Group Name="StackManipulator"/>
    <Group Name="ObjectModel"/>
    <Group Name="FieldAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldsflda">
    <Group Name="StackManipulator"/>
    <Group Name="ObjectModel"/>
    <Group Name="FieldAccess"/>
    <Group Name="Load"/>
  </Instruction>
    <Instruction Name="Stfld">
    <Group Name="StackManipulator"/>
    <Group Name="ObjectModel"/>
    <Group Name="FieldAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stsfld">
    <Group Name="ObjectModel"/>
    <Group Name="FieldAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Ldftn">
    <Group Name="StackManipulator"/>
    <Group Name="ObjectModel"/>
    <Group Name="MethodAccess"/>
    <Group Name="Load"/>
  </Instruction>
    <!-- End member access -->
  
  <!-- Start IndirectAccess access -->  
  <Instruction Name="Ldind_I">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_I1">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_I2">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_I4">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_I8">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_R4">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_R8">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_Ref">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_U1">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_U2">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldind_U4">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Stind_I">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stind_I1">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stind_I2">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stind_I4">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stind_I8">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stind_R4">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stind_R8">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stind_Ref">
    <Group Name="StackManipulator"/>
    <Group Name="IndirectAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <!-- End IndirectAccess access -->

  <!-- Start local access -->
  <Instruction Name="Ldloc">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldloca">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldloca_S">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldloc_0">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldloc_1">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldloc_2">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldloc_3">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldloc_S">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stloc">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stloc_0">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stloc_1">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stloc_2">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stloc_3">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <Instruction Name="Stloc_S">
    <Group Name="StackManipulator"/>
    <Group Name="LocalVariableAccess"/>
    <Group Name="Store"/>
  </Instruction>
  <!-- End local access -->

  <Instruction Name="Ldobj">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Ldstr">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldtoken">
    <Group Name="StackManipulator"/>
    <Group Name="Constants"/>
    <Group Name="Load"/>
  </Instruction>
  <Instruction Name="Ldvirtftn">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Localloc">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Mkrefany">
    <Group Name=""/>
  </Instruction>
  
  <Instruction Name="Newarr">
    <Group Name="ArrayAccess"/>
    <Group Name="Allocation"/>
  </Instruction>
  <Instruction Name="Newobj">
    <Group Name="ObjectModel"/>
    <Group Name="Allocation"/>
  </Instruction>
  <Instruction Name="Stobj">
    <Group Name="ObjectModel"/>
  </Instruction>
  
  <Instruction Name="Nop">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Pop">
    <Group Name="StackManipulator"/>
  </Instruction>
  <Instruction Name="Arglist">
    <Group Name="ArgumentManipulation"/>
  </Instruction>
  
  <Instruction Name="Prefix1">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Prefix2">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Prefix3">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Prefix4">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Prefix5">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Prefix6">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Prefix7">
    <Group Name=""/>
  </Instruction>
    
  <Instruction Name="Prefixref">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Readonly">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Refanytype">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="Refanyval">
    <Group Name=""/>
  </Instruction>

  <Instruction Name="Sizeof">
    <Group Name=""/>
  </Instruction>
  
  <Instruction Name="Tailcall">
    <Group Name=""/>
  </Instruction>

  <Instruction Name="UNKNOWN1">
    <Group Name=""/>
  </Instruction>
  <Instruction Name="UNKNOWN2">
    <Group Name=""/>
  </Instruction>
</InstructionSet>


================================================
File: FuzzyEngine/SherlockEngine.csproj
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{E3A50E23-AF8A-4523-AD34-92DDB90C5DAE}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>SherlockEngine</RootNamespace>
    <AssemblyName>SherlockEngine</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Stateless, Version=2.5.62.0, Culture=neutral, PublicKeyToken=93038f0927583c9a, processorArchitecture=MSIL">
      <HintPath>..\packages\Stateless.2.5.62.0\lib\portable-net40+sl50+win+wp80+MonoAndroid10+xamarinios10+MonoTouch10\Stateless.dll</HintPath>
      <Private>True</Private>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Compiler\ASTNode.cs" />
    <Compile Include="ComparisonContext.cs" />
    <Compile Include="Compiler\SherlockCompiler.cs" />
    <Compile Include="Compiler\ILexer.cs" />
    <Compile Include="Compiler\SherlockLexer.cs" />
    <Compile Include="Compiler\SherlockParser.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="SherlockLoader.cs" />
    <Compile Include="SherlockNode.cs" />
    <Compile Include="Compiler\SherlockParserState.cs" />
    <Compile Include="Compiler\SherlockToken.cs" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="ILMetaInfo.xml">
      <SubType>Designer</SubType>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\ConfuserEx\dnlib\src\dnlib.csproj">
      <Project>{FDFC1237-143F-4919-8318-4926901F4639}</Project>
      <Name>dnlib</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>


================================================
File: FuzzyEngine/SherlockLoader.cs
================================================
ï»¿using dnlib.DotNet.Emit;
using System;
using System.IO;
using System.Reflection;
using System.Xml;

namespace SherlockEngine
{
    public class SherlockLoader
    {
        SherlockNode desc;

        public string LoadILDescription()
        {
            string result = string.Empty;
            using (Stream stream = GetType().Assembly.GetManifestResourceStream("SherlockEngine.ILMetaInfo.xml"))
            {
                using (StreamReader sr = new StreamReader(stream))
                    result = sr.ReadToEnd();
            }
            return result;
        }

        public SherlockNode LoadLanguage()
        {
            desc = new SherlockNode();
            XmlDocument langSpec = new XmlDocument();
            langSpec.LoadXml(LoadILDescription());

            XmlNode elemList = langSpec.GetElementsByTagName("InstructionSet")[0];
            Type opcodesType = typeof(OpCodes);

            foreach (XmlNode inst in elemList.ChildNodes)
            {
                if (inst.Name != "Instruction")
                    continue;

                string attrVal = inst.Attributes["Name"].Value;
                FieldInfo info = opcodesType.GetField(attrVal);

                if (info == null)
                    continue;

                OpCode currentOpcode = (OpCode)info.GetValue(null);

                foreach(XmlNode group in inst.ChildNodes)
                {
                    string groupName = group.Attributes["Name"].Value;
                    if (groupName == null || groupName.Length==0)
                        continue;

                    desc[groupName].Childs.Add(new SherlockNode(currentOpcode));
                }
            }

            SherlockNode callDescription = new SherlockNode();
            callDescription.Childs.AddRange(desc["NumberConversion"].Clone().Childs);
            callDescription.Childs.AddRange(desc["wtf"].Clone().Childs);

            callDescription.Childs[0].MaxNumber = 10;

            return desc;
        }
    }
}



================================================
File: FuzzyEngine/SherlockNode.cs
================================================
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace SherlockEngine
{
    public enum NodeType
    {
        Node,
        Leaf
    }
    public enum TestMode
    {
        InRange,
        MatchEverything,
        Fuzzy
    }

    public enum ConditionOutcome
    {
        Matched,
        NotMatched,
        Skip
    }

    /// <summary>
    /// This represent either a single 
    /// instruction or a group of instructions
    /// </summary>
    public class SherlockNode : ICloneable, IEquatable<SherlockNode>
    {
        public Func<ComparisonContext, SherlockNode, ConditionOutcome> Condition
        {
            get;set;
        }

        protected object ValueOrChilds { get; set; }
        public NodeType Type { get; protected set; }
        public TestMode Mode { get; set; }
        public OpCode Value
        {
            get
            {
                if (Type == NodeType.Leaf)
                    return (OpCode)ValueOrChilds;
                throw new InvalidCastException();
            }
            set
            {
                ValueOrChilds = value;
                Type = NodeType.Leaf;
            }
        }

        public SherlockNode Not(SherlockNode second)
        {
            SherlockNode toReturn = new SherlockNode();
            foreach (var firstChilds in GetLeafs())
            {
                bool found = false;
                foreach (var secondChilds in second.GetLeafs())
                {
                    if (firstChilds.Equals(secondChilds))
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                    toReturn.Childs.Add(firstChilds.Clone());
            }
            return toReturn;
        }

        public SherlockNode Union(SherlockNode second)
        {
            SherlockNode toReturn = Clone();
            foreach (var v in second.GetLeafs())
            {
                bool found = false;
                foreach (var vv in GetLeafs())
                {
                    if (v.Equals(vv))
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                    toReturn.Childs.Add(v.Clone());
            }
            return toReturn;
        }

        public SherlockNode Intersect(SherlockNode second)
        {
            SherlockNode toReturn = new SherlockNode();
            foreach (var firstChilds in GetLeafs())
            {
                foreach (var secondChilds in second.GetLeafs())
                {
                    if (firstChilds.Equals(secondChilds))
                    {
                        toReturn.Childs.Add(firstChilds.Clone());
                        break;
                    }
                }
            }
            return toReturn;
        }

        public List<SherlockNode> Childs
        {
            get
            {
                if (Type == NodeType.Node)
                    return (List<SherlockNode>)ValueOrChilds;
                throw new InvalidCastException();
            }
            set
            {
                ValueOrChilds = value;
                Type = NodeType.Node;
            }
        }

        bool [] Matched { get; set; }
        public uint MinNumber { get; set; }
        public uint? MaxNumber { get; set; }
        public string Name { get; set; }
        public SherlockNode()
        {
            Childs = new List<SherlockNode>();
            MinNumber = 1;
            MaxNumber = null;
            Name = "";
        }

        public SherlockNode(IEnumerable<SherlockNode> childs)
        {
            Childs = new List<SherlockNode>();
            MinNumber = 1;
            MaxNumber = null;
            Name = "";

            foreach (var v in childs)
            {
                Childs.Add(v.Clone());
            }
        }

        public SherlockNode(OpCode opcode)
        {
            Value = opcode;
            MinNumber = 1;
            MaxNumber = 1;
            Name = opcode.ToString();
        }

        public override string ToString()
        {
            return Name;
        }



        public SherlockNode this[string id]
        {
            get
            {
                if (Type == NodeType.Leaf)
                    throw new InvalidOperationException();

                var nodes = Childs.Where(x => x.Name == id);

                if (nodes.Any())
                    return nodes.Single();

                var retVal = new SherlockNode { Name = id };
                Childs.Add(retVal);
                return retVal;
            }
            set
            {
                var v = Childs.Where(x => x.Name == id).FirstOrDefault();
                if (v == null)
                {
                    v = new SherlockNode { Name = id };
                    Childs.Add(v);
                }

                v.Childs.Add(value);
            }
        }

        public IEnumerable<SherlockNode> WalkTree()
        {
            yield return this;

            if (Type == NodeType.Node)
            {
                foreach (var v in Childs)
                {
                    foreach (var vv in v.WalkTree())
                        yield return vv;
                }
            }
        }

        public IEnumerable<SherlockNode> GetLeafs()
        {
            if(Type == NodeType.Leaf)
            {
                yield return this;
                yield break;
            }

            if (Type == NodeType.Node)
            {
                foreach (var v in Childs)
                {
                    foreach (var vv in v.GetLeafs())
                        yield return vv;
                }
            }
        }

        public double FuzzyTest(ComparisonContext ctx)
        {
            int totalMatch = 0;
            int lastChildMatchedIndex = 0;
            int savedContextIndex = 0;
            bool contextChangeInProgress = false;

            bool[] currentMatched = new bool[ctx.InstructionList.Count];
            bool[] lastCurrentMatched = ctx.AlreadyMatched;
            ctx.AlreadyMatched = currentMatched;

            do
            {
                int iterationMatch = 0;

                if (ctx.CurrentIndex >= ctx.InstructionList.Count)
                    break;

                if (Type == NodeType.Leaf)
                {
                    if (ctx.InstructionList[ctx.CurrentIndex].OpCode == this.Value)
                    {
                        iterationMatch++;
                        ctx.AlreadyMatched[ctx.CurrentIndex] = true;
                    }
                }
                else // if (Type == NodeType.Node)
                {
                    bool contextChanged = false;
                    for (; lastChildMatchedIndex < Childs.Count; lastChildMatchedIndex++)
                    {
                        var v = Childs[lastChildMatchedIndex];

                        ConditionOutcome outcome = ConditionOutcome.NotMatched;

                        if (Condition != null)
                            outcome = Condition(ctx, v);
                        else
                            outcome = v.Test(ctx);

                        if (outcome == ConditionOutcome.Matched)
                        {
                            iterationMatch++;
                            
                            if (Mode == TestMode.InRange)
                                break;
                        }
                        else if (Mode == TestMode.MatchEverything)
                        {
                            if (!contextChangeInProgress)
                            {
                                savedContextIndex = ctx.CurrentIndex;
                                contextChangeInProgress = true;
                            }
                            if (ctx.CurrentIndex+1 >= ctx.InstructionList.Count)
                            {
                                ctx.CurrentIndex = savedContextIndex;
                                lastChildMatchedIndex++;
                                break;
                            }

                            ctx.CurrentIndex++;
                            contextChanged = true;
                            break;
                        }
                    }

                    if (contextChanged)
                    {
                        contextChanged = false;
                        continue;
                    }
                }

                if (iterationMatch == 0)
                    break;

                totalMatch += iterationMatch;
            } while ((Type == NodeType.Leaf || Mode == TestMode.InRange) &&
                     (!MaxNumber.HasValue || totalMatch < MaxNumber));

            // Commit eventually current matched position in the master array



            // Reason for returning NotMatched:
            // 1. If this is a Leaf:
            //    1.1: Matched number less than MinNumber
            // 2. If this is a Node:
            //    2.1: Comparison mode is InRange and matching number is outside this range
            //    2.2: Comparison mode is MatchEverything and not everything is matched

            if (((Type == NodeType.Leaf || Mode == TestMode.InRange) && totalMatch < MinNumber) ||
                (Mode == TestMode.MatchEverything && totalMatch != Childs.Count))
            {
                //return ConditionOutcome.NotMatched;
            }
            //return ConditionOutcome.Matched;
            return 0;
        }


        public ConditionOutcome Test(ComparisonContext ctx)
        {
            int totalMatch = 0;

            do
            {
                int iterationMatch = 0;

                if (ctx.CurrentIndex >= ctx.InstructionList.Count)
                    break;

                if (Type == NodeType.Leaf)
                {
                    if (ctx.InstructionList[ctx.CurrentIndex].OpCode == this.Value)
                        iterationMatch++;
                }
                else // if (Type == NodeType.Node)
                {
                    foreach (var v in Childs)
                    {
                        ConditionOutcome outcome = ConditionOutcome.NotMatched;
                        if (Condition != null)
                            outcome = Condition(ctx, v);
                        else
                            outcome = v.Test(ctx);

                        if (outcome == ConditionOutcome.Matched)
                        {
                            iterationMatch++;

                            if (Mode == TestMode.InRange)
                                break;
                        }
                        else if (Mode == TestMode.MatchEverything)
                        {
                            return ConditionOutcome.NotMatched;
                        }
                    }
                }

                if (iterationMatch == 0)
                    break;

                totalMatch += iterationMatch;
            } while ((Type == NodeType.Leaf || Mode == TestMode.InRange) &&
                     (!MaxNumber.HasValue   || totalMatch < MaxNumber));

            // Reason for returning NotMatched:
            // 1. If this is a Leaf:
            //    1.1: Matched number less than MinNumber
            // 2. If this is a Node:
            //    2.1: Comparison mode is InRange and matching number is outside this range
            //    2.2: Comparison mode is MatchEverything and not everything is matched

            if (((Type == NodeType.Leaf || Mode == TestMode.InRange) && totalMatch < MinNumber) ||
                (Mode == TestMode.MatchEverything && totalMatch != Childs.Count))
                return ConditionOutcome.NotMatched;

            return ConditionOutcome.Matched;
        }

        object ICloneable.Clone()
        {
            return Clone();
        }

        public SherlockNode Clone()
        {
            if (Type == NodeType.Leaf)
            {
                return new SherlockNode(Value)
                {
                    Name = Name,
                    MinNumber = MinNumber,
                    MaxNumber = MaxNumber,
                    Condition = Condition
                };
            }

            SherlockNode retNodeValue = new SherlockNode()
            {
                Name = Name,
                MinNumber = MinNumber,
                MaxNumber = MaxNumber,
                Condition = Condition
            };

            Childs.ForEach(x => retNodeValue.Childs.Add(x.Clone()));
            return retNodeValue;
        }

        public bool Equals(SherlockNode other)
        {
            if (!CompareProperties(other))
                return false;

            if (Type == NodeType.Leaf)
                return true;

            if (Childs.Count != other.Childs.Count)
                return false;

            for(int i=0; i<Childs.Count; ++i)
            {
                if (!other.Childs[i].Equals(Childs[i]))
                    return false;
            }
            return true;
        }

        public bool CompareProperties(SherlockNode other)
        {
            if (Type != other.Type)
                return false;
            if (this.Mode != other.Mode)
                return false;
            if (this.MinNumber != other.MinNumber)
                return false;
            if (this.MaxNumber != other.MaxNumber)
                return false;
            if (this.Value != other.Value)
                return false;
            return true;
        }
    }
}


================================================
File: FuzzyEngine/packages.config
================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Stateless" version="2.5.62.0" targetFramework="net452" />
</packages>


================================================
File: FuzzyEngine/Compiler/ASTNode.cs
================================================
ï»¿namespace SherlockEngine
{
    public enum ASTOperation
    {
        Nop,
        And,
        Or,
        Not
    }

    internal class ASTNode
    {
        public ASTNode(ASTNode parent)
        {
            Parent = parent;
            First = null;
            Second = null;
            Operation = ASTOperation.Nop;
        }

        public ASTNode(string value, ASTNode parent) : this(parent)
        {
            Value = value;
        }

        public ASTOperation Operation { get; set; }
        public ASTNode First { get; set; }
        public ASTNode Second { get; set; }
        public string Value { get; set; }
        public ASTNode Parent { get; set; }
    }
}



================================================
File: FuzzyEngine/Compiler/ILexer.cs
================================================
using System;

namespace SherlockEngine
{
    internal interface ILexer<TokenType>
    {
        bool CanRead { get; }
        TokenType Peek();
        TokenType ReadNext(bool moveIndex = false);
    }
}


================================================
File: FuzzyEngine/Compiler/SherlockCompiler.cs
================================================
ï»¿
namespace SherlockEngine
{
    public class SherlockCompiler
    {
        SherlockLoader loader = new SherlockLoader();
        SherlockParser parser = new SherlockParser();
        SherlockNode language = null;

        void InitCompiler()
        {
            language = loader.LoadLanguage();
        }
        
        public SherlockNode Compile(string toCompile)
        {
            if (language == null)
                InitCompiler();

            ASTNode rootNode = parser.Parse(toCompile);
            return ToSherlockNode(rootNode);
        }

        SherlockNode ToSherlockNode(ASTNode rootNode)
        {
            if (rootNode.Value != null)
            {
                return language[rootNode.Value];
            }

            else if (rootNode.Operation == ASTOperation.And)
            {
                SherlockNode first, second;
                first = ToSherlockNode(rootNode.First);
                second = ToSherlockNode(rootNode.Second);
                return first.Intersect(second);
            }
            else if (rootNode.Operation == ASTOperation.Not)
            {
                return language.Not(ToSherlockNode(rootNode.First));
            }
            else if (rootNode.Operation == ASTOperation.Or)
            {
                SherlockNode first, second;
                first = ToSherlockNode(rootNode.First);
                second = ToSherlockNode(rootNode.Second);
                return first.Union(second);
            }
            else if (rootNode.Operation == ASTOperation.Nop)
            {
                return ToSherlockNode(rootNode.First);
            }
            return null;
        }
    }
}


================================================
File: FuzzyEngine/Compiler/SherlockLexer.cs
================================================
ï»¿using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace SherlockEngine
{
    class SherlockLexer : ILexer<SherlockToken>
    {
        TextReader toCompile;
        bool canRead;
        string cachedLine;
        int currentColumn;

        Dictionary<Regex, SherlockTokenType> mapCharType = new Dictionary<Regex, SherlockTokenType>
        {
            {new Regex(@"^\{"), SherlockTokenType.BracesEnd},
            {new Regex(@"^\}"), SherlockTokenType.BracesEnd},
            {new Regex(@"^\["), SherlockTokenType.BracesStart },
            {new Regex(@"^\]"), SherlockTokenType.BracketEnd },
            {new Regex(@"^\("), SherlockTokenType.ParenthesesBegin },
            {new Regex(@"^\)"), SherlockTokenType.ParenthesesEnd },
            {new Regex(@"^!"), SherlockTokenType.UnaryOperator },
            {new Regex(@"^&&"), SherlockTokenType.BinaryOperator },
            {new Regex(@"^\|\|"), SherlockTokenType.BinaryOperator },
            {new Regex(@"^="), SherlockTokenType.EqualSign },
            {new Regex(@"^;"), SherlockTokenType.End },
            {new Regex(@"^[a-zA-Z0-9_]+"), SherlockTokenType.Label },
            {new Regex(@"^\$[a-zA-Z0-9_]+"), SherlockTokenType.Variable },
            {new Regex(@"[\t\s(\r\n?|\n)]+"), SherlockTokenType.Null }
        };

        public bool CanRead
        {
            get
            {
                return canRead;
            }
        }

        public void PresetProgram(TextReader toCompile)
        {
            this.toCompile = toCompile;
        }

        private void CacheNextLine()
        {
            StringBuilder sb = new StringBuilder();
            int readedChar;
            while ((readedChar = toCompile.Read()) != -1)
            {
                sb.Append((char)readedChar);
                if (readedChar == ';')
                    break;
            }
            cachedLine = sb.ToString();
        }

        public SherlockToken Peek()
        {
            return ReadNext(false);
        }
        public SherlockToken ReadNext(bool moveIndex = true)
        {
            if (cachedLine == null)
                CacheNextLine();

            if (cachedLine.Length <= currentColumn)
            {
                cachedLine = null;
                return null;
            }

            int startPosition = currentColumn;
            bool skip;

            do
            {
                string currentPart = cachedLine.Substring(currentColumn);
                skip = false;
                foreach (var v in mapCharType)
                {
                    Match vv = v.Key.Match(currentPart);
                    if (vv.Success)
                    {
                        System.Diagnostics.Debug.Assert(vv.Index == 0);
                        if (v.Value == SherlockTokenType.Null)
                        {
                            if (moveIndex)
                                currentColumn += vv.Length;
                            skip = true;
                            break;
                        }

                        if (vv.Index != 0)
                            continue;
                        if (moveIndex)
                            currentColumn += vv.Length;

                        return new SherlockToken(vv.Value, v.Value, startPosition);
                    }
                }
            } while (skip);

            return null;
        }
    }


}



================================================
File: FuzzyEngine/Compiler/SherlockParser.cs
================================================
ï»¿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace SherlockEngine
{
    public class ParsingErrorException : Exception
    {
        public ParsingErrorException(string error) : base(error)
        {
        }
    }

    class SherlockParser
    {
        [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
        class SherlockHandlerAttribute : Attribute
        {
            public SherlockTokenType Type { get; private set; }
            public SherlockHandlerAttribute(SherlockTokenType type)
            {
                Type = type;
            }
        }

        SherlockLexer lexer = new SherlockLexer();
        SherlockParserState state = new SherlockParserState();

        Dictionary<SherlockTokenType, Func<ASTNode, SherlockToken, ASTNode>> mapTokenHandler;
        ASTNode toReturn;

        [SherlockHandler(SherlockTokenType.ParenthesesEnd)]
        [SherlockHandler(SherlockTokenType.ParenthesesBegin)]
        ASTNode HandleParentheses(SherlockToken token, ASTNode currentNode)
        {
            if (token.TokenType == SherlockTokenType.ParenthesesBegin)
            {
                currentNode.First = new ASTNode(currentNode);
                return currentNode.First;
            }
            return currentNode.Parent;
        }

        [SherlockHandler(SherlockTokenType.BinaryOperator)]
        ASTNode HandleBinary(SherlockToken token, ASTNode currentNode)
        {
            GC.KeepAlive(token);
            ASTNode tempNode = GetFreeNode(currentNode);

            if (token.Value == "&&")
                tempNode.Operation = ASTOperation.And;
            else if (token.Value == "||")
                tempNode.Operation = ASTOperation.Or;

            if (tempNode.Parent == null)
                toReturn = tempNode;

            return tempNode.Second;
        }

        [SherlockHandler(SherlockTokenType.UnaryOperator)]
        ASTNode HandleUnary(SherlockToken token, ASTNode currentNode)
        {
            GC.KeepAlive(token);
            currentNode.Operation = ASTOperation.Not;
            currentNode.First = new ASTNode(currentNode);
            return currentNode.First;
        }

        [SherlockHandler(SherlockTokenType.BracketEnd)]
        [SherlockHandler(SherlockTokenType.BracketStart)]
        ASTNode HandleBracket(SherlockToken token, ASTNode currentNode)
        {
            GC.KeepAlive(token);
            return currentNode;
        }

        [SherlockHandler(SherlockTokenType.BracesEnd)]
        [SherlockHandler(SherlockTokenType.BracesStart)]
        ASTNode HandleBraces(SherlockToken token, ASTNode currentNode)
        {
            GC.KeepAlive(token);
            return currentNode;
        }

        [SherlockHandler(SherlockTokenType.Value)]
        ASTNode HandleValues(SherlockToken token, ASTNode currentNode)
        {
            currentNode.Value = token.Value;
            return currentNode;
        }

        public SherlockParser()
        {
            //File.WriteAllText(".\\DotGraph",state.StateMachine.ToDotGraph());
            Type thisType = GetType();

            try
            {
                foreach (var method in thisType.GetMethods(BindingFlags.Instance & BindingFlags.NonPublic))
                {
                    foreach (var attribute in method.CustomAttributes)
                    {
                        if (attribute.AttributeType.Name == "SherlockHandlerAttribute")
                        {
                            SherlockTokenType type = (SherlockTokenType)attribute.NamedArguments.Single().TypedValue.Value;
                            Debug.Assert(!mapTokenHandler.ContainsKey(type));

                            mapTokenHandler[(SherlockTokenType)attribute.NamedArguments.Single().TypedValue.Value]
                                = (Func<ASTNode, SherlockToken, ASTNode>)method.CreateDelegate(typeof(Func<ASTNode, SherlockToken, ASTNode>), this);
                        }
                    }
                }
            }
            catch (Exception)
            {
                Debug.Assert(false);
            }
        }

        public ASTNode Parse(string toParse)
        {
            ASTNode currentNode = new ASTNode(null);
            SherlockToken currentToken = null;

            try
            {
                lexer.PresetProgram(new StringReader(toParse));

                while ((currentToken = lexer.ReadNext()) != null)
                {
                    state.CurrentColumn = currentToken.Column;
                    if (!state.StateMachine.CanFire(currentToken.TokenType))
                        throw new InvalidOperationException();

                    state.StateMachine.Fire(currentToken.TokenType);

                    switch (currentToken.TokenType)
                    {
                        case SherlockTokenType.UnaryOperator:

                            break;
                        case SherlockTokenType.BinaryOperator:

                            break;
                        case SherlockTokenType.Label:
                            
                            break;
                    }
                }
            }
            catch (ParsingErrorException)
            {
                throw new ParsingErrorException(string.Format("Unexpected character '{0}' at column {1}.", currentToken.Value ?? "", currentToken.Column));
            }
            return toReturn;
        }

        private ASTNode GetFreeNode(ASTNode currentNode)
        {
            while (currentNode.Operation != ASTOperation.Nop || currentNode.Value != null)
            {
                if (currentNode.Parent == null)
                {
                    currentNode.Parent = new ASTNode(null);
                    currentNode.Parent.First = currentNode;
                    currentNode = currentNode.Parent;
                    break;
                }
                currentNode = currentNode.Parent;
            }
            currentNode.Second = new ASTNode(currentNode);
            return currentNode;
        }
    }
}


================================================
File: FuzzyEngine/Compiler/SherlockParserState.cs
================================================
ï»¿using Stateless;
using System;
using System.Collections.Generic;

namespace SherlockEngine
{
    /// <summary>
    /// This is a stupid state machine that define a simple grammar, more or less defined by this BNF notation:
    /// 
    /// label ::= [_a-zA-Z0-9]+
    /// and ::= "&&"
    /// or ::= "||"
    /// not ::= "!"
    /// nullchars ::= " " | "\t"
    /// parenthesis_begin ::= "("
    /// parenthesis_end ::= ")"
    /// expression ::= 
    ///     | not, expression
    ///     | label
    ///     | parenthesis_begin, expression, parenthesis_end
    ///     | expression, and|or, expression
    ///
    /// It sucks, but for the needs of this language it's okay.
    /// Soon or later I'll think at something better.
    /// </summary>
    class SherlockParserState
    {
        StateMachine<SherlockTokenType, SherlockTokenType> stateMachine = new StateMachine<SherlockTokenType, SherlockTokenType>(SherlockTokenType.JustStarted);
        private bool inBraces = false;
        private bool inExpression = false;
        private Stack<int> level = new Stack<int>();
        public int CurrentColumn { get; set; }

        internal StateMachine<SherlockTokenType, SherlockTokenType> StateMachine
        {
            get
            {
                return stateMachine;
            }
        }

        public SherlockParserState()
        {
            stateMachine.Configure(SherlockTokenType.JustStarted)
                .Permit(SherlockTokenType.UnaryOperator, SherlockTokenType.UnaryOperator)
                .Permit(SherlockTokenType.Label, SherlockTokenType.Label)
                .Permit(SherlockTokenType.ParenthesesBegin, SherlockTokenType.ParenthesesBegin);

            stateMachine.Configure(SherlockTokenType.ParenthesesBegin)
                .OnEntry(() => { level.Push(CurrentColumn); inExpression = true; })
                .PermitReentry(SherlockTokenType.ParenthesesBegin)
                .Permit(SherlockTokenType.Label, SherlockTokenType.Label)
                .Permit(SherlockTokenType.UnaryOperator, SherlockTokenType.UnaryOperator);

            stateMachine.Configure(SherlockTokenType.Label)
                .Permit(SherlockTokenType.ParenthesesEnd, SherlockTokenType.ParenthesesEnd)
                .Permit(SherlockTokenType.BinaryOperator, SherlockTokenType.BinaryOperator)
                .Permit(SherlockTokenType.BracesStart, SherlockTokenType.BracesStart)
                .Permit(SherlockTokenType.End, SherlockTokenType.End);

            stateMachine.Configure(SherlockTokenType.UnaryOperator)
                .OnEntry(() => inExpression = true)
                .Permit(SherlockTokenType.Label, SherlockTokenType.Label)
                .Permit(SherlockTokenType.ParenthesesBegin, SherlockTokenType.ParenthesesBegin);

            stateMachine.Configure(SherlockTokenType.BinaryOperator)
                .OnEntry(() => inExpression = true)
                .Permit(SherlockTokenType.Label, SherlockTokenType.Label)
                .Permit(SherlockTokenType.ParenthesesBegin, SherlockTokenType.ParenthesesBegin)
                .Permit(SherlockTokenType.UnaryOperator, SherlockTokenType.UnaryOperator);

            stateMachine.Configure(SherlockTokenType.ParenthesesEnd)
                .OnEntry(() => { if (level.Count == 0) throw new InvalidOperationException(); level.Pop(); })
                .Permit(SherlockTokenType.UnaryOperator, SherlockTokenType.UnaryOperator)
                .Permit(SherlockTokenType.BinaryOperator, SherlockTokenType.BinaryOperator)
                .Permit(SherlockTokenType.BracketStart, SherlockTokenType.BracketStart)
                .Permit(SherlockTokenType.End, SherlockTokenType.End);

            stateMachine.Configure(SherlockTokenType.BracketStart)
                .Permit(SherlockTokenType.Key, SherlockTokenType.Key);
            stateMachine.Configure(SherlockTokenType.Key)
                .Permit(SherlockTokenType.EqualSign, SherlockTokenType.EqualSign);
            stateMachine.Configure(SherlockTokenType.EqualSign)
                .Permit(SherlockTokenType.Value, SherlockTokenType.Value);
            stateMachine.Configure(SherlockTokenType.Value)
                .Permit(SherlockTokenType.Comma, SherlockTokenType.Comma)
                .Permit(SherlockTokenType.BracketEnd, SherlockTokenType.BracketEnd);
            stateMachine.Configure(SherlockTokenType.Comma)
                .Permit(SherlockTokenType.Key, SherlockTokenType.Key);
            stateMachine.Configure(SherlockTokenType.BracketEnd)
                .Permit(SherlockTokenType.End, SherlockTokenType.End);

            stateMachine.Configure(SherlockTokenType.End)
                .OnEntry(() => inExpression = false)
                .Permit(SherlockTokenType.Label, SherlockTokenType.Label)
                .Permit(SherlockTokenType.ParenthesesBegin, SherlockTokenType.ParenthesesBegin)
                .Permit(SherlockTokenType.UnaryOperator, SherlockTokenType.UnaryOperator);

            stateMachine.Configure(SherlockTokenType.BracesStart)
                .OnEntry(() => { if (inBraces || inExpression) throw new InvalidOperationException(); inBraces = true; })
                .Permit(SherlockTokenType.Label, SherlockTokenType.Label)
                .Permit(SherlockTokenType.ParenthesesBegin, SherlockTokenType.ParenthesesBegin)
                .Permit(SherlockTokenType.UnaryOperator, SherlockTokenType.UnaryOperator);

            stateMachine.Configure(SherlockTokenType.BracesEnd)
                .OnEntry(() => { if (!inBraces) throw new InvalidOperationException(); inBraces = false; })
                .Permit(SherlockTokenType.Label, SherlockTokenType.Label)
                .Permit(SherlockTokenType.UnaryOperator, SherlockTokenType.UnaryOperator)
                .Permit(SherlockTokenType.ParenthesesBegin, SherlockTokenType.ParenthesesBegin);

            stateMachine.Configure(SherlockTokenType.Null)
                .Ignore(SherlockTokenType.Label)
                .Ignore(SherlockTokenType.ParenthesesBegin)
                .Ignore(SherlockTokenType.ParenthesesEnd)
                .Ignore(SherlockTokenType.BinaryOperator)
                .Ignore(SherlockTokenType.UnaryOperator)
                .Ignore(SherlockTokenType.BracesStart)
                .Ignore(SherlockTokenType.BracesEnd)
                .Ignore(SherlockTokenType.BracketStart)
                .Ignore(SherlockTokenType.BracketEnd)
                .Ignore(SherlockTokenType.Variable)
                .Ignore(SherlockTokenType.EqualSign)
                .Ignore(SherlockTokenType.End)
                .Ignore(SherlockTokenType.Key)
                .Ignore(SherlockTokenType.Comma)
                .Ignore(SherlockTokenType.Value)
                .Ignore(SherlockTokenType.JustStarted);
        }
    }
}



================================================
File: FuzzyEngine/Compiler/SherlockToken.cs
================================================
using System;

namespace SherlockEngine
{
    internal class SherlockToken
    {
        SherlockTokenType tokenType;
        string value;
        int column;

        internal SherlockToken(string value, SherlockTokenType tokenType, int column)
        {
            this.value = value;
            this.tokenType = tokenType;
            this.column = column;
        }

        internal string Value
        {
            get
            {
                return value;
            }
        }

        internal SherlockTokenType TokenType
        {
            get
            {
                return tokenType;
            }
        }

        public int Column
        {
            get
            {
                return column;
            }
        }
        public override string ToString()
        {
            return string.Format("{0}: {1} {2}",Column,TokenType,Value );
        }
    }

    enum SherlockTokenType
    {
        Label,
        ParenthesesBegin,
        ParenthesesEnd,
        BinaryOperator,
        UnaryOperator,
        BracesStart,
        BracesEnd,
        BracketStart,
        BracketEnd,
        Variable,
        EqualSign,
        End,
        Key,
        Comma,
        Value,
        Null,
        JustStarted,
    }
}




================================================
File: FuzzyEngine/Properties/AssemblyInfo.cs
================================================
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Le informazioni generali relative a un assembly sono controllate dal seguente 
// set di attributi. Modificare i valori di questi attributi per modificare le informazioni
// associate a un assembly.
[assembly: AssemblyTitle("FuzzyEngine")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("FuzzyEngine")]
[assembly: AssemblyCopyright("Copyright Â©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Se si imposta ComVisible su false, i tipi in questo assembly non saranno visibili 
// ai componenti COM. Se Ã¨ necessario accedere a un tipo in questo assembly da 
// COM, impostare su true l'attributo ComVisible per tale tipo.
[assembly: ComVisible(false)]

// Se il progetto viene esposto a COM, il GUID seguente verrÃ  utilizzato come ID della libreria dei tipi
[assembly: Guid("e3a50e23-af8a-4523-ad34-92ddb90c5dae")]

// Le informazioni sulla versione di un assembly sono costituite dai seguenti quattro valori:
//
//      Versione principale
//      Versione secondaria 
//      Numero di build
//      Revisione
//
// Ãˆ possibile specificare tutti i valori oppure impostare valori predefiniti per i numeri relativi alla revisione e alla build 
// usando l'asterisco '*' come illustrato di seguito:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]


